{"sha": "30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBiYjBlNDRkMzg5M2IyN2M2Y2Q3NGM3MmEwNzdlNWEwZDk2YTI0NA==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2019-03-15T19:52:43Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2019-03-15T19:52:43Z"}, "message": "re PR target/87532 (bad results from vec_extract(unsigned char, foo) dependent upon function inline)\n\ngcc/ChangeLog:\n\n2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\tPR target/87532\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n\tWhen handling vec_extract, use modular arithmetic to allow\n\tconstant selectors greater than vector length.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow\n\tV1TImode vectors to have constant selector values greater than 0.\n\tUse modular arithmetic to compute vector index.\n\t(rs6000_split_vec_extract_var): Use modular arithmetic to compute\n\tindex for in-memory vectors.  Correct code generation for\n\tin-register vectors.\n\t(altivec_expand_vec_ext_builtin): Use modular arithmetic to\n\tcompute index.\n\ngcc/testsuite/ChangeLog:\n\n2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\tPR target/87532\n\t* gcc.target/powerpc/fold-vec-extract-char.p8.c: Modify expected\n\tinstruction selection.\n\t* gcc.target/powerpc/fold-vec-extract-int.p8.c: Likewise.\n\t* gcc.target/powerpc/fold-vec-extract-short.p8.c: Likewise.\n\t* gcc.target/powerpc/pr87532-mc.c: New test.\n\t* gcc.target/powerpc/pr87532.c: New test.\n\t* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.\n\t* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.\n\t* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-10a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-10b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-11a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-11b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-12a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-12b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-13a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-13b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-14a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-14b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-15a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-15b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-16a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-16b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-17a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-17b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-18a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-18b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-19a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-19b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-20a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-20b.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-9a.c: New test.\n\t* gcc.target/powerpc/vsx-builtin-9b.c: New test.\n\nFrom-SVN: r269715", "tree": {"sha": "d9bf3448990fc806c36eb62cc71cf34d4cdea326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9bf3448990fc806c36eb62cc71cf34d4cdea326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/comments", "author": null, "committer": null, "parents": [{"sha": "167727579b725adba2e262129f664db474445273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/167727579b725adba2e262129f664db474445273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/167727579b725adba2e262129f664db474445273"}], "stats": {"total": 4004, "additions": 3981, "deletions": 23}, "files": [{"sha": "55d80e563678e75e88bd7971c4eb35c5d92d15ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -1,3 +1,18 @@\n+2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\tPR target/87532\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tWhen handling vec_extract, use modular arithmetic to allow\n+\tconstant selectors greater than vector length.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow\n+\tV1TImode vectors to have constant selector values greater than 0.\n+\tUse modular arithmetic to compute vector index.\n+\t(rs6000_split_vec_extract_var): Use modular arithmetic to compute\n+\tindex for in-memory vectors.  Correct code generation for\n+\tin-register vectors.\n+\t(altivec_expand_vec_ext_builtin): Use modular arithmetic to\n+\tcompute index.\n+\n 2019-03-15  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/88534"}, {"sha": "063d4acfafb98aa8dd551834920000d4cc0639e5", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -6565,12 +6565,14 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \n \t  arg2 = fold_for_warn (arg2);\n \n-\t  /* If the second argument is an integer constant, if the value is in\n-\t     the expected range, generate the built-in code if we can.  We need\n-\t     64-bit and direct move to extract the small integer vectors.  */\n-\t  if (TREE_CODE (arg2) == INTEGER_CST\n-\t      && wi::ltu_p (wi::to_wide (arg2), nunits))\n+\t  /* If the second argument is an integer constant, generate\n+\t     the built-in code if we can.  We need 64-bit and direct\n+\t     move to extract the small integer vectors.  */\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n \t    {\n+\t      wide_int selector = wi::to_wide (arg2);\n+\t      selector = wi::umod_trunc (selector, nunits);\n+\t      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n \t      switch (mode)\n \t\t{\n \t\tdefault:"}, {"sha": "734c3860ffe04cf4aefb9004c2d1332d88949bc4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -6894,7 +6894,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \tdefault:\n \t  break;\n \tcase E_V1TImode:\n-\t  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);\n \t  emit_move_insn (target, gen_lowpart (TImode, vec));\n \t  break;\n \tcase E_V2DFmode:\n@@ -6974,18 +6973,32 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n \t}\n     }\n \n-  gcc_assert (CONST_INT_P (elt));\n-\n   /* Allocate mode-sized buffer.  */\n   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n \n   emit_move_insn (mem, vec);\n+  if (CONST_INT_P (elt))\n+    {\n+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);\n \n-  /* Add offset to field within buffer matching vector element.  */\n-  mem = adjust_address_nv (mem, inner_mode,\n-\t\t\t   INTVAL (elt) * GET_MODE_SIZE (inner_mode));\n+      /* Add offset to field within buffer matching vector element.  */\n+      mem = adjust_address_nv (mem, inner_mode,\n+\t\t\t       modulo_elt * GET_MODE_SIZE (inner_mode));\n+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n+    }\n+  else\n+    {\n+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);\n+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);\n+      rtx new_addr = gen_reg_rtx (Pmode);\n \n-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));\n+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);\n+      if (ele_size > 1)\n+\telt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));\n+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);\n+      new_addr = change_address (mem, inner_mode, new_addr);\n+      emit_move_insn (target, new_addr);\n+    }\n }\n \n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n@@ -7165,6 +7178,10 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n      systems.  */\n   if (MEM_P (src))\n     {\n+      int num_elements = GET_MODE_NUNITS (mode);\n+      rtx num_ele_m1 = GEN_INT (num_elements - 1);\n+\n+      emit_insn (gen_anddi3 (element, element, num_ele_m1));\n       gcc_assert (REG_P (tmp_gpr));\n       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,\n \t\t\t\t\t\t       tmp_gpr, scalar_mode));\n@@ -7173,7 +7190,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \n   else if (REG_P (src) || SUBREG_P (src))\n     {\n-      int bit_shift = byte_shift + 3;\n+      int num_elements = GET_MODE_NUNITS (mode);\n+      int bits_in_element = mode_to_bits (GET_MODE_INNER (mode));\n+      int bit_shift = 7 - exact_log2 (num_elements);\n       rtx element2;\n       unsigned int dest_regno = reg_or_subregno (dest);\n       unsigned int src_regno = reg_or_subregno (src);\n@@ -7249,7 +7268,7 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \t{\n \t  if (!BYTES_BIG_ENDIAN)\n \t    {\n-\t      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);\n+\t      rtx num_ele_m1 = GEN_INT (num_elements - 1);\n \n \t      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));\n \t      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));\n@@ -7307,8 +7326,8 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n \t    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,\n \t\t\t\t\t  tmp_altivec));\n \t    emit_move_insn (tmp_gpr_di, tmp_altivec_di);\n-\t    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,\n-\t\t\t\t    GEN_INT (64 - (8 * scalar_size))));\n+\t    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,\n+\t\t\t\t    GEN_INT (64 - bits_in_element)));\n \t    return;\n \t  }\n \n@@ -14725,9 +14744,17 @@ altivec_expand_vec_ext_builtin (tree exp, rtx target)\n   op0 = expand_normal (arg0);\n   op1 = expand_normal (arg1);\n \n-  /* Call get_element_number to validate arg1 if it is a constant.  */\n   if (TREE_CODE (arg1) == INTEGER_CST)\n-    (void) get_element_number (TREE_TYPE (arg0), arg1);\n+    {\n+      unsigned HOST_WIDE_INT elt;\n+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));\n+      unsigned int truncated_selector;\n+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)\n+\t returns low-order bits of INTEGER_CST for modulo indexing.  */\n+      elt = TREE_INT_CST_LOW (arg1);\n+      truncated_selector = elt % size;\n+      op1 = GEN_INT (truncated_selector);\n+    }\n \n   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));\n   mode0 = TYPE_MODE (TREE_TYPE (arg0));"}, {"sha": "7acb52b1ffdeda7546e3b72c1f44c2ad8e4251ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -1,3 +1,40 @@\n+2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\tPR target/87532\n+\t* gcc.target/powerpc/fold-vec-extract-char.p8.c: Modify expected\n+\tinstruction selection.\n+\t* gcc.target/powerpc/fold-vec-extract-int.p8.c: Likewise.\n+\t* gcc.target/powerpc/fold-vec-extract-short.p8.c: Likewise.\n+\t* gcc.target/powerpc/pr87532-mc.c: New test.\n+\t* gcc.target/powerpc/pr87532.c: New test.\n+\t* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.\n+\t* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.\n+\t* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-10a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-10b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-11a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-11b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-12a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-12b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-13a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-13b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-14a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-14b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-15a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-15b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-16a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-16b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-17a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-17b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-18a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-18b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-19a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-19b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-20a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-20b.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-9a.c: New test.\n+\t* gcc.target/powerpc/vsx-builtin-9b.c: New test.\n+\n 2019-03-15  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/88534"}, {"sha": "81a7a0239f1796ecb91579aedd521e1503b6d421", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-char.p8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -18,7 +18,7 @@\n /* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mvslo\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 6 { target lp64 } } } */\n-/* { dg-final { scan-assembler-times {\\msradi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\msrdi\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times \"extsb\" 2 } } */\n /* { dg-final { scan-assembler-times {\\mvspltb\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mrlwinm\\M} 2 { target lp64} } } */"}, {"sha": "637cdce318a3c17902108c15646be50fb8434b76", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-int.p8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -21,7 +21,7 @@\n /* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mvslo\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 3 { target lp64 } } } */\n-/* { dg-final { scan-assembler-times {\\msradi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\msrdi\\M} 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times {\\mextsw\\M} 2 { target lp64 } } } */\n \n "}, {"sha": "e9dd1131691709b6bf8cc6b07f98705af04660c8", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-short.p8.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -6,9 +6,9 @@\n /* { dg-options \"-mdejagnu-cpu=power8 -O2\" } */\n \n // six tests total. Targeting P8, both LE and BE.\n-// p8 (le) variable offset: rldicl, subfic, sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, *extsh\n+// p8 (le) variable offset: rldicl, subfic, sldi, mtvsrd, xxpermdi, vslo, mfvsrd, srdi, *extsh\n // p8 (le) const offset:                          mtvsrd,                                *extsh/rlwinm\n-// p8 (be) var offset:                      sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, *extsh\n+// p8 (be) var offset:                      sldi, mtvsrd, xxpermdi, vslo, mfvsrd, srdi, *extsh\n // p8 (be) const offset:    vsplth,               mfvsrd,                                *extsh/rlwinm\n \n // * - each of the above will have an extsh if the argument is signed.\n@@ -22,7 +22,7 @@\n /* { dg-final { scan-assembler-times \"xxpermdi\" 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times \"vslo\" 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times \"mfvsrd\" 6 { target lp64 } } } */\n-/* { dg-final { scan-assembler-times \"sradi\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"srdi\" 3 { target lp64 } } } */\n /* { dg-final { scan-assembler-times \"extsh\" 2 { target lp64 } } } */\n /* { dg-final { scan-assembler-times \"rlwinm\" 2 { target lp64 } } } */\n "}, {"sha": "400df7f1b7740e98c5d81f36b1f39516a6331219", "filename": "gcc/testsuite/gcc.target/powerpc/pr87532-mc.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532-mc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532-mc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532-mc.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,258 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O2\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <altivec.h>\n+\n+#include <stdio.h>\n+\n+static vector unsigned __int128\n+deoptimize_uint128 (vector unsigned __int128  a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned long long int\n+deoptimize_ulong (vector unsigned long long int a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned int\n+deoptimize_uint (vector unsigned int a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned char\n+deoptimize_uchar (vector unsigned char a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector unsigned short\n+deoptimize_ushort (vector unsigned short a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+__attribute ((noinline)) unsigned __int128\n+get_auto_n_uint128 (vector unsigned __int128 a, int n)\n+{\n+  return __builtin_vec_extract (a, n);\n+}\n+\n+__attribute ((noinline)) unsigned long long int\n+get_auto_n_ulong (vector unsigned long long int a, int n)\n+{\n+  return __builtin_vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned int get_auto_n_uint (vector unsigned int a, int n)\n+{\n+  return __builtin_vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned char get_auto_n_uchar (vector unsigned char a, int n)\n+{\n+  return __builtin_vec_extract (a, n);\n+}\n+\n+__attribute ((noinline))\n+unsigned short get_auto_n_ushort (vector unsigned short a, int n)\n+{\n+  return __builtin_vec_extract (a, n);\n+}\n+\n+\n+int check_uint128_element (int i, unsigned __int128 entry)\n+{\n+  printf (\"checking uint128 entry at index %d\\n\", i);\n+\n+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)\n+\t\t    | 0x0706050403020100ULL));\n+}\n+\n+int check_ulong_element (int i, unsigned long long int entry)\n+{\n+  printf (\"checking ulong entry 0x%llx at index %d\\n\", entry, i);\n+\n+  switch (i % 2)\n+    {\n+      case 0: return (entry == 0x9999901010ULL);\n+      case 1: return (entry == 0x7777733333ULL);\n+      default:\n+\treturn 0;\n+    }\n+}\n+\n+int check_uint_element (int i, unsigned int entry)\n+{\n+  printf (\"checking uint entry 0x%x at index %d\\n\", entry, i);\n+\n+  switch (i % 4)\n+    {\n+    case 0: return (entry == 0x99999);\n+    case 1: return (entry == 0x01010);\n+    case 2: return (entry == 0x77777);\n+    case 3: return (entry == 0x33333);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+int check_uchar_element (int i, unsigned char entry)\n+{\n+  printf (\"checking uchar entry 0x%x at index %d\\n\", entry, i);\n+  switch (i % 16)\n+    {\n+    case 0: return (entry == 0x90);\n+    case 1: return (entry == 0x80);\n+    case 2: return (entry == 0x70);\n+    case 3: return (entry == 0x60);\n+    case 4: return (entry == 0x50);\n+    case 5: return (entry == 0x40);\n+    case 6: return (entry == 0x30);\n+    case 7: return (entry == 0x20);\n+    case 8: return (entry == 0x10);\n+    case 9: return (entry == 0xf0);\n+    case 10: return (entry == 0xe0);\n+    case 11: return (entry == 0xd0);\n+    case 12: return (entry == 0xc0);\n+    case 13: return (entry == 0xb0);\n+    case 14: return (entry == 0xa0);\n+    case 15: return (entry == 0xff);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+int check_ushort_element (int i, unsigned short entry)\n+{\n+  printf (\"checking ushort entry 0x%x at index %d\\n\", entry, i);\n+  switch (i % 8)\n+    {\n+    case 0: return (entry == 0x9988);\n+    case 1: return (entry == 0x8877);\n+    case 2: return (entry == 0x7766);\n+    case 3: return (entry == 0x6655);\n+    case 4: return (entry == 0x5544);\n+    case 5: return (entry == 0x4433);\n+    case 6: return (entry == 0x3322);\n+    case 7: return (entry == 0x2211);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+void do_auto_uint128 ( vector unsigned __int128 a )\n+{\n+  int i;\n+  unsigned __int128 c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uint128 (a,i);\n+      if (!check_uint128_element (i, c)) abort ();\n+    }\n+ }\n+\n+void do_auto_ulong ( vector unsigned long long int a )\n+{\n+  int i;\n+  unsigned long long int c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_ulong (a,i);\n+      if (!check_ulong_element (i, c)) abort ();\n+    }\n+ }\n+\n+void do_auto_uint ( vector unsigned int a )\n+{\n+  int i;\n+  unsigned int c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uint (a,i);\n+      if (!check_uint_element (i, c)) abort ();\n+    }\n+ }\n+\n+void do_auto_ushort ( vector unsigned short a )\n+{\n+  int i;\n+  unsigned short c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_ushort (a,i);\n+      if (!check_ushort_element (i, c)) abort ();\n+    }\n+}\n+\n+void do_auto_uchar ( vector unsigned char a )\n+{\n+  int i;\n+  unsigned char c;\n+  for (i = 0; i < 32; i += 3)\n+    {\n+      c = get_auto_n_uchar (a,i);\n+      if (!check_uchar_element (i, c)) abort ();\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+\n+  vector unsigned __int128 u = {\n+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)\n+     | 0x0706050403020100ULL) };\n+  vector unsigned __int128 du;\n+\n+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };\n+  vector unsigned long long int dv;\n+\n+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };\n+  vector unsigned int dx;\n+\n+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,\n+\t\t\t     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };\n+  vector unsigned char dy;\n+\n+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,\n+\t\t\t      0x5544, 0x4433, 0x3322, 0x2211 };\n+  vector unsigned short dz;\n+\n+  do_auto_uint128 (u);\n+  do_auto_ulong (v);\n+  do_auto_uint (x);\n+  do_auto_uchar (y);\n+  do_auto_ushort (z);\n+\n+  du = deoptimize_uint128 (u);\n+  dv = deoptimize_ulong (v);\n+  dx = deoptimize_uint (x);\n+  dy = deoptimize_uchar (y);\n+  dz = deoptimize_ushort (z);\n+\n+  do_auto_uint128 (du);\n+  do_auto_ulong (dv);\n+  do_auto_uint (dx);\n+  do_auto_uchar (dy);\n+  do_auto_ushort (dz);\n+  return 0;\n+}"}, {"sha": "4b07f07258f3256d0e688461049d137e43c7d9b5", "filename": "gcc/testsuite/gcc.target/powerpc/pr87532.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87532.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <altivec.h>\n+#include <stdio.h>\n+\n+static void\n+check (unsigned char, unsigned char) __attribute__((__noinline__));\n+\n+static __attribute__((altivec(vector__))) unsigned char\n+deoptimize (__attribute__((altivec(vector__))) unsigned char)\n+__attribute__((__noinline__));\n+\n+static __attribute__((altivec(vector__))) unsigned char\n+deoptimize (__attribute__((altivec(vector__))) unsigned char a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+// Toggle this attribute inline/noinline to see pass/fail.\n+// fails with the noinline attribute applied.\n+__attribute__ ((__noinline__))\n+unsigned char\n+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)\n+{\n+  return (unsigned char) __builtin_vec_extract (a, n);\n+}\n+\n+void\n+do_auto (__attribute__((altivec(vector__))) unsigned char a)\n+{\n+  size_t i;\n+  for (i = 1; i < 3 ; i++)\n+  {\n+    do\n+      {\n+\tprintf (\"get_auto_n (a, %d) produces 0x0%x\\n\",\n+\t\ti, (int) get_auto_n (a, i));\n+\n+\tif ((int) get_auto_n (a,i) > 250) abort();\n+      } while (0);\n+  }\n+}\n+\n+int\n+main (void)\n+{\n+  size_t i;\n+  __attribute__((altivec(vector__))) unsigned char x =\n+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };\n+  __attribute__((altivec(vector__))) unsigned char a;\n+\n+  printf (\" first elements of x are: %d %d %d %d %d\\n\",\n+\t  x[0], x[1], x[2], x[3], x[4]);\n+\n+  a = deoptimize (x);\n+\n+  printf (\" after deoptimization, first elements of a are: %d %d %d %d %d\\n\",\n+\t  a[0], a[1], a[2], a[3], a[4]);\n+\n+  do_auto (a);\n+\n+  return 0;\n+}"}, {"sha": "d1157599ee7c66ef95a920ad68f46e947d159687", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2.h?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,253 @@\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <altivec.h>\n+\n+#ifndef RTYPE\n+#define RTYPE TYPE\n+#endif\n+\n+#ifdef DO_TRACE\n+#include <stdio.h>\n+\n+#define TRACE(STRING, NUM)\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (stderr, \"%s: %2d\\n\", STRING, (int) NUM);\t\t\t\\\n+    fflush (stderr);\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#ifndef FAIL_FORMAT\n+#define FAIL_FORMAT \"%ld\"\n+#define FAIL_CAST(X) ((long)(X))\n+#endif\n+\n+#define FAIL(EXP, GOT)\t\t\t\t\t\t\t \\\n+do\t\t\t\t\t\t\t\t\t \\\n+  {\t\t\t\t\t\t\t\t\t \\\n+    fprintf (stderr, \"Expected: \" FAIL_FORMAT \", got \" FAIL_FORMAT \"\\n\", \\\n+\t     FAIL_CAST (EXP), FAIL_CAST (GOT));\t\t\t\t \\\n+    fflush (stderr);\t\t\t\t\t\t\t \\\n+    abort ();\t\t\t\t\t\t\t\t \\\n+  }\t\t\t\t\t\t\t\t\t \\\n+while (0)\n+\n+#else\n+#define TRACE(STRING, NUM)\n+#define FAIL(EXP, GOT) abort ()\n+#endif\n+\n+static void\n+check (RTYPE, RTYPE) __attribute__((__noinline__));\n+\n+static vector TYPE\n+deoptimize (vector TYPE) __attribute__((__noinline__));\n+\n+static vector TYPE\n+*deoptimize_ptr (vector TYPE *)\t__attribute__((__noinline__));\n+\n+static void\n+check (RTYPE expected, RTYPE got)\n+{\n+  if (expected != got)\n+    FAIL (expected, got);\n+}\n+\n+static vector TYPE\n+deoptimize (vector TYPE a)\n+{\n+  __asm__ (\" # %x0\" : \"+v\" (a));\n+  return a;\n+}\n+\n+static vector TYPE *\n+deoptimize_ptr (vector TYPE *p)\n+{\n+  __asm__ (\" # %0\" : \"+r\" (p));\n+  return p;\n+}\n+\n+\f\n+RTYPE\n+get_auto_0 (vector TYPE a)\n+{\n+  TRACE (\"get_auto_\", 0);\n+  return (RTYPE) vec_extract (a, 0);\n+}\n+\n+RTYPE\n+get_auto_1 (vector TYPE a)\n+{\n+  TRACE (\"get_auto_\", 1);\n+  return (RTYPE) vec_extract (a, 1);\n+}\n+\n+#if ELEMENTS >= 4\n+RTYPE\n+get_auto_2 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 2);\n+}\n+\n+RTYPE\n+get_auto_3 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 3);\n+}\n+\n+#if ELEMENTS >= 8\n+RTYPE\n+get_auto_4 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 4);\n+}\n+\n+RTYPE\n+get_auto_5 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 5);\n+}\n+\n+RTYPE\n+get_auto_6 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 6);\n+}\n+\n+RTYPE\n+get_auto_7 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 7);\n+}\n+\n+#if ELEMENTS >= 16\n+RTYPE\n+get_auto_8 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 8);\n+}\n+\n+RTYPE\n+get_auto_9 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 9);\n+}\n+\n+RTYPE\n+get_auto_10 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 10);\n+}\n+\n+RTYPE\n+get_auto_11 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 11);\n+}\n+\n+RTYPE\n+get_auto_12 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 12);\n+}\n+\n+RTYPE\n+get_auto_13 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 13);\n+}\n+\n+RTYPE\n+get_auto_14 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 14);\n+}\n+\n+RTYPE\n+get_auto_15 (vector TYPE a)\n+{\n+  return (RTYPE) vec_extract (a, 15);\n+}\n+\n+#endif\n+#endif\n+#endif\n+\n+\f\n+/* Tests for the normal case of vec_extract where the vector is in a register\n+   and returning the result in a register as a return value.  */\n+#ifdef DISABLE_INLINE_OF_GET_AUTO_N\n+__attribute__ ((__noinline__))\n+#else\n+/* gcc issues warning: always_inline function might not be inlinable\n+\n+   __attribute__ ((__always_inline__))\n+*/\n+#endif\n+RTYPE\n+get_auto_n (vector TYPE a, ssize_t n)\n+{\n+  return (RTYPE) vec_extract (a, n);\n+}\n+\n+typedef RTYPE (*auto_func_type) (vector TYPE);\n+\n+static auto_func_type get_auto_const[] = {\n+  get_auto_0,\n+  get_auto_1,\n+#if ELEMENTS >= 4\n+  get_auto_2,\n+  get_auto_3,\n+#if ELEMENTS >= 8\n+  get_auto_4,\n+  get_auto_5,\n+  get_auto_6,\n+  get_auto_7,\n+#if ELEMENTS >= 16\n+  get_auto_8,\n+  get_auto_9,\n+  get_auto_10,\n+  get_auto_11,\n+  get_auto_12,\n+  get_auto_13,\n+  get_auto_14,\n+  get_auto_15,\n+#endif\n+#endif\n+#endif\n+};\n+\n+extern void do_auto (vector TYPE a) __attribute__((__noinline__));\n+\n+void\n+do_auto (vector TYPE a)\n+{\n+  size_t i;\n+\n+  for (i = 1; i < 40; i += 3)\n+    {\n+      TRACE (\"do_auto, i: \", i);\n+      TRACE (\"  get_auto_const[i] returns: \",\n+\t     (*get_auto_const [i % ELEMENTS]) (a));\n+      TRACE (\"  get_auto_n returns\", get_auto_n (a, i));\n+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));\n+    }\n+}\n+\n+\n+\f\n+/* Main program to test all of the possibilities.  */\n+int\n+main (void)\n+{\n+  size_t i;\n+  vector TYPE x = INITIAL;\n+  vector TYPE *p, *p2, a, y;\n+  vector TYPE z[2];\n+\n+  a = deoptimize (x);\n+\n+  do_auto (a);\n+\n+  return 0;\n+}"}, {"sha": "05082b71c2063030ac7af38ef9330dce218d8ab3", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned char\n+/* ELEMENTS is number of elements in a vector of TYPE.  */\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }\n+\n+#define DO_TRACE\n+#define DISABLE_INLINE_OF_GET_AUTO_N\n+\n+#include \"vec-extract-v16qiu-v2.h\""}, {"sha": "87a3aa4a8e5f6687d3d3fc6d2141f40bb3a8d59f", "filename": "gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-extract-v16qiu-v2b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+#define TYPE unsigned char\n+/* ELEMENTS is number of elements in a vector of TYPE.  */\n+#define ELEMENTS 16\n+#define INITIAL \\\n+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }\n+\n+#define DO_TRACE\n+#undef DISABLE_INLINE_OF_GET_AUTO_N\n+\n+#include \"vec-extract-v16qiu-v2.h\""}, {"sha": "e8516de66ff972654a2cad18832e316e8b626ec3", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+short s3 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 3);\n+}\n+\n+short s7 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 7);\n+}\n+\n+short s21 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 21);\n+}\n+\n+short s30 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+short ms3 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 3);\n+}\n+\n+short ms7 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 7);\n+}\n+\n+short ms21 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 21);\n+}\n+\n+short ms30 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+short ci (vector short v, int i)\n+{\n+  return __builtin_vec_ext_v8hi (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+short mci (vector short *vp, int i)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, i);\n+}\n+\n+\n+int main (int argc, short *argv[]) {\n+  vector short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  short s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s7 (sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms7 (&sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "6300b0e22304e025216dc426d027706099c36a96", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-10b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+short s3 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 3);\n+}\n+\n+short s7 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 7);\n+}\n+\n+short s21 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 21);\n+}\n+\n+short s30 (vector short v)\n+{\n+  return __builtin_vec_ext_v8hi (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+short ms3 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 3);\n+}\n+\n+short ms7 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 7);\n+}\n+\n+short ms21 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 21);\n+}\n+\n+short ms30 (vector short *vp)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+short ci (vector short v, int i)\n+{\n+  return __builtin_vec_ext_v8hi (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+short mci (vector short *vp, int i)\n+{\n+  return __builtin_vec_ext_v8hi (*vp, i);\n+}\n+\n+\n+int main (int argc, short *argv[]) {\n+  vector short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  short s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s7 (sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms7 (&sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e962e121bd019b0c731a8dc3c495cbf4b2248a45", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+int s3 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 3);\n+}\n+\n+int s1 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 1);\n+}\n+\n+int s21 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 21);\n+}\n+\n+int s30 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+int ms3 (vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 3);\n+}\n+\n+int ms1(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 1);\n+}\n+\n+int ms21(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 21);\n+}\n+\n+int ms30(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+int ci (vector int v, int i)\n+{\n+  return __builtin_vec_ext_v4si (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+int mci(vector int *vp, int i)\n+{\n+  return __builtin_vec_ext_v4si (*vp, i);\n+}\n+\n+\n+int main (int argc, int *argv[]) {\n+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  int s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s1 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms1 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "fafdd10f842495f70640c918d3f2ffb59ebb6215", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-11b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+int s3 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 3);\n+}\n+\n+int s1 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 1);\n+}\n+\n+int s21 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 21);\n+}\n+\n+int s30 (vector int v)\n+{\n+  return __builtin_vec_ext_v4si (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+int ms3 (vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 3);\n+}\n+\n+int ms1(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 1);\n+}\n+\n+int ms21(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 21);\n+}\n+\n+int ms30(vector int *vp)\n+{\n+  return __builtin_vec_ext_v4si (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+int ci (vector int v, int i)\n+{\n+  return __builtin_vec_ext_v4si (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+int mci(vector int *vp, int i)\n+{\n+  return __builtin_vec_ext_v4si (*vp, i);\n+}\n+\n+\n+int main (int argc, int *argv[]) {\n+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  int s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s1 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms1 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "a79bc7f5384b08bc70c740434b3b2c72db3a1169", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+long long int e0 (vector long long int v)\n+{\n+  return __builtin_vec_ext_v2di (v, 0);\n+}\n+\n+long long int e3 (vector long long int v)\n+{\n+  return __builtin_vec_ext_v2di (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+long long int me0 (vector long long int *vp)\n+{\n+  return __builtin_vec_ext_v2di (*vp, 0);\n+}\n+\n+long long int me3 (vector long long int *vp)\n+{\n+  return __builtin_vec_ext_v2di (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+long long int ei (vector long long int v, int i)\n+{\n+  return __builtin_vec_ext_v2di (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+long long int mei (vector long long int *vp, int i)\n+{\n+  return __builtin_vec_ext_v2di (*vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector long long int dv = { CONST0, CONST1 };\n+  long long int d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "2b63624f8b120b8a32a80227a189b443d39e1f04", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-12b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+long long int e0 (vector long long int v)\n+{\n+  return __builtin_vec_ext_v2di (v, 0);\n+}\n+\n+long long int e3 (vector long long int v)\n+{\n+  return __builtin_vec_ext_v2di (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+long long int me0 (vector long long int *vp)\n+{\n+  return __builtin_vec_ext_v2di (*vp, 0);\n+}\n+\n+long long int me3 (vector long long int *vp)\n+{\n+  return __builtin_vec_ext_v2di (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+long long int ei (vector long long int v, int i)\n+{\n+  return __builtin_vec_ext_v2di (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+long long int mei (vector long long int *vp, int i)\n+{\n+  return __builtin_vec_ext_v2di (*vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector long long int dv = { CONST0, CONST1 };\n+  long long int d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "907bcce923660bc76085fcae8d567df5319dfdfc", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+/* Define this after PR89424 is addressed.  */\n+#undef PR89424\n+\n+/* Define this after PR89626 is addressed.  */\n+#undef PR89626\n+\n+#ifdef PR89626\n+#define SIGNED\n+#else\n+#define SIGNED signed\n+#endif\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((SIGNED __int128) 31415926539) << 60)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+SIGNED __int128 e0 (vector SIGNED __int128 v)\n+{\n+  return __builtin_vec_ext_v1ti (v, 0);\n+}\n+\n+SIGNED __int128 e3 (vector SIGNED __int128 v)\n+{\n+  return __builtin_vec_ext_v1ti (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+SIGNED __int128 me0 (vector SIGNED __int128 *vp)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, 0);\n+}\n+\n+SIGNED __int128 me3 (vector SIGNED __int128 *vp)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+#ifdef PR89424\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+SIGNED __int128 ei (vector SIGNED __int128 v, int i)\n+{\n+  return __builtin_vec_ext_v1ti (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, i);\n+}\n+#endif\n+\n+int main (int argc, char *argv[]) {\n+  vector SIGNED __int128 dv = { CONST0 };\n+  SIGNED __int128 d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+#ifdef PR89424\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "e1d791ded4f3a8aec015667af7cb949be59d076b", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-13b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+/* Define this after PR89424 is addressed.  */\n+#undef PR89424\n+\n+/* Define this after PR89626 is addressed.  */\n+#undef PR89626\n+\n+#ifdef PR89626\n+#define SIGNED\n+#else\n+#define SIGNED signed\n+#endif\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((SIGNED __int128) 31415926539) << 60)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+SIGNED __int128 e0 (vector SIGNED __int128 v)\n+{\n+  return __builtin_vec_ext_v1ti (v, 0);\n+}\n+\n+SIGNED __int128 e3 (vector SIGNED __int128 v)\n+{\n+  return __builtin_vec_ext_v1ti (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+SIGNED __int128 me0 (vector SIGNED __int128 *vp)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, 0);\n+}\n+\n+SIGNED __int128 me3 (vector SIGNED __int128 *vp)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+#ifdef PR89424\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+SIGNED __int128 ei (vector SIGNED __int128 v, int i)\n+{\n+  return __builtin_vec_ext_v1ti (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)\n+{\n+  return __builtin_vec_ext_v1ti (*vp, i);\n+}\n+#endif\n+\n+int main (int argc, char *argv[]) {\n+  vector SIGNED __int128 dv = { CONST0 };\n+  SIGNED __int128 d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+#ifdef PR89424\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "8eb8eb63fbebeea8a80ea110ac87c694512693a3", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t((float) (3.1415926539))\n+#define CONST1\t\t((float) (3.1415926539 * 2))\n+#define CONST2\t\t((float) (3.1415926539 * 3))\n+#define CONST3\t\t((float) (3.1415926539 * 4))\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }\n+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }\n+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }\n+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }\n+\n+/* Test for vector residing in memory.  */\n+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }\n+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }\n+\n+float me13(vector float *vp)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, 13);\n+}\n+\n+float me15(vector float *vp)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, 15);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+float ei(vector float v, int i)\n+{\n+  return __builtin_vec_ext_v4sf (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+float mei(vector float *vp, int i)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };\n+  float d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e1 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = e7 (dv);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = e8 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me1 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me13 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me15 (&dv);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST2)\n+    abort ();\n+\n+  d = ei (dv, 11);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = ei (dv, 17);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 15);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = mei (&dv, 6);\n+  if (d != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "84bc8a2ae71cd965779adb0baf09ff3ceb448780", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-14b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t((float) (3.1415926539))\n+#define CONST1\t\t((float) (3.1415926539 * 2))\n+#define CONST2\t\t((float) (3.1415926539 * 3))\n+#define CONST3\t\t((float) (3.1415926539 * 4))\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }\n+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }\n+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }\n+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }\n+\n+/* Test for vector residing in memory.  */\n+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }\n+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }\n+\n+float me13(vector float *vp)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, 13);\n+}\n+\n+float me15(vector float *vp)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, 15);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+float ei(vector float v, int i)\n+{\n+  return __builtin_vec_ext_v4sf (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+float mei(vector float *vp, int i)\n+{\n+  return __builtin_vec_ext_v4sf (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };\n+  float d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e1 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = e7 (dv);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = e8 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me1 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me13 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me15 (&dv);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST2)\n+    abort ();\n+\n+  d = ei (dv, 11);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = ei (dv, 17);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 15);\n+  if (d != CONST3)\n+    abort ();\n+\n+  d = mei (&dv, 6);\n+  if (d != CONST2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b8bff5c3f56fc704e53dddbb65851277630b5ee1", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,113 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(3.1415926539)\n+#define CONST1\t\t(3.1415926539 * 2)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }\n+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }\n+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }\n+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }\n+\n+/* Test for vector residing in memory.  */\n+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }\n+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }\n+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }\n+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }\n+\n+/* Test for variable selector and vector residing in memory.  */\n+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector double dv;\n+  double d;\n+  dv[0] = CONST0;\n+  dv[1] = CONST1;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e1 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = e2 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me1 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me2 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "402cde7b1c3ab3bdb53ab54013568b72e36394bd", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-15b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,113 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(3.1415926539)\n+#define CONST1\t\t(3.1415926539 * 2)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }\n+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }\n+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }\n+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }\n+\n+/* Test for vector residing in memory.  */\n+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }\n+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }\n+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }\n+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }\n+\n+/* Test for variable selector and vector residing in memory.  */\n+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector double dv;\n+  double d;\n+  dv[0] = CONST0;\n+  dv[1] = CONST1;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e1 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = e2 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me1 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me2 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "465296a820a83b5c2b9b5f12ce46520db887b3b2", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,165 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned char c0 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned char c9 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 9);\n+}\n+\n+unsigned char c21 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned char c30 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned char mc0 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned char mc9 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 9);\n+}\n+\n+unsigned char mc21 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned char mc30 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned char ci (vector unsigned char v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned char mci (vector unsigned char *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  unsigned char c;\n+\n+  c = c0 (cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = c9 (cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = c21 (cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = c30 (cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = mc0 (&cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = mc9 (&cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mc21 (&cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mc30 (&cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = ci (cv, 8);\n+  if (c != CONST8)\n+    abort ();\n+\n+  c = ci (cv, 13);\n+  if (c != CONSTD)\n+    abort ();\n+\n+  c = ci (cv, 23);\n+  if (c != CONST7)\n+    abort ();\n+\n+  c = ci (cv, 31);\n+  if (c != CONSTF)\n+    abort ();\n+\n+  c = mci (&cv, 5);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mci (&cv, 12);\n+  if (c != CONSTC)\n+    abort ();\n+\n+  c = mci (&cv, 25);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mci (&cv, 16);\n+  if (c != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b646fb12dabbbd6a674572db2b6cf998aa867d6f", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-16b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,165 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned char c0 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned char c9 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 9);\n+}\n+\n+unsigned char c21 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned char c30 (vector unsigned char v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned char mc0 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned char mc9 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 9);\n+}\n+\n+unsigned char mc21 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned char mc30 (vector unsigned char *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned char ci (vector unsigned char v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned char mci (vector unsigned char *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  unsigned char c;\n+\n+  c = c0 (cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = c9 (cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = c21 (cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = c30 (cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = mc0 (&cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = mc9 (&cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mc21 (&cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mc30 (&cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = ci (cv, 8);\n+  if (c != CONST8)\n+    abort ();\n+\n+  c = ci (cv, 13);\n+  if (c != CONSTD)\n+    abort ();\n+\n+  c = ci (cv, 23);\n+  if (c != CONST7)\n+    abort ();\n+\n+  c = ci (cv, 31);\n+  if (c != CONSTF)\n+    abort ();\n+\n+  c = mci (&cv, 5);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mci (&cv, 12);\n+  if (c != CONSTC)\n+    abort ();\n+\n+  c = mci (&cv, 25);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mci (&cv, 16);\n+  if (c != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "afb69342a31bf5118c54e08048bc7a2b8e7ae9b6", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned short s3 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+unsigned short s7 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 7);\n+}\n+\n+unsigned short s21 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned short s30 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned short ms3 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+unsigned short ms7 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 7);\n+}\n+\n+unsigned short ms21 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned short ms30 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned short ci (vector unsigned short v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned short mci (vector unsigned short *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+int main (int argc, unsigned short *argv[]) {\n+  vector unsigned short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  unsigned short s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s7 (sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms7 (&sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "63814ee4bb4bed82f9a56f7892fc9c963a3025d1", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-17b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned short s3 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+unsigned short s7 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 7);\n+}\n+\n+unsigned short s21 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned short s30 (vector unsigned short v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned short ms3 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+unsigned short ms7 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 7);\n+}\n+\n+unsigned short ms21 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned short ms30 (vector unsigned short *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned short ci (vector unsigned short v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned short mci (vector unsigned short *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+int main (int argc, unsigned short *argv[]) {\n+  vector unsigned short sv = {\n+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };\n+  unsigned short s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s7 (sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms7 (&sv);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST6)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST7)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST5)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST4)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "3681ad9d019327dbb1d641b01b78108be68e4b00", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Unsigned Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned int s3 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+unsigned int s1 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 1);\n+}\n+\n+unsigned int s21 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned int s30 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned int ms3 (vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+unsigned int ms1(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 1);\n+}\n+\n+unsigned int ms21(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned int ms30(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned int ci (vector unsigned int v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned int mci(vector unsigned int *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+unsigned int main (int argc, unsigned char *argv[]) {\n+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  unsigned int s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s1 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms1 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "57b5c43282c62dba8f87ca8a407e4ceb80171a72", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-18b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Unsigned Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned int s3 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+unsigned int s1 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 1);\n+}\n+\n+unsigned int s21 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 21);\n+}\n+\n+unsigned int s30 (vector unsigned int v)\n+{\n+  return __builtin_vec_extract (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned int ms3 (vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+unsigned int ms1(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 1);\n+}\n+\n+unsigned int ms21(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 21);\n+}\n+\n+unsigned int ms30(vector unsigned int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned int ci (vector unsigned int v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+unsigned int mci(vector unsigned int *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+\n+unsigned int main (int argc, unsigned char *argv[]) {\n+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };\n+  unsigned int s;\n+\n+  s = s3 (sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = s1 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s21 (sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = s30 (sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ms3 (&sv);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ms1 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms21 (&sv);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ms30 (&sv);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = ci (sv, 2);\n+  if (s != CONST2)\n+    abort ();\n+\n+  s = ci (sv, 15);\n+  if (s != CONST3)\n+    abort ();\n+\n+  s = ci (sv, 28);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 5);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 12);\n+  if (s != CONST0)\n+    abort ();\n+\n+  s = mci (&sv, 25);\n+  if (s != CONST1)\n+    abort ();\n+\n+  s = mci (&sv, 16);\n+  if (s != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "dee8319fb10c9d01fc77b9d1dafd139835c535e7", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned long long int e0 (vector unsigned long long int v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned long long int e3 (vector unsigned long long int v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned long long int me0 (vector unsigned long long int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned long long int me3 (vector unsigned long long int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned long long int ei (vector unsigned long long int v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+unsigned long long int mei (vector unsigned long long int *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned long long int dv = { CONST0, CONST1 };\n+  unsigned long long int d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c39923e319b14c1f6da559ae62aae3e1a7d366b1", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-19b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(31415926539LL)\n+#define CONST1\t\t(2 * 31415926539LL)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned long long int e0 (vector unsigned long long int v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned long long int e3 (vector unsigned long long int v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned long long int me0 (vector unsigned long long int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned long long int me3 (vector unsigned long long int *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned long long int ei (vector unsigned long long int v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+unsigned long long int mei (vector unsigned long long int *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned long long int dv = { CONST0, CONST1 };\n+  unsigned long long int d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST1)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "638f5a1c9044ccb42217c763c68f38dc9a85c952", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+/* Define this after PR89424 is addressed.  */\n+#undef PR89424\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((unsigned __int128) 31415926539) << 60)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned __int128 e0 (vector unsigned __int128 v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned __int128 e3 (vector unsigned __int128 v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned __int128 me0 (vector unsigned __int128 *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned __int128 me3 (vector unsigned __int128 *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+#ifdef PR89424\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned __int128 ei (vector unsigned __int128 v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+unsigned __int128 mei (vector unsigned __int128 *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+#endif\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned __int128 dv = { CONST0 };\n+  unsigned __int128 d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+#ifdef PR89424\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "7b127a06c7741a65204eca8bf0ef764f165534f4", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-20b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do run { target int128 } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* This test should run the same on any target that supports vsx\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+/* Define this after PR89424 is addressed.  */\n+#undef PR89424\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(((unsigned __int128) 31415926539) << 60)\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+unsigned __int128 e0 (vector unsigned __int128 v)\n+{\n+  return __builtin_vec_extract (v, 0);\n+}\n+\n+unsigned __int128 e3 (vector unsigned __int128 v)\n+{\n+  return __builtin_vec_extract (v, 3);\n+}\n+\n+/* Test for vector residing in memory.  */\n+unsigned __int128 me0 (vector unsigned __int128 *vp)\n+{\n+  return __builtin_vec_extract (*vp, 0);\n+}\n+\n+unsigned __int128 me3 (vector unsigned __int128 *vp)\n+{\n+  return __builtin_vec_extract (*vp, 3);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+#ifdef PR89424\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+unsigned __int128 ei (vector unsigned __int128 v, int i)\n+{\n+  return __builtin_vec_extract (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+unsigned __int128 mei (vector unsigned __int128 *vp, int i)\n+{\n+  return __builtin_vec_extract (*vp, i);\n+}\n+#endif\n+\n+int main (int argc, char *argv[]) {\n+  vector unsigned __int128 dv = { CONST0 };\n+  unsigned __int128 d;\n+\n+  d = e0 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = e3 (dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me0 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = me3 (&dv);\n+  if (d != CONST0)\n+    abort ();\n+\n+#ifdef PR89424\n+  d = ei (dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = ei (dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 0);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 1);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 2);\n+  if (d != CONST0)\n+    abort ();\n+\n+  d = mei (&dv, 3);\n+  if (d != CONST0)\n+    abort ();\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "7b3543443b7c02e4763e8af6d320e1cf6b4aa2c2", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9a.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+signed char c0 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 0);\n+}\n+\n+signed char c9 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 9);\n+}\n+\n+signed char c21 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 21);\n+}\n+\n+signed char c30 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+signed char mc0 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 0);\n+}\n+\n+signed char mc9 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 9);\n+}\n+\n+signed char mc21 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 21);\n+}\n+\n+signed char mc30 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+signed char ci (vector signed char v, int i)\n+{\n+  return __builtin_vec_ext_v16qi (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+signed char mci(vector signed char *vp, int i) {\n+  return __builtin_vec_ext_v16qi (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  signed char c;\n+\n+  c = c0 (cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = c9 (cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = c21 (cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = c30 (cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = mc0 (&cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = mc9 (&cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mc21 (&cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mc30 (&cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = ci (cv, 8);\n+  if (c != CONST8)\n+    abort ();\n+\n+  c = ci (cv, 13);\n+  if (c != CONSTD)\n+    abort ();\n+\n+  c = ci (cv, 23);\n+  if (c != CONST7)\n+    abort ();\n+\n+  c = ci (cv, 31);\n+  if (c != CONSTF)\n+    abort ();\n+\n+  c = mci (&cv, 5);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mci (&cv, 12);\n+  if (c != CONSTC)\n+    abort ();\n+\n+  c = mci (&cv, 25);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mci (&cv, 16);\n+  if (c != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "ff081b354b2f0a53bac7e70a9f52a3786f309c0d", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30bb0e44d3893b27c6cd74c72a077e5a0d96a244/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-builtin-9b.c?ref=30bb0e44d3893b27c6cd74c72a077e5a0d96a244", "patch": "@@ -0,0 +1,164 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+/* This test should run the same on any target that supports altivec/dfp\n+   instructions.  Intentionally not specifying cpu in order to test\n+   all code generation paths.  */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+#define CONST0\t\t(0)\n+#define CONST1\t\t(1)\n+#define CONST2\t\t(2)\n+#define CONST3\t\t(3)\n+#define CONST4\t\t(4)\n+#define CONST5\t\t(5)\n+#define CONST6\t\t(6)\n+#define CONST7\t\t(7)\n+#define CONST8\t\t(8)\n+#define CONST9\t\t(9)\n+#define CONSTA\t\t(10)\n+#define CONSTB\t\t(11)\n+#define CONSTC\t\t(12)\n+#define CONSTD\t\t(13)\n+#define CONSTE\t\t(14)\n+#define CONSTF\t\t(15)\n+\n+\n+/* Test that indices > length of vector are applied modulo the vector\n+   length.  */\n+\n+/* Test for vector residing in register.  */\n+signed char c0 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 0);\n+}\n+\n+signed char c9 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 9);\n+}\n+\n+signed char c21 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 21);\n+}\n+\n+signed char c30 (vector signed char v)\n+{\n+  return __builtin_vec_ext_v16qi (v, 30);\n+}\n+\n+/* Test for vector residing in memory.  */\n+signed char mc0 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 0);\n+}\n+\n+signed char mc9 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 9);\n+}\n+\n+signed char mc21 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 21);\n+}\n+\n+signed char mc30 (vector signed char *vp)\n+{\n+  return __builtin_vec_ext_v16qi (*vp, 30);\n+}\n+\n+/* Test the same with variable indices.  */\n+\n+/* Test for variable selector and vector residing in register.  */\n+__attribute__((noinline))\n+signed char ci (vector signed char v, int i)\n+{\n+  return __builtin_vec_ext_v16qi (v, i);\n+}\n+\n+/* Test for variable selector and vector residing in memory.  */\n+__attribute__((noinline))\n+signed char mci(vector signed char *vp, int i) {\n+  return __builtin_vec_ext_v16qi (*vp, i);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,\n+\t\t\t    CONST4, CONST5, CONST6, CONST7,\n+\t\t\t    CONST8, CONST9, CONSTA, CONSTB,\n+\t\t\t    CONSTC, CONSTD, CONSTE, CONSTF };\n+  signed char c;\n+\n+  c = c0 (cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = c9 (cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = c21 (cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = c30 (cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = mc0 (&cv);\n+  if (c != CONST0)\n+    abort ();\n+\n+  c = mc9 (&cv);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mc21 (&cv);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mc30 (&cv);\n+  if (c != CONSTE)\n+    abort ();\n+\n+  c = ci (cv, 8);\n+  if (c != CONST8)\n+    abort ();\n+\n+  c = ci (cv, 13);\n+  if (c != CONSTD)\n+    abort ();\n+\n+  c = ci (cv, 23);\n+  if (c != CONST7)\n+    abort ();\n+\n+  c = ci (cv, 31);\n+  if (c != CONSTF)\n+    abort ();\n+\n+  c = mci (&cv, 5);\n+  if (c != CONST5)\n+    abort ();\n+\n+  c = mci (&cv, 12);\n+  if (c != CONSTC)\n+    abort ();\n+\n+  c = mci (&cv, 25);\n+  if (c != CONST9)\n+    abort ();\n+\n+  c = mci (&cv, 16);\n+  if (c != CONST0)\n+    abort ();\n+\n+  return 0;\n+}"}]}