{"sha": "0448002b1755eadd531fe1013cf46ea3ef4acfa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ0ODAwMmIxNzU1ZWFkZDUzMWZlMTAxM2NmNDZlYTNlZjRhY2ZhNQ==", "commit": {"author": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2018-10-04T22:28:18Z"}, "committer": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2018-10-04T22:28:18Z"}, "message": "contrib: unused_functions.py: Handle archives\n\none can now use verbatim the arguments used by the driver invocation to\nlink e.g. cc1.\n\n2018-10-04  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n\n\t* unused_functions.py: Handle archive files.\n\nFrom-SVN: r264856", "tree": {"sha": "f9e7059d80dbb0a70802be4332ab4ee9fe0be690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9e7059d80dbb0a70802be4332ab4ee9fe0be690"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0448002b1755eadd531fe1013cf46ea3ef4acfa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0448002b1755eadd531fe1013cf46ea3ef4acfa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0448002b1755eadd531fe1013cf46ea3ef4acfa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0448002b1755eadd531fe1013cf46ea3ef4acfa5/comments", "author": null, "committer": null, "parents": [{"sha": "f556d6b5d193dc23d2e65c5c06ee62ad5f25e59a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f556d6b5d193dc23d2e65c5c06ee62ad5f25e59a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f556d6b5d193dc23d2e65c5c06ee62ad5f25e59a"}], "stats": {"total": 131, "additions": 101, "deletions": 30}, "files": [{"sha": "498abb501969c9d4cd14b8c69a0c37f4d97803d6", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0448002b1755eadd531fe1013cf46ea3ef4acfa5/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0448002b1755eadd531fe1013cf46ea3ef4acfa5/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=0448002b1755eadd531fe1013cf46ea3ef4acfa5", "patch": "@@ -1,3 +1,7 @@\n+2018-10-04  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+\n+\t* unused_functions.py: Handle archive files.\n+\n 2018-10-04  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n \n \t* unused_functions.py: New file."}, {"sha": "bf7cf36854a8a8613b3750687b93a16ee9f8a2ca", "filename": "contrib/unused_functions.py", "status": "modified", "additions": 97, "deletions": 30, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0448002b1755eadd531fe1013cf46ea3ef4acfa5/contrib%2Funused_functions.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0448002b1755eadd531fe1013cf46ea3ef4acfa5/contrib%2Funused_functions.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Funused_functions.py?ref=0448002b1755eadd531fe1013cf46ea3ef4acfa5", "patch": "@@ -1,4 +1,5 @@\n #!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n #\n # Copyright (c) 2018 Free Software Foundation\n # Contributed by Bernhard Reutner-Fischer <aldot@gcc.gnu.org>\n@@ -17,71 +18,125 @@\n # unused_functions.py gcc/cp gcc/c-family/ gcc/*-c.o | grep -v \"'gt_\"\n \n import sys, os\n+from tempfile import mkdtemp\n+from subprocess import Popen, PIPE\n \n def usage():\n-    sys.stderr.write(\"usage: %s [dirs | files] [-- <readelf options>]\\n\"\n+    sys.stderr.write(\"usage: %s [-v] [dirs | files] [-- <readelf options>]\\n\"\n                         % sys.argv[0])\n+    sys.stderr.write(\"\\t-v\\tVerbose output\\n\");\n     sys.exit(1)\n \n-(odir, sym_args) = (set(), \"\")\n+(odir, sym_args, tmpd, verbose) = (set(), \"\", None, False)\n \n for i in range(1, len(sys.argv)):\n     f = sys.argv[i]\n-    if f == \"--\": # sym_args\n-        sym_args = \" \".join(sys.argv[i + 1:])\n+    if f == '--': # sym_args\n+        sym_args = ' '.join(sys.argv[i + 1:])\n         break\n+    if f == '-v':\n+        verbose = True\n+        continue\n     if not os.path.exists(f):\n         sys.stderr.write(\"Error: No such file or directory '%s'\\n\" % f)\n         usage()\n     else:\n+        if f.endswith('.a') and tmpd is None:\n+            tmpd = mkdtemp(prefix='unused_fun')\n         odir.add(f)\n \n+def dbg(args):\n+    if not verbose: return\n+    print(args)\n+\n def get_symbols(file):\n     syms = {}\n-    for l in os.popen(\"readelf -W -s %s %s | c++filt\" % (sym_args, file)).readlines():\n+    rargs = \"readelf -W -s %s %s\" % (sym_args, file)\n+    p0 = Popen((a for a in rargs.split(' ') if a.strip() != ''), stdout=PIPE)\n+    p1 = Popen([\"c++filt\"], stdin=p0.stdout, stdout=PIPE,\n+            universal_newlines=True)\n+    lines = p1.communicate()[0]\n+    for l in lines.split('\\n'):\n         l = l.strip()\n-        if not (len(l) and l[0].isdigit() and len(l.split()) == 8):\n-            continue\n-        num, value, size, typ, bind, vis, ndx, name = l.split()\n+        if not len(l) or not l[0].isdigit(): continue\n+        larr = l.split()\n+        if len(larr) != 8: continue\n+        num, value, size, typ, bind, vis, ndx, name = larr\n         if typ == 'SECTION' or typ == 'FILE': continue\n         # I don't think we have many aliases in gcc, re-instate the addr\n         # lut otherwise.\n-        if vis != \"DEFAULT\": continue\n+        if vis != 'DEFAULT': continue\n         #value = int(value, 16)\n         #size = int(size, 16) if size.startswith('0x') else int(size)\n-        defined = ndx != \"UND\"\n-        globl = bind == \"GLOBAL\"\n+        defined = ndx != 'UND'\n+        globl = bind == 'GLOBAL'\n         # c++ RID_FUNCTION_NAME dance. FORNOW: Handled as local use\n         # Is that correct?\n-        if name.endswith(\"::__FUNCTION__\") and typ == \"OBJECT\":\n-            name = name[0:(len(name) - len(\"::__FUNCTION__\"))]\n+        if name.endswith('::__FUNCTION__') and typ == 'OBJECT':\n+            name = name[0:(len(name) - len('::__FUNCTION__'))]\n             if defined: defined = False\n         if defined and not globl: continue\n         syms.setdefault(name, {})\n-        syms[name][[\"use\",\"def\"][defined]] = True\n-        syms[name][[\"local\",\"global\"][globl]] = True\n+        syms[name][['use','def'][defined]] = True\n+        syms[name][['local','global'][globl]] = True\n     # Note: we could filter out e.g. debug_* symbols by looking for\n     # value in the debug_macro sections.\n+    if p1.returncode != 0:\n+        print(\"Warning: Reading file '%s' exited with %r|%r\"\n+            % (file, p0.returncode, p1.returncode))\n+    p0.kill()\n     return syms\n \n (oprog, nprog) = ({}, {})\n \n def walker(paths):\n+    def ar_x(archive):\n+        dbg(\"Archive %s\" % path)\n+        f = os.path.abspath(archive)\n+        f = os.path.splitdrive(f)[1]\n+        d = tmpd + os.path.sep + f\n+        d = os.path.normpath(d)\n+        owd = os.getcwd()\n+        try:\n+            os.makedirs(d)\n+            os.chdir(d)\n+            p0 = Popen([\"ar\", \"x\", \"%s\" % os.path.join(owd, archive)],\n+                    stderr=PIPE, universal_newlines=True)\n+            p0.communicate()\n+            if p0.returncode > 0: d = None # assume thin archive\n+        except:\n+            dbg(\"ar x: Error: %s: %s\" % (archive, sys.exc_info()[0]))\n+            os.chdir(owd)\n+            raise\n+        os.chdir(owd)\n+        if d: dbg(\"Extracted to %s\" % (d))\n+        return (archive, d)\n+\n+    def ar_t(archive):\n+        dbg(\"Thin archive, using existing files:\")\n+        try:\n+            p0 = Popen([\"ar\", \"t\", \"%s\" % archive], stdout=PIPE,\n+                    universal_newlines=True)\n+            ret = p0.communicate()[0]\n+            return ret.split('\\n')\n+        except:\n+            dbg(\"ar t: Error: %s: %s\" % (archive, sys.exc_info()[0]))\n+            raise\n+\n     prog = {}\n     for path in paths:\n         if os.path.isdir(path):\n             for r, dirs, files in os.walk(path):\n-                for f in files:\n-                    # TODO: maybe extract .a to a tmpdir and walk that, too\n-                    # maybe /there/foolib.a(file.o) as name?\n-                    if not f.endswith(\".o\"): continue\n-                    p = os.path.join(r, f)\n-                    prog[os.path.normpath(p)] = get_symbols(p)\n-                for d in dirs:\n-                    tem = prog.copy()\n-                    tem.update(walker([os.path.join(r, d)]))\n-                    prog = tem\n+                if files: dbg(\"Files %s\" % \", \".join(files))\n+                if dirs: dbg(\"Dirs  %s\" % \", \".join(dirs))\n+                prog.update(walker([os.path.join(r, f) for f in files]))\n+                prog.update(walker([os.path.join(r, d) for d in dirs]))\n         else:\n+            if path.endswith('.a'):\n+                if ar_x(path)[1] is not None: continue # extract worked\n+                prog.update(walker(ar_t(path)))\n+            if not path.endswith('.o'): continue\n+            dbg(\"Reading symbols from %s\" % (path))\n             prog[os.path.normpath(path)] = get_symbols(path)\n     return prog\n \n@@ -92,19 +147,31 @@ def resolve(prog):\n     for (f, g) in ((f,g) for f in x for g in x if f != g):\n         refs = set()\n         # for each defined symbol\n-        for s in (s for s in prog[f] if prog[f][s].get(\"def\") and s in prog[g]):\n-            if prog[g][s].get(\"use\"):\n+        for s in (s for s in prog[f] if prog[f][s].get('def') and s in prog[g]):\n+            if prog[g][s].get('use'):\n                 refs.add(s)\n         for s in refs:\n             # Prune externally referenced symbols as speed optimization only\n             for i in (i for i in x if s in prog[i]): del prog[i][s]\n         use |= refs\n     return use\n \n-oprog = walker(odir)\n-oused = resolve(oprog)\n+try:\n+    oprog = walker(odir)\n+    if tmpd is not None:\n+        oprog.update(walker([tmpd]))\n+    oused = resolve(oprog)\n+finally:\n+    try:\n+        p0 = Popen([\"rm\", \"-r\", \"-f\", \"%s\" % (tmpd)], stderr=PIPE, stdout=PIPE)\n+        p0.communicate()\n+        if p0.returncode != 0: raise \"rm '%s' didn't work out\" % (tmpd)\n+    except:\n+        from shutil import rmtree\n+        rmtree(tmpd, ignore_errors=True)\n+\n for (i,s) in ((i,s) for i in oprog.keys() for s in oprog[i] if oprog[i][s]):\n-    if oprog[i][s].get(\"def\") and not oprog[i][s].get(\"use\"):\n+    if oprog[i][s].get('def') and not oprog[i][s].get('use'):\n         print(\"%s: Symbol '%s' declared extern but never referenced externally\"\n             % (i,s))\n "}]}