{"sha": "fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNmYmQ4ZjllMDBlYWI0NDdjNjY2ZjJlMjhjZWYyODI2ZmFiODhmMg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-05T16:26:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-05T16:26:06Z"}, "message": "Merge #484 #485 #486\n\n484: Trait impls and initial start of traits work r=philberty a=philberty\n\nThis does not start enforcing anything to do with traits. in order to\r\nimplement the traits milestone we need to be able to implement a\r\ntrait first.\r\n\r\nThis makes the Trait impls follow a normal impl block. As the starting\r\npoint.\r\n\r\nFixes #395 #472\n\n485: All toplevel items must respect the prefix for their path r=philberty a=philberty\n\nThe commit message has a more detailed explanation as to why.\r\nBut some toplevel items were not respecting their prefix which is\r\nimportant for module support.\n\n486: Use PRIx64 to print 64bit hex values in legacy_hash r=philberty a=philberty\n\n* gcc/rust/backend/rust-compile.cc (legacy_hash): lo and hi are uint64_t use\r\nPRIx64 to print them as hex values instead of %lx which is target specific.\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "50dc4bee295b9de60612ad36f48d58044b1e1f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50dc4bee295b9de60612ad36f48d58044b1e1f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgu6WeCRBK7hj4Ov3rIwAAjhMIAE22X2ULCzShcPcDQyf4PrtJ\n+EkNdUNLqWV00q/f0vopzufhgngwCvqvv9z4YGEHHmv5Sev/gkSVcmiHMvPHuEr4\ndd4nUQpf9MApGkk72iP4HqQdcEQKelQ9Gg7sfeP9jZ1q9HWEQVOmOBDsrC01ZIUR\nIGo1qDvrgelCkNyJe1gNa7oMHaP+w5irTjfS29RD7VsOzt7fNhI3rZMeBS+yfl2k\nX+GcIdHPal/iJ/jTH7hJTQIF+mfxiPZF3D0iHoTXBGt3fdegEgKJrBN5I5s9tdez\na0I1cdECwwSEV7qXY+fBmCq8JzgwJzCD+2fROZYx41TAoLRR7nPbm5KF0GaOFTc=\n=6Ob1\n-----END PGP SIGNATURE-----\n", "payload": "tree 50dc4bee295b9de60612ad36f48d58044b1e1f53\nparent bc4c1ef45d46284583168c321a292df54ce86b2e\nparent 1c0f8d6d2a22ce498ef3f1bfd60a3867a90c8130\nparent 7222dcb2bb831b92c71e2a4db3d490525e78a4dd\nparent b2fd4346a65289390342fb61815b11926945416e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622910366 +0000\ncommitter GitHub <noreply@github.com> 1622910366 +0000\n\nMerge #484 #485 #486\n\n484: Trait impls and initial start of traits work r=philberty a=philberty\n\nThis does not start enforcing anything to do with traits. in order to\r\nimplement the traits milestone we need to be able to implement a\r\ntrait first.\r\n\r\nThis makes the Trait impls follow a normal impl block. As the starting\r\npoint.\r\n\r\nFixes #395 #472\n\n485: All toplevel items must respect the prefix for their path r=philberty a=philberty\n\nThe commit message has a more detailed explanation as to why.\r\nBut some toplevel items were not respecting their prefix which is\r\nimportant for module support.\n\n486: Use PRIx64 to print 64bit hex values in legacy_hash r=philberty a=philberty\n\n* gcc/rust/backend/rust-compile.cc (legacy_hash): lo and hi are uint64_t use\r\nPRIx64 to print them as hex values instead of %lx which is target specific.\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4c1ef45d46284583168c321a292df54ce86b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4c1ef45d46284583168c321a292df54ce86b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4c1ef45d46284583168c321a292df54ce86b2e"}, {"sha": "1c0f8d6d2a22ce498ef3f1bfd60a3867a90c8130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0f8d6d2a22ce498ef3f1bfd60a3867a90c8130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0f8d6d2a22ce498ef3f1bfd60a3867a90c8130"}, {"sha": "7222dcb2bb831b92c71e2a4db3d490525e78a4dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7222dcb2bb831b92c71e2a4db3d490525e78a4dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7222dcb2bb831b92c71e2a4db3d490525e78a4dd"}, {"sha": "b2fd4346a65289390342fb61815b11926945416e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2fd4346a65289390342fb61815b11926945416e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2fd4346a65289390342fb61815b11926945416e"}], "stats": {"total": 1000, "additions": 916, "deletions": 84}, "files": [{"sha": "0e25de2be5c36075f5167329407a5cd0088a559f", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -1282,9 +1282,13 @@ class MacroItem : public Item\n class TraitItem\n {\n protected:\n+  TraitItem () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n \n+  NodeId node_id;\n+\n public:\n   virtual ~TraitItem () {}\n \n@@ -1300,6 +1304,8 @@ class TraitItem\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n /* Abstract base class for items used within an inherent impl block (the impl"}, {"sha": "f9a5a6ddb5c44f38eebe4473d6b94537bcd6cf2c", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -2765,6 +2765,8 @@ struct TraitFunctionDecl\n   // Returns whether function has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  Identifier get_identifier () const { return function_name; }\n+\n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n \t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -2871,14 +2873,17 @@ class TraitItemFunc : public TraitItem\n \n   TraitItemFunc (TraitFunctionDecl decl, std::unique_ptr<BlockExpr> block_expr,\n \t\t std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n-      block_expr (std::move (block_expr)), locus (locus)\n+    : TraitItem (), outer_attrs (std::move (outer_attrs)),\n+      decl (std::move (decl)), block_expr (std::move (block_expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clone\n   TraitItemFunc (TraitItemFunc const &other)\n     : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n   {\n+    node_id = other.node_id;\n+\n     // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n@@ -2891,6 +2896,7 @@ class TraitItemFunc : public TraitItem\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n@@ -2983,6 +2989,8 @@ struct TraitMethodDecl\n   // Returns whether method has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  Identifier get_identifier () const { return function_name; }\n+\n   // Mega-constructor\n   TraitMethodDecl (Identifier function_name, FunctionQualifiers qualifiers,\n \t\t   std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -3095,14 +3103,17 @@ class TraitItemMethod : public TraitItem\n \n   TraitItemMethod (TraitMethodDecl decl, std::unique_ptr<BlockExpr> block_expr,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n-      block_expr (std::move (block_expr)), locus (locus)\n+    : TraitItem (), outer_attrs (std::move (outer_attrs)),\n+      decl (std::move (decl)), block_expr (std::move (block_expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clone\n   TraitItemMethod (TraitItemMethod const &other)\n     : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n   {\n+    node_id = other.node_id;\n+\n     // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n       block_expr = other.block_expr->clone_block_expr ();\n@@ -3115,6 +3126,7 @@ class TraitItemMethod : public TraitItem\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n@@ -3187,14 +3199,17 @@ class TraitItemConst : public TraitItem\n   TraitItemConst (Identifier name, std::unique_ptr<Type> type,\n \t\t  std::unique_ptr<Expr> expr,\n \t\t  std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n-      type (std::move (type)), expr (std::move (expr)), locus (locus)\n+    : TraitItem (), outer_attrs (std::move (outer_attrs)),\n+      name (std::move (name)), type (std::move (type)), expr (std::move (expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clones\n   TraitItemConst (TraitItemConst const &other)\n     : outer_attrs (other.outer_attrs), name (other.name), locus (other.locus)\n   {\n+    node_id = other.node_id;\n+\n     // guard to prevent null dereference\n     if (other.expr != nullptr)\n       expr = other.expr->clone_expr ();\n@@ -3211,6 +3226,7 @@ class TraitItemConst : public TraitItem\n     outer_attrs = other.outer_attrs;\n     name = other.name;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent null dereference\n     if (other.expr != nullptr)\n@@ -3259,6 +3275,8 @@ class TraitItemConst : public TraitItem\n     return type;\n   }\n \n+  Identifier get_identifier () const { return name; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -3289,14 +3307,16 @@ class TraitItemType : public TraitItem\n     Identifier name,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n+    : TraitItem (), outer_attrs (std::move (outer_attrs)),\n+      name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   TraitItemType (TraitItemType const &other)\n     : outer_attrs (other.outer_attrs), name (other.name), locus (other.locus)\n   {\n+    node_id = other.node_id;\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -3309,6 +3329,7 @@ class TraitItemType : public TraitItem\n     outer_attrs = other.outer_attrs;\n     name = other.name;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -3346,6 +3367,8 @@ class TraitItemType : public TraitItem\n     return type_param_bounds;\n   }\n \n+  Identifier get_identifier () const { return name; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -3397,6 +3420,10 @@ class Trait : public VisItem\n   // Returns whether trait has inner attributes.\n   bool has_inner_attrs () const { return !inner_attrs.empty (); }\n \n+  Identifier get_identifier () const { return name; }\n+\n+  bool is_unsafe () const { return has_unsafe; }\n+\n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n \t std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -3732,8 +3759,6 @@ class TraitImpl : public Impl\n       trait_path (std::move (trait_path)), impl_items (std::move (impl_items))\n   {}\n \n-  // TODO: constructors with less params\n-\n   // Copy constructor with vector clone\n   TraitImpl (TraitImpl const &other)\n     : Impl (other), has_unsafe (other.has_unsafe),\n@@ -3765,6 +3790,9 @@ class TraitImpl : public Impl\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  bool is_unsafe () const { return has_unsafe; };\n+  bool is_exclam () const { return has_exclam; }\n+\n   // TODO: think of better way to do this\n   const std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items () const\n   {"}, {"sha": "a4fb6d12174799a93715117012d1a96ef67e23ca", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -42,6 +42,14 @@ class CompileInherentImplItem : public HIRCompileBase\n     item->accept_vis (compiler);\n   }\n \n+  static void Compile (TyTy::BaseType *self, HIR::TraitImplItem *item,\n+\t\t       Context *ctx, bool compile_fns,\n+\t\t       TyTy::BaseType *concrete = nullptr)\n+  {\n+    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete);\n+    item->accept_vis (compiler);\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *resolved_type = nullptr;"}, {"sha": "e68165206e7b5d66112609e2728e3ba2538d9467", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -290,6 +290,22 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\tcompile_fns);\n   }\n \n+  void visit (HIR::TraitImpl &impl_block) override\n+  {\n+    TyTy::BaseType *self_lookup = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+      {\n+\trust_error_at (impl_block.get_locus (),\n+\t\t       \"failed to resolve type of impl\");\n+\treturn;\n+      }\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      CompileInherentImplItem::Compile (self_lookup, impl_item.get (), ctx,\n+\t\t\t\t\tcompile_fns);\n+  }\n+\n private:\n   CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n     : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)"}, {"sha": "ea21ad3f92b8ccaddb9857e2e47d5cf9a33abfc5", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -442,7 +442,7 @@ legacy_hash (const std::string &fingerprint)\n \n   char hex[16 + 1];\n   memset (hex, 0, sizeof hex);\n-  snprintf (hex, sizeof hex, \"%08lx%08lx\", lo, hi);\n+  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n \n   return \"h\" + std::string (hex, sizeof (hex) - 1);\n }"}, {"sha": "a3baf501ac2f216c6bd3fb3e4b84a6dc6d5280e6", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -293,6 +293,8 @@ class ASTLoweringBase : public AST::ASTVisitor\n   HIR::GenericArgs lower_generic_args (AST::GenericArgs &args);\n \n   HIR::GenericArgsBinding lower_binding (AST::GenericArgsBinding &binding);\n+\n+  HIR::SelfParam lower_self (AST::SelfParam &self);\n };\n \n } // namespace HIR"}, {"sha": "f830918545478b3b4affef85d2e24027441d68dd", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 200, "deletions": 18, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -43,19 +43,14 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n-  HIR::SelfParam lower_self (AST::SelfParam &self)\n+  static HIR::TraitImplItem *translate (AST::TraitImplItem *item,\n+\t\t\t\t\tHirId parent_impl_id)\n   {\n-    HIR::Type *type = self.has_type ()\n-\t\t\t? ASTLoweringType::translate (self.get_type ().get ())\n-\t\t\t: nullptr;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n-\t\t\t   self.get_is_mut (), self.get_locus ());\n+    ASTLowerImplItem resolver (parent_impl_id);\n+    item->accept_vis (resolver);\n+    rust_assert (resolver.trait_impl_item != nullptr);\n+    // can get a way with this for now since they have the same hierarchy\n+    return resolver.trait_impl_item;\n   }\n \n   void visit (AST::ConstantItem &constant) override\n@@ -70,11 +65,14 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n-\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n-\t\t\t\t\tconstant.get_outer_attrs (),\n-\t\t\t\t\tconstant.get_locus ());\n+    auto translated_constant\n+      = new HIR::ConstantItem (mapping, constant.get_identifier (), vis,\n+\t\t\t       std::unique_ptr<HIR::Type> (type),\n+\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t       constant.get_outer_attrs (),\n+\t\t\t       constant.get_locus ());\n+    translated = translated_constant;\n+    trait_impl_item = translated_constant;\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id,\n@@ -163,6 +161,7 @@ class ASTLowerImplItem : public ASTLoweringBase\n       }\n \n     translated = fn;\n+    trait_impl_item = fn;\n   }\n \n   void visit (AST::Method &method) override\n@@ -251,17 +250,200 @@ class ASTLowerImplItem : public ASTLoweringBase\n       }\n \n     translated = mth;\n+    trait_impl_item = mth;\n   }\n \n private:\n   ASTLowerImplItem (HirId parent_impl_id)\n-    : translated (nullptr), parent_impl_id (parent_impl_id)\n+    : translated (nullptr), trait_impl_item (nullptr),\n+      parent_impl_id (parent_impl_id)\n   {}\n \n   HIR::InherentImplItem *translated;\n+  HIR::TraitImplItem *trait_impl_item;\n   HirId parent_impl_id;\n };\n \n+class ASTLowerTraitItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TraitItem *translate (AST::TraitItem *item)\n+  {\n+    ASTLowerTraitItem resolver;\n+    item->accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    AST::TraitFunctionDecl &ref = func.get_trait_function_decl ();\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (ref.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (ref.get_generic_params ());\n+      }\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = ref.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (ref.get_return_type ().get ()))\n+\t\t\t       : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : ref.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    HIR::TraitFunctionDecl decl (ref.get_identifier (), std::move (qualifiers),\n+\t\t\t\t std::move (generic_params),\n+\t\t\t\t std::move (function_params),\n+\t\t\t\t std::move (return_type),\n+\t\t\t\t std::move (where_clause));\n+    HIR::Expr *block_expr\n+      = func.has_definition ()\n+\t  ? ASTLoweringExpr::translate (func.get_definition ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, func.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TraitItemFunc (mapping, std::move (decl),\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (block_expr),\n+\t\t\t\tfunc.get_outer_attrs (), func.get_locus ());\n+  }\n+\n+  void visit (AST::TraitItemMethod &method) override\n+  {\n+    AST::TraitMethodDecl &ref = method.get_trait_method_decl ();\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (ref.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (ref.get_generic_params ());\n+      }\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = ref.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (ref.get_return_type ().get ()))\n+\t\t\t       : nullptr;\n+\n+    HIR::SelfParam self_param = lower_self (ref.get_self_param ());\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : ref.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    HIR::TraitMethodDecl decl (ref.get_identifier (), std::move (qualifiers),\n+\t\t\t       std::move (generic_params),\n+\t\t\t       std::move (self_param),\n+\t\t\t       std::move (function_params),\n+\t\t\t       std::move (return_type),\n+\t\t\t       std::move (where_clause));\n+    HIR::Expr *block_expr\n+      = method.has_definition ()\n+\t  ? ASTLoweringExpr::translate (method.get_definition ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TraitItemMethod (mapping, std::move (decl),\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (block_expr),\n+\t\t\t\t  method.get_outer_attrs (),\n+\t\t\t\t  method.get_locus ());\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr\n+      = constant.has_expression ()\n+\t  ? ASTLoweringExpr::translate (constant.get_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::TraitItemConst (mapping, constant.get_identifier (),\n+\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t\t  constant.get_outer_attrs (),\n+\t\t\t\t\t  constant.get_locus ());\n+  }\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TraitItemType (mapping, type.get_identifier (),\n+\t\t\t\tstd::move (type_param_bounds),\n+\t\t\t\ttype.get_outer_attrs (), type.get_locus ());\n+  }\n+\n+private:\n+  ASTLowerTraitItem () : translated (nullptr) {}\n+\n+  HIR::TraitItem *translated;\n+};\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "206eeff01527a64cb248a7163abcd98ce7d2c714", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -406,6 +406,149 @@ class ASTLoweringItem : public ASTLoweringBase\n       }\n   }\n \n+  void visit (AST::Trait &trait) override\n+  {\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (trait.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (trait.get_generic_params ());\n+\n+\tfor (auto &generic_param : generic_params)\n+\t  {\n+\t    switch (generic_param->get_kind ())\n+\t      {\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  const HIR::TypeParam &t\n+\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\t  if (t.has_type ())\n+\t\t    {\n+\t\t      // see https://github.com/rust-lang/rust/issues/36887\n+\t\t      rust_error_at (\n+\t\t\tt.get_locus (),\n+\t\t\t\"defaults for type parameters are not allowed here\");\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+\n+    std::vector<std::unique_ptr<HIR::TraitItem> > trait_items;\n+    for (auto &item : trait.get_trait_items ())\n+      {\n+\tHIR::TraitItem *lowered = ASTLowerTraitItem::translate (item.get ());\n+\ttrait_items.push_back (std::unique_ptr<HIR::TraitItem> (lowered));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, trait.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Trait (mapping, trait.get_identifier (),\n+\t\t\t\t trait.is_unsafe (), std::move (generic_params),\n+\t\t\t\t std::move (type_param_bounds), where_clause,\n+\t\t\t\t std::move (trait_items), vis,\n+\t\t\t\t trait.get_outer_attrs (), trait.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       trait.get_locus ());\n+  }\n+\n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (impl_block.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (impl_block.get_generic_params ());\n+\n+\tfor (auto &generic_param : generic_params)\n+\t  {\n+\t    switch (generic_param->get_kind ())\n+\t      {\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  const HIR::TypeParam &t\n+\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\t  if (t.has_type ())\n+\t\t    {\n+\t\t      // see https://github.com/rust-lang/rust/issues/36887\n+\t\t      rust_error_at (\n+\t\t\tt.get_locus (),\n+\t\t\t\"defaults for type parameters are not allowed here\");\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    HIR::Type *trait_type\n+      = ASTLoweringType::translate (impl_block.get_type ().get ());\n+    HIR::Type *trait = nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    std::vector<std::unique_ptr<HIR::TraitImplItem> > impl_items;\n+    std::vector<HirId> impl_item_ids;\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      {\n+\tHIR::TraitImplItem *lowered\n+\t  = ASTLowerImplItem::translate (impl_item.get (),\n+\t\t\t\t\t mapping.get_hirid ());\n+\timpl_items.push_back (std::unique_ptr<HIR::TraitImplItem> (lowered));\n+\timpl_item_ids.push_back (\n+\t  lowered->get_trait_impl_mappings ().get_hirid ());\n+      }\n+\n+    translated\n+      = new HIR::TraitImpl (mapping, std::unique_ptr<HIR::Type> (trait),\n+\t\t\t    impl_block.is_unsafe (), impl_block.is_exclam (),\n+\t\t\t    std::move (impl_items), std::move (generic_params),\n+\t\t\t    std::unique_ptr<HIR::Type> (trait_type),\n+\t\t\t    where_clause, vis, impl_block.get_inner_attrs (),\n+\t\t\t    impl_block.get_outer_attrs (),\n+\t\t\t    impl_block.get_locus ());\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       impl_block.get_locus ());\n+\n+    for (auto &impl_item_id : impl_item_ids)\n+      {\n+\tmappings->insert_impl_item_mapping (impl_item_id,\n+\t\t\t\t\t    static_cast<HIR::InherentImpl *> (\n+\t\t\t\t\t      translated));\n+      }\n+  }\n+\n private:\n   ASTLoweringItem () : translated (nullptr) {}\n "}, {"sha": "1abdd3cc8a75e86c6d4bb5b0b817a54c810e734d", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -347,5 +347,21 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n \t\t\t   std::move (binding_args), args.get_locus ());\n }\n \n+HIR::SelfParam\n+ASTLoweringBase::lower_self (AST::SelfParam &self)\n+{\n+  HIR::Type *type = self.has_type ()\n+\t\t      ? ASTLoweringType::translate (self.get_type ().get ())\n+\t\t      : nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t self.get_is_mut (), self.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "63eb1bb17bf20ffe2a3bbca8f0ae7328ad8150f4", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -1170,7 +1170,7 @@ TraitImpl::as_string () const\n       str += \"false\";\n     }\n \n-  str += \"\\n TypePath (to trait): \" + trait_path.as_string ();\n+  str += \"\\n TypePath (to trait): \" + trait_path->as_string ();\n \n   str += \"\\n Type (struct to impl on): \" + trait_type->as_string ();\n "}, {"sha": "e466a35898f9bdb589f88c06844495d7bde22005", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 75, "deletions": 33, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -700,6 +700,11 @@ class Method : public InherentImplItem, public TraitImplItem\n     return get_mappings ();\n   };\n \n+  Analysis::NodeMapping get_trait_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n   // Returns whether function has return type - if not, it is void.\n   bool has_function_return_type () const { return return_type != nullptr; }\n \n@@ -748,6 +753,8 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n+  Location get_trait_impl_locus () const final { return get_locus (); }\n+\n   std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n   const std::unique_ptr<BlockExpr> &get_function_body () const\n   {\n@@ -1370,13 +1377,20 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n+  Location get_trait_impl_locus () const final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n   Analysis::NodeMapping get_impl_mappings () const override\n   {\n     return get_mappings ();\n   };\n \n+  Analysis::NodeMapping get_trait_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n   const std::vector<FunctionParam> &get_function_params () const\n   {\n@@ -1518,6 +1532,8 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   Location get_locus () const { return locus; }\n \n+  Location get_trait_impl_locus () const final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n   std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n@@ -1545,6 +1561,11 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   Identifier get_new_type_name () const { return new_type_name; }\n \n+  Analysis::NodeMapping get_trait_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2271,6 +2292,8 @@ class ConstantItem : public VisItem,\n \n   Location get_impl_locus () const final { return get_locus (); }\n \n+  Location get_trait_impl_locus () const final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n   Type *get_type () { return type.get (); }\n@@ -2284,6 +2307,11 @@ class ConstantItem : public VisItem,\n     return get_mappings ();\n   };\n \n+  Analysis::NodeMapping get_trait_impl_mappings () const override\n+  {\n+    return get_mappings ();\n+  };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2478,25 +2506,28 @@ class TraitItemFunc : public TraitItem\n {\n   AST::AttrVec outer_attrs;\n   TraitFunctionDecl decl;\n-  std::unique_ptr<BlockExpr> block_expr;\n+  std::unique_ptr<Expr> block_expr;\n   Location locus;\n \n public:\n   // Returns whether function has a definition or is just a declaration.\n   bool has_definition () const { return block_expr != nullptr; }\n \n-  TraitItemFunc (TraitFunctionDecl decl, std::unique_ptr<BlockExpr> block_expr,\n-\t\t AST::AttrVec outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n-      block_expr (std::move (block_expr)), locus (locus)\n+  TraitItemFunc (Analysis::NodeMapping mappings, TraitFunctionDecl decl,\n+\t\t std::unique_ptr<Expr> block_expr, AST::AttrVec outer_attrs,\n+\t\t Location locus)\n+    : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n+      decl (std::move (decl)), block_expr (std::move (block_expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clone\n   TraitItemFunc (TraitItemFunc const &other)\n-    : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n+    : TraitItem (other.mappings), outer_attrs (other.outer_attrs),\n+      decl (other.decl), locus (other.locus)\n   {\n     if (other.block_expr != nullptr)\n-      block_expr = other.block_expr->clone_block_expr ();\n+      block_expr = other.block_expr->clone_expr ();\n   }\n \n   // Overloaded assignment operator to clone\n@@ -2506,8 +2537,9 @@ class TraitItemFunc : public TraitItem\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n     locus = other.locus;\n+    mappings = other.mappings;\n     if (other.block_expr != nullptr)\n-      block_expr = other.block_expr->clone_block_expr ();\n+      block_expr = other.block_expr->clone_expr ();\n \n     return *this;\n   }\n@@ -2522,7 +2554,7 @@ class TraitItemFunc : public TraitItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  BlockExpr *get_block_expr () { return block_expr.get (); }\n+  std::unique_ptr<Expr> &get_block_expr () { return block_expr; }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2629,23 +2661,26 @@ class TraitItemMethod : public TraitItem\n {\n   AST::AttrVec outer_attrs;\n   TraitMethodDecl decl;\n-  std::unique_ptr<BlockExpr> block_expr;\n+  std::unique_ptr<Expr> block_expr;\n   Location locus;\n \n public:\n   // Returns whether method has a definition or is just a declaration.\n   bool has_definition () const { return block_expr != nullptr; }\n \n-  TraitItemMethod (TraitMethodDecl decl, std::unique_ptr<BlockExpr> block_expr,\n-\t\t   AST::AttrVec outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), decl (std::move (decl)),\n-      block_expr (std::move (block_expr)), locus (locus)\n+  TraitItemMethod (Analysis::NodeMapping mappings, TraitMethodDecl decl,\n+\t\t   std::unique_ptr<Expr> block_expr, AST::AttrVec outer_attrs,\n+\t\t   Location locus)\n+    : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n+      decl (std::move (decl)), block_expr (std::move (block_expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clone\n   TraitItemMethod (TraitItemMethod const &other)\n-    : outer_attrs (other.outer_attrs), decl (other.decl),\n-      block_expr (other.block_expr->clone_block_expr ()), locus (other.locus)\n+    : TraitItem (other.mappings), outer_attrs (other.outer_attrs),\n+      decl (other.decl), block_expr (other.block_expr->clone_expr ()),\n+      locus (other.locus)\n   {}\n \n   // Overloaded assignment operator to clone\n@@ -2654,8 +2689,9 @@ class TraitItemMethod : public TraitItem\n     TraitItem::operator= (other);\n     outer_attrs = other.outer_attrs;\n     decl = other.decl;\n-    block_expr = other.block_expr->clone_block_expr ();\n+    block_expr = other.block_expr->clone_expr ();\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -2670,7 +2706,7 @@ class TraitItemMethod : public TraitItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  BlockExpr *get_block_expr () { return block_expr.get (); }\n+  std::unique_ptr<Expr> &get_block_expr () { return block_expr; }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2696,18 +2732,19 @@ class TraitItemConst : public TraitItem\n   // Whether the constant item has an associated expression.\n   bool has_expression () const { return expr != nullptr; }\n \n-  TraitItemConst (Identifier name, std::unique_ptr<Type> type,\n-\t\t  std::unique_ptr<Expr> expr, AST::AttrVec outer_attrs,\n-\t\t  Location locus)\n-    : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n-      type (std::move (type)), expr (std::move (expr)), locus (locus)\n+  TraitItemConst (Analysis::NodeMapping mappings, Identifier name,\n+\t\t  std::unique_ptr<Type> type, std::unique_ptr<Expr> expr,\n+\t\t  AST::AttrVec outer_attrs, Location locus)\n+    : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n+      name (std::move (name)), type (std::move (type)), expr (std::move (expr)),\n+      locus (locus)\n   {}\n \n   // Copy constructor with clones\n   TraitItemConst (TraitItemConst const &other)\n-    : outer_attrs (other.outer_attrs), name (other.name),\n-      type (other.type->clone_type ()), expr (other.expr->clone_expr ()),\n-      locus (other.locus)\n+    : TraitItem (other.mappings), outer_attrs (other.outer_attrs),\n+      name (other.name), type (other.type->clone_type ()),\n+      expr (other.expr->clone_expr ()), locus (other.locus)\n   {}\n \n   // Overloaded assignment operator to clone\n@@ -2719,6 +2756,7 @@ class TraitItemConst : public TraitItem\n     type = other.type->clone_type ();\n     expr = other.expr->clone_expr ();\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -2760,16 +2798,18 @@ class TraitItemType : public TraitItem\n   bool has_type_param_bounds () const { return !type_param_bounds.empty (); }\n \n   TraitItemType (\n-    Identifier name,\n+    Analysis::NodeMapping mappings, Identifier name,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     AST::AttrVec outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n+    : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n+      name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   TraitItemType (TraitItemType const &other)\n-    : outer_attrs (other.outer_attrs), name (other.name), locus (other.locus)\n+    : TraitItem (other.mappings), outer_attrs (other.outer_attrs),\n+      name (other.name), locus (other.locus)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -2783,6 +2823,7 @@ class TraitItemType : public TraitItem\n     outer_attrs = other.outer_attrs;\n     name = other.name;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -3092,7 +3133,7 @@ class TraitImpl : public Impl\n {\n   bool has_unsafe;\n   bool has_exclam;\n-  TypePath trait_path;\n+  std::unique_ptr<Type> trait_path;\n \n   // bool has_impl_items;\n   std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n@@ -3104,7 +3145,7 @@ class TraitImpl : public Impl\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n   // Mega-constructor\n-  TraitImpl (Analysis::NodeMapping mappings, TypePath trait_path,\n+  TraitImpl (Analysis::NodeMapping mappings, std::unique_ptr<Type> trait_path,\n \t     bool is_unsafe, bool has_exclam,\n \t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n \t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n@@ -3123,7 +3164,8 @@ class TraitImpl : public Impl\n   // Copy constructor with vector clone\n   TraitImpl (TraitImpl const &other)\n     : Impl (other), has_unsafe (other.has_unsafe),\n-      has_exclam (other.has_exclam), trait_path (other.trait_path)\n+      has_exclam (other.has_exclam),\n+      trait_path (other.trait_path->clone_type ())\n   {\n     impl_items.reserve (other.impl_items.size ());\n     for (const auto &e : other.impl_items)\n@@ -3134,7 +3176,7 @@ class TraitImpl : public Impl\n   TraitImpl &operator= (TraitImpl const &other)\n   {\n     Impl::operator= (other);\n-    trait_path = other.trait_path;\n+    trait_path = other.trait_path->clone_type ();\n     has_unsafe = other.has_unsafe;\n     has_exclam = other.has_exclam;\n "}, {"sha": "0cc9d0803ee679f486d749af3993a9ec14f219b6", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -770,29 +770,18 @@ class MacroItem : public Item\n // Item used in trait declarations - abstract base class\n class TraitItem\n {\n-  // bool has_outer_attrs;\n-  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-  // std::vector<Attribute> outer_attrs;\n-\n-  // NOTE: all children should have outer attributes\n-\n protected:\n   // Constructor\n-  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n-    : outer_attrs(std::move(outer_attrs)) {}*/\n+  TraitItem (Analysis::NodeMapping mappings) : mappings (mappings) {}\n \n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n \n+  Analysis::NodeMapping mappings;\n+\n public:\n   virtual ~TraitItem () {}\n \n-  // Returns whether TraitItem has outer attributes.\n-  /*bool has_outer_attrs() const {\n-      return !outer_attrs.empty();\n-  }*/\n-\n-  // Unique pointer custom clone function\n   std::unique_ptr<TraitItem> clone_trait_item () const\n   {\n     return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n@@ -801,6 +790,8 @@ class TraitItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n };\n \n /* Abstract base class for items used within an inherent impl block (the impl\n@@ -847,6 +838,10 @@ class TraitImplItem\n   virtual std::string as_string () const = 0;\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_trait_impl_mappings () const = 0;\n+\n+  virtual Location get_trait_impl_locus () const = 0;\n };\n \n // A crate HIR object - holds all the data for a single compilation unit"}, {"sha": "576cd3e585dd47eb0f2f168dcc7ca171e7017b8f", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -37,6 +37,12 @@ class ResolveToplevelImplItem : public ResolverBase\n     item->accept_vis (resolver);\n   }\n \n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix)\n+  {\n+    ResolveToplevelImplItem resolver (prefix);\n+    item->accept_vis (resolver);\n+  }\n+\n   void visit (AST::ConstantItem &constant) override\n   {\n     auto path\n@@ -95,6 +101,90 @@ class ResolveToplevelImplItem : public ResolverBase\n   const CanonicalPath &prefix;\n };\n \n+class ResolveTopLevelTraitItems : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::TraitItem *item,\n+\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  {\n+    ResolveTopLevelTraitItems resolver (prefix);\n+    item->accept_vis (resolver);\n+  };\n+\n+  void visit (AST::TraitItemFunc &function) override\n+  {\n+    auto path = prefix.append (\n+      ResolveTraitItemFunctionToCanonicalPath::resolve (function));\n+    resolver->get_name_scope ().insert (\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (function.get_node_id (),\n+\t\t\t\t     Definition{function.get_node_id (),\n+\t\t\t\t\t\tfunction.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemMethod &method) override\n+  {\n+    auto path\n+      = prefix.append (ResolveTraitItemMethodToCanonicalPath::resolve (method));\n+    resolver->get_name_scope ().insert (\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (method.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (method.get_node_id (),\n+\t\t\t\t     Definition{method.get_node_id (),\n+\t\t\t\t\t\tmethod.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    auto path = prefix.append (\n+      ResolveTraitItemConstToCanonicalPath::resolve (constant));\n+    resolver->get_name_scope ().insert (\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (constant.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (constant.get_node_id (),\n+\t\t\t\t     Definition{constant.get_node_id (),\n+\t\t\t\t\t\tconstant.get_node_id ()});\n+  }\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    auto path\n+      = prefix.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    resolver->get_name_scope ().insert (\n+      path, type.get_node_id (), type.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (type.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+    resolver->insert_new_definition (type.get_node_id (),\n+\t\t\t\t     Definition{type.get_node_id (),\n+\t\t\t\t\t\ttype.get_node_id ()});\n+  }\n+\n+private:\n+  ResolveTopLevelTraitItems (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "38003505ef914b957922d8a9c9a511b1311b88cf", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -259,6 +259,133 @@ class ResolveItem : public ResolverBase\n     resolver->get_label_scope ().pop ();\n   }\n \n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    NodeId scope_node_id = impl_block.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (impl_block.has_generics ())\n+      {\n+\tfor (auto &generic : impl_block.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t  }\n+      }\n+\n+    bool canonicalize_type_with_generics = false;\n+    NodeId trait_resolved_node\n+      = ResolveType::go (&impl_block.get_trait_path (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics);\n+    if (trait_resolved_node == UNKNOWN_NODEID)\n+      {\n+\tresolver->get_type_scope ().pop ();\n+\treturn;\n+      }\n+\n+    NodeId type_resolved_node\n+      = ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics);\n+    if (type_resolved_node == UNKNOWN_NODEID)\n+      {\n+\tresolver->get_type_scope ().pop ();\n+\treturn;\n+      }\n+\n+    resolver->get_type_scope ().insert (\n+      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id (),\n+      impl_block.get_type ()->get_locus_slow ());\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      impl_item->accept_vis (*this);\n+\n+    resolver->get_type_scope ().peek ()->clear_name (\n+      CanonicalPath::get_big_self (), impl_block.get_type ()->get_node_id ());\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::Trait &trait) override\n+  {\n+    NodeId scope_node_id = trait.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    // TODO\n+    // we need to inject an implicit self TypeParam here\n+    // see: https://doc.rust-lang.org/reference/items/traits.html\n+\n+    if (trait.has_generics ())\n+      {\n+\tfor (auto &generic : trait.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n+\t  }\n+      }\n+\n+    for (auto &item : trait.get_trait_items ())\n+      item->accept_vis (*this);\n+\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n+\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n+  }\n+\n+  void visit (AST::TraitItemMethod &) override\n+  {\n+    // TODO\n+  }\n+\n+  void visit (AST::TraitItemConst &) override\n+  {\n+    // TODO\n+  }\n+\n+  void visit (AST::TraitItemType &) override\n+  {\n+    // TODO\n+  }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "089322461d5486678299aec6c8b1d578363ef2d1", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -41,9 +41,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::TypeAlias &alias) override\n   {\n+    auto path = prefix.append (CanonicalPath (alias.get_new_type_name ()));\n     resolver->get_type_scope ().insert (\n-      CanonicalPath (alias.get_new_type_name ()), alias.get_node_id (),\n-      alias.get_locus (), false,\n+      path, alias.get_node_id (), alias.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (alias.get_locus ());\n \tr.add_range (locus);\n@@ -53,9 +53,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n+    auto path = prefix.append (CanonicalPath (struct_decl.get_identifier ()));\n     resolver->get_type_scope ().insert (\n-      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n-      struct_decl.get_locus (), false,\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -65,9 +65,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n+    auto path = prefix.append (CanonicalPath (struct_decl.get_identifier ()));\n     resolver->get_type_scope ().insert (\n-      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n-      struct_decl.get_locus (), false,\n+      path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n@@ -77,9 +77,9 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::StaticItem &var) override\n   {\n+    auto path = prefix.append (CanonicalPath (var.get_identifier ()));\n     resolver->get_name_scope ().insert (\n-      CanonicalPath (var.get_identifier ()), var.get_node_id (),\n-      var.get_locus (), false,\n+      path, var.get_node_id (), var.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (var.get_locus ());\n \tr.add_range (locus);\n@@ -145,6 +145,36 @@ class ResolveTopLevel : public ResolverBase\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }\n \n+  void visit (AST::TraitImpl &impl_block) override\n+  {\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+  }\n+\n+  void visit (AST::Trait &trait) override\n+  {\n+    CanonicalPath path\n+      = prefix.append (CanonicalPath (trait.get_identifier ()));\n+    resolver->get_type_scope ().insert (\n+      path, trait.get_node_id (), trait.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (trait.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n+\n+    for (auto &item : trait.get_trait_items ())\n+      ResolveTopLevelTraitItems::go (item.get ());\n+  }\n+\n private:\n   ResolveTopLevel (const CanonicalPath &prefix)\n     : ResolverBase (UNKNOWN_NODEID), prefix (prefix)"}, {"sha": "05b347c3fca1376ed7b510d7fca0806b6428d6d7", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -52,6 +52,43 @@ class ResolveMethodItemToCanonicalPath\n   }\n };\n \n+class ResolveTraitItemFunctionToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemFunc &function)\n+  {\n+    return CanonicalPath (\n+      function.get_trait_function_decl ().get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemMethodToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemMethod &method)\n+  {\n+    return CanonicalPath (method.get_trait_method_decl ().get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemConstToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemConst &constant)\n+  {\n+    return CanonicalPath (constant.get_identifier ());\n+  }\n+};\n+\n+class ResolveTraitItemTypeToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::TraitItemType &type)\n+  {\n+    return CanonicalPath (type.get_identifier ());\n+  }\n+};\n+\n class ResolveTypeToCanonicalPath : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;"}, {"sha": "f97c97b1d930c750e0fdd92ad5dc76bdd559d700", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -41,6 +41,9 @@\n     }                                                                          \\\n   while (0)\n \n+extern bool\n+saw_errors (void);\n+\n namespace Rust {\n namespace Resolver {\n \n@@ -322,6 +325,9 @@ NameResolution::go (AST::Crate &crate)\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveTopLevel::go (it->get ());\n \n+  if (saw_errors ())\n+    return;\n+\n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveItem::go (it->get ());"}, {"sha": "bed89b859228c004ce862c49da5cf9953bfb02a5", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -41,6 +41,14 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  static void\n+  Resolve (HIR::TraitImplItem *item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+  {\n+    TypeCheckTopLevelImplItem resolver (self, substitutions);\n+    item->accept_vis (resolver);\n+  }\n+\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n@@ -219,6 +227,12 @@ class TypeCheckImplItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n+  static void Resolve (HIR::TraitImplItem *item, TyTy::BaseType *self)\n+  {\n+    TypeCheckImplItem resolver (self);\n+    item->accept_vis (resolver);\n+  }\n+\n   void visit (HIR::Function &function) override\n   {\n     TyTy::BaseType *lookup;"}, {"sha": "47d9a8accf71c184274547ef4283959d51beb626", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -55,6 +55,21 @@ class TypeCheckItem : public TypeCheckBase\n       TypeCheckImplItem::Resolve (impl_item.get (), self);\n   }\n \n+  void visit (HIR::TraitImpl &impl_block) override\n+  {\n+    TyTy::BaseType *self = nullptr;\n+    if (!context->lookup_type (\n+\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n+      {\n+\trust_error_at (impl_block.get_locus (),\n+\t\t       \"failed to resolve Self for TraitImpl\");\n+\treturn;\n+      }\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      TypeCheckImplItem::Resolve (impl_item.get (), self);\n+  }\n+\n   void visit (HIR::Function &function) override\n   {\n     TyTy::BaseType *lookup;"}, {"sha": "3ec231f631fb1d828cb097f6c2da20a6ed9e95d6", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -273,6 +273,47 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t\t\t  substitutions);\n   }\n \n+  void visit (HIR::TraitImpl &impl_block) override\n+  {\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    if (impl_block.has_generics ())\n+      {\n+\tfor (auto &generic_param : impl_block.get_generic_params ())\n+\t  {\n+\t    switch (generic_param.get ()->get_kind ())\n+\t      {\n+\t      case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t// Skipping Lifetime completely until better handling.\n+\t\tbreak;\n+\n+\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n+\t\t  auto param_type\n+\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t\t  context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\tparam_type);\n+\n+\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n+\t\t    param_type));\n+\t\t}\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+    // TODO\n+    // resolve the trait and check all items implemented\n+\n+    auto self\n+      = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n+    if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self,\n+\t\t\t\t\t  substitutions);\n+  }\n+\n private:\n   TypeCheckTopLevel () : TypeCheckBase () {}\n };"}, {"sha": "18e2779baf2f80bb7c3b41899ebcbe6a50722783", "filename": "gcc/testsuite/rust/compile/torture/traits1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits1.rs?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -0,0 +1,17 @@\n+trait Foo {\n+    fn bar() -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct Test(i32, f32);\n+\n+impl Foo for Test {\n+    fn bar() -> i32 {\n+        123\n+    }\n+}\n+\n+fn main() {\n+    let a: i32;\n+    a = Test::bar();\n+}"}, {"sha": "6df369de59a5ee201bdf6693bf1d81656e731e89", "filename": "gcc/testsuite/rust/compile/torture/traits2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfbd8f9e00eab447c666f2e28cef2826fab88f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits2.rs?ref=fcfbd8f9e00eab447c666f2e28cef2826fab88f2", "patch": "@@ -0,0 +1,17 @@\n+trait Foo {\n+    fn bar() -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct Test<T>(T);\n+\n+impl<T> Foo for Test<T> {\n+    fn bar() -> i32 {\n+        123\n+    }\n+}\n+\n+fn main() {\n+    let a: i32;\n+    a = Test::<i32>::bar();\n+}"}]}