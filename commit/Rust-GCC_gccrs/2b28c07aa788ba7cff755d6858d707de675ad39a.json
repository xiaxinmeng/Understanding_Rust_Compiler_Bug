{"sha": "2b28c07aa788ba7cff755d6858d707de675ad39a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIyOGMwN2FhNzg4YmE3Y2ZmNzU1ZDY4NThkNzA3ZGU2NzVhZDM5YQ==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2007-05-04T18:08:06Z"}, "committer": {"name": "Josh Conner", "email": "jconner@gcc.gnu.org", "date": "2007-05-04T18:08:06Z"}, "message": "basic-block.h (cdi_direction): Assign values to all enumeration constants.\n\n2007-05-04  Josh Conner  <jconner@apple.com>\n\n\t* basic-block.h (cdi_direction): Assign values to all enumeration\n\tconstants.\n\t(dom_computed): Remove.\n\t(dom_info_state): New.\n\t(set_dom_info_availability): New.\n\t* tree-ssa-loop-im.c (determine_invariantness): Initialize\n\twalk_data.dom_direction.\n\t* cfghooks.c (delete_basic_block): Use dom_info_available_p()\n\tinstead of dom_computed[].\n\t(split_edge): Likewise.\n\t(create_basic_block): Likewise.\n\t(merge_blocks): Likewise.\n\t* ifcvt.c (find_if_header): Likewise.\n\t* tree-cfgcleanup.c (cleanup_tree_cfg): Likewise.\n\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n\t* tree-ssa.c (verify_ssa): Likewise.\n\t* tree-cfg.c (tree_verify_flow_info): Likewise.\n\t(remove_edge_and_dominated_blocks): Likewise.\n\t* dominance.c (dom_computed): Make static.\n\t(calc_dfs_tree_nonrec): Change third param to a bool.\n\t(calc_dfs_tree): Change second param to a bool.\n\t(calc_idioms): Change second param to a bool.  Use\n\tdom_convert_dir_to_idx.\n\t(init_dom_info): Validate dir before using.\n\t(dom_convert_dir_to_idx): New.\n\t(calculate_dominance_info): Use dom_convert_dir_to_idx.  New\n\tvariable 'reverse' used for calling calc_dfs_tree and calc_idoms.\n\t(free_dominance_info): Use dom_convert_dir_to_idx.\n\t(get_immediate_dominator): Likewise.\n\t(set_immediate_dominator): Likewise.\n\t(get_dominated_by): Likewise.\n\t(redirect_immediate_dominators): Likewise.\n\t(nearest_common_denominator): Likewise.\n\t(dominated_by_p): Likewise.\n\t(bb_dom_dfs_in): Likewise.\n\t(bb_dom_dfs_out): Likewise.\n\t(recount_dominator): Likewise.\n\t(iterate_fix_dominators): Likewise.\n\t(add_to_dominance_info): Likewise.\n\t(delete_from_dominance_info): Likewise.\n\t(first_dom_son): Likewise.\n\t(next_dom_son): Likewise.\n\t(dom_info_available_p): Likewise.\n\t(dom_info_state): New.\n\t(set_dom_info_availability): New.\n\nFrom-SVN: r124439", "tree": {"sha": "5c6fa079d68d275f0a55181d36fa6087b1b38780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c6fa079d68d275f0a55181d36fa6087b1b38780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b28c07aa788ba7cff755d6858d707de675ad39a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b28c07aa788ba7cff755d6858d707de675ad39a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b28c07aa788ba7cff755d6858d707de675ad39a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b28c07aa788ba7cff755d6858d707de675ad39a/comments", "author": null, "committer": null, "parents": [{"sha": "acb8a4ef2dc4120ef9e03885e58138d58db192b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb8a4ef2dc4120ef9e03885e58138d58db192b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb8a4ef2dc4120ef9e03885e58138d58db192b4"}], "stats": {"total": 295, "additions": 206, "deletions": 89}, "files": [{"sha": "dd4beb2ad42474040257ab19026176aabf3b6a30", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -1,3 +1,51 @@\n+2007-05-04  Josh Conner  <jconner@apple.com>\n+\n+\t* basic-block.h (cdi_direction): Assign values to all enumeration\n+\tconstants.\n+\t(dom_computed): Remove.\n+\t(dom_info_state): New.\n+\t(set_dom_info_availability): New.\n+\t* tree-ssa-loop-im.c (determine_invariantness): Initialize\n+\twalk_data.dom_direction.\n+\t* cfghooks.c (delete_basic_block): Use dom_info_available_p()\n+\tinstead of dom_computed[].\n+\t(split_edge): Likewise.\n+\t(create_basic_block): Likewise.\n+\t(merge_blocks): Likewise.\n+\t* ifcvt.c (find_if_header): Likewise.\n+\t* tree-cfgcleanup.c (cleanup_tree_cfg): Likewise.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n+\t* tree-ssa.c (verify_ssa): Likewise.\n+\t* tree-cfg.c (tree_verify_flow_info): Likewise.\n+\t(remove_edge_and_dominated_blocks): Likewise.\n+\t* dominance.c (dom_computed): Make static.\n+\t(calc_dfs_tree_nonrec): Change third param to a bool.\n+\t(calc_dfs_tree): Change second param to a bool.\n+\t(calc_idioms): Change second param to a bool.  Use\n+\tdom_convert_dir_to_idx.\n+\t(init_dom_info): Validate dir before using.\n+\t(dom_convert_dir_to_idx): New.\n+\t(calculate_dominance_info): Use dom_convert_dir_to_idx.  New\n+\tvariable 'reverse' used for calling calc_dfs_tree and calc_idoms.\n+\t(free_dominance_info): Use dom_convert_dir_to_idx.\n+\t(get_immediate_dominator): Likewise.\n+\t(set_immediate_dominator): Likewise.\n+\t(get_dominated_by): Likewise.\n+\t(redirect_immediate_dominators): Likewise.\n+\t(nearest_common_denominator): Likewise.\n+\t(dominated_by_p): Likewise.\n+\t(bb_dom_dfs_in): Likewise.\n+\t(bb_dom_dfs_out): Likewise.\n+\t(recount_dominator): Likewise.\n+\t(iterate_fix_dominators): Likewise.\n+\t(add_to_dominance_info): Likewise.\n+\t(delete_from_dominance_info): Likewise.\n+\t(first_dom_son): Likewise.\n+\t(next_dom_son): Likewise.\n+\t(dom_info_available_p): Likewise.\n+\t(dom_info_state): New.\n+\t(set_dom_info_availability): New.\n+\n 2007-05-04  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md (\"fix_trunc<mode>di2\", \"fix_trunc<mode>si2\"):"}, {"sha": "6286a5d1ed72cb0935b41f3ff1a0f5e28643e9d1", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -936,8 +936,8 @@ extern void reorder_basic_blocks (void);\n \n enum cdi_direction\n {\n-  CDI_DOMINATORS,\n-  CDI_POST_DOMINATORS\n+  CDI_DOMINATORS = 1,\n+  CDI_POST_DOMINATORS = 2\n };\n \n enum dom_state\n@@ -947,8 +947,8 @@ enum dom_state\n   DOM_OK\t\t/* Everything is ok.  */\n };\n \n-extern enum dom_state dom_computed[2];\n-\n+extern enum dom_state dom_info_state (enum cdi_direction);\n+extern void set_dom_info_availability (enum cdi_direction, enum dom_state);\n extern bool dom_info_available_p (enum cdi_direction);\n extern void calculate_dominance_info (enum cdi_direction);\n extern void free_dominance_info (enum cdi_direction);"}, {"sha": "9e2eae75d492754164c507065f0e9d5d857f36ae", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -486,9 +486,9 @@ delete_basic_block (basic_block bb)\n   while (EDGE_COUNT (bb->succs) != 0)\n     remove_edge (EDGE_SUCC (bb, 0));\n \n-  if (dom_computed[CDI_DOMINATORS])\n+  if (dom_info_available_p (CDI_DOMINATORS))\n     delete_from_dominance_info (CDI_DOMINATORS, bb);\n-  if (dom_computed[CDI_POST_DOMINATORS])\n+  if (dom_info_available_p (CDI_POST_DOMINATORS))\n     delete_from_dominance_info (CDI_POST_DOMINATORS, bb);\n \n   /* Remove the basic block from the array.  */\n@@ -527,10 +527,10 @@ split_edge (edge e)\n       single_succ_edge (ret)->flags |= EDGE_IRREDUCIBLE_LOOP;\n     }\n \n-  if (dom_computed[CDI_DOMINATORS])\n+  if (dom_info_available_p (CDI_DOMINATORS))\n     set_immediate_dominator (CDI_DOMINATORS, ret, single_pred (ret));\n \n-  if (dom_computed[CDI_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+  if (dom_info_state (CDI_DOMINATORS) >= DOM_NO_FAST_QUERY)\n     {\n       /* There are two cases:\n \n@@ -586,9 +586,9 @@ create_basic_block (void *head, void *end, basic_block after)\n \n   ret = cfg_hooks->create_basic_block (head, end, after);\n \n-  if (dom_computed[CDI_DOMINATORS])\n+  if (dom_info_available_p (CDI_DOMINATORS))\n     add_to_dominance_info (CDI_DOMINATORS, ret);\n-  if (dom_computed[CDI_POST_DOMINATORS])\n+  if (dom_info_available_p (CDI_POST_DOMINATORS))\n     add_to_dominance_info (CDI_POST_DOMINATORS, ret);\n \n   return ret;\n@@ -676,12 +676,12 @@ merge_blocks (basic_block a, basic_block b)\n   /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n   b->preds = b->succs = NULL;\n \n-  if (dom_computed[CDI_DOMINATORS])\n+  if (dom_info_available_p (CDI_DOMINATORS))\n     redirect_immediate_dominators (CDI_DOMINATORS, b, a);\n \n-  if (dom_computed[CDI_DOMINATORS])\n+  if (dom_info_available_p (CDI_DOMINATORS))\n     delete_from_dominance_info (CDI_DOMINATORS, b);\n-  if (dom_computed[CDI_POST_DOMINATORS])\n+  if (dom_info_available_p (CDI_POST_DOMINATORS))\n     delete_from_dominance_info (CDI_POST_DOMINATORS, b);\n \n   expunge_block (b);"}, {"sha": "a9af9d52d15939adfebdabdfc4b57cfd82d5d854", "filename": "gcc/dominance.c", "status": "modified", "additions": 135, "deletions": 68, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -46,7 +46,7 @@\n #include \"timevar.h\"\n \n /* Whether the dominators and the postdominators are available.  */\n-enum dom_state dom_computed[2];\n+static enum dom_state dom_computed[2];\n \n /* We name our nodes with integers, beginning with 1.  Zero is reserved for\n    'undefined' or 'end of list'.  The name of each node is given by the dfs\n@@ -114,13 +114,12 @@ struct dom_info\n \n static void init_dom_info (struct dom_info *, enum cdi_direction);\n static void free_dom_info (struct dom_info *);\n-static void calc_dfs_tree_nonrec (struct dom_info *, basic_block,\n-\t\t\t\t  enum cdi_direction);\n-static void calc_dfs_tree (struct dom_info *, enum cdi_direction);\n+static void calc_dfs_tree_nonrec (struct dom_info *, basic_block, bool);\n+static void calc_dfs_tree (struct dom_info *, bool);\n static void compress (struct dom_info *, TBB);\n static TBB eval (struct dom_info *, TBB);\n static void link_roots (struct dom_info *, TBB, TBB);\n-static void calc_idoms (struct dom_info *, enum cdi_direction);\n+static void calc_idoms (struct dom_info *, bool);\n void debug_dominance_info (enum cdi_direction);\n \n /* Keeps track of the*/\n@@ -168,11 +167,34 @@ init_dom_info (struct dom_info *di, enum cdi_direction dir)\n   di->dfsnum = 1;\n   di->nodes = 0;\n \n-  di->fake_exit_edge = dir ? BITMAP_ALLOC (NULL) : NULL;\n+  switch (dir)\n+    {\n+      case CDI_DOMINATORS:\n+\tdi->fake_exit_edge = NULL;\n+\tbreak;\n+      case CDI_POST_DOMINATORS:\n+\tdi->fake_exit_edge = BITMAP_ALLOC (NULL);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+    }\n }\n \n #undef init_ar\n \n+/* Map dominance calculation type to array index used for various\n+   dominance information arrays.  This version is simple -- it will need\n+   to be modified, obviously, if additional values are added to\n+   cdi_direction.  */\n+\n+static unsigned int\n+dom_convert_dir_to_idx (enum cdi_direction dir)\n+{\n+  gcc_assert (dir == CDI_DOMINATORS || dir == CDI_POST_DOMINATORS);\n+  return dir - 1;\n+}\n+\n /* Free all allocated memory in DI, but not DI itself.  */\n \n static void\n@@ -199,8 +221,7 @@ free_dom_info (struct dom_info *di)\n    assigned their dfs number and are linked together to form a tree.  */\n \n static void\n-calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n-\t\t      enum cdi_direction reverse)\n+calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, bool reverse)\n {\n   /* We call this _only_ if bb is not already visited.  */\n   edge e;\n@@ -311,7 +332,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n    because there may be nodes from which the EXIT_BLOCK is unreachable.  */\n \n static void\n-calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n+calc_dfs_tree (struct dom_info *di, bool reverse)\n {\n   /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n   basic_block begin = reverse ? EXIT_BLOCK_PTR : ENTRY_BLOCK_PTR;\n@@ -471,7 +492,7 @@ link_roots (struct dom_info *di, TBB v, TBB w)\n    On return the immediate dominator to node V is in di->dom[V].  */\n \n static void\n-calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n+calc_idoms (struct dom_info *di, bool reverse)\n {\n   TBB v, w, k, par;\n   basic_block en_block;\n@@ -590,19 +611,20 @@ compute_dom_fast_query (enum cdi_direction dir)\n {\n   int num = 0;\n   basic_block bb;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n   gcc_assert (dom_info_available_p (dir));\n \n-  if (dom_computed[dir] == DOM_OK)\n+  if (dom_computed[dir_index] == DOM_OK)\n     return;\n \n   FOR_ALL_BB (bb)\n     {\n-      if (!bb->dom[dir]->father)\n-\tassign_dfs_numbers (bb->dom[dir], &num);\n+      if (!bb->dom[dir_index]->father)\n+\tassign_dfs_numbers (bb->dom[dir_index], &num);\n     }\n \n-  dom_computed[dir] = DOM_OK;\n+  dom_computed[dir_index] = DOM_OK;\n }\n \n /* The main entry point into this module.  DIR is set depending on whether\n@@ -613,35 +635,37 @@ calculate_dominance_info (enum cdi_direction dir)\n {\n   struct dom_info di;\n   basic_block b;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  bool reverse = (dir == CDI_POST_DOMINATORS) ? true : false;\n \n-  if (dom_computed[dir] == DOM_OK)\n+  if (dom_computed[dir_index] == DOM_OK)\n     return;\n \n   timevar_push (TV_DOMINANCE);\n   if (!dom_info_available_p (dir))\n     {\n-      gcc_assert (!n_bbs_in_dom_tree[dir]);\n+      gcc_assert (!n_bbs_in_dom_tree[dir_index]);\n \n       FOR_ALL_BB (b)\n \t{\n-\t  b->dom[dir] = et_new_tree (b);\n+\t  b->dom[dir_index] = et_new_tree (b);\n \t}\n-      n_bbs_in_dom_tree[dir] = n_basic_blocks;\n+      n_bbs_in_dom_tree[dir_index] = n_basic_blocks;\n \n       init_dom_info (&di, dir);\n-      calc_dfs_tree (&di, dir);\n-      calc_idoms (&di, dir);\n+      calc_dfs_tree (&di, reverse);\n+      calc_idoms (&di, reverse);\n \n       FOR_EACH_BB (b)\n \t{\n \t  TBB d = di.dom[di.dfs_order[b->index]];\n \n \t  if (di.dfs_to_bb[d])\n-\t    et_set_father (b->dom[dir], di.dfs_to_bb[d]->dom[dir]);\n+\t    et_set_father (b->dom[dir_index], di.dfs_to_bb[d]->dom[dir_index]);\n \t}\n \n       free_dom_info (&di);\n-      dom_computed[dir] = DOM_NO_FAST_QUERY;\n+      dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n     }\n \n   compute_dom_fast_query (dir);\n@@ -654,29 +678,31 @@ void\n free_dominance_info (enum cdi_direction dir)\n {\n   basic_block bb;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n   if (!dom_info_available_p (dir))\n     return;\n \n   FOR_ALL_BB (bb)\n     {\n-      et_free_tree_force (bb->dom[dir]);\n-      bb->dom[dir] = NULL;\n+      et_free_tree_force (bb->dom[dir_index]);\n+      bb->dom[dir_index] = NULL;\n     }\n   et_free_pools ();\n \n-  n_bbs_in_dom_tree[dir] = 0;\n+  n_bbs_in_dom_tree[dir_index] = 0;\n \n-  dom_computed[dir] = DOM_NONE;\n+  dom_computed[dir_index] = DOM_NONE;\n }\n \n /* Return the immediate dominator of basic block BB.  */\n basic_block\n get_immediate_dominator (enum cdi_direction dir, basic_block bb)\n {\n-  struct et_node *node = bb->dom[dir];\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *node = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir]);\n+  gcc_assert (dom_computed[dir_index]);\n \n   if (!node->father)\n     return NULL;\n@@ -690,9 +716,10 @@ inline void\n set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n \t\t\t basic_block dominated_by)\n {\n-  struct et_node *node = bb->dom[dir];\n-\n-  gcc_assert (dom_computed[dir]);\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *node = bb->dom[dir_index];\n+ \n+  gcc_assert (dom_computed[dir_index]);\n \n   if (node->father)\n     {\n@@ -702,21 +729,22 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n     }\n \n   if (dominated_by)\n-    et_set_father (node, dominated_by->dom[dir]);\n+    et_set_father (node, dominated_by->dom[dir_index]);\n \n-  if (dom_computed[dir] == DOM_OK)\n-    dom_computed[dir] = DOM_NO_FAST_QUERY;\n+  if (dom_computed[dir_index] == DOM_OK)\n+    dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n }\n \n /* Store all basic blocks immediately dominated by BB into BBS and return\n    their number.  */\n int\n get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n {\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   int n;\n-  struct et_node *node = bb->dom[dir], *son = node->son, *ason;\n-\n-  gcc_assert (dom_computed[dir]);\n+  struct et_node *node = bb->dom[dir_index], *son = node->son, *ason;\n+ \n+  gcc_assert (dom_computed[dir_index]);\n \n   if (!son)\n     {\n@@ -766,9 +794,13 @@ void\n redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n \t\t\t       basic_block to)\n {\n-  struct et_node *bb_node = bb->dom[dir], *to_node = to->dom[dir], *son;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *bb_node, *to_node, *son;\n+ \n+  bb_node = bb->dom[dir_index];\n+  to_node = to->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir]);\n+  gcc_assert (dom_computed[dir_index]);\n \n   if (!bb_node->son)\n     return;\n@@ -781,22 +813,24 @@ redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n       et_set_father (son, to_node);\n     }\n \n-  if (dom_computed[dir] == DOM_OK)\n-    dom_computed[dir] = DOM_NO_FAST_QUERY;\n+  if (dom_computed[dir_index] == DOM_OK)\n+    dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n }\n \n /* Find first basic block in the tree dominating both BB1 and BB2.  */\n basic_block\n nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n {\n-  gcc_assert (dom_computed[dir]);\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  gcc_assert (dom_computed[dir_index]);\n \n   if (!bb1)\n     return bb2;\n   if (!bb2)\n     return bb1;\n \n-  return et_nca (bb1->dom[dir], bb2->dom[dir])->data;\n+  return et_nca (bb1->dom[dir_index], bb2->dom[dir_index])->data;\n }\n \n \n@@ -898,11 +932,12 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n bool\n dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n { \n-  struct et_node *n1 = bb1->dom[dir], *n2 = bb2->dom[dir];\n-\n-  gcc_assert (dom_computed[dir]);\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *n1 = bb1->dom[dir_index], *n2 = bb2->dom[dir_index];\n+ \n+  gcc_assert (dom_computed[dir_index]);\n \n-  if (dom_computed[dir] == DOM_OK)\n+  if (dom_computed[dir_index] == DOM_OK)\n     return (n1->dfs_num_in >= n2->dfs_num_in\n   \t    && n1->dfs_num_out <= n2->dfs_num_out);\n \n@@ -914,9 +949,10 @@ dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n unsigned\n bb_dom_dfs_in (enum cdi_direction dir, basic_block bb)\n {\n-  struct et_node *n = bb->dom[dir];\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *n = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir] == DOM_OK);\n+  gcc_assert (dom_computed[dir_index] == DOM_OK);\n   return n->dfs_num_in;\n }\n \n@@ -925,9 +961,10 @@ bb_dom_dfs_in (enum cdi_direction dir, basic_block bb)\n unsigned\n bb_dom_dfs_out (enum cdi_direction dir, basic_block bb)\n {\n-  struct et_node *n = bb->dom[dir];\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *n = bb->dom[dir_index];\n \n-  gcc_assert (dom_computed[dir] == DOM_OK);\n+  gcc_assert (dom_computed[dir_index] == DOM_OK);\n   return n->dfs_num_out;\n }\n \n@@ -981,11 +1018,12 @@ verify_dominators (enum cdi_direction dir)\n basic_block\n recount_dominator (enum cdi_direction dir, basic_block bb)\n {\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   basic_block dom_bb = NULL;\n   edge e;\n   edge_iterator ei;\n \n-  gcc_assert (dom_computed[dir]);\n+  gcc_assert (dom_computed[dir_index]);\n \n   if (dir == CDI_DOMINATORS)\n     {\n@@ -1017,10 +1055,11 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n void\n iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n {\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   int i, changed = 1;\n   basic_block old_dom, new_dom;\n \n-  gcc_assert (dom_computed[dir]);\n+  gcc_assert (dom_computed[dir_index]);\n \n   for (i = 0; i < n; i++)\n     set_immediate_dominator (dir, bbs[i], NULL);\n@@ -1047,28 +1086,32 @@ iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n void\n add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n-  gcc_assert (dom_computed[dir]);\n-  gcc_assert (!bb->dom[dir]);\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  gcc_assert (dom_computed[dir_index]);\n+  gcc_assert (!bb->dom[dir_index]);\n \n-  n_bbs_in_dom_tree[dir]++;\n+  n_bbs_in_dom_tree[dir_index]++;\n   \n-  bb->dom[dir] = et_new_tree (bb);\n+  bb->dom[dir_index] = et_new_tree (bb);\n \n-  if (dom_computed[dir] == DOM_OK)\n-    dom_computed[dir] = DOM_NO_FAST_QUERY;\n+  if (dom_computed[dir_index] == DOM_OK)\n+    dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n }\n \n void\n delete_from_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n-  gcc_assert (dom_computed[dir]);\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n-  et_free_tree (bb->dom[dir]);\n-  bb->dom[dir] = NULL;\n-  n_bbs_in_dom_tree[dir]--;\n+  gcc_assert (dom_computed[dir_index]);\n \n-  if (dom_computed[dir] == DOM_OK)\n-    dom_computed[dir] = DOM_NO_FAST_QUERY;\n+  et_free_tree (bb->dom[dir_index]);\n+  bb->dom[dir_index] = NULL;\n+  n_bbs_in_dom_tree[dir_index]--;\n+\n+  if (dom_computed[dir_index] == DOM_OK)\n+    dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n }\n \n /* Returns the first son of BB in the dominator or postdominator tree\n@@ -1077,7 +1120,8 @@ delete_from_dominance_info (enum cdi_direction dir, basic_block bb)\n basic_block\n first_dom_son (enum cdi_direction dir, basic_block bb)\n {\n-  struct et_node *son = bb->dom[dir]->son;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *son = bb->dom[dir_index]->son;\n \n   return son ? son->data : NULL;\n }\n@@ -1088,17 +1132,40 @@ first_dom_son (enum cdi_direction dir, basic_block bb)\n basic_block\n next_dom_son (enum cdi_direction dir, basic_block bb)\n {\n-  struct et_node *next = bb->dom[dir]->right;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  struct et_node *next = bb->dom[dir_index]->right;\n \n   return next->father->son == next ? NULL : next->data;\n }\n \n+/* Return dominance availability for dominance info DIR.  */\n+\n+enum dom_state\n+dom_info_state (enum cdi_direction dir)\n+{\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  return dom_computed[dir_index];\n+}\n+\n+/* Set the dominance availability for dominance info DIR to NEW_STATE.  */\n+\n+void\n+set_dom_info_availability (enum cdi_direction dir, enum dom_state new_state)\n+{\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  dom_computed[dir_index] = new_state;\n+}\n+\n /* Returns true if dominance information for direction DIR is available.  */\n \n bool\n dom_info_available_p (enum cdi_direction dir)\n {\n-  return dom_computed[dir] != DOM_NONE;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  return dom_computed[dir_index] != DOM_NONE;\n }\n \n void"}, {"sha": "64a897cc9edb15ac02a2d07f3cb4fceb36534296", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -2932,7 +2932,7 @@ find_if_header (basic_block test_bb, int pass)\n       && find_cond_trap (test_bb, then_edge, else_edge))\n     goto success;\n \n-  if (dom_computed[CDI_POST_DOMINATORS] >= DOM_NO_FAST_QUERY\n+  if (dom_info_state (CDI_POST_DOMINATORS) >= DOM_NO_FAST_QUERY\n       && (! HAVE_conditional_execution || reload_completed))\n     {\n       if (find_if_case_1 (test_bb, then_edge, else_edge))"}, {"sha": "0b0ed8675914fb5af09e48d0472ca4c2b6a7396e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -3865,7 +3865,7 @@ tree_verify_flow_info (void)\n \t}\n     }\n \n-  if (dom_computed[CDI_DOMINATORS] >= DOM_NO_FAST_QUERY)\n+  if (dom_info_state (CDI_DOMINATORS) >= DOM_NO_FAST_QUERY)\n     verify_dominators (CDI_DOMINATORS);\n \n   return err;\n@@ -5375,7 +5375,7 @@ remove_edge_and_dominated_blocks (edge e)\n   basic_block bb, dbb;\n   bitmap_iterator bi;\n \n-  if (!dom_computed[CDI_DOMINATORS])\n+  if (!dom_info_available_p (CDI_DOMINATORS))\n     {\n       remove_edge (e);\n       return;"}, {"sha": "1bf416ea76850411552dc8e10c00c27ff0ff0150", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -609,7 +609,7 @@ cleanup_tree_cfg (void)\n \n      If dominance information is available, there cannot be any unreachable\n      blocks.  */\n-  if (!dom_computed[CDI_DOMINATORS])\n+  if (!dom_info_available_p (CDI_DOMINATORS))\n     {\n       changed = delete_unreachable_blocks ();\n       calculate_dominance_info (CDI_DOMINATORS);\n@@ -624,7 +624,7 @@ cleanup_tree_cfg (void)\n \n   changed |= cleanup_tree_cfg_1 ();\n \n-  gcc_assert (dom_computed[CDI_DOMINATORS]);\n+  gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n   compact_blocks ();\n \n #ifdef ENABLE_CHECKING"}, {"sha": "381a3429e0728fff474888ff3789af847c20c01c", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -591,7 +591,7 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n       basic_block post_dom_bb;\n \n       /* The post dominance info has to be up-to-date.  */\n-      gcc_assert (dom_computed[CDI_POST_DOMINATORS] == DOM_OK);\n+      gcc_assert (dom_info_state (CDI_POST_DOMINATORS) == DOM_OK);\n       /* Get the immediate post dominator of bb.  */\n       post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n "}, {"sha": "1d0c4ade3032c0af30157b93bb5d64c0da62d0d5", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -794,6 +794,7 @@ determine_invariantness (void)\n   struct dom_walk_data walk_data;\n \n   memset (&walk_data, 0, sizeof (struct dom_walk_data));\n+  walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.before_dom_children_before_stmts = determine_invariantness_stmt;\n \n   init_walk_dominator_tree (&walk_data);\n@@ -864,6 +865,7 @@ move_computations (void)\n   struct dom_walk_data walk_data;\n \n   memset (&walk_data, 0, sizeof (struct dom_walk_data));\n+  walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.before_dom_children_before_stmts = move_computations_stmt;\n \n   init_walk_dominator_tree (&walk_data);"}, {"sha": "3dfc34f05b9a0b33dd7faa3c39153568c4d51666", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b28c07aa788ba7cff755d6858d707de675ad39a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=2b28c07aa788ba7cff755d6858d707de675ad39a", "patch": "@@ -606,7 +606,7 @@ verify_ssa (bool check_modified_stmt)\n   basic_block *definition_block = XCNEWVEC (basic_block, num_ssa_names);\n   ssa_op_iter iter;\n   tree op;\n-  enum dom_state orig_dom_state = dom_computed[CDI_DOMINATORS];\n+  enum dom_state orig_dom_state = dom_info_state (CDI_DOMINATORS);\n   bitmap names_defined_in_bb = BITMAP_ALLOC (NULL);\n \n   gcc_assert (!need_ssa_update_p ());\n@@ -747,7 +747,7 @@ verify_ssa (bool check_modified_stmt)\n   if (orig_dom_state == DOM_NONE)\n     free_dominance_info (CDI_DOMINATORS);\n   else\n-    dom_computed[CDI_DOMINATORS] = orig_dom_state;\n+    set_dom_info_availability (CDI_DOMINATORS, orig_dom_state);\n   \n   BITMAP_FREE (names_defined_in_bb);\n   timevar_pop (TV_TREE_SSA_VERIFY);"}]}