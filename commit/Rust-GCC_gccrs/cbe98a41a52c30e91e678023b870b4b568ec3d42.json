{"sha": "cbe98a41a52c30e91e678023b870b4b568ec3d42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JlOThhNDFhNTJjMzBlOTFlNjc4MDIzYjg3MGI0YjU2OGVjM2Q0Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-25T05:37:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-25T05:37:48Z"}, "message": "Implement new order of assignment rules.\n\nIn \"i, x[i] = 1, 2\" the assigment to x[i] must use the value\nof i from before the assignment statement.\n\nFrom-SVN: r180421", "tree": {"sha": "10a760f788e4ae33c7cd6ceccd1aa5268973236d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10a760f788e4ae33c7cd6ceccd1aa5268973236d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbe98a41a52c30e91e678023b870b4b568ec3d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe98a41a52c30e91e678023b870b4b568ec3d42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe98a41a52c30e91e678023b870b4b568ec3d42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe98a41a52c30e91e678023b870b4b568ec3d42/comments", "author": null, "committer": null, "parents": [{"sha": "cbffbd59d6d26b87ea4414717c6659c28689981f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbffbd59d6d26b87ea4414717c6659c28689981f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbffbd59d6d26b87ea4414717c6659c28689981f"}], "stats": {"total": 105, "additions": 103, "deletions": 2}, "files": [{"sha": "180279efac65b3764f6efac1688778057767a22f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=cbe98a41a52c30e91e678023b870b4b568ec3d42", "patch": "@@ -3992,6 +3992,10 @@ class Unary_expression : public Expression\n \t\t\t\t  this->location());\n   }\n \n+  bool\n+  do_must_eval_subexpressions_in_order(int*) const\n+  { return this->op_ == OPERATOR_MULT; }\n+\n   bool\n   do_is_addressable() const\n   { return this->op_ == OPERATOR_MULT; }\n@@ -10036,6 +10040,13 @@ class Array_index_expression : public Expression\n \t\t\t\t\tthis->location());\n   }\n \n+  bool\n+  do_must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 1;\n+    return true;\n+  }\n+\n   bool\n   do_is_addressable() const;\n \n@@ -10461,6 +10472,13 @@ class String_index_expression : public Expression\n \t\t\t\t\t this->location());\n   }\n \n+  bool\n+  do_must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 1;\n+    return true;\n+  }\n+\n   tree\n   do_get_tree(Translate_context*);\n "}, {"sha": "a1f03c429fca40e55e039be1692ad634ad82ede0", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=cbe98a41a52c30e91e678023b870b4b568ec3d42", "patch": "@@ -582,6 +582,18 @@ class Expression\n   must_eval_in_order() const\n   { return this->do_must_eval_in_order(); }\n \n+  // Return whether subexpressions of this expression must be\n+  // evaluated in order.  This is true of index expressions and\n+  // pointer indirections.  This sets *SKIP to the number of\n+  // subexpressions to skip during traversing, as index expressions\n+  // only requiring moving the index, not the array.\n+  bool\n+  must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 0;\n+    return this->do_must_eval_subexpressions_in_order(skip);\n+  }\n+\n   // Return the tree for this expression.\n   tree\n   get_tree(Translate_context*);\n@@ -717,6 +729,13 @@ class Expression\n   do_must_eval_in_order() const\n   { return false; }\n \n+  // Child class implements whether this expressions requires that\n+  // subexpressions be evaluated in order.  The child implementation\n+  // may set *SKIP if it should be non-zero.\n+  virtual bool\n+  do_must_eval_subexpressions_in_order(int* /* skip */) const\n+  { return false; }\n+\n   // Child class implements conversion to tree.\n   virtual tree\n   do_get_tree(Translate_context*) = 0;\n@@ -1526,6 +1545,13 @@ class Index_expression : public Parser_expression\n \t\t\t\tthis->location());\n   }\n \n+  bool\n+  do_must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 1;\n+    return true;\n+  }\n+\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n@@ -1623,6 +1649,13 @@ class Map_index_expression : public Expression\n \t\t\t\t      this->location());\n   }\n \n+  bool\n+  do_must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 1;\n+    return true;\n+  }\n+\n   // A map index expression is an lvalue but it is not addressable.\n \n   tree"}, {"sha": "abc629e12c3ad4e2e8a6fcb727f36864ee43480d", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe98a41a52c30e91e678023b870b4b568ec3d42/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=cbe98a41a52c30e91e678023b870b4b568ec3d42", "patch": "@@ -652,6 +652,47 @@ Statement::make_assignment(Expression* lhs, Expression* rhs,\n   return new Assignment_statement(lhs, rhs, location);\n }\n \n+// The Move_subexpressions class is used to move all top-level\n+// subexpressions of an expression.  This is used for things like\n+// index expressions in which we must evaluate the index value before\n+// it can be changed by a multiple assignment.\n+\n+class Move_subexpressions : public Traverse\n+{\n+ public:\n+  Move_subexpressions(int skip, Block* block)\n+    : Traverse(traverse_expressions),\n+      skip_(skip), block_(block)\n+  { }\n+\n+ protected:\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The number of subexpressions to skip moving.  This is used to\n+  // avoid moving the array itself, as we only need to move the index.\n+  int skip_;\n+  // The block where new temporary variables should be added.\n+  Block* block_;\n+};\n+\n+int\n+Move_subexpressions::expression(Expression** pexpr)\n+{\n+  if (this->skip_ > 0)\n+    --this->skip_;\n+  else if ((*pexpr)->temporary_reference_expression() == NULL)\n+    {\n+      source_location loc = (*pexpr)->location();\n+      Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n+      this->block_->add_statement(temp);\n+      *pexpr = Expression::make_temporary_reference(temp, loc);\n+    }\n+  // We only need to move top-level subexpressions.\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n // The Move_ordered_evals class is used to find any subexpressions of\n // an expression that have an evaluation order dependency.  It creates\n // temporary variables to hold them.\n@@ -679,6 +720,15 @@ Move_ordered_evals::expression(Expression** pexpr)\n   // We have to look at subexpressions first.\n   if ((*pexpr)->traverse_subexpressions(this) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n+\n+  int i;\n+  if ((*pexpr)->must_eval_subexpressions_in_order(&i))\n+    {\n+      Move_subexpressions ms(i, this->block_);\n+      if ((*pexpr)->traverse_subexpressions(&ms) == TRAVERSE_EXIT)\n+\treturn TRAVERSE_EXIT;\n+    }\n+\n   if ((*pexpr)->must_eval_in_order())\n     {\n       source_location loc = (*pexpr)->location();\n@@ -901,10 +951,10 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n   // First move out any subexpressions on the left hand side.  The\n   // right hand side will be evaluated in the required order anyhow.\n   Move_ordered_evals moe(b);\n-  for (Expression_list::const_iterator plhs = this->lhs_->begin();\n+  for (Expression_list::iterator plhs = this->lhs_->begin();\n        plhs != this->lhs_->end();\n        ++plhs)\n-    (*plhs)->traverse_subexpressions(&moe);\n+    Expression::traverse(&*plhs, &moe);\n \n   std::vector<Temporary_statement*> temps;\n   temps.reserve(this->lhs_->size());"}]}