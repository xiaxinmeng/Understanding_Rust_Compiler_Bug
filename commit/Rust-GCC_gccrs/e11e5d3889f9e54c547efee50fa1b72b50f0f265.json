{"sha": "e11e5d3889f9e54c547efee50fa1b72b50f0f265", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTExZTVkMzg4OWY5ZTU0YzU0N2VmZWU1MGZhMWI3MmI1MGYwZjI2NQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-01-28T16:30:46Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-01-28T16:30:46Z"}, "message": "Map long double built-ins correctly with IEEE 128-bit long double.\n\nThe PowerPC has two different 128-bit long double types, one that uses a pair\nof doubles to get more mantissa range, and the other using the IEEE 128-bit\n754R binary floating point format.  The pair of doubles has been used as the\ntraditional format, and we are in the process of moving to allow an\nimplementation to switch to using IEEE 128-bit floating point.  The GLIBC and\nLIBSTDC++ libraries have been modified to have functions using the two\ndifferent formats in their libraries with different names.\n\nThis patch goes through all of the built-in functions that either take long\ndouble arguments or return long double, and changes the name from the\ntraditional name to the IEEE 128-bit name.  The minimum GLIBC version to\nsupport IEEE 128-bit floating point is 2.32.\n\nThe names changed are:\n\n    *\t<name>l is usually mapped to __<name>ieee128;\n    *\t<extra>printf is mapped to __<extra>printfieee128; (and)\n    *\t<extra>scanf is mapped to __isoc99_<extra>scanfieee128.\n\nA few functions have different mappings:\n\n    *\tdreml\t\t=> __remainderieee128;\n    *\tgammal\t\t=> __lgammaieee128;\n    *\tgammal_r\t=> __lgammaieee128_r;\n    *\tlgammal_r\t=> __lgammaieee128_r;\n    *\tnexttoward\t=> __nexttoward_to_ieee128;\n    *\tnexttowardf\t=> __nexttowardf_to_ieee128;\n    *\tnexttowardl\t=> __nexttowardl_to_ieee128;\n    *\tpow10l\t\t=> __exp10ieee128;\n    *\tscalbl\t\t=> __scalbieee128;\n    *\tsignificandl\t=> __significandieee128; (and)\n    *\tsincosl\t\t=> __sincosieee128.\n\ngcc/\n2021-01-28  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_mangle_decl_assembler_name): Add\n\tsupport for mapping built-in function names for long double\n\tbuilt-in functions if long double is IEEE 128-bit.\n\ngcc/testsuite/\n2021-01-28  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* gcc.target/powerpc/float128-longdouble-math.c: New test.\n\t* gcc.target/powerpc/float128-longdouble-stdio.c: New test.\n\t* gcc.target/powerpc/float128-math.c: Adjust test for new name\n\tbeing generated.  Add support for running test on power10.  Add\n\tsupport for running if long double defaults to 64-bits.", "tree": {"sha": "619107109b36ebadb39cbcfb7de2e9749753b0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/619107109b36ebadb39cbcfb7de2e9749753b0bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e11e5d3889f9e54c547efee50fa1b72b50f0f265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11e5d3889f9e54c547efee50fa1b72b50f0f265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e11e5d3889f9e54c547efee50fa1b72b50f0f265", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e11e5d3889f9e54c547efee50fa1b72b50f0f265/comments", "author": null, "committer": null, "parents": [{"sha": "6bb207b468da36d9d99c63409dc4098514759c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb207b468da36d9d99c63409dc4098514759c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb207b468da36d9d99c63409dc4098514759c90"}], "stats": {"total": 629, "additions": 589, "deletions": 40}, "files": [{"sha": "fbaff289a401588cb469ea1fd3ae442ce07f3a18", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 103, "deletions": 32, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e11e5d3889f9e54c547efee50fa1b72b50f0f265", "patch": "@@ -27338,57 +27338,128 @@ rs6000_globalize_decl_name (FILE * stream, tree decl)\n    library before you can switch the real*16 type at compile time.\n \n    We use the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change this name.  We\n-   only do this if the default is that long double is IBM extended double, and\n-   the user asked for IEEE 128-bit.  */\n+   only do this transformation if the __float128 type is enabled.  This\n+   prevents us from doing the transformation on older 32-bit ports that might\n+   have enabled using IEEE 128-bit floating point as the default long double\n+   type.  */\n \n static tree\n rs6000_mangle_decl_assembler_name (tree decl, tree id)\n {\n-  if (!TARGET_IEEEQUAD_DEFAULT && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n+  if (TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n       && TREE_CODE (decl) == FUNCTION_DECL\n-      && DECL_IS_UNDECLARED_BUILTIN (decl))\n+      && DECL_IS_UNDECLARED_BUILTIN (decl)\n+      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n     {\n       size_t len = IDENTIFIER_LENGTH (id);\n       const char *name = IDENTIFIER_POINTER (id);\n+      char *newname = NULL;\n \n-      if (name[len - 1] == 'l')\n+      /* See if it is one of the built-in functions with an unusual name.  */\n+      switch (DECL_FUNCTION_CODE (decl))\n \t{\n-\t  bool uses_ieee128_p = false;\n-\t  tree type = TREE_TYPE (decl);\n-\t  machine_mode ret_mode = TYPE_MODE (type);\n+\tcase BUILT_IN_DREML:\n+\t  newname = xstrdup (\"__remainderieee128\");\n+\t  break;\n \n-\t  /* See if the function returns a IEEE 128-bit floating point type or\n-\t     complex type.  */\n-\t  if (ret_mode == TFmode || ret_mode == TCmode)\n-\t    uses_ieee128_p = true;\n-\t  else\n-\t    {\n-\t      function_args_iterator args_iter;\n-\t      tree arg;\n+\tcase BUILT_IN_GAMMAL:\n+\t  newname = xstrdup (\"__lgammaieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_GAMMAL_R:\n+\tcase BUILT_IN_LGAMMAL_R:\n+\t  newname = xstrdup (\"__lgammaieee128_r\");\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARD:\n+\t  newname = xstrdup (\"__nexttoward_to_ieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARDF:\n+\t  newname = xstrdup (\"__nexttowardf_to_ieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_NEXTTOWARDL:\n+\t  newname = xstrdup (\"__nexttowardieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_POW10L:\n+\t  newname = xstrdup (\"__exp10ieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_SCALBL:\n+\t  newname = xstrdup (\"__scalbieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_SIGNIFICANDL:\n+\t  newname = xstrdup (\"__significandieee128\");\n+\t  break;\n+\n+\tcase BUILT_IN_SINCOSL:\n+\t  newname = xstrdup (\"__sincosieee128\");\n+\t  break;\n \n-\t      /* See if the function passes a IEEE 128-bit floating point type\n-\t\t or complex type.  */\n-\t      FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* Update the __builtin_*printf and __builtin_*scanf functions.  */\n+      if (!newname)\n+\t{\n+\t  size_t printf_len = strlen (\"printf\");\n+\t  size_t scanf_len = strlen (\"scanf\");\n+\n+\t  if (len >= printf_len\n+\t      && strcmp (name + len - printf_len, \"printf\") == 0)\n+\t    newname = xasprintf (\"__%sieee128\", name);\n+\n+\t  else if (len >= scanf_len\n+\t\t   && strcmp (name + len - scanf_len, \"scanf\") == 0)\n+\t    newname = xasprintf (\"__isoc99_%sieee128\", name);\n+\n+\t  else if (name[len - 1] == 'l')\n+\t    {\n+\t      bool uses_ieee128_p = false;\n+\t      tree type = TREE_TYPE (decl);\n+\t      machine_mode ret_mode = TYPE_MODE (type);\n+\n+\t      /* See if the function returns a IEEE 128-bit floating point type or\n+\t\t complex type.  */\n+\t      if (ret_mode == TFmode || ret_mode == TCmode)\n+\t\tuses_ieee128_p = true;\n+\t      else\n \t\t{\n-\t\t  machine_mode arg_mode = TYPE_MODE (arg);\n-\t\t  if (arg_mode == TFmode || arg_mode == TCmode)\n+\t\t  function_args_iterator args_iter;\n+\t\t  tree arg;\n+\n+\t\t  /* See if the function passes a IEEE 128-bit floating point type\n+\t\t     or complex type.  */\n+\t\t  FOREACH_FUNCTION_ARGS (type, arg, args_iter)\n \t\t    {\n-\t\t      uses_ieee128_p = true;\n-\t\t      break;\n+\t\t      machine_mode arg_mode = TYPE_MODE (arg);\n+\t\t      if (arg_mode == TFmode || arg_mode == TCmode)\n+\t\t\t{\n+\t\t\t  uses_ieee128_p = true;\n+\t\t\t  break;\n+\t\t\t}\n \t\t    }\n \t\t}\n-\t    }\n \n-\t  /* If we passed or returned an IEEE 128-bit floating point type,\n-\t     change the name.  */\n-\t  if (uses_ieee128_p)\n-\t    {\n-\t      char *name2 = (char *) alloca (len + 4);\n-\t      memcpy (name2, name, len - 1);\n-\t      strcpy (name2 + len - 1, \"f128\");\n-\t      id = get_identifier (name2);\n+\t      /* If we passed or returned an IEEE 128-bit floating point type,\n+\t\t change the name.  Use __<name>ieee128, instead of <name>l.  */\n+\t      if (uses_ieee128_p)\n+\t\tnewname = xasprintf (\"__%.*sieee128\", (int)(len - 1), name);\n \t    }\n \t}\n+\n+      if (newname)\n+\t{\n+\t  if (TARGET_DEBUG_BUILTIN)\n+\t    fprintf (stderr, \"Map %s => %s\\n\", name, newname);\n+\n+\t  id = get_identifier (newname);\n+\t  free (newname);\n+\t}\n     }\n \n   return id;"}, {"sha": "07934bb73572e72ecf2995db3c70989aa66f1af9", "filename": "gcc/testsuite/gcc.target/powerpc/float128-longdouble-math.c", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-math.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-math.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-math.c?ref=e11e5d3889f9e54c547efee50fa1b72b50f0f265", "patch": "@@ -0,0 +1,442 @@\n+/* { dg-require-effective-target ppc_float128_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power9 -O2 -mlong-double-128 -Wno-psabi -mabi=ieeelongdouble\" } */\n+\n+/* Test if switching long double to IEEE 128-bit maps all of the math built-in\n+   function names correctly.  We leave off the \\M in matching the calls, so\n+   power10 will match using bl foo@notoc.  */\n+\n+#ifdef DO_FUNC\n+#define BUILTIN1(FUNC, ARG1)             FUNC (ARG1)\n+#define BUILTIN2(FUNC, ARG1, ARG2)       FUNC (ARG1, ARG2)\n+#define BUILTIN3(FUNC, ARG1, ARG2, ARG3) FUNC (ARG1, ARG2, ARG3)\n+\n+#else\n+#define BUILTIN1(FUNC, ARG1)             __builtin_ ## FUNC (ARG1)\n+#define BUILTIN2(FUNC, ARG1, ARG2)       __builtin_ ## FUNC (ARG1, ARG2)\n+#define BUILTIN3(FUNC, ARG1, ARG2, ARG3) __builtin_ ## FUNC (ARG1, ARG2, ARG3)\n+#endif\n+\n+/* Built-in functions that returns a long double and take one long double\n+   argument.  */\n+\n+void\n+return_ld_arg_ld (long double *p,\n+\t\t  long double *q)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __acoshieee128} } }  */\n+  *p++ = BUILTIN1 (acoshl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __acosieee128} } }  */\n+  *p++ = BUILTIN1 (acosl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __asinhieee128} } }  */\n+  *p++ = BUILTIN1 (asinhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __asinieee128} } }  */\n+  *p++ = BUILTIN1 (asinl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __atanhieee128} } }  */\n+  *p++ = BUILTIN1 (atanhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __atanieee128} } }  */\n+  *p++ = BUILTIN1 (atanl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __cbrtieee128} } }  */\n+  *p++ = BUILTIN1 (cbrtl, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsrqpi +[0-9]+,[0-9]+,[0-9]+,2} } }  */\n+  *p++ = BUILTIN1 (ceill, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __coshieee128} } }  */\n+  *p++ = BUILTIN1 (coshl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __cosieee128} } }  */\n+  *p++ = BUILTIN1 (cosl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __erfcieee128} } }  */\n+  *p++ = BUILTIN1 (erfcl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __erfieee128} } }  */\n+  *p++ = BUILTIN1 (erfl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __exp10ieee128} } }  */\n+  *p++ = BUILTIN1 (exp10l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __exp2ieee128} } }  */\n+  *p++ = BUILTIN1 (exp2l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __expieee128} } }  */\n+  *p++ = BUILTIN1 (expl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __expm1ieee128} } }  */\n+  *p++ = BUILTIN1 (expm1l, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsabsqp} } }  */\n+  *p++ = BUILTIN1 (fabsl, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsrqpi +[0-9]+,[0-9]+,[0-9]+,3} } }  */\n+  *p++ = BUILTIN1 (floorl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __lgammaieee128} } }  */\n+  *p++ = BUILTIN1 (gammal, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __j0ieee128} } }  */\n+  *p++ = BUILTIN1 (j0l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __j1ieee128} } }  */\n+  *p++ = BUILTIN1 (j1l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __log10ieee128} } }  */\n+  *p++ = BUILTIN1 (log10l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __log1pieee128} } }  */\n+  *p++ = BUILTIN1 (log1pl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __log2ieee128} } }  */\n+  *p++ = BUILTIN1 (log2l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __logbieee128} } }  */\n+  *p++ = BUILTIN1 (logbl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __logieee128} } }  */\n+  *p++ = BUILTIN1 (logl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __nearbyintieee128} } }  */\n+  *p++ = BUILTIN1 (nearbyintl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __exp10ieee128} } }  */\n+  *p++ = BUILTIN1 (pow10l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __rintieee128} } }  */\n+  *p++ = BUILTIN1 (rintl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __roundevenieee128} } }  */\n+  *p++ = BUILTIN1 (roundevenl, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsrqpi +[0-9]+,[0-9]+,[0-9]+,0} } }  */\n+  *p++ = BUILTIN1 (roundl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __significandieee128} } }  */\n+  *p++ = BUILTIN1 (significandl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __sinhieee128} } }  */\n+  *p++ = BUILTIN1 (sinhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __sinieee128} } }  */\n+  *p++ = BUILTIN1 (sinl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __sqrtieee128} } }  */\n+  *p++ = BUILTIN1 (sqrtl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __tanhieee128} } }  */\n+  *p++ = BUILTIN1 (tanhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __tanieee128} } }  */\n+  *p++ = BUILTIN1 (tanl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __tgammaieee128} } }  */\n+  *p++ = BUILTIN1 (tgammal, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsrqpi +[0-9]+,[0-9]+,[0-9]+,1} } }  */\n+  *p++ = BUILTIN1 (truncl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __y0ieee128} } }  */\n+  *p++ = BUILTIN1 (y0l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __y1ieee128} } }  */\n+  *p   = BUILTIN1 (y1l, *q);\n+\n+}\n+\n+/* Built-in functions that returns a long double and take two long double\n+   arguments.  */\n+\n+void\n+return_ld_arg_ld_ld (long double *p,\n+\t\t     long double *q,\n+\t\t     long double *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __atan2ieee128} } }  */\n+  *p++ = BUILTIN2 (atan2l, *q++, *r++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxscpsgnqp} } }  */\n+  *p++ = BUILTIN2 (copysignl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __remainderieee128} } }  */\n+  *p++ = BUILTIN2 (dreml, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __fdimieee128} } }  */\n+  *p++ = BUILTIN2 (fdiml, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __fmaxieee128} } }  */\n+  *p++ = BUILTIN2 (fmaxl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __fminieee128} } }  */\n+  *p++ = BUILTIN2 (fminl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __fmodieee128} } }  */\n+  *p++ = BUILTIN2 (fmodl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __hypotieee128} } }  */\n+  *p++ = BUILTIN2 (hypotl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __nextafterieee128} } }  */\n+  *p++ = BUILTIN2 (nextafterl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __nexttowardieee128} } }  */\n+  *p++ = BUILTIN2 (nexttowardl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __powieee128} } }  */\n+  *p++ = BUILTIN2 (powl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __scalbnieee128} } }  */\n+  *p   = BUILTIN2 (scalbl, *q, *r);\n+}\n+\n+/* Built-in function that returns a long double and take three long double\n+   arguments.  */\n+\n+void\n+return_ld_arg_ld_ld_ld (long double *p,\n+\t\t\tlong double *q,\n+\t\t\tlong double *r,\n+\t\t\tlong double *s)\n+{\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxsmaddqp} } }  */\n+  *p = BUILTIN3 (fmal, *q, *r, *s);\n+}\n+\n+/* Built-in functions that returns a long double and take one\n+   _Complex long double argument.  */\n+\n+void\n+return_ld_arg_cld (long double *p,\n+\t\t   _Complex long double *q)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __cabsieee128} } }  */\n+  *p++ = BUILTIN1 (cabsl, *q++);\n+}\n+\n+/* Built-in functions that returns a _Complex long double and takes one\n+   _Complex long double argument.  */\n+\n+void\n+return_cld_arg_cld (_Complex long double *p,\n+\t\t    _Complex long double *q)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __cacoshieee128} } }  */\n+  *p++ = BUILTIN1 (cacoshl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __cacosieee128} } }  */\n+  *p++ = BUILTIN1 (cacosl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __casinhieee128} } }  */\n+  *p++ = BUILTIN1 (casinhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __casinieee128} } }  */\n+  *p++ = BUILTIN1 (casinl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __catanhieee128} } }  */\n+  *p++ = BUILTIN1 (catanhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __catanieee128} } }  */\n+  *p++ = BUILTIN1 (catanl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ccoshieee128} } }  */\n+  *p++ = BUILTIN1 (ccoshl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ccosieee128} } }  */\n+  *p++ = BUILTIN1 (ccosl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __cexpieee128} } }  */\n+  *p++ = BUILTIN1 (cexpl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __clogieee128} } }  */\n+  *p++ = BUILTIN1 (clogl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __clog10ieee128} } }  */\n+  *p++ = BUILTIN1 (clog10l, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __cprojieee128} } }  */\n+  *p++ = BUILTIN1 (cprojl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __csinhieee128} } }  */\n+  *p++ = BUILTIN1 (csinhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __csinieee128} } }  */\n+  *p++ = BUILTIN1 (csinl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __csqrtieee128} } }  */\n+  *p++ = BUILTIN1 (csqrtl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ctanhieee128} } }  */\n+  *p++ = BUILTIN1 (ctanhl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ctanieee128} } }  */\n+  *p   = BUILTIN1 (ctanl, *q);\n+}\n+\n+/* Built-in functions that returns a _Complex long double and takes one\n+   long double argument.  */\n+\n+void\n+return_cld_arg_ld (_Complex long double *p,\n+\t\t   long double *q)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __sincosieee128} } }  */\n+  *p = BUILTIN1 (cexpil, *q);\n+}\n+\n+/* Built-in function that returns a _Complex long double and takes two\n+   _Complex long double arguments.  */\n+\n+void\n+return_cld_arg_cld_cld (_Complex long double *p,\n+\t\t\t_Complex long double *q,\n+\t\t\t_Complex long double *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __cpowieee128} } }  */\n+  *p = BUILTIN2 (cpowl, *q, *r);\n+}\n+\n+/* Built-in functions that returns a long double and takes a long double and a\n+   pointer to an int arguments.  */\n+\n+void\n+return_ld_arg_ld_pi (long double *p,\n+\t\t     long double *q,\n+\t\t     int **r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __frexpieee128} } }  */\n+  *p++ = BUILTIN2 (frexpl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __lgammaieee128_r} } }  */\n+  *p++ = BUILTIN2 (gammal_r, *q++, *r++);\n+}\n+\n+/* Built-in functions that returns a long double and takes a long double and an\n+   int arguments.  */\n+\n+void\n+return_ld_arg_ld_i (long double *p,\n+\t\t    long double *q,\n+\t\t    int *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __ldexpieee128} } }  */\n+  *p++ = BUILTIN2 (ldexpl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __powikf2} } }  */\n+  *p++ = BUILTIN2 (powil, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __scalbnieee128} } }  */\n+  *p   = BUILTIN2 (scalbnl, *q, *r);\n+}\n+\n+/* Built-in function that returns a long double and takes a long double and a\n+   long arguments.  */\n+\n+void\n+return_ld_arg_ld_l (long double *p,\n+\t\t    long double *q,\n+\t\t    long *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __scalblnieee128} } }  */\n+  *p = BUILTIN2 (scalblnl, *q, *r);\n+}\n+\n+/* Built-in functions that returns a long double and takes a long double and a\n+   long long arguments.  */\n+\n+void\n+return_ld_arg_i_ld (long double *p,\n+\t\t    int *q,\n+\t\t    long double *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __jnieee128} } }  */\n+  *p++ = BUILTIN2 (jnl, *q++, *r++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ynieee128} } }  */\n+  *p   = BUILTIN2 (ynl, *q, *r);\n+}\n+\n+/* Built-in functions that returns a long double and takes a long double and a\n+   pointer to a long double arguments.  */\n+\n+void\n+return_ld_arg_ld_pld (long double *p,\n+\t\t      long double *q,\n+\t\t      long double **r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __modfieee128} } }  */\n+  *p = BUILTIN2 (modfl, *q, *r);\n+}\n+\n+/* Built-in function that returns a long double and takes two long double and a\n+   pointer to an int arguments.  */\n+\n+void\n+return_ld_arg_ld_ld_pi (long double *p,\n+\t\t\tlong double *q,\n+\t\t\tlong double *r,\n+\t\t\tint **s)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __remquoieee128} } }  */\n+  *p = BUILTIN3 (remquol, *q, *r, *s);\n+}\n+\n+/* Built-in functions that return san int and takes one long double argument.  */\n+\n+void\n+return_i_arg_ld (int *p,\n+\t\t long double *q)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __ceilieee128} } }  */\n+  *p++ = BUILTIN1 (iceill, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __floorieee128} } }  */\n+  *p++ = BUILTIN1 (ifloorl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __ilogbieee128} } }  */\n+  *p++ = BUILTIN1 (ilogbl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __lrintieee128} } }  */\n+  *p++ = BUILTIN1 (irintl, *q++);\n+\n+  /* { dg-final { scan-assembler {\\mbl __lroundieee128} } }  */\n+  *p++ = BUILTIN1 (iroundl, *q++);\n+\n+  /* inline code.  */\n+  /* { dg-final { scan-assembler {\\mxscvqpswz} } }  */\n+  *p++ = BUILTIN1 (signbitl, *q++);\n+}\n+\n+/* Built-in function that returns a double and takes one double and one long\n+   double arguments.  */\n+\n+void\n+return_d_arg_d_ld (double *p,\n+\t\t   double *q,\n+\t\t   long double *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __nexttoward_to_ieee128} } }  */\n+  *p = BUILTIN2 (nexttoward, *q, *r);\n+}\n+\n+/* Built-in function that returns a float and takes one float and one long\n+   double arguments.  */\n+\n+void\n+return_f_arg_f_ld (float *p,\n+\t\t   float *q,\n+\t\t   long double *r)\n+{\n+  /* { dg-final { scan-assembler {\\mbl __nexttowardf_to_ieee128} } }  */\n+  *p = BUILTIN2 (nexttowardf, *q, *r);\n+}"}, {"sha": "39e59d949f9f10586758d128faf5aa4efd3cf417", "filename": "gcc/testsuite/gcc.target/powerpc/float128-longdouble-stdio.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-stdio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-stdio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-longdouble-stdio.c?ref=e11e5d3889f9e54c547efee50fa1b72b50f0f265", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-require-effective-target ppc_float128_hw } */\n+/* { dg-options \"-mdejagnu-cpu=power9 -O2 -mlong-double-128 -Wno-psabi -mabi=ieeelongdouble\" } */\n+\n+/* Test if switching long double to IEEE 128-bit maps the printf and scanf\n+   function names correctly.  We leave off the \\M in matching the calls, so\n+   power10 will match using bl foo@notoc.  */\n+\n+#include <stdlib.h>\n+\n+volatile long double x = 1.0L;\n+volatile long double y, z;\n+\n+int\n+main (void)\n+{\n+  char buffer[100];\n+\n+  /* { dg-final { scan-assembler {\\mbl __sprintfieee128} } }  */\n+  __builtin_sprintf (buffer, \"%Lg\", x);\n+\n+  /* { dg-final { scan-assembler {\\mbl __printfieee128} } }  */\n+  __builtin_printf (\"x is %Lg [%s]\\n\", x, buffer);\n+\n+  /* { dg-final { scan-assembler {\\mbl __isoc99_sscanfieee128} } }  */\n+  __builtin_sscanf (buffer, \"%Lg\", &y);\n+\n+  __builtin_printf (\"Type 1.0: \");\n+\n+  /* { dg-final { scan-assembler {\\mbl __isoc99_scanfieee128} } }  */\n+  __builtin_scanf (\"%Lg\", &z);\n+\n+  if (x != y || x != z)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "d1e222397187a65c4a8f5030b6fb7451b13c5fae", "filename": "gcc/testsuite/gcc.target/powerpc/float128-math.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e11e5d3889f9e54c547efee50fa1b72b50f0f265/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-math.c?ref=e11e5d3889f9e54c547efee50fa1b72b50f0f265", "patch": "@@ -1,20 +1,20 @@\n-/* { dg-do compile { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target ppc_float128_sw } */\n /* { dg-require-effective-target vsx_hw } */\n-/* { dg-options \"-mvsx -O2 -mfloat128 -mabi=ieeelongdouble -Wno-psabi\" } */\n+/* { dg-options \"-mvsx -O2 -mfloat128 -mlong-double-128 -mabi=ieeelongdouble -Wno-psabi\" } */\n \n /* Test whether we convert __builtin_<math>l to __builtin_<math>f128 if the\n-   default long double type is IEEE 128-bit.  Also test that using the explicit\n-   __builtin_<math>f128 function does not interfere with the __builtin_<math>l\n-   function.  */\n+   default long double type is IEEE 128-bit.  We leave off the \\M in matching\n+   the calls, so power10 will match using bl foo@notoc.  Also test that using\n+   the explicit __builtin_<math>f128 function does not interfere with the\n+   __builtin_<math>l function.  */\n \n extern __float128 sinf128 (__float128);\n \n-void foo (__float128 *p, long double *q, long double *r)\n+void foo (__float128 *p, long double *q)\n {\n   *p = sinf128 (*p);\n   *q = __builtin_sinl (*q);\n }\n \n-/* { dg-final { scan-assembler-times {\\mbl sinf128\\M} 2 } } */\n-/* { dg-final { scan-assembler-not   {\\mbl sinl\\M}      } } */\n+/* { dg-final { scan-assembler     {\\mbl __sinieee128} } } */\n+/* { dg-final { scan-assembler-not {\\mbl sinl}         } } */"}]}