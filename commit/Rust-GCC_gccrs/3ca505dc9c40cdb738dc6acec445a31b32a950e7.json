{"sha": "3ca505dc9c40cdb738dc6acec445a31b32a950e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhNTA1ZGM5YzQwY2RiNzM4ZGM2YWNlYzQ0NWEzMWIzMmE5NTBlNw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-07-07T09:42:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-07T09:42:10Z"}, "message": "exp_ch3.adb (Build_Record_Init_Proc/Freeze_Record_Type): Reimplementation of the support for abstract interface types in order to leave...\n\n2005-07-07  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Build_Record_Init_Proc/Freeze_Record_Type):\n\tReimplementation of the support for abstract interface types in order\n\tto leave the code more clear and easy to maintain.\n\n\t* exp_ch6.adb (Freeze_Subprogram): Reimplementation of the support for\n\tabstract interface types in order to leave the code clearer and easier\n\tto maintain.\n\n\t* exp_disp.ads, exp_disp.adb (Fill_DT_Entry): Part of its functionality\n\tis now implemented by the new subprogram Fill_Secondary_DT_Entry.\n\t(Fill_Secondary_DT_Entry): Generate the code necessary to fill the\n\tappropriate entry of the secondary dispatch table.\n\t(Make_DT): Add code to inherit the secondary dispatch tables of\n\tthe ancestors.\n\n\t* exp_util.adb (Find_Interface_Tag/Find_Interface_ADT): Instead of\n\timplementing both functionalities by means of a common routine, each\n\troutine has its own code.\n\nFrom-SVN: r101694", "tree": {"sha": "638e14e666a1b32a2339a40ce7405fbcc3e2c6e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/638e14e666a1b32a2339a40ce7405fbcc3e2c6e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ca505dc9c40cdb738dc6acec445a31b32a950e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca505dc9c40cdb738dc6acec445a31b32a950e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca505dc9c40cdb738dc6acec445a31b32a950e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca505dc9c40cdb738dc6acec445a31b32a950e7/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69601f746d42adbf89b28a162cdbad0fa23de354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69601f746d42adbf89b28a162cdbad0fa23de354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69601f746d42adbf89b28a162cdbad0fa23de354"}], "stats": {"total": 892, "additions": 621, "deletions": 271}, "files": [{"sha": "465a792e495e84af25b0185e097f62f74e62ea89", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 148, "deletions": 85, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3ca505dc9c40cdb738dc6acec445a31b32a950e7", "patch": "@@ -1361,10 +1361,6 @@ package body Exp_Ch3 is\n       Rec_Type    : Entity_Id;\n       Set_Tag     : Entity_Id := Empty;\n \n-      ADT      : Elmt_Id;\n-      Aux_N    : Node_Id;\n-      Aux_Comp : Node_Id;\n-\n       function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id;\n       --  Build a assignment statement node which assigns to record\n       --  component its default expression if defined. The left hand side\n@@ -1735,6 +1731,100 @@ package body Exp_Ch3 is\n          Record_Extension_Node : Node_Id;\n          Init_Tag              : Node_Id;\n \n+         procedure Init_Secondary_Tags (Typ : Entity_Id);\n+         --  Ada 2005 (AI-251): Initialize the tags of all the secondary\n+         --  tables associated with abstract interface types\n+\n+         -------------------------\n+         -- Init_Secondary_Tags --\n+         -------------------------\n+\n+         procedure Init_Secondary_Tags (Typ : Entity_Id) is\n+            ADT : Elmt_Id;\n+\n+            procedure Init_Secondary_Tags_Internal (Typ : Entity_Id);\n+            --  Internal subprogram used to recursively climb to the root type\n+\n+            ----------------------------------\n+            -- Init_Secondary_Tags_Internal --\n+            ----------------------------------\n+\n+            procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n+               E     : Entity_Id;\n+               Aux_N : Node_Id;\n+\n+            begin\n+               if not Is_Interface (Typ)\n+                 and then Etype (Typ) /= Typ\n+               then\n+                  Init_Secondary_Tags_Internal (Etype (Typ));\n+               end if;\n+\n+               if Present (Abstract_Interfaces (Typ))\n+                 and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+               then\n+                  E := First_Entity (Typ);\n+                  while Present (E) loop\n+                     if Is_Tag (E)\n+                       and then Chars (E) /= Name_uTag\n+                     then\n+                        Aux_N := Node (ADT);\n+                        pragma Assert (Present (Aux_N));\n+\n+                        --  Initialize the pointer to the secondary DT\n+                        --  associated with the interface\n+\n+                        Append_To (Body_Stmts,\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix => Make_Identifier (Loc, Name_uInit),\n+                                Selector_Name =>\n+                                  New_Reference_To (E, Loc)),\n+                            Expression =>\n+                              New_Reference_To (Aux_N, Loc)));\n+\n+                        --  Generate:\n+                        --    Set_Offset_To_Top (DT_Ptr, n);\n+\n+                        Append_To (Body_Stmts,\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name => New_Reference_To\n+                                      (RTE (RE_Set_Offset_To_Top), Loc),\n+                            Parameter_Associations => New_List (\n+                              Unchecked_Convert_To (RTE (RE_Tag),\n+                                New_Reference_To (Aux_N, Loc)),\n+                              Unchecked_Convert_To (RTE (RE_Storage_Offset),\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix         =>\n+                                   Make_Selected_Component (Loc,\n+                                     Prefix         => Make_Identifier (Loc,\n+                                                         Name_uInit),\n+                                     Selector_Name  => New_Reference_To\n+                                                         (E, Loc)),\n+                                 Attribute_Name => Name_Position)))));\n+\n+                        Next_Elmt (ADT);\n+                     end if;\n+\n+                     Next_Entity (E);\n+                  end loop;\n+               end if;\n+            end Init_Secondary_Tags_Internal;\n+\n+         --  Start of processing for Init_Secondary_Tags\n+\n+         begin\n+            --  Skip the first _Tag, which is the main tag of the\n+            --  tagged type. Following tags correspond with abstract\n+            --  interfaces.\n+\n+            ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+            Init_Secondary_Tags_Internal (Typ);\n+         end Init_Secondary_Tags;\n+\n+      --  Start of processing for Build_Init_Procedure\n+\n       begin\n          Body_Stmts := New_List;\n          Body_Node := New_Node (N_Subprogram_Body, Loc);\n@@ -1864,55 +1954,10 @@ package body Exp_Ch3 is\n                --  Ada 2005 (AI-251): Initialization of all the tags\n                --  corresponding with abstract interfaces\n \n-               if Present (First_Tag_Component (Rec_Type)) then\n-\n-                  --  Skip the first _Tag, which is the main tag of the\n-                  --  tagged type. Following tags correspond with abstract\n-                  --  interfaces.\n-\n-                  Aux_Comp :=\n-                    Next_Tag_Component (First_Tag_Component (Rec_Type));\n-\n-                  ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Rec_Type)));\n-                  while Present (ADT) loop\n-                     Aux_N := Node (ADT);\n-\n-                     --  Initialize the pointer to the secondary DT associated\n-                     --  with the interface\n-\n-                     Append_To (Body_Stmts,\n-                       Make_Assignment_Statement (Loc,\n-                         Name =>\n-                           Make_Selected_Component (Loc,\n-                             Prefix => Make_Identifier (Loc, Name_uInit),\n-                             Selector_Name =>\n-                               New_Reference_To (Aux_Comp, Loc)),\n-                         Expression =>\n-                           New_Reference_To (Aux_N, Loc)));\n-\n-                     --  Generate:\n-                     --    Set_Offset_To_Top (DT_Ptr, n);\n-\n-                     Append_To (Body_Stmts,\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name => New_Reference_To (RTE (RE_Set_Offset_To_Top),\n-                                                   Loc),\n-                         Parameter_Associations => New_List (\n-                           Unchecked_Convert_To (RTE (RE_Tag),\n-                             New_Reference_To (Aux_N, Loc)),\n-                           Unchecked_Convert_To (RTE (RE_Storage_Offset),\n-                             Make_Attribute_Reference (Loc,\n-                               Prefix         =>\n-                                Make_Selected_Component (Loc,\n-                                  Prefix         => Make_Identifier (Loc,\n-                                                      Name_uInit),\n-                                  Selector_Name  => New_Reference_To\n-                                                      (Aux_Comp, Loc)),\n-                              Attribute_Name => Name_Position)))));\n-\n-                     Aux_Comp := Next_Tag_Component (Aux_Comp);\n-                     Next_Elmt (ADT);\n-                  end loop;\n+               if Ada_Version >= Ada_05\n+                 and then not Is_Interface (Rec_Type)\n+               then\n+                  Init_Secondary_Tags (Rec_Type);\n                end if;\n \n             else\n@@ -4480,36 +4525,6 @@ package body Exp_Ch3 is\n                Expand_Tagged_Root (Def_Id);\n             end if;\n \n-            --  Build the secondary tables\n-\n-            if not Java_VM\n-              and then Present (Abstract_Interfaces (Def_Id))\n-              and then not Is_Empty_Elmt_List (Abstract_Interfaces (Def_Id))\n-            then\n-               declare\n-                  E      : Entity_Id;\n-                  Result : List_Id;\n-                  ADT    : Elist_Id := Access_Disp_Table (Def_Id);\n-\n-               begin\n-                  E := First_Entity (Def_Id);\n-                  while Present (E) loop\n-                     if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                        Make_Abstract_Interface_DT\n-                          (AI_Tag          => E,\n-                           Acc_Disp_Tables => ADT,\n-                           Result          => Result);\n-\n-                        Append_Freeze_Actions (Def_Id, Result);\n-                     end if;\n-\n-                     Next_Entity (E);\n-                  end loop;\n-\n-                  Set_Access_Disp_Table (Def_Id, ADT);\n-               end;\n-            end if;\n-\n             --  Unfreeze momentarily the type to add the predefined primitives\n             --  operations. The reason we unfreeze is so that these predefined\n             --  operations will indeed end up as primitive operations (which\n@@ -4533,7 +4548,55 @@ package body Exp_Ch3 is\n             --  dispatching mechanism is handled internally by the JVM.\n \n             if not Java_VM then\n-               Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+\n+               --  Ada 2005 (AI-251): Build the secondary dispatch tables\n+\n+               declare\n+                  ADT : Elist_Id := Access_Disp_Table (Def_Id);\n+\n+                  procedure Add_Secondary_Tables (Typ : Entity_Id);\n+                  --  Comment required ???\n+\n+                  --------------------------\n+                  -- Add_Secondary_Tables --\n+                  --------------------------\n+\n+                  procedure Add_Secondary_Tables (Typ : Entity_Id) is\n+                     E      : Entity_Id;\n+                     Result : List_Id;\n+\n+                  begin\n+                     if Etype (Typ) /= Typ then\n+                        Add_Secondary_Tables (Etype (Typ));\n+                     end if;\n+\n+                     if Present (Abstract_Interfaces (Typ))\n+                       and then not Is_Empty_Elmt_List\n+                                      (Abstract_Interfaces (Typ))\n+                     then\n+                        E := First_Entity (Typ);\n+                        while Present (E) loop\n+                           if Is_Tag (E) and then Chars (E) /= Name_uTag then\n+                              Make_Abstract_Interface_DT\n+                                (AI_Tag          => E,\n+                                 Acc_Disp_Tables => ADT,\n+                                 Result          => Result);\n+\n+                              Append_Freeze_Actions (Def_Id, Result);\n+                           end if;\n+\n+                           Next_Entity (E);\n+                        end loop;\n+                     end if;\n+                  end Add_Secondary_Tables;\n+\n+               --  Start of processing to build secondary dispatch tables\n+\n+               begin\n+                  Add_Secondary_Tables  (Def_Id);\n+                  Set_Access_Disp_Table (Def_Id, ADT);\n+                  Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n+               end;\n             end if;\n \n             --  Make sure that the primitives Initialize, Adjust and Finalize\n@@ -5681,7 +5744,7 @@ package body Exp_Ch3 is\n \n         Ret_Type => Standard_Integer));\n \n-      --  Specs for dispatching stream attributes.\n+      --  Specs for dispatching stream attributes\n \n       declare\n          Stream_Op_TSS_Names :"}, {"sha": "41620784065664ba899e6ae7c6f409948c335f88", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 203, "deletions": 26, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=3ca505dc9c40cdb738dc6acec445a31b32a950e7", "patch": "@@ -4062,37 +4062,157 @@ package body Exp_Ch6 is\n    procedure Freeze_Subprogram (N : Node_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       E         : constant Entity_Id  := Entity (N);\n-      Thunk_Id  : Entity_Id;\n-      Iface_Tag : Entity_Id;\n-      New_Thunk : Node_Id;\n \n-   begin\n-      --  When a primitive is frozen, enter its name in the corresponding\n-      --  dispatch table. If the DTC_Entity field is not set this is an\n-      --  overridden primitive that can be ignored. We suppress the\n-      --  initialization of the dispatch table entry when Java_VM because\n-      --  the dispatching mechanism is handled internally by the JVM.\n+      procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id);\n+      --  (Ada 2005): Check if the primitive E covers some interface already\n+      --  implemented by some ancestor of the tagged-type associated with E\n+\n+      procedure Register_Interface_DT_Entry\n+        (Prim                : Entity_Id;\n+         Ancestor_Iface_Prim : Entity_Id := Empty);\n+      --  (Ada 2005): Register an interface primitive in a secondary dispatch\n+      --  table. If Prim overrides an ancestor primitive of its associated\n+      --  tagged-type then Ancestor_Iface_Prim indicates the entity of that\n+      --  immediate ancestor associated with the interface; otherwise Prim and\n+      --  Ancestor_Iface_Prim have the same info.\n+\n+      -------------------------------------------\n+      -- Check_Overriding_Inherited_Interfaces --\n+      -------------------------------------------\n+\n+      procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id) is\n+         Typ          : Entity_Id;\n+         Elmt         : Elmt_Id;\n+         Prim_Op      : Entity_Id;\n+         Overriden_Op : Entity_Id := Empty;\n \n-      if Is_Dispatching_Operation (E)\n-        and then not Is_Abstract (E)\n-        and then Present (DTC_Entity (E))\n-        and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n-        and then not Java_VM\n-      then\n-         Check_Overriding_Operation (E);\n+      begin\n+         if Ada_Version < Ada_05\n+           or else not Is_Overriding_Operation (E)\n+           or else Is_Predefined_Dispatching_Operation (E)\n+           or else Present (Alias (E))\n+         then\n+            return;\n+         end if;\n+\n+         --  Get the entity associated with this primitive operation\n+\n+         Typ := Scope (DTC_Entity (E));\n+         while Etype (Typ) /= Typ loop\n+\n+            --  Climb to the immediate ancestor\n+\n+            Typ := Etype (Typ);\n \n-         --  Common case: Primitive subprogram\n+            if Present (Abstract_Interfaces (Typ)) then\n \n-         if not Present (Abstract_Interface_Alias (E)) then\n-            Insert_After (N, Fill_DT_Entry (Sloc (N), E));\n+               --  Look for the overriden subprogram in the primary dispatch\n+               --  table of the ancestor.\n \n-         --  Ada 2005 (AI-251): Primitive subprogram that covers an interface\n+               Overriden_Op := Empty;\n+               Elmt         := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Elmt) loop\n+                  Prim_Op := Node (Elmt);\n+\n+                  if DT_Position (Prim_Op) = DT_Position (E)\n+                    and then Etype (DTC_Entity (Prim_Op)) = RTE (RE_Tag)\n+                    and then not Present (Abstract_Interface_Alias (Prim_Op))\n+                  then\n+                     if Overriden_Op /= Empty then\n+                        raise Program_Error;\n+                     end if;\n+\n+                     Overriden_Op := Prim_Op;\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+\n+               --  if not found this is the first overriding of some\n+               --  abstract interface\n+\n+               if Overriden_Op /= Empty then\n+                  Elmt := First_Elmt (Primitive_Operations (Typ));\n+\n+                  --  Find the entries associated with interfaces that are\n+                  --  alias of this primitive operation in the ancestor\n+\n+                  while Present (Elmt) loop\n+                     Prim_Op := Node (Elmt);\n+\n+                     if Present (Abstract_Interface_Alias (Prim_Op))\n+                       and then Alias (Prim_Op) = Overriden_Op\n+                     then\n+                        Register_Interface_DT_Entry (E, Prim_Op);\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end if;\n+            end if;\n+         end loop;\n+      end Check_Overriding_Inherited_Interfaces;\n+\n+      ---------------------------------\n+      -- Register_Interface_DT_Entry --\n+      ---------------------------------\n+\n+      procedure Register_Interface_DT_Entry\n+        (Prim                : Entity_Id;\n+         Ancestor_Iface_Prim : Entity_Id := Empty)\n+      is\n+         Prim_Typ     : Entity_Id;\n+         Prim_Op      : Entity_Id;\n+         Iface_Typ    : Entity_Id;\n+         Iface_DT_Ptr : Entity_Id;\n+         Iface_Tag    : Entity_Id;\n+         New_Thunk    : Node_Id;\n+         Thunk_Id     : Entity_Id;\n+\n+      begin\n+         if not Present (Ancestor_Iface_Prim) then\n+            Prim_Typ  := Scope (DTC_Entity (Alias (Prim)));\n+            Iface_Typ := Scope (DTC_Entity (Abstract_Interface_Alias (Prim)));\n+            Iface_Tag := Find_Interface_Tag\n+                           (T     => Prim_Typ,\n+                            Iface => Iface_Typ);\n+\n+            --  Generate the code of the thunk only when this primitive\n+            --  operation is associated with a secondary dispatch table\n+\n+            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n+               Thunk_Id  := Make_Defining_Identifier (Loc,\n+                              New_Internal_Name ('T'));\n+               New_Thunk :=\n+                 Expand_Interface_Thunk\n+                   (N           => Prim,\n+                    Thunk_Alias => Alias (Prim),\n+                    Thunk_Id    => Thunk_Id,\n+                    Iface_Tag   => Iface_Tag);\n+\n+               Insert_After (N, New_Thunk);\n+\n+               Iface_DT_Ptr :=\n+                 Find_Interface_ADT\n+                   (T     => Prim_Typ,\n+                    Iface => Iface_Typ);\n+\n+               Insert_After (New_Thunk,\n+                 Fill_Secondary_DT_Entry (Sloc (Prim),\n+                   Prim         => Prim,\n+                   Iface_DT_Ptr => Iface_DT_Ptr,\n+                   Thunk_Id     => Thunk_Id));\n+            end if;\n \n          else\n+            Iface_Typ :=\n+              Scope (DTC_Entity (Abstract_Interface_Alias\n+                                  (Ancestor_Iface_Prim)));\n+\n             Iface_Tag :=\n               Find_Interface_Tag\n-                (T     => Scope (DTC_Entity (Alias (E))),    -- Formal Type\n-                 Iface => Scope (DTC_Entity (Abstract_Interface_Alias (E))));\n+                (T     => Scope (DTC_Entity (Alias (Ancestor_Iface_Prim))),\n+                 Iface => Iface_Typ);\n \n             --  Generate the thunk only if the associated tag is an interface\n             --  tag. The case in which the associated tag is the primary tag\n@@ -4107,12 +4227,69 @@ package body Exp_Ch6 is\n                Thunk_Id  := Make_Defining_Identifier (Loc,\n                               New_Internal_Name ('T'));\n \n-               New_Thunk := Expand_Interface_Thunk (N, Thunk_Id, Iface_Tag);\n+               if Present (Alias (Prim)) then\n+                  Prim_Op := Alias (Prim);\n+               else\n+                  Prim_Op := Prim;\n+               end if;\n+\n+               New_Thunk :=\n+                 Expand_Interface_Thunk\n+                   (N           => Ancestor_Iface_Prim,\n+                    Thunk_Alias => Prim_Op,\n+                    Thunk_Id    => Thunk_Id,\n+                    Iface_Tag   => Iface_Tag);\n+\n+               Insert_After (N, New_Thunk);\n+\n+               Iface_DT_Ptr :=\n+                 Find_Interface_ADT\n+                   (T     => Scope (DTC_Entity (Prim_Op)),\n+                    Iface => Iface_Typ);\n \n                Insert_After (New_Thunk,\n-                  Fill_DT_Entry (Sloc (N),\n-                     Prim     => E,\n-                     Thunk_Id => Thunk_Id));\n+                 Fill_Secondary_DT_Entry (Sloc (Prim),\n+                   Prim         => Ancestor_Iface_Prim,\n+                   Iface_DT_Ptr => Iface_DT_Ptr,\n+                   Thunk_Id     => Thunk_Id));\n+            end if;\n+         end if;\n+      end Register_Interface_DT_Entry;\n+\n+   --  Start of processing for Freeze_Subprogram\n+\n+   begin\n+      --  When a primitive is frozen, enter its name in the corresponding\n+      --  dispatch table. If the DTC_Entity field is not set this is an\n+      --  overridden primitive that can be ignored. We suppress the\n+      --  initialization of the dispatch table entry when Java_VM because\n+      --  the dispatching mechanism is handled internally by the JVM.\n+\n+      if Is_Dispatching_Operation (E)\n+        and then not Is_Abstract (E)\n+        and then Present (DTC_Entity (E))\n+        and then not Java_VM\n+        and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n+      then\n+         Check_Overriding_Operation (E);\n+\n+         if Ada_Version < Ada_05 then\n+            Insert_After (N,\n+              Fill_DT_Entry (Sloc (N), Prim => E));\n+\n+         else\n+            --  Ada 2005 (AI-251): Check if this entry corresponds with\n+            --  a subprogram that covers an abstract interface type\n+\n+            if Present (Abstract_Interface_Alias (E)) then\n+               Register_Interface_DT_Entry (E);\n+\n+            --  Common case: Primitive subprogram\n+\n+            else\n+               Insert_After (N,\n+                 Fill_DT_Entry (Sloc (N), Prim => E));\n+               Check_Overriding_Inherited_Interfaces (E);\n             end if;\n          end if;\n       end if;"}, {"sha": "05ecfb655e922cd14cb1e3b0cb2c6f7c262b958b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 134, "deletions": 60, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3ca505dc9c40cdb738dc6acec445a31b32a950e7", "patch": "@@ -902,6 +902,7 @@ package body Exp_Disp is\n \n    function Expand_Interface_Thunk\n      (N           : Node_Id;\n+      Thunk_Alias : Entity_Id;\n       Thunk_Id    : Entity_Id;\n       Iface_Tag   : Entity_Id) return Node_Id\n    is\n@@ -910,7 +911,6 @@ package body Exp_Disp is\n       Decl        : constant List_Id    := New_List;\n       Formals     : constant List_Id    := New_List;\n       Thunk_Tag   : constant Node_Id    := Iface_Tag;\n-      Thunk_Alias : constant Entity_Id  := Alias (Entity (N));\n       Target      : Entity_Id;\n       New_Code    : Node_Id;\n       Formal      : Node_Id;\n@@ -950,11 +950,7 @@ package body Exp_Disp is\n \n          if Is_Controlling_Formal (Formal) then\n             Set_Parameter_Type (New_Formal,\n-              New_Reference_To (Etype (First_Entity (Entity (N))), Loc));\n-\n-            --  Why is this line silently commented out ???\n-\n-            --  New_Reference_To (Etype (Formal), Loc));\n+              New_Reference_To (Etype (First_Entity (N)), Loc));\n          end if;\n \n          Append_To (Formals, New_Formal);\n@@ -1150,66 +1146,76 @@ package body Exp_Disp is\n       end if;\n \n       Analyze (New_Code);\n-      Insert_After (N, New_Code);\n       return New_Code;\n    end Expand_Interface_Thunk;\n \n-   -------------\n-   -- Fill_DT --\n-   -------------\n+   -------------------\n+   -- Fill_DT_Entry --\n+   -------------------\n \n    function Fill_DT_Entry\n-     (Loc      : Source_Ptr;\n-      Prim     : Entity_Id;\n-      Thunk_Id : Entity_Id := Empty) return Node_Id\n+     (Loc     : Source_Ptr;\n+      Prim    : Entity_Id) return Node_Id\n    is\n       Typ     : constant Entity_Id := Scope (DTC_Entity (Prim));\n-      DT_Ptr  : Entity_Id := Node (First_Elmt (Access_Disp_Table (Typ)));\n-      Target  : Entity_Id;\n-      Tag     : Entity_Id := First_Tag_Component (Typ);\n-      Prim_Op : Entity_Id := Prim;\n+      DT_Ptr  : constant Entity_Id :=\n+                  Node (First_Elmt (Access_Disp_Table (Typ)));\n+      Pos     : constant Uint      := DT_Position (Prim);\n+      Tag     : constant Entity_Id := First_Tag_Component (Typ);\n \n    begin\n-      --  Ada 2005 (AI-251): If we have a thunk available then generate code\n-      --  that saves its address in the secondary dispatch table of its\n-      --  abstract interface; otherwise save the address of the primitive\n-      --  subprogram in the main virtual table.\n-\n-      if Thunk_Id /= Empty then\n-         Target := Thunk_Id;\n-      else\n-         Target := Prim;\n+      if Pos = Uint_0 or else Pos > DT_Entry_Count (Tag) then\n+         raise Program_Error;\n       end if;\n \n-      --  Ada 2005 (AI-251): If the subprogram is the alias of an abstract\n-      --  interface subprogram then find the correct dispatch table pointer\n+      return\n+        Make_DT_Access_Action (Typ,\n+          Action => Set_Prim_Op_Address,\n+          Args   => New_List (\n+            Unchecked_Convert_To (RTE (RE_Tag),\n+              New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n \n-      if Present (Abstract_Interface_Alias (Prim)) then\n-         Prim_Op := Abstract_Interface_Alias (Prim);\n+            Make_Integer_Literal (Loc, Pos),                    -- Position\n \n-         DT_Ptr  := Find_Interface_ADT\n-                      (T     => Typ,\n-                       Iface => Scope (DTC_Entity (Prim_Op)));\n+            Make_Attribute_Reference (Loc,                      -- Value\n+              Prefix          => New_Reference_To (Prim, Loc),\n+              Attribute_Name  => Name_Address)));\n+   end Fill_DT_Entry;\n \n-         Tag := First_Tag_Component (Scope (DTC_Entity (Prim_Op)));\n-      end if;\n+   -----------------------------\n+   -- Fill_Secondary_DT_Entry --\n+   -----------------------------\n \n-      pragma Assert (DT_Position (Prim_Op) <= DT_Entry_Count (Tag));\n-      pragma Assert (DT_Position (Prim_Op) > Uint_0);\n+   function Fill_Secondary_DT_Entry\n+     (Loc          : Source_Ptr;\n+      Prim         : Entity_Id;\n+      Thunk_Id     : Entity_Id;\n+      Iface_DT_Ptr : Entity_Id) return Node_Id\n+   is\n+      Typ        : constant Entity_Id := Scope (DTC_Entity (Alias (Prim)));\n+      Iface_Prim : constant Entity_Id := Abstract_Interface_Alias (Prim);\n+      Pos        : constant Uint      := DT_Position (Iface_Prim);\n+      Tag        : constant Entity_Id :=\n+                     First_Tag_Component (Scope (DTC_Entity (Iface_Prim)));\n+\n+   begin\n+      if Pos = Uint_0 or else Pos > DT_Entry_Count (Tag) then\n+         raise Program_Error;\n+      end if;\n \n       return\n         Make_DT_Access_Action (Typ,\n           Action => Set_Prim_Op_Address,\n           Args   => New_List (\n             Unchecked_Convert_To (RTE (RE_Tag),\n-              New_Reference_To (DT_Ptr, Loc)),                  -- DTptr\n+              New_Reference_To (Iface_DT_Ptr, Loc)),            -- DTptr\n \n-            Make_Integer_Literal (Loc, DT_Position (Prim_Op)),  -- Position\n+            Make_Integer_Literal (Loc, Pos),                    -- Position\n \n             Make_Attribute_Reference (Loc,                      -- Value\n-              Prefix          => New_Reference_To (Target, Loc),\n+              Prefix          => New_Reference_To (Thunk_Id, Loc),\n               Attribute_Name  => Name_Address)));\n-   end Fill_DT_Entry;\n+   end Fill_Secondary_DT_Entry;\n \n    ---------------------------\n    -- Get_Remotely_Callable --\n@@ -1313,7 +1319,6 @@ package body Exp_Disp is\n       Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n       --  ----------------------------------------------------------------\n-\n       --  Dispatch table and related entities are allocated statically\n \n       Set_Ekind (DT, E_Variable);\n@@ -1538,6 +1543,71 @@ package body Exp_Disp is\n             Node3 => Make_Integer_Literal (Loc,\n                        DT_Entry_Count (First_Tag_Component (Etype (Typ)))))));\n \n+      --  Inherit the secondary dispatch tables of the ancestor\n+\n+      if not Is_CPP_Class (Etype (Typ)) then\n+         declare\n+            Sec_DT_Ancestor : Elmt_Id :=\n+              Next_Elmt (First_Elmt (Access_Disp_Table (Etype (Typ))));\n+            Sec_DT_Typ      : Elmt_Id :=\n+              Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+\n+            procedure Copy_Secondary_DTs (Typ : Entity_Id);\n+            --  ??? comment required\n+\n+            ------------------------\n+            -- Copy_Secondary_DTs --\n+            ------------------------\n+\n+            procedure Copy_Secondary_DTs (Typ : Entity_Id) is\n+               E : Entity_Id;\n+\n+            begin\n+               if Etype (Typ) /= Typ then\n+                  Copy_Secondary_DTs (Etype (Typ));\n+               end if;\n+\n+               if Present (Abstract_Interfaces (Typ))\n+                 and then not Is_Empty_Elmt_List\n+                                (Abstract_Interfaces (Typ))\n+               then\n+                  E := First_Entity (Typ);\n+\n+                  while Present (E)\n+                    and then Present (Node (Sec_DT_Ancestor))\n+                  loop\n+                     if Is_Tag (E) and then Chars (E) /= Name_uTag then\n+                        Append_To (Elab_Code,\n+                          Make_DT_Access_Action (Typ,\n+                            Action => Inherit_DT,\n+                            Args   => New_List (\n+                              Node1 => Unchecked_Convert_To\n+                                         (RTE (RE_Tag),\n+                                          New_Reference_To\n+                                            (Node (Sec_DT_Ancestor), Loc)),\n+                              Node2 => Unchecked_Convert_To\n+                                         (RTE (RE_Tag),\n+                                          New_Reference_To\n+                                            (Node (Sec_DT_Typ), Loc)),\n+                              Node3 => Make_Integer_Literal (Loc,\n+                                         DT_Entry_Count (E)))));\n+\n+                        Next_Elmt (Sec_DT_Ancestor);\n+                        Next_Elmt (Sec_DT_Typ);\n+                     end if;\n+\n+                     Next_Entity (E);\n+                  end loop;\n+               end if;\n+            end Copy_Secondary_DTs;\n+\n+         begin\n+            if Present (Node (Sec_DT_Ancestor)) then\n+               Copy_Secondary_DTs (Typ);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Generate: Inherit_TSD (parent'tag, DT_Ptr);\n \n       Append_To (Elab_Code,\n@@ -1547,17 +1617,20 @@ package body Exp_Disp is\n             Node1 => Old_Tag2,\n             Node2 => New_Reference_To (DT_Ptr, Loc))));\n \n-      --  for types with no controlled components\n-      --    Generate: Set_RC_Offset (DT_Ptr, 0);\n-      --  for simple types with controlled components\n-      --    Generate: Set_RC_Offset (DT_Ptr, type._record_controller'position);\n-      --  for complex types with controlled components where the position\n+      --  For types with no controlled components, generate:\n+      --    Set_RC_Offset (DT_Ptr, 0);\n+\n+      --  For simple types with controlled components, generate:\n+      --    Set_RC_Offset (DT_Ptr, type._record_controller'position);\n+\n+      --  For complex types with controlled components where the position\n       --  of the record controller is not statically computable, if there are\n-      --  controlled components at this level\n-      --    Generate: Set_RC_Offset (DT_Ptr, -1);\n-      --  to indicate that the _controller field is right after the _parent or\n-      --  if there are no controlled components at this level,\n-      --    Generate: Set_RC_Offset (DT_Ptr, -2);\n+      --  controlled components at this level, generate:\n+      --    Set_RC_Offset (DT_Ptr, -1);\n+      --  to indicate that the _controller field is right after the _parent\n+\n+      --  Or if there are no controlled components at this level, generate:\n+      --    Set_RC_Offset (DT_Ptr, -2);\n       --  to indicate that we need to get the position from the parent.\n \n       declare\n@@ -1588,6 +1661,8 @@ package body Exp_Disp is\n             --  the back end (see comment on the Bit_Component attribute in\n             --  sem_attr). So we avoid semantic checking here.\n \n+            --  Is this documented in sinfo.ads??? it should be!\n+\n             Set_Analyzed (Position);\n             Set_Etype (Prefix (Position), RTE (RE_Record_Controller));\n             Set_Etype (Prefix (Prefix (Position)), Typ);\n@@ -1604,8 +1679,8 @@ package body Exp_Disp is\n                Node2 => Position)));\n       end;\n \n-      --  Generate: Set_Remotely_Callable (DT_Ptr, Status);\n-      --  where Status is described in E.4 (18)\n+      --  Generate: Set_Remotely_Callable (DT_Ptr, Status); where Status is\n+      --  described in E.4 (18)\n \n       declare\n          Status : Entity_Id;\n@@ -1681,8 +1756,8 @@ package body Exp_Disp is\n       --  Ada 2005 (AI-251): Register the tag of the interfaces into\n       --  the table of implemented interfaces\n \n-      if Present (Abstract_Interfaces (Typ))\n-        and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+      if Present (Abstract_Interfaces (Typ_Copy))\n+        and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ_Copy))\n       then\n          AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n          while Present (AI) loop\n@@ -1718,9 +1793,8 @@ package body Exp_Disp is\n       Result          : out List_Id)\n    is\n       Loc         : constant Source_Ptr := Sloc (AI_Tag);\n-      Tname       : constant Name_Id := Chars (AI_Tag);\n-      Name_DT     : constant Name_Id := New_External_Name (Tname, 'T');\n-      Name_DT_Ptr : constant Name_Id := New_External_Name (Tname, 'P');\n+      Name_DT     : constant Name_Id := New_Internal_Name ('T');\n+      Name_DT_Ptr : constant Name_Id := New_Internal_Name ('P');\n \n       Iface_DT     : constant Node_Id :=\n                        Make_Defining_Identifier (Loc, Name_DT);\n@@ -1848,7 +1922,6 @@ package body Exp_Disp is\n       end if;\n \n       Append_Elmt (Iface_DT_Ptr, Acc_Disp_Tables);\n-\n    end Make_Abstract_Interface_DT;\n \n    ---------------------------\n@@ -2117,6 +2190,7 @@ package body Exp_Disp is\n \n          Prim_Elmt  := First_Prim;\n          Count_Prim := 0;\n+\n          while Present (Prim_Elmt) loop\n             Count_Prim := Count_Prim + 1;\n             Prim       := Node (Prim_Elmt);"}, {"sha": "10900d0410378b4be35538efbf5589ee1d9d0c06", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=3ca505dc9c40cdb738dc6acec445a31b32a950e7", "patch": "@@ -55,12 +55,20 @@ package Exp_Disp is\n        TSD_Prologue_Size);\n \n    function Fill_DT_Entry\n-     (Loc      : Source_Ptr;\n-      Prim     : Entity_Id;\n-      Thunk_Id : Entity_Id := Empty) return Node_Id;\n+     (Loc          : Source_Ptr;\n+      Prim         : Entity_Id) return Node_Id;\n    --  Generate the code necessary to fill the appropriate entry of the\n    --  dispatch table of Prim's controlling type with Prim's address.\n \n+   function Fill_Secondary_DT_Entry\n+     (Loc          : Source_Ptr;\n+      Prim         : Entity_Id;\n+      Thunk_Id     : Entity_Id;\n+      Iface_DT_Ptr : Entity_Id) return Node_Id;\n+   --  (Ada 2005): Generate the code necessary to fill the appropriate entry of\n+   --  the secondary dispatch table of Prim's controlling type with Thunk_Id's\n+   --  address.\n+\n    procedure Make_Abstract_Interface_DT\n      (AI_Tag          : Entity_Id;\n       Acc_Disp_Tables : in out Elist_Id;\n@@ -102,9 +110,10 @@ package Exp_Disp is\n    --  secondary dispatch table\n \n    function Expand_Interface_Thunk\n-     (N         : Node_Id;\n-      Thunk_Id  : Entity_Id;\n-      Iface_Tag : Entity_Id) return Node_Id;\n+     (N           : Node_Id;\n+      Thunk_Alias : Node_Id;\n+      Thunk_Id    : Entity_Id;\n+      Iface_Tag   : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n    --  generate additional subprograms (thunks) to have a layout compatible\n    --  with the C++ ABI. The thunk modifies the value of the first actual of"}, {"sha": "643ed8a31e37f881aab67417da53d5bd24675e42", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 121, "deletions": 94, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ca505dc9c40cdb738dc6acec445a31b32a950e7/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3ca505dc9c40cdb738dc6acec445a31b32a950e7", "patch": "@@ -108,15 +108,6 @@ package body Exp_Util is\n    --  procedure of record with task components, or for a dynamically\n    --  created task that is assigned to a selected component.\n \n-   procedure Find_Interface_Tag\n-     (T         : Entity_Id;\n-      Iface     : Entity_Id;\n-      Iface_Tag : out Entity_Id;\n-      Iface_ADT : out Entity_Id);\n-   --  Ada 2005 (AI-251): Subsidiary procedure to Find_Interface_ADT and\n-   --  Find_Interface_Tag. Given a type T implementing the interface,\n-   --  returns the corresponding Tag and Access_Disp_Table entities.\n-\n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n@@ -1298,26 +1289,100 @@ package body Exp_Util is\n    -- Find_Interface_Tag --\n    ------------------------\n \n-   procedure Find_Interface_Tag\n-     (T         : Entity_Id;\n-      Iface     : Entity_Id;\n-      Iface_Tag : out Entity_Id;\n-      Iface_ADT : out Entity_Id)\n+   function Find_Interface_ADT\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id\n+   is\n+      ADT   : Elmt_Id;\n+      Found : Boolean := False;\n+      Typ   : Entity_Id := T;\n+\n+      procedure Find_Secondary_Table (Typ : Entity_Id);\n+      --  Comment required ???\n+\n+      --------------------------\n+      -- Find_Secondary_Table --\n+      --------------------------\n+\n+      procedure Find_Secondary_Table (Typ : Entity_Id) is\n+         AI_Elmt : Elmt_Id;\n+         AI      : Node_Id;\n+\n+      begin\n+         if Etype (Typ) /= Typ then\n+            Find_Secondary_Table (Etype (Typ));\n+         end if;\n+\n+         if Present (Abstract_Interfaces (Typ))\n+           and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+         then\n+            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+            while Present (AI_Elmt) loop\n+               AI := Node (AI_Elmt);\n+\n+               if AI = Iface or else Is_Ancestor (Iface, AI) then\n+                  Found := True;\n+                  return;\n+               end if;\n+\n+               Next_Elmt (ADT);\n+               Next_Elmt (AI_Elmt);\n+            end loop;\n+         end if;\n+      end Find_Secondary_Table;\n+\n+   --  Start of processing for Find_Interface_Tag\n+\n+   begin\n+      --  Handle private types\n+\n+      if Has_Private_Declaration (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n+\n+      --  Handle access types\n+\n+      if Is_Access_Type (Typ) then\n+         Typ := Directly_Designated_Type (Typ);\n+      end if;\n+\n+      --  Handle task and protected types implementing interfaces\n+\n+      if Ekind (Typ) = E_Protected_Type\n+        or else Ekind (Typ) = E_Task_Type\n+      then\n+         Typ := Corresponding_Record_Type (Typ);\n+      end if;\n+\n+      ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+      pragma Assert (Present (Node (ADT)));\n+      Find_Secondary_Table (Typ);\n+      pragma Assert (Found);\n+      return Node (ADT);\n+   end Find_Interface_ADT;\n+\n+   ------------------------\n+   -- Find_Interface_Tag --\n+   ------------------------\n+\n+   function Find_Interface_Tag\n+     (T      : Entity_Id;\n+      Iface  : Entity_Id) return Entity_Id\n    is\n-      AI_Tag   : Entity_Id;\n-      ADT_Elmt : Elmt_Id;\n-      Found    : Boolean   := False;\n+      AI_Tag : Entity_Id;\n+      Found  : Boolean := False;\n+      Typ    : Entity_Id := T;\n \n-      procedure Find_AI_Tag (Typ : in Entity_Id; Found : in out Boolean);\n-      --  This must be commented ???\n+      procedure Find_Tag (Typ : in Entity_Id);\n+      --  Internal subprogram used to recursively climb to the ancestors\n \n       -----------------\n       -- Find_AI_Tag --\n       -----------------\n \n-      procedure Find_AI_Tag (Typ : in Entity_Id; Found : in out Boolean) is\n-         T       : Entity_Id := Typ;\n-         Etyp    : Entity_Id; -- := Etype (Typ); -- why is this commented ???\n+      procedure Find_Tag (Typ : in Entity_Id) is\n          AI_Elmt : Elmt_Id;\n          AI      : Node_Id;\n \n@@ -1326,60 +1391,31 @@ package body Exp_Util is\n          --  therefore shares the main tag.\n \n          if Typ = Iface then\n-            AI_Tag    := First_Tag_Component (Typ);\n-            ADT_Elmt  := First_Elmt (Access_Disp_Table (Typ));\n-            Found     := True;\n+            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+            AI_Tag := First_Tag_Component (Typ);\n+            Found  := True;\n             return;\n          end if;\n \n-         --  Handle private types\n-\n-         if Has_Private_Declaration (T)\n-           and then Present (Full_View (T))\n-         then\n-            T := Full_View (T);\n-         end if;\n-\n-         if Is_Access_Type (Typ) then\n-            T := Directly_Designated_Type (T);\n-\n-         elsif Ekind (T) = E_Protected_Type\n-           or else Ekind (T) = E_Task_Type\n-         then\n-            T := Corresponding_Record_Type (T);\n-         end if;\n-\n-         Etyp := Etype (T);\n-\n          --  Climb to the root type\n \n-         if Etyp /= Typ then\n-            Find_AI_Tag (Etyp, Found);\n+         if Etype (Typ) /= Typ then\n+            Find_Tag (Etype (Typ));\n          end if;\n \n          --  Traverse the list of interfaces implemented by the type\n \n          if not Found\n-           and then Present (Abstract_Interfaces (T))\n-           and then not Is_Empty_Elmt_List (Abstract_Interfaces (T))\n+           and then Present (Abstract_Interfaces (Typ))\n+           and then not (Is_Empty_Elmt_List (Abstract_Interfaces (Typ)))\n          then\n-            --  Skip the tag associated with the primary table (if\n-            --  already placed in the record)\n-\n-            if Etype (Node (First_Elmt\n-                              (Access_Disp_Table (T)))) = RTE (RE_Tag)\n-            then\n-               AI_Tag   := Next_Tag_Component (First_Tag_Component (T));\n-               ADT_Elmt := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n-            else\n-               AI_Tag   := First_Tag_Component (T);\n-               ADT_Elmt := First_Elmt (Access_Disp_Table (T));\n-            end if;\n+            --  Skip the tag associated with the primary table.\n \n+            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+            AI_Tag := Next_Tag_Component (First_Tag_Component (Typ));\n             pragma Assert (Present (AI_Tag));\n-            pragma Assert (Present (Node (ADT_Elmt)));\n \n-            AI_Elmt  := First_Elmt (Abstract_Interfaces (T));\n+            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n             while Present (AI_Elmt) loop\n                AI := Node (AI_Elmt);\n \n@@ -1390,47 +1426,38 @@ package body Exp_Util is\n \n                AI_Tag := Next_Tag_Component (AI_Tag);\n                Next_Elmt (AI_Elmt);\n-               Next_Elmt (ADT_Elmt);\n             end loop;\n          end if;\n-      end Find_AI_Tag;\n+      end Find_Tag;\n+\n+   --  Start of processing for Find_Interface_Tag\n \n    begin\n-      Find_AI_Tag (T, Found);\n-      pragma Assert (Found);\n+      --  Handle private types\n \n-      Iface_Tag := AI_Tag;\n-      Iface_ADT := Node (ADT_Elmt);\n-   end Find_Interface_Tag;\n+      if Has_Private_Declaration (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         Typ := Full_View (Typ);\n+      end if;\n \n-   ------------------------\n-   -- Find_Interface_Tag --\n-   ------------------------\n+      --  Handle access types\n \n-   function Find_Interface_ADT\n-     (T     : Entity_Id;\n-      Iface : Entity_Id) return Entity_Id\n-   is\n-      Iface_Tag : Entity_Id := Empty;\n-      Iface_ADT : Entity_Id := Empty;\n-   begin\n-      Find_Interface_Tag (T, Iface, Iface_Tag, Iface_ADT);\n-      return Iface_ADT;\n-   end Find_Interface_ADT;\n+      if Is_Access_Type (Typ) then\n+         Typ := Directly_Designated_Type (Typ);\n+      end if;\n \n-   ------------------------\n-   -- Find_Interface_Tag --\n-   ------------------------\n+      --  Handle task and protected types implementing interfaces\n \n-   function Find_Interface_Tag\n-     (T     : Entity_Id;\n-      Iface : Entity_Id) return Entity_Id\n-   is\n-      Iface_Tag : Entity_Id := Empty;\n-      Iface_ADT : Entity_Id := Empty;\n-   begin\n-      Find_Interface_Tag (T, Iface, Iface_Tag, Iface_ADT);\n-      return Iface_Tag;\n+      if Ekind (Typ) = E_Protected_Type\n+        or else Ekind (Typ) = E_Task_Type\n+      then\n+         Typ := Corresponding_Record_Type (Typ);\n+      end if;\n+\n+      Find_Tag (Typ);\n+      pragma Assert (Found);\n+      return AI_Tag;\n    end Find_Interface_Tag;\n \n    ------------------"}]}