{"sha": "d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiYjVjY2ZlYmZjMjllYTJhNTgzZmEzZmIwZDBmZmQ0OGUwZTIyNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-08-27T19:07:04Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-08-27T19:07:04Z"}, "message": "remove -floop-* flags\n\n2015-08-27  Sebastian Pop  <s.pop@samsung.com>\n\n\t* Makefile.in (OBJS): Remove graphite-blocking.o and\n\tgraphite-interchange.o.\n\t* common.opt (floop-strip-mine, floop-interchange, floop-block):\n\tAlias of floop-nest-optimize.\n\t* doc/invoke.texi (floop-strip-mine, floop-interchange, floop-block):\n\tDocument as alias of -floop-nest-optimize.\n\t* graphite-blocking.c: Remove.\n\t* graphite-interchange.c: Remove.\n\t* graphite-optimize-isl.c: Include dumpfile.h.\n\t(getScheduleForBand): Add dump for tiled loops.  Use\n\tPARAM_LOOP_BLOCK_TILE_SIZE instead of hard coded constant.\n\t* graphite-poly.c (scop_max_loop_depth): Remove.\n\t(print_scattering_function_1): Remove.\n\t(print_scattering_function): Remove.\n\t(print_scattering_functions): Remove.\n\t(debug_scattering_function): Remove.\n\t(debug_scattering_functions): Remove.\n\t(apply_poly_transforms): Remove use of flag_loop_block,\n\tflag_loop_strip_mine, and flag_loop_interchange.\n\t(new_poly_bb): Remove use of PBB_TRANSFORMED, PBB_SAVED, and\n\tPBB_ORIGINAL.\n\t(print_pdr_access_layout): Remove.\n\t(print_pdr): Print ISL representation.\n\t(new_scop): Remove use of SCOP_ORIGINAL_SCHEDULE,\n\tSCOP_TRANSFORMED_SCHEDULE, and SCOP_SAVED_SCHEDULE.\n\t(free_scop): Same.\n\t(openscop_print_pbb_domain): Remove.\n\t(print_pbb): Remove call to print_scattering_function.\n\t(openscop_print_scop_context): Remove.\n\t(print_scop_context): Do not print matrices anymore.\n\t(print_scop): Do not print SCOP_ORIGINAL_SCHEDULE and\n\tSCOP_TRANSFORMED_SCHEDULE.\n\t(print_isl_set): Add printing of a new line.\n\t(print_isl_map): Same.\n\t(print_isl_aff): Same.\n\t(print_isl_constraint): Same.\n\t(loop_to_lst): Remove.\n\t(scop_to_lst): Remove.\n\t(lst_indent_to): Remove.\n\t(print_lst): Remove.\n\t(debug_lst): Remove.\n\t(dot_lst_1): Remove.\n\t(dot_lst): Remove.\n\t(reverse_loop_at_level): Remove.\n\t(reverse_loop_for_pbbs): Remove.\n\t* graphite-poly.h (pdr_dim_iter_domain): Remove.\n\t(pdr_nb_params): Remove.\n\t(pdr_alias_set_dim): Remove.\n\t(pdr_subscript_dim): Remove.\n\t(pdr_iterator_dim): Remove.\n\t(pdr_parameter_dim): Remove.\n\t(same_pdr_p): Remove.\n\t(struct poly_scattering): Remove.\n\t(struct poly_bb): Remove _original, _transformed, _saved.\n\t(PBB_DOMAIN, PBB_ORIGINAL, PBB_ORIGINAL_SCATTERING): Remove.\n\t(PBB_TRANSFORMED, PBB_TRANSFORMED_SCATTERING, PBB_SAVED): Remove.\n\t(PBB_NB_LOCAL_VARIABLES): Remove.\n\t(PBB_NB_SCATTERING_TRANSFORM): Remove.\n\t(schedule_to_scattering): Remove.\n\t(number_of_write_pdrs): Remove.\n\t(pbb_dim_iter_domain): Remove.\n\t(pbb_nb_params): Remove.\n\t(pbb_nb_scattering_orig): Remove.\n\t(pbb_nb_scattering_transform): Remove.\n\t(pbb_nb_dynamic_scattering_transform): Remove.\n\t(pbb_nb_local_vars): Remove.\n\t(pbb_iterator_dim): Remove.\n\t(pbb_parameter_dim): Remove.\n\t(psco_scattering_dim): Remove.\n\t(psct_scattering_dim): Remove.\n\t(psct_local_var_dim): Remove.\n\t(psco_iterator_dim): Remove.\n\t(psct_iterator_dim): Remove.\n\t(psco_parameter_dim): Remove.\n\t(psct_parameter_dim): Remove.\n\t(psct_dynamic_dim): Remove.\n\t(psct_static_dim): Remove.\n\t(psct_add_local_variable): Remove.\n\t(new_lst_loop): Remove.\n\t(new_lst_stmt): Remove.\n\t(free_lst): Remove.\n\t(copy_lst): Remove.\n\t(lst_add_loop_under_loop): Remove.\n\t(lst_depth): Remove.\n\t(lst_dewey_number): Remove.\n\t(lst_dewey_number_at_depth): Remove.\n\t(lst_pred): Remove.\n\t(lst_succ): Remove.\n\t(lst_find_pbb): Remove.\n\t(find_lst_loop): Remove.\n\t(lst_find_first_pbb): Remove.\n\t(lst_empty_p): Remove.\n\t(lst_find_last_pbb): Remove.\n\t(lst_contains_p): Remove.\n\t(lst_contains_pbb): Remove.\n\t(lst_create_nest): Remove.\n\t(lst_remove_from_sequence): Remove.\n\t(lst_remove_loop_and_inline_stmts_in_loop_father): Remove.\n\t(lst_niter_for_loop): Remove.\n\t(pbb_update_scattering): Remove.\n\t(lst_update_scattering_under): Remove.\n\t(lst_update_scattering): Remove.\n\t(lst_insert_in_sequence): Remove.\n\t(lst_replace): Remove.\n\t(lst_substitute_3): Remove.\n\t(lst_distribute_lst): Remove.\n\t(lst_remove_all_before_including_pbb): Remove.\n\t(lst_remove_all_before_excluding_pbb): Remove.\n\t(struct scop): Remove original_schedule, transformed_schedule, and\n\tsaved_schedule.\n\t(SCOP_ORIGINAL_SCHEDULE, SCOP_TRANSFORMED_SCHEDULE): Remove.\n\t(SCOP_SAVED_SCHEDULE): Remove.\n\t(poly_scattering_new): Remove.\n\t(poly_scattering_free): Remove.\n\t(poly_scattering_copy): Remove.\n\t(store_scattering_pbb): Remove.\n\t(store_lst_schedule): Remove.\n\t(restore_lst_schedule): Remove.\n\t(store_scattering): Remove.\n\t(restore_scattering_pbb): Remove.\n\t(restore_scattering): Remove.\n\t* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons):\n\tRemove scattering_dimensions.  Do not use pbb_dim_iter_domain:\n\tcompute the scattering polyhedron dimension from the dimension of\n\tpbb->domain.\n\t(build_scop_scattering): Update call to\n\tbuild_pbb_scattering_polyhedrons.\n\t(build_poly_scop): Remove call to scop_to_lst.\n\t* graphite.c (graphite_transform_loops): Add call to print_scop.\n\t(gate_graphite_transforms): Remove use of flag_loop_block,\n\tflag_loop_interchange, and flag_loop_strip_mine.\n\ntestsuite/\n\n\t* gcc.dg/graphite/graphite.exp (interchange_files, block_files):\n\tReplaced by opt_files, compile with -floop-nest-optimize.\n\t* g++.dg/graphite/graphite.exp: Same.\n\t* gfortran.dg/graphite/graphite.exp: Same.\n\t* gcc.dg/graphite/block-0.c: Adjust pattern.\n\t* gcc.dg/graphite/block-1.c: Same.\n\t* gcc.dg/graphite/block-3.c: Same.\n\t* gcc.dg/graphite/block-4.c: Same.\n\t* gcc.dg/graphite/block-5.c: Same.\n\t* gcc.dg/graphite/block-6.c: Same.\n\t* gcc.dg/graphite/block-7.c: Same.\n\t* gcc.dg/graphite/block-8.c: Same.\n\t* gcc.dg/graphite/block-pr47654.c: Same.\n\t* gcc.dg/graphite/interchange-0.c: Same.\n\t* gcc.dg/graphite/interchange-1.c: Same.\n\t* gcc.dg/graphite/interchange-10.c: Same.\n\t* gcc.dg/graphite/interchange-11.c: Same.\n\t* gcc.dg/graphite/interchange-12.c: Same.\n\t* gcc.dg/graphite/interchange-13.c: Same.\n\t* gcc.dg/graphite/interchange-14.c: Same.\n\t* gcc.dg/graphite/interchange-15.c: Same.\n\t* gcc.dg/graphite/interchange-3.c: Same.\n\t* gcc.dg/graphite/interchange-4.c: Same.\n\t* gcc.dg/graphite/interchange-5.c: Same.\n\t* gcc.dg/graphite/interchange-6.c: Same.\n\t* gcc.dg/graphite/interchange-7.c: Same.\n\t* gcc.dg/graphite/interchange-8.c: Same.\n\t* gcc.dg/graphite/interchange-9.c: Same.\n\t* gcc.dg/graphite/interchange-mvt.c: Same.\n\t* gcc.dg/graphite/pr37485.c: Same.\n\t* gcc.dg/graphite/uns-block-1.c: Same.\n\t* gcc.dg/graphite/uns-interchange-12.c: Same.\n\t* gcc.dg/graphite/uns-interchange-14.c: Same.\n\t* gcc.dg/graphite/uns-interchange-15.c: Same.\n\t* gcc.dg/graphite/uns-interchange-9.c: Same.\n\t* gcc.dg/graphite/uns-interchange-mvt.c: Same.\n\t* gfortran.dg/graphite/interchange-3.f90: Same.\n\nFrom-SVN: r227277", "tree": {"sha": "880a7c9f5b8523640dba320e719c4decf87758ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/880a7c9f5b8523640dba320e719c4decf87758ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31da952a49ef2861ee35786a3e41865ac259599c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31da952a49ef2861ee35786a3e41865ac259599c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31da952a49ef2861ee35786a3e41865ac259599c"}], "stats": {"total": 2966, "additions": 275, "deletions": 2691}, "files": [{"sha": "189234a3a34fe5f5fa06b65f2da8e67eedd1ae5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -1,3 +1,137 @@\n+2015-08-27  Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* Makefile.in (OBJS): Remove graphite-blocking.o and\n+\tgraphite-interchange.o.\n+\t* common.opt (floop-strip-mine, floop-interchange, floop-block):\n+\tAlias of floop-nest-optimize.\n+\t* doc/invoke.texi (floop-strip-mine, floop-interchange, floop-block):\n+\tDocument as alias of -floop-nest-optimize.\n+\t* graphite-blocking.c: Remove.\n+\t* graphite-interchange.c: Remove.\n+\t* graphite-optimize-isl.c: Include dumpfile.h.\n+\t(getScheduleForBand): Add dump for tiled loops.  Use\n+\tPARAM_LOOP_BLOCK_TILE_SIZE instead of hard coded constant.\n+\t* graphite-poly.c (scop_max_loop_depth): Remove.\n+\t(print_scattering_function_1): Remove.\n+\t(print_scattering_function): Remove.\n+\t(print_scattering_functions): Remove.\n+\t(debug_scattering_function): Remove.\n+\t(debug_scattering_functions): Remove.\n+\t(apply_poly_transforms): Remove use of flag_loop_block,\n+\tflag_loop_strip_mine, and flag_loop_interchange.\n+\t(new_poly_bb): Remove use of PBB_TRANSFORMED, PBB_SAVED, and\n+\tPBB_ORIGINAL.\n+\t(print_pdr_access_layout): Remove.\n+\t(print_pdr): Print ISL representation.\n+\t(new_scop): Remove use of SCOP_ORIGINAL_SCHEDULE,\n+\tSCOP_TRANSFORMED_SCHEDULE, and SCOP_SAVED_SCHEDULE.\n+\t(free_scop): Same.\n+\t(openscop_print_pbb_domain): Remove.\n+\t(print_pbb): Remove call to print_scattering_function.\n+\t(openscop_print_scop_context): Remove.\n+\t(print_scop_context): Do not print matrices anymore.\n+\t(print_scop): Do not print SCOP_ORIGINAL_SCHEDULE and\n+\tSCOP_TRANSFORMED_SCHEDULE.\n+\t(print_isl_set): Add printing of a new line.\n+\t(print_isl_map): Same.\n+\t(print_isl_aff): Same.\n+\t(print_isl_constraint): Same.\n+\t(loop_to_lst): Remove.\n+\t(scop_to_lst): Remove.\n+\t(lst_indent_to): Remove.\n+\t(print_lst): Remove.\n+\t(debug_lst): Remove.\n+\t(dot_lst_1): Remove.\n+\t(dot_lst): Remove.\n+\t(reverse_loop_at_level): Remove.\n+\t(reverse_loop_for_pbbs): Remove.\n+\t* graphite-poly.h (pdr_dim_iter_domain): Remove.\n+\t(pdr_nb_params): Remove.\n+\t(pdr_alias_set_dim): Remove.\n+\t(pdr_subscript_dim): Remove.\n+\t(pdr_iterator_dim): Remove.\n+\t(pdr_parameter_dim): Remove.\n+\t(same_pdr_p): Remove.\n+\t(struct poly_scattering): Remove.\n+\t(struct poly_bb): Remove _original, _transformed, _saved.\n+\t(PBB_DOMAIN, PBB_ORIGINAL, PBB_ORIGINAL_SCATTERING): Remove.\n+\t(PBB_TRANSFORMED, PBB_TRANSFORMED_SCATTERING, PBB_SAVED): Remove.\n+\t(PBB_NB_LOCAL_VARIABLES): Remove.\n+\t(PBB_NB_SCATTERING_TRANSFORM): Remove.\n+\t(schedule_to_scattering): Remove.\n+\t(number_of_write_pdrs): Remove.\n+\t(pbb_dim_iter_domain): Remove.\n+\t(pbb_nb_params): Remove.\n+\t(pbb_nb_scattering_orig): Remove.\n+\t(pbb_nb_scattering_transform): Remove.\n+\t(pbb_nb_dynamic_scattering_transform): Remove.\n+\t(pbb_nb_local_vars): Remove.\n+\t(pbb_iterator_dim): Remove.\n+\t(pbb_parameter_dim): Remove.\n+\t(psco_scattering_dim): Remove.\n+\t(psct_scattering_dim): Remove.\n+\t(psct_local_var_dim): Remove.\n+\t(psco_iterator_dim): Remove.\n+\t(psct_iterator_dim): Remove.\n+\t(psco_parameter_dim): Remove.\n+\t(psct_parameter_dim): Remove.\n+\t(psct_dynamic_dim): Remove.\n+\t(psct_static_dim): Remove.\n+\t(psct_add_local_variable): Remove.\n+\t(new_lst_loop): Remove.\n+\t(new_lst_stmt): Remove.\n+\t(free_lst): Remove.\n+\t(copy_lst): Remove.\n+\t(lst_add_loop_under_loop): Remove.\n+\t(lst_depth): Remove.\n+\t(lst_dewey_number): Remove.\n+\t(lst_dewey_number_at_depth): Remove.\n+\t(lst_pred): Remove.\n+\t(lst_succ): Remove.\n+\t(lst_find_pbb): Remove.\n+\t(find_lst_loop): Remove.\n+\t(lst_find_first_pbb): Remove.\n+\t(lst_empty_p): Remove.\n+\t(lst_find_last_pbb): Remove.\n+\t(lst_contains_p): Remove.\n+\t(lst_contains_pbb): Remove.\n+\t(lst_create_nest): Remove.\n+\t(lst_remove_from_sequence): Remove.\n+\t(lst_remove_loop_and_inline_stmts_in_loop_father): Remove.\n+\t(lst_niter_for_loop): Remove.\n+\t(pbb_update_scattering): Remove.\n+\t(lst_update_scattering_under): Remove.\n+\t(lst_update_scattering): Remove.\n+\t(lst_insert_in_sequence): Remove.\n+\t(lst_replace): Remove.\n+\t(lst_substitute_3): Remove.\n+\t(lst_distribute_lst): Remove.\n+\t(lst_remove_all_before_including_pbb): Remove.\n+\t(lst_remove_all_before_excluding_pbb): Remove.\n+\t(struct scop): Remove original_schedule, transformed_schedule, and\n+\tsaved_schedule.\n+\t(SCOP_ORIGINAL_SCHEDULE, SCOP_TRANSFORMED_SCHEDULE): Remove.\n+\t(SCOP_SAVED_SCHEDULE): Remove.\n+\t(poly_scattering_new): Remove.\n+\t(poly_scattering_free): Remove.\n+\t(poly_scattering_copy): Remove.\n+\t(store_scattering_pbb): Remove.\n+\t(store_lst_schedule): Remove.\n+\t(restore_lst_schedule): Remove.\n+\t(store_scattering): Remove.\n+\t(restore_scattering_pbb): Remove.\n+\t(restore_scattering): Remove.\n+\t* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons):\n+\tRemove scattering_dimensions.  Do not use pbb_dim_iter_domain:\n+\tcompute the scattering polyhedron dimension from the dimension of\n+\tpbb->domain.\n+\t(build_scop_scattering): Update call to\n+\tbuild_pbb_scattering_polyhedrons.\n+\t(build_poly_scop): Remove call to scop_to_lst.\n+\t* graphite.c (graphite_transform_loops): Add call to print_scop.\n+\t(gate_graphite_transforms): Remove use of flag_loop_block,\n+\tflag_loop_interchange, and flag_loop_strip_mine.\n+\n 2015-08-27  Sebastian Pop  <s.pop@samsung.com>\n \n \t* common.opt (floop-unroll-and-jam): Make alias of floop-nest-optimize."}, {"sha": "3d1c1e5aba34dc08b60bb4eddb1697415d380ec9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -1277,10 +1277,8 @@ OBJS = \\\n \tgraph.o \\\n \tgraphds.o \\\n \tgraphite.o \\\n-\tgraphite-blocking.o \\\n \tgraphite-isl-ast-to-gimple.o \\\n \tgraphite-dependences.o \\\n-\tgraphite-interchange.o \\\n \tgraphite-optimize-isl.o \\\n \tgraphite-poly.o \\\n \tgraphite-scop-detection.o \\"}, {"sha": "94d1d88483327b56c65bfa06afdf77abf9310ab4", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -1341,16 +1341,16 @@ Common Report Var(flag_loop_parallelize_all) Optimization\n Mark all loops as parallel\n \n floop-strip-mine\n-Common Report Var(flag_loop_strip_mine) Optimization\n-Enable Loop Strip Mining transformation\n+Common Alias(floop-nest-optimize)\n+Enable loop nest transforms.  Same as -floop-nest-optimize\n \n floop-interchange\n-Common Report Var(flag_loop_interchange) Optimization\n-Enable Loop Interchange transformation\n+Common Alias(floop-nest-optimize)\n+Enable loop nest transforms.  Same as -floop-nest-optimize\n \n floop-block\n-Common Report Var(flag_loop_block) Optimization\n-Enable Loop Blocking transformation\n+Common Alias(floop-nest-optimize)\n+Enable loop nest transforms.  Same as -floop-nest-optimize\n \n floop-unroll-and-jam\n Common Alias(floop-nest-optimize)\n@@ -2315,8 +2315,8 @@ Common Report Var(flag_tree_loop_im) Init(1) Optimization\n Enable loop invariant motion on trees\n \n ftree-loop-linear\n-Common Alias(floop-interchange)\n-Enable loop interchange transforms.  Same as -floop-interchange\n+Common Alias(floop-nest-optimize)\n+Enable loop nest transforms.  Same as -floop-nest-optimize\n \n ftree-loop-ivcanon\n Common Report Var(flag_tree_loop_ivcanon) Init(1) Optimization"}, {"sha": "c0ec0fde639d6cd7cbb5b6858f19b4b2c2fdf5a9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 99, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -8734,102 +8734,19 @@ Perform loop optimizations on trees.  This flag is enabled by default\n at @option{-O} and higher.\n \n @item -ftree-loop-linear\n+@itemx -floop-interchange\n+@itemx -floop-strip-mine\n+@itemx -floop-block\n+@itemx -floop-unroll-and-jam\n @opindex ftree-loop-linear\n-Perform loop interchange transformations on tree.  Same as\n-@option{-floop-interchange}.  To use this code transformation, GCC has\n-to be configured with @option{--with-isl} to enable the Graphite loop\n-transformation infrastructure.\n-\n-@item -floop-interchange\n @opindex floop-interchange\n-Perform loop interchange transformations on loops.  Interchanging two\n-nested loops switches the inner and outer loops.  For example, given a\n-loop like:\n-@smallexample\n-DO J = 1, M\n-  DO I = 1, N\n-    A(J, I) = A(J, I) * C\n-  ENDDO\n-ENDDO\n-@end smallexample\n-@noindent\n-loop interchange transforms the loop as if it were written:\n-@smallexample\n-DO I = 1, N\n-  DO J = 1, M\n-    A(J, I) = A(J, I) * C\n-  ENDDO\n-ENDDO\n-@end smallexample\n-which can be beneficial when @code{N} is larger than the caches,\n-because in Fortran, the elements of an array are stored in memory\n-contiguously by column, and the original loop iterates over rows,\n-potentially creating at each access a cache miss.  This optimization\n-applies to all the languages supported by GCC and is not limited to\n-Fortran.  To use this code transformation, GCC has to be configured\n-with @option{--with-isl} to enable the Graphite loop transformation\n-infrastructure.\n-\n-@item -floop-strip-mine\n @opindex floop-strip-mine\n-Perform loop strip mining transformations on loops.  Strip mining\n-splits a loop into two nested loops.  The outer loop has strides\n-equal to the strip size and the inner loop has strides of the\n-original loop within a strip.  The strip length can be changed\n-using the @option{loop-block-tile-size} parameter.  For example,\n-given a loop like:\n-@smallexample\n-DO I = 1, N\n-  A(I) = A(I) + C\n-ENDDO\n-@end smallexample\n-@noindent\n-loop strip mining transforms the loop as if it were written:\n-@smallexample\n-DO II = 1, N, 51\n-  DO I = II, min (II + 50, N)\n-    A(I) = A(I) + C\n-  ENDDO\n-ENDDO\n-@end smallexample\n-This optimization applies to all the languages supported by GCC and is\n-not limited to Fortran.  To use this code transformation, GCC has to\n-be configured with @option{--with-isl} to enable the Graphite loop\n-transformation infrastructure.\n-\n-@item -floop-block\n @opindex floop-block\n-Perform loop blocking transformations on loops.  Blocking strip mines\n-each loop in the loop nest such that the memory accesses of the\n-element loops fit inside caches.  The strip length can be changed\n-using the @option{loop-block-tile-size} parameter.  For example, given\n-a loop like:\n-@smallexample\n-DO I = 1, N\n-  DO J = 1, M\n-    A(J, I) = B(I) + C(J)\n-  ENDDO\n-ENDDO\n-@end smallexample\n-@noindent\n-loop blocking transforms the loop as if it were written:\n-@smallexample\n-DO II = 1, N, 51\n-  DO JJ = 1, M, 51\n-    DO I = II, min (II + 50, N)\n-      DO J = JJ, min (JJ + 50, M)\n-        A(J, I) = B(I) + C(J)\n-      ENDDO\n-    ENDDO\n-  ENDDO\n-ENDDO\n-@end smallexample\n-which can be beneficial when @code{M} is larger than the caches,\n-because the innermost loop iterates over a smaller amount of data\n-which can be kept in the caches.  This optimization applies to all the\n-languages supported by GCC and is not limited to Fortran.  To use this\n-code transformation, GCC has to be configured with @option{--with-isl}\n-to enable the Graphite loop transformation infrastructure.\n+@opindex floop-unroll-and-jam\n+Perform loop nest optimizations.  Same as\n+@option{-floop-nest-optimize}.  To use this code transformation, GCC has\n+to be configured with @option{--with-isl} to enable the Graphite loop\n+transformation infrastructure.\n \n @item -fgraphite-identity\n @opindex fgraphite-identity\n@@ -8847,13 +8764,6 @@ optimizer based on the Pluto optimization algorithms.  It calculates a loop\n structure optimized for data-locality and parallelism.  This option\n is experimental.\n \n-@item -floop-unroll-and-jam\n-@opindex floop-unroll-and-jam\n-Perform loop nest transformations.  Same as\n-@option{-floop-nest-optimize}.  To use this code transformation, GCC has\n-to be configured with @option{--with-isl} to enable the Graphite loop\n-transformation infrastructure.\n-\n @item -floop-parallelize-all\n @opindex floop-parallelize-all\n Use the Graphite data dependence analysis to identify loops that can"}, {"sha": "343429484097d8118805f8c8ff0b9e0c796e17e0", "filename": "gcc/graphite-blocking.c", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31da952a49ef2861ee35786a3e41865ac259599c/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31da952a49ef2861ee35786a3e41865ac259599c/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=31da952a49ef2861ee35786a3e41865ac259599c", "patch": "@@ -1,270 +0,0 @@\n-/* Heuristics and transform for loop blocking and strip mining on\n-   polyhedral representation.\n-\n-   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n-   Pranav Garg  <pranav.garg2107@gmail.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#ifdef HAVE_isl\n-/* Workaround for GMP 5.1.3 bug, see PR56019.  */\n-#include <stddef.h>\n-\n-#include <isl/constraint.h>\n-#include <isl/set.h>\n-#include <isl/map.h>\n-#include <isl/union_map.h>\n-#include <isl/constraint.h>\n-\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"cfghooks.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"params.h\"\n-#include \"fold-const.h\"\n-#include \"gimple-iterator.h\"\n-#include \"tree-ssa-loop.h\"\n-#include \"dumpfile.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-data-ref.h\"\n-#include \"graphite-poly.h\"\n-\n-/* Strip mines with a factor STRIDE the scattering (time) dimension\n-   around PBB at depth TIME_DEPTH.\n-\n-   The following example comes from the wiki page:\n-   http://gcc.gnu.org/wiki/Graphite/Strip_mine\n-\n-   The strip mine of a loop with a tile of 64 can be obtained with a\n-   scattering function as follows:\n-\n-   $ cat ./albert_strip_mine.cloog\n-   # language: C\n-   c\n-\n-   # parameter {n | n >= 0}\n-   1 3\n-   #  n  1\n-   1  1  0\n-   1\n-   n\n-\n-   1 # Number of statements:\n-\n-   1\n-   # {i | 0 <= i <= n}\n-   2 4\n-   #  i  n   1\n-   1  1  0   0\n-   1 -1  1   0\n-\n-   0  0  0\n-   1\n-   i\n-\n-   1 # Scattering functions\n-\n-   3 6\n-   #  NEW  OLD    i    n    1\n-   1  -64    0    1    0    0\n-   1   64    0   -1    0   63\n-   0    0    1   -1    0    0\n-\n-   1\n-   NEW  OLD\n-\n-   #the output of CLooG is like this:\n-   #$ cloog ./albert_strip_mine.cloog\n-   # for (NEW=0;NEW<=floord(n,64);NEW++) {\n-   #   for (OLD=max(64*NEW,0);OLD<=min(64*NEW+63,n);OLD++) {\n-   #     S1(i = OLD) ;\n-   #   }\n-   # }\n-*/\n-\n-static void\n-pbb_strip_mine_time_depth (poly_bb_p pbb, int time_depth, int stride)\n-{\n-  isl_space *d;\n-  isl_constraint *c;\n-  int iter, strip;\n-  /* STRIP is the dimension that iterates with stride STRIDE.  */\n-  /* ITER is the dimension that enumerates single iterations inside\n-     one strip that has at most STRIDE iterations.  */\n-  strip = time_depth;\n-  iter = strip + 2;\n-\n-  pbb->transformed = isl_map_insert_dims (pbb->transformed, isl_dim_out,\n-\t\t\t\t\t  strip, 2);\n-\n-  /* Lower bound of the striped loop.  */\n-  d = isl_map_get_space (pbb->transformed);\n-  c = isl_inequality_alloc (isl_local_space_from_space (d));\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip, -stride);\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, iter, 1);\n-  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n-\n-  /* Upper bound of the striped loop.  */\n-  d = isl_map_get_space (pbb->transformed);\n-  c = isl_inequality_alloc (isl_local_space_from_space (d));\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip, stride);\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, iter, -1);\n-  c = isl_constraint_set_constant_si (c, stride - 1);\n-  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n-\n-  /* Static scheduling for ITER level.\n-     This is mandatory to keep the 2d + 1 canonical scheduling format.  */\n-  d = isl_map_get_space (pbb->transformed);\n-  c = isl_equality_alloc (isl_local_space_from_space (d));\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip + 1, 1);\n-  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n-}\n-\n-/* Returns true when strip mining with STRIDE of the loop LST is\n-   profitable.  */\n-\n-static bool\n-lst_strip_mine_profitable_p (lst_p lst, int stride)\n-{\n-  mpz_t niter, strip_stride;\n-  bool res;\n-\n-  gcc_assert (LST_LOOP_P (lst));\n-  mpz_init (strip_stride);\n-  mpz_init (niter);\n-\n-  mpz_set_si (strip_stride, stride);\n-  lst_niter_for_loop (lst, niter);\n-  res = (mpz_cmp (niter, strip_stride) > 0);\n-\n-  mpz_clear (strip_stride);\n-  mpz_clear (niter);\n-  return res;\n-}\n-\n-/* Strip-mines all the loops of LST with STRIDE.  Return the number of\n-   loops strip-mined.  */\n-\n-static int\n-lst_do_strip_mine_loop (lst_p lst, int depth, int stride)\n-{\n-  int i;\n-  lst_p l;\n-  poly_bb_p pbb;\n-\n-  if (!lst)\n-    return 0;\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int res = 0;\n-\n-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-\tres += lst_do_strip_mine_loop (l, depth, stride);\n-\n-      return res;\n-    }\n-\n-  pbb = LST_PBB (lst);\n-  pbb_strip_mine_time_depth (pbb, psct_dynamic_dim (pbb, depth), stride);\n-  return 1;\n-}\n-\n-/* Strip-mines all the loops of LST with STRIDE.  When STRIDE is zero,\n-   read the stride from the PARAM_LOOP_BLOCK_TILE_SIZE.  Return the\n-   number of strip-mined loops.\n-\n-   Strip mining transforms a loop\n-\n-   | for (i = 0; i < N; i++)\n-   |   S (i);\n-\n-   into the following loop nest:\n-\n-   | for (k = 0; k < N; k += STRIDE)\n-   |   for (j = 0; j < STRIDE; j++)\n-   |     S (i = k + j);\n-*/\n-\n-static int\n-lst_do_strip_mine (lst_p lst, int stride)\n-{\n-  int i;\n-  lst_p l;\n-  int res = 0;\n-  int depth;\n-\n-  if (!stride)\n-    stride = PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE);\n-\n-  if (!lst\n-      || !LST_LOOP_P (lst))\n-    return false;\n-\n-  FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-    res += lst_do_strip_mine (l, stride);\n-\n-  depth = lst_depth (lst);\n-  if (depth >= 0\n-      && lst_strip_mine_profitable_p (lst, stride))\n-    {\n-      res += lst_do_strip_mine_loop (lst, lst_depth (lst), stride);\n-      lst_add_loop_under_loop (lst);\n-    }\n-\n-  return res;\n-}\n-\n-/* Strip mines all the loops in SCOP.  Returns the number of\n-   strip-mined loops.  */\n-\n-int\n-scop_do_strip_mine (scop_p scop, int stride)\n-{\n-  return lst_do_strip_mine (SCOP_TRANSFORMED_SCHEDULE (scop), stride);\n-}\n-\n-/* Loop blocks all the loops in SCOP.  Returns true when we manage to\n-   block some loops.  */\n-\n-bool\n-scop_do_block (scop_p scop)\n-{\n-  store_scattering (scop);\n-\n-  /* If we don't strip mine at least two loops, or not interchange\n-     loops, the strip mine alone will not be profitable, and the\n-     transform is not a loop blocking: so revert the transform.  */\n-  if (lst_do_strip_mine (SCOP_TRANSFORMED_SCHEDULE (scop), 0) < 2\n-      || scop_do_interchange (scop) == 0)\n-    {\n-      restore_scattering (scop);\n-      return false;\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"SCoP will be loop blocked.\\n\");\n-\n-  return true;\n-}\n-\n-#endif"}, {"sha": "6b14955ced75325693191bc62a4c624ee10e069e", "filename": "gcc/graphite-interchange.c", "status": "removed", "additions": 0, "deletions": 656, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31da952a49ef2861ee35786a3e41865ac259599c/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31da952a49ef2861ee35786a3e41865ac259599c/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=31da952a49ef2861ee35786a3e41865ac259599c", "patch": "@@ -1,656 +0,0 @@\n-/* Interchange heuristics and transform for loop interchange on\n-   polyhedral representation.\n-\n-   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n-   Harsha Jagasia <harsha.jagasia@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#ifdef HAVE_isl\n-/* Workaround for GMP 5.1.3 bug, see PR56019.  */\n-#include <stddef.h>\n-\n-#include <isl/constraint.h>\n-#include <isl/aff.h>\n-#include <isl/set.h>\n-#include <isl/map.h>\n-#include <isl/union_map.h>\n-#include <isl/ilp.h>\n-#include <isl/val.h>\n-\n-/* Since ISL-0.13, the extern is in val_gmp.h.  */\n-#if !defined(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE) && defined(__cplusplus)\n-extern \"C\" {\n-#endif\n-#include <isl/val_gmp.h>\n-#if !defined(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE) && defined(__cplusplus)\n-}\n-#endif\n-\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"cfghooks.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"fold-const.h\"\n-#include \"gimple-iterator.h\"\n-#include \"tree-ssa-loop.h\"\n-#include \"dumpfile.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-data-ref.h\"\n-#include \"graphite-poly.h\"\n-\n-\n-/* XXX isl rewrite following comment */\n-/* Builds a linear expression, of dimension DIM, representing PDR's\n-   memory access:\n-\n-   L = r_{n}*r_{n-1}*...*r_{1}*s_{0} + ... + r_{n}*s_{n-1} + s_{n}.\n-\n-   For an array A[10][20] with two subscript locations s0 and s1, the\n-   linear memory access is 20 * s0 + s1: a stride of 1 in subscript s0\n-   corresponds to a memory stride of 20.\n-\n-   OFFSET is a number of dimensions to prepend before the\n-   subscript dimensions: s_0, s_1, ..., s_n.\n-\n-   Thus, the final linear expression has the following format:\n-   0 .. 0_{offset} | 0 .. 0_{nit} | 0 .. 0_{gd} | 0 | c_0 c_1 ... c_n\n-   where the expression itself is:\n-   c_0 * s_0 + c_1 * s_1 + ... c_n * s_n.  */\n-\n-static isl_constraint *\n-build_linearized_memory_access (isl_map *map, poly_dr_p pdr)\n-{\n-  isl_local_space *ls = isl_local_space_from_space (isl_map_get_space (map));\n-  isl_constraint *res = isl_equality_alloc (ls);\n-  isl_val *size = isl_val_int_from_ui (isl_map_get_ctx (map), 1);\n-\n-  unsigned nsubs = isl_set_dim (pdr->subscript_sizes, isl_dim_set);\n-  /* -1 for the already included L dimension.  */\n-  unsigned offset = isl_map_dim (map, isl_dim_out) - 1 - nsubs;\n-  res = isl_constraint_set_coefficient_si (res, isl_dim_out, offset + nsubs, -1);\n-  /* Go through all subscripts from last to first.  The dimension \"i=0\"\n-     is the alias set, ignore it.  */\n-  for (int i = nsubs - 1; i >= 1; i--)\n-    {\n-      isl_aff *extract_dim;\n-      res = isl_constraint_set_coefficient_val (res, isl_dim_out, offset + i,\n-\t\t\t\t\t\tisl_val_copy (size));\n-      isl_space *dc = isl_set_get_space (pdr->subscript_sizes);\n-      extract_dim = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n-      extract_dim = isl_aff_set_coefficient_si (extract_dim, isl_dim_in, i, 1);\n-      isl_val *max = isl_set_max_val (pdr->subscript_sizes, extract_dim);\n-      isl_aff_free (extract_dim);\n-\n-      /* The result is NULL in case of an error, the optimal value in case there\n-\t is one, negative infinity or infinity if the problem is unbounded and\n-\t NaN if the problem is empty.  */\n-      gcc_assert (max);\n-\n-      /* When one of the dimensions cannot be computed, we cannot build the size\n-\t of the array for any outer dimensions.  */\n-      if (!isl_val_is_int (max))\n-\t{\n-\t  isl_val_free (max);\n-\t  break;\n-\t}\n-      size = isl_val_mul (size, max);\n-    }\n-\n-  isl_val_free (size);\n-\n-  return res;\n-}\n-\n-/* Set STRIDE to the stride of PDR in memory by advancing by one in\n-   the loop at DEPTH.  */\n-\n-static void\n-pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n-{\n-  poly_bb_p pbb = PDR_PBB (pdr);\n-  isl_map *map;\n-  isl_set *set;\n-  isl_aff *aff;\n-  isl_space *dc;\n-  isl_constraint *lma, *c;\n-  isl_val *islstride;\n-  graphite_dim_t time_depth;\n-  unsigned offset, nt;\n-  unsigned i;\n-  /* XXX isl rewrite following comments.  */\n-  /* Builds a partial difference equations and inserts them\n-     into pointset powerset polyhedron P.  Polyhedron is assumed\n-     to have the format: T|I|T'|I'|G|S|S'|l1|l2.\n-\n-     TIME_DEPTH is the time dimension w.r.t. which we are\n-     differentiating.\n-     OFFSET represents the number of dimensions between\n-     columns t_{time_depth} and t'_{time_depth}.\n-     DIM_SCTR is the number of scattering dimensions.  It is\n-     essentially the dimensionality of the T vector.\n-\n-     The following equations are inserted into the polyhedron P:\n-     | t_1 = t_1'\n-     | ...\n-     | t_{time_depth-1} = t'_{time_depth-1}\n-     | t_{time_depth} = t'_{time_depth} + 1\n-     | t_{time_depth+1} = t'_{time_depth + 1}\n-     | ...\n-     | t_{dim_sctr} = t'_{dim_sctr}.  */\n-\n-  /* Add the equality: t_{time_depth} = t'_{time_depth} + 1.\n-     This is the core part of this alogrithm, since this\n-     constraint asks for the memory access stride (difference)\n-     between two consecutive points in time dimensions.  */\n-\n-  /* Add equalities:\n-     | t1 = t1'\n-     | ...\n-     | t_{time_depth-1} = t'_{time_depth-1}\n-     | t_{time_depth+1} = t'_{time_depth+1}\n-     | ...\n-     | t_{dim_sctr} = t'_{dim_sctr}\n-\n-     This means that all the time dimensions are equal except for\n-     time_depth, where the constraint is t_{depth} = t'_{depth} + 1\n-     step.  More to this: we should be careful not to add equalities\n-     to the 'coupled' dimensions, which happens when the one dimension\n-     is stripmined dimension, and the other dimension corresponds\n-     to the point loop inside stripmined dimension.  */\n-\n-  /* pdr->accesses:    [P1..nb_param,I1..nb_domain]->[a,S1..nb_subscript]\n-          ??? [P] not used for PDRs?\n-     pdr->subscript_sizes:      [a,S1..nb_subscript]\n-     pbb->domain:      [P1..nb_param,I1..nb_domain]\n-     pbb->transformed: [P1..nb_param,I1..nb_domain]->[T1..Tnb_sctr]\n-          [T] includes local vars (currently unused)\n-     \n-     First we create [P,I] -> [T,a,S].  */\n-  \n-  map = isl_map_flat_range_product (isl_map_copy (pbb->transformed),\n-\t\t\t\t    isl_map_copy (pdr->accesses));\n-  /* Add a dimension for L: [P,I] -> [T,a,S,L].*/\n-  map = isl_map_add_dims (map, isl_dim_out, 1);\n-  /* Build a constraint for \"lma[S] - L == 0\", effectively calculating\n-     L in terms of subscripts.  */\n-  lma = build_linearized_memory_access (map, pdr);\n-  /* And add it to the map, so we now have:\n-     [P,I] -> [T,a,S,L] : lma([S]) == L.  */\n-  map = isl_map_add_constraint (map, lma);\n-\n-  /* Then we create  [P,I,P',I'] -> [T,a,S,L,T',a',S',L'].  */\n-  map = isl_map_flat_product (map, isl_map_copy (map));\n-\n-  /* Now add the equality T[time_depth] == T'[time_depth]+1.  This will\n-     force L' to be the linear address at T[time_depth] + 1. */\n-  time_depth = psct_dynamic_dim (pbb, depth);\n-  /* Length of [a,S] plus [L] ...  */\n-  offset = 1 + isl_map_dim (pdr->accesses, isl_dim_out);\n-  /* ... plus [T].  */\n-  offset += isl_map_dim (pbb->transformed, isl_dim_out);\n-\n-  c = isl_equality_alloc (isl_local_space_from_space (isl_map_get_space (map)));\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, time_depth, 1);\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out,\n-\t\t\t\t\t offset + time_depth, -1);\n-  c = isl_constraint_set_constant_si (c, 1);\n-  map = isl_map_add_constraint (map, c);\n-\n-  /* Now we equate most of the T/T' elements (making PITaSL nearly\n-     the same is (PITaSL)', except for one dimension, namely for 'depth'\n-     (an index into [I]), after translating to index into [T].  Take care\n-     to not produce an empty map, which indicates we wanted to equate\n-     two dimensions that are already coupled via the above time_depth\n-     dimension.  Happens with strip mining where several scatter dimension\n-     are interdependend.  */\n-  /* Length of [T].  */\n-  nt = pbb_nb_scattering_transform (pbb) + pbb_nb_local_vars (pbb);\n-  for (i = 0; i < nt; i++)\n-    if (i != time_depth)\n-      {\n-\tisl_map *temp = isl_map_equate (isl_map_copy (map),\n-\t\t\t\t\tisl_dim_out, i,\n-\t\t\t\t\tisl_dim_out, offset + i);\n-\tif (isl_map_is_empty (temp))\n-\t  isl_map_free (temp);\n-\telse\n-\t  {\n-\t    isl_map_free (map);\n-\t    map = temp;\n-\t  }\n-      }\n-\n-  /* Now maximize the expression L' - L.  */\n-  set = isl_map_range (map);\n-  dc = isl_set_get_space (set);\n-  aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n-  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset - 1, -1);\n-  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset + offset - 1, 1);\n-  islstride = isl_set_max_val (set, aff);\n-  isl_val_get_num_gmp (islstride, stride);\n-  isl_val_free (islstride);\n-  isl_aff_free (aff);\n-  isl_set_free (set);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      gmp_fprintf (dump_file, \"\\nStride in BB_%d, DR_%d, depth %d:  %Zd \",\n-\t\t   pbb_index (pbb), PDR_ID (pdr), (int) depth, stride);\n-    }\n-}\n-\n-/* Sets STRIDES to the sum of all the strides of the data references\n-   accessed in LOOP at DEPTH.  */\n-\n-static void\n-memory_strides_in_loop_1 (lst_p loop, graphite_dim_t depth, mpz_t strides)\n-{\n-  int i, j;\n-  lst_p l;\n-  poly_dr_p pdr;\n-  mpz_t s, n;\n-\n-  mpz_init (s);\n-  mpz_init (n);\n-\n-  FOR_EACH_VEC_ELT (LST_SEQ (loop), j, l)\n-    if (LST_LOOP_P (l))\n-      memory_strides_in_loop_1 (l, depth, strides);\n-    else\n-      FOR_EACH_VEC_ELT (PBB_DRS (LST_PBB (l)), i, pdr)\n-\t{\n-\t  pdr_stride_in_loop (s, depth, pdr);\n-\t  mpz_set_si (n, PDR_NB_REFS (pdr));\n-\t  mpz_mul (s, s, n);\n-\t  mpz_add (strides, strides, s);\n-\t}\n-\n-  mpz_clear (s);\n-  mpz_clear (n);\n-}\n-\n-/* Sets STRIDES to the sum of all the strides of the data references\n-   accessed in LOOP at DEPTH.  */\n-\n-static void\n-memory_strides_in_loop (lst_p loop, graphite_dim_t depth, mpz_t strides)\n-{\n-  if (mpz_cmp_si (loop->memory_strides, -1) == 0)\n-    {\n-      mpz_set_si (strides, 0);\n-      memory_strides_in_loop_1 (loop, depth, strides);\n-    }\n-  else\n-    mpz_set (strides, loop->memory_strides);\n-}\n-\n-/* Return true when the interchange of loops LOOP1 and LOOP2 is\n-   profitable.\n-\n-   Example:\n-\n-   | int a[100][100];\n-   |\n-   | int\n-   | foo (int N)\n-   | {\n-   |   int j;\n-   |   int i;\n-   |\n-   |   for (i = 0; i < N; i++)\n-   |     for (j = 0; j < N; j++)\n-   |       a[j][2 * i] += 1;\n-   |\n-   |   return a[N][12];\n-   | }\n-\n-   The data access A[j][i] is described like this:\n-\n-   | i   j   N   a  s0  s1   1\n-   | 0   0   0   1   0   0  -5    = 0\n-   | 0  -1   0   0   1   0   0    = 0\n-   |-2   0   0   0   0   1   0    = 0\n-   | 0   0   0   0   1   0   0   >= 0\n-   | 0   0   0   0   0   1   0   >= 0\n-   | 0   0   0   0  -1   0 100   >= 0\n-   | 0   0   0   0   0  -1 100   >= 0\n-\n-   The linearized memory access L to A[100][100] is:\n-\n-   | i   j   N   a  s0  s1   1\n-   | 0   0   0   0 100   1   0\n-\n-   TODO: the shown format is not valid as it does not show the fact\n-   that the iteration domain \"i j\" is transformed using the scattering.\n-\n-   Next, to measure the impact of iterating once in loop \"i\", we build\n-   a maximization problem: first, we add to DR accesses the dimensions\n-   k, s2, s3, L1 = 100 * s0 + s1, L2, and D1: this is the polyhedron P1.\n-   L1 and L2 are the linearized memory access functions.\n-\n-   | i   j   N   a  s0  s1   k  s2  s3  L1  L2  D1   1\n-   | 0   0   0   1   0   0   0   0   0   0   0   0  -5    = 0  alias = 5\n-   | 0  -1   0   0   1   0   0   0   0   0   0   0   0    = 0  s0 = j\n-   |-2   0   0   0   0   1   0   0   0   0   0   0   0    = 0  s1 = 2 * i\n-   | 0   0   0   0   1   0   0   0   0   0   0   0   0   >= 0\n-   | 0   0   0   0   0   1   0   0   0   0   0   0   0   >= 0\n-   | 0   0   0   0  -1   0   0   0   0   0   0   0 100   >= 0\n-   | 0   0   0   0   0  -1   0   0   0   0   0   0 100   >= 0\n-   | 0   0   0   0 100   1   0   0   0  -1   0   0   0    = 0  L1 = 100 * s0 + s1\n-\n-   Then, we generate the polyhedron P2 by interchanging the dimensions\n-   (s0, s2), (s1, s3), (L1, L2), (k, i)\n-\n-   | i   j   N   a  s0  s1   k  s2  s3  L1  L2  D1   1\n-   | 0   0   0   1   0   0   0   0   0   0   0   0  -5    = 0  alias = 5\n-   | 0  -1   0   0   0   0   0   1   0   0   0   0   0    = 0  s2 = j\n-   | 0   0   0   0   0   0  -2   0   1   0   0   0   0    = 0  s3 = 2 * k\n-   | 0   0   0   0   0   0   0   1   0   0   0   0   0   >= 0\n-   | 0   0   0   0   0   0   0   0   1   0   0   0   0   >= 0\n-   | 0   0   0   0   0   0   0  -1   0   0   0   0 100   >= 0\n-   | 0   0   0   0   0   0   0   0  -1   0   0   0 100   >= 0\n-   | 0   0   0   0   0   0   0 100   1   0  -1   0   0    = 0  L2 = 100 * s2 + s3\n-\n-   then we add to P2 the equality k = i + 1:\n-\n-   |-1   0   0   0   0   0   1   0   0   0   0   0  -1    = 0  k = i + 1\n-\n-   and finally we maximize the expression \"D1 = max (P1 inter P2, L2 - L1)\".\n-\n-   Similarly, to determine the impact of one iteration on loop \"j\", we\n-   interchange (k, j), we add \"k = j + 1\", and we compute D2 the\n-   maximal value of the difference.\n-\n-   Finally, the profitability test is D1 < D2: if in the outer loop\n-   the strides are smaller than in the inner loop, then it is\n-   profitable to interchange the loops at DEPTH1 and DEPTH2.  */\n-\n-static bool\n-lst_interchange_profitable_p (lst_p nest, int depth1, int depth2)\n-{\n-  mpz_t d1, d2;\n-  bool res;\n-\n-  gcc_assert (depth1 < depth2);\n-\n-  mpz_init (d1);\n-  mpz_init (d2);\n-\n-  memory_strides_in_loop (nest, depth1, d1);\n-  memory_strides_in_loop (nest, depth2, d2);\n-\n-  res = mpz_cmp (d1, d2) < 0;\n-\n-  mpz_clear (d1);\n-  mpz_clear (d2);\n-\n-  return res;\n-}\n-\n-/* Interchanges the loops at DEPTH1 and DEPTH2 of the original\n-   scattering and assigns the resulting polyhedron to the transformed\n-   scattering.  */\n-\n-static void\n-pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2,\n-\t\t\t     poly_bb_p pbb)\n-{\n-  unsigned i;\n-  unsigned dim1 = psct_dynamic_dim (pbb, depth1);\n-  unsigned dim2 = psct_dynamic_dim (pbb, depth2);\n-  isl_space *d = isl_map_get_space (pbb->transformed);\n-  isl_space *d1 = isl_space_range (d);\n-  unsigned n = isl_space_dim (d1, isl_dim_out);\n-  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n-  isl_map *x = isl_map_universe (d2);\n-\n-  x = isl_map_equate (x, isl_dim_in, dim1, isl_dim_out, dim2);\n-  x = isl_map_equate (x, isl_dim_in, dim2, isl_dim_out, dim1);\n-\n-  for (i = 0; i < n; i++)\n-    if (i != dim1 && i != dim2)\n-      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n-\n-  pbb->transformed = isl_map_apply_range (pbb->transformed, x);\n-}\n-\n-/* Apply the interchange of loops at depths DEPTH1 and DEPTH2 to all\n-   the statements below LST.  */\n-\n-static void\n-lst_apply_interchange (lst_p lst, int depth1, int depth2)\n-{\n-  if (!lst)\n-    return;\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int i;\n-      lst_p l;\n-\n-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-\tlst_apply_interchange (l, depth1, depth2);\n-    }\n-  else\n-    pbb_interchange_loop_depths (depth1, depth2, LST_PBB (lst));\n-}\n-\n-/* Return true when the nest starting at LOOP1 and ending on LOOP2 is\n-   perfect: i.e. there are no sequence of statements.  */\n-\n-static bool\n-lst_perfectly_nested_p (lst_p loop1, lst_p loop2)\n-{\n-  if (loop1 == loop2)\n-    return true;\n-\n-  if (!LST_LOOP_P (loop1))\n-    return false;\n-\n-  return LST_SEQ (loop1).length () == 1\n-         && lst_perfectly_nested_p (LST_SEQ (loop1)[0], loop2);\n-}\n-\n-/* Transform the loop nest between LOOP1 and LOOP2 into a perfect\n-   nest.  To continue the naming tradition, this function is called\n-   after perfect_nestify.  NEST is set to the perfectly nested loop\n-   that is created.  BEFORE/AFTER are set to the loops distributed\n-   before/after the loop NEST.  */\n-\n-static void\n-lst_perfect_nestify (lst_p loop1, lst_p loop2, lst_p *before,\n-\t\t     lst_p *nest, lst_p *after)\n-{\n-  poly_bb_p first, last;\n-\n-  gcc_assert (loop1 && loop2\n-\t      && loop1 != loop2\n-\t      && LST_LOOP_P (loop1) && LST_LOOP_P (loop2));\n-\n-  first = LST_PBB (lst_find_first_pbb (loop2));\n-  last = LST_PBB (lst_find_last_pbb (loop2));\n-\n-  *before = copy_lst (loop1);\n-  *nest = copy_lst (loop1);\n-  *after = copy_lst (loop1);\n-\n-  lst_remove_all_before_including_pbb (*before, first, false);\n-  lst_remove_all_before_including_pbb (*after, last, true);\n-\n-  lst_remove_all_before_excluding_pbb (*nest, first, true);\n-  lst_remove_all_before_excluding_pbb (*nest, last, false);\n-\n-  if (lst_empty_p (*before))\n-    {\n-      free_lst (*before);\n-      *before = NULL;\n-    }\n-  if (lst_empty_p (*after))\n-    {\n-      free_lst (*after);\n-      *after = NULL;\n-    }\n-  if (lst_empty_p (*nest))\n-    {\n-      free_lst (*nest);\n-      *nest = NULL;\n-    }\n-}\n-\n-/* Try to interchange LOOP1 with LOOP2 for all the statements of the\n-   body of LOOP2.  LOOP1 contains LOOP2.  Return true if it did the\n-   interchange.  */\n-\n-static bool\n-lst_try_interchange_loops (scop_p scop, lst_p loop1, lst_p loop2)\n-{\n-  int depth1 = lst_depth (loop1);\n-  int depth2 = lst_depth (loop2);\n-  lst_p transformed;\n-\n-  lst_p before = NULL, nest = NULL, after = NULL;\n-\n-  if (!lst_perfectly_nested_p (loop1, loop2))\n-    lst_perfect_nestify (loop1, loop2, &before, &nest, &after);\n-\n-  if (!lst_interchange_profitable_p (loop2, depth1, depth2))\n-    return false;\n-\n-  lst_apply_interchange (loop2, depth1, depth2);\n-\n-  /* Sync the transformed LST information and the PBB scatterings\n-     before using the scatterings in the data dependence analysis.  */\n-  if (before || nest || after)\n-    {\n-      transformed = lst_substitute_3 (SCOP_TRANSFORMED_SCHEDULE (scop), loop1,\n-\t\t\t\t      before, nest, after);\n-      lst_update_scattering (transformed);\n-      free_lst (transformed);\n-    }\n-\n-  if (graphite_legal_transform (scop))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Loops at depths %d and %d will be interchanged.\\n\",\n-\t\t depth1, depth2);\n-\n-      /* Transform the SCOP_TRANSFORMED_SCHEDULE of the SCOP.  */\n-      lst_insert_in_sequence (before, loop1, true);\n-      lst_insert_in_sequence (after, loop1, false);\n-\n-      if (nest)\n-\t{\n-\t  lst_replace (loop1, nest);\n-\t  free_lst (loop1);\n-\t}\n-\n-      return true;\n-    }\n-\n-  /* Undo the transform.  */\n-  free_lst (before);\n-  free_lst (nest);\n-  free_lst (after);\n-  lst_apply_interchange (loop2, depth2, depth1);\n-  return false;\n-}\n-\n-/* Selects the inner loop in LST_SEQ (INNER_FATHER) to be interchanged\n-   with the loop OUTER in LST_SEQ (OUTER_FATHER).  */\n-\n-static bool\n-lst_interchange_select_inner (scop_p scop, lst_p outer_father, int outer,\n-\t\t\t      lst_p inner_father)\n-{\n-  int inner;\n-  lst_p loop1, loop2;\n-\n-  gcc_assert (outer_father\n-\t      && LST_LOOP_P (outer_father)\n-\t      && LST_LOOP_P (LST_SEQ (outer_father)[outer])\n-\t      && inner_father\n-\t      && LST_LOOP_P (inner_father));\n-\n-  loop1 = LST_SEQ (outer_father)[outer];\n-\n-  FOR_EACH_VEC_ELT (LST_SEQ (inner_father), inner, loop2)\n-    if (LST_LOOP_P (loop2)\n-\t&& (lst_try_interchange_loops (scop, loop1, loop2)\n-\t    || lst_interchange_select_inner (scop, outer_father, outer, loop2)))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Interchanges all the loops of LOOP and the loops of its body that\n-   are considered profitable to interchange.  Return the number of\n-   interchanged loops.  OUTER is the index in LST_SEQ (LOOP) that\n-   points to the next outer loop to be considered for interchange.  */\n-\n-static int\n-lst_interchange_select_outer (scop_p scop, lst_p loop, int outer)\n-{\n-  lst_p l;\n-  int res = 0;\n-  int i = 0;\n-  lst_p father;\n-\n-  if (!loop || !LST_LOOP_P (loop))\n-    return 0;\n-\n-  father = LST_LOOP_FATHER (loop);\n-  if (father)\n-    {\n-      while (lst_interchange_select_inner (scop, father, outer, loop))\n-\t{\n-\t  res++;\n-\t  loop = LST_SEQ (father)[outer];\n-\t}\n-    }\n-\n-  if (LST_LOOP_P (loop))\n-    FOR_EACH_VEC_ELT (LST_SEQ (loop), i, l)\n-      if (LST_LOOP_P (l))\n-\tres += lst_interchange_select_outer (scop, l, i);\n-\n-  return res;\n-}\n-\n-/* Interchanges all the loop depths that are considered profitable for\n-   SCOP.  Return the number of interchanged loops.  */\n-\n-int\n-scop_do_interchange (scop_p scop)\n-{\n-  int res = lst_interchange_select_outer\n-    (scop, SCOP_TRANSFORMED_SCHEDULE (scop), 0);\n-\n-  lst_update_scattering (SCOP_TRANSFORMED_SCHEDULE (scop));\n-\n-  return res;\n-}\n-\n-\n-#endif /* HAVE_isl */\n-"}, {"sha": "ffa44652f63a490c6b469cb26cc75a25cb260a9b", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-data-ref.h\"\n #include \"graphite-poly.h\"\n #include \"params.h\"\n+#include \"dumpfile.h\"\n \n static isl_union_set *\n scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n@@ -177,12 +178,21 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n \n   /* It does not make any sense to tile a band with just one dimension.  */\n   if (*Dimensions == 1)\n-    return PartialSchedule;\n+    {\n+      if (dump_file && dump_flags)\n+\tfprintf (dump_file, \"not tiled\\n\");\n+      return PartialSchedule;\n+    }\n+\n+  if (dump_file && dump_flags)\n+    fprintf (dump_file, \"tiled by %d\\n\",\n+\t     PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n \n   ctx = isl_union_map_get_ctx (PartialSchedule);\n   Space = isl_union_map_get_space (PartialSchedule);\n \n-  TileMap = getTileMap (ctx, *Dimensions, 32);\n+  TileMap = getTileMap (ctx, *Dimensions,\n+\t\t\tPARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n   TileUMap = isl_union_map_from_map (isl_map_from_basic_map (TileMap));\n   TileUMap = isl_union_map_align_params (TileUMap, Space);\n   *Dimensions = 2 * *Dimensions;"}, {"sha": "98e8ab01cdc6edb91d412213deaaf7ef9f7330f5", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 11, "deletions": 479, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -69,94 +69,6 @@ debug_gmp_value (mpz_t val)\n   gmp_fprintf (stderr, \"%Zd\", val);\n }\n \n-/* Return the maximal loop depth in SCOP.  */\n-\n-int\n-scop_max_loop_depth (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  int max_nb_loops = 0;\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      int nb_loops = pbb_dim_iter_domain (pbb);\n-      if (max_nb_loops < nb_loops)\n-        max_nb_loops = nb_loops;\n-    }\n-\n-  return max_nb_loops;\n-}\n-\n-/* Prints to FILE the scattering function of PBB, at some VERBOSITY\n-   level.  */\n-\n-static void\n-print_scattering_function_1 (FILE *file, poly_bb_p pbb, int verbosity)\n-{\n-  graphite_dim_t i;\n-\n-  if (verbosity > 0)\n-    {\n-      fprintf (file, \"# scattering bb_%d (\\n\", pbb_index (pbb));\n-      fprintf (file, \"#eq\");\n-\n-      for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)\n-\tfprintf (file, \"     s%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_local_vars (pbb); i++)\n-\tfprintf (file, \"    lv%d\", (int) i);\n-\n-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-\tfprintf (file, \"     i%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_params (pbb); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n-\n-  fprintf (file, \"isl\\n\");\n-  print_isl_map (file, pbb->transformed ? pbb->transformed : pbb->schedule);\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"#)\\n\");\n-}\n-\n-/* Prints to FILE the scattering function of PBB, at some VERBOSITY\n-   level.  */\n-\n-void\n-print_scattering_function (FILE *file, poly_bb_p pbb, int verbosity)\n-{\n-  if (!PBB_TRANSFORMED (pbb))\n-    return;\n-\n-  if (pbb->schedule || pbb->transformed)\n-    {\n-      if (verbosity > 0)\n-\tfprintf (file, \"# Scattering function is provided\\n\");\n-\n-      fprintf (file, \"1\\n\");\n-    }\n-  else\n-    {\n-      if (verbosity > 0)\n-\tfprintf (file, \"# Scattering function is not provided\\n\");\n-\n-      fprintf (file, \"0\\n\");\n-      return;\n-    }\n-\n-  print_scattering_function_1 (file, pbb, verbosity);\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"# Scattering names are not provided\\n\");\n-\n-  fprintf (file, \"0\\n\");\n-\n-}\n-\n /* Prints to FILE the iteration domain of PBB, at some VERBOSITY\n    level.  */\n \n@@ -166,18 +78,6 @@ print_iteration_domain (FILE *file, poly_bb_p pbb, int verbosity)\n   print_pbb_domain (file, pbb, verbosity);\n }\n \n-/* Prints to FILE the scattering functions of every PBB of SCOP.  */\n-\n-void\n-print_scattering_functions (FILE *file, scop_p scop, int verbosity)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    print_scattering_function (file, pbb, verbosity);\n-}\n-\n /* Prints to FILE the iteration domains of every PBB of SCOP, at some\n    VERBOSITY level.  */\n \n@@ -191,15 +91,6 @@ print_iteration_domains (FILE *file, scop_p scop, int verbosity)\n     print_iteration_domain (file, pbb, verbosity);\n }\n \n-/* Prints to STDERR the scattering function of PBB, at some VERBOSITY\n-   level.  */\n-\n-DEBUG_FUNCTION void\n-debug_scattering_function (poly_bb_p pbb, int verbosity)\n-{\n-  print_scattering_function (stderr, pbb, verbosity);\n-}\n-\n /* Prints to STDERR the iteration domain of PBB, at some VERBOSITY\n    level.  */\n \n@@ -209,15 +100,6 @@ debug_iteration_domain (poly_bb_p pbb, int verbosity)\n   print_iteration_domain (stderr, pbb, verbosity);\n }\n \n-/* Prints to STDERR the scattering functions of every PBB of SCOP, at\n-   some VERBOSITY level.  */\n-\n-DEBUG_FUNCTION void\n-debug_scattering_functions (scop_p scop, int verbosity)\n-{\n-  print_scattering_functions (stderr, scop, verbosity);\n-}\n-\n /* Prints to STDERR the iteration domains of every PBB of SCOP, at\n    some VERBOSITY level.  */\n \n@@ -236,28 +118,13 @@ apply_poly_transforms (scop_p scop)\n \n   /* Generate code even if we did not apply any real transformation.\n      This also allows to check the performance for the identity\n-     transformation: GIMPLE -> GRAPHITE -> GIMPLE\n-     Keep in mind that CLooG optimizes in control, so the loop structure\n-     may change, even if we only use -fgraphite-identity.  */\n+     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */\n   if (flag_graphite_identity)\n     transform_done = true;\n \n   if (flag_loop_parallelize_all)\n     transform_done = true;\n \n-  if (flag_loop_block)\n-    transform_done |= scop_do_block (scop);\n-  else\n-    {\n-      if (flag_loop_strip_mine)\n-\ttransform_done |= scop_do_strip_mine (scop, 0);\n-\n-      if (flag_loop_interchange)\n-\ttransform_done |= scop_do_interchange (scop);\n-    }\n-\n-  /* This pass needs to be run at the final stage, as it does not\n-     update the lst.  */\n   if (flag_loop_optimize_isl)\n     transform_done |= optimize_isl (scop);\n \n@@ -311,9 +178,6 @@ new_poly_bb (scop_p scop, void *black_box)\n   pbb->saved = NULL;\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n-  PBB_TRANSFORMED (pbb) = NULL;\n-  PBB_SAVED (pbb) = NULL;\n-  PBB_ORIGINAL (pbb) = NULL;\n   PBB_DRS (pbb).create (3);\n   PBB_IS_REDUCTION (pbb) = false;\n   GBB_PBB ((gimple_bb_p) black_box) = pbb;\n@@ -342,27 +206,6 @@ free_poly_bb (poly_bb_p pbb)\n   XDELETE (pbb);\n }\n \n-static void\n-print_pdr_access_layout (FILE *file, poly_bb_p pbb, poly_dr_p pdr)\n-{\n-  graphite_dim_t i;\n-\n-  fprintf (file, \"#  eq\");\n-\n-  fprintf (file, \"   alias\");\n-\n-  for (i = 0; i < PDR_NB_SUBSCRIPTS (pdr); i++)\n-    fprintf (file, \"   sub%d\", (int) i);\n-\n-  for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-    fprintf (file, \"     i%d\", (int) i);\n-\n-  for (i = 0; i < pbb_nb_params (pbb); i++)\n-    fprintf (file, \"     p%d\", (int) i);\n-\n-  fprintf (file, \"    cst\\n\");\n-}\n-\n /* Prints to FILE the polyhedral data reference PDR, at some VERBOSITY\n    level.  */\n \n@@ -397,14 +240,10 @@ print_pdr (FILE *file, poly_dr_p pdr, int verbosity)\n   if (verbosity > 0)\n     {\n       fprintf (file, \"# data accesses (\\n\");\n-      print_pdr_access_layout (file, PDR_PBB (pdr), pdr);\n+      print_isl_map (file, pdr->accesses);\n+      print_isl_set (file, pdr->subscript_sizes);\n+      fprintf (file, \"#)\\n\");\n     }\n-\n-  /* XXX isl dump accesses/subscripts */\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"#)\\n\");\n-\n   if (verbosity > 1)\n     fprintf (file, \"#)\\n\");\n }\n@@ -440,9 +279,6 @@ new_scop (sese region)\n   scop->may_waw_no_source = NULL;\n   scop_set_region (scop, region);\n   SCOP_BBS (scop).create (3);\n-  SCOP_ORIGINAL_SCHEDULE (scop) = NULL;\n-  SCOP_TRANSFORMED_SCHEDULE (scop) = NULL;\n-  SCOP_SAVED_SCHEDULE (scop) = NULL;\n   POLY_SCOP_P (scop) = false;\n \n   return scop;\n@@ -474,44 +310,9 @@ free_scop (scop_p scop)\n   isl_union_map_free (scop->may_waw);\n   isl_union_map_free (scop->must_waw_no_source);\n   isl_union_map_free (scop->may_waw_no_source);\n-  free_lst (SCOP_ORIGINAL_SCHEDULE (scop));\n-  free_lst (SCOP_TRANSFORMED_SCHEDULE (scop));\n-  free_lst (SCOP_SAVED_SCHEDULE (scop));\n   XDELETE (scop);\n }\n \n-/* Print to FILE the domain of PBB in OpenScop format, at some VERBOSITY\n-   level.  */\n-\n-static void\n-openscop_print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)\n-{\n-  graphite_dim_t i;\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-\n-  if (!pbb->domain)\n-    return;\n-\n-  if (verbosity > 0)\n-    {\n-      fprintf (file, \"\\n# Iteration domain of bb_%d (\\n\", GBB_BB (gbb)->index);\n-      fprintf (file, \"#eq\");\n-\n-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-\tfprintf (file, \"     i%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_params (pbb); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n-\n-  fprintf (file, \"XXX isl\\n\");\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"#)\\n\");\n-}\n-\n /* Print to FILE the domain of PBB, at some VERBOSITY level.  */\n \n void\n@@ -699,8 +500,7 @@ print_pbb (FILE *file, poly_bb_p pbb, int verbosity)\n       dump_gbb_cases (file, PBB_BLACK_BOX (pbb));\n     }\n \n-  openscop_print_pbb_domain (file, pbb, verbosity);\n-  print_scattering_function (file, pbb, verbosity);\n+  print_pbb_domain (file, pbb, verbosity);\n   print_pdrs (file, pbb, verbosity);\n   print_pbb_body (file, pbb, verbosity, false);\n \n@@ -748,58 +548,16 @@ print_scop_params (FILE *file, scop_p scop, int verbosity)\n     fprintf (file, \"#)\\n\");\n }\n \n-/* Print to FILE the context of SCoP in OpenScop format, at some VERBOSITY\n-   level.  */\n-\n-static void\n-openscop_print_scop_context (FILE *file, scop_p scop, int verbosity)\n-{\n-  graphite_dim_t i;\n-\n-  if (verbosity > 0)\n-    {\n-      fprintf (file, \"# Context (\\n\");\n-      fprintf (file, \"#eq\");\n-\n-      for (i = 0; i < scop_nb_params (scop); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n-\n-  if (scop->context)\n-    /* XXX isl print context */\n-    fprintf (file, \"XXX isl\\n\");\n-  else\n-    fprintf (file, \"0 %d 0 0 0 %d\\n\", (int) scop_nb_params (scop) + 2,\n-\t     (int) scop_nb_params (scop));\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"# )\\n\");\n-}\n-\n /* Print to FILE the context of SCoP, at some VERBOSITY level.  */\n \n void\n print_scop_context (FILE *file, scop_p scop, int verbosity)\n {\n-  graphite_dim_t i;\n-\n   if (verbosity > 0)\n-    {\n-      fprintf (file, \"# Context (\\n\");\n-      fprintf (file, \"#eq\");\n-\n-      for (i = 0; i < scop_nb_params (scop); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n+    fprintf (file, \"# Context (\\n\");\n \n   if (scop->context)\n     print_isl_set (file, scop->context);\n-  else\n-    fprintf (file, \"no isl context %d\\n\", (int) scop_nb_params (scop) + 2);\n \n   if (verbosity > 0)\n     fprintf (file, \"# )\\n\");\n@@ -815,7 +573,7 @@ print_scop (FILE *file, scop_p scop, int verbosity)\n \n   fprintf (file, \"SCoP 1\\n#(\\n\");\n   fprintf (file, \"# Language\\nGimple\\n\");\n-  openscop_print_scop_context (file, scop, verbosity);\n+  print_scop_context (file, scop, verbosity);\n   print_scop_params (file, scop, verbosity);\n \n   if (verbosity > 0)\n@@ -826,17 +584,6 @@ print_scop (FILE *file, scop_p scop, int verbosity)\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     print_pbb (file, pbb, verbosity);\n \n-  if (verbosity > 1)\n-    {\n-      fprintf (file, \"# original_lst (\\n\");\n-      print_lst (file, SCOP_ORIGINAL_SCHEDULE (scop), 0);\n-      fprintf (file, \"\\n#)\\n\");\n-\n-      fprintf (file, \"# transformed_lst (\\n\");\n-      print_lst (file, SCOP_TRANSFORMED_SCHEDULE (scop), 0);\n-      fprintf (file, \"\\n#)\\n\");\n-    }\n-\n   fprintf (file, \"#)\\n\");\n }\n \n@@ -888,6 +635,7 @@ print_isl_set (FILE *f, isl_set *set)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_set (p, set);\n+  p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n@@ -902,6 +650,7 @@ print_isl_map (FILE *f, isl_map *map)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_map (p, map);\n+  p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n@@ -916,6 +665,7 @@ print_isl_aff (FILE *f, isl_aff *aff)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_aff (p, aff);\n+  p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n@@ -930,6 +680,7 @@ print_isl_constraint (FILE *f, isl_constraint *c)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_constraint (p, c);\n+  p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n@@ -976,224 +727,5 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,\n   isl_set_free (transdomain);\n }\n \n-/* Translates LOOP to LST.  */\n-\n-static lst_p\n-loop_to_lst (loop_p loop, vec<poly_bb_p> bbs, int *i)\n-{\n-  poly_bb_p pbb;\n-  vec<lst_p> seq;\n-  seq.create (5);\n-\n-  for (; bbs.iterate (*i, &pbb); (*i)++)\n-    {\n-      lst_p stmt;\n-      basic_block bb = GBB_BB (PBB_BLACK_BOX (pbb));\n-\n-      if (bb->loop_father == loop)\n-\tstmt = new_lst_stmt (pbb);\n-      else if (flow_bb_inside_loop_p (loop, bb))\n-\t{\n-\t  loop_p next = loop->inner;\n-\n-\t  while (next && !flow_bb_inside_loop_p (next, bb))\n-\t    next = next->next;\n-\n-\t  stmt = loop_to_lst (next, bbs, i);\n-\t}\n-      else\n-\t{\n-\t  (*i)--;\n-\t  return new_lst_loop (seq);\n-\t}\n-\n-      seq.safe_push (stmt);\n-    }\n-\n-  return new_lst_loop (seq);\n-}\n-\n-/* Reads the original scattering of the SCOP and returns an LST\n-   representing it.  */\n-\n-void\n-scop_to_lst (scop_p scop)\n-{\n-  lst_p res;\n-  int i, n = SCOP_BBS (scop).length ();\n-  vec<lst_p> seq;\n-  seq.create (5);\n-  sese region = SCOP_REGION (scop);\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      poly_bb_p pbb = SCOP_BBS (scop)[i];\n-      loop_p loop = outermost_loop_in_sese (region, GBB_BB (PBB_BLACK_BOX (pbb)));\n-\n-      if (loop_in_sese_p (loop, region))\n-\tres = loop_to_lst (loop, SCOP_BBS (scop), &i);\n-      else\n-\tres = new_lst_stmt (pbb);\n-\n-      seq.safe_push (res);\n-    }\n-\n-  res = new_lst_loop (seq);\n-  SCOP_ORIGINAL_SCHEDULE (scop) = res;\n-  SCOP_TRANSFORMED_SCHEDULE (scop) = copy_lst (res);\n-}\n-\n-/* Print to FILE on a new line COLUMN white spaces.  */\n-\n-static void\n-lst_indent_to (FILE *file, int column)\n-{\n-  int i;\n-\n-  if (column > 0)\n-    fprintf (file, \"\\n#\");\n-\n-  for (i = 0; i < column; i++)\n-    fprintf (file, \" \");\n-}\n-\n-/* Print LST to FILE with INDENT spaces of indentation.  */\n-\n-void\n-print_lst (FILE *file, lst_p lst, int indent)\n-{\n-  if (!lst)\n-    return;\n-\n-  lst_indent_to (file, indent);\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int i;\n-      lst_p l;\n-\n-      if (LST_LOOP_FATHER (lst))\n-\tfprintf (file, \"%d (loop\", lst_dewey_number (lst));\n-      else\n-\tfprintf (file, \"#(root\");\n-\n-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-\tprint_lst (file, l, indent + 2);\n-\n-      fprintf (file, \")\");\n-    }\n-  else\n-    fprintf (file, \"%d stmt_%d\", lst_dewey_number (lst), pbb_index (LST_PBB (lst)));\n-}\n-\n-/* Print LST to STDERR.  */\n-\n-DEBUG_FUNCTION void\n-debug_lst (lst_p lst)\n-{\n-  print_lst (stderr, lst, 0);\n-}\n-\n-/* Pretty print to FILE the loop statement tree LST in DOT format.  */\n-\n-static void\n-dot_lst_1 (FILE *file, lst_p lst)\n-{\n-  if (!lst)\n-    return;\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int i;\n-      lst_p l;\n-\n-      if (!LST_LOOP_FATHER (lst))\n-\tfprintf (file, \"L -> L_%d_%d\\n\",\n-\t\t lst_depth (lst),\n-\t\t lst_dewey_number (lst));\n-      else\n-\tfprintf (file, \"L_%d_%d -> L_%d_%d\\n\",\n-\t\t lst_depth (LST_LOOP_FATHER (lst)),\n-\t\t lst_dewey_number (LST_LOOP_FATHER (lst)),\n-\t\t lst_depth (lst),\n-\t\t lst_dewey_number (lst));\n-\n-      FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-\tdot_lst_1 (file, l);\n-    }\n-\n-  else\n-    fprintf (file, \"L_%d_%d -> S_%d\\n\",\n-\t     lst_depth (LST_LOOP_FATHER (lst)),\n-\t     lst_dewey_number (LST_LOOP_FATHER (lst)),\n-\t     pbb_index (LST_PBB (lst)));\n-\n-}\n-\n-/* Display the LST using dotty.  */\n-\n-DEBUG_FUNCTION void\n-dot_lst (lst_p lst)\n-{\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *stream = fopen (\"/tmp/lst.dot\", \"w\");\n-  gcc_assert (stream);\n-\n-  fputs (\"digraph all {\\n\", stream);\n-  dot_lst_1 (stream, lst);\n-  fputs (\"}\\n\\n\", stream);\n-  fclose (stream);\n-\n-  system (\"dotty /tmp/lst.dot &\");\n-#else\n-  fputs (\"digraph all {\\n\", stderr);\n-  dot_lst_1 (stderr, lst);\n-  fputs (\"}\\n\\n\", stderr);\n-\n-#endif\n-}\n-\n-/* Reverse the loop around PBB at level DEPTH.  */\n-\n-isl_map *\n-reverse_loop_at_level (poly_bb_p pbb, int depth)\n-{\n-  unsigned i, depth_dim = psct_dynamic_dim (pbb, depth);\n-  isl_space *d = isl_map_get_space (pbb->transformed);\n-  isl_space *d1 = isl_space_range (d);\n-  unsigned n = isl_space_dim (d1, isl_dim_out);\n-  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n-  isl_map *x = isl_map_universe (isl_space_copy (d2));\n-  isl_constraint *c = isl_equality_alloc (isl_local_space_from_space (d2));\n-\n-  for (i = 0; i < n; i++)\n-    if (i != depth_dim)\n-      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n-\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_in, depth_dim, 1);\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_out, depth_dim, 1);\n-  x = isl_map_add_constraint (x, c);\n-  return x;\n-}\n-\n-/* Reverse the loop at level DEPTH for all the PBBS.  */\n-\n-isl_union_map *\n-reverse_loop_for_pbbs (scop_p scop, vec<poly_bb_p> pbbs, int depth)\n-{\n-  poly_bb_p pbb;\n-  int i;\n-  isl_space *space = isl_space_from_domain (isl_set_get_space (scop->context));\n-  isl_union_map *res = isl_union_map_empty (space);\n-\n-  for (i = 0; pbbs.iterate (i, &pbb); i++)\n-    res = isl_union_map_add_map (res, reverse_loop_at_level (pbb, depth));\n-\n-  return res;\n-}\n-\n-\n #endif  /* HAVE_isl */\n "}, {"sha": "3bd22f05ae8c592658f5cb0e3c8a29dbf572a300", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 1082, "changes": 1082, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -37,8 +37,6 @@ typedef struct scop *scop_p;\n \n typedef unsigned graphite_dim_t;\n \n-static inline graphite_dim_t pbb_dim_iter_domain (const struct poly_bb *);\n-static inline graphite_dim_t pbb_nb_params (const struct poly_bb *);\n static inline graphite_dim_t scop_nb_params (scop_p);\n \n /* A data reference can write or read some memory or we\n@@ -206,63 +204,6 @@ void new_poly_dr (poly_bb_p, int, enum poly_dr_type, void *,\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p, int);\n void print_pdr (FILE *, poly_dr_p, int);\n-static inline scop_p pdr_scop (poly_dr_p pdr);\n-\n-/* The dimension of the iteration domain of the scop of PDR.  */\n-\n-static inline graphite_dim_t\n-pdr_dim_iter_domain (poly_dr_p pdr)\n-{\n-  return pbb_dim_iter_domain (PDR_PBB (pdr));\n-}\n-\n-/* The number of parameters of the scop of PDR.  */\n-\n-static inline graphite_dim_t\n-pdr_nb_params (poly_dr_p pdr)\n-{\n-  return scop_nb_params (pdr_scop (pdr));\n-}\n-\n-/* The dimension of the alias set in PDR.  */\n-\n-static inline graphite_dim_t\n-pdr_alias_set_dim (poly_dr_p pdr)\n-{\n-  poly_bb_p pbb = PDR_PBB (pdr);\n-\n-  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n-}\n-\n-/* The dimension in PDR containing subscript S.  */\n-\n-static inline graphite_dim_t\n-pdr_subscript_dim (poly_dr_p pdr, graphite_dim_t s)\n-{\n-  poly_bb_p pbb = PDR_PBB (pdr);\n-\n-  return pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb) + 1 + s;\n-}\n-\n-/* The dimension in PDR containing the loop iterator ITER.  */\n-\n-static inline graphite_dim_t\n-pdr_iterator_dim (poly_dr_p pdr ATTRIBUTE_UNUSED, graphite_dim_t iter)\n-{\n-  return iter;\n-}\n-\n-/* The dimension in PDR containing parameter PARAM.  */\n-\n-static inline graphite_dim_t\n-pdr_parameter_dim (poly_dr_p pdr, graphite_dim_t param)\n-{\n-  poly_bb_p pbb = PDR_PBB (pdr);\n-\n-  return pbb_dim_iter_domain (pbb) + param;\n-}\n-\n-/* Returns true when PDR is a \"read\".  */\n \n static inline bool\n pdr_read_p (poly_dr_p pdr)\n@@ -286,27 +227,6 @@ pdr_may_write_p (poly_dr_p pdr)\n   return PDR_TYPE (pdr) == PDR_MAY_WRITE;\n }\n \n-/* Return true when PDR1 and PDR2 are similar data accesses: they have\n-   the same base array, and the same access functions.  */\n-\n-static inline bool\n-same_pdr_p (poly_dr_p pdr1, poly_dr_p pdr2)\n-{\n-  return PDR_NB_SUBSCRIPTS (pdr1) == PDR_NB_SUBSCRIPTS (pdr2)\n-    && PDR_BASE_OBJECT_SET (pdr1) == PDR_BASE_OBJECT_SET (pdr2);\n-}\n-\n-typedef struct poly_scattering *poly_scattering_p;\n-\n-struct poly_scattering\n-{\n-  /* The number of local variables.  */\n-  int nb_local_variables;\n-\n-  /* The number of scattering dimensions.  */\n-  int nb_scattering;\n-};\n-\n /* POLY_BB represents a blackbox in the polyhedral model.  */\n \n struct poly_bb\n@@ -345,15 +265,12 @@ struct poly_bb\n   vec<poly_dr_p> drs;\n \n   /* The original scattering.  */\n-  poly_scattering_p _original;\n   isl_map *schedule;\n \n   /* The transformed scattering.  */\n-  poly_scattering_p _transformed;\n   isl_map *transformed;\n \n   /* A copy of the transformed scattering.  */\n-  poly_scattering_p _saved;\n   isl_map *saved;\n \n   /* True when this PBB contains only a reduction statement.  */\n@@ -362,24 +279,12 @@ struct poly_bb\n \n #define PBB_BLACK_BOX(PBB) ((gimple_bb_p) PBB->black_box)\n #define PBB_SCOP(PBB) (PBB->scop)\n-#define PBB_DOMAIN(PBB) (NULL)\n #define PBB_DRS(PBB) (PBB->drs)\n-#define PBB_ORIGINAL(PBB) (PBB->_original)\n-#define PBB_ORIGINAL_SCATTERING(PBB) (NULL)\n-#define PBB_TRANSFORMED(PBB) (PBB->_transformed)\n-#define PBB_TRANSFORMED_SCATTERING(PBB) (NULL)\n-#define PBB_SAVED(PBB) (PBB->_saved)\n-/* XXX isl if we ever need local vars in the scatter, we can't use the\n-   out dimension of transformed to count the scatterting transform dimension.\n-   */\n-#define PBB_NB_LOCAL_VARIABLES(PBB) (0)\n-#define PBB_NB_SCATTERING_TRANSFORM(PBB) (isl_map_n_out (PBB->transformed))\n #define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)\n \n extern poly_bb_p new_poly_bb (scop_p, void *);\n extern void free_poly_bb (poly_bb_p);\n extern void debug_loop_vec (poly_bb_p);\n-extern void schedule_to_scattering (poly_bb_p, int);\n extern void print_pbb_domain (FILE *, poly_bb_p, int);\n extern void print_pbb (FILE *, poly_bb_p, int);\n extern void print_scop_context (FILE *, scop_p, int);\n@@ -412,22 +317,6 @@ extern bool optimize_isl (scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void debug_gmp_value (mpz_t);\n \n-/* Return the number of write data references in PBB.  */\n-\n-static inline int\n-number_of_write_pdrs (poly_bb_p pbb)\n-{\n-  int res = 0;\n-  int i;\n-  poly_dr_p pdr;\n-\n-  for (i = 0; PBB_DRS (pbb).iterate (i, &pdr); i++)\n-    if (PDR_TYPE (pdr) == PDR_WRITE)\n-      res++;\n-\n-  return res;\n-}\n-\n /* Returns a gimple_bb from BB.  */\n \n static inline gimple_bb_p\n@@ -452,8 +341,6 @@ pbb_bb (poly_bb_p pbb)\n   return GBB_BB (PBB_BLACK_BOX (pbb));\n }\n \n-/* The index of the PBB.  */\n-\n static inline int\n pbb_index (poly_bb_p pbb)\n {\n@@ -484,859 +371,6 @@ pbb_set_black_box (poly_bb_p pbb, void *black_box)\n   pbb->black_box = black_box;\n }\n \n-/* The number of loops around PBB: the dimension of the iteration\n-   domain.  */\n-\n-static inline graphite_dim_t\n-pbb_dim_iter_domain (const struct poly_bb *pbb)\n-{\n-  return isl_set_dim (pbb->domain, isl_dim_set);\n-}\n-\n-/* The number of params defined in PBB.  */\n-\n-static inline graphite_dim_t\n-pbb_nb_params (const struct poly_bb *pbb)\n-{\n-  scop_p scop = PBB_SCOP (pbb);\n-\n-  return scop_nb_params (scop);\n-}\n-\n-/* The number of scattering dimensions in the SCATTERING polyhedron\n-   of a PBB for a given SCOP.  */\n-\n-static inline graphite_dim_t\n-pbb_nb_scattering_orig (const struct poly_bb *pbb)\n-{\n-  return 2 * pbb_dim_iter_domain (pbb) + 1;\n-}\n-\n-/* The number of scattering dimensions in PBB.  */\n-\n-static inline graphite_dim_t\n-pbb_nb_scattering_transform (const struct poly_bb *pbb)\n-{\n-  return PBB_NB_SCATTERING_TRANSFORM (pbb);\n-}\n-\n-/* The number of dynamic scattering dimensions in PBB.  */\n-\n-static inline graphite_dim_t\n-pbb_nb_dynamic_scattering_transform (const struct poly_bb *pbb)\n-{\n-  /* This function requires the 2d + 1 scattering format to be\n-     invariant during all transformations.  */\n-  gcc_assert (PBB_NB_SCATTERING_TRANSFORM (pbb) % 2);\n-  return PBB_NB_SCATTERING_TRANSFORM (pbb) / 2;\n-}\n-\n-/* Returns the number of local variables used in the transformed\n-   scattering polyhedron of PBB.  */\n-\n-static inline graphite_dim_t\n-pbb_nb_local_vars (const struct poly_bb *pbb ATTRIBUTE_UNUSED)\n-{\n-  /* For now we do not have any local variables, as we do not do strip\n-     mining for example.  */\n-  return PBB_NB_LOCAL_VARIABLES (pbb);\n-}\n-\n-/* The dimension in the domain of PBB containing the iterator ITER.  */\n-\n-static inline graphite_dim_t\n-pbb_iterator_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t iter)\n-{\n-  return iter;\n-}\n-\n-/* The dimension in the domain of PBB containing the iterator ITER.  */\n-\n-static inline graphite_dim_t\n-pbb_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n-{\n-  return param\n-    + pbb_dim_iter_domain (pbb);\n-}\n-\n-/* The dimension in the original scattering polyhedron of PBB\n-   containing the scattering iterator SCATTER.  */\n-\n-static inline graphite_dim_t\n-psco_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n-{\n-  gcc_assert (scatter < pbb_nb_scattering_orig (pbb));\n-  return scatter;\n-}\n-\n-/* The dimension in the transformed scattering polyhedron of PBB\n-   containing the scattering iterator SCATTER.  */\n-\n-static inline graphite_dim_t\n-psct_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n-{\n-  gcc_assert (scatter <= pbb_nb_scattering_transform (pbb));\n-  return scatter;\n-}\n-\n-/* The dimension in the transformed scattering polyhedron of PBB of\n-   the local variable LV.  */\n-\n-static inline graphite_dim_t\n-psct_local_var_dim (poly_bb_p pbb, graphite_dim_t lv)\n-{\n-  gcc_assert (lv <= pbb_nb_local_vars (pbb));\n-  return lv + pbb_nb_scattering_transform (pbb);\n-}\n-\n-/* The dimension in the original scattering polyhedron of PBB\n-   containing the loop iterator ITER.  */\n-\n-static inline graphite_dim_t\n-psco_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n-{\n-  gcc_assert (iter < pbb_dim_iter_domain (pbb));\n-  return iter + pbb_nb_scattering_orig (pbb);\n-}\n-\n-/* The dimension in the transformed scattering polyhedron of PBB\n-   containing the loop iterator ITER.  */\n-\n-static inline graphite_dim_t\n-psct_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n-{\n-  gcc_assert (iter < pbb_dim_iter_domain (pbb));\n-  return iter\n-    + pbb_nb_scattering_transform (pbb)\n-    + pbb_nb_local_vars (pbb);\n-}\n-\n-/* The dimension in the original scattering polyhedron of PBB\n-   containing parameter PARAM.  */\n-\n-static inline graphite_dim_t\n-psco_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n-{\n-  gcc_assert (param < pbb_nb_params (pbb));\n-  return param\n-    + pbb_nb_scattering_orig (pbb)\n-    + pbb_dim_iter_domain (pbb);\n-}\n-\n-/* The dimension in the transformed scattering polyhedron of PBB\n-   containing parameter PARAM.  */\n-\n-static inline graphite_dim_t\n-psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n-{\n-  gcc_assert (param < pbb_nb_params (pbb));\n-  return param\n-    + pbb_nb_scattering_transform (pbb)\n-    + pbb_nb_local_vars (pbb)\n-    + pbb_dim_iter_domain (pbb);\n-}\n-\n-/* The scattering dimension of PBB corresponding to the dynamic level\n-   LEVEL.  */\n-\n-static inline graphite_dim_t\n-psct_dynamic_dim (poly_bb_p pbb, graphite_dim_t level)\n-{\n-  graphite_dim_t result = 1 + 2 * level;\n-\n-  gcc_assert (result < pbb_nb_scattering_transform (pbb));\n-  return result;\n-}\n-\n-/* The scattering dimension of PBB corresponding to the static\n-   sequence of the loop level LEVEL.  */\n-\n-static inline graphite_dim_t\n-psct_static_dim (poly_bb_p pbb, graphite_dim_t level)\n-{\n-  graphite_dim_t result = 2 * level;\n-\n-  gcc_assert (result < pbb_nb_scattering_transform (pbb));\n-  return result;\n-}\n-\n-/* Adds to the transformed scattering polyhedron of PBB a new local\n-   variable and returns its index.  */\n-\n-static inline graphite_dim_t\n-psct_add_local_variable (poly_bb_p pbb ATTRIBUTE_UNUSED)\n-{\n-  gcc_unreachable ();\n-  return 0;\n-}\n-\n-typedef struct lst *lst_p;\n-\n-/* Loops and Statements Tree.  */\n-struct lst {\n-\n-  /* LOOP_P is true when an LST node is a loop.  */\n-  bool loop_p;\n-\n-  /* A pointer to the loop that contains this node.  */\n-  lst_p loop_father;\n-\n-  /* The sum of all the memory strides for an LST loop.  */\n-  mpz_t memory_strides;\n-\n-  /* Loop nodes contain a sequence SEQ of LST nodes, statements\n-     contain a pointer to their polyhedral representation PBB.  */\n-  union {\n-    poly_bb_p pbb;\n-    vec<lst_p> seq;\n-  } node;\n-};\n-\n-#define LST_LOOP_P(LST) ((LST)->loop_p)\n-#define LST_LOOP_FATHER(LST) ((LST)->loop_father)\n-#define LST_PBB(LST) ((LST)->node.pbb)\n-#define LST_SEQ(LST) ((LST)->node.seq)\n-#define LST_LOOP_MEMORY_STRIDES(LST) ((LST)->memory_strides)\n-\n-void scop_to_lst (scop_p);\n-void print_lst (FILE *, lst_p, int);\n-void debug_lst (lst_p);\n-void dot_lst (lst_p);\n-\n-/* Creates a new LST loop with SEQ.  */\n-\n-static inline lst_p\n-new_lst_loop (vec<lst_p> seq)\n-{\n-  lst_p lst = XNEW (struct lst);\n-  int i;\n-  lst_p l;\n-\n-  LST_LOOP_P (lst) = true;\n-  LST_SEQ (lst) = seq;\n-  LST_LOOP_FATHER (lst) = NULL;\n-  mpz_init (LST_LOOP_MEMORY_STRIDES (lst));\n-  mpz_set_si (LST_LOOP_MEMORY_STRIDES (lst), -1);\n-\n-  for (i = 0; seq.iterate (i, &l); i++)\n-    LST_LOOP_FATHER (l) = lst;\n-\n-  return lst;\n-}\n-\n-/* Creates a new LST statement with PBB.  */\n-\n-static inline lst_p\n-new_lst_stmt (poly_bb_p pbb)\n-{\n-  lst_p lst = XNEW (struct lst);\n-\n-  LST_LOOP_P (lst) = false;\n-  LST_PBB (lst) = pbb;\n-  LST_LOOP_FATHER (lst) = NULL;\n-  return lst;\n-}\n-\n-/* Frees the memory used by LST.  */\n-\n-static inline void\n-free_lst (lst_p lst)\n-{\n-  if (!lst)\n-    return;\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int i;\n-      lst_p l;\n-\n-      for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-\tfree_lst (l);\n-\n-      mpz_clear (LST_LOOP_MEMORY_STRIDES (lst));\n-      LST_SEQ (lst).release ();\n-    }\n-\n-  free (lst);\n-}\n-\n-/* Returns a copy of LST.  */\n-\n-static inline lst_p\n-copy_lst (lst_p lst)\n-{\n-  if (!lst)\n-    return NULL;\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      int i;\n-      lst_p l;\n-      vec<lst_p> seq;\n-      seq.create (5);\n-\n-      for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-\tseq.safe_push (copy_lst (l));\n-\n-      return new_lst_loop (seq);\n-    }\n-\n-  return new_lst_stmt (LST_PBB (lst));\n-}\n-\n-/* Adds a new loop under the loop LST.  */\n-\n-static inline void\n-lst_add_loop_under_loop (lst_p lst)\n-{\n-  vec<lst_p> seq;\n-  seq.create (1);\n-  lst_p l = new_lst_loop (LST_SEQ (lst));\n-\n-  gcc_assert (LST_LOOP_P (lst));\n-\n-  LST_LOOP_FATHER (l) = lst;\n-  seq.quick_push (l);\n-  LST_SEQ (lst) = seq;\n-}\n-\n-/* Returns the loop depth of LST.  */\n-\n-static inline int\n-lst_depth (lst_p lst)\n-{\n-  if (!lst)\n-    return -2;\n-\n-  /* The depth of the outermost \"fake\" loop is -1.  This outermost\n-     loop does not have a loop father and it is just a container, as\n-     in the loop representation of GCC.  */\n-  if (!LST_LOOP_FATHER (lst))\n-    return -1;\n-\n-  return lst_depth (LST_LOOP_FATHER (lst)) + 1;\n-}\n-\n-/* Returns the Dewey number for LST.  */\n-\n-static inline int\n-lst_dewey_number (lst_p lst)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!lst)\n-    return -1;\n-\n-  if (!LST_LOOP_FATHER (lst))\n-    return 0;\n-\n-  FOR_EACH_VEC_ELT (LST_SEQ (LST_LOOP_FATHER (lst)), i, l)\n-    if (l == lst)\n-      return i;\n-\n-  return -1;\n-}\n-\n-/* Returns the Dewey number of LST at depth DEPTH.  */\n-\n-static inline int\n-lst_dewey_number_at_depth (lst_p lst, int depth)\n-{\n-  gcc_assert (lst && depth >= 0 && lst_depth (lst) <= depth);\n-\n-  if (lst_depth (lst) == depth)\n-    return lst_dewey_number (lst);\n-\n-  return lst_dewey_number_at_depth (LST_LOOP_FATHER (lst), depth);\n-}\n-\n-/* Returns the predecessor of LST in the sequence of its loop father.\n-   Returns NULL if LST is the first statement in the sequence.  */\n-\n-static inline lst_p\n-lst_pred (lst_p lst)\n-{\n-  int dewey;\n-  lst_p father;\n-\n-  if (!lst || !LST_LOOP_FATHER (lst))\n-    return NULL;\n-\n-  dewey = lst_dewey_number (lst);\n-  if (dewey == 0)\n-    return NULL;\n-\n-  father = LST_LOOP_FATHER (lst);\n-  return LST_SEQ (father)[dewey - 1];\n-}\n-\n-/* Returns the successor of LST in the sequence of its loop father.\n-   Returns NULL if there is none.  */\n-\n-static inline lst_p\n-lst_succ (lst_p lst)\n-{\n-  int dewey;\n-  lst_p father;\n-\n-  if (!lst || !LST_LOOP_FATHER (lst))\n-    return NULL;\n-\n-  dewey = lst_dewey_number (lst);\n-  father = LST_LOOP_FATHER (lst);\n-\n-  if (LST_SEQ (father).length () == (unsigned) dewey + 1)\n-    return NULL;\n-\n-  return LST_SEQ (father)[dewey + 1];\n-}\n-\n-\n-/* Return the LST node corresponding to PBB.  */\n-\n-static inline lst_p\n-lst_find_pbb (lst_p lst, poly_bb_p pbb)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!lst)\n-    return NULL;\n-\n-  if (!LST_LOOP_P (lst))\n-    return (pbb == LST_PBB (lst)) ? lst : NULL;\n-\n-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-    {\n-      lst_p res = lst_find_pbb (l, pbb);\n-      if (res)\n-\treturn res;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Return the LST node corresponding to the loop around STMT at depth\n-   LOOP_DEPTH.  */\n-\n-static inline lst_p\n-find_lst_loop (lst_p stmt, int loop_depth)\n-{\n-  lst_p loop = LST_LOOP_FATHER (stmt);\n-\n-  gcc_assert (loop_depth >= 0);\n-\n-  while (loop_depth < lst_depth (loop))\n-    loop = LST_LOOP_FATHER (loop);\n-\n-  return loop;\n-}\n-\n-/* Return the first LST representing a PBB statement in LST.  */\n-\n-static inline lst_p\n-lst_find_first_pbb (lst_p lst)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!lst)\n-    return NULL;\n-\n-  if (!LST_LOOP_P (lst))\n-    return lst;\n-\n-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-    {\n-      lst_p res = lst_find_first_pbb (l);\n-      if (res)\n-\treturn res;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Returns true when LST is a loop that does not contain\n-   statements.  */\n-\n-static inline bool\n-lst_empty_p (lst_p lst)\n-{\n-  return !lst_find_first_pbb (lst);\n-}\n-\n-/* Return the last LST representing a PBB statement in LST.  */\n-\n-static inline lst_p\n-lst_find_last_pbb (lst_p lst)\n-{\n-  int i;\n-  lst_p l, res = NULL;\n-\n-  if (!lst)\n-    return NULL;\n-\n-  if (!LST_LOOP_P (lst))\n-    return lst;\n-\n-  for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-    {\n-      lst_p last = lst_find_last_pbb (l);\n-\n-      if (last)\n-\tres = last;\n-    }\n-\n-  gcc_assert (res);\n-  return res;\n-}\n-\n-/* Returns true if LOOP contains LST, in other words, if LST is nested\n-   in LOOP.  */\n-\n-static inline bool\n-lst_contains_p (lst_p loop, lst_p lst)\n-{\n-  if (!loop || !lst || !LST_LOOP_P (loop))\n-    return false;\n-\n-  if (loop == lst)\n-    return true;\n-\n-  return lst_contains_p (loop, LST_LOOP_FATHER (lst));\n-}\n-\n-/* Returns true if LOOP contains PBB, in other words, if PBB is nested\n-   in LOOP.  */\n-\n-static inline bool\n-lst_contains_pbb (lst_p loop, poly_bb_p pbb)\n-{\n-  return lst_find_pbb (loop, pbb) ? true : false;\n-}\n-\n-/* Creates a loop nest of depth NB_LOOPS containing LST.  */\n-\n-static inline lst_p\n-lst_create_nest (int nb_loops, lst_p lst)\n-{\n-  lst_p res, loop;\n-  vec<lst_p> seq;\n-\n-  if (nb_loops == 0)\n-    return lst;\n-\n-  seq.create (1);\n-  loop = lst_create_nest (nb_loops - 1, lst);\n-  seq.quick_push (loop);\n-  res = new_lst_loop (seq);\n-  LST_LOOP_FATHER (loop) = res;\n-\n-  return res;\n-}\n-\n-/* Removes LST from the sequence of statements of its loop father.  */\n-\n-static inline void\n-lst_remove_from_sequence (lst_p lst)\n-{\n-  lst_p father = LST_LOOP_FATHER (lst);\n-  int dewey = lst_dewey_number (lst);\n-\n-  gcc_assert (lst && father && dewey >= 0);\n-\n-  LST_SEQ (father).ordered_remove (dewey);\n-  LST_LOOP_FATHER (lst) = NULL;\n-}\n-\n-/* Removes the loop LST and inline its body in the father loop.  */\n-\n-static inline void\n-lst_remove_loop_and_inline_stmts_in_loop_father (lst_p lst)\n-{\n-  lst_p l, father = LST_LOOP_FATHER (lst);\n-  int i, dewey = lst_dewey_number (lst);\n-\n-  gcc_assert (lst && father && dewey >= 0);\n-\n-  LST_SEQ (father).ordered_remove (dewey);\n-  LST_LOOP_FATHER (lst) = NULL;\n-\n-  FOR_EACH_VEC_ELT (LST_SEQ (lst), i, l)\n-    {\n-      LST_SEQ (father).safe_insert (dewey + i, l);\n-      LST_LOOP_FATHER (l) = father;\n-    }\n-}\n-\n-/* Sets NITER to the upper bound approximation of the number of\n-   iterations of loop LST.  */\n-\n-static inline void\n-lst_niter_for_loop (lst_p lst, mpz_t niter)\n-{\n-  int depth = lst_depth (lst);\n-  poly_bb_p pbb = LST_PBB (lst_find_first_pbb (lst));\n-\n-  gcc_assert (LST_LOOP_P (lst));\n-  pbb_number_of_iterations_at_time (pbb, psct_dynamic_dim (pbb, depth), niter);\n-}\n-\n-/* Updates the scattering of PBB to be at the DEWEY number in the loop\n-   at depth LEVEL.  */\n-\n-static inline void\n-pbb_update_scattering (poly_bb_p pbb, graphite_dim_t level, int dewey)\n-{\n-  graphite_dim_t sched = psct_static_dim (pbb, level);\n-  isl_space *d = isl_map_get_space (pbb->transformed);\n-  isl_space *d1 = isl_space_range (d);\n-  unsigned i, n = isl_space_dim (d1, isl_dim_out);\n-  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n-  isl_map *x = isl_map_universe (d2);\n-\n-  x = isl_map_fix_si (x, isl_dim_out, sched, dewey);\n-\n-  for (i = 0; i < n; i++)\n-    if (i != sched)\n-      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n-\n-  pbb->transformed = isl_map_apply_range (pbb->transformed, x);\n-}\n-\n-/* Updates the scattering of all the PBBs under LST to be at the DEWEY\n-   number in the loop at depth LEVEL.  */\n-\n-static inline void\n-lst_update_scattering_under (lst_p lst, int level, int dewey)\n-{\n-  int i;\n-  lst_p l;\n-\n-  gcc_assert (lst && level >= 0 && dewey >= 0);\n-\n-  if (LST_LOOP_P (lst))\n-    for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-      lst_update_scattering_under (l, level, dewey);\n-  else\n-    pbb_update_scattering (LST_PBB (lst), level, dewey);\n-}\n-\n-/* Updates the all the scattering levels of all the PBBs under\n-   LST.  */\n-\n-static inline void\n-lst_update_scattering (lst_p lst)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!lst)\n-    return;\n-\n-  if (LST_LOOP_FATHER (lst))\n-    {\n-      lst_p father = LST_LOOP_FATHER (lst);\n-      int dewey = lst_dewey_number (lst);\n-      int level = lst_depth (lst);\n-\n-      gcc_assert (lst && father && dewey >= 0 && level >= 0);\n-\n-      for (i = dewey; LST_SEQ (father).iterate (i, &l); i++)\n-\tlst_update_scattering_under (l, level, i);\n-    }\n-\n-  if (LST_LOOP_P (lst))\n-    for (i = 0; LST_SEQ (lst).iterate (i, &l); i++)\n-      lst_update_scattering (l);\n-}\n-\n-/* Inserts LST1 before LST2 if BEFORE is true; inserts LST1 after LST2\n-   if BEFORE is false.  */\n-\n-static inline void\n-lst_insert_in_sequence (lst_p lst1, lst_p lst2, bool before)\n-{\n-  lst_p father;\n-  int dewey;\n-\n-  /* Do not insert empty loops.  */\n-  if (!lst1 || lst_empty_p (lst1))\n-    return;\n-\n-  father = LST_LOOP_FATHER (lst2);\n-  dewey = lst_dewey_number (lst2);\n-\n-  gcc_assert (lst2 && father && dewey >= 0);\n-\n-  LST_SEQ (father).safe_insert (before ? dewey : dewey + 1, lst1);\n-  LST_LOOP_FATHER (lst1) = father;\n-}\n-\n-/* Replaces LST1 with LST2.  */\n-\n-static inline void\n-lst_replace (lst_p lst1, lst_p lst2)\n-{\n-  lst_p father;\n-  int dewey;\n-\n-  if (!lst2 || lst_empty_p (lst2))\n-    return;\n-\n-  father = LST_LOOP_FATHER (lst1);\n-  dewey = lst_dewey_number (lst1);\n-  LST_LOOP_FATHER (lst2) = father;\n-  LST_SEQ (father)[dewey] = lst2;\n-}\n-\n-/* Returns a copy of ROOT where LST has been replaced by a copy of the\n-   LSTs A B C in this sequence.  */\n-\n-static inline lst_p\n-lst_substitute_3 (lst_p root, lst_p lst, lst_p a, lst_p b, lst_p c)\n-{\n-  int i;\n-  lst_p l;\n-  vec<lst_p> seq;\n-\n-  if (!root)\n-    return NULL;\n-\n-  gcc_assert (lst && root != lst);\n-\n-  if (!LST_LOOP_P (root))\n-    return new_lst_stmt (LST_PBB (root));\n-\n-  seq.create (5);\n-\n-  for (i = 0; LST_SEQ (root).iterate (i, &l); i++)\n-    if (l != lst)\n-      seq.safe_push (lst_substitute_3 (l, lst, a, b, c));\n-    else\n-      {\n-\tif (!lst_empty_p (a))\n-\t  seq.safe_push (copy_lst (a));\n-\tif (!lst_empty_p (b))\n-\t  seq.safe_push (copy_lst (b));\n-\tif (!lst_empty_p (c))\n-\t  seq.safe_push (copy_lst (c));\n-      }\n-\n-  return new_lst_loop (seq);\n-}\n-\n-/* Moves LST before LOOP if BEFORE is true, and after the LOOP if\n-   BEFORE is false.  */\n-\n-static inline void\n-lst_distribute_lst (lst_p loop, lst_p lst, bool before)\n-{\n-  int loop_depth = lst_depth (loop);\n-  int depth = lst_depth (lst);\n-  int nb_loops = depth - loop_depth;\n-\n-  gcc_assert (lst && loop && LST_LOOP_P (loop) && nb_loops > 0);\n-\n-  lst_remove_from_sequence (lst);\n-  lst_insert_in_sequence (lst_create_nest (nb_loops, lst), loop, before);\n-}\n-\n-/* Removes from LOOP all the statements before/after and including PBB\n-   if BEFORE is true/false.  Returns the negation of BEFORE when the\n-   statement PBB has been found.  */\n-\n-static inline bool\n-lst_remove_all_before_including_pbb (lst_p loop, poly_bb_p pbb, bool before)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!loop || !LST_LOOP_P (loop))\n-    return before;\n-\n-  for (i = 0; LST_SEQ (loop).iterate (i, &l);)\n-    if (LST_LOOP_P (l))\n-      {\n-\tbefore = lst_remove_all_before_including_pbb (l, pbb, before);\n-\n-\tif (LST_SEQ (l).length () == 0)\n-\t  {\n-\t    LST_SEQ (loop).ordered_remove (i);\n-\t    free_lst (l);\n-\t  }\n-\telse\n-\t  i++;\n-      }\n-    else\n-      {\n-\tif (before)\n-\t  {\n-\t    if (LST_PBB (l) == pbb)\n-\t      before = false;\n-\n-\t    LST_SEQ (loop).ordered_remove (i);\n-\t    free_lst (l);\n-\t  }\n-\telse if (LST_PBB (l) == pbb)\n-\t  {\n-\t    before = true;\n-\t    LST_SEQ (loop).ordered_remove (i);\n-\t    free_lst (l);\n-\t  }\n-\telse\n-\t  i++;\n-      }\n-\n-  return before;\n-}\n-\n-/* Removes from LOOP all the statements before/after and excluding PBB\n-   if BEFORE is true/false; Returns the negation of BEFORE when the\n-   statement PBB has been found.  */\n-\n-static inline bool\n-lst_remove_all_before_excluding_pbb (lst_p loop, poly_bb_p pbb, bool before)\n-{\n-  int i;\n-  lst_p l;\n-\n-  if (!loop || !LST_LOOP_P (loop))\n-    return before;\n-\n-  for (i = 0; LST_SEQ (loop).iterate (i, &l);)\n-    if (LST_LOOP_P (l))\n-      {\n-\tbefore = lst_remove_all_before_excluding_pbb (l, pbb, before);\n-\n-\tif (LST_SEQ (l).length () == 0)\n-\t  {\n-\t    LST_SEQ (loop).ordered_remove (i);\n-\t    free_lst (l);\n-\t    continue;\n-\t  }\n-\n-\ti++;\n-      }\n-    else\n-      {\n-\tif (before && LST_PBB (l) != pbb)\n-\t  {\n-\t    LST_SEQ (loop).ordered_remove (i);\n-\t    free_lst (l);\n-\t    continue;\n-\t  }\n-\n-\ti++;\n-\n-\tif (LST_PBB (l) == pbb)\n-\t  before = before ? false : true;\n-      }\n-\n-  return before;\n-}\n-\n /* A SCOP is a Static Control Part of the program, simple enough to be\n    represented in polyhedral form.  */\n struct scop\n@@ -1352,9 +386,6 @@ struct scop\n      representation.  */\n   vec<poly_bb_p> bbs;\n \n-  /* Original, transformed and saved schedules.  */\n-  lst_p original_schedule, transformed_schedule, saved_schedule;\n-\n   /* The context describes known restrictions concerning the parameters\n      and relations in between the parameters.\n \n@@ -1389,21 +420,13 @@ struct scop\n #define SCOP_BBS(S) (S->bbs)\n #define SCOP_REGION(S) (S->region)\n #define SCOP_CONTEXT(S) (NULL)\n-#define SCOP_ORIGINAL_SCHEDULE(S) (S->original_schedule)\n-#define SCOP_TRANSFORMED_SCHEDULE(S) (S->transformed_schedule)\n-#define SCOP_SAVED_SCHEDULE(S) (S->saved_schedule)\n #define POLY_SCOP_P(S) (S->poly_scop_p)\n \n extern scop_p new_scop (sese);\n extern void free_scop (scop_p);\n extern void free_scops (vec<scop_p> );\n extern void print_generated_program (FILE *, scop_p);\n extern void debug_generated_program (scop_p);\n-extern void print_scattering_function (FILE *, poly_bb_p, int);\n-extern void print_scattering_functions (FILE *, scop_p, int);\n-extern void debug_scattering_function (poly_bb_p, int);\n-extern void debug_scattering_functions (scop_p, int);\n-extern int scop_max_loop_depth (scop_p);\n extern int unify_scattering_dimensions (scop_p);\n extern bool apply_poly_transforms (scop_p);\n extern bool graphite_legal_transform (scop_p);\n@@ -1432,114 +455,9 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n   scop->nb_params = nb_params;\n }\n \n-/* Allocates a new empty poly_scattering structure.  */\n-\n-static inline poly_scattering_p\n-poly_scattering_new (void)\n-{\n-  poly_scattering_p res = XNEW (struct poly_scattering);\n-\n-  res->nb_local_variables = 0;\n-  res->nb_scattering = 0;\n-  return res;\n-}\n-\n-/* Free a poly_scattering structure.  */\n-\n-static inline void\n-poly_scattering_free (poly_scattering_p s)\n-{\n-  free (s);\n-}\n-\n-/* Copies S and return a new scattering.  */\n-\n-static inline poly_scattering_p\n-poly_scattering_copy (poly_scattering_p s)\n-{\n-  poly_scattering_p res = poly_scattering_new ();\n-\n-  res->nb_local_variables = s->nb_local_variables;\n-  res->nb_scattering = s->nb_scattering;\n-  return res;\n-}\n-\n-/* Saves the transformed scattering of PBB.  */\n-\n-static inline void\n-store_scattering_pbb (poly_bb_p pbb)\n-{\n-  isl_map_free (pbb->saved);\n-  pbb->saved = isl_map_copy (pbb->transformed);\n-}\n-\n-/* Stores the SCOP_TRANSFORMED_SCHEDULE to SCOP_SAVED_SCHEDULE.  */\n-\n-static inline void\n-store_lst_schedule (scop_p scop)\n-{\n-  if (SCOP_SAVED_SCHEDULE (scop))\n-    free_lst (SCOP_SAVED_SCHEDULE (scop));\n-\n-  SCOP_SAVED_SCHEDULE (scop) = copy_lst (SCOP_TRANSFORMED_SCHEDULE (scop));\n-}\n-\n-/* Restores the SCOP_TRANSFORMED_SCHEDULE from SCOP_SAVED_SCHEDULE.  */\n-\n-static inline void\n-restore_lst_schedule (scop_p scop)\n-{\n-  if (SCOP_TRANSFORMED_SCHEDULE (scop))\n-    free_lst (SCOP_TRANSFORMED_SCHEDULE (scop));\n-\n-  SCOP_TRANSFORMED_SCHEDULE (scop) = copy_lst (SCOP_SAVED_SCHEDULE (scop));\n-}\n-\n-/* Saves the scattering for all the pbbs in the SCOP.  */\n-\n-static inline void\n-store_scattering (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  for (i = 0; SCOP_BBS (scop).iterate (i, &pbb); i++)\n-    store_scattering_pbb (pbb);\n-\n-  store_lst_schedule (scop);\n-}\n-\n-/* Restores the scattering of PBB.  */\n-\n-static inline void\n-restore_scattering_pbb (poly_bb_p pbb)\n-{\n-  gcc_assert (pbb->saved);\n-\n-  isl_map_free (pbb->transformed);\n-  pbb->transformed = isl_map_copy (pbb->saved);\n-}\n-\n-/* Restores the scattering for all the pbbs in the SCOP.  */\n-\n-static inline void\n-restore_scattering (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  for (i = 0; SCOP_BBS (scop).iterate (i, &pbb); i++)\n-    restore_scattering_pbb (pbb);\n-\n-  restore_lst_schedule (scop);\n-}\n-\n bool graphite_legal_transform (scop_p);\n-isl_map *reverse_loop_at_level (poly_bb_p, int);\n-isl_union_map *reverse_loop_for_pbbs (scop_p, vec<poly_bb_p> , int);\n __isl_give isl_union_map *extend_schedule (__isl_take isl_union_map *);\n \n-\n void\n compute_deps (scop_p scop, vec<poly_bb_p> pbbs,\n \t      isl_union_map **must_raw,"}, {"sha": "e64a6fce45f98b77983172bc4c21be836f4621a8", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -443,18 +443,12 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n /* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n    We generate SCATTERING_DIMENSIONS scattering dimensions.\n \n-   CLooG 0.15.0 and previous versions require, that all\n-   scattering functions of one CloogProgram have the same number of\n-   scattering dimensions, therefore we allow to specify it.  This\n-   should be removed in future versions of CLooG.\n-\n    The scattering polyhedron consists of these dimensions: scattering,\n    loop_iterators, parameters.\n \n    Example:\n \n    | scattering_dimensions = 5\n-   | used_scattering_dimensions = 3\n    | nb_iterators = 1\n    | scop_nb_params = 2\n    |\n@@ -475,15 +469,13 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n \n static void\n build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n-\t\t\t\t  poly_bb_p pbb, int scattering_dimensions)\n+\t\t\t\t  poly_bb_p pbb)\n {\n   int i;\n-  int nb_iterators = pbb_dim_iter_domain (pbb);\n-  int used_scattering_dimensions = nb_iterators * 2 + 1;\n   isl_val *val;\n   isl_space *dc, *dm;\n \n-  gcc_assert (scattering_dimensions >= used_scattering_dimensions);\n+  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;\n \n   dc = isl_set_get_space (pbb->domain);\n   dm = isl_space_add_dims (isl_space_from_domain (dc),\n@@ -577,7 +569,6 @@ build_scop_scattering (scop_p scop)\n     {\n       gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n       int prefix;\n-      int nb_scat_dims = pbb_dim_iter_domain (pbb) * 2 + 1;\n \n       if (previous_gbb)\n \tprefix = nb_common_loops (SCOP_REGION (scop), previous_gbb, gbb);\n@@ -588,7 +579,7 @@ build_scop_scattering (scop_p scop)\n \n       static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,\n \t\t\t\t\t\t prefix, 1);\n-      build_pbb_scattering_polyhedrons (static_sched, pbb, nb_scat_dims);\n+      build_pbb_scattering_polyhedrons (static_sched, pbb);\n     }\n \n   isl_aff_free (static_sched);\n@@ -3103,7 +3094,7 @@ rewrite_commutative_reductions_out_of_ssa (scop_p scop)\n }\n \n /* Can all ivs be represented by a signed integer?\n-   As CLooG might generate negative values in its expressions, signed loop ivs\n+   As ISL might generate negative values in its expressions, signed loop ivs\n    are required in the backend. */\n \n static bool\n@@ -3149,9 +3140,7 @@ build_poly_scop (scop_p scop)\n \n   build_scop_bbs (scop);\n \n-  /* FIXME: This restriction is needed to avoid a problem in CLooG.\n-     Once CLooG is fixed, remove this guard.  Anyways, it makes no\n-     sense to optimize a scop containing only PBBs that do not belong\n+  /* Do not optimize a scop containing only PBBs that do not belong\n      to any loops.  */\n   if (nb_pbbs_in_loops (scop) == 0)\n     return;\n@@ -3182,7 +3171,6 @@ build_poly_scop (scop_p scop)\n   rewrite_cross_bb_scalar_deps_out_of_ssa (scop);\n \n   build_scop_drs (scop);\n-  scop_to_lst (scop);\n   build_scop_scattering (scop);\n \n   /* This SCoP has been translated to the polyhedral"}, {"sha": "36b97a71e3f40db06c9054099c54c5d6e9260b8b", "filename": "gcc/graphite.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -25,12 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n    An early description of this pass can be found in the GCC Summit'06\n    paper \"GRAPHITE: Polyhedral Analyses and Optimizations for GCC\".\n    The wiki page http://gcc.gnu.org/wiki/Graphite contains pointers to\n-   the related work.\n-\n-   One important document to read is CLooG's internal manual:\n-   http://repo.or.cz/w/cloog-ppl.git?a=blob_plain;f=doc/cloog.texi;hb=HEAD\n-   that describes the data structure of loops used in this file, and\n-   the functions that are used for transforming the code.  */\n+   the related work.  */\n \n #include \"config.h\"\n \n@@ -286,6 +281,9 @@ graphite_transform_loops (void)\n \tscop->ctx = ctx;\n \tbuild_poly_scop (scop);\n \n+\tif (dump_file && dump_flags)\n+\t  print_scop (dump_file, scop, 3);\n+\n \tif (POLY_SCOP_P (scop)\n \t    && apply_poly_transforms (scop)\n \t    && graphite_regenerate_ast_isl (scop))\n@@ -326,10 +324,7 @@ gate_graphite_transforms (void)\n {\n   /* Enable -fgraphite pass if any one of the graphite optimization flags\n      is turned on.  */\n-  if (flag_loop_block\n-      || flag_loop_interchange\n-      || flag_loop_strip_mine\n-      || flag_graphite_identity\n+  if (flag_graphite_identity\n       || flag_loop_parallelize_all\n       || flag_loop_optimize_isl)\n     flag_graphite = 1;"}, {"sha": "e04ef9d3a090262f3081bc9de6f7607934e618a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -1,3 +1,43 @@\n+2015-08-27  Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* gcc.dg/graphite/graphite.exp (interchange_files, block_files):\n+\tReplaced by opt_files, compile with -floop-nest-optimize.\n+\t* g++.dg/graphite/graphite.exp: Same.\n+\t* gfortran.dg/graphite/graphite.exp: Same.\n+\t* gcc.dg/graphite/block-0.c: Adjust pattern.\n+\t* gcc.dg/graphite/block-1.c: Same.\n+\t* gcc.dg/graphite/block-3.c: Same.\n+\t* gcc.dg/graphite/block-4.c: Same.\n+\t* gcc.dg/graphite/block-5.c: Same.\n+\t* gcc.dg/graphite/block-6.c: Same.\n+\t* gcc.dg/graphite/block-7.c: Same.\n+\t* gcc.dg/graphite/block-8.c: Same.\n+\t* gcc.dg/graphite/block-pr47654.c: Same.\n+\t* gcc.dg/graphite/interchange-0.c: Same.\n+\t* gcc.dg/graphite/interchange-1.c: Same.\n+\t* gcc.dg/graphite/interchange-10.c: Same.\n+\t* gcc.dg/graphite/interchange-11.c: Same.\n+\t* gcc.dg/graphite/interchange-12.c: Same.\n+\t* gcc.dg/graphite/interchange-13.c: Same.\n+\t* gcc.dg/graphite/interchange-14.c: Same.\n+\t* gcc.dg/graphite/interchange-15.c: Same.\n+\t* gcc.dg/graphite/interchange-3.c: Same.\n+\t* gcc.dg/graphite/interchange-4.c: Same.\n+\t* gcc.dg/graphite/interchange-5.c: Same.\n+\t* gcc.dg/graphite/interchange-6.c: Same.\n+\t* gcc.dg/graphite/interchange-7.c: Same.\n+\t* gcc.dg/graphite/interchange-8.c: Same.\n+\t* gcc.dg/graphite/interchange-9.c: Same.\n+\t* gcc.dg/graphite/interchange-mvt.c: Same.\n+\t* gcc.dg/graphite/pr37485.c: Same.\n+\t* gcc.dg/graphite/uns-block-1.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-12.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-14.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-15.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-9.c: Same.\n+\t* gcc.dg/graphite/uns-interchange-mvt.c: Same.\n+\t* gfortran.dg/graphite/interchange-3.f90: Same.\n+\n 2015-08-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/67317"}, {"sha": "2d85cf7442f27c0922514f73d6bf71ca93710601", "filename": "gcc/testsuite/g++.dg/graphite/graphite.exp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgraphite%2Fgraphite.exp?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -41,8 +41,8 @@ set wait_to_run_files [lsort [glob -nocomplain $srcdir/$subdir/*.C ] ]\n set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.C ] ]\n set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.C ] ]\n set run_id_files      [lsort [glob -nocomplain $srcdir/$subdir/run-id-*.C ] ]\n-set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.C ] ]\n-set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.C ] ]\n+set opt_files         [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.C \\\n+\t\t\t\t\t       $srcdir/$subdir/block-*.C ] ]\n \n # Tests to be compiled.\n set dg-do-what-default compile\n@@ -52,16 +52,14 @@ g++-dg-runtest $id_files          \"\" \"-O2 -fgraphite-identity -ffast-math\"\n # Tests to be run.\n set dg-do-what-default run\n g++-dg-runtest $run_id_files      \"\" \"-O2 -fgraphite-identity\"\n-g++-dg-runtest $interchange_files \"\" \"-O2 -floop-interchange -fno-loop-block -fno-loop-strip-mine -ffast-math -fdump-tree-graphite-all\"\n-g++-dg-runtest $block_files       \"\" \"-O2 -floop-block -fno-loop-strip-mine -fno-loop-interchange -ffast-math -fdump-tree-graphite-all\"\n+g++-dg-runtest $opt_files         \"\" \"-O2 -floop-nest-optimize -ffast-math -fdump-tree-graphite-all\"\n \n # The default action for the rest of the files is 'compile'.\n set dg-do-what-default compile\n foreach f $scop_files        {lremove wait_to_run_files $f}\n foreach f $id_files          {lremove wait_to_run_files $f}\n foreach f $run_id_files      {lremove wait_to_run_files $f}\n-foreach f $interchange_files {lremove wait_to_run_files $f}\n-foreach f $block_files       {lremove wait_to_run_files $f}\n+foreach f $opt_files         {lremove wait_to_run_files $f}\n g++-dg-runtest $wait_to_run_files \"\" \"-pedantic-errors\"\n \n # Clean up."}, {"sha": "cb08a5fe56f2519224992f4d41e83475b8f40df9", "filename": "gcc/testsuite/gcc.dg/graphite/block-0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -42,4 +42,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-not \"will be loop blocked\" \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"not tiled\" 3 \"graphite\" } } */"}, {"sha": "19f9f20c3bc0be9f120a37b7236db56ce1905c4b", "filename": "gcc/testsuite/gcc.dg/graphite/block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 3 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } } */"}, {"sha": "fd0e661696a153c91f8100bb12db010a950870d1", "filename": "gcc/testsuite/gcc.dg/graphite/block-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -17,7 +17,7 @@ foo (void)\n {\n   int i, j, k;\n \n-  /* These loops contain too few iterations to be blocked by 64.  */\n+  /* These loops contain too few iterations to be blocked.  */\n   for (i = 0; i < 24; i++)\n     for (j = 0; j < 24; j++)\n       for (k = 0; k < 24; k++)\n@@ -58,4 +58,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */"}, {"sha": "744b481eaf00f7ceb452192e4ba10ba76adbfad0", "filename": "gcc/testsuite/gcc.dg/graphite/block-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -16,7 +16,7 @@ foo (void)\n {\n   int i, j, k;\n \n-  /* This should NOT be blocked: each loop iterates only 24 times.  */\n+  /* This should NOT be blocked.  */\n   for (i = 0; i < 24; i++)\n     for (j = 0; j < 24; j++)\n       for (k = 0; k < 24; k++)\n@@ -57,4 +57,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */"}, {"sha": "d30abf80fda41a9917a4ff9c515e4dcc5355d78f", "filename": "gcc/testsuite/gcc.dg/graphite/block-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-5.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -53,4 +53,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */"}, {"sha": "9f03448b957e14a14ab59c9fe31db1af451e3f89", "filename": "gcc/testsuite/gcc.dg/graphite/block-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-6.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -48,4 +48,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 0 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */"}, {"sha": "8b54e2670781171a506c295498f5f2551ad228f3", "filename": "gcc/testsuite/gcc.dg/graphite/block-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-7.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -54,4 +54,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */"}, {"sha": "d3fdf849d59adf5fb8e11e735eacc9ed15e6e336", "filename": "gcc/testsuite/gcc.dg/graphite/block-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-8.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -55,4 +55,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */"}, {"sha": "a7453c5e9a6c6e015964d119f4fab414a82af136", "filename": "gcc/testsuite/gcc.dg/graphite/block-pr47654.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-pr47654.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -21,4 +21,4 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-not \"will be loop blocked\" \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 1 \"graphite\" } } */"}, {"sha": "f2d1417d87eb9038f763273d246e9c119a0f9710", "filename": "gcc/testsuite/gcc.dg/graphite/graphite.exp", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fgraphite.exp?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -41,10 +41,10 @@ set wait_to_run_files [lsort [glob -nocomplain $srcdir/$subdir/*.c ] ]\n set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.c ] ]\n set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.c ] ]\n set run_id_files      [lsort [glob -nocomplain $srcdir/$subdir/run-id-*.c ] ]\n-set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c \\\n-\t\t\t      $srcdir/$subdir/uns-interchange-*.c ] ]\n-set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.c \\\n-\t\t\t      $srcdir/$subdir/uns-block-*.c ] ]\n+set opt_files         [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.c \\\n+\t\t\t\t\t       $srcdir/$subdir/uns-interchange-*.c \\\n+\t\t\t\t\t       $srcdir/$subdir/block-*.c \\\n+\t\t\t\t\t       $srcdir/$subdir/uns-block-*.c ] ]\n set vect_files        [lsort [glob -nocomplain $srcdir/$subdir/vect-*.c ] ]\n \n # Tests to be compiled.\n@@ -55,8 +55,7 @@ dg-runtest $id_files          \"\" \"-O2 -fgraphite-identity -ffast-math\"\n # Tests to be run.\n set dg-do-what-default run\n dg-runtest $run_id_files      \"\" \"-O2 -fgraphite-identity\"\n-dg-runtest $interchange_files \"\" \"-O2 -floop-interchange -fno-loop-block -fno-loop-strip-mine -ffast-math -fdump-tree-graphite-all\"\n-dg-runtest $block_files       \"\" \"-O2 -floop-block -fno-loop-strip-mine -fno-loop-interchange -ffast-math -fdump-tree-graphite-all\"\n+dg-runtest $opt_files         \"\" \"-O2 -ffast-math -floop-nest-optimize -fdump-tree-graphite-all\"\n \n # Vectorizer tests, to be run or compiled, depending on target capabilities.\n global DEFAULT_VECTCFLAGS\n@@ -71,8 +70,7 @@ set dg-do-what-default compile\n foreach f $scop_files        {lremove wait_to_run_files $f}\n foreach f $id_files          {lremove wait_to_run_files $f}\n foreach f $run_id_files      {lremove wait_to_run_files $f}\n-foreach f $interchange_files {lremove wait_to_run_files $f}\n-foreach f $block_files       {lremove wait_to_run_files $f}\n+foreach f $opt_files         {lremove wait_to_run_files $f}\n foreach f $vect_files        {lremove wait_to_run_files $f}\n dg-runtest $wait_to_run_files \"\" \"-ansi -pedantic-errors\"\n "}, {"sha": "2ea8f017b8e56f6a1a1b7786bc7056d47037623d", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-0.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "b9f12c7d20d635cf65102c4828851aa5cf896dbc", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-1.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -49,4 +49,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "29e11c722577e9572ebf94b925dbd94579d81177", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-10.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */"}, {"sha": "afd71230a63ab592693c3782c80c2aebda40938e", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-11.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "9d5e04c882bda81f167dfd78aa93f4a894a37bad", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-12.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -53,4 +53,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } } */"}, {"sha": "0e722e2632eb6b347c0f04a2c5d780170b898cc9", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-13.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-13.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -50,4 +50,4 @@ main (void)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "55c600247c0f7be9499c72a4d6df5ff0c03428e7", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-14.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-14.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -54,5 +54,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */"}, {"sha": "0b6829f14cfe4fcda0ccae048fc20c0e31af65aa", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-15.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-15.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -48,6 +48,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n-\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */"}, {"sha": "cdc02020197f2d8d2e5d6421f50eddf6a160a169", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-3.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -47,4 +47,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "6712565828642a0d10aac7604329f0989c14fd3d", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-4.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "339e3b75f94767f306efe1f3afc55a9358056809", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-5.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "78f358e9ed246ab1c146e718ba38b0e177dfb2b5", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-6.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -47,4 +47,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "d99a16a291ab09894517299578a16acf26063712", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-7.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -46,4 +46,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "123106bb4759edf98a5632045d7e191917b896fb", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-8.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -82,4 +82,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 5 \"graphite\" } } */"}, {"sha": "e4c54ae181d2ac054e13ce1acd32a1b297a60701", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-9.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -44,4 +44,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */"}, {"sha": "bfa5c63b9d1d71d4fafdf8cd82a014759130f1c0", "filename": "gcc/testsuite/gcc.dg/graphite/interchange-mvt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Finterchange-mvt.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -58,6 +58,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" { xfail *-*-* } } } */\n-\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 7 \"graphite\" } } */"}, {"sha": "0a6dfbceefc94dc1224c9449c30f4b965f7abd05", "filename": "gcc/testsuite/gcc.dg/graphite/pr37485.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37485.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -floop-block -fno-loop-strip-mine -fno-loop-interchange -ffast-math -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -floop-block -ffast-math -fdump-tree-graphite-all\" } */\n \n typedef unsigned char   UChar;\n typedef int             Int32;\n@@ -30,4 +30,5 @@ void fallbackSort ( UInt32* fmap,\n    }\n    AssertH ( j < 256, 1005 );\n }\n-/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\" { xfail *-*-* }} } */\n+\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 1 \"graphite\" } } */"}, {"sha": "12a62919b5fad554dfbcc8e2cbdba302800995db", "filename": "gcc/testsuite/gcc.dg/graphite/uns-block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-block-1.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */"}, {"sha": "d9c07e2fe21eb43cba7bf75aa55ba61ea4892435", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-12.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -54,4 +54,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 4 \"graphite\" } } */"}, {"sha": "7ef575b667d18d0ef9f3622f99c2502da74cc7f2", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-14.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-14.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -55,5 +55,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 6 \"graphite\" } } */"}, {"sha": "0e32fd61456aa576d3a1e4c61df3ddd9baf4814e", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-15.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-15.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -49,6 +49,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n-\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "31b132253c6c714db1cc0db446e4ae8187ee52db", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-9.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -45,4 +45,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } } */"}, {"sha": "eebece386985d26f6f69067d41cd250542c0c14a", "filename": "gcc/testsuite/gcc.dg/graphite/uns-interchange-mvt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-mvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-mvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Funs-interchange-mvt.c?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -59,6 +59,4 @@ main (void)\n   return 0;\n }\n \n-/* PRE destroys the perfect nest and we can't cope with that yet.  */\n-/* { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } } */\n-\n+/* { dg-final { scan-tree-dump-times \"tiled by\" 3 \"graphite\" } } */"}, {"sha": "93863c32922904e03c5aa169c94198eb596ea83d", "filename": "gcc/testsuite/gfortran.dg/graphite/graphite.exp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fgraphite.exp?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -38,9 +38,9 @@ set save-dg-do-what-default ${dg-do-what-default}\n dg-init\n \n set wait_to_run_files [lsort [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95,03,08} ] ]\n-set block_files       [lsort [glob -nocomplain $srcdir/$subdir/block-*.\\[fF\\]{,90,95,03,08} ] ]\n set id_files          [lsort [glob -nocomplain $srcdir/$subdir/id-*.\\[fF\\]{,90,95,03,08} ] ]\n-set interchange_files [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.\\[fF\\]{,90,95,03,08} ] ]\n+set opt_files         [lsort [glob -nocomplain $srcdir/$subdir/interchange-*.\\[fF\\]{,90,95,03,08} \\\n+\t\t\t\t\t       $srcdir/$subdir/block-*.\\[fF\\]{,90,95,03,08} ] ]\n set scop_files        [lsort [glob -nocomplain $srcdir/$subdir/scop-*.\\[fF\\]{,90,95,03,08} ] ]\n set run_id_files      [lsort [glob -nocomplain $srcdir/$subdir/run-id-*.\\[fF\\]{,90,95,03,08} ] ]\n set vect_files        [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[fF\\]{,90,95,03,08} ] ]\n@@ -49,8 +49,7 @@ set vect_files        [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[fF\\]{,90\n set dg-do-what-default compile\n gfortran-dg-runtest $scop_files        \"\" \"-O2 -fgraphite -fdump-tree-graphite-all\"\n gfortran-dg-runtest $id_files          \"\" \"-O2 -fgraphite-identity -ffast-math\"\n-gfortran-dg-runtest $interchange_files \"\" \"-O2 -floop-interchange -fno-loop-block -fno-loop-strip-mine -ffast-math -fdump-tree-graphite-all\"\n-gfortran-dg-runtest $block_files       \"\" \"-O2 -floop-block -fno-loop-strip-mine -fno-loop-interchange -ffast-math -fdump-tree-graphite-all\"\n+gfortran-dg-runtest $opt_files         \"\" \"-O2 -floop-nest-optimize -ffast-math -fdump-tree-graphite-all\"\n \n # Vectorizer tests, to be run or compiled, depending on target capabilities.\n if [check_vect_support_and_set_flags] {\n@@ -63,9 +62,8 @@ gfortran-dg-runtest $run_id_files      \"\" \"-O2 -fgraphite-identity\"\n \n # The default action for the rest of the files is 'compile'.\n set dg-do-what-default compile\n-foreach f $block_files       {lremove wait_to_run_files $f}\n foreach f $id_files          {lremove wait_to_run_files $f}\n-foreach f $interchange_files {lremove wait_to_run_files $f}\n+foreach f $opt_files         {lremove wait_to_run_files $f}\n foreach f $scop_files        {lremove wait_to_run_files $f}\n foreach f $run_id_files      {lremove wait_to_run_files $f}\n foreach f $vect_files        {lremove wait_to_run_files $f}"}, {"sha": "a99cf153d9e3f396d01d414b9e31752ae15b0712", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90?ref=d6bb5ccfebfc29ea2a583fa3fb0d0ffd48e0e226", "patch": "@@ -24,4 +24,4 @@ Program FOO\n \n end Program FOO\n \n-! { dg-final { scan-tree-dump-times \"will be interchanged\" 1 \"graphite\" } }\n+! { dg-final { scan-tree-dump-times \"tiled by\" 2 \"graphite\" } }"}]}