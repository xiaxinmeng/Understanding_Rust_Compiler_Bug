{"sha": "8a57e88dc63d44a2f72781e4732ede00f14205cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE1N2U4OGRjNjNkNDRhMmY3Mjc4MWU0NzMyZWRlMDBmMTQyMDVjZg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-06-04T09:44:33Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-06-04T09:44:33Z"}, "message": "New attribute lookup function addition\n\n\t* tree.h (private_lookup_attribute_starting): New function.\n\t(lookup_attribute_starting): Likewise.\n\t* tree.c (private_lookup_attribute_starting): Likewise.\n\nFrom-SVN: r211219", "tree": {"sha": "1470e3aa0e88e7cee9a286e65c00ca02080a9d9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1470e3aa0e88e7cee9a286e65c00ca02080a9d9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a57e88dc63d44a2f72781e4732ede00f14205cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a57e88dc63d44a2f72781e4732ede00f14205cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a57e88dc63d44a2f72781e4732ede00f14205cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a57e88dc63d44a2f72781e4732ede00f14205cf/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d211e4719264a66f3a310870d7459751c335ce7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d211e4719264a66f3a310870d7459751c335ce7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d211e4719264a66f3a310870d7459751c335ce7f"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "de07e5caca0820e1602dc13c83781bf6b73ebb63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a57e88dc63d44a2f72781e4732ede00f14205cf", "patch": "@@ -1,3 +1,9 @@\n+2014-06-04  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree.h (private_lookup_attribute_starting): New function.\n+\t(lookup_attribute_starting): Likewise.\n+\t* tree.c (private_lookup_attribute_starting): Likewise.\n+\n 2014-06-04  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.h (expand_thunk): New argument added."}, {"sha": "c6e4bcbacd883f76783fcb160c692a7e3fd653ea", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8a57e88dc63d44a2f72781e4732ede00f14205cf", "patch": "@@ -5759,6 +5759,44 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n   return list;\n }\n \n+/* Given an attribute name ATTR_NAME and a list of attributes LIST,\n+   return a pointer to the attribute's list first element if the attribute\n+   starts with ATTR_NAME. ATTR_NAME must be in the form 'text' (not\n+   '__text__').  */\n+\n+tree\n+private_lookup_attribute_by_prefix (const char *attr_name, size_t attr_len,\n+\t\t\t\t    tree list)\n+{\n+  while (list)\n+    {\n+      size_t ident_len = IDENTIFIER_LENGTH (get_attribute_name (list));\n+\n+      if (attr_len > ident_len)\n+\t{\n+\t  list = TREE_CHAIN (list);\n+\t  continue;\n+\t}\n+\n+      const char *p = IDENTIFIER_POINTER (get_attribute_name (list));\n+\n+      if (strncmp (attr_name, p, attr_len) == 0)\n+\tbreak;\n+\n+      /* TODO: If we made sure that attributes were stored in the\n+\t canonical form without '__...__' (ie, as in 'text' as opposed\n+\t to '__text__') then we could avoid the following case.  */\n+      if (p[0] == '_' && p[1] == '_' &&\n+\t  strncmp (attr_name, p + 2, attr_len) == 0)\n+\tbreak;\n+\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return list;\n+}\n+\n+\n /* A variant of lookup_attribute() that can be used with an identifier\n    as the first argument, and where the identifier can be either\n    'text' or '__text__'."}, {"sha": "2637b55fa3636cb6a3f4bfdf655f3133d79eb097", "filename": "gcc/tree.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a57e88dc63d44a2f72781e4732ede00f14205cf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8a57e88dc63d44a2f72781e4732ede00f14205cf", "patch": "@@ -3736,6 +3736,10 @@ extern tree merge_type_attributes (tree, tree);\n    and you should never call it directly.  */\n extern tree private_lookup_attribute (const char *, size_t, tree);\n \n+/* This function is a private implementation detail\n+   of lookup_attribute_by_prefix() and you should never call it directly.  */\n+extern tree private_lookup_attribute_by_prefix (const char *, size_t, tree);\n+\n /* Given an attribute name ATTR_NAME and a list of attributes LIST,\n    return a pointer to the attribute's list element if the attribute\n    is part of the list, or NULL_TREE if not found.  If the attribute\n@@ -3758,6 +3762,24 @@ lookup_attribute (const char *attr_name, tree list)\n     return private_lookup_attribute (attr_name, strlen (attr_name), list);\n }\n \n+/* Given an attribute name ATTR_NAME and a list of attributes LIST,\n+   return a pointer to the attribute's list first element if the attribute\n+   starts with ATTR_NAME. ATTR_NAME must be in the form 'text' (not\n+   '__text__').  */\n+\n+static inline tree\n+lookup_attribute_by_prefix (const char *attr_name, tree list)\n+{\n+  gcc_checking_assert (attr_name[0] != '_');\n+  /* In most cases, list is NULL_TREE.  */\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+  else\n+    return private_lookup_attribute_by_prefix (attr_name, strlen (attr_name),\n+\t\t\t\t\t       list);\n+}\n+\n+\n /* This function is a private implementation detail of\n    is_attribute_p() and you should never call it directly.  */\n extern bool private_is_attribute_p (const char *, size_t, const_tree);"}]}