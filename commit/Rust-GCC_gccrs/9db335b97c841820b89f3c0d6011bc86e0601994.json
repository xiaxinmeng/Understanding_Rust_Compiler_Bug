{"sha": "9db335b97c841820b89f3c0d6011bc86e0601994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiMzM1Yjk3Yzg0MTgyMGI4OWYzYzBkNjAxMWJjODZlMDYwMTk5NA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-07-12T07:37:55Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-07-12T07:37:55Z"}, "message": "i386.c (ix86_asm_output_function_label): Change format string placeholder from 0x%x to %#x.\n\n\t* config/i386/i386.c (ix86_asm_output_function_label): Change format\n\tstring placeholder from 0x%x to %#x.\n\t(ix86_code_end): Use putc to output '\\n'.\n\t(ix86_print_operand) <case ';'>: Use putc to output ';'.\n\nFrom-SVN: r162067", "tree": {"sha": "20df23624d82943c610efe43951ed7e257f39921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20df23624d82943c610efe43951ed7e257f39921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db335b97c841820b89f3c0d6011bc86e0601994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db335b97c841820b89f3c0d6011bc86e0601994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db335b97c841820b89f3c0d6011bc86e0601994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db335b97c841820b89f3c0d6011bc86e0601994/comments", "author": null, "committer": null, "parents": [{"sha": "30ac015ec790dea2b09e53bae5afd9aa8296b7c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ac015ec790dea2b09e53bae5afd9aa8296b7c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ac015ec790dea2b09e53bae5afd9aa8296b7c7"}], "stats": {"total": 800, "additions": 403, "deletions": 397}, "files": [{"sha": "14527ac03ea8605658f77e3c34dc468870d59657", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db335b97c841820b89f3c0d6011bc86e0601994/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db335b97c841820b89f3c0d6011bc86e0601994/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9db335b97c841820b89f3c0d6011bc86e0601994", "patch": "@@ -1,3 +1,10 @@\n+2010-07-12  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_asm_output_function_label): Change format\n+\tstring placeholder from 0x%x to %#x.\n+\t(ix86_code_end): Use putc to output '\\n'.\n+\t(ix86_print_operand) <case ';'>: Use putc to output ';'.\n+\n 2010-07-11  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/winnt.c (i386_pe_file_end): Quote symbol name\n@@ -51,8 +58,7 @@\n \t    Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR debug/44832\n-\t* tree-ssa-live.c (mark_all_vars_used_1): Set TREE_USED for\n-\tLABEL_DECL.\n+\t* tree-ssa-live.c (mark_all_vars_used_1): Set TREE_USED for LABEL_DECL.\n \t(remove_unused_scope_block_p): Don't drop TREE_USED LABEL_DECLs\n \tunless they have DECL_IGNORED_P set.\n \n@@ -78,8 +84,8 @@\n \n 2010-07-09  Jan Hubicka  <jh@suse.cz>\n \n-\t* lto-streamer-out.c (produce_symtab): Do not write alias cgraph/varpool\n-\tnodes.\n+\t* lto-streamer-out.c (produce_symtab): Do not write alias\n+\tcgraph/varpool nodes.\n \n 2010-07-09  Jan Hubicka  <jh@suse.cz>\n \n@@ -110,9 +116,8 @@\n \n 2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n \n-\t* reload.c (find_reloads): Don't clear badop if we have a\n-\twinreg alternative, but not win, and the class only has fixed\n-\tregs.\n+\t* reload.c (find_reloads): Don't clear badop if we have a winreg\n+\talternative, but not win, and the class only has fixed regs.\n \t* hard-reg-set.h (class_only_fixed_regs): Declare.\n \t* reginfo.c (class_only_fixed_regs): New array.\n \t(init_reg_sets_1): Initialize it."}, {"sha": "e6b608945b318336c402f0a423ed0711bf956aac", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 391, "deletions": 390, "changes": 781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db335b97c841820b89f3c0d6011bc86e0601994/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db335b97c841820b89f3c0d6011bc86e0601994/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9db335b97c841820b89f3c0d6011bc86e0601994", "patch": "@@ -83,21 +83,21 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* variable shift costs */\n   COSTS_N_BYTES (3),\t\t\t/* constant shift costs */\n   {COSTS_N_BYTES (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_BYTES (3),\t\t\t/*                               HI */\n-   COSTS_N_BYTES (3),\t\t\t/*                               SI */\n-   COSTS_N_BYTES (3),\t\t\t/*                               DI */\n-   COSTS_N_BYTES (5)},\t\t\t/*                            other */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_BYTES (5)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_BYTES (3),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_BYTES (3),\t\t\t/*                          HI */\n-   COSTS_N_BYTES (3),\t\t\t/*                          SI */\n-   COSTS_N_BYTES (3),\t\t\t/*                          DI */\n-   COSTS_N_BYTES (5)},\t\t\t/*                       other */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_BYTES (3),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_BYTES (5)},\t\t\t/*\t\t\t    other */\n   COSTS_N_BYTES (3),\t\t\t/* cost of movsx */\n   COSTS_N_BYTES (3),\t\t\t/* cost of movzx */\n   0,\t\t\t\t\t/* \"large\" insn */\n   2,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -133,17 +133,17 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  1,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  1,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  1,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  1,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n /* Processor costs (relative to an add) */\n@@ -154,21 +154,21 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (2),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (6),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (6),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (6),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (6),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (6)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (6),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (6)},\t\t\t/*\t\t\t      other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (23),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (23),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (23),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (23),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (23)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (23),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (23),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (23),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (23)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -204,17 +204,17 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -224,21 +224,21 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (2),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (12),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (12),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (12),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (12),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (12)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (12),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (12),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (12),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (12)},\t\t\t/*\t\t\t      other */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (40),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (40),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (40),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (40),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (40)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (40),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (40),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (40),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (40)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -276,17 +276,17 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -296,21 +296,21 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (11),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (11),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (11),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (11),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (11)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (11),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (11),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (11),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (11)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (25),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (25),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (25),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (25),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (25)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (25),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (25),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (25),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (25)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (3),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-  6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -346,17 +346,17 @@ struct processor_costs pentium_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -366,21 +366,21 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (4),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (4)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (4)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (17),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (17),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (17),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (17),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (17)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (17),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (17),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (17),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (17)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -412,28 +412,28 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  /* PentiumPro has optimized rep instructions for blocks aligned by 8 bytes (we ensure\n-     the alignment).  For small blocks inline loop is still a noticeable win, for bigger\n-     blocks either rep movsl or rep movsb is way to go.  Rep movsb has apparently\n-     more expensive startup time in CPU, but after 4K the difference is down in the noise.\n-   */\n+  /* PentiumPro has optimized rep instructions for blocks aligned by 8 bytes\n+     (we ensure the alignment).  For small blocks inline loop is still a\n+     noticeable win, for bigger blocks either rep movsl or rep movsb is\n+     way to go.  Rep movsb has apparently more expensive startup time in CPU,\n+     but after 4K the difference is down in the noise.  */\n   {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n \t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n   {{rep_prefix_4_byte, {{1024, unrolled_loop},\n-  \t\t        {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  \t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -443,21 +443,21 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (7),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (7),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (7)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (7),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (7),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (7)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (15),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (23),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (39),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (39),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (39)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (23),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (39),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (39),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (39)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n-  1,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  1,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {1, 1, 1},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -494,17 +494,17 @@ struct processor_costs geode_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -514,21 +514,21 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (3)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (18),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (18),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (18),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (18)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (18),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (18),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (18),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (18)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n-  3,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  3,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -567,17 +567,17 @@ struct processor_costs k6_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -587,21 +587,21 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (5),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (5),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (5),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (5),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (5)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (5),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (5),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (5),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -640,17 +640,17 @@ struct processor_costs athlon_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -660,21 +660,21 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (5)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -711,48 +711,48 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n-  /* K8 has optimized REP instruction for medium sized blocks, but for very small\n-     blocks it is better to use loop. For large blocks, libcall can do\n-     nontemporary accesses and beat inline considerably.  */\n+  /* K8 has optimized REP instruction for medium sized blocks, but for very\n+     small blocks it is better to use loop. For large blocks, libcall can\n+     do nontemporary accesses and beat inline considerably.  */\n   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  4,                                    /* scalar_stmt_cost.  */\n-  2,                                    /* scalar load_cost.  */\n-  2,                                    /* scalar_store_cost.  */\n-  5,                                    /* vec_stmt_cost.  */\n-  0,                                    /* vec_to_scalar_cost.  */\n-  2,                                    /* scalar_to_vec_cost.  */\n-  2,                                    /* vec_align_load_cost.  */\n-  3,                                    /* vec_unalign_load_cost.  */\n-  3,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  2,                                    /* cond_not_taken_branch_cost.  */\n+  4,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  2,\t\t\t\t\t/* scalar load_cost.  */\n+  2,\t\t\t\t\t/* scalar_store_cost.  */\n+  5,\t\t\t\t\t/* vec_stmt_cost.  */\n+  0,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  2,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  2,\t\t\t\t\t/* vec_align_load_cost.  */\n+  3,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  3,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  2,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n struct processor_costs amdfam10_cost = {\n-  COSTS_N_INSNS (1),                    /* cost of an add instruction */\n-  COSTS_N_INSNS (2),                    /* cost of a lea instruction */\n-  COSTS_N_INSNS (1),                    /* variable shift costs */\n-  COSTS_N_INSNS (1),                    /* constant shift costs */\n-  {COSTS_N_INSNS (3),                   /* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),                   /*                               HI */\n-   COSTS_N_INSNS (3),                   /*                               SI */\n-   COSTS_N_INSNS (4),                   /*                               DI */\n-   COSTS_N_INSNS (5)},                  /*                               other */\n-  0,                                    /* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),                  /* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),                  /*                          HI */\n-   COSTS_N_INSNS (51),                  /*                          SI */\n-   COSTS_N_INSNS (83),                  /*                          DI */\n-   COSTS_N_INSNS (83)},                 /*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -773,14 +773,14 @@ struct processor_costs amdfam10_cost = {\n   {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n \t\t\t\t\t   in SImode, DImode and TImode */\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n-  \t\t\t\t\t/* On K8\n-  \t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFSTORE 4\n-\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFSTORE 4\n-\t\t\t\t\t   On AMDFAM10\n-\t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFADD 3\n-                                                                1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFADD 3\n-                                                                1/1  1/1 */\n+  \t\t\t\t\t/* On K8:\n+  \t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n+\t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n+\t\t\t\t\t   On AMDFAM10:\n+\t\t\t\t\t    MOVD reg64, xmmreg Double FADD 3\n+\t\t\t\t\t\t\t       1/1  1/1\n+\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n+\t\t\t\t\t\t\t       1/1  1/1 */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -806,40 +806,40 @@ struct processor_costs amdfam10_cost = {\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  4,                                    /* scalar_stmt_cost.  */\n-  2,                                    /* scalar load_cost.  */\n-  2,                                    /* scalar_store_cost.  */\n-  6,                                    /* vec_stmt_cost.  */\n-  0,                                    /* vec_to_scalar_cost.  */\n-  2,                                    /* scalar_to_vec_cost.  */\n-  2,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  2,                                    /* vec_store_cost.  */\n-  2,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  4,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  2,\t\t\t\t\t/* scalar load_cost.  */\n+  2,\t\t\t\t\t/* scalar_store_cost.  */\n+  6,\t\t\t\t\t/* vec_stmt_cost.  */\n+  0,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  2,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  2,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  2,\t\t\t\t\t/* vec_store_cost.  */\n+  2,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n struct processor_costs bdver1_cost = {\n-  COSTS_N_INSNS (1),                    /* cost of an add instruction */\n-  COSTS_N_INSNS (2),                    /* cost of a lea instruction */\n-  COSTS_N_INSNS (1),                    /* variable shift costs */\n-  COSTS_N_INSNS (1),                    /* constant shift costs */\n-  {COSTS_N_INSNS (3),                   /* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),                   /*                               HI */\n-   COSTS_N_INSNS (3),                   /*                               SI */\n-   COSTS_N_INSNS (4),                   /*                               DI */\n-   COSTS_N_INSNS (5)},                  /*                               other */\n-  0,                                    /* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (19),                  /* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (35),                  /*                          HI */\n-   COSTS_N_INSNS (51),                  /*                          SI */\n-   COSTS_N_INSNS (83),                  /*                          DI */\n-   COSTS_N_INSNS (83)},                 /*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (2),\t\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (5)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (19),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (35),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (51),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (83),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (83)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -860,14 +860,14 @@ struct processor_costs bdver1_cost = {\n   {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n \t\t\t\t\t   in SImode, DImode and TImode */\n   3,\t\t\t\t\t/* MMX or SSE register to integer */\n-  \t\t\t\t\t/* On K8\n-  \t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFSTORE 4\n-\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFSTORE 4\n-\t\t\t\t\t   On AMDFAM10\n-\t\t\t\t\t    MOVD reg64, xmmreg \tDouble\tFADD 3\n-                                                                1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg \tDouble\tFADD 3\n-                                                                1/1  1/1 */\n+  \t\t\t\t\t/* On K8:\n+\t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n+\t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n+\t\t\t\t\t   On AMDFAM10:\n+\t\t\t\t\t    MOVD reg64, xmmreg Double FADD 3\n+\t\t\t\t\t\t\t       1/1  1/1\n+\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n+\t\t\t\t\t\t\t       1/1  1/1 */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   1024,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -886,24 +886,24 @@ struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n   /*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n-      very small blocks it is better to use loop. For large blocks, libcall can\n-      do nontemporary accesses and beat inline considerably.  */\n+      very small blocks it is better to use loop. For large blocks, libcall\n+      can do nontemporary accesses and beat inline considerably.  */\n   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  4,                                    /* scalar_stmt_cost.  */\n-  2,                                    /* scalar load_cost.  */\n-  2,                                    /* scalar_store_cost.  */\n-  6,                                    /* vec_stmt_cost.  */\n-  0,                                    /* vec_to_scalar_cost.  */\n-  2,                                    /* scalar_to_vec_cost.  */\n-  2,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  2,                                    /* vec_store_cost.  */\n-  2,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  4,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  2,\t\t\t\t\t/* scalar load_cost.  */\n+  2,\t\t\t\t\t/* scalar_store_cost.  */\n+  6,\t\t\t\t\t/* vec_stmt_cost.  */\n+  0,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  2,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  2,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  2,\t\t\t\t\t/* vec_store_cost.  */\n+  2,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -913,21 +913,21 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (4),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (4),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (15),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (15),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (15),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (15),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (15)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (15),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (15)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (56),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (56),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (56),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (56),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (56)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (56),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (56)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -964,17 +964,17 @@ struct processor_costs pentium4_cost = {\n   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -984,21 +984,21 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (10),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (10),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (10),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (10),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (10)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (10),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (10),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (10),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (10)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (66),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (66),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (66),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (66),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (66)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (66),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (66),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (66),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (66)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -1037,17 +1037,17 @@ struct processor_costs nocona_cost = {\n    {-1, libcall}}},\n    {libcall, {{24, loop}, {64, unrolled_loop},\n \t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -1057,21 +1057,21 @@ struct processor_costs core2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (3)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (22),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (22),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (22),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (22),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (22)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (22),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (22),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (22),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (22)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   16,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -1110,17 +1110,17 @@ struct processor_costs core2_cost = {\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{24, loop}, {32, unrolled_loop},\n \t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n static const\n@@ -1130,21 +1130,21 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (2)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -1178,22 +1178,22 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n   {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{32, loop}, {64, rep_prefix_4_byte},\n-          {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {15, unrolled_loop},\n-          {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+\t  {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{24, loop}, {32, unrolled_loop},\n-          {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n /* Generic64 should produce code tuned for Nocona and K8.  */\n@@ -1208,21 +1208,21 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (2)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -1247,8 +1247,8 @@ struct processor_costs generic64_cost = {\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n   6,\t\t\t\t\t/* number of parallel prefetches */\n-  /* Benchmarks shows large regressions on K8 sixtrack benchmark when this value\n-     is increased to perhaps more appropriate value of 5.  */\n+  /* Benchmarks shows large regressions on K8 sixtrack benchmark when this\n+     value is increased to perhaps more appropriate value of 5.  */\n   3,\t\t\t\t\t/* Branch cost */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n@@ -1260,42 +1260,43 @@ struct processor_costs generic64_cost = {\n    {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {DUMMY_STRINGOP_ALGS,\n    {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-/* Generic32 should produce code tuned for Athlon, PPro, Pentium4, Nocona and K8.  */\n+/* Generic32 should produce code tuned for PPro, Pentium4, Nocona,\n+   Athlon and K8.  */\n static const\n struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n   {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               HI */\n-   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n-   COSTS_N_INSNS (4),\t\t\t/*                               DI */\n-   COSTS_N_INSNS (2)},\t\t\t/*                               other */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*                          HI */\n-   COSTS_N_INSNS (42),\t\t\t/*                          SI */\n-   COSTS_N_INSNS (74),\t\t\t/*                          DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*                          other */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n@@ -1331,17 +1332,17 @@ struct processor_costs generic32_cost = {\n    DUMMY_STRINGOP_ALGS},\n   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-  1,                                    /* scalar_stmt_cost.  */\n-  1,                                    /* scalar load_cost.  */\n-  1,                                    /* scalar_store_cost.  */\n-  1,                                    /* vec_stmt_cost.  */\n-  1,                                    /* vec_to_scalar_cost.  */\n-  1,                                    /* scalar_to_vec_cost.  */\n-  1,                                    /* vec_align_load_cost.  */\n-  2,                                    /* vec_unalign_load_cost.  */\n-  1,                                    /* vec_store_cost.  */\n-  3,                                    /* cond_taken_branch_cost.  */\n-  1,                                    /* cond_not_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n const struct processor_costs *ix86_cost = &pentium_cost;\n@@ -5145,7 +5146,7 @@ ix86_asm_output_function_label (FILE *asm_out_file, const char *fname,\n       unsigned int filler_cc = 0xcccccccc;\n \n       for (i = 0; i < filler_count; i += 4)\n-        fprintf (asm_out_file, ASM_LONG \" 0x%x\\n\", filler_cc);\n+        fprintf (asm_out_file, ASM_LONG \" %#x\\n\", filler_cc);\n     }\n \n   ASM_OUTPUT_LABEL (asm_out_file, fname);\n@@ -7948,7 +7949,7 @@ ix86_code_end (void)\n \t  assemble_name (asm_out_file, name);\n \t  fputs (\"\\n\\t.private_extern\\t\", asm_out_file);\n \t  assemble_name (asm_out_file, name);\n-\t  fputs (\"\\n\", asm_out_file);\n+\t  putc ('\\n', asm_out_file);\n \t  ASM_OUTPUT_LABEL (asm_out_file, name);\n \t  DECL_WEAK (decl) = 1;\n \t}\n@@ -12652,7 +12653,7 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \n \tcase ';':\n #ifndef HAVE_AS_IX86_REP_LOCK_PREFIX\n-\t  fputs (\";\", file);\n+\t  putc (';', file);\n #endif\n \t  return;\n "}]}