{"sha": "092ae4ba981a89701458541198d8c865601a08d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkyYWU0YmE5ODFhODk3MDE0NTg1NDExOThkOGM4NjU2MDFhMDhkOA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-07T00:36:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-07T00:36:35Z"}, "message": "gcse.c (post_dominators): Kill.\n\n\n        * gcse.c (post_dominators): Kill.\n        (alloc_code_hoist_mem, free_code_hoist_mem); Kill post_dominators.\n        (compute_code_hoist_data): Use compute_flow_dominators.  Do not\n        pass in a pdom array since we do not need pdoms.\n        * haifa-sched.c (schedule_insns): Similarly.\n        * flow.c (compute_dominators): Remove dead function.\n        (compute_flow_dominators): Do not compute doms or pdoms if the\n        caller does not request them.  Split up loop to build doms and\n        pdoms.  Use a worklist to compute doms and pdoms.\n        * basic-block.h (compute_dominators): Remove prototype.\n\nFrom-SVN: r30437", "tree": {"sha": "94fe489fb7140cdc9aa35fd9eb02e59df99a88c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94fe489fb7140cdc9aa35fd9eb02e59df99a88c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/092ae4ba981a89701458541198d8c865601a08d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092ae4ba981a89701458541198d8c865601a08d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/092ae4ba981a89701458541198d8c865601a08d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092ae4ba981a89701458541198d8c865601a08d8/comments", "author": null, "committer": null, "parents": [{"sha": "ea1fd42450d3cd96ae03002c3436134c49afc958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1fd42450d3cd96ae03002c3436134c49afc958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1fd42450d3cd96ae03002c3436134c49afc958"}], "stats": {"total": 173, "additions": 96, "deletions": 77}, "files": [{"sha": "be5b313e903317ec3086eb57d4a60707fae672a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092ae4ba981a89701458541198d8c865601a08d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092ae4ba981a89701458541198d8c865601a08d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=092ae4ba981a89701458541198d8c865601a08d8", "patch": "@@ -1,3 +1,16 @@\n+Sat Nov  6 17:34:39 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* gcse.c (post_dominators): Kill.\n+\t(alloc_code_hoist_mem, free_code_hoist_mem); Kill post_dominators.\n+\t(compute_code_hoist_data): Use compute_flow_dominators.  Do not\n+\tpass in a pdom array since we do not need pdoms.\n+\t* haifa-sched.c (schedule_insns): Similarly.\n+\t* flow.c (compute_dominators): Remove dead function.\n+\t(compute_flow_dominators): Do not compute doms or pdoms if the\n+\tcaller does not request them.  Split up loop to build doms and\n+\tpdoms.  Use a worklist to compute doms and pdoms.\n+\t* basic-block.h (compute_dominators): Remove prototype.\n+\n Sat Nov  6 11:38:39 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (struct haifa_insn_data, h_i_d): New."}, {"sha": "16537b79b8bb324d2b355db6edced8289a20a555", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=092ae4ba981a89701458541198d8c865601a08d8", "patch": "@@ -294,9 +294,6 @@ int find_edge_index\t\t\tPROTO ((struct edge_list *,\n \n extern void compute_preds_succs\t\tPROTO ((int_list_ptr *, int_list_ptr *,\n \t\t\t\t\t\tint *, int *));\n-extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,\n-\t\t\t\t\t\tint_list_ptr *,\n-\t\t\t\t\t\tint_list_ptr *));\n extern void compute_flow_dominators\tPROTO ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n "}, {"sha": "bf482632bcb70bfb443ed91e9e95cee936b1f5cc", "filename": "gcc/flow.c", "status": "modified", "additions": 80, "deletions": 66, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=092ae4ba981a89701458541198d8c865601a08d8", "patch": "@@ -5317,95 +5317,109 @@ free_bb_mem ()\n   free_int_list (&pred_int_list_blocks);\n }\n \n-/* Compute dominator relationships.  */\n+/* Compute dominator relationships using new flow graph structures.  */\n void\n-compute_dominators (dominators, post_dominators, s_preds, s_succs)\n+compute_flow_dominators (dominators, post_dominators)\n      sbitmap *dominators;\n      sbitmap *post_dominators;\n-     int_list_ptr *s_preds;\n-     int_list_ptr *s_succs;\n {\n-  int bb, changed, passes;\n+  int bb;\n   sbitmap *temp_bitmap;\n+  edge e;\n+  basic_block *worklist, *tos;\n+\n+  /* Allocate a worklist array/queue.  Entries are only added to the\n+     list if they were not already on the list.  So the size is\n+     bounded by the number of basic blocks.  */\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n+\t\t    * n_basic_blocks);\n \n   temp_bitmap = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_ones (dominators, n_basic_blocks);\n-  sbitmap_vector_ones (post_dominators, n_basic_blocks);\n   sbitmap_vector_zero (temp_bitmap, n_basic_blocks);\n \n-  sbitmap_zero (dominators[0]);\n-  SET_BIT (dominators[0], 0);\n-\n-  sbitmap_zero (post_dominators[n_basic_blocks - 1]);\n-  SET_BIT (post_dominators[n_basic_blocks - 1], 0);\n-\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  if (dominators)\n     {\n-      changed = 0;\n-      for (bb = 1; bb < n_basic_blocks; bb++)\n+      sbitmap_vector_ones (dominators, n_basic_blocks);\n+      sbitmap_zero (dominators[0]);\n+      SET_BIT (dominators[0], 0);\n+\n+      /* Put the successors of the entry block on the worklist.  */\n+      for (e = BASIC_BLOCK (0)->succ; e; e = e->succ_next)\n \t{\n-\t  sbitmap_intersect_of_predecessors (temp_bitmap[bb], dominators,\n-\t\t\t\t\t     bb, s_preds);\n-\t  SET_BIT (temp_bitmap[bb], bb);\n-\t  changed |= sbitmap_a_and_b (dominators[bb],\n-\t\t\t\t      dominators[bb],\n-\t\t\t\t      temp_bitmap[bb]);\n-\t  sbitmap_intersect_of_successors (temp_bitmap[bb], post_dominators,\n-\t\t\t\t\t   bb, s_succs);\n-\t  SET_BIT (temp_bitmap[bb], bb);\n-\t  changed |= sbitmap_a_and_b (post_dominators[bb],\n-\t\t\t\t      post_dominators[bb],\n-\t\t\t\t      temp_bitmap[bb]);\n+\t  *tos++ = e->dest;\n+\t  e->dest->aux = e;\n \t}\n-      passes++;\n-    }\n \n-  free (temp_bitmap);\n-}\n+      /* Iterate until the worklist is empty.  */\n+      while (tos != worklist)\n+\t{\n+\t  /* Take the first entry off the worklist.  */\n+\t  basic_block b = *--tos;\n+\t  b->aux = NULL;\n+\t  bb = b->index;\n \n-/* Compute dominator relationships using new flow graph structures.  */\n-void\n-compute_flow_dominators (dominators, post_dominators)\n-     sbitmap *dominators;\n-     sbitmap *post_dominators;\n-{\n-  int bb, changed, passes;\n-  sbitmap *temp_bitmap;\n+\t  sbitmap_intersection_of_preds (temp_bitmap[bb], dominators, bb);\n+\t  SET_BIT (temp_bitmap[bb], bb);\n \n-  temp_bitmap = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_ones (dominators, n_basic_blocks);\n-  sbitmap_vector_ones (post_dominators, n_basic_blocks);\n-  sbitmap_vector_zero (temp_bitmap, n_basic_blocks);\n+\t  /* If the out state of this block changed, then we need to\n+\t     add the successors of this block to the worklist if they\n+\t     are not already on the worklist.  */\n+\t  if (sbitmap_a_and_b (dominators[bb], dominators[bb], temp_bitmap[bb]))\n+\t    {\n+\t      for (e = b->succ; e; e = e->succ_next)\n+\t\t{\n+\t\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n+\t\t    {\n+\t\t      *tos++ = e->dest;\n+\t\t      e->dest->aux = e;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n-  sbitmap_zero (dominators[0]);\n-  SET_BIT (dominators[0], 0);\n+  if (post_dominators)\n+    {\n+      sbitmap_vector_ones (post_dominators, n_basic_blocks);\n+      sbitmap_zero (post_dominators[n_basic_blocks - 1]);\n+      SET_BIT (post_dominators[n_basic_blocks - 1], 0);\n \n-  sbitmap_zero (post_dominators[n_basic_blocks - 1]);\n-  SET_BIT (post_dominators[n_basic_blocks - 1], 0);\n+      /* Put the predecessors of the exit block on the worklist.  */\n+      for (e = BASIC_BLOCK (n_basic_blocks - 1)->pred; e; e = e->pred_next)\n+\t{\n+\t  *tos++ = e->src;\n+\t  e->src->aux = e;\n+\t}\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 1; bb < n_basic_blocks; bb++)\n+      /* Iterate until the worklist is empty.  */\n+      while (tos != worklist)\n \t{\n-\t  sbitmap_intersection_of_preds (temp_bitmap[bb], dominators, bb);\n-\t  SET_BIT (temp_bitmap[bb], bb);\n-\t  changed |= sbitmap_a_and_b (dominators[bb],\n-\t\t\t\t      dominators[bb],\n-\t\t\t\t      temp_bitmap[bb]);\n+\t  /* Take the first entry off the worklist.  */\n+\t  basic_block b = *--tos;\n+\t  b->aux = NULL;\n+\t  bb = b->index;\n+\n \t  sbitmap_intersection_of_succs (temp_bitmap[bb], post_dominators, bb);\n \t  SET_BIT (temp_bitmap[bb], bb);\n-\t  changed |= sbitmap_a_and_b (post_dominators[bb],\n-\t\t\t\t      post_dominators[bb],\n-\t\t\t\t      temp_bitmap[bb]);\n+\n+\t  /* If the out state of this block changed, then we need to\n+\t     add the successors of this block to the worklist if they\n+\t     are not already on the worklist.  */\n+\t  if (sbitmap_a_and_b (post_dominators[bb],\n+\t\t\t       post_dominators[bb],\n+\t\t\t       temp_bitmap[bb]))\n+\t    {\n+\t      for (e = b->pred; e; e = e->pred_next)\n+\t\t{\n+\t\t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n+\t\t    {\n+\t\t      *tos++ = e->src;\n+\t\t      e->src->aux = e;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n-      passes++;\n     }\n-\n   free (temp_bitmap);\n }\n "}, {"sha": "69af46346b914be16a168df426b7e84f31f1c5f3", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=092ae4ba981a89701458541198d8c865601a08d8", "patch": "@@ -5330,7 +5330,6 @@ static sbitmap *hoist_exprs;\n \n /* Dominator bitmaps.  */\n static sbitmap *dominators;\n-static sbitmap *post_dominators;\n \n /* ??? We could compute post dominators and run this algorithm in\n    reverse to to perform tail merging, doing so would probably be\n@@ -5355,7 +5354,6 @@ alloc_code_hoist_mem (n_blocks, n_exprs)\n   transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n \n   dominators = sbitmap_vector_alloc (n_blocks, n_blocks);\n-  post_dominators = sbitmap_vector_alloc (n_blocks, n_blocks);\n }\n \n /* Free vars used for code hoisting analysis.  */\n@@ -5373,7 +5371,6 @@ free_code_hoist_mem ()\n   free (transpout);\n \n   free (dominators);\n-  free (post_dominators);\n }\n \n /* Compute the very busy expressions at entry/exit from each block.\n@@ -5418,7 +5415,7 @@ compute_code_hoist_data ()\n   compute_local_properties (transp, comp, antloc, 0);\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n-  compute_flow_dominators (dominators, post_dominators);\n+  compute_flow_dominators (dominators, NULL);\n   if (gcse_file)\n     fprintf (gcse_file, \"\\n\");\n }"}, {"sha": "a4fdd75f2c806b721d3be33ebdb4171d117b0e76", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/092ae4ba981a89701458541198d8c865601a08d8/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=092ae4ba981a89701458541198d8c865601a08d8", "patch": "@@ -6965,7 +6965,7 @@ schedule_insns (dump_file)\n \t{\n \t  int_list_ptr *s_preds, *s_succs;\n \t  int *num_preds, *num_succs;\n-\t  sbitmap *dom, *pdom;\n+\t  sbitmap *dom;\n \n \t  s_preds = (int_list_ptr *) xmalloc (n_basic_blocks\n \t\t\t\t\t      * sizeof (int_list_ptr));\n@@ -6974,7 +6974,6 @@ schedule_insns (dump_file)\n \t  num_preds = (int *) xmalloc (n_basic_blocks * sizeof (int));\n \t  num_succs = (int *) xmalloc (n_basic_blocks * sizeof (int));\n \t  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-\t  pdom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n \n \t  /* The scheduler runs after flow; therefore, we can't blindly call\n \t     back into find_basic_blocks since doing so could invalidate the\n@@ -6993,7 +6992,7 @@ schedule_insns (dump_file)\n \t  /* Compute the dominators and post dominators.  We don't\n \t     currently use post dominators, but we should for\n \t     speculative motion analysis.  */\n-\t  compute_dominators (dom, pdom, s_preds, s_succs);\n+\t  compute_flow_dominators (dom, NULL);\n \n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents\n@@ -7010,7 +7009,6 @@ schedule_insns (dump_file)\n \t     to using the cfg code in flow.c.  */\n \t  free_bb_mem ();\n \t  free (dom);\n-\t  free (pdom);\n \t  free (s_preds);\n \t  free (s_succs);\n \t  free (num_preds);"}]}