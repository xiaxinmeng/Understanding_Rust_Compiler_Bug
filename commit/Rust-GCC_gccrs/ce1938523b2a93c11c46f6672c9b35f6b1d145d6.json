{"sha": "ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxOTM4NTIzYjJhOTNjMTFjNDZmNjY3MmM5YjM1ZjZiMWQxNDVkNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-04-04T19:57:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-04T19:57:26Z"}, "message": "i386.md (ffssi, ffshi): Rewrite as define_expands.\n\n* i386.md (ffssi, ffshi): Rewrite as define_expands.\n(ffssi_1, ffshi_1): New (unspec [] 5) support patterns.\n* i386.c (notice_update_cc): Recognize unspec 5.\n\nFrom-SVN: r18999", "tree": {"sha": "2b2d25d4c661f6316c182c704ead16573b8c07ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b2d25d4c661f6316c182c704ead16573b8c07ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/comments", "author": null, "committer": null, "parents": [{"sha": "e06e4d453410364f49563827274f50e46d8d64dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06e4d453410364f49563827274f50e46d8d64dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e06e4d453410364f49563827274f50e46d8d64dc"}], "stats": {"total": 139, "additions": 59, "deletions": 80}, "files": [{"sha": "f7bb7c1ce44283a0a9308495968da530c0d7cf56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "patch": "@@ -1,3 +1,9 @@\n+Sat Apr  4 19:08:37 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.md (ffssi, ffshi): Rewrite as define_expands.\n+\t(ffssi_1, ffshi_1): New (unspec [] 5) support patterns.\n+\t* i386.c (notice_update_cc): Recognize unspec 5.\n+\n Sat Apr  4 18:07:16 1998  David Mosberger-Tang  (davidm@mostang.com)\n \n \t* alpha.h (PRINT_OPERAND_PUNCT_VALID_P): Accept '(' for s/sv/svi."}, {"sha": "1232b4a46f6d9b981ca09e881dd3c117da0a9b59", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "patch": "@@ -3646,6 +3646,18 @@ notice_update_cc (exp)\n \t    cc_status.value2 = SET_DEST (exp);\n \t    break;\n \n+\t    /* This is the bsf pattern used by ffs.  */\n+\t  case UNSPEC:\n+\t    if (XINT (SET_SRC (exp), 1) == 5)\n+\t      {\n+\t\t/* Only the Z flag is defined after bsf.  */\n+\t\tcc_status.flags\n+\t\t  = CC_NOT_POSITIVE | CC_NOT_NEGATIVE | CC_NO_OVERFLOW;\n+\t\tcc_status.value1 = XVECEXP (SET_SRC (exp), 0, 0);\n+\t\tbreak;\n+\t      }\n+\t    /* FALLTHRU */\n+\n \t  default:\n \t    CC_STATUS_INIT;\n \t  }"}, {"sha": "3a88982852a0d6e0a2d1d7e6d070c95a41ce1515", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 41, "deletions": 80, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1938523b2a93c11c46f6672c9b35f6b1d145d6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ce1938523b2a93c11c46f6672c9b35f6b1d145d6", "patch": "@@ -63,6 +63,7 @@\n ;; 4  This is the source of a fake SET of the frame pointer which is used to\n ;;    prevent insns referencing it being scheduled across the initial\n ;;    decrement of the stack pointer.\n+;; 5  This is a `bsf' operation.\n \f\n ;; This shadows the processor_type enumeration, so changes must be made\n ;; to i386.h at the same time.\n@@ -6963,103 +6964,63 @@ byte_xor_operation:\n }\")\n \n \f\n-(define_expand \"ffssi2\"\n-  [(set (match_dup 2)\n-\t(plus:SI (ffs:SI (match_operand:SI 1 \"general_operand\" \"\"))\n-\t\t (const_int -1)))\n-   (set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(plus:SI (match_dup 2) (const_int 1)))]\n-  \"\"\n-  \"operands[2] = gen_reg_rtx (SImode);\")\n-\n ;; Note, you cannot optimize away the branch following the bsfl by assuming\n ;; that the destination is not modified if the input is 0, since not all\n ;; x86 implementations do this.\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(plus:SI (ffs:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n-\t\t (const_int -1)))]\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\") \n+\t(ffs:SI (match_operand:SI 1 \"general_operand\" \"\")))]\n   \"\"\n-  \"*\n+  \"\n {\n-  rtx xops[3];\n-  static int ffssi_label_number;\n-  char buffer[30];\n+  rtx label = gen_label_rtx (), temp = gen_reg_rtx (SImode);\n \n-  xops[0] = operands[0];\n-  xops[1] = operands[1];\n-  xops[2] = constm1_rtx;\n-  output_asm_insn (AS2 (bsf%L0,%1,%0), xops);\n-#ifdef LOCAL_LABEL_PREFIX\n-  sprintf (buffer, \\\"jnz %sLFFSSI%d\\\",\n-\t   LOCAL_LABEL_PREFIX, ffssi_label_number);\n-#else\n-  sprintf (buffer, \\\"jnz %sLFFSSI%d\\\",\n-\t   \\\"\\\", ffssi_label_number);\n-#endif\n-  output_asm_insn (buffer, xops);\n-  output_asm_insn (AS2 (mov%L0,%2,%0), xops);\n-#ifdef LOCAL_LABEL_PREFIX\n-  sprintf (buffer, \\\"%sLFFSSI%d:\\\",\n-\t   LOCAL_LABEL_PREFIX, ffssi_label_number);\n-#else\n-  sprintf (buffer, \\\"%sLFFSSI%d:\\\",\n-\t   \\\"\\\", ffssi_label_number);\n-#endif\n-  output_asm_insn (buffer, xops);\n+  emit_insn (gen_ffssi_1 (temp, operands[1]));\n+  emit_cmp_insn (operands[1], const0_rtx, NE, NULL_RTX, SImode, 0, 0);\n+  emit_jump_insn (gen_bne (label));\n+  emit_move_insn (temp, constm1_rtx);\n+  emit_label (label);\n+  temp = expand_binop (SImode, add_optab, temp, const1_rtx,\n+\t\t       operands[0], 0, OPTAB_WIDEN);\n \n-  ffssi_label_number++;\n-  CC_STATUS_INIT;\n-  return \\\"\\\";\n+  if (temp != operands[0])\n+    emit_move_insn (operands[0], temp);\n+  DONE;  \n }\")\n \n-(define_expand \"ffshi2\"\n-  [(set (match_dup 2)\n-\t(plus:HI (ffs:HI (match_operand:HI 1 \"general_operand\" \"\"))\n-\t\t (const_int -1)))\n-   (set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(plus:HI (match_dup 2) (const_int 1)))]\n+(define_insn \"ffssi_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"nonimmediate_operand\" \"rm\")] 5))]\n   \"\"\n-  \"operands[2] = gen_reg_rtx (HImode);\")\n+  \"* return AS2 (bsf%L0,%1,%0);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(plus:HI (ffs:HI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n-\t\t (const_int -1)))]\n+(define_expand \"ffshi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\") \n+\t(ffs:HI (match_operand:HI 1 \"general_operand\" \"\")))]\n   \"\"\n-  \"*\n+  \"\n {\n-  rtx xops[3];\n-  static int ffshi_label_number;\n-  char buffer[30];\n+  rtx label = gen_label_rtx (), temp = gen_reg_rtx (HImode);\n \n-  xops[0] = operands[0];\n-  xops[1] = operands[1];\n-  xops[2] = constm1_rtx;\n-  output_asm_insn (AS2 (bsf%W0,%1,%0), xops);\n-#ifdef LOCAL_LABEL_PREFIX\n-  sprintf (buffer, \\\"jnz %sLFFSHI%d\\\",\n-\t   LOCAL_LABEL_PREFIX, ffshi_label_number);\n-#else\n-  sprintf (buffer, \\\"jnz %sLFFSHI%d\\\",\n-\t   \\\"\\\", ffshi_label_number);\n-#endif\n-  output_asm_insn (buffer, xops);\n-  output_asm_insn (AS2 (mov%W0,%2,%0), xops);\n-#ifdef LOCAL_LABEL_PREFIX\n-  sprintf (buffer, \\\"%sLFFSHI%d:\\\",\n-\t   LOCAL_LABEL_PREFIX, ffshi_label_number);\n-#else\n-  sprintf (buffer, \\\"%sLFFSHI%d:\\\",\n-\t   \\\"\\\", ffshi_label_number);\n-#endif\n-  output_asm_insn (buffer, xops);\n+  emit_insn (gen_ffshi_1 (temp, operands[1]));\n+  emit_cmp_insn (operands[1], const0_rtx, NE, NULL_RTX, HImode, 0, 0);\n+  emit_jump_insn (gen_bne (label));\n+  emit_move_insn (temp, constm1_rtx);\n+  emit_label (label);\n+  temp = expand_binop (HImode, add_optab, temp, const1_rtx,\n+\t\t       operands[0], 0, OPTAB_WIDEN);\n \n-  ffshi_label_number++;\n-  CC_STATUS_INIT;\n-  return \\\"\\\";\n+  if (temp != operands[0])\n+    emit_move_insn (operands[0], temp);\n+  DONE;  \n }\")\n+\n+(define_insn \"ffshi_1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(unspec:HI [(match_operand:SI 1 \"nonimmediate_operand\" \"rm\")] 5))]\n+  \"\"\n+  \"* return AS2 (bsf%W0,%1,%0);\")\n \f\n ;; These patterns match the binary 387 instructions for addM3, subM3,\n ;; mulM3 and divM3.  There are three patterns for each of DFmode and"}]}