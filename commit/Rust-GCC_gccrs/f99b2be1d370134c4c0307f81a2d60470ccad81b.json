{"sha": "f99b2be1d370134c4c0307f81a2d60470ccad81b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5YjJiZTFkMzcwMTM0YzRjMDMwN2Y4MWEyZDYwNDcwY2NhZDgxYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-05-15T21:07:36Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-05-15T21:07:36Z"}, "message": "hashtable (hashtable<>::m_find, [...]): Add.\n\n2006-05-15  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/hashtable (hashtable<>::m_find, m_insert_bucket): Add.\n\t(hashtable<>::find, m_insert(const value_type&, std::tr1::true_type),\n\tmap_base<>::operator[]): Use the above.\n\t* testsuite/performance/23_containers/insert/unordered_map_array.cc:\n\tNew.\t\n\n\t* include/tr1/hashtable (hashtable<>::find_node,\n\tinsert(const value_type&, ...), erase_node): Rename to m_*, adjust\n\tcallers.\n\t* include/tr1/hashtable: Minor cosmetic changes.\n\nFrom-SVN: r113800", "tree": {"sha": "d68402b60509b2068e6e80097679ed7571739d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d68402b60509b2068e6e80097679ed7571739d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f99b2be1d370134c4c0307f81a2d60470ccad81b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99b2be1d370134c4c0307f81a2d60470ccad81b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99b2be1d370134c4c0307f81a2d60470ccad81b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99b2be1d370134c4c0307f81a2d60470ccad81b/comments", "author": null, "committer": null, "parents": [{"sha": "95dd3097939517ea3a4f7631407f9300288a98e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dd3097939517ea3a4f7631407f9300288a98e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95dd3097939517ea3a4f7631407f9300288a98e3"}], "stats": {"total": 212, "additions": 160, "deletions": 52}, "files": [{"sha": "db1a74e131f9c3f4642a4e9dafb5c1a4ee6f65ab", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f99b2be1d370134c4c0307f81a2d60470ccad81b", "patch": "@@ -1,3 +1,16 @@\n+2006-05-15  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/hashtable (hashtable<>::m_find, m_insert_bucket): Add.\n+\t(hashtable<>::find, m_insert(const value_type&, std::tr1::true_type),\n+\tmap_base<>::operator[]): Use the above.\n+\t* testsuite/performance/23_containers/insert/unordered_map_array.cc:\n+\tNew.\t\n+\n+\t* include/tr1/hashtable (hashtable<>::find_node,\n+\tinsert(const value_type&, ...), erase_node): Rename to m_*, adjust\n+\tcallers.\n+\t* include/tr1/hashtable: Minor cosmetic changes.\n+\n 2006-05-13  Peter Doerfler  <gcc@pdoerfler.com>\n \n \t* include/tr1/hashtable (identity<>::operator(),"}, {"sha": "9e711368e208d0ad81f27da0d45b3868c2650788", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 86, "deletions": 52, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=f99b2be1d370134c4c0307f81a2d60470ccad81b", "patch": "@@ -680,8 +680,11 @@ namespace Internal\n       operator[](const K& k)\n       {\n \tHashtable* h = static_cast<Hashtable*>(this);\n-\ttypename Hashtable::iterator it = \n-\t  h->insert(std::make_pair(k, mapped_type())).first;\n+\ttypename Hashtable::hash_code_t code = h->m_hash_code(k);\n+\ttypename Hashtable::iterator it = h->m_find(k, code);\n+\tif (!it.m_cur_node)\n+\t  it = h->m_insert_bucket(std::make_pair(k, mapped_type()),\n+\t\t\t\t  it.m_cur_bucket - h->m_buckets, code);\n \treturn it->second;\n       }\n     };\n@@ -1032,6 +1035,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t\t\t\t cache_hash_code>\n                                                           const_iterator;\n \n+      template<typename K, typename Pair, typename Hashtable>\n+        friend struct Internal::map_base;\n+\n     private:\n       typedef Internal::hash_node<Value, cache_hash_code> node;\n       typedef typename Allocator::template rebind<node>::other\n@@ -1188,7 +1194,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     public:\t\t\t\t// lookup\n       iterator\n-      find(const key_type&);\n+      find(const key_type& k);\n \n       const_iterator\n       find(const key_type& k) const;\n@@ -1202,7 +1208,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& k) const;\n \n-    private:\t\t\t// Insert and erase helper functions\n+    private:\t\t\t// Find, insert and erase helper functions\n       // ??? This dispatching is a workaround for the fact that we don't\n       // have partial specialization of member templates; it would be\n       // better to just specialize insert on unique_keys.  There may be a\n@@ -1217,31 +1223,35 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n                                    >::type\n         Insert_Conv_Type;\n \n+      iterator\n+      m_find(const key_type&, typename hashtable::hash_code_t) const;\n+\n       node*\n-      find_node(node* p, const key_type& k,\n-\t\ttypename hashtable::hash_code_t c) const;\n+      m_find_node(node*, const key_type&,\n+\t\t  typename hashtable::hash_code_t) const;\n+\n+      iterator\n+      m_insert_bucket(const value_type&, size_type,\n+\t\t      typename hashtable::hash_code_t);\n \n       std::pair<iterator, bool>\n-      insert(const value_type&, std::tr1::true_type);\n-  \n+      m_insert(const value_type&, std::tr1::true_type);\n+\n       iterator\n-      insert(const value_type&, std::tr1::false_type);\n+      m_insert(const value_type&, std::tr1::false_type);\n \n       void\n-      erase_node(node*, node**);\n+      m_erase_node(node*, node**);\n \n     public:\t\t\t\t// Insert and erase\n       Insert_Return_Type\n       insert(const value_type& v) \n-      { \n-\treturn this->insert(v, std::tr1::integral_constant<bool,\n-\t\t\t    unique_keys>());\n-      }\n+      { return m_insert(v, std::tr1::integral_constant<bool, unique_keys>()); }\n \n       iterator\n       insert(iterator, const value_type& v)\n       { return iterator(Insert_Conv_Type()(this->insert(v))); }\n-      \n+\n       const_iterator\n       insert(const_iterator, const value_type& v)\n       { return const_iterator(Insert_Conv_Type()(this->insert(v))); }\n@@ -1525,6 +1535,19 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \tm_rehash(n_bkt);\n     }\n \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    m_find(const key_type& k, typename hashtable::hash_code_t code) const\n+    {\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node* p = m_find_node(m_buckets[n], k, code);\n+      return iterator(p, m_buckets + n);\n+    }\n+\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n@@ -1534,9 +1557,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     find(const key_type& k)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = find_node(m_buckets[n], k, code);\n-      return p ? iterator(p, m_buckets + n) : this->end();\n+      iterator i = m_find(k, code);\n+      return i.m_cur_node ? i : this->end();\n     }\n   \n   template<typename K, typename V, \n@@ -1548,11 +1570,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     find(const key_type& k) const\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = find_node(m_buckets[n], k, code);\n-      return p ? const_iterator(p, m_buckets + n) : this->end();\n+      const_iterator i = const_iterator(m_find(k, code));\n+      return i.m_cur_node ? i : this->end();\n     }\n-  \n+\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n@@ -1584,7 +1605,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node** head = m_buckets + n;\n-      node* p = find_node(*head, k, code);\n+      node* p = m_find_node(*head, k, code);\n       \n       if (p)\n \t{\n@@ -1617,7 +1638,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node** head = m_buckets + n;\n-      node* p = find_node(*head, k, code);\n+      node* p = m_find_node(*head, k, code);\n \n       if (p)\n \t{\n@@ -1644,43 +1665,37 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node* \n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    find_node(node* p, const key_type& k,\n-\t      typename hashtable::hash_code_t code) const\n+    m_find_node(node* p, const key_type& k,\n+\t\ttypename hashtable::hash_code_t code) const\n     {\n       for (; p; p = p->m_next)\n \tif (this->compare(k, code, p))\n \t  return p;\n       return false;\n     }\n \n-  // Insert v if no element with its key is already present.\n+  // Insert v in bucket n (assumes no element with its key already present).\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n \t   bool c, bool ci, bool u>\n-    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, ci, u>::iterator, bool>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    insert(const value_type& v, std::tr1::true_type)\n+    m_insert_bucket(const value_type& v, size_type n,\n+\t\t    typename hashtable::hash_code_t code)\n     {\n-      const key_type& k = this->m_extract(v);\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n-      \n-      if (node* p = find_node(m_buckets[n], k, code))\n-\treturn std::make_pair(iterator(p, m_buckets + n), false);\n-\n       std::pair<bool, std::size_t> do_rehash\n \t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n \n       // Allocate the new node before doing the rehash so that we don't\n       // do a rehash if the allocation throws.\n       node* new_node = m_allocate_node(v);\n-      \n+\n       try\n \t{\n \t  if (do_rehash.first)\n \t    {\n+\t      const key_type& k = this->m_extract(v);\n \t      n = this->bucket_index(k, code, do_rehash.second);\n \t      m_rehash(do_rehash.second);\n \t    }\n@@ -1689,14 +1704,33 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  this->store_code(new_node, code);\n \t  m_buckets[n] = new_node;\n \t  ++m_element_count;\n-\t  return std::make_pair(iterator(new_node, m_buckets + n), true);\n+\t  return iterator(new_node, m_buckets + n);\n \t}\n       catch(...)\n \t{\n \t  m_deallocate_node(new_node);\n \t  __throw_exception_again;\n \t}\n     }\n+\n+  // Insert v if no element with its key is already present.\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n+\t\t\t\t H2, H, RP, c, ci, u>::iterator, bool>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    m_insert(const value_type& v, std::tr1::true_type)\n+    {\n+      const key_type& k = this->m_extract(v);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n+      size_type n = this->bucket_index(k, code, m_bucket_count);\n+\n+      if (node* p = m_find_node(m_buckets[n], k, code))\n+\treturn std::make_pair(iterator(p, m_buckets + n), false);\n+      return std::make_pair(m_insert_bucket(v, n, code), true);\n+    }\n   \n   // Insert v unconditionally.\n   template<typename K, typename V, \n@@ -1705,19 +1739,19 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    insert(const value_type& v, std::tr1::false_type)\n+    m_insert(const value_type& v, std::tr1::false_type)\n     {\n       std::pair<bool, std::size_t> do_rehash\n \t= m_rehash_policy.need_rehash(m_bucket_count, m_element_count, 1);\n       if (do_rehash.first)\n \tm_rehash(do_rehash.second);\n-\n+ \n       const key_type& k = this->m_extract(v);\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      std::size_t n = this->bucket_index(k, code, m_bucket_count);\n-      \n+      size_type n = this->bucket_index(k, code, m_bucket_count);\n+\n       node* new_node = m_allocate_node(v);\n-      node* prev = find_node(m_buckets[n], k, code);\n+      node* prev = m_find_node(m_buckets[n], k, code);\n       if (prev)\n \t{\n \t  new_node->m_next = prev->m_next;\n@@ -1741,7 +1775,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     void\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase_node(node* p, node** b)\n+    m_erase_node(node* p, node** b)\n     {\n       node* cur = *b;\n       if (cur == p)\n@@ -1786,25 +1820,25 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(iterator i)\n+    erase(iterator it)\n     {\n-      iterator result = i;\n+      iterator result = it;\n       ++result;\n-      erase_node(i.m_cur_node, i.m_cur_bucket);\n+      m_erase_node(it.m_cur_node, it.m_cur_bucket);\n       return result;\n     }\n-  \n+\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n \t   bool c, bool ci, bool u>\n     typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    erase(const_iterator i)\n+    erase(const_iterator it)\n     {\n-      const_iterator result = i;\n+      const_iterator result = it;\n       ++result;\n-      erase_node(i.m_cur_node, i.m_cur_bucket);\n+      m_erase_node(it.m_cur_node, it.m_cur_bucket);\n       return result;\n     }\n "}, {"sha": "e682f362a0aeb3a5b582d9354ad91f26a173416e", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/unordered_map_array.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_map_array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99b2be1d370134c4c0307f81a2d60470ccad81b/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_map_array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_map_array.cc?ref=f99b2be1d370134c4c0307f81a2d60470ccad81b", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <tr1/unordered_map>\n+#include <testsuite_performance.h>\n+\n+typedef std::tr1::unordered_map<int, int> map_type;\n+typedef std::tr1::unordered_map<int, map_type> matrix_type;\n+\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  const int sz = 1000;\n+\n+  matrix_type matrix;\n+\n+  start_counters(time, resource);\n+  for (int iter = 0; iter < 50; ++iter)\n+    {\n+      for (int i = 0; i < sz; ++i)\n+\t{\n+\t  for (int j = 0; j < sz; ++j)\n+\t    {\n+\t      map_type& row = matrix[i / 4];\n+\t      ++row[j / 4];\n+\t    }\n+\t}\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"\", time, resource);\n+\n+  return 0;\n+}"}]}