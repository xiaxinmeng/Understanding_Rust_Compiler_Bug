{"sha": "5cd4d463f974cced4d9819ace4583641ec0ad188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkNGQ0NjNmOTc0Y2NlZDRkOTgxOWFjZTQ1ODM2NDFlYzBhZDE4OA==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-12-16T22:54:22Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-12-16T22:54:22Z"}, "message": "win32.cc (WSAEventWrapper): Implemented default constructor and init() methods.\n\n\t* win32.cc (WSAEventWrapper): Implemented default\n\tconstructor and init() methods.\n\t(_Jv_select): Removed.\n\t* gnu/java/nio/natSelectorImplWin32.cc\n\t(helper_put_filedescriptors): Removed.\n\t(helper_get_filedescriptors): Removed.\n\t(implSelect): Implemented in terms of WSAEventWrapper\n\tand WSAWaitForMultipleEvents instead of _Jv_select().\n\tAdded support for thread interruption.\n\t* include/win32.h (WSAEventWrapper): Minor formatting\n\tchanges; added default constructor declaration, init(),\n\tgetFD() and getEventHandle() methods.\n\t(_Jv_select): Removed.\n\nFrom-SVN: r74715", "tree": {"sha": "b5989fc00b6fe0bbc2e88ddede32688185e6203f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5989fc00b6fe0bbc2e88ddede32688185e6203f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cd4d463f974cced4d9819ace4583641ec0ad188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd4d463f974cced4d9819ace4583641ec0ad188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd4d463f974cced4d9819ace4583641ec0ad188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd4d463f974cced4d9819ace4583641ec0ad188/comments", "author": null, "committer": null, "parents": [{"sha": "027e655b6eb26b1a17355c0ad4d97baf9d418a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/027e655b6eb26b1a17355c0ad4d97baf9d418a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/027e655b6eb26b1a17355c0ad4d97baf9d418a30"}], "stats": {"total": 216, "additions": 122, "deletions": 94}, "files": [{"sha": "2667bd2741e59629bf10e1d9e19aa3895310975b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5cd4d463f974cced4d9819ace4583641ec0ad188", "patch": "@@ -1,3 +1,19 @@\n+2003-12-16  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* win32.cc (WSAEventWrapper): Implemented default\n+\tconstructor and init() methods.\n+\t(_Jv_select): Removed.\n+\t* gnu/java/nio/natSelectorImplWin32.cc\n+\t(helper_put_filedescriptors): Removed.\n+\t(helper_get_filedescriptors): Removed.\n+\t(implSelect): Implemented in terms of WSAEventWrapper\n+\tand WSAWaitForMultipleEvents instead of _Jv_select().\n+\tAdded support for thread interruption.\n+\t* include/win32.h (WSAEventWrapper): Minor formatting\n+\tchanges; added default constructor declaration, init(),\n+\tgetFD() and getEventHandle() methods.\n+\t(_Jv_select): Removed.\n+\n 2003-12-16  Mohan Embar  <gnustuff@thisiscool.com>\n \n \t* gnu/java/net/natPlainDatagramSocketImplPosix.cc"}, {"sha": "34c4deb0e96580225ed10565b119d8fa0ef3cb59", "filename": "libjava/gnu/java/nio/natSelectorImplWin32.cc", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Fgnu%2Fjava%2Fnio%2FnatSelectorImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Fgnu%2Fjava%2Fnio%2FnatSelectorImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FnatSelectorImplWin32.cc?ref=5cd4d463f974cced4d9819ace4583641ec0ad188", "patch": "@@ -11,81 +11,83 @@ details.  */\n #include <config.h>\n #include <platform.h>\n \n-#include <errno.h>\n-#include <string.h>\n-\n #include <gnu/java/nio/SelectorImpl.h>\n-#include <java/io/IOException.h>\n-\n-void\n-helper_put_filedescriptors (jintArray fdArray, fd_set& fds, int& max_fd)\n-{\n-  jint* tmpFDArray = elements (fdArray);\n-\n-  for (int index = 0; index < JvGetArrayLength (fdArray); index++)\n-    {\n-      FD_SET (tmpFDArray [index], &fds);\n-\n-      if (tmpFDArray [index] > max_fd)\n-        max_fd = tmpFDArray [index];\n-    }\n-}\n-\n-void\n-helper_get_filedescriptors (jintArray& fdArray, fd_set fds)\n-{\n-  jint* tmpFDArray = elements (fdArray);\n-  \n-  for (int index = 0; index < JvGetArrayLength (fdArray); index++)\n-    if (!FD_ISSET (tmpFDArray [index], &fds))\n-      tmpFDArray [index] = 0;\n-}\n+#include <java/lang/Thread.h>\n \n jint\n gnu::java::nio::SelectorImpl::implSelect (jintArray read, jintArray write,\n                                           jintArray except, jlong timeout)\n {\n-  jint result;\n-  int max_fd = 0;\n-  fd_set read_fds;\n-  fd_set write_fds;\n-  fd_set except_fds;\n-  struct timeval real_time_data;\n-  struct timeval *time_data = NULL;\n+  // FIXME: The API for implSelect is biased towards POSIX implementations.\n+  jint* pReadFD = elements (read);\n+  int nNbReadFDs = JvGetArrayLength (read);\n \n-  real_time_data.tv_sec = 0;\n-  real_time_data.tv_usec = timeout;\n+  jint* pWriteFD = elements (write);\n+  int nNbWriteFDs = JvGetArrayLength (write);\n+  \n+  int nNbEvents = nNbReadFDs + nNbWriteFDs;\n+  \n+  // Create and initialize our event wrapper array\n+  \n+  // FIXME: We're creating fresh WSAEVENTs for each call.\n+  // This is inefficient. It would probably be better to cache these\n+  // in the Win32 socket implementation class.\n+  WSAEventWrapper aArray[nNbEvents];\n+\n+  int nCurIndex = 0;\n+  for (int i=0; i < nNbReadFDs; ++i)\n+    aArray[nCurIndex++].init(pReadFD[i], FD_ACCEPT | FD_READ);\n+\n+  for (int i=0; i < nNbWriteFDs; ++i)\n+    aArray[nCurIndex++].init(pWriteFD[i], FD_WRITE);\n+\n+  // Build our array of WSAEVENTs to wait on. Also throw in our thread's\n+  // interrupt event in order to detect thread interruption.\n+  HANDLE arh[nNbEvents + 1];\n+  for (int i=0; i < nNbEvents; ++i)\n+    arh[i] = aArray[i].getEventHandle();\n+  arh[nNbEvents] = _Jv_Win32GetInterruptEvent ();\n+  \n+  // A timeout value of 0 needs to be treated as infinite.\n+  if (timeout <= 0)\n+    timeout = WSA_INFINITE;\n \n-  // If not legal timeout value is given, use NULL.\n-  // This means an infinite timeout.\n-  if (timeout >= 0)\n+  // Do the select.\n+  DWORD dwRet = WSAWaitForMultipleEvents (nNbEvents+1, arh, 0, timeout, false);\n+  \n+  if (dwRet == WSA_WAIT_FAILED)\n+    _Jv_ThrowIOException ();\n+\n+  // Before we do anything else, clear output file descriptor arrays.\n+  memset(pReadFD, 0, sizeof(jint) * nNbReadFDs);\n+  memset(pWriteFD, 0, sizeof(jint) * nNbWriteFDs);\n+  memset(elements (except), 0, sizeof(jint) * JvGetArrayLength (except));\n+  \n+  if (dwRet == DWORD(WSA_WAIT_EVENT_0 + nNbEvents))\n     {\n-      time_data = &real_time_data;\n+      // We were interrupted. Set the current thread's interrupt\n+      // status and get out of here, with nothing selected..\n+      ::java::lang::Thread::currentThread ()->interrupt ();\n+      return 0;\n     }\n-\n-  // Reset all fd_set structures\n-  FD_ZERO (&read_fds);\n-  FD_ZERO (&write_fds);\n-  FD_ZERO (&except_fds);\n-\n-  // Fill the fd_set data structures for the _Jv_select() call.\n-  helper_put_filedescriptors (read, read_fds, max_fd);\n-  helper_put_filedescriptors (write, write_fds, max_fd);\n-  helper_put_filedescriptors (except, except_fds, max_fd);\n-\n-  // Actually do the select\n-  result = _Jv_select (max_fd + 1, &read_fds, &write_fds, &except_fds, time_data);\n-\n-  if (result < 0)\n+  else if (dwRet < DWORD(WSA_WAIT_EVENT_0 + nNbEvents))\n     {\n-      char* strerr = strerror (errno);\n-      throw new ::java::io::IOException (JvNewStringUTF (strerr));\n+      int nSelectedEventIndex = dwRet - WSA_WAIT_EVENT_0;\n+\n+      // Record the selected file descriptor.\n+      // FIXME: This implementation only allows one file descriptor\n+      // to be selected at a time. Remedy this by looping on\n+      // WSAWaitForMultipleEvents 'til nothing more is selected.\n+      jint fd = aArray[nSelectedEventIndex].getFD();\n+      if (nSelectedEventIndex < nNbReadFDs)\n+        pReadFD[0] = fd;\n+      else\n+        pWriteFD[0] = fd;\n+\n+      return 1;  \n     }\n-\n-  // Set the file descriptors according to the values returned from select().\n-  helper_get_filedescriptors (read, read_fds);\n-  helper_get_filedescriptors (write, write_fds);\n-  helper_get_filedescriptors (except, except_fds);\n-\n-  return result;\n+  else\n+    // None of the event objects was signalled, so nothing was\n+    // selected.\n+    return 0;\n }"}, {"sha": "8dd2964e6372fbda9bed145eb22c0bb14b445e80", "filename": "libjava/include/win32.h", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Finclude%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Finclude%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32.h?ref=5cd4d463f974cced4d9819ace4583641ec0ad188", "patch": "@@ -93,25 +93,36 @@ extern jstring _Jv_Win32NewString (LPCTSTR pcsz);\n /* Useful helper classes and methods. */\n \n /* A C++ wrapper around a WSAEVENT which closes the event\n-\t in its destructor. If dwSelFlags is non-zero, we also\n-\t issue an WSAEventSelect on the socket descriptor with\n-\t the given flags; this is undone by a corresponding call\n-\t to WSAEventSelect(fd, 0, 0) in our destructor. */\n+   in its destructor. If dwSelFlags is non-zero, we also\n+   issue an WSAEventSelect on the socket descriptor with\n+   the given flags; this is undone by a corresponding call\n+   to WSAEventSelect(fd, 0, 0) in our destructor. */\n class WSAEventWrapper\n {\n public:\n-\tWSAEventWrapper(int fd, DWORD dwSelFlags);\n-\t~WSAEventWrapper();\n+  // Default constructor. Call init() after this.\n+  WSAEventWrapper();\n+  WSAEventWrapper(int fd, DWORD dwSelFlags);\n+  ~WSAEventWrapper();\n \n-\tWSAEVENT getEventHandle()\n-\t{\n-\t\treturn m_hEvent;\n-\t}\n+  // Used for two-step initialization after calling\n+  // default constructor.\n+  void init(int fd, DWORD dwSelFlags);\n+\n+  int getFD()\n+  {\n+    return m_fd;\n+  }\n+\n+  WSAEVENT getEventHandle()\n+  {\n+    return m_hEvent;\n+  }\n \n private:\n-\tWSAEVENT m_hEvent;\n-\tint m_fd;\n-\tDWORD m_dwSelFlags;\n+  WSAEVENT m_hEvent;\n+  int m_fd;\n+  DWORD m_dwSelFlags;\n };\n \n // Error string text. The int argument is compatible\n@@ -141,7 +152,6 @@ _Jv_ThrowSocketException ();\n extern void _Jv_platform_initialize (void);\n extern void _Jv_platform_initProperties (java::util::Properties*);\n extern jlong _Jv_platform_gettimeofday ();\n-extern int _Jv_select (int n, fd_set *, fd_set *, fd_set *, struct timeval *);\n extern int _Jv_pipe (int filedes[2]);\n \n extern void"}, {"sha": "027333be73852e6444e5f3bb4b96e5506546bb1a", "filename": "libjava/win32.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Fwin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd4d463f974cced4d9819ace4583641ec0ad188/libjava%2Fwin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32.cc?ref=5cd4d463f974cced4d9819ace4583641ec0ad188", "patch": "@@ -143,11 +143,24 @@ _Jv_Win32TempString::~_Jv_Win32TempString()\n }\n \n // class WSAEventWrapper\n+WSAEventWrapper::WSAEventWrapper ():\n+  m_hEvent(0),\n+  m_fd(0),\n+  m_dwSelFlags(0)\n+{}\n+\n WSAEventWrapper::WSAEventWrapper (int fd, DWORD dwSelFlags):\n   m_hEvent(0),\n-  m_fd(fd),\n-  m_dwSelFlags(dwSelFlags)\n+  m_fd(0),\n+  m_dwSelFlags(0)\n+{\n+  init(fd, dwSelFlags);\n+}\n+\n+void WSAEventWrapper::init(int fd, DWORD dwSelFlags)\n {\n+  m_fd = fd;\n+  m_dwSelFlags = dwSelFlags;\n   m_hEvent = WSACreateEvent ();\n   if (dwSelFlags)\n     WSAEventSelect(fd, m_hEvent, dwSelFlags);\n@@ -445,19 +458,6 @@ backtrace (void **__array, int __size)\n   return i;\n }\n \n-int\n-_Jv_select (int n, fd_set *readfds, fd_set  *writefds,\n-      fd_set *exceptfds, struct timeval *timeout)\n-{\n-  int r = ::select (n, readfds, writefds, exceptfds, timeout);\n-  if (r == SOCKET_ERROR)\n-    {\n-      DWORD dwErrorCode = WSAGetLastError ();\n-      throw new java::io::IOException (_Jv_WinStrError (dwErrorCode));\n-    }\n-  return r;      \n-}\n-\n int\n _Jv_pipe (int filedes[2])\n {"}]}