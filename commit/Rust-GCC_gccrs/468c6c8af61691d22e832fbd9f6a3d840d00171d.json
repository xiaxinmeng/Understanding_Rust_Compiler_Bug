{"sha": "468c6c8af61691d22e832fbd9f6a3d840d00171d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4YzZjOGFmNjE2OTFkMjJlODMyZmJkOWY2YTNkODQwZDAwMTcxZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:06:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:06:06Z"}, "message": "sem_attr.ads, [...] (Analyze_Access_Attribute): Diagnose properly an attempt to apply Unchecked_Access to a protected operation.\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_attr.ads, sem_attr.adb (Analyze_Access_Attribute): Diagnose\n\tproperly an attempt to apply Unchecked_Access to a protected operation.\n\t(OK_Self_Reference): New subprogram to check the legality of an access\n\tattribute whose prefix is the type of an enclosing aggregate.\n\tGeneralizes previous mechanism to handle attribute references nested\n\tarbitrarily deep within the aggregate.\n\t(Analyze_Access_Attribute): An access attribute whose prefix is a type\n\tcan appear in an aggregate if this is a default-initialized aggregate\n\tfor a self-referential type.\n\t(Resolve_Attribute, case Access): Ditto.\n\tAdd support for new implementation defined attribute Stub_Type.\n\t(Eval_Attribute, case Attribute_Stub_Type): New case.\n\t(Analyze_Attribute, case Attribute_Stub_Type): New case.\n\t(Stream_Attribute_Available): Implement using new subprogram from\n\tsem_cat, Has_Stream_Attribute_Definition, instead of incorrect\n\tHas_Specified_Stream_Attribute flag.\n\tDisallow Storage_Size and Storage_Pool for access to subprogram\n\t(Resolve_Attribute, case 'Access et al): Take into account anonymous\n\taccess types of return subtypes in extended return statements. Remove\n\taccessibility checks on anonymous access types when Unchecked_Access is\n\tused.\n\t(Analyze_Attribute): Add support for the use of 'Class to convert\n\ta class-wide interface to a tagged type.\n\tAdd support for the attribute Priority.\n\t(Resolve_Attribute, case Attribute_Access): For Ada_05, add test for\n\twhether the designated type is discriminated with a constrained partial\n\tview and require static matching in that case.\n\tAdd local variable Des_Btyp. The Designated_Type\n\tof an access to incomplete subtype is either its non-limited view if\n\tcoming from a limited with or its etype if regular incomplete subtype.\n\n\t* sem_cat.ads, sem_cat.adb (Validate_Remote_Access_To_Class_Wide_Type):\n\tFix predicate to identify and allow cases of (expander-generated)\n\treferences to tag of designated object of a RACW.\n\t(Validate_Static_Object_Name): In Ada 2005, a formal object is\n\tnon-static, and therefore cannot appear as a primary in a preelaborable\n\tpackage.\n\t(Has_Stream_Attribute_Definition): New subprogram, abstracted from\n\tHas_Read_Write_Attributes.\n\t(Has_Read_Write_Attributes): Reimplement in termes of\n\tHas_Stream_Attribute_Definition.\n\t(Missing_Read_Write_Attributes): When checking component types in a\n\trecord, unconditionally call Missing_Read_Write_Attributes recursively\n\t(remove guard checking for Is_Record_Type / Is_Access_Type).\n\nFrom-SVN: r118298", "tree": {"sha": "e430fef9f70b2c6e9a023185a5207237d0af6a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e430fef9f70b2c6e9a023185a5207237d0af6a58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/468c6c8af61691d22e832fbd9f6a3d840d00171d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468c6c8af61691d22e832fbd9f6a3d840d00171d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468c6c8af61691d22e832fbd9f6a3d840d00171d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468c6c8af61691d22e832fbd9f6a3d840d00171d/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "daca8389efba4b72ee492746f613faa05413dff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daca8389efba4b72ee492746f613faa05413dff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daca8389efba4b72ee492746f613faa05413dff0"}], "stats": {"total": 837, "additions": 571, "deletions": 266}, "files": [{"sha": "91a8b61601b92a259978721ac9977e054a0d541d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 186, "deletions": 48, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=468c6c8af61691d22e832fbd9f6a3d840d00171d", "patch": "@@ -31,6 +31,7 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Eval_Fat;\n+with Exp_Dist; use Exp_Dist;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n with Freeze;   use Freeze;\n@@ -342,6 +343,11 @@ package body Sem_Attr is\n          --  the type of the prefix. If prefix is overloaded, so it the\n          --  node itself. The result is stored in Acc_Type.\n \n+         function OK_Self_Reference return Boolean;\n+         --  An access reference whose prefix is a type can legally appear\n+         --  within an aggregate, where it is obtained by expansion of\n+         --  a defaulted aggregate;\n+\n          ------------------------------\n          -- Build_Access_Object_Type --\n          ------------------------------\n@@ -432,6 +438,36 @@ package body Sem_Attr is\n             end if;\n          end Build_Access_Subprogram_Type;\n \n+         ----------------------\n+         -- OK_Self_Reference --\n+         ----------------------\n+\n+         function OK_Self_Reference return Boolean is\n+            Par : Node_Id;\n+\n+         begin\n+            Par := Parent (N);\n+            while Present (Par)\n+              and then Nkind (Par) in N_Subexpr\n+            loop\n+               exit when Nkind (Par) = N_Aggregate\n+                 or else Nkind (Par) = N_Extension_Aggregate;\n+               Par := Parent (Par);\n+            end loop;\n+\n+            if Present (Par)\n+              and then\n+                (Nkind (Par) = N_Aggregate\n+                   or else Nkind (Par) = N_Extension_Aggregate)\n+              and then Etype (Par) = Typ\n+            then\n+               Set_Has_Self_Reference (Par);\n+               return True;\n+            else\n+               return False;\n+            end if;\n+         end OK_Self_Reference;\n+\n       --  Start of processing for Analyze_Access_Attribute\n \n       begin\n@@ -460,6 +496,10 @@ package body Sem_Attr is\n                   P);\n             end if;\n \n+            if Aname = Name_Unchecked_Access then\n+               Error_Attr (\"attribute% cannot be applied to a subprogram\", P);\n+            end if;\n+\n             --  Build the appropriate subprogram type\n \n             Build_Access_Subprogram_Type (P);\n@@ -488,7 +528,9 @@ package body Sem_Attr is\n          end if;\n \n          --  Deal with incorrect reference to a type, but note that some\n-         --  accesses are allowed (references to the current type instance).\n+         --  accesses are allowed: references to the current type instance,\n+         --  or in Ada 2005 self-referential pointer in a default-initialized\n+         --  aggregate.\n \n          if Is_Entity_Name (P) then\n             Typ := Entity (P);\n@@ -570,6 +612,15 @@ package body Sem_Attr is\n                elsif Is_Task_Type (Typ) then\n                   null;\n \n+               --  OK if self-reference in an aggregate in Ada 2005, and\n+               --  the reference comes from a copied default expression.\n+\n+               elsif Ada_Version >= Ada_05\n+                 and then not Comes_From_Source (N)\n+                 and then OK_Self_Reference\n+               then\n+                  null;\n+\n                --  Otherwise we have an error case\n \n                else\n@@ -985,7 +1036,6 @@ package body Sem_Attr is\n \n       procedure Check_Enum_Image is\n          Lit : Entity_Id;\n-\n       begin\n          if Is_Enumeration_Type (P_Base_Type) then\n             Lit := First_Literal (P_Base_Type);\n@@ -1277,6 +1327,7 @@ package body Sem_Attr is\n       procedure Check_Stream_Attribute (Nam : TSS_Name_Type) is\n          Etyp : Entity_Id;\n          Btyp : Entity_Id;\n+\n       begin\n          Validate_Non_Static_Attribute_Function_Call;\n \n@@ -1561,6 +1612,8 @@ package body Sem_Attr is\n                return False;\n             end On_X86;\n \n+         --  Start of processing for Alignment_Kludge\n+\n          begin\n             if Aname = Name_Maximum_Alignment and then On_X86 then\n                P := Parent (N);\n@@ -1673,7 +1726,6 @@ package body Sem_Attr is\n             elsif Entity (P) = Current_Scope\n               and then Is_Record_Type (Entity (P))\n             then\n-\n                --  Use of current instance within the type. Verify that if the\n                --  attribute appears within a constraint, it  yields an access\n                --  type, other uses are illegal.\n@@ -1779,7 +1831,6 @@ package body Sem_Attr is\n \n             begin\n                Get_First_Interp (P, I, It);\n-\n                while Present (It.Nam) loop\n                   if Comes_From_Source (It.Nam) then\n                      Count := Count + 1;\n@@ -2329,15 +2380,16 @@ package body Sem_Attr is\n \n             Save_Interps (E1, Expression (N));\n \n-            if not Is_Interface (Etype (P)) then\n-               Analyze (N);\n-\n             --  Ada 2005 (AI-251): In case of abstract interfaces we have to\n             --  analyze and resolve the type conversion to generate the code\n             --  that displaces the reference to the base of the object.\n \n-            else\n+            if Is_Interface (Etype (P))\n+              or else Is_Interface (Etype (E1))\n+            then\n                Analyze_And_Resolve (N, Etype (P));\n+            else\n+               Analyze (N);\n             end if;\n \n          --  Otherwise we just need to find the proper type\n@@ -3410,6 +3462,56 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n+      --------------\n+      -- Priority --\n+      --------------\n+\n+      --  Ada 2005 (AI-327): Dynamic ceiling priorities\n+\n+      when Attribute_Priority =>\n+         if Ada_Version < Ada_05 then\n+            Error_Attr (\"% attribute is allowed only in Ada 2005 mode\", P);\n+         end if;\n+\n+         Check_E0;\n+\n+         --  The prefix must be a protected object (AARM D.5.2 (2/2))\n+\n+         Analyze (P);\n+\n+         if Is_Protected_Type (Etype (P))\n+           or else (Is_Access_Type (Etype (P))\n+                      and then Is_Protected_Type (Designated_Type (Etype (P))))\n+         then\n+            Resolve (P, Etype (P));\n+         else\n+            Error_Attr (\"prefix of % attribute must be a protected object\", P);\n+         end if;\n+\n+         Set_Etype (N, Standard_Integer);\n+\n+         --  Must be called from within a protected procedure or entry of the\n+         --  protected object.\n+\n+         declare\n+            S : Entity_Id;\n+\n+         begin\n+            S := Current_Scope;\n+            while S /= Etype (P)\n+               and then S /= Standard_Standard\n+            loop\n+               S := Scope (S);\n+            end loop;\n+\n+            if S = Standard_Standard then\n+               Error_Attr (\"the attribute % is only allowed inside protected \"\n+                           & \"operations\", P);\n+            end if;\n+         end;\n+\n+         Validate_Non_Static_Attribute_Function_Call;\n+\n       -----------\n       -- Range --\n       -----------\n@@ -3619,6 +3721,11 @@ package body Sem_Attr is\n          if Is_Access_Type (P_Type) then\n             Check_E0;\n \n+            if Ekind (P_Type) = E_Access_Subprogram_Type then\n+               Error_Attr\n+                 (\"cannot use % attribute for access-to-subprogram type\", P);\n+            end if;\n+\n             --  Set appropriate entity\n \n             if Present (Associated_Storage_Pool (Root_Type (P_Type))) then\n@@ -3644,12 +3751,16 @@ package body Sem_Attr is\n       ------------------\n \n       when Attribute_Storage_Size =>\n-\n          if Is_Task_Type (P_Type) then\n             Check_E0;\n             Set_Etype (N, Universal_Integer);\n \n          elsif Is_Access_Type (P_Type) then\n+            if Ekind (P_Type) = E_Access_Subprogram_Type then\n+               Error_Attr\n+                 (\"cannot use % attribute for access-to-subprogram type\", P);\n+            end if;\n+\n             if Is_Entity_Name (P)\n               and then Is_Type (Entity (P))\n             then\n@@ -3700,6 +3811,22 @@ package body Sem_Attr is\n             Error_Attr (\"invalid prefix for % attribute\", P);\n          end if;\n \n+      ---------------\n+      -- Stub_Type --\n+      ---------------\n+\n+      when Attribute_Stub_Type =>\n+         Check_Type;\n+         Check_E0;\n+\n+         if Is_Remote_Access_To_Class_Wide_Type (P_Type) then\n+            Rewrite (N,\n+              New_Occurrence_Of (Corresponding_Stub_Type (P_Type), Loc));\n+         else\n+            Error_Attr\n+              (\"prefix of% attribute must be remote access to classwide\", P);\n+         end if;\n+\n       ----------\n       -- Succ --\n       ----------\n@@ -6725,10 +6852,12 @@ package body Sem_Attr is\n            Attribute_Partition_ID             |\n            Attribute_Pool_Address             |\n            Attribute_Position                 |\n+           Attribute_Priority                 |\n            Attribute_Read                     |\n            Attribute_Storage_Pool             |\n            Attribute_Storage_Size             |\n            Attribute_Storage_Unit             |\n+           Attribute_Stub_Type                |\n            Attribute_Tag                      |\n            Attribute_Target_Name              |\n            Attribute_Terminated               |\n@@ -6807,6 +6936,7 @@ package body Sem_Attr is\n       Aname    : constant Name_Id      := Attribute_Name (N);\n       Attr_Id  : constant Attribute_Id := Get_Attribute_Id (Aname);\n       Btyp     : constant Entity_Id    := Base_Type (Typ);\n+      Des_Btyp : Entity_Id;\n       Index    : Interp_Index;\n       It       : Interp;\n       Nom_Subt : Entity_Id;\n@@ -7170,6 +7300,8 @@ package body Sem_Attr is\n             --  X'Access is illegal if X denotes a constant and the access\n             --  type is access-to-variable. Same for 'Unchecked_Access.\n             --  The rule does not apply to 'Unrestricted_Access.\n+            --  If the reference is a default-initialized aggregate component\n+            --  for a self-referential type the reference is legal.\n \n             if not (Ekind (Btyp) = E_Access_Subprogram_Type\n                      or else Ekind (Btyp) = E_Anonymous_Access_Subprogram_Type\n@@ -7182,7 +7314,15 @@ package body Sem_Attr is\n                      or else Is_Variable (P)\n                      or else Attr_Id = Attribute_Unrestricted_Access)\n             then\n-               if Comes_From_Source (N) then\n+               if Is_Entity_Name (P)\n+                 and then Is_Type (Entity (P))\n+               then\n+                  --  Legality of a self-reference through an access\n+                  --  attribute has been verified in Analyze_Access_Attribute.\n+\n+                  null;\n+\n+               elsif Comes_From_Source (N) then\n                   Error_Msg_N (\"access-to-variable designates constant\", P);\n                end if;\n             end if;\n@@ -7199,8 +7339,11 @@ package body Sem_Attr is\n                --  enclosing composite type.\n \n                if Ada_Version >= Ada_05\n-                 and then Is_Local_Anonymous_Access (Btyp)\n+                 and then\n+                   (Is_Local_Anonymous_Access (Btyp)\n+                      or else Ekind (Scope (Btyp)) = E_Return_Statement)\n                  and then Object_Access_Level (P) > Type_Access_Level (Btyp)\n+                 and then Attr_Id = Attribute_Access\n                then\n                   --  In an instance, this is a runtime check, but one we\n                   --  know will fail, so generate an appropriate warning.\n@@ -7236,6 +7379,23 @@ package body Sem_Attr is\n                   Nom_Subt := Etype (Nom_Subt);\n                end if;\n \n+               Des_Btyp := Designated_Type (Btyp);\n+\n+               if Ekind (Des_Btyp) = E_Incomplete_Subtype then\n+\n+                  --  Ada 2005 (AI-412): Subtypes of incomplete types visible\n+                  --  through a limited with clause or regular incomplete\n+                  --  subtypes.\n+\n+                  if From_With_Type (Des_Btyp)\n+                    and then Present (Non_Limited_View (Des_Btyp))\n+                  then\n+                     Des_Btyp := Non_Limited_View (Des_Btyp);\n+                  else\n+                     Des_Btyp := Etype (Des_Btyp);\n+                  end if;\n+               end if;\n+\n                if Is_Tagged_Type (Designated_Type (Typ)) then\n \n                   --  If the attribute is in the context of an access\n@@ -7291,13 +7451,22 @@ package body Sem_Attr is\n                        (N, Etype (Designated_Type (Typ)));\n                   end if;\n \n-               elsif not Subtypes_Statically_Match\n-                           (Designated_Type (Base_Type (Typ)), Nom_Subt)\n+               --  Ada 2005 (AI-363): Require static matching when designated\n+               --  type has discriminants and a constrained partial view, since\n+               --  in general objects of such types are mutable, so we can't\n+               --  allow the access value to designate a constrained object\n+               --  (because access values must be assumed to designate mutable\n+               --  objects when designated type does not impose a constraint).\n+\n+               elsif not Subtypes_Statically_Match (Des_Btyp, Nom_Subt)\n                  and then\n                    not (Has_Discriminants (Designated_Type (Typ))\n+                          and then not Is_Constrained (Des_Btyp)\n                           and then\n-                            not Is_Constrained\n-                                  (Designated_Type (Base_Type (Typ))))\n+                            (Ada_Version < Ada_05\n+                              or else\n+                                not Has_Constrained_Partial_View\n+                                      (Designated_Type (Base_Type (Typ)))))\n                then\n                   Error_Msg_N\n                     (\"object subtype must statically match \"\n@@ -7306,7 +7475,6 @@ package body Sem_Attr is\n                   if Is_Entity_Name (P)\n                     and then Is_Array_Type (Designated_Type (Typ))\n                   then\n-\n                      declare\n                         D : constant Node_Id := Declaration_Node (Entity (P));\n \n@@ -7795,42 +7963,12 @@ package body Sem_Attr is\n    is\n       Etyp : Entity_Id := Typ;\n \n-      function Has_Specified_Stream_Attribute\n-        (Typ : Entity_Id;\n-         Nam : TSS_Name_Type) return Boolean;\n-      --  True iff there is a visible attribute definition clause specifying\n-      --  attribute Nam for Typ.\n-\n-      ------------------------------------\n-      -- Has_Specified_Stream_Attribute --\n-      ------------------------------------\n-\n-      function Has_Specified_Stream_Attribute\n-        (Typ : Entity_Id;\n-         Nam : TSS_Name_Type) return Boolean\n-      is\n-      begin\n-         return False\n-           or else\n-             (Nam = TSS_Stream_Input\n-               and then Has_Specified_Stream_Input (Typ))\n-           or else\n-             (Nam = TSS_Stream_Output\n-               and then Has_Specified_Stream_Output (Typ))\n-           or else\n-             (Nam = TSS_Stream_Read\n-               and then Has_Specified_Stream_Read (Typ))\n-           or else\n-             (Nam = TSS_Stream_Write\n-               and then Has_Specified_Stream_Write (Typ));\n-      end Has_Specified_Stream_Attribute;\n-\n    --  Start of processing for Stream_Attribute_Available\n \n    begin\n       --  We need some comments in this body ???\n \n-      if Has_Specified_Stream_Attribute (Typ, Nam) then\n+      if Has_Stream_Attribute_Definition (Typ, Nam) then\n          return True;\n       end if;\n \n@@ -7874,7 +8012,7 @@ package body Sem_Attr is\n       while Etype (Etyp) /= Etyp loop\n          Etyp := Etype (Etyp);\n \n-         if Has_Specified_Stream_Attribute (Etyp, Nam) then\n+         if Has_Stream_Attribute_Definition (Etyp, Nam) then\n             return True;\n          end if;\n       end loop;"}, {"sha": "c80852aa7d93c36b19a5d5db185a238ef1262b4d", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=468c6c8af61691d22e832fbd9f6a3d840d00171d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,18 +78,18 @@ package Sem_Attr is\n       ---------------\n \n       Attribute_Asm_Input => True,\n-      --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n-      --  in package Machine_Code to construct machine instructions. See\n-      --  documentation in package Machine_Code in file s-maccod.ads.\n+      --  Used only in conjunction with the Asm subprograms in package\n+      --  Machine_Code to construct machine instructions. See documentation\n+      --  in package Machine_Code in file s-maccod.ads.\n \n       ----------------\n       -- Asm_Output --\n       ----------------\n \n       Attribute_Asm_Output => True,\n-      --  Used only in conjunction with the Asm and Asm_Volatile subprograms\n-      --  in package Machine_Code to construct machine instructions. See\n-      --  documentation in package Machine_Code in file s-maccod.ads.\n+      --  Used only in conjunction with the Asm subprograms in package\n+      --  Machine_Code to construct machine instructions. See documentation\n+      --  in package Machine_Code in file s-maccod.ads.\n \n       ---------------\n       -- AST_Entry --\n@@ -382,6 +382,27 @@ package Sem_Attr is\n       --  for constructing this definition in package System (see note above\n       --  in Default_Bit_Order description). The is a static attribute.\n \n+      ---------------\n+      -- Stub_Type --\n+      ---------------\n+\n+      Attribute_Stub_Type => True,\n+      --  The GNAT implementation of remote access-to-classwide types is\n+      --  organised as described in AARM E.4(20.t): a value of an RACW type\n+      --  (designating a remote object) is represented as a normal access\n+      --  value, pointing to a \"stub\" object which in turn contains the\n+      --  necessary information to contact the designated remote object. A\n+      --  call on any dispatching operation of such a stub object does the\n+      --  remote call, if necessary, using the information in the stub object\n+      --  to locate the target partition, etc.\n+      --\n+      --  For a prefix T that denotes a remote access-to-classwide type,\n+      --  T'Stub_Type denotes the type of the corresponding stub objects.\n+      --\n+      --  By construction, the layout of T'Stub_Type is identical to that of\n+      --  System.Partition_Interface.RACW_Stub_Type (see implementation notes\n+      --  in body of Exp_Dist).\n+\n       -----------------\n       -- Target_Name --\n       -----------------"}, {"sha": "dc7350a2101616ccd0f6f8674126bf06ffda5845", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 338, "deletions": 209, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=468c6c8af61691d22e832fbd9f6a3d840d00171d", "patch": "@@ -29,7 +29,6 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Exp_Tss;  use Exp_Tss;\n with Fname;    use Fname;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n@@ -73,6 +72,8 @@ package body Sem_Cat is\n    function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean;\n    --  Return True if the entity or one of its subcomponent is an access\n    --  type which does not have user-defined Read and Write attribute.\n+   --  Additionally, in Ada 2005 mode, stream attributes are considered missing\n+   --  if the attribute definition clause is not visible.\n \n    function In_RCI_Declaration (N : Node_Id) return Boolean;\n    --  Determines if a declaration is  within the visible part of  a Remote\n@@ -84,7 +85,8 @@ package body Sem_Cat is\n    --  for semantic checking purposes.\n \n    function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean;\n-   --  Returns true if the entity is a non-remote access type\n+   --  Returns true if the entity is a type whose full view is a non-remote\n+   --  access type, for the purpose of enforcing E.2.2(8) rules.\n \n    function In_Shared_Passive_Unit return Boolean;\n    --  Determines if current scope is within a Shared Passive compilation unit\n@@ -295,6 +297,51 @@ package body Sem_Cat is\n       end loop;\n    end Check_Non_Static_Default_Expr;\n \n+   -------------------------------------\n+   -- Has_Stream_Attribute_Definition --\n+   -------------------------------------\n+\n+   function Has_Stream_Attribute_Definition\n+     (Typ : Entity_Id; Nam : TSS_Name_Type) return Boolean\n+   is\n+      Rep_Item : Node_Id;\n+   begin\n+      --  We start from the declaration node and then loop until the end of\n+      --  the list until we find the requested attribute definition clause.\n+      --  In Ada 2005 mode, clauses are ignored if they are not currently\n+      --  visible (this is tested using the corresponding Entity, which is\n+      --  inserted by the expander at the point where the clause occurs).\n+\n+      Rep_Item := First_Rep_Item (Typ);\n+      while Present (Rep_Item) loop\n+         if Nkind (Rep_Item) = N_Attribute_Definition_Clause then\n+            case Chars (Rep_Item) is\n+               when Name_Read =>\n+                  exit when Nam = TSS_Stream_Read;\n+\n+               when Name_Write =>\n+                  exit when Nam = TSS_Stream_Write;\n+\n+               when Name_Input =>\n+                  exit when Nam = TSS_Stream_Input;\n+\n+               when Name_Output =>\n+                  exit when Nam = TSS_Stream_Output;\n+\n+               when others =>\n+                  null;\n+\n+            end case;\n+         end if;\n+\n+         Next_Rep_Item (Rep_Item);\n+      end loop;\n+\n+      return Present (Rep_Item)\n+        and then (Ada_Version < Ada_05\n+                   or else not Is_Hidden (Entity (Rep_Item)));\n+   end Has_Stream_Attribute_Definition;\n+\n    ---------------------------\n    -- In_Preelaborated_Unit --\n    ---------------------------\n@@ -306,7 +353,7 @@ package body Sem_Cat is\n \n    begin\n       --  There are no constraints on body of remote_call_interface or\n-      --  remote_types packages..\n+      --  remote_types packages.\n \n       return (Unit_Entity /= Standard_Standard)\n         and then (Is_Preelaborated (Unit_Entity)\n@@ -422,10 +469,19 @@ package body Sem_Cat is\n    -------------------------------\n \n    function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean is\n+      U_E : constant Entity_Id := Underlying_Type (E);\n    begin\n-      return Is_Access_Type (E)\n-        and then not Is_Remote_Access_To_Class_Wide_Type (E)\n-        and then not Is_Remote_Access_To_Subprogram_Type (E);\n+      if No (U_E) then\n+\n+         --  This case arises for the case of a generic formal type, in which\n+         --  case E.2.2(8) rules will be enforced at instantiation time.\n+\n+         return False;\n+      end if;\n+\n+      return Is_Access_Type (U_E)\n+        and then not Is_Remote_Access_To_Class_Wide_Type (U_E)\n+        and then not Is_Remote_Access_To_Subprogram_Type (U_E);\n    end Is_Non_Remote_Access_Type;\n \n    ------------------------------------\n@@ -460,59 +516,47 @@ package body Sem_Cat is\n    function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean is\n       Component      : Entity_Id;\n       Component_Type : Entity_Id;\n+      U_E            : constant Entity_Id := Underlying_Type (E);\n \n       function Has_Read_Write_Attributes (E : Entity_Id) return Boolean;\n-      --  Return True if entity has Read and Write attributes\n+      --  Return True if entity has visible attribute definition clauses for\n+      --  Read and Write attributes.\n \n       -------------------------------\n       -- Has_Read_Write_Attributes --\n       -------------------------------\n \n       function Has_Read_Write_Attributes (E : Entity_Id) return Boolean is\n-         Rep_Item        : Node_Id := First_Rep_Item (E);\n-         Read_Attribute  : Boolean := False;\n-         Write_Attribute : Boolean := False;\n-\n       begin\n-         --  We start from the declaration node and then loop until the end\n-         --  of the list until we find those two attribute definition clauses.\n-\n-         while Present (Rep_Item) loop\n-            if Chars (Rep_Item) = Name_Read then\n-               Read_Attribute := True;\n-            elsif Chars (Rep_Item) = Name_Write then\n-               Write_Attribute := True;\n-            end if;\n-\n-            if Read_Attribute and Write_Attribute then\n-               return True;\n-            end if;\n-\n-            Next_Rep_Item (Rep_Item);\n-         end loop;\n-\n-         return False;\n+         return True\n+           and then Has_Stream_Attribute_Definition (E, TSS_Stream_Read)\n+           and then Has_Stream_Attribute_Definition (E, TSS_Stream_Write);\n       end Has_Read_Write_Attributes;\n \n    --  Start of processing for Missing_Read_Write_Attributes\n \n    begin\n-      if Has_Read_Write_Attributes (E) then\n+      if No (U_E) then\n+         return False;\n+\n+      elsif Has_Read_Write_Attributes (E)\n+        or else Has_Read_Write_Attributes (U_E)\n+      then\n          return False;\n-      elsif Is_Non_Remote_Access_Type (E) then\n+\n+      elsif Is_Non_Remote_Access_Type (U_E) then\n          return True;\n       end if;\n \n-      if Is_Record_Type (E) then\n-         Component := First_Entity (E);\n+      if Is_Record_Type (U_E) then\n+         Component := First_Entity (U_E);\n          while Present (Component) loop\n-            Component_Type := Etype (Component);\n+            if not Is_Tag (Component) then\n+               Component_Type := Etype (Component);\n \n-            if (Is_Non_Remote_Access_Type (Component_Type)\n-                or else Is_Record_Type (Component_Type))\n-              and then Missing_Read_Write_Attributes (Component_Type)\n-            then\n-               return True;\n+               if Missing_Read_Write_Attributes (Component_Type) then\n+                  return True;\n+               end if;\n             end if;\n \n             Next_Entity (Component);\n@@ -536,16 +580,22 @@ package body Sem_Cat is\n          --  the argument of the pragma can be resolved properly, and reset\n          --  afterwards.\n \n-      procedure Set_Parents (Visibility : Boolean) is\n-         Par : Entity_Id := Scope (S);\n+      -----------------\n+      -- Set_Parents --\n+      -----------------\n \n+      procedure Set_Parents (Visibility : Boolean) is\n+         Par : Entity_Id;\n       begin\n+         Par := Scope (S);\n          while Present (Par) and then Par /= Standard_Standard loop\n             Set_Is_Immediately_Visible (Par, Visibility);\n             Par := Scope (Par);\n          end loop;\n       end Set_Parents;\n \n+   --  Start of processing for Set_Categorization_From_Pragmas\n+\n    begin\n       --  Deal with categorization pragmas in Pragmas of Compilation_Unit.\n       --  The purpose is to set categorization flags before analyzing the\n@@ -558,16 +608,16 @@ package body Sem_Cat is\n       end if;\n \n       declare\n-         PN : Node_Id := First (Pragmas_After (Aux_Decls_Node (P)));\n+         PN : Node_Id;\n \n       begin\n-\n          if Is_Child_Unit (S)\n            and then Is_Generic_Instance (S)\n          then\n             Set_Parents (True);\n          end if;\n \n+         PN := First (Pragmas_After (Aux_Decls_Node (P)));\n          while Present (PN) loop\n \n             --  Skip implicit types that may have been introduced by\n@@ -588,12 +638,12 @@ package body Sem_Cat is\n \n             Next (PN);\n          end loop;\n+\n          if Is_Child_Unit (S)\n            and then Is_Generic_Instance (S)\n          then\n             Set_Parents (False);\n          end if;\n-\n       end;\n    end Set_Categorization_From_Pragmas;\n \n@@ -711,11 +761,15 @@ package body Sem_Cat is\n                Set_Is_Pure_Unit_Access_Type (T);\n             end if;\n \n-            --  Check for RCI or RT unit type declaration. It should not\n-            --  contain the declaration of an access-to-object type unless it\n-            --  is a general access type that designates a class-wide limited\n-            --  private type. There are also constraints about the primitive\n-            --  subprograms of the class-wide type.\n+            --  Check for RCI or RT unit type declaration: declaration of an\n+            --  access-to-object type is illegal unless it is a general access\n+            --  type that designates a class-wide limited private type.\n+            --  Note that constraints on the primitive subprograms of the\n+            --  designated tagged type are not enforced here but in\n+            --  Validate_RACW_Primitives, which is done separately because the\n+            --  designated type might not be frozen (and therefore its\n+            --  primitive operations might not be completely known) at the\n+            --  point of the RACW declaration.\n \n             Validate_Remote_Access_Object_Type_Declaration (T);\n \n@@ -810,7 +864,6 @@ package body Sem_Cat is\n          loop\n             U := Scope (U);\n          end loop;\n-\n       end if;\n \n       if Nkind (P) /= N_Compilation_Unit then\n@@ -834,7 +887,6 @@ package body Sem_Cat is\n \n       begin\n          Item := First (Context_Items (P));\n-\n          while Present (Item) loop\n             if Nkind (Item) = N_With_Clause\n               and then not (Implicit_With (Item)\n@@ -883,6 +935,13 @@ package body Sem_Cat is\n \n    procedure Validate_Controlled_Object (E : Entity_Id) is\n    begin\n+      --  Don't need this check in Ada 2005 mode, where this is all taken\n+      --  care of by the mechanism for Preelaborable Initialization.\n+\n+      if Ada_Version >= Ada_05 then\n+         return;\n+      end if;\n+\n       --  For now, never apply this check for internal GNAT units, since we\n       --  have a number of cases in the library where we are stuck with objects\n       --  of this type, and the RM requires Preelaborate.\n@@ -920,7 +979,6 @@ package body Sem_Cat is\n    begin\n       if In_Preelaborated_Unit then\n          Item := First (Statements (Handled_Statement_Sequence (N)));\n-\n          while Present (Item) loop\n             if Nkind (Item) /= N_Label\n               and then Nkind (Item) /= N_Null_Statement\n@@ -1003,9 +1061,10 @@ package body Sem_Cat is\n \n                if Is_Array_Type (Ent) then\n                   declare\n-                     Comp_Type : Entity_Id := Component_Type (Ent);\n+                     Comp_Type : Entity_Id;\n \n                   begin\n+                     Comp_Type := Component_Type (Ent);\n                      while Is_Array_Type (Comp_Type) loop\n                         Comp_Type := Component_Type (Comp_Type);\n                      end loop;\n@@ -1032,21 +1091,64 @@ package body Sem_Cat is\n                   end if;\n                end if;\n \n-               --  We relax the restriction of 10.2.1(9) within GNAT\n-               --  units. (There are ACVC tests that check that the\n-               --  restriction is enforced, but note that AI-161,\n-               --  once approved, will relax the restriction prohibiting\n-               --  default-initialized objects of private types, and\n-               --  will recommend a pragma for marking private types.)\n-\n-               if (Is_Private_Type (Ent)\n-                    or else Depends_On_Private (Ent))\n-                 and then not Is_Internal_File_Name\n-                                (Unit_File_Name (Get_Source_Unit (N)))\n+               --  Check for invalid use of private object. Note that Ada 2005\n+               --  AI-161 modifies the rules for Ada 2005, including the use of\n+               --  the new pragma Preelaborable_Initialization.\n+\n+               if Is_Private_Type (Ent)\n+                 or else Depends_On_Private (Ent)\n                then\n-                  Error_Msg_N\n-                    (\"private object not allowed in preelaborated unit\", N);\n-                  return;\n+                  --  Case where type has preelaborable initialization which\n+                  --  means that a pragma Preelaborable_Initialization was\n+                  --  given for the private type.\n+\n+                  if Has_Preelaborable_Initialization (Ent) then\n+\n+                     --  But for the predefined units, we will ignore this\n+                     --  status unless we are in Ada 2005 mode since we want\n+                     --  Ada 95 compatible behavior, in which the entities\n+                     --  marked with this pragma in the predefined library are\n+                     --  not treated specially.\n+\n+                     if Ada_Version < Ada_05 then\n+                        Error_Msg_N\n+                          (\"private object not allowed in preelaborated unit\",\n+                           N);\n+                        Error_Msg_N (\"\\(would be legal in Ada 2005 mode)\", N);\n+                     end if;\n+\n+                  --  Type does not have preelaborable initialization\n+\n+                  else\n+                     --  We allow this when compiling in GNAT mode to make life\n+                     --  easier for some cases where it would otherwise be hard\n+                     --  to be exactly valid Ada.\n+\n+                     if not GNAT_Mode then\n+                        Error_Msg_N\n+                          (\"private object not allowed in preelaborated unit\",\n+                           N);\n+\n+                        --  If we are in Ada 2005 mode, add a message if pragma\n+                        --  Preelaborable_Initialization on the type of the\n+                        --  object would help.\n+\n+                        --  If the type has no full view (generic type, or\n+                        --  previous error), the warning does not apply.\n+\n+                        if Ada_Version >= Ada_05\n+                          and then Is_Private_Type (Ent)\n+                          and then Present (Full_View (Ent))\n+                          and then\n+                            Has_Preelaborable_Initialization (Full_View (Ent))\n+                        then\n+                           Error_Msg_Sloc := Sloc (Ent);\n+                           Error_Msg_NE\n+                             (\"\\would be legal if pragma Preelaborable_\" &\n+                              \"Initialization given for & #\", N, Ent);\n+                        end if;\n+                     end if;\n+                  end if;\n \n                --  Access to Task or Protected type\n \n@@ -1109,9 +1211,9 @@ package body Sem_Cat is\n          end if;\n       end if;\n \n-      --  A pure library_item must not contain the declaration of any\n-      --  variable except within  a subprogram, generic subprogram, task\n-      --  unit or protected unit (RM 10.2.1(16)).\n+      --  A pure library_item must not contain the declaration of any variable\n+      --  except within a subprogram, generic subprogram, task unit, or\n+      --  protected unit (RM 10.2.1(16)).\n \n       if In_Pure_Unit\n         and then not In_Subprogram_Task_Protected_Unit\n@@ -1134,6 +1236,113 @@ package body Sem_Cat is\n \n    end Validate_Object_Declaration;\n \n+   ------------------------------\n+   -- Validate_RACW_Primitives --\n+   ------------------------------\n+\n+   procedure Validate_RACW_Primitives (T : Entity_Id) is\n+      Desig_Type             : Entity_Id;\n+      Primitive_Subprograms  : Elist_Id;\n+      Subprogram_Elmt        : Elmt_Id;\n+      Subprogram             : Entity_Id;\n+      Profile                : List_Id;\n+      Param_Spec             : Node_Id;\n+      Param                  : Entity_Id;\n+      Param_Type             : Entity_Id;\n+      Rtyp                   : Node_Id;\n+\n+   begin\n+      Desig_Type := Etype (Designated_Type (T));\n+\n+      Primitive_Subprograms := Primitive_Operations (Desig_Type);\n+\n+      Subprogram_Elmt := First_Elmt (Primitive_Subprograms);\n+      while Subprogram_Elmt /= No_Elmt loop\n+         Subprogram := Node (Subprogram_Elmt);\n+\n+         if not Comes_From_Source (Subprogram) then\n+            goto Next_Subprogram;\n+         end if;\n+\n+         --  Check return type\n+\n+         if Ekind (Subprogram) = E_Function then\n+            Rtyp := Etype (Subprogram);\n+\n+            if Has_Controlling_Result (Subprogram) then\n+               null;\n+\n+            elsif Ekind (Rtyp) = E_Anonymous_Access_Type then\n+               Error_Msg_N\n+                 (\"anonymous access result in remote object primitive\", Rtyp);\n+\n+            elsif Is_Limited_Type (Rtyp) then\n+               if No (TSS (Rtyp, TSS_Stream_Read))\n+                    or else\n+                  No (TSS (Rtyp, TSS_Stream_Write))\n+               then\n+                  Error_Msg_N\n+                    (\"limited return type must have Read and Write attributes\",\n+                     Parent (Subprogram));\n+                  Explain_Limited_Type (Rtyp, Parent (Subprogram));\n+               end if;\n+\n+            end if;\n+         end if;\n+\n+         Profile := Parameter_Specifications (Parent (Subprogram));\n+\n+         --  Profile must exist, otherwise not primitive operation\n+\n+         Param_Spec := First (Profile);\n+         while Present (Param_Spec) loop\n+\n+            --  Now find out if this parameter is a controlling parameter\n+\n+            Param      := Defining_Identifier (Param_Spec);\n+            Param_Type := Etype (Param);\n+\n+            if Is_Controlling_Formal (Param) then\n+\n+               --  It is a controlling parameter, so specific checks below\n+               --  do not apply.\n+\n+               null;\n+\n+            elsif Ekind (Param_Type) = E_Anonymous_Access_Type then\n+\n+               --  From RM E.2.2(14), no access parameter other than\n+               --  controlling ones may be used.\n+\n+               Error_Msg_N\n+                 (\"non-controlling access parameter\", Param_Spec);\n+\n+            elsif Is_Limited_Type (Param_Type) then\n+\n+               --  Not a controlling parameter, so type must have Read and\n+               --  Write attributes.\n+\n+               if No (TSS (Param_Type, TSS_Stream_Read))\n+                    or else\n+                  No (TSS (Param_Type, TSS_Stream_Write))\n+               then\n+                  Error_Msg_N\n+                    (\"limited formal must have Read and Write attributes\",\n+                     Param_Spec);\n+                  Explain_Limited_Type (Param_Type, Param_Spec);\n+               end if;\n+            end if;\n+\n+            --  Check next parameter in this subprogram\n+\n+            Next (Param_Spec);\n+         end loop;\n+\n+         <<Next_Subprogram>>\n+            Next_Elmt (Subprogram_Elmt);\n+      end loop;\n+   end Validate_RACW_Primitives;\n+\n    -------------------------------\n    -- Validate_RCI_Declarations --\n    -------------------------------\n@@ -1147,7 +1356,7 @@ package body Sem_Cat is\n          if Comes_From_Source (E) then\n             if Is_Limited_Type (E) then\n                Error_Msg_N\n-                 (\"Limited type not allowed in rci unit\", Parent (E));\n+                 (\"limited type not allowed in rci unit\", Parent (E));\n                Explain_Limited_Type (E, Parent (E));\n \n             elsif Ekind (E) = E_Generic_Function\n@@ -1164,10 +1373,10 @@ package body Sem_Cat is\n                Error_Msg_N\n                  (\"inlined subprogram not allowed in rci unit\", Parent (E));\n \n-            --  Inner packages that are renamings need not be checked.\n-            --  Generic RCI packages are subject to the checks, but\n-            --  entities that come from formal packages are not part of the\n-            --  visible declarations of the package and are not checked.\n+            --  Inner packages that are renamings need not be checked. Generic\n+            --  RCI packages are subject to the checks, but entities that come\n+            --  from formal packages are not part of the visible declarations\n+            --  of the package and are not checked.\n \n             elsif Ekind (E) = E_Package then\n                if Present (Renamed_Entity (E)) then\n@@ -1235,7 +1444,6 @@ package body Sem_Cat is\n \n       if Present (Profile) then\n          Param_Spec := First (Profile);\n-\n          while Present (Param_Spec) loop\n             Param_Type := Etype (Defining_Identifier (Param_Spec));\n             Type_Decl  := Parent (Param_Type);\n@@ -1256,10 +1464,9 @@ package body Sem_Cat is\n                       Error_Node);\n                end if;\n \n-            --  For limited private type parameter, we check only the\n-            --  private declaration and ignore full type declaration,\n-            --  unless this is the only declaration for the type, eg.\n-            --  as a limited record.\n+            --  For limited private type parameter, we check only the private\n+            --  declaration and ignore full type declaration, unless this is\n+            --  the only declaration for the type, eg. as a limited record.\n \n             elsif Is_Limited_Type (Param_Type)\n               and then (Nkind (Type_Decl) = N_Private_Type_Declaration\n@@ -1347,16 +1554,10 @@ package body Sem_Cat is\n    procedure Validate_Remote_Access_Object_Type_Declaration (T : Entity_Id) is\n       Direct_Designated_Type : Entity_Id;\n       Desig_Type             : Entity_Id;\n-      Primitive_Subprograms  : Elist_Id;\n-      Subprogram             : Elmt_Id;\n-      Subprogram_Node        : Node_Id;\n-      Profile                : List_Id;\n-      Param_Spec             : Node_Id;\n-      Param_Type             : Entity_Id;\n \n    begin\n-      --  We are called from Analyze_Type_Declaration, and the Nkind\n-      --  of the given node is N_Access_To_Object_Definition.\n+      --  We are called from Analyze_Type_Declaration, and the Nkind of the\n+      --  given node is N_Access_To_Object_Definition.\n \n       if not Comes_From_Source (T)\n         or else (not In_RCI_Declaration (Parent (T))\n@@ -1373,24 +1574,24 @@ package body Sem_Cat is\n          return;\n       end if;\n \n-      --  Check RCI or RT unit type declaration. It may not contain\n-      --  the declaration of an access-to-object type unless it is a\n-      --  general access type that designates a class-wide limited\n-      --  private type. There are also constraints about the primitive\n-      --  subprograms of the class-wide type (RM E.2.3(14)).\n+      --  Check RCI or RT unit type declaration. It may not contain the\n+      --  declaration of an access-to-object type unless it is a general access\n+      --  type that designates a class-wide limited private type. There are\n+      --  also constraints on the primitive subprograms of the class-wide type\n+      --  (RM E.2.2(14), see Validate_RACW_Primitives).\n \n       if Ekind (T) /= E_General_Access_Type\n         or else Ekind (Designated_Type (T)) /= E_Class_Wide_Type\n       then\n          if In_RCI_Declaration (Parent (T)) then\n             Error_Msg_N\n-              (\"access type in Remote_Call_Interface unit must be \" &\n-               \"general access\", T);\n+              (\"error in access type in Remote_Call_Interface unit\", T);\n          else\n-            Error_Msg_N (\"access type in Remote_Types unit must be \" &\n-              \"general access\", T);\n+            Error_Msg_N\n+              (\"error in access type in Remote_Types unit\", T);\n          end if;\n-         Error_Msg_N (\"\\to class-wide type\", T);\n+\n+         Error_Msg_N (\"\\must be general access to class-wide type\", T);\n          return;\n       end if;\n \n@@ -1405,80 +1606,6 @@ package body Sem_Cat is\n          return;\n       end if;\n \n-      Primitive_Subprograms := Primitive_Operations (Desig_Type);\n-      Subprogram            := First_Elmt (Primitive_Subprograms);\n-\n-      while Subprogram /= No_Elmt loop\n-         Subprogram_Node := Node (Subprogram);\n-\n-         if not Comes_From_Source (Subprogram_Node) then\n-            goto Next_Subprogram;\n-         end if;\n-\n-         Profile := Parameter_Specifications (Parent (Subprogram_Node));\n-\n-         --  Profile must exist, otherwise not primitive operation\n-\n-         Param_Spec := First (Profile);\n-         while Present (Param_Spec) loop\n-\n-            --  Now find out if this parameter is a controlling parameter\n-\n-            Param_Type := Parameter_Type (Param_Spec);\n-\n-            if (Nkind (Param_Type) = N_Access_Definition\n-                  and then Etype (Subtype_Mark (Param_Type)) = Desig_Type)\n-              or else (Nkind (Param_Type) /= N_Access_Definition\n-                        and then Etype (Param_Type) = Desig_Type)\n-            then\n-               --  It is a controlling parameter, so specific checks below\n-               --  do not apply.\n-\n-               null;\n-\n-            elsif\n-              Nkind (Param_Type) = N_Access_Definition\n-            then\n-               --  From RM E.2.2(14), no access parameter other than\n-               --  controlling ones may be used.\n-\n-               Error_Msg_N\n-                 (\"non-controlling access parameter\", Param_Spec);\n-\n-            elsif\n-              Is_Limited_Type (Etype (Defining_Identifier (Param_Spec)))\n-            then\n-               --  Not a controlling parameter, so type must have Read\n-               --  and Write attributes.\n-\n-               if Nkind (Param_Type) in N_Has_Etype\n-                 and then Nkind (Parent (Etype (Param_Type))) =\n-                          N_Private_Type_Declaration\n-               then\n-                  Param_Type := Etype (Param_Type);\n-\n-                  if No (TSS (Param_Type, TSS_Stream_Read))\n-                       or else\n-                     No (TSS (Param_Type, TSS_Stream_Write))\n-                  then\n-                     Error_Msg_N\n-                       (\"limited formal must have Read and Write attributes\",\n-                         Param_Spec);\n-                     Explain_Limited_Type\n-                       (Etype (Defining_Identifier (Param_Spec)), Param_Spec);\n-                  end if;\n-               end if;\n-            end if;\n-\n-            --  Check next parameter in this subprogram\n-\n-            Next (Param_Spec);\n-         end loop;\n-\n-         <<Next_Subprogram>>\n-            Next_Elmt (Subprogram);\n-      end loop;\n-\n       --  Now this is an RCI unit access-to-class-wide-limited-private type\n       --  declaration. Set the type entity to be Is_Remote_Call_Interface to\n       --  optimize later checks by avoiding tree traversal to find out if this\n@@ -1545,8 +1672,8 @@ package body Sem_Cat is\n          end if;\n \n       --  This subprogram also enforces the checks in E.2.2(13). A value of\n-      --  such type must not be dereferenced unless as controlling operand of a\n-      --  dispatching call.\n+      --  such type must not be dereferenced unless as controlling operand of\n+      --  a dispatching call.\n \n       elsif K = N_Explicit_Dereference\n         and then (Comes_From_Source (N)\n@@ -1565,8 +1692,7 @@ package body Sem_Cat is\n          --  If we have a true dereference that comes from source and that\n          --  is a controlling argument for a dispatching call, accept it.\n \n-         if K = N_Explicit_Dereference\n-           and then Is_Actual_Parameter (N)\n+         if Is_Actual_Parameter (N)\n            and then Is_Controlling_Actual (N)\n          then\n             return;\n@@ -1582,17 +1708,12 @@ package body Sem_Cat is\n             return;\n          end if;\n \n-         --  The following is to let the compiler generated tags check pass\n-         --  through without error message. This is a bit kludgy isn't there\n-         --  some better way of making this exclusion ???\n-\n-         if (PK = N_Selected_Component\n-              and then Present (Parent (Parent (N)))\n-              and then Nkind (Parent (Parent (N))) = N_Op_Ne)\n-           or else (PK = N_Unchecked_Type_Conversion\n-                    and then Present (Parent (Parent (N)))\n-                    and then\n-                      Nkind (Parent (Parent (N))) = N_Selected_Component)\n+         --  We must allow expanded code to generate a reference to the tag of\n+         --  the designated object (may be either the actual tag, or the stub\n+         --  tag in the case of a remote object).\n+\n+         if PK = N_Selected_Component\n+           and then Is_Tag (Entity (Selector_Name (Parent (N))))\n          then\n             return;\n          end if;\n@@ -1670,39 +1791,43 @@ package body Sem_Cat is\n    -------------------------------\n \n    procedure Validate_RT_RAT_Component (N : Node_Id) is\n-      Spec            : constant Node_Id   := Specification (N);\n-      Name_U          : constant Entity_Id := Defining_Entity (Spec);\n-      Typ             : Entity_Id;\n-      First_Priv_Ent  : constant Entity_Id := First_Private_Entity (Name_U);\n-      In_Visible_Part : Boolean            := True;\n+      Spec           : constant Node_Id   := Specification (N);\n+      Name_U         : constant Entity_Id := Defining_Entity (Spec);\n+      Typ            : Entity_Id;\n+      U_Typ          : Entity_Id;\n+      First_Priv_Ent : constant Entity_Id := First_Private_Entity (Name_U);\n \n    begin\n       if not Is_Remote_Types (Name_U) then\n          return;\n       end if;\n \n       Typ := First_Entity (Name_U);\n-      while Present (Typ) loop\n-         if In_Visible_Part and then Typ = First_Priv_Ent then\n-            In_Visible_Part := False;\n+      while Present (Typ) and then Typ /= First_Priv_Ent loop\n+         U_Typ := Underlying_Type (Typ);\n+\n+         if No (U_Typ) then\n+            U_Typ := Typ;\n          end if;\n \n-         if Comes_From_Source (Typ)\n-           and then Is_Type (Typ)\n-           and then (In_Visible_Part or else Has_Private_Declaration (Typ))\n-         then\n+         if Comes_From_Source (Typ) and then Is_Type (Typ) then\n             if Missing_Read_Write_Attributes (Typ) then\n                if Is_Non_Remote_Access_Type (Typ) then\n-                  Error_Msg_N\n-                    (\"non-remote access type without user-defined Read \" &\n-                     \"and Write attributes\", Typ);\n+                  Error_Msg_N (\"error in non-remote access type\", U_Typ);\n                else\n                   Error_Msg_N\n-                    (\"record type containing a component of a \" &\n-                     \"non-remote access\", Typ);\n+                    (\"error in record type containing a component of a \" &\n+                     \"non-remote access type\", U_Typ);\n+               end if;\n+\n+               if Ada_Version >= Ada_05 then\n+                  Error_Msg_N\n+                    (\"\\must have visible Read and Write attribute \" &\n+                     \"definition clauses ('R'M E.2.2(8))\", U_Typ);\n+               else\n                   Error_Msg_N\n-                    (\"\\type without Read and Write attributes \" &\n-                     \"('R'M E.2.2(8))\", Typ);\n+                    (\"\\must have Read and Write attribute \" &\n+                     \"definition clauses ('R'M E.2.2(8))\", U_Typ);\n                end if;\n             end if;\n          end if;\n@@ -1791,6 +1916,9 @@ package body Sem_Cat is\n \n       function Is_Primary (N : Node_Id) return Boolean;\n       --  Determine whether node is syntactically a primary in an expression\n+      --  This function should probably be somewhere else ???\n+      --  Also it does not do what it says, e.g if N is a binary operator\n+      --  whose parent is a binary operator, Is_Primary returns True ???\n \n       ----------------\n       -- Is_Primary --\n@@ -1801,7 +1929,7 @@ package body Sem_Cat is\n \n       begin\n          case K is\n-            when N_Op | N_In | N_Not_In =>\n+            when N_Op | N_Membership_Test =>\n                return True;\n \n             when N_Aggregate\n@@ -1874,7 +2002,9 @@ package body Sem_Cat is\n         and then (not Inside_A_Generic\n                    or else Present (Enclosing_Generic_Body (N)))\n       then\n-         if Ekind (Entity (N)) = E_Variable then\n+         if Ekind (Entity (N)) = E_Variable\n+           or else Ekind (Entity (N)) in Formal_Object_Kind\n+         then\n             Flag_Non_Static_Expr\n               (\"non-static object name in preelaborated unit\", N);\n \n@@ -1918,7 +2048,6 @@ package body Sem_Cat is\n                   Flag_Non_Static_Expr\n                     (\"non-static constant in preelaborated unit\", N);\n                end if;\n-\n             end if;\n          end if;\n       end if;"}, {"sha": "481a52af9239c8a9047a7a2ab47ea9ddbc013b80", "filename": "gcc/ada/sem_cat.ads", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_cat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c6c8af61691d22e832fbd9f6a3d840d00171d/gcc%2Fada%2Fsem_cat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.ads?ref=468c6c8af61691d22e832fbd9f6a3d840d00171d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,10 +36,21 @@\n --  Note that we treat Preelaborate as a categorization pragma, even though\n --  strictly, according to RM E.2(2,3), the term does not apply in this case.\n \n-with Types; use Types;\n+with Exp_Tss; use Exp_Tss;\n+with Types;   use Types;\n \n package Sem_Cat is\n \n+   function Has_Stream_Attribute_Definition\n+     (Typ : Entity_Id; Nam : TSS_Name_Type) return Boolean;\n+   --  True when there is a attribute definition clause specifying attribute\n+   --  Nam for Typ. In Ada 2005 mode, returns True only when the attribute\n+   --  definition clause is visible. Note that attribute definition clauses\n+   --  inherited from parent types are taken into account by this predicate\n+   --  (to test for presence of an attribute definition clause for one\n+   --  specific type, excluding inherited definitions, the flags\n+   --  Has_Specicied_Stream_* can be used instead).\n+\n    function In_Preelaborated_Unit return Boolean;\n    --  Determines if the current scope is within a preelaborated compilation\n    --  unit, that is one to which one of the pragmas Preelaborate, Pure,\n@@ -137,4 +148,10 @@ package Sem_Cat is\n    --  are not included because the generic declaration and body are\n    --  preelaborable.\n \n+   procedure Validate_RACW_Primitives (T : Entity_Id);\n+   --  Enforce constraints on primitive operations of the designated type of\n+   --  an RACW. Note that since the complete set of primitive operations of the\n+   --  designated type needs to be known, we must defer these checks until the\n+   --  desgianted type is frozen.\n+\n end Sem_Cat;"}]}