{"sha": "394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0ZmE5ZjU0YTRmYzdmMmNjNmVhMDYzMGY5NDhmMGU0NzU1OGUyOA==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2017-04-27T09:10:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:10:44Z"}, "message": "a-cofuba.ads (Add): Take as an additional input parameter the position where the element should be...\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cofuba.ads (Add): Take as an additional input parameter\n\tthe position where the element should be inserted.\n\t(Remove): New function that removes an element from the container.\n\t* a-cofuma.ads (Add): Adapt to the new API of Base.Add.\n\t* a-cofuse.ads (Add): Adapt to the new API of Base.Add.\n\t(Remove): New function that removes an element from a set.\n\t* a-cofuve.ads (Add): Adapt to the new API of Base.Add.\n\t(Remove): New function that removes an element from a sequence.\n\t(Insert): New function that adds anywhere in a sequence.\n\nFrom-SVN: r247297", "tree": {"sha": "5d9de499cf2417de857b33128f1d71075a207f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d9de499cf2417de857b33128f1d71075a207f78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11775988d5f6db984fb902b7447a5b2817b555b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11775988d5f6db984fb902b7447a5b2817b555b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11775988d5f6db984fb902b7447a5b2817b555b1"}], "stats": {"total": 332, "additions": 227, "deletions": 105}, "files": [{"sha": "f6bf798fe547bc570a75b7f8c94feb1e22f095d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -1,3 +1,15 @@\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cofuba.ads (Add): Take as an additional input parameter\n+\tthe position where the element should be inserted.\n+\t(Remove): New function that removes an element from the container.\n+\t* a-cofuma.ads (Add): Adapt to the new API of Base.Add.\n+\t* a-cofuse.ads (Add): Adapt to the new API of Base.Add.\n+\t(Remove): New function that removes an element from a set.\n+\t* a-cofuve.ads (Add): Adapt to the new API of Base.Add.\n+\t(Remove): New function that removes an element from a sequence.\n+\t(Insert): New function that adds anywhere in a sequence.\n+\n 2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* checks.adb (Generate_Range_Check): Revert previous change."}, {"sha": "63ebc5f205bd5d74ea8f053bc1d35df049c5845c", "filename": "gcc/ada/a-cofuba.adb", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.adb?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -33,21 +33,17 @@ pragma Ada_2012;\n \n package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n-   pragma Assertion_Policy\n-      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n-\n    function To_Count (Idx : Extended_Index) return Count_Type\n    is (Count_Type\n-       (Extended_Index'Pos (Idx)\n-        - Extended_Index'Pos (Extended_Index'First)));\n+         (Extended_Index'Pos (Idx)\n+            - Extended_Index'Pos (Extended_Index'First)));\n    function To_Index (Position : Count_Type) return Extended_Index\n    is (Extended_Index'Val\n-       (Position\n-        + Extended_Index'Pos (Extended_Index'First)));\n+         (Position + Extended_Index'Pos (Extended_Index'First)));\n    --  Conversion functions between Index_Type and Count_Type\n \n    function Find (C : Container; E : access Element_Type) return Count_Type;\n-   --  Search a container C for an element equal to E.all, return the\n+   --  Search a container C for an element equal to E.all, returning the\n    --  position in the underlying array.\n \n    ---------\n@@ -86,11 +82,24 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Add --\n    ---------\n \n-   function Add (C : Container; E : Element_Type) return Container is\n+   function Add\n+     (C : Container;\n+      I : Index_Type;\n+      E : Element_Type) return Container\n+   is\n+      A : constant Element_Array_Access :=\n+            new Element_Array'(1 .. C.Elements'Last + 1 => <>);\n+      P : Count_Type := 0;\n    begin\n-      return Container'(Elements =>\n-                           new Element_Array'\n-                          (C.Elements.all & new Element_Type'(E)));\n+      for J in 1 .. C.Elements'Last + 1 loop\n+         if J /= To_Count (I) then\n+            P := P + 1;\n+            A (J) := C.Elements (P);\n+         else\n+            A (J) := new Element_Type'(E);\n+         end if;\n+      end loop;\n+      return Container'(Elements => A);\n    end Add;\n \n    ----------\n@@ -123,7 +132,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n    function Intersection (C1, C2 : Container) return Container is\n       A : constant Element_Array_Access :=\n-        new Element_Array'(1 .. Num_Overlaps (C1, C2) => <>);\n+            new Element_Array'(1 .. Num_Overlaps (C1, C2) => <>);\n       P : Count_Type := 0;\n    begin\n       for I in C1.Elements'Range loop\n@@ -139,8 +148,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    -- Length --\n    ------------\n \n-   function Length (C : Container) return Count_Type is\n-     (C.Elements'Length);\n+   function Length (C : Container) return Count_Type is (C.Elements'Length);\n \n    ---------------------\n    -- Num_Overlaps --\n@@ -157,6 +165,24 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       return P;\n    end Num_Overlaps;\n \n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   function Remove (C : Container; I : Index_Type) return Container is\n+      A : constant Element_Array_Access :=\n+            new Element_Array'(1 .. C.Elements'Last - 1 => <>);\n+      P : Count_Type := 0;\n+   begin\n+      for J in C.Elements'Range loop\n+         if J /= To_Count (I) then\n+            P := P + 1;\n+            A (P) := C.Elements (J);\n+         end if;\n+      end loop;\n+      return Container'(Elements => A);\n+   end Remove;\n+\n    ---------\n    -- Set --\n    ---------\n@@ -165,7 +191,7 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n                  return Container\n    is\n       Result : constant Container :=\n-        Container'(Elements => new Element_Array'(C.Elements.all));\n+                 Container'(Elements => new Element_Array'(C.Elements.all));\n    begin\n       Result.Elements (To_Count (I)) := new Element_Type'(E);\n       return Result;"}, {"sha": "e1760712d729c8e0366125b406dfdb2989aaf331", "filename": "gcc/ada/a-cofuba.ads", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.ads?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -28,16 +28,16 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n---  Functional containers are neither controlled nor limited. This is safe as\n---  no primitives is provided to modify them.\n+--  Functional containers are neither controlled nor limited. This is safe, as\n+--  no primitives are provided to modify them.\n --  Memory allocated inside functional containers is never reclaimed.\n \n pragma Ada_2012;\n \n private generic\n    type Index_Type is (<>);\n-   --  To avoid Constraint_Error being raised at runtime, Index_Type'Base\n-   --  should have at least one more element at the left than Index_Type.\n+   --  To avoid Constraint_Error being raised at run time, Index_Type'Base\n+   --  should have at least one more element at the low end than Index_Type.\n \n    type Element_Type (<>) is private;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n@@ -52,22 +52,28 @@ package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    --  Return True if C1 and C2 contain the same elements at the same position\n \n    function Length (C : Container) return Count_Type;\n-   --  Number of elements stored in C.\n+   --  Number of elements stored in C\n \n    function Get (C : Container; I : Index_Type) return Element_Type;\n-   --  Access to the element at index I in C.\n+   --  Access to the element at index I in C\n \n    function Set (C : Container; I : Index_Type; E : Element_Type)\n                  return Container;\n    --  Return a new container which is equal to C except for the element at\n-   --  index I which is set to E.\n+   --  index I, which is set to E.\n \n-   function Add (C : Container; E : Element_Type) return Container;\n-   --  Return a new container which is C appended with E.\n+   function Add\n+     (C : Container;\n+      I : Index_Type;\n+      E : Element_Type) return Container;\n+   --  Return a new container that is C with E inserted at index I\n+\n+   function Remove (C : Container; I : Index_Type) return Container;\n+   --  Return a new container that is C without the element at index I\n \n    function Find (C : Container; E : Element_Type) return Extended_Index;\n-   --  Return the first index for which the element stored in C is I.\n-   --  If there are no such indexes, return Extended_Index'First.\n+   --  Return the first index for which the element stored in C is I. If there\n+   --  are no such indexes, return Extended_Index'First.\n \n    --------------------\n    -- Set Operations --\n@@ -77,7 +83,7 @@ package Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    --  Return True if every element of C1 is in C2\n \n    function Num_Overlaps (C1, C2 : Container) return Count_Type;\n-   --  Return the number of elements that are both in\n+   --  Return the number of elements that are in both C1 and C2\n \n    function Union (C1, C2 : Container) return Container;\n    --  Return a container which is C1 plus all the elements of C2 that are not\n@@ -92,13 +98,17 @@ private\n    subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n \n    type Element_Access is access all Element_Type;\n+\n    type Element_Array is\n      array (Positive_Count_Type range <>) of Element_Access;\n+\n    type Element_Array_Access is not null access Element_Array;\n+\n    Empty_Element_Array_Access : constant Element_Array_Access :=\n      new Element_Array'(1 .. 0 => null);\n \n    type Container is record\n       Elements : Element_Array_Access := Empty_Element_Array_Access;\n    end record;\n+\n end Ada.Containers.Functional_Base;"}, {"sha": "742320c6f894df0db075de7ca29c48082880291a", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -34,9 +34,6 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    use Key_Containers;\n    use Element_Containers;\n \n-   pragma Assertion_Policy\n-      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n-\n    ---------\n    -- \"=\" --\n    ---------\n@@ -69,8 +66,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    function Add (M : Map; K : Key_Type; E : Element_Type) return Map is\n    begin\n       return\n-        (Keys     => Add (M.Keys, K),\n-         Elements => Add (M.Elements, E));\n+        (Keys     => Add (M.Keys, Length (M.Keys) + 1, K),\n+         Elements => Add (M.Elements, Length (M.Elements) + 1, E));\n    end Add;\n \n    ---------"}, {"sha": "960264c21d7df62f05165004a26488d76974befa", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -39,17 +39,19 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n+   pragma Assertion_Policy (Post => Ignore);\n+\n    type Map is private with\n      Default_Initial_Condition => Is_Empty (Map) and Length (Map) = 0,\n      Iterable                  => (First       => Iter_First,\n                                    Next        => Iter_Next,\n                                    Has_Element => Iter_Has_Element,\n                                    Element     => Iter_Element);\n    --  Maps are empty when default initialized.\n-   --  For in quantification over maps should not be used.\n-   --  For of quantification over maps iterates over keys.\n+   --  \"For in\" quantification over maps should not be used.\n+   --  \"For of\" quantification over maps iterates over keys.\n \n-   --  Maps are axiomatized using Mem and Get encoding respectively the\n+   --  Maps are axiomatized using Mem and Get, encoding respectively the\n    --  presence of a key in a map and an accessor to elements associated to its\n    --  keys. The length of a map is also added to protect Add against overflows\n    --  but it is not actually modeled.\n@@ -64,33 +66,31 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Global => null;\n \n    function \"<=\" (M1, M2 : Map) return Boolean with\n-   --  Map inclusion.\n+   --  Map inclusion\n \n      Global => null,\n      Post   => \"<=\"'Result =\n        (for all K of M1 => Mem (M2, K)\n         and then Get (M2, K) = Get (M1, K));\n \n    function \"=\" (M1, M2 : Map) return Boolean with\n-   --  Extensional equality over maps.\n+   --  Extensional equality over maps\n \n      Global => null,\n      Post   => \"=\"'Result =\n-       ((for all K of M1 => Mem (M2, K)\n-        and then Get (M2, K) = Get (M1, K))\n-        and (for all K of M2 => Mem (M1, K)));\n+       ((for all K of M1 => Mem (M2, K) and then Get (M2, K) = Get (M1, K))\n+          and (for all K of M2 => Mem (M1, K)));\n \n    pragma Warnings (Off, \"unused variable \"\"K\"\"\");\n    function Is_Empty (M : Map) return Boolean with\n-   --  A map is empty if it contains no key.\n-\n+   --  A map is empty if it contains no key\n      Global => null,\n      Post   => Is_Empty'Result = (for all K of M => False);\n    pragma Warnings (On, \"unused variable \"\"K\"\"\");\n \n    function Is_Add\n      (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n-   --  Returns True if Result is M augmented with the mapping K -> E.\n+   --  Returns True if Result is M augmented with the mapping K -> E\n \n    with\n      Global => null,\n@@ -115,7 +115,7 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    function Is_Set\n      (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n-   --  Returns True if Result is M where the element associated to K has been\n+   --  Returns True if Result is M, where the element associated to K has been\n    --  replaced by E.\n \n    with\n@@ -130,7 +130,7 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n           and then (for all K of Result => Mem (M, K)));\n \n    function Set (M : Map; K : Key_Type; E : Element_Type) return Map with\n-   --  Returns M where the element associated to K has been replaced by E.\n+   --  Returns M, where the element associated to K has been replaced by E.\n    --  Is_Set (M, K, E, Result) should be used instead of\n    --  Result = Set (M, K, E) whenever possible both for execution and for\n    --  proof.\n@@ -157,7 +157,9 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Global => null,\n      Pre    => Iter_Has_Element (M, K);\n    pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+\n private\n+\n    pragma SPARK_Mode (Off);\n \n    function \"=\"  (Left, Right : Key_Type) return Boolean\n@@ -190,4 +192,5 @@ private\n \n    function Iter_Element (M : Map; K : Private_Key) return Key_Type is\n      (Key_Containers.Get (M.Keys, Count_Type (K)));\n+\n end Ada.Containers.Functional_Maps;"}, {"sha": "8a3d08d9a2f97d503b69f893d8c73615a1091fb2", "filename": "gcc/ada/a-cofuse.adb", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -34,9 +34,6 @@ pragma Ada_2012;\n package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    use Containers;\n \n-   pragma Assertion_Policy\n-      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n-\n    ---------\n    -- \"=\" --\n    ---------\n@@ -55,27 +52,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    ---------\n \n    function Add (S : Set; E : Element_Type) return Set is\n-     (Content => Add (S.Content, E));\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (S : Set) return Count_Type is (Length (S.Content));\n-\n-   ---------\n-   -- Mem --\n-   ---------\n-\n-   function Mem (S : Set; E : Element_Type) return Boolean is\n-      (Find (S.Content, E) > 0);\n-\n-   ------------------\n-   -- Num_Overlaps --\n-   ------------------\n-\n-   function Num_Overlaps (S1, S2 : Set) return Count_Type is\n-      (Num_Overlaps (S1.Content, S2.Content));\n+     (Content => Add (S.Content, Length (S.Content) + 1, E));\n \n    ------------------\n    -- Intersection --\n@@ -119,6 +96,33 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n       and (for all E of S1 => Mem (Result, E))\n       and (for all E of S2 => Mem (Result, E)));\n \n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (S : Set) return Count_Type is (Length (S.Content));\n+\n+   ---------\n+   -- Mem --\n+   ---------\n+\n+   function Mem (S : Set; E : Element_Type) return Boolean is\n+      (Find (S.Content, E) > 0);\n+\n+   ------------------\n+   -- Num_Overlaps --\n+   ------------------\n+\n+   function Num_Overlaps (S1, S2 : Set) return Count_Type is\n+      (Num_Overlaps (S1.Content, S2.Content));\n+\n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   function Remove (S : Set; E : Element_Type) return Set is\n+     (Content => Remove (S.Content, Find (S.Content, E)));\n+\n    -----------\n    -- Union --\n    -----------"}, {"sha": "6f4dc98ad4d4f001304215ef96034c691f66d5ce", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -37,18 +37,20 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n+   pragma Assertion_Policy (Post => Ignore);\n+\n    type Set is private with\n      Default_Initial_Condition => Is_Empty (Set) and Length (Set) = 0,\n      Iterable                  => (First       => Iter_First,\n                                    Next        => Iter_Next,\n                                    Has_Element => Iter_Has_Element,\n                                    Element     => Iter_Element);\n    --  Sets are empty when default initialized.\n-   --  For in quantification over sets should not be used.\n-   --  For of quantification over sets iterates over elements.\n+   --  \"For in\" quantification over sets should not be used.\n+   --  \"For of\" quantification over sets iterates over elements.\n \n-   --  Sets are axiomatized using Mem which encodes whether an element is\n-   --  contained in a set.  The length of a set is also added to protect Add\n+   --  Sets are axiomatized using Mem, which encodes whether an element is\n+   --  contained in a set. The length of a set is also added to protect Add\n    --  against overflows but it is not actually modeled.\n \n    function Mem (S : Set; E : Element_Type) return Boolean with\n@@ -58,13 +60,13 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Global => null;\n \n    function \"<=\" (S1, S2 : Set) return Boolean with\n-   --  Set inclusion.\n+   --  Set inclusion\n \n      Global => null,\n      Post   => \"<=\"'Result = (for all E of S1 => Mem (S2, E));\n \n    function \"=\" (S1, S2 : Set) return Boolean with\n-   --  Extensional equality over sets.\n+   --  Extensional equality over sets\n \n      Global => null,\n      Post   =>\n@@ -73,14 +75,14 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    pragma Warnings (Off, \"unused variable \"\"E\"\"\");\n    function Is_Empty (S : Set) return Boolean with\n-   --  A set is empty if it contains no element.\n+   --  A set is empty if it contains no element\n \n      Global => null,\n      Post   => Is_Empty'Result = (for all E of S => False);\n    pragma Warnings (On, \"unused variable \"\"E\"\"\");\n \n    function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n-   --  Returns True if Result is S augmented with E.\n+   --  Returns True if Result is S augmented with E\n \n    with\n      Global => null,\n@@ -99,8 +101,18 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Post   => Length (Add'Result) = Length (S) + 1\n      and Is_Add (S, E, Add'Result);\n \n+   function Remove (S : Set; E : Element_Type) return Set with\n+   --  Returns S without E.\n+   --  Is_Add (Result, E, S) should be used instead of Result = Remove (S, E)\n+   --  whenever possible both for execution and for proof.\n+\n+     Global => null,\n+     Pre    => Mem (S, E),\n+     Post   => Length (Remove'Result) = Length (S) - 1\n+     and Is_Add (Remove'Result, E, S);\n+\n    function Is_Intersection (S1, S2, Result : Set) return Boolean with\n-   --  Returns True if Result is the intersection of S1 and S2.\n+   --  Returns True if Result is the intersection of S1 and S2\n \n      Global => null,\n      Post   => Is_Intersection'Result =\n@@ -110,7 +122,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n                (if Mem (S2, E) then Mem (Result, E))));\n \n    function Num_Overlaps (S1, S2 : Set) return Count_Type with\n-   --  Number of elements that are both in S1 and S2.\n+   --  Number of elements that are both in S1 and S2\n \n      Global => null,\n      Post   => Num_Overlaps'Result <= Length (S1)\n@@ -129,7 +141,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      and Is_Intersection (S1, S2, Intersection'Result);\n \n    function Is_Union (S1, S2, Result : Set) return Boolean with\n-   --  Returns True if Result is the union of S1 and S2.\n+   --  Returns True if Result is the union of S1 and S2\n \n      Global => null,\n      Post   => Is_Union'Result =\n@@ -167,7 +179,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Global => null,\n      Pre    => Iter_Has_Element (S, K);\n    pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+\n private\n+\n    pragma SPARK_Mode (Off);\n \n    subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n@@ -192,4 +206,5 @@ private\n \n    function Iter_Element (S : Set; K : Private_Key) return Element_Type is\n      (Containers.Get (S.Content, Count_Type (K)));\n+\n end Ada.Containers.Functional_Sets;"}, {"sha": "04c79097cae26aa403e82ef61d35adb61a4a6fc4", "filename": "gcc/ada/a-cofuve.adb", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.adb?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -33,9 +33,6 @@ pragma Ada_2012;\n package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    use Containers;\n \n-   pragma Assertion_Policy\n-      (Pre => Suppressible, Ghost => Suppressible, Post => Ignore);\n-\n    ---------\n    -- \"=\" --\n    ---------\n@@ -66,7 +63,11 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    ---------\n \n    function Add (S : Sequence; E : Element_Type) return Sequence is\n-     (Content => Add (S.Content, E));\n+     (Content => Add (S.Content,\n+                      Index_Type'Val\n+                        (Index_Type'Pos (Index_Type'First) +\n+                             Length (S.Content)),\n+                      E));\n \n    ---------\n    -- Get --\n@@ -75,6 +76,16 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function Get (S : Sequence; N : Extended_Index) return Element_Type is\n      (Get (S.Content, N));\n \n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   function Insert\n+     (S : Sequence;\n+      N : Index_Type;\n+      E : Element_Type) return Sequence is\n+     (Content => Add (S.Content, N, E));\n+\n    ------------\n    -- Is_Add --\n    ------------\n@@ -123,6 +134,13 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function Length (S : Sequence) return Count_Type is\n      (Length (S.Content));\n \n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   function Remove (S : Sequence; N : Index_Type) return Sequence is\n+     (Content => Remove (S.Content, N));\n+\n    ---------\n    -- Set --\n    ---------"}, {"sha": "13c047ed8e14b238854062dacdaeea80cdd49130", "filename": "gcc/ada/a-cofuve.ads", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/394fa9f54a4fc7f2cc6ea0630f948f0e47558e28/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=394fa9f54a4fc7f2cc6ea0630f948f0e47558e28", "patch": "@@ -34,18 +34,20 @@ private with Ada.Containers.Functional_Base;\n \n generic\n    type Index_Type is (<>);\n-   --  To avoid Constraint_Error being raised at runtime, Index_Type'Base\n-   --  should have at least one more element at the left than Index_Type.\n+   --  To avoid Constraint_Error being raised at run time, Index_Type'Base\n+   --  should have at least one more element at the low end than Index_Type.\n \n    type Element_Type (<>) is private;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n+   pragma Assertion_Policy (Post => Ignore);\n+\n    subtype Extended_Index is Index_Type'Base range\n      Index_Type'Pred (Index_Type'First) .. Index_Type'Last;\n-   --  Index_Type with one more element to the left.\n+   --  Index_Type with one more element at the low end of the range.\n    --  This type is never used but it forces GNATprove to check that there is\n-   --  room for one more element at the left of Index_Type.\n+   --  room for one more element at the low end of Index_Type.\n \n    type Sequence is private\n      with Default_Initial_Condition => Length (Sequence) = 0,\n@@ -55,9 +57,9 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n                   Element     => Get);\n    --  Sequences are empty when default initialized.\n    --  Quantification over sequences can be done using the regular\n-   --  quantification over its range or directky on its elements using for of.\n+   --  quantification over its range or directly on its elements with \"for of\".\n \n-   --  Sequences are axiomatized using Length and Get providing respectively\n+   --  Sequences are axiomatized using Length and Get, providing respectively\n    --  the length of a sequence and an accessor to its Nth element:\n \n    function Length (S : Sequence) return Count_Type with\n@@ -73,14 +75,14 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n    function First return Extended_Index is (Index_Type'First);\n \n    function Get (S : Sequence; N : Extended_Index) return Element_Type\n-   --  Get ranges over Extended_Index so that it can be used for iteration.\n+   --  Get ranges over Extended_Index so that it can be used for iteration\n \n    with\n      Global => null,\n      Pre    => N in Index_Type'First .. Last (S);\n \n    function \"=\" (S1, S2 : Sequence) return Boolean with\n-   --  Extensional equality over sequences.\n+   --  Extensional equality over sequences\n \n      Global => null,\n      Post   => \"=\"'Result =\n@@ -109,22 +111,22 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n    function Is_Set\n      (S : Sequence; N : Index_Type; E : Element_Type; Result : Sequence)\n       return Boolean\n-   --  Returns True if Result is S where the Nth element has been replaced by\n+   --  Returns True if Result is S, where the Nth element has been replaced by\n    --  E.\n \n    with\n      Global => null,\n        Post   => Is_Set'Result =\n          (N in Index_Type'First .. Last (S)\n-          and then Length (Result) = Length (S)\n-          and then Get (Result, N) = E\n-          and then (for all M in Index_Type'First .. Last (S) =>\n-              (if M /= N then Get (Result, M) = Get (S, M))));\n+           and then Length (Result) = Length (S)\n+           and then Get (Result, N) = E\n+           and then (for all M in Index_Type'First .. Last (S) =>\n+                       (if M /= N then Get (Result, M) = Get (S, M))));\n \n    function Set\n      (S : Sequence; N : Index_Type; E : Element_Type) return Sequence\n-   --  Returns S where the Nth element has been replaced by E.\n-   --  Is_Set (S, N, E, Result) should be instead of than\n+   --  Returns S, where the Nth element has been replaced by E.\n+   --  Is_Set (S, N, E, Result) should be used instead of\n    --  Result = Set (S, N, E) whenever possible both for execution and for\n    --  proof.\n \n@@ -135,15 +137,15 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n    function Is_Add\n      (S : Sequence; E : Element_Type; Result : Sequence) return Boolean\n-   --  Returns True if Result is S appended with E.\n+   --  Returns True if Result is S appended with E\n \n    with\n      Global => null,\n      Post   => Is_Add'Result =\n          (Length (Result) = Length (S) + 1\n-          and then Get (Result, Last (Result)) = E\n-          and then (for all M in Index_Type'First .. Last (S) =>\n-              Get (Result, M) = Get (S, M)));\n+           and then Get (Result, Last (Result)) = E\n+           and then (for all M in Index_Type'First .. Last (S) =>\n+                       Get (Result, M) = Get (S, M)));\n \n    function Add (S : Sequence; E : Element_Type) return Sequence with\n    --  Returns S appended with E.\n@@ -154,6 +156,39 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Pre    => Length (S) < Count_Type'Last and Last (S) < Index_Type'Last,\n      Post   => Is_Add (S, E, Add'Result);\n \n+   function Insert\n+     (S : Sequence;\n+      N : Index_Type;\n+      E : Element_Type) return Sequence\n+   with\n+   --  Returns S with E inserted at index I\n+\n+     Global => null,\n+     Pre    => Length (S) < Count_Type'Last and then Last (S) < Index_Type'Last\n+     and then N <= Extended_Index'Succ (Last (S)),\n+     Post   => Length (Insert'Result) = Length (S) + 1\n+     and then Get (Insert'Result, N) = E\n+     and then (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n+                   Get (Insert'Result, M) = Get (S, M))\n+     and then (for all M in Extended_Index'Succ (N) .. Last (Insert'Result) =>\n+                   Get (Insert'Result, M) = Get (S, Extended_Index'Pred (M)))\n+     and then (for all M in N .. Last (S) =>\n+                   Get (Insert'Result, Extended_Index'Succ (M)) = Get (S, M));\n+\n+   function Remove (S : Sequence; N : Index_Type) return Sequence with\n+   --  Returns S without the element at index N\n+\n+     Global => null,\n+     Pre    => Length (S) < Count_Type'Last and Last (S) < Index_Type'Last\n+     and N in Index_Type'First .. Last (S),\n+     Post   => Length (Remove'Result) = Length (S) - 1\n+     and then (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n+                   Get (Remove'Result, M) = Get (S, M))\n+     and then (for all M in N .. Last (Remove'Result) =>\n+                   Get (Remove'Result, M) = Get (S, Extended_Index'Succ (M)))\n+     and then (for all M in Extended_Index'Succ (N) .. Last (S) =>\n+                   Get (Remove'Result, Extended_Index'Pred (M)) = Get (S, M));\n+\n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------\n@@ -172,6 +207,7 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Pre    => Iter_Has_Element (S, I);\n \n private\n+\n    pragma SPARK_Mode (Off);\n \n    package Containers is new Ada.Containers.Functional_Base\n@@ -194,5 +230,6 @@ private\n    is\n      (I in Index_Type'First ..\n         (Index_Type'Val\n-             ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n+           ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n+\n end Ada.Containers.Functional_Vectors;"}]}