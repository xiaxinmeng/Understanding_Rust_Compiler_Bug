{"sha": "499056939e05450db87c2caadd659345617d026e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk5MDU2OTM5ZTA1NDUwZGI4N2MyY2FhZGQ2NTkzNDU2MTdkMDI2ZQ==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T09:59:41Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T09:59:41Z"}, "message": "(class_pose_as): lazy copy dtables.\n\n#include sarray.h\n(class_pose_as): Rewritten\n\nFrom-SVN: r5202", "tree": {"sha": "5a1fe38583d18f17bde8c32c2b3a1035f4872a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a1fe38583d18f17bde8c32c2b3a1035f4872a37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/499056939e05450db87c2caadd659345617d026e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499056939e05450db87c2caadd659345617d026e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/499056939e05450db87c2caadd659345617d026e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/499056939e05450db87c2caadd659345617d026e/comments", "author": null, "committer": null, "parents": [{"sha": "0b3d89ca5432caa60da889962a956766961e4fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3d89ca5432caa60da889962a956766961e4fd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3d89ca5432caa60da889962a956766961e4fd7"}], "stats": {"total": 210, "additions": 96, "deletions": 114}, "files": [{"sha": "7521ad66d200740bf48b8a9d79154bc4c8d96c15", "filename": "gcc/objc/class.c", "status": "modified", "additions": 96, "deletions": 114, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/499056939e05450db87c2caadd659345617d026e/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/499056939e05450db87c2caadd659345617d026e/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=499056939e05450db87c2caadd659345617d026e", "patch": "@@ -25,7 +25,7 @@ You should have received a copy of the GNU General Public License along with\n    covered by the GNU General Public License.  */\n \n #include \"runtime.h\"\t\t/* the kitchen sink */\n-\n+#include \"sarray.h\"\n \n /* The table of classname->class.  Used for objc_lookup_class and friends */\n static cache_ptr __objc_class_hash = 0;\n@@ -211,140 +211,122 @@ void __objc_resolve_class_links()\n }\n \n \n-/* This is a incomplete implementation of posing.   This function does the\n-   bulk of the work but does not initialize the class method caches.  That is\n-   a run-time specific operation.\n \n-I implement posing by hiding SUPER_CLASS, creating new class and meta class\n-   structures, initializing it with IMPOSTOR, and changing it such that it is\n-   identified as SUPER_CLASS. SUPER_CLASS remains in the hierarchy but is\n-   inaccessible by the means. The class hierarchy is then re arranged such\n-   that all of the subclasses of SUPER_CLASS now inherit from the new class\n-   structures -- except the impostor itself. The only dramatic effect on the\n-   application is that subclasses of SUPER_CLASS cannot do a [ ....\n-   super_class ] and expect their real super class. */\n+#define CLASSOF(c) ((c)->class_pointer)\n+\n Class*\n class_pose_as (Class* impostor, Class* super_class)\n {\n-  Class* new_class = (Class*) __objc_xcalloc (1, sizeof (Class));\n-  MetaClass* new_meta_class =\n-    (MetaClass*) __objc_xmalloc(sizeof (MetaClass));\n-  char *new_name = (char *)__objc_xmalloc ((size_t)strlen ((char*)super_class->name) + 12);\n-\n-  /* We must know the state of the hierachy.  Do initial setup if needed */\n-  if(!CLS_ISRESOLV(impostor))\n-    __objc_resolve_class_links();\n-\n-  assert (new_class);\n-  assert (new_meta_class);\n-  assert (new_name);\n-\n-  assert (CLS_ISCLASS(impostor));\n-  assert (CLS_ISCLASS(super_class));\n-\n+  if (!CLS_ISRESOLV (impostor))\n+    __objc_resolve_class_links ();\n+\n+  /* preconditions */\n+  assert (impostor);\n+  assert (super_class);\n+  assert (impostor->super_class == super_class);\n+  assert (CLS_ISCLASS (impostor));\n+  assert (CLS_ISCLASS (super_class));\n   assert (impostor->instance_size == super_class->instance_size);\n \n-  /* Create the impostor class.  */\n-  new_class->class_pointer = new_meta_class;\n-  new_class->super_class = super_class;\n-  new_class->name = super_class->name;\n-  new_class->version = super_class->version;\n-  new_class->info = super_class->info;\n-  new_class->instance_size = super_class->instance_size;\n-  new_class->ivars = super_class->ivars;\n-  new_class->methods = impostor->methods;\n-  new_class->dtable = impostor->dtable;\n-\n-  /* Create the impostor meta class.  */\n-  new_meta_class->class_pointer = super_class->class_pointer->class_pointer;\n-  new_meta_class->super_class = super_class->class_pointer->super_class;\n-  new_meta_class->name = super_class->class_pointer->name;\n-  new_meta_class->version = super_class->class_pointer->version;\n-  new_meta_class->info = super_class->class_pointer->info;\n-  new_meta_class->instance_size = super_class->class_pointer->instance_size;\n-  new_meta_class->ivars = super_class->class_pointer->ivars;\n-  new_meta_class->methods = impostor->class_pointer->methods;\n-  new_meta_class->dtable = impostor->class_pointer->dtable;\n-\n-  /* Now change super/subclass links of all related classes.  This is rather\n-     complex, since we have both super_class link, and subclass_list for the\n-     involved classes. */\n   {\n-    Class* *classpp;\n-    MetaClass* *metaclasspp;\n+    Class **subclass = &(super_class->subclass_list);\n+    BOOL super_is_base_class = NO;\n \n-    /* Remove impostor from subclass list of super_class */\n-    for (classpp = &(super_class->subclass_list);\n-         *classpp;\n-         classpp = &((*classpp)->sibling_class))\n+    /* move subclasses of super_class to impostor */\n+    while (*subclass)\n       {\n-        if (*classpp == impostor)\n-          *classpp = (*classpp)->sibling_class;\n-        if (*classpp == 0)\n-          break;\n+\tClass *nextSub = (*subclass)->sibling_class;\n+\n+\t/* this happens when super_class is a base class */\n+\tif (*subclass == CLASSOF (super_class))\n+\t  {\n+\t    super_is_base_class = YES;\n+\t  }\n+\telse if (*subclass != impostor)\n+\t  {\n+\t    Class *sub = *subclass;\n+\n+\t    /* classes */\n+\t    sub->sibling_class = impostor->subclass_list;\n+\t    sub->super_class = impostor;\n+\t    impostor->subclass_list = sub;\n+\t    \n+\t    /* meta classes */\n+\t    CLASSOF (sub)->sibling_class = CLASSOF (impostor)->subclass_list;\n+\t    CLASSOF (sub)->super_class = CLASSOF (impostor);\n+\t    CLASSOF (impostor)->subclass_list = CLASSOF (sub);\n+\t  }\n+\n+\t*subclass = nextSub;\n       }\n \n-    /* Do the same for the meta classes */\n+    /* set subclasses of superclass to be impostor only */\n+    super_class->subclass_list = impostor;\n+    CLASSOF (super_class)->subclass_list = CLASSOF (impostor);\n+    \n+    /* set impostor to have no sibling classes */\n+    impostor->sibling_class = 0;\n+    CLASSOF (impostor)->sibling_class = 0;\n \n-    for (metaclasspp = &(super_class->class_pointer->subclass_list);\n-         *metaclasspp;\n-         metaclasspp = &((*metaclasspp)->sibling_class))\n+    /* impostor has a sibling... */\n+    if (super_is_base_class)\n       {\n-        if (*metaclasspp == impostor->class_pointer)\n-          *metaclasspp = (*metaclasspp)->sibling_class;\n-        if (*metaclasspp == 0)\n-          break;\n+\tCLASSOF (super_class)->sibling_class = 0;\n+\timpostor->sibling_class = CLASSOF (super_class);\n       }\n+  }\n+  \n+  /* check relationship of impostor and super_class */\n+  assert (impostor->super_class == super_class);\n+  assert (CLASSOF (impostor)->super_class == CLASSOF (super_class));\n \n-    /* From the loop above, classpp now points to the sibling_class entry */\n-    /* of the last element in the list of subclasses for super_class */\n+  /* by now, the re-organization of the class hierachy \n+     is done.  We only need to update various tables. */\n \n-    /* Append the subclass list of impostor to the subclass list of */\n-    /* superclass, and excange those two and set subclass of */\n-    /* super_class to be impostor only */\n+  /* First, we change the names in the hash table.\n+     This will change the behavior of objc_get_class () */\n+  {\n+    char* buffer = (char*) __objc_xmalloc(strlen (super_class->name) + 2);\n \n-    *classpp = impostor->subclass_list;\n-    new_class->subclass_list = super_class->subclass_list;\n-    super_class->subclass_list = new_class;\n-    new_class->sibling_class = 0;\n+    strcpy (buffer+1, super_class->name);\n+    buffer[0] = '*';\n \n-    /* Do the same thing for the meta classes */\n-    *metaclasspp = impostor->class_pointer->subclass_list;\n-    new_meta_class->subclass_list = super_class->class_pointer->subclass_list;\n-    super_class->class_pointer->subclass_list = new_meta_class;\n-    new_meta_class->sibling_class = 0;\n+    /* keep on prepending '*' until the name is unique */\n+    while (hash_value_for_key (__objc_class_hash, buffer))\n+      {\n+\tchar *bbuffer = (char*) __objc_xmalloc (strlen (buffer)+2);\n \n-    /* Update superclass links for all subclasses of new_class */\n-    for (classpp = &(new_class->subclass_list); *classpp;\n-         classpp = &((*classpp)->sibling_class))\n-      (*classpp)->super_class = new_class;\n+\tstrcpy (bbuffer+1, buffer);\n+\tbbuffer[0] = '*';\n+\tfree (buffer);\n+\tbuffer = bbuffer;\n+      }\n \n-    for (metaclasspp = &(new_meta_class->subclass_list); *metaclasspp;\n-         metaclasspp = &((*metaclasspp)->sibling_class))\n-      (*metaclasspp)->super_class = new_meta_class;\n+    hash_remove (__objc_class_hash, super_class->name);\n+    hash_add (&__objc_class_hash, buffer, super_class);\n+    hash_add (&__objc_class_hash, super_class->name, impostor);\n \n+    /* Note that -name and +name will still respond with\n+       the same strings as before.  This way any\n+       -isKindOfGivenName: will always work.         */\n   }\n \n-  /* Delete the class from the hash table, change its name so that it can no\n-     longer be found, then place it back into the hash table using its new\n-     name.\n-  \n-  Don't worry about the class number.  It is already assigned.\n-     memory is lost with the hash key.) */\n-  hash_remove (__objc_class_hash, super_class->name);\n-  sprintf (new_name, \"%s*\", super_class->name);\n-  super_class->name = new_name;\n-  super_class->class_pointer->name = new_name;\n-  hash_add (&__objc_class_hash, super_class->name, super_class);\n-\n-  /* Place the impostor class in class hash table and assign it a class\n-     number.  */\n-  __objc_add_class_to_hash (new_class);\n-\n-  /* Now update dispatch tables for new_class and it's subclasses */\n-  __objc_update_dispatch_table_for_class ((Class*) new_meta_class);\n-  __objc_update_dispatch_table_for_class (new_class);\n-\n-  return new_class;\n-}\n+  /* next, we update the dispatch tables... */\n+  {\n+    Class *subclass;\n+\n+    for (subclass = impostor->subclass_list;\n+\t subclass; subclass = subclass->sibling_class)\n+      {\n+\t/* we use the opportunity to check what we did */\n+\tassert (subclass->super_class == impostor);\n+\tassert (CLASSOF (subclass)->super_class == CLASSOF (impostor));\n \n+\t__objc_update_dispatch_table_for_class (CLASSOF (subclass));\n+\t__objc_update_dispatch_table_for_class (subclass);\n+      }\n+  }\n+\n+  return impostor;\n+}\n+  "}]}