{"sha": "f1deee9179236ea46965e11923c0f8306b6821ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFkZWVlOTE3OTIzNmVhNDY5NjVlMTE5MjNjMGY4MzA2YjY4MjFlZg==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-09-03T20:48:55Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-09-03T20:48:55Z"}, "message": "MSP430: Setup exclusion tables for function and data attributes\n\ngcc/ChangeLog:\n\n2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* config/msp430/msp430.c (msp430_attr): Remove warnings about\n\tconflicting msp430-specific attributes.\n\t(msp430_section_attr): Likewise.\n\tAdd warnings about conflicts with generic \"noinit\" and \"section\"\n\tattributes.\n\tFix grammar in -mlarge error message.\n\t(msp430_data_attr): Rename to msp430_persist_attr.\n\tAdd warnings about conflicts with generic \"noinit\" and \"section\"\n\tattributes.\n\tAdd warning for when variable is not initialized.\n\tChain conditionals which prevent the attribute being added.\n\t(ATTR_EXCL): New helper.\n\t(attr_reent_exclusions): New exclusion table.\n\t(attr_naked_exclusions): Likewise.\n\t(attr_crit_exclusions): Likewise.\n\t(attr_lower_exclusions): Likewise.\n\t(attr_upper_exclusions): Likewise.\n\t(attr_either_exclusions): Likewise.\n\t(attr_persist_exclusions): Likewise.\n\t(msp430_attribute_table): Update with exclusion rules.\n\t(msp430_output_aligned_decl_common): Don't output common symbol if decl\n\thas a section.\n\ngcc/testsuite/ChangeLog:\n\n2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* gcc.target/msp430/data-attributes-2.c: New test.\n\t* gcc.target/msp430/function-attributes-4.c: Update dg-warning\n\tstrings.\n\t* gcc.target/msp430/region-attribute-misuse.c: Likewise.\n\nFrom-SVN: r275356", "tree": {"sha": "20ea6afb60d894c3129d6aeb6241a1fe9fc54058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20ea6afb60d894c3129d6aeb6241a1fe9fc54058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1deee9179236ea46965e11923c0f8306b6821ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1deee9179236ea46965e11923c0f8306b6821ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1deee9179236ea46965e11923c0f8306b6821ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1deee9179236ea46965e11923c0f8306b6821ef/comments", "author": null, "committer": null, "parents": [{"sha": "7a4418a53e80d38918a1f7ca4b8c2050cde08a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a4418a53e80d38918a1f7ca4b8c2050cde08a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a4418a53e80d38918a1f7ca4b8c2050cde08a24"}], "stats": {"total": 317, "additions": 222, "deletions": 95}, "files": [{"sha": "e78a2b39569c5cb728cb2cda89106d745be48de7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -1,3 +1,28 @@\n+2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* config/msp430/msp430.c (msp430_attr): Remove warnings about\n+\tconflicting msp430-specific attributes.\n+\t(msp430_section_attr): Likewise.\n+\tAdd warnings about conflicts with generic \"noinit\" and \"section\"\n+\tattributes.\n+\tFix grammar in -mlarge error message.\n+\t(msp430_data_attr): Rename to msp430_persist_attr.\n+\tAdd warnings about conflicts with generic \"noinit\" and \"section\"\n+\tattributes.\n+\tAdd warning for when variable is not initialized.\n+\tChain conditionals which prevent the attribute being added.\n+\t(ATTR_EXCL): New helper.\n+\t(attr_reent_exclusions): New exclusion table.\n+\t(attr_naked_exclusions): Likewise.\n+\t(attr_crit_exclusions): Likewise.\n+\t(attr_lower_exclusions): Likewise.\n+\t(attr_upper_exclusions): Likewise.\n+\t(attr_either_exclusions): Likewise.\n+\t(attr_persist_exclusions): Likewise.\n+\t(msp430_attribute_table): Update with exclusion rules.\n+\t(msp430_output_aligned_decl_common): Don't output common symbol if decl\n+\thas a section.\n+\n 2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* config/msp430/msp430.c (TARGET_HANDLE_GENERIC_ATTRIBUTE): Define."}, {"sha": "8880522194bca4ed6accbe2da85c84092c9c469a", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 120, "deletions": 79, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -1345,35 +1345,19 @@ msp430_attr (tree * node,\n \t}\n       if (is_critical_func (* node))\n \t{\n+\t  /* We always ignore the critical attribute when interrupt and\n+\t     critical are used together.  */\n \t  warning (OPT_Wattributes,\n \t\t   \"critical attribute has no effect on interrupt functions\");\n \t  DECL_ATTRIBUTES (*node) = remove_attribute (ATTR_CRIT,\n \t\t\t\t\t\t      DECL_ATTRIBUTES (* node));\n \t}\n     }\n-  else if (TREE_NAME_EQ (name, ATTR_REENT))\n-    {\n-      if (is_naked_func (* node))\n-\tmessage = \"naked functions cannot be reentrant\";\n-      else if (is_critical_func (* node))\n-\tmessage = \"critical functions cannot be reentrant\";\n-    }\n   else if (TREE_NAME_EQ (name, ATTR_CRIT))\n     {\n-      if (is_naked_func (* node))\n-\tmessage = \"naked functions cannot be critical\";\n-      else if (is_reentrant_func (* node))\n-\tmessage = \"reentrant functions cannot be critical\";\n-      else if (is_interrupt_func ( *node))\n+      if (is_interrupt_func ( *node))\n \tmessage = \"critical attribute has no effect on interrupt functions\";\n     }\n-  else if (TREE_NAME_EQ (name, ATTR_NAKED))\n-    {\n-      if (is_critical_func (* node))\n-\tmessage = \"critical functions cannot be naked\";\n-      else if (is_reentrant_func (* node))\n-\tmessage = \"reentrant functions cannot be naked\";\n-    }\n \n   if (message)\n     {\n@@ -1396,42 +1380,25 @@ msp430_section_attr (tree * node,\n \n   const char * message = NULL;\n \n-  if (TREE_NAME_EQ (name, ATTR_UPPER))\n-    {\n-      if (has_attr (ATTR_LOWER, * node))\n-\tmessage = \"already marked with 'lower' attribute\";\n-      else if (has_attr (ATTR_EITHER, * node))\n-\tmessage = \"already marked with 'either' attribute\";\n-      else if (! msp430x)\n-\tmessage = \"upper attribute needs a 430X cpu\";\n-    }\n-  else if (TREE_NAME_EQ (name, ATTR_LOWER))\n-    {\n-      if (has_attr (ATTR_UPPER, * node))\n-\tmessage = \"already marked with 'upper' attribute\";\n-      else if (has_attr (ATTR_EITHER, * node))\n-\tmessage = \"already marked with 'either' attribute\";\n-    }\n-  else\n-    {\n-      gcc_assert (TREE_NAME_EQ (name, ATTR_EITHER));\n-\n-      if (has_attr (ATTR_LOWER, * node))\n-\tmessage = \"already marked with 'lower' attribute\";\n-      else if (has_attr (ATTR_UPPER, * node))\n-\tmessage = \"already marked with 'upper' attribute\";\n-    }\n-\n+  /* The \"noinit\" and \"section\" attributes are handled generically, so we\n+     cannot set up additional target-specific attribute exclusions using the\n+     existing mechanism.  */\n+  if (has_attr (ATTR_NOINIT, *node))\n+    message = G_(\"ignoring attribute %qE because it conflicts with \"\n+\t\t \"attribute %<noinit%>\");\n+  else if (has_attr (\"section\", *node))\n+    message = G_(\"ignoring attribute %qE because it conflicts with \"\n+\t\t \"attribute %<section%>\");\n   /* It does not make sense to use upper/lower/either attributes without\n      -mlarge.\n      Without -mlarge, \"lower\" is the default and only region, so is redundant.\n      Without -mlarge, \"upper\" will (and \"either\" might) place code/data in the\n      upper region, which for data could result in relocation overflows, and for\n      code could result in stack mismanagement and incorrect call/return\n      instructions.  */\n-  if (!TARGET_LARGE)\n-    message = G_(\"%qE attribute ignored. large memory model (%<-mlarge%>) \"\n-\t\t \"is required\");\n+  else if (!TARGET_LARGE)\n+    message = G_(\"%qE attribute ignored.  Large memory model (%<-mlarge%>) \"\n+\t\t \"is required.\");\n \n   if (message)\n     {\n@@ -1443,7 +1410,7 @@ msp430_section_attr (tree * node,\n }\n \n static tree\n-msp430_data_attr (tree * node,\n+msp430_persist_attr (tree *node,\n \t\t  tree   name,\n \t\t  tree   args,\n \t\t  int    flags ATTRIBUTE_UNUSED,\n@@ -1453,34 +1420,36 @@ msp430_data_attr (tree * node,\n \n   gcc_assert (DECL_P (* node));\n   gcc_assert (args == NULL);\n+  gcc_assert (TREE_NAME_EQ (name, ATTR_PERSIST));\n \n-  if (TREE_CODE (* node) != VAR_DECL)\n-    message = G_(\"%qE attribute only applies to variables\");\n-\n+  /* Check for the section attribute separately from DECL_SECTION_NAME so\n+     we can provide a clearer warning.  */\n+  if (has_attr (\"section\", *node))\n+    message = G_(\"ignoring attribute %qE because it conflicts with \"\n+\t\t \"attribute %<section%>\");\n   /* Check that it's possible for the variable to have a section.  */\n-  if ((TREE_STATIC (* node) || DECL_EXTERNAL (* node) || in_lto_p)\n-      && DECL_SECTION_NAME (* node))\n+  else if ((TREE_STATIC (*node) || DECL_EXTERNAL (*node) || in_lto_p)\n+\t   && (DECL_SECTION_NAME (*node)))\n     message = G_(\"%qE attribute cannot be applied to variables with specific \"\n \t\t \"sections\");\n-\n-  if (!message && TREE_NAME_EQ (name, ATTR_PERSIST) && !TREE_STATIC (* node)\n-      && !TREE_PUBLIC (* node) && !DECL_EXTERNAL (* node))\n+  else if (has_attr (ATTR_NOINIT, *node))\n+    message = G_(\"ignoring attribute %qE because it conflicts with \"\n+\t\t \"attribute %<noinit%>\");\n+  else if (TREE_CODE (*node) != VAR_DECL)\n+    message = G_(\"%qE attribute only applies to variables\");\n+  else if (!TREE_STATIC (*node) && !TREE_PUBLIC (*node)\n+\t   && !DECL_EXTERNAL (*node))\n     message = G_(\"%qE attribute has no effect on automatic variables\");\n-\n-  /* It's not clear if there is anything that can be set here to prevent the\n-     front end placing the variable before the back end can handle it, in a\n-     similar way to how DECL_COMMON is used below.\n-     So just place the variable in the .persistent section now.  */\n-  if ((TREE_STATIC (* node) || DECL_EXTERNAL (* node) || in_lto_p)\n-      && TREE_NAME_EQ (name, ATTR_PERSIST))\n+  else if (DECL_COMMON (*node) || DECL_INITIAL (*node) == NULL)\n+    message = G_(\"variables marked with %qE attribute must be initialized\");\n+  else\n+    /* It's not clear if there is anything that can be set here to prevent the\n+       front end placing the variable before the back end can handle it, in a\n+       similar way to how DECL_COMMON is cleared for .noinit variables in\n+       handle_noinit_attribute (gcc/c-family/c-attribs.c).\n+       So just place the variable in the .persistent section now.  */\n     set_decl_section_name (* node, \".persistent\");\n \n-  /* If this var is thought to be common, then change this.  Common variables\n-     are assigned to sections before the backend has a chance to process\n-     them.  */\n-  if (DECL_COMMON (* node))\n-    DECL_COMMON (* node) = 0;\n-\n   if (message)\n     {\n       warning (OPT_Wattributes, message, name);\n@@ -1490,6 +1459,67 @@ msp430_data_attr (tree * node,\n   return NULL_TREE;\n }\n \n+/* Helper to define attribute exclusions.  */\n+#define ATTR_EXCL(name, function, type, variable)\t\\\n+  { name, function, type, variable }\n+\n+/* \"reentrant\", \"critical\" and \"naked\" functions must conflict because\n+   they all modify the prologue or epilogue of functions in mutually exclusive\n+   ways.  */\n+static const struct attribute_spec::exclusions attr_reent_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_NAKED, true, true, true),\n+  ATTR_EXCL (ATTR_CRIT, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_naked_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_REENT, true, true, true),\n+  ATTR_EXCL (ATTR_CRIT, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_crit_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_REENT, true, true, true),\n+  ATTR_EXCL (ATTR_NAKED, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+/* Attributes which put the given object in a specific section must conflict\n+   with one another.  */\n+static const struct attribute_spec::exclusions attr_lower_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_UPPER, true, true, true),\n+  ATTR_EXCL (ATTR_EITHER, true, true, true),\n+  ATTR_EXCL (ATTR_PERSIST, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_upper_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_LOWER, true, true, true),\n+  ATTR_EXCL (ATTR_EITHER, true, true, true),\n+  ATTR_EXCL (ATTR_PERSIST, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_either_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_LOWER, true, true, true),\n+  ATTR_EXCL (ATTR_UPPER, true, true, true),\n+  ATTR_EXCL (ATTR_PERSIST, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_persist_exclusions[] =\n+{\n+  ATTR_EXCL (ATTR_LOWER, true, true, true),\n+  ATTR_EXCL (ATTR_UPPER, true, true, true),\n+  ATTR_EXCL (ATTR_EITHER, true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n \n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE\t\tmsp430_attribute_table\n@@ -1500,20 +1530,23 @@ const struct attribute_spec msp430_attribute_table[] =\n     /* { name, min_num_args, max_num_args, decl_req, type_req, fn_type_req,\n \t affects_type_identity, handler, exclude } */\n     { ATTR_INTR,\t0, 1, true,  false, false, false, msp430_attr, NULL },\n-    { ATTR_NAKED,       0, 0, true,  false, false, false, msp430_attr, NULL },\n-    { ATTR_REENT,       0, 0, true,  false, false, false, msp430_attr, NULL },\n-    { ATTR_CRIT,\t0, 0, true,  false, false, false, msp430_attr, NULL },\n+    { ATTR_NAKED,       0, 0, true,  false, false, false, msp430_attr,\n+      attr_naked_exclusions },\n+    { ATTR_REENT,       0, 0, true,  false, false, false, msp430_attr,\n+      attr_reent_exclusions },\n+    { ATTR_CRIT,\t0, 0, true,  false, false, false, msp430_attr,\n+      attr_crit_exclusions },\n     { ATTR_WAKEUP,      0, 0, true,  false, false, false, msp430_attr, NULL },\n \n     { ATTR_LOWER,       0, 0, true,  false, false, false, msp430_section_attr,\n-      NULL },\n+      attr_lower_exclusions },\n     { ATTR_UPPER,       0, 0, true,  false, false, false, msp430_section_attr,\n-      NULL },\n+      attr_upper_exclusions },\n     { ATTR_EITHER,      0, 0, true,  false, false, false, msp430_section_attr,\n-      NULL },\n+      attr_either_exclusions },\n \n-    { ATTR_PERSIST,     0, 0, true,  false, false, false, msp430_data_attr,\n-      NULL },\n+    { ATTR_PERSIST,     0, 0, true,  false, false, false, msp430_persist_attr,\n+      attr_persist_exclusions },\n \n     { NULL,\t\t0, 0, false, false, false, false, NULL,  NULL }\n   };\n@@ -1922,7 +1955,15 @@ msp430_output_aligned_decl_common (FILE *\t\t  stream,\n \t\t\t\t   unsigned HOST_WIDE_INT size,\n \t\t\t\t   unsigned int\t\t  align)\n {\n-  if (msp430_data_region == MSP430_REGION_ANY)\n+  /* Only emit a common symbol if the variable does not have a specific section\n+     assigned.  */\n+  if (msp430_data_region == MSP430_REGION_ANY\n+      && !(decl != NULL_TREE && DECL_SECTION_NAME (decl))\n+      && !has_attr (ATTR_EITHER, decl)\n+      && !has_attr (ATTR_LOWER, decl)\n+      && !has_attr (ATTR_UPPER, decl)\n+      && !has_attr (ATTR_PERSIST, decl)\n+      && !has_attr (ATTR_NOINIT, decl))\n     {\n       fprintf (stream, COMMON_ASM_OP);\n       assemble_name (stream, name);"}, {"sha": "7c9a9c92fd650927d350ea0456c5ff4b3ca399a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -1,6 +1,13 @@\n+2019-09-03  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* gcc.target/msp430/data-attributes-2.c: New test.\n+\t* gcc.target/msp430/function-attributes-4.c: Update dg-warning\n+\tstrings.\n+\t* gcc.target/msp430/region-attribute-misuse.c: Likewise.\n+\n 2019-09-03  Kamlesh Kumar  <kamleshbhalui@gmail.com>\n \n-        PR tree-optimization/91504\n+\tPR tree-optimization/91504\n \tgcc.dg/tree-ssa/pr91504.c: New test.\n \n 2019-09-03  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "d049194425dc9c89cde4c8b3898689410019b139", "filename": "gcc/testsuite/gcc.target/msp430/data-attributes-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fdata-attributes-2.c?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-mcpu=msp430\" } } */\n+/* { dg-options \"-mlarge\" } */\n+\n+/* The msp430-specific variable attributes \"lower\", \"upper\", either\", \"noinit\"\n+   and \"persistent\", all conflict with one another.\n+   These attributes also conflict with the \"section\" attribute, since they\n+   specify sections to put the variables into.  */\n+int __attribute__((persistent)) p = 10;\n+int __attribute__((persistent,lower)) pl = 20; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'persistent'\" } */\n+int __attribute__((persistent,upper)) pu = 20; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'persistent'\" } */\n+int __attribute__((persistent,either)) pe = 20; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'persistent'\" } */\n+/* This one results in an error because the handler for persistent sets the\n+   section to .persistent there and then.  */\n+int __attribute__((persistent,section(\".data.foo\"))) ps = 20; /* { dg-error \"section of 'ps' conflicts with previous declaration\" } */\n+int __attribute__((persistent,noinit)) pn = 2; /* { dg-warning \"'noinit' attribute cannot be applied to variables with specific sections\" } */\n+\n+int __attribute__((noinit)) n;\n+int __attribute__((noinit,lower)) nl; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'noinit'\" } */\n+int __attribute__((noinit,upper)) nu; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'noinit'\" } */\n+int __attribute__((noinit,either)) ne; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'noinit'\" } */\n+int __attribute__((noinit,persistent)) np; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'noinit'\" } */\n+int __attribute__((noinit,section(\".data.foo\"))) ns; /* { dg-warning \"ignoring attribute 'section' because it conflicts with attribute 'noinit'\" } */\n+\n+int __attribute__((lower)) l = 20;\n+int __attribute__((lower,upper)) lu = 20; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'lower'\" } */\n+int __attribute__((lower,either)) le = 20; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'lower'\" } */\n+int __attribute__((lower,persistent)) lp = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'lower'\" } */\n+int __attribute__((lower,noinit)) ln; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'lower'\" } */\n+int __attribute__((lower,section(\".data.foo\"))) ls = 30; /* { dg-warning \"ignoring attribute 'section' because it conflicts with attribute 'lower'\" } */\n+\n+int __attribute__((upper)) u = 20;\n+int __attribute__((upper,lower)) ul = 20; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'upper'\" } */\n+int __attribute__((upper,either)) ue = 20; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'upper'\" } */\n+int __attribute__((upper,persistent)) up = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'upper'\" } */\n+int __attribute__((upper,noinit)) un; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'upper'\" } */\n+int __attribute__((upper,section(\".data.foo\"))) us = 30; /* { dg-warning \"ignoring attribute 'section' because it conflicts with attribute 'upper'\" } */\n+\n+int __attribute__((either)) e = 20;\n+int __attribute__((either,lower)) el = 20; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'either'\" } */\n+int __attribute__((either,upper)) ee = 20; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'either'\" } */\n+int __attribute__((either,persistent)) ep = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'either'\" } */\n+int __attribute__((either,noinit)) en; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'either'\" } */\n+int __attribute__((either,section(\".data.foo\"))) es = 30; /* { dg-warning \"ignoring attribute 'section' because it conflicts with attribute 'either'\" } */\n+\n+int __attribute__((section(\".data.foo\"))) s = 20;\n+int __attribute__((section(\".data.foo\"),noinit)) sn; /* { dg-warning \"ignoring attribute 'noinit' because it conflicts with attribute 'section'\" } */\n+int __attribute__((section(\".data.foo\"),persistent)) sp = 20; /* { dg-warning \"ignoring attribute 'persistent' because it conflicts with attribute 'section'\" } */\n+int __attribute__((section(\".data.foo\"),lower)) sl = 2; /* { dg-warning \"ignoring attribute 'lower' because it conflicts with attribute 'section'\" } */\n+int __attribute__((section(\".data.foo\"),upper)) su = 20; /* { dg-warning \"ignoring attribute 'upper' because it conflicts with attribute 'section'\" } */\n+int __attribute__((section(\".data.foo\"),either)) se = 2; /* { dg-warning \"ignoring attribute 'either' because it conflicts with attribute 'section'\" } */"}, {"sha": "86224cc1436f2abaa556511fbc8dcb5b4c9a577a", "filename": "gcc/testsuite/gcc.target/msp430/function-attributes-4.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Ffunction-attributes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Ffunction-attributes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Ffunction-attributes-4.c?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -1,69 +1,72 @@\n /* { dg-do compile } */\n /* Check that the foo interrupt vectors aren't actually removed.  */\n /* { dg-final { scan-assembler-times \"__interrupt_vector_foo\" 2 } } */\n+/* Check that the out-of-range interrupt vectors aren't actually removed.  */\n+/* { dg-final { scan-assembler \"__interrupt_vector_65\" } } */\n+/* { dg-final { scan-assembler \"__interrupt_vector_100\" } } */\n \n /* Check that warnings are emitted when attributes are used incorrectly and\n    that attributes are interpreted correctly whether leading and trailing\n    underscores are used or not.  */\n \n void __attribute__((__naked__,__reentrant__))\n fn1(void)\n-{ /* { dg-warning \"naked functions cannot be reentrant\" } */\n+{ /* { dg-warning \"ignoring attribute 'reentrant' because it conflicts with attribute 'naked'\" } */\n }\n \n void __attribute__((naked,reentrant))\n fn2(void)\n-{ /* { dg-warning \"naked functions cannot be reentrant\" } */\n+{ /* { dg-warning \"ignoring attribute 'reentrant' because it conflicts with attribute 'naked'\" } */\n }\n \n void __attribute__((__reentrant__,__naked__))\n fn3(void)\n-{ /* { dg-warning \"reentrant functions cannot be naked\" } */\n+{ /* { dg-warning \"ignoring attribute 'naked' because it conflicts with attribute 'reentrant'\" } */\n }\n \n void __attribute__((reentrant,naked))\n fn4(void)\n-{ /* { dg-warning \"reentrant functions cannot be naked\" } */\n+{ /* { dg-warning \"ignoring attribute 'naked' because it conflicts with attribute 'reentrant'\" } */\n }\n \n void __attribute__((__critical__,__reentrant__))\n fn5(void)\n-{ /* { dg-warning \"critical functions cannot be reentrant\" } */\n+{ /* { dg-warning \"ignoring attribute 'reentrant' because it conflicts with attribute 'critical'\" } */\n }\n \n void __attribute__((critical,reentrant))\n fn6(void)\n-{ /* { dg-warning \"critical functions cannot be reentrant\" } */\n+{ /* { dg-warning \"ignoring attribute 'reentrant' because it conflicts with attribute 'critical'\" } */\n }\n \n void __attribute__((__reentrant__,__critical__))\n fn7(void)\n-{ /* { dg-warning \"reentrant functions cannot be critical\" } */\n+{ /* { dg-warning \"ignoring attribute 'critical' because it conflicts with attribute 'reentrant'\" } */\n }\n \n void __attribute__((reentrant,critical))\n fn8(void)\n-{ /* { dg-warning \"reentrant functions cannot be critical\" } */\n+{ /* { dg-warning \"ignoring attribute 'critical' because it conflicts with attribute 'reentrant'\" } */\n }\n \n void __attribute__((__critical__,__naked__))\n fn9(void)\n-{ /* { dg-warning \"critical functions cannot be naked\" } */\n+{ /* { dg-warning \"ignoring attribute 'naked' because it conflicts with attribute 'critical'\" } */\n }\n \n void __attribute__((critical,naked))\n fn10(void)\n-{ /* { dg-warning \"critical functions cannot be naked\" } */\n+{ /* { dg-warning \"ignoring attribute 'naked' because it conflicts with attribute 'critical'\" } */\n }\n \n void __attribute__((__naked__,__critical__))\n fn11(void)\n-{ /* { dg-warning \"naked functions cannot be critical\" } */\n+{ /* { dg-warning \"ignoring attribute 'critical' because it conflicts with attribute 'naked'\" } */\n }\n \n void __attribute__((naked,critical))\n fn12(void)\n-{ /* { dg-warning \"naked functions cannot be critical\" } */\n+{ /* { dg-warning \"ignoring attribute 'critical' because it conflicts with attribute 'naked'\" } */\n }\n \n int __attribute__((interrupt))"}, {"sha": "a108e2741236b3c402097881528329dd5cc073c7", "filename": "gcc/testsuite/gcc.target/msp430/region-attribute-misuse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fregion-attribute-misuse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1deee9179236ea46965e11923c0f8306b6821ef/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fregion-attribute-misuse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmsp430%2Fregion-attribute-misuse.c?ref=f1deee9179236ea46965e11923c0f8306b6821ef", "patch": "@@ -5,9 +5,9 @@\n /* { dg-final { scan-assembler \".section.*lower.data\" } } */\n /* { dg-final { scan-assembler \".section.*either.data\" } } */\n \n-int __attribute__((upper)) upper_bss; /* { dg-warning \"'upper' attribute ignored. large memory model .'-mlarge'. is required\" } */\n-int __attribute__((lower)) lower_bss; /* { dg-warning \"'lower' attribute ignored. large memory model .'-mlarge'. is required\" } */\n-int __attribute__((either)) either_bss; /* { dg-warning \"'either' attribute ignored. large memory model .'-mlarge'. is required\" } */\n+int __attribute__((upper)) upper_bss; /* { dg-warning \"'upper' attribute ignored.  Large memory model .'-mlarge'. is required\" } */\n+int __attribute__((lower)) lower_bss; /* { dg-warning \"'lower' attribute ignored.  Large memory model .'-mlarge'. is required\" } */\n+int __attribute__((either)) either_bss; /* { dg-warning \"'either' attribute ignored.  Large memory model .'-mlarge'. is required\" } */\n \n /* Verify that even without -mlarge, objects can still be placed in\n    upper/lower/either regions manually.  */"}]}