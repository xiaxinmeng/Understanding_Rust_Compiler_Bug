{"sha": "a30596354de502932d005f38551425a86e231f89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwNTk2MzU0ZGU1MDI5MzJkMDA1ZjM4NTUxNDI1YTg2ZTIzMWY4OQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2011-07-31T18:58:06Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2011-07-31T18:58:06Z"}, "message": "re PR tree-optimization/49749 (Reassociation rank algorithm does not include all non-NULL operands)\n\n2011-07-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/49749\n\t* tree-ssa-reassoc.c (get_rank): New forward declaration.\n\t(PHI_LOOP_BIAS): New macro.\n\t(phi_rank): New function.\n\t(loop_carried_phi): Likewise.\n\t(propagate_rank): Likewise.\n\t(get_rank): Add calls to phi_rank and propagate_rank.\n\nFrom-SVN: r176984", "tree": {"sha": "77efe0580db056a3057fa6ba1fa7b5a84c042452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77efe0580db056a3057fa6ba1fa7b5a84c042452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a30596354de502932d005f38551425a86e231f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30596354de502932d005f38551425a86e231f89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a30596354de502932d005f38551425a86e231f89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30596354de502932d005f38551425a86e231f89/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ee7be4c1949fcc99d309bbb40cf117ac1e39641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ee7be4c1949fcc99d309bbb40cf117ac1e39641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ee7be4c1949fcc99d309bbb40cf117ac1e39641"}], "stats": {"total": 168, "additions": 161, "deletions": 7}, "files": [{"sha": "7576188f081b1de6523370e42c02083548206b14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30596354de502932d005f38551425a86e231f89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30596354de502932d005f38551425a86e231f89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a30596354de502932d005f38551425a86e231f89", "patch": "@@ -1,3 +1,13 @@\n+2011-07-31  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/49749\n+\t* tree-ssa-reassoc.c (get_rank): New forward declaration.\n+\t(PHI_LOOP_BIAS): New macro.\n+\t(phi_rank): New function.\n+\t(loop_carried_phi): Likewise.\n+\t(propagate_rank): Likewise.\n+\t(get_rank): Add calls to phi_rank and propagate_rank.\n+\t\n 2011-07-31  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/x86-64.h (SIZE_TYPE): Check TARGET_LP64 instead"}, {"sha": "51f7ef887981921627c1744b1cee8e7af234886b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 151, "deletions": 7, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a30596354de502932d005f38551425a86e231f89/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a30596354de502932d005f38551425a86e231f89/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=a30596354de502932d005f38551425a86e231f89", "patch": "@@ -190,6 +190,114 @@ static long *bb_rank;\n /* Operand->rank hashtable.  */\n static struct pointer_map_t *operand_rank;\n \n+/* Forward decls.  */\n+static long get_rank (tree);\n+\n+\n+/* Bias amount for loop-carried phis.  We want this to be larger than\n+   the depth of any reassociation tree we can see, but not larger than\n+   the rank difference between two blocks.  */\n+#define PHI_LOOP_BIAS (1 << 15)\n+\n+/* Rank assigned to a phi statement.  If STMT is a loop-carried phi of\n+   an innermost loop, and the phi has only a single use which is inside\n+   the loop, then the rank is the block rank of the loop latch plus an\n+   extra bias for the loop-carried dependence.  This causes expressions\n+   calculated into an accumulator variable to be independent for each\n+   iteration of the loop.  If STMT is some other phi, the rank is the\n+   block rank of its containing block.  */\n+static long\n+phi_rank (gimple stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+  struct loop *father = bb->loop_father;\n+  tree res;\n+  unsigned i;\n+  use_operand_p use;\n+  gimple use_stmt;\n+\n+  /* We only care about real loops (those with a latch).  */\n+  if (!father->latch)\n+    return bb_rank[bb->index];\n+\n+  /* Interesting phis must be in headers of innermost loops.  */\n+  if (bb != father->header\n+      || father->inner)\n+    return bb_rank[bb->index];\n+\n+  /* Ignore virtual SSA_NAMEs.  */\n+  res = gimple_phi_result (stmt);\n+  if (!is_gimple_reg (SSA_NAME_VAR (res)))\n+    return bb_rank[bb->index];\n+\n+  /* The phi definition must have a single use, and that use must be\n+     within the loop.  Otherwise this isn't an accumulator pattern.  */\n+  if (!single_imm_use (res, &use, &use_stmt)\n+      || gimple_bb (use_stmt)->loop_father != father)\n+    return bb_rank[bb->index];\n+\n+  /* Look for phi arguments from within the loop.  If found, bias this phi.  */\n+  for (i = 0; i < gimple_phi_num_args (stmt); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (stmt, i);\n+      if (TREE_CODE (arg) == SSA_NAME\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (arg))\n+\t{\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t  if (gimple_bb (def_stmt)->loop_father == father)\n+\t    return bb_rank[father->latch->index] + PHI_LOOP_BIAS;\n+\t}\n+    }\n+\n+  /* Must be an uninteresting phi.  */\n+  return bb_rank[bb->index];\n+}\n+\n+/* If EXP is an SSA_NAME defined by a PHI statement that represents a\n+   loop-carried dependence of an innermost loop, return TRUE; else\n+   return FALSE.  */\n+static bool\n+loop_carried_phi (tree exp)\n+{\n+  gimple phi_stmt;\n+  long block_rank;\n+\n+  if (TREE_CODE (exp) != SSA_NAME\n+      || SSA_NAME_IS_DEFAULT_DEF (exp))\n+    return false;\n+\n+  phi_stmt = SSA_NAME_DEF_STMT (exp);\n+\n+  if (gimple_code (SSA_NAME_DEF_STMT (exp)) != GIMPLE_PHI)\n+    return false;\n+\n+  /* Non-loop-carried phis have block rank.  Loop-carried phis have\n+     an additional bias added in.  If this phi doesn't have block rank,\n+     it's biased and should not be propagated.  */\n+  block_rank = bb_rank[gimple_bb (phi_stmt)->index];\n+\n+  if (phi_rank (phi_stmt) != block_rank)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return the maximum of RANK and the rank that should be propagated\n+   from expression OP.  For most operands, this is just the rank of OP.\n+   For loop-carried phis, the value is zero to avoid undoing the bias\n+   in favor of the phi.  */\n+static long\n+propagate_rank (long rank, tree op)\n+{\n+  long op_rank;\n+\n+  if (loop_carried_phi (op))\n+    return rank;\n+\n+  op_rank = get_rank (op);\n+\n+  return MAX (rank, op_rank);\n+}\n \n /* Look up the operand rank structure for expression E.  */\n \n@@ -232,11 +340,38 @@ get_rank (tree e)\n      I make no claims that this is optimal, however, it gives good\n      results.  */\n \n+  /* We make an exception to the normal ranking system to break\n+     dependences of accumulator variables in loops.  Suppose we\n+     have a simple one-block loop containing:\n+\n+       x_1 = phi(x_0, x_2)\n+       b = a + x_1\n+       c = b + d\n+       x_2 = c + e\n+\n+     As shown, each iteration of the calculation into x is fully\n+     dependent upon the iteration before it.  We would prefer to\n+     see this in the form:\n+\n+       x_1 = phi(x_0, x_2)\n+       b = a + d\n+       c = b + e\n+       x_2 = c + x_1\n+\n+     If the loop is unrolled, the calculations of b and c from\n+     different iterations can be interleaved.\n+\n+     To obtain this result during reassociation, we bias the rank\n+     of the phi definition x_1 upward, when it is recognized as an\n+     accumulator pattern.  The artificial rank causes it to be \n+     added last, providing the desired independence.  */\n+\n   if (TREE_CODE (e) == SSA_NAME)\n     {\n       gimple stmt;\n       long rank;\n       int i, n;\n+      tree op;\n \n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n \t  && SSA_NAME_IS_DEFAULT_DEF (e))\n@@ -246,6 +381,9 @@ get_rank (tree e)\n       if (gimple_bb (stmt) == NULL)\n \treturn 0;\n \n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\treturn phi_rank (stmt);\n+\n       if (!is_gimple_assign (stmt)\n \t  || gimple_vdef (stmt))\n \treturn bb_rank[gimple_bb (stmt)->index];\n@@ -255,29 +393,35 @@ get_rank (tree e)\n       if (rank != -1)\n \treturn rank;\n \n-      /* Otherwise, find the maximum rank for the operands, or the bb\n-\t rank, whichever is less.   */\n+      /* Otherwise, find the maximum rank for the operands.  As an\n+\t exception, remove the bias from loop-carried phis when propagating\n+\t the rank so that dependent operations are not also biased.  */\n       rank = 0;\n       if (gimple_assign_single_p (stmt))\n \t{\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n \t  n = TREE_OPERAND_LENGTH (rhs);\n \t  if (n == 0)\n-\t    rank = MAX (rank, get_rank (rhs));\n+\t    rank = propagate_rank (rank, rhs);\n \t  else\n \t    {\n \t      for (i = 0; i < n; i++)\n-\t\tif (TREE_OPERAND (rhs, i))\n-\t\t  rank = MAX(rank, get_rank (TREE_OPERAND (rhs, i)));\n+\t\t{\n+\t\t  op = TREE_OPERAND (rhs, i);\n+\n+\t\t  if (op != NULL_TREE)\n+\t\t    rank = propagate_rank (rank, op);\n+\t\t}\n \t    }\n \t}\n       else\n \t{\n \t  n = gimple_num_ops (stmt);\n \t  for (i = 1; i < n; i++)\n \t    {\n-\t      gcc_assert (gimple_op (stmt, i));\n-\t      rank = MAX(rank, get_rank (gimple_op (stmt, i)));\n+\t      op = gimple_op (stmt, i);\n+\t      gcc_assert (op);\n+\t      rank = propagate_rank (rank, op);\n \t    }\n \t}\n "}]}