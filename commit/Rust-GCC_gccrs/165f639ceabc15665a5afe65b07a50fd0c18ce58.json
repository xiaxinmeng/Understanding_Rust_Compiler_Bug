{"sha": "165f639ceabc15665a5afe65b07a50fd0c18ce58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1ZjYzOWNlYWJjMTU2NjVhNWFmZTY1YjA3YTUwZmQwYzE4Y2U1OA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-06-04T18:27:36Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-06-04T18:27:36Z"}, "message": "ira-int.h (struct target_ira_int): Add member x_ira_uniform_class_p.\n\n2012-06-04  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* ira-int.h (struct target_ira_int): Add member\n\tx_ira_uniform_class_p.\n\t(ira_uniform_class_p): New macro.\n\n\t* ira.c (setup_uniform_class_p): New function.\n\t(setup_allocno_and_important_classes): Call the function.\n\t(print_unform_and_important_classes): New function.\n\t(print_classes): Rename to print_translated_classes.\n\t(ira_debug_allocno_classes): Add call of\n\tprint_unform_and_important_classes.\n\n\t* ira-costs.c (setup_regno_cost_classes_by_aclass): Use uniform\n\tclasses instead of pressure classes.\n\nFrom-SVN: r188199", "tree": {"sha": "cdd6f5fb0521728a400335ee4aff711a94fce696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdd6f5fb0521728a400335ee4aff711a94fce696"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/165f639ceabc15665a5afe65b07a50fd0c18ce58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165f639ceabc15665a5afe65b07a50fd0c18ce58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165f639ceabc15665a5afe65b07a50fd0c18ce58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165f639ceabc15665a5afe65b07a50fd0c18ce58/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7496cd5bea9e9b4c1fd0dfef46fbea5718e7aa35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7496cd5bea9e9b4c1fd0dfef46fbea5718e7aa35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7496cd5bea9e9b4c1fd0dfef46fbea5718e7aa35"}], "stats": {"total": 111, "additions": 88, "deletions": 23}, "files": [{"sha": "9151e7d4ab44a31bcd0045a6068705088bbd297d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=165f639ceabc15665a5afe65b07a50fd0c18ce58", "patch": "@@ -1,3 +1,19 @@\n+2012-06-04  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-int.h (struct target_ira_int): Add member\n+\tx_ira_uniform_class_p.\n+\t(ira_uniform_class_p): New macro.\n+\n+\t* ira.c (setup_uniform_class_p): New function.\n+\t(setup_allocno_and_important_classes): Call the function.\n+\t(print_unform_and_important_classes): New function.\n+\t(print_classes): Rename to print_translated_classes.\n+\t(ira_debug_allocno_classes): Add call of\n+\tprint_unform_and_important_classes.\n+\n+\t* ira-costs.c (setup_regno_cost_classes_by_aclass): Use uniform\n+\tclasses instead of pressure classes.\n+\n 2012-06-04   Sterling Augustine  <saugustine@google.com>\n \n \t* gcc/c-family/c-pretty-print.h (pp_c_flag_gnu_v3): New enumerator."}, {"sha": "c59b28c8a73d0502d8e67715377c529abb895c3d", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=165f639ceabc15665a5afe65b07a50fd0c18ce58", "patch": "@@ -239,33 +239,19 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n       COPY_HARD_REG_SET (temp, reg_class_contents[aclass]);\n       AND_COMPL_HARD_REG_SET (temp, ira_no_alloc_regs);\n       /* We exclude classes from consideration which are subsets of\n-\t ACLASS only if ACLASS is a pressure class or subset of a\n-\t pressure class.  It means by the definition of pressure classes\n-\t that cost of moving between susbets of ACLASS is cheaper than\n-\t load or store.  */\n-      for (i = 0; i < ira_pressure_classes_num; i++)\n-\t{\n-\t  cl = ira_pressure_classes[i];\n-\t  if (cl == aclass)\n-\t    break;\n-\t  COPY_HARD_REG_SET (temp2, reg_class_contents[cl]);\n-\t  AND_COMPL_HARD_REG_SET (temp2, ira_no_alloc_regs);\n-\t  if (hard_reg_set_subset_p (temp, temp2))\n-\t    break;\n-\t}\n-      exclude_p = i < ira_pressure_classes_num;\n+\t ACLASS only if ACLASS is an uniform class.  */\n+      exclude_p = ira_uniform_class_p[aclass];\n       classes.num = 0;\n       for (i = 0; i < ira_important_classes_num; i++)\n \t{\n \t  cl = ira_important_classes[i];\n \t  if (exclude_p)\n \t    {\n-\t      /* Exclude no-pressure classes which are subsets of\n+\t      /* Exclude non-uniform classes which are subsets of\n \t\t ACLASS.  */\n \t      COPY_HARD_REG_SET (temp2, reg_class_contents[cl]);\n \t      AND_COMPL_HARD_REG_SET (temp2, ira_no_alloc_regs);\n-\t      if (! ira_reg_pressure_class_p[cl]\n-\t\t  && hard_reg_set_subset_p (temp2, temp) && cl != aclass)\n+\t      if (hard_reg_set_subset_p (temp2, temp) && cl != aclass)\n \t\tcontinue;\n \t    }\n \t  classes.classes[classes.num++] = cl;"}, {"sha": "8d44e35df0c5d8bb2fd3ccf2b1525d140597f785", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=165f639ceabc15665a5afe65b07a50fd0c18ce58", "patch": "@@ -828,6 +828,9 @@ struct target_ira_int {\n      classes.  */\n   int x_ira_important_class_nums[N_REG_CLASSES];\n \n+  /* Map class->true if class is an uniform class, false otherwise.  */\n+  bool x_ira_uniform_class_p[N_REG_CLASSES];\n+\n   /* The biggest important class inside of intersection of the two\n      classes (that is calculated taking only hard registers available\n      for allocation into account;.  If the both classes contain no hard\n@@ -905,6 +908,8 @@ extern struct target_ira_int *this_target_ira_int;\n   (this_target_ira_int->x_ira_important_classes)\n #define ira_important_class_nums \\\n   (this_target_ira_int->x_ira_important_class_nums)\n+#define ira_uniform_class_p \\\n+  (this_target_ira_int->x_ira_uniform_class_p)\n #define ira_reg_class_intersect \\\n   (this_target_ira_int->x_ira_reg_class_intersect)\n #define ira_reg_classes_intersect_p \\"}, {"sha": "d477ec958033370f9d8eab428cf4439b58060445", "filename": "gcc/ira.c", "status": "modified", "additions": 63, "deletions": 5, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165f639ceabc15665a5afe65b07a50fd0c18ce58/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=165f639ceabc15665a5afe65b07a50fd0c18ce58", "patch": "@@ -903,6 +903,45 @@ setup_pressure_classes (void)\n   setup_stack_reg_pressure_class ();\n }\n \n+/* Set up IRA_UNIFORM_CLASS_P.  Uniform class is a register class\n+   whose register move cost between any registers of the class is the\n+   same as for all its subclasses.  We use the data to speed up the\n+   2nd pass of calculations of allocno costs.  */\n+static void\n+setup_uniform_class_p (void)\n+{\n+  int i, cl, cl2, m;\n+\n+  for (cl = 0; cl < N_REG_CLASSES; cl++)\n+    {\n+      ira_uniform_class_p[cl] = false;\n+      if (ira_class_hard_regs_num[cl] == 0)\n+\tcontinue;\n+      /* We can not use alloc_reg_class_subclasses here because move\n+\t cost hooks does not take into account that some registers are\n+\t unavailable for the subtarget.  E.g. for i686, INT_SSE_REGS\n+\t is element of alloc_reg_class_subclasses for GENERAL_REGS\n+\t because SSE regs are unavailable.  */\n+      for (i = 0; (cl2 = reg_class_subclasses[cl][i]) != LIM_REG_CLASSES; i++)\n+\t{\n+\t  if (ira_class_hard_regs_num[cl2] == 0)\n+\t    continue;\n+      \t  for (m = 0; m < NUM_MACHINE_MODES; m++)\n+\t    if (contains_reg_of_mode[cl][m] && contains_reg_of_mode[cl2][m])\n+\t      {\n+\t\tira_init_register_move_cost_if_necessary ((enum machine_mode) m);\n+\t\tif (ira_register_move_cost[m][cl][cl]\n+\t\t    != ira_register_move_cost[m][cl2][cl2])\n+\t\t  break;\n+\t      }\n+\t  if (m < NUM_MACHINE_MODES)\n+\t    break;\n+\t}\n+      if (cl2 == LIM_REG_CLASSES)\n+\tira_uniform_class_p[cl] = true;\n+    }\n+}\n+\n /* Set up IRA_ALLOCNO_CLASSES, IRA_ALLOCNO_CLASSES_NUM,\n    IRA_IMPORTANT_CLASSES, and IRA_IMPORTANT_CLASSES_NUM.\n \n@@ -1008,6 +1047,7 @@ setup_allocno_and_important_classes (void)\n   for (j = 0; j < ira_allocno_classes_num; j++)\n     ira_reg_allocno_class_p[ira_allocno_classes[j]] = true;\n   setup_pressure_classes ();\n+  setup_uniform_class_p ();\n }\n \n /* Setup translation in CLASS_TRANSLATE of all classes into a class\n@@ -1292,10 +1332,27 @@ setup_reg_class_relations (void)\n     }\n }\n \n-/* Output all possible allocno classes and the translation map into\n-   file F.  */\n+/* Output all unifrom and important classes into file F.  */\n+static void\n+print_unform_and_important_classes (FILE *f)\n+{\n+  static const char *const reg_class_names[] = REG_CLASS_NAMES;\n+  int i, cl;\n+\n+  fprintf (f, \"Uniform classes:\\n\");\n+  for (cl = 0; cl < N_REG_CLASSES; cl++)\n+    if (ira_uniform_class_p[cl])\n+      fprintf (f, \" %s\", reg_class_names[cl]);\n+  fprintf (f, \"\\nImportant classes:\\n\");\n+  for (i = 0; i < ira_important_classes_num; i++)\n+    fprintf (f, \" %s\", reg_class_names[ira_important_classes[i]]);\n+  fprintf (f, \"\\n\");\n+}\n+\n+/* Output all possible allocno or pressure classes and their\n+   translation map into file F.  */\n static void\n-print_classes (FILE *f, bool pressure_p)\n+print_translated_classes (FILE *f, bool pressure_p)\n {\n   int classes_num = (pressure_p\n \t\t     ? ira_pressure_classes_num : ira_allocno_classes_num);\n@@ -1321,8 +1378,9 @@ print_classes (FILE *f, bool pressure_p)\n void\n ira_debug_allocno_classes (void)\n {\n-  print_classes (stderr, false);\n-  print_classes (stderr, true);\n+  print_unform_and_important_classes (stderr);\n+  print_translated_classes (stderr, false);\n+  print_translated_classes (stderr, true);\n }\n \n /* Set up different arrays concerning class subsets, allocno and"}]}