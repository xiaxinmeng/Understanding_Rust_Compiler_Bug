{"sha": "bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlYTk4Y2EyZTJjMjlkMWFkNGMxMjRjNGE3YzBkMjNjMzMzMDkyMA==", "commit": {"author": {"name": "Max Ostapenko", "email": "m.ostapenko@partner.samsung.com", "date": "2014-10-28T12:36:54Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2014-10-28T12:36:54Z"}, "message": "Don't inline GCC memory builtins if ASan is enabled.\n\ngcc/\n\n2014-10-28  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n\n        * asan.h (asan_intercepted_p): New function.\n        * asan.c (asan_mem_ref_hasher::hash): Remove MEM_REF access size from\n        hash value construction.  Call iterative_hash_expr instead of explicit\n        hash building.\n        (asan_mem_ref_hasher::equal): Change condition.\n        (has_mem_ref_been_instrumented): Likewise.\n        (update_mem_ref_hash_table): Likewise.\n        (maybe_update_mem_ref_hash_table): New function.\n        (instrument_strlen_call): Removed.\n        (get_mem_refs_of_builtin_call): Handle new parameter.\n        (instrument_builtin_call): Call maybe_update_mem_ref_hash_table instead\n        of instrument_mem_region_access if intercepted_p is true.\n        (instrument_mem_region_access): Instrument only base with len instead of\n        base and end with 1.\n        (build_check_stmt): Remove start_instrumented and end_instrumented\n        parameters.\n        (enum asan_check_flags): Remove ASAN_CHECK_START_INSTRUMENTED and\n        ASAN_CHECK_END_INSTRUMENTED.  Change ASAN_CHECK_LAST.\n        (asan_expand_check_ifn): Remove start_instrumented and end_instrumented.\n        * builtins.c (expand_builtin): Include asan.h.  Don't expand string/memory\n        builtin functions that have interceptors if ASan is enabled.\n\ngcc/testsuite/\n\n        * c-c++-common/asan/no-redundant-instrumentation-1.c: Updated test.\n        * c-c++-common/asan/no-redundant-instrumentation-4.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-2.c: Removed.\n        * c-c++-common/asan/no-redundant-instrumentation-9.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-10.c: New test.\n        * c-c++-common/asan/no-redundant-instrumentation-11.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-12.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-13.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-14.c: Likewise.\n        * c-c++-common/asan/no-redundant-instrumentation-15.c: Likewise.\n        * c-c++-common/asan/pr63638.c: Likewise.\n\nFrom-SVN: r216783", "tree": {"sha": "1d5b6a83a9cca56b4d76442dee10ed6abac9cb82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5b6a83a9cca56b4d76442dee10ed6abac9cb82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/comments", "author": null, "committer": null, "parents": [{"sha": "9ccaac1188959d2b35cfa820c46277ebef5f75e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccaac1188959d2b35cfa820c46277ebef5f75e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccaac1188959d2b35cfa820c46277ebef5f75e0"}], "stats": {"total": 500, "additions": 234, "deletions": 266}, "files": [{"sha": "4104d8da5cd664f9ce127a228228d90c943f4b7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -1,3 +1,27 @@\n+2014-10-28  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* asan.h (asan_intercepted_p): New function.\n+\t* asan.c (asan_mem_ref_hasher::hash): Remove MEM_REF access size from\n+\thash value construction.  Call iterative_hash_expr instead of explicit\n+\thash building.\n+\t(asan_mem_ref_hasher::equal): Change condition.\n+\t(has_mem_ref_been_instrumented): Likewise.\n+\t(update_mem_ref_hash_table): Likewise.\n+\t(maybe_update_mem_ref_hash_table): New function.\n+\t(instrument_strlen_call): Removed.\n+\t(get_mem_refs_of_builtin_call): Handle new parameter.\n+\t(instrument_builtin_call): Call maybe_update_mem_ref_hash_table instead\n+\tof instrument_mem_region_access if intercepted_p is true.\n+\t(instrument_mem_region_access): Instrument only base with len instead of\n+\tbase and end with 1.\n+\t(build_check_stmt): Remove start_instrumented and end_instrumented\n+\tparameters.\n+\t(enum asan_check_flags): Remove ASAN_CHECK_START_INSTRUMENTED and\n+\tASAN_CHECK_END_INSTRUMENTED.  Change ASAN_CHECK_LAST.\n+\t(asan_expand_check_ifn): Remove start_instrumented and end_instrumented.\n+\t* builtins.c (expand_builtin): Include asan.h.  Don't expand string/memory\n+\tbuiltin functions that have interceptors if ASan is enabled.\n+\n 2014-10-28  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/63665"}, {"sha": "ad366903847d0b82efed1b570e22ef772aeb17d8", "filename": "gcc/asan.c", "status": "modified", "additions": 118, "deletions": 204, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -301,9 +301,7 @@ enum asan_check_flags\n   ASAN_CHECK_STORE = 1 << 0,\n   ASAN_CHECK_SCALAR_ACCESS = 1 << 1,\n   ASAN_CHECK_NON_ZERO_LEN = 1 << 2,\n-  ASAN_CHECK_START_INSTRUMENTED = 1 << 3,\n-  ASAN_CHECK_END_INSTRUMENTED = 1 << 4,\n-  ASAN_CHECK_LAST\n+  ASAN_CHECK_LAST = 1 << 3\n };\n \n /* Hashtable support for memory references used by gimple\n@@ -400,10 +398,7 @@ struct asan_mem_ref_hasher\n inline hashval_t\n asan_mem_ref_hasher::hash (const asan_mem_ref *mem_ref)\n {\n-  inchash::hash hstate;\n-  inchash::add_expr (mem_ref->start, hstate);\n-  hstate.add_wide_int (mem_ref->access_size);\n-  return hstate.end ();\n+  return iterative_hash_expr (mem_ref->start, 0);\n }\n \n /* Compare two memory references.  We accept the length of either\n@@ -413,8 +408,7 @@ inline bool\n asan_mem_ref_hasher::equal (const asan_mem_ref *m1,\n \t\t\t    const asan_mem_ref *m2)\n {\n-  return (m1->access_size == m2->access_size\n-\t  && operand_equal_p (m1->start, m2->start, 0));\n+  return operand_equal_p (m1->start, m2->start, 0);\n }\n \n static hash_table<asan_mem_ref_hasher> *asan_mem_ref_ht;\n@@ -465,7 +459,8 @@ has_mem_ref_been_instrumented (tree ref, HOST_WIDE_INT access_size)\n   asan_mem_ref r;\n   asan_mem_ref_init (&r, ref, access_size);\n \n-  return (get_mem_ref_hash_table ()->find (&r) != NULL);\n+  asan_mem_ref *saved_ref = get_mem_ref_hash_table ()->find (&r);\n+  return saved_ref && saved_ref->access_size >= access_size;\n }\n \n /* Return true iff the memory reference REF has been instrumented.  */\n@@ -482,19 +477,11 @@ has_mem_ref_been_instrumented (const asan_mem_ref *ref)\n static bool\n has_mem_ref_been_instrumented (const asan_mem_ref *ref, tree len)\n {\n-  /* First let's see if the address of the beginning of REF has been\n-     instrumented.  */\n-  if (!has_mem_ref_been_instrumented (ref))\n-    return false;\n+  HOST_WIDE_INT size_in_bytes\n+    = tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n \n-  if (len != 0)\n-    {\n-      /* Let's see if the end of the region has been instrumented.  */\n-      if (!has_mem_ref_been_instrumented (asan_mem_ref_get_end (ref, len),\n-\t\t\t\t\t  ref->access_size))\n-\treturn false;\n-    }\n-  return true;\n+  return size_in_bytes != -1\n+    && has_mem_ref_been_instrumented (ref->start, size_in_bytes);\n }\n \n /* Set REF to the memory reference present in a gimple assignment\n@@ -540,7 +527,8 @@ get_mem_refs_of_builtin_call (const gimple call,\n \t\t\t      asan_mem_ref *dst,\n \t\t\t      tree *dst_len,\n \t\t\t      bool *dst_is_store,\n-\t\t\t      bool *dest_is_deref)\n+\t\t\t      bool *dest_is_deref,\n+\t\t\t      bool *intercepted_p)\n {\n   gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n \n@@ -550,6 +538,8 @@ get_mem_refs_of_builtin_call (const gimple call,\n   bool is_store = true, got_reference_p = false;\n   HOST_WIDE_INT access_size = 1;\n \n+  *intercepted_p = asan_intercepted_p ((DECL_FUNCTION_CODE (callee)));\n+\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n       /* (s, s, n) style memops.  */\n@@ -882,12 +872,12 @@ has_stmt_been_instrumented_p (gimple stmt)\n \n       tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n       bool src0_is_store = false, src1_is_store = false,\n-\tdest_is_store = false, dest_is_deref = false;\n+\tdest_is_store = false, dest_is_deref = false, intercepted_p = true;\n       if (get_mem_refs_of_builtin_call (stmt,\n \t\t\t\t\t&src0, &src0_len, &src0_is_store,\n \t\t\t\t\t&src1, &src1_len, &src1_is_store,\n \t\t\t\t\t&dest, &dest_len, &dest_is_store,\n-\t\t\t\t\t&dest_is_deref))\n+\t\t\t\t\t&dest_is_deref, &intercepted_p))\n \t{\n \t  if (src0.start != NULL_TREE\n \t      && !has_mem_ref_been_instrumented (&src0, src0_len))\n@@ -918,7 +908,7 @@ update_mem_ref_hash_table (tree ref, HOST_WIDE_INT access_size)\n   asan_mem_ref_init (&r, ref, access_size);\n \n   asan_mem_ref **slot = ht->find_slot (&r, INSERT);\n-  if (*slot == NULL)\n+  if (*slot == NULL || (*slot)->access_size < access_size)\n     *slot = asan_mem_ref_new (ref, access_size);\n }\n \n@@ -1684,22 +1674,13 @@ static void\n build_check_stmt (location_t loc, tree base, tree len,\n \t\t  HOST_WIDE_INT size_in_bytes, gimple_stmt_iterator *iter,\n \t\t  bool is_non_zero_len, bool before_p, bool is_store,\n-\t\t  bool is_scalar_access, unsigned int align = 0,\n-\t\t  bool start_instrumented = false,\n-\t\t  bool end_instrumented = false)\n+\t\t  bool is_scalar_access, unsigned int align = 0)\n {\n   gimple_stmt_iterator gsi = *iter;\n   gimple g;\n \n   gcc_assert (!(size_in_bytes > 0 && !is_non_zero_len));\n \n-  if (start_instrumented && end_instrumented)\n-    {\n-      if (!before_p)\n-\tgsi_next (iter);\n-      return;\n-    }\n-\n   gsi = *iter;\n \n   base = unshare_expr (base);\n@@ -1742,10 +1723,6 @@ build_check_stmt (location_t loc, tree base, tree len,\n     flags |= ASAN_CHECK_NON_ZERO_LEN;\n   if (is_scalar_access)\n     flags |= ASAN_CHECK_SCALAR_ACCESS;\n-  if (start_instrumented)\n-    flags |= ASAN_CHECK_START_INSTRUMENTED;\n-  if (end_instrumented)\n-    flags |= ASAN_CHECK_END_INSTRUMENTED;\n \n   g = gimple_build_call_internal (IFN_ASAN_CHECK, 4,\n \t\t\t\t  build_int_cst (integer_type_node, flags),\n@@ -1860,6 +1837,22 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \n }\n \n+/*  Insert a memory reference into the hash table if access length\n+    can be determined in compile time.  */\n+\n+static void\n+maybe_update_mem_ref_hash_table (tree base, tree len)\n+{\n+  if (!POINTER_TYPE_P (TREE_TYPE (base))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (len)))\n+    return;\n+\n+  HOST_WIDE_INT size_in_bytes = tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n+\n+  if (size_in_bytes != -1)\n+    update_mem_ref_hash_table (base, size_in_bytes);\n+}\n+\n /* Instrument an access to a contiguous memory region that starts at\n    the address pointed to by BASE, over a length of LEN (expressed in\n    the sizeof (*BASE) bytes).  ITER points to the instruction before\n@@ -1878,97 +1871,20 @@ instrument_mem_region_access (tree base, tree len,\n       || integer_zerop (len))\n     return;\n \n-  /* If the beginning of the memory region has already been\n-     instrumented, do not instrument it.  */\n-  bool start_instrumented = has_mem_ref_been_instrumented (base, 1);\n-\n-  /* If the end of the memory region has already been instrumented, do\n-     not instrument it.  */\n-  tree end = asan_mem_ref_get_end (base, len);\n-  bool end_instrumented = has_mem_ref_been_instrumented (end, 1);\n-\n   HOST_WIDE_INT size_in_bytes = tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n \n-  build_check_stmt (location, base, len, size_in_bytes, iter,\n-\t\t    /*is_non_zero_len*/size_in_bytes > 0, /*before_p*/true,\n-\t\t    is_store, /*is_scalar_access*/false, /*align*/0,\n-\t\t    start_instrumented, end_instrumented);\n-\n-  update_mem_ref_hash_table (base, 1);\n-  if (size_in_bytes != -1)\n-    update_mem_ref_hash_table (end, 1);\n+  if ((size_in_bytes == -1)\n+      || !has_mem_ref_been_instrumented (base, size_in_bytes))\n+    {\n+      build_check_stmt (location, base, len, size_in_bytes, iter,\n+\t\t\t/*is_non_zero_len*/size_in_bytes > 0, /*before_p*/true,\n+\t\t\tis_store, /*is_scalar_access*/false, /*align*/0);\n+    }\n \n+  maybe_update_mem_ref_hash_table (base, len);\n   *iter = gsi_for_stmt (gsi_stmt (*iter));\n }\n \n-/* Instrument the call (to the builtin strlen function) pointed to by\n-   ITER.\n-\n-   This function instruments the access to the first byte of the\n-   argument, right before the call.  After the call it instruments the\n-   access to the last byte of the argument; it uses the result of the\n-   call to deduce the offset of that last byte.\n-\n-   Upon completion, iff the call has actually been instrumented, this\n-   function returns TRUE and *ITER points to the statement logically\n-   following the built-in strlen function call *ITER was initially\n-   pointing to.  Otherwise, the function returns FALSE and *ITER\n-   remains unchanged.  */\n-\n-static bool\n-instrument_strlen_call (gimple_stmt_iterator *iter)\n-{\n-  gimple g;\n-  gimple call = gsi_stmt (*iter);\n-  gcc_assert (is_gimple_call (call));\n-\n-  tree callee = gimple_call_fndecl (call);\n-  gcc_assert (is_builtin_fn (callee)\n-\t      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n-\t      && DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN);\n-\n-  location_t loc = gimple_location (call);\n-\n-  tree len = gimple_call_lhs (call);\n-  if (len == NULL)\n-    /* Some passes might clear the return value of the strlen call;\n-       bail out in that case.  Return FALSE as we are not advancing\n-       *ITER.  */\n-    return false;\n-  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (len)));\n-\n-  len = maybe_cast_to_ptrmode (loc, len, iter, /*before_p*/false);\n-\n-  tree str_arg = gimple_call_arg (call, 0);\n-  bool start_instrumented = has_mem_ref_been_instrumented (str_arg, 1);\n-\n-  tree cptr_type = build_pointer_type (char_type_node);\n-  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (cptr_type, NULL),\n-\t\t\t\t    str_arg, NULL);\n-  gimple_set_location (g, loc);\n-  gsi_insert_before (iter, g, GSI_SAME_STMT);\n-  str_arg = gimple_assign_lhs (g);\n-\n-  build_check_stmt (loc, str_arg, NULL_TREE, 1, iter,\n-\t\t    /*is_non_zero_len*/true, /*before_p=*/true,\n-\t\t    /*is_store=*/false, /*is_scalar_access*/true, /*align*/0,\n-\t\t    start_instrumented, start_instrumented);\n-\n-  g = gimple_build_assign_with_ops (POINTER_PLUS_EXPR,\n-\t\t\t\t    make_ssa_name (cptr_type, NULL),\n-\t\t\t\t    str_arg,\n-\t\t\t\t    len);\n-  gimple_set_location (g, loc);\n-  gsi_insert_after (iter, g, GSI_NEW_STMT);\n-\n-  build_check_stmt (loc, gimple_assign_lhs (g), NULL_TREE, 1, iter,\n-\t\t    /*is_non_zero_len*/true, /*before_p=*/false,\n-\t\t    /*is_store=*/false, /*is_scalar_access*/true, /*align*/0);\n-\n-  return true;\n-}\n-\n /* Instrument the call to a built-in memory access function that is\n    pointed to by the iterator ITER.\n \n@@ -1986,49 +1902,54 @@ instrument_builtin_call (gimple_stmt_iterator *iter)\n \n   gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n \n-  tree callee = gimple_call_fndecl (call);\n   location_t loc = gimple_location (call);\n \n-  if (DECL_FUNCTION_CODE (callee) == BUILT_IN_STRLEN)\n-    iter_advanced_p = instrument_strlen_call (iter);\n-  else\n-    {\n-      asan_mem_ref src0, src1, dest;\n-      asan_mem_ref_init (&src0, NULL, 1);\n-      asan_mem_ref_init (&src1, NULL, 1);\n-      asan_mem_ref_init (&dest, NULL, 1);\n+  asan_mem_ref src0, src1, dest;\n+  asan_mem_ref_init (&src0, NULL, 1);\n+  asan_mem_ref_init (&src1, NULL, 1);\n+  asan_mem_ref_init (&dest, NULL, 1);\n \n-      tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n-      bool src0_is_store = false, src1_is_store = false,\n-\tdest_is_store = false, dest_is_deref = false;\n+  tree src0_len = NULL_TREE, src1_len = NULL_TREE, dest_len = NULL_TREE;\n+  bool src0_is_store = false, src1_is_store = false, dest_is_store = false,\n+    dest_is_deref = false, intercepted_p = true;\n \n-      if (get_mem_refs_of_builtin_call (call,\n-\t\t\t\t\t&src0, &src0_len, &src0_is_store,\n-\t\t\t\t\t&src1, &src1_len, &src1_is_store,\n-\t\t\t\t\t&dest, &dest_len, &dest_is_store,\n-\t\t\t\t\t&dest_is_deref))\n+  if (get_mem_refs_of_builtin_call (call,\n+\t\t\t\t    &src0, &src0_len, &src0_is_store,\n+\t\t\t\t    &src1, &src1_len, &src1_is_store,\n+\t\t\t\t    &dest, &dest_len, &dest_is_store,\n+\t\t\t\t    &dest_is_deref, &intercepted_p))\n+    {\n+      if (dest_is_deref)\n \t{\n-\t  if (dest_is_deref)\n-\t    {\n-\t      instrument_derefs (iter, dest.start, loc, dest_is_store);\n-\t      gsi_next (iter);\n-\t      iter_advanced_p = true;\n-\t    }\n-\t  else if (src0_len || src1_len || dest_len)\n-\t    {\n-\t      if (src0.start != NULL_TREE)\n-\t\tinstrument_mem_region_access (src0.start, src0_len,\n-\t\t\t\t\t      iter, loc, /*is_store=*/false);\n-\t      if (src1.start != NULL_TREE)\n-\t\tinstrument_mem_region_access (src1.start, src1_len,\n-\t\t\t\t\t      iter, loc, /*is_store=*/false);\n-\t      if (dest.start != NULL_TREE)\n-\t\tinstrument_mem_region_access (dest.start, dest_len,\n-\t\t\t\t\t      iter, loc, /*is_store=*/true);\n-\t      *iter = gsi_for_stmt (call);\n-\t      gsi_next (iter);\n-\t      iter_advanced_p = true;\n-\t    }\n+\t  instrument_derefs (iter, dest.start, loc, dest_is_store);\n+\t  gsi_next (iter);\n+\t  iter_advanced_p = true;\n+\t}\n+      else if (!intercepted_p\n+\t       && (src0_len || src1_len || dest_len))\n+\t{\n+\t  if (src0.start != NULL_TREE)\n+\t    instrument_mem_region_access (src0.start, src0_len,\n+\t\t\t\t\t  iter, loc, /*is_store=*/false);\n+\t  if (src1.start != NULL_TREE)\n+\t    instrument_mem_region_access (src1.start, src1_len,\n+\t\t\t\t\t  iter, loc, /*is_store=*/false);\n+\t  if (dest.start != NULL_TREE)\n+\t    instrument_mem_region_access (dest.start, dest_len,\n+\t\t\t\t\t  iter, loc, /*is_store=*/true);\n+\n+\t  *iter = gsi_for_stmt (call);\n+\t  gsi_next (iter);\n+\t  iter_advanced_p = true;\n+\t}\n+      else\n+\t{\n+\t  if (src0.start != NULL_TREE)\n+\t    maybe_update_mem_ref_hash_table (src0.start, src0_len);\n+\t  if (src1.start != NULL_TREE)\n+\t    maybe_update_mem_ref_hash_table (src1.start, src1_len);\n+\t  if (dest.start != NULL_TREE)\n+\t    maybe_update_mem_ref_hash_table (dest.start, dest_len);\n \t}\n     }\n   return iter_advanced_p;\n@@ -2586,8 +2507,6 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n   bool is_scalar_access = (flags & ASAN_CHECK_SCALAR_ACCESS) != 0;\n   bool is_store = (flags & ASAN_CHECK_STORE) != 0;\n   bool is_non_zero_len = (flags & ASAN_CHECK_NON_ZERO_LEN) != 0;\n-  bool start_instrumented = (flags & ASAN_CHECK_START_INSTRUMENTED) != 0;\n-  bool end_instrumented = (flags & ASAN_CHECK_END_INSTRUMENTED) != 0;\n \n   tree base = gimple_call_arg (g, 1);\n   tree len = gimple_call_arg (g, 2);\n@@ -2692,46 +2611,42 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n   else\n     {\n       /* Slow path for 1, 2 and 4 byte accesses.  */\n-\n-      if (!start_instrumented)\n+      /* Test (shadow != 0)\n+\t & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n+      tree shadow = build_shadow_mem_access (&gsi, loc, base_addr,\n+\t\t\t\t\t     shadow_ptr_type);\n+      gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+      gimple_seq seq = NULL;\n+      gimple_seq_add_stmt (&seq, shadow_test);\n+      /* Aligned (>= 8 bytes) can test just\n+\t (real_size_in_bytes - 1 >= shadow), as base_addr & 7 is known\n+\t to be 0.  */\n+      if (align < 8)\n \t{\n-\t  /* Test (shadow != 0)\n-\t     & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n-\t  tree shadow = build_shadow_mem_access (&gsi, loc, base_addr,\n-\t\t\t\t\t\t shadow_ptr_type);\n-\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n-\t  gimple_seq seq = NULL;\n-\t  gimple_seq_add_stmt (&seq, shadow_test);\n-\t  /* Aligned (>= 8 bytes) can test just\n-\t     (real_size_in_bytes - 1 >= shadow), as base_addr & 7 is known\n-\t     to be 0.  */\n-\t  if (align < 8)\n-\t    {\n-\t      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n-\t\t\t\t\t\t       base_addr, 7));\n-\t      gimple_seq_add_stmt (&seq,\n-\t\t\t\t   build_type_cast (shadow_type,\n-\t\t\t\t\t\t    gimple_seq_last (seq)));\n-\t      if (real_size_in_bytes > 1)\n-\t\tgimple_seq_add_stmt (&seq,\n-\t\t\t\t     build_assign (PLUS_EXPR,\n-\t\t\t\t\t\t   gimple_seq_last (seq),\n-\t\t\t\t\t\t   real_size_in_bytes - 1));\n-\t      t = gimple_assign_lhs (gimple_seq_last_stmt (seq));\n-\t    }\n-\t  else\n-\t    t = build_int_cst (shadow_type, real_size_in_bytes - 1);\n-\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR, t, shadow));\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n-\t\t\t\t\t\t   gimple_seq_last (seq)));\n-\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n-\t  gimple_seq_set_location (seq, loc);\n-\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n+\t\t\t\t\t\t   base_addr, 7));\n+\t  gimple_seq_add_stmt (&seq,\n+\t\t\t       build_type_cast (shadow_type,\n+\t\t\t\t\t\tgimple_seq_last (seq)));\n+\t  if (real_size_in_bytes > 1)\n+\t    gimple_seq_add_stmt (&seq,\n+\t\t\t\t build_assign (PLUS_EXPR,\n+\t\t\t\t\t       gimple_seq_last (seq),\n+\t\t\t\t\t       real_size_in_bytes - 1));\n+\t  t = gimple_assign_lhs (gimple_seq_last_stmt (seq));\n \t}\n+      else\n+\tt = build_int_cst (shadow_type, real_size_in_bytes - 1);\n+      gimple_seq_add_stmt (&seq, build_assign (GE_EXPR, t, shadow));\n+      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+\t\t\t\t\t       gimple_seq_last (seq)));\n+      t = gimple_assign_lhs (gimple_seq_last (seq));\n+      gimple_seq_set_location (seq, loc);\n+      gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n \n       /* For non-constant, misaligned or otherwise weird access sizes,\n-\t check first and last byte.  */\n-      if (size_in_bytes == -1 && !end_instrumented)\n+       check first and last byte.  */\n+      if (size_in_bytes == -1)\n \t{\n \t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n \t\t\t\t\t    make_ssa_name (pointer_sized_int_node, NULL),\n@@ -2762,9 +2677,8 @@ asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n \t\t\t\t\t\t   shadow));\n \t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n \t\t\t\t\t\t   gimple_seq_last (seq)));\n-\t  if (!start_instrumented)\n-\t    gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n-\t\t\t\t\t\t     gimple_seq_last (seq)));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n \t  t = gimple_assign_lhs (gimple_seq_last (seq));\n \t  gimple_seq_set_location (seq, loc);\n \t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);"}, {"sha": "8e3f0bae44cc092bcfd5dec938e783ad902ec7bf", "filename": "gcc/asan.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -78,4 +78,28 @@ asan_red_zone_size (unsigned int size)\n \n extern bool set_asan_shadow_offset (const char *);\n \n+/* Return TRUE if builtin with given FCODE will be intercepted by\n+   libasan.  */\n+\n+static inline bool\n+asan_intercepted_p (enum built_in_function fcode)\n+{\n+  return fcode == BUILT_IN_INDEX\n+\t || fcode == BUILT_IN_MEMCHR\n+\t || fcode == BUILT_IN_MEMCMP\n+\t || fcode == BUILT_IN_MEMCPY\n+\t || fcode == BUILT_IN_MEMMOVE\n+\t || fcode == BUILT_IN_MEMSET\n+\t || fcode == BUILT_IN_STRCASECMP\n+\t || fcode == BUILT_IN_STRCAT\n+\t || fcode == BUILT_IN_STRCHR\n+\t || fcode == BUILT_IN_STRCMP\n+\t || fcode == BUILT_IN_STRCPY\n+\t || fcode == BUILT_IN_STRDUP\n+\t || fcode == BUILT_IN_STRLEN\n+\t || fcode == BUILT_IN_STRNCASECMP\n+\t || fcode == BUILT_IN_STRNCAT\n+\t || fcode == BUILT_IN_STRNCMP\n+\t || fcode == BUILT_IN_STRNCPY;\n+}\n #endif /* TREE_ASAN */"}, {"sha": "c2eb373ed662ca5a1cde0802bead1a4ac7512897", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"diagnostic-core.h\"\n #include \"builtins.h\"\n+#include \"asan.h\"\n #include \"ubsan.h\"\n #include \"cilk.h\"\n \n@@ -5765,6 +5766,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n   enum machine_mode target_mode = TYPE_MODE (TREE_TYPE (exp));\n   int flags;\n \n+  /* When ASan is enabled, we don't want to expand some memory/string\n+     builtins and rely on libsanitizer's hooks.  This allows us to avoid\n+     redundant checks and be sure, that possible overflow will be detected\n+     by ASan.  */\n+\n+  if ((flag_sanitize & SANITIZE_ADDRESS) && asan_intercepted_p (fcode))\n+    return expand_call (exp, target, ignore);\n+\n   if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n     return targetm.expand_builtin (exp, target, subtarget, mode, ignore);\n "}, {"sha": "920df04201583ac50c4771fc8b83082486baee15", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -1,3 +1,21 @@\n+2014-10-28  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Updated test.\n+\t* c-c++-common/asan/no-redundant-instrumentation-4.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-2.c: Removed.\n+\t* c-c++-common/asan/no-redundant-instrumentation-9.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-10.c: New test.\n+\t* c-c++-common/asan/no-redundant-instrumentation-11.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-12.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-13.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-14.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-15.c: Likewise.\n+\t* c-c++-common/asan/pr63638.c: Likewise.\n+\n 2014-10-28  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/63665"}, {"sha": "baacb1e536ea88e29bfce92659ca41a167c62eca", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -6,7 +6,7 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n-extern char tab[4];\n+extern char tab[6];\n \n static int\n test0 ()\n@@ -35,17 +35,10 @@ test1 (int i)\n     the initialization.  */\n   foo[i] = 1;\n \n-  /*__builtin___asan_report_store_n called once here to instrument\n-    the store to the memory region of tab.  */\n+  /* Instrument tab memory region.  */\n   __builtin_memset (tab, 3, sizeof (tab));\n \n-  /* There is no instrumentation for the two memset calls below.  */\n-  __builtin_memset (tab, 4, sizeof (tab));\n-  __builtin_memset (tab, 5, sizeof (tab));\n-\n-  /* There is a call to __builtin___asan_report_store_n and a call\n-     to __builtin___asan_report_load_n to instrument the store to\n-     (subset of) the memory region of tab.  */\n+  /* Instrument tab[1] with access size 3.  */\n   __builtin_memcpy (&tab[1], foo + i, 3);\n \n   /* This should not generate a __builtin___asan_report_load1 because\n@@ -63,6 +56,5 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 1 \"sanopt\" }  } */\n+/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_load1\" \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "a613b92cbcee81c5436a70c3d43b6a081a3b6405", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -5,13 +5,13 @@\n void\n foo  (int *a, char *b, char *c)\n {\n-  /* One check for c[0], one check for a[], one check for c, two checks for b.  */\n+  /* One check for c[0], one check for a[].  */\n   __builtin_memmove (c, b, a[c[0]]);\n-  /* For a total of 5 checks.  */\n+  /* For a total of 2 checks.  */\n+  int d = c[0] == 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 2 \"sanopt\" } } */\n /* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "f4ca603f0c0eaa4276bc7443f2b7ebcf4ef0974b", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -5,14 +5,12 @@\n void\n foo  (int *a, char *b, char *c)\n {\n-  /* One check for b[0], one check for a[], 2 checks for c and one checks for b.  */\n-  __builtin_memmove (c, b, a[b[0]]);\n-  /* For a total of 5 checks.  */\n+  /* One check for a[].  */\n+  __builtin_memmove (c, b, a[0]);\n+  /* For a total of 1 checks.  */\n+  int d = a[0] == 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 1 \"sanopt\" } } */\n /* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "757f0eeb6228778cc3998fe5f86ec8b1a53d1221", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -5,16 +5,15 @@\n void\n foo  (int *a, char *b, char *c)\n {\n-  /* One check for c[0], one check for a[], one check for c and 2 checks for b.  */\n+  /* One check for c[0], one check for a[].  */\n   __builtin_memmove (c, b, a[c[0]]);\n-  /* One check for a[], one check for c and one check for b.  */\n+  /* One check for b[0], one check for a[].  */\n   __builtin_memmove (c, b, a[b[0]]);\n-  /* For a total of 8 checks.  */\n+  /* For a total of 4 checks.  */\n+  int d = c[0] == b[0];\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 8 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 4 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 2 \"sanopt\" } } */\n /* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 2 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 2 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "0c501451281737d1e822e1418f922dbf43845f05", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -2,26 +2,22 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n-char e[200];\n+char e[5];\n \n-struct S\n+extern struct S\n {\n-  char a[100];\n-  char b[100];\n+  int a;\n+  char b;\n } s;\n \n int\n foo  (int *a, char *b, char *c)\n {\n-  /* 2 checks for s.a, 2 checks for e.  */\n-  int d = __builtin_memcmp (s.a, e, 100);\n-  /* One check for s.a and one check for e.  */\n-  d += __builtin_memcmp (s.a, e, 200);\n-  /* For a total of 6 checks.  */\n-  return d;\n+  int d = __builtin_memcmp (&s.a, e, 4);\n+  /* No check because s.a was instrumented above with access size 4.  */\n+  return s.a;\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 6 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 4 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_store\" \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-not \"& 7\" \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_load4\" \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "4eeedcedc988ce2f4901c1a9ad83858a3d702d63", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -5,16 +5,16 @@\n char\n foo  (int *a, char *b, char *c)\n {\n-  /* One check for b[0], one check for a[], two checks for c and one check for b.  */\n+  /* One check for b[0], one check for a[].  */\n   __builtin_memmove (c, b, a[b[0]]);\n+  /* One check for c[0], one check for a[].  */\n+  __builtin_memmove (b, c, a[c[0]]);\n   /* No checks here.  */\n   return c[0] + b[0];\n-  /* For a total of 5 checks.  */\n+  /* For a total of 4 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 4 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 2 \"sanopt\" } } */\n /* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "0f49286306aaf07005356ed0fdf82c03e4035726", "filename": "gcc/testsuite/c-c++-common/asan/strlen-overflow-1.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrlen-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrlen-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrlen-overflow-1.c?ref=bdea98ca2e2c29d1ad4c124c4a7c0d23c3330920", "patch": "@@ -9,14 +9,8 @@ char a[2] = \"0\";\n #ifdef __cplusplus\n extern \"C\"\n #endif\n-\n-__attribute__((no_sanitize_address, noinline)) __SIZE_TYPE__\n-strlen (const char *p) {\n-\n-  __SIZE_TYPE__ n = 0;\n-  for (; *p; ++n, ++p);\n-  return n;\n-}\n+__SIZE_TYPE__\n+strlen (const char *p);\n \n int main () {\n   char *p = &a[0];\n@@ -25,6 +19,6 @@ int main () {\n   return __builtin_strlen (a);\n }\n \n-/* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+ thread T0.*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ (in _*main (\\[^\\n\\r]*strlen-overflow-1.c:25|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 1 bytes inside of global variable\" } */\n+/* { dg-output \"READ of size 2 at 0x\\[0-9a-f\\]+ thread T0.*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ (in _*main (\\[^\\n\\r]*strlen-overflow-1.c:19|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 0 bytes to the right of global variable\" } */"}]}