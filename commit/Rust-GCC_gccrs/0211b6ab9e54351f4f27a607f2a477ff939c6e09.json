{"sha": "0211b6ab9e54351f4f27a607f2a477ff939c6e09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxMWI2YWI5ZTU0MzUxZjRmMjdhNjA3ZjJhNDc3ZmY5MzljNmUwOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-05-17T13:47:28Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-05-17T13:47:28Z"}, "message": "Revert April 21 alias.c change from jfc.\n\n\t* alias.c (mode_alias_check): Delete.\n\t(true_dependence, anti_dependence, output_dependence): Revert April 21\n\tchange.\n\nFrom-SVN: r19818", "tree": {"sha": "625cd01d4d945c6a94da625aee4fd22c514eea06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/625cd01d4d945c6a94da625aee4fd22c514eea06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0211b6ab9e54351f4f27a607f2a477ff939c6e09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0211b6ab9e54351f4f27a607f2a477ff939c6e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0211b6ab9e54351f4f27a607f2a477ff939c6e09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0211b6ab9e54351f4f27a607f2a477ff939c6e09/comments", "author": null, "committer": null, "parents": [{"sha": "5aef487f9c3320f833d8ea10a0d8096f90a5a65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aef487f9c3320f833d8ea10a0d8096f90a5a65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aef487f9c3320f833d8ea10a0d8096f90a5a65a"}], "stats": {"total": 140, "additions": 55, "deletions": 85}, "files": [{"sha": "a5f4bc33bf777dedac0954f46f301381795871bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0211b6ab9e54351f4f27a607f2a477ff939c6e09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0211b6ab9e54351f4f27a607f2a477ff939c6e09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0211b6ab9e54351f4f27a607f2a477ff939c6e09", "patch": "@@ -1,3 +1,9 @@\n+Sun May 17 13:44:32 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* alias.c (mode_alias_check): Delete.\n+\t(true_dependence, anti_dependence, output_dependence): Revert April 21\n+\tchange.\n+\n Sun May 17 08:45:21 1998  Krister Walfridsson <cato@df.lth.se>\n \n         * toplev.c (output_lang_identify): Enable prototype and definition."}, {"sha": "445e2732e9ff2f0d15cc3cc04faf20b85e4b9fbf", "filename": "gcc/alias.c", "status": "modified", "additions": 49, "deletions": 85, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0211b6ab9e54351f4f27a607f2a477ff939c6e09/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0211b6ab9e54351f4f27a607f2a477ff939c6e09/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0211b6ab9e54351f4f27a607f2a477ff939c6e09", "patch": "@@ -35,7 +35,6 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n static void record_set\t\t\tPROTO((rtx, rtx));\n static rtx find_base_term\t\tPROTO((rtx));\n static int base_alias_check\t\tPROTO((rtx, rtx));\n-static int mode_alias_check\t\tPROTO((rtx, rtx, int (*)(rtx)));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -642,11 +641,7 @@ base_alias_check (x, y)\n    align memory references, as is done on the Alpha.\n \n    Nice to notice that varying addresses cannot conflict with fp if no\n-   local variables had their addresses taken, but that's too hard now.\n-\n-   TODO: (symbol_ref foo) can not alias (plus REG N) if N is a positive\n-   integer because REG would have to point outside of the object, which\n-   is not allowed in C or C++.  */\n+   local variables had their addresses taken, but that's too hard now.  */\n \n \n static int\n@@ -847,70 +842,6 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    generate aligned addresses from unaligned addresses, for instance, the\n    alpha storeqi_unaligned pattern.  */\n \n-\n-/* This subroutine implements the type and struct/varying part of the\n-   alias check.\n-\n-   Return 0 if the memory references can never alias.\n-   Return 1 if the values of the addresses should be checked.  */\n-\n-static int\n-mode_alias_check (x, y, varies)\n-     register rtx x, y;\n-     int (*varies) PROTO ((rtx));\n-{\n-#if 1\n-  /* gcc rules: all type aliasing allowed  */\n-  return 1;\n-#else\n-  /* ANSI C rules: different types do not alias. */\n-  enum machine_mode x_mode = GET_MODE (x), y_mode = GET_MODE (y);\n-  rtx x_addr = XEXP (x, 0), y_addr = XEXP (y, 0);\n-  int x_varies, y_varies, x_struct, y_struct;\n-\n-  /* If either address is an AND then neither the mode check nor the\n-     struct/varying check is valid.  */\n-  if (GET_CODE (x_addr) == AND || GET_CODE (y_addr) == AND)\n-    return 1;\n-\n-  x_struct = MEM_IN_STRUCT_P (x);\n-  y_struct = MEM_IN_STRUCT_P (y);\n-\n-  /* QImode and BLKmode references can alias anything.  */\n-  if (x_mode == QImode || x_mode == BLKmode\n-      || y_mode == QImode || y_mode == BLKmode)\n-    return 1;\n-\n-  /* Otherwise, different modes can only alias if they are structure\n-     references.  gcc bitfield operations can access an entire word,\n-     but that word may also contain integers accessed directly.\n-\n-     ??? It appears that bitfield accesses can not be larger than\n-     word_mode?\n-     ??? Can complex modes alias their components? */\n-  if (x_mode != y_mode && ! (x_struct && y_struct))\n-    return 0;\n-\n-  /* Modes are the same or may alias.  */\n-\n-  /* No alias if one reference is a struct at a varying address and the\n-     other is a scalar at a fixed address.\n-\n-     If either reference is a varying scalar or a fixed struct nothing\n-     is known about aliasing.  */\n-  x_varies = varies (x_addr);\n-  if (x_struct != x_varies)\n-    return 1;\n-  y_varies = varies (y_addr);\n-  if (y_struct != y_varies)\n-    return 1;\n-\n-  /* Both are varying structs or fixed scalars.  Check that they are not\n-     the same type.  */\n-  return (x_struct == y_struct);\n-#endif\n-}\n-\n /* Read dependence: X is read after read in MEM takes place.  There can\n    only be a dependence here if both reads are volatile.  */\n \n@@ -949,17 +880,40 @@ true_dependence (mem, mem_mode, x, varies)\n   if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n     return 0;\n \n-  if (! mode_alias_check (x, mem, varies))\n-    return 0;\n-\n   x_addr = canon_rtx (XEXP (x, 0));\n   mem_addr = canon_rtx (XEXP (mem, 0));\n \n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n-  return memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n-\t\t\t     SIZE_FOR_MODE (x), x_addr, 0);\n+  if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n+\t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n+    return 0;\n+\n+  /* If both references are struct references, or both are not, nothing\n+     is known about aliasing.\n+\n+     If either reference is QImode or BLKmode, ANSI C permits aliasing.\n+\n+     If both addresses are constant, or both are not, nothing is known\n+     about aliasing.  */\n+  if (MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (mem)\n+      || mem_mode == QImode || mem_mode == BLKmode\n+      || GET_MODE (x) == QImode || GET_MODE (x) == BLKmode\n+      || GET_CODE (x_addr) == AND || GET_CODE (mem_addr) == AND\n+      || varies (x_addr) == varies (mem_addr))\n+    return 1;\n+\n+  /* One memory reference is to a constant address, one is not.\n+     One is to a structure, the other is not.\n+\n+     If either memory reference is a variable structure the other is a\n+     fixed scalar and there is no aliasing.  */\n+  if ((MEM_IN_STRUCT_P (mem) && varies (mem_addr))\n+      || (MEM_IN_STRUCT_P (x) && varies (x_addr)))\n+    return 0;\n+\n+  return 1;\n }\n \n /* Anti dependence: X is written after read in MEM takes place.  */\n@@ -989,11 +943,16 @@ anti_dependence (mem, x)\n   x_addr = XEXP (x, 0);\n   mem_addr = XEXP (mem, 0);\n \n-  if (! mode_alias_check (x, mem, rtx_varies_p))\n-    return 0;\n-\n-  return memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n-\t\t\t     SIZE_FOR_MODE (x), x_addr, 0);\n+  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n+\t\t\t      SIZE_FOR_MODE (x), x_addr, 0)\n+\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n+\t\t&& GET_MODE (mem) != QImode\n+\t\t&& GET_CODE (mem_addr) != AND\n+\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n+\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n+\t\t&& GET_MODE (x) != QImode\n+\t\t&& GET_CODE (x_addr) != AND\n+\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n@@ -1012,11 +971,16 @@ output_dependence (mem, x)\n   x = canon_rtx (x);\n   mem = canon_rtx (mem);\n \n-  if (! mode_alias_check (x, mem, rtx_varies_p))\n-    return 0;\n-\n-  return memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t     SIZE_FOR_MODE (x), XEXP (x, 0), 0);\n+  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n+\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n+\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n+\t\t&& GET_MODE (mem) != QImode\n+\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n+\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n+\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n+\t\t&& GET_MODE (x) != QImode\n+\t\t&& GET_CODE (XEXP (x, 0)) != AND\n+\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n }\n \n "}]}