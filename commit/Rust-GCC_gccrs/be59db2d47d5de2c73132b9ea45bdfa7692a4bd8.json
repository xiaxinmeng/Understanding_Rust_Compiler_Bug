{"sha": "be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU1OWRiMmQ0N2Q1ZGUyYzczMTMyYjllYTQ1YmRmYTc2OTJhNGJkOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-04-06T18:16:13Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-06T18:16:13Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2010-04-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * array.c (gfc_free_array_spec,gfc_resolve_array_spec,\n        match_array_element_spec,gfc_copy_array_spec,\n        gfc_compare_array_spec): Include corank.\n        (match_array_element_spec,gfc_set_array_spec): Support codimension.\n        * decl.c (build_sym,build_struct,variable_decl,\n        match_attr_spec,attr_decl1,cray_pointer_decl,\n        gfc_match_volatile): Add codimension.\n        (gfc_match_codimension): New function.\n        * dump-parse-tree.c (show_array_spec,show_attr): Support\n        * codimension.\n        * gfortran.h (symbol_attribute,gfc_array_spec): Ditto.\n        (gfc_add_codimension): New function prototype.\n        * match.h (gfc_match_codimension): New function prototype.\n        (gfc_match_array_spec): Update prototype\n        * match.c (gfc_match_common): Update gfc_match_array_spec call.\n        * module.c (MOD_VERSION): Bump.\n        (mio_symbol_attribute): Support coarray attributes.\n        (mio_array_spec): Add corank support.\n        * parse.c (decode_specification_statement,decode_statement,\n        parse_derived): Add coarray support.\n        * resolve.c (resolve_formal_arglist, was_declared,\n        is_non_constant_shape_array, resolve_fl_variable,\n        resolve_fl_derived, resolve_symbol): Add coarray support.\n        * symbol.c (check_conflict, gfc_add_volatile, gfc_copy_attr,\n        gfc_build_class_symbol): Add coarray support.\n        (gfc_add_codimension): New function.\n\n2010-04-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_4.f90: New test.\n        * gfortran.dg/coarray_5.f90: New test.\n        * gfortran.dg/coarray_6.f90: New test.\n\nFrom-SVN: r158012", "tree": {"sha": "5e7fce8dfc8a026d1df286f7a6b7e2340402829b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e7fce8dfc8a026d1df286f7a6b7e2340402829b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "385e8144121c9dfc0f8eb1a096db3e68183246bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385e8144121c9dfc0f8eb1a096db3e68183246bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385e8144121c9dfc0f8eb1a096db3e68183246bb"}], "stats": {"total": 706, "additions": 655, "deletions": 51}, "files": [{"sha": "f6cfcfdcce2a5ccb98d2a2184911a624cf5c8da9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -1,3 +1,32 @@\n+2010-04-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* array.c (gfc_free_array_spec,gfc_resolve_array_spec,\n+\tmatch_array_element_spec,gfc_copy_array_spec,\n+\tgfc_compare_array_spec): Include corank.\n+\t(match_array_element_spec,gfc_set_array_spec): Support codimension.\n+\t* decl.c (build_sym,build_struct,variable_decl,\n+\tmatch_attr_spec,attr_decl1,cray_pointer_decl,\n+\tgfc_match_volatile): Add codimension.\n+\t(gfc_match_codimension): New function.\n+\t* dump-parse-tree.c (show_array_spec,show_attr): Support codimension.\n+\t* gfortran.h (symbol_attribute,gfc_array_spec): Ditto.\n+\t(gfc_add_codimension): New function prototype.\n+\t* match.h (gfc_match_codimension): New function prototype.\n+\t(gfc_match_array_spec): Update prototype\n+\t* match.c (gfc_match_common): Update gfc_match_array_spec call.\n+\t* module.c (MOD_VERSION): Bump.\n+\t(mio_symbol_attribute): Support coarray attributes.\n+\t(mio_array_spec): Add corank support.\n+\t* parse.c (decode_specification_statement,decode_statement,\n+\tparse_derived): Add coarray support.\n+\t* resolve.c (resolve_formal_arglist, was_declared,\n+\tis_non_constant_shape_array, resolve_fl_variable,\n+\tresolve_fl_derived, resolve_symbol): Add coarray support.\n+\t* symbol.c (check_conflict, gfc_add_volatile, gfc_copy_attr,\n+\tgfc_build_class_symbol): Add coarray support.\n+\t(gfc_add_codimension): New function.\n+\n 2010-04-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "4b2ccf643c5ed7dbf65832f5b82f162e9b22eece", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 213, "deletions": 22, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -188,7 +188,7 @@ gfc_free_array_spec (gfc_array_spec *as)\n   if (as == NULL)\n     return;\n \n-  for (i = 0; i < as->rank; i++)\n+  for (i = 0; i < as->rank + as->corank; i++)\n     {\n       gfc_free_expr (as->lower[i]);\n       gfc_free_expr (as->upper[i]);\n@@ -234,7 +234,7 @@ gfc_resolve_array_spec (gfc_array_spec *as, int check_constant)\n   if (as == NULL)\n     return SUCCESS;\n \n-  for (i = 0; i < as->rank; i++)\n+  for (i = 0; i < as->rank + as->corank; i++)\n     {\n       e = as->lower[i];\n       if (resolve_array_bound (e, check_constant) == FAILURE)\n@@ -290,8 +290,8 @@ match_array_element_spec (gfc_array_spec *as)\n   gfc_expr **upper, **lower;\n   match m;\n \n-  lower = &as->lower[as->rank - 1];\n-  upper = &as->upper[as->rank - 1];\n+  lower = &as->lower[as->rank + as->corank - 1];\n+  upper = &as->upper[as->rank + as->corank - 1];\n \n   if (gfc_match_char ('*') == MATCH_YES)\n     {\n@@ -335,33 +335,40 @@ match_array_element_spec (gfc_array_spec *as)\n \n \n /* Matches an array specification, incidentally figuring out what sort\n-   it is.  */\n+   it is. Match either a normal array specification, or a coarray spec\n+   or both. Optionally allow [:] for coarrays.  */\n \n match\n-gfc_match_array_spec (gfc_array_spec **asp)\n+gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n {\n   array_type current_type;\n+  array_type coarray_type = AS_UNKNOWN;\n   gfc_array_spec *as;\n   int i;\n-\n-  if (gfc_match_char ('(') != MATCH_YES)\n-    {\n-      *asp = NULL;\n-      return MATCH_NO;\n-    }\n-\n+ \n   as = gfc_get_array_spec ();\n+  as->corank = 0;\n+  as->rank = 0;\n \n   for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n     {\n       as->lower[i] = NULL;\n       as->upper[i] = NULL;\n     }\n \n-  as->rank = 1;\n+  if (!match_dim)\n+    goto coarray;\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    {\n+      if (!match_codim)\n+\tgoto done;\n+      goto coarray;\n+    }\n \n   for (;;)\n     {\n+      as->rank++;\n       current_type = match_array_element_spec (as);\n \n       if (as->rank == 1)\n@@ -427,32 +434,150 @@ gfc_match_array_spec (gfc_array_spec **asp)\n \t  goto cleanup;\n \t}\n \n-      if (as->rank >= GFC_MAX_DIMENSIONS)\n+      if (as->rank + as->corank >= GFC_MAX_DIMENSIONS)\n \t{\n \t  gfc_error (\"Array specification at %C has more than %d dimensions\",\n \t\t     GFC_MAX_DIMENSIONS);\n \t  goto cleanup;\n \t}\n \n-      if (as->rank >= 7\n+      if (as->corank + as->rank >= 7\n \t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Array \"\n \t\t\t     \"specification at %C with more than 7 dimensions\")\n \t     == FAILURE)\n \tgoto cleanup;\n+    }\n \n-      as->rank++;\n+  if (!match_codim)\n+    goto done;\n+\n+coarray:\n+  if (gfc_match_char ('[')  != MATCH_YES)\n+    goto done;\n+\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Coarray declaration at %C\")\n+      == FAILURE)\n+    goto cleanup;\n+\n+  for (;;)\n+    {\n+      as->corank++;\n+      current_type = match_array_element_spec (as);\n+\n+      if (current_type == AS_UNKNOWN)\n+\tgoto cleanup;\n+\n+      if (as->rank && as->type != AS_DEFERRED && current_type == AS_DEFERRED)\n+\t{\n+\t  gfc_error (\"Array at %C has non-deferred shape and deferred \"\n+\t\t     \"coshape\");\n+          goto cleanup;\n+\t}\n+      if (as->rank && as->type == AS_DEFERRED && current_type != AS_DEFERRED)\n+\t{\n+\t  gfc_error (\"Array at %C has deferred shape and non-deferred \"\n+\t\t     \"coshape\");\n+          goto cleanup;\n+\t}\n+\n+      if (as->corank == 1)\n+\tcoarray_type = current_type;\n+      else\n+\tswitch (coarray_type)\n+\t  { /* See how current spec meshes with the existing.  */\n+\t    case AS_UNKNOWN:\n+\t      goto cleanup;\n+\n+\t    case AS_EXPLICIT:\n+\t      if (current_type == AS_ASSUMED_SIZE)\n+\t\t{\n+\t\t  coarray_type = AS_ASSUMED_SIZE;\n+\t\t  break;\n+\t\t}\n+\n+\t      if (current_type == AS_EXPLICIT)\n+\t\tbreak;\n+\n+\t      gfc_error (\"Bad array specification for an explicitly \"\n+\t\t\t \"shaped array at %C\");\n+\n+\t      goto cleanup;\n+\n+\t    case AS_ASSUMED_SHAPE:\n+\t      if ((current_type == AS_ASSUMED_SHAPE)\n+\t\t  || (current_type == AS_DEFERRED))\n+\t\tbreak;\n+\n+\t      gfc_error (\"Bad array specification for assumed shape \"\n+\t\t\t \"array at %C\");\n+\t      goto cleanup;\n+\n+\t    case AS_DEFERRED:\n+\t      if (current_type == AS_DEFERRED)\n+\t\tbreak;\n+\n+\t      if (current_type == AS_ASSUMED_SHAPE)\n+\t\t{\n+\t\t  as->type = AS_ASSUMED_SHAPE;\n+\t\t  break;\n+\t\t}\n+\n+\t      gfc_error (\"Bad specification for deferred shape array at %C\");\n+\t      goto cleanup;\n+\n+\t    case AS_ASSUMED_SIZE:\n+\t      gfc_error (\"Bad specification for assumed size array at %C\");\n+\t      goto cleanup;\n+\t  }\n+\n+      if (gfc_match_char (']') == MATCH_YES)\n+\tbreak;\n+\n+      if (gfc_match_char (',') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected another dimension in array declaration at %C\");\n+\t  goto cleanup;\n+\t}\n+\n+      if (as->corank >= GFC_MAX_DIMENSIONS)\n+\t{\n+\t  gfc_error (\"Array specification at %C has more than %d \"\n+\t\t     \"dimensions\", GFC_MAX_DIMENSIONS);\n+\t  goto cleanup;\n+\t}\n+    }\n+\n+  if (current_type == AS_EXPLICIT)\n+    {\n+      gfc_error (\"Upper bound of last coarray dimension must be '*' at %C\");\n+      goto cleanup;\n+    }\n+\n+  if (as->rank == 0 && coarray_type == AS_ASSUMED_SIZE)\n+    as->type = AS_EXPLICIT;\n+  else if (as->rank == 0)\n+    as->type = coarray_type;\n+\n+done:\n+  if (as->rank == 0 && as->corank == 0)\n+    {\n+      *asp = NULL;\n+      gfc_free_array_spec (as);\n+      return MATCH_NO;\n     }\n \n   /* If a lower bounds of an assumed shape array is blank, put in one.  */\n   if (as->type == AS_ASSUMED_SHAPE)\n     {\n-      for (i = 0; i < as->rank; i++)\n+      for (i = 0; i < as->rank + as->corank; i++)\n \t{\n \t  if (as->lower[i] == NULL)\n \t    as->lower[i] = gfc_int_expr (1);\n \t}\n     }\n+\n   *asp = as;\n+\n   return MATCH_YES;\n \n cleanup:\n@@ -469,14 +594,77 @@ gfc_match_array_spec (gfc_array_spec **asp)\n gfc_try\n gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n {\n+  int i;\n+\n   if (as == NULL)\n     return SUCCESS;\n \n-  if (gfc_add_dimension (&sym->attr, sym->name, error_loc) == FAILURE)\n+  if (as->rank\n+      && gfc_add_dimension (&sym->attr, sym->name, error_loc) == FAILURE)\n     return FAILURE;\n \n-  sym->as = as;\n+  if (as->corank\n+      && gfc_add_codimension (&sym->attr, sym->name, error_loc) == FAILURE)\n+    return FAILURE;\n+\n+  if (sym->as == NULL)\n+    {\n+      sym->as = as;\n+      return SUCCESS;\n+    }\n+\n+  if (sym->as->type == AS_DEFERRED && as->type != AS_DEFERRED)\n+    {\n+      gfc_error (\"'%s' at %L has deferred shape and non-deferred coshape\",\n+\t\t sym->name, error_loc);\n+      return FAILURE;\n+    }\n+\n+  if (sym->as->type != AS_DEFERRED && as->type == AS_DEFERRED)\n+    {\n+      gfc_error (\"'%s' at %L has non-deferred shape and deferred coshape\",\n+\t\t sym->name, error_loc);\n+      return FAILURE;\n+    }\n+\n+  if (as->corank)\n+    {\n+      /* The \"sym\" has no corank (checked via gfc_add_codimension). Thus\n+\t the codimension is simply added.  */\n+      gcc_assert (as->rank == 0 && sym->as->corank == 0);\n+\n+      sym->as->corank = as->corank;\n+      for (i = 0; i < as->corank; i++)\n+\t{\n+\t  sym->as->lower[sym->as->rank + i] = as->lower[i];\n+\t  sym->as->upper[sym->as->rank + i] = as->upper[i];\n+\t}\n+    }\n+  else\n+    {\n+      /* The \"sym\" has no rank (checked via gfc_add_dimension). Thus\n+\t the dimension is added - but first the codimensions (if existing\n+\t need to be shifted to make space for the dimension.  */\n+      gcc_assert (as->corank == 0 && sym->as->rank == 0);\n+\n+      sym->as->rank = as->rank;\n+      sym->as->type = as->type;\n+      sym->as->cray_pointee = as->cray_pointee;\n+      sym->as->cp_was_assumed = as->cp_was_assumed;\n+\n+      for (i = 0; i < sym->as->corank; i++)\n+\t{\n+\t  sym->as->lower[as->rank + i] = sym->as->lower[i];\n+\t  sym->as->upper[as->rank + i] = sym->as->upper[i];\n+\t}\n+      for (i = 0; i < as->rank; i++)\n+\t{\n+\t  sym->as->lower[i] = as->lower[i];\n+\t  sym->as->upper[i] = as->upper[i];\n+\t}\n+    }\n \n+  gfc_free (as);\n   return SUCCESS;\n }\n \n@@ -496,7 +684,7 @@ gfc_copy_array_spec (gfc_array_spec *src)\n \n   *dest = *src;\n \n-  for (i = 0; i < dest->rank; i++)\n+  for (i = 0; i < dest->rank + dest->corank; i++)\n     {\n       dest->lower[i] = gfc_copy_expr (dest->lower[i]);\n       dest->upper[i] = gfc_copy_expr (dest->upper[i]);\n@@ -543,14 +731,17 @@ gfc_compare_array_spec (gfc_array_spec *as1, gfc_array_spec *as2)\n   if (as1->rank != as2->rank)\n     return 0;\n \n+  if (as1->corank != as2->corank)\n+    return 0;\n+\n   if (as1->rank == 0)\n     return 1;\n \n   if (as1->type != as2->type)\n     return 0;\n \n   if (as1->type == AS_EXPLICIT)\n-    for (i = 0; i < as1->rank; i++)\n+    for (i = 0; i < as1->rank + as1->corank; i++)\n       {\n \tif (compare_bounds (as1->lower[i], as2->lower[i]) == 0)\n \t  return 0;"}, {"sha": "b3761921db08f8945613ccae30b2d3d856f03bf5", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 75, "deletions": 13, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -1057,6 +1057,7 @@ build_sym (const char *name, gfc_charlen *cl,\n      dimension attribute.  */\n   attr = current_attr;\n   attr.dimension = 0;\n+  attr.codimension = 0;\n \n   if (gfc_copy_attr (&sym->attr, &attr, var_locus) == FAILURE)\n     return FAILURE;\n@@ -1430,7 +1431,12 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \n   c->as = *as;\n   if (c->as != NULL)\n-    c->attr.dimension = 1;\n+    {\n+      if (c->as->corank)\n+\tc->attr.codimension = 1;\n+      if (c->as->rank)\n+\tc->attr.dimension = 1;\n+    }\n   *as = NULL;\n \n   /* Should this ever get more complicated, combine with similar section\n@@ -1589,7 +1595,7 @@ variable_decl (int elem)\n   var_locus = gfc_current_locus;\n \n   /* Now we could see the optional array spec. or character length.  */\n-  m = gfc_match_array_spec (&as);\n+  m = gfc_match_array_spec (&as, true, true);\n   if (gfc_option.flag_cray_pointer && m == MATCH_YES)\n     cp_as = gfc_copy_array_spec (as);\n   else if (m == MATCH_ERROR)\n@@ -2820,7 +2826,7 @@ match_attr_spec (void)\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n-    DECL_IS_BIND_C, DECL_ASYNCHRONOUS, DECL_NONE,\n+    DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n@@ -2894,6 +2900,11 @@ match_attr_spec (void)\n \t\tgoto cleanup;\n \t      break;\n \n+\t    case 'c':\n+\t      if (match_string_p (\"codimension\"))\n+\t\td = DECL_CODIMENSION;\n+\t      break;\n+\n \t    case 'd':\n \t      if (match_string_p (\"dimension\"))\n \t\td = DECL_DIMENSION;\n@@ -3041,7 +3052,7 @@ match_attr_spec (void)\n \n       if (d == DECL_DIMENSION)\n \t{\n-\t  m = gfc_match_array_spec (&current_as);\n+\t  m = gfc_match_array_spec (&current_as, true, false);\n \n \t  if (m == MATCH_NO)\n \t    {\n@@ -3052,6 +3063,20 @@ match_attr_spec (void)\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \t}\n+\n+      if (d == DECL_CODIMENSION)\n+\t{\n+\t  m = gfc_match_array_spec (&current_as, false, true);\n+\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      gfc_error (\"Missing codimension specification at %C\");\n+\t      m = MATCH_ERROR;\n+\t    }\n+\n+\t  if (m == MATCH_ERROR)\n+\t    goto cleanup;\n+\t}\n     }\n \n   /* Since we've seen a double colon, we have to be looking at an\n@@ -3067,6 +3092,9 @@ match_attr_spec (void)\n \t  case DECL_ASYNCHRONOUS:\n \t    attr = \"ASYNCHRONOUS\";\n \t    break;\n+\t  case DECL_CODIMENSION:\n+\t    attr = \"CODIMENSION\";\n+\t    break;\n \t  case DECL_DIMENSION:\n \t    attr = \"DIMENSION\";\n \t    break;\n@@ -3135,9 +3163,9 @@ match_attr_spec (void)\n \tcontinue;\n \n       if (gfc_current_state () == COMP_DERIVED\n-\t  && d != DECL_DIMENSION && d != DECL_POINTER\n-\t  && d != DECL_PRIVATE   && d != DECL_PUBLIC\n-\t  && d != DECL_NONE)\n+\t  && d != DECL_DIMENSION && d != DECL_CODIMENSION\n+\t  && d != DECL_POINTER   && d != DECL_PRIVATE\n+\t  && d != DECL_PUBLIC && d != DECL_NONE)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n@@ -3202,6 +3230,10 @@ match_attr_spec (void)\n \t    t = gfc_add_asynchronous (&current_attr, NULL, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_CODIMENSION:\n+\t  t = gfc_add_codimension (&current_attr, NULL, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_DIMENSION:\n \t  t = gfc_add_dimension (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -5626,11 +5658,15 @@ attr_decl1 (void)\n \n   /* Deal with possible array specification for certain attributes.  */\n   if (current_attr.dimension\n+      || current_attr.codimension\n       || current_attr.allocatable\n       || current_attr.pointer\n       || current_attr.target)\n     {\n-      m = gfc_match_array_spec (&as);\n+      m = gfc_match_array_spec (&as, !current_attr.codimension,\n+\t\t\t\t!current_attr.dimension\n+\t\t\t\t&& !current_attr.pointer\n+\t\t\t\t&& !current_attr.target);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n \n@@ -5650,6 +5686,14 @@ attr_decl1 (void)\n \t  goto cleanup;\n \t}\n \n+      if (current_attr.codimension && m == MATCH_NO)\n+\t{\n+\t  gfc_error (\"Missing array specification at %L in CODIMENSION \"\n+\t\t     \"statement\", &var_locus);\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+\n       if ((current_attr.allocatable || current_attr.pointer)\n \t  && (m == MATCH_YES) && (as->type != AS_DEFERRED))\n \t{\n@@ -5678,8 +5722,8 @@ attr_decl1 (void)\n     }\n   else\n     {\n-      if (current_attr.dimension == 0\n-\t    && gfc_copy_attr (&sym->attr, &current_attr, &var_locus) == FAILURE)\n+      if (current_attr.dimension == 0 && current_attr.codimension == 0\n+\t  && gfc_copy_attr (&sym->attr, &current_attr, &var_locus) == FAILURE)\n \t{\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -5777,7 +5821,7 @@ static match\n cray_pointer_decl (void)\n {\n   match m;\n-  gfc_array_spec *as;\n+  gfc_array_spec *as = NULL;\n   gfc_symbol *cptr; /* Pointer symbol.  */\n   gfc_symbol *cpte; /* Pointee symbol.  */\n   locus var_locus;\n@@ -5846,7 +5890,7 @@ cray_pointer_decl (void)\n \t}\n \n       /* Check for an optional array spec.  */\n-      m = gfc_match_array_spec (&as);\n+      m = gfc_match_array_spec (&as, true, false);\n       if (m == MATCH_ERROR)\n \t{\n \t  gfc_free_array_spec (as);\n@@ -6005,6 +6049,16 @@ gfc_match_allocatable (void)\n }\n \n \n+match\n+gfc_match_codimension (void)\n+{\n+  gfc_clear_attr (&current_attr);\n+  current_attr.codimension = 1;\n+\n+  return attr_decl ();\n+}\n+\n+\n match\n gfc_match_dimension (void)\n {\n@@ -6493,11 +6547,19 @@ gfc_match_volatile (void)\n   for(;;)\n     {\n       /* VOLATILE is special because it can be added to host-associated \n-\t symbols locally.  */\n+\t symbols locally. Except for coarrays. */\n       m = gfc_match_symbol (&sym, 1);\n       switch (m)\n \t{\n \tcase MATCH_YES:\n+\t  /* F2008, C560+C561. VOLATILE for host-/use-associated variable or\n+\t     for variable in a BLOCK which is defined outside of the BLOCK.  */\n+\t  if (sym->ns != gfc_current_ns && sym->attr.codimension)\n+\t    {\n+\t      gfc_error (\"Specifying VOLATILE for coarray variable '%s' at \"\n+\t\t\t \"%C, which is use-/host-associated\", sym->name);\n+\t      return MATCH_ERROR;\n+\t    }\n \t  if (gfc_add_volatile (&sym->attr, sym->name, &gfc_current_locus)\n \t      == FAILURE)\n \t    return MATCH_ERROR;"}, {"sha": "e722ff045a20d4d4e0393a36d0033eb86616e57c", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -141,9 +141,9 @@ show_array_spec (gfc_array_spec *as)\n       return;\n     }\n \n-  fprintf (dumpfile, \"(%d\", as->rank);\n+  fprintf (dumpfile, \"(%d [%d]\", as->rank, as->corank);\n \n-  if (as->rank != 0)\n+  if (as->rank + as->corank > 0)\n     {\n       switch (as->type)\n       {\n@@ -157,7 +157,7 @@ show_array_spec (gfc_array_spec *as)\n       }\n       fprintf (dumpfile, \" %s \", c);\n \n-      for (i = 0; i < as->rank; i++)\n+      for (i = 0; i < as->rank + as->corank; i++)\n \t{\n \t  show_expr (as->lower[i]);\n \t  fputc (' ', dumpfile);\n@@ -591,6 +591,8 @@ show_attr (symbol_attribute *attr)\n     fputs (\" ALLOCATABLE\", dumpfile);\n   if (attr->asynchronous)\n     fputs (\" ASYNCHRONOUS\", dumpfile);\n+  if (attr->codimension)\n+    fputs (\" CODIMENSION\", dumpfile);\n   if (attr->dimension)\n     fputs (\" DIMENSION\", dumpfile);\n   if (attr->external)"}, {"sha": "a2e385d2d3100507bdd0e005619168ec8ff22e88", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -651,7 +651,7 @@ extern const ext_attr_t ext_attr_list[];\n typedef struct\n {\n   /* Variable attributes.  */\n-  unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n+  unsigned allocatable:1, dimension:1, codimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1;\n@@ -735,7 +735,7 @@ typedef struct\n      possibly nested.  zero_comp is true if the derived type has no\n      component at all.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n-\t   private_comp:1, zero_comp:1;\n+\t   private_comp:1, zero_comp:1, coarray_comp:1;\n \n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n@@ -867,6 +867,7 @@ gfc_typespec;\n typedef struct\n {\n   int rank;\t/* A rank of zero means that a variable is a scalar.  */\n+  int corank;\n   array_type type;\n   struct gfc_expr *lower[GFC_MAX_DIMENSIONS], *upper[GFC_MAX_DIMENSIONS];\n \n@@ -2400,6 +2401,7 @@ void gfc_set_sym_referenced (gfc_symbol *);\n gfc_try gfc_add_attribute (symbol_attribute *, locus *);\n gfc_try gfc_add_ext_attribute (symbol_attribute *, ext_attr_id_t, locus *);\n gfc_try gfc_add_allocatable (symbol_attribute *, locus *);\n+gfc_try gfc_add_codimension (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_external (symbol_attribute *, locus *);\n gfc_try gfc_add_intrinsic (symbol_attribute *, locus *);"}, {"sha": "e719628b0d55c538f062a7bd7162000ddf6d5c54", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -3562,7 +3562,7 @@ gfc_match_common (void)\n \n \t  /* Deal with an optional array specification after the\n \t     symbol name.  */\n-\t  m = gfc_match_array_spec (&as);\n+\t  m = gfc_match_array_spec (&as, true, true);\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n "}, {"sha": "7a0f8470a1717ff6dd8c069d869a0002da26240d", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -168,6 +168,7 @@ void gfc_set_constant_character_len (int, gfc_expr *, int);\n /* Matchers for attribute declarations.  */\n match gfc_match_allocatable (void);\n match gfc_match_asynchronous (void);\n+match gfc_match_codimension (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n match gfc_match_gcc_attributes (void);\n@@ -214,7 +215,7 @@ gfc_try gfc_reduce_init_expr (gfc_expr *expr);\n match gfc_match_init_expr (gfc_expr **);\n \n /* array.c.  */\n-match gfc_match_array_spec (gfc_array_spec **);\n+match gfc_match_array_spec (gfc_array_spec **, bool, bool);\n match gfc_match_array_ref (gfc_array_ref *, gfc_array_spec *, int);\n match gfc_match_array_constructor (gfc_expr **);\n "}, {"sha": "5c574bbd2bef669573bbefe4321c91926701b6cf", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -78,7 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"4\"\n+#define MOD_VERSION \"5\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -1672,7 +1672,8 @@ typedef enum\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n-  AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS\n+  AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n+  AB_COARRAY_COMP\n }\n ab_attribute;\n \n@@ -1681,6 +1682,7 @@ static const mstring attr_bits[] =\n     minit (\"ALLOCATABLE\", AB_ALLOCATABLE),\n     minit (\"ASYNCHRONOUS\", AB_ASYNCHRONOUS),\n     minit (\"DIMENSION\", AB_DIMENSION),\n+    minit (\"CODIMENSION\", AB_CODIMENSION),\n     minit (\"EXTERNAL\", AB_EXTERNAL),\n     minit (\"INTRINSIC\", AB_INTRINSIC),\n     minit (\"OPTIONAL\", AB_OPTIONAL),\n@@ -1708,6 +1710,7 @@ static const mstring attr_bits[] =\n     minit (\"IS_ISO_C\", AB_IS_ISO_C),\n     minit (\"VALUE\", AB_VALUE),\n     minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n+    minit (\"COARRAY_COMP\", AB_COARRAY_COMP),\n     minit (\"POINTER_COMP\", AB_POINTER_COMP),\n     minit (\"PRIVATE_COMP\", AB_PRIVATE_COMP),\n     minit (\"ZERO_COMP\", AB_ZERO_COMP),\n@@ -1798,6 +1801,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_ASYNCHRONOUS, attr_bits);\n       if (attr->dimension)\n \tMIO_NAME (ab_attribute) (AB_DIMENSION, attr_bits);\n+      if (attr->codimension)\n+\tMIO_NAME (ab_attribute) (AB_CODIMENSION, attr_bits);\n       if (attr->external)\n \tMIO_NAME (ab_attribute) (AB_EXTERNAL, attr_bits);\n       if (attr->intrinsic)\n@@ -1864,6 +1869,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_POINTER_COMP, attr_bits);\n       if (attr->private_comp)\n \tMIO_NAME (ab_attribute) (AB_PRIVATE_COMP, attr_bits);\n+      if (attr->coarray_comp)\n+\tMIO_NAME (ab_attribute) (AB_COARRAY_COMP, attr_bits);\n       if (attr->zero_comp)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n       if (attr->is_class)\n@@ -1897,6 +1904,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_DIMENSION:\n \t      attr->dimension = 1;\n \t      break;\n+\t    case AB_CODIMENSION:\n+\t      attr->codimension = 1;\n+\t      break;\n \t    case AB_EXTERNAL:\n \t      attr->external = 1;\n \t      break;\n@@ -1984,6 +1994,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ALLOC_COMP:\n \t      attr->alloc_comp = 1;\n \t      break;\n+\t    case AB_COARRAY_COMP:\n+\t      attr->coarray_comp = 1;\n+\t      break;\n \t    case AB_POINTER_COMP:\n \t      attr->pointer_comp = 1;\n \t      break;\n@@ -2131,9 +2144,10 @@ mio_array_spec (gfc_array_spec **asp)\n     }\n \n   mio_integer (&as->rank);\n+  mio_integer (&as->corank);\n   as->type = MIO_NAME (array_type) (as->type, array_spec_types);\n \n-  for (i = 0; i < as->rank; i++)\n+  for (i = 0; i < as->rank + as->corank; i++)\n     {\n       mio_expr (&as->lower[i]);\n       mio_expr (&as->upper[i]);"}, {"sha": "b68afba3d66f4e2b69f79bd95a9d8267a771380a", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -138,6 +138,7 @@ decode_specification_statement (void)\n       break;\n \n     case 'c':\n+      match (\"codimension\", gfc_match_codimension, ST_ATTR_DECL);\n       break;\n \n     case 'd':\n@@ -349,6 +350,7 @@ decode_statement (void)\n       match (\"common\", gfc_match_common, ST_COMMON);\n       match (\"contains\", gfc_match_eos, ST_CONTAINS);\n       match (\"class\", gfc_match_class_is, ST_CLASS_IS);\n+      match (\"codimension\", gfc_match_codimension, ST_ATTR_DECL);\n       break;\n \n     case 'd':\n@@ -2112,6 +2114,10 @@ parse_derived (void)\n \t      && c->ts.u.derived->attr.proc_pointer_comp))\n \tsym->attr.proc_pointer_comp = 1;\n \n+      /* Looking for coarray components.  */\n+      if (c->attr.codimension || c->attr.coarray_comp)\n+\tsym->attr.coarray_comp = 1;\n+\n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE"}, {"sha": "55c0d124f51b8ebcdc96c9e241f368d8e07ee8c2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 99, "deletions": 4, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -258,6 +258,14 @@ resolve_formal_arglist (gfc_symbol *proc)\n \n       if (gfc_elemental (proc))\n \t{\n+\t  /* F2008, C1289.  */\n+\t  if (sym->attr.codimension)\n+\t    {\n+\t      gfc_error (\"Coarray dummy argument '%s' at %L to elemental \"\n+\t\t\t \"procedure\", sym->name, &sym->declared_at);\n+\t      continue;\n+\t    }\n+\n \t  if (sym->as != NULL)\n \t    {\n \t      gfc_error (\"Argument '%s' of elemental procedure at %L must \"\n@@ -955,7 +963,7 @@ was_declared (gfc_symbol *sym)\n   if (a.allocatable || a.dimension || a.dummy || a.external || a.intrinsic\n       || a.optional || a.pointer || a.save || a.target || a.volatile_\n       || a.value || a.access != ACCESS_UNKNOWN || a.intent != INTENT_UNKNOWN\n-      || a.asynchronous)\n+      || a.asynchronous || a.codimension)\n     return 1;\n \n   return 0;\n@@ -8691,13 +8699,12 @@ is_non_constant_shape_array (gfc_symbol *sym)\n       /* Unfortunately, !gfc_is_compile_time_shape hits a legal case that\n \t has not been simplified; parameter array references.  Do the\n \t simplification now.  */\n-      for (i = 0; i < sym->as->rank; i++)\n+      for (i = 0; i < sym->as->rank + sym->as->corank; i++)\n \t{\n \t  e = sym->as->lower[i];\n \t  if (e && (resolve_index_expr (e) == FAILURE\n \t\t    || !gfc_is_constant_expr (e)))\n \t    not_constant = true;\n-\n \t  e = sym->as->upper[i];\n \t  if (e && (resolve_index_expr (e) == FAILURE\n \t\t    || !gfc_is_constant_expr (e)))\n@@ -9147,7 +9154,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   if (sym->attr.allocatable || sym->attr.external || sym->attr.dummy\n       || sym->attr.intrinsic || sym->attr.result)\n     no_init_flag = 1;\n-  else if (sym->attr.dimension && !sym->attr.pointer\n+  else if ((sym->attr.dimension || sym->attr.codimension) && !sym->attr.pointer\n \t   && is_non_constant_shape_array (sym))\n     {\n       no_init_flag = automatic_flag = 1;\n@@ -10431,6 +10438,15 @@ resolve_fl_derived (gfc_symbol *sym)\n \n   super_type = gfc_get_derived_super_type (sym);\n \n+  /* F2008, C432. */\n+  if (super_type && sym->attr.coarray_comp && !super_type->attr.coarray_comp)\n+    {\n+      gfc_error (\"As extending type '%s' at %L has a coarray component, \"\n+\t\t \"parent type '%s' shall also have one\", sym->name,\n+\t\t &sym->declared_at, super_type->name);\n+      return FAILURE;\n+    }\n+\n   /* Ensure the extended type gets resolved before we do.  */\n   if (super_type && resolve_fl_derived (super_type) == FAILURE)\n     return FAILURE;\n@@ -10445,6 +10461,34 @@ resolve_fl_derived (gfc_symbol *sym)\n \n   for (c = sym->components; c != NULL; c = c->next)\n     {\n+      /* F2008, C442.  */\n+      if (c->attr.codimension\n+\t  && (!c->attr.allocatable || c->as->type != AS_DEFERRED))\n+\t{\n+\t  gfc_error (\"Coarray component '%s' at %L must be allocatable with \"\n+\t\t     \"deferred shape\", c->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n+      /* F2008, C443.  */\n+      if (c->attr.codimension && c->ts.type == BT_DERIVED\n+\t  && c->ts.u.derived->ts.is_iso_c)\n+\t{\n+\t  gfc_error (\"Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n+\t\t     \"shall not be a coarray\", c->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n+      /* F2008, C444.  */\n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n+\t  && (c->attr.codimension || c->attr.pointer || c->attr.dimension))\n+\t{\n+\t  gfc_error (\"Component '%s' at %L with coarray component \"\n+\t\t     \"shall be a nonpointer, nonallocatable scalar\",\n+\t\t     c->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n       if (c->attr.proc_pointer && c->ts.interface)\n \t{\n \t  if (c->ts.interface->attr.procedure)\n@@ -11275,6 +11319,57 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n+  if (sym->attr.codimension && sym->attr.allocatable\n+      && sym->as->type != AS_DEFERRED)\n+    gfc_error (\"Allocatable coarray variable '%s' at %L must have \"\n+\t       \"deferred shape\", sym->name, &sym->declared_at);\n+\n+  /* F2008, C526.  */\n+  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+       || sym->attr.codimension)\n+      && sym->attr.result)\n+    gfc_error (\"Function result '%s' at %L shall not be a coarray or have \"\n+\t       \"a coarray component\", sym->name, &sym->declared_at);\n+\n+  /* F2008, C524.  */\n+  if (sym->attr.codimension && sym->ts.type == BT_DERIVED\n+      && sym->ts.u.derived->ts.is_iso_c)\n+    gfc_error (\"Variable '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n+\t       \"shall not be a coarray\", sym->name, &sym->declared_at);\n+\n+  /* F2008, C525.  */\n+  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp\n+      && (sym->attr.codimension || sym->attr.pointer || sym->attr.dimension\n+\t  || sym->attr.allocatable))\n+    gfc_error (\"Variable '%s' at %L with coarray component \"\n+\t       \"shall be a nonpointer, nonallocatable scalar\",\n+\t       sym->name, &sym->declared_at);\n+\n+  /* F2008, C526.  The function-result case was handled above.  */\n+  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+       || sym->attr.codimension)\n+      && !(sym->attr.allocatable || sym->attr.dummy || sym->attr.save\n+\t   || sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t   || sym->ns->proc_name->attr.is_main_program\n+\t   || sym->attr.function || sym->attr.result || sym->attr.use_assoc))\n+    gfc_error (\"Variable '%s' at %L is a coarray or has a coarray \"\n+\t       \"component and is not ALLOCATABLE, SAVE nor a \"\n+\t       \"dummy argument\", sym->name, &sym->declared_at);\n+\n+  /* F2008, C541.  */\n+  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+       || (sym->attr.codimension && sym->attr.allocatable))\n+      && sym->attr.dummy && sym->attr.intent == INTENT_OUT)\n+    gfc_error (\"Variable '%s' at %L is INTENT(OUT) and can thus not be an \"\n+\t       \"allocatable coarray or have coarray components\",\n+\t       sym->name, &sym->declared_at);\n+\n+  if (sym->attr.codimension && sym->attr.dummy\n+      && sym->ns->proc_name && sym->ns->proc_name->attr.is_bind_c)\n+    gfc_error (\"Coarray dummy variable '%s' at %L not allowed in BIND(C) \"\n+\t       \"procedure '%s'\", sym->name, &sym->declared_at,\n+\t       sym->ns->proc_name->name);\n+\n   switch (sym->attr.flavor)\n     {\n     case FL_VARIABLE:"}, {"sha": "dbbc97c78cde49536e680ff79c2d3ada6c59e8a2", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -371,7 +371,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n     *volatile_ = \"VOLATILE\", *is_protected = \"PROTECTED\",\n     *is_bind_c = \"BIND(C)\", *procedure = \"PROCEDURE\",\n-    *asynchronous = \"ASYNCHRONOUS\";\n+    *asynchronous = \"ASYNCHRONOUS\", *codimension = \"CODIMENSION\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -477,11 +477,13 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (in_common, dummy);\n   conf (in_common, allocatable);\n+  conf (in_common, codimension);\n   conf (in_common, result);\n \n   conf (dummy, result);\n \n   conf (in_equivalence, use_assoc);\n+  conf (in_equivalence, codimension);\n   conf (in_equivalence, dummy);\n   conf (in_equivalence, target);\n   conf (in_equivalence, pointer);\n@@ -503,6 +505,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (is_bind_c, cray_pointer);\n   conf (is_bind_c, cray_pointee);\n+  conf (is_bind_c, codimension);\n   conf (is_bind_c, allocatable);\n   conf (is_bind_c, elemental);\n \n@@ -513,6 +516,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   /* Cray pointer/pointee conflicts.  */\n   conf (cray_pointer, cray_pointee);\n   conf (cray_pointer, dimension);\n+  conf (cray_pointer, codimension);\n   conf (cray_pointer, pointer);\n   conf (cray_pointer, target);\n   conf (cray_pointer, allocatable);\n@@ -524,6 +528,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (cray_pointer, entry);\n \n   conf (cray_pointee, allocatable);\n+  conf (cray_pointer, codimension);\n   conf (cray_pointee, intent);\n   conf (cray_pointee, optional);\n   conf (cray_pointee, dummy);\n@@ -547,8 +552,11 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (value, function)\n   conf (value, volatile_)\n   conf (value, dimension)\n+  conf (value, codimension)\n   conf (value, external)\n \n+  conf (codimension, result)\n+\n   if (attr->value\n       && (attr->intent == INTENT_OUT || attr->intent == INTENT_INOUT))\n     {\n@@ -576,6 +584,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \n   conf (procedure, allocatable)\n   conf (procedure, dimension)\n+  conf (procedure, codimension)\n   conf (procedure, intrinsic)\n   conf (procedure, is_protected)\n   conf (procedure, target)\n@@ -601,6 +610,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     case FL_BLOCK_DATA:\n     case FL_MODULE:\n     case FL_LABEL:\n+      conf2 (codimension);\n       conf2 (dimension);\n       conf2 (dummy);\n       conf2 (volatile_);\n@@ -653,6 +663,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n \t  conf2 (volatile_);\n \t  conf2 (asynchronous);\n \t  conf2 (in_namelist);\n+\t  conf2 (codimension);\n \t  conf2 (dimension);\n \t  conf2 (function);\n \t  conf2 (threadprivate);\n@@ -722,6 +733,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (threadprivate);\n       conf2 (value);\n       conf2 (is_bind_c);\n+      conf2 (codimension);\n       conf2 (result);\n       break;\n \n@@ -865,6 +877,32 @@ gfc_add_allocatable (symbol_attribute *attr, locus *where)\n }\n \n \n+gfc_try\n+gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)\n+{\n+\n+  if (check_used (attr, name, where))\n+    return FAILURE;\n+\n+  if (attr->codimension)\n+    {\n+      duplicate_attr (\"CODIMENSION\", where);\n+      return FAILURE;\n+    }\n+\n+  if (attr->flavor == FL_PROCEDURE && attr->if_source == IFSRC_IFBODY\n+      && gfc_find_state (COMP_INTERFACE) == FAILURE)\n+    {\n+      gfc_error (\"CODIMENSION specified for '%s' outside its INTERFACE body \"\n+\t\t \"at %L\", name, where);\n+      return FAILURE;\n+    }\n+\n+  attr->codimension = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n gfc_try\n gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n {\n@@ -1096,7 +1134,7 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n {\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n      that the local identifier made accessible by a use statement can be\n-     given a VOLATILE attribute.  */\n+     given a VOLATILE attribute - unless it is a coarray (F2008, C560).  */\n \n   if (attr->volatile_ && attr->volatile_ns == gfc_current_ns)\n     if (gfc_notify_std (GFC_STD_LEGACY, \n@@ -1677,6 +1715,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n \n   if (src->dimension && gfc_add_dimension (dest, NULL, where) == FAILURE)\n     goto fail;\n+  if (src->codimension && gfc_add_codimension (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->optional && gfc_add_optional (dest, where) == FAILURE)\n     goto fail;\n   if (src->pointer && gfc_add_pointer (dest, where) == FAILURE)\n@@ -4713,6 +4753,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->attr.pointer = attr->pointer || attr->dummy;\n       c->attr.allocatable = attr->allocatable;\n       c->attr.dimension = attr->dimension;\n+      c->attr.codimension = attr->codimension;\n       c->attr.abstract = ts->u.derived->attr.abstract;\n       c->as = (*as);\n       c->initializer = gfc_get_expr ();"}, {"sha": "bcbc8d3df2beeebe38a5b9bda691c7631081684d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -1,3 +1,10 @@\n+2010-04-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_4.f90: New test.\n+\t* gfortran.dg/coarray_5.f90: New test.\n+\t* gfortran.dg/coarray_6.f90: New test.\n+\n 2010-04-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "71fbf98c82de630177bfe1998f28bcdb17b72d7b", "filename": "gcc/testsuite/gfortran.dg/coarray_4.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_4.f90?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -0,0 +1,86 @@\n+! { dg-do compile }\n+!\n+! Coarray support -- corank declarations\n+! PR fortran/18918\n+!\n+\n+subroutine valid(n, c, f)\n+  implicit none\n+  integer :: n\n+  integer, save :: a[*], b(4)[-1:4,*]\n+  real :: c(*)[1,0:3,3:*]\n+  real :: f(n)[0:n,-100:*]\n+  integer, allocatable :: d[:], e(:)[:,:]\n+  integer, save, codimension[1,*] :: g, h(7), i(6)[*], j[*]\n+  integer :: k\n+  codimension :: k[*]\n+  save :: k\n+  integer :: ii = 7\n+  block\n+    integer, save :: kk[ii, *] ! { dg-error \"cannot have the SAVE attribute\" }\n+  end block\n+end subroutine valid\n+\n+subroutine valid2()\n+  type t\n+    integer, allocatable :: a[:]\n+  end type t\n+  type, extends(t) :: tt\n+    integer, allocatable :: b[:]\n+  end type tt\n+  type(tt), save :: foo\n+  type(tt) :: bar ! { dg-error \"is a coarray or has a coarray component\" }\n+end subroutine valid2\n+\n+subroutine invalid(n)\n+  implicit none\n+  integer :: n\n+  integer :: k[*] ! { dg-error \"not ALLOCATABLE, SAVE nor a dummy\" }\n+  integer :: h(3)[*] ! { dg-error \"not ALLOCATABLE, SAVE nor a dummy\" }\n+  integer, save :: a[*]\n+  codimension :: a[1,*] ! { dg-error \"Duplicate CODIMENSION attribute\" }\n+  complex, save :: hh(n)[*] ! { dg-error \"cannot have the SAVE attribute\" }\n+  integer :: j = 6\n+\n+  integer, save :: hf1[j,*] ! { dg-error \"cannot appear in the expression|cannot have the SAVE attribute\" }\n+  integer, save :: hf2[n,*] ! { dg-error \"cannot have the SAVE attribute\" }\n+  integer, save :: hf3(4)[j,*] ! { dg-error \"cannot appear in the expression|cannot have the SAVE attribute\" }\n+  integer, save :: hf4(5)[n,*] ! { dg-error \"cannot have the SAVE attribute\" }\n+\n+  integer, allocatable :: a2[*] ! { dg-error \"must have deferred shape\" }\n+  integer, allocatable :: a3(:)[*] ! { dg-error \"deferred shape and non-deferred coshape\" }\n+  integer, allocatable :: a4[*] ! { dg-error \"must have deferred shape\" }\n+end subroutine invalid\n+\n+subroutine invalid2\n+  use iso_c_binding\n+  implicit none\n+  type t0\n+    integer, allocatable :: a[:,:,:]\n+  end type t0\n+  type t\n+  end type t\n+  type, extends(t) :: tt ! { dg-error \"has a coarray component, parent type\" }\n+    integer, allocatable :: a[:]\n+  end type tt\n+  type ttt\n+    integer, pointer :: a[:] ! { dg-error \"must be allocatable\" }\n+  end type ttt\n+  type t4\n+    integer, allocatable :: b[4,*] ! { dg-error \"with deferred shape\" }\n+  end type t4\n+  type t5\n+    type(c_ptr), allocatable :: p[:] ! { dg-error \"shall not be a coarray\" }\n+  end type t5\n+  type(t0), save :: t0_1[*] ! { dg-error \"shall be a nonpointer, nonallocatable scalar\" }\n+  type(t0), allocatable :: t0_2[:] ! { dg-error \"shall be a nonpointer, nonallocatable scalar\" }\n+  type(c_ptr), save :: pp[*] ! { dg-error \"shall not be a coarray\" }\n+end subroutine invalid2\n+\n+elemental subroutine elem(a) ! { dg-error \"Coarray dummy argument\" }\n+  integer, intent(in) :: a[*]\n+end subroutine\n+\n+function func() result(res)\n+  integer :: res[*] ! { dg-error \"CODIMENSION attribute conflicts with RESULT\" }\n+end function func"}, {"sha": "46aa311f2d694bb82ff02ef6ce546765c21ab496", "filename": "gcc/testsuite/gfortran.dg/coarray_5.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_5.f90?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! Coarray support -- corank declarations\n+! PR fortran/18918\n+!\n+\n+integer :: a, b[*]  ! { dg-error \"Fortran 2008: Coarray declaration\" }\n+codimension :: a[*] ! { dg-error \"Fortran 2008: Coarray declaration\" }\n+end"}, {"sha": "f122fd451f3753d28203dc512cd38713d0f60ccf", "filename": "gcc/testsuite/gfortran.dg/coarray_6.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90?ref=be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do compile }\n+!\n+! Coarray support -- corank declarations\n+! PR fortran/18918\n+!\n+module m2\n+  use iso_c_binding\n+  integer(c_int), bind(C) :: a[*] ! { dg-error \"BIND.C. attribute conflicts with CODIMENSION\" }\n+\n+  type, bind(C) :: t ! { dg-error \"cannot have the ALLOCATABLE\" }\n+    integer(c_int), allocatable :: a[:] ! { dg-error \"cannot have the ALLOCATABLE\" }\n+    integer(c_int)  :: b[*] ! { dg-error \"must be allocatable\" }\n+  end type t\n+end module m2\n+\n+subroutine bind(a) bind(C) ! { dg-error \"Coarray dummy variable\" }\n+  use iso_c_binding\n+  integer(c_int) :: a[*]\n+end subroutine bind\n+\n+subroutine allo(x) ! { dg-error \"can thus not be an allocatable coarray\" }\n+  integer, allocatable, intent(out) :: x[:]\n+end subroutine allo\n+\n+module m\n+  integer :: modvar[*] ! OK, implicit save\n+  type t\n+    complex, allocatable :: b(:,:,:,:)[:,:,:]\n+  end type t\n+end module m\n+\n+subroutine bar()\n+  integer, parameter :: a[*] = 4 ! { dg-error \"PARAMETER attribute conflicts with CODIMENSION\" }\n+  integer, pointer :: b[:] ! { dg-error \"is not ALLOCATABLE, SAVE nor a dummy\" }\n+end subroutine bar\n+\n+subroutine vol()\n+  integer,save :: a[*]\n+  block\n+    volatile :: a ! { dg-error \"Specifying VOLATILE for coarray\" }\n+  end block\n+contains\n+  subroutine int()\n+    volatile :: a ! { dg-error \"Specifying VOLATILE for coarray\" }\n+  end subroutine int\n+end subroutine vol\n+\n+\n+function func() result(func2) ! { dg-error \"shall not be a coarray or have a coarray component\" }\n+  use m\n+  type(t) :: func2\n+end function func\n+\n+program main\n+  integer :: A[*] ! Valid, implicit SAVE attribute\n+end program main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}