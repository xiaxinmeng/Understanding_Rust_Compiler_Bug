{"sha": "c926fd82bbd336b317266d43b9fa67a83397b06b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkyNmZkODJiYmQzMzZiMzE3MjY2ZDQzYjlmYTY3YTgzMzk3YjA2Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2019-12-13T20:04:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-12-13T20:04:47Z"}, "message": "libbacktrace: add DWARF 5 support\n\n\t* dwarf.c (struct attr): Add val field.\n\t(enum attr_val_encoding): Add ATTR_VAL_ADDDRESS_INDEX,\n\tATTR_VAL_STRING_INDEX, ATTR_VAL_RNGLISTS_INDEX.\n\t(struct line_header): Add addrsize field.\n\t(struct line_header_format): Define.\n\t(struct unit): Add str_offsets_base, addr_base, and rnglists_base\n\tfields.\n\t(read_uint24): New static function.\n\t(read_attribute): Add implicit_val parameter.  Replace dwarf_str\n\tand dwarf_str_size parameters with dwarf_sections parameter.  Add\n\tsupport for new DWARF 5 forms.  Change all callers.\n\t(resolve_string): New static function.\n\t(resolve_addr_index): Likewise.\n\t(read_abbrevs): Support DW_FORM_implicit_const.\n\t(struct pcrange): Add lowpc_is_addr_index, highpc_is_addr_Index,\n\tand ranges_is_index fields.\n\t(update_pcrange): Support DWARF 5 encodings.\n\t(add_high_low_range): New static function, split out of\n\tadd_ranges.\n\t(add_ranges_from_ranges): Likewise.\n\t(add_ranges_from_rnglists): New static function.\n\t(add_ranges): Just call new helper functions.\n\t(find_address_ranges): Use resolve_string for strings, after\n\treading all attributes.  Handle new DWARF 5 attributes.\n\t(build_address_map): Support DWARF 5 compilation units.\n\t(read_v2_paths): New static function, split out of\n\tread_line_header.\n\t(read_lnct): New static\tfunction.\n\t(read_line_header_format_entries): Likewise.\n\t(read_line_header): Add ddata parameter.  Support DWARF 5 line\n\theaders.  Call new helper functions.  Change all callers.\n\t(read_line_program): Use addrsize from line program header.  Don't\n\tspecial case directory index 0 for DWARF 5.\n\t(read_referenced_name): Use resolve_string.\n\t(read_function_entry): Handle DWARF 5 encodings.  Use\n\tresolve_string.\n\t* internal.h (enum dwarf_section): Add DEBUG_ADDR,\n\tDEBUG_STR_OFFSETS, DEBUG_LINE_STR, DEBUG_RNGLISTS.\n\t* elf.c (dwarf_section_names): Add new section names.\n\t* pecoff.c (dwarf_section_names): Likewise.\n\t* xcoff.c (xcoff_add): Clear dwarf_sections before setting\n\tfields.\n\t* configure.ac: Define HAVE_DWARF5 automake conditional.\n\t* Makefile.am (dwarf5_SOURCES): New variable if HAVE_DWARF5.\n\t(dwarf5_CFLAGS, dwarf5_LDADD): Likewise.\n\t(dwarf5_alloc_SOURCES, dwarf5_alloc_CFLAGS): Likewise.\n\t(dwarf5_alloc_LDADD): Likewise.\n\t(BUILDTESTS): Add dwarf5 tests if HAVE_DWARF5.\n\t(CLEANFILES, clean-local): Define.\n\nFrom-SVN: r279380", "tree": {"sha": "2f686f2d4657aa570473986e7d0924794093c67b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f686f2d4657aa570473986e7d0924794093c67b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c926fd82bbd336b317266d43b9fa67a83397b06b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c926fd82bbd336b317266d43b9fa67a83397b06b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c926fd82bbd336b317266d43b9fa67a83397b06b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c926fd82bbd336b317266d43b9fa67a83397b06b/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "510873f901ffa34391b4b744c939e6ac33d1e663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/510873f901ffa34391b4b744c939e6ac33d1e663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/510873f901ffa34391b4b744c939e6ac33d1e663"}], "stats": {"total": 1380, "additions": 1213, "deletions": 167}, "files": [{"sha": "b63d216c8c40d35a7e5eb7027c8a19efb34857e4", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -1,3 +1,56 @@\n+2019-12-13  Ian Lance Taylor  <iant@golang.org>\n+\n+\tAdd DWARF 5 support.\n+\t* dwarf.c (struct attr): Add val field.\n+\t(enum attr_val_encoding): Add ATTR_VAL_ADDDRESS_INDEX,\n+\tATTR_VAL_STRING_INDEX, ATTR_VAL_RNGLISTS_INDEX.\n+\t(struct line_header): Add addrsize field.\n+\t(struct line_header_format): Define.\n+\t(struct unit): Add str_offsets_base, addr_base, and rnglists_base\n+\tfields.\n+\t(read_uint24): New static function.\n+\t(read_attribute): Add implicit_val parameter.  Replace dwarf_str\n+\tand dwarf_str_size parameters with dwarf_sections parameter.  Add\n+\tsupport for new DWARF 5 forms.  Change all callers.\n+\t(resolve_string): New static function.\n+\t(resolve_addr_index): Likewise.\n+\t(read_abbrevs): Support DW_FORM_implicit_const.\n+\t(struct pcrange): Add lowpc_is_addr_index, highpc_is_addr_Index,\n+\tand ranges_is_index fields.\n+\t(update_pcrange): Support DWARF 5 encodings.\n+\t(add_high_low_range): New static function, split out of\n+\tadd_ranges.\n+\t(add_ranges_from_ranges): Likewise.\n+\t(add_ranges_from_rnglists): New static function.\n+\t(add_ranges): Just call new helper functions.\n+\t(find_address_ranges): Use resolve_string for strings, after\n+\treading all attributes.  Handle new DWARF 5 attributes.\n+\t(build_address_map): Support DWARF 5 compilation units.\n+\t(read_v2_paths): New static function, split out of\n+\tread_line_header.\n+\t(read_lnct): New static\tfunction.\n+\t(read_line_header_format_entries): Likewise.\n+\t(read_line_header): Add ddata parameter.  Support DWARF 5 line\n+\theaders.  Call new helper functions.  Change all callers.\n+\t(read_line_program): Use addrsize from line program header.  Don't\n+\tspecial case directory index 0 for DWARF 5.\n+\t(read_referenced_name): Use resolve_string.\n+\t(read_function_entry): Handle DWARF 5 encodings.  Use\n+\tresolve_string.\n+\t* internal.h (enum dwarf_section): Add DEBUG_ADDR,\n+\tDEBUG_STR_OFFSETS, DEBUG_LINE_STR, DEBUG_RNGLISTS.\n+\t* elf.c (dwarf_section_names): Add new section names.\n+\t* pecoff.c (dwarf_section_names): Likewise.\n+\t* xcoff.c (xcoff_add): Clear dwarf_sections before setting\n+\tfields.\n+\t* configure.ac: Define HAVE_DWARF5 automake conditional.\n+\t* Makefile.am (dwarf5_SOURCES): New variable if HAVE_DWARF5.\n+\t(dwarf5_CFLAGS, dwarf5_LDADD): Likewise.\n+\t(dwarf5_alloc_SOURCES, dwarf5_alloc_CFLAGS): Likewise.\n+\t(dwarf5_alloc_LDADD): Likewise.\n+\t(BUILDTESTS): Add dwarf5 tests if HAVE_DWARF5.\n+\t(CLEANFILES, clean-local): Define.\n+\n 2019-12-08  Ian Lance Taylor  <iant@golang.org>\n \n \t* dwarf.c (struct pcrange): Define."}, {"sha": "79abcc9174b9096eb554df1110bac62f112b950b", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -385,12 +385,33 @@ BUILDTESTS += ctestg_alloc ctesta_alloc\n \n endif\n \n+if HAVE_DWARF5\n+\n+dwarf5_SOURCES = btest.c testlib.c\n+dwarf5_CFLAGS = $(AM_CFLAGS) -gdwarf-5\n+dwarf5_LDADD = libbacktrace.la\n+\n+BUILDTESTS += dwarf5\n+\n+dwarf5_alloc_SOURCES = $(dwarf5_SOURCES)\n+dwarf5_alloc_CFLAGS = $(dwarf5_CFLAGS)\n+dwarf5_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += dwarf5_alloc\n+\n+endif\n+\n endif NATIVE\n \n check_PROGRAMS += $(BUILDTESTS)\n \n TESTS += $(BUILDTESTS)\n \n+CLEANFILES = $(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build\n+\n+clean-local:\n+\t-rm -rf usr\n+\n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n # with GCC bootstrap will cause some of the objects to depend on"}, {"sha": "01855bfac07691ae653facec102f34f7236bbd46", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 96, "deletions": 16, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -121,10 +121,10 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n-\t$(am__EXEEXT_11)\n+\t$(am__EXEEXT_12)\n TESTS = $(am__append_4) $(am__append_6) $(am__append_8) \\\n \t$(am__append_11) $(am__append_12) $(am__append_18) \\\n-\t$(am__EXEEXT_11)\n+\t$(am__EXEEXT_12)\n @HAVE_ELF_TRUE@@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_1 = libbacktrace_elf_for_test.la\n @NATIVE_TRUE@am__append_2 = test_elf_32 test_elf_64 test_xcoff_32 \\\n @NATIVE_TRUE@\ttest_xcoff_64 test_pecoff test_unknown unittest \\\n@@ -148,6 +148,7 @@ TESTS = $(am__append_4) $(am__append_6) $(am__append_8) \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@am__append_19 = ctestg ctesta \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctestg_alloc \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta_alloc\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__append_20 = dwarf5 dwarf5_alloc\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/cet.m4 \\\n@@ -224,9 +225,11 @@ libbacktrace_noformat_la_OBJECTS =  \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta$(EXEEXT) \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctestg_alloc$(EXEEXT) \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@\tctesta_alloc$(EXEEXT)\n-am__EXEEXT_11 = $(am__EXEEXT_4) $(am__EXEEXT_5) $(am__EXEEXT_6) \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__EXEEXT_11 = dwarf5$(EXEEXT) \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc$(EXEEXT)\n+am__EXEEXT_12 = $(am__EXEEXT_4) $(am__EXEEXT_5) $(am__EXEEXT_6) \\\n \t$(am__EXEEXT_7) $(am__EXEEXT_8) $(am__EXEEXT_9) \\\n-\t$(am__EXEEXT_10)\n+\t$(am__EXEEXT_10) $(am__EXEEXT_11)\n @NATIVE_TRUE@am_allocfail_OBJECTS = allocfail.$(OBJEXT) \\\n @NATIVE_TRUE@\ttestlib.$(OBJEXT)\n allocfail_OBJECTS = $(am_allocfail_OBJECTS)\n@@ -305,20 +308,39 @@ ctestg_alloc_OBJECTS = $(am_ctestg_alloc_OBJECTS)\n ctestg_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ctestg_alloc_CFLAGS) \\\n \t$(CFLAGS) $(ctestg_alloc_LDFLAGS) $(LDFLAGS) -o $@\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am_dwarf5_OBJECTS =  \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5-btest.$(OBJEXT) \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5-testlib.$(OBJEXT)\n+dwarf5_OBJECTS = $(am_dwarf5_OBJECTS)\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_DEPENDENCIES = libbacktrace.la\n+dwarf5_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(dwarf5_CFLAGS) $(CFLAGS) \\\n+\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am__objects_7 =  \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc-btest.$(OBJEXT) \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tdwarf5_alloc-testlib.$(OBJEXT)\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@am_dwarf5_alloc_OBJECTS =  \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\t$(am__objects_7)\n+dwarf5_alloc_OBJECTS = $(am_dwarf5_alloc_OBJECTS)\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_DEPENDENCIES =  \\\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@\tlibbacktrace_alloc.la\n+dwarf5_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(dwarf5_alloc_CFLAGS) \\\n+\t$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n @NATIVE_TRUE@am_edtest_OBJECTS = edtest.$(OBJEXT) \\\n @NATIVE_TRUE@\tedtest2_build.$(OBJEXT) testlib.$(OBJEXT)\n edtest_OBJECTS = $(am_edtest_OBJECTS)\n @NATIVE_TRUE@edtest_DEPENDENCIES = libbacktrace.la\n-@NATIVE_TRUE@am__objects_7 = edtest.$(OBJEXT) edtest2_build.$(OBJEXT) \\\n+@NATIVE_TRUE@am__objects_8 = edtest.$(OBJEXT) edtest2_build.$(OBJEXT) \\\n @NATIVE_TRUE@\ttestlib.$(OBJEXT)\n-@NATIVE_TRUE@am_edtest_alloc_OBJECTS = $(am__objects_7)\n+@NATIVE_TRUE@am_edtest_alloc_OBJECTS = $(am__objects_8)\n edtest_alloc_OBJECTS = $(am_edtest_alloc_OBJECTS)\n @NATIVE_TRUE@edtest_alloc_DEPENDENCIES = libbacktrace_alloc.la\n @NATIVE_TRUE@am_stest_OBJECTS = stest.$(OBJEXT)\n stest_OBJECTS = $(am_stest_OBJECTS)\n @NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n-@NATIVE_TRUE@am__objects_8 = stest.$(OBJEXT)\n-@NATIVE_TRUE@am_stest_alloc_OBJECTS = $(am__objects_8)\n+@NATIVE_TRUE@am__objects_9 = stest.$(OBJEXT)\n+@NATIVE_TRUE@am_stest_alloc_OBJECTS = $(am__objects_9)\n stest_alloc_OBJECTS = $(am_stest_alloc_OBJECTS)\n @NATIVE_TRUE@stest_alloc_DEPENDENCIES = libbacktrace_alloc.la\n @NATIVE_TRUE@am_test_elf_32_OBJECTS = test_format.$(OBJEXT) \\\n@@ -359,11 +381,11 @@ ttest_OBJECTS = $(am_ttest_OBJECTS)\n ttest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ttest_CFLAGS) $(CFLAGS) \\\n \t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__objects_9 =  \\\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__objects_10 =  \\\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tttest_alloc-ttest.$(OBJEXT) \\\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tttest_alloc-testlib.$(OBJEXT)\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am_ttest_alloc_OBJECTS =  \\\n-@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\t$(am__objects_9)\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\t$(am__objects_10)\n ttest_alloc_OBJECTS = $(am_ttest_alloc_OBJECTS)\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_alloc_DEPENDENCIES =  \\\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tlibbacktrace_alloc.la\n@@ -374,8 +396,8 @@ ttest_alloc_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n @NATIVE_TRUE@\ttestlib.$(OBJEXT)\n unittest_OBJECTS = $(am_unittest_OBJECTS)\n @NATIVE_TRUE@unittest_DEPENDENCIES = libbacktrace.la\n-@NATIVE_TRUE@am__objects_10 = unittest.$(OBJEXT) testlib.$(OBJEXT)\n-@NATIVE_TRUE@am_unittest_alloc_OBJECTS = $(am__objects_10)\n+@NATIVE_TRUE@am__objects_11 = unittest.$(OBJEXT) testlib.$(OBJEXT)\n+@NATIVE_TRUE@am_unittest_alloc_OBJECTS = $(am__objects_11)\n unittest_alloc_OBJECTS = $(am_unittest_alloc_OBJECTS)\n @NATIVE_TRUE@unittest_alloc_DEPENDENCIES = libbacktrace_alloc.la\n @HAVE_ELF_TRUE@@NATIVE_TRUE@am_ztest_OBJECTS = ztest-ztest.$(OBJEXT) \\\n@@ -387,11 +409,11 @@ ztest_OBJECTS = $(am_ztest_OBJECTS)\n ztest_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ztest_CFLAGS) $(CFLAGS) \\\n \t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@am__objects_11 =  \\\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@am__objects_12 =  \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tztest_alloc-ztest.$(OBJEXT) \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tztest_alloc-testlib.$(OBJEXT)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@am_ztest_alloc_OBJECTS =  \\\n-@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__objects_11)\n+@HAVE_ELF_TRUE@@NATIVE_TRUE@\t$(am__objects_12)\n ztest_alloc_OBJECTS = $(am_ztest_alloc_OBJECTS)\n @HAVE_ELF_TRUE@@NATIVE_TRUE@ztest_alloc_DEPENDENCIES =  \\\n @HAVE_ELF_TRUE@@NATIVE_TRUE@\tlibbacktrace_alloc.la \\\n@@ -441,7 +463,8 @@ SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n \t$(b2test_SOURCES) $(b3test_SOURCES) $(btest_SOURCES) \\\n \t$(btest_alloc_SOURCES) $(btest_lto_SOURCES) $(ctesta_SOURCES) \\\n \t$(ctesta_alloc_SOURCES) $(ctestg_SOURCES) \\\n-\t$(ctestg_alloc_SOURCES) $(edtest_SOURCES) \\\n+\t$(ctestg_alloc_SOURCES) $(dwarf5_SOURCES) \\\n+\t$(dwarf5_alloc_SOURCES) $(edtest_SOURCES) \\\n \t$(edtest_alloc_SOURCES) $(stest_SOURCES) \\\n \t$(stest_alloc_SOURCES) $(test_elf_32_SOURCES) \\\n \t$(test_elf_64_SOURCES) $(test_pecoff_SOURCES) \\\n@@ -863,7 +886,7 @@ libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n # Add test to this variable, if you want it to be build and run.\n BUILDTESTS = $(am__append_2) $(am__append_9) $(am__append_10) \\\n \t$(am__append_15) $(am__append_16) $(am__append_17) \\\n-\t$(am__append_19)\n+\t$(am__append_19) $(am__append_20)\n @NATIVE_TRUE@check_LTLIBRARIES = libbacktrace_alloc.la \\\n @NATIVE_TRUE@\tlibbacktrace_noformat.la $(am__append_1) \\\n @NATIVE_TRUE@\tlibbacktrace_instrumented_alloc.la\n@@ -960,6 +983,13 @@ BUILDTESTS = $(am__append_2) $(am__append_9) $(am__append_10) \\\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_alloc_CFLAGS = $(ctesta_CFLAGS)\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_alloc_LDFLAGS = $(ctesta_LDFLAGS)\n @HAVE_COMPRESSED_DEBUG_TRUE@@NATIVE_TRUE@ctesta_alloc_LDADD = libbacktrace_alloc.la\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_SOURCES = btest.c testlib.c\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_CFLAGS = $(AM_CFLAGS) -gdwarf-5\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_LDADD = libbacktrace.la\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_SOURCES = $(dwarf5_SOURCES)\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_CFLAGS = $(dwarf5_CFLAGS)\n+@HAVE_DWARF5_TRUE@@NATIVE_TRUE@dwarf5_alloc_LDADD = libbacktrace_alloc.la\n+CLEANFILES = $(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build\n \n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n@@ -1124,6 +1154,14 @@ ctestg_alloc$(EXEEXT): $(ctestg_alloc_OBJECTS) $(ctestg_alloc_DEPENDENCIES) $(EX\n \t@rm -f ctestg_alloc$(EXEEXT)\n \t$(AM_V_CCLD)$(ctestg_alloc_LINK) $(ctestg_alloc_OBJECTS) $(ctestg_alloc_LDADD) $(LIBS)\n \n+dwarf5$(EXEEXT): $(dwarf5_OBJECTS) $(dwarf5_DEPENDENCIES) $(EXTRA_dwarf5_DEPENDENCIES) \n+\t@rm -f dwarf5$(EXEEXT)\n+\t$(AM_V_CCLD)$(dwarf5_LINK) $(dwarf5_OBJECTS) $(dwarf5_LDADD) $(LIBS)\n+\n+dwarf5_alloc$(EXEEXT): $(dwarf5_alloc_OBJECTS) $(dwarf5_alloc_DEPENDENCIES) $(EXTRA_dwarf5_alloc_DEPENDENCIES) \n+\t@rm -f dwarf5_alloc$(EXEEXT)\n+\t$(AM_V_CCLD)$(dwarf5_alloc_LINK) $(dwarf5_alloc_OBJECTS) $(dwarf5_alloc_LDADD) $(LIBS)\n+\n edtest$(EXEEXT): $(edtest_OBJECTS) $(edtest_DEPENDENCIES) $(EXTRA_edtest_DEPENDENCIES) \n \t@rm -f edtest$(EXEEXT)\n \t$(AM_V_CCLD)$(LINK) $(edtest_OBJECTS) $(edtest_LDADD) $(LIBS)\n@@ -1311,6 +1349,30 @@ ctestg_alloc-testlib.o: testlib.c\n ctestg_alloc-testlib.obj: testlib.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ctestg_alloc_CFLAGS) $(CFLAGS) -c -o ctestg_alloc-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n \n+dwarf5-btest.o: btest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_CFLAGS) $(CFLAGS) -c -o dwarf5-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+dwarf5-btest.obj: btest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_CFLAGS) $(CFLAGS) -c -o dwarf5-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+dwarf5-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_CFLAGS) $(CFLAGS) -c -o dwarf5-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+dwarf5-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_CFLAGS) $(CFLAGS) -c -o dwarf5-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n+dwarf5_alloc-btest.o: btest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_alloc_CFLAGS) $(CFLAGS) -c -o dwarf5_alloc-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+dwarf5_alloc-btest.obj: btest.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_alloc_CFLAGS) $(CFLAGS) -c -o dwarf5_alloc-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+dwarf5_alloc-testlib.o: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_alloc_CFLAGS) $(CFLAGS) -c -o dwarf5_alloc-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+dwarf5_alloc-testlib.obj: testlib.c\n+\t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(dwarf5_alloc_CFLAGS) $(CFLAGS) -c -o dwarf5_alloc-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n ttest-ttest.o: ttest.c\n \t$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-ttest.o `test -f 'ttest.c' || echo '$(srcdir)/'`ttest.c\n \n@@ -1771,6 +1833,20 @@ ctesta_alloc.log: ctesta_alloc$(EXEEXT)\n \t--log-file $$b.log --trs-file $$b.trs \\\n \t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n \t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+dwarf5.log: dwarf5$(EXEEXT)\n+\t@p='dwarf5$(EXEEXT)'; \\\n+\tb='dwarf5'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+dwarf5_alloc.log: dwarf5_alloc$(EXEEXT)\n+\t@p='dwarf5_alloc$(EXEEXT)'; \\\n+\tb='dwarf5_alloc'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n .test.log:\n \t@p='$<'; \\\n \t$(am__set_b); \\\n@@ -1816,6 +1892,7 @@ mostlyclean-generic:\n \t-test -z \"$(TEST_SUITE_LOG)\" || rm -f $(TEST_SUITE_LOG)\n \n clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n \n distclean-generic:\n \t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n@@ -1973,6 +2050,9 @@ uninstall-am:\n @NATIVE_TRUE@\t  \"$(TEST_BUILD_ID_DIR)\" \\\n @NATIVE_TRUE@\t  $<\n @NATIVE_TRUE@\t$(OBJCOPY) --strip-debug $< $@\n+\n+clean-local:\n+\t-rm -rf usr\n alloc.lo: config.h backtrace.h internal.h\n backtrace.lo: config.h backtrace.h internal.h\n btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h"}, {"sha": "676adb89224e23a78bf406e02f32edbce8fc1ebc", "filename": "libbacktrace/configure", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -643,6 +643,8 @@ HAVE_COMPRESSED_DEBUG_FALSE\n HAVE_COMPRESSED_DEBUG_TRUE\n HAVE_ZLIB_FALSE\n HAVE_ZLIB_TRUE\n+HAVE_DWARF5_FALSE\n+HAVE_DWARF5_TRUE\n HAVE_PTHREAD_FALSE\n HAVE_PTHREAD_TRUE\n PTHREAD_CFLAGS\n@@ -11497,7 +11499,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11500 \"configure\"\n+#line 11502 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11603,7 +11605,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11606 \"configure\"\n+#line 11608 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13280,6 +13282,36 @@ else\n fi\n \n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether -gdwarf-5 is supported\" >&5\n+$as_echo_n \"checking whether -gdwarf-5 is supported... \" >&6; }\n+if ${libbacktrace_cv_lib_dwarf5+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -gdwarf-5\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+int i;\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libbacktrace_cv_lib_dwarf5=yes\n+else\n+  libbacktrace_cv_lib_dwarf5=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+CFLAGS=$CFLAGS_hold\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libbacktrace_cv_lib_dwarf5\" >&5\n+$as_echo \"$libbacktrace_cv_lib_dwarf5\" >&6; }\n+ if test \"$libbacktrace_cv_lib_dwarf5\" = yes; then\n+  HAVE_DWARF5_TRUE=\n+  HAVE_DWARF5_FALSE='#'\n+else\n+  HAVE_DWARF5_TRUE='#'\n+  HAVE_DWARF5_FALSE=\n+fi\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for compress in -lz\" >&5\n $as_echo_n \"checking for compress in -lz... \" >&6; }\n if ${ac_cv_lib_z_compress+:} false; then :\n@@ -13665,6 +13697,10 @@ if test -z \"${HAVE_PTHREAD_TRUE}\" && test -z \"${HAVE_PTHREAD_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"HAVE_PTHREAD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_DWARF5_TRUE}\" && test -z \"${HAVE_DWARF5_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_DWARF5\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${HAVE_ZLIB_TRUE}\" && test -z \"${HAVE_ZLIB_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"HAVE_ZLIB\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "cda4f09f72e667d205e81ef032cd2d616413489f", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -420,6 +420,17 @@ AC_SUBST(PTHREAD_CFLAGS)\n \n AM_CONDITIONAL(HAVE_PTHREAD, test \"$libgo_cv_lib_pthread\" = yes)\n \n+dnl Test whether the compiler supports the -gdwarf-5 option.\n+AC_CACHE_CHECK([whether -gdwarf-5 is supported],\n+[libbacktrace_cv_lib_dwarf5],\n+[CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -gdwarf-5\"\n+AC_COMPILE_IFELSE([AC_LANG_SOURCE([int i;])],\n+[libbacktrace_cv_lib_dwarf5=yes],\n+[libbacktrace_cv_lib_dwarf5=no])\n+CFLAGS=$CFLAGS_hold])\n+AM_CONDITIONAL(HAVE_DWARF5, test \"$libbacktrace_cv_lib_dwarf5\" = yes)\n+\n AC_CHECK_LIB([z], [compress],\n     [AC_DEFINE(HAVE_ZLIB, 1, [Define if -lz is available.])])\n AM_CONDITIONAL(HAVE_ZLIB, test \"$ac_cv_lib_z_compress\" = yes)"}, {"sha": "d27376860a59f018a54af0a04b1d086691b5256c", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 979, "deletions": 148, "changes": 1127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -92,6 +92,8 @@ struct attr\n   enum dwarf_attribute name;\n   /* The attribute form.  */\n   enum dwarf_form form;\n+  /* The attribute value, for DW_FORM_implicit_const.  */\n+  int64_t val;\n };\n \n /* A single DWARF abbreviation.  */\n@@ -133,22 +135,29 @@ enum attr_val_encoding\n   ATTR_VAL_NONE,\n   /* An address.  */\n   ATTR_VAL_ADDRESS,\n+  /* An index into the .debug_addr section, whose value is relative to\n+   * the DW_AT_addr_base attribute of the compilation unit.  */\n+  ATTR_VAL_ADDRESS_INDEX,\n   /* A unsigned integer.  */\n   ATTR_VAL_UINT,\n   /* A sigd integer.  */\n   ATTR_VAL_SINT,\n   /* A string.  */\n   ATTR_VAL_STRING,\n+  /* An index into the .debug_str_offsets section.  */\n+  ATTR_VAL_STRING_INDEX,\n   /* An offset to other data in the containing unit.  */\n   ATTR_VAL_REF_UNIT,\n-  /* An offset to other data within the .dwarf_info section.  */\n+  /* An offset to other data within the .debug_info section.  */\n   ATTR_VAL_REF_INFO,\n-  /* An offset to other data within the alt .dwarf_info section.  */\n+  /* An offset to other data within the alt .debug_info section.  */\n   ATTR_VAL_REF_ALT_INFO,\n   /* An offset to data in some other section.  */\n   ATTR_VAL_REF_SECTION,\n   /* A type signature.  */\n   ATTR_VAL_REF_TYPE,\n+  /* An index into the .debug_rnglists section.  */\n+  ATTR_VAL_RNGLISTS_INDEX,\n   /* A block of data (not represented).  */\n   ATTR_VAL_BLOCK,\n   /* An expression (not represented).  */\n@@ -163,7 +172,7 @@ struct attr_val\n   enum attr_val_encoding encoding;\n   union\n   {\n-    /* ATTR_VAL_ADDRESS, ATTR_VAL_UINT, ATTR_VAL_REF*.  */\n+    /* ATTR_VAL_ADDRESS*, ATTR_VAL_UINT, ATTR_VAL_REF*.  */\n     uint64_t uint;\n     /* ATTR_VAL_SINT.  */\n     int64_t sint;\n@@ -179,6 +188,8 @@ struct line_header\n {\n   /* The version of the line number information.  */\n   int version;\n+  /* Address size.  */\n+  int addrsize;\n   /* The minimum instruction length.  */\n   unsigned int min_insn_len;\n   /* The maximum number of ops per instruction.  */\n@@ -201,6 +212,14 @@ struct line_header\n   const char **filenames;\n };\n \n+/* A format description from a line header.  */\n+\n+struct line_header_format\n+{\n+  int lnct;\t\t/* LNCT code.  */\n+  enum dwarf_form form;\t/* Form of entry data.  */\n+};\n+\n /* Map a single PC value to a file/line.  We will keep a vector of\n    these sorted by PC value.  Each file/line will be correct from the\n    PC up to the PC of the next entry if there is one.  We allocate one\n@@ -297,6 +316,12 @@ struct unit\n   int addrsize;\n   /* Offset into line number information.  */\n   off_t lineoff;\n+  /* Offset of compilation unit in .debug_str_offsets.  */\n+  uint64_t str_offsets_base;\n+  /* Offset of compilation unit in .debug_addr.  */\n+  uint64_t addr_base;\n+  /* Offset of compilation unit in .debug_rnglists.  */\n+  uint64_t rnglists_base;\n   /* Primary source file.  */\n   const char *filename;\n   /* Compilation command working directory.  */\n@@ -483,6 +508,23 @@ read_uint16 (struct dwarf_buf *buf)\n     return ((uint16_t) p[1] << 8) | (uint16_t) p[0];\n }\n \n+/* Read a 24 bit value from BUF and advance 3 bytes.  */\n+\n+static uint32_t\n+read_uint24 (struct dwarf_buf *buf)\n+{\n+  const unsigned char *p = buf->buf;\n+\n+  if (!advance (buf, 3))\n+    return 0;\n+  if (buf->is_bigendian)\n+    return (((uint32_t) p[0] << 16) | ((uint32_t) p[1] << 8)\n+\t    | (uint32_t) p[2]);\n+  else\n+    return (((uint32_t) p[2] << 16) | ((uint32_t) p[1] << 8)\n+\t    | (uint32_t) p[0]);\n+}\n+\n /* Read a uint32 from BUF and advance 4 bytes.  */\n \n static uint32_t\n@@ -709,9 +751,9 @@ free_abbrevs (struct backtrace_state *state, struct abbrevs *abbrevs,\n    forms, because we don't care about them.  */\n \n static int\n-read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n-\t\tint is_dwarf64, int version, int addrsize,\n-\t\tconst unsigned char *dwarf_str, size_t dwarf_str_size,\n+read_attribute (enum dwarf_form form, uint64_t implicit_val,\n+\t\tstruct dwarf_buf *buf, int is_dwarf64, int version,\n+\t\tint addrsize, const struct dwarf_sections *dwarf_sections,\n \t\tstruct dwarf_data *altlink, struct attr_val *val)\n {\n   /* Avoid warnings about val.u.FIELD may be used uninitialized if\n@@ -744,6 +786,9 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n       val->encoding = ATTR_VAL_UINT;\n       val->u.uint = read_uint64 (buf);\n       return 1;\n+    case DW_FORM_data16:\n+      val->encoding = ATTR_VAL_BLOCK;\n+      return advance (buf, 16);\n     case DW_FORM_string:\n       val->encoding = ATTR_VAL_STRING;\n       val->u.string = read_string (buf);\n@@ -771,13 +816,29 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n \tuint64_t offset;\n \n \toffset = read_offset (buf, is_dwarf64);\n-\tif (offset >= dwarf_str_size)\n+\tif (offset >= dwarf_sections->size[DEBUG_STR])\n \t  {\n \t    dwarf_buf_error (buf, \"DW_FORM_strp out of range\");\n \t    return 0;\n \t  }\n \tval->encoding = ATTR_VAL_STRING;\n-\tval->u.string = (const char *) dwarf_str + offset;\n+\tval->u.string =\n+\t  (const char *) dwarf_sections->data[DEBUG_STR] + offset;\n+\treturn 1;\n+      }\n+    case DW_FORM_line_strp:\n+      {\n+\tuint64_t offset;\n+\n+\toffset = read_offset (buf, is_dwarf64);\n+\tif (offset >= dwarf_sections->size[DEBUG_LINE_STR])\n+\t  {\n+\t    dwarf_buf_error (buf, \"DW_FORM_line_strp out of range\");\n+\t    return 0;\n+\t  }\n+\tval->encoding = ATTR_VAL_STRING;\n+\tval->u.string =\n+\t  (const char *) dwarf_sections->data[DEBUG_LINE_STR] + offset;\n \treturn 1;\n       }\n     case DW_FORM_udata:\n@@ -816,9 +877,15 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n \tuint64_t form;\n \n \tform = read_uleb128 (buf);\n-\treturn read_attribute ((enum dwarf_form) form, buf, is_dwarf64,\n-\t\t\t       version, addrsize, dwarf_str, dwarf_str_size,\n-\t\t\t       altlink, val);\n+\tif (form == DW_FORM_implicit_const)\n+\t  {\n+\t    dwarf_buf_error (buf,\n+\t\t\t     \"DW_FORM_indirect to DW_FORM_implicit_const\");\n+\t    return 0;\n+\t  }\n+\treturn read_attribute ((enum dwarf_form) form, 0, buf, is_dwarf64,\n+\t\t\t       version, addrsize, dwarf_sections, altlink,\n+\t\t\t       val);\n       }\n     case DW_FORM_sec_offset:\n       val->encoding = ATTR_VAL_REF_SECTION;\n@@ -835,6 +902,88 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n       val->encoding = ATTR_VAL_REF_TYPE;\n       val->u.uint = read_uint64 (buf);\n       return 1;\n+    case DW_FORM_strx: case DW_FORM_strx1: case DW_FORM_strx2:\n+    case DW_FORM_strx3: case DW_FORM_strx4:\n+      {\n+\tuint64_t offset;\n+\n+\tswitch (form)\n+\t  {\n+\t  case DW_FORM_strx:\n+\t    offset = read_uleb128 (buf);\n+\t    break;\n+\t  case DW_FORM_strx1:\n+\t    offset = read_byte (buf);\n+\t    break;\n+\t  case DW_FORM_strx2:\n+\t    offset = read_uint16 (buf);\n+\t    break;\n+\t  case DW_FORM_strx3:\n+\t    offset = read_uint24 (buf);\n+\t    break;\n+\t  case DW_FORM_strx4:\n+\t    offset = read_uint32 (buf);\n+\t    break;\n+\t  default:\n+\t    /* This case can't happen.  */\n+\t    return 0;\n+\t  }\n+\tval->encoding = ATTR_VAL_STRING_INDEX;\n+\tval->u.uint = offset;\n+\treturn 1;\n+      }\n+    case DW_FORM_addrx: case DW_FORM_addrx1: case DW_FORM_addrx2:\n+    case DW_FORM_addrx3: case DW_FORM_addrx4:\n+      {\n+\tuint64_t offset;\n+\n+\tswitch (form)\n+\t  {\n+\t  case DW_FORM_addrx:\n+\t    offset = read_uleb128 (buf);\n+\t    break;\n+\t  case DW_FORM_addrx1:\n+\t    offset = read_byte (buf);\n+\t    break;\n+\t  case DW_FORM_addrx2:\n+\t    offset = read_uint16 (buf);\n+\t    break;\n+\t  case DW_FORM_addrx3:\n+\t    offset = read_uint24 (buf);\n+\t    break;\n+\t  case DW_FORM_addrx4:\n+\t    offset = read_uint32 (buf);\n+\t    break;\n+\t  default:\n+\t    /* This case can't happen.  */\n+\t    return 0;\n+\t  }\n+\tval->encoding = ATTR_VAL_ADDRESS_INDEX;\n+\tval->u.uint = offset;\n+\treturn 1;\n+      }\n+    case DW_FORM_ref_sup4:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_uint32 (buf);\n+      return 1;\n+    case DW_FORM_ref_sup8:\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_uint64 (buf);\n+      return 1;\n+    case DW_FORM_implicit_const:\n+      val->encoding = ATTR_VAL_UINT;\n+      val->u.uint = implicit_val;\n+      return 1;\n+    case DW_FORM_loclistx:\n+      /* We don't distinguish this from DW_FORM_sec_offset.  It\n+       * shouldn't matter since we don't care about loclists.  */\n+      val->encoding = ATTR_VAL_REF_SECTION;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n+    case DW_FORM_rnglistx:\n+      val->encoding = ATTR_VAL_RNGLISTS_INDEX;\n+      val->u.uint = read_uleb128 (buf);\n+      return 1;\n     case DW_FORM_GNU_addr_index:\n       val->encoding = ATTR_VAL_REF_SECTION;\n       val->u.uint = read_uleb128 (buf);\n@@ -852,9 +1001,10 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n \t}\n       val->encoding = ATTR_VAL_REF_ALT_INFO;\n       return 1;\n-    case DW_FORM_GNU_strp_alt:\n+    case DW_FORM_strp_sup: case DW_FORM_GNU_strp_alt:\n       {\n \tuint64_t offset;\n+\n \toffset = read_offset (buf, is_dwarf64);\n \tif (altlink == NULL)\n \t  {\n@@ -863,7 +1013,7 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n \t  }\n \tif (offset >= altlink->dwarf_sections.size[DEBUG_STR])\n \t  {\n-\t    dwarf_buf_error (buf, \"DW_FORM_GNU_strp_alt out of range\");\n+\t    dwarf_buf_error (buf, \"DW_FORM_strp_sup out of range\");\n \t    return 0;\n \t  }\n \tval->encoding = ATTR_VAL_STRING;\n@@ -877,6 +1027,95 @@ read_attribute (enum dwarf_form form, struct dwarf_buf *buf,\n     }\n }\n \n+/* If we can determine the value of a string attribute, set *STRING to\n+   point to the string.  Return 1 on success, 0 on error.  If we don't\n+   know the value, we consider that a success, and we don't change\n+   *STRING.  An error is only reported for some sort of out of range\n+   offset.  */\n+\n+static int\n+resolve_string (const struct dwarf_sections *dwarf_sections, int is_dwarf64,\n+\t\tint is_bigendian, uint64_t str_offsets_base,\n+\t\tconst struct attr_val *val,\n+\t\tbacktrace_error_callback error_callback, void *data,\n+\t\tconst char **string)\n+{\n+  switch (val->encoding)\n+    {\n+    case ATTR_VAL_STRING:\n+      *string = val->u.string;\n+      return 1;\n+\n+    case ATTR_VAL_STRING_INDEX:\n+      {\n+\tuint64_t offset;\n+\tstruct dwarf_buf offset_buf;\n+\n+\toffset = val->u.uint * (is_dwarf64 ? 8 : 4) + str_offsets_base;\n+\tif (offset + (is_dwarf64 ? 8 : 4)\n+\t    >= dwarf_sections->size[DEBUG_STR_OFFSETS])\n+\t  {\n+\t    error_callback (data, \"DW_FORM_strx value out of range\", 0);\n+\t    return 0;\n+\t  }\n+\n+\toffset_buf.name = \".debug_str_offsets\";\n+\toffset_buf.start = dwarf_sections->data[DEBUG_STR_OFFSETS];\n+\toffset_buf.buf = dwarf_sections->data[DEBUG_STR_OFFSETS] + offset;\n+\toffset_buf.left = dwarf_sections->size[DEBUG_STR_OFFSETS] - offset;\n+\toffset_buf.is_bigendian = is_bigendian;\n+\toffset_buf.error_callback = error_callback;\n+\toffset_buf.data = data;\n+\toffset_buf.reported_underflow = 0;\n+\n+\toffset = read_offset (&offset_buf, is_dwarf64);\n+\tif (offset >= dwarf_sections->size[DEBUG_STR])\n+\t  {\n+\t    dwarf_buf_error (&offset_buf, \"DW_FORM_strx offset out of range\");\n+\t    return 0;\n+\t  }\n+\t*string = (const char *) dwarf_sections->data[DEBUG_STR] + offset;\n+\treturn 1;\n+      }\n+\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Set *ADDRESS to the real address for a ATTR_VAL_ADDRESS_INDEX.\n+   Return 1 on success, 0 on error.  */\n+\n+static int\n+resolve_addr_index (const struct dwarf_sections *dwarf_sections,\n+\t\t    uint64_t addr_base, int addrsize, int is_bigendian,\n+\t\t    uint64_t addr_index,\n+\t\t    backtrace_error_callback error_callback, void *data,\n+\t\t    uint64_t *address)\n+{\n+  uint64_t offset;\n+  struct dwarf_buf addr_buf;\n+\n+  offset = addr_index * addrsize + addr_base;\n+  if (offset + addrsize >= dwarf_sections->size[DEBUG_ADDR])\n+    {\n+      error_callback (data, \"DW_FORM_addrx value out of range\", 0);\n+      return 0;\n+    }\n+\n+  addr_buf.name = \".debug_addr\";\n+  addr_buf.start = dwarf_sections->data[DEBUG_ADDR];\n+  addr_buf.buf = dwarf_sections->data[DEBUG_ADDR] + offset;\n+  addr_buf.left = dwarf_sections->size[DEBUG_ADDR] - offset;\n+  addr_buf.is_bigendian = is_bigendian;\n+  addr_buf.error_callback = error_callback;\n+  addr_buf.data = data;\n+  addr_buf.reported_underflow = 0;\n+\n+  *address = read_address (&addr_buf, addrsize);\n+  return 1;\n+}\n+\n /* Compare a unit offset against a unit for bsearch.  */\n \n static int\n@@ -1142,7 +1381,13 @@ read_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n       read_byte (&count_buf);\n       // Skip attributes.\n       while (read_uleb128 (&count_buf) != 0)\n-\tread_uleb128 (&count_buf);\n+\t{\n+\t  uint64_t form;\n+\n+\t  form = read_uleb128 (&count_buf);\n+\t  if ((enum dwarf_form) form == DW_FORM_implicit_const)\n+\t    read_sleb128 (&count_buf);\n+\t}\n       // Skip form of last attribute.\n       read_uleb128 (&count_buf);\n     }\n@@ -1185,8 +1430,12 @@ read_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n       num_attrs = 0;\n       while (read_uleb128 (&count_buf) != 0)\n \t{\n+\t  uint64_t form;\n+\n \t  ++num_attrs;\n-\t  read_uleb128 (&count_buf);\n+\t  form = read_uleb128 (&count_buf);\n+\t  if ((enum dwarf_form) form == DW_FORM_implicit_const)\n+\t    read_sleb128 (&count_buf);\n \t}\n \n       if (num_attrs == 0)\n@@ -1214,6 +1463,10 @@ read_abbrevs (struct backtrace_state *state, uint64_t abbrev_offset,\n \t\tbreak;\n \t      attrs[num_attrs].name = (enum dwarf_attribute) name;\n \t      attrs[num_attrs].form = (enum dwarf_form) form;\n+\t      if ((enum dwarf_form) form == DW_FORM_implicit_const)\n+\t\tattrs[num_attrs].val = read_sleb128 (&abbrev_buf);\n+\t      else\n+\t\tattrs[num_attrs].val = 0;\n \t      ++num_attrs;\n \t    }\n \t}\n@@ -1272,11 +1525,14 @@ lookup_abbrev (struct abbrevs *abbrevs, uint64_t code,\n struct pcrange {\n   uint64_t lowpc;\t\t/* The low PC value.  */\n   int have_lowpc;\t\t/* Whether a low PC value was found.  */\n+  int lowpc_is_addr_index;\t/* Whether lowpc is in .debug_addr.  */\n   uint64_t highpc;\t\t/* The high PC value.  */\n   int have_highpc;\t\t/* Whether a high PC value was found.  */\n   int highpc_is_relative;\t/* Whether highpc is relative to lowpc.  */\n+  int highpc_is_addr_index;\t/* Whether highpc is in .debug_addr.  */\n   uint64_t ranges;\t\t/* Offset in ranges section.  */\n   int have_ranges;\t\t/* Whether ranges is valid.  */\n+  int ranges_is_index;\t\t/* Whether ranges is DW_FORM_rnglistx.  */\n };\n \n /* Update PCRANGE from an attribute value.  */\n@@ -1293,6 +1549,12 @@ update_pcrange (const struct attr* attr, const struct attr_val* val,\n \t  pcrange->lowpc = val->u.uint;\n \t  pcrange->have_lowpc = 1;\n \t}\n+      else if (val->encoding == ATTR_VAL_ADDRESS_INDEX)\n+\t{\n+\t  pcrange->lowpc = val->u.uint;\n+\t  pcrange->have_lowpc = 1;\n+\t  pcrange->lowpc_is_addr_index = 1;\n+\t}\n       break;\n \n     case DW_AT_high_pc:\n@@ -1307,6 +1569,12 @@ update_pcrange (const struct attr* attr, const struct attr_val* val,\n \t  pcrange->have_highpc = 1;\n \t  pcrange->highpc_is_relative = 1;\n \t}\n+      else if (val->encoding == ATTR_VAL_ADDRESS_INDEX)\n+\t{\n+\t  pcrange->highpc = val->u.uint;\n+\t  pcrange->have_highpc = 1;\n+\t  pcrange->highpc_is_addr_index = 1;\n+\t}\n       break;\n \n     case DW_AT_ranges:\n@@ -1316,58 +1584,86 @@ update_pcrange (const struct attr* attr, const struct attr_val* val,\n \t  pcrange->ranges = val->u.uint;\n \t  pcrange->have_ranges = 1;\n \t}\n+      else if (val->encoding == ATTR_VAL_RNGLISTS_INDEX)\n+\t{\n+\t  pcrange->ranges = val->u.uint;\n+\t  pcrange->have_ranges = 1;\n+\t  pcrange->ranges_is_index = 1;\n+\t}\n       break;\n \n     default:\n       break;\n     }\n }\n \n-/* Call ADD_RANGE for each lowpc/highpc pair in PCRANGE.  RDATA is\n-   passed to ADD_RANGE, and is either a struct unit * or a struct\n-   function *.  VEC is the vector we are adding ranges to, and is\n-   either a struct unit_addrs_vector * or a struct function_vector *.\n-   Returns 1 on success, 0 on error.  */\n+/* Call ADD_RANGE for a low/high PC pair.  Returns 1 on success, 0 on\n+  error.  */\n \n static int\n-add_ranges (struct backtrace_state *state,\n-\t    const struct dwarf_sections *dwarf_sections,\n-\t    uintptr_t base_address, int is_bigendian,\n-\t    struct unit *u, uint64_t base, const struct pcrange *pcrange,\n-\t    int (*add_range) (struct backtrace_state *state, void *rdata, \n-\t\t\t      uint64_t lowpc, uint64_t highpc,\n-\t\t\t      backtrace_error_callback error_callback,\n-\t\t\t      void *data, void *vec),\n-\t    void *rdata,\n-\t    backtrace_error_callback error_callback, void *data,\n-\t    void *vec)\n+add_low_high_range (struct backtrace_state *state,\n+\t\t    const struct dwarf_sections *dwarf_sections,\n+\t\t    uintptr_t base_address, int is_bigendian,\n+\t\t    struct unit *u, const struct pcrange *pcrange,\n+\t\t    int (*add_range) (struct backtrace_state *state,\n+\t\t\t\t      void *rdata, uint64_t lowpc,\n+\t\t\t\t      uint64_t highpc,\n+\t\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t\t      void *data, void *vec),\n+\t\t    void *rdata,\n+\t\t    backtrace_error_callback error_callback, void *data,\n+\t\t    void *vec)\n {\n-  struct dwarf_buf ranges_buf;\n+  uint64_t lowpc;\n+  uint64_t highpc;\n \n-  if (pcrange->have_lowpc && pcrange->have_highpc)\n+  lowpc = pcrange->lowpc;\n+  if (pcrange->lowpc_is_addr_index)\n     {\n-      uint64_t lowpc;\n-      uint64_t highpc;\n-\n-      lowpc = pcrange->lowpc;\n-      highpc = pcrange->highpc;\n-      if (pcrange->highpc_is_relative)\n-\thighpc += lowpc;\n-\n-      /* Add in the base address of the module when recording PC\n-\t values, so that we can look up the PC directly.  */\n-      lowpc += base_address;\n-      highpc += base_address;\n-\n-      return add_range (state, rdata, lowpc, highpc, error_callback, data,\n-\t\t\tvec);\n+      if (!resolve_addr_index (dwarf_sections, u->addr_base, u->addrsize,\n+\t\t\t       is_bigendian, lowpc, error_callback, data,\n+\t\t\t       &lowpc))\n+\treturn 0;\n     }\n \n-  if (!pcrange->have_ranges)\n+  highpc = pcrange->highpc;\n+  if (pcrange->highpc_is_addr_index)\n     {\n-      /* Did not find any address ranges to add.  */\n-      return 1;\n+      if (!resolve_addr_index (dwarf_sections, u->addr_base, u->addrsize,\n+\t\t\t       is_bigendian, highpc, error_callback, data,\n+\t\t\t       &highpc))\n+\treturn 0;\n     }\n+  if (pcrange->highpc_is_relative)\n+    highpc += lowpc;\n+\n+  /* Add in the base address of the module when recording PC values,\n+     so that we can look up the PC directly.  */\n+  lowpc += base_address;\n+  highpc += base_address;\n+\n+  return add_range (state, rdata, lowpc, highpc, error_callback, data, vec);\n+}\n+\n+/* Call ADD_RANGE for each range read from .debug_ranges, as used in\n+   DWARF versions 2 through 4.  */\n+\n+static int\n+add_ranges_from_ranges (\n+    struct backtrace_state *state,\n+    const struct dwarf_sections *dwarf_sections,\n+    uintptr_t base_address, int is_bigendian,\n+    struct unit *u, uint64_t base,\n+    const struct pcrange *pcrange,\n+    int (*add_range) (struct backtrace_state *state, void *rdata,\n+\t\t      uint64_t lowpc, uint64_t highpc,\n+\t\t      backtrace_error_callback error_callback, void *data,\n+\t\t      void *vec),\n+    void *rdata,\n+    backtrace_error_callback error_callback, void *data,\n+    void *vec)\n+{\n+  struct dwarf_buf ranges_buf;\n \n   if (pcrange->ranges >= dwarf_sections->size[DEBUG_RANGES])\n     {\n@@ -1416,6 +1712,220 @@ add_ranges (struct backtrace_state *state,\n   return 1;\n }\n \n+/* Call ADD_RANGE for each range read from .debug_rnglists, as used in\n+   DWARF version 5.  */\n+\n+static int\n+add_ranges_from_rnglists (\n+    struct backtrace_state *state,\n+    const struct dwarf_sections *dwarf_sections,\n+    uintptr_t base_address, int is_bigendian,\n+    struct unit *u, uint64_t base,\n+    const struct pcrange *pcrange,\n+    int (*add_range) (struct backtrace_state *state, void *rdata,\n+\t\t      uint64_t lowpc, uint64_t highpc,\n+\t\t      backtrace_error_callback error_callback, void *data,\n+\t\t      void *vec),\n+    void *rdata,\n+    backtrace_error_callback error_callback, void *data,\n+    void *vec)\n+{\n+  uint64_t offset;\n+  struct dwarf_buf rnglists_buf;\n+\n+  if (!pcrange->ranges_is_index)\n+    offset = pcrange->ranges;\n+  else\n+    offset = u->rnglists_base + pcrange->ranges * (u->is_dwarf64 ? 8 : 4);\n+  if (offset >= dwarf_sections->size[DEBUG_RNGLISTS])\n+    {\n+      error_callback (data, \"rnglists offset out of range\", 0);\n+      return 0;\n+    }\n+\n+  rnglists_buf.name = \".debug_rnglists\";\n+  rnglists_buf.start = dwarf_sections->data[DEBUG_RNGLISTS];\n+  rnglists_buf.buf = dwarf_sections->data[DEBUG_RNGLISTS] + offset;\n+  rnglists_buf.left = dwarf_sections->size[DEBUG_RNGLISTS] - offset;\n+  rnglists_buf.is_bigendian = is_bigendian;\n+  rnglists_buf.error_callback = error_callback;\n+  rnglists_buf.data = data;\n+  rnglists_buf.reported_underflow = 0;\n+\n+  if (pcrange->ranges_is_index)\n+    {\n+      offset = read_offset (&rnglists_buf, u->is_dwarf64);\n+      offset += u->rnglists_base;\n+      if (offset >= dwarf_sections->size[DEBUG_RNGLISTS])\n+\t{\n+\t  error_callback (data, \"rnglists index offset out of range\", 0);\n+\t  return 0;\n+\t}\n+      rnglists_buf.buf = dwarf_sections->data[DEBUG_RNGLISTS] + offset;\n+      rnglists_buf.left = dwarf_sections->size[DEBUG_RNGLISTS] - offset;\n+    }\n+\n+  while (1)\n+    {\n+      unsigned char rle;\n+\n+      rle = read_byte (&rnglists_buf);\n+      if (rle == DW_RLE_end_of_list)\n+\tbreak;\n+      switch (rle)\n+\t{\n+\tcase DW_RLE_base_addressx:\n+\t  {\n+\t    uint64_t index;\n+\n+\t    index = read_uleb128 (&rnglists_buf);\n+\t    if (!resolve_addr_index (dwarf_sections, u->addr_base,\n+\t\t\t\t     u->addrsize, is_bigendian, index,\n+\t\t\t\t     error_callback, data, &base))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tcase DW_RLE_startx_endx:\n+\t  {\n+\t    uint64_t index;\n+\t    uint64_t low;\n+\t    uint64_t high;\n+\n+\t    index = read_uleb128 (&rnglists_buf);\n+\t    if (!resolve_addr_index (dwarf_sections, u->addr_base,\n+\t\t\t\t     u->addrsize, is_bigendian, index,\n+\t\t\t\t     error_callback, data, &low))\n+\t      return 0;\n+\t    index = read_uleb128 (&rnglists_buf);\n+\t    if (!resolve_addr_index (dwarf_sections, u->addr_base,\n+\t\t\t\t     u->addrsize, is_bigendian, index,\n+\t\t\t\t     error_callback, data, &high))\n+\t      return 0;\n+\t    if (!add_range (state, rdata, low + base_address,\n+\t\t\t    high + base_address, error_callback, data,\n+\t\t\t    vec))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tcase DW_RLE_startx_length:\n+\t  {\n+\t    uint64_t index;\n+\t    uint64_t low;\n+\t    uint64_t length;\n+\n+\t    index = read_uleb128 (&rnglists_buf);\n+\t    if (!resolve_addr_index (dwarf_sections, u->addr_base,\n+\t\t\t\t     u->addrsize, is_bigendian, index,\n+\t\t\t\t     error_callback, data, &low))\n+\t      return 0;\n+\t    length = read_uleb128 (&rnglists_buf);\n+\t    low += base_address;\n+\t    if (!add_range (state, rdata, low, low + length,\n+\t\t\t    error_callback, data, vec))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tcase DW_RLE_offset_pair:\n+\t  {\n+\t    uint64_t low;\n+\t    uint64_t high;\n+\n+\t    low = read_uleb128 (&rnglists_buf);\n+\t    high = read_uleb128 (&rnglists_buf);\n+\t    if (!add_range (state, rdata, low + base + base_address,\n+\t\t\t    high + base + base_address,\n+\t\t\t    error_callback, data, vec))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tcase DW_RLE_base_address:\n+\t  base = read_address (&rnglists_buf, u->addrsize);\n+\t  break;\n+\n+\tcase DW_RLE_start_end:\n+\t  {\n+\t    uint64_t low;\n+\t    uint64_t high;\n+\n+\t    low = read_address (&rnglists_buf, u->addrsize);\n+\t    high = read_address (&rnglists_buf, u->addrsize);\n+\t    if (!add_range (state, rdata, low + base_address,\n+\t\t\t    high + base_address, error_callback, data,\n+\t\t\t    vec))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tcase DW_RLE_start_length:\n+\t  {\n+\t    uint64_t low;\n+\t    uint64_t length;\n+\n+\t    low = read_address (&rnglists_buf, u->addrsize);\n+\t    length = read_uleb128 (&rnglists_buf);\n+\t    low += base_address;\n+\t    if (!add_range (state, rdata, low, low + length,\n+\t\t\t    error_callback, data, vec))\n+\t      return 0;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  dwarf_buf_error (&rnglists_buf, \"unrecognized DW_RLE value\");\n+\t  return 0;\n+\t}\n+    }\n+\n+  if (rnglists_buf.reported_underflow)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Call ADD_RANGE for each lowpc/highpc pair in PCRANGE.  RDATA is\n+   passed to ADD_RANGE, and is either a struct unit * or a struct\n+   function *.  VEC is the vector we are adding ranges to, and is\n+   either a struct unit_addrs_vector * or a struct function_vector *.\n+   Returns 1 on success, 0 on error.  */\n+\n+static int\n+add_ranges (struct backtrace_state *state,\n+\t    const struct dwarf_sections *dwarf_sections,\n+\t    uintptr_t base_address, int is_bigendian,\n+\t    struct unit *u, uint64_t base, const struct pcrange *pcrange,\n+\t    int (*add_range) (struct backtrace_state *state, void *rdata, \n+\t\t\t      uint64_t lowpc, uint64_t highpc,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data, void *vec),\n+\t    void *rdata,\n+\t    backtrace_error_callback error_callback, void *data,\n+\t    void *vec)\n+{\n+  if (pcrange->have_lowpc && pcrange->have_highpc)\n+    return add_low_high_range (state, dwarf_sections, base_address,\n+\t\t\t       is_bigendian, u, pcrange, add_range, rdata,\n+\t\t\t       error_callback, data, vec);\n+\n+  if (!pcrange->have_ranges)\n+    {\n+      /* Did not find any address ranges to add.  */\n+      return 1;\n+    }\n+\n+  if (u->version < 5)\n+    return add_ranges_from_ranges (state, dwarf_sections, base_address,\n+\t\t\t\t   is_bigendian, u, base, pcrange, add_range,\n+\t\t\t\t   rdata, error_callback, data, vec);\n+  else\n+    return add_ranges_from_rnglists (state, dwarf_sections, base_address,\n+\t\t\t\t     is_bigendian, u, base, pcrange, add_range,\n+\t\t\t\t     rdata, error_callback, data, vec);\n+}\n+\n /* Find the address range covered by a compilation unit, reading from\n    UNIT_BUF and adding values to U.  Returns 1 if all data could be\n    read, 0 if there is some error.  */\n@@ -1434,6 +1944,10 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n       uint64_t code;\n       const struct abbrev *abbrev;\n       struct pcrange pcrange;\n+      struct attr_val name_val;\n+      int have_name_val;\n+      struct attr_val comp_dir_val;\n+      int have_comp_dir_val;\n       size_t i;\n \n       code = read_uleb128 (unit_buf);\n@@ -1448,15 +1962,17 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n \t*unit_tag = abbrev->tag;\n \n       memset (&pcrange, 0, sizeof pcrange);\n+      memset (&name_val, 0, sizeof name_val);\n+      have_name_val = 0;\n+      memset (&comp_dir_val, 0, sizeof comp_dir_val);\n+      have_comp_dir_val = 0;\n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n \t  struct attr_val val;\n \n-\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n-\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n-\t\t\t       dwarf_sections->data[DEBUG_STR],\n-\t\t\t       dwarf_sections->size[DEBUG_STR],\n-\t\t\t       altlink, &val))\n+\t  if (!read_attribute (abbrev->attrs[i].form, abbrev->attrs[i].val,\n+\t\t\t       unit_buf, u->is_dwarf64, u->version,\n+\t\t\t       u->addrsize, dwarf_sections, altlink, &val))\n \t    return 0;\n \n \t  switch (abbrev->attrs[i].name)\n@@ -1473,22 +1989,61 @@ find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n \t      break;\n \n \t    case DW_AT_name:\n-\t      if (abbrev->tag == DW_TAG_compile_unit\n-\t\t  && val.encoding == ATTR_VAL_STRING)\n-\t\tu->filename = val.u.string;\n+\t      if (abbrev->tag == DW_TAG_compile_unit)\n+\t\t{\n+\t\t  name_val = val;\n+\t\t  have_name_val = 1;\n+\t\t}\n \t      break;\n \n \t    case DW_AT_comp_dir:\n+\t      if (abbrev->tag == DW_TAG_compile_unit)\n+\t\t{\n+\t\t  comp_dir_val = val;\n+\t\t  have_comp_dir_val = 1;\n+\t\t}\n+\t      break;\n+\n+\t    case DW_AT_str_offsets_base:\n \t      if (abbrev->tag == DW_TAG_compile_unit\n-\t\t  && val.encoding == ATTR_VAL_STRING)\n-\t\tu->comp_dir = val.u.string;\n+\t\t  && val.encoding == ATTR_VAL_REF_SECTION)\n+\t\tu->str_offsets_base = val.u.uint;\n+\t      break;\n+\n+\t    case DW_AT_addr_base:\n+\t      if (abbrev->tag == DW_TAG_compile_unit\n+\t\t  && val.encoding == ATTR_VAL_REF_SECTION)\n+\t\tu->addr_base = val.u.uint;\n+\t      break;\n+\n+\t    case DW_AT_rnglists_base:\n+\t      if (abbrev->tag == DW_TAG_compile_unit\n+\t\t  && val.encoding == ATTR_VAL_REF_SECTION)\n+\t\tu->rnglists_base = val.u.uint;\n \t      break;\n \n \t    default:\n \t      break;\n \t    }\n \t}\n \n+      // Resolve strings after we're sure that we have seen\n+      // DW_AT_str_offsets_base.\n+      if (have_name_val)\n+\t{\n+\t  if (!resolve_string (dwarf_sections, u->is_dwarf64, is_bigendian,\n+\t\t\t       u->str_offsets_base, &name_val,\n+\t\t\t       error_callback, data, &u->filename))\n+\t    return 0;\n+\t}\n+      if (have_comp_dir_val)\n+\t{\n+\t  if (!resolve_string (dwarf_sections, u->is_dwarf64, is_bigendian,\n+\t\t\t       u->str_offsets_base, &comp_dir_val,\n+\t\t\t       error_callback, data, &u->comp_dir))\n+\t    return 0;\n+\t}\n+\n       if (abbrev->tag == DW_TAG_compile_unit\n \t  || abbrev->tag == DW_TAG_subprogram)\n \t{\n@@ -1565,6 +2120,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n       int is_dwarf64;\n       struct dwarf_buf unit_buf;\n       int version;\n+      int unit_type;\n       uint64_t abbrev_offset;\n       int addrsize;\n       struct unit *u;\n@@ -1583,12 +2139,24 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \tgoto fail;\n \n       version = read_uint16 (&unit_buf);\n-      if (version < 2 || version > 4)\n+      if (version < 2 || version > 5)\n \t{\n \t  dwarf_buf_error (&unit_buf, \"unrecognized DWARF version\");\n \t  goto fail;\n \t}\n \n+      if (version < 5)\n+\tunit_type = 0;\n+      else\n+\t{\n+\t  unit_type = read_byte (&unit_buf);\n+\t  if (unit_type == DW_UT_type || unit_type == DW_UT_split_type)\n+\t    {\n+\t      /* This unit doesn't have anything we need.  */\n+\t      continue;\n+\t    }\n+\t}\n+\n       pu = ((struct unit **)\n \t    backtrace_vector_grow (state, sizeof (struct unit *),\n \t\t\t\t   error_callback, data, &units));\n@@ -1603,6 +2171,11 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n       *pu = u;\n       ++units_count;\n \n+      if (version < 5)\n+\taddrsize = 0; /* Set below.  */\n+      else\n+\taddrsize = read_byte (&unit_buf);\n+\n       memset (&u->abbrevs, 0, sizeof u->abbrevs);\n       abbrev_offset = read_offset (&unit_buf, is_dwarf64);\n       if (!read_abbrevs (state, abbrev_offset,\n@@ -1611,7 +2184,21 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t\t is_bigendian, error_callback, data, &u->abbrevs))\n \tgoto fail;\n \n-      addrsize = read_byte (&unit_buf);\n+      if (version < 5)\n+\taddrsize = read_byte (&unit_buf);\n+\n+      switch (unit_type)\n+\t{\n+\tcase 0:\n+\t  break;\n+\tcase DW_UT_compile: case DW_UT_partial:\n+\t  break;\n+\tcase DW_UT_skeleton: case DW_UT_split_compile:\n+\t  read_uint64 (&unit_buf); /* dwo_id */\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n \n       u->low_offset = unit_offset;\n       unit_offset += len + (is_dwarf64 ? 12 : 4);\n@@ -1720,55 +2307,21 @@ free_line_header (struct backtrace_state *state, struct line_header *hdr,\n \t\t  error_callback, data);\n }\n \n-/* Read the line header.  Return 1 on success, 0 on failure.  */\n+/* Read the directories and file names for a line header for version\n+   2, setting fields in HDR.  Return 1 on success, 0 on failure.  */\n \n static int\n-read_line_header (struct backtrace_state *state, struct unit *u,\n-\t\t  int is_dwarf64, struct dwarf_buf *line_buf,\n-\t\t  struct line_header *hdr)\n+read_v2_paths (struct backtrace_state *state, struct unit *u,\n+\t       struct dwarf_buf *hdr_buf, struct line_header *hdr)\n {\n-  uint64_t hdrlen;\n-  struct dwarf_buf hdr_buf;\n   const unsigned char *p;\n   const unsigned char *pend;\n   size_t i;\n \n-  hdr->version = read_uint16 (line_buf);\n-  if (hdr->version < 2 || hdr->version > 4)\n-    {\n-      dwarf_buf_error (line_buf, \"unsupported line number version\");\n-      return 0;\n-    }\n-\n-  hdrlen = read_offset (line_buf, is_dwarf64);\n-\n-  hdr_buf = *line_buf;\n-  hdr_buf.left = hdrlen;\n-\n-  if (!advance (line_buf, hdrlen))\n-    return 0;\n-\n-  hdr->min_insn_len = read_byte (&hdr_buf);\n-  if (hdr->version < 4)\n-    hdr->max_ops_per_insn = 1;\n-  else\n-    hdr->max_ops_per_insn = read_byte (&hdr_buf);\n-\n-  /* We don't care about default_is_stmt.  */\n-  read_byte (&hdr_buf);\n-\n-  hdr->line_base = read_sbyte (&hdr_buf);\n-  hdr->line_range = read_byte (&hdr_buf);\n-\n-  hdr->opcode_base = read_byte (&hdr_buf);\n-  hdr->opcode_lengths = hdr_buf.buf;\n-  if (!advance (&hdr_buf, hdr->opcode_base - 1))\n-    return 0;\n-\n   /* Count the number of directory entries.  */\n   hdr->dirs_count = 0;\n-  p = hdr_buf.buf;\n-  pend = p + hdr_buf.left;\n+  p = hdr_buf->buf;\n+  pend = p + hdr_buf->left;\n   while (p < pend && *p != '\\0')\n     {\n       p += strnlen((const char *) p, pend - p) + 1;\n@@ -1781,29 +2334,30 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n       hdr->dirs = ((const char **)\n \t\t   backtrace_alloc (state,\n \t\t\t\t    hdr->dirs_count * sizeof (const char *),\n-\t\t\t\t    line_buf->error_callback, line_buf->data));\n+\t\t\t\t    hdr_buf->error_callback,\n+\t\t\t\t    hdr_buf->data));\n       if (hdr->dirs == NULL)\n \treturn 0;\n     }\n \n   i = 0;\n-  while (*hdr_buf.buf != '\\0')\n+  while (*hdr_buf->buf != '\\0')\n     {\n-      if (hdr_buf.reported_underflow)\n+      if (hdr_buf->reported_underflow)\n \treturn 0;\n \n-      hdr->dirs[i] = read_string (&hdr_buf);\n+      hdr->dirs[i] = read_string (hdr_buf);\n       if (hdr->dirs[i] == NULL)\n \treturn 0;\n       ++i;\n     }\n-  if (!advance (&hdr_buf, 1))\n+  if (!advance (hdr_buf, 1))\n     return 0;\n \n   /* Count the number of file entries.  */\n   hdr->filenames_count = 0;\n-  p = hdr_buf.buf;\n-  pend = p + hdr_buf.left;\n+  p = hdr_buf->buf;\n+  pend = p + hdr_buf->left;\n   while (p < pend && *p != '\\0')\n     {\n       p += strnlen ((const char *) p, pend - p) + 1;\n@@ -1816,23 +2370,23 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n   hdr->filenames = ((const char **)\n \t\t    backtrace_alloc (state,\n \t\t\t\t     hdr->filenames_count * sizeof (char *),\n-\t\t\t\t     line_buf->error_callback,\n-\t\t\t\t     line_buf->data));\n+\t\t\t\t     hdr_buf->error_callback,\n+\t\t\t\t     hdr_buf->data));\n   if (hdr->filenames == NULL)\n     return 0;\n   i = 0;\n-  while (*hdr_buf.buf != '\\0')\n+  while (*hdr_buf->buf != '\\0')\n     {\n       const char *filename;\n       uint64_t dir_index;\n \n-      if (hdr_buf.reported_underflow)\n+      if (hdr_buf->reported_underflow)\n \treturn 0;\n \n-      filename = read_string (&hdr_buf);\n+      filename = read_string (hdr_buf);\n       if (filename == NULL)\n \treturn 0;\n-      dir_index = read_uleb128 (&hdr_buf);\n+      dir_index = read_uleb128 (hdr_buf);\n       if (IS_ABSOLUTE_PATH (filename)\n \t  || (dir_index == 0 && u->comp_dir == NULL))\n \thdr->filenames[i] = filename;\n@@ -1849,16 +2403,16 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \t    dir = hdr->dirs[dir_index - 1];\n \t  else\n \t    {\n-\t      dwarf_buf_error (line_buf,\n+\t      dwarf_buf_error (hdr_buf,\n \t\t\t       (\"invalid directory index in \"\n \t\t\t\t\"line number program header\"));\n \t      return 0;\n \t    }\n \t  dir_len = strlen (dir);\n \t  filename_len = strlen (filename);\n-\t  s = ((char *)\n-\t       backtrace_alloc (state, dir_len + filename_len + 2,\n-\t\t\t\tline_buf->error_callback, line_buf->data));\n+\t  s = ((char *) backtrace_alloc (state, dir_len + filename_len + 2,\n+\t\t\t\t\t hdr_buf->error_callback,\n+\t\t\t\t\t hdr_buf->data));\n \t  if (s == NULL)\n \t    return 0;\n \t  memcpy (s, dir, dir_len);\n@@ -1871,12 +2425,258 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \t}\n \n       /* Ignore the modification time and size.  */\n-      read_uleb128 (&hdr_buf);\n-      read_uleb128 (&hdr_buf);\n+      read_uleb128 (hdr_buf);\n+      read_uleb128 (hdr_buf);\n \n       ++i;\n     }\n \n+  return 1;\n+}\n+\n+/* Read a single version 5 LNCT entry for a directory or file name in a\n+   line header.  Sets *STRING to the resulting name, ignoring other\n+   data.  Return 1 on success, 0 on failure.  */\n+\n+static int\n+read_lnct (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t   struct unit *u, struct dwarf_buf *hdr_buf,\n+\t   const struct line_header *hdr, size_t formats_count,\n+\t   const struct line_header_format *formats, const char **string)\n+{\n+  size_t i;\n+  const char *dir;\n+  const char *path;\n+\n+  dir = NULL;\n+  path = NULL;\n+  for (i = 0; i < formats_count; i++)\n+    {\n+      struct attr_val val;\n+\n+      if (!read_attribute (formats[i].form, 0, hdr_buf, u->is_dwarf64,\n+\t\t\t   u->version, hdr->addrsize, &ddata->dwarf_sections,\n+\t\t\t   ddata->altlink, &val))\n+\treturn 0;\n+      switch (formats[i].lnct)\n+\t{\n+\tcase DW_LNCT_path:\n+\t  if (!resolve_string (&ddata->dwarf_sections, u->is_dwarf64,\n+\t\t\t       ddata->is_bigendian, u->str_offsets_base,\n+\t\t\t       &val, hdr_buf->error_callback, hdr_buf->data,\n+\t\t\t       &path))\n+\t    return 0;\n+\t  break;\n+\tcase DW_LNCT_directory_index:\n+\t  if (val.encoding == ATTR_VAL_UINT)\n+\t    {\n+\t      if (val.u.uint >= hdr->dirs_count)\n+\t\t{\n+\t\t  dwarf_buf_error (hdr_buf,\n+\t\t\t\t   (\"invalid directory index in \"\n+\t\t\t\t    \"line number program header\"));\n+\t\t  return 0;\n+\t\t}\n+\t      dir = hdr->dirs[val.u.uint];\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  /* We don't care about timestamps or sizes or hashes.  */\n+\t  break;\n+\t}\n+    }\n+\n+  if (path == NULL)\n+    {\n+      dwarf_buf_error (hdr_buf,\n+\t\t       \"missing file name in line number program header\");\n+      return 0;\n+    }\n+\n+  if (dir == NULL)\n+    *string = path;\n+  else\n+    {\n+      size_t dir_len;\n+      size_t path_len;\n+      char *s;\n+\n+      dir_len = strlen (dir);\n+      path_len = strlen (path);\n+      s = (char *) backtrace_alloc (state, dir_len + path_len + 2,\n+\t\t\t\t    hdr_buf->error_callback, hdr_buf->data);\n+      if (s == NULL)\n+\treturn 0;\n+      memcpy (s, dir, dir_len);\n+      /* FIXME: If we are on a DOS-based file system, and the\n+\t directory or the path name use backslashes, then we should\n+\t use a backslash here.  */\n+      s[dir_len] = '/';\n+      memcpy (s + dir_len + 1, path, path_len + 1);\n+      *string = s;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Read a set of DWARF 5 line header format entries, setting *PCOUNT\n+   and *PPATHS.  Return 1 on success, 0 on failure.  */\n+\n+static int\n+read_line_header_format_entries (struct backtrace_state *state,\n+\t\t\t\t struct dwarf_data *ddata,\n+\t\t\t\t struct unit *u,\n+\t\t\t\t struct dwarf_buf *hdr_buf,\n+\t\t\t\t struct line_header *hdr,\n+\t\t\t\t size_t *pcount,\n+\t\t\t\t const char ***ppaths)\n+{\n+  size_t formats_count;\n+  struct line_header_format *formats;\n+  size_t paths_count;\n+  const char **paths;\n+  size_t i;\n+  int ret;\n+\n+  formats_count = read_byte (hdr_buf);\n+  if (formats_count == 0)\n+    formats = NULL;\n+  else\n+    {\n+      formats = ((struct line_header_format *)\n+\t\t backtrace_alloc (state,\n+\t\t\t\t  (formats_count\n+\t\t\t\t   * sizeof (struct line_header_format)),\n+\t\t\t\t  hdr_buf->error_callback,\n+\t\t\t\t  hdr_buf->data));\n+      if (formats == NULL)\n+\treturn 0;\n+\n+      for (i = 0; i < formats_count; i++)\n+\t{\n+\t  formats[i].lnct = (int) read_uleb128(hdr_buf);\n+\t  formats[i].form = (enum dwarf_form) read_uleb128 (hdr_buf);\n+\t}\n+    }\n+\n+  paths_count = read_uleb128 (hdr_buf);\n+  if (paths_count == 0)\n+    {\n+      *pcount = 0;\n+      *ppaths = NULL;\n+      ret = 1;\n+      goto exit;\n+    }\n+\n+  paths = ((const char **)\n+\t   backtrace_alloc (state, paths_count * sizeof (const char *),\n+\t\t\t    hdr_buf->error_callback, hdr_buf->data));\n+  if (paths == NULL)\n+    {\n+      ret = 0;\n+      goto exit;\n+    }\n+  for (i = 0; i < paths_count; i++)\n+    {\n+      if (!read_lnct (state, ddata, u, hdr_buf, hdr, formats_count,\n+\t\t      formats, &paths[i]))\n+\t{\n+\t  backtrace_free (state, paths,\n+\t\t\t  paths_count * sizeof (const char *),\n+\t\t\t  hdr_buf->error_callback, hdr_buf->data);\n+\t  ret = 0;\n+\t  goto exit;\n+\t}\n+    }\n+\n+  *pcount = paths_count;\n+  *ppaths = paths;\n+\n+  ret = 1;\n+\n+ exit:\n+  if (formats != NULL)\n+    backtrace_free (state, formats,\n+\t\t    formats_count * sizeof (struct line_header_format),\n+\t\t    hdr_buf->error_callback, hdr_buf->data);\n+\n+  return  ret;\n+}\n+\n+/* Read the line header.  Return 1 on success, 0 on failure.  */\n+\n+static int\n+read_line_header (struct backtrace_state *state, struct dwarf_data *ddata,\n+\t\t  struct unit *u, int is_dwarf64, struct dwarf_buf *line_buf,\n+\t\t  struct line_header *hdr)\n+{\n+  uint64_t hdrlen;\n+  struct dwarf_buf hdr_buf;\n+\n+  hdr->version = read_uint16 (line_buf);\n+  if (hdr->version < 2 || hdr->version > 5)\n+    {\n+      dwarf_buf_error (line_buf, \"unsupported line number version\");\n+      return 0;\n+    }\n+\n+  if (hdr->version < 5)\n+    hdr->addrsize = u->addrsize;\n+  else\n+    {\n+      hdr->addrsize = read_byte (line_buf);\n+      /* We could support a non-zero segment_selector_size but I doubt\n+\t we'll ever see it.  */\n+      if (read_byte (line_buf) != 0)\n+\t{\n+\t  dwarf_buf_error (line_buf,\n+\t\t\t   \"non-zero segment_selector_size not supported\");\n+\t  return 0;\n+\t}\n+    }\n+\n+  hdrlen = read_offset (line_buf, is_dwarf64);\n+\n+  hdr_buf = *line_buf;\n+  hdr_buf.left = hdrlen;\n+\n+  if (!advance (line_buf, hdrlen))\n+    return 0;\n+\n+  hdr->min_insn_len = read_byte (&hdr_buf);\n+  if (hdr->version < 4)\n+    hdr->max_ops_per_insn = 1;\n+  else\n+    hdr->max_ops_per_insn = read_byte (&hdr_buf);\n+\n+  /* We don't care about default_is_stmt.  */\n+  read_byte (&hdr_buf);\n+\n+  hdr->line_base = read_sbyte (&hdr_buf);\n+  hdr->line_range = read_byte (&hdr_buf);\n+\n+  hdr->opcode_base = read_byte (&hdr_buf);\n+  hdr->opcode_lengths = hdr_buf.buf;\n+  if (!advance (&hdr_buf, hdr->opcode_base - 1))\n+    return 0;\n+\n+  if (hdr->version < 5)\n+    {\n+      if (!read_v2_paths (state, u, &hdr_buf, hdr))\n+\treturn 0;\n+    }\n+  else\n+    {\n+      if (!read_line_header_format_entries (state, ddata, u, &hdr_buf, hdr,\n+\t\t\t\t\t    &hdr->dirs_count,\n+\t\t\t\t\t    &hdr->dirs))\n+\treturn 0;\n+      if (!read_line_header_format_entries (state, ddata, u, &hdr_buf, hdr,\n+\t\t\t\t\t    &hdr->filenames_count,\n+\t\t\t\t\t    &hdr->filenames))\n+\treturn 0;\n+    }\n+\n   if (hdr_buf.reported_underflow)\n     return 0;\n \n@@ -1942,7 +2742,7 @@ read_line_program (struct backtrace_state *state, struct dwarf_data *ddata,\n \t      lineno = 1;\n \t      break;\n \t    case DW_LNE_set_address:\n-\t      address = read_address (line_buf, u->addrsize);\n+\t      address = read_address (line_buf, hdr->addrsize);\n \t      break;\n \t    case DW_LNE_define_file:\n \t      {\n@@ -1965,7 +2765,7 @@ read_line_program (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t    size_t f_len;\n \t\t    char *p;\n \n-\t\t    if (dir_index == 0)\n+\t\t    if (dir_index == 0 && hdr->version < 5)\n \t\t      dir = u->comp_dir;\n \t\t    else if (dir_index - 1 < hdr->dirs_count)\n \t\t      dir = hdr->dirs[dir_index - 1];\n@@ -2129,7 +2929,7 @@ read_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   len = read_initial_length (&line_buf, &is_dwarf64);\n   line_buf.left = len;\n \n-  if (!read_line_header (state, u, is_dwarf64, &line_buf, hdr))\n+  if (!read_line_header (state, ddata, u, is_dwarf64, &line_buf, hdr))\n     goto fail;\n \n   if (!read_line_program (state, ddata, u, hdr, &line_buf, &vec))\n@@ -2287,11 +3087,9 @@ read_referenced_name (struct dwarf_data *ddata, struct unit *u,\n     {\n       struct attr_val val;\n \n-      if (!read_attribute (abbrev->attrs[i].form, &unit_buf,\n-\t\t\t   u->is_dwarf64, u->version, u->addrsize,\n-\t\t\t   ddata->dwarf_sections.data[DEBUG_STR],\n-\t\t\t   ddata->dwarf_sections.size[DEBUG_STR],\n-\t\t\t   ddata->altlink, &val))\n+      if (!read_attribute (abbrev->attrs[i].form, abbrev->attrs[i].val,\n+\t\t\t   &unit_buf, u->is_dwarf64, u->version, u->addrsize,\n+\t\t\t   &ddata->dwarf_sections, ddata->altlink, &val))\n \treturn NULL;\n \n       switch (abbrev->attrs[i].name)\n@@ -2302,15 +3100,26 @@ read_referenced_name (struct dwarf_data *ddata, struct unit *u,\n \t     normally not mangled.  */\n \t  if (ret != NULL)\n \t    break;\n-\t  if (val.encoding == ATTR_VAL_STRING)\n-\t    ret = val.u.string;\n+\t  if (!resolve_string (&ddata->dwarf_sections, u->is_dwarf64,\n+\t\t\t       ddata->is_bigendian, u->str_offsets_base,\n+\t\t\t       &val, error_callback, data, &ret))\n+\t    return NULL;\n \t  break;\n \n \tcase DW_AT_linkage_name:\n \tcase DW_AT_MIPS_linkage_name:\n \t  /* First name preference: override all.  */\n-\t  if (val.encoding == ATTR_VAL_STRING)\n-\t    return val.u.string;\n+\t  {\n+\t    const char *s;\n+\n+\t    s = NULL;\n+\t    if (!resolve_string (&ddata->dwarf_sections, u->is_dwarf64,\n+\t\t\t\t ddata->is_bigendian, u->str_offsets_base,\n+\t\t\t\t &val, error_callback, data, &s))\n+\t      return NULL;\n+\t    if (s != NULL)\n+\t      return s;\n+\t  }\n \t  break;\n \n \tcase DW_AT_specification:\n@@ -2430,19 +3239,28 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t{\n \t  struct attr_val val;\n \n-\t  if (!read_attribute (abbrev->attrs[i].form, unit_buf,\n-\t\t\t       u->is_dwarf64, u->version, u->addrsize,\n-\t\t\t       ddata->dwarf_sections.data[DEBUG_STR],\n-\t\t\t       ddata->dwarf_sections.size[DEBUG_STR],\n+\t  if (!read_attribute (abbrev->attrs[i].form, abbrev->attrs[i].val,\n+\t\t\t       unit_buf, u->is_dwarf64, u->version,\n+\t\t\t       u->addrsize, &ddata->dwarf_sections,\n \t\t\t       ddata->altlink, &val))\n \t    return 0;\n \n \t  /* The compile unit sets the base address for any address\n \t     ranges in the function entries.  */\n \t  if (abbrev->tag == DW_TAG_compile_unit\n-\t      && abbrev->attrs[i].name == DW_AT_low_pc\n-\t      && val.encoding == ATTR_VAL_ADDRESS)\n-\t    base = val.u.uint;\n+\t      && abbrev->attrs[i].name == DW_AT_low_pc)\n+\t    {\n+\t      if (val.encoding == ATTR_VAL_ADDRESS)\n+\t\tbase = val.u.uint;\n+\t      else if (val.encoding == ATTR_VAL_ADDRESS_INDEX)\n+\t\t{\n+\t\t  if (!resolve_addr_index (&ddata->dwarf_sections,\n+\t\t\t\t\t   u->addr_base, u->addrsize,\n+\t\t\t\t\t   ddata->is_bigendian, val.u.uint,\n+\t\t\t\t\t   error_callback, data, &base))\n+\t\t    return 0;\n+\t\t}\n+\t    }\n \n \t  if (is_function)\n \t    {\n@@ -2495,18 +3313,31 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t  /* Third name preference: don't override.  */\n \t\t  if (function->name != NULL)\n \t\t    break;\n-\t\t  if (val.encoding == ATTR_VAL_STRING)\n-\t\t    function->name = val.u.string;\n+\t\t  if (!resolve_string (&ddata->dwarf_sections, u->is_dwarf64,\n+\t\t\t\t       ddata->is_bigendian,\n+\t\t\t\t       u->str_offsets_base, &val,\n+\t\t\t\t       error_callback, data, &function->name))\n+\t\t    return 0;\n \t\t  break;\n \n \t\tcase DW_AT_linkage_name:\n \t\tcase DW_AT_MIPS_linkage_name:\n \t\t  /* First name preference: override all.  */\n-\t\t  if (val.encoding == ATTR_VAL_STRING)\n-\t\t    {\n-\t\t      function->name = val.u.string;\n-\t\t      have_linkage_name = 1;\n-\t\t    }\n+\t\t  {\n+\t\t    const char *s;\n+\n+\t\t    s = NULL;\n+\t\t    if (!resolve_string (&ddata->dwarf_sections, u->is_dwarf64,\n+\t\t\t\t\t ddata->is_bigendian,\n+\t\t\t\t\t u->str_offsets_base, &val,\n+\t\t\t\t\t error_callback, data, &s))\n+\t\t      return 0;\n+\t\t    if (s != NULL)\n+\t\t      {\n+\t\t\tfunction->name = s;\n+\t\t\thave_linkage_name = 1;\n+\t\t      }\n+\t\t  }\n \t\t  break;\n \n \t\tcase DW_AT_low_pc: case DW_AT_high_pc: case DW_AT_ranges:"}, {"sha": "d1d257b1399265b920c30a8ebe3c6df67178850e", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -346,6 +346,10 @@ static const char * const dwarf_section_names[DEBUG_MAX] =\n   \".debug_abbrev\",\n   \".debug_ranges\",\n   \".debug_str\",\n+  \".debug_addr\",\n+  \".debug_str_offsets\",\n+  \".debug_line_str\",\n+  \".debug_rnglists\"\n };\n \n /* Information we gather for the sections we care about.  */"}, {"sha": "a9c6688251aa14ea169522d3fbd28591e89557c1", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -295,6 +295,10 @@ enum dwarf_section\n   DEBUG_ABBREV,\n   DEBUG_RANGES,\n   DEBUG_STR,\n+  DEBUG_ADDR,\n+  DEBUG_STR_OFFSETS,\n+  DEBUG_LINE_STR,\n+  DEBUG_RNGLISTS,\n \n   DEBUG_MAX\n };"}, {"sha": "f932f35d4cf5736c3d4d37907269a7dd6656c0be", "filename": "libbacktrace/pecoff.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fpecoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fpecoff.c?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -141,7 +141,11 @@ static const char * const debug_section_names[DEBUG_MAX] =\n   \".debug_line\",\n   \".debug_abbrev\",\n   \".debug_ranges\",\n-  \".debug_str\"\n+  \".debug_str\",\n+  \".debug_addr\",\n+  \".debug_str_offsets\",\n+  \".debug_line_str\",\n+  \".debug_rnglists\"\n };\n \n /* Information we gather for the sections we care about.  */"}, {"sha": "a0030f07184d4e19150fb8fcd9db2427a1b48ba5", "filename": "libbacktrace/xcoff.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fxcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c926fd82bbd336b317266d43b9fa67a83397b06b/libbacktrace%2Fxcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxcoff.c?ref=c926fd82bbd336b317266d43b9fa67a83397b06b", "patch": "@@ -1286,6 +1286,8 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n \t\t\t      + (dwsect[i].offset - min_offset));\n \t}\n \n+      memset (&dwarf_sections, 0, sizeof dwarf_sections);\n+\n       dwarf_sections.data[DEBUG_INFO] = dwsect[DEBUG_INFO].data;\n       dwarf_sections.size[DEBUG_INFO] = dwsect[DEBUG_INFO].size;\n #if BACKTRACE_XCOFF_SIZE == 32"}]}