{"sha": "6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyOTkzZTU4YjkwNjA1ZWM3ZTBlOWRlYTYxYzZhZDE0MWJmMjE4OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-07-02T07:34:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-07-02T07:34:27Z"}, "message": "mips.c (machine_function): Add new fields: ignore_hazard_length_p and all_noreorder_p.\n\n\t* config/mips/mips.c (machine_function): Add new fields:\n\tignore_hazard_length_p and all_noreorder_p.\n\t(mips_flag_delayed_branch): New variable.\n\t(override_options): Treat '/' as an operand punctuation character.\n\tSet up mips_flag_delayed_branch.\n\t(print_operand): Handle '/'.\n\t(mips_output_function_prologue): Put the whole function in\n\t.set noreorder and .set nomacro if all_noreorder_p is true.\n\t(mips_output_function_epilogue): End the noreorder/nomacro sequence.\n\t(mips16_optimize_gp): Remove \"first insn\" parameter.\n\t(mips16_lay_out_constants): New function, split out from mips_reorg.\n\t(mips_avoid_hazard, mips_avoid_hazards): New functions.\n\t(mips_reorg): For mips16 code, call mips16_lay_out_constant\n\tand (optionally) mips16_optimize.  If TARGET_EXPLICIT_RELOCS,\n\tdo delayed-branch scheduling followed by hazard detection.\n\t(mips_adjust_insn_length): Only account for hazards if\n\t!ignore_hazard_length_p.\n\t(mips_output_load_label): Add a nop to the o32 sequence if\n\tthe target suffers from load delays.\n\t(mips_output_conditional_branch): Add %/ to the end of branches.\n\t(mips_output_division): Fill the branch delay slot with %#.\n\t* config/mips/mips.md: Remove redundant '%*' from mips16 branch\n\tinstructions.  End all other %* branches with %/.\n\t(ffssi2, ffsdi2): Fix lengths.\n\t(truncdisi2, truncdihi2, truncdiqi2): Add store attributes.\n\t(fix_truncdfsi2_macro): Turn off .set nomacro if appropriate.\n\t(fix_truncsfsi2_macro): Likewise.\n\t(mov_lwl): Set hazard to \"none\".\n\t(ashldi3_internal): Fill the branch delay slot with %#.\n\t(ashrdi3_internal, lshrdi3_internal): Likewise.\n\t(exception_receiver): Explicitly set $28.\n\t(hazard_nop): New pattern.\n\nFrom-SVN: r68821", "tree": {"sha": "f10bcd538a2db743ce56ebc162ce8aa7c9a60ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f10bcd538a2db743ce56ebc162ce8aa7c9a60ef2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/comments", "author": null, "committer": null, "parents": [{"sha": "0184bd46b030b4024e07d8e93e87c4b9b7b9f7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0184bd46b030b4024e07d8e93e87c4b9b7b9f7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0184bd46b030b4024e07d8e93e87c4b9b7b9f7e6"}], "stats": {"total": 384, "additions": 308, "deletions": 76}, "files": [{"sha": "d76a77c912a302876481898737dcd29b48b6769a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "patch": "@@ -1,3 +1,38 @@\n+2003-07-02  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (machine_function): Add new fields:\n+\tignore_hazard_length_p and all_noreorder_p.\n+\t(mips_flag_delayed_branch): New variable.\n+\t(override_options): Treat '/' as an operand punctuation character.\n+\tSet up mips_flag_delayed_branch.\n+\t(print_operand): Handle '/'.\n+\t(mips_output_function_prologue): Put the whole function in\n+\t.set noreorder and .set nomacro if all_noreorder_p is true.\n+\t(mips_output_function_epilogue): End the noreorder/nomacro sequence.\n+\t(mips16_optimize_gp): Remove \"first insn\" parameter.\n+\t(mips16_lay_out_constants): New function, split out from mips_reorg.\n+\t(mips_avoid_hazard, mips_avoid_hazards): New functions.\n+\t(mips_reorg): For mips16 code, call mips16_lay_out_constant\n+\tand (optionally) mips16_optimize.  If TARGET_EXPLICIT_RELOCS,\n+\tdo delayed-branch scheduling followed by hazard detection.\n+\t(mips_adjust_insn_length): Only account for hazards if\n+\t!ignore_hazard_length_p.\n+\t(mips_output_load_label): Add a nop to the o32 sequence if\n+\tthe target suffers from load delays.\n+\t(mips_output_conditional_branch): Add %/ to the end of branches.\n+\t(mips_output_division): Fill the branch delay slot with %#.\n+\t* config/mips/mips.md: Remove redundant '%*' from mips16 branch\n+\tinstructions.  End all other %* branches with %/.\n+\t(ffssi2, ffsdi2): Fix lengths.\n+\t(truncdisi2, truncdihi2, truncdiqi2): Add store attributes.\n+\t(fix_truncdfsi2_macro): Turn off .set nomacro if appropriate.\n+\t(fix_truncsfsi2_macro): Likewise.\n+\t(mov_lwl): Set hazard to \"none\".\n+\t(ashldi3_internal): Fill the branch delay slot with %#.\n+\t(ashrdi3_internal, lshrdi3_internal): Likewise.\n+\t(exception_receiver): Explicitly set $28.\n+\t(hazard_nop): New pattern.\n+\n Wed Jul  2 08:12:36 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (cgraph_finalize_unit): Set current_function_decl"}, {"sha": "b06bf57d7f455dfe813870c5be2ac767779c4fb1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 200, "deletions": 22, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "patch": "@@ -243,13 +243,17 @@ static void save_restore_insns\t\t\tPARAMS ((int, rtx, long));\n static void mips_gp_insn\t\t\tPARAMS ((rtx, rtx));\n static void mips16_fp_args\t\t\tPARAMS ((FILE *, int, int));\n static void build_mips16_function_stub\t\tPARAMS ((FILE *));\n-static void mips16_optimize_gp\t\t\tPARAMS ((rtx));\n+static void mips16_optimize_gp\t\t\tPARAMS ((void));\n static rtx add_constant\t\t\t\tPARAMS ((struct constant **,\n \t\t\t\t\t\t\trtx,\n \t\t\t\t\t\t\tenum machine_mode));\n static void dump_constants\t\t\tPARAMS ((struct constant *,\n \t\t\t\t\t\t\trtx));\n static rtx mips_find_symbol\t\t\tPARAMS ((rtx));\n+static void mips16_lay_out_constants\t\tPARAMS ((void));\n+static void mips_avoid_hazard\t\t\tPARAMS ((rtx, rtx, int *,\n+\t\t\t\t\t\t\t rtx *, rtx));\n+static void mips_avoid_hazards\t\t\tPARAMS ((void));\n static void mips_reorg\t\t\t\tPARAMS ((void));\n static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n@@ -335,6 +339,14 @@ struct machine_function GTY(()) {\n \n   /* The register to use as the global pointer within this function.  */\n   unsigned int global_pointer;\n+\n+  /* True if mips_adjust_insn_length should ignore an instruction's\n+     hazard attribute.  */\n+  bool ignore_hazard_length_p;\n+\n+  /* True if the whole function is suitable for .set noreorder and\n+     .set nomacro.  */\n+  bool all_noreorder_p;\n };\n \n /* Information about a single argument.  */\n@@ -585,6 +597,9 @@ int mips_dbx_regno[FIRST_PSEUDO_REGISTER];\n /* An alias set for the GOT.  */\n static int mips_got_alias_set;\n \n+/* A copy of the original flag_delayed_branch: see override_options.  */\n+static int mips_flag_delayed_branch;\n+\n static GTY (()) int mips_output_filename_first_time = 1;\n \n /* Hardware names for the registers.  If -mrnames is used, this\n@@ -5153,6 +5168,14 @@ override_options ()\n   else\n     mips16 = 0;\n \n+  /* When using explicit relocs, we call dbr_schedule from within\n+     mips_reorg.  */\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      mips_flag_delayed_branch = flag_delayed_branch;\n+      flag_delayed_branch = 0;\n+    }\n+\n   real_format_for_mode[SFmode - QFmode] = &mips_single_format;\n   real_format_for_mode[DFmode - QFmode] = &mips_double_format;\n #ifdef MIPS_TFMODE_FORMAT\n@@ -5163,6 +5186,7 @@ override_options ()\n \n   mips_print_operand_punct['?'] = 1;\n   mips_print_operand_punct['#'] = 1;\n+  mips_print_operand_punct['/'] = 1;\n   mips_print_operand_punct['&'] = 1;\n   mips_print_operand_punct['!'] = 1;\n   mips_print_operand_punct['*'] = 1;\n@@ -5478,6 +5502,7 @@ mips_debugger_offset (addr, offset)\n    '*'\tTurn on both .set noreorder and .set nomacro if filling delay slots\n    '!'\tTurn on .set nomacro if filling delay slots\n    '#'\tPrint nop if in a .set noreorder section.\n+   '/'\tLike '#', but does nothing within a delayed branch sequence\n    '?'\tPrint 'l' if we are to use a branch likely instead of normal branch.\n    '@'\tPrint the name of the assembler temporary register (at or $1).\n    '.'\tPrint the name of the register with a hard-wired zero (zero or $0).\n@@ -5551,6 +5576,14 @@ print_operand (file, op, letter)\n \t    fputs (\"\\n\\tnop\", file);\n \t  break;\n \n+\tcase '/':\n+\t  /* Print an extra newline so that the delayed insn is separated\n+\t     from the following ones.  This looks neater and is consistent\n+\t     with non-nop delayed sequences.  */\n+\t  if (set_noreorder != 0 && final_sequence == 0)\n+\t    fputs (\"\\n\\tnop\\n\", file);\n+\t  break;\n+\n \tcase '(':\n \t  if (set_noreorder++ == 0)\n \t    fputs (\".set\\tnoreorder\\n\\t\", file);\n@@ -7073,10 +7106,16 @@ mips_output_function_prologue (file, size)\n       fprintf (file, \"\\n\");\n     }\n \n-  /* Handle the initialization of $gp for SVR4 PIC.  */\n   if (TARGET_ABICALLS && !TARGET_NEWABI && cfun->machine->global_pointer > 0)\n-    fprintf (file, \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n-\t     reg_names[PIC_FUNCTION_ADDR_REGNUM]);\n+    {\n+      /* Handle the initialization of $gp for SVR4 PIC.  */\n+      if (!cfun->machine->all_noreorder_p)\n+\toutput_asm_insn (\"%(.cpload\\t%^%)\", 0);\n+      else\n+\toutput_asm_insn (\"%(.cpload\\t%^\\n\\t%<\", 0);\n+    }\n+  else if (cfun->machine->all_noreorder_p)\n+    output_asm_insn (\"%(%<\", 0);\n }\n \f\n /* Emit an instruction to move SRC into DEST.  When generating\n@@ -7487,6 +7526,14 @@ mips_output_function_epilogue (file, size)\n {\n   rtx string;\n \n+  if (cfun->machine->all_noreorder_p)\n+    {\n+      /* Avoid using %>%) since it adds excess whitespace.  */\n+      output_asm_insn (\".set\\tmacro\", 0);\n+      output_asm_insn (\".set\\treorder\", 0);\n+      set_noreorder = set_nomacro = 0;\n+    }\n+\n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n   if (!flag_inhibit_size_directive)\n     {\n@@ -8893,8 +8940,7 @@ build_mips16_call_stub (retval, fn, arg_size, fp_code)\n    generated is correct, so we do not need to catch all cases.  */\n \n static void\n-mips16_optimize_gp (first)\n-     rtx first;\n+mips16_optimize_gp ()\n {\n   rtx gpcopy, slot, insn;\n \n@@ -8907,7 +8953,7 @@ mips16_optimize_gp (first)\n \n   gpcopy = NULL_RTX;\n   slot = NULL_RTX;\n-  for (insn = first; insn != NULL_RTX; insn = next_active_insn (insn))\n+  for (insn = get_insns (); insn != NULL_RTX; insn = next_active_insn (insn))\n     {\n       rtx set;\n \n@@ -8990,7 +9036,7 @@ mips16_optimize_gp (first)\n \n #if 0\n   /* ??? FIXME.  Rewrite for new UNSPEC_RELOC stuff.  */\n-      for (insn = first; insn != NULL_RTX; insn = next)\n+      for (insn = get_insns (); insn != NULL_RTX; insn = next)\n \t{\n \t  rtx set1, set2;\n \n@@ -9059,7 +9105,7 @@ mips16_optimize_gp (first)\n      replace all assignments from SLOT to GPCOPY with assignments from\n      $28.  */\n \n-  for (insn = first; insn != NULL_RTX; insn = next_active_insn (insn))\n+  for (insn = get_insns (); insn != NULL_RTX; insn = next_active_insn (insn))\n     {\n       rtx set;\n \n@@ -9236,22 +9282,14 @@ mips_find_symbol (addr)\n    PC relative loads that are out of range.  */\n \n static void\n-mips_reorg ()\n+mips16_lay_out_constants ()\n {\n   int insns_len, max_internal_pool_size, pool_size, addr, first_constant_ref;\n   rtx first, insn;\n   struct constant *constants;\n \n-  if (! TARGET_MIPS16)\n-    return;\n-\n   first = get_insns ();\n \n-  /* If $gp is used, try to remove stores, and replace loads with\n-     copies from $gp.  */\n-  if (optimize)\n-    mips16_optimize_gp (first);\n-\n   /* Scan the function looking for PC relative loads which may be out\n      of range.  All such loads will either be from the constant table,\n      or be getting the address of a constant string.  If the size of\n@@ -9436,6 +9474,144 @@ mips_reorg ()\n      constant table, but we have no way to prevent that.  */\n }\n \n+\n+/* Subroutine of mips_reorg.  If there is a hazard between INSN\n+   and a previous instruction, avoid it by inserting nops after\n+   instruction AFTER.\n+\n+   *DELAYED_REG and *HILO_DELAY describe the hazards that apply at\n+   this point.  If *DELAYED_REG is non-null, INSN must wait a cycle\n+   before using the value of that register.  *HILO_DELAY counts the\n+   number of instructions since the last hilo hazard (that is,\n+   the number of instructions since the last mflo or mfhi).\n+\n+   After inserting nops for INSN, update *DELAYED_REG and *HILO_DELAY\n+   for the next instruction.\n+\n+   LO_REG is an rtx for the LO register, used in dependence checking.  */\n+\n+static void\n+mips_avoid_hazard (after, insn, hilo_delay, delayed_reg, lo_reg)\n+     rtx after, insn, *delayed_reg, lo_reg;\n+     int *hilo_delay;\n+{\n+  rtx pattern, set;\n+  int nops, ninsns;\n+\n+  if (!INSN_P (insn))\n+    return;\n+\n+  pattern = PATTERN (insn);\n+\n+  /* Do not put the whole function in .set noreorder if it contains\n+     an asm statement.  We don't know whether there will be hazards\n+     between the asm statement and the gcc-generated code.  */\n+  if (GET_CODE (pattern) == ASM_INPUT || asm_noperands (pattern) >= 0)\n+    cfun->machine->all_noreorder_p = false;\n+\n+  /* Ignore zero-length instructions (barriers and the like).  */\n+  ninsns = get_attr_length (insn) / 4;\n+  if (ninsns == 0)\n+    return;\n+\n+  /* Work out how many nops are needed.  Note that we only care about\n+     registers that are explicitly mentioned in the instruction's pattern.\n+     It doesn't matter that calls use the argument registers or that they\n+     clobber hi and lo.  */\n+  if (*hilo_delay < 2 && reg_set_p (lo_reg, pattern))\n+    nops = 2 - *hilo_delay;\n+  else if (*delayed_reg != 0 && reg_referenced_p (*delayed_reg, pattern))\n+    nops = 1;\n+  else\n+    nops = 0;\n+\n+  /* Insert the nops between this instruction and the previous one.\n+     Each new nop takes us further from the last hilo hazard.  */\n+  *hilo_delay += nops;\n+  while (nops-- > 0)\n+    emit_insn_after (gen_hazard_nop (), after);\n+\n+  /* Set up the state for the next instruction.  */\n+  *hilo_delay += ninsns;\n+  *delayed_reg = 0;\n+  if (INSN_CODE (insn) >= 0)\n+    switch (get_attr_hazard (insn))\n+      {\n+      case HAZARD_NONE:\n+\tbreak;\n+\n+      case HAZARD_HILO:\n+\t*hilo_delay = 0;\n+\tbreak;\n+\n+      case HAZARD_DELAY:\n+\tset = single_set (insn);\n+\tif (set == 0)\n+\t  abort ();\n+\t*delayed_reg = SET_DEST (set);\n+\tbreak;\n+      }\n+}\n+\n+\n+/* Go through the instruction stream and insert nops where necessary.\n+   See if the whole function can then be put into .set noreorder &\n+   .set nomacro.  */\n+\n+static void\n+mips_avoid_hazards ()\n+{\n+  rtx insn, last_insn, lo_reg, delayed_reg;\n+  int hilo_delay, i;\n+\n+  /* Recalculate instruction lengths without taking nops into account.  */\n+  cfun->machine->ignore_hazard_length_p = true;\n+  shorten_branches (get_insns ());\n+\n+  /* The profiler code uses assembler macros.  */\n+  cfun->machine->all_noreorder_p = !current_function_profile;\n+\n+  last_insn = 0;\n+  hilo_delay = 2;\n+  delayed_reg = 0;\n+  lo_reg = gen_rtx_REG (SImode, LO_REGNUM);\n+\n+  for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\tif (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t    mips_avoid_hazard (last_insn, XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t       &hilo_delay, &delayed_reg, lo_reg);\n+\telse\n+\t  mips_avoid_hazard (last_insn, insn, &hilo_delay,\n+\t\t\t     &delayed_reg, lo_reg);\n+\n+\tlast_insn = insn;\n+      }\n+}\n+\n+\n+/* Implement TARGET_MACHINE_DEPENDENT_REORG.  */\n+\n+static void\n+mips_reorg ()\n+{\n+  if (TARGET_MIPS16)\n+    {\n+      if (optimize)\n+\tmips16_optimize_gp ();\n+      mips16_lay_out_constants ();\n+    }\n+  else if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      if (mips_flag_delayed_branch)\n+\tdbr_schedule (get_insns (), rtl_dump_file);\n+      mips_avoid_hazards ();\n+    }\n+}\n+\n+\n /* Return a number assessing the cost of moving a register in class\n    FROM to class TO.  The classes are expressed using the enumeration\n    values such as `GENERAL_REGS'.  A value of 2 is the default; other\n@@ -9551,7 +9727,7 @@ mips_adjust_insn_length (insn, length)\n     length += 4;\n \n   /* See how many nops might be needed to avoid hardware hazards.  */\n-  if (INSN_CODE (insn) >= 0)\n+  if (!cfun->machine->ignore_hazard_length_p && INSN_CODE (insn) >= 0)\n     switch (get_attr_hazard (insn))\n       {\n       case HAZARD_NONE:\n@@ -9590,6 +9766,8 @@ mips_output_load_label ()\n \treturn \"%[ld\\t%@,%%got_page(%0)(%+)\\n\\tdaddiu\\t%@,%@,%%got_ofst(%0)\";\n \n       default:\n+\tif (ISA_HAS_LOAD_DELAY)\n+\t  return \"%[lw\\t%@,%%got(%0)(%+)%#\\n\\taddiu\\t%@,%@,%%lo(%0)\";\n \treturn \"%[lw\\t%@,%%got(%0)(%+)\\n\\taddiu\\t%@,%@,%%lo(%0)\";\n       }\n   else\n@@ -9709,10 +9887,10 @@ mips_output_conditional_branch (insn,\n     case 8:\n       /* Just a simple conditional branch.  */\n       if (float_p)\n-\tsprintf (buffer, \"%%*b%s%%?\\t%%Z2%%1\",\n+\tsprintf (buffer, \"%%*b%s%%?\\t%%Z2%%1%%/\",\n \t\t inverted_p ? inverted_comp : comp);\n       else\n-\tsprintf (buffer, \"%%*b%s%s%%?\\t%s%s,%%1\",\n+\tsprintf (buffer, \"%%*b%s%s%%?\\t%s%s,%%1%%/\",\n \t\t inverted_p ? inverted_comp : comp,\n \t\t need_z_p ? \"z\" : \"\",\n \t\t op1,\n@@ -9930,7 +10108,7 @@ mips_output_division (division, operands)\n       if (TARGET_MIPS16)\n \treturn \"bnez\\t%2,1f\\n\\tbreak\\t7\\n1:\";\n       else\n-\treturn \"bne\\t%2,%.,1f\\n\\t%#break\\t7\\n1:\";\n+\treturn \"bne\\t%2,%.,1f%#\\n\\tbreak\\t7\\n1:\";\n     }\n   return division;\n }"}, {"sha": "7621530b0c218d5e8e6159f40de03346749021f9", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f2993e58b90605ec7e0e9dea61c6ad141bf2188/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6f2993e58b90605ec7e0e9dea61c6ad141bf2188", "patch": "@@ -3040,7 +3040,7 @@ move\\\\t%0,%z4\\\\n\\\\\n }\"\n   [(set_attr \"type\"\t\"multi\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"12\")])\n+   (set_attr \"length\"\t\"28\")])\n \n (define_insn \"ffsdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n@@ -3074,7 +3074,7 @@ move\\\\t%0,%z4\\\\n\\\\\n }\"\n   [(set_attr \"type\"\t\"multi\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"24\")])\n+   (set_attr \"length\"\t\"28\")])\n \n \f\n \n@@ -3489,7 +3489,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"@\n     sll\\t%0,%1,0\n     sw\\t%1,%0\"\n-  [(set_attr \"type\" \"darith\")\n+  [(set_attr \"type\" \"darith,store\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"extended_mips16\" \"yes,*\")])\n \n@@ -3500,7 +3500,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"@\n     sll\\t%0,%1,0\n     sh\\t%1,%0\"\n-  [(set_attr \"type\" \"darith\")\n+  [(set_attr \"type\" \"darith,store\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"extended_mips16\" \"yes,*\")])\n \n@@ -3511,7 +3511,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"@\n     sll\\t%0,%1,0\n     sb\\t%1,%0\"\n-  [(set_attr \"type\" \"darith\")\n+  [(set_attr \"type\" \"darith,store\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"extended_mips16\" \"yes,*\")])\n \n@@ -4075,7 +4075,11 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(fix:SI (match_operand:DF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !ISA_HAS_TRUNC_W\"\n-  \"trunc.w.d %0,%1,%2\"\n+  {\n+    if (set_nomacro)\n+      return \".set\\tmacro\\n\\ttrunc.w.d %0,%1,%2\\n\\t.set\\tmacro\";\n+    return \"trunc.w.d %0,%1,%2\";\n+  }\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"36\")])\n@@ -4106,7 +4110,11 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:SF 2 \"=d\"))]\n   \"TARGET_HARD_FLOAT && !ISA_HAS_TRUNC_W\"\n-  \"trunc.w.s %0,%1,%2\"\n+  {\n+    if (set_nomacro)\n+      return \".set\\tmacro\\n\\ttrunc.w.s %0,%1,%2\\n\\t.set\\tmacro\";\n+    return \"trunc.w.s %0,%1,%2\";\n+  }\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"36\")])\n@@ -4437,7 +4445,8 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_MIPS16\"\n   \"lwl\\t%0,%2\"\n   [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"hazard\" \"none\")])\n \n (define_insn \"mov_lwr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -5636,7 +5645,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[4] = const0_rtx;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n-\\\\tbgez\\\\t%3,1f\\\\n\\\\\n+\\\\tbgez\\\\t%3,1f%#\\\\n\\\\\n \\\\tsll\\\\t%M0,%L1,%2\\\\n\\\\\n \\\\t%(b\\\\t3f\\\\n\\\\\n \\\\tmove\\\\t%L0,%z4%)\\\\n\\\\\n@@ -5991,7 +6000,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[4] = const0_rtx;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n-\\\\tbgez\\\\t%3,1f\\\\n\\\\\n+\\\\tbgez\\\\t%3,1f%#\\\\n\\\\\n \\\\tsra\\\\t%L0,%M1,%2\\\\n\\\\\n \\\\t%(b\\\\t3f\\\\n\\\\\n \\\\tsra\\\\t%M0,%M1,31%)\\\\n\\\\\n@@ -6369,7 +6378,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[4] = const0_rtx;\n \n   return \\\"sll\\\\t%3,%2,26\\\\n\\\\\n-\\\\tbgez\\\\t%3,1f\\\\n\\\\\n+\\\\tbgez\\\\t%3,1f%#\\\\n\\\\\n \\\\tsrl\\\\t%L0,%M1,%2\\\\n\\\\\n \\\\t%(b\\\\t3f\\\\n\\\\\n \\\\tmove\\\\t%M0,%z4%)\\\\n\\\\\n@@ -6988,16 +6997,16 @@ move\\\\t%0,%z4\\\\n\\\\\n   if (operands[2] != pc_rtx)\n     {\n       if (which_alternative == 0)\n-\treturn \\\"%*b%C0z\\\\t%1,%2\\\";\n+\treturn \\\"b%C0z\\\\t%1,%2\\\";\n       else\n-\treturn \\\"%*bt%C0z\\\\t%2\\\";\n+\treturn \\\"bt%C0z\\\\t%2\\\";\n     }\n   else\n     {\n       if (which_alternative == 0)\n-\treturn \\\"%*b%N0z\\\\t%1,%3\\\";\n+\treturn \\\"b%N0z\\\\t%1,%3\\\";\n       else\n-\treturn \\\"%*bt%N0z\\\\t%3\\\";\n+\treturn \\\"bt%N0z\\\\t%3\\\";\n     }\n }\"\n   [(set_attr \"type\"\t\"branch\")\n@@ -7017,16 +7026,16 @@ move\\\\t%0,%z4\\\\n\\\\\n   if (operands[2] != pc_rtx)\n     {\n       if (which_alternative == 0)\n-\treturn \\\"%*b%C0z\\\\t%1,%2\\\";\n+\treturn \\\"b%C0z\\\\t%1,%2\\\";\n       else\n-\treturn \\\"%*bt%C0z\\\\t%2\\\";\n+\treturn \\\"bt%C0z\\\\t%2\\\";\n     }\n   else\n     {\n       if (which_alternative == 0)\n-\treturn \\\"%*b%N0z\\\\t%1,%3\\\";\n+\treturn \\\"b%N0z\\\\t%1,%3\\\";\n       else\n-\treturn \\\"%*bt%N0z\\\\t%3\\\";\n+\treturn \\\"bt%N0z\\\\t%3\\\";\n     }\n }\"\n   [(set_attr \"type\"\t\"branch\")\n@@ -8389,15 +8398,15 @@ move\\\\t%0,%z4\\\\n\\\\\n   if (flag_pic && ! TARGET_EMBEDDED_PIC)\n     {\n       if (get_attr_length (insn) <= 8)\n-\treturn \\\"%*b\\\\t%l0\\\";\n+\treturn \\\"%*b\\\\t%l0%/\\\";\n       else\n \t{\n \t  output_asm_insn (mips_output_load_label (), operands);\n-\t  return \\\"%*jr\\\\t%@%]\\\";\n+\t  return \\\"%*jr\\\\t%@%/%]\\\";\n \t}\n     }\n   else\n-    return \\\"%*j\\\\t%l0\\\";\n+    return \\\"%*j\\\\t%l0%/\\\";\n }\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n@@ -8450,14 +8459,14 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"indirect_jump_internal1\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))]\n   \"!(Pmode == DImode)\"\n-  \"%*j\\\\t%0\"\n+  \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n (define_insn \"indirect_jump_internal2\"\n   [(set (pc) (match_operand:DI 0 \"register_operand\" \"d\"))]\n   \"Pmode == DImode\"\n-  \"%*j\\\\t%0\"\n+  \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -8501,7 +8510,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(match_operand:SI 0 \"register_operand\" \"d\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"%*j\\\\t%0\"\n+  \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -8510,7 +8519,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(match_operand:DI 0 \"register_operand\" \"d\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"%*j\\\\t%0\"\n+  \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -8626,7 +8635,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    (clobber (reg:SI 31))]\n   \"TARGET_EMBEDDED_PIC\"\n   \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,2\\\\n%~%S1:\\;addu\\\\t%2,%2,$31%)\\;\\\\\n-lw\\\\t%2,%1-%S1(%2)\\;addu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n+lw\\\\t%2,%1-%S1(%2)\\;addu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"24\")])\n@@ -8643,7 +8652,7 @@ lw\\\\t%2,%1-%S1(%2)\\;addu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n    (clobber (reg:DI 31))]\n   \"TARGET_EMBEDDED_PIC\"\n   \"%(bal\\\\t%S1\\;sll\\\\t%2,%0,3\\\\n%~%S1:\\;daddu\\\\t%2,%2,$31%)\\;\\\\\n-ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n+ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"24\")])\n@@ -8751,7 +8760,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n (define_insn \"return\"\n   [(return)]\n   \"mips_can_use_return_insn ()\"\n-  \"%*j\\\\t$31\"\n+  \"%*j\\t$31%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -8761,10 +8770,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   [(use (match_operand 0 \"pmode_register_operand\" \"\"))\n    (return)]\n   \"\"\n-  \"*\n-{\n-  return \\\"%*j\\\\t%0\\\";\n-}\"\n+  \"%*j\\t%0%/\"\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -8827,7 +8833,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n }\")\n \n (define_insn \"exception_receiver\"\n-  [(unspec_volatile [(const_int 0)] UNSPEC_EH_RECEIVER)]\n+  [(set (reg:SI 28)\n+\t(unspec_volatile [(const_int 0)] UNSPEC_EH_RECEIVER))]\n   \"TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64)\"\n   { return mips_restore_gp (operands); }\n   [(set_attr \"type\"   \"load\")\n@@ -8867,8 +8874,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n   \"@\n-    %*jr\\\\t%0\n-    %*j\\\\t%0\"\n+    %*jr\\t%0%/\n+    %*j\\t%0%/\"\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"sibcall_value\"\n@@ -8889,8 +8896,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n               (match_operand 2 \"\" \"\")))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n   \"@\n-    %*jr\\\\t%1\n-    %*j\\\\t%1\"\n+    %*jr\\t%1%/\n+    %*j\\t%1%/\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"sibcall_value_multiple_internal\"\n@@ -8902,8 +8909,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n \t      (match_dup 2)))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n   \"@\n-    %*jr\\\\t%1\n-    %*j\\\\t%1\"\n+    %*jr\\t%1%/\n+    %*j\\t%1%/\"\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"call\"\n@@ -8922,7 +8929,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\\\t%0\"\n+  \"%*jal\\t%0%/\"\n   \"reload_completed && TARGET_SPLIT_CALLS\"\n   [(const_int 0)]\n   {\n@@ -8939,7 +8946,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n    (clobber (reg:SI 31))\n    (const_int 1)]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\\\t%0\"\n+  \"%*jalr\\t%0%/\"\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"call_value\"\n@@ -8960,7 +8967,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\\\t%1\"\n+  \"%*jal\\t%1%/\"\n   \"reload_completed && TARGET_SPLIT_CALLS\"\n   [(const_int 0)]\n   {\n@@ -8979,7 +8986,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n    (clobber (reg:SI 31))\n    (const_int 1)]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\\\t%1\"\n+  \"%*jalr\\t%1%/\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn_and_split \"call_value_multiple_internal\"\n@@ -8991,7 +8998,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n \t      (match_dup 2)))\n    (clobber (reg:SI 31))]\n   \"\"\n-  \"%*jal\\\\t%1\"\n+  \"%*jal\\t%1%/\"\n   \"reload_completed && TARGET_SPLIT_CALLS\"\n   [(const_int 0)]\n   {\n@@ -9013,7 +9020,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n    (clobber (reg:SI 31))\n    (const_int 1)]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\\\t%1\"\n+  \"%*jalr\\t%1%/\"\n   [(set_attr \"type\" \"call\")])\n \n ;; Call subroutine returning any type.\n@@ -9100,6 +9107,18 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   [(set_attr \"type\"\t\"nop\")\n    (set_attr \"mode\"\t\"none\")])\n \n+;; Like nop, but commented out when outside a .set noreorder block.\n+(define_insn \"hazard_nop\"\n+  [(const_int 1)]\n+  \"\"\n+  {\n+    if (set_noreorder)\n+      return \"nop\";\n+    else\n+      return \"#nop\";\n+  }\n+  [(set_attr \"type\"\t\"arith\")])\n+\n ;; The MIPS chip does not seem to require stack probes.\n ;;\n ;; (define_expand \"probe\"\n@@ -9509,9 +9528,9 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   \"*\n {\n   if (operands[3] != pc_rtx)\n-    return \\\"%*b%C2z\\\\t%1,%3\\\";\n+    return \\\"b%C2z\\\\t%1,%3\\\";\n   else\n-    return \\\"%*b%N2z\\\\t%1,%4\\\";\n+    return \\\"b%N2z\\\\t%1,%4\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n@@ -9534,9 +9553,9 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   \"*\n {\n   if (operands[3] != pc_rtx)\n-    return \\\"%*b%C2z\\\\t%1,%3\\\";\n+    return \\\"b%C2z\\\\t%1,%3\\\";\n   else\n-    return \\\"%*b%N2z\\\\t%1,%4\\\";\n+    return \\\"b%N2z\\\\t%1,%4\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n@@ -9563,9 +9582,9 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   \"*\n {\n   if (operands[3] != pc_rtx)\n-    return \\\"%*bt%C2z\\\\t%3\\\";\n+    return \\\"bt%C2z\\\\t%3\\\";\n   else\n-    return \\\"%*bt%N2z\\\\t%4\\\";\n+    return \\\"bt%N2z\\\\t%4\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")\n@@ -9588,9 +9607,9 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   \"*\n {\n   if (operands[3] != pc_rtx)\n-    return \\\"%*bt%C2z\\\\t%3\\\";\n+    return \\\"bt%C2z\\\\t%3\\\";\n   else\n-    return \\\"%*bt%N2z\\\\t%4\\\";\n+    return \\\"bt%N2z\\\\t%4\\\";\n }\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")"}]}