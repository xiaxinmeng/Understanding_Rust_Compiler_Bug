{"sha": "ac7ee6adbe648bf0144976989030fac57798f6f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM3ZWU2YWRiZTY0OGJmMDE0NDk3Njk4OTAzMGZhYzU3Nzk4ZjZmOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-07-15T15:07:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-07-15T15:07:46Z"}, "message": "re PR middle-end/36369 (may_alias broken with previous uses of non attributed type in some cases)\n\n2008-07-15  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/36369\n\t* c-common.c (strict_aliasing_warning): Do not warn for\n\tTYPE_REF_CAN_ALIAS_ALL pointers.\n\t(c_common_get_alias_set): may_alias types are not special.\n\t* tree.c (build_pointer_type_for_mode): Look up the may_alias\n\tattribute and set can_ref_all accordingly.\n\t(build_reference_type_for_mode): Likewise.\n\t* doc/extend.texi (may_alias): Clarify.\n\n\t* gcc.dg/Wstrict-aliasing-bogus-ref-all.c: New testcase.\n\nFrom-SVN: r137843", "tree": {"sha": "0bcb9d1a50290f889709fe4909b9f2295332dc22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bcb9d1a50290f889709fe4909b9f2295332dc22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac7ee6adbe648bf0144976989030fac57798f6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7ee6adbe648bf0144976989030fac57798f6f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7ee6adbe648bf0144976989030fac57798f6f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7ee6adbe648bf0144976989030fac57798f6f9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96c72efecd3d87a178da3ee4b4d0eff5f83f833c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c72efecd3d87a178da3ee4b4d0eff5f83f833c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96c72efecd3d87a178da3ee4b4d0eff5f83f833c"}], "stats": {"total": 97, "additions": 87, "deletions": 10}, "files": [{"sha": "7ea39a7e3163f765cab1f225aa6e1657f2b5fa4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -1,3 +1,14 @@\n+2008-07-15  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/36369\n+\t* c-common.c (strict_aliasing_warning): Do not warn for\n+\tTYPE_REF_CAN_ALIAS_ALL pointers.\n+\t(c_common_get_alias_set): may_alias types are not special.\n+\t* tree.c (build_pointer_type_for_mode): Look up the may_alias\n+\tattribute and set can_ref_all accordingly.\n+\t(build_reference_type_for_mode): Likewise.\n+\t* doc/extend.texi (may_alias): Clarify.\n+\n 2008-07-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/36780"}, {"sha": "e93d2fba6dffa7ca6a130f623d2db298a993e7d0", "filename": "gcc/c-common.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -1242,8 +1242,13 @@ warn_logical_operator (enum tree_code code, tree arg1, tree\n bool\n strict_aliasing_warning (tree otype, tree type, tree expr)\n {\n-  if (!(flag_strict_aliasing && POINTER_TYPE_P (type) \n-        && POINTER_TYPE_P (otype) && !VOID_TYPE_P (TREE_TYPE (type))))\n+  if (!(flag_strict_aliasing\n+\t&& POINTER_TYPE_P (type)\n+\t&& POINTER_TYPE_P (otype)\n+\t&& !VOID_TYPE_P (TREE_TYPE (type)))\n+      /* If the type we are casting to is a ref-all pointer\n+         dereferencing it is always valid.  */\n+      || TYPE_REF_CAN_ALIAS_ALL (type))\n     return false;\n \n   if ((warn_strict_aliasing > 1) && TREE_CODE (expr) == ADDR_EXPR\n@@ -3464,10 +3469,6 @@ c_common_get_alias_set (tree t)\n       || t == unsigned_char_type_node)\n     return 0;\n \n-  /* If it has the may_alias attribute, it can alias anything.  */\n-  if (lookup_attribute (\"may_alias\", TYPE_ATTRIBUTES (t)))\n-    return 0;\n-\n   /* The C standard specifically allows aliasing between signed and\n      unsigned variants of the same type.  We treat the signed\n      variant as canonical.  */"}, {"sha": "4a4c9a3a4a172cd4ecf294e590c38090db7b63d3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -4240,10 +4240,16 @@ The @code{deprecated} attribute can also be used for functions and\n variables (@pxref{Function Attributes}, @pxref{Variable Attributes}.)\n \n @item may_alias\n-Accesses to objects with types with this attribute are not subjected to\n-type-based alias analysis, but are instead assumed to be able to alias\n-any other type of objects, just like the @code{char} type.  See\n-@option{-fstrict-aliasing} for more information on aliasing issues.\n+Accesses through pointers to types with this attribute are not subject\n+to type-based alias analysis, but are instead assumed to be able to alias\n+any other type of objects.  In the context of 6.5/7 an lvalue expression\n+dereferencing such a pointer is treated like having a character type.\n+See @option{-fstrict-aliasing} for more information on aliasing issues.\n+This extension exists to support some vector APIs, in which pointers to\n+one vector type are permitted to alias pointers to a different vector type.\n+\n+Note that an object of a type with this attribute does not have any\n+special semantics.\n \n Example of use:\n "}, {"sha": "33d94fceaecaf2374619235717501312e2622ab7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -1,3 +1,8 @@\n+2008-07-15  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/36369\n+\t* gcc.dg/Wstrict-aliasing-bogus-ref-all.c: New testcase.\n+\n 2008-07-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR target/31568"}, {"sha": "7e8d1771568d532639b31ad153e60ddc8d8a4476", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-ref-all.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-ref-all.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-ref-all.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-ref-all.c?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+struct g { long a; };\n+unsigned long f(struct g *a) { return *(unsigned long *)&a->a; }\n+\n+struct A\n+{\n+  void *a;\n+};\n+\n+int g(const struct A *x, long *y)\n+{\n+  typedef long __attribute__ ((may_alias)) long_a;\n+  *y = *(const long_a *) (&x->a);\n+  return 1;\n+}\n+\n+void *a;\n+\n+int\n+f0 (long *y)\n+{\n+  *y = *(const long *) &a; /* { dg-warning \"will break\" } */\n+  return 1;\n+}\n+\n+int\n+f1 (long *y)\n+{\n+  typedef long __attribute__ ((may_alias)) long_a;\n+  *y = *(const long_a *) &a;\n+  return 1;\n+}\n+\n+int\n+f2 (long *y)\n+{\n+  *y = *(const long *) &a; /* { dg-warning \"will break\" } */\n+  return 1;\n+}"}, {"sha": "6441ae6ef336e66041ea7b655bbeabd0a2eb39d5", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7ee6adbe648bf0144976989030fac57798f6f9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ac7ee6adbe648bf0144976989030fac57798f6f9", "patch": "@@ -5499,6 +5499,11 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n   if (to_type == error_mark_node)\n     return error_mark_node;\n \n+  /* If the pointed-to type has the may_alias attribute set, force\n+     a TYPE_REF_CAN_ALIAS_ALL pointer to be generated.  */\n+  if (lookup_attribute (\"may_alias\", TYPE_ATTRIBUTES (to_type)))\n+    can_alias_all = true;\n+\n   /* In some cases, languages will have things that aren't a POINTER_TYPE\n      (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_POINTER_TO.\n      In that case, return that type without regard to the rest of our\n@@ -5555,6 +5560,14 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n {\n   tree t;\n \n+  if (to_type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* If the pointed-to type has the may_alias attribute set, force\n+     a TYPE_REF_CAN_ALIAS_ALL pointer to be generated.  */\n+  if (lookup_attribute (\"may_alias\", TYPE_ATTRIBUTES (to_type)))\n+    can_alias_all = true;\n+\n   /* In some cases, languages will have things that aren't a REFERENCE_TYPE\n      (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_REFERENCE_TO.\n      In that case, return that type without regard to the rest of our"}]}