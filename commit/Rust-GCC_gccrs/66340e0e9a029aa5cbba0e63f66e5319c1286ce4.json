{"sha": "66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYzNDBlMGU5YTAyOWFhNWNiYmEwZTYzZjY2ZTUzMTljMTI4NmNlNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:01:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-13T10:01:38Z"}, "message": "[multiple changes]\n\n2017-01-13  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-mmap.adb, s-mmap.ads (Open_Read_No_Exception): New function.\n\t(Open_Read): Re-implement using Open_Read_No_Exception.\n\t(Open_Write): Raise exception in case of error.\n\t* s-mmosin-mingw.adb (Open_Common): Do not raise exception.\n\t* s-mmosin-unix.adb (Open_Read, Open_Write): Do not\n\treaise exception.\n\t* s-mmosin-mingw.ads, s-mmosin-unix.ads (Open_Read): Adjust comment.\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb: Code cleanup.\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* freeze.adb (Check_Inherited_Conditions): Use analyzed pragma\n\texpression instead of unanalyzed aspect expression for checking\n\tthe validity of inheriting an operation. Also copy the expression\n\tbeing passing it to Build_Class_Wide_Expression, as this call\n\tmodifies its argument.\n\t* sem_util.ads Fix comment to reference correct function name\n\tNew_Copy_Tree.\n\n2017-01-13  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_res.adb (Resolve_Generalized_Indexing): Compiling in ASIS mode,\n\twhen we propagate information about the indexes back to the original\n\tindexing mode and the prefix of the index is a function call, do not\n\tremove any parameter from such call.\n\n2017-01-13  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch6.ads (Needs_BIP_Finalization_Master): Update comment.\n\t* exp_ch6.adb (Needs_BIP_Finalization_Master): Return True for\n\ta build-in-place function whose result type is tagged.\n\n2017-01-13  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming.Build_Class_Wide_Wrapper):\n\tDo not generate a wrapper when the only candidate is a class-wide\n\tsubprogram.\n\t(Analyze_Subprogram_Renaming): Do not freeze the renaming or renamed\n\tinside a generic context.\n\nFrom-SVN: r244399", "tree": {"sha": "12f33f495cd3ec7d0d45593615bbbfd492d8805c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12f33f495cd3ec7d0d45593615bbbfd492d8805c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/comments", "author": null, "committer": null, "parents": [{"sha": "27bb79414764b83bf6c7208d6081afd01f98869f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27bb79414764b83bf6c7208d6081afd01f98869f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27bb79414764b83bf6c7208d6081afd01f98869f"}], "stats": {"total": 229, "additions": 172, "deletions": 57}, "files": [{"sha": "bb79e01b9ba732dce997c0e60fcb9af145b6031f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -1,3 +1,48 @@\n+2017-01-13  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-mmap.adb, s-mmap.ads (Open_Read_No_Exception): New function.\n+\t(Open_Read): Re-implement using Open_Read_No_Exception.\n+\t(Open_Write): Raise exception in case of error.\n+\t* s-mmosin-mingw.adb (Open_Common): Do not raise exception.\n+\t* s-mmosin-unix.adb (Open_Read, Open_Write): Do not\n+\treaise exception.\n+\t* s-mmosin-mingw.ads, s-mmosin-unix.ads (Open_Read): Adjust comment.\n+\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb: Code cleanup.\n+\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* freeze.adb (Check_Inherited_Conditions): Use analyzed pragma\n+\texpression instead of unanalyzed aspect expression for checking\n+\tthe validity of inheriting an operation. Also copy the expression\n+\tbeing passing it to Build_Class_Wide_Expression, as this call\n+\tmodifies its argument.\n+\t* sem_util.ads Fix comment to reference correct function name\n+\tNew_Copy_Tree.\n+\n+2017-01-13  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Generalized_Indexing): Compiling in ASIS mode,\n+\twhen we propagate information about the indexes back to the original\n+\tindexing mode and the prefix of the index is a function call, do not\n+\tremove any parameter from such call.\n+\n+2017-01-13  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch6.ads (Needs_BIP_Finalization_Master): Update comment.\n+\t* exp_ch6.adb (Needs_BIP_Finalization_Master): Return True for\n+\ta build-in-place function whose result type is tagged.\n+\n+2017-01-13  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming.Build_Class_Wide_Wrapper):\n+\tDo not generate a wrapper when the only candidate is a class-wide\n+\tsubprogram.\n+\t(Analyze_Subprogram_Renaming): Do not freeze the renaming or renamed\n+\tinside a generic context.\n+\n 2017-01-13  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb (Add_Inherited_Tagged_DIC):"}, {"sha": "6913e8fb9b4e6f39bf79c48e55d154e10a02b9b7", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -337,6 +337,10 @@ package body Checks is\n    --  Like Apply_Selected_Length_Checks, except it doesn't modify\n    --  anything, just returns a list of nodes as described in the spec of\n    --  this package for the Range_Check function.\n+   --  ??? In fact it does construct the test and insert it into the tree,\n+   --  and insert actions in various ways (calling Insert_Action directly\n+   --  in particular) so we do not call it in GNATprove mode, contrary to\n+   --  Selected_Range_Checks.\n \n    function Selected_Range_Checks\n      (Ck_Node    : Node_Id;\n@@ -3085,25 +3089,18 @@ package body Checks is\n           or else (not Length_Checks_Suppressed (Target_Typ));\n \n    begin\n-      --  Only apply checks when generating code. In GNATprove mode, we do\n-      --  not apply the checks, but we still call Selected_Length_Checks to\n-      --  possibly issue errors on SPARK code when a run-time error can be\n-      --  detected at compile time.\n+      --  Only apply checks when generating code\n \n       --  Note: this means that we lose some useful warnings if the expander\n       --  is not active.\n \n-      if not Expander_Active and not GNATprove_Mode then\n+      if not Expander_Active then\n          return;\n       end if;\n \n       R_Result :=\n         Selected_Length_Checks (Ck_Node, Target_Typ, Source_Typ, Empty);\n \n-      if GNATprove_Mode then\n-         return;\n-      end if;\n-\n       for J in 1 .. 2 loop\n          R_Cno := R_Result (J);\n          exit when No (R_Cno);\n@@ -9082,12 +9079,9 @@ package body Checks is\n    --  Start of processing for Selected_Length_Checks\n \n    begin\n-      --  Checks will be applied only when generating code. In GNATprove mode,\n-      --  we do not apply the checks, but we still call Selected_Length_Checks\n-      --  to possibly issue errors on SPARK code when a run-time error can be\n-      --  detected at compile time.\n+      --  Checks will be applied only when generating code\n \n-      if not Expander_Active and not GNATprove_Mode then\n+      if not Expander_Active then\n          return Ret_Result;\n       end if;\n "}, {"sha": "04122e35f16d496fac47be4c764b04c7a3eec61e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -8378,9 +8378,20 @@ package body Exp_Ch6 is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n    begin\n+      --  A formal giving the finalization master is needed for build-in-place\n+      --  functions whose result type needs finalization or is a tagged type.\n+      --  Tagged primitive build-in-place functions need such a formal because\n+      --  they can be called by a dispatching call, and extensions may require\n+      --  finalization even if the root type doesn't. This means they're also\n+      --  needed for tagged nonprimitive build-in-place functions with tagged\n+      --  results, since such functions can be called via access-to-function\n+      --  types, and those can be used to call primitives, so masters have to\n+      --  be passed to all such build-in-place functions, primitive or not.\n+\n       return\n         not Restriction_Active (No_Finalization)\n-          and then Needs_Finalization (Func_Typ);\n+          and then (Needs_Finalization (Func_Typ)\n+                     or else Is_Tagged_Type (Func_Typ));\n    end Needs_BIP_Finalization_Master;\n \n    --------------------------"}, {"sha": "249bf14a10b5c007c3626803361f79ccb008a773", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -201,7 +201,9 @@ package Exp_Ch6 is\n \n    function Needs_BIP_Finalization_Master (Func_Id : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Return True if the result subtype of function\n-   --  Func_Id needs finalization actions.\n+   --  Func_Id might need finalization actions. This includes build-in-place\n+   --  functions with tagged result types, since they can be invoked via\n+   --  dispatching calls, and descendant types may require finalization.\n \n    function Needs_Result_Accessibility_Level\n      (Func_Id : Entity_Id) return Boolean;"}, {"sha": "a4ba0e69ff5d8184bdde0e0a5bdb953c9dc1990d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -1446,18 +1446,29 @@ package body Freeze is\n          Prim := Node (Op_Node);\n          if not Comes_From_Source (Prim) and then Present (Alias (Prim)) then\n             Par_Prim := Alias (Prim);\n-            A_Pre    := Find_Aspect (Par_Prim, Aspect_Pre);\n+\n+            --  Analyze the contract items of the parent operation, before\n+            --  they are rewritten when inherited.\n+\n+            Analyze_Entry_Or_Subprogram_Contract (Par_Prim);\n+\n+            A_Pre := Get_Pragma (Par_Prim, Pragma_Precondition);\n \n             if Present (A_Pre) and then Class_Present (A_Pre) then\n+               A_Pre :=\n+                 Expression (First (Pragma_Argument_Associations (A_Pre)));\n                Build_Class_Wide_Expression\n-                 (Expression (A_Pre), Prim, Par_Prim, Adjust_Sloc => False);\n+                 (New_Copy_Tree (A_Pre), Prim, Par_Prim, Adjust_Sloc => False);\n             end if;\n \n-            A_Post := Find_Aspect (Par_Prim, Aspect_Post);\n+            A_Post := Get_Pragma (Par_Prim, Pragma_Postcondition);\n \n             if Present (A_Post) and then Class_Present (A_Post) then\n+               A_Post :=\n+                 Expression (First (Pragma_Argument_Associations (A_Post)));\n                Build_Class_Wide_Expression\n-                 (Expression (A_Post), Prim, Par_Prim, Adjust_Sloc => False);\n+                 (New_Copy_Tree (A_Post),\n+                  Prim, Par_Prim, Adjust_Sloc => False);\n             end if;\n          end if;\n "}, {"sha": "aee0ebeaad0917fdff0bf5b1522752b4530491e0", "filename": "gcc/ada/s-mmap.adb", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmap.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -112,20 +112,43 @@ package body System.Mmap is\n    procedure To_Disk (Region : Mapped_Region);\n    --  Write the region of the file back to disk if necessary, and free memory\n \n-   ---------------\n-   -- Open_Read --\n-   ---------------\n+   ----------------------------\n+   -- Open_Read_No_Exception --\n+   ----------------------------\n \n-   function Open_Read\n+   function Open_Read_No_Exception\n      (Filename              : String;\n       Use_Mmap_If_Available : Boolean := True) return Mapped_File\n    is\n       File : constant System_File :=\n          Open_Read (Filename, Use_Mmap_If_Available);\n    begin\n+      if File = Invalid_System_File then\n+         return Invalid_Mapped_File;\n+      end if;\n+\n       return new Mapped_File_Record'\n         (Current_Region => Invalid_Mapped_Region,\n          File           => File);\n+   end Open_Read_No_Exception;\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File\n+   is\n+      Res : constant Mapped_File :=\n+        Open_Read_No_Exception (Filename, Use_Mmap_If_Available);\n+   begin\n+      if Res = Invalid_Mapped_File then\n+         raise Ada.IO_Exceptions.Name_Error\n+           with \"Cannot open \" & Filename;\n+      else\n+         return Res;\n+      end if;\n    end Open_Read;\n \n    ----------------\n@@ -139,9 +162,14 @@ package body System.Mmap is\n       File : constant System_File :=\n          Open_Write (Filename, Use_Mmap_If_Available);\n    begin\n-      return new Mapped_File_Record'\n-        (Current_Region => Invalid_Mapped_Region,\n-         File           => File);\n+      if File = Invalid_System_File then\n+         raise Ada.IO_Exceptions.Name_Error\n+           with \"Cannot open \" & Filename;\n+      else\n+         return new Mapped_File_Record'\n+           (Current_Region => Invalid_Mapped_Region,\n+            File           => File);\n+      end if;\n    end Open_Write;\n \n    -----------"}, {"sha": "00b080b02ddddadaf70ccf586e44972e254f77dd", "filename": "gcc/ada/s-mmap.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmap.ads?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -140,6 +140,11 @@ package System.Mmap is\n    --  Name_Error is raised if the file does not exist.\n    --  Filename should be compatible with the filesystem.\n \n+   function Open_Read_No_Exception\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File;\n+   --  Like Open_Read but return Invalid_Mapped_File in case of error\n+\n    function Open_Write\n      (Filename              : String;\n       Use_Mmap_If_Available : Boolean := True) return Mapped_File;"}, {"sha": "b850630d53cb0b8dd5fdbe43f1ce6c832233ae6f", "filename": "gcc/ada/s-mmosin-mingw.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-mingw.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -32,6 +32,11 @@\n with Ada.IO_Exceptions;\n with System.Strings; use System.Strings;\n \n+with System.OS_Lib;\n+pragma Unreferenced (System.OS_Lib);\n+--  Only used to generate same runtime dependencies and same binder file on\n+--  GNU/Linux and Windows.\n+\n package body System.Mmap.OS_Interface is\n \n    use Win;\n@@ -126,16 +131,15 @@ package body System.Mmap.OS_Interface is\n          null, OPEN_EXISTING, Win.FILE_ATTRIBUTE_NORMAL, 0);\n \n       if File_Handle = Win.INVALID_HANDLE_VALUE then\n-         raise Ada.IO_Exceptions.Name_Error\n-           with \"Cannot open \" & Filename;\n+         return Invalid_System_File;\n       end if;\n \n       --  Compute its size\n \n       Size := File_Size (Win.GetFileSize (File_Handle, SizeH'Access));\n \n       if Size = Win.INVALID_FILE_SIZE then\n-         raise Ada.IO_Exceptions.Use_Error;\n+         return Invalid_System_File;\n       end if;\n \n       if SizeH /= 0 and then File_Size'Size > 32 then"}, {"sha": "ad296c1c5dc1f379ec87bc1ca4b82de5a976ef65", "filename": "gcc/ada/s-mmosin-mingw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-mingw.ads?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -191,8 +191,8 @@ package System.Mmap.OS_Interface is\n    function Open_Read\n      (Filename              : String;\n       Use_Mmap_If_Available : Boolean := True) return System_File;\n-   --  Open a file for reading and return the corresponding System_File. Raise\n-   --  a Ada.IO_Exceptions.Name_Error if unsuccessful.\n+   --  Open a file for reading and return the corresponding System_File. Return\n+   --  Invalid_System_File if unsuccessful.\n \n    function Open_Write\n      (Filename              : String;"}, {"sha": "634d980cb2972fd19168ee036e4bc4378fd8425d", "filename": "gcc/ada/s-mmosin-unix.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-unix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-unix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-unix.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -57,8 +57,7 @@ package body System.Mmap.OS_Interface is\n         Open_Read (Filename, Binary);\n    begin\n       if Fd = Invalid_FD then\n-         raise Ada.IO_Exceptions.Name_Error\n-           with \"Cannot open \" & Filename;\n+         return Invalid_System_File;\n       end if;\n       return\n         (Fd     => Fd,\n@@ -78,8 +77,7 @@ package body System.Mmap.OS_Interface is\n         Open_Read_Write (Filename, Binary);\n    begin\n       if Fd = Invalid_FD then\n-         raise Ada.IO_Exceptions.Name_Error\n-         with \"Cannot open \" & Filename;\n+         return Invalid_System_File;\n       end if;\n       return\n         (Fd     => Fd,"}, {"sha": "002bf7743517c4e8cea05731ce5cffbd0a3deca5", "filename": "gcc/ada/s-mmosin-unix.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-unix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fs-mmosin-unix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-unix.ads?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -61,8 +61,8 @@ package System.Mmap.OS_Interface is\n    function Open_Read\n      (Filename              : String;\n       Use_Mmap_If_Available : Boolean := True) return System_File;\n-   --  Open a file for reading and return the corresponding System_File. Raise\n-   --  a Ada.IO_Exceptions.Name_Error if unsuccessful.\n+   --  Open a file for reading and return the corresponding System_File. Return\n+   --  Invalid_System_File if unsuccessful.\n \n    function Open_Write\n      (Filename              : String;"}, {"sha": "6ada187b60c7152b936d25253867ed364d04da70", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -1888,8 +1888,10 @@ package body Sem_Ch8 is\n       --\n       --  This transformation applies only if there is no explicit visible\n       --  class-wide operation at the point of the instantiation. Ren_Id is\n-      --  the entity of the renaming declaration. Wrap_Id is the entity of\n-      --  the generated class-wide wrapper (or Any_Id).\n+      --  the entity of the renaming declaration. When the transformation\n+      --  applies, Wrap_Id is the entity of the generated class-wide wrapper\n+      --  (or Any_Id). Otherwise, Wrap_Id is the entity of the class-wide\n+      --  operation.\n \n       procedure Check_Null_Exclusion\n         (Ren : Entity_Id;\n@@ -2372,6 +2374,16 @@ package body Sem_Ch8 is\n          Set_Is_Overloaded (Name (N), False);\n          Set_Referenced    (Prim_Op);\n \n+         --  Do not generate a wrapper when the only candidate is a class-wide\n+         --  subprogram. Instead modify the renaming to directly map the actual\n+         --  to the generic formal.\n+\n+         if CW_Prim_OK and then Prim_Op = CW_Prim_Op then\n+            Wrap_Id := Prim_Op;\n+            Rewrite (Nam, New_Occurrence_Of (Prim_Op, Loc));\n+            return;\n+         end if;\n+\n          --  Step 3: Create the declaration and the body of the wrapper, insert\n          --  all the pieces into the tree.\n \n@@ -3391,7 +3403,12 @@ package body Sem_Ch8 is\n             Set_Alias (New_S, Empty);\n          end if;\n \n-         if Is_Actual then\n+         --  Do not freeze the renaming nor the renamed entity when the context\n+         --  is an enclosing generic. Freezing is an expansion activity, and in\n+         --  addition the renamed entity may depend on the generic formals of\n+         --  the enclosing generic.\n+\n+         if Is_Actual and not Inside_A_Generic then\n             Freeze_Before (N, Old_S);\n             Freeze_Actual_Profile;\n             Set_Has_Delayed_Freeze (New_S, False);"}, {"sha": "85f74de2afd0d637593c38ac5a427a71c363d09d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -8112,7 +8112,7 @@ package body Sem_Res is\n          end loop;\n \n          if Nkind (Call) = N_Function_Call then\n-            Indexes := Parameter_Associations (Call);\n+            Indexes := New_Copy_List (Parameter_Associations (Call));\n             Pref := Remove_Head (Indexes);\n             Set_Expressions (N, Indexes);\n "}, {"sha": "1e84fa55c7701ded943e64a8cd5c5e52a2d78c82", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66340e0e9a029aa5cbba0e63f66e5319c1286ce4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=66340e0e9a029aa5cbba0e63f66e5319c1286ce4", "patch": "@@ -1849,21 +1849,21 @@ package Sem_Util is\n       Map       : Elist_Id   := No_Elist;\n       New_Sloc  : Source_Ptr := No_Location;\n       New_Scope : Entity_Id  := Empty) return Node_Id;\n-   --  Given a node that is the root of a subtree, Copy_Tree copies the entire\n-   --  syntactic subtree, including recursively any descendants whose parent\n-   --  field references a copied node (descendants not linked to a copied node\n-   --  by the parent field are not copied, instead the copied tree references\n-   --  the same descendant as the original in this case, which is appropriate\n-   --  for non-syntactic fields such as Etype). The parent pointers in the\n-   --  copy are properly set. Copy_Tree (Empty/Error) returns Empty/Error.\n-   --  The one exception to the rule of not copying semantic fields is that\n-   --  any implicit types attached to the subtree are duplicated, so that\n-   --  the copy contains a distinct set of implicit type entities. Thus this\n-   --  function is used when it is necessary to duplicate an analyzed tree,\n-   --  declared in the same or some other compilation unit. This function is\n-   --  declared here rather than in atree because it uses semantic information\n-   --  in particular concerning the structure of itypes and the generation of\n-   --  public symbols.\n+   --  Given a node that is the root of a subtree, New_Copy_Tree copies the\n+   --  entire syntactic subtree, including recursively any descendants whose\n+   --  parent field references a copied node (descendants not linked to a\n+   --  copied node by the parent field are not copied, instead the copied tree\n+   --  references the same descendant as the original in this case, which is\n+   --  appropriate for non-syntactic fields such as Etype). The parent pointers\n+   --  in the copy are properly set. New_Copy_Tree (Empty/Error) returns\n+   --  Empty/Error. The one exception to the rule of not copying semantic\n+   --  fields is that any implicit types attached to the subtree are\n+   --  duplicated, so that the copy contains a distinct set of implicit type\n+   --  entities. Thus this function is used when it is necessary to duplicate\n+   --  an analyzed tree, declared in the same or some other compilation unit.\n+   --  This function is declared here rather than in atree because it uses\n+   --  semantic information in particular concerning the structure of itypes\n+   --  and the generation of public symbols.\n \n    --  The Map argument, if set to a non-empty Elist, specifies a set of\n    --  mappings to be applied to entities in the tree. The map has the form:"}]}