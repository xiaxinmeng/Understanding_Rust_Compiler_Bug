{"sha": "265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "node_id": "C_kwDOANBUbNoAKDI2NWE3NDlmMjkwZjdjNmFkYzlhM2FhYTljNTg1YjQ5OGE4YTM4ZWE", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-01-24T21:10:59Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-01-24T21:13:36Z"}, "message": "LRA: Always do elimination and only for hard register to check insn constraints\n\nLRA does elimination but not always checks insn constraints in this case.\nThis results in LRA failure for PDP11 target whose addition is only 2-op insn.\nThe same might happen for other analogous targets.  The patch fixes this problem.\n\n        PR rtl-optimization/108388\n\ngcc/ChangeLog:\n\n\t* lra-constraints.cc (get_hard_regno): Remove final_p arg.  Always\n\tdo elimination but only for hard register.\n\t(operands_match_p, uses_hard_regs_p, process_alt_operands): Adjust\n\tcalls of get_hard_regno.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pdp11/pdp11.exp: New.\n\t* gcc.target/pdp11/pr108388.c: New.", "tree": {"sha": "4c4c550d7af39bfcafc1ac88d3d55ec926fc67f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c4c550d7af39bfcafc1ac88d3d55ec926fc67f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c96382eed96a9285611f2e3e2e59557094172b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c96382eed96a9285611f2e3e2e59557094172b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c96382eed96a9285611f2e3e2e59557094172b8"}], "stats": {"total": 151, "additions": 141, "deletions": 10}, "files": [{"sha": "7bffbc07ee2331cd7bd6ad3d075e0c6a3c83a00b", "filename": "gcc/lra-constraints.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Flra-constraints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Flra-constraints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.cc?ref=265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "patch": "@@ -184,12 +184,12 @@ get_try_hard_regno (int regno)\n   return ira_class_hard_regs[rclass][0];\n }\n \n-/* Return the hard regno of X after removing its subreg.  If X is not\n-   a register or a subreg of a register, return -1.  If X is a pseudo,\n-   use its assignment.  If FINAL_P return the final hard regno which will\n-   be after elimination.  */\n+/* Return the hard regno of X after removing its subreg.  If X is not a\n+   register or a subreg of a register, return -1.  If X is a pseudo, use its\n+   assignment.  If X is a hard regno, return the final hard regno which will be\n+   after elimination.  */\n static int\n-get_hard_regno (rtx x, bool final_p)\n+get_hard_regno (rtx x)\n {\n   rtx reg;\n   int hard_regno;\n@@ -203,7 +203,7 @@ get_hard_regno (rtx x, bool final_p)\n     hard_regno = lra_get_regno_hard_regno (hard_regno);\n   if (hard_regno < 0)\n     return -1;\n-  if (final_p)\n+  if (HARD_REGISTER_NUM_P (REGNO (reg)))\n     hard_regno = lra_get_elimination_hard_regno (hard_regno);\n   if (SUBREG_P (x))\n     hard_regno += subreg_regno_offset (hard_regno, GET_MODE (reg),\n@@ -782,7 +782,7 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n     {\n       int j;\n \n-      i = get_hard_regno (x, false);\n+      i = get_hard_regno (x);\n       if (i < 0)\n \tgoto slow;\n \n@@ -1920,7 +1920,7 @@ uses_hard_regs_p (rtx x, HARD_REG_SET set)\n \n   if (REG_P (x) || SUBREG_P (x))\n     {\n-      x_hard_regno = get_hard_regno (x, true);\n+      x_hard_regno = get_hard_regno (x);\n       return (x_hard_regno >= 0\n \t      && overlaps_hard_reg_set_p (set, mode, x_hard_regno));\n     }\n@@ -2078,7 +2078,7 @@ process_alt_operands (int only_alternative)\n \n       op = no_subreg_reg_operand[nop] = *curr_id->operand_loc[nop];\n       /* The real hard regno of the operand after the allocation.  */\n-      hard_regno[nop] = get_hard_regno (op, true);\n+      hard_regno[nop] = get_hard_regno (op);\n \n       operand_reg[nop] = reg = op;\n       biggest_mode[nop] = GET_MODE (op);\n@@ -2258,7 +2258,7 @@ process_alt_operands (int only_alternative)\n \t\t\t&& curr_operand_mode[m] != curr_operand_mode[nop])\n \t\t      break;\n \t\t    \n-\t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m], false);\n+\t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m]);\n \t\t    /* We are supposed to match a previous operand.\n \t\t       If we do, we win if that one did.  If we do\n \t\t       not, count both of the operands as losers."}, {"sha": "89b1f257329b2dafd8a72851074d9a265dc00580", "filename": "gcc/testsuite/gcc.target/pdp11/pdp11.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpdp11.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpdp11.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpdp11.exp?ref=265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "patch": "@@ -0,0 +1,41 @@\n+# Copyright (C) 2023 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an pdp11 target.\n+if ![istarget pdp11*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "0d54b915c754232adcdd7caeb31dac825f561867", "filename": "gcc/testsuite/gcc.target/pdp11/pr108388.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpr108388.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265a749f290f7c6adc9a3aaa9c585b498a8a38ea/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpr108388.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpdp11%2Fpr108388.c?ref=265a749f290f7c6adc9a3aaa9c585b498a8a38ea", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mlra\" } */\n+\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+extern DItype __mulvdi3 (DItype, DItype);\n+struct DWstruct {SItype high, low;};\n+\n+typedef union {\n+  struct DWstruct s;\n+  DItype ll;\n+} DWunion;\n+\n+DItype __mulvdi3 (DItype u, DItype v) {\n+  const DWunion uu = {.ll = u};\n+  const DWunion vv = {.ll = v};\n+  \n+  if (__builtin_expect (uu.s.high == uu.s.low >> ((4 * 8) - 1), 1)) {\n+    if (__builtin_expect (vv.s.high == vv.s.low >> ((4 * 8) - 1), 1)) {\n+      return (DItype) uu.s.low * (DItype) vv.s.low;\n+    } else {\n+      DWunion w0 = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low};\n+      DWunion w1 = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.high};\n+      \n+      if (vv.s.high < 0)\n+\tw1.s.high -= uu.s.low;\n+      if (uu.s.low < 0)\n+\tw1.ll -= vv.ll;\n+      w1.ll += (USItype) w0.s.high;\n+      if (__builtin_expect (w1.s.high == w1.s.low >> ((4 * 8) - 1), 1))\t{\n+\tw0.s.high = w1.s.low;\n+\treturn w0.ll;\n+      }\n+    }\n+  } else {\n+    if (__builtin_expect (vv.s.high == vv.s.low >> ((4 * 8) - 1), 1)) {\n+      DWunion w0 = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low};\n+      DWunion w1 = {.ll = (UDItype) (USItype) uu.s.high * (UDItype) (USItype) vv.s.low};\n+\n+      if (uu.s.high < 0)\n+\tw1.s.high -= vv.s.low;\n+      if (vv.s.low < 0)\n+\tw1.ll -= uu.ll;\n+      w1.ll += (USItype) w0.s.high;\n+      if (__builtin_expect (w1.s.high == w1.s.low >> ((4 * 8) - 1), 1))\t{\n+\tw0.s.high = w1.s.low;\n+\treturn w0.ll;\n+      }\n+    } else {\n+      if (uu.s.high >= 0) {\n+\tif (vv.s.high >= 0) {\n+\t  if (uu.s.high == 0 && vv.s.high == 0) {\n+\t    const DItype w = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low;\n+\t    if (__builtin_expect (w >= 0, 1))\n+\t      return w;\n+\t  }\n+\t} else {\n+\t  if (uu.s.high == 0 && vv.s.high == (SItype) -1) {\n+\t    DWunion ww = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low};\n+\t    ww.s.high -= uu.s.low;\n+\t    if (__builtin_expect (ww.s.high < 0, 1))\n+\t      return ww.ll;\n+\t  }\n+\t}\n+      } else {\n+\tif (vv.s.high >= 0) {\n+\t  if (uu.s.high == (SItype) -1 && vv.s.high == 0) {\n+\t    DWunion ww = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low};\n+\t    \n+\t    ww.s.high -= vv.s.low;\n+\t    if (__builtin_expect (ww.s.high < 0, 1))\n+\t      return ww.ll;\n+\t  }\n+\t} else {\n+\t  if ((uu.s.high & vv.s.high) == (SItype) -1 && (uu.s.low | vv.s.low) != 0) {\n+\t      DWunion ww = {.ll = (UDItype) (USItype) uu.s.low * (UDItype) (USItype) vv.s.low};\n+\t      \n+\t      ww.s.high -= uu.s.low;\n+\t      ww.s.high -= vv.s.low;\n+\t      if (__builtin_expect (ww.s.high >= 0, 1))\n+\t\treturn ww.ll;\n+\t  }\n+\t}\n+      }\n+    }\n+  }\n+  __builtin_trap ();\n+}"}]}