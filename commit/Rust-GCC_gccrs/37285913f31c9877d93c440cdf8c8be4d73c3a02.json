{"sha": "37285913f31c9877d93c440cdf8c8be4d73c3a02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcyODU5MTNmMzFjOTg3N2Q5M2M0NDBjZGY4YzhiZTRkNzNjM2EwMg==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2014-10-17T12:21:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-10-17T12:21:21Z"}, "message": "Implement the Library Fundamentals v1 variable templates.\n\n2014-10-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n\n\tImplement the Library Fundamentals v1 variable templates.\n\t* include/Makefile.am: Add the new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/type_traits: New.\n\t* testsuite/experimental/type_traits/value.cc: Likewise.\n\nFrom-SVN: r216397", "tree": {"sha": "667f86f8afb1788bbacb0b3f55772404d9122994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/667f86f8afb1788bbacb0b3f55772404d9122994"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37285913f31c9877d93c440cdf8c8be4d73c3a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37285913f31c9877d93c440cdf8c8be4d73c3a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37285913f31c9877d93c440cdf8c8be4d73c3a02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37285913f31c9877d93c440cdf8c8be4d73c3a02/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a342326069ab45d77f0e508983321e613c4acac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a342326069ab45d77f0e508983321e613c4acac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a342326069ab45d77f0e508983321e613c4acac2"}], "stats": {"total": 564, "additions": 562, "deletions": 2}, "files": [{"sha": "b915a0b85b1f67f16498aad3192176cdc2b76309", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=37285913f31c9877d93c440cdf8c8be4d73c3a02", "patch": "@@ -1,3 +1,11 @@\n+2014-10-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement the Library Fundamentals v1 variable templates.\n+\t* include/Makefile.am: Add the new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/experimental/type_traits: New.\n+\t* testsuite/experimental/type_traits/value.cc: Likewise.\n+\n 2014-10-16  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/lib/libstdc++.exp: Prefer -std=gnu++11."}, {"sha": "1ee8ddcb38d10f3900c6ae7961e49759445b0ed8", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=37285913f31c9877d93c440cdf8c8be4d73c3a02", "patch": "@@ -643,7 +643,8 @@ experimental_headers = \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/string_view.tcc \\\n-\t${experimental_srcdir}/tuple\n+\t${experimental_srcdir}/tuple \\\n+\t${experimental_srcdir}/type_traits\n \n # This is the common subset of C++ files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)"}, {"sha": "a2262e898c476beda9c27879cae5082002e94de0", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=37285913f31c9877d93c440cdf8c8be4d73c3a02", "patch": "@@ -909,7 +909,8 @@ experimental_headers = \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/string_view.tcc \\\n-\t${experimental_srcdir}/tuple\n+\t${experimental_srcdir}/tuple \\\n+\t${experimental_srcdir}/type_traits\n \n \n # This is the common subset of C++ files that all three \"C\" header models use."}, {"sha": "93dd8ce394597fe2e515cecfc83b2ed9029174d9", "filename": "libstdc++-v3/include/experimental/type_traits", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftype_traits?ref=37285913f31c9877d93c440cdf8c8be4d73c3a02", "patch": "@@ -0,0 +1,226 @@\n+// Variable Templates For Type Traits -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/type_traits\n+ *  This is a TS C++ Library header.\n+ */\n+\n+//\n+// N3932 Variable Templates For Type Traits (Revision 1)\n+//\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_TYPE_TRAITS\n+#define _GLIBCXX_EXPERIMENTAL_TYPE_TRAITS 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <type_traits>\n+\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+inline namespace fundamentals_v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+// See C++14 \u00a720.10.4.1, primary type categories\n+template <typename _Tp>\n+  constexpr bool is_void_v = is_void<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_integral_v = is_integral<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_array_v = is_array<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_pointer_v = is_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_member_object_pointer_v =\n+    is_member_object_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_member_function_pointer_v =\n+    is_member_function_pointer<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_enum_v = is_enum<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_union_v = is_union<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_class_v = is_class<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_function_v = is_function<_Tp>::value;\n+\n+// See C++14 \u00a720.10.4.2, composite type categories\n+template <typename _Tp>\n+  constexpr bool is_reference_v = is_reference<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_object_v = is_object<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_scalar_v = is_scalar<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_compound_v = is_compound<_Tp>::value;\n+template <typename _Tp>\n+ constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;\n+\n+// See C++14 \u00a720.10.4.3, type properties\n+template <typename _Tp>\n+  constexpr bool is_const_v = is_const<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_volatile_v = is_volatile<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivial_v = is_trivial<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_pod_v = is_pod<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_empty_v = is_empty<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_abstract_v = is_abstract<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_final_v = is_final<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_signed_v = is_signed<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_constructible_v = is_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_default_constructible_v =\n+    is_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_destructible_v = is_destructible<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_trivially_constructible_v =\n+    is_trivially_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_default_constructible_v =\n+    is_trivially_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copy_constructible_v =\n+    is_trivially_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_move_constructible_v =\n+    is_trivially_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_trivially_assignable_v =\n+    is_trivially_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_copy_assignable_v =\n+    is_trivially_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_move_assignable_v =\n+    is_trivially_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_trivially_destructible_v =\n+    is_trivially_destructible<_Tp>::value;\n+template <typename _Tp, typename... _Args>\n+  constexpr bool is_nothrow_constructible_v =\n+    is_nothrow_constructible<_Tp, _Args...>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_default_constructible_v =\n+    is_nothrow_default_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_copy_constructible_v =\n+    is_nothrow_copy_constructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_move_constructible_v =\n+    is_nothrow_move_constructible<_Tp>::value;\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_nothrow_assignable_v =\n+    is_nothrow_assignable<_Tp, _Up>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_copy_assignable_v =\n+    is_nothrow_copy_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_move_assignable_v =\n+    is_nothrow_move_assignable<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool is_nothrow_destructible_v =\n+    is_nothrow_destructible<_Tp>::value;\n+template <typename _Tp>\n+  constexpr bool has_virtual_destructor_v =\n+    has_virtual_destructor<_Tp>::value;\n+\n+// See C++14 \u00a720.10.5, type property queries\n+template <typename _Tp>\n+  constexpr size_t alignment_of_v = alignment_of<_Tp>::value;\n+template <typename _Tp>\n+  constexpr size_t rank_v = rank<_Tp>::value;\n+template <typename _Tp, unsigned _Idx = 0>\n+  constexpr size_t extent_v = extent<_Tp, _Idx>::value;\n+\n+// See C++14 \u00a720.10.6, type relations\n+template <typename _Tp, typename _Up>\n+  constexpr bool is_same_v = is_same<_Tp, _Up>::value;\n+template <typename _Base, typename _Derived>\n+  constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;\n+template <typename _From, typename _To>\n+  constexpr bool is_convertible_v = is_convertible<_From, _To>::value;\n+\n+\n+  // 3.3.2, Other type transformations\n+  // invocation_type (still unimplemented)\n+  // raw_invocation_type (still unimplemented)\n+  // invocation_type_t (still unimplemented)\n+  // raw_invocation_type_t (still unimplemented)\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v1\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // __cplusplus <= 201103L\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_TYPE_TRAITS"}, {"sha": "b8d9fe1f950c74121bf3c620f2a3f9d6d3e489cd", "filename": "libstdc++-v3/testsuite/experimental/type_traits/value.cc", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_traits%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37285913f31c9877d93c440cdf8c8be4d73c3a02/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_traits%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ftype_traits%2Fvalue.cc?ref=37285913f31c9877d93c440cdf8c8be4d73c3a02", "patch": "@@ -0,0 +1,324 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/type_traits>\n+\n+using namespace std;\n+using namespace std::experimental;\n+\n+// These tests are rather simple, the front-end tests already test\n+// variable templates, and the library tests for the underlying\n+// traits are more elaborate. These are just simple sanity tests.\n+\n+static_assert(is_void_v<void> && is_void<void>::value, \"\");\n+static_assert(!is_void_v<int> && !is_void<int>::value, \"\");\n+\n+static_assert(is_null_pointer_v<nullptr_t>\n+\t      && is_null_pointer<nullptr_t>::value, \"\");\n+static_assert(!is_null_pointer_v<void*>\n+\t      && !is_null_pointer<void*>::value, \"\");\n+\n+static_assert(is_integral_v<int> && is_integral<int>::value, \"\");\n+static_assert(!is_integral_v<int*> && !is_integral<int*>::value, \"\");\n+\n+static_assert(is_floating_point_v<float>\n+\t      && is_floating_point<float>::value, \"\");\n+static_assert(!is_floating_point_v<int>\n+\t      && !is_floating_point<int>::value, \"\");\n+\n+static_assert(is_array_v<char[42]> && is_array<char[42]>::value, \"\");\n+static_assert(!is_array_v<char*> && !is_array<char*>::value, \"\");\n+\n+static_assert(is_pointer_v<int*> && is_pointer<int*>::value, \"\");\n+static_assert(!is_pointer_v<int> && !is_pointer<int>::value, \"\");\n+\n+static_assert(is_lvalue_reference_v<int&>\n+\t      && is_lvalue_reference<int&>::value, \"\");\n+static_assert(!is_lvalue_reference_v<int>\n+\t      && !is_lvalue_reference<int>::value, \"\");\n+\n+static_assert(is_rvalue_reference_v<int&&>\n+\t      && is_rvalue_reference<int&&>::value, \"\");\n+static_assert(!is_rvalue_reference_v<int>\n+\t      && !is_rvalue_reference<int>::value, \"\");\n+\n+struct EmptyFinal final {};\n+\n+static_assert(is_member_object_pointer_v<int (EmptyFinal::*)>\n+\t      && is_member_object_pointer<int (EmptyFinal::*)>::value, \"\");\n+static_assert(!is_member_object_pointer_v<void*>\n+\t      && !is_member_object_pointer<void*>::value, \"\");\n+\n+static_assert(is_member_function_pointer_v<int (EmptyFinal::*)()>\n+\t      && is_member_function_pointer<int (EmptyFinal::*)()>::value, \"\");\n+static_assert(!is_member_function_pointer_v<void*>\n+\t      && !is_member_function_pointer<void*>::value, \"\");\n+\n+enum Enum {};\n+\n+static_assert(is_enum_v<Enum> && is_enum<Enum>::value, \"\");\n+static_assert(!is_enum_v<int> && !is_enum<int>::value, \"\");\n+\n+union Union;\n+\n+static_assert(is_union_v<Union> && is_union<Union>::value, \"\");\n+static_assert(!is_union_v<int> && !is_union<int>::value, \"\");\n+\n+static_assert(is_class_v<EmptyFinal> && is_class<EmptyFinal>::value, \"\");\n+static_assert(!is_class_v<int> && !is_class<int>::value, \"\");\n+\n+static_assert(is_function_v<void()> && is_function<void()>::value, \"\");\n+static_assert(!is_function_v<void(*)()> && !is_function<void(*)()>::value, \"\");\n+\n+static_assert(is_reference_v<int&> && is_reference<int&>::value, \"\");\n+static_assert(!is_reference_v<int> && !is_reference<int>::value, \"\");\n+\n+static_assert(is_arithmetic_v<int> && is_arithmetic<int>::value, \"\");\n+static_assert(!is_arithmetic_v<void*> && !is_arithmetic<void*>::value, \"\");\n+\n+static_assert(is_fundamental_v<int> && is_fundamental<int>::value, \"\");\n+static_assert(!is_fundamental_v<EmptyFinal>\n+\t      && !is_fundamental<EmptyFinal>::value, \"\");\n+\n+static_assert(is_object_v<int> && is_object<int>::value, \"\");\n+static_assert(!is_object_v<int&> && !is_object<int&>::value, \"\");\n+\n+static_assert(is_scalar_v<int> && is_scalar<int>::value, \"\");\n+static_assert(!is_scalar_v<int&> && !is_scalar<int&>::value, \"\");\n+\n+static_assert(is_compound_v<EmptyFinal>\n+\t      && is_compound<EmptyFinal>::value, \"\");\n+static_assert(!is_compound_v<int> && !is_compound<int>::value, \"\");\n+\n+static_assert(is_member_pointer_v<int (EmptyFinal::*)>\n+\t      && is_member_pointer<int (EmptyFinal::*)>::value, \"\");\n+static_assert(!is_member_pointer_v<void*>\n+\t      && !is_member_pointer<void*>::value, \"\");\n+\n+static_assert(is_const_v<const int> && is_const<const int>::value, \"\");\n+static_assert(!is_const_v<int> && !is_const<int>::value, \"\");\n+\n+static_assert(is_volatile_v<volatile int>\n+\t      && is_volatile<volatile int>::value, \"\");\n+static_assert(!is_volatile_v<int> && !is_volatile<int>::value, \"\");\n+\n+struct NType\n+{\n+  NType(int);\n+  ~NType();\n+  int i;\n+private:\n+  NType(const NType&);\n+  NType& operator=(const NType&);\n+  int i2;\n+};\n+\n+static_assert(is_trivial_v<int> && is_trivial<int>::value, \"\");\n+static_assert(!is_trivial_v<NType> && !is_trivial<NType>::value, \"\");\n+\n+static_assert(is_trivially_copyable_v<int>\n+\t      && is_trivially_copyable<int>::value, \"\");\n+static_assert(!is_trivially_copyable_v<NType>\n+\t      && !is_trivially_copyable<NType>::value, \"\");\n+\n+static_assert(is_standard_layout_v<int>\n+\t      && is_standard_layout<int>::value, \"\");\n+static_assert(!is_standard_layout_v<NType>\n+\t      && !is_standard_layout<NType>::value, \"\");\n+\n+static_assert(is_pod_v<int>\n+\t      && is_pod<int>::value, \"\");\n+static_assert(!is_pod_v<NType>\n+\t      && !is_pod<NType>::value, \"\");\n+\n+static_assert(is_literal_type_v<int>\n+\t      && is_literal_type<int>::value, \"\");\n+static_assert(!is_literal_type_v<NType>\n+\t      && !is_literal_type<NType>::value, \"\");\n+\n+static_assert(is_empty_v<EmptyFinal>\n+\t      && is_empty<EmptyFinal>::value, \"\");\n+static_assert(!is_empty_v<NType>\n+\t      && !is_empty<NType>::value, \"\");\n+\n+struct Abstract {protected: virtual ~Abstract() = 0;};\n+struct Poly : Abstract {virtual ~Poly();};\n+\n+static_assert(is_polymorphic_v<Poly>\n+\t      && is_polymorphic<Poly>::value, \"\");\n+static_assert(!is_polymorphic_v<EmptyFinal>\n+\t      && !is_polymorphic<EmptyFinal>::value, \"\");\n+\n+\n+\n+static_assert(is_abstract_v<Abstract>\n+\t      && is_abstract<Abstract>::value, \"\");\n+static_assert(!is_abstract_v<EmptyFinal>\n+\t      && !is_abstract<EmptyFinal>::value, \"\");\n+\n+static_assert(is_final_v<EmptyFinal>\n+\t      && is_final<EmptyFinal>::value, \"\");\n+static_assert(!is_final_v<Abstract>\n+\t      && !is_final<Abstract>::value, \"\");\n+\n+static_assert(is_signed_v<int> && is_signed<int>::value, \"\");\n+static_assert(!is_signed_v<unsigned int>\n+\t      && !is_signed<unsigned int>::value, \"\");\n+\n+static_assert(is_constructible_v<int, int>\n+\t      && is_constructible<int, int>::value, \"\");\n+static_assert(!is_constructible_v<int, void*>\n+\t      && !is_constructible<int, void*>::value, \"\");\n+\n+static_assert(is_default_constructible_v<int>\n+\t      && is_default_constructible<int>::value, \"\");\n+static_assert(!is_default_constructible_v<NType>\n+\t      && !is_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_copy_constructible_v<int>\n+\t      && is_copy_constructible<int>::value, \"\");\n+static_assert(!is_copy_constructible_v<NType>\n+\t      && !is_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_move_constructible_v<int>\n+\t      && is_copy_constructible<int>::value, \"\");\n+static_assert(!is_move_constructible_v<NType>\n+\t      && !is_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_assignable_v<int&, int>\n+\t      && is_assignable<int&, int>::value, \"\");\n+static_assert(!is_assignable_v<int, int>\n+\t      && !is_assignable<int, int>::value, \"\");\n+\n+static_assert(is_copy_assignable_v<int>\n+\t      && is_copy_assignable<int>::value, \"\");\n+static_assert(!is_copy_assignable_v<NType>\n+\t      && !is_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_move_assignable_v<int>\n+\t      && is_move_assignable<int>::value, \"\");\n+static_assert(!is_move_assignable_v<NType>\n+\t      && !is_move_assignable<NType>::value, \"\");\n+\n+static_assert(is_destructible_v<int>\n+\t      && is_destructible<int>::value, \"\");\n+static_assert(!is_destructible_v<Abstract>\n+\t      && !is_destructible<Abstract>::value, \"\");\n+\n+static_assert(is_trivially_constructible_v<int, int>\n+\t      && is_trivially_constructible<int, int>::value, \"\");\n+static_assert(!is_trivially_constructible_v<NType, NType>\n+\t      && !is_trivially_constructible<NType, NType>::value, \"\");\n+\n+static_assert(is_trivially_default_constructible_v<int>\n+\t      && is_trivially_default_constructible<int>::value, \"\");\n+static_assert(!is_trivially_default_constructible_v<NType>\n+\t      && !is_trivially_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_copy_constructible_v<int>\n+\t      && is_trivially_copy_constructible<int>::value, \"\");\n+static_assert(!is_trivially_copy_constructible_v<NType>\n+\t      && !is_trivially_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_move_constructible_v<int>\n+\t      && is_trivially_move_constructible<int>::value, \"\");\n+static_assert(!is_trivially_move_constructible_v<NType>\n+\t      && !is_trivially_move_constructible<NType>::value, \"\");\n+\n+static_assert(is_trivially_assignable_v<int&, int>\n+\t      && is_trivially_assignable<int&, int>::value, \"\");\n+static_assert(!is_trivially_assignable_v<NType, NType>\n+\t      && !is_trivially_assignable<NType, NType>::value, \"\");\n+\n+static_assert(is_trivially_copy_assignable_v<int>\n+\t      && is_trivially_copy_assignable<int>::value, \"\");\n+static_assert(!is_trivially_copy_assignable_v<NType>\n+\t      && !is_trivially_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_trivially_move_assignable_v<int>\n+\t      && is_trivially_move_assignable<int>::value, \"\");\n+static_assert(!is_trivially_move_assignable_v<NType>\n+\t      && !is_trivially_move_assignable<NType>::value, \"\");\n+\n+static_assert(is_trivially_destructible_v<int>\n+\t      && is_trivially_destructible<int>::value, \"\");\n+static_assert(!is_trivially_destructible_v<Abstract>\n+\t      && !is_trivially_destructible<Abstract>::value, \"\");\n+\n+static_assert(is_nothrow_constructible_v<int, int>\n+\t      && is_nothrow_constructible<int, int>::value, \"\");\n+static_assert(!is_nothrow_constructible_v<NType, NType>\n+\t      && !is_nothrow_constructible<NType, NType>::value, \"\");\n+\n+static_assert(is_nothrow_default_constructible_v<int>\n+\t      && is_nothrow_default_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_default_constructible_v<NType>\n+\t      && !is_nothrow_default_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_copy_constructible_v<int>\n+\t      && is_nothrow_copy_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_copy_constructible_v<NType>\n+\t      && !is_nothrow_copy_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_move_constructible_v<int>\n+\t      && is_nothrow_move_constructible<int>::value, \"\");\n+static_assert(!is_nothrow_move_constructible_v<NType>\n+\t      && !is_nothrow_move_constructible<NType>::value, \"\");\n+\n+static_assert(is_nothrow_assignable_v<int&, int>\n+\t      && is_nothrow_assignable<int&, int>::value, \"\");\n+static_assert(!is_nothrow_assignable_v<NType, NType>\n+\t      && !is_nothrow_assignable<NType, NType>::value, \"\");\n+\n+static_assert(is_nothrow_copy_assignable_v<int>\n+\t      && is_nothrow_copy_assignable<int>::value, \"\");\n+static_assert(!is_nothrow_copy_assignable_v<NType>\n+\t      && !is_nothrow_copy_assignable<NType>::value, \"\");\n+\n+static_assert(is_nothrow_move_assignable_v<int>\n+\t      && is_nothrow_move_assignable<int>::value, \"\");\n+static_assert(!is_nothrow_move_assignable_v<NType>\n+\t      && !is_nothrow_move_assignable<NType>::value, \"\");\n+\n+static_assert(has_virtual_destructor_v<Abstract>\n+\t      && has_virtual_destructor<Abstract>::value, \"\");\n+static_assert(!has_virtual_destructor_v<NType>\n+\t      && !has_virtual_destructor<NType>::value, \"\");\n+\n+static_assert(alignment_of_v<int> == alignof(int)\n+\t      && alignment_of<int>::value == alignof(int) , \"\");\n+\n+static_assert(rank_v<int[1][1]> == rank<int[1][1]>::value, \"\");\n+\n+static_assert(extent_v<int[1][2], 1> == 2\n+\t      && extent<int[1][2], 1>::value == 2, \"\");\n+\n+static_assert(is_same_v<int, int> && is_same<int, int>::value, \"\");\n+static_assert(!is_same_v<int, char> && !is_same<int, char>::value, \"\");\n+\n+static_assert(is_base_of_v<Abstract, Poly>\n+\t      && is_base_of<Abstract, Poly>::value, \"\");\n+static_assert(!is_base_of_v<Abstract, NType>\n+\t      && !is_base_of<Abstract, NType>::value, \"\");\n+\n+static_assert(is_convertible_v<int&, const int&>\n+\t      && is_convertible<int&, const int&>::value, \"\");\n+static_assert(!is_convertible_v<const int&, int&>\n+\t      && !is_convertible<const int&, int&>::value, \"\");"}]}