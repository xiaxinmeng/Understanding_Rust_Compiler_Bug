{"sha": "bf2a705c2913fde78457d776b8fef8923836c1c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYyYTcwNWMyOTEzZmRlNzg0NTdkNzc2YjhmZWY4OTIzODM2YzFjNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-05-09T21:25:23Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-05-09T21:25:23Z"}, "message": "re PR target/68163 (GCC on power8 does not issue the stxsspx instruction on power8)\n\n[gcc]\n2017-05-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/68163\n\t* config/rs6000/rs6000.md (f32_lr): Delete mode attributes that\n\tare now unused after splitting mov{sf,sd}_hardfloat.\n\t(f32_lr2): Likewise.\n\t(f32_lm): Likewise.\n\t(f32_lm2): Likewise.\n\t(f32_li): Likewise.\n\t(f32_li2): Likewise.\n\t(f32_lv): Likewise.\n\t(f32_sr): Likewise.\n\t(f32_sr2): Likewise.\n\t(f32_sm): Likewise.\n\t(f32_sm2): Likewise.\n\t(f32_si): Likewise.\n\t(f32_si2): Likewise.\n\t(f32_sv): Likewise.\n\t(f32_dm): Likewise.\n\t(f32_vsx): Likewise.\n\t(f32_av): Likewise.\n\t(mov<mode>_hardfloat): Split into separate movsf and movsd pieces.\n\tFor movsf, order stores so the VSX stores occur before the GPR\n\tstore which encourages the register allocator to use a traditional\n\tFPR instead of a GPR.  For movsd, order the stores so that the GPR\n\tstore comes before the VSX stores to allow the power6 to work.\n\tThis is due to the power6 not having a 32-bit integer store\n\tinstruction from a FPR.\n\t(movsf_hardfloat): Likewise.\n\t(movsd_hardfloat): Likewise.\n\n[gcc/testsuite]\n2017-05-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/68163\n\t* gcc.target/powerpc/pr68163.c: New test.\n\nFrom-SVN: r247819", "tree": {"sha": "dcf9f016d42dcaf7d0dd0f114db64376ab68f8e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf9f016d42dcaf7d0dd0f114db64376ab68f8e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf2a705c2913fde78457d776b8fef8923836c1c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf2a705c2913fde78457d776b8fef8923836c1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf2a705c2913fde78457d776b8fef8923836c1c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf2a705c2913fde78457d776b8fef8923836c1c4/comments", "author": null, "committer": null, "parents": [{"sha": "5285d5d3574ac90b8c14ac05ad205d2b4af30090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5285d5d3574ac90b8c14ac05ad205d2b4af30090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5285d5d3574ac90b8c14ac05ad205d2b4af30090"}], "stats": {"total": 356, "additions": 307, "deletions": 49}, "files": [{"sha": "1f08f99f01d76042928a56927a3d6c9f3c5d6517", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf2a705c2913fde78457d776b8fef8923836c1c4", "patch": "@@ -1,3 +1,34 @@\n+2017-05-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/68163\n+\t* config/rs6000/rs6000.md (f32_lr): Delete mode attributes that\n+\tare now unused after splitting mov{sf,sd}_hardfloat.\n+\t(f32_lr2): Likewise.\n+\t(f32_lm): Likewise.\n+\t(f32_lm2): Likewise.\n+\t(f32_li): Likewise.\n+\t(f32_li2): Likewise.\n+\t(f32_lv): Likewise.\n+\t(f32_sr): Likewise.\n+\t(f32_sr2): Likewise.\n+\t(f32_sm): Likewise.\n+\t(f32_sm2): Likewise.\n+\t(f32_si): Likewise.\n+\t(f32_si2): Likewise.\n+\t(f32_sv): Likewise.\n+\t(f32_dm): Likewise.\n+\t(f32_vsx): Likewise.\n+\t(f32_av): Likewise.\n+\t(mov<mode>_hardfloat): Split into separate movsf and movsd pieces.\n+\tFor movsf, order stores so the VSX stores occur before the GPR\n+\tstore which encourages the register allocator to use a traditional\n+\tFPR instead of a GPR.  For movsd, order the stores so that the GPR\n+\tstore comes before the VSX stores to allow the power6 to work.\n+\tThis is due to the power6 not having a 32-bit integer store\n+\tinstruction from a FPR.\n+\t(movsf_hardfloat): Likewise.\n+\t(movsd_hardfloat): Likewise.\n+\n 2017-05-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR translation/80280"}, {"sha": "3eb415cb209b9c5413f0368ef46bb005254cce97", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=bf2a705c2913fde78457d776b8fef8923836c1c4", "patch": "@@ -445,35 +445,6 @@\n \t\t\t   (DD \"wn\")\n \t\t\t   (TD \"wn\")])\n \n-; Definitions for load to 32-bit fpr register\n-(define_mode_attr f32_lr  [(SF \"f\")\t\t  (SD \"wz\")])\n-(define_mode_attr f32_lr2 [(SF \"wb\")\t\t  (SD \"wn\")])\n-(define_mode_attr f32_lm  [(SF \"m\")\t\t  (SD \"Z\")])\n-(define_mode_attr f32_lm2 [(SF \"wY\")\t\t  (SD \"wn\")])\n-(define_mode_attr f32_li  [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n-(define_mode_attr f32_li2 [(SF \"lxssp %0,%1\")     (SD \"lfiwzx %0,%y1\")])\n-(define_mode_attr f32_lv  [(SF \"lxsspx %x0,%y1\")  (SD \"lxsiwzx %x0,%y1\")])\n-\n-; Definitions for store from 32-bit fpr register\n-(define_mode_attr f32_sr  [(SF \"f\")\t\t   (SD \"wx\")])\n-(define_mode_attr f32_sr2 [(SF \"wb\")\t\t   (SD \"wn\")])\n-(define_mode_attr f32_sm  [(SF \"m\")\t\t   (SD \"Z\")])\n-(define_mode_attr f32_sm2 [(SF \"wY\")\t\t   (SD \"wn\")])\n-(define_mode_attr f32_si  [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n-(define_mode_attr f32_si2 [(SF \"stxssp %1,%0\")     (SD \"stfiwx %1,%y0\")])\n-(define_mode_attr f32_sv  [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwx %x1,%y0\")])\n-\n-; Definitions for 32-bit fpr direct move\n-; At present, the decimal modes are not allowed in the traditional altivec\n-; registers, so restrict the constraints to just the traditional FPRs.\n-(define_mode_attr f32_dm [(SF \"wn\") (SD \"wh\")])\n-\n-; Definitions for 32-bit VSX\n-(define_mode_attr f32_vsx [(SF \"ww\") (SD \"wn\")])\n-\n-; Definitions for 32-bit use of altivec registers\n-(define_mode_attr f32_av  [(SF \"wu\") (SD \"wn\")])\n-\n ; Definitions for 64-bit VSX\n (define_mode_attr f64_vsx [(DF \"ws\") (DD \"wn\")])\n \n@@ -7232,40 +7203,82 @@\n   operands[3] = gen_int_mode (l, SImode);\n }\")\n \n-(define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\"\n-\t \"=!r,       <f32_lr>,  <f32_lr2>, <f32_av>,  m,         <f32_sm>,\n-\t  <f32_sm2>, Z,         <f32_vsx>, !r,        ?<f32_dm>, ?r,\n-\t  f,         <f32_vsx>, !r,        *c*l,      !r,        *h\")\n-\t(match_operand:FMOVE32 1 \"input_operand\"\n-\t \"m,         <f32_lm>,  <f32_lm2>, Z,         r,         <f32_sr>,\n-\t  <f32_sr2>, <f32_av>,  <zero_fp>, <zero_fp>, r,         <f32_dm>,\n-\t  f,         <f32_vsx>, r,         r,         *h,        0\"))]\n-  \"(register_operand (operands[0], <MODE>mode)\n-   || register_operand (operands[1], <MODE>mode))\n+;; Originally, we tried to keep movsf and movsd common, but the differences\n+;; addressing was making it rather difficult to hide with mode attributes.  In\n+;; particular for SFmode, on ISA 2.07 (power8) systems, having the GPR store\n+;; before the VSX stores meant that the register allocator would tend to do a\n+;; direct move to the GPR (which involves conversion from scalar to\n+;; vector/memory formats) to save values in the traditional Altivec registers,\n+;; while SDmode had problems on power6 if the GPR store was not first due to\n+;; the power6 not having an integer store operation.\n+;;\n+;;\tLWZ          LFS        LXSSP       LXSSPX     STFS       STXSSP\n+;;\tSTXSSPX      STW        XXLXOR      LI         FMR        XSCPSGNDP\n+;;\tMR           MT<x>      MF<x>       NOP\n+\n+(define_insn \"movsf_hardfloat\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n+\t \"=!r,       f,         wb,         wu,        m,         wY,\n+\t  Z,         m,         ww,         !r,        f,         ww,\n+\t  !r,        *c*l,      !r,         *h\")\n+\t(match_operand:SF 1 \"input_operand\"\n+\t \"m,         m,         wY,         Z,         f,         wb,\n+\t  wu,        r,         j,          j,         f,         ww,\n+\t  r,         r,         *h,         0\"))]\n+  \"(register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode))\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n    && (TARGET_ALLOW_SF_SUBREG\n-       || valid_sf_si_move (operands[0], operands[1], <MODE>mode))\"\n+       || valid_sf_si_move (operands[0], operands[1], SFmode))\"\n   \"@\n    lwz%U1%X1 %0,%1\n-   <f32_li>\n-   <f32_li2>\n-   <f32_lv>\n+   lfs%U1%X1 %0,%1\n+   lxssp %0,%1\n+   lxsspx %x0,%y1\n+   stfs%U0%X0 %1,%0\n+   stxssp %1,%0\n+   stxsspx %x1,%y0\n    stw%U0%X0 %1,%0\n-   <f32_si>\n-   <f32_si2>\n-   <f32_sv>\n    xxlxor %x0,%x0,%x0\n    li %0,0\n+   fmr %0,%1\n+   xscpsgndp %x0,%x1,%x1\n+   mr %0,%1\n+   mt%0 %1\n+   mf%1 %0\n+   nop\"\n+  [(set_attr \"type\"\n+\t\"load,       fpload,    fpload,     fpload,    fpstore,   fpstore,\n+\t fpstore,    store,     veclogical, integer,   fpsimple,  fpsimple,\n+\t *,          mtjmpr,    mfjmpr,     *\")])\n+\n+;;\tLWZ          LFIWZX     STW        STFIWX     MTVSRWZ    MFVSRWZ\n+;;\tFMR          MR         MT%0       MF%1       NOP\n+(define_insn \"movsd_hardfloat\"\n+  [(set (match_operand:SD 0 \"nonimmediate_operand\"\n+\t \"=!r,       wz,        m,         Z,         ?wh,       ?r,\n+\t  f,         !r,        *c*l,      !r,        *h\")\n+\t(match_operand:SD 1 \"input_operand\"\n+\t \"m,         Z,         r,         wx,        r,         wh,\n+\t  f,         r,         r,         *h,        0\"))]\n+  \"(register_operand (operands[0], SDmode)\n+   || register_operand (operands[1], SDmode))\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n+  \"@\n+   lwz%U1%X1 %0,%1\n+   lfiwzx %0,%y1\n+   stw%U0%X0 %1,%0\n+   stfiwx %1,%y0\n    mtvsrwz %x0,%1\n    mfvsrwz %0,%x1\n    fmr %0,%1\n-   xscpsgndp %x0,%x1,%x1\n    mr %0,%1\n    mt%0 %1\n    mf%1 %0\n    nop\"\n-  [(set_attr \"type\" \"load,fpload,fpload,fpload,store,fpstore,fpstore,fpstore,veclogical,integer,mffgpr,mftgpr,fpsimple,fpsimple,*,mtjmpr,mfjmpr,*\")])\n+  [(set_attr \"type\"\n+\t\"load,       fpload,    store,     fpstore,   mffgpr,    mftgpr,\n+\t fpsimple,   *,         mtjmpr,    mfjmpr,    *\")])\n \n (define_insn \"*mov<mode>_softfloat\"\n   [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=r,cl,r,r,m,r,r,r,r,*h\")"}, {"sha": "adec236c2edd058f997144593964180a9e234532", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf2a705c2913fde78457d776b8fef8923836c1c4", "patch": "@@ -1,3 +1,8 @@\n+2017-05-09  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/68163\n+\t* gcc.target/powerpc/pr68163.c: New test.\n+\n 2017-05-09  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/79311"}, {"sha": "3953c8c8d489cf5e9653825388a044187aaaff41", "filename": "gcc/testsuite/gcc.target/powerpc/pr68163.c", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68163.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf2a705c2913fde78457d776b8fef8923836c1c4/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68163.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68163.c?ref=bf2a705c2913fde78457d776b8fef8923836c1c4", "patch": "@@ -0,0 +1,209 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Make sure that the register allocator does not move SF values to GPR\n+   registers in order to do an offsettable store.  */\n+\n+#ifndef TYPE\n+#define TYPE float\n+#endif\n+\n+#ifndef TYPE_IN\n+#define TYPE_IN TYPE\n+#endif\n+\n+#ifndef TYPE_OUT\n+#define TYPE_OUT TYPE\n+#endif\n+\n+#ifndef ITYPE\n+#define ITYPE long\n+#endif\n+\n+#ifdef DO_CALL\n+extern ITYPE get_bits (ITYPE);\n+\n+#else\n+#define get_bits(X) (X)\n+#endif\n+\n+void test (ITYPE *bits, ITYPE n, TYPE one, TYPE_IN *p, TYPE_OUT *q)\n+{\n+  TYPE x_00 = p[ 0];\n+  TYPE x_01 = p[ 1];\n+  TYPE x_02 = p[ 2];\n+  TYPE x_03 = p[ 3];\n+  TYPE x_04 = p[ 4];\n+  TYPE x_05 = p[ 5];\n+  TYPE x_06 = p[ 6];\n+  TYPE x_07 = p[ 7];\n+  TYPE x_08 = p[ 8];\n+  TYPE x_09 = p[ 9];\n+\n+  TYPE x_10 = p[10];\n+  TYPE x_11 = p[11];\n+  TYPE x_12 = p[12];\n+  TYPE x_13 = p[13];\n+  TYPE x_14 = p[14];\n+  TYPE x_15 = p[15];\n+  TYPE x_16 = p[16];\n+  TYPE x_17 = p[17];\n+  TYPE x_18 = p[18];\n+  TYPE x_19 = p[19];\n+\n+  TYPE x_20 = p[20];\n+  TYPE x_21 = p[21];\n+  TYPE x_22 = p[22];\n+  TYPE x_23 = p[23];\n+  TYPE x_24 = p[24];\n+  TYPE x_25 = p[25];\n+  TYPE x_26 = p[26];\n+  TYPE x_27 = p[27];\n+  TYPE x_28 = p[28];\n+  TYPE x_29 = p[29];\n+\n+  TYPE x_30 = p[30];\n+  TYPE x_31 = p[31];\n+  TYPE x_32 = p[32];\n+  TYPE x_33 = p[33];\n+  TYPE x_34 = p[34];\n+  TYPE x_35 = p[35];\n+  TYPE x_36 = p[36];\n+  TYPE x_37 = p[37];\n+  TYPE x_38 = p[38];\n+  TYPE x_39 = p[39];\n+\n+  TYPE x_40 = p[40];\n+  TYPE x_41 = p[41];\n+  TYPE x_42 = p[42];\n+  TYPE x_43 = p[43];\n+  TYPE x_44 = p[44];\n+  TYPE x_45 = p[45];\n+  TYPE x_46 = p[46];\n+  TYPE x_47 = p[47];\n+  TYPE x_48 = p[48];\n+  TYPE x_49 = p[49];\n+\n+  ITYPE i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ITYPE bit = get_bits (bits[i]);\n+\n+      if ((bit & ((ITYPE)1) << \t0) != 0) x_00 += one;\n+      if ((bit & ((ITYPE)1) << \t1) != 0) x_01 += one;\n+      if ((bit & ((ITYPE)1) << \t2) != 0) x_02 += one;\n+      if ((bit & ((ITYPE)1) << \t3) != 0) x_03 += one;\n+      if ((bit & ((ITYPE)1) << \t4) != 0) x_04 += one;\n+      if ((bit & ((ITYPE)1) << \t5) != 0) x_05 += one;\n+      if ((bit & ((ITYPE)1) << \t6) != 0) x_06 += one;\n+      if ((bit & ((ITYPE)1) << \t7) != 0) x_07 += one;\n+      if ((bit & ((ITYPE)1) << \t8) != 0) x_08 += one;\n+      if ((bit & ((ITYPE)1) << \t9) != 0) x_09 += one;\n+\n+      if ((bit & ((ITYPE)1) << 10) != 0) x_10 += one;\n+      if ((bit & ((ITYPE)1) << 11) != 0) x_11 += one;\n+      if ((bit & ((ITYPE)1) << 12) != 0) x_12 += one;\n+      if ((bit & ((ITYPE)1) << 13) != 0) x_13 += one;\n+      if ((bit & ((ITYPE)1) << 14) != 0) x_14 += one;\n+      if ((bit & ((ITYPE)1) << 15) != 0) x_15 += one;\n+      if ((bit & ((ITYPE)1) << 16) != 0) x_16 += one;\n+      if ((bit & ((ITYPE)1) << 17) != 0) x_17 += one;\n+      if ((bit & ((ITYPE)1) << 18) != 0) x_18 += one;\n+      if ((bit & ((ITYPE)1) << 19) != 0) x_19 += one;\n+\n+      if ((bit & ((ITYPE)1) << 20) != 0) x_20 += one;\n+      if ((bit & ((ITYPE)1) << 21) != 0) x_21 += one;\n+      if ((bit & ((ITYPE)1) << 22) != 0) x_22 += one;\n+      if ((bit & ((ITYPE)1) << 23) != 0) x_23 += one;\n+      if ((bit & ((ITYPE)1) << 24) != 0) x_24 += one;\n+      if ((bit & ((ITYPE)1) << 25) != 0) x_25 += one;\n+      if ((bit & ((ITYPE)1) << 26) != 0) x_26 += one;\n+      if ((bit & ((ITYPE)1) << 27) != 0) x_27 += one;\n+      if ((bit & ((ITYPE)1) << 28) != 0) x_28 += one;\n+      if ((bit & ((ITYPE)1) << 29) != 0) x_29 += one;\n+\n+      if ((bit & ((ITYPE)1) << 30) != 0) x_30 += one;\n+      if ((bit & ((ITYPE)1) << 31) != 0) x_31 += one;\n+      if ((bit & ((ITYPE)1) << 32) != 0) x_32 += one;\n+      if ((bit & ((ITYPE)1) << 33) != 0) x_33 += one;\n+      if ((bit & ((ITYPE)1) << 34) != 0) x_34 += one;\n+      if ((bit & ((ITYPE)1) << 35) != 0) x_35 += one;\n+      if ((bit & ((ITYPE)1) << 36) != 0) x_36 += one;\n+      if ((bit & ((ITYPE)1) << 37) != 0) x_37 += one;\n+      if ((bit & ((ITYPE)1) << 38) != 0) x_38 += one;\n+      if ((bit & ((ITYPE)1) << 39) != 0) x_39 += one;\n+\n+      if ((bit & ((ITYPE)1) << 40) != 0) x_40 += one;\n+      if ((bit & ((ITYPE)1) << 41) != 0) x_41 += one;\n+      if ((bit & ((ITYPE)1) << 42) != 0) x_42 += one;\n+      if ((bit & ((ITYPE)1) << 43) != 0) x_43 += one;\n+      if ((bit & ((ITYPE)1) << 44) != 0) x_44 += one;\n+      if ((bit & ((ITYPE)1) << 45) != 0) x_45 += one;\n+      if ((bit & ((ITYPE)1) << 46) != 0) x_46 += one;\n+      if ((bit & ((ITYPE)1) << 47) != 0) x_47 += one;\n+      if ((bit & ((ITYPE)1) << 48) != 0) x_48 += one;\n+      if ((bit & ((ITYPE)1) << 49) != 0) x_49 += one;\n+    }\n+\n+  q[ 0] = x_00;\n+  q[ 1] = x_01;\n+  q[ 2] = x_02;\n+  q[ 3] = x_03;\n+  q[ 4] = x_04;\n+  q[ 5] = x_05;\n+  q[ 6] = x_06;\n+  q[ 7] = x_07;\n+  q[ 8] = x_08;\n+  q[ 9] = x_09;\n+\n+  q[10] = x_10;\n+  q[11] = x_11;\n+  q[12] = x_12;\n+  q[13] = x_13;\n+  q[14] = x_14;\n+  q[15] = x_15;\n+  q[16] = x_16;\n+  q[17] = x_17;\n+  q[18] = x_18;\n+  q[19] = x_19;\n+\n+  q[20] = x_20;\n+  q[21] = x_21;\n+  q[22] = x_22;\n+  q[23] = x_23;\n+  q[24] = x_24;\n+  q[25] = x_25;\n+  q[26] = x_26;\n+  q[27] = x_27;\n+  q[28] = x_28;\n+  q[29] = x_29;\n+\n+  q[30] = x_30;\n+  q[31] = x_31;\n+  q[32] = x_32;\n+  q[33] = x_33;\n+  q[34] = x_34;\n+  q[35] = x_35;\n+  q[36] = x_36;\n+  q[37] = x_37;\n+  q[38] = x_38;\n+  q[39] = x_39;\n+\n+  q[40] = x_40;\n+  q[41] = x_41;\n+  q[42] = x_42;\n+  q[43] = x_43;\n+  q[44] = x_44;\n+  q[45] = x_45;\n+  q[46] = x_46;\n+  q[47] = x_47;\n+  q[48] = x_48;\n+  q[49] = x_49;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\mmfvsrd\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mstw\\M}    } } */"}]}