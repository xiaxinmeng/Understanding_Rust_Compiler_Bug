{"sha": "40130403e5500f38e023fac59472f8c61c8356d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAxMzA0MDNlNTUwMGYzOGUwMjNmYWM1OTQ3MmY4YzYxYzgzNTZkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-06-03T06:28:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-06-03T06:28:11Z"}, "message": "genpreds.c (mark_mode_tests): Mark all MATCH_CODEs as NO_MODE_TEST.\n\ngcc/\n\t* genpreds.c (mark_mode_tests): Mark all MATCH_CODEs as\n\tNO_MODE_TEST.\n\t(add_mode_tests): Don't add mode tests if the predicate only\n\taccepts scalar constant integers.  Otherwise, allow the mode\n\tof \"op\" to be VOIDmode if the predicate does accept such integers.\n\nFrom-SVN: r224056", "tree": {"sha": "66bbfe93611e62b98107ca670840298fa57f2d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66bbfe93611e62b98107ca670840298fa57f2d5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40130403e5500f38e023fac59472f8c61c8356d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40130403e5500f38e023fac59472f8c61c8356d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40130403e5500f38e023fac59472f8c61c8356d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40130403e5500f38e023fac59472f8c61c8356d2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c49316be70e3817af7a09354fab830c0f5208fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49316be70e3817af7a09354fab830c0f5208fbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49316be70e3817af7a09354fab830c0f5208fbc"}], "stats": {"total": 63, "additions": 53, "deletions": 10}, "files": [{"sha": "bf01fafd618a2a87cbcd7a4d010ef64041350e61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40130403e5500f38e023fac59472f8c61c8356d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40130403e5500f38e023fac59472f8c61c8356d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40130403e5500f38e023fac59472f8c61c8356d2", "patch": "@@ -1,3 +1,11 @@\n+2015-06-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genpreds.c (mark_mode_tests): Mark all MATCH_CODEs as\n+\tNO_MODE_TEST.\n+\t(add_mode_tests): Don't add mode tests if the predicate only\n+\taccepts scalar constant integers.  Otherwise, allow the mode\n+\tof \"op\" to be VOIDmode if the predicate does accept such integers.\n+\n 2015-06-02  Jim Wilson  <jim.wilson@linaro.org>\n \n \tPR target/66258"}, {"sha": "4f1efb54e9f91d73212c732998031a0b5f7a3e66", "filename": "gcc/genpreds.c", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40130403e5500f38e023fac59472f8c61c8356d2/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40130403e5500f38e023fac59472f8c61c8356d2/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=40130403e5500f38e023fac59472f8c61c8356d2", "patch": "@@ -218,11 +218,11 @@ needs_variable (rtx exp, const char *var)\n \n /* Given an RTL expression EXP, find all subexpressions which we may\n    assume to perform mode tests.  Normal MATCH_OPERAND does;\n-   MATCH_CODE does if it applies to the whole expression and accepts\n-   CONST_INT or CONST_DOUBLE; and we have to assume that MATCH_TEST\n-   does not.  These combine in almost-boolean fashion - the only\n-   exception is that (not X) must be assumed not to perform a mode\n-   test, whether or not X does.\n+   MATCH_CODE doesn't as such (although certain codes always have\n+   VOIDmode); and we have to assume that MATCH_TEST does not.\n+   These combine in almost-boolean fashion - the only exception is\n+   that (not X) must be assumed not to perform a mode test, whether\n+   or not X does.\n \n    The mark is the RTL /v flag, which is true for subexpressions which\n    do *not* perform mode tests.\n@@ -244,10 +244,7 @@ mark_mode_tests (rtx exp)\n       break;\n \n     case MATCH_CODE:\n-      if (XSTR (exp, 1)[0] != '\\0'\n-\t  || (!strstr (XSTR (exp, 0), \"const_int\")\n-\t      && !strstr (XSTR (exp, 0), \"const_double\")))\n-\tNO_MODE_TEST (exp) = 1;\n+      NO_MODE_TEST (exp) = 1;\n       break;\n \n     case MATCH_TEST:\n@@ -313,14 +310,52 @@ add_mode_tests (struct pred_data *p)\n   if (p->special)\n     return;\n \n+  /* Check whether the predicate accepts const scalar ints (which always\n+     have a stored mode of VOIDmode, but logically have a real mode)\n+     and whether it matches anything besides const scalar ints.  */\n+  bool matches_const_scalar_int_p = false;\n+  bool matches_other_p = false;\n+  for (int i = 0; i < NUM_RTX_CODE; ++i)\n+    if (p->codes[i])\n+      switch (i)\n+\t{\n+\tcase CONST_INT:\n+\tcase CONST_WIDE_INT:\n+\t  matches_const_scalar_int_p = true;\n+\t  break;\n+\n+\tcase CONST_DOUBLE:\n+\t  if (!TARGET_SUPPORTS_WIDE_INT)\n+\t    matches_const_scalar_int_p = true;\n+\t  matches_other_p = true;\n+\t  break;\n+\n+\tdefault:\n+\t  matches_other_p = true;\n+\t  break;\n+\t}\n+\n+  /* There's no need for a mode check if the predicate only accepts\n+     constant integers.  The code checks in the predicate are enough\n+     to establish that the mode is VOIDmode.\n+\n+     Note that the predicate itself should check whether a scalar\n+     integer is in range of the given mode.  */\n+  if (!matches_other_p)\n+    return;\n+\n   mark_mode_tests (p->exp);\n \n   /* If the whole expression already tests the mode, we're done.  */\n   if (!NO_MODE_TEST (p->exp))\n     return;\n \n   match_test_exp = rtx_alloc (MATCH_TEST);\n-  XSTR (match_test_exp, 0) = \"mode == VOIDmode || GET_MODE (op) == mode\";\n+  if (matches_const_scalar_int_p)\n+    XSTR (match_test_exp, 0) = (\"mode == VOIDmode || GET_MODE (op) == mode\"\n+\t\t\t\t\" || GET_MODE (op) == VOIDmode\");\n+  else\n+    XSTR (match_test_exp, 0) = \"mode == VOIDmode || GET_MODE (op) == mode\";\n   and_exp = rtx_alloc (AND);\n   XEXP (and_exp, 1) = match_test_exp;\n "}]}