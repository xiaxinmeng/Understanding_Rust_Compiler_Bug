{"sha": "b820d2b8702a1702e8e869fcdb2382e89f014b4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyMGQyYjg3MDJhMTcwMmU4ZTg2OWZjZGIyMzgyZTg5ZjAxNGI0Yw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-01-26T02:07:48Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-01-26T02:07:48Z"}, "message": "calls.c (save_fixed_argument_area): Tidy.\n\n\t* calls.c (save_fixed_argument_area): Tidy.\n\t(restore_fixed_argument_area): Tidy.  Set alignment of stack_area.\n\t(expand_call): Comment typo fixes.  Don't init low_to_save.  Start\n\tcall chain loop at 1 if !try_tail_call.  Formatting.\n\t(emit_library_call_value_1): Don't init low_to_save or high_to_save.\n\tUse save_fixed_argument_area and restore_fixed_argument_area.\n\nFrom-SVN: r61818", "tree": {"sha": "2a19a1068edb23f6b4ca581e645990e1e815a749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a19a1068edb23f6b4ca581e645990e1e815a749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b820d2b8702a1702e8e869fcdb2382e89f014b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b820d2b8702a1702e8e869fcdb2382e89f014b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b820d2b8702a1702e8e869fcdb2382e89f014b4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b820d2b8702a1702e8e869fcdb2382e89f014b4c/comments", "author": null, "committer": null, "parents": [{"sha": "42510de4e1b616c3f97896e1bc6c9abda8b82ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42510de4e1b616c3f97896e1bc6c9abda8b82ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42510de4e1b616c3f97896e1bc6c9abda8b82ccc"}], "stats": {"total": 227, "additions": 79, "deletions": 148}, "files": [{"sha": "48a880c39d130377772073bde0183d56c6647456", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b820d2b8702a1702e8e869fcdb2382e89f014b4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b820d2b8702a1702e8e869fcdb2382e89f014b4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b820d2b8702a1702e8e869fcdb2382e89f014b4c", "patch": "@@ -1,3 +1,12 @@\n+2003-01-26  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* calls.c (save_fixed_argument_area): Tidy.\n+\t(restore_fixed_argument_area): Tidy.  Set alignment of stack_area.\n+\t(expand_call): Comment typo fixes.  Don't init low_to_save.  Start\n+\tcall chain loop at 1 if !try_tail_call.  Formatting.\n+\t(emit_library_call_value_1): Don't init low_to_save or high_to_save.\n+\tUse save_fixed_argument_area and restore_fixed_argument_area.\n+\n 2003-01-26  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* df.c (df_uses_record): Handle CC0."}, {"sha": "d85e23882955ace414a62d2e0824ee160e61b753", "filename": "gcc/calls.c", "status": "modified", "additions": 70, "deletions": 148, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b820d2b8702a1702e8e869fcdb2382e89f014b4c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b820d2b8702a1702e8e869fcdb2382e89f014b4c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b820d2b8702a1702e8e869fcdb2382e89f014b4c", "patch": "@@ -1,6 +1,6 @@\n /* Convert function calls to rtl insns, for GNU C compiler.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -912,66 +912,68 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n      int *low_to_save;\n      int *high_to_save;\n {\n-  int i;\n-  rtx save_area = NULL_RTX;\n+  int low;\n+  int high;\n \n-  /* Compute the boundary of the that needs to be saved, if any.  */\n+  /* Compute the boundary of the area that needs to be saved, if any.  */\n+  high = reg_parm_stack_space;\n #ifdef ARGS_GROW_DOWNWARD\n-  for (i = 0; i < reg_parm_stack_space + 1; i++)\n-#else\n-  for (i = 0; i < reg_parm_stack_space; i++)\n+  high += 1;\n #endif\n-    {\n-      if (i >= highest_outgoing_arg_in_use\n-\t  || stack_usage_map[i] == 0)\n-\tcontinue;\n+  if (high > highest_outgoing_arg_in_use)\n+    high = highest_outgoing_arg_in_use;\n \n-      if (*low_to_save == -1)\n-\t*low_to_save = i;\n+  for (low = 0; low < high; low++)\n+    if (stack_usage_map[low] != 0)\n+      {\n+\tint num_to_save;\n+\tenum machine_mode save_mode;\n+\tint delta;\n+\trtx stack_area;\n+\trtx save_area;\n \n-      *high_to_save = i;\n-    }\n+\twhile (stack_usage_map[--high] == 0)\n+\t  ;\n \n-  if (*low_to_save >= 0)\n-    {\n-      int num_to_save = *high_to_save - *low_to_save + 1;\n-      enum machine_mode save_mode\n-\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n-      rtx stack_area;\n+\t*low_to_save = low;\n+\t*high_to_save = high;\n+\n+\tnum_to_save = high - low + 1;\n+\tsave_mode = mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n \n-      /* If we don't have the required alignment, must do this in BLKmode.  */\n-      if ((*low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t\tBIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n-\tsave_mode = BLKmode;\n+\t/* If we don't have the required alignment, must do this\n+\t   in BLKmode.  */\n+\tif ((low & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\t  save_mode = BLKmode;\n \n #ifdef ARGS_GROW_DOWNWARD\n-      stack_area\n-\t= gen_rtx_MEM (save_mode,\n-\t\t       memory_address (save_mode,\n-\t\t\t\t       plus_constant (argblock,\n-\t\t\t\t\t\t      - *high_to_save)));\n+\tdelta = -high;\n #else\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       *low_to_save)));\n+\tdelta = low;\n #endif\n+\tstack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\t  memory_address (save_mode,\n+\t\t\t\t\t\t  plus_constant (argblock,\n+\t\t\t\t\t\t\t\t delta)));\n \n-      set_mem_align (stack_area, PARM_BOUNDARY);\n-      if (save_mode == BLKmode)\n-\t{\n-\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t   GEN_INT (num_to_save), BLOCK_OP_CALL_PARM);\n-\t}\n-      else\n-\t{\n-\t  save_area = gen_reg_rtx (save_mode);\n-\t  emit_move_insn (save_area, stack_area);\n-\t}\n-    }\n+\tset_mem_align (stack_area, PARM_BOUNDARY);\n+\tif (save_mode == BLKmode)\n+\t  {\n+\t    save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t    emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t     GEN_INT (num_to_save), BLOCK_OP_CALL_PARM);\n+\t  }\n+\telse\n+\t  {\n+\t    save_area = gen_reg_rtx (save_mode);\n+\t    emit_move_insn (save_area, stack_area);\n+\t  }\n \n-  return save_area;\n+\treturn save_area;\n+      }\n+\n+  return NULL_RTX;\n }\n \n static void\n@@ -982,19 +984,18 @@ restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n      int low_to_save;\n {\n   enum machine_mode save_mode = GET_MODE (save_area);\n+  int delta;\n+  rtx stack_area;\n+\n #ifdef ARGS_GROW_DOWNWARD\n-  rtx stack_area\n-    = gen_rtx_MEM (save_mode,\n-\t\t   memory_address (save_mode,\n-\t\t\t\t   plus_constant (argblock,\n-\t\t\t\t\t\t  - high_to_save)));\n+  delta = -high_to_save;\n #else\n-  rtx stack_area\n-    = gen_rtx_MEM (save_mode,\n-\t\t   memory_address (save_mode,\n-\t\t\t\t   plus_constant (argblock,\n-\t\t\t\t\t\t  low_to_save)));\n+  delta = low_to_save;\n #endif\n+  stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t    plus_constant (argblock, delta)));\n+  set_mem_align (stack_area, PARM_BOUNDARY);\n \n   if (save_mode != BLKmode)\n     emit_move_insn (stack_area, save_area);\n@@ -2194,8 +2195,8 @@ expand_call (exp, target, ignore)\n   int is_integrable = 0;\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n-     save, if any.  */\n-  int low_to_save = -1, high_to_save;\n+     saved, if any.  */\n+  int low_to_save, high_to_save;\n   rtx save_area = 0;\t\t/* Place that it is saved */\n #endif\n \n@@ -2632,7 +2633,7 @@ expand_call (exp, target, ignore)\n   /* We want to make two insn chains; one for a sibling call, the other\n      for a normal call.  We will select one of the two chains after\n      initial RTL generation is complete.  */\n-  for (pass = 0; pass < 2; pass++)\n+  for (pass = try_tail_call ? 0 : 1; pass < 2; pass++)\n     {\n       int sibcall_failure = 0;\n       /* We want to emit any pending stack adjustments before the tail\n@@ -2646,9 +2647,6 @@ expand_call (exp, target, ignore)\n \n       if (pass == 0)\n \t{\n-\t  if (! try_tail_call)\n-\t    continue;\n-\n \t  /* Emit any queued insns now; otherwise they would end up in\n              only one of the alternates.  */\n \t  emit_queue ();\n@@ -3320,10 +3318,8 @@ expand_call (exp, target, ignore)\n \t{\n #ifdef REG_PARM_STACK_SPACE\n \t  if (save_area)\n-\t    {\n-\t      restore_fixed_argument_area (save_area, argblock,\n-\t\t\t\t\t   high_to_save, low_to_save);\n-\t    }\n+\t    restore_fixed_argument_area (save_area, argblock,\n+\t\t\t\t\t high_to_save, low_to_save);\n #endif\n \n \t  /* If we saved any argument areas, restore them.  */\n@@ -3511,7 +3507,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n-  int low_to_save = -1, high_to_save = 0;\n+  int low_to_save, high_to_save;\n   rtx save_area = 0;            /* Place that it is saved.  */\n #endif\n \n@@ -3892,62 +3888,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n     {\n       /* The argument list is the property of the called routine and it\n \t may clobber it.  If the fixed area has been used for previous\n-\t parameters, we must save and restore it.\n-\n-\t Here we compute the boundary of the that needs to be saved, if any.  */\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-      for (count = 0; count < reg_parm_stack_space + 1; count++)\n-#else\n-      for (count = 0; count < reg_parm_stack_space; count++)\n-#endif\n-\t{\n-\t  if (count >= highest_outgoing_arg_in_use\n-\t      || stack_usage_map[count] == 0)\n-\t    continue;\n-\n-\t  if (low_to_save == -1)\n-\t    low_to_save = count;\n-\n-\t  high_to_save = count;\n-\t}\n-\n-      if (low_to_save >= 0)\n-\t{\n-\t  int num_to_save = high_to_save - low_to_save + 1;\n-\t  enum machine_mode save_mode\n-\t    = mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n-\t  rtx stack_area;\n-\n-\t  /* If we don't have the required alignment, must do this in BLKmode.  */\n-\t  if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t\t   BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n-\t    save_mode = BLKmode;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-\t  stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\t    memory_address (save_mode,\n-\t\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t\t   -high_to_save)));\n-#else\n-\t  stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\t    memory_address (save_mode,\n-\t\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t\t   low_to_save)));\n-#endif\n-\t  if (save_mode == BLKmode)\n-\t    {\n-\t      save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t      set_mem_align (save_area, PARM_BOUNDARY);\n-\t      emit_block_move (save_area, stack_area, GEN_INT (num_to_save),\n-\t\t\t       BLOCK_OP_CALL_PARM);\n-\t    }\n-\t  else\n-\t    {\n-\t      save_area = gen_reg_rtx (save_mode);\n-\t      emit_move_insn (save_area, stack_area);\n-\t    }\n-\t}\n+\t parameters, we must save and restore it.  */\n+      save_area = save_fixed_argument_area (reg_parm_stack_space, argblock,\n+\t\t\t\t\t    &low_to_save, &high_to_save);\n     }\n #endif\n \n@@ -4192,29 +4135,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n     {\n #ifdef REG_PARM_STACK_SPACE\n       if (save_area)\n-\t{\n-\t  enum machine_mode save_mode = GET_MODE (save_area);\n-#ifdef ARGS_GROW_DOWNWARD\n-\t  rtx stack_area\n-\t    = gen_rtx_MEM (save_mode,\n-\t\t\t   memory_address (save_mode,\n-\t\t\t\t\t   plus_constant (argblock,\n-\t\t\t\t\t\t\t  - high_to_save)));\n-#else\n-\t  rtx stack_area\n-\t    = gen_rtx_MEM (save_mode,\n-\t\t\t   memory_address (save_mode,\n-\t\t\t\t\t   plus_constant (argblock, low_to_save)));\n-#endif\n-\n-\t  set_mem_align (stack_area, PARM_BOUNDARY);\n-\t  if (save_mode != BLKmode)\n-\t    emit_move_insn (stack_area, save_area);\n-\t  else\n-\t    emit_block_move (stack_area, save_area,\n-\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t     BLOCK_OP_CALL_PARM);\n-\t}\n+\trestore_fixed_argument_area (save_area, argblock,\n+\t\t\t\t     high_to_save, low_to_save);\n #endif\n \n       /* If we saved any argument areas, restore them.  */"}]}