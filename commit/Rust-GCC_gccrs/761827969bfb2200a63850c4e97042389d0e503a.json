{"sha": "761827969bfb2200a63850c4e97042389d0e503a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYxODI3OTY5YmZiMjIwMGE2Mzg1MGM0ZTk3MDQyMzg5ZDBlNTAzYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-04T20:41:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-04T20:41:15Z"}, "message": "(emit_reload_insns): Add another way to delete an output reload.\n\nFrom-SVN: r7209", "tree": {"sha": "c1b00fe737287b5431c3a4091b4af7f9f5e2ee17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1b00fe737287b5431c3a4091b4af7f9f5e2ee17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/761827969bfb2200a63850c4e97042389d0e503a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761827969bfb2200a63850c4e97042389d0e503a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761827969bfb2200a63850c4e97042389d0e503a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761827969bfb2200a63850c4e97042389d0e503a/comments", "author": null, "committer": null, "parents": [{"sha": "2b979c572605c9b2ffdaf68ef64615b71127d66f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b979c572605c9b2ffdaf68ef64615b71127d66f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b979c572605c9b2ffdaf68ef64615b71127d66f"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "c5877e3174a72b3bb62dcc496fcb5e044dcab26d", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761827969bfb2200a63850c4e97042389d0e503a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761827969bfb2200a63850c4e97042389d0e503a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=761827969bfb2200a63850c4e97042389d0e503a", "patch": "@@ -5614,6 +5614,21 @@ emit_reload_insns (insn)\n \t  else if (GET_CODE (oldequiv) == SUBREG)\n \t    oldequiv_reg = SUBREG_REG (oldequiv);\n \n+\t  /* If we are reloading from a register that was recently stored in\n+\t     with an output-reload, see if we can prove there was\n+\t     actually no need to store the old value in it.  */\n+\n+\t  if (optimize && GET_CODE (oldequiv) == REG\n+\t      && REGNO (oldequiv) < FIRST_PSEUDO_REGISTER\n+\t      && spill_reg_order[REGNO (oldequiv)] >= 0\n+\t      && spill_reg_store[reload_spill_index[REGNO (oldequiv)]] != 0\n+\t      && dead_or_set_p (insn, reload_in[j])\n+\t      /* This is unsafe if operand occurs more than once in current\n+\t     insn.  Perhaps some occurrences weren't reloaded.  */\n+\t      && count_occurrences (PATTERN (insn), reload_in[j]) == 1)\n+\t    delete_output_reload\n+\t      (insn, j, spill_reg_store[spill_reg_order[REGNO (oldequiv)]]);\n+\n \t  /* Encapsulate both RELOADREG and OLDEQUIV into that mode,\n \t     then load RELOADREG from OLDEQUIV.  Note that we cannot use\n \t     gen_lowpart_common since it can do the wrong thing when"}]}