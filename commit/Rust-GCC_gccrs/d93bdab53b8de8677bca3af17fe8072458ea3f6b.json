{"sha": "d93bdab53b8de8677bca3af17fe8072458ea3f6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzYmRhYjUzYjhkZTg2NzdiY2EzYWYxN2ZlODA3MjQ1OGVhM2Y2Yg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2015-04-08T15:58:33Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2015-04-08T15:58:33Z"}, "message": "mkoffload.c (process): Support variable mapping.\n\n\tgcc/\n\t* config/nvptx/mkoffload.c (process): Support variable mapping.\n\n\tlibgomp/\n\t* libgomp.h (target_mem_desc: Remove mem_map field.\n\t(acc_dispatch_t): Remove open_device_func, close_device_func,\n\tget_device_num_func, set_device_num_func, target_data members.\n\tChange create_thread_data_func argument to device number instead of\n\tgeneric pointer.\n\t* oacc-async.c (assert.h): Include.\n\t(acc_async_test, acc_async_test_all, acc_wait, acc_wait_async)\n\t(acc_wait_all, acc_wait_all_async): Use current host thread's\n\tactive device, not base_dev.\n\t* oacc-cuda.c (acc_get_current_cuda_device)\n\t(acc_get_current_cuda_context, acc_get_cuda_stream)\n\t(acc_set_cuda_stream): Likewise.\n\t* oacc-host.c (host_dispatch): Don't set open_device_func,\n\tclose_device_func, get_device_num_func or set_device_num_func.\n\t* oacc-init.c (base_dev, init_key): Remove.\n\t(cached_base_dev): New.\n\t(name_of_acc_device_t): New.\n\t(acc_init_1): Initialise default-numbered device, not zeroth.\n\t(acc_shutdown_1): Close all devices of a given type.\n\t(goacc_destroy_thread): Don't use base_dev.\n\t(lazy_open, lazy_init, lazy_init_and_open): Remove.\n\t(goacc_attach_host_thread_to_device): New.\n\t(acc_init): Reimplement with goacc_attach_host_thread_to_device.\n\t(acc_get_num_devices): Don't use base_dev.\n\t(acc_set_device_type): Reimplement.\n\t(acc_get_device_type): Don't use base_dev.\n\t(acc_get_device_num): Tweak logic.\n\t(acc_set_device_num): Likewise.\n\t(acc_on_device): Use acc_get_device_type.\n\t(goacc_runtime_initialize): Initialize cached_base_dev not base_dev.\n\t(goacc_lazy_initialize): Reimplement with acc_init and\n\tgoacc_attach_host_thread_to_device.\n\t* oacc-int.h (goacc_thread): Add base_dev field.\n\t(base_dev): Remove extern declaration.\n\t(goacc_attach_host_thread_to_device): Add prototype.\n\t* oacc-mem.c (acc_malloc): Use current thread's device instead of\n\tbase_dev.\n\t(acc_free): Likewise.\n\t(acc_memcpy_to_device): Likewise.\n\t(acc_memcpy_from_device): Likewise.\n\t* oacc-parallel.c (select_acc_device): Remove. Replace calls with\n\tgoacc_lazy_initialize (throughout).\n\t(GOACC_parallel): Use tgt_offset to locate target functions.\n\t* target.c (gomp_map_vars): Don't set tgt->mem_map.\n\t(gomp_unmap_vars): Use devicep->mem_map pointer not tgt->mem_map.\n\t(gomp_load_plugin_for_device): Remove open_device, close_device,\n\tget_device_num, set_device_num openacc hook initialisation. Don't set\n\topenacc.target_data.\n\t* plugin/plugin-host.c (GOMP_OFFLOAD_openacc_open_device)\n\t(GOMP_OFFLOAD_openacc_close_device)\n\t(GOMP_OFFLOAD_openacc_get_device_num)\n\t(GOMP_OFFLOAD_openacc_set_device_num): Remove.\n\t(GOMP_OFFLOAD_openacc_create_thread_data): Change (unused) argument\n\tto int.\n\t* plugin/plugin-nvptx.c (ptx_inited): Remove.\n\t(instantiated_devices, ptx_dev_lock): New.\n\t(struct ptx_image_data): New.\n\t(ptx_devices, ptx_images, ptx_image_lock): New.\n\t(fini_streams_for_device): Reorder cuStreamDestroy call.\n\t(nvptx_get_num_devices): Remove forward declaration.\n\t(nvptx_init): Change return type to bool.\n\t(nvptx_fini): Remove.\n\t(nvptx_attach_host_thread_to_device): New.\n\t(nvptx_open_device): Return struct ptx_device* instead of void*.\n\t(nvptx_close_device): Change argument type to struct ptx_device*,\n\treturn type to void.\n\t(nvptx_get_num_devices): Use instantiated_devices not ptx_inited.\n\t(kernel_target_data, kernel_host_table): Remove static globals.\n\t(GOMP_OFFLOAD_register_image, GOMP_OFFLOAD_get_table): Remove.\n\t(GOMP_OFFLOAD_init_device): Reimplement.\n\t(GOMP_OFFLOAD_fini_device): Likewise.\n\t(GOMP_OFFLOAD_load_image, GOMP_OFFLOAD_unload_image): New.\n\t(GOMP_OFFLOAD_alloc, GOMP_OFFLOAD_free, GOMP_OFFLOAD_dev2host)\n\t(GOMP_OFFLOAD_host2dev): Use ORD argument.\n\t(GOMP_OFFLOAD_openacc_open_device)\n\t(GOMP_OFFLOAD_openacc_close_device)\n\t(GOMP_OFFLOAD_openacc_set_device_num)\n\t(GOMP_OFFLOAD_openacc_get_device_num): Remove.\n\t(GOMP_OFFLOAD_openacc_create_thread_data): Change argument to int\n\t(device number).\n\n\tlibgomp/testsuite/\n\t* libgomp.oacc-c-c++-common/lib-9.c: Fix devnum check in test.\n\nFrom-SVN: r221922", "tree": {"sha": "60d71a75181c79b311aaa199f917cb19ed8c06f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60d71a75181c79b311aaa199f917cb19ed8c06f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d93bdab53b8de8677bca3af17fe8072458ea3f6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93bdab53b8de8677bca3af17fe8072458ea3f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93bdab53b8de8677bca3af17fe8072458ea3f6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93bdab53b8de8677bca3af17fe8072458ea3f6b/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6330e856f5f2a0c6c92e54cec42ff1798bf0ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6330e856f5f2a0c6c92e54cec42ff1798bf0ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6330e856f5f2a0c6c92e54cec42ff1798bf0ea8"}], "stats": {"total": 1045, "additions": 592, "deletions": 453}, "files": [{"sha": "e97439f897742913a48ed354745892aaf0eb5357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -1,3 +1,7 @@\n+2015-04-08  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/nvptx/mkoffload.c (process): Support variable mapping.\n+\n 2015-03-27  Trevor Saunders  <tbsaunde@tbsaunde.org>\n \n \t* config/alpha/alpha.c (alpha_use_linkage): Change type of slot to"}, {"sha": "dbc68bcfbed9fc410b0236b9066bb133d0c37d54", "filename": "gcc/config/nvptx/mkoffload.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -839,6 +839,7 @@ process (FILE *in, FILE *out)\n {\n   const char *input = read_file (in);\n   Token *tok = tokenize (input);\n+  unsigned int nvars = 0, nfuncs = 0;\n \n   do\n     tok = parse_file (tok);\n@@ -850,16 +851,17 @@ process (FILE *in, FILE *out)\n   write_stmts (out, rev_stmts (fns));\n   fprintf (out, \";\\n\\n\");\n   fprintf (out, \"static const char *var_mappings[] = {\\n\");\n-  for (id_map *id = var_ids; id; id = id->next)\n+  for (id_map *id = var_ids; id; id = id->next, nvars++)\n     fprintf (out, \"\\t\\\"%s\\\"%s\\n\", id->ptx_name, id->next ? \",\" : \"\");\n   fprintf (out, \"};\\n\\n\");\n   fprintf (out, \"static const char *func_mappings[] = {\\n\");\n-  for (id_map *id = func_ids; id; id = id->next)\n+  for (id_map *id = func_ids; id; id = id->next, nfuncs++)\n     fprintf (out, \"\\t\\\"%s\\\"%s\\n\", id->ptx_name, id->next ? \",\" : \"\");\n   fprintf (out, \"};\\n\\n\");\n \n   fprintf (out, \"static const void *target_data[] = {\\n\");\n-  fprintf (out, \"  ptx_code, var_mappings, func_mappings\\n\");\n+  fprintf (out, \"  ptx_code, (void*) %u, var_mappings, (void*) %u, \"\n+\t\t\"func_mappings\\n\", nvars, nfuncs);\n   fprintf (out, \"};\\n\\n\");\n \n   fprintf (out, \"extern void GOMP_offload_register (const void *, int, void *);\\n\");"}, {"sha": "4b0a1c91be678edbda5c50507b0b7ddb0d3f60a3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -1,3 +1,89 @@\n+2015-04-08  Julian Brown  <julian@codesourcery.com>\n+\n+\t* libgomp.h (target_mem_desc: Remove mem_map field.\n+\t(acc_dispatch_t): Remove open_device_func, close_device_func,\n+\tget_device_num_func, set_device_num_func, target_data members.\n+\tChange create_thread_data_func argument to device number instead of\n+\tgeneric pointer.\n+\t* oacc-async.c (assert.h): Include.\n+\t(acc_async_test, acc_async_test_all, acc_wait, acc_wait_async)\n+\t(acc_wait_all, acc_wait_all_async): Use current host thread's\n+\tactive device, not base_dev.\n+\t* oacc-cuda.c (acc_get_current_cuda_device)\n+\t(acc_get_current_cuda_context, acc_get_cuda_stream)\n+\t(acc_set_cuda_stream): Likewise.\n+\t* oacc-host.c (host_dispatch): Don't set open_device_func,\n+\tclose_device_func, get_device_num_func or set_device_num_func.\n+\t* oacc-init.c (base_dev, init_key): Remove.\n+\t(cached_base_dev): New.\n+\t(name_of_acc_device_t): New.\n+\t(acc_init_1): Initialise default-numbered device, not zeroth.\n+\t(acc_shutdown_1): Close all devices of a given type.\n+\t(goacc_destroy_thread): Don't use base_dev.\n+\t(lazy_open, lazy_init, lazy_init_and_open): Remove.\n+\t(goacc_attach_host_thread_to_device): New.\n+\t(acc_init): Reimplement with goacc_attach_host_thread_to_device.\n+\t(acc_get_num_devices): Don't use base_dev.\n+\t(acc_set_device_type): Reimplement.\n+\t(acc_get_device_type): Don't use base_dev.\n+\t(acc_get_device_num): Tweak logic.\n+\t(acc_set_device_num): Likewise.\n+\t(acc_on_device): Use acc_get_device_type.\n+\t(goacc_runtime_initialize): Initialize cached_base_dev not base_dev.\n+\t(goacc_lazy_initialize): Reimplement with acc_init and\n+\tgoacc_attach_host_thread_to_device.\n+\t* oacc-int.h (goacc_thread): Add base_dev field.\n+\t(base_dev): Remove extern declaration.\n+\t(goacc_attach_host_thread_to_device): Add prototype.\n+\t* oacc-mem.c (acc_malloc): Use current thread's device instead of\n+\tbase_dev.\n+\t(acc_free): Likewise.\n+\t(acc_memcpy_to_device): Likewise.\n+\t(acc_memcpy_from_device): Likewise.\n+\t* oacc-parallel.c (select_acc_device): Remove. Replace calls with\n+\tgoacc_lazy_initialize (throughout).\n+\t(GOACC_parallel): Use tgt_offset to locate target functions.\n+\t* target.c (gomp_map_vars): Don't set tgt->mem_map.\n+\t(gomp_unmap_vars): Use devicep->mem_map pointer not tgt->mem_map.\n+\t(gomp_load_plugin_for_device): Remove open_device, close_device,\n+\tget_device_num, set_device_num openacc hook initialisation. Don't set\n+\topenacc.target_data.\n+\t* plugin/plugin-host.c (GOMP_OFFLOAD_openacc_open_device)\n+\t(GOMP_OFFLOAD_openacc_close_device)\n+\t(GOMP_OFFLOAD_openacc_get_device_num)\n+\t(GOMP_OFFLOAD_openacc_set_device_num): Remove.\n+\t(GOMP_OFFLOAD_openacc_create_thread_data): Change (unused) argument\n+\tto int.\n+\t* plugin/plugin-nvptx.c (ptx_inited): Remove.\n+\t(instantiated_devices, ptx_dev_lock): New.\n+\t(struct ptx_image_data): New.\n+\t(ptx_devices, ptx_images, ptx_image_lock): New.\n+\t(fini_streams_for_device): Reorder cuStreamDestroy call.\n+\t(nvptx_get_num_devices): Remove forward declaration.\n+\t(nvptx_init): Change return type to bool.\n+\t(nvptx_fini): Remove.\n+\t(nvptx_attach_host_thread_to_device): New.\n+\t(nvptx_open_device): Return struct ptx_device* instead of void*.\n+\t(nvptx_close_device): Change argument type to struct ptx_device*,\n+\treturn type to void.\n+\t(nvptx_get_num_devices): Use instantiated_devices not ptx_inited.\n+\t(kernel_target_data, kernel_host_table): Remove static globals.\n+\t(GOMP_OFFLOAD_register_image, GOMP_OFFLOAD_get_table): Remove.\n+\t(GOMP_OFFLOAD_init_device): Reimplement.\n+\t(GOMP_OFFLOAD_fini_device): Likewise.\n+\t(GOMP_OFFLOAD_load_image, GOMP_OFFLOAD_unload_image): New.\n+\t(GOMP_OFFLOAD_alloc, GOMP_OFFLOAD_free, GOMP_OFFLOAD_dev2host)\n+\t(GOMP_OFFLOAD_host2dev): Use ORD argument.\n+\t(GOMP_OFFLOAD_openacc_open_device)\n+\t(GOMP_OFFLOAD_openacc_close_device)\n+\t(GOMP_OFFLOAD_openacc_set_device_num)\n+\t(GOMP_OFFLOAD_openacc_get_device_num): Remove.\n+\t(GOMP_OFFLOAD_openacc_create_thread_data): Change argument to int\n+\t(device number).\n+\n+\ttestsuite/\n+\t* libgomp.oacc-c-c++-common/lib-9.c: Fix devnum check in test.\n+\n 2015-04-06  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* libgomp-plugin.h (struct mapping_table): Replace with addr_pair."}, {"sha": "5272f0154b760c3fa34bfb6f26e0c66db5f74188", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -655,9 +655,6 @@ struct target_mem_desc {\n   /* Corresponding target device descriptor.  */\n   struct gomp_device_descr *device_descr;\n \n-  /* Memory mapping info for the thread that created this descriptor.  */\n-  struct splay_tree_s *mem_map;\n-\n   /* List of splay keys to remove (or decrease refcount)\n      at the end of region.  */\n   splay_tree_key list[];\n@@ -691,18 +688,6 @@ typedef struct acc_dispatch_t\n   /* This is guarded by the lock in the \"outer\" struct gomp_device_descr.  */\n   struct target_mem_desc *data_environ;\n \n-  /* Extra information required for a device instance by a given target.  */\n-  /* This is guarded by the lock in the \"outer\" struct gomp_device_descr.  */\n-  void *target_data;\n-\n-  /* Open or close a device instance.  */\n-  void *(*open_device_func) (int n);\n-  int (*close_device_func) (void *h);\n-\n-  /* Set or get the device number.  */\n-  int (*get_device_num_func) (void);\n-  void (*set_device_num_func) (int);\n-\n   /* Execute.  */\n   void (*exec_func) (void (*) (void *), size_t, void **, void **, size_t *,\n \t\t     unsigned short *, int, int, int, int, void *);\n@@ -720,7 +705,7 @@ typedef struct acc_dispatch_t\n   void (*async_set_async_func) (int);\n \n   /* Create/destroy TLS data.  */\n-  void *(*create_thread_data_func) (void *);\n+  void *(*create_thread_data_func) (int);\n   void (*destroy_thread_data_func) (void *);\n \n   /* NVIDIA target specific routines.  */"}, {"sha": "1f5827e79f6843847de010f114b0758a4b88c147", "filename": "libgomp/oacc-async.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-async.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-async.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-async.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -26,7 +26,7 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n-\n+#include <assert.h>\n #include \"openacc.h\"\n #include \"libgomp.h\"\n #include \"oacc-int.h\"\n@@ -37,13 +37,23 @@ acc_async_test (int async)\n   if (async < acc_async_sync)\n     gomp_fatal (\"invalid async argument: %d\", async);\n \n-  return base_dev->openacc.async_test_func (async);\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  return thr->dev->openacc.async_test_func (async);\n }\n \n int\n acc_async_test_all (void)\n {\n-  return base_dev->openacc.async_test_all_func ();\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  return thr->dev->openacc.async_test_all_func ();\n }\n \n void\n@@ -52,19 +62,34 @@ acc_wait (int async)\n   if (async < acc_async_sync)\n     gomp_fatal (\"invalid async argument: %d\", async);\n \n-  base_dev->openacc.async_wait_func (async);\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  thr->dev->openacc.async_wait_func (async);\n }\n \n void\n acc_wait_async (int async1, int async2)\n {\n-  base_dev->openacc.async_wait_async_func (async1, async2);\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  thr->dev->openacc.async_wait_async_func (async1, async2);\n }\n \n void\n acc_wait_all (void)\n {\n-  base_dev->openacc.async_wait_all_func ();\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  thr->dev->openacc.async_wait_all_func ();\n }\n \n void\n@@ -73,5 +98,10 @@ acc_wait_all_async (int async)\n   if (async < acc_async_sync)\n     gomp_fatal (\"invalid async argument: %d\", async);\n \n-  base_dev->openacc.async_wait_all_async_func (async);\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  if (!thr || !thr->dev)\n+    gomp_fatal (\"no device active\");\n+\n+  thr->dev->openacc.async_wait_all_async_func (async);\n }"}, {"sha": "4aab4221a423646280c620e5e1a7d3ff7abecfef", "filename": "libgomp/oacc-cuda.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-cuda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-cuda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-cuda.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -34,51 +34,53 @@\n void *\n acc_get_current_cuda_device (void)\n {\n-  void *p = NULL;\n+  struct goacc_thread *thr = goacc_thread ();\n \n-  if (base_dev && base_dev->openacc.cuda.get_current_device_func)\n-    p = base_dev->openacc.cuda.get_current_device_func ();\n+  if (thr && thr->dev && thr->dev->openacc.cuda.get_current_device_func)\n+    return thr->dev->openacc.cuda.get_current_device_func ();\n \n-  return p;\n+  return NULL;\n }\n \n void *\n acc_get_current_cuda_context (void)\n {\n-  void *p = NULL;\n+  struct goacc_thread *thr = goacc_thread ();\n \n-  if (base_dev && base_dev->openacc.cuda.get_current_context_func)\n-    p = base_dev->openacc.cuda.get_current_context_func ();\n-\n-  return p;\n+  if (thr && thr->dev && thr->dev->openacc.cuda.get_current_context_func)\n+    return thr->dev->openacc.cuda.get_current_context_func ();\n+ \n+  return NULL;\n }\n \n void *\n acc_get_cuda_stream (int async)\n {\n-  void *p = NULL;\n+  struct goacc_thread *thr = goacc_thread ();\n \n   if (async < 0)\n-    return p;\n-\n-  if (base_dev && base_dev->openacc.cuda.get_stream_func)\n-    p = base_dev->openacc.cuda.get_stream_func (async);\n+    return NULL;\n \n-  return p;\n+  if (thr && thr->dev && thr->dev->openacc.cuda.get_stream_func)\n+    return thr->dev->openacc.cuda.get_stream_func (async);\n+ \n+  return NULL;\n }\n \n int\n acc_set_cuda_stream (int async, void *stream)\n {\n-  int s = -1;\n+  struct goacc_thread *thr;\n \n   if (async < 0 || stream == NULL)\n     return 0;\n \n   goacc_lazy_initialize ();\n \n-  if (base_dev && base_dev->openacc.cuda.set_stream_func)\n-    s = base_dev->openacc.cuda.set_stream_func (async, stream);\n+  thr = goacc_thread ();\n+\n+  if (thr && thr->dev && thr->dev->openacc.cuda.set_stream_func)\n+    return thr->dev->openacc.cuda.set_stream_func (async, stream);\n \n-  return s;\n+  return -1;\n }"}, {"sha": "6dcdbf3658e18c4c114343cb3132477bf4d5f9d9", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -53,16 +53,9 @@ static struct gomp_device_descr host_dispatch =\n     .host2dev_func = GOMP_OFFLOAD_host2dev,\n     .run_func = GOMP_OFFLOAD_run,\n \n-    .mem_map.root = NULL,\n     .is_initialized = false,\n \n     .openacc = {\n-      .open_device_func = GOMP_OFFLOAD_openacc_open_device,\n-      .close_device_func = GOMP_OFFLOAD_openacc_close_device,\n-\n-      .get_device_num_func = GOMP_OFFLOAD_openacc_get_device_num,\n-      .set_device_num_func = GOMP_OFFLOAD_openacc_set_device_num,\n-\n       .exec_func = GOMP_OFFLOAD_openacc_parallel,\n \n       .register_async_cleanup_func"}, {"sha": "dc40fb6ffe10508bbdad573a38effda28de6cf18", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 205, "deletions": 219, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -37,14 +37,13 @@\n \n static gomp_mutex_t acc_device_lock;\n \n-/* The dispatch table for the current accelerator device.  This is global, so\n-   you can only have one type of device open at any given time in a program.\n-   This is the \"base\" device in that several devices that use the same\n-   dispatch table may be active concurrently: this one (the \"zeroth\") is used\n-   for overall initialisation/shutdown, and other instances -- not necessarily\n-   including this one -- may be opened and closed once the base device has\n-   been initialized.  */\n-struct gomp_device_descr *base_dev;\n+/* A cached version of the dispatcher for the global \"current\" accelerator type,\n+   e.g. used as the default when creating new host threads.  This is the\n+   device-type equivalent of goacc_device_num (which specifies which device to\n+   use out of potentially several of the same type).  If there are several\n+   devices of a given type, this points at the first one.  */\n+\n+static struct gomp_device_descr *cached_base_dev = NULL;\n \n #if defined HAVE_TLS || defined USE_EMUTLS\n __thread struct goacc_thread *goacc_tls_data;\n@@ -53,9 +52,6 @@ pthread_key_t goacc_tls_key;\n #endif\n static pthread_key_t goacc_cleanup_key;\n \n-/* Current dispatcher, and how it was initialized */\n-static acc_device_t init_key = _ACC_device_hwm;\n-\n static struct goacc_thread *goacc_threads;\n static gomp_mutex_t goacc_thread_lock;\n \n@@ -94,6 +90,21 @@ get_openacc_name (const char *name)\n     return name;\n }\n \n+static const char *\n+name_of_acc_device_t (enum acc_device_t type)\n+{\n+  switch (type)\n+    {\n+    case acc_device_none: return \"none\";\n+    case acc_device_default: return \"default\";\n+    case acc_device_host: return \"host\";\n+    case acc_device_host_nonshm: return \"host_nonshm\";\n+    case acc_device_not_host: return \"not_host\";\n+    case acc_device_nvidia: return \"nvidia\";\n+    default: gomp_fatal (\"unknown device type %u\", (unsigned) type);\n+    }\n+}\n+\n static struct gomp_device_descr *\n resolve_device (acc_device_t d)\n {\n@@ -159,22 +170,87 @@ resolve_device (acc_device_t d)\n static struct gomp_device_descr *\n acc_init_1 (acc_device_t d)\n {\n-  struct gomp_device_descr *acc_dev;\n+  struct gomp_device_descr *base_dev, *acc_dev;\n+  int ndevs;\n \n-  acc_dev = resolve_device (d);\n+  base_dev = resolve_device (d);\n+\n+  ndevs = base_dev->get_num_devices_func ();\n+\n+  if (!base_dev || ndevs <= 0 || goacc_device_num >= ndevs)\n+    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n \n-  if (!acc_dev || acc_dev->get_num_devices_func () <= 0)\n-    gomp_fatal (\"device %u not supported\", (unsigned)d);\n+  acc_dev = &base_dev[goacc_device_num];\n \n   if (acc_dev->is_initialized)\n     gomp_fatal (\"device already active\");\n \n-  /* We need to remember what we were intialized as, to check shutdown etc.  */\n-  init_key = d;\n-\n   gomp_init_device (acc_dev);\n \n-  return acc_dev;\n+  return base_dev;\n+}\n+\n+static void\n+acc_shutdown_1 (acc_device_t d)\n+{\n+  struct gomp_device_descr *base_dev;\n+  struct goacc_thread *walk;\n+  int ndevs, i;\n+  bool devices_active = false;\n+\n+  /* Get the base device for this device type.  */\n+  base_dev = resolve_device (d);\n+\n+  if (!base_dev)\n+    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n+\n+  gomp_mutex_lock (&goacc_thread_lock);\n+\n+  /* Free target-specific TLS data and close all devices.  */\n+  for (walk = goacc_threads; walk != NULL; walk = walk->next)\n+    {\n+      if (walk->target_tls)\n+\tbase_dev->openacc.destroy_thread_data_func (walk->target_tls);\n+\n+      walk->target_tls = NULL;\n+\n+      /* This would mean the user is shutting down OpenACC in the middle of an\n+         \"acc data\" pragma.  Likely not intentional.  */\n+      if (walk->mapped_data)\n+\tgomp_fatal (\"shutdown in 'acc data' region\");\n+\n+      /* Similarly, if this happens then user code has done something weird.  */\n+      if (walk->saved_bound_dev)\n+        gomp_fatal (\"shutdown during host fallback\");\n+\n+      if (walk->dev)\n+\t{\n+\t  gomp_mutex_lock (&walk->dev->lock);\n+\t  gomp_free_memmap (&walk->dev->mem_map);\n+\t  gomp_mutex_unlock (&walk->dev->lock);\n+\n+\t  walk->dev = NULL;\n+\t  walk->base_dev = NULL;\n+\t}\n+    }\n+\n+  gomp_mutex_unlock (&goacc_thread_lock);\n+\n+  ndevs = base_dev->get_num_devices_func ();\n+\n+  /* Close all the devices of this type that have been opened.  */\n+  for (i = 0; i < ndevs; i++)\n+    {\n+      struct gomp_device_descr *acc_dev = &base_dev[i];\n+      if (acc_dev->is_initialized)\n+        {\n+\t  devices_active = true;\n+\t  gomp_fini_device (acc_dev);\n+\t}\n+    }\n+\n+  if (!devices_active)\n+    gomp_fatal (\"no device initialized\");\n }\n \n static struct goacc_thread *\n@@ -207,9 +283,11 @@ goacc_destroy_thread (void *data)\n \n   if (thr)\n     {\n-      if (base_dev && thr->target_tls)\n+      struct gomp_device_descr *acc_dev = thr->dev;\n+\n+      if (acc_dev && thr->target_tls)\n \t{\n-\t  base_dev->openacc.destroy_thread_data_func (thr->target_tls);\n+\t  acc_dev->openacc.destroy_thread_data_func (thr->target_tls);\n \t  thr->target_tls = NULL;\n \t}\n \n@@ -236,53 +314,49 @@ goacc_destroy_thread (void *data)\n   gomp_mutex_unlock (&goacc_thread_lock);\n }\n \n-/* Open the ORD'th device of the currently-active type (base_dev must be\n-   initialised before calling).  If ORD is < 0, open the default-numbered\n-   device (set by the ACC_DEVICE_NUM environment variable or a call to\n-   acc_set_device_num), or leave any currently-opened device as is.  \"Opening\"\n-   consists of calling the device's open_device_func hook, and setting up\n-   thread-local data (maybe allocating, then initializing with information\n-   pertaining to the newly-opened or previously-opened device).  */\n+/* Use the ORD'th device instance for the current host thread (or -1 for the\n+   current global default).  The device (and the runtime) must be initialised\n+   before calling this function.  */\n \n-static void\n-lazy_open (int ord)\n+void\n+goacc_attach_host_thread_to_device (int ord)\n {\n   struct goacc_thread *thr = goacc_thread ();\n-  struct gomp_device_descr *acc_dev;\n-\n-  if (thr && thr->dev)\n-    {\n-      assert (ord < 0 || ord == thr->dev->target_id);\n-      return;\n-    }\n-\n-  assert (base_dev);\n-\n+  struct gomp_device_descr *acc_dev = NULL, *base_dev = NULL;\n+  int num_devices;\n+  \n+  if (thr && thr->dev && (thr->dev->target_id == ord || ord < 0))\n+    return;\n+  \n   if (ord < 0)\n     ord = goacc_device_num;\n-\n-  /* The OpenACC 2.0 spec leaves the runtime's behaviour when an out-of-range\n-     device is requested as implementation-defined (4.2 ACC_DEVICE_NUM).\n-     We choose to raise an error in such a case.  */\n-  if (ord >= base_dev->get_num_devices_func ())\n-    gomp_fatal (\"device %u does not exist\", ord);\n-\n+  \n+  /* Decide which type of device to use.  If the current thread has a device\n+     type already (e.g. set by acc_set_device_type), use that, else use the\n+     global default.  */\n+  if (thr && thr->base_dev)\n+    base_dev = thr->base_dev;\n+  else\n+    {\n+      assert (cached_base_dev);\n+      base_dev = cached_base_dev;\n+    }\n+  \n+  num_devices = base_dev->get_num_devices_func ();\n+  if (num_devices <= 0 || ord >= num_devices)\n+    gomp_fatal (\"device %u out of range\", ord);\n+  \n   if (!thr)\n     thr = goacc_new_thread ();\n-\n-  acc_dev = thr->dev = &base_dev[ord];\n-\n-  assert (acc_dev->target_id == ord);\n-\n+  \n+  thr->base_dev = base_dev;\n+  thr->dev = acc_dev = &base_dev[ord];\n   thr->saved_bound_dev = NULL;\n   thr->mapped_data = NULL;\n-\n-  if (!acc_dev->openacc.target_data)\n-    acc_dev->openacc.target_data = acc_dev->openacc.open_device_func (ord);\n-\n+  \n   thr->target_tls\n-    = acc_dev->openacc.create_thread_data_func (acc_dev->openacc.target_data);\n-\n+    = acc_dev->openacc.create_thread_data_func (ord);\n+  \n   acc_dev->openacc.async_set_async_func (acc_async_sync);\n }\n \n@@ -292,74 +366,20 @@ lazy_open (int ord)\n void\n acc_init (acc_device_t d)\n {\n-  if (!base_dev)\n+  if (!cached_base_dev)\n     gomp_init_targets_once ();\n \n   gomp_mutex_lock (&acc_device_lock);\n \n-  base_dev = acc_init_1 (d);\n-\n-  lazy_open (-1);\n+  cached_base_dev = acc_init_1 (d);\n \n   gomp_mutex_unlock (&acc_device_lock);\n+  \n+  goacc_attach_host_thread_to_device (-1);\n }\n \n ialias (acc_init)\n \n-static void\n-acc_shutdown_1 (acc_device_t d)\n-{\n-  struct goacc_thread *walk;\n-\n-  /* We don't check whether d matches the actual device found, because\n-     OpenACC 2.0 (3.2.12) says the parameters to the init and this\n-     call must match (for the shutdown call anyway, it's silent on\n-     others).  */\n-\n-  if (!base_dev)\n-    gomp_fatal (\"no device initialized\");\n-  if (d != init_key)\n-    gomp_fatal (\"device %u(%u) is initialized\",\n-\t\t(unsigned) init_key, (unsigned) base_dev->type);\n-\n-  gomp_mutex_lock (&goacc_thread_lock);\n-\n-  /* Free target-specific TLS data and close all devices.  */\n-  for (walk = goacc_threads; walk != NULL; walk = walk->next)\n-    {\n-      if (walk->target_tls)\n-\tbase_dev->openacc.destroy_thread_data_func (walk->target_tls);\n-\n-      walk->target_tls = NULL;\n-\n-      /* This would mean the user is shutting down OpenACC in the middle of an\n-         \"acc data\" pragma.  Likely not intentional.  */\n-      if (walk->mapped_data)\n-\tgomp_fatal (\"shutdown in 'acc data' region\");\n-\n-      if (walk->dev)\n-\t{\n-\t  void *target_data = walk->dev->openacc.target_data;\n-\t  if (walk->dev->openacc.close_device_func (target_data) < 0)\n-\t    gomp_fatal (\"failed to close device\");\n-\n-\t  walk->dev->openacc.target_data = target_data = NULL;\n-\n-\t  gomp_mutex_lock (&walk->dev->lock);\n-\t  gomp_free_memmap (&walk->dev->mem_map);\n-\t  gomp_mutex_unlock (&walk->dev->lock);\n-\n-\t  walk->dev = NULL;\n-\t}\n-    }\n-\n-  gomp_mutex_unlock (&goacc_thread_lock);\n-\n-  gomp_fini_device (base_dev);\n-\n-  base_dev = NULL;\n-}\n-\n void\n acc_shutdown (acc_device_t d)\n {\n@@ -372,59 +392,16 @@ acc_shutdown (acc_device_t d)\n \n ialias (acc_shutdown)\n \n-/* This function is called after plugins have been initialized.  It deals with\n-   the \"base\" device, and is used to prepare the runtime for dealing with a\n-   number of such devices (as implemented by some particular plugin).  If the\n-   argument device type D matches a previous call to the function, return the\n-   current base device, else shut the old device down and re-initialize with\n-   the new device type.  */\n-\n-static struct gomp_device_descr *\n-lazy_init (acc_device_t d)\n-{\n-  if (base_dev)\n-    {\n-      /* Re-initializing the same device, do nothing.  */\n-      if (d == init_key)\n-\treturn base_dev;\n-\n-      acc_shutdown_1 (init_key);\n-    }\n-\n-  assert (!base_dev);\n-\n-  return acc_init_1 (d);\n-}\n-\n-/* Ensure that plugins are loaded, initialize and open the (default-numbered)\n-   device.  */\n-\n-static void\n-lazy_init_and_open (acc_device_t d)\n-{\n-  if (!base_dev)\n-    gomp_init_targets_once ();\n-\n-  gomp_mutex_lock (&acc_device_lock);\n-\n-  base_dev = lazy_init (d);\n-\n-  lazy_open (-1);\n-\n-  gomp_mutex_unlock (&acc_device_lock);\n-}\n-\n int\n acc_get_num_devices (acc_device_t d)\n {\n   int n = 0;\n-  const struct gomp_device_descr *acc_dev;\n+  struct gomp_device_descr *acc_dev;\n \n   if (d == acc_device_none)\n     return 0;\n \n-  if (!base_dev)\n-    gomp_init_targets_once ();\n+  gomp_init_targets_once ();\n \n   acc_dev = resolve_device (d);\n   if (!acc_dev)\n@@ -439,10 +416,39 @@ acc_get_num_devices (acc_device_t d)\n \n ialias (acc_get_num_devices)\n \n+/* Set the device type for the current thread only (using the current global\n+   default device number), initialising that device if necessary.  Also set the\n+   default device type for new threads to D.  */\n+\n void\n acc_set_device_type (acc_device_t d)\n {\n-  lazy_init_and_open (d);\n+  struct gomp_device_descr *base_dev, *acc_dev;\n+  struct goacc_thread *thr = goacc_thread ();\n+\n+  gomp_mutex_lock (&acc_device_lock);\n+\n+  if (!cached_base_dev)\n+    gomp_init_targets_once ();\n+\n+  cached_base_dev = base_dev = resolve_device (d);\n+  acc_dev = &base_dev[goacc_device_num];\n+\n+  if (!acc_dev->is_initialized)\n+    gomp_init_device (acc_dev);\n+\n+  gomp_mutex_unlock (&acc_device_lock);\n+\n+  /* We're changing device type: invalidate the current thread's dev and\n+     base_dev pointers.  */\n+  if (thr && thr->base_dev != base_dev)\n+    {\n+      thr->base_dev = thr->dev = NULL;\n+      if (thr->mapped_data)\n+        gomp_fatal (\"acc_set_device_type in 'acc data' region\");\n+    }\n+\n+  goacc_attach_host_thread_to_device (-1);\n }\n \n ialias (acc_set_device_type)\n@@ -451,10 +457,11 @@ acc_device_t\n acc_get_device_type (void)\n {\n   acc_device_t res = acc_device_none;\n-  const struct gomp_device_descr *dev;\n+  struct gomp_device_descr *dev;\n+  struct goacc_thread *thr = goacc_thread ();\n \n-  if (base_dev)\n-    res = acc_device_type (base_dev->type);\n+  if (thr && thr->base_dev)\n+    res = acc_device_type (thr->base_dev->type);\n   else\n     {\n       gomp_init_targets_once ();\n@@ -475,89 +482,73 @@ int\n acc_get_device_num (acc_device_t d)\n {\n   const struct gomp_device_descr *dev;\n-  int num;\n+  struct goacc_thread *thr = goacc_thread ();\n \n   if (d >= _ACC_device_hwm)\n     gomp_fatal (\"device %u out of range\", (unsigned)d);\n \n-  if (!base_dev)\n+  if (!cached_base_dev)\n     gomp_init_targets_once ();\n \n   dev = resolve_device (d);\n   if (!dev)\n-    gomp_fatal (\"no devices of type %u\", d);\n+    gomp_fatal (\"device %s not supported\", name_of_acc_device_t (d));\n \n-  /* We might not have called lazy_open for this host thread yet, in which case\n-     the get_device_num_func hook will return -1.  */\n-  num = dev->openacc.get_device_num_func ();\n-  if (num < 0)\n-    num = goacc_device_num;\n+  if (thr && thr->base_dev == dev && thr->dev)\n+    return thr->dev->target_id;\n \n-  return num;\n+  return goacc_device_num;\n }\n \n ialias (acc_get_device_num)\n \n void\n-acc_set_device_num (int n, acc_device_t d)\n+acc_set_device_num (int ord, acc_device_t d)\n {\n-  const struct gomp_device_descr *dev;\n+  struct gomp_device_descr *base_dev, *acc_dev;\n   int num_devices;\n \n-  if (!base_dev)\n+  if (!cached_base_dev)\n     gomp_init_targets_once ();\n \n-  if ((int) d == 0)\n-    {\n-      int i;\n-\n-      /* A device setting of zero sets all device types on the system to use\n-         the Nth instance of that device type.  Only attempt it for initialized\n-\t devices though.  */\n-      for (i = acc_device_not_host + 1; i < _ACC_device_hwm; i++)\n-        {\n-\t  dev = resolve_device (d);\n-\t  if (dev && dev->is_initialized)\n-\t    dev->openacc.set_device_num_func (n);\n-\t}\n+  if (ord < 0)\n+    ord = goacc_device_num;\n \n-      /* ...and for future calls to acc_init/acc_set_device_type, etc.  */\n-      goacc_device_num = n;\n-    }\n+  if ((int) d == 0)\n+    /* Set whatever device is being used by the current host thread to use\n+       device instance ORD.  It's unclear if this is supposed to affect other\n+       host threads too (OpenACC 2.0 (3.2.4) acc_set_device_num).  */\n+    goacc_attach_host_thread_to_device (ord);\n   else\n     {\n-      struct goacc_thread *thr = goacc_thread ();\n-\n       gomp_mutex_lock (&acc_device_lock);\n \n-      base_dev = lazy_init (d);\n+      cached_base_dev = base_dev = resolve_device (d);\n \n       num_devices = base_dev->get_num_devices_func ();\n \n-      if (n >= num_devices)\n-        gomp_fatal (\"device %u out of range\", n);\n+      if (ord >= num_devices)\n+        gomp_fatal (\"device %u out of range\", ord);\n \n-      /* If we're changing the device number, de-associate this thread with\n-\t the device (but don't close the device, since it may be in use by\n-\t other threads).  */\n-      if (thr && thr->dev && n != thr->dev->target_id)\n-\tthr->dev = NULL;\n+      acc_dev = &base_dev[ord];\n \n-      lazy_open (n);\n+      if (!acc_dev->is_initialized)\n+        gomp_init_device (acc_dev);\n \n       gomp_mutex_unlock (&acc_device_lock);\n+\n+      goacc_attach_host_thread_to_device (ord);\n     }\n+  \n+  goacc_device_num = ord;\n }\n \n ialias (acc_set_device_num)\n \n int\n acc_on_device (acc_device_t dev)\n {\n-  struct goacc_thread *thr = goacc_thread ();\n-\n-  if (thr && thr->dev\n-      && acc_device_type (thr->dev->type) == acc_device_host_nonshm)\n+  if (acc_get_device_type () == acc_device_host_nonshm)\n     return dev == acc_device_host_nonshm || dev == acc_device_not_host;\n \n   /* Just rely on the compiler builtin.  */\n@@ -577,7 +568,7 @@ goacc_runtime_initialize (void)\n \n   pthread_key_create (&goacc_cleanup_key, goacc_destroy_thread);\n \n-  base_dev = NULL;\n+  cached_base_dev = NULL;\n \n   goacc_threads = NULL;\n   gomp_mutex_init (&goacc_thread_lock);\n@@ -606,9 +597,8 @@ goacc_restore_bind (void)\n }\n \n /* This is called from any OpenACC support function that may need to implicitly\n-   initialize the libgomp runtime.  On exit all such initialization will have\n-   been done, and both the global ACC_dev and the per-host-thread ACC_memmap\n-   pointers will be valid.  */\n+   initialize the libgomp runtime, either globally or from a new host thread. \n+   On exit \"goacc_thread\" will return a valid & populated thread block.  */\n \n attribute_hidden void\n goacc_lazy_initialize (void)\n@@ -618,12 +608,8 @@ goacc_lazy_initialize (void)\n   if (thr && thr->dev)\n     return;\n \n-  if (!base_dev)\n-    lazy_init_and_open (acc_device_default);\n+  if (!cached_base_dev)\n+    acc_init (acc_device_default);\n   else\n-    {\n-      gomp_mutex_lock (&acc_device_lock);\n-      lazy_open (-1);\n-      gomp_mutex_unlock (&acc_device_lock);\n-    }\n+    goacc_attach_host_thread_to_device (-1);\n }"}, {"sha": "0ace737884aa60d4a7bd0c82b73bf0d814b51522", "filename": "libgomp/oacc-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-int.h?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -56,6 +56,9 @@ acc_device_type (enum offload_target_type type)\n \n struct goacc_thread\n {\n+  /* The base device for the current thread.  */\n+  struct gomp_device_descr *base_dev;\n+\n   /* The device for the current thread.  */\n   struct gomp_device_descr *dev;\n \n@@ -89,10 +92,7 @@ goacc_thread (void)\n #endif\n \n void goacc_register (struct gomp_device_descr *) __GOACC_NOTHROW;\n-\n-/* Current dispatcher.  */\n-extern struct gomp_device_descr *base_dev;\n-\n+void goacc_attach_host_thread_to_device (int);\n void goacc_runtime_initialize (void);\n void goacc_save_and_set_bind (acc_device_t);\n void goacc_restore_bind (void);"}, {"sha": "89ef5fcd8873319591715cec3af04e02f68a9d85", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -107,7 +107,9 @@ acc_malloc (size_t s)\n \n   struct goacc_thread *thr = goacc_thread ();\n \n-  return base_dev->alloc_func (thr->dev->target_id, s);\n+  assert (thr->dev);\n+\n+  return thr->dev->alloc_func (thr->dev->target_id, s);\n }\n \n /* OpenACC 2.0a (3.2.16) doesn't specify what to do in the event\n@@ -122,6 +124,8 @@ acc_free (void *d)\n   if (!d)\n     return;\n \n+  assert (thr && thr->dev);\n+\n   /* We don't have to call lazy open here, as the ptr value must have\n      been returned by acc_malloc.  It's not permitted to pass NULL in\n      (unless you got that null from acc_malloc).  */\n@@ -134,7 +138,7 @@ acc_free (void *d)\n      acc_unmap_data ((void *)(k->host_start + offset));\n    }\n \n-  base_dev->free_func (thr->dev->target_id, d);\n+  thr->dev->free_func (thr->dev->target_id, d);\n }\n \n void\n@@ -144,7 +148,9 @@ acc_memcpy_to_device (void *d, void *h, size_t s)\n      been obtained from a routine that did that.  */\n   struct goacc_thread *thr = goacc_thread ();\n \n-  base_dev->host2dev_func (thr->dev->target_id, d, h, s);\n+  assert (thr && thr->dev);\n+\n+  thr->dev->host2dev_func (thr->dev->target_id, d, h, s);\n }\n \n void\n@@ -154,7 +160,9 @@ acc_memcpy_from_device (void *h, void *d, size_t s)\n      been obtained from a routine that did that.  */\n   struct goacc_thread *thr = goacc_thread ();\n \n-  base_dev->dev2host_func (thr->dev->target_id, h, d, s);\n+  assert (thr && thr->dev);\n+\n+  thr->dev->dev2host_func (thr->dev->target_id, h, d, s);\n }\n \n /* Return the device pointer that corresponds to host data H.  Or NULL"}, {"sha": "d8999463d6d6b2cdb8ac1bc20b854d33bf1ef6a2", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -49,32 +49,6 @@ find_pset (int pos, size_t mapnum, unsigned short *kinds)\n   return kind == GOMP_MAP_TO_PSET;\n }\n \n-\n-/* Ensure that the target device for DEVICE_TYPE is initialised (and that\n-   plugins have been loaded if appropriate).  The ACC_dev variable for the\n-   current thread will be set appropriately for the given device type on\n-   return.  */\n-\n-attribute_hidden void\n-select_acc_device (int device_type)\n-{\n-  goacc_lazy_initialize ();\n-\n-  if (device_type == GOMP_DEVICE_HOST_FALLBACK)\n-    return;\n-\n-  if (device_type == acc_device_none)\n-    device_type = acc_device_host;\n-\n-  if (device_type >= 0)\n-    {\n-      /* NOTE: this will go badly if the surrounding data environment is set up\n-         to use a different device type.  We'll just have to trust that users\n-\t know what they're doing...  */\n-      acc_set_device_type (device_type);\n-    }\n-}\n-\n static void goacc_wait (int async, int num_waits, va_list ap);\n \n void\n@@ -111,7 +85,7 @@ GOACC_parallel (int device, void (*fn) (void *),\n \t      __FUNCTION__, (unsigned long) mapnum, hostaddrs, sizes, kinds,\n \t      async);\n #endif\n-  select_acc_device (device);\n+  goacc_lazy_initialize ();\n \n   thr = goacc_thread ();\n   acc_dev = thr->dev;\n@@ -151,7 +125,7 @@ GOACC_parallel (int device, void (*fn) (void *),\n       if (tgt_fn_key == NULL)\n \tgomp_fatal (\"target function wasn't mapped\");\n \n-      tgt_fn = (void (*)) tgt_fn_key->tgt->tgt_start;\n+      tgt_fn = (void (*)) tgt_fn_key->tgt_offset;\n     }\n   else\n     tgt_fn = (void (*)) fn;\n@@ -195,7 +169,7 @@ GOACC_data_start (int device, size_t mapnum,\n \t      __FUNCTION__, (unsigned long) mapnum, hostaddrs, sizes, kinds);\n #endif\n \n-  select_acc_device (device);\n+  goacc_lazy_initialize ();\n \n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n@@ -242,7 +216,7 @@ GOACC_enter_exit_data (int device, size_t mapnum,\n   bool data_enter = false;\n   size_t i;\n \n-  select_acc_device (device);\n+  goacc_lazy_initialize ();\n \n   thr = goacc_thread ();\n   acc_dev = thr->dev;\n@@ -429,7 +403,7 @@ GOACC_update (int device, size_t mapnum,\n   bool host_fallback = device == GOMP_DEVICE_HOST_FALLBACK;\n   size_t i;\n \n-  select_acc_device (device);\n+  goacc_lazy_initialize ();\n \n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;"}, {"sha": "1faf5bc194eb452e1cc9065d67749010fe56eee2", "filename": "libgomp/plugin/plugin-host.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Fplugin%2Fplugin-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Fplugin%2Fplugin-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-host.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -118,31 +118,6 @@ GOMP_OFFLOAD_unload_image (int n __attribute__ ((unused)),\n {\n }\n \n-STATIC void *\n-GOMP_OFFLOAD_openacc_open_device (int n)\n-{\n-  return (void *) (intptr_t) n;\n-}\n-\n-STATIC int\n-GOMP_OFFLOAD_openacc_close_device (void *hnd)\n-{\n-  return 0;\n-}\n-\n-STATIC int\n-GOMP_OFFLOAD_openacc_get_device_num (void)\n-{\n-  return 0;\n-}\n-\n-STATIC void\n-GOMP_OFFLOAD_openacc_set_device_num (int n)\n-{\n-  if (n > 0)\n-    GOMP (fatal) (\"device number %u out of range for host execution\", n);\n-}\n-\n STATIC void *\n GOMP_OFFLOAD_alloc (int n __attribute__ ((unused)), size_t s)\n {\n@@ -254,7 +229,7 @@ GOMP_OFFLOAD_openacc_async_wait_all_async (int async __attribute__ ((unused)))\n }\n \n STATIC void *\n-GOMP_OFFLOAD_openacc_create_thread_data (void *targ_data\n+GOMP_OFFLOAD_openacc_create_thread_data (int ord\n \t\t\t\t\t __attribute__ ((unused)))\n {\n   return NULL;"}, {"sha": "583ec87aeee09a735738856543b1d41aa841185f", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 209, "deletions": 109, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -133,7 +133,8 @@ struct targ_fn_descriptor\n   const char *name;\n };\n \n-static bool ptx_inited = false;\n+static unsigned int instantiated_devices = 0;\n+static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n \n struct ptx_stream\n {\n@@ -331,9 +332,21 @@ struct ptx_event\n   struct ptx_event *next;\n };\n \n+struct ptx_image_data\n+{\n+  void *target_data;\n+  CUmodule module;\n+  struct ptx_image_data *next;\n+};\n+\n static pthread_mutex_t ptx_event_lock;\n static struct ptx_event *ptx_events;\n \n+static struct ptx_device **ptx_devices;\n+\n+static struct ptx_image_data *ptx_images = NULL;\n+static pthread_mutex_t ptx_image_lock = PTHREAD_MUTEX_INITIALIZER;\n+\n #define _XSTR(s) _STR(s)\n #define _STR(s) #s\n \n@@ -450,8 +463,8 @@ fini_streams_for_device (struct ptx_device *ptx_dev)\n       struct ptx_stream *s = ptx_dev->active_streams;\n       ptx_dev->active_streams = ptx_dev->active_streams->next;\n \n-      cuStreamDestroy (s->stream);\n       map_fini (s);\n+      cuStreamDestroy (s->stream);\n       free (s);\n     }\n \n@@ -575,21 +588,21 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n   return stream;\n }\n \n-static int nvptx_get_num_devices (void);\n-\n-/* Initialize the device.  */\n-static int\n+/* Initialize the device.  Return TRUE on success, else FALSE.  PTX_DEV_LOCK\n+   should be locked on entry and remains locked on exit.  */\n+static bool\n nvptx_init (void)\n {\n   CUresult r;\n   int rc;\n+  int ndevs;\n \n-  if (ptx_inited)\n-    return nvptx_get_num_devices ();\n+  if (instantiated_devices != 0)\n+    return true;\n \n   rc = verify_device_library ();\n   if (rc < 0)\n-    return -1;\n+    return false;\n \n   r = cuInit (0);\n   if (r != CUDA_SUCCESS)\n@@ -599,22 +612,64 @@ nvptx_init (void)\n \n   pthread_mutex_init (&ptx_event_lock, NULL);\n \n-  ptx_inited = true;\n+  r = cuDeviceGetCount (&ndevs);\n+  if (r != CUDA_SUCCESS)\n+    GOMP_PLUGIN_fatal (\"cuDeviceGetCount error: %s\", cuda_error (r));\n \n-  return nvptx_get_num_devices ();\n+  ptx_devices = GOMP_PLUGIN_malloc_cleared (sizeof (struct ptx_device *)\n+\t\t\t\t\t    * ndevs);\n+\n+  return true;\n }\n \n+/* Select the N'th PTX device for the current host thread.  The device must\n+   have been previously opened before calling this function.  */\n+\n static void\n-nvptx_fini (void)\n+nvptx_attach_host_thread_to_device (int n)\n {\n-  ptx_inited = false;\n+  CUdevice dev;\n+  CUresult r;\n+  struct ptx_device *ptx_dev;\n+  CUcontext thd_ctx;\n+\n+  r = cuCtxGetDevice (&dev);\n+  if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n+    GOMP_PLUGIN_fatal (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+\n+  if (r != CUDA_ERROR_INVALID_CONTEXT && dev == n)\n+    return;\n+  else\n+    {\n+      CUcontext old_ctx;\n+\n+      ptx_dev = ptx_devices[n];\n+      assert (ptx_dev);\n+\n+      r = cuCtxGetCurrent (&thd_ctx);\n+      if (r != CUDA_SUCCESS)\n+        GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));\n+\n+      /* We don't necessarily have a current context (e.g. if it has been\n+         destroyed.  Pop it if we do though.  */\n+      if (thd_ctx != NULL)\n+\t{\n+\t  r = cuCtxPopCurrent (&old_ctx);\n+\t  if (r != CUDA_SUCCESS)\n+            GOMP_PLUGIN_fatal (\"cuCtxPopCurrent error: %s\", cuda_error (r));\n+\t}\n+\n+      r = cuCtxPushCurrent (ptx_dev->ctx);\n+      if (r != CUDA_SUCCESS)\n+        GOMP_PLUGIN_fatal (\"cuCtxPushCurrent error: %s\", cuda_error (r));\n+    }\n }\n \n-static void *\n+static struct ptx_device *\n nvptx_open_device (int n)\n {\n   struct ptx_device *ptx_dev;\n-  CUdevice dev;\n+  CUdevice dev, ctx_dev;\n   CUresult r;\n   int async_engines, pi;\n \n@@ -628,6 +683,21 @@ nvptx_open_device (int n)\n   ptx_dev->dev = dev;\n   ptx_dev->ctx_shared = false;\n \n+  r = cuCtxGetDevice (&ctx_dev);\n+  if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n+    GOMP_PLUGIN_fatal (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+  \n+  if (r != CUDA_ERROR_INVALID_CONTEXT && ctx_dev != dev)\n+    {\n+      /* The current host thread has an active context for a different device.\n+         Detach it.  */\n+      CUcontext old_ctx;\n+      \n+      r = cuCtxPopCurrent (&old_ctx);\n+      if (r != CUDA_SUCCESS)\n+\tGOMP_PLUGIN_fatal (\"cuCtxPopCurrent error: %s\", cuda_error (r));\n+    }\n+\n   r = cuCtxGetCurrent (&ptx_dev->ctx);\n   if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));\n@@ -678,17 +748,16 @@ nvptx_open_device (int n)\n \n   init_streams_for_device (ptx_dev, async_engines);\n \n-  return (void *) ptx_dev;\n+  return ptx_dev;\n }\n \n-static int\n-nvptx_close_device (void *targ_data)\n+static void\n+nvptx_close_device (struct ptx_device *ptx_dev)\n {\n   CUresult r;\n-  struct ptx_device *ptx_dev = targ_data;\n \n   if (!ptx_dev)\n-    return 0;\n+    return;\n \n   fini_streams_for_device (ptx_dev);\n \n@@ -700,8 +769,6 @@ nvptx_close_device (void *targ_data)\n     }\n \n   free (ptx_dev);\n-\n-  return 0;\n }\n \n static int\n@@ -714,7 +781,7 @@ nvptx_get_num_devices (void)\n      order to enumerate available devices, but CUDA API routines can't be used\n      until cuInit has been called.  Just call it now (but don't yet do any\n      further initialization).  */\n-  if (!ptx_inited)\n+  if (instantiated_devices == 0)\n     cuInit (0);\n \n   r = cuDeviceGetCount (&n);\n@@ -1507,64 +1574,84 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return nvptx_get_num_devices ();\n }\n \n-static void **kernel_target_data;\n-static void **kernel_host_table;\n-\n void\n-GOMP_OFFLOAD_register_image (void *host_table, void *target_data)\n+GOMP_OFFLOAD_init_device (int n)\n {\n-  kernel_target_data = target_data;\n-  kernel_host_table = host_table;\n-}\n+  pthread_mutex_lock (&ptx_dev_lock);\n \n-void\n-GOMP_OFFLOAD_init_device (int n __attribute__ ((unused)))\n-{\n-  (void) nvptx_init ();\n+  if (!nvptx_init () || ptx_devices[n] != NULL)\n+    {\n+      pthread_mutex_unlock (&ptx_dev_lock);\n+      return;\n+    }\n+\n+  ptx_devices[n] = nvptx_open_device (n);\n+  instantiated_devices++;\n+\n+  pthread_mutex_unlock (&ptx_dev_lock);\n }\n \n void\n-GOMP_OFFLOAD_fini_device (int n __attribute__ ((unused)))\n+GOMP_OFFLOAD_fini_device (int n)\n {\n-  nvptx_fini ();\n+  pthread_mutex_lock (&ptx_dev_lock);\n+\n+  if (ptx_devices[n] != NULL)\n+    {\n+      nvptx_attach_host_thread_to_device (n);\n+      nvptx_close_device (ptx_devices[n]);\n+      ptx_devices[n] = NULL;\n+      instantiated_devices--;\n+    }\n+\n+  pthread_mutex_unlock (&ptx_dev_lock);\n }\n \n int\n-GOMP_OFFLOAD_get_table (int n __attribute__ ((unused)),\n-\t\t\tstruct mapping_table **tablep)\n+GOMP_OFFLOAD_load_image (int ord, void *target_data,\n+\t\t\t struct addr_pair **target_table)\n {\n   CUmodule module;\n-  void **fn_table;\n-  char **fn_names;\n-  int fn_entries, i;\n+  char **fn_names, **var_names;\n+  unsigned int fn_entries, var_entries, i, j;\n   CUresult r;\n   struct targ_fn_descriptor *targ_fns;\n+  void **img_header = (void **) target_data;\n+  struct ptx_image_data *new_image;\n \n-  if (nvptx_init () <= 0)\n-    return 0;\n+  GOMP_OFFLOAD_init_device (ord);\n \n-  /* This isn't an error, because an image may legitimately have no offloaded\n-     regions and so will not call GOMP_offload_register.  */\n-  if (kernel_target_data == NULL)\n-    return 0;\n+  nvptx_attach_host_thread_to_device (ord);\n+\n+  link_ptx (&module, img_header[0]);\n \n-  link_ptx (&module, kernel_target_data[0]);\n+  pthread_mutex_lock (&ptx_image_lock);\n+  new_image = GOMP_PLUGIN_malloc (sizeof (struct ptx_image_data));\n+  new_image->target_data = target_data;\n+  new_image->module = module;\n+  new_image->next = ptx_images;\n+  ptx_images = new_image;\n+  pthread_mutex_unlock (&ptx_image_lock);\n \n-  /* kernel_target_data[0] -> ptx code\n-     kernel_target_data[1] -> variable mappings\n-     kernel_target_data[2] -> array of kernel names in ascii\n+  /* The mkoffload utility emits a table of pointers/integers at the start of\n+     each offload image:\n \n-     kernel_host_table[0] -> start of function addresses (__offload_func_table)\n-     kernel_host_table[1] -> end of function addresses (__offload_funcs_end)\n+     img_header[0] -> ptx code\n+     img_header[1] -> number of variables\n+     img_header[2] -> array of variable names (pointers to strings)\n+     img_header[3] -> number of kernels\n+     img_header[4] -> array of kernel names (pointers to strings)\n \n      The array of kernel names and the functions addresses form a\n      one-to-one correspondence.  */\n \n-  fn_table = kernel_host_table[0];\n-  fn_names = (char **) kernel_target_data[2];\n-  fn_entries = (kernel_host_table[1] - kernel_host_table[0]) / sizeof (void *);\n+  var_entries = (uintptr_t) img_header[1];\n+  var_names = (char **) img_header[2];\n+  fn_entries = (uintptr_t) img_header[3];\n+  fn_names = (char **) img_header[4];\n \n-  *tablep = GOMP_PLUGIN_malloc (sizeof (struct mapping_table) * fn_entries);\n+  *target_table = GOMP_PLUGIN_malloc (sizeof (struct addr_pair)\n+\t\t\t\t      * (fn_entries + var_entries));\n   targ_fns = GOMP_PLUGIN_malloc (sizeof (struct targ_fn_descriptor)\n \t\t\t\t * fn_entries);\n \n@@ -1579,38 +1666,86 @@ GOMP_OFFLOAD_get_table (int n __attribute__ ((unused)),\n       targ_fns[i].fn = function;\n       targ_fns[i].name = (const char *) fn_names[i];\n \n-      (*tablep)[i].host_start = (uintptr_t) fn_table[i];\n-      (*tablep)[i].host_end = (*tablep)[i].host_start + 1;\n-      (*tablep)[i].tgt_start = (uintptr_t) &targ_fns[i];\n-      (*tablep)[i].tgt_end = (*tablep)[i].tgt_start + 1;\n+      (*target_table)[i].start = (uintptr_t) &targ_fns[i];\n+      (*target_table)[i].end = (*target_table)[i].start + 1;\n     }\n \n-  return fn_entries;\n+  for (j = 0; j < var_entries; j++, i++)\n+    {\n+      CUdeviceptr var;\n+      size_t bytes;\n+\n+      r = cuModuleGetGlobal (&var, &bytes, module, var_names[j]);\n+      if (r != CUDA_SUCCESS)\n+        GOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n+\n+      (*target_table)[i].start = (uintptr_t) var;\n+      (*target_table)[i].end = (*target_table)[i].start + bytes;\n+    }\n+\n+  return i;\n+}\n+\n+void\n+GOMP_OFFLOAD_unload_image (int tid __attribute__((unused)), void *target_data)\n+{\n+  void **img_header = (void **) target_data;\n+  struct targ_fn_descriptor *targ_fns\n+    = (struct targ_fn_descriptor *) img_header[0];\n+  struct ptx_image_data *image, *prev = NULL, *newhd = NULL;\n+\n+  free (targ_fns);\n+\n+  pthread_mutex_lock (&ptx_image_lock);\n+  for (image = ptx_images; image != NULL;)\n+    {\n+      struct ptx_image_data *next = image->next;\n+\n+      if (image->target_data == target_data)\n+\t{\n+\t  cuModuleUnload (image->module);\n+\t  free (image);\n+\t  if (prev)\n+\t    prev->next = next;\n+\t}\n+      else\n+\t{\n+\t  prev = image;\n+\t  if (!newhd)\n+\t    newhd = image;\n+\t}\n+\n+      image = next;\n+    }\n+  ptx_images = newhd;\n+  pthread_mutex_unlock (&ptx_image_lock);\n }\n \n void *\n-GOMP_OFFLOAD_alloc (int n __attribute__ ((unused)), size_t size)\n+GOMP_OFFLOAD_alloc (int ord, size_t size)\n {\n+  nvptx_attach_host_thread_to_device (ord);\n   return nvptx_alloc (size);\n }\n \n void\n-GOMP_OFFLOAD_free (int n __attribute__ ((unused)), void *ptr)\n+GOMP_OFFLOAD_free (int ord, void *ptr)\n {\n+  nvptx_attach_host_thread_to_device (ord);\n   nvptx_free (ptr);\n }\n \n void *\n-GOMP_OFFLOAD_dev2host (int ord __attribute__ ((unused)), void *dst,\n-\t\t       const void *src, size_t n)\n+GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n {\n+  nvptx_attach_host_thread_to_device (ord);\n   return nvptx_dev2host (dst, src, n);\n }\n \n void *\n-GOMP_OFFLOAD_host2dev (int ord __attribute__ ((unused)), void *dst,\n-\t\t       const void *src, size_t n)\n+GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n {\n+  nvptx_attach_host_thread_to_device (ord);\n   return nvptx_host2dev (dst, src, n);\n }\n \n@@ -1627,45 +1762,6 @@ GOMP_OFFLOAD_openacc_parallel (void (*fn) (void *), size_t mapnum,\n \t    num_workers, vector_length, async, targ_mem_desc);\n }\n \n-void *\n-GOMP_OFFLOAD_openacc_open_device (int n)\n-{\n-  return nvptx_open_device (n);\n-}\n-\n-int\n-GOMP_OFFLOAD_openacc_close_device (void *h)\n-{\n-  return nvptx_close_device (h);\n-}\n-\n-void\n-GOMP_OFFLOAD_openacc_set_device_num (int n)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  assert (n >= 0);\n-\n-  if (!nvthd->ptx_dev || nvthd->ptx_dev->ord != n)\n-    (void) nvptx_open_device (n);\n-}\n-\n-/* This can be called before the device is \"opened\" for the current thread, in\n-   which case we can't tell which device number should be returned.  We don't\n-   actually want to open the device here, so just return -1 and let the caller\n-   (oacc-init.c:acc_get_device_num) handle it.  */\n-\n-int\n-GOMP_OFFLOAD_openacc_get_device_num (void)\n-{\n-  struct nvptx_thread *nvthd = nvptx_thread ();\n-\n-  if (nvthd && nvthd->ptx_dev)\n-    return nvthd->ptx_dev->ord;\n-  else\n-    return -1;\n-}\n-\n void\n GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc)\n {\n@@ -1729,14 +1825,18 @@ GOMP_OFFLOAD_openacc_async_set_async (int async)\n }\n \n void *\n-GOMP_OFFLOAD_openacc_create_thread_data (void *targ_data)\n+GOMP_OFFLOAD_openacc_create_thread_data (int ord)\n {\n-  struct ptx_device *ptx_dev = (struct ptx_device *) targ_data;\n+  struct ptx_device *ptx_dev;\n   struct nvptx_thread *nvthd\n     = GOMP_PLUGIN_malloc (sizeof (struct nvptx_thread));\n   CUresult r;\n   CUcontext thd_ctx;\n \n+  ptx_dev = ptx_devices[ord];\n+\n+  assert (ptx_dev);\n+\n   r = cuCtxGetCurrent (&thd_ctx);\n   if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));"}, {"sha": "d8da7833aa96d2782a5fef8772b3e648a9dce40d", "filename": "libgomp/target.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -178,7 +178,6 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n   tgt->list_count = mapnum;\n   tgt->refcount = 1;\n   tgt->device_descr = devicep;\n-  tgt->mem_map = mem_map;\n \n   if (mapnum == 0)\n     return tgt;\n@@ -597,7 +596,7 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \t  devicep->dev2host_func (devicep->target_id, (void *) k->host_start,\n \t\t\t\t  (void *) (k->tgt->tgt_start + k->tgt_offset),\n \t\t\t\t  k->host_end - k->host_start);\n-\tsplay_tree_remove (tgt->mem_map, k);\n+\tsplay_tree_remove (&devicep->mem_map, k);\n \tif (k->tgt->refcount > 1)\n \t  k->tgt->refcount--;\n \telse\n@@ -1159,10 +1158,6 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n     {\n       optional_present = optional_total = 0;\n       DLSYM_OPT (openacc.exec, openacc_parallel);\n-      DLSYM_OPT (openacc.open_device, openacc_open_device);\n-      DLSYM_OPT (openacc.close_device, openacc_close_device);\n-      DLSYM_OPT (openacc.get_device_num, openacc_get_device_num);\n-      DLSYM_OPT (openacc.set_device_num, openacc_set_device_num);\n       DLSYM_OPT (openacc.register_async_cleanup,\n \t\t openacc_register_async_cleanup);\n       DLSYM_OPT (openacc.async_test, openacc_async_test);\n@@ -1271,7 +1266,6 @@ gomp_target_init (void)\n \t\tcurrent_device.mem_map.root = NULL;\n \t\tcurrent_device.is_initialized = false;\n \t\tcurrent_device.openacc.data_environ = NULL;\n-\t\tcurrent_device.openacc.target_data = NULL;\n \t\tfor (i = 0; i < new_num_devices; i++)\n \t\t  {\n \t\t    current_device.target_id = i;"}, {"sha": "a4cf7f2e848fc4cd401635d9bbdacbac362473e4", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93bdab53b8de8677bca3af17fe8072458ea3f6b/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-9.c?ref=d93bdab53b8de8677bca3af17fe8072458ea3f6b", "patch": "@@ -58,7 +58,7 @@ main (int argc, char **argv)\n       acc_set_device_num (1, (acc_device_t) 0);\n \n       devnum = acc_get_device_num (devtype);\n-      if (devnum != 0)\n+      if (devnum != 1)\n \tabort ();\n   }\n "}]}