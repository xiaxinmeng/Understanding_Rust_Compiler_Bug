{"sha": "49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlkZjJmYjhiZGJjYTY1OThhNGVjZWUwZGEzZmE3YWI1ZWE2ZDQxZA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2009-06-01T16:46:42Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2009-06-01T16:46:42Z"}, "message": "ia64.md (floatdirf2, [...]): New.\n\n2009-06-01  Steve Ellcey  <sje@cup.hp.com>\n\n\t* ia64.md (floatdirf2, fix_truncrfdi, floatunsdirf,\n\tfixuns_truncrfdi2): New.\n\t(fix_truncxfdi2_alts, fixuns_truncxfdi2_alts,\n\t*nmaddsf4_alts, *nmadddf4_alts, *nmadddf4_truncsf_alts,\n\t*mulxf3_alts, *mulxf3_truncsf_alts, *mulxf3_truncdf_alts,\n\t*maddxf4_alts, *maddxf4_alts_truncsf, *maddxf4_alts_truncdf,\n\t*nmaddxf4_alts, *nmaddxf4_truncsf_alts, *nmaddxf4_truncdf_alts,\n\t*recip_approx): Remove.\n\t(divsi3 modsi3, udivsi3, umodsi3, divsi3_internal, divdi3,\n\tmoddi3, udivdi3, umoddi3, divdi3_internal_lat, divdi3_internal_thr,\n\tdivsf3, sqrtsf2, divdf3, sqrtdf2, divxf3, sqrtxf2): Modify and\n\tmove to div.md.\n\t* div.md (fix_truncrfdi2_alts, fixuns_truncrfdi2_alt,\n\tsetf_exp_rf): New.\n\nFrom-SVN: r148054", "tree": {"sha": "4603697e628259773428c631ee86165685796402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4603697e628259773428c631ee86165685796402"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/comments", "author": null, "committer": null, "parents": [{"sha": "67165eb379fa57c009beb29b180cd630eacbac8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67165eb379fa57c009beb29b180cd630eacbac8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67165eb379fa57c009beb29b180cd630eacbac8e"}], "stats": {"total": 1084, "additions": 462, "deletions": 622}, "files": [{"sha": "3e745ea1e9b6703dd3ceec289dd75f198bc96321", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "patch": "@@ -1,3 +1,20 @@\n+2009-06-01  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* ia64.md (floatdirf2, fix_truncrfdi, floatunsdirf,\n+\tfixuns_truncrfdi2): New.\n+\t(fix_truncxfdi2_alts, fixuns_truncxfdi2_alts,\n+\t*nmaddsf4_alts, *nmadddf4_alts, *nmadddf4_truncsf_alts,\n+\t*mulxf3_alts, *mulxf3_truncsf_alts, *mulxf3_truncdf_alts,\n+\t*maddxf4_alts, *maddxf4_alts_truncsf, *maddxf4_alts_truncdf,\n+\t*nmaddxf4_alts, *nmaddxf4_truncsf_alts, *nmaddxf4_truncdf_alts,\n+\t*recip_approx): Remove.\n+\t(divsi3 modsi3, udivsi3, umodsi3, divsi3_internal, divdi3,\n+\tmoddi3, udivdi3, umoddi3, divdi3_internal_lat, divdi3_internal_thr,\n+\tdivsf3, sqrtsf2, divdf3, sqrtdf2, divxf3, sqrtxf2): Modify and\n+\tmove to div.md.\n+\t* div.md (fix_truncrfdi2_alts, fixuns_truncrfdi2_alt,\n+\tsetf_exp_rf): New.\n+\n 2009-06-01  Ian Lance Taylor  <iant@google.com>\n \n \t* attribs.c (register_attribute): Use CONST_CAST."}, {"sha": "f443a28e7ec6f8b009d4a6296249cbfba59390cc", "filename": "gcc/config/ia64/div.md", "status": "modified", "additions": 425, "deletions": 2, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2Fconfig%2Fia64%2Fdiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2Fconfig%2Fia64%2Fdiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fdiv.md?ref=49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "patch": "@@ -222,6 +222,32 @@\n      operands[2] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\n })\n \n+;; Float to integer truncations using an alternative status register. \n+\n+(define_insn \"fix_truncrfdi2_alts\"\n+  [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n+        (fix:DI (match_operand:RF 1 \"fr_register_operand\" \"f\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fcvt.fx.trunc.s%2 %0 = %1\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n+(define_insn \"fixuns_truncrfdi2_alts\"\n+  [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n+        (unsigned_fix:DI (match_operand:RF 1 \"fr_register_operand\" \"f\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"fcvt.fxu.trunc.s%2 %0 = %1\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n+(define_insn \"setf_exp_rf\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+        (unspec:RF [(match_operand:DI 1 \"register_operand\" \"r\")]\n+                  UNSPEC_SETF_EXP))]\n+  \"\"\n+  \"setf.exp %0 = %1\"\n+  [(set_attr \"itanium_class\" \"frfr\")])\n+\n ;; Reciprocal approximation\n \n (define_insn \"recip_approx_rf\"\n@@ -237,6 +263,23 @@\n   [(set_attr \"itanium_class\" \"fmisc\")\n    (set_attr \"predicable\" \"no\")])\n \n+;; Single precision floating point division\n+\n+(define_expand \"divsf3\"\n+  [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n+\t(div:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t\t(match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n+  \"TARGET_INLINE_FLOAT_DIV\"\n+{\n+  rtx insn;\n+  if (TARGET_INLINE_FLOAT_DIV == INL_MIN_LAT)\n+    insn = gen_divsf3_internal_lat (operands[0], operands[1], operands[2]);\n+  else\n+    insn = gen_divsf3_internal_thr (operands[0], operands[1], operands[2]);\n+  emit_insn (insn);\n+  DONE;\n+})\n+\n ;; Single precision floating point division (maximum throughput algorithm).\n \n (define_expand \"divsf3_internal_thr\"\n@@ -334,6 +377,22 @@\n   DONE;\n })\n \n+;; Double precision floating point division\n+\n+(define_expand \"divdf3\"\n+  [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n+\t(div:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")\n+\t\t(match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n+  \"TARGET_INLINE_FLOAT_DIV\"\n+{\n+  rtx insn;\n+  if (TARGET_INLINE_FLOAT_DIV == INL_MIN_LAT)\n+    insn = gen_divdf3_internal_lat (operands[0], operands[1], operands[2]);\n+  else\n+    insn = gen_divdf3_internal_thr (operands[0], operands[1], operands[2]);\n+  emit_insn (insn);\n+  DONE;\n+})\n \n ;; Double precision floating point division (maximum throughput algorithm).\n \n@@ -454,7 +513,7 @@\n \n ;; Extended precision floating point division.\n \n-(define_expand \"divxf3_internal\"\n+(define_expand \"divxf3\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"\")\n         (div:XF (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"\")\n                 (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n@@ -520,6 +579,340 @@\n })\n \n \n+;; Integer division operations\n+\n+(define_expand \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op1_rf, op2_rf, op0_rf, op0_di;\n+\n+  op0_rf = gen_reg_rtx (RFmode);\n+  op0_di = gen_reg_rtx (DImode);\n+\n+  if (! register_operand (operands[1], SImode))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  op1_rf = gen_reg_rtx (RFmode);\n+  expand_float (op1_rf, operands[1], 0);\n+\n+  if (! register_operand (operands[2], SImode))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  op2_rf = gen_reg_rtx (RFmode);\n+  expand_float (op2_rf, operands[2], 0);\n+\n+  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (SImode),\n+\t\t\t    CONST1_RTX (SImode)));\n+  \n+  emit_insn (gen_divsi3_internal (op0_rf, op1_rf, op2_rf));\n+\n+  emit_insn (gen_fix_truncrfdi2_alts (op0_di, op0_rf, const1_rtx));\n+  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n+  DONE;\n+})\n+\n+(define_expand \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op2_neg, op1_di, div;\n+\n+  div = gen_reg_rtx (SImode);\n+  emit_insn (gen_divsi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  /* This is a trick to get us to reuse the value that we're sure to\n+     have already copied to the FP regs.  */\n+  op1_di = gen_reg_rtx (DImode);\n+  convert_move (op1_di, operands[1], 0);\n+\n+  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n+\t\t\t  gen_lowpart (SImode, op1_di)));\n+  DONE;\n+})\n+\n+(define_expand \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op1_rf, op2_rf, op0_rf, op0_di;\n+\n+  op0_rf = gen_reg_rtx (RFmode);\n+  op0_di = gen_reg_rtx (DImode);\n+\n+  if (! register_operand (operands[1], SImode))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  op1_rf = gen_reg_rtx (RFmode);\n+  expand_float (op1_rf, operands[1], 1);\n+\n+  if (! register_operand (operands[2], SImode))\n+    operands[2] = force_reg (SImode, operands[2]);\n+  op2_rf = gen_reg_rtx (RFmode);\n+  expand_float (op2_rf, operands[2], 1);\n+\n+  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (SImode),\n+                            CONST1_RTX (SImode)));\n+  \n+  emit_insn (gen_divsi3_internal (op0_rf, op1_rf, op2_rf));\n+\n+  emit_insn (gen_fixuns_truncrfdi2_alts (op0_di, op0_rf, const1_rtx));\n+  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n+  DONE;\n+})\n+\n+(define_expand \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op2_neg, op1_di, div;\n+\n+  div = gen_reg_rtx (SImode);\n+  emit_insn (gen_udivsi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  /* This is a trick to get us to reuse the value that we're sure to\n+     have already copied to the FP regs.  */\n+  op1_di = gen_reg_rtx (DImode);\n+  convert_move (op1_di, operands[1], 1);\n+\n+  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n+\t\t\t  gen_lowpart (SImode, op1_di)));\n+  DONE;\n+})\n+\n+(define_expand \"divsi3_internal\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"\")\n+        (float:RF (div:SI (match_operand:RF 1 \"fr_register_operand\" \"\")\n+                          (match_operand:RF 2 \"fr_register_operand\" \"\"))))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx a         = operands[1];\n+  rtx b         = operands[2];\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx e1        = gen_reg_rtx (RFmode);\n+  rtx q         = gen_reg_rtx (RFmode);\n+  rtx q1        = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx one       = CONST1_RTX (RFmode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+  rtx twon34_exp = gen_reg_rtx (DImode);\n+  rtx twon34    = gen_reg_rtx (RFmode);\n+\n+  /* Load cosntant 2**(-34) */\n+  emit_move_insn (twon34_exp, GEN_INT (65501));\n+  emit_insn (gen_setf_exp_rf (twon34, twon34_exp));\n+\n+  /* y  = 1 / b\t\t\t*/\n+  emit_insn (gen_recip_approx_rf (y, a, b, cond, status1));\n+  /* e  = 1 - (b * y)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, b, y, zero, status1, trunc_off));\n+  /* q  = a * y                 */\n+  emit_insn (gen_mulrf3_cond (q, cond, a, y, zero, status1, trunc_off));\n+  /* q1 = q + (q * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (q1, cond, q, q, e, zero, status1, trunc_off));\n+  /* e1 = (2**-34) + (e * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (e1, cond, twon34, e, e, zero, status1, trunc_off));\n+  /* q2 = q1 + (e1 * q1)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (operands[0], cond, q1, e1, q1, y, status1, trunc_off));\n+  DONE;\n+})\n+\n+(define_expand \"divdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op1_rf, op2_rf, op0_rf;\n+\n+  op0_rf = gen_reg_rtx (RFmode);\n+\n+  if (! register_operand (operands[1], DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  op1_rf = gen_reg_rtx (RFmode);\n+  expand_float (op1_rf, operands[1], 0);\n+\n+  if (! register_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  op2_rf = gen_reg_rtx (RFmode);\n+  expand_float (op2_rf, operands[2], 0);\n+\n+  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (DImode),\n+                            CONST1_RTX (DImode)));\n+\n+  if (TARGET_INLINE_INT_DIV == INL_MIN_LAT)\n+    emit_insn (gen_divdi3_internal_lat (op0_rf, op1_rf, op2_rf));\n+  else\n+    emit_insn (gen_divdi3_internal_thr (op0_rf, op1_rf, op2_rf));\n+\n+  emit_insn (gen_fix_truncrfdi2_alts (operands[0], op0_rf, const1_rtx));\n+  DONE;\n+})\n+\n+(define_expand \"moddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op2_neg, div;\n+\n+  div = gen_reg_rtx (DImode);\n+  emit_insn (gen_divdi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"udivdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op1_rf, op2_rf, op0_rf;\n+\n+  op0_rf = gen_reg_rtx (RFmode);\n+\n+  if (! register_operand (operands[1], DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n+  op1_rf = gen_reg_rtx (RFmode);\n+  expand_float (op1_rf, operands[1], 1);\n+\n+  if (! register_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+  op2_rf = gen_reg_rtx (RFmode);\n+  expand_float (op2_rf, operands[2], 1);\n+\n+  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (DImode),\n+                            CONST1_RTX (DImode)));\n+\n+  if (TARGET_INLINE_INT_DIV == INL_MIN_LAT)\n+    emit_insn (gen_divdi3_internal_lat (op0_rf, op1_rf, op2_rf));\n+  else\n+    emit_insn (gen_divdi3_internal_thr (op0_rf, op1_rf, op2_rf));\n+\n+  emit_insn (gen_fixuns_truncrfdi2_alts (operands[0], op0_rf, const1_rtx));\n+  DONE;\n+})\n+\n+(define_expand \"umoddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx op2_neg, div;\n+\n+  div = gen_reg_rtx (DImode);\n+  emit_insn (gen_udivdi3 (div, operands[1], operands[2]));\n+\n+  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n+\n+  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"divdi3_internal_lat\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"\")\n+        (float:RF (div:DI (match_operand:RF 1 \"fr_register_operand\" \"\")\n+                          (match_operand:RF 2 \"fr_register_operand\" \"\"))))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx a         = operands[1];\n+  rtx b         = operands[2];\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx y1        = gen_reg_rtx (RFmode);\n+  rtx y2        = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx e1        = gen_reg_rtx (RFmode);\n+  rtx q         = gen_reg_rtx (RFmode);\n+  rtx q1        = gen_reg_rtx (RFmode);\n+  rtx q2        = gen_reg_rtx (RFmode);\n+  rtx r         = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx one       = CONST1_RTX (RFmode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* y  = 1 / b\t\t\t*/\n+  emit_insn (gen_recip_approx_rf (y, a, b, cond, status1));\n+  /* e  = 1 - (b * y)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, b, y, zero, status1, trunc_off));\n+  /* q  = a * y                 */\n+  emit_insn (gen_mulrf3_cond (q, cond, a, y, zero, status1, trunc_off));\n+  /* q1 = q + (q * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (q1, cond, q, q, e, zero, status1, trunc_off));\n+  /* e1 = e * e\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (e1, cond, e, e, zero, status1, trunc_off));\n+  /* q2 = q1 + (e1 * q1)\t*/\n+  emit_insn (gen_m2addrf4_cond (q2, cond, q1, e1, q1, zero, status1, trunc_off));\n+  /* y1 = y + (y * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y1, cond, y, y, e, zero, status1, trunc_off));\n+  /* r  = a - (b * q2)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r, cond, a, b, q2, zero, status1, trunc_off));\n+  /* y2 = y1 + (y1 * e1)\t*/\n+  emit_insn (gen_m2addrf4_cond (y2, cond, y1, y1, e1, zero, status1, trunc_off));\n+  /* q3 = q2 + (r * y2)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (operands[0], cond, q2, r, y2, y, status1, trunc_off));\n+  DONE;\n+})\n+\n+(define_expand \"divdi3_internal_thr\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"\")\n+        (float:RF (div:DI (match_operand:RF 1 \"fr_register_operand\" \"\")\n+                          (match_operand:RF 2 \"fr_register_operand\" \"\"))))]\n+  \"TARGET_INLINE_INT_DIV\"\n+{\n+  rtx a         = operands[1];\n+  rtx b         = operands[2];\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx y1        = gen_reg_rtx (RFmode);\n+  rtx y2        = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx e1        = gen_reg_rtx (RFmode);\n+  rtx q2        = gen_reg_rtx (RFmode);\n+  rtx r         = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx one       = CONST1_RTX (RFmode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* y  = 1 / b\t\t\t*/\n+  emit_insn (gen_recip_approx_rf (y, a, b, cond, status1));\n+  /* e  = 1 - (b * y)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, b, y, zero, status1, trunc_off));\n+  /* y1 = y + (y * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y1, cond, y, y, e, zero, status1, trunc_off));\n+  /* e1 = e * e\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (e1, cond, e, e, zero, status1, trunc_off));\n+  /* y2 = y1 + (y1 * e1)\t*/\n+  emit_insn (gen_m2addrf4_cond (y2, cond, y1, y1, e1, zero, status1, trunc_off));\n+  /* q2 = y2 * a\t\t*/\n+  emit_insn (gen_mulrf3_cond (q2, cond, y2, a, zero, status1, trunc_off));\n+  /* r  = a - (b * q2)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r, cond, a, b, q2, zero, status1, trunc_off));\n+  /* q3 = q2 + (r * y2)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (operands[0], cond, q2, r, y2, y, status1, trunc_off));\n+  DONE;\n+})\n+\n ;; SQRT operations\n \n \n@@ -535,6 +928,20 @@\n   [(set_attr \"itanium_class\" \"fmisc\")\n    (set_attr \"predicable\" \"no\")])\n \n+(define_expand \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n+\t(sqrt:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx insn;\n+  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n+    insn = gen_sqrtsf2_internal_lat (operands[0], operands[1]);\n+  else\n+    insn = gen_sqrtsf2_internal_thr (operands[0], operands[1]);\n+  emit_insn (insn);\n+  DONE;\n+})\n+\n (define_expand \"sqrtsf2_internal_thr\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n         (sqrt:SF (match_operand:SF 1 \"fr_register_operand\" \"\")))]\n@@ -662,6 +1069,22 @@\n   DONE;\n })\n \n+(define_expand \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n+\t(sqrt:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx insn;\n+#if 0\n+  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n+    insn = gen_sqrtdf2_internal_lat (operands[0], operands[1]);\n+  else\n+#endif\n+  insn = gen_sqrtdf2_internal_thr (operands[0], operands[1]);\n+  emit_insn (insn);\n+  DONE;\n+})\n+\n (define_expand \"sqrtdf2_internal_thr\"\n   [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n         (sqrt:DF (match_operand:DF 1 \"fr_register_operand\" \"\")))]\n@@ -727,7 +1150,7 @@\n   DONE;\n })\n \n-(define_expand \"sqrtxf2_internal\"\n+(define_expand \"sqrtxf2\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"\")\n         (sqrt:XF (match_operand:XF 1 \"fr_register_operand\" \"\")))]\n   \"TARGET_INLINE_SQRT\""}, {"sha": "f9c6de2dbe45b5d71d3f24e2ffab07cebb4fea36", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 20, "deletions": 620, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=49df2fb8bdbca6598a4ecee0da3fa7ab5ea6d41d", "patch": "@@ -1234,6 +1234,13 @@\n \n ;; Convert between signed integer types and floating point.\n \n+(define_insn \"floatdirf2\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+\t(float:RF (match_operand:DI 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n+  \"fcvt.xf %0 = %F1\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n (define_insn \"floatdixf2\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n \t(float:XF (match_operand:DI 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n@@ -1262,12 +1269,11 @@\n   \"fcvt.fx.trunc %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fix_truncxfdi2_alts\"\n+(define_insn \"fix_truncrfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(fix:DI (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")))\n-   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+\t(fix:DI (match_operand:RF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n   \"\"\n-  \"fcvt.fx.trunc.s%2 %0 = %F1\"\n+  \"fcvt.fx.trunc %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n ;; Convert between unsigned integer types and floating point.\n@@ -1293,6 +1299,13 @@\n   \"fcvt.xuf %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n+(define_insn \"floatunsdirf2\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+\t(unsigned_float:RF (match_operand:DI 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n+  \"\"\n+  \"fcvt.xuf %0 = %F1\"\n+  [(set_attr \"itanium_class\" \"fcvtfx\")])\n+\n (define_insn \"fixuns_truncsfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(unsigned_fix:DI (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n@@ -1314,12 +1327,11 @@\n   \"fcvt.fxu.trunc %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \n-(define_insn \"fixuns_truncxfdi2_alts\"\n+(define_insn \"fixuns_truncrfdi2\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n-\t(unsigned_fix:DI (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")))\n-   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+\t(unsigned_fix:DI (match_operand:RF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n   \"\"\n-  \"fcvt.fxu.trunc.s%2 %0 = %F1\"\n+  \"fcvt.fxu.trunc %0 = %F1\"\n   [(set_attr \"itanium_class\" \"fcvtfx\")])\n \f\n ;; ::::::::::::::::::::\n@@ -2176,169 +2188,6 @@\n \t\t\t (match_dup 1) (match_dup 2)))]\n   \"\"\n   { operands[3] = gen_reg_rtx (BImode); })\n-\n-(define_expand \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op1_xf, op2_xf, op0_xf, op0_di, twon34, twon34_exp;\n-\n-  op0_xf = gen_reg_rtx (XFmode);\n-  op0_di = gen_reg_rtx (DImode);\n-\n-  if (CONSTANT_P (operands[1]))\n-    operands[1] = force_reg (SImode, operands[1]);\n-  op1_xf = gen_reg_rtx (XFmode);\n-  expand_float (op1_xf, operands[1], 0);\n-\n-  if (CONSTANT_P (operands[2]))\n-    operands[2] = force_reg (SImode, operands[2]);\n-  op2_xf = gen_reg_rtx (XFmode);\n-  expand_float (op2_xf, operands[2], 0);\n-\n-  /* 2^-34 */\n-  twon34_exp = gen_reg_rtx (DImode);\n-  emit_move_insn (twon34_exp, GEN_INT (65501));\n-  twon34 = gen_reg_rtx (XFmode);\n-  emit_insn (gen_setf_exp_xf (twon34, twon34_exp));\n-\n-  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (SImode),\n-\t\t\t    CONST1_RTX (SImode)));\n-  \n-  emit_insn (gen_divsi3_internal (op0_xf, op1_xf, op2_xf, twon34));\n-\n-  emit_insn (gen_fix_truncxfdi2_alts (op0_di, op0_xf, const1_rtx));\n-  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n-  DONE;\n-})\n-\n-(define_expand \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op2_neg, op1_di, div;\n-\n-  div = gen_reg_rtx (SImode);\n-  emit_insn (gen_divsi3 (div, operands[1], operands[2]));\n-\n-  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n-\n-  /* This is a trick to get us to reuse the value that we're sure to\n-     have already copied to the FP regs.  */\n-  op1_di = gen_reg_rtx (DImode);\n-  convert_move (op1_di, operands[1], 0);\n-\n-  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n-\t\t\t  gen_lowpart (SImode, op1_di)));\n-  DONE;\n-})\n-\n-(define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op1_xf, op2_xf, op0_xf, op0_di, twon34, twon34_exp;\n-\n-  op0_xf = gen_reg_rtx (XFmode);\n-  op0_di = gen_reg_rtx (DImode);\n-\n-  if (CONSTANT_P (operands[1]))\n-    operands[1] = force_reg (SImode, operands[1]);\n-  op1_xf = gen_reg_rtx (XFmode);\n-  expand_float (op1_xf, operands[1], 1);\n-\n-  if (CONSTANT_P (operands[2]))\n-    operands[2] = force_reg (SImode, operands[2]);\n-  op2_xf = gen_reg_rtx (XFmode);\n-  expand_float (op2_xf, operands[2], 1);\n-\n-  /* 2^-34 */\n-  twon34_exp = gen_reg_rtx (DImode);\n-  emit_move_insn (twon34_exp, GEN_INT (65501));\n-  twon34 = gen_reg_rtx (XFmode);\n-  emit_insn (gen_setf_exp_xf (twon34, twon34_exp));\n-\n-  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (SImode),\n-\t\t\t    CONST1_RTX (SImode)));\n-  \n-  emit_insn (gen_divsi3_internal (op0_xf, op1_xf, op2_xf, twon34));\n-\n-  emit_insn (gen_fixuns_truncxfdi2_alts (op0_di, op0_xf, const1_rtx));\n-  emit_move_insn (operands[0], gen_lowpart (SImode, op0_di));\n-  DONE;\n-})\n-\n-(define_expand \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op2_neg, op1_di, div;\n-\n-  div = gen_reg_rtx (SImode);\n-  emit_insn (gen_udivsi3 (div, operands[1], operands[2]));\n-\n-  op2_neg = expand_unop (SImode, neg_optab, operands[2], NULL_RTX, 0);\n-\n-  /* This is a trick to get us to reuse the value that we're sure to\n-     have already copied to the FP regs.  */\n-  op1_di = gen_reg_rtx (DImode);\n-  convert_move (op1_di, operands[1], 1);\n-\n-  emit_insn (gen_maddsi4 (operands[0], div, op2_neg,\n-\t\t\t  gen_lowpart (SImode, op1_di)));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"divsi3_internal\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:XF (div:SI (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\"))))\n-   (clobber (match_scratch:XF 4 \"=&f\"))\n-   (clobber (match_scratch:XF 5 \"=&f\"))\n-   (clobber (match_scratch:BI 6 \"=c\"))\n-   (use (match_operand:XF 3 \"fr_register_operand\" \"f\"))]\n-  \"TARGET_INLINE_INT_DIV\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (unspec:XF [(const_int 1) (match_dup 2)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX_RES))\n-\t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n-\t      (use (const_int 1))])\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 5)\n-\t\t     (minus:XF (match_dup 7)\n-\t\t\t       (mult:XF (match_dup 2) (match_dup 0))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-\t\t\t      (match_dup 4)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 5)\n-\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 5))\n-\t\t\t      (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-\t\t\t      (match_dup 4)))\n-\t\t(use (const_int 1))]))\n-  ] \n-  \"operands[7] = CONST1_RTX (XFmode);\"\n-  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -2612,215 +2461,6 @@\n   \"\"\n   \"getf.exp %0 = %F1\"\n   [(set_attr \"itanium_class\" \"frfr\")])\n-\n-(define_expand \"divdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(div:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op1_xf, op2_xf, op0_xf;\n-\n-  op0_xf = gen_reg_rtx (XFmode);\n-\n-  if (CONSTANT_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-  op1_xf = gen_reg_rtx (XFmode);\n-  expand_float (op1_xf, operands[1], 0);\n-\n-  if (CONSTANT_P (operands[2]))\n-    operands[2] = force_reg (DImode, operands[2]);\n-  op2_xf = gen_reg_rtx (XFmode);\n-  expand_float (op2_xf, operands[2], 0);\n-\n-  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (DImode),\n-\t\t\t    CONST1_RTX (DImode)));\n-\n-  if (TARGET_INLINE_INT_DIV == INL_MIN_LAT)\n-    emit_insn (gen_divdi3_internal_lat (op0_xf, op1_xf, op2_xf));\n-  else\n-    emit_insn (gen_divdi3_internal_thr (op0_xf, op1_xf, op2_xf));\n-\n-  emit_insn (gen_fix_truncxfdi2_alts (operands[0], op0_xf, const1_rtx));\n-  DONE;\n-})\n-\n-(define_expand \"moddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(mod:SI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op2_neg, div;\n-\n-  div = gen_reg_rtx (DImode);\n-  emit_insn (gen_divdi3 (div, operands[1], operands[2]));\n-\n-  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n-\n-  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n-  DONE;\n-})\n-\n-(define_expand \"udivdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(udiv:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op1_xf, op2_xf, op0_xf;\n-\n-  op0_xf = gen_reg_rtx (XFmode);\n-\n-  if (CONSTANT_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-  op1_xf = gen_reg_rtx (XFmode);\n-  expand_float (op1_xf, operands[1], 1);\n-\n-  if (CONSTANT_P (operands[2]))\n-    operands[2] = force_reg (DImode, operands[2]);\n-  op2_xf = gen_reg_rtx (XFmode);\n-  expand_float (op2_xf, operands[2], 1);\n-\n-  emit_insn (gen_cond_trap (EQ, operands[2], CONST0_RTX (DImode),\n-\t\t\t    CONST1_RTX (DImode)));\n-\n-  if (TARGET_INLINE_INT_DIV == INL_MIN_LAT)\n-    emit_insn (gen_divdi3_internal_lat (op0_xf, op1_xf, op2_xf));\n-  else\n-    emit_insn (gen_divdi3_internal_thr (op0_xf, op1_xf, op2_xf));\n-\n-  emit_insn (gen_fixuns_truncxfdi2_alts (operands[0], op0_xf, const1_rtx));\n-  DONE;\n-})\n-\n-(define_expand \"umoddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(umod:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_INLINE_INT_DIV\"\n-{\n-  rtx op2_neg, div;\n-\n-  div = gen_reg_rtx (DImode);\n-  emit_insn (gen_udivdi3 (div, operands[1], operands[2]));\n-\n-  op2_neg = expand_unop (DImode, neg_optab, operands[2], NULL_RTX, 0);\n-\n-  emit_insn (gen_madddi4 (operands[0], div, op2_neg, operands[1]));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"divdi3_internal_lat\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:XF (div:SI (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\"))))\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   (clobber (match_scratch:XF 4 \"=&f\"))\n-   (clobber (match_scratch:XF 5 \"=&f\"))\n-   (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"TARGET_INLINE_INT_DIV == INL_MIN_LAT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (unspec:XF [(const_int 1) (match_dup 2)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX_RES))\n-\t      (set (match_dup 6) (unspec:BI [(match_dup 1) (match_dup 2)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n-\t      (use (const_int 1))])\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (minus:XF (match_dup 7)\n-\t\t\t       (mult:XF (match_dup 2) (match_dup 0))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4) (mult:XF (match_dup 1) (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 5) (mult:XF (match_dup 3) (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n-\t\t\t      (match_dup 4)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n-\t\t\t      (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-\t\t\t      (match_dup 4)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 5) (match_dup 0))\n-\t\t\t      (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (minus:XF (match_dup 1)\n-\t\t\t       (mult:XF (match_dup 2) (match_dup 3))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 6) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n-\t\t\t      (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-  ] \n-  \"operands[7] = CONST1_RTX (XFmode);\"\n-  [(set_attr \"predicable\" \"no\")])\n-\n-(define_insn_and_split \"divdi3_internal_thr\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n-\t(float:XF (div:SI (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\"))))\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   (clobber (match_scratch:XF 4 \"=f\"))\n-   (clobber (match_scratch:BI 5 \"=c\"))]\n-  \"TARGET_INLINE_INT_DIV == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0) (unspec:XF [(const_int 1) (match_dup 2)]\n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX_RES))\n-\t      (set (match_dup 5) (unspec:BI [(match_dup 1) (match_dup 2)] \n-\t\t\t\t\t    UNSPEC_FR_RECIP_APPROX))\n-\t      (use (const_int 1))])\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3)\n-\t\t     (minus:XF (match_dup 6)\n-\t\t\t       (mult:XF (match_dup 2) (match_dup 0))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n-\t\t\t      (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:XF (match_dup 3) (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 3) (match_dup 0))\n-\t\t\t      (match_dup 0)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 3) (mult:XF (match_dup 0) (match_dup 1)))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 4)\n-\t\t     (minus:XF (match_dup 1)\n-\t\t\t       (mult:XF (match_dup 2) (match_dup 3))))\n-\t\t(use (const_int 1))]))\n-   (cond_exec (ne (match_dup 5) (const_int 0))\n-     (parallel [(set (match_dup 0)\n-\t\t     (plus:XF (mult:XF (match_dup 4) (match_dup 0))\n-\t\t\t      (match_dup 3)))\n-\t\t(use (const_int 1))]))\n-  ] \n-  \"operands[6] = CONST1_RTX (XFmode);\"\n-  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3135,56 +2775,6 @@\n   \"TARGET_FUSED_MADD\"\n   \"fnma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*nmaddsf4_alts\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 3 \"fr_reg_or_fp01_operand\" \"fG\") \n-\t\t  (mult:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t   (match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.s.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_expand \"divsf3\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n-\t(div:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"\")\n-\t\t(match_operand:SF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n-  \"TARGET_INLINE_FLOAT_DIV\"\n-{\n-  rtx insn;\n-  if (TARGET_INLINE_FLOAT_DIV == INL_MIN_LAT)\n-    insn = gen_divsf3_internal_lat (operands[0], operands[1], operands[2]);\n-  else\n-    insn = gen_divsf3_internal_thr (operands[0], operands[1], operands[2]);\n-  emit_insn (insn);\n-  DONE;\n-})\n-\n-(define_insn \"setf_exp_xf\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-        (unspec:XF [(match_operand:DI 1 \"register_operand\" \"r\")]\n-                  UNSPEC_SETF_EXP))]\n-  \"\"\n-  \"setf.exp %0 = %1\"\n-  [(set_attr \"itanium_class\" \"frfr\")])\n-\n-\n-;; Inline square root.\n-\n-(define_expand \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n-  \"TARGET_INLINE_SQRT\"\n-{\n-  rtx insn;\n-  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n-    insn = gen_sqrtsf2_internal_lat (operands[0], operands[1]);\n-  else\n-    insn = gen_sqrtsf2_internal_thr (operands[0], operands[1]);\n-  emit_insn (insn);\n-  DONE;\n-})\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3362,16 +2952,6 @@\n   \"fnma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*nmadddf4_alts\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 3 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t  (mult:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t   (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.d.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n (define_insn \"*nmadddf4_truncsf\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n \t(float_truncate:SF\n@@ -3381,50 +2961,6 @@\n   \"TARGET_FUSED_MADD\"\n   \"fnma.s %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*nmadddf4_truncsf_alts\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:SF\n-\t(minus:DF (match_operand:DF 3 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t  (mult:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t\t   (match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"fG\")))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.s.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_expand \"divdf3\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n-\t(div:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"\")\n-\t\t(match_operand:DF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n-  \"TARGET_INLINE_FLOAT_DIV\"\n-{\n-  rtx insn;\n-  if (TARGET_INLINE_FLOAT_DIV == INL_MIN_LAT)\n-    insn = gen_divdf3_internal_lat (operands[0], operands[1], operands[2]);\n-  else\n-    insn = gen_divdf3_internal_thr (operands[0], operands[1], operands[2]);\n-  emit_insn (insn);\n-  DONE;\n-})\n-\n-;; Inline square root.\n-\n-(define_expand \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n-  \"TARGET_INLINE_SQRT\"\n-{\n-  rtx insn;\n-#if 0\n-  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n-    insn = gen_sqrtdf2_internal_lat (operands[0], operands[1]);\n-  else\n-#endif\n-  insn = gen_sqrtdf2_internal_thr (operands[0], operands[1]);\n-  emit_insn (insn);\n-  DONE;\n-})\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3510,35 +3046,6 @@\n   \"fmpy.d %0 = %F1, %F2\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*mulxf3_alts\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-\t(mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fmpy.s%3 %0 = %F1, %F2\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*mulxf3_truncsf_alts\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:SF\n-\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fmpy.s.s%3 %0 = %F1, %F2\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*mulxf3_truncdf_alts\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:DF\n-\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fmpy.d.s%3 %0 = %F1, %F2\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n (define_insn \"absxf2\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n \t(abs:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")))]\n@@ -3623,38 +3130,6 @@\n   \"fma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n \n-(define_insn \"*maddxf4_alts\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-\t(plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t  (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n-\t\t (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fma.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*maddxf4_alts_truncsf\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:SF\n-\t  (plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n-\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fma.s.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*maddxf4_alts_truncdf\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:DF\n-\t  (plus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t    (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\"))\n-\t\t   (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\"))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fma.d.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n (define_insn \"*msubxf4\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n \t(minus:XF (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n@@ -3743,81 +3218,6 @@\n   \"TARGET_FUSED_MADD\"\n   \"fnma.d %0 = %F1, %F2, %F3\"\n   [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*nmaddxf4_alts\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-\t(minus:XF (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t  (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t   (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")\n-   )))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*nmaddxf4_truncsf_alts\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:SF\n-\t  (minus:XF (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\") \n-\t\t    (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t     (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")\n-   ))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.s.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_insn \"*nmaddxf4_truncdf_alts\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=f\")\n-\t(float_truncate:DF\n-\t  (minus:XF (match_operand:XF 3 \"xfreg_or_fp01_operand\" \"fG\") \n-\t\t    (mult:XF (match_operand:XF 1 \"xfreg_or_fp01_operand\" \"fG\")\n-\t\t\t     (match_operand:XF 2 \"xfreg_or_fp01_operand\" \"fG\")\n-   ))))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"fnma.d.s%4 %0 = %F1, %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmac\")])\n-\n-(define_expand \"divxf3\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"\")\n-\t(div:XF (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"\")\n-\t\t(match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"\")))]\n-  \"TARGET_INLINE_FLOAT_DIV\"\n-{\n-  /* There is only one divxf3 sequence, not two like for divsf and divdf.  */\n-  emit_insn (gen_divxf3_internal (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-;; Inline square root.\n-\n-(define_expand \"sqrtxf2\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:XF (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n-  \"TARGET_INLINE_SQRT\"\n-{\n-  rtx insn;\n-  insn = gen_sqrtxf2_internal (operands[0], operands[1]);\n-  emit_insn (insn);\n-  DONE;\n-})\n-\n-;; ??? frcpa works like cmp.foo.unc.\n-\n-(define_insn \"*recip_approx\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-\t(unspec:XF [(const_int 1)\n-\t\t    (match_operand:XF 3 \"fr_reg_or_fp01_operand\" \"fG\")]\n-\t\t   UNSPEC_FR_RECIP_APPROX_RES))\n-   (set (match_operand:BI 1 \"register_operand\" \"=c\")\n-\t(unspec:BI [(match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\")\n-\t\t    (match_dup 3)] UNSPEC_FR_RECIP_APPROX))\n-   (use (match_operand:SI 4 \"const_int_operand\" \"\"))]\n-  \"\"\n-  \"frcpa.s%4 %0, %1 = %F2, %F3\"\n-  [(set_attr \"itanium_class\" \"fmisc\")\n-   (set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::"}]}