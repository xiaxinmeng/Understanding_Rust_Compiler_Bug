{"sha": "68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "node_id": "C_kwDOANBUbNoAKDY4ZjM3NjcwZWZmMGI4NzJjZTVkZmQzODJjOGQ4ZjMyMDZiZGZjMjc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-19T18:04:13Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-07-19T18:04:13Z"}, "message": "c++: shortcut bad reference binding [PR94894]\n\nIn case of l/rvalue or cv-qual mismatch during reference binding, we\ntry to give more helpful diagnostics by computing a bad conversion that\nallows the mismatch.  But in doing so, we may end up considering and\ninstantiating a conversion function that could induce a hard error and\nin turn cause us to reject otherwise valid code.  We could just give up\non producing a better diagnostic here, but ideally we'd preserve the\nbetter diagnostics for invalid code while avoiding unnecessary template\ninstantiations for valid code.\n\nTo that end, this patch adapts the bad conversion shortcutting mechanism\nfrom r12-3346-g47543e5f9d1fc5 to additionally handle this situation.\nThe main observation from there is that during overload resolution, if we\nknow we have a strictly viable candidate then we don't need to distinguish\nbetween an unviable and non-strictly viable candidate.  Thus we don't\nneed to distinguish between an invalid and bad conversion either, which\nis what this patch exploits.  Of course, we don't know whether we have a\nstrictly viable candidate until after the fact, so we still need to\nremember when we deferred distinguishing between an invalid and bad\nconversion.  This patch adds a special conversion kind ck_deferred_bad\nfor this purpose.\n\n\tPR c++/94894\n\tPR c++/105766\n\tPR c++/106201\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (enum conversion_kind): Add ck_deferred_bad enumerator.\n\t(has_next): Return false for it.\n\t(reference_binding): Return a ck_deferred_bad conversion instead\n\tof an actual bad conversion when LOOKUP_SHORTCUT_BAD_CONVS is set.\n\tRemove now obsolete early exit for the incomplete TO case.\n\t(implicit_conversion_1): Don't mask out LOOKUP_SHORTCUT_BAD_CONVS.\n\t(add_function_candidate): Set LOOKUP_SHORTCUT_BAD_CONVS iff\n\tshortcut_bad_convs.\n\t(missing_conversion_p): Also return true for a ck_deferred_bad\n\tconversion.\n\t* cp-tree.h (LOOKUP_SHORTCUT_BAD_CONVS): Define.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/conversion/ref8.C: New test.\n\t* g++.dg/conversion/ref9.C: New test.", "tree": {"sha": "3b182cbef25c3efa64e734a340ce60281853d152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b182cbef25c3efa64e734a340ce60281853d152"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/comments", "author": null, "committer": null, "parents": [{"sha": "7a158a5776f5ca95a318fcae0ca2dfefb0789538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a158a5776f5ca95a318fcae0ca2dfefb0789538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a158a5776f5ca95a318fcae0ca2dfefb0789538"}], "stats": {"total": 140, "additions": 108, "deletions": 32}, "files": [{"sha": "01a7be100778d0255d2f00ee0c9d96e5e4eb68d2", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "patch": "@@ -59,7 +59,13 @@ enum conversion_kind {\n   ck_ambig,\n   ck_list,\n   ck_aggr,\n-  ck_rvalue\n+  ck_rvalue,\n+  /* When LOOKUP_SHORTCUT_BAD_CONVS is set, we may return a conversion of\n+     this kind whenever we know the true conversion is either bad or outright\n+     invalid, but we don't want to attempt to compute the bad conversion (for\n+     sake of avoiding unnecessary instantiation).  bad_p should always be set\n+     for these.  */\n+  ck_deferred_bad,\n };\n \n /* The rank of the conversion.  Order of the enumerals matters; better\n@@ -775,7 +781,8 @@ has_next (conversion_kind code)\n   return !(code == ck_identity\n \t   || code == ck_ambig\n \t   || code == ck_list\n-\t   || code == ck_aggr);\n+\t   || code == ck_aggr\n+\t   || code == ck_deferred_bad);\n }\n \n static conversion *\n@@ -1912,18 +1919,38 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n      difference in top-level cv-qualification is subsumed by the\n      initialization itself and does not constitute a conversion.  */\n \n+  bool maybe_valid_p = true;\n+\n   /* [dcl.init.ref]\n \n      Otherwise, the reference shall be an lvalue reference to a\n      non-volatile const type, or the reference shall be an rvalue\n-     reference.\n+     reference.  */\n+  if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !TYPE_REF_IS_RVALUE (rto))\n+    maybe_valid_p = false;\n \n-     We try below to treat this as a bad conversion to improve diagnostics,\n-     but if TO is an incomplete class, we need to reject this conversion\n-     now to avoid unnecessary instantiation.  */\n-  if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !TYPE_REF_IS_RVALUE (rto)\n-      && !COMPLETE_TYPE_P (to))\n-    return NULL;\n+  /* [dcl.init.ref]\n+\n+     Otherwise, a temporary of type \"cv1 T1\" is created and\n+     initialized from the initializer expression using the rules for a\n+     non-reference copy initialization.  If T1 is reference-related to\n+     T2, cv1 must be the same cv-qualification as, or greater\n+     cv-qualification than, cv2; otherwise, the program is ill-formed.  */\n+  if (related_p && !at_least_as_qualified_p (to, from))\n+    maybe_valid_p = false;\n+\n+  /* We try below to treat an invalid reference binding as a bad conversion\n+     to improve diagnostics, but doing so may cause otherwise unnecessary\n+     instantiations that can lead to a hard error.  So during the first pass\n+     of overload resolution wherein we shortcut bad conversions, instead just\n+     produce a special conversion indicating a second pass is necessary if\n+     there's no strictly viable candidate.  */\n+  if (!maybe_valid_p && (flags & LOOKUP_SHORTCUT_BAD_CONVS))\n+    {\n+      conv = alloc_conversion (ck_deferred_bad);\n+      conv->bad_p = true;\n+      return conv;\n+    }\n \n   /* We're generating a temporary now, but don't bind any more in the\n      conversion (specifically, don't slice the temporary returned by a\n@@ -1967,7 +1994,9 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n \t\t\t\t   sflags, complain);\n \t    if (!new_second)\n \t      return NULL;\n-\t    return merge_conversion_sequences (t, new_second);\n+\t    conv = merge_conversion_sequences (t, new_second);\n+\t    gcc_assert (maybe_valid_p || conv->bad_p);\n+\t    return conv;\n \t  }\n     }\n \n@@ -1976,24 +2005,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n      creation of a temporary.  */\n   conv->need_temporary_p = true;\n   conv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n-\n-  /* [dcl.init.ref]\n-\n-     Otherwise, the reference shall be an lvalue reference to a\n-     non-volatile const type, or the reference shall be an rvalue\n-     reference.  */\n-  if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !TYPE_REF_IS_RVALUE (rto))\n-    conv->bad_p = true;\n-\n-  /* [dcl.init.ref]\n-\n-     Otherwise, a temporary of type \"cv1 T1\" is created and\n-     initialized from the initializer expression using the rules for a\n-     non-reference copy initialization.  If T1 is reference-related to\n-     T2, cv1 must be the same cv-qualification as, or greater\n-     cv-qualification than, cv2; otherwise, the program is ill-formed.  */\n-  if (related_p && !at_least_as_qualified_p (to, from))\n-    conv->bad_p = true;\n+  conv->bad_p |= !maybe_valid_p;\n \n   return conv;\n }\n@@ -2015,7 +2027,8 @@ implicit_conversion_1 (tree to, tree from, tree expr, bool c_cast_p,\n      resolution, or after we've chosen one.  */\n   flags &= (LOOKUP_ONLYCONVERTING|LOOKUP_NO_CONVERSION|LOOKUP_COPY_PARM\n \t    |LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND|LOOKUP_PREFER_RVALUE\n-\t    |LOOKUP_NO_NARROWING|LOOKUP_PROTECT|LOOKUP_NO_NON_INTEGRAL);\n+\t    |LOOKUP_NO_NARROWING|LOOKUP_PROTECT|LOOKUP_NO_NON_INTEGRAL\n+\t    |LOOKUP_SHORTCUT_BAD_CONVS);\n \n   /* FIXME: actually we don't want warnings either, but we can't just\n      have 'complain &= ~(tf_warning|tf_error)' because it would cause\n@@ -2433,6 +2446,11 @@ add_function_candidate (struct z_candidate **candidates,\n   if (! viable)\n     goto out;\n \n+  if (shortcut_bad_convs)\n+    flags |= LOOKUP_SHORTCUT_BAD_CONVS;\n+  else\n+    flags &= ~LOOKUP_SHORTCUT_BAD_CONVS;\n+\n   /* Third, for F to be a viable function, there shall exist for each\n      argument an implicit conversion sequence that converts that argument\n      to the corresponding parameter of F.  */\n@@ -6038,14 +6056,24 @@ perfect_candidate_p (z_candidate *cand)\n   return true;\n }\n \n-/* True iff one of CAND's argument conversions is NULL.  */\n+/* True iff one of CAND's argument conversions is missing.  */\n \n static bool\n missing_conversion_p (const z_candidate *cand)\n {\n   for (unsigned i = 0; i < cand->num_convs; ++i)\n-    if (!cand->convs[i])\n-      return true;\n+    {\n+      conversion *conv = cand->convs[i];\n+      if (!conv)\n+\treturn true;\n+      if (conv->kind == ck_deferred_bad)\n+\t{\n+\t  /* We don't know whether this conversion is outright invalid or\n+\t     just bad, so conservatively assume it's missing.  */\n+\t  gcc_checking_assert (conv->bad_p);\n+\t  return true;\n+\t}\n+    }\n   return false;\n }\n "}, {"sha": "3278b4114bd6280cf9d9ccb153a65360805ce29e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "patch": "@@ -5877,6 +5877,11 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_REVERSED (LOOKUP_REWRITTEN << 1)\n /* We're initializing an aggregate from a parenthesized list of values.  */\n #define LOOKUP_AGGREGATE_PAREN_INIT (LOOKUP_REVERSED << 1)\n+/* We're computing conversions as part of a first pass of overload resolution\n+   wherein we don't try to distinguish an unviable candidate from a\n+   non-strictly viable candidate and thus can avoid computing unnecessary\n+   bad conversions.  */\n+#define LOOKUP_SHORTCUT_BAD_CONVS (LOOKUP_AGGREGATE_PAREN_INIT << 1)\n \n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined)."}, {"sha": "0dd29f751ca00f7d2502ee0b1a6dbc3730537373", "filename": "gcc/testsuite/g++.dg/conversion/ref8.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref8.C?ref=68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/105766\n+// { dg-do compile { target c++20 } }\n+\n+template<class T>\n+struct baz {\n+  baz() = default;\n+  baz(int) requires requires { T(0); };\n+};\n+\n+struct foo;\n+\n+struct bar {\n+  bar() = default;\n+  bar(foo&);\n+  bar(int);\n+};\n+\n+struct foo {\n+  baz<bar> m_bars;\n+};\n+\n+foo a;"}, {"sha": "e6dfc03cd7f9098fcd5abef06d8c549ea65e6616", "filename": "gcc/testsuite/g++.dg/conversion/ref9.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f37670eff0b872ce5dfd382c8d8f3206bdfc27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fref9.C?ref=68f37670eff0b872ce5dfd382c8d8f3206bdfc27", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/106201\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  template<class T, class = decltype(f(*(T*)nullptr))>\n+  A(const T&);\n+};\n+\n+struct B {\n+  template<class T> B(const T&);\n+};\n+\n+void f(A&);\n+void f(B);\n+\n+struct C { };\n+\n+int main() {\n+  C c;\n+  f(c);\n+}"}]}