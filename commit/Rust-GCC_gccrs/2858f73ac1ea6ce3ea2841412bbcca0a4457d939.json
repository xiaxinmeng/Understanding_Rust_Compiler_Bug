{"sha": "2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1OGY3M2FjMWVhNmNlM2VhMjg0MTQxMmJiY2NhMGE0NDU3ZDkzOQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-11-06T21:52:36Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-11-06T21:52:36Z"}, "message": "rs6000.h (USE_FP_FOR_ARG_P): Move to rs6000.c.\n\n\t* config/rs6000/rs6000.h (USE_FP_FOR_ARG_P): Move to rs6000.c.\n\t(USE_ALTIVEC_FOR_ARG_P): Likewise.\n\t* config/rs6000/rs6000.c (USE_FP_FOR_ARG_P): Move from rs6000.h.\n\tTake a pointer as the CUM parameter.  Update callers.\n\t(USE_ALTIVEC_FOR_ARG_P): Likewise.  Also correct for Darwin/AIX\n\t32-bit ABIs.\n\t(function_arg_advance): Use USE_ALTIVEC_FOR_ARG_P.  Correct case\n\tof vector parameters as named arguments of stdarg function.\n\t(function_arg): Likewise.\n\n\t* config/rs6000/darwin.h (ASM_SPEC): Use -force_cpusubtype_ALL when\n\t-maltivec is specified, not the non-existent -faltivec.\n\nFrom-SVN: r73317", "tree": {"sha": "c287691f13ab129d28d129a7659cd182d4d7dae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c287691f13ab129d28d129a7659cd182d4d7dae7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c17530ef3d7a0e4db6706df5507ace7714ad56d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c17530ef3d7a0e4db6706df5507ace7714ad56d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c17530ef3d7a0e4db6706df5507ace7714ad56d"}], "stats": {"total": 195, "additions": 152, "deletions": 43}, "files": [{"sha": "f889c2c4db803cf1e18f8663934826f6818f8886", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -1,3 +1,18 @@\n+2003-11-06  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* config/rs6000/rs6000.h (USE_FP_FOR_ARG_P): Move to rs6000.c.\n+\t(USE_ALTIVEC_FOR_ARG_P): Likewise.\n+\t* config/rs6000/rs6000.c (USE_FP_FOR_ARG_P): Move from rs6000.h.\n+\tTake a pointer as the CUM parameter.  Update callers.\n+\t(USE_ALTIVEC_FOR_ARG_P): Likewise.  Also correct for Darwin/AIX\n+\t32-bit ABIs.\n+\t(function_arg_advance): Use USE_ALTIVEC_FOR_ARG_P.  Correct case\n+\tof vector parameters as named arguments of stdarg function.\n+\t(function_arg): Likewise.\n+\n+\t* config/rs6000/darwin.h (ASM_SPEC): Use -force_cpusubtype_ALL when\n+\t-maltivec is specified, not the non-existent -faltivec.\n+\n 2003-11-06  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390-protos.h (s390_function_value): Declare."}, {"sha": "929290ffebfc860f58f2bd1d5571005f6f01e9d7", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -100,7 +100,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_SPEC \"-arch ppc \\\n   %{Zforce_cpusubtype_ALL:-force_cpusubtype_ALL} \\\n-  %{!Zforce_cpusubtype_ALL:%{faltivec:-force_cpusubtype_ALL}}\"\n+  %{!Zforce_cpusubtype_ALL:%{maltivec:-force_cpusubtype_ALL}}\"\n \n #undef SUBTARGET_EXTRA_SPECS\n #define SUBTARGET_EXTRA_SPECS\t\t\t\\"}, {"sha": "9a0efb0efd8b8e9dd300645528d05e27d9af6bbd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -3618,6 +3618,19 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n }\n \f\n+/* Nonzero if we can use a floating-point register to pass this arg.  */\n+#define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+   && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n+   && TARGET_HARD_FLOAT && TARGET_FPRS)\n+\n+/* Nonzero if we can use an AltiVec register to pass this arg.  */\n+#define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE,NAMED)\t\\\n+  (ALTIVEC_VECTOR_MODE (MODE)\t\t\t\t\\\n+   && (CUM)->vregno <= ALTIVEC_ARG_MAX_REG\t\t\\\n+   && TARGET_ALTIVEC_ABI\t\t\t\t\\\n+   && (DEFAULT_ABI == ABI_V4 || (NAMED)))\n+\n /* Return a nonzero value to say to return the function value in\n    memory, just as large structures are always returned.  TYPE will be\n    the data type of the value, and FNTYPE will be the type of the\n@@ -3802,23 +3815,35 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     {\n-      if (named && cum->vregno <= ALTIVEC_ARG_MAX_REG)\n+      if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n \tcum->vregno++;\n-      else\n+      \n+      /* In variable-argument functions, vector arguments get GPRs allocated\n+\t even if they are going to be passed in a vector register.  */\n+      if (cum->stdarg && DEFAULT_ABI != ABI_V4)\n \t{\n \t  int align;\n \t  \n-\t  /* Vector parameters must be 16-byte aligned.  This places them at\n-\t     2 mod 4 in terms of words (on both ABIs).  */\n-\t  align = ((6 - (cum->words & 3)) & 3);\n+\t  /* Vector parameters must be 16-byte aligned.  This places\n+\t     them at 2 mod 4 in terms of words in 32-bit mode, since\n+\t     the parameter save area starts at offset 24 from the\n+\t     stack.  In 64-bit mode, they just have to start on an\n+\t     even word, since the parameter save area is 16-byte\n+\t     aligned.  Space for GPRs is reserved even if the argument\n+\t     will be passed in memory.  */\n+\t  if (TARGET_32BIT)\n+\t    align = ((6 - (cum->words & 3)) & 3);\n+\t  else\n+\t    align = cum->words & 1;\n \t  cum->words += align + RS6000_ARG_SIZE (mode, type);\n-\n+\t  \n \t  if (TARGET_DEBUG_ARG)\n \t    {\n \t      fprintf (stderr, \"function_adv: words = %2d, align=%d, \", \n \t\t       cum->words, align);\n \t      fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s\\n\",\n-\t\t       cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode));\n+\t\t       cum->nargs_prototype, cum->prototype, \n+\t\t       GET_MODE_NAME (mode));\n \t    }\n \t}\n     }\n@@ -4099,40 +4124,43 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       return GEN_INT (cum->call_cookie);\n     }\n \n-  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n+    return gen_rtx_REG (mode, cum->vregno);\n+  else if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     {\n-      if (named && cum->vregno <= ALTIVEC_ARG_MAX_REG)\n-\treturn gen_rtx_REG (mode, cum->vregno);\n-      else if (named || abi == ABI_V4)\n+      if (named || abi == ABI_V4)\n \treturn NULL_RTX;\n       else\n \t{\n \t  /* Vector parameters to varargs functions under AIX or Darwin\n \t     get passed in memory and possibly also in GPRs.  */\n \t  int align, align_words;\n-\t  rtx reg;\n+\t  enum machine_mode part_mode = mode;\n \n \t  /* Vector parameters must be 16-byte aligned.  This places them at\n-\t     2 mod 4 in terms of words.  */\n-\t  align = ((6 - (cum->words & 3)) & 3);\n+\t     2 mod 4 in terms of words in 32-bit mode, since the parameter\n+\t     save area starts at offset 24 from the stack.  In 64-bit mode,\n+\t     they just have to start on an even word, since the parameter\n+\t     save area is 16-byte aligned.  */\n+\t  if (TARGET_32BIT)\n+\t    align = ((6 - (cum->words & 3)) & 3);\n+\t  else\n+\t    align = cum->words & 1;\n \t  align_words = cum->words + align;\n \n \t  /* Out of registers?  Memory, then.  */\n \t  if (align_words >= GP_ARG_NUM_REG)\n \t    return NULL_RTX;\n \t  \n-\t  /* The vector value goes in both memory and GPRs.  Varargs\n-\t     vector regs will always be saved in R5-R8 or R9-R12.  */\n-\t  reg = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n-\n-\t  return gen_rtx_PARALLEL (mode,\n-\t\t\t\t   gen_rtvec (2,\n-\t\t\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t\t\t NULL_RTX, \n-\t\t\t\t\t\t\t\t const0_rtx),\n-\t\t\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t\t\t reg, \n-\t\t\t\t\t\t\t\t const0_rtx)));\n+\t  /* The vector value goes in GPRs.  Only the part of the\n+\t     value in GPRs is reported here.  */\n+\t  if (align_words + CLASS_MAX_NREGS (mode, GENERAL_REGS)\n+\t      > GP_ARG_NUM_REG)\n+\t    /* Fortunately, there are only two possibilites, the value\n+\t       is either wholly in GPRs or half in GPRs and half not.  */\n+\t    part_mode = DImode;\n+\t  \n+\t  return gen_rtx_REG (part_mode, GP_ARG_MIN_REG + align_words);\n \t}\n     }\n   else if (TARGET_SPE_ABI && TARGET_SPE && SPE_VECTOR_MODE (mode))\n@@ -4183,7 +4211,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  && (mode == DFmode || mode == DImode || mode == BLKmode))\n \treturn rs6000_mixed_function_arg (cum, mode, type, align_words);\n \n-      if (USE_FP_FOR_ARG_P (*cum, mode, type))\n+      if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n \t  if (! type\n \t      || ((cum->nargs_prototype > 0)\n@@ -4228,13 +4256,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n int\n function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n-\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n+\t\t\t    tree type, int named)\n {\n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n \n-  if (USE_FP_FOR_ARG_P (*cum, mode, type)\n-      || USE_ALTIVEC_FOR_ARG_P (*cum, mode, type))\n+  if (USE_FP_FOR_ARG_P (cum, mode, type)\n+      || USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n     {\n       if (cum->nargs_prototype >= 0)\n \treturn 0;"}, {"sha": "ce38901ff5b316f6c051b471020e77e6a18d5bac", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -1800,18 +1800,6 @@ typedef struct rs6000_args\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n-/* Nonzero if we can use a floating-point register to pass this arg.  */\n-#define USE_FP_FOR_ARG_P(CUM,MODE,TYPE) \\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT  \\\n-   && (CUM).fregno <= FP_ARG_MAX_REG    \\\n-   && TARGET_HARD_FLOAT && TARGET_FPRS)\n-\n-/* Nonzero if we can use an AltiVec register to pass this arg.  */\n-#define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE)\t\\\n-  (ALTIVEC_VECTOR_MODE (MODE)\t\t\t\\\n-   && (CUM).vregno <= ALTIVEC_ARG_MAX_REG\t\\\n-   && TARGET_ALTIVEC_ABI)\n-\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument."}, {"sha": "8390d019143676470e4593df48065025f3b5be14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -1,3 +1,7 @@\n+2003-11-06  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/altivec-varargs-1.c: New test.\n+\n 2003-11-05  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.c-torture/compile/20031023-4.c: XFAIL on SPARC64"}, {"sha": "b86650074e5094c3d8e7a4de736f338493846ba2", "filename": "gcc/testsuite/gcc.dg/altivec-varargs-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Ftestsuite%2Fgcc.dg%2Faltivec-varargs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2858f73ac1ea6ce3ea2841412bbcca0a4457d939/gcc%2Ftestsuite%2Fgcc.dg%2Faltivec-varargs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Faltivec-varargs-1.c?ref=2858f73ac1ea6ce3ea2841412bbcca0a4457d939", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run { target powerpc*-*-darwin* powerpc*-*-*altivec* } } */\n+/* { dg-options \"-maltivec\" } */\n+/* This test requires altivec, which means it'll fail on Darwin running\n+   on G3. FIXME.  */\n+\n+#include <stdarg.h>\n+\n+#define vector __attribute__((mode(V4SI)))\n+\n+const vector unsigned int v1 = {10,11,12,13};\n+const vector unsigned int v2 = {20,21,22,23};\n+const vector unsigned int v3 = {30,31,32,33};\n+const vector unsigned int v4 = {40,41,42,43};\n+\n+void foo(vector unsigned int a, ...)\n+{\n+  va_list args;\n+  vector unsigned int v;\n+\n+  va_start (args, a);\n+  if (memcmp (&a, &v1, sizeof (v)) != 0)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v2, sizeof (v)) != 0)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v3, sizeof (v)) != 0)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v4, sizeof (v)) != 0)\n+    abort ();\n+  va_end (args);\n+}\n+\n+void bar(vector unsigned int a, ...)\n+{\n+  va_list args;\n+  vector unsigned int v;\n+  int b;\n+\n+  va_start (args, a);\n+  if (memcmp (&a, &v1, sizeof (v)) != 0)\n+    abort ();\n+  b = va_arg (args, int);\n+  if (b != 2)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v2, sizeof (v)) != 0)\n+    abort ();\n+  v = va_arg (args, vector unsigned int);\n+  if (memcmp (&v, &v3, sizeof (v)) != 0)\n+    abort ();\n+  va_end (args);\n+}\n+\n+\n+int main(void)\n+{\n+  /* In this call, in the Darwin ABI, the first argument goes into v2\n+     the second one into r9-r10 and memory,\n+     and the next two in memory.  */\n+  foo ((vector unsigned int){10,11,12,13},\n+       (vector unsigned int){20,21,22,23},\n+       (vector unsigned int){30,31,32,33},\n+       (vector unsigned int){40,41,42,43});\n+  /* In this call, in the Darwin ABI, the first argument goes into v2\n+     the second one into r9, then r10 is reserved and\n+     there are two words of padding in memory, and the next two arguments\n+     go after the padding.  */\n+  bar ((vector unsigned int){10,11,12,13}, 2,\n+       (vector unsigned int){20,21,22,23},\n+       (vector unsigned int){30,31,32,33});\n+  return 0;\n+}"}]}