{"sha": "366e9446961bf5d8efcb0bc5442e2d112dc17160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2ZTk0NDY5NjFiZjVkOGVmY2IwYmM1NDQyZTJkMTEyZGMxNzE2MA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-03-20T23:06:35Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-03-20T23:06:35Z"}, "message": "Revert:\n\n\t2017-03-17  Bernd Schmidt  <bschmidt@redhat.com>\n\n\t* combine.c (record_used_regs): New static function.\n\t(try_combine): Handle situations where there is an additional\n\tinstruction between I2 and I3 which needs to have a LOG_LINK\n\tupdated.\n\n\tRevert:\n\t2017-03-17  Jim Wilson  <jim.wilson@linaro.org>\n\n\t* combine.c (try_combine): Delete redundant i1 test.  Call\n\tprev_nonnote_nondebug_insn instead of prev_nonnote_insn.\n\nFrom-SVN: r246296", "tree": {"sha": "49d734ecfee5e0bf27ae940c7ea06159da038aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49d734ecfee5e0bf27ae940c7ea06159da038aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/366e9446961bf5d8efcb0bc5442e2d112dc17160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366e9446961bf5d8efcb0bc5442e2d112dc17160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366e9446961bf5d8efcb0bc5442e2d112dc17160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366e9446961bf5d8efcb0bc5442e2d112dc17160/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "497e615007a42ff7d0c4d5b9905ee369e72deb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497e615007a42ff7d0c4d5b9905ee369e72deb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497e615007a42ff7d0c4d5b9905ee369e72deb83"}], "stats": {"total": 153, "additions": 16, "deletions": 137}, "files": [{"sha": "55e9bc81e582ea3384287036785798f4660ada7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366e9446961bf5d8efcb0bc5442e2d112dc17160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366e9446961bf5d8efcb0bc5442e2d112dc17160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=366e9446961bf5d8efcb0bc5442e2d112dc17160", "patch": "@@ -1,3 +1,19 @@\n+2017-03-20  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tRevert:\n+\t2017-03-17  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\t* combine.c (record_used_regs): New static function.\n+\t(try_combine): Handle situations where there is an additional\n+\tinstruction between I2 and I3 which needs to have a LOG_LINK\n+\tupdated.\n+\n+\tRevert:\n+\t2017-03-17  Jim Wilson  <jim.wilson@linaro.org>\n+\n+\t* combine.c (try_combine): Delete redundant i1 test.  Call\n+\tprev_nonnote_nondebug_insn instead of prev_nonnote_insn.\n+\n 2017-03-20  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \tPR target/80083"}, {"sha": "66215a607bd9c968f1e5a736fb1fd738cec70989", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366e9446961bf5d8efcb0bc5442e2d112dc17160/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366e9446961bf5d8efcb0bc5442e2d112dc17160/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=366e9446961bf5d8efcb0bc5442e2d112dc17160", "patch": "@@ -2559,57 +2559,6 @@ can_split_parallel_of_n_reg_sets (rtx_insn *insn, int n)\n   return true;\n }\n \n-/* Set up a set of registers used in an insn.  Called through note_uses,\n-   arguments as described for that function.  */\n-\n-static void\n-record_used_regs (rtx *xptr, void *data)\n-{\n-  bitmap set = (bitmap)data;\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-  rtx x = *xptr;\n-\n-  /* repeat is used to turn tail-recursion into iteration since GCC\n-     can't do it when there's no return value.  */\n- repeat:\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  if (REG_P (x))\n-    {\n-      unsigned regno = REGNO (x);\n-      unsigned end_regno = END_REGNO (x);\n-      while (regno < end_regno)\n-\tbitmap_set_bit (set, regno++);\n-      return;\n-    }\n-\n-  /* Recursively scan the operands of this expression.  */\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = XEXP (x, 0);\n-\t      goto repeat;\n-\t    }\n-\n-\t  record_used_regs (&XEXP (x, i), data);\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  record_used_regs (&XVECEXP (x, i, j), data);\n-    }\n-}\n-\n /* Try to combine the insns I0, I1 and I2 into I3.\n    Here I0, I1 and I2 appear earlier than I3.\n    I0 and I1 can be zero; then we combine just I2 into I3, or I1 and I2 into\n@@ -2793,26 +2742,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n   added_links_insn = 0;\n \n-  /* For combinations that may result in two insns, we have to gather\n-     some extra information about registers used, so that we can\n-     update all relevant LOG_LINKS later.  */\n-  auto_bitmap i2_regset, i3_regset, links_regset;\n-  if (i1)\n-    {\n-      note_uses (&PATTERN (i2), record_used_regs, (bitmap)i2_regset);\n-      note_uses (&PATTERN (i3), record_used_regs, (bitmap)i3_regset);\n-      insn_link *ll;\n-      FOR_EACH_LOG_LINK (ll, i3)\n-\tbitmap_set_bit (links_regset, ll->regno);\n-      FOR_EACH_LOG_LINK (ll, i2)\n-\tbitmap_set_bit (links_regset, ll->regno);\n-      FOR_EACH_LOG_LINK (ll, i1)\n-\tbitmap_set_bit (links_regset, ll->regno);\n-      if (i0)\n-\tFOR_EACH_LOG_LINK (ll, i0)\n-\t  bitmap_set_bit (links_regset, ll->regno);\n-    }\n-\n   /* First check for one important special case that the code below will\n      not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL\n      and I3 is a SET whose SET_SRC is a SET_DEST in I2.  In that case,\n@@ -4122,33 +4051,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       return 0;\n     }\n \n-  auto_bitmap new_regs_in_i2;\n-  if (newi2pat)\n-    {\n-      /* We need to discover situations where we introduce a use of a\n-\t register into I2, where none of the existing LOG_LINKS contain\n-\t a reference to it.  This can happen if previously I3 referenced\n-\t the reg, and there is an additional use between I2 and I3.  We\n-\t must remove the LOG_LINKS entry from that additional use and\n-\t distribute it along with our own ones.  */\n-\tnote_uses (&newi2pat, record_used_regs, (bitmap)new_regs_in_i2);\n-\tbitmap_and_compl_into (new_regs_in_i2, i2_regset);\n-\tbitmap_and_compl_into (new_regs_in_i2, links_regset);\n-\n-\t/* Here, we first look for situations where a hard register use\n-\t   moved, and just give up.  This should happen approximately\n-\t   never, and it's not worth it to deal with possibilities like\n-\t   multi-word registers.  Later, when fixing up LOG_LINKS, we\n-\t   deal with the case where a pseudo use moved.  */\n-\tif (!bitmap_empty_p (new_regs_in_i2)\n-\t    && prev_nonnote_nondebug_insn (i3) != i2\n-\t    && bitmap_first_set_bit (new_regs_in_i2) < FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    undo_all ();\n-\t    return 0;\n-\t  }\n-    }\n-\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       struct undo *undo;\n@@ -4591,45 +4493,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n-    if (newi2pat)\n-      {\n-\tbitmap_iterator iter;\n-\tunsigned int i;\n-\n-\t/* See comments above where we calculate the bitmap.  */\n-\tEXECUTE_IF_SET_IN_BITMAP ((bitmap)new_regs_in_i2,\n-\t\t\t\t  LAST_VIRTUAL_REGISTER, i, iter)\n-\t  {\n-\t    rtx reg = regno_reg_rtx[i];\n-\t    rtx_insn *other;\n-\t    for (other = NEXT_INSN (i2); other != i3; other = NEXT_INSN (other))\n-\t      if (NONDEBUG_INSN_P (other)\n-\t\t  && (reg_overlap_mentioned_p (reg, PATTERN (other))\n-\t\t      || (CALL_P (other) && find_reg_fusage (other, USE, reg))))\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"found extra use of reg %d at insn %d\\n\", i,\n-\t\t\t     INSN_UID (other));\n-\t\t  insn_link **plink;\n-\t\t  for (plink = &LOG_LINKS (other);\n-\t\t       *plink;\n-\t\t       plink = &(*plink)->next)\n-\t\t    {\n-\t\t      insn_link *link = *plink;\n-\t\t      if (link->regno == i)\n-\t\t\t{\n-\t\t\t  *plink = link->next;\n-\t\t\t  link->next = i3links;\n-\t\t\t  i3links = link;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t  }\n-      }\n-\n     distribute_links (i3links);\n     distribute_links (i2links);\n     distribute_links (i1links);"}]}