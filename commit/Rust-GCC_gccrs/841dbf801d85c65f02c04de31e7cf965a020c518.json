{"sha": "841dbf801d85c65f02c04de31e7cf965a020c518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxZGJmODAxZDg1YzY1ZjAyYzA0ZGUzMWU3Y2Y5NjVhMDIwYzUxOA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-24T13:04:53Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-24T13:04:53Z"}, "message": "re PR target/49263 (SH Target: underutilized \"TST #imm, R0\" instruction)\n\ngcc/\n\tPR target/49263\n\tPR target/53987\n\tPR target/64345\n\tPR target/59533\n\tPR target/52933\n\tPR target/54236\n\tPR target/51244\n\t* config/sh/sh-protos.h\n\t(sh_extending_set_of_reg::can_use_as_unextended_reg,\n\tsh_extending_set_of_reg::use_as_unextended_reg,\n\tsh_is_nott_insn, sh_movt_set_dest, sh_movrt_set_dest, sh_is_movt_insn,\n\tsh_is_movrt_insn, sh_insn_operands_modified_between_p,\n\tsh_reg_dead_or_unused_after_insn, sh_in_recog_treg_set_expr,\n\tsh_recog_treg_set_expr, sh_split_treg_set_expr): New functions.\n\t(sh_treg_insns): New class.\n\t* config/sh/sh.c (TARGET_LEGITIMATE_COMBINED_INSN): Define target hook.\n\t(scope_counter): New class.\n\t(sh_legitimate_combined_insn, sh_is_nott_insn, sh_movt_set_dest,\n\tsh_movrt_set_dest, sh_reg_dead_or_unused_after_insn,\n\tsh_extending_set_of_reg::can_use_as_unextended_reg,\n\tsh_extending_set_of_reg::use_as_unextended_reg, sh_recog_treg_set_expr,\n\tsh_in_recog_treg_set_expr, sh_try_split_insn_simple,\n\tsh_split_treg_set_expr): New functions.\n\t(addsubcosts): Handle treg_set_expr.\n\t(sh_rtx_costs): Handle IF_THEN_ELSE and ZERO_EXTRACT.\n\t(sh_rtx_costs): Use arith_reg_operand in SIGN_EXTEND and ZERO_EXTEND.\n\t(sh_rtx_costs): Handle additional bit test patterns in EQ and AND cases.\n\t(sh_insn_operands_modified_between_p): Make non-static.\n\t* config/sh/predicates.md (zero_extend_movu_operand): Allow\n\tsimple_mem_operand in addition to displacement_mem_operand.\n\t(zero_extend_operand): Don't allow zero_extend_movu_operand.\n\t(treg_set_expr, treg_set_expr_not_const01,\n\tarith_reg_or_treg_set_expr): New predicates.\n\t* config/sh/sh.md (tstsi_t): Use arith_reg_operand and\n\tarith_or_int_operand instead of logical_operand.  Convert to\n\tinsn_and_split.  Try to optimize constant operand in splitter.\n\t(tsthi_t, tstqi_t): Fold into *tst<mode>_t.  Convert to insn_and_split.\n\t(*tstqi_t_zero): Delete.\n\t(*tst<mode>_t_subregs): Add !sh_in_recog_treg_set_expr split condition.\n\t(tstsi_t_and_not): Delete.\n\t(tst<mode>_t_zero_extract_eq): Rename to *tst<mode>_t_zero_extract.\n\tConvert to insn_and_split.\n\t(unnamed split, tstsi_t_zero_extract_xor,\n\ttstsi_t_zero_extract_subreg_xor_little,\n\ttstsi_t_zero_extract_subreg_xor_big): Delete.\n\t(*tstsi_t_shift_mask): New insn_and_split.\n\t(cmpeqsi_t, cmpgesi_t): Add new split for const_int 0 operands and try\n\tto recombine with surrounding insns when splitting.\n\t(*negtstsi): Add !sh_in_recog_treg_set_expr condition.\n\t(cmp_div0s_0, cmp_div0s_1, *cmp_div0s_0, *cmp_div0s_1): Rewrite as ...\n\t(cmp_div0s, *cmp_div0s_1, *cmp_div0s_2, *cmp_div0s_3, *cmp_div0s_4,\n\t*cmp_div0s_5, *cmp_div0s_6): ... these new insn_and_split patterns.\n\t(*cbranch_div0s: Delete.\n\t(*addc): Convert to insn_and_split.  Use treg_set_expr as 3rd operand.\n\tTry to recombine with surrounding insns when splitting.  Add operand\n\torder variants.\n\t(*addc_t_r, *addc_r_t): Use treg_set_expr_not_const01.\n\t(*addc_r_r_1, *addc_r_lsb, *addc_r_r_lsb, *addc_r_lsb_r, *addc_r_msb,\n\t*addc_r_r_msb, *addc_2r_msb): Delete.\n\t(*addc_2r_lsb): Rename to *addc_2r_t.  Use treg_set_expr.  Add operand\n\torder variant.\n\t(*addc_negreg_t): New insn_and_split.\n\t(*subc): Convert to insn_and_split.  Use treg_set_expr as 3rd operand.\n\tTry to recombine with surrounding insns when splitting.\n\tAdd operand order variants.  \n\t(*subc_negt_reg, *subc_negreg_t, *reg_lsb_t, *reg_msb_t): New\n\tinsn_and_split patterns.\n\t(*rotcr): Use arith_reg_or_treg_set_expr.  Try to recombine with\n\tsurrounding insns when splitting.\n\t(unnamed rotcr split): Use arith_reg_or_treg_set_expr.\n\t(*rotcl): Likewise.  Add zero_extract variant.\n\t(*ashrsi2_31): New insn_and_split.\n\t(*negc): Convert to insn_and_split.  Use treg_set_expr.\n\t(*zero_extend<mode>si2_disp_mem): Update comment.\n\t(movrt_negc, *movrt_negc, nott): Add !sh_in_recog_treg_set_expr split\n\tcondition.\n\t(*mov_t_msb_neg, mov_neg_si_t): Use treg_set_expr.  Try to recombine\n\twith surrounding insns when splitting.\n\t(any_treg_expr_to_reg): New insn_and_split.\n\t(*neg_zero_extract_0, *neg_zero_extract_1, *neg_zero_extract_2,\n\t*neg_zero_extract_3, *neg_zero_extract_4, *neg_zero_extract_5,\n\t*neg_zero_extract_6, *zero_extract_0, *zero_extract_1,\n\t*zero_extract_2): New single bit zero extract patterns.\n\t(bld_reg, *bld_regqi): Fold into bld<mode>_reg.\n\t(*get_thread_pointersi, store_gbr, *mov<mode>_gbr_load,\n\t*mov<mode>_gbr_load, *mov<mode>_gbr_load, *mov<mode>_gbr_load,\n\t*movdi_gbr_load): Use arith_reg_dest instead of register_operand for\n\tset destination.\n\t(set_thread_pointersi, load_gbr): Use arith_reg_operand instead of\n\tregister_operand for set source.\n\ngcc/testsuite/\n\tPR target/49263\n\tPR target/53987\n\tPR target/64345\n\tPR target/59533\n\tPR target/52933\n\tPR target/54236\n\tPR target/51244\n\t* gcc.target/sh/pr64345-1.c: New.\n\t* gcc.target/sh/pr64345-2.c: New.\n\t* gcc.target/sh/pr59533-1.c: New.\n\t* gcc.target/sh/pr49263.c: Adjust matching of expected insns.\n\t* gcc.target/sh/pr52933-2.c: Likewise.\n\t* gcc.target/sh/pr54089-1.c: Likewise.\n\t* gcc.target/sh/pr54236-1.c: Likewise.\n\t* gcc.target/sh/pr51244-20-sh2a.c: Likewise.\n\t* gcc.target/sh/pr49263-1.c: Remove xfails.\n\t* gcc.target/sh/pr49263-2.c: Likewise.\n\t* gcc.target/sh/pr49263-3.c: Likewise.\n\t* gcc.target/sh/pr53987-1.c: Likewise.\n\t* gcc.target/sh/pr52933-1.c: Adjust matching of expected insns.\n\t(test_24, test_25, test_26, test_27, test_28, test_29, test_30): New.\n\t* gcc.target/sh/pr51244-12.c: Adjust matching of expected insns.\n\t(test05, test06, test07, test08, test09, test10, test11, test12): New.\n\t* gcc.target/sh/pr54236-3.c: Adjust matching of expected insns.\n\t(test_002, test_003, test_004, test_005, test_006, test_007, test_008,\n\ttest_009): New.\n\t* gcc.target/sh/pr51244-4.c: Adjust matching of expected insns.\n\t(test_02): New.\n\nFrom-SVN: r220081", "tree": {"sha": "db69dc3cf457df982a926d511d89a52be95ee9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db69dc3cf457df982a926d511d89a52be95ee9fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/841dbf801d85c65f02c04de31e7cf965a020c518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/841dbf801d85c65f02c04de31e7cf965a020c518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/841dbf801d85c65f02c04de31e7cf965a020c518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/841dbf801d85c65f02c04de31e7cf965a020c518/comments", "author": null, "committer": null, "parents": [{"sha": "19bd4ebce2c48709989f7b56d1be5360e86c33af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19bd4ebce2c48709989f7b56d1be5360e86c33af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19bd4ebce2c48709989f7b56d1be5360e86c33af"}], "stats": {"total": 2940, "additions": 2407, "deletions": 533}, "files": [{"sha": "c6f121305f7b6e10463e1cfb3c0d6cae8cfdbc1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -1,3 +1,96 @@\n+2015-01-24  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/49263\n+\tPR target/53987\n+\tPR target/64345\n+\tPR target/59533\n+\tPR target/52933\n+\tPR target/54236\n+\tPR target/51244\n+\t* config/sh/sh-protos.h\n+\t(sh_extending_set_of_reg::can_use_as_unextended_reg,\n+\tsh_extending_set_of_reg::use_as_unextended_reg,\n+\tsh_is_nott_insn, sh_movt_set_dest, sh_movrt_set_dest, sh_is_movt_insn,\n+\tsh_is_movrt_insn, sh_insn_operands_modified_between_p,\n+\tsh_reg_dead_or_unused_after_insn, sh_in_recog_treg_set_expr,\n+\tsh_recog_treg_set_expr, sh_split_treg_set_expr): New functions.\n+\t(sh_treg_insns): New class.\n+\t* config/sh/sh.c (TARGET_LEGITIMATE_COMBINED_INSN): Define target hook.\n+\t(scope_counter): New class.\n+\t(sh_legitimate_combined_insn, sh_is_nott_insn, sh_movt_set_dest,\n+\tsh_movrt_set_dest, sh_reg_dead_or_unused_after_insn,\n+\tsh_extending_set_of_reg::can_use_as_unextended_reg,\n+\tsh_extending_set_of_reg::use_as_unextended_reg, sh_recog_treg_set_expr,\n+\tsh_in_recog_treg_set_expr, sh_try_split_insn_simple,\n+\tsh_split_treg_set_expr): New functions.\n+\t(addsubcosts): Handle treg_set_expr.\n+\t(sh_rtx_costs): Handle IF_THEN_ELSE and ZERO_EXTRACT.\n+\t(sh_rtx_costs): Use arith_reg_operand in SIGN_EXTEND and ZERO_EXTEND.\n+\t(sh_rtx_costs): Handle additional bit test patterns in EQ and AND cases.\n+\t(sh_insn_operands_modified_between_p): Make non-static.\n+\t* config/sh/predicates.md (zero_extend_movu_operand): Allow\n+\tsimple_mem_operand in addition to displacement_mem_operand.\n+\t(zero_extend_operand): Don't allow zero_extend_movu_operand.\n+\t(treg_set_expr, treg_set_expr_not_const01,\n+\tarith_reg_or_treg_set_expr): New predicates.\n+\t* config/sh/sh.md (tstsi_t): Use arith_reg_operand and\n+\tarith_or_int_operand instead of logical_operand.  Convert to\n+\tinsn_and_split.  Try to optimize constant operand in splitter.\n+\t(tsthi_t, tstqi_t): Fold into *tst<mode>_t.  Convert to insn_and_split.\n+\t(*tstqi_t_zero): Delete.\n+\t(*tst<mode>_t_subregs): Add !sh_in_recog_treg_set_expr split condition.\n+\t(tstsi_t_and_not): Delete.\n+\t(tst<mode>_t_zero_extract_eq): Rename to *tst<mode>_t_zero_extract.\n+\tConvert to insn_and_split.\n+\t(unnamed split, tstsi_t_zero_extract_xor,\n+\ttstsi_t_zero_extract_subreg_xor_little,\n+\ttstsi_t_zero_extract_subreg_xor_big): Delete.\n+\t(*tstsi_t_shift_mask): New insn_and_split.\n+\t(cmpeqsi_t, cmpgesi_t): Add new split for const_int 0 operands and try\n+\tto recombine with surrounding insns when splitting.\n+\t(*negtstsi): Add !sh_in_recog_treg_set_expr condition.\n+\t(cmp_div0s_0, cmp_div0s_1, *cmp_div0s_0, *cmp_div0s_1): Rewrite as ...\n+\t(cmp_div0s, *cmp_div0s_1, *cmp_div0s_2, *cmp_div0s_3, *cmp_div0s_4,\n+\t*cmp_div0s_5, *cmp_div0s_6): ... these new insn_and_split patterns.\n+\t(*cbranch_div0s: Delete.\n+\t(*addc): Convert to insn_and_split.  Use treg_set_expr as 3rd operand.\n+\tTry to recombine with surrounding insns when splitting.  Add operand\n+\torder variants.\n+\t(*addc_t_r, *addc_r_t): Use treg_set_expr_not_const01.\n+\t(*addc_r_r_1, *addc_r_lsb, *addc_r_r_lsb, *addc_r_lsb_r, *addc_r_msb,\n+\t*addc_r_r_msb, *addc_2r_msb): Delete.\n+\t(*addc_2r_lsb): Rename to *addc_2r_t.  Use treg_set_expr.  Add operand\n+\torder variant.\n+\t(*addc_negreg_t): New insn_and_split.\n+\t(*subc): Convert to insn_and_split.  Use treg_set_expr as 3rd operand.\n+\tTry to recombine with surrounding insns when splitting.\n+\tAdd operand order variants.  \n+\t(*subc_negt_reg, *subc_negreg_t, *reg_lsb_t, *reg_msb_t): New\n+\tinsn_and_split patterns.\n+\t(*rotcr): Use arith_reg_or_treg_set_expr.  Try to recombine with\n+\tsurrounding insns when splitting.\n+\t(unnamed rotcr split): Use arith_reg_or_treg_set_expr.\n+\t(*rotcl): Likewise.  Add zero_extract variant.\n+\t(*ashrsi2_31): New insn_and_split.\n+\t(*negc): Convert to insn_and_split.  Use treg_set_expr.\n+\t(*zero_extend<mode>si2_disp_mem): Update comment.\n+\t(movrt_negc, *movrt_negc, nott): Add !sh_in_recog_treg_set_expr split\n+\tcondition.\n+\t(*mov_t_msb_neg, mov_neg_si_t): Use treg_set_expr.  Try to recombine\n+\twith surrounding insns when splitting.\n+\t(any_treg_expr_to_reg): New insn_and_split.\n+\t(*neg_zero_extract_0, *neg_zero_extract_1, *neg_zero_extract_2,\n+\t*neg_zero_extract_3, *neg_zero_extract_4, *neg_zero_extract_5,\n+\t*neg_zero_extract_6, *zero_extract_0, *zero_extract_1,\n+\t*zero_extract_2): New single bit zero extract patterns.\n+\t(bld_reg, *bld_regqi): Fold into bld<mode>_reg.\n+\t(*get_thread_pointersi, store_gbr, *mov<mode>_gbr_load,\n+\t*mov<mode>_gbr_load, *mov<mode>_gbr_load, *mov<mode>_gbr_load,\n+\t*movdi_gbr_load): Use arith_reg_dest instead of register_operand for\n+\tset destination.\n+\t(set_thread_pointersi, load_gbr): Use arith_reg_operand instead of\n+\tregister_operand for set source.\n+\n 2015-01-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* i386.opt (prefetch_sse): New targetsave."}, {"sha": "a18515a3a15a7444ead05b342ddaee72146389b9", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -456,17 +456,17 @@\n \n ;; Returns 1 if the operand can be used in an SH2A movu.{b|w} insn.\n (define_predicate \"zero_extend_movu_operand\"\n-  (and (match_operand 0 \"displacement_mem_operand\")\n-       (match_test \"GET_MODE (op) == QImode || GET_MODE (op) == HImode\")))\n+  (and (ior (match_operand 0 \"displacement_mem_operand\")\n+\t    (match_operand 0 \"simple_mem_operand\"))\n+       (ior (match_test \"GET_MODE (op) == QImode\")\n+\t    (match_test \"GET_MODE (op) == HImode\"))))\n \n ;; Returns 1 if the operand can be used in a zero_extend.\n (define_predicate \"zero_extend_operand\"\n   (ior (and (match_test \"TARGET_SHMEDIA\")\n \t    (match_operand 0 \"general_extend_operand\"))\n        (and (match_test \"! TARGET_SHMEDIA\")\n-\t    (match_operand 0 \"arith_reg_operand\"))\n-       (and (match_test \"TARGET_SH2A\")\n-\t    (match_operand 0 \"zero_extend_movu_operand\"))))\n+\t    (match_operand 0 \"arith_reg_operand\"))))\n \n ;; Returns 1 if OP can be source of a simple move operation. Same as\n ;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as\n@@ -1152,6 +1152,18 @@\n \t    (match_test \"mode != HImode\")\n \t    (match_test \"TARGET_SH4A\"))))\n \n+;; A predicate that matches any expression for which there is an\n+;; insn pattern that sets the T bit.\n+(define_predicate \"treg_set_expr\"\n+  (match_test \"sh_recog_treg_set_expr (op, mode)\"))\n+\n+;; Same as treg_set_expr but disallow constants 0 and 1 which can be loaded\n+;; into the T bit.\n+(define_predicate \"treg_set_expr_not_const01\"\n+  (and (match_test \"op != const0_rtx\")\n+       (match_test \"op != const1_rtx\")\n+       (match_operand 0 \"treg_set_expr\")))\n+\n ;; A predicate describing the T bit register in any form.\n (define_predicate \"t_reg_operand\"\n   (match_code \"reg,subreg,sign_extend,zero_extend\")\n@@ -1206,6 +1218,10 @@\n   (ior (match_operand 0 \"arith_reg_operand\")\n        (match_operand 0 \"t_reg_operand\")))\n \n+(define_predicate \"arith_reg_or_treg_set_expr\"\n+  (ior (match_operand 0 \"arith_reg_operand\")\n+       (match_operand 0 \"treg_set_expr\")))\n+\n ;; A predicate describing the negated value of the T bit register shifted\n ;; left by 31.\n (define_predicate \"negt_reg_shl31_operand\""}, {"sha": "945a54f4f1b951d3be730a29d17d9b7cca7f7008", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -264,6 +264,14 @@ struct sh_extending_set_of_reg : public set_of_reg\n     ext_code = UNKNOWN;\n   }\n \n+  /* Returns true if it's possible to use the source reg of the sign\n+     or zero extending set directly, bypassing the extension.  */\n+  bool can_use_as_unextended_reg (void) const;\n+\n+  /* Returns the reg rtx of the sign or zero extending set source, that can\n+     be safely used at the specified insn in SImode.  */\n+  rtx use_as_unextended_reg (rtx_insn* use_at_insn) const;\n+\n   /* Returns the reg rtx of the sign or zero extending result, that can be\n      safely used at the specified insn in SImode.  If the set source is an\n      implicitly sign extending mem load, the mem load is converted into an\n@@ -281,7 +289,66 @@ extern bool sh_split_movrt_negc_to_movt_xor (rtx_insn* curr_insn,\n extern void sh_split_tst_subregs (rtx_insn* curr_insn,\n \t\t\t\t  machine_mode subreg_mode, int subreg_offset,\n \t\t\t\t  rtx operands[]);\n+\n+extern bool sh_is_nott_insn (const rtx_insn* i);\n+extern rtx sh_movt_set_dest (const rtx_insn* i);\n+extern rtx sh_movrt_set_dest (const rtx_insn* i);\n+\n+inline bool sh_is_movt_insn (const rtx_insn* i)\n+{\n+  return sh_movt_set_dest (i) != NULL;\n+}\n+\n+inline bool sh_is_movrt_insn (const rtx_insn* i)\n+{\n+  return sh_movrt_set_dest (i) != NULL;\n+}\n+\n+extern bool sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n+\t\t\t\t\t\t const rtx_insn* from,\n+\t\t\t\t\t\t const rtx_insn* to);\n+\n+extern bool sh_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno);\n extern void sh_remove_reg_dead_or_unused_notes (rtx_insn* i, int regno);\n+\n+extern bool sh_in_recog_treg_set_expr (void);\n+extern bool sh_recog_treg_set_expr (rtx op, machine_mode mode);\n+\n+/* Result value of sh_split_treg_set_expr.  Contains the first insn emitted\n+   and the optional trailing nott insn.  */\n+class sh_treg_insns\n+{\n+public:\n+  sh_treg_insns (void) : m_first_insn (NULL), m_trailing_nott_insn (NULL) { }\n+  sh_treg_insns (rtx_insn* first_insn, rtx_insn* nott_insn)\n+  : m_first_insn (first_insn),\n+    m_trailing_nott_insn (nott_insn)\n+  { }\n+\n+  bool was_treg_operand (void) const { return m_first_insn == NULL; }\n+  bool has_trailing_nott (void) const { return m_trailing_nott_insn != NULL; }\n+  rtx_insn* trailing_nott (void) const { return m_trailing_nott_insn; }\n+  rtx_insn* first_insn (void) const { return m_first_insn; }\n+\n+  /* If there is a trailing nott, remove it from the emitted insns and\n+     return true.  Return false otherwise.  */\n+  bool\n+  remove_trailing_nott (void)\n+  {\n+    if (!has_trailing_nott ())\n+      return false;\n+\n+    remove_insn (trailing_nott ());\n+    return true;\n+  }\n+\n+private:\n+  rtx_insn* m_first_insn;\n+  rtx_insn* m_trailing_nott_insn;\n+};\n+\n+extern sh_treg_insns sh_split_treg_set_expr (rtx x, rtx_insn* curr_insn);\n+\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "7d07634abe3518e1a0e3f01489fb3f8147d73d76", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 438, "deletions": 5, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -364,6 +364,8 @@ static bool sequence_insn_p (rtx_insn *);\n static void sh_canonicalize_comparison (int *, rtx *, rtx *, bool);\n static void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n \t\t\t\t\tmachine_mode, bool);\n+static bool sh_legitimate_combined_insn (rtx_insn* insn);\n+\n static bool sh_fixed_condition_code_regs (unsigned int* p1, unsigned int* p2);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n@@ -672,6 +674,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_CANONICALIZE_COMPARISON\n #define TARGET_CANONICALIZE_COMPARISON\tsh_canonicalize_comparison\n \n+#undef TARGET_LEGITIMATE_COMBINED_INSN\n+#define TARGET_LEGITIMATE_COMBINED_INSN sh_legitimate_combined_insn\n+\n #undef TARGET_FIXED_CONDITION_CODE_REGS\n #define TARGET_FIXED_CONDITION_CODE_REGS sh_fixed_condition_code_regs\n \n@@ -2044,6 +2049,26 @@ sh_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n   *code = (int)tmp_code;\n }\n \n+/* This function implements the legitimate_combined_insn target hook,\n+   which the combine pass uses to early reject combined insns, before\n+   it tries to recog the insn and determine its cost.  */\n+static bool\n+sh_legitimate_combined_insn (rtx_insn* insn)\n+{\n+  /* Reject combinations of memory loads and zero extensions, as these\n+     interfere with other combine patterns such as zero extracts and bit\n+     tests.  The SH2A movu.{b|w} insns are formed later in the\n+     'sh_optimize_extu_exts' pass after combine/split1.  */\n+  rtx p = PATTERN (insn);\n+  if (GET_CODE (p) == SET\n+      && REG_P (XEXP (p, 0)) && GET_MODE (XEXP (p, 0)) == SImode\n+      && GET_CODE (XEXP (p, 1)) == ZERO_EXTEND\n+      && MEM_P (XEXP (XEXP (p, 1), 0)))\n+      return false;\n+\n+  return true;\n+}\n+\n bool\n sh_fixed_condition_code_regs (unsigned int* p1, unsigned int* p2)\n {\n@@ -3330,6 +3355,12 @@ addsubcosts (rtx x)\n \t      && CONST_INT_P (XEXP (op1, 1)) && INTVAL (XEXP (op1, 1)) == 31)\n \t    return 1;\n \t}\n+      /* Let's assume that adding the result of an insns that stores into\n+\t the T bit is cheap.  */\n+      if (treg_set_expr (op1, SImode))\n+\treturn 1;\n+      if (treg_set_expr (op0, SImode))\n+\treturn 1;\n     }\n \n   /* On SH1-4 we have only max. SImode operations.\n@@ -3445,10 +3476,36 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t\t\t\ttrue);\n       return true;\n \n+    case IF_THEN_ELSE:\n+      /* This case is required for the if_then_else negc pattern.  */\n+      if (treg_set_expr (XEXP (x, 0), SImode))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n+\n+    /* Zero extracts of single bits are usually combine patterns for the\n+       tst insns.  */\n+    case ZERO_EXTRACT:\n+      if (GET_CODE (XEXP (x, 0)) == XOR\n+\t  && arith_reg_operand (XEXP (XEXP (x, 0), 0), VOIDmode)\n+\t  && XEXP (x, 1) == const1_rtx\n+\t  && CONST_INT_P (XEXP (x, 2))\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+\t  /* Check that the xor constaint overlaps with the extracted bit.  */\n+\t  && (INTVAL (XEXP (XEXP (x, 0), 1)) & (1LL << INTVAL (XEXP (x, 2)))))\n+\t{\n+\t  *total = 1; //COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      return false;\n+\n     /* The cost of a sign or zero extend depends on whether the source is a\n        reg or a mem.  In case of a mem take the address into acount.  */\n     case SIGN_EXTEND:\n-      if (REG_P (XEXP (x, 0)))\n+      if (arith_reg_operand (XEXP (x, 0), GET_MODE (XEXP (x, 0))))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return true;\n@@ -3463,7 +3520,7 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return false;\n \n     case ZERO_EXTEND:\n-      if (REG_P (XEXP (x, 0)))\n+      if (arith_reg_operand (XEXP (x, 0), GET_MODE (XEXP (x, 0))))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return true;\n@@ -3555,8 +3612,21 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t most likely going to be a TST #imm, R0 instruction.\n \t Notice that this does not catch the zero_extract variants from\n \t the md file.  */\n-      if (GET_CODE (XEXP (x, 0)) == AND\n-\t  && CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == 0)\n+      if (XEXP (x, 1) == const0_rtx\n+          && (GET_CODE (XEXP (x, 0)) == AND\n+              || (SUBREG_P (XEXP (x, 0))\n+\t\t  && GET_CODE (SUBREG_REG (XEXP (x, 0))) == AND)))\n+\t{\n+\t  *total = 1;\n+\t  return true;\n+\t}\n+\n+      else if (XEXP (x, 1) == const0_rtx\n+\t       && GET_CODE (XEXP (x, 0)) == AND\n+\t       && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+\t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == ASHIFT\n+\t       && arith_reg_operand (XEXP (XEXP (XEXP (x, 0), 0), 0), SImode)\n+\t       && CONST_INT_P (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n \t{\n \t  *total = 1;\n \t  return true;\n@@ -3622,6 +3692,14 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       return true;\n \n     case AND:\n+      /* Check for (and (not (reg)) (const_int 1)) which is a tst insn.  */\n+      if (GET_CODE (XEXP (x, 0)) == NOT && XEXP (x, 1) == const1_rtx)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      /* Fall through.  */\n+\n     case XOR:\n     case IOR:\n       *total = COSTS_N_INSNS (and_xor_ior_costs (x, code));\n@@ -13751,7 +13829,7 @@ sh_unspec_insn_p (rtx x)\n \n /* Return true if the register operands of the specified insn are modified\n    between the specified from and to insns (exclusive of those two).  */\n-static bool\n+bool\n sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n \t\t\t\t     const rtx_insn* from,\n \t\t\t\t     const rtx_insn* to)\n@@ -13770,6 +13848,57 @@ sh_insn_operands_modified_between_p (rtx_insn* operands_insn,\n   return false;\n }\n \n+/* Given an insn, determine whether it's a 'nott' insn, i.e. an insn that\n+   negates the T bit and stores the result in the T bit.  */\n+bool\n+sh_is_nott_insn (const rtx_insn* i)\n+{\n+  return i != NULL && GET_CODE (PATTERN (i)) == SET\n+\t && t_reg_operand (XEXP (PATTERN (i), 0), VOIDmode)\n+\t && negt_reg_operand (XEXP (PATTERN (i), 1), VOIDmode);\n+}\n+\n+rtx\n+sh_movt_set_dest (const rtx_insn* i)\n+{\n+  if (i == NULL)\n+    return NULL;\n+\n+  const_rtx p = PATTERN (i);\n+  return GET_CODE (p) == SET\n+\t && arith_reg_dest (XEXP (p, 0), SImode)\n+\t && t_reg_operand (XEXP (p, 1), VOIDmode) ? XEXP (p, 0) : NULL;\n+}\n+\n+/* Given an insn, check whether it's a 'movrt' kind of insn, i.e. an insn\n+   that stores the negated T bit in a register, and return the destination\n+   register rtx, or null.  */\n+rtx\n+sh_movrt_set_dest (const rtx_insn* i)\n+{\n+  if (i == NULL)\n+    return NULL;\n+\n+  const_rtx p = PATTERN (i);\n+\n+  /* The negc movrt replacement is inside a parallel.  */\n+  if (GET_CODE (p) == PARALLEL)\n+    p = XVECEXP (p, 0, 0);\n+\n+  return GET_CODE (p) == SET\n+\t && arith_reg_dest (XEXP (p, 0), SImode)\n+\t && negt_reg_operand (XEXP (p, 1), VOIDmode) ? XEXP (p, 0) : NULL;\n+}\n+\n+/* Given an insn and a reg number, tell whether the reg dies or is unused\n+   after the insn.  */\n+bool\n+sh_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno)\n+{\n+  return find_regno_note (i, REG_DEAD, regno) != NULL\n+\t || find_regno_note (i, REG_UNUSED, regno) != NULL;\n+}\n+\n /* Given an insn and a reg number, remove reg dead or reg unused notes to\n    mark it as being used after the insn.  */\n void\n@@ -14006,6 +14135,40 @@ sh_extending_set_of_reg::use_as_extended_reg (rtx_insn* use_at_insn) const\n     }\n }\n \n+bool\n+sh_extending_set_of_reg::can_use_as_unextended_reg (void) const\n+{\n+  if ((ext_code == SIGN_EXTEND || ext_code == ZERO_EXTEND)\n+      && (from_mode == QImode || from_mode == HImode)\n+      && set_src != NULL)\n+    return arith_reg_operand (XEXP (set_src, 0), from_mode);\n+  else\n+    return false;\n+}\n+\n+rtx\n+sh_extending_set_of_reg::use_as_unextended_reg (rtx_insn* use_at_insn) const\n+{\n+  gcc_assert (can_use_as_unextended_reg ());\n+\n+  rtx r = XEXP (set_src, 0);\n+  rtx r0 = simplify_gen_subreg (SImode, r, from_mode, 0);\n+\n+  if (modified_between_p (r, insn, use_at_insn))\n+    {\n+      rtx r1 = gen_reg_rtx (SImode);\n+      emit_insn_after (gen_move_insn (r1, r0), insn);\n+      return r1;\n+    }\n+  else\n+    {\n+      sh_remove_reg_dead_or_unused_notes (insn, SUBREG_P (r)\n+\t\t\t\t\t\t? REGNO (SUBREG_REG (r))\n+\t\t\t\t\t\t: REGNO (r));\n+      return r0;\n+    }\n+}\n+\n /* Given the current insn, which is assumed to be the *tst<mode>_t_subregs insn,\n    perform the necessary checks on the operands and split it accordingly.  */\n void\n@@ -14059,6 +14222,276 @@ sh_split_tst_subregs (rtx_insn* curr_insn, machine_mode subreg_mode,\n   emit_insn (gen_tstsi_t (tmp0, operands[1]));\n }\n \n+/* A helper class to increment/decrement a counter variable each time a\n+   function is entered/left.  */\n+class scope_counter\n+{\n+public:\n+  scope_counter (int& counter) : m_counter (counter) { ++m_counter; }\n+\n+  ~scope_counter (void)\n+  {\n+    --m_counter;\n+    gcc_assert (m_counter >= 0);\n+  }\n+\n+  int count (void) const { return m_counter; }\n+\n+private:\n+  int& m_counter;\n+};\n+\n+/* Given an rtx x, determine whether the expression can be used to create\n+   an insn that calulates x and stores the result in the T bit.\n+   This is used by the 'treg_set_expr' predicate to construct insns sequences\n+   where T bit results are fed into other insns, such as addc, subc, negc\n+   insns.\n+\n+   FIXME: The patterns that expand 'treg_set_expr' operands tend to\n+   distinguish between 'positive' and 'negative' forms.  For now this has to\n+   be done in the preparation code.  We could also introduce\n+   'pos_treg_set_expr' and 'neg_treg_set_expr' predicates for that and write\n+   two different patterns for the 'postive' and 'negative' forms.  However,\n+   the total amount of lines of code seems to be about the same and the\n+   '{pos|neg}_treg_set_expr' predicates would be more expensive, because the\n+   recog function would need to look inside the expression by temporarily\n+   splitting it.  */\n+static int sh_recog_treg_set_expr_reent_count = 0;\n+\n+bool\n+sh_recog_treg_set_expr (rtx op, machine_mode mode)\n+{\n+  scope_counter recursion (sh_recog_treg_set_expr_reent_count);\n+\n+  /* Limit the recursion count to avoid nested expressions which we can't\n+     resolve to a single treg set insn.  */\n+  if (recursion.count () > 1)\n+    return false;\n+\n+  /* Early accept known possible operands before doing recog.  */\n+  if (op == const0_rtx || op == const1_rtx || t_reg_operand (op, mode))\n+    return true;\n+\n+  /* Early reject impossible operands before doing recog.\n+     There are some (set ((t) (subreg ...))) patterns, but we must be careful\n+     not to allow any invalid reg-reg or mem-reg moves, or else other passes\n+     such as lower-subreg will bail out.  Some insns such as SH4A movua are\n+     done with UNSPEC, so must reject those, too, or else it would result\n+     in an invalid reg -> treg move.  */\n+  if (register_operand (op, mode) || memory_operand (op, mode)\n+      || sh_unspec_insn_p (op))\n+    return false;\n+\n+  if (!can_create_pseudo_p ())\n+    return false;\n+\n+  /* We are going to invoke recog in a re-entrant way and thus\n+     have to capture its current state and restore it afterwards.  */\n+  recog_data_d prev_recog_data = recog_data;\n+\n+  rtx_insn* i = make_insn_raw (gen_rtx_SET (VOIDmode, get_t_reg_rtx (), op));\n+  SET_PREV_INSN (i) = NULL;\n+  SET_NEXT_INSN (i) = NULL;\n+\n+  int result = recog (PATTERN (i), i, 0);\n+\n+  /* It seems there is no insn like that.  Create a simple negated\n+     version and try again.  If we hit a negated form, we'll allow that\n+     and append a nott sequence when splitting out the insns.  Insns that\n+     do the split can then remove the trailing nott if they know how to\n+     deal with it.  */\n+  if (result < 0 && GET_CODE (op) == EQ)\n+    {\n+      PUT_CODE (op, NE);\n+      result = recog (PATTERN (i), i, 0);\n+      PUT_CODE (op, EQ);\n+    }\n+  if (result < 0 && GET_CODE (op) == NE)\n+    {\n+      PUT_CODE (op, EQ);\n+      result = recog (PATTERN (i), i, 0);\n+      PUT_CODE (op, NE);\n+    }\n+\n+  recog_data = prev_recog_data;\n+  return result >= 0;\n+}\n+\n+/* Returns true when recog of a 'treg_set_expr' is currently in progress.\n+   This can be used as a condition for insn/split patterns to allow certain\n+   T bit setting patters only to be matched as sub expressions of other\n+   patterns.  */\n+bool\n+sh_in_recog_treg_set_expr (void)\n+{\n+  return sh_recog_treg_set_expr_reent_count > 0;\n+}\n+\n+/* Given an rtx x, which is assumed to be some expression that has been\n+   matched by the 'treg_set_expr' predicate before, split and emit the\n+   insns that are necessary to calculate the expression and store the result\n+   in the T bit.\n+   The splitting is done recursively similar to 'try_split' in emit-rt.c.\n+   Unfortunately we can't use 'try_split' here directly, as it tries to invoke\n+   'delete_insn' which then causes the DF parts to bail out, because we\n+   currently are inside another gen_split* function and would invoke\n+   'try_split' in a reentrant way.  */\n+static std::pair<rtx_insn*, rtx_insn*>\n+sh_try_split_insn_simple (rtx_insn* i, rtx_insn* curr_insn, int n = 0)\n+{\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"sh_try_split_insn_simple n = %d i = \\n\", n);\n+      print_rtl_single (dump_file, i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  rtx_insn* seq = safe_as_a<rtx_insn*> (split_insns (PATTERN (i), curr_insn));\n+\n+  if (seq == NULL)\n+    return std::make_pair (i, i);\n+\n+  /* Avoid infinite splitter loops if any insn of the result matches\n+     the original pattern.  */\n+  for (rtx_insn* s = seq; s != NULL; s = NEXT_INSN (s))\n+    if (INSN_P (s) && rtx_equal_p (PATTERN (s), PATTERN (i)))\n+      return std::make_pair (i, i);\n+\n+  unshare_all_rtl_in_chain (seq);\n+\n+  /* 'seq' is now a replacement for 'i'.  Assuming that 'i' is an insn in\n+     a linked list, replace the single insn with the new insns.  */\n+  rtx_insn* seqlast = seq;\n+  while (NEXT_INSN (seqlast) != NULL)\n+    seqlast = NEXT_INSN (seqlast);\n+\n+  if (rtx_insn* iprev = PREV_INSN (i))\n+    SET_NEXT_INSN (iprev) = seq;\n+  if (rtx_insn* inext = NEXT_INSN (i))\n+    SET_PREV_INSN (inext) = seqlast;\n+\n+  SET_PREV_INSN (seq) = PREV_INSN (i);\n+  SET_NEXT_INSN (seqlast) = NEXT_INSN (i);\n+\n+  SET_PREV_INSN (i) = NULL;\n+  SET_NEXT_INSN (i) = NULL;\n+\n+  /* Recursively split all insns.  */\n+  for (i = seq; ; i = NEXT_INSN (i))\n+    {\n+      std::pair<rtx_insn*, rtx_insn*> ii =\n+\t  sh_try_split_insn_simple (i, curr_insn, n + 1);\n+      if (i == seq)\n+\tseq = ii.first;\n+      if (i == seqlast)\n+\t{\n+\t  seqlast = ii.second;\n+\t  break;\n+\t}\n+      i = ii.first;\n+    }\n+\n+  return std::make_pair (seq, seqlast);\n+}\n+\n+sh_treg_insns\n+sh_split_treg_set_expr (rtx x, rtx_insn* curr_insn)\n+{\n+  if (t_reg_operand (x, VOIDmode))\n+    return sh_treg_insns ();\n+\n+  scope_counter in_treg_set_expr (sh_recog_treg_set_expr_reent_count);\n+\n+  rtx_insn* i = make_insn_raw (gen_rtx_SET (VOIDmode, get_t_reg_rtx (), x));\n+  SET_PREV_INSN (i) = NULL;\n+  SET_NEXT_INSN (i) = NULL;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"split_treg_set_expr insn:\\n\");\n+      print_rtl (dump_file, i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* We are going to invoke recog/split_insns in a re-entrant way and thus\n+     have to capture its current state and restore it afterwards.  */\n+  recog_data_d prev_recog_data = recog_data;\n+\n+  int insn_code = recog (PATTERN (i), i, 0);\n+\n+  /* If the insn was not found, see if we matched the negated form before\n+     and append a nott.  */\n+  bool append_nott = false;\n+\n+  if (insn_code < 0 && GET_CODE (x) == EQ)\n+    {\n+      PUT_CODE (x, NE);\n+      insn_code = recog (PATTERN (i), i, 0);\n+      if (insn_code >= 0)\n+\tappend_nott = true;\n+      else\n+\tPUT_CODE (x, EQ);\n+    }\n+  if (insn_code < 0 && GET_CODE (x) == NE)\n+    {\n+      PUT_CODE (x, EQ);\n+      insn_code = recog (PATTERN (i), i, 0);\n+      if (insn_code >= 0)\n+\tappend_nott = true;\n+      else\n+\tPUT_CODE (x, NE);\n+    }\n+\n+  gcc_assert (insn_code >= 0);\n+\n+  /* Try to recursively split the insn.  Some insns might refuse to split\n+     any further while we are in the treg_set_expr splitting phase.  They\n+     will be emitted as part of the outer insn and then split again.  */\n+  std::pair<rtx_insn*, rtx_insn*> insnlist =\n+\tsh_try_split_insn_simple (i, curr_insn);\n+\n+  /* Restore recog state.  */\n+  recog_data = prev_recog_data;\n+\n+  rtx_insn* nott_insn = sh_is_nott_insn (insnlist.second)\n+\t\t\t? insnlist.second\n+\t\t\t: NULL;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"split_treg_set_expr insnlist:\\n\");\n+      print_rtl (dump_file, insnlist.first);\n+      fprintf (dump_file, \"\\n\");\n+\n+      if (nott_insn != NULL)\n+\tfprintf (dump_file, \"trailing nott insn %d\\n\", INSN_UID (nott_insn));\n+    }\n+\n+  if (nott_insn != NULL && append_nott)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"removing trailing nott\\n\");\n+      remove_insn (nott_insn);\n+      nott_insn = NULL;\n+      append_nott = false;\n+    }\n+\n+  emit_insn (insnlist.first);\n+\n+  if (append_nott)\n+    nott_insn = emit_insn (gen_nott (get_t_reg_rtx ()));\n+\n+  rtx_insn* first_insn = get_insns ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"resulting insns:\\n\");\n+      print_rtl (dump_file, first_insn);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  return sh_treg_insns (first_insn, nott_insn);\n+}\n+\n /*------------------------------------------------------------------------------\n   Mode switching support code.\n */"}, {"sha": "956d1ef672ef6e322d1316bb24240f457edeae4d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1130, "deletions": 485, "changes": 1615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -612,58 +612,199 @@\n ;; SImode signed integer comparisons\n ;; -------------------------------------------------------------------------\n \n-;; Various patterns to generate the TST #imm, R0 instruction.\n-;; Although this adds some pressure on the R0 register, it can potentially\n-;; result in faster code, even if the operand has to be moved to R0 first.\n-;; This is because on SH4 TST #imm, R0 and MOV Rm, Rn are both MT group \n-;; instructions and thus will be executed in parallel.  On SH4A TST #imm, R0\n-;; is an EX group instruction but still can be executed in parallel with the\n-;; MT group MOV Rm, Rn instruction.\n-\n-;; Usual TST #imm, R0 patterns for SI, HI and QI\n-;; This is usually used for bit patterns other than contiguous bits \n-;; and single bits.\n-(define_insn \"tstsi_t\"\n+;; Patterns to generate the tst instruction which are usually formed by\n+;; the combine pass.\n+;; The canonical form here being used is (eq (and (op) (op)) 0).\n+;; For some bit patterns, such as contiguous bits, we also must accept\n+;; zero_extract forms.  Single bit tests are also handled via zero_extract\n+;; patterns in the 'bit field extract patterns' section.  All variants\n+;; are eventually converted to the 'tstsi_t' insn.\n+;; As long as pseudos can be created (before RA), 'tstsi_t' will also accept\n+;; constants that won't fit into 8 bits.  After having captured the constant\n+;; we can decide better whether/how to load it into a register and do other\n+;; post-combine optimizations such as bypassing sign/zero extensions.\n+(define_insn_and_split \"tstsi_t\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI (and:SI (match_operand:SI 0 \"logical_operand\" \"%z,r\")\n-\t\t       (match_operand:SI 1 \"logical_operand\" \"K08,r\"))\n-\t       (const_int 0)))]\n-  \"TARGET_SH1\"\n-  \"tst\t%1,%0\"\n-  [(set_attr \"type\" \"mt_group\")])\n-\n-(define_insn \"tsthi_t\"\n-  [(set (reg:SI T_REG)\n-\t(eq:SI (subreg:SI (and:HI (match_operand:HI 0 \"logical_operand\" \"%z\")\n-\t\t\t\t  (match_operand 1 \"const_int_operand\")) 0)\n+\t(eq:SI (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"%z,r\")\n+\t\t       (match_operand:SI 1 \"arith_or_int_operand\" \"K08,r\"))\n \t       (const_int 0)))]\n   \"TARGET_SH1\n-   && CONST_OK_FOR_K08 (INTVAL (operands[1]))\"\n+   && (can_create_pseudo_p () || arith_reg_operand (operands[1], SImode)\n+       || satisfies_constraint_K08 (operands[1]))\"\n   \"tst\t%1,%0\"\n-  [(set_attr \"type\" \"mt_group\")])\n-\n-(define_insn \"tstqi_t\"\n-  [(set (reg:SI T_REG)\n-\t(eq:SI (subreg:SI (and:QI (match_operand:QI 0 \"logical_operand\" \"%z\")\n-\t\t\t\t  (match_operand 1 \"const_int_operand\")) 0)\n-\t       (const_int 0)))]\n-  \"TARGET_SH1\n-   && (CONST_OK_FOR_K08 (INTVAL (operands[1])) \n-       || CONST_OK_FOR_I08 (INTVAL (operands[1])))\"\n+  \"TARGET_SH1 && can_create_pseudo_p () && CONST_INT_P (operands[1])\n+   && !sh_in_recog_treg_set_expr ()\"\n+  [(const_int 0)]\n {\n-  operands[1] = GEN_INT (INTVAL (operands[1]) & 255);\n-  return \"tst\t%1,%0\";\n+  gcc_assert (CONST_INT_P (operands[1]));\n+\n+  HOST_WIDE_INT op1val = INTVAL (operands[1]);\n+  bool op0_dead_after_this =\n+\tsh_reg_dead_or_unused_after_insn (curr_insn, REGNO (operands[0]));\n+\n+  if (optimize)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"tstsi_t: trying to optimize const_int 0x%08x\\n\",\n+\t\t (uint32_t)op1val);\n+\n+      /* See if we can convert a test with a reg and a constant into\n+\t something simpler, if the reg is known to be zero or sign\n+\t extended.  */\n+      sh_extending_set_of_reg eop0 = sh_find_extending_set_of_reg (operands[0],\n+\t\t\t\t\t\t\t\t   curr_insn);\n+      if (eop0.ext_code != UNKNOWN)\n+\t{\n+\t  /* Adjust the constant, trying to eliminate bits that are not\n+\t     contributing to the result.  */\n+\t  if (eop0.from_mode == QImode)\n+\t    op1val = (op1val\n+                      | (eop0.ext_code == SIGN_EXTEND && (op1val & 0xFFFFFF80)\n+\t\t\t ? 0x80 : 0)) & 0xFF;\n+\t  else if (eop0.from_mode == HImode)\n+\t    op1val = (op1val\n+\t\t      | (eop0.ext_code == SIGN_EXTEND && (op1val & 0xFFFF8000)\n+\t\t\t ? 0x8000 : 0)) & 0xFFFF;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"tstsi_t: using effective const_int: 0x%08x\\n\",\n+\t\t     (uint32_t)op1val);\n+\n+\t  /* Try to bypass the sign/zero extension first if op0 dies after\n+\t     this insn.  */\n+\t  if (op0_dead_after_this && eop0.can_use_as_unextended_reg ())\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"tstsi_t: bypassing sign/zero extension\\n\");\n+\n+\t      operands[0] = eop0.use_as_unextended_reg (curr_insn);\n+\t    }\n+\t  else if ((eop0.from_mode == QImode && op1val == 0xFF)\n+\t\t   || (eop0.from_mode == HImode && op1val == 0xFFFF))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"tstsi_t: converting to cmpeqsi_t\\n\");\n+\t      emit_insn (gen_cmpeqsi_t (eop0.use_as_extended_reg (curr_insn),\n+\t\t\t\t\tconst0_rtx));\n+\t      DONE;\n+\t    }\n+\t  else if (eop0.ext_code == SIGN_EXTEND\n+\t\t   && ((eop0.from_mode == QImode && op1val == 0x80)\n+\t\t       || (eop0.from_mode == HImode && op1val == 0x8000)))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"tstsi_t: converting to cmpgesi_t\\n\");\n+\t      emit_insn (gen_cmpgesi_t (eop0.use_as_extended_reg (curr_insn),\n+\t\t\t\t\tconst0_rtx));\n+\t      DONE;\n+\t    }\n+\t  else if (!CONST_OK_FOR_K08 (op1val))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"tstsi_t: converting const_int to signed \"\n+\t\t\t \"value\\n\");\n+\n+\t      /* If here we haven't done anything yet.  Convert the constant\n+\t\t to a signed value to reduce the constant pool size.  */\n+\t      operands[0] = eop0.use_as_extended_reg (curr_insn);\n+\n+\t      if (eop0.from_mode == QImode)\n+\t\top1val |= (op1val & 0x80) ? 0xFFFFFFFFFFFFFF00LL : 0;\n+\t      else if (eop0.from_mode == HImode)\n+\t\top1val |= (op1val & 0x8000) ? 0xFFFFFFFFFFFF0000LL : 0;\n+\t    }\n+\t  else\n+\t    operands[0] = eop0.use_as_extended_reg (curr_insn);\n+\t}\n+    }\n+\n+    if (dump_file)\n+      fprintf (dump_file, \"tstsi_t: using const_int 0x%08x\\n\",\n+\t       (uint32_t)op1val);\n+\n+  /* Try to fit the constant into 8 bits by shuffling the value in the\n+     register operand.\n+     Doing that usually results in smaller code as the constants in the\n+     pools are avoided (32 bit constant = load + constant = 6 bytes).\n+     However, if the constant load (LS insn) can be hoisted insn dependencies\n+     can be avoided and chances for parallel execution increase.  The common\n+     usage pattern is:\n+       - load reg from mem\n+       - test bits\n+       - conditional branch\n+\n+     FIXME: For now we do that only when optimizing for size until there is\n+     a better heuristic.\n+\n+     FIXME: If there are multiple tst insns in the block with the same\n+     constant, avoid the #imm variant to avoid R0 loads.  Use the 'tst Rn,Rm'\n+     variant instead and load the constant into a reg.  For that we'd need\n+     to do some analysis.  */\n+\n+  if ((op1val & 0xFFFF) == 0\n+      && CONST_OK_FOR_K08 (op1val >> 16) && optimize_size)\n+    {\n+      /* Use a swap.w insn to do a shift + reg copy (to R0) in one insn.  */\n+      op1val = op1val >> 16;\n+      rtx r = gen_reg_rtx (SImode);\n+      emit_insn (gen_rotlsi3_16 (r, operands[0]));\n+      operands[0] = r;\n+    }\n+  else if ((op1val & 0xFF) == 0\n+\t   && CONST_OK_FOR_K08 (op1val >> 8) && optimize_size)\n+    {\n+      /* Use a swap.b insn to do a shift + reg copy (to R0) in one insn.  */\n+      op1val = op1val >> 8;\n+      rtx r = gen_reg_rtx (SImode);\n+      emit_insn (gen_swapbsi2 (r, operands[0]));\n+      operands[0] = r;\n+    }\n+  else if ((op1val & 3) == 0\n+\t   && CONST_OK_FOR_K08 (op1val >> 2) && optimize_size)\n+    {\n+      op1val = op1val >> 2;\n+      rtx r = gen_reg_rtx (SImode);\n+      emit_insn (gen_lshrsi3_k (r, operands[0], GEN_INT (2)));\n+      operands[0] = r;\n+    }\n+  else if ((op1val & 1) == 0\n+\t   && CONST_OK_FOR_K08 (op1val >> 1) && optimize_size)\n+    {\n+      op1val = op1val >> 1;\n+      rtx r = gen_reg_rtx (SImode);\n+      emit_insn (gen_shlr (r, operands[0]));\n+      operands[0] = r;\n+    }\n+\n+  operands[1] = GEN_INT (op1val);\n+\n+  if (!satisfies_constraint_K08 (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+\n+  emit_insn (gen_tstsi_t (operands[0], operands[1]));\n+  DONE;\n }\n   [(set_attr \"type\" \"mt_group\")])\n \n-;; Test low QI subreg against zero.\n-;; This avoids unnecessary zero extension before the test.\n-(define_insn \"*tstqi_t_zero\"\n+;; This pattern is used by combine when testing QI/HImode subregs with a\n+;; negative constant.  Ignore high bits by masking them out in the constant.\n+(define_insn_and_split \"*tst<mode>_t\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI (match_operand:QI 0 \"logical_operand\" \"z\") (const_int 0)))]\n-  \"TARGET_SH1\"\n-  \"tst\t#255,%0\"\n-  [(set_attr \"type\" \"mt_group\")])\n+\t(eq:SI (subreg:SI\n+\t\t (and:QIHI (match_operand:QIHI 0 \"arith_reg_operand\")\n+\t\t\t   (match_operand 1 \"const_int_operand\")) 0)\n+\t       (const_int 0)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (and:SI (match_dup 0) (match_dup 1)) (const_int 0)))]\n+{\n+  operands[0] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n+  operands[1] = GEN_INT (INTVAL (operands[1])\n+\t\t\t & (<MODE>mode == HImode ? 0xFFFF : 0xFF));\n+})\n \n ;; This pattern might be risky because it also tests the upper bits and not\n ;; only the subreg.  We have to check whether the operands have been sign\n@@ -678,7 +819,7 @@\n \t  (const_int 0)))]\n   \"TARGET_SH1 && TARGET_LITTLE_ENDIAN && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& 1\"\n+  \"&& !sh_in_recog_treg_set_expr ()\"\n   [(const_int 0)]\n {\n   sh_split_tst_subregs (curr_insn, <MODE>mode, <lowpart_le>, operands);\n@@ -694,109 +835,50 @@\n \t  (const_int 0)))]\n   \"TARGET_SH1 && TARGET_BIG_ENDIAN && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& 1\"\n+  \"&& !sh_in_recog_treg_set_expr ()\"\n   [(const_int 0)]\n {\n   sh_split_tst_subregs (curr_insn, <MODE>mode, <lowpart_be>, operands);\n   DONE;\n })\n \n-;; Extract LSB, negate and store in T bit.\n-(define_insn \"tstsi_t_and_not\"\n-  [(set (reg:SI T_REG)\n-\t (and:SI (not:SI (match_operand:SI 0 \"logical_operand\" \"z\"))\n-\t\t (const_int 1)))]\n-  \"TARGET_SH1\"\n-  \"tst\t#1,%0\"\n-  [(set_attr \"type\" \"mt_group\")])\n-\n ;; Extract contiguous bits and compare them against zero.\n-(define_insn \"tst<mode>_t_zero_extract_eq\"\n+;; Notice that this will not be used for single bits.  Special single bit\n+;; extraction patterns are in the 'bit field extract patterns' section.\n+(define_insn_and_split \"*tst<mode>_t_zero_extract\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI (zero_extract:SI (match_operand:QIHISIDI 0 \"logical_operand\" \"z\")\n-\t\t\t\t(match_operand:SI 1 \"const_int_operand\")\n-\t\t\t\t(match_operand:SI 2 \"const_int_operand\"))\n+\t(eq:SI (zero_extract:SI (match_operand:QIHISI 0 \"arith_reg_operand\")\n+\t\t\t\t(match_operand 1 \"const_int_operand\")\n+\t\t\t\t(match_operand 2 \"const_int_operand\"))\n \t       (const_int 0)))]\n-  \"TARGET_SH1\n-   && CONST_OK_FOR_K08 (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]))\"\n-{\n-  operands[1] = GEN_INT (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]));\n-  return \"tst\t%1,%0\";\n-}\n-  [(set_attr \"type\" \"mt_group\")])\n-\n-;; This split is required when testing bits in a QI subreg.\n-(define_split\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI\n-\t  (if_then_else:SI\n-\t    (zero_extract:SI (match_operand 0 \"logical_operand\")\n-\t\t\t     (match_operand 1 \"const_int_operand\")\n-\t\t\t     (match_operand 2 \"const_int_operand\"))\n-\t    (match_operand 3 \"const_int_operand\")\n-\t    (const_int 0))\n-\t  (const_int 0)))]\n-  \"TARGET_SH1\n-   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2]) == INTVAL (operands[3])\n-   && CONST_OK_FOR_K08 (INTVAL (operands[3]))\"\n-  [(set (reg:SI T_REG) (eq:SI (and:SI (match_dup 0) (match_dup 3))\n-\t\t\t      (const_int 0)))]\n+\t(eq:SI (and:SI (match_dup 0) (match_dup 1)) (const_int 0)))]\n {\n-  if (GET_MODE (operands[0]) == QImode)\n-    operands[0] = simplify_gen_subreg (SImode, operands[0], QImode, 0);\n+  operands[1] = GEN_INT (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]));\n+  if (GET_MODE (operands[0]) != SImode)\n+    operands[0] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n })\n \n-;; Extract single bit, negate and store it in the T bit.\n-;; Not used for SH4A.\n-(define_insn \"tstsi_t_zero_extract_xor\"\n+;; Convert '(reg << shift) & mask' into 'reg & (mask >> shift)'.\n+;; The shifted-out bits in the mask will always be zero, since the\n+;; shifted-in bits in the reg will also be always zero.\n+(define_insn_and_split \"*tstsi_t_shift_mask\"\n   [(set (reg:SI T_REG)\n-\t(zero_extract:SI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n-\t\t\t\t (match_operand:SI 3 \"const_int_operand\"))\n-\t\t\t (match_operand:SI 1 \"const_int_operand\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_SH1\n-   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2]) == INTVAL (operands[3])\n-   && CONST_OK_FOR_K08 (INTVAL (operands[3]))\"\n-  \"tst\t%3,%0\"\n-  [(set_attr \"type\" \"mt_group\")])\n-\n-;; Extract single bit, negate and store it in the T bit.\n-;; Used for SH4A little endian.\n-(define_insn \"tstsi_t_zero_extract_subreg_xor_little\"\n-  [(set (reg:SI T_REG)\n-\t(zero_extract:SI\n-\t (subreg:QI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n-\t\t\t    (match_operand:SI 3 \"const_int_operand\")) 0)\n-\t (match_operand:SI 1 \"const_int_operand\")\n-\t (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN\n-   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2])\n-      == (INTVAL (operands[3]) & 255)\n-   && CONST_OK_FOR_K08 (INTVAL (operands[3]) & 255)\"\n-{\n-  operands[3] = GEN_INT (INTVAL (operands[3]) & 255);\n-  return \"tst\t%3,%0\";\n-}\n-  [(set_attr \"type\" \"mt_group\")])\n-\n-;; Extract single bit, negate and store it in the T bit.\n-;; Used for SH4A big endian.\n-(define_insn \"tstsi_t_zero_extract_subreg_xor_big\"\n+\t(eq:SI (and:SI (ashift:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t\t  (match_operand 1 \"const_int_operand\"))\n+\t\t       (match_operand 2 \"const_int_operand\"))\n+\t       (const_int 0)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n   [(set (reg:SI T_REG)\n-\t(zero_extract:SI\n-\t (subreg:QI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n-\t\t\t    (match_operand:SI 3 \"const_int_operand\")) 3)\n-\t (match_operand:SI 1 \"const_int_operand\")\n-\t (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_SH1 && TARGET_BIG_ENDIAN\n-   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2])\n-      == (INTVAL (operands[3]) & 255)\n-   && CONST_OK_FOR_K08 (INTVAL (operands[3]) & 255)\"\n-{\n-  operands[3] = GEN_INT (INTVAL (operands[3]) & 255);\n-  return \"tst\t%3,%0\";\n-}\n-  [(set_attr \"type\" \"mt_group\")])\n+\t(eq:SI (and:SI (match_dup 0) (match_dup 2)) (const_int 0)))]\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) >> INTVAL (operands[1]));\n+})\n \n (define_insn \"cmpeqsi_t\"\n   [(set (reg:SI T_REG)\n@@ -809,6 +891,85 @@\n \tcmp/eq\t%1,%0\"\n   [(set_attr \"type\" \"mt_group\")])\n \n+;; Sometimes combine fails to form the (eq (and (op) (op)) 0) tst insn.\n+;; Try to fix that in the split1 pass by looking for the previous set\n+;; of the tested op.  Also see if there is a preceeding sign/zero\n+;; extension that can be avoided.\n+(define_split\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (match_operand:SI 0 \"arith_reg_operand\") (const_int 0)))]\n+  \"TARGET_SH1 && can_create_pseudo_p () && optimize\n+   && !sh_in_recog_treg_set_expr ()\"\n+  [(set (reg:SI T_REG) (eq:SI (match_dup 0) (const_int 0)))]\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"cmpeqsi_t: trying to optimize const_int 0\\n\");\n+\n+  /* If the tested reg is not dead after this insn, it's probably used by\n+     something else after the comparison.  It's probably better to leave\n+     it as it is.  */\n+  if (find_regno_note (curr_insn, REG_DEAD, REGNO (operands[0])) == NULL_RTX)\n+    FAIL;\n+\n+  /* FIXME: Maybe also search the predecessor basic blocks to catch\n+     more cases.  */\n+  set_of_reg op = sh_find_set_of_reg (operands[0], curr_insn,\n+\t\t\t\t      prev_nonnote_insn_bb);\n+\n+  if (op.set_src != NULL && GET_CODE (op.set_src) == AND\n+      && !sh_insn_operands_modified_between_p (op.insn, op.insn, curr_insn))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"cmpeqsi_t: found preceeding and in insn %d\\n\",\n+\t\t INSN_UID (op.insn));\n+\n+      if (!(arith_reg_operand (XEXP (op.set_src, 0), SImode)\n+\t    && (arith_reg_operand (XEXP (op.set_src, 1), SImode)\n+\t\t|| CONST_INT_P (XEXP (op.set_src, 1)))))\n+\tFAIL;\n+\n+      /* Assume that the operands of the andsi insn are compatible with the\n+\t operands of the tstsi_t insn, which is generally the case.  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"cmpeqsi_t: replacing with tstsi_t\\n\");\n+      emit_insn (gen_tstsi_t (XEXP (op.set_src, 0), XEXP (op.set_src, 1)));\n+      DONE;\n+    }\n+\n+  /* Converting HImode into tests against 0xFFFF tends to increase the code\n+     size, as it will create constant pool entries.  Disable it for now.  */\n+  const bool enable_himode = false;\n+\n+  /* FIXME: try to keep the (eq (reg) (const_int 0)).  Even if the zero\n+     extended reg is used after this insn, if we know that _before_ the zero\n+     extension the value was loaded via sign extending mem load, we can just\n+     use the value of the mem load directly.  */\n+  sh_extending_set_of_reg eop = sh_find_extending_set_of_reg (operands[0],\n+\t\t\t\t\t\t\t      curr_insn);\n+\n+  if (eop.ext_code != UNKNOWN\n+      && (eop.from_mode == QImode || (eop.from_mode == HImode && enable_himode))\n+      && eop.can_use_as_unextended_reg ()\n+      && !reg_used_between_p (operands[0], eop.insn, curr_insn))\n+    {\n+      /* Bypass the sign/zero extension and test against the bit mask, but\n+\t only if it's the only use of the sign/zero extracted value.\n+\t Otherwise we'd be introducing new constants in the pool.  */\n+      if (dump_file)\n+\tfprintf (dump_file, \"cmpeqsi_t: bypassing sign/zero extension in \"\n+\t\t \"insn %d and using tstsi_t\\n\", INSN_UID (op.insn));\n+\n+      emit_insn (gen_tstsi_t (\n+\t  eop.use_as_unextended_reg (curr_insn),\n+\t  GEN_INT (eop.from_mode == QImode ? 0xFF : 0xFFFF)));\n+      DONE;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"cmpeqsi_t: nothing optimized\\n\");\n+  FAIL;\n+})\n+\n ;; FIXME: For some reason, on SH4A and SH2A combine fails to simplify this\n ;; pattern by itself.  What this actually does is:\n ;;\tx == 0: (1 >> 0-0) & 1 = 1\n@@ -845,6 +1006,61 @@\n \tcmp/ge\t%1,%0\"\n   [(set_attr \"type\" \"mt_group\")])\n \n+;; Recombine a cmp/pz followed by a nott into a shll.\n+;; On non-SH2A recombine a cmp/pz followed by a movrt into shll-movt.\n+;; On SH2A cmp/pz-movrt is slightly better, as it does not mutate the input.\n+(define_split\n+  [(set (reg:SI T_REG)\n+\t(ge:SI (match_operand:SI 0 \"arith_reg_operand\") (const_int 0)))]\n+\n+  \"TARGET_SH1 && can_create_pseudo_p () && optimize\n+   && !sh_in_recog_treg_set_expr ()\"\n+  [(const_int 0)]\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"cmpgesi_t: trying to optimize for const_int 0\\n\");\n+\n+  rtx_insn* i = next_nonnote_insn_bb (curr_insn);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"cmpgesi_t: following insn is \\n\");\n+      print_rtl_single (dump_file, i);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (sh_is_nott_insn (i))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"cmpgesi_t: replacing (cmp/pz, nott) with (shll)\\n\");\n+      emit_insn (gen_shll (gen_reg_rtx (SImode), operands[0]));\n+      set_insn_deleted (i);\n+      DONE;\n+    }\n+\n+  /* On non-SH2A negc is used as movrt replacement, which sets T = 1.\n+     Thus we can remove it only if T is marked as dead afterwards.  */\n+  if (rtx dest_reg = !TARGET_SH2A\n+\t\t     && sh_reg_dead_or_unused_after_insn (i, T_REG)\n+\t\t     ? sh_movrt_set_dest (i) : NULL)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"cmpgesi_t: replacing (cmp/pz, movrt) with (shll, movt)\\n\");\n+      emit_insn (gen_shll (gen_reg_rtx (SImode), operands[0]));\n+      add_reg_note (emit_insn (gen_movt (dest_reg, get_t_reg_rtx ())),\n+\t\t    REG_DEAD, get_t_reg_rtx ());\n+      set_insn_deleted (i);\n+      DONE;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"cmpgesi_t: nothing optimized\\n\");\n+\n+  FAIL;\n+})\n+\n ;; FIXME: This is actually wrong.  There is no way to literally move a\n ;; general reg to t reg.  Luckily, it seems that this pattern will be only\n ;; used when the general reg is known be either '0' or '1' during combine.\n@@ -853,13 +1069,18 @@\n ;; and invert the dependent logic.\n (define_insn \"*negtstsi\"\n   [(set (reg:SI T_REG) (match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !sh_in_recog_treg_set_expr ()\"\n   \"cmp/pl\t%0\"\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; Some integer sign comparison patterns can be realized with the div0s insn.\n ;;\tdiv0s\tRm,Rn\t\tT = (Rm >> 31) ^ (Rn >> 31)\n-(define_insn \"cmp_div0s_0\"\n+;;\n+;; The 'cmp_div0s' pattern is our canonical form, into which all the other\n+;; variations are converted.  The negative forms will split into a trailing\n+;; nott sequence, which will be eliminated either by the\n+;; 'any_treg_expr_to_reg' pattern, or by the 'sh_treg_combine' pass.\n+(define_insn \"cmp_div0s\"\n   [(set (reg:SI T_REG)\n \t(lshiftrt:SI (xor:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n \t\t\t     (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -868,79 +1089,79 @@\n   \"div0s\t%0,%1\"\n   [(set_attr \"type\" \"arith\")])\n \n-(define_insn \"cmp_div0s_1\"\n+(define_insn_and_split \"*cmp_div0s_1\"\n   [(set (reg:SI T_REG)\n-\t(lt:SI (xor:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n-\t\t       (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t       (const_int 0)))]\n-  \"TARGET_SH1\"\n-  \"div0s\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")])\n-\n-(define_insn_and_split \"*cmp_div0s_0\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(lshiftrt:SI (xor:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n-\t\t     (const_int 31)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+\t(xor:SI (ge:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t       (const_int 0))\n+\t\t(ge:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t       (const_int 0))))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n   [(set (reg:SI T_REG)\n-\t(lshiftrt:SI (xor:SI (match_dup 1) (match_dup 2)) (const_int 31)))\n-   (set (match_dup 0) (reg:SI T_REG))])\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))])\n \n-(define_insn \"*cmp_div0s_0\"\n+(define_insn_and_split \"*cmp_div0s_2\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI (lshiftrt:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n+\t(eq:SI (lshiftrt:SI (match_operand:SI 0 \"arith_reg_operand\")\n \t\t\t    (const_int 31))\n-\t       (ge:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t       (ge:SI (match_operand:SI 1 \"arith_reg_operand\")\n \t\t      (const_int 0))))]\n-  \"TARGET_SH1\"\n-  \"div0s\t%0,%1\"\n-  [(set_attr \"type\" \"arith\")])\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))])\n \n-(define_insn_and_split \"*cmp_div0s_1\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(ge:SI (xor:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t       (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n-\t       (const_int 0)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+(define_insn_and_split \"*cmp_div0s_3\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (ge:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t      (const_int 0))\n+\t       (ge:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t      (const_int 0))))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(const_int 0)]\n-;; We have to go through the movnegt expander here which will handle the\n-;; SH2A vs non-SH2A cases.\n-{\n-  emit_insn (gen_cmp_div0s_1 (operands[1], operands[2]));\n-  emit_insn (gen_movnegt (operands[0], get_t_reg_rtx ()));\n-  DONE;\n-})\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))\n+   (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))])\n \n-(define_insn_and_split \"*cmp_div0s_1\"\n+(define_insn_and_split \"*cmp_div0s_4\"\n   [(set (reg:SI T_REG)\n-\t(ge:SI (xor:SI (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t       (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n+\t(ge:SI (xor:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t       (match_operand:SI 1 \"arith_reg_operand\"))\n \t       (const_int 0)))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(set (reg:SI T_REG) (lt:SI (xor:SI (match_dup 0) (match_dup 1))\n-\t\t\t      (const_int 0)))\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))\n    (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))])\n \n-(define_insn_and_split \"*cmp_div0s_1\"\n+(define_insn_and_split \"*cmp_div0s_5\"\n+  [(set (reg:SI T_REG)\n+\t(xor:SI (lshiftrt:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t     (const_int 31))\n+\t\t(ge:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t       (const_int 0))))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))\n+   (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))])\n+\n+(define_insn_and_split \"*cmp_div0s_6\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (lshiftrt:SI (match_operand:SI 0 \"arith_reg_operand\")\n \t\t\t    (const_int 31))\n \t       (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n \t\t\t    (const_int 31))))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(set (reg:SI T_REG) (lt:SI (xor:SI (match_dup 0) (match_dup 1))\n-\t\t\t      (const_int 0)))\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 31)))\n    (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))])\n \n ;; -------------------------------------------------------------------------\n@@ -1059,43 +1280,6 @@\n \t\t\t   (label_ref (match_dup 2))\n \t\t\t   (pc)))])\n \n-;; Compare and branch combine patterns for div0s comparisons.\n-(define_insn_and_split \"*cbranch_div0s\"\n-  [(set (pc)\n-\t(if_then_else (lt (xor:SI (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 2))\n-\t\t      (pc)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (reg:SI T_REG)\n-\t(lt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (ne (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))])\n-\n-(define_insn_and_split \"*cbranch_div0s\"\n-  [(set (pc)\n-\t(if_then_else (ge (xor:SI (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 2))\n-\t\t      (pc)))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (reg:SI T_REG)\n-\t(lt:SI (xor:SI (match_dup 0) (match_dup 1)) (const_int 0)))\n-   (set (pc)\n-\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n-\t\t      (label_ref (match_dup 2))\n-\t\t      (pc)))])\n-\n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n ;; -------------------------------------------------------------------------\n@@ -1809,50 +1993,71 @@\n ;; A simplified version of the addc insn, where the exact value of the\n ;; T bit doesn't matter.  This is easier for combine to pick up.\n ;; We allow a reg or 0 for one of the operands in order to be able to\n-;; do 'reg + T' sequences.  Reload will load the constant 0 into the reg\n-;; as needed.\n-;; FIXME: The load of constant 0 should be split out before reload, or else\n-;; it will be difficult to hoist or combine the constant load.\n-(define_insn \"*addc\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n-\t\t\t  (match_operand:SI 2 \"arith_reg_or_0_operand\" \"r\"))\n-\t\t (match_operand:SI 3 \"t_reg_operand\" \"\")))\n+;; do 'reg + T' sequences.\n+(define_insn_and_split \"*addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_or_0_operand\"))\n+\t\t (match_operand 3 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"addc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[3], curr_insn);\n+  if (ti.has_trailing_nott ())\n+    {\n+      if (operands[2] == const0_rtx)\n+\t{\n+\t  /* op1 + 0 + (1 - T) = op1 + 1 - T = op1 - (-1) - T  */\n+\t  remove_insn (ti.trailing_nott ());\n+\t  emit_insn (gen_subc (operands[0], operands[1],\n+\t\t\t       force_reg (SImode, GEN_INT (-1))));\n+\t  DONE;\n+\t}\n+      else if (!TARGET_SH2A)\n+\t{\n+\t  /* op1 + op2 + (1 - T) = op1 - (0 - op2 - 1) - T = op1 - ~op2 - T\n+\t     On SH2A keep the nott insn, because nott-addc sequence doesn't\n+\t     mutate the inputs.  */\n+\t  remove_insn (ti.trailing_nott ());\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_one_cmplsi2 (tmp, operands[2]));\n+\t  emit_insn (gen_subc (operands[0], operands[1], tmp));\n+\t  DONE;\n+\t}\n+    }\n \n-;; Split 'reg + reg + 1' into a sett addc sequence, as it can be scheduled\n-;; better, if the sett insn can be done early.\n-(define_insn_and_split \"*addc_r_r_1\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n-\t\t (const_int 1)))\n+  emit_insn (gen_addc (operands[0], operands[1],\n+\t\t       force_reg (SImode, operands[2])));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (plus:SI (match_operand 1 \"treg_set_expr\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\"))\n+\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(set (reg:SI T_REG) (const_int 1))\n-   (parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 1) (match_dup 2))\n-\t\t\t\t          (reg:SI T_REG)))\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n+\t\t\t\t          (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n-;; Left shifts by one are usually done with an add insn to avoid T_REG\n-;; clobbers.  Thus addc can also be used to do something like '(x << 1) + 1'.\n-(define_insn_and_split \"*addc_2r_1\"\n+(define_insn_and_split \"*addc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t  (const_int 2))\n-\t\t (const_int 1)))\n+\t(plus:SI (match_operand 1 \"treg_set_expr\")\n+\t\t (plus:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\"))))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(set (reg:SI T_REG) (const_int 1))\n-   (parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 1) (match_dup 1))\n-\t\t\t\t          (reg:SI T_REG)))\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n+\t\t\t\t\t  (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n ;; Sometimes combine will try to do 'reg + (0-reg) + 1' if the *addc pattern\n@@ -1881,152 +2086,77 @@\n ;; can be scheduled much better since the load of the constant can be\n ;; done earlier, before any comparison insns that store the result in\n ;; the T bit.\n+;; However, avoid things like 'reg + 1', which would expand into a\n+;; 3 insn sequence, instead of add #imm8.\n (define_insn_and_split \"*addc_t_r\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (match_operand:SI 1 \"t_reg_operand\")\n+\t(plus:SI (match_operand 1 \"treg_set_expr_not_const01\")\n \t\t (match_operand:SI 2 \"arith_reg_operand\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (plus:SI (match_dup 2) (const_int 0))\n-\t\t\t    (match_dup 1)))\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (const_int 0))\n+\t\t\t\t\t  (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n (define_insn_and_split \"*addc_r_t\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n \t(plus:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t (match_operand:SI 2 \"t_reg_operand\")))\n+\t\t (match_operand 2 \"treg_set_expr_not_const01\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (plus:SI (match_dup 1) (const_int 0))\n-\t\t\t    (match_dup 2)))\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 1) (const_int 0))\n+\t\t\t\t\t  (match_dup 2)))\n \t      (clobber (reg:SI T_REG))])])\n \n-;; Use shlr-addc to do 'reg + (reg & 1)'.\n-(define_insn_and_split \"*addc_r_lsb\"\n+;; Convert '2 * reg + T' into 'reg + reg + T'.\n+(define_insn_and_split \"*addc_2r_t\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t (const_int 1))\n-\t\t (match_operand:SI 2 \"arith_reg_operand\")))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0) (plus:SI (reg:SI T_REG) (match_dup 2)))\n-\t      (clobber (reg:SI T_REG))])]\n-{\n-  emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[1]));\n-})\n-\n-;; Use shlr-addc to do 'reg + reg + (reg & 1)'.\n-(define_insn_and_split \"*addc_r_r_lsb\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t\t  (const_int 1))\n-\t\t\t  (match_operand:SI 2 \"arith_reg_operand\"))\n-\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n-\t\t\t\t          (reg:SI T_REG)))\n-\t      (clobber (reg:SI T_REG))])]\n-{\n-  emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[1]));\n-})\n-\n-;; Canonicalize 'reg + (reg & 1) + reg' into 'reg + reg + (reg & 1)'.\n-(define_insn_and_split \"*addc_r_lsb_r\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t (const_int 1))\n-\t\t (plus:SI (match_operand:SI 2 \"arith_reg_operand\")\n-\t\t\t  (match_operand:SI 3 \"arith_reg_operand\"))))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (plus:SI (and:SI (match_dup 1) (const_int 1))\n-\t\t\t\t     (match_dup 2))\n-\t\t\t    (match_dup 3)))\n-\t      (clobber (reg:SI T_REG))])])\n-\n-;; Canonicalize '2 * reg + (reg & 1)' into 'reg + reg + (reg & 1)'.\n-(define_insn_and_split \"*addc_2r_lsb\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (and:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t (const_int 1))\n+\t(plus:SI (match_operand 1 \"treg_set_expr\")\n \t\t (mult:SI (match_operand:SI 2 \"arith_reg_operand\")\n \t\t\t  (const_int 2))))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (plus:SI (and:SI (match_dup 1) (const_int 1))\n-\t\t\t\t     (match_dup 2))\n-\t\t\t    (match_dup 2)))\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 2))\n+\t\t\t\t\t  (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n-;; Use shll-addc to do 'reg + ((unsigned int)reg >> 31)'.\n-(define_insn_and_split \"*addc_r_msb\"\n+(define_insn_and_split \"*addc_2r_t\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t      (const_int 31))\n-\t\t (match_operand:SI 2 \"arith_reg_operand\")))\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t  (const_int 2))\n+\t\t (match_operand 2 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0) (plus:SI (reg:SI T_REG) (match_dup 2)))\n-\t      (clobber (reg:SI T_REG))])]\n-{\n-  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[1]));\n-})\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 1) (match_dup 1))\n+\t\t\t\t\t  (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])])\n \n-;; Use shll-addc to do 'reg + reg + ((unsigned int)reg >> 31)'.\n-(define_insn_and_split \"*addc_r_r_msb\"\n+;; Convert '(op2 + T) - op3' into 'op2 + (-op3) + T'\n+(define_insn_and_split \"*addc_negreg_t\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (plus:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t\t       (const_int 31))\n-\t\t \t  (match_operand:SI 2 \"arith_reg_operand\"))\n-\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n+\t(minus:SI (plus:SI (match_operand 1 \"treg_set_expr\")\n+\t\t\t   (match_operand:SI 2 \"arith_reg_operand\"))\n+\t\t  (match_operand:SI 3 \"arith_reg_operand\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 3))\n-\t\t\t\t          (reg:SI T_REG)))\n+  \"&& 1\"\n+  [(set (match_dup 4) (neg:SI (match_dup 3)))\n+   (parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 2) (match_dup 4))\n+\t\t\t\t\t  (match_dup 1)))\n \t      (clobber (reg:SI T_REG))])]\n {\n-  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[1]));\n+  operands[4] = gen_reg_rtx (SImode);\n })\n \n-;; Canonicalize '2 * reg + ((unsigned int)reg >> 31)'\n-;; into 'reg + reg + (reg & 1)'.\n-(define_insn_and_split \"*addc_2r_msb\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\")\n-\t\t\t  (const_int 2))\n-\t\t (lshiftrt:SI (match_operand:SI 2 \"arith_reg_operand\")\n-\t\t\t      (const_int 31))))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (plus:SI (plus:SI (lshiftrt:SI (match_dup 2) (const_int 31))\n-\t\t\t\t     (match_dup 1))\n-\t\t\t    (match_dup 1)))\n-\t      (clobber (reg:SI T_REG))])])\n-\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"\")\n@@ -2169,15 +2299,60 @@\n ;; We allow a reg or 0 for one of the operands in order to be able to\n ;; do 'reg - T' sequences.  Reload will load the constant 0 into the reg\n ;; as needed.\n-(define_insn \"*subc\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(minus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t\t    (match_operand:SI 2 \"arith_reg_or_0_operand\" \"r\"))\n-\t\t  (match_operand:SI 3 \"t_reg_operand\" \"\")))\n+(define_insn_and_split \"*subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t    (match_operand:SI 2 \"arith_reg_or_0_operand\"))\n+\t\t  (match_operand 3 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"subc\t%2,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[3], curr_insn);\n+  if (ti.has_trailing_nott ())\n+    {\n+      if (operands[2] == const0_rtx)\n+\t{\n+\t  /* op1 - (1 - T) = op1 - 1 + T = op1 + (-1) + T  */\n+\t  remove_insn (ti.trailing_nott ());\n+\t  emit_insn (gen_addc (operands[0], operands[1],\n+\t\t\t       force_reg (SImode, GEN_INT (-1))));\n+\t  DONE;\n+\t}\n+      else if (!TARGET_SH2A)\n+\t{\n+\t  /* op1 - op2 - (1 - T) = op1 + (0 - op2 - 1) + T = op1 + ~op2 + T\n+\t     On SH2A keep the nott insn, because nott-subc sequence doesn't\n+\t     mutate the inputs.  */\n+\t  remove_insn (ti.trailing_nott ());\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_one_cmplsi2 (tmp, operands[2]));\n+\t  emit_insn (gen_addc (operands[0], operands[1], tmp));\n+\t  DONE;\n+\t}\n+    }\n+\n+  emit_insn (gen_subc (operands[0], operands[1],\n+\t\t       force_reg (SImode, operands[2])));\n+  DONE;\n+})\n+\n+;; Convert reg - T - reg = reg - reg - T\n+(define_insn_and_split \"*subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t    (match_operand 2 \"treg_set_expr\"))\n+\t\t  (match_operand:SI 3 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:SI (minus:SI (match_dup 1) (match_dup 3))\n+\t\t\t     (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])])\n \n ;; Split reg - reg - 1 into a sett subc sequence, as it can be scheduled\n ;; better, if the sett insn can be done early.\n@@ -2187,13 +2362,12 @@\n \t(plus:SI (not:SI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n \t\t (match_operand:SI 2 \"arith_reg_operand\" \"\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(set (reg:SI T_REG) (const_int 1))\n-   (parallel [(set (match_dup 0)\n+  [(parallel [(set (match_dup 0)\n \t\t   (minus:SI (minus:SI (match_dup 2) (match_dup 1))\n-\t\t\t     (reg:SI T_REG)))\n+\t\t\t     (const_int 1)))\n \t      (clobber (reg:SI T_REG))])])\n \n ;; Split 'reg - T' into 'reg - 0 - T' to utilize the subc insn.\n@@ -2208,19 +2382,82 @@\n ;; can be scheduled much better since the load of the constant can be\n ;; done earlier, before any comparison insns that store the result in\n ;; the T bit.\n+;; However, avoid things like 'reg - 1', which would expand into a\n+;; 3 insn sequence, instead of add #imm8.\n (define_insn_and_split \"*subc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"t_reg_operand\" \"\")))\n+\t\t  (match_operand 2 \"treg_set_expr_not_const01\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n \t\t   (minus:SI (minus:SI (match_dup 1) (const_int 0))\n \t\t\t     (match_dup 2)))\n \t      (clobber (reg:SI T_REG))])])\n \n+;; Convert\n+;;   (1 - T) - op2 = 1 - op2 - T\n+(define_insn_and_split \"*subc_negt_reg\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(minus:SI (match_operand 1 \"treg_set_expr_not_const01\")\n+\t\t  (match_operand:SI 2 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+  if (ti.remove_trailing_nott ())\n+    {\n+      /* (1 - T) - op2 = 1 - op2 - T  */\n+      emit_insn (gen_subc (operands[0],\n+\t\t\t   force_reg (SImode, GEN_INT (1)), operands[2]));\n+    }\n+  else\n+    {\n+      /* T - op2: use movt,sub sequence.  */\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_movt (tmp, get_t_reg_rtx ()));\n+      emit_insn (gen_subsi3 (operands[0], tmp, operands[2]));\n+    }\n+  DONE;\n+})\n+\n+;; Convert\n+;;   op1 - (1 - T) + op3 = op1 - 1 + T + op3\n+;;   (op1 - T) + op3 = op1 - (-op3) - T\n+(define_insn_and_split \"*subc_negreg_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand 2 \"treg_set_expr\"))\n+\t\t (match_operand:SI 3 \"arith_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[2], curr_insn);\n+  if (ti.remove_trailing_nott ())\n+    {\n+      /* op1 - (1 - T) + op3 = (op1 - 1) + op3 + T  */\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_addsi3 (tmp, operands[1], GEN_INT (-1)));\n+      emit_insn (gen_addc (operands[0], tmp, operands[3]));\n+    }\n+  else\n+    {\n+      /* (op1 - T) + op3' = 'op1 - (-op3) - T  */\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_negsi2 (tmp, operands[3]));\n+      emit_insn (gen_subc (operands[0], operands[1], tmp));\n+    }\n+  DONE;\n+})\n+\n (define_insn \"*subsi3_internal\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3995,10 +4232,38 @@ label:\n     offset += 8 - GET_MODE_SIZE (inmode);\n   operands[5] = gen_rtx_SUBREG (inmode, operands[0], offset);\n })\n-\f\n-;; -------------------------------------------------------------------------\n-;; Shifts and rotates\n-;; -------------------------------------------------------------------------\n+\f\n+;; -------------------------------------------------------------------------\n+;; Shifts and rotates\n+;; -------------------------------------------------------------------------\n+\n+;; Let combine see that we can get the MSB and LSB into the T bit\n+;; via shll and shlr.  This allows it to plug it into insns that can have\n+;; the T bit as an input (e.g. addc).\n+;; FIXME: On SH2A use bld #0,Rn instead of shlr to avoid mutating the input.\n+(define_insn_and_split \"*reg_lsb_t\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[0]));\n+})\n+\n+(define_insn_and_split \"*reg_msb_t\"\n+  [(set (reg:SI T_REG)\n+\t(lshiftrt:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t     (const_int 31)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[0]));\n+})\n \n (define_expand \"rotldi3\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"\")\n@@ -4236,20 +4501,46 @@ label:\n ;; directly.  Otherwise we have to insert a shift in between.\n (define_insn_and_split \"*rotcr\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_or_0_operand\")\n \t\t\t     (match_operand:SI 2 \"const_int_operand\"))\n-\t\t(ashift:SI (match_operand:SI 3 \"arith_reg_or_t_reg_operand\")\n+\t\t(ashift:SI (match_operand 3 \"arith_reg_or_treg_set_expr\")\n \t\t\t   (const_int 31))))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n+  \"&& 1\"\n   [(const_int 0)]\n {\n+  rtx prev_set_t_insn = NULL_RTX;\n+\n+  if (!arith_reg_operand (operands[3], SImode))\n+    {\n+      sh_treg_insns ti = sh_split_treg_set_expr (operands[3], curr_insn);\n+      if (!ti.was_treg_operand ())\n+\tprev_set_t_insn = ti.first_insn ();\n+\n+      operands[3] = get_t_reg_rtx ();\n+\n+      if (TARGET_SH2A && ti.has_trailing_nott () && operands[1] == const0_rtx)\n+\t{\n+\t  /* Convert to a movrt, rotr sequence.  */\n+\t  remove_insn (ti.trailing_nott ());\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_movnegt (tmp, get_t_reg_rtx ()));\n+\t  emit_insn (gen_rotrsi3_1 (operands[0], tmp));\n+\t  DONE;\n+\t}\n+    }\n+\n+  if (operands[1] == const0_rtx)\n+    {\n+      operands[1] = gen_reg_rtx (SImode);\n+      emit_insn (gen_movt (operands[1], get_t_reg_rtx ()));\n+    }\n+\n   if (INTVAL (operands[2]) > 1)\n     {\n       const rtx shift_count = GEN_INT (INTVAL (operands[2]) - 1);\n-      rtx prev_set_t_insn = NULL_RTX;\n       rtx tmp_t_reg = NULL_RTX;\n \n       /* If we're going to emit a shift sequence that clobbers the T_REG,\n@@ -4260,7 +4551,8 @@ label:\n       if (sh_lshrsi_clobbers_t_reg_p (shift_count)\n \t  && ! sh_dynamicalize_shift_p (shift_count))\n \t{\n-\t  prev_set_t_insn = prev_nonnote_insn_bb (curr_insn);\n+\t  if (prev_set_t_insn == NULL)\n+\t    prev_set_t_insn = prev_nonnote_insn_bb (curr_insn);\n \n \t  /* Skip the nott insn, which was probably inserted by the splitter\n \t     of *rotcr_neg_t.  Don't use one of the recog functions\n@@ -4320,9 +4612,9 @@ label:\n ;; it so that it will try the pattern above.\n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_or_t_reg_operand\")\n+\t(ior:SI (ashift:SI (match_operand 1 \"arith_reg_or_treg_set_expr\")\n \t\t\t   (const_int 31))\n-\t\t(lshiftrt:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"arith_reg_or_0_operand\")\n \t\t\t     (match_operand:SI 3 \"const_int_operand\"))))]\n   \"TARGET_SH1 && can_create_pseudo_p ()\"\n   [(parallel [(set (match_dup 0)\n@@ -4421,15 +4713,19 @@ label:\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n \t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n-\t\t(match_operand:SI 3 \"t_reg_operand\")))\n+\t\t(match_operand 3 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n   [(parallel [(set (match_dup 0)\n \t\t   (ior:SI (ashift:SI (match_dup 1) (match_dup 2))\n \t\t\t   (and:SI (match_dup 3) (const_int 1))))\n-\t      (clobber (reg:SI T_REG))])])\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  sh_split_treg_set_expr (operands[3], curr_insn);\n+  operands[3] = get_t_reg_rtx ();\n+})\n \n (define_insn_and_split \"*rotcl\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n@@ -4484,20 +4780,51 @@ label:\n   emit_insn (gen_shll (gen_reg_rtx (SImode), operands[3]));\n })\n \n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand 2 \"const_int_operand\"))\n+\t\t(zero_extract:SI (match_operand:SI 3 \"arith_reg_operand\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand 4 \"const_int_operand\"))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 1) (match_dup 2))\n+\t\t\t   (and:SI (match_dup 5) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  if (TARGET_SH2A && satisfies_constraint_K03 (operands[4]))\n+    {\n+      /* On SH2A we can use the bld insn to zero extract a single bit\n+\t into the T bit.  */\n+      operands[5] = get_t_reg_rtx ();\n+      emit_insn (gen_bldsi_reg (operands[3], operands[4]));\n+    }\n+  else\n+    {\n+      /* If we can't use the bld insn we have to emit a tst + nott sequence\n+\t to get the extracted bit into the T bit.\n+\t This will probably be worse than pre-shifting the operand.  */\n+      operands[5] = gen_reg_rtx (SImode);\n+      emit_insn (gen_lshrsi3 (operands[5], operands[3], operands[4]));\n+    }\n+})\n+\n ;; rotcr combine bridge pattern which will make combine try out more\n ;; complex patterns.\n (define_insn_and_split \"*rotcr\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(ashift:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 31)))]\n-  \"TARGET_SH1\"\n+\t(ashift:SI (match_operand 1 \"treg_set_expr\") (const_int 31)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (parallel [(set (match_dup 0)\n-\t\t   (ior:SI (lshiftrt:SI (match_dup 0) (const_int 1))\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (lshiftrt:SI (const_int 0) (const_int 1))\n \t\t\t   (ashift:SI (match_dup 1) (const_int 31))))\n-\t      (set (reg:SI T_REG)\n-\t\t   (and:SI (match_dup 0) (const_int 1)))])])\n+\t      (clobber (reg:SI T_REG))])])\n \n (define_insn_and_split \"*rotcr\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n@@ -4999,6 +5326,21 @@ label:\n   DONE;\n })\n \n+;; If the shift amount is changed by combine it will try to plug the\n+;; use on the symbol of the library function and the PR clobber.\n+(define_insn_and_split \"*ashrsi2_31\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t     (const_int 31)))\n+   (clobber (reg:SI T_REG))\n+   (clobber (reg:SI PR_REG))\n+   (use (match_operand:SI 2 \"symbol_ref_operand\"))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n (define_insn \"ashrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -5618,14 +5960,20 @@ label:\n ;; T bit doesn't matter.  This is easier for combine to pick up.\n ;; Notice that '0 - x - 1' is the same as '~x', thus we don't specify\n ;; extra patterns for this case.\n-(define_insn \"*negc\"\n+(define_insn_and_split \"*negc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(minus:SI (neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t  (match_operand:SI 2 \"t_reg_operand\" \"\")))\n+\t\t  (match_operand 2 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n-  \"negc\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_split_treg_set_expr (operands[2], curr_insn);\n+  emit_insn (gen_negc (operands[0], operands[1]));\n+  DONE;\n+});\n \n (define_insn \"*negdi_media\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n@@ -6101,11 +6449,14 @@ label:\n ;; the displacement value to zero.  However, doing so too early results in\n ;; missed opportunities for other optimizations such as post-inc or index\n ;; addressing loads.\n-;; Although the 'zero_extend_movu_operand' predicate does not allow simple\n-;; register addresses (an address without a displacement, index, post-inc),\n-;; zero-displacement addresses might be generated during reload, wich are\n-;; simplified to simple register addresses in turn.  Thus, we have to\n-;; provide the Sdd and Sra alternatives in the patterns.\n+;; We don't allow the zero extending loads to match during RTL expansion\n+;; (see zero_extend_operand predicate), as this would pessimize other\n+;; optimization opportunities such as bit extractions of unsigned mems,\n+;; where the zero extraction is irrelevant.  If the zero extracting mem\n+;; loads are emitted early it will be more difficult to change them back\n+;; to sign extending loads (which are preferred).\n+;; The combine pass will also try to combine mem loads and zero extends,\n+;; which is prevented by 'sh_legitimate_combined_insn'.\n (define_insn \"*zero_extend<mode>si2_disp_mem\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n \t(zero_extend:SI\n@@ -10672,25 +11023,25 @@ label:\n ;; On SH the thread pointer is kept in the GBR.\n ;; These patterns are usually expanded from the respective built-in functions.\n (define_expand \"get_thread_pointersi\"\n-  [(set (match_operand:SI 0 \"register_operand\") (reg:SI GBR_REG))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\") (reg:SI GBR_REG))]\n   \"TARGET_SH1\")\n \n ;; The store_gbr insn can also be used on !TARGET_SH1 for doing TLS accesses.\n (define_insn \"store_gbr\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\") (reg:SI GBR_REG))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\") (reg:SI GBR_REG))]\n   \"\"\n   \"stc\tgbr,%0\"\n   [(set_attr \"type\" \"tls_load\")])\n \n (define_expand \"set_thread_pointersi\"\n   [(set (reg:SI GBR_REG)\n-\t(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\")]\n+\t(unspec_volatile:SI [(match_operand:SI 0 \"arith_reg_operand\")]\n \t UNSPECV_GBR))]\n   \"TARGET_SH1\")\n \n (define_insn \"load_gbr\"\n   [(set (reg:SI GBR_REG)\n-\t(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t(unspec_volatile:SI [(match_operand:SI 0 \"arith_reg_operand\" \"r\")]\n \t UNSPECV_GBR))]\n   \"TARGET_SH1\"\n   \"ldc\t%0,gbr\"\n@@ -10708,22 +11059,22 @@ label:\n ;; zero displacement for some strange reason.\n \n (define_insn \"*mov<mode>_gbr_load\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=z\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=z\")\n \t(mem:QIHISI (plus:SI (reg:SI GBR_REG)\n \t\t\t     (match_operand:QIHISI 1 \"gbr_displacement\"))))]\n   \"TARGET_SH1\"\n   \"mov.<bwl>\t@(%O1,gbr),%0\"\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"*mov<mode>_gbr_load\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=z\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=z\")\n \t(mem:QIHISI (reg:SI GBR_REG)))]\n   \"TARGET_SH1\"\n   \"mov.<bwl>\t@(0,gbr),%0\"\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"*mov<mode>_gbr_load\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n \t(sign_extend:SI\n \t  (mem:QIHI (plus:SI (reg:SI GBR_REG)\n \t\t\t     (match_operand:QIHI 1 \"gbr_displacement\")))))]\n@@ -10732,7 +11083,7 @@ label:\n   [(set_attr \"type\" \"load\")])\n \n (define_insn \"*mov<mode>_gbr_load\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n \t(sign_extend:SI (mem:QIHI (reg:SI GBR_REG))))]\n   \"TARGET_SH1\"\n   \"mov.<bw>\t@(0,gbr),%0\"\n@@ -10759,7 +11110,7 @@ label:\n ;; Do not match this insn during or after reload because it can't be split\n ;; afterwards.\n (define_insn_and_split \"*movdi_gbr_load\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n+  [(set (match_operand:DI 0 \"arith_reg_dest\")\n \t(match_operand:DI 1 \"gbr_address_mem\"))]\n   \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n@@ -11562,7 +11913,7 @@ label:\n    (use (match_operand:SI 2 \"arith_reg_operand\" \"r\"))]\n   \"TARGET_SH1\"\n   \"negc\t%2,%0\"\n-  \"&& 1\"\n+  \"&& !sh_in_recog_treg_set_expr ()\"\n   [(const_int 0)]\n {\n   if (sh_split_movrt_negc_to_movt_xor (curr_insn, operands))\n@@ -11583,7 +11934,7 @@ label:\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && ! TARGET_SH2A\"\n   \"#\"\n-  \"&& 1\"\n+  \"&& !sh_in_recog_treg_set_expr ()\"\n   [(const_int 0)]\n {\n   if (sh_split_movrt_negc_to_movt_xor (curr_insn, operands))\n@@ -11617,61 +11968,107 @@ label:\n ;;\tT = 0: 0x80000000 -> reg\n ;;\tT = 1: 0x7FFFFFFF -> reg\n ;; This works because 0 - 0x80000000 = 0x80000000.\n-;;\n-;; This insn must not match again after it has been split into the constant\n-;; load and negc.  This is accomplished by the special negc insn that\n-;; has a use on the operand.\n (define_insn_and_split \"*mov_t_msb_neg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n \t(minus:SI (const_int -2147483648)  ;; 0x80000000\n-\t\t  (match_operand 1 \"t_reg_operand\")))\n+\t\t  (match_operand 1 \"treg_set_expr\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 2) (const_int -2147483648))\n-   (parallel [(set (match_dup 0) (minus:SI (neg:SI (match_dup 2))\n-\t\t\t\t \t   (reg:SI T_REG)))\n-\t      (clobber (reg:SI T_REG))\n-\t      (use (match_dup 2))])]\n+  \"&& 1\"\n+  [(const_int 0)]\n {\n-  operands[2] = gen_reg_rtx (SImode);\n-})\n+  if (negt_reg_operand (operands[1], VOIDmode))\n+    {\n+      emit_insn (gen_addc (operands[0],\n+\t\t\t   force_reg (SImode, const0_rtx),\n+\t\t\t   force_reg (SImode, GEN_INT (2147483647))));\n+      DONE;\n+    }\n \n-(define_insn \"*mov_t_msb_neg_negc\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(minus:SI (neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n-\t\t  (match_operand:SI 2 \"t_reg_operand\")))\n-   (clobber (reg:SI T_REG))\n-   (use (match_dup 1))]\n-  \"TARGET_SH1\"\n-  \"negc\t%1,%0\"\n-  [(set_attr \"type\" \"arith\")])\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+  if (ti.remove_trailing_nott ())\n+    emit_insn (gen_addc (operands[0],\n+\t\t\t force_reg (SImode, const0_rtx),\n+\t\t\t force_reg (SImode, GEN_INT (2147483647))));\n+  else\n+    emit_insn (gen_negc (operands[0],\n+\t\t\t force_reg (SImode, GEN_INT (-2147483648LL))));\n+  DONE;\n+})\n \n+;; 0x7fffffff + T\n+;; 0x7fffffff + (1-T) = 0 - 0x80000000 - T\n (define_insn_and_split \"*mov_t_msb_neg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(plus:SI (match_operand 1 \"negt_reg_operand\")\n+\t(plus:SI (match_operand 1 \"treg_set_expr\")\n \t\t (const_int 2147483647)))  ;; 0x7fffffff\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n    \"#\"\n    \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (minus:SI (const_int -2147483648) (reg:SI T_REG)))\n-\t      (clobber (reg:SI T_REG))])])\n+  [(const_int 0)]\n+{\n+  if (negt_reg_operand (operands[1], VOIDmode))\n+    {\n+      emit_insn (gen_negc (operands[0],\n+\t\t\t   force_reg (SImode, GEN_INT (-2147483648LL))));\n+      DONE;\n+    }\n+\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+  if (ti.remove_trailing_nott ())\n+    emit_insn (gen_negc (operands[0],\n+\t\t\t force_reg (SImode, GEN_INT (-2147483648LL))));\n+  else\n+    emit_insn (gen_addc (operands[0],\n+\t\t\t force_reg (SImode, const0_rtx),\n+\t\t\t force_reg (SImode, GEN_INT (2147483647))));\n+  DONE;\n+})\n \n (define_insn_and_split \"*mov_t_msb_neg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(if_then_else:SI (match_operand 1 \"t_reg_operand\")\n-\t\t\t (const_int 2147483647)  ;; 0x7fffffff\n-\t\t\t (const_int -2147483648)))  ;; 0x80000000\n+\t(if_then_else:SI (match_operand 1 \"treg_set_expr\")\n+\t\t\t (match_operand 2 \"const_int_operand\")\n+\t\t\t (match_operand 3 \"const_int_operand\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && can_create_pseudo_p ()\n+   && ((INTVAL (operands[2]) == -2147483648LL\n+\t&& INTVAL (operands[3]) == 2147483647LL)\n+       || (INTVAL (operands[2]) == 2147483647LL\n+\t   && INTVAL (operands[3]) == -2147483648LL))\"\n   \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (minus:SI (const_int -2147483648) (reg:SI T_REG)))\n-\t      (clobber (reg:SI T_REG))])])\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+\n+  if (INTVAL (operands[2]) == -2147483648LL)\n+    {\n+      if (ti.remove_trailing_nott ())\n+\temit_insn (gen_negc (operands[0],\n+\t\t\t     force_reg (SImode, GEN_INT (-2147483648LL))));\n+      else\n+\temit_insn (gen_addc (operands[0],\n+\t\t\t     force_reg (SImode, const0_rtx),\n+\t\t\t     force_reg (SImode, operands[3])));\n+      DONE;\n+    }\n+  else if (INTVAL (operands[2]) == 2147483647LL)\n+    {\n+      if (ti.remove_trailing_nott ())\n+\temit_insn (gen_addc (operands[0],\n+\t\t\t     force_reg (SImode, const0_rtx),\n+\t\t\t     force_reg (SImode, GEN_INT (2147483647LL))));\n+      else\n+\temit_insn (gen_negc (operands[0],\n+\t\t\t     force_reg (SImode, GEN_INT (-2147483648LL))));\n+      DONE;\n+    }\n+  else\n+    gcc_unreachable ();\n+})\n \n ;; The *negnegt pattern helps the combine pass to figure out how to fold \n ;; an explicit double T bit negation.\n@@ -11683,24 +12080,29 @@ label:\n   \"\"\n   [(const_int 0)])\n \n-;; Store T bit as all zeros or ones in a reg.\n-(define_insn \"mov_neg_si_t\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:SI (match_operand 1 \"t_reg_operand\" \"\")))]\n-  \"TARGET_SH1\"\n-  \"subc\t%0,%0\"\n-  [(set_attr \"type\" \"arith\")])\n-\n-;; Store negated T bit as all zeros or ones in a reg.\n-;; Use the following sequence:\n+;; Store (negated) T bit as all zeros or ones in a reg.\n ;;\tsubc\tRn,Rn\t! Rn = Rn - Rn - T; T = T\n ;;\tnot\tRn,Rn\t! Rn = 0 - Rn\n-(define_split\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(neg:SI (match_operand 1 \"negt_reg_operand\" \"\")))]\n+(define_insn_and_split \"mov_neg_si_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(neg:SI (match_operand 1 \"treg_set_expr\")))]\n   \"TARGET_SH1\"\n-  [(set (match_dup 0) (neg:SI (reg:SI T_REG)))\n-   (set (match_dup 0) (not:SI (match_dup 0)))])\n+{\n+  gcc_assert (t_reg_operand (operands[1], VOIDmode));\n+  return \"subc\t%0,%0\";\n+}\n+  \"&& can_create_pseudo_p () && !t_reg_operand (operands[1], VOIDmode)\"\n+  [(const_int 0)]\n+{\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+  emit_insn (gen_mov_neg_si_t (operands[0], get_t_reg_rtx ()));\n+\n+  if (ti.remove_trailing_nott ())\n+    emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n+\n+  DONE;\n+}\n+  [(set_attr \"type\" \"arith\")])\n \n ;; The *movtt pattern eliminates redundant T bit to T bit moves / tests.\n (define_insn_and_split \"*movtt\"\n@@ -11719,6 +12121,10 @@ label:\n ;; This requires an additional pseudo.  The SH specific sh_treg_combine RTL\n ;; pass will look for this insn.  Disallow using it if pseudos can't be\n ;; created.\n+;; Don't split the nott inside the splitting of a treg_set_expr, or else\n+;; surrounding insns might not see and recombine it.  Defer the splitting\n+;; of the nott until after the whole insn containing the treg_set_expr\n+;; has been split.\n (define_insn_and_split \"nott\"\n   [(set (reg:SI T_REG)\n \t(xor:SI (match_operand:SI 0 \"t_reg_operand\") (const_int 1)))]\n@@ -11727,7 +12133,7 @@ label:\n   gcc_assert (TARGET_SH2A);\n   return \"nott\";\n }\n-  \"! TARGET_SH2A && can_create_pseudo_p ()\"\n+  \"!TARGET_SH2A && can_create_pseudo_p () && !sh_in_recog_treg_set_expr ()\"\n   [(set (match_dup 0) (reg:SI T_REG))\n    (set (reg:SI T_REG) (eq:SI (match_dup 0) (const_int 0)))]\n {\n@@ -11868,6 +12274,66 @@ label:\n   DONE;\n })\n \n+;; Sometimes the T bit result of insns is needed in normal registers.\n+;; Instead of open coding all the pattern variations, use the treg_set_expr\n+;; predicate to match any T bit output insn and split it out after.\n+;; This pattern should be below all other related patterns so that it is\n+;; considered as a last resort option during matching.   This allows\n+;; overriding it with special case patterns.\n+(define_insn_and_split \"any_treg_expr_to_reg\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand 1 \"treg_set_expr\"))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& !sh_in_recog_treg_set_expr ()\"\n+  [(const_int 0)]\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"splitting any_treg_expr_to_reg\\n\");\n+\n+  if (t_reg_operand (operands[1], VOIDmode))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"t_reg_operand: emitting movt\\n\");\n+      emit_insn (gen_movt (operands[0], get_t_reg_rtx ()));\n+      DONE;\n+    }\n+  if (negt_reg_operand (operands[1], VOIDmode))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"negt_reg_operand: emitting movrt\\n\");\n+      emit_insn (gen_movnegt (operands[0], get_t_reg_rtx ()));\n+      DONE;\n+    }\n+\n+  /* If the split out insns ended with a nott, emit a movrt sequence,\n+     otherwise a normal movt.  */\n+  sh_treg_insns ti = sh_split_treg_set_expr (operands[1], curr_insn);\n+  rtx_insn* i = NULL;\n+  if (ti.remove_trailing_nott ())\n+    {\n+      /* Emit this same insn_and_split again.  However, the next time it\n+\t is split, it will emit the actual negc/movrt insn.  This gives\n+\t other surrounding insns the chance to see the trailing movrt.  */\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"any_treg_expr_to_reg: replacing trailing nott with movrt\\n\");\n+      i = emit_insn (gen_any_treg_expr_to_reg (\n+\t\t\toperands[0], gen_rtx_XOR (SImode, get_t_reg_rtx (),\n+\t\t\tconst1_rtx)));\n+    }\n+  else\n+    {\n+      i = emit_insn (gen_movt (operands[0], get_t_reg_rtx ()));\n+      if (dump_file)\n+\tfprintf (dump_file, \"any_treg_expr_to_reg: appending movt\\n\");\n+    }\n+\n+  add_reg_note (i, REG_UNUSED, get_t_reg_rtx ());\n+  DONE;\n+})\n+\n ;; -------------------------------------------------------------------------\n ;; Instructions to cope with inline literal tables\n ;; -------------------------------------------------------------------------\n@@ -13416,7 +13882,7 @@ label:\n       else if (REG_P (operands[3])\n \t       && satisfies_constraint_M (operands[1]))\n \t{\n-\t  emit_insn (gen_bld_reg (operands[3], const0_rtx));\n+\t  emit_insn (gen_bldsi_reg (operands[3], const0_rtx));\n \t  emit_insn (gen_bst_m2a (operands[0], operands[2]));\n \t  DONE;\n \t}\n@@ -13558,6 +14024,193 @@ label:\n   FAIL;\n })\n \n+;; -------------------------------------------------------------------------\n+;; Extract negated single bit and zero extend it.\n+;; Generally we don't care about the exact xor const_int value, as long\n+;; as it contains the extracted bit.  For simplicity, the pattern variations\n+;; that convert everything into the primary '*neg_zero_extract_0' pattern use\n+;; a xor const_int -1 value.\n+\n+(define_insn_and_split \"*neg_zero_extract_0\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (xor:QIHISI (match_operand:QIHISI 0 \"arith_reg_operand\")\n+\t\t\t\t     (match_operand 1 \"const_int_operand\"))\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 2 \"const_int_operand\")))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\n+   && INTVAL (operands[1]) & (1LL << INTVAL (operands[2]))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (eq:SI (and:SI (match_dup 0) (match_dup 2))\n+\t\t       (const_int 0)))]\n+{\n+  if (INTVAL (operands[2]) == 31 && <MODE>mode == SImode)\n+    {\n+      /* Use cmp/pz to extract bit 31 into the T bit.  */\n+      emit_insn (gen_cmpgesi_t (operands[0], const0_rtx));\n+      DONE;\n+    }\n+\n+  operands[2] = GEN_INT ((1 << INTVAL (operands[2])));\n+  if (GET_MODE (operands[0]) != SImode)\n+    operands[0] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n+})\n+\n+(define_insn_and_split \"*neg_zero_extract_1\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (not:SI (match_operand:SI 0 \"arith_reg_operand\"))\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (const_int -1))\n+\t\t\t\t\t(const_int 1) (const_int 0)))])\n+\n+;; x & (1 << n) == 0: 0x00000000 + 1 = 1\n+;; x & (1 << n) != 0: 0xFFFFFFFF + 1 = 0\n+(define_insn_and_split \"*neg_zero_extract_2\"\n+  [(set (reg:SI T_REG)\n+\t(plus:SI (sign_extract:SI (match_operand:QIHISI 0 \"arith_reg_operand\")\n+\t\t\t\t  (const_int 1)\n+\t\t\t\t  (match_operand 1 \"const_int_operand\"))\n+\t\t (const_int 1)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (const_int -1))\n+\t\t\t\t\t(const_int 1) (match_dup 1)))])\n+\n+;; (signed)x >> 31 + 1 = (x >= 0) ^ 1\n+(define_insn_and_split \"*neg_zero_extract_3\"\n+  [(set (reg:SI T_REG)\n+\t(plus:SI (ashiftrt:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t      (const_int 31))\n+\t\t (const_int 1)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (const_int -1))\n+\t\t\t\t\t(const_int 1) (const_int 31)))])\n+\n+;; This is required for some bit patterns of DImode subregs.\n+;; It looks like combine gets confused by the DImode right shift and fails\n+;; to simplify things.\n+(define_insn_and_split \"*neg_zero_extract_4\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (and:SI\n+\t\t  (lshiftrt:SI (xor:SI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t\t       (match_operand 1 \"const_int_operand\"))\n+\t\t\t       (match_operand 2 \"const_int_operand\"))\n+\t\t  (not:SI (ashift:SI (match_operand:SI 3 \"arith_reg_operand\")\n+\t\t\t\t     (match_operand 4 \"const_int_operand\"))))\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\n+   && INTVAL (operands[4]) > 0\n+   && INTVAL (operands[1]) & (1LL << INTVAL (operands[2]))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (match_dup 1))\n+\t\t\t\t    \t(const_int 1) (match_dup 2)))])\n+\n+(define_insn_and_split \"*neg_zero_extract_5\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (not:SI (subreg:SI\n+\t\t\t  (lshiftrt:DI (match_operand:DI 0 \"arith_reg_operand\")\n+\t\t\t\t       (match_operand 1 \"const_int_operand\"))\n+\t\t\t 0))\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN && can_create_pseudo_p ()\n+   && INTVAL (operands[1]) < 32\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (const_int -1))\n+\t\t\t\t\t(const_int 1) (match_dup 1)))]\n+{\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_insn_and_split \"*neg_zero_extract_6\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (not:SI (subreg:SI\n+\t\t\t  (lshiftrt:DI (match_operand:DI 0 \"arith_reg_operand\")\n+\t\t\t\t       (match_operand 1 \"const_int_operand\"))\n+\t\t\t 4))\n+\t\t(const_int 1)))]\n+  \"TARGET_SH1 && TARGET_BIG_ENDIAN && can_create_pseudo_p ()\n+   && INTVAL (operands[1]) < 32\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (zero_extract:SI (xor:SI (match_dup 0) (const_int -1))\n+\t\t\t\t\t(const_int 1) (match_dup 1)))]\n+{\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+;; -------------------------------------------------------------------------\n+;; Extract single bit and zero extend it.\n+;; All patterns store the result bit in the T bit, although that is not\n+;; always possible to do with a single insn and a nott must be appended.\n+;; The trailing nott will be optimized away in most cases.  E.g. if the\n+;; extracted bit is fed into a branch condition, the condition can be\n+;; inverted and the nott will be eliminated.\n+;; FIXME: In cases where the trailing nott can't be eliminated, try to\n+;; convert it into a (not, tst) sequence, which could be better on non-SH2A.\n+\n+;; On SH2A the 'bld<mode>_reg' insn will be used if the bit position fits.\n+(define_insn_and_split \"*zero_extract_0\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (match_operand:QIHISI 0 \"arith_reg_operand\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_int_operand\")))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\n+   && !(TARGET_SH2A && satisfies_constraint_K03 (operands[1]))\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (eq:SI (and:SI (match_dup 0) (match_dup 1))\n+\t\t\t      (const_int 0)))\n+   (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))]\n+{\n+  if (INTVAL (operands[1]) == 31 && <MODE>mode == SImode)\n+    {\n+      emit_insn (gen_shll (gen_reg_rtx (SImode), operands[0]));\n+      DONE;\n+    }\n+\n+  operands[1] = GEN_INT (1 << INTVAL (operands[1]));\n+  if (GET_MODE (operands[0]) != SImode)\n+    operands[0] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n+})\n+\n+;; This is required for some bit patterns of DImode subregs.\n+;; It looks like combine gets confused by the DImode right shift and fails\n+;; to simplify things.\n+(define_insn_and_split \"*zero_extract_1\"\n+  [(set (reg:SI T_REG)\n+\t(subreg:SI (zero_extract:DI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (match_operand 1 \"const_int_operand\"))\n+\t 0))]\n+  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN && can_create_pseudo_p ()\n+   && INTVAL (operands[1]) < 32\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1)))])\n+\n+(define_insn_and_split \"*zero_extract_2\"\n+  [(set (reg:SI T_REG)\n+\t(subreg:SI (zero_extract:DI (match_operand:SI 0 \"arith_reg_operand\")\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (match_operand 1 \"const_int_operand\"))\n+\t 4))]\n+  \"TARGET_SH1 && TARGET_BIG_ENDIAN && can_create_pseudo_p ()\n+   && INTVAL (operands[1]) < 32\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1)))])\n+\n+;; -------------------------------------------------------------------------\n ;; SH2A instructions for bitwise operations.\n ;; FIXME: Convert multiple instruction insns to insn_and_split.\n ;; FIXME: Use iterators to fold at least and,xor,or insn variations.\n@@ -13652,17 +14305,9 @@ label:\n   [(set_attr \"length\" \"4,4\")])\n \n ;; Store a specified bit of the LSB 8 bits of a register in the T bit.\n-(define_insn \"bld_reg\"\n-  [(set (reg:SI T_REG)\n-\t(zero_extract:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand 1 \"const_int_operand\" \"K03\")))]\n-  \"TARGET_SH2A && satisfies_constraint_K03 (operands[1])\"\n-  \"bld\t%1,%0\")\n-\n-(define_insn \"*bld_regqi\"\n+(define_insn \"bld<mode>_reg\"\n   [(set (reg:SI T_REG)\n-\t(zero_extract:SI (match_operand:QI 0 \"arith_reg_operand\" \"r\")\n+\t(zero_extract:SI (match_operand:QIHISI 0 \"arith_reg_operand\" \"r\")\n \t\t\t (const_int 1)\n \t\t\t (match_operand 1 \"const_int_operand\" \"K03\")))]\n   \"TARGET_SH2A && satisfies_constraint_K03 (operands[1])\""}, {"sha": "8b3dfc41b64c242b127b1796ecc69e1cd6c5b210", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -1,3 +1,34 @@\n+2015-01-24  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/49263\n+\tPR target/53987\n+\tPR target/64345\n+\tPR target/59533\n+\tPR target/52933\n+\tPR target/54236\n+\tPR target/51244\n+\t* gcc.target/sh/pr64345-1.c: New.\n+\t* gcc.target/sh/pr64345-2.c: New.\n+\t* gcc.target/sh/pr59533-1.c: New.\n+\t* gcc.target/sh/pr49263.c: Adjust matching of expected insns.\n+\t* gcc.target/sh/pr52933-2.c: Likewise.\n+\t* gcc.target/sh/pr54089-1.c: Likewise.\n+\t* gcc.target/sh/pr54236-1.c: Likewise.\n+\t* gcc.target/sh/pr51244-20-sh2a.c: Likewise.\n+\t* gcc.target/sh/pr49263-1.c: Remove xfails.\n+\t* gcc.target/sh/pr49263-2.c: Likewise.\n+\t* gcc.target/sh/pr49263-3.c: Likewise.\n+\t* gcc.target/sh/pr53987-1.c: Likewise.\n+\t* gcc.target/sh/pr52933-1.c: Adjust matching of expected insns.\n+\t(test_24, test_25, test_26, test_27, test_28, test_29, test_30): New.\n+\t* gcc.target/sh/pr51244-12.c: Adjust matching of expected insns.\n+\t(test05, test06, test07, test08, test09, test10, test11, test12): New.\n+\t* gcc.target/sh/pr54236-3.c: Adjust matching of expected insns.\n+\t(test_002, test_003, test_004, test_005, test_006, test_007, test_008,\n+\ttest_009): New.\n+\t* gcc.target/sh/pr51244-4.c: Adjust matching of expected insns.\n+\t(test_02): New.\n+\n 2015-01-24  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.target/i386/funcspec-5.c: Replace avx512 with avx512f."}, {"sha": "92a0cb0e0380eee0618cab491d7317ee5c4583b3", "filename": "gcc/testsuite/gcc.target/sh/pr49263-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -3,9 +3,9 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" }  */\n /* { dg-final { scan-assembler-not \"and\" } }  */\n-/* { dg-final { scan-assembler-not \"bclr\" { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"extu\" 1 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"exts\" 1 { xfail *-*-* } } }  */\n+/* { dg-final { scan-assembler-not \"bclr\" } }  */\n+/* { dg-final { scan-assembler-times \"extu\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"exts\" 1 } }  */\n \n #define make_func(__valtype__, __valget__, __tstval__, __suff__)\\\n   int test_imm_##__tstval__##__suff__ (__valtype__ val) \\"}, {"sha": "a6318fcd432bec18df147bf09cff8f24d751894b", "filename": "gcc/testsuite/gcc.target/sh/pr49263-2.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-2.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -3,13 +3,12 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" }  */\n /* { dg-final { scan-assembler-not \"and\" } }  */\n-/* { dg-final { scan-assembler-not \"exts\" { xfail *-*-* } } }  */\n-\n+/* { dg-final { scan-assembler-not \"exts\" } }  */\n /* { dg-final { scan-assembler-times \"tst\\t#127,r0\" 2 } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#255,r0\" 1 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"65407\" 1 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"-129\" 2 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"extu\" 1 { xfail *-*-* } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#255,r0\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"65407\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"-129\" 2 } }  */\n+/* { dg-final { scan-assembler-times \"extu\" 1 } }  */\n \n int\n test_00 (unsigned char x)"}, {"sha": "0fbed940ddef92865d1c63a68a3dcf58ed781c3c", "filename": "gcc/testsuite/gcc.target/sh/pr49263-3.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263-3.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -2,18 +2,18 @@\n    is shifted by a constant amount.  */\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" }  */\n-/* { dg-final { scan-assembler-not \"and|shl|sha|exts\" { xfail *-*-* } } }  */\n+/* { dg-final { scan-assembler-not \"and|shl|sha|exts\" } }  */\n \n-/* { dg-final { scan-assembler-times \"tst\\t#7,r0\" 3 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#12,r0\" 1 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#24,r0\" 6 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#13,r0\" 3 { xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#242,r0\" 3 { xfail *-*-* } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#7,r0\" 3 } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#12,r0\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#24,r0\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#13,r0\" 3 } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#242,r0\" 3 } }  */\n /* { dg-final { scan-assembler-times \"tst\\t#252,r0\" 1 } }  */\n \n-/* { dg-final { scan-assembler-times \"tst\\t#64,r0\" 6 { target { ! sh2a } xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"tst\\t#64,r0\" 4 { target { sh2a } xfail *-*-* } } }  */\n-/* { dg-final { scan-assembler-times \"bld\\t#6\" 2 { target { sh2a } xfail *-*-* } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#64,r0\" 6 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#64,r0\" 4 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#6\" 2 { target { sh2a } } } }  */\n \n int\n test_00 (unsigned char* x, int y, int z)"}, {"sha": "2393e531fe3ba5978442643d46abcce37ceff112", "filename": "gcc/testsuite/gcc.target/sh/pr49263.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr49263.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -5,6 +5,8 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" } */\n /* { dg-final { scan-assembler-not \"and\" } } */\n+/* { dg-final { scan-assembler-not \"extu\" } } */\n+/* { dg-final { scan-assembler-not \"exts\" } } */\n \n #define make_func(__valtype__, __valget__, __tstval__, __suff__)\\\n   int test_imm_##__tstval__##__suff__ (__valtype__ val) \\"}, {"sha": "ae856f8c0ff1e006a33089de174a2185e8c0e5df", "filename": "gcc/testsuite/gcc.target/sh/pr51244-12.c", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -4,8 +4,9 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O1\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n-/* { dg-final { scan-assembler-times \"negc\" 10 } } */\n-/* { dg-final { scan-assembler-not \"movrt|#-1|add|sub\" } } */\n+/* { dg-final { scan-assembler-times \"negc\" 15 } } */\n+/* { dg-final { scan-assembler-times \"addc\" 3 } } */\n+/* { dg-final { scan-assembler-not \"movrt|#-1|add\\t|sub\\t|movt\" } } */\n \n int\n test00 (int a, int b, int* x)\n@@ -66,3 +67,56 @@ test04_inv (int a)\n {\n   return ((a & 0x55) != 0) ? 0x80000000 : 0x7FFFFFFF;\n }\n+\n+int\n+test05 (int a, int b)\n+{\n+  /* 1x addc  */\n+  return a != b ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test06 (char a)\n+{\n+  return ((a & 0x03) == 0) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test07 (char a)\n+{\n+  return ((a & 0x80) == 0) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test08 (char a)\n+{\n+  return ((a & 1) == 0) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test09 (int a)\n+{\n+  /* 1x cmp/pz, 1x addc  */\n+  return a < 0 ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test10 (int a)\n+{\n+  /* 1x cmp/pz, 1x negc  */\n+  return a >= 0 ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test11 (int a)\n+{\n+  /* 1x cmp/pl, 1x negc  */\n+  return a > 0 ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test12 (int a)\n+{\n+  /* 1x cmp/pl, 1x addc  */\n+  return a <= 0 ? 0x7FFFFFFF : 0x80000000;\n+}"}, {"sha": "82ed9e0218bc091bc48f861e345a7b0d3398d93b", "filename": "gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -4,8 +4,8 @@\n /* { dg-options \"-O2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n /* { dg-final { scan-assembler-times \"tst\" 6 } } */\n-/* { dg-final { scan-assembler-times \"movt\" 1 } } */\n-/* { dg-final { scan-assembler-times \"nott\" 1 } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+/* { dg-final { scan-assembler-times \"nott\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp/eq\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp/hi\" 4 } } */\n /* { dg-final { scan-assembler-times \"cmp/gt\" 3 } } */"}, {"sha": "ac967bffd8ce4ae09ea413e6089fa52b62cc4775", "filename": "gcc/testsuite/gcc.target/sh/pr51244-4.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-4.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -1,19 +1,31 @@\n /* Check that storing the (negated) T bit as all ones or zeros in a reg\n-   uses the subc instruction.  On SH2A a sequence with the movrt instruction\n-   is also OK instead of subc.  */\n+   uses the subc instruction.  */\n /* { dg-do compile }  */\n /* { dg-options \"-O1 -mbranch-cost=2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n-/* { dg-final { scan-assembler-not \"movt|tst|negc\" } } */\n-/* { dg-final { scan-assembler \"subc|movrt|neg|not\" } } */\n+/* { dg-final { scan-assembler-not \"movt|tst|negc|movrt\" } } */\n+/* { dg-final { scan-assembler-times \"subc\" 3 } }  */\n+/* { dg-final { scan-assembler-times \"not\\t\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"shll\" 1 } }  */\n+/* { dg-final { scan-assembler-not \"cmp/gt\" } }  */\n \n-int test_00 (int x, int y)\n+int\n+test_00 (int x, int y)\n {\n+  /* 1x subc, 1x not  */\n   return x != y ? -1 : 0;\n }\n \n-int test_01 (int x, int y)\n+int\n+test_01 (int x, int y)\n {\n+  /* 1x subc  */\n   return x == y ? -1 : 0;\n }\n \n+int\n+test_02 (int x)\n+{\n+  /* 1x shll, 1x subc  */\n+  return 0 <= x ? 0 : -1;\n+}"}, {"sha": "0c69027281d90fdd27175bb82637c0b65bcb9ff5", "filename": "gcc/testsuite/gcc.target/sh/pr52933-1.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -5,8 +5,13 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n-/* { dg-final { scan-assembler-times \"div0s\" 25 } } */\n+/* { dg-final { scan-assembler-times \"div0s\" 32 } } */\n /* { dg-final { scan-assembler-not \"tst\" } } */\n+/* { dg-final { scan-assembler-not \"not\\t\" } }  */\n+/* { dg-final { scan-assembler-not \"nott\" } }  */\n+\n+/* { dg-final { scan-assembler-times \"negc\" 9 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"movrt\" 9 { target { sh2a } } } }  */\n \n typedef unsigned char bool;\n \n@@ -166,3 +171,45 @@ test_23 (int a, int b, int c, int d)\n   /* Should emit 2x div0s.  */\n   return ((a < 0) == (b < 0)) | ((c < 0) == (d < 0));\n }\n+\n+bool\n+test_24 (int a, int b)\n+{\n+  return a >= 0 != b >= 0;\n+}\n+\n+bool\n+test_25 (int a, int b)\n+{\n+  return !(a < 0 != b < 0);\n+}\n+\n+int\n+test_26 (int a, int b, int c, int d)\n+{\n+  return a >= 0 != b >= 0 ? c : d;\n+}\n+\n+int\n+test_27 (int a, int b)\n+{\n+  return a >= 0 == b >= 0;\n+}\n+\n+int\n+test_28 (int a, int b, int c, int d)\n+{\n+  return a >= 0 == b >= 0 ? c : d;\n+}\n+\n+int\n+test_29 (int a, int b)\n+{\n+  return ((a >> 31) ^ (b >= 0)) & 1;\n+}\n+\n+int\n+test_30 (int a, int b)\n+{\n+  return ((a >> 31) ^ (b >> 31)) & 1;\n+}"}, {"sha": "67e2753b2176b871fd439b73188fa2d280655e8b", "filename": "gcc/testsuite/gcc.target/sh/pr52933-2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr52933-2.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -6,7 +6,12 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2 -mpretend-cmove\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n-/* { dg-final { scan-assembler-times \"div0s\" 25 } } */\n+/* { dg-final { scan-assembler-times \"div0s\" 32 } } */\n /* { dg-final { scan-assembler-not \"tst\" } } */\n+/* { dg-final { scan-assembler-not \"not\\t\" } }  */\n+/* { dg-final { scan-assembler-not \"nott\" } }  */\n+\n+/* { dg-final { scan-assembler-times \"negc\" 9 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"movrt\" 9 { target { sh2a } } } }  */\n \n #include \"pr52933-1.c\""}, {"sha": "003dd4f49d2cd1eaec5a55f66a73ab28e185a6aa", "filename": "gcc/testsuite/gcc.target/sh/pr53987-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53987-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53987-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53987-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -6,7 +6,7 @@\n /* { dg-final { scan-assembler-not \"exts.b\" } }  */\n /* { dg-final { scan-assembler-not \"exts.w\" } }  */\n /* { dg-final { scan-assembler-not \"movu\" } }  */\n-/* { dg-final { scan-assembler-not \"tst\\t#255\" { xfail *-*-*} } }  */\n+/* { dg-final { scan-assembler-not \"tst\\t#255\" } }  */\n \n int\n test_00 (unsigned char* x, char* xx, int y, int z)"}, {"sha": "418ba694392794b979b59b9d13865f7e4d23d7b0", "filename": "gcc/testsuite/gcc.target/sh/pr54089-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -4,6 +4,8 @@\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n /* { dg-final { scan-assembler-times \"rotcr\" 24 } } */\n /* { dg-final { scan-assembler-times \"shll\\t\" 1 } } */\n+/* { dg-final { scan-assembler-not \"and\\t#1\" } }  */\n+/* { dg-final { scan-assembler-not \"cmp/pl\" } }  */\n \n typedef char bool;\n "}, {"sha": "b5c35464a6a6589af7a44ce5578357fa6a0175ef", "filename": "gcc/testsuite/gcc.target/sh/pr54236-1.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -7,8 +7,12 @@\n /* { dg-final { scan-assembler-times \"addc\" 4 } } */\n /* { dg-final { scan-assembler-times \"subc\" 3 } } */\n /* { dg-final { scan-assembler-times \"sett\" 5 } } */\n-/* { dg-final { scan-assembler-times \"negc\" 1 } } */\n-/* { dg-final { scan-assembler-not \"movt\" } } */\n+\n+/* { dg-final { scan-assembler-times \"negc\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-not \"movt\" { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"bld\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"movt\" 1 { target { sh2a } } } }  */\n \n int\n test_00 (int a, int b, int c, int d)\n@@ -64,7 +68,8 @@ test_07 (int *vec)\n {\n   /* Must not see a 'sett' or 'addc' here.\n      This is a case where combine tries to produce\n-     'a + (0 - b) + 1' out of 'a - b + 1'.  */\n+     'a + (0 - b) + 1' out of 'a - b + 1'.\n+     On non-SH2A there is a 'tst + negc', on SH2A a 'bld + movt'.  */\n   int z = vec[0];\n   int vi = vec[1];\n   int zi = vec[2];"}, {"sha": "933ece3639ba08f6403eecb81968442254f48995", "filename": "gcc/testsuite/gcc.target/sh/pr54236-3.c", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-3.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -2,11 +2,13 @@\n    If everything works as expected we won't see any movt instructions in\n    these cases.  */\n /* { dg-do compile }  */\n-/* { dg-options \"-O1\" } */\n+/* { dg-options \"-O2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n-/* { dg-final { scan-assembler-times \"addc\" 1 } } */\n-/* { dg-final { scan-assembler-times \"subc\" 1 } } */\n-/* { dg-final { scan-assembler-not \"movt\" } } */\n+/* { dg-final { scan-assembler-times \"addc\" 4 } }  */\n+/* { dg-final { scan-assembler-times \"subc\" 5 } }  */\n+/* { dg-final { scan-assembler-times \"movt\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"sub\\t\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"neg\\t\" 2 } }  */\n \n int\n test_000 (int* x, unsigned int c)\n@@ -29,3 +31,66 @@ test_001 (int* x, unsigned int c)\n     s -= ! (x[i] & 0x3000);\n   return s;\n }\n+\n+int\n+test_002 (int a, int b, int c)\n+{\n+  /* 1x tst, 1x subc  */\n+  return ((a & b) != 0) - c;\n+}\n+\n+int\n+test_003 (int a, int b, int c)\n+{\n+  /* 1x tst, 1x movt, 1x sub  */\n+  return ((a & b) == 0) - c;\n+}\n+\n+int\n+test_004 (int a, int b, int c)\n+{\n+  /* 1x tst, 1x addc  */\n+  return c - ((a & b) != 0);\n+}\n+\n+int\n+test_005 (int a, int b, int c)\n+{\n+  /* 1x shll, 1x subc  */\n+  int x = a < 0;\n+  return c - (b + x);\n+}\n+\n+int\n+test_006 (int a, int b, int c)\n+{\n+  /* 1x neg, 1x cmp/pl, 1x addc  */\n+  int x = a > 0;\n+  int y = b + x;\n+  return y - c;\n+}\n+\n+int\n+test_007 (int a, int b, int c)\n+{\n+  /* 1x add #-1, 1x cmp/eq, 1x addc  */\n+  int x = a != 1;\n+  int y = b - x;\n+  return c + y;\n+}\n+\n+int\n+test_008 (int a, int b, int c)\n+{\n+  /* 1x neg, 1x cmp/gt, 1x subc  */\n+  int x = a > 1;\n+  int y = b - x;\n+  return c + y;\n+}\n+\n+int\n+test_009 (int a, int b, int c, int d)\n+{\n+  /* 1x div0s, 1x subc  */\n+  return c - d - (a < 0 != b < 0);\n+}"}, {"sha": "f45e4b83d715e219afb1c0c724bd8da877fa9e30", "filename": "gcc/testsuite/gcc.target/sh/pr59533-1.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59533-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -0,0 +1,185 @@\n+/* Check that the cmp/pz instruction is generated as expected.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+\n+/* { dg-final { scan-assembler-times \"shll\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"movt\" 5 } }  */\n+/* { dg-final { scan-assembler-times \"rotcl\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"and\" 3 } }  */\n+/* { dg-final { scan-assembler-times \"extu.b\" 5 } }  */\n+\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 22 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 3 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"subc\" 12 { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 20 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"addc\" 5 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"subc\" 10 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\" 2 { target { sh2a } } } }  */\n+\n+int\n+test_00 (unsigned char* a)\n+{\n+  /* 1x cmp/pz, 1x movt  */\n+  return a[0] < 128;\n+}\n+\n+int\n+test_01 (unsigned char* a)\n+{\n+  /* 1x cmp/pz, 1x addc  */\n+  return a[0] + (a[0] < 128);\n+}\n+\n+int\n+test_02 (unsigned char* a)\n+{\n+  /* 1x cmp/pz, 1x addc  */\n+  return a[0] + ((a[0] & 0x80) == 0);\n+}\n+\n+int\n+test_03 (unsigned char* a)\n+{\n+  /* 1x cmp/pz, 1x subc\n+     SH2A: 1x bld, 1x addc  */\n+  return a[0] + (a[0] > 127);\n+}\n+\n+int\n+test_04 (unsigned char* a)\n+{\n+  /* 1x cmp/pz, 1x subc\n+     SH2A: 1x bld, 1x addc  */\n+  return a[0] + ((a[0] & 0x80) != 0);\n+}\n+\n+int\n+test_05 (unsigned char* a, int b, int c)\n+{\n+  /* 1x cmp/pz  */\n+  if (a[0] < 128)\n+    return c;\n+  else\n+    return b + 50;\n+}\n+\n+unsigned int\n+test_06 (unsigned int a)\n+{\n+  /* 1x cmp/pz, 1x movt  */\n+  return ~a >> 31;\n+}\n+\n+int\n+test_07 (unsigned short* a)\n+{\n+  /* 1x cmp/pz  */\n+  return a[0] < 32768;\n+}\n+\n+int\n+test_08 (unsigned short* a)\n+{\n+  /* 1x cmp/pz, 1x addc  */\n+  return a[0] + (a[0] < 32768);\n+}\n+\n+unsigned int\n+test_09 (unsigned int a)\n+{\n+  /* 1x cmp/pz, 1x movt  */\n+  return (a >> 31) ^ 1;\n+}\n+\n+unsigned int\n+test_10 (unsigned int a, unsigned int b)\n+{\n+  /* 1x cmp/pz, 1x rotcl  */\n+  return (a << 1) | ((a >> 31) ^ 1);\n+}\n+\n+unsigned int\n+test_11 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return ~(x >> 31);\n+}\n+\n+unsigned int\n+test_12 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return 0xFFFFFFFF - (x >> 31);\n+}\n+\n+unsigned int\n+test_13 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc, 1x add  */\n+  return ~(x >> 31) << 1;\n+}\n+\n+unsigned int\n+test_14 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return ~(x >> 31) >> 1;\n+}\n+\n+unsigned int\n+test_15 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return ~(x >> 31) >> 31;\n+}\n+\n+unsigned int\n+test_16 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc, 1x and  */\n+  return ~(x >> 31) & 0xFF000000;\n+}\n+\n+unsigned int\n+test_17 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc, 1x and  */\n+  return ~(x >> 31) & 0x00FF0000;\n+}\n+\n+unsigned int\n+test_18 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc, 1x and  */\n+  return ~(x >> 31) & 0x0000FF00;\n+}\n+\n+unsigned int\n+test_19 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc, 1x extu.b  */\n+  return ~(x >> 31) & 0x000000FF;\n+}\n+\n+unsigned int\n+test_20 (int x, unsigned int y, unsigned int z)\n+{\n+  /* 1x shll  */\n+  return ~(x >> 31) ? y : z;\n+}\n+\n+int\n+test_21 (int x)\n+{\n+  /* 1x cmp/pz, 1x subc  */\n+  return x >= 0 ? 0xFFFFFFFF : 0;\n+}\n+\n+int\n+test_22 (int x)\n+{\n+  /* 1x cmp/pz, 1x movt  */\n+  return (x >> 31) + 1;\n+}"}, {"sha": "16c37d79d884e0b7e1ea0db0deb3124560b3b117", "filename": "gcc/testsuite/gcc.target/sh/pr64345-1.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-1.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -0,0 +1,97 @@\n+/* Verify that single bit zero extractions emit the expected\n+   insns sequences.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-not \"exts|extu|sha|shld|subc|xor\" } }  */\n+\n+/* { dg-final { scan-assembler-times \"tst\" 716 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 6 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"shll\\t\" 6 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"shlr\\t\" 8 { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"tst\" 442 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\" 276 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 6 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"shll\\t\" 4 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"shlr\\t\" 8 { target { sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"and\\t#1\" 32 } }  */\n+\n+#define make_func(type,shift)\\\n+  int test_##type##_##_shift_##shift##_0 (type x)\\\n+  {\\\n+    return ((x >> shift) ^ 1) & 1 ? -40 : -10;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_1 (type x)\\\n+  {\\\n+    return ((x >> shift) ^ 0) & 1 ? -40 : -10;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_2 (type x)\\\n+  {\\\n+    return ((x >> shift) ^ 1) & 1;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_3 (type x)\\\n+  {\\\n+    return ((x >> shift) ^ 0) & 1;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_4 (type x)\\\n+  {\\\n+    return (x & (1 << shift)) == 0;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_5 (type x)\\\n+  {\\\n+    return (x & (1 << shift)) != 0;\\\n+  }\\\n+\\\n+  int test_##type##_##_shift_##shift##_6 (type* x)\\\n+  {\\\n+    return ((*x >> shift) ^ 1) & 1 ? -40 : -10;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_7 (type* x)\\\n+  {\\\n+    return ((*x >> shift) ^ 0) & 1 ? -40 : -10;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_8 (type* x)\\\n+  {\\\n+    return ((*x >> shift) ^ 1) & 1;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_9 (type* x)\\\n+  {\\\n+    return ((*x >> shift) ^ 0) & 1;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_10 (type* x)\\\n+  {\\\n+    return (*x & (1 << shift)) == 0;\\\n+  }\\\n+  int test_##type##_##_shift_##shift##_11 (type* x)\\\n+  {\\\n+    return (*x & (1 << shift)) != 0;\\\n+  }\n+\n+#define make_funcs(type)\\\n+  make_func (type, 0)\\\n+  make_func (type, 1)\\\n+  make_func (type, 2)\\\n+  make_func (type, 3)\\\n+  make_func (type, 4)\\\n+  make_func (type, 5)\\\n+  make_func (type, 6)\\\n+  make_func (type, 7)\n+\n+typedef signed char int8_t;\n+typedef unsigned char uint8_t;\n+typedef signed short int16_t;\n+typedef unsigned short uint16_t;\n+typedef signed int int32_t;\n+typedef unsigned int uint32_t;\n+typedef signed long long int64_t;\n+typedef unsigned long long uint64_t;\n+\n+make_funcs (int8_t)\n+make_funcs (uint8_t)\n+make_funcs (int16_t)\n+make_funcs (uint16_t)\n+make_funcs (int32_t)\n+make_funcs (uint32_t)\n+make_funcs (int64_t)\n+make_funcs (uint64_t)"}, {"sha": "dba1552cb57d4a3f3cb2b81c9e57638b3aab3431", "filename": "gcc/testsuite/gcc.target/sh/pr64345-2.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/841dbf801d85c65f02c04de31e7cf965a020c518/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64345-2.c?ref=841dbf801d85c65f02c04de31e7cf965a020c518", "patch": "@@ -0,0 +1,116 @@\n+/* Verify that the TST insn is used to extract a zero extended\n+   single bit into the T bit (for a following conditional branch) and into\n+   a GP register.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-not \"exts|extu|sha|shld|subc|xor\" } }  */\n+\n+/* { dg-final { scan-assembler-times \"tst\" 61 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#1,\" 1 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#2\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#4\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#8\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#16\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#32\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#64\" 2 { target { ! sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#128\" 2 { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"tst\" 54 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#1,\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#2\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#4\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#8\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#16\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#32\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#64\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"tst\\t#128\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#1,\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#2\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#3\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#4\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#5\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#6\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"bld\\t#7\" 1 { target { sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"and\\t#1\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 1 } }  */\n+/* { dg-final { scan-assembler-times \"shll\" 1 } }  */\n+\n+typedef struct\n+{\n+  unsigned int b31 : 1;\n+  unsigned int b30 : 1;\n+  unsigned int b29 : 1;\n+  unsigned int b28 : 1;\n+  unsigned int b27 : 1;\n+  unsigned int b26 : 1;\n+  unsigned int b25 : 1;\n+  unsigned int b24 : 1;\n+  unsigned int b23 : 1;\n+  unsigned int b22 : 1;\n+  unsigned int b21 : 1;\n+  unsigned int b20 : 1;\n+  unsigned int b19 : 1;\n+  unsigned int b18 : 1;\n+  unsigned int b17 : 1;\n+  unsigned int b16 : 1;\n+  unsigned int b15 : 1;\n+  unsigned int b14 : 1;\n+  unsigned int b13 : 1;\n+  unsigned int b12 : 1;\n+  unsigned int b11 : 1;\n+  unsigned int b10 : 1;\n+  unsigned int b9 : 1;\n+  unsigned int b8 : 1;\n+  unsigned int b7 : 1;\n+  unsigned int b6 : 1;\n+  unsigned int b5 : 1;\n+  unsigned int b4 : 1;\n+  unsigned int b3 : 1;\n+  unsigned int b2 : 1;\n+  unsigned int b1 : 1;\n+  unsigned int b0 : 1;\n+} S;\n+\n+#define make_funcs(bitpos)\\\n+  unsigned int test_b##bitpos##_0 (S s)\\\n+  {\\\n+    return s.b##bitpos;\\\n+  }\\\n+  unsigned int test_b##bitpos##_1 (S s)\\\n+  {\\\n+    return !s.b##bitpos;\\\n+  }\\\n+\n+make_funcs (0)\n+make_funcs (1)\n+make_funcs (2)\n+make_funcs (3)\n+make_funcs (4)\n+make_funcs (5)\n+make_funcs (6)\n+make_funcs (7)\n+make_funcs (8)\n+make_funcs (9)\n+make_funcs (10)\n+make_funcs (11)\n+make_funcs (12)\n+make_funcs (13)\n+make_funcs (14)\n+make_funcs (15)\n+make_funcs (16)\n+make_funcs (17)\n+make_funcs (18)\n+make_funcs (19)\n+make_funcs (20)\n+make_funcs (21)\n+make_funcs (22)\n+make_funcs (23)\n+make_funcs (24)\n+make_funcs (25)\n+make_funcs (26)\n+make_funcs (27)\n+make_funcs (28)\n+make_funcs (29)\n+make_funcs (30)\n+make_funcs (31)"}]}