{"sha": "bd454efdcf81282b006932fa7bcf8e8bc9968052", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ0NTRlZmRjZjgxMjgyYjAwNjkzMmZhN2JjZjhlOGJjOTk2ODA1Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-08-19T00:32:41Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-08-19T00:32:41Z"}, "message": "basic-block.h (struct edge_def): Remove crossing_edge.\n\n\t* basic-block.h (struct edge_def): Remove crossing_edge.\n\t(EDGE_CROSSING): New define.\n\t(EDGE_ALL_FLAGS): Update.\n\t* bb-reorder.c (find_traces_1_round, better_edge_p,\n\tfind_rarely_executed_basic_blocks_and_cr, fix_up_fall_thru_edges,\n\tfind_jump_block, fix_crossing_conditional_branches,\n\tfix_crossing_unconditional_branches, add_reg_crossing_jump_notes):\n\tReplace all occurences of crossing_edge with an edge flag check\n\tor set/reset.\n\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n\ttry_crossjump_bb): Likewise.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t* cfgrtl.c (force_nonfallthru_and_redirect,\n\tcommit_one_edge_insertion): Likewise.\n\n\t* Makefile.in (cfganal.o): Depend on TIMEVAR_H.\n\t* tree-flow.h (compute_dominance_frontiers): Move prototype...\n\t* basic-block.h:  ...here.\n\t* tree-cfg.c (compute_dominance_frontiers_1,\n\tcompute_dominance_frontiers): Move from here...\n\t* cfganal.c: ...to here.  Include timevar.h.\n\nFrom-SVN: r86228", "tree": {"sha": "78ce9f32b952d51f37e0689307e730753fca369a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78ce9f32b952d51f37e0689307e730753fca369a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd454efdcf81282b006932fa7bcf8e8bc9968052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd454efdcf81282b006932fa7bcf8e8bc9968052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd454efdcf81282b006932fa7bcf8e8bc9968052", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd454efdcf81282b006932fa7bcf8e8bc9968052/comments", "author": null, "committer": null, "parents": [{"sha": "f80fd74213fc464dafad0aa9ffc5fd6c7ab8072a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80fd74213fc464dafad0aa9ffc5fd6c7ab8072a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80fd74213fc464dafad0aa9ffc5fd6c7ab8072a"}], "stats": {"total": 246, "additions": 137, "deletions": 109}, "files": [{"sha": "706fb616160c1715ca1934b167630e9e1a982f36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -1,3 +1,27 @@\n+2004-09-19  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* basic-block.h (struct edge_def): Remove crossing_edge.\n+\t(EDGE_CROSSING): New define.\n+\t(EDGE_ALL_FLAGS): Update.\n+\t* bb-reorder.c (find_traces_1_round, better_edge_p,\n+\tfind_rarely_executed_basic_blocks_and_cr, fix_up_fall_thru_edges,\n+\tfind_jump_block, fix_crossing_conditional_branches,\n+\tfix_crossing_unconditional_branches, add_reg_crossing_jump_notes):\n+\tReplace all occurences of crossing_edge with an edge flag check\n+\tor set/reset.\n+\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n+\ttry_crossjump_bb): Likewise.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect,\n+\tcommit_one_edge_insertion): Likewise.\n+\n+\t* Makefile.in (cfganal.o): Depend on TIMEVAR_H.\n+\t* tree-flow.h (compute_dominance_frontiers): Move prototype...\n+\t* basic-block.h:  ...here.\n+\t* tree-cfg.c (compute_dominance_frontiers_1,\n+\tcompute_dominance_frontiers): Move from here...\n+\t* cfganal.c: ...to here.  Include timevar.h.\n+\n 2004-08-18  James E Wilson  <wilson@specifixinc.com>\n \n \t* config/mips/mips.h (ASM_SPEC): In comment, change -meabi= to -mabi=."}, {"sha": "b7fd64ff2edf4954697b49ea49f8a03e9a60658b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -1974,7 +1974,8 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(GGC_H) $(TM_P_H)\n+   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(GGC_H) $(TM_P_H) \\\n+   $(TIMEVAR_H)\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H)"}, {"sha": "b5f045ed921fa7a5b5c1448c5a397aa15547ffae", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -149,8 +149,6 @@ struct edge_def GTY((chain_next (\"%h.pred_next\")))\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n   gcov_type count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n-  bool crossing_edge;           /* Crosses between hot and cold sections, when\n-\t\t\t\t   we do partitioning.  */\n };\n \n typedef struct edge_def *edge;\n@@ -174,7 +172,10 @@ typedef struct edge_def *edge;\n \t\t\t\t\t   predicate is zero.  */\n #define EDGE_EXECUTABLE\t\t4096\t/* Edge is executable.  Only\n \t\t\t\t\t   valid during SSA-CCP.  */\n-#define EDGE_ALL_FLAGS\t\t8191\n+#define EDGE_CROSSING\t\t8192    /* Edge crosses between hot\n+\t\t\t\t\t   and cold sections, when we\n+\t\t\t\t\t   do partitioning.  */\n+#define EDGE_ALL_FLAGS\t       16383\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -444,6 +445,7 @@ extern void flow_preorder_transversal_compute (int *);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(basic_block, void *),\n \t\t\t       basic_block *, int, void *);\n+extern void compute_dominance_frontiers (bitmap *);\n extern void dump_edge_info (FILE *, edge, int);\n extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);"}, {"sha": "f4c486009a5b8e939526bc8b349a9e1772cd9eee", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -688,7 +688,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n \t\t\t&& !e->dest->rbi->visited\n \t\t\t&& !e->dest->pred->pred_next\n-\t\t\t&& !e->crossing_edge\n+\t\t\t&& !(e->flags & EDGE_CROSSING)\n \t\t\t&& e->dest->succ\n \t\t\t&& (e->dest->succ->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->dest->succ->flags & EDGE_COMPLEX)\n@@ -880,8 +880,8 @@ better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n   if (!is_better_edge\n       && flag_reorder_blocks_and_partition \n       && cur_best_edge \n-      && cur_best_edge->crossing_edge\n-      && !e->crossing_edge)\n+      && (cur_best_edge->flags & EDGE_CROSSING)\n+      && !(e->flags & EDGE_CROSSING))\n     is_better_edge = true;\n \n   return is_better_edge;\n@@ -1304,7 +1304,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n \t\t&& e->dest != EXIT_BLOCK_PTR\n \t\t&& e->src->partition != e->dest->partition)\n \t      {\n-\t\te->crossing_edge = true;\n+\t\te->flags |= EDGE_CROSSING;\n \t\tif (i == *max_idx)\n \t\t  {\n \t\t    *max_idx *= 2;\n@@ -1314,7 +1314,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n \t\tcrossing_edges[i++] = e;\n \t      }\n \t    else\n-\t      e->crossing_edge = false;\n+\t      e->flags &= ~EDGE_CROSSING;\n \t  }\n     }\n   *n_crossing_edges = i;\n@@ -1472,7 +1472,7 @@ fix_up_fall_thru_edges (void)\n   \t{\n   \t  /* Check to see if the fall-thru edge is a crossing edge.  */\n \t\n-\t  if (fall_thru->crossing_edge)\n+\t  if (fall_thru->flags & EDGE_CROSSING)\n   \t    {\n \t      /* The fall_thru edge crosses; now check the cond jump edge, if\n \t         it exists.  */\n@@ -1485,7 +1485,7 @@ fix_up_fall_thru_edges (void)\n \t      \n  \t      if (cond_jump)\n  \t\t{\n-\t\t  if (!cond_jump->crossing_edge)\n+\t\t  if (!(cond_jump->flags & EDGE_CROSSING))\n  \t\t    cond_jump_crosses = false;\n \t\t  \n  \t\t  /* We know the fall-thru edge crosses; if the cond\n@@ -1513,8 +1513,8 @@ fix_up_fall_thru_edges (void)\n  \t\t\t  e = fall_thru;\n  \t\t\t  fall_thru = cond_jump;\n  \t\t\t  cond_jump = e;\n-\t\t\t  cond_jump->crossing_edge = true;\n-\t\t\t  fall_thru->crossing_edge = false;\n+\t\t\t  cond_jump->flags |= EDGE_CROSSING;\n+\t\t\t  fall_thru->flags &= ~EDGE_CROSSING;\n  \t\t\t}\n  \t\t    }\n  \t\t}\n@@ -1537,7 +1537,7 @@ fix_up_fall_thru_edges (void)\n \t\t\t partition as bb it's falling through from.  */\n  \t\t      \n \t\t      new_bb->partition = cur_bb->partition;\n-\t\t      new_bb->succ->crossing_edge = true;\n+\t\t      new_bb->succ->flags |= EDGE_CROSSING;\n  \t\t    }\n \t\t  \n  \t\t  /* Add barrier after new jump */\n@@ -1574,7 +1574,7 @@ find_jump_block (basic_block jump_dest)\n   rtx insn;\n \n   for (e = jump_dest->pred; e; e = e->pred_next)\n-    if (e->crossing_edge)\n+    if (e->flags & EDGE_CROSSING)\n       {\n \tbasic_block src = e->src;\n \t\n@@ -1643,9 +1643,9 @@ fix_crossing_conditional_branches (void)\n       /* We already took care of fall-through edges, so only one successor\n \t can be a crossing edge.  */\n       \n-      if (succ1 && succ1->crossing_edge)\n+      if (succ1 && (succ1->flags & EDGE_CROSSING))\n \tcrossing_edge = succ1;\n-      else if (succ2 && succ2->crossing_edge)\n+      else if (succ2 && (succ2->flags & EDGE_CROSSING))\n  \tcrossing_edge = succ2;\n       \n       if (crossing_edge) \n@@ -1758,8 +1758,8 @@ fix_crossing_conditional_branches (void)\n \t      else\n \t\tnew_edge = new_bb->succ;\n \t      \n-\t      crossing_edge->crossing_edge = false;\n-\t      new_edge->crossing_edge = true;\n+\t      crossing_edge->flags &= ~EDGE_CROSSING;\n+\t      new_edge->flags |= EDGE_CROSSING;\n \t    }\n  \t}\n     }\n@@ -1790,7 +1790,7 @@ fix_crossing_unconditional_branches (void)\n          this point, no crossing jumps should be conditional.  */\n \n       if (JUMP_P (last_insn)\n-\t  && succ->crossing_edge)\n+\t  && (succ->flags & EDGE_CROSSING))\n \t{\n \t  rtx label2, table;\n \n@@ -1858,7 +1858,7 @@ add_reg_crossing_jump_notes (void)\n \n   FOR_EACH_BB (bb)\n     for (e = bb->succ; e; e = e->succ_next)\n-      if (e->crossing_edge\n+      if ((e->flags & EDGE_CROSSING)\n \t  && JUMP_P (BB_END (e->src)))\n \tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP, \n \t\t\t\t\t\t\t NULL_RTX, "}, {"sha": "58745d0ff09f48edbb71304943eb7a6bccdb0eba", "filename": "gcc/cfganal.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"toplev.h\"\n #include \"tm_p.h\"\n+#include \"timevar.h\"\n \n /* Store the data structures necessary for depth-first search.  */\n struct depth_first_search_dsS {\n@@ -1041,3 +1042,81 @@ dfs_enumerate_from (basic_block bb, int reverse,\n     rslt[sp]->flags &= ~BB_VISITED;\n   return tv;\n }\n+\n+\n+/* Computing the Dominance Frontier:\n+\n+   As described in Morgan, section 3.5, this may be done simply by\n+   walking the dominator tree bottom-up, computing the frontier for\n+   the children before the parent.  When considering a block B,\n+   there are two cases:\n+\n+   (1) A flow graph edge leaving B that does not lead to a child\n+   of B in the dominator tree must be a block that is either equal\n+   to B or not dominated by B.  Such blocks belong in the frontier\n+   of B.\n+\n+   (2) Consider a block X in the frontier of one of the children C\n+   of B.  If X is not equal to B and is not dominated by B, it\n+   is in the frontier of B.  */\n+\n+static void\n+compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n+{\n+  edge e;\n+  basic_block c;\n+\n+  SET_BIT (done, bb->index);\n+\n+  /* Do the frontier of the children first.  Not all children in the\n+     dominator tree (blocks dominated by this one) are children in the\n+     CFG, so check all blocks.  */\n+  for (c = first_dom_son (CDI_DOMINATORS, bb);\n+       c;\n+       c = next_dom_son (CDI_DOMINATORS, c))\n+    {\n+      if (! TEST_BIT (done, c->index))\n+    \tcompute_dominance_frontiers_1 (frontiers, c, done);\n+    }\n+      \n+  /* Find blocks conforming to rule (1) above.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+      if (get_immediate_dominator (CDI_DOMINATORS, e->dest) != bb)\n+\tbitmap_set_bit (frontiers[bb->index], e->dest->index);\n+    }\n+\n+  /* Find blocks conforming to rule (2).  */\n+  for (c = first_dom_son (CDI_DOMINATORS, bb);\n+       c;\n+       c = next_dom_son (CDI_DOMINATORS, c))\n+    {\n+      int x;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (frontiers[c->index], 0, x,\n+\t{\n+\t  if (get_immediate_dominator (CDI_DOMINATORS, BASIC_BLOCK (x)) != bb)\n+\t    bitmap_set_bit (frontiers[bb->index], x);\n+\t});\n+    }\n+}\n+\n+\n+void\n+compute_dominance_frontiers (bitmap *frontiers)\n+{\n+  sbitmap done = sbitmap_alloc (last_basic_block);\n+\n+  timevar_push (TV_DOM_FRONTIERS);\n+\n+  sbitmap_zero (done);\n+\n+  compute_dominance_frontiers_1 (frontiers, ENTRY_BLOCK_PTR->succ->dest, done);\n+\n+  sbitmap_free (done);\n+\n+  timevar_pop (TV_DOM_FRONTIERS);\n+}\n+"}, {"sha": "8080c663bc791221b0041f3c656c76802c4bcb18", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -154,7 +154,7 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   if (flag_reorder_blocks_and_partition\n       && (jump_block->partition != jump_dest_block->partition\n-\t  || cbranch_jump_edge->crossing_edge))\n+\t  || (cbranch_jump_edge->flags & EDGE_CROSSING)))\n     return false;\n \n   /* The conditional branch must target the block after the\n@@ -461,7 +461,7 @@ try_forward_edges (int mode, basic_block b)\n \t  may_thread |= target->flags & BB_DIRTY;\n \n \t  if (FORWARDER_BLOCK_P (target)\n-\t      && !target->succ->crossing_edge\n+\t      && !(target->succ->flags & EDGE_CROSSING)\n \t      && target->succ->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n@@ -1674,7 +1674,7 @@ try_crossjump_bb (int mode, basic_block bb)\n   \n   if (flag_reorder_blocks_and_partition\n       && (bb->pred->src->partition != bb->pred->pred_next->src->partition\n-\t  || bb->pred->crossing_edge))\n+\t  || (bb->pred->flags & EDGE_CROSSING)))\n     return false;\n \n   /* It is always cheapest to redirect a block that ends in a branch to"}, {"sha": "e99ed6484da98b7954486c5da0555d61d43ed6af", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -723,7 +723,8 @@ fixup_reorder_chain (void)\n \n \t      /* If the \"jumping\" edge is a crossing edge, and the fall\n \t\t through edge is non-crossing, leave things as they are.  */\n-\t      else if (e_taken->crossing_edge && !e_fall->crossing_edge)\n+\t      else if ((e_taken->flags & EDGE_CROSSING)\n+\t\t       && !(e_fall->flags & EDGE_CROSSING))\n \t\tcontinue;\n \n \t      /* Otherwise we can try to invert the jump.  This will\n@@ -814,7 +815,7 @@ fixup_reorder_chain (void)\n \t\t}\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-\t\t  && bb->succ->crossing_edge )\n+\t\t  && (bb->succ->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t    }"}, {"sha": "7295ead57d666cd25419f85ddbb15d0a2187192a", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -1114,7 +1114,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t    }\n \t  if (JUMP_P (BB_END (jump_block))\n \t      && !any_condjump_p (BB_END (jump_block))\n-\t      && jump_block->succ->crossing_edge )\n+\t      && (jump_block->succ->flags & EDGE_CROSSING))\n \t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n \t      (REG_CROSSING_JUMP, NULL_RTX, \n \t       REG_NOTES (BB_END (jump_block)));\n@@ -1602,7 +1602,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      && targetm.have_named_sections\n \t      && e->src != ENTRY_BLOCK_PTR\n \t      && e->src->partition == COLD_PARTITION\n-\t      && !e->crossing_edge)\n+\t      && !(e->flags & EDGE_CROSSING))\n \t    {\n \t      rtx bb_note, new_note, cur_insn;\n \n@@ -1621,7 +1621,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      NOTE_BASIC_BLOCK (new_note) = bb;\n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-\t\t  && bb->succ->crossing_edge )\n+\t\t  && (bb->succ->flags & EDGE_CROSSING))\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t      if (after == bb_note)\n@@ -1986,7 +1986,7 @@ rtl_verify_flow_info_1 (void)\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    {\n \t      n_fallthru++, fallthru = e;\n-\t      if (e->crossing_edge\n+\t      if ((e->flags & EDGE_CROSSING)\n \t\t  || (e->src->partition != e->dest->partition\n \t\t      && e->src != ENTRY_BLOCK_PTR\n \t\t      && e->dest != EXIT_BLOCK_PTR))"}, {"sha": "621ea576fa760db2c34b07cf35ede4cbc8516bdb", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -2171,84 +2171,6 @@ phi_alternatives_equal (basic_block dest, edge e1, edge e2)\n }\n \n \n-/* Computing the Dominance Frontier:\n-\n-   As described in Morgan, section 3.5, this may be done simply by\n-   walking the dominator tree bottom-up, computing the frontier for\n-   the children before the parent.  When considering a block B,\n-   there are two cases:\n-\n-   (1) A flow graph edge leaving B that does not lead to a child\n-   of B in the dominator tree must be a block that is either equal\n-   to B or not dominated by B.  Such blocks belong in the frontier\n-   of B.\n-\n-   (2) Consider a block X in the frontier of one of the children C\n-   of B.  If X is not equal to B and is not dominated by B, it\n-   is in the frontier of B.  */\n-\n-static void\n-compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n-{\n-  edge e;\n-  basic_block c;\n-\n-  SET_BIT (done, bb->index);\n-\n-  /* Do the frontier of the children first.  Not all children in the\n-     dominator tree (blocks dominated by this one) are children in the\n-     CFG, so check all blocks.  */\n-  for (c = first_dom_son (CDI_DOMINATORS, bb);\n-       c;\n-       c = next_dom_son (CDI_DOMINATORS, c))\n-    {\n-      if (! TEST_BIT (done, c->index))\n-    \tcompute_dominance_frontiers_1 (frontiers, c, done);\n-    }\n-      \n-  /* Find blocks conforming to rule (1) above.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-      if (get_immediate_dominator (CDI_DOMINATORS, e->dest) != bb)\n-\tbitmap_set_bit (frontiers[bb->index], e->dest->index);\n-    }\n-\n-  /* Find blocks conforming to rule (2).  */\n-  for (c = first_dom_son (CDI_DOMINATORS, bb);\n-       c;\n-       c = next_dom_son (CDI_DOMINATORS, c))\n-    {\n-      int x;\n-\n-      EXECUTE_IF_SET_IN_BITMAP (frontiers[c->index], 0, x,\n-\t{\n-\t  if (get_immediate_dominator (CDI_DOMINATORS, BASIC_BLOCK (x)) != bb)\n-\t    bitmap_set_bit (frontiers[bb->index], x);\n-\t});\n-    }\n-}\n-\n-\n-void\n-compute_dominance_frontiers (bitmap *frontiers)\n-{\n-  sbitmap done = sbitmap_alloc (last_basic_block);\n-\n-  timevar_push (TV_DOM_FRONTIERS);\n-\n-  sbitmap_zero (done);\n-\n-  compute_dominance_frontiers_1 (frontiers, ENTRY_BLOCK_PTR->succ->dest, done);\n-\n-  sbitmap_free (done);\n-\n-  timevar_pop (TV_DOM_FRONTIERS);\n-}\n-\n-\n-\n /*---------------------------------------------------------------------------\n \t\t\t      Debugging functions\n ---------------------------------------------------------------------------*/"}, {"sha": "7d26c5efaa68e674c856ddf8849befaad453cff4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd454efdcf81282b006932fa7bcf8e8bc9968052/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=bd454efdcf81282b006932fa7bcf8e8bc9968052", "patch": "@@ -489,7 +489,6 @@ extern void bsi_insert_on_edge (edge, tree);\n extern void bsi_commit_edge_inserts (int *);\n extern void notice_special_calls (tree);\n extern void clear_special_calls (void);\n-extern void compute_dominance_frontiers (bitmap *);\n extern void verify_stmts (void);\n extern tree tree_block_label (basic_block bb);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);"}]}