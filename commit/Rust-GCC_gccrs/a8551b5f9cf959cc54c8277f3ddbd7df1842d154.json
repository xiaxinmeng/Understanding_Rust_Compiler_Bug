{"sha": "a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg1NTFiNWY5Y2Y5NTljYzU0YzgyNzdmM2RkYmQ3ZGYxODQyZDE1NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-02-08T09:27:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-02-08T09:27:17Z"}, "message": "[multiple changes]\n\n2012-02-08  Robert Dewar  <dewar@adacore.com>\n\n\t* a-coinve.adb, sem_util.adb, sem_ch8.adb, a-cobove.adb,\n\ta-convec.adb: Minor reformatting and code reorganization.\n\n2012-02-08  Steve Baird  <baird@adacore.com>\n\n\t* sem_cat.adb (In_Preelaborated_Unit): A child\n\tunit instantiation does not inherit preelaboration requirements\n\tfrom its parent.\n\n2012-02-08  Gary Dismukes  <dismukes@adacore.com>\n\n\t* aspects.ads (type Aspect_Id): Add Aspect_Simple_Storage_Pool.\n\t(Impl_Defined_Aspects): Add entry for Aspect_Simple_Storage_Pool.\n\t(Aspect_Argument): Add Name entry for Aspect_Simple_Storage_Pool.\n\t(Aspect_Names): Add entry for Aspect_Simple_Storage_Pool.\n\t* aspects.adb (Canonical_Aspect): Add entry for\n\tAspect_Simple_Storage_Pool.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Handle case of\n\tAttribute_Simple_Storage_Pool in the same way as Storage_Pool\n\t(add conversion, analyze/resolve). For the Storage_Size attribute,\n\tfor the simple pool case, locate and use the simple pool type's\n\tStorage_Size function (if any), otherwise evaluate to zero.\n\t* exp_ch4.adb (Expand_N_Allocator): In the case of an allocator\n\tfor an access type with an associated simple storage pool,\n\tlocate and use the pool type's Allocate.\n\t* exp_intr.adb (Expand_Unc_Deallocation): In the case where the\n\taccess type has a simple storage pool, locate the pool type's\n\tDeallocate procedure (if present) and use it as the procedure\n\tto call on the Free operation.\n\t* freeze.adb (Freeze_Entity): In the case of a full type for\n\ta private type defined with pragma Simple_Storage_Pool, check\n\tthat the full type is also appropriate for the pragma. For\n\ta simple storage pool type, validate that the operations\n\tAllocate, Deallocate (if present), and Storage_Size\n\t(if present) are defined with appropriate expected profiles.\n\t(Validate_Simple_Pool_Op_Formal): New procedure\n\t(Validate_Simple_Pool_Operation): New procedure Add with and\n\tuse of Rtsfind.\n\t* par-prag.adb: Add Pragma_Simple_Storage_Pool to case statement\n\t(no action required).\n\t* sem_attr.adb (Analyze_Attribute): For the case of the\n\tStorage_Pool attribute, give a warning if the prefix type has an\n\tassociated simple storage pool, and rewrite the attribute as a\n\traise of Program_Error. In the case of the Simple_Storage_Pool\n\tattribute, check that the prefix type has an associated simple\n\tstorage pool, and set the attribute type to the pool's type.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add\n\tAspect_Simple_Storage_Pool case choice.\n\t(Analyze_Attribute_Definition_Clause): Add\n\tAspect_Simple_Storage_Pool to case for Ignore_Rep_Clauses\n\t(no action). Add handling for Simple_Storage_Pool attribute\n\tdefinition, requiring the name to denote a simple storage pool\n\tobject.\n\t(Check_Aspect_At_Freeze_Point): For a simple storage pool\n\taspect, set the type to that of the name specified for the aspect.\n\t* sem_prag.adb (Analyze_Pragma): Add handling for pragma\n\tSimple_Storage_Pool, requiring that it applies to a library-level\n\ttype declared in a package declaration that is a limited private\n\tor limited record type.\n\t* sem_res.adb (Resolve_Allocator): Flag an attempt to call a\n\tbuild-in-place function in an allocator for an access type with\n\ta simple storage pool as unsupported.\n\t* snames.ads-tmpl: Add Name_Simple_Storage_Pool.\n\t(type Attribute_Id): Add Attribute_Simple_Storage_Pool.\n\t(type Pragma_Id): Add Pragma_Simple_Storage_Pool.\n\t* snames.adb-tmpl (Get_Pragma_Id): Handle case of\n\tName_Simple_Storage_Pool.\n\t(Is_Pragma_Name): Return True for Name_Simple_Storage_Pool.\n\n2012-02-08  Cyrille Comar  <comar@adacore.com>\n\n\t* projects.texi: Clarify doc for interfaces.\n\nFrom-SVN: r183997", "tree": {"sha": "dc8537cde3046210d1bdc3d08b0d20cde3b64224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc8537cde3046210d1bdc3d08b0d20cde3b64224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/comments", "author": null, "committer": null, "parents": [{"sha": "86c923c886b1822995af62f41e9abdc8c7686efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c923c886b1822995af62f41e9abdc8c7686efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c923c886b1822995af62f41e9abdc8c7686efd"}], "stats": {"total": 828, "additions": 726, "deletions": 102}, "files": [{"sha": "16cd2e91dd6a848621f9d46f1cadc12f946ceeb7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1,3 +1,78 @@\n+2012-02-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-coinve.adb, sem_util.adb, sem_ch8.adb, a-cobove.adb,\n+\ta-convec.adb: Minor reformatting and code reorganization.\n+\n+2012-02-08  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_cat.adb (In_Preelaborated_Unit): A child\n+\tunit instantiation does not inherit preelaboration requirements\n+\tfrom its parent.\n+\n+2012-02-08  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* aspects.ads (type Aspect_Id): Add Aspect_Simple_Storage_Pool.\n+\t(Impl_Defined_Aspects): Add entry for Aspect_Simple_Storage_Pool.\n+\t(Aspect_Argument): Add Name entry for Aspect_Simple_Storage_Pool.\n+\t(Aspect_Names): Add entry for Aspect_Simple_Storage_Pool.\n+\t* aspects.adb (Canonical_Aspect): Add entry for\n+\tAspect_Simple_Storage_Pool.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Handle case of\n+\tAttribute_Simple_Storage_Pool in the same way as Storage_Pool\n+\t(add conversion, analyze/resolve). For the Storage_Size attribute,\n+\tfor the simple pool case, locate and use the simple pool type's\n+\tStorage_Size function (if any), otherwise evaluate to zero.\n+\t* exp_ch4.adb (Expand_N_Allocator): In the case of an allocator\n+\tfor an access type with an associated simple storage pool,\n+\tlocate and use the pool type's Allocate.\n+\t* exp_intr.adb (Expand_Unc_Deallocation): In the case where the\n+\taccess type has a simple storage pool, locate the pool type's\n+\tDeallocate procedure (if present) and use it as the procedure\n+\tto call on the Free operation.\n+\t* freeze.adb (Freeze_Entity): In the case of a full type for\n+\ta private type defined with pragma Simple_Storage_Pool, check\n+\tthat the full type is also appropriate for the pragma. For\n+\ta simple storage pool type, validate that the operations\n+\tAllocate, Deallocate (if present), and Storage_Size\n+\t(if present) are defined with appropriate expected profiles.\n+\t(Validate_Simple_Pool_Op_Formal): New procedure\n+\t(Validate_Simple_Pool_Operation): New procedure Add with and\n+\tuse of Rtsfind.\n+\t* par-prag.adb: Add Pragma_Simple_Storage_Pool to case statement\n+\t(no action required).\n+\t* sem_attr.adb (Analyze_Attribute): For the case of the\n+\tStorage_Pool attribute, give a warning if the prefix type has an\n+\tassociated simple storage pool, and rewrite the attribute as a\n+\traise of Program_Error. In the case of the Simple_Storage_Pool\n+\tattribute, check that the prefix type has an associated simple\n+\tstorage pool, and set the attribute type to the pool's type.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add\n+\tAspect_Simple_Storage_Pool case choice.\n+\t(Analyze_Attribute_Definition_Clause): Add\n+\tAspect_Simple_Storage_Pool to case for Ignore_Rep_Clauses\n+\t(no action). Add handling for Simple_Storage_Pool attribute\n+\tdefinition, requiring the name to denote a simple storage pool\n+\tobject.\n+\t(Check_Aspect_At_Freeze_Point): For a simple storage pool\n+\taspect, set the type to that of the name specified for the aspect.\n+\t* sem_prag.adb (Analyze_Pragma): Add handling for pragma\n+\tSimple_Storage_Pool, requiring that it applies to a library-level\n+\ttype declared in a package declaration that is a limited private\n+\tor limited record type.\n+\t* sem_res.adb (Resolve_Allocator): Flag an attempt to call a\n+\tbuild-in-place function in an allocator for an access type with\n+\ta simple storage pool as unsupported.\n+\t* snames.ads-tmpl: Add Name_Simple_Storage_Pool.\n+\t(type Attribute_Id): Add Attribute_Simple_Storage_Pool.\n+\t(type Pragma_Id): Add Pragma_Simple_Storage_Pool.\n+\t* snames.adb-tmpl (Get_Pragma_Id): Handle case of\n+\tName_Simple_Storage_Pool.\n+\t(Is_Pragma_Name): Return True for Name_Simple_Storage_Pool.\n+\n+2012-02-08  Cyrille Comar  <comar@adacore.com>\n+\n+\t* projects.texi: Clarify doc for interfaces.\n+\n 2012-02-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Make-lang.in (GCC_LINKERFLAGS): New variable."}, {"sha": "9148fa17454cb3f8fabda0a43622b4e868a53856", "filename": "gcc/ada/a-cobove.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-cobove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-cobove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cobove.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -939,8 +939,6 @@ package body Ada.Containers.Bounded_Vectors is\n               Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n \n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n@@ -2238,8 +2236,9 @@ package body Ada.Containers.Bounded_Vectors is\n    ----------------------\n \n    procedure Reverse_Elements (Container : in out Vector) is\n-      E        : Elements_Array renames Container.Elements;\n-      Idx, Jdx : Count_Type;\n+      E   : Elements_Array renames Container.Elements;\n+      Idx : Count_Type;\n+      Jdx : Count_Type;\n \n    begin\n       if Container.Length <= 1 then\n@@ -2251,9 +2250,9 @@ package body Ada.Containers.Bounded_Vectors is\n       --  catch more things) instead of for element tampering (which will catch\n       --  fewer things). It's true that the elements of this vector container\n       --  could be safely moved around while (say) an iteration is taking place\n-      --  (iteration only increments the busy counter), and so technically all\n-      --  we would need here is a test for element tampering (indicated by the\n-      --  lock counter), that's simply an artifact of our array-based\n+      --  (iteration only increments the busy counter), and so technically\n+      --  all we would need here is a test for element tampering (indicated\n+      --  by the lock counter), that's simply an artifact of our array-based\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n "}, {"sha": "326524cc2f16bb3c45ba1e30a159f42fe7720422", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1402,8 +1402,6 @@ package body Ada.Containers.Indefinite_Vectors is\n             Array_Type   => Elements_Array,\n             \"<\"          => Is_Less);\n \n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n@@ -3432,9 +3430,9 @@ package body Ada.Containers.Indefinite_Vectors is\n       --  catch more things) instead of for element tampering (which will catch\n       --  fewer things). It's true that the elements of this vector container\n       --  could be safely moved around while (say) an iteration is taking place\n-      --  (iteration only increments the busy counter), and so technically all\n-      --  we would need here is a test for element tampering (indicated by the\n-      --  lock counter), that's simply an artifact of our array-based\n+      --  (iteration only increments the busy counter), and so technically\n+      --  all we would need here is a test for element tampering (indicated\n+      --  by the lock counter), that's simply an artifact of our array-based\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n "}, {"sha": "729fead732cc051796d7962df62040e4fdd79e66", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1047,8 +1047,6 @@ package body Ada.Containers.Vectors is\n               Array_Type   => Elements_Array,\n               \"<\"          => \"<\");\n \n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Last <= Index_Type'First then\n             return;\n@@ -2994,9 +2992,9 @@ package body Ada.Containers.Vectors is\n       --  catch more things) instead of for element tampering (which will catch\n       --  fewer things). It's true that the elements of this vector container\n       --  could be safely moved around while (say) an iteration is taking place\n-      --  (iteration only increments the busy counter), and so technically all\n-      --  we would need here is a test for element tampering (indicated by the\n-      --  lock counter), that's simply an artifact of our array-based\n+      --  (iteration only increments the busy counter), and so technically\n+      --  all we would need here is a test for element tampering (indicated\n+      --  by the lock counter), that's simply an artifact of our array-based\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n \n@@ -3006,22 +3004,22 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         I, J : Index_Type;\n-         E    : Elements_Type renames Container.Elements.all;\n+         K : Index_Type;\n+         J : Index_Type;\n+         E : Elements_Type renames Container.Elements.all;\n \n       begin\n-         I := Index_Type'First;\n+         K := Index_Type'First;\n          J := Container.Last;\n-         while I < J loop\n+         while K < J loop\n             declare\n-               EI : constant Element_Type := E.EA (I);\n-\n+               EK : constant Element_Type := E.EA (K);\n             begin\n-               E.EA (I) := E.EA (J);\n-               E.EA (J) := EI;\n+               E.EA (K) := E.EA (J);\n+               E.EA (J) := EK;\n             end;\n \n-            I := I + 1;\n+            K := K + 1;\n             J := J - 1;\n          end loop;\n       end;\n@@ -3116,12 +3114,12 @@ package body Ada.Containers.Vectors is\n       Count : constant Count_Type'Base := Container.Length - Length;\n \n    begin\n-      --  Set_Length allows the user to set the length explicitly, instead of\n-      --  implicitly as a side-effect of deletion or insertion. If the\n+      --  Set_Length allows the user to set the length explicitly, instead\n+      --  of implicitly as a side-effect of deletion or insertion. If the\n       --  requested length is less then the current length, this is equivalent\n       --  to deleting items from the back end of the vector. If the requested\n-      --  length is greater than the current length, then this is equivalent to\n-      --  inserting \"space\" (nonce items) at the end.\n+      --  length is greater than the current length, then this is equivalent\n+      --  to inserting \"space\" (nonce items) at the end.\n \n       if Count >= 0 then\n          Container.Delete_Last (Count);\n@@ -3360,6 +3358,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Length.\n@@ -3440,13 +3439,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n+      else\n+         Update_Element (Container, Position.Index, Process);\n       end if;\n-\n-      Update_Element (Container, Position.Index, Process);\n    end Update_Element;\n \n    -----------"}, {"sha": "d78ce81427a5fa87b7077b3616d53b209f825705", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -298,6 +298,7 @@ package body Aspects is\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n     Aspect_Read                         => Aspect_Read,\n     Aspect_Shared                       => Aspect_Atomic,\n+    Aspect_Simple_Storage_Pool          => Aspect_Simple_Storage_Pool,\n     Aspect_Size                         => Aspect_Size,\n     Aspect_Small                        => Aspect_Small,\n     Aspect_Static_Predicate             => Aspect_Predicate,"}, {"sha": "bb713a427585813d14c14dad4150aa0c302068d3", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -74,6 +74,7 @@ package Aspects is\n       Aspect_Predicate,                     -- GNAT\n       Aspect_Priority,\n       Aspect_Read,\n+      Aspect_Simple_Storage_Pool,           -- GNAT\n       Aspect_Size,\n       Aspect_Small,\n       Aspect_Static_Predicate,\n@@ -186,6 +187,7 @@ package Aspects is\n                              Aspect_Pure_Function        => True,\n                              Aspect_Remote_Access_Type   => True,\n                              Aspect_Shared               => True,\n+                             Aspect_Simple_Storage_Pool  => True,\n                              Aspect_Suppress_Debug_Info  => True,\n                              Aspect_Test_Case            => True,\n                              Aspect_Universal_Data       => True,\n@@ -277,6 +279,7 @@ package Aspects is\n                         Aspect_Predicate               => Expression,\n                         Aspect_Priority                => Expression,\n                         Aspect_Read                    => Name,\n+                        Aspect_Simple_Storage_Pool     => Name,\n                         Aspect_Size                    => Expression,\n                         Aspect_Small                   => Expression,\n                         Aspect_Static_Predicate        => Expression,\n@@ -364,6 +367,7 @@ package Aspects is\n      Aspect_Remote_Types                 => Name_Remote_Types,\n      Aspect_Shared                       => Name_Shared,\n      Aspect_Shared_Passive               => Name_Shared_Passive,\n+     Aspect_Simple_Storage_Pool          => Name_Simple_Storage_Pool,\n      Aspect_Size                         => Name_Size,\n      Aspect_Small                        => Name_Small,\n      Aspect_Static_Predicate             => Name_Static_Predicate,"}, {"sha": "a2651545871da189472d34e3b957b48f0cfaa529", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 73, "deletions": 14, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4217,6 +4217,17 @@ package body Exp_Attr is\n       when Attribute_Scaling =>\n          Expand_Fpt_Attribute_RI (N);\n \n+      -------------------------\n+      -- Simple_Storage_Pool --\n+      -------------------------\n+\n+      when Attribute_Simple_Storage_Pool =>\n+         Rewrite (N,\n+           Make_Type_Conversion (Loc,\n+             Subtype_Mark => New_Reference_To (Etype (N), Loc),\n+             Expression   => New_Reference_To (Entity (N), Loc)));\n+         Analyze_And_Resolve (N, Typ);\n+\n       ----------\n       -- Size --\n       ----------\n@@ -4475,7 +4486,10 @@ package body Exp_Attr is\n       -- Storage_Size --\n       ------------------\n \n-      when Attribute_Storage_Size => Storage_Size : begin\n+      when Attribute_Storage_Size => Storage_Size : declare\n+         Alloc_Op  : Entity_Id := Empty;\n+\n+      begin\n \n          --  Access type case, always go to the root type\n \n@@ -4497,19 +4511,64 @@ package body Exp_Attr is\n                          (Storage_Size_Variable (Root_Type (Ptyp)), Loc)))));\n \n             elsif Present (Associated_Storage_Pool (Root_Type (Ptyp))) then\n-               Rewrite (N,\n-                 OK_Convert_To (Typ,\n-                   Make_Function_Call (Loc,\n-                     Name =>\n-                       New_Reference_To\n-                         (Find_Prim_Op\n-                           (Etype (Associated_Storage_Pool (Root_Type (Ptyp))),\n-                            Attribute_Name (N)),\n-                          Loc),\n \n-                     Parameter_Associations => New_List (\n-                       New_Reference_To\n-                         (Associated_Storage_Pool (Root_Type (Ptyp)), Loc)))));\n+               --  If the access type is associated with a simple storage pool\n+               --  object, then attempt to locate the optional Storage_Size\n+               --  function of the simple storage pool type. If not found,\n+               --  then the result will default to zero.\n+\n+               if Present (Get_Rep_Pragma (Root_Type (Ptyp),\n+                                           Name_Simple_Storage_Pool))\n+               then\n+                  declare\n+                     Pool_Type : constant Entity_Id :=\n+                                   Base_Type (Etype (Entity (N)));\n+\n+                  begin\n+                     Alloc_Op := Get_Name_Entity_Id (Name_Storage_Size);\n+                     while Present (Alloc_Op) loop\n+                        if Scope (Alloc_Op) = Scope (Pool_Type)\n+                          and then Present (First_Formal (Alloc_Op))\n+                          and then Etype (First_Formal (Alloc_Op)) = Pool_Type\n+                        then\n+                           exit;\n+                        end if;\n+\n+                        Alloc_Op := Homonym (Alloc_Op);\n+                     end loop;\n+                  end;\n+\n+               --  In the normal Storage_Pool case, retrieve the primitive\n+               --  function associated with the pool type.\n+\n+               else\n+                  Alloc_Op :=\n+                    Find_Prim_Op\n+                      (Etype (Associated_Storage_Pool (Root_Type (Ptyp))),\n+                       Attribute_Name (N));\n+               end if;\n+\n+               --  If Storage_Size wasn't found (can only occur in the simple\n+               --  storage pool case), then simply use zero for the result.\n+\n+               if not Present (Alloc_Op) then\n+                  Rewrite (N, Make_Integer_Literal (Loc, 0));\n+\n+               --  Otherwise, rewrite the allocator as a call to pool type's\n+               --  Storage_Size function.\n+\n+               else\n+                  Rewrite (N,\n+                    OK_Convert_To (Typ,\n+                      Make_Function_Call (Loc,\n+                        Name =>\n+                          New_Reference_To (Alloc_Op, Loc),\n+\n+                        Parameter_Associations => New_List (\n+                          New_Reference_To\n+                            (Associated_Storage_Pool\n+                               (Root_Type (Ptyp)), Loc)))));\n+               end if;\n \n             else\n                Rewrite (N, Make_Integer_Literal (Loc, 0));"}, {"sha": "605de764254c16f9accdd9852d7abfe6d58dca22", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -3565,6 +3565,31 @@ package body Exp_Ch4 is\n                   Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n                end if;\n \n+            --  In the case of an allocator for a simple storage pool, locate\n+            --  and save a reference to the pool type's Allocate routine.\n+\n+            elsif Present (Get_Rep_Pragma\n+                             (Etype (Pool), Name_Simple_Storage_Pool))\n+            then\n+               declare\n+                  Alloc_Op  : Entity_Id := Get_Name_Entity_Id (Name_Allocate);\n+                  Pool_Type : constant Entity_Id := Base_Type (Etype (Pool));\n+\n+               begin\n+                  while Present (Alloc_Op) loop\n+                     if Scope (Alloc_Op) = Scope (Pool_Type)\n+                       and then Present (First_Formal (Alloc_Op))\n+                       and then Etype (First_Formal (Alloc_Op)) = Pool_Type\n+                     then\n+                        Set_Procedure_To_Call (N, Alloc_Op);\n+\n+                        exit;\n+                     end if;\n+\n+                     Alloc_Op := Homonym (Alloc_Op);\n+                  end loop;\n+               end;\n+\n             elsif Is_Class_Wide_Type (Etype (Pool)) then\n                Set_Procedure_To_Call (N, RTE (RE_Allocate_Any));\n "}, {"sha": "2707d7a2a063c61a55735ee1c9fdead4c1733d33", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1084,6 +1084,34 @@ package body Exp_Intr is\n          if Is_RTE (Pool, RE_SS_Pool) then\n             null;\n \n+         --  If the pool object is of a simple storage pool type, then attempt\n+         --  to locate the type's Deallocate procedure, if any, and set the\n+         --  free operation's procedure to call. If the type doesn't have a\n+         --  Deallocate (which is allowed), then the actual will simply be set\n+         --  to null.\n+\n+         elsif Present (Get_Rep_Pragma\n+                          (Etype (Pool), Name_Simple_Storage_Pool))\n+         then\n+            declare\n+               Dealloc_Op  : Entity_Id := Get_Name_Entity_Id (Name_Deallocate);\n+               Pool_Type : constant Entity_Id := Base_Type (Etype (Pool));\n+\n+            begin\n+               while Present (Dealloc_Op) loop\n+                  if Scope (Dealloc_Op) = Scope (Pool_Type)\n+                    and then Present (First_Formal (Dealloc_Op))\n+                    and then Etype (First_Formal (Dealloc_Op)) = Pool_Type\n+                  then\n+                     Set_Procedure_To_Call (Free_Node, Dealloc_Op);\n+\n+                     exit;\n+                  end if;\n+\n+                  Dealloc_Op := Homonym (Dealloc_Op);\n+               end loop;\n+            end;\n+\n          --  Case of a class-wide pool type: make a dispatching call to\n          --  Deallocate through the class-wide Deallocate_Any.\n "}, {"sha": "9d3dd171bb9b20284e39f92167ad8557700e0ae9", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -42,6 +42,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n+with Rtsfind; use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n@@ -4103,6 +4104,281 @@ package body Freeze is\n                   end loop;\n                end;\n             end if;\n+\n+            --  If the type is a simple storage pool type, then this is where\n+            --  we attempt to locate and validate its Allocate, Deallocate, and\n+            --  Storage_Size operations (the first is required, and the latter\n+            --  two are optional). We also verify that the full type for a\n+            --  private type is allowed to be a simple storage pool type.\n+\n+            if Present (Get_Rep_Pragma (E, Name_Simple_Storage_Pool))\n+              and then (Is_Base_Type (E) or else Has_Private_Declaration (E))\n+            then\n+\n+               --  If the type is marked Has_Private_Declaration, then this is\n+               --  a full type for a private type that was specified with the\n+               --  pragma Simple_Storage_Pool, and here we ensure that the\n+               --  pragma is allowed for the full type (for example, it can't\n+               --  be an array type, or a nonlimited record type).\n+\n+               if Has_Private_Declaration (E) then\n+                  if (not Is_Record_Type (E)\n+                       or else not Is_Immutably_Limited_Type (E))\n+                    and then not Is_Private_Type (E)\n+                  then\n+                     Error_Msg_Name_1 := Name_Simple_Storage_Pool;\n+\n+                     Error_Msg_N\n+                       (\"pragma% can only apply to full type that is an \" &\n+                        \"explicitly limited type\", E);\n+                  end if;\n+               end if;\n+\n+               Validate_Simple_Pool_Ops : declare\n+                  Pool_Type    : Entity_Id renames E;\n+                  Address_Type : constant Entity_Id := RTE (RE_Address);\n+                  Stg_Cnt_Type : constant Entity_Id := RTE (RE_Storage_Count);\n+\n+                  procedure Validate_Simple_Pool_Op_Formal\n+                    (Pool_Op        : Entity_Id;\n+                     Pool_Op_Formal : in out Entity_Id;\n+                     Expected_Mode  : Formal_Kind;\n+                     Expected_Type  : Entity_Id;\n+                     Formal_Name    : String;\n+                     OK_Formal      : in out Boolean);\n+                  --  Validate one formal Pool_Op_Formal of the candidate pool\n+                  --  operation Pool_Op. The formal must be of Expected_Type\n+                  --  and have mode Expected_Mode. OK_Formal will be set to\n+                  --  False if the formal doesn't match. If OK_Formal is False\n+                  --  on entry, then the formal will effectively be ignored\n+                  --  (because validation of the pool op has already failed).\n+                  --  Upon return, Pool_Op_Formal will be updated to the next\n+                  --  formal, if any.\n+\n+                  procedure Validate_Simple_Pool_Operation (Op_Name : Name_Id);\n+                  --  Search for and validate a simple pool operation with the\n+                  --  name Op_Name. If the name is Allocate, then there must be\n+                  --  exactly one such primitive operation for the simple pool\n+                  --  type. If the name is Deallocate or Storage_Size, then\n+                  --  there can be at most one such primitive operation. The\n+                  --  profile of the located primitive must conform to what\n+                  --  is expected for each operation.\n+\n+                  ------------------------------------\n+                  -- Validate_Simple_Pool_Op_Formal --\n+                  ------------------------------------\n+\n+                  procedure Validate_Simple_Pool_Op_Formal\n+                    (Pool_Op        : Entity_Id;\n+                     Pool_Op_Formal : in out Entity_Id;\n+                     Expected_Mode  : Formal_Kind;\n+                     Expected_Type  : Entity_Id;\n+                     Formal_Name    : String;\n+                     OK_Formal      : in out Boolean)\n+                  is\n+                  begin\n+                     --  If OK_Formal is False on entry, then simply ignore\n+                     --  the formal, because an earlier formal has already\n+                     --  been flagged.\n+\n+                     if not OK_Formal then\n+                        return;\n+\n+                     --  If no formal is passed in, then issue an error for a\n+                     --  missing formal.\n+\n+                     elsif not Present (Pool_Op_Formal) then\n+                        Error_Msg_NE\n+                          (\"simple storage pool op missing formal \" &\n+                           Formal_Name & \" of type&\", Pool_Op, Expected_Type);\n+                        OK_Formal := False;\n+\n+                        return;\n+                     end if;\n+\n+                     if Etype (Pool_Op_Formal) /= Expected_Type then\n+                        --  If the pool type was expected for this formal, then\n+                        --  this will not be considered a candidate operation\n+                        --  for the simple pool, so we unset OK_Formal so that\n+                        --  the op and any later formals will be ignored.\n+\n+                        if Expected_Type = Pool_Type then\n+                           OK_Formal := False;\n+\n+                           return;\n+\n+                        else\n+                           Error_Msg_NE\n+                             (\"wrong type for formal \" & Formal_Name &\n+                              \" of simple storage pool op; expected type&\",\n+                              Pool_Op_Formal, Expected_Type);\n+                        end if;\n+                     end if;\n+\n+                     --  Issue error if formal's mode is not the expected one\n+\n+                     if Ekind (Pool_Op_Formal) /= Expected_Mode then\n+                        Error_Msg_N\n+                          (\"wrong mode for formal of simple storage pool op\",\n+                           Pool_Op_Formal);\n+                     end if;\n+\n+                     --  Advance to the next formal\n+\n+                     Next_Formal (Pool_Op_Formal);\n+                  end Validate_Simple_Pool_Op_Formal;\n+\n+                  ------------------------------------\n+                  -- Validate_Simple_Pool_Operation --\n+                  ------------------------------------\n+\n+                  procedure Validate_Simple_Pool_Operation\n+                    (Op_Name : Name_Id)\n+                  is\n+                     Op       : Entity_Id;\n+                     Found_Op : Entity_Id := Empty;\n+                     Formal   : Entity_Id;\n+                     Is_OK    : Boolean;\n+\n+                  begin\n+                     pragma Assert\n+                       (Op_Name = Name_Allocate\n+                          or else Op_Name = Name_Deallocate\n+                          or else Op_Name = Name_Storage_Size);\n+\n+                     Error_Msg_Name_1 := Op_Name;\n+\n+                     --  For each homonym declared immediately in the scope\n+                     --  of the simple storage pool type, determine whether\n+                     --  the homonym is an operation of the pool type, and,\n+                     --  if so, check that its profile is as expected for\n+                     --  a simple pool operation of that name.\n+\n+                     Op := Get_Name_Entity_Id (Op_Name);\n+                     while Present (Op) loop\n+                        if Ekind_In (Op, E_Function, E_Procedure)\n+                          and then Scope (Op) = Current_Scope\n+                        then\n+                           Formal := First_Entity (Op);\n+\n+                           Is_OK := True;\n+\n+                           --  The first parameter must be of the pool type\n+                           --  in order for the operation to qualify.\n+\n+                           if Op_Name = Name_Storage_Size then\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_In_Parameter, Pool_Type,\n+                                 \"Pool\", Is_OK);\n+\n+                           else\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_In_Out_Parameter, Pool_Type,\n+                                 \"Pool\", Is_OK);\n+                           end if;\n+\n+                           --  If another operation with this name has already\n+                           --  been located for the type, then flag an error,\n+                           --  since we only allow the type to have a single\n+                           --  such primitive.\n+\n+                           if Present (Found_Op) and then Is_OK then\n+                              Error_Msg_NE\n+                                (\"only one % operation allowed for \" &\n+                                 \"simple storage pool type&\", Op, Pool_Type);\n+                           end if;\n+\n+                           --  In the case of Allocate and Deallocate, a formal\n+                           --  of type System.Address is required.\n+\n+                           if Op_Name = Name_Allocate then\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_Out_Parameter,\n+                                 Address_Type, \"Storage_Address\", Is_OK);\n+\n+                           elsif Op_Name = Name_Deallocate then\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_In_Parameter,\n+                                 Address_Type, \"Storage_Address\", Is_OK);\n+                           end if;\n+\n+                           --  In the case of Allocate and Deallocate, formals\n+                           --  of type Storage_Count are required as the third\n+                           --  and fourth parameters.\n+\n+                           if Op_Name /= Name_Storage_Size then\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_In_Parameter,\n+                                 Stg_Cnt_Type, \"Size_In_Storage_Units\", Is_OK);\n+\n+                              Validate_Simple_Pool_Op_Formal\n+                                (Op, Formal, E_In_Parameter,\n+                                 Stg_Cnt_Type, \"Alignment\", Is_OK);\n+                           end if;\n+\n+                           --  If no mismatched formals have been found (Is_OK)\n+                           --  and no excess formals are present, then this\n+                           --  operation has been validated, so record it.\n+\n+                           if not Present (Formal) and then Is_OK then\n+                              Found_Op := Op;\n+                           end if;\n+                        end if;\n+\n+                        Op := Homonym (Op);\n+                     end loop;\n+\n+                     --  There must be a valid Allocate operation for the type,\n+                     --  so issue an error if none was found.\n+\n+                     if Op_Name = Name_Allocate\n+                       and then not Present (Found_Op)\n+                     then\n+                        Error_Msg_N (\"missing % operation for simple \" &\n+                                     \"storage pool type\", Pool_Type);\n+\n+                     elsif Present (Found_Op) then\n+                        --  Simple pool operations can't be abstract\n+\n+                        if Is_Abstract_Subprogram (Found_Op) then\n+                           Error_Msg_N\n+                             (\"simple storage pool operation must not be \" &\n+                              \"abstract\", Found_Op);\n+                        end if;\n+\n+                        --  The Storage_Size operation must be a function with\n+                        --  Storage_Count as its result type.\n+\n+                        if Op_Name = Name_Storage_Size then\n+                           if Ekind (Found_Op) = E_Procedure then\n+                              Error_Msg_N\n+                                (\"% operation must be a function\", Found_Op);\n+\n+                           elsif Etype (Found_Op) /= Stg_Cnt_Type then\n+                              Error_Msg_NE\n+                                (\"wrong result type for%, expected type&\",\n+                                 Found_Op, Stg_Cnt_Type);\n+                           end if;\n+\n+                        --  Allocate and Deallocate must be procedures\n+\n+                        elsif Ekind (Found_Op) = E_Function then\n+                           Error_Msg_N\n+                             (\"% operation must be a procedure\", Found_Op);\n+                        end if;\n+                     end if;\n+                  end Validate_Simple_Pool_Operation;\n+\n+               --  Start of processing for Validate_Simple_Pool_Ops\n+\n+               begin\n+                  Validate_Simple_Pool_Operation (Name_Allocate);\n+\n+                  Validate_Simple_Pool_Operation (Name_Deallocate);\n+\n+                  Validate_Simple_Pool_Operation (Name_Storage_Size);\n+               end Validate_Simple_Pool_Ops;\n+            end if;\n          end if;\n \n          --  Now that all types from which E may depend are frozen, see if the"}, {"sha": "6402ff4e88049773d128c7bc91079c9d9ef19c35", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1230,6 +1230,7 @@ begin\n            Pragma_Shared_Passive                 |\n            Pragma_Short_Circuit_And_Or           |\n            Pragma_Short_Descriptors              |\n+           Pragma_Simple_Storage_Pool            |\n            Pragma_Storage_Size                   |\n            Pragma_Storage_Unit                   |\n            Pragma_Static_Elaboration_Desired     |"}, {"sha": "88a623d4c316d9cba4ec1f6ef3e59a97ae2205ce", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1767,10 +1767,10 @@ language and takes a list of sources as parameter.\n @table @asis\n @item @b{Library_Interface}:\n @cindex @code{Library_Interface}\n-  This attribute defines an explicit subset of the units of the project.\n-  Projects importing this library project may only \"with\" units whose sources\n-  are listed in the @code{Library_Interface}. Other sources are considered\n-  implementation units.\n+  This attribute defines an explicit subset of the units of the project. Units\n+  from projects importing this library project may only \"with\" units whose\n+  sources are listed in the @code{Library_Interface}. Other sources are\n+  considered implementation units.\n \n @smallexample @c projectfile\n @group\n@@ -1781,11 +1781,13 @@ language and takes a list of sources as parameter.\n @end smallexample\n \n @item @b{Interfaces}\n-  This attribute defnes an explicit subset of the source files of a project.\n-  It may be used as a replacement for attribute @code{Library_Interface}. For\n-  multi-language library projects, it is the only way to make the project a\n-  Stand-Alone Library project and at the same time to reduce the non Ada\n-  interfacing sources.\n+  This attribute defines an explicit subset of the source files of a project.\n+  Sources from projects importing this project, can only depend on sources from\n+  this subset. This attribute can be used on non library projects. It can also\n+  be used as a replacement for attribute @code{Library_Interface}, in which\n+  case, units have to be replaced by source files. For multi-language library\n+  projects, it is the only way to make the project a Stand-Alone Library project\n+  whose interface is not purely Ada.\n \n @item @b{Library_Standalone}:\n @cindex @code{Library_Standalone}"}, {"sha": "aa798b009732135f6902a2f54aa65783d1d8024b", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -4528,7 +4528,8 @@ package body Sem_Attr is\n       -- Storage_Pool --\n       ------------------\n \n-      when Attribute_Storage_Pool => Storage_Pool :\n+      when Attribute_Storage_Pool        |\n+           Attribute_Simple_Storage_Pool => Storage_Pool :\n       begin\n          Check_E0;\n \n@@ -4546,7 +4547,38 @@ package body Sem_Attr is\n                Set_Entity (N, RTE (RE_Global_Pool_Object));\n             end if;\n \n-            Set_Etype (N, Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n+            if Attr_Id = Attribute_Storage_Pool then\n+               if Present (Get_Rep_Pragma (Etype (Entity (N)),\n+                                           Name_Simple_Storage_Pool))\n+               then\n+                  Error_Msg_Name_1 := Aname;\n+                  Error_Msg_N (\"cannot use % attribute for type with simple \" &\n+                               \"storage pool?\", N);\n+                  Error_Msg_N\n+                     (\"\\Program_Error will be raised at run time?\", N);\n+\n+                  Rewrite\n+                    (N, Make_Raise_Program_Error\n+                          (Sloc (N), Reason => PE_Explicit_Raise));\n+               end if;\n+\n+               Set_Etype (N, Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n+\n+            --  In the Simple_Storage_Pool case, verify that the pool entity is\n+            --  actually of a simple storage pool type, and set the attribute's\n+            --  type to the pool object's type.\n+\n+            else\n+               if not Present (Get_Rep_Pragma (Etype (Entity (N)),\n+                                               Name_Simple_Storage_Pool))\n+               then\n+                  Error_Attr_P\n+                    (\"cannot use % attribute for type without simple \" &\n+                     \"storage pool\");\n+               end if;\n+\n+               Set_Etype (N, Etype (Entity (N)));\n+            end if;\n \n             --  Validate_Remote_Access_To_Class_Wide_Type for attribute\n             --  Storage_Pool since this attribute is not defined for such\n@@ -7931,6 +7963,7 @@ package body Sem_Attr is\n            Attribute_Priority                   |\n            Attribute_Read                       |\n            Attribute_Result                     |\n+           Attribute_Simple_Storage_Pool        |\n            Attribute_Storage_Pool               |\n            Attribute_Storage_Size               |\n            Attribute_Storage_Unit               |"}, {"sha": "cbb86c8efe0e9caa76588321f2e9e885adfd4e19", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -486,11 +486,22 @@ package body Sem_Cat is\n    ---------------------------\n \n    function In_Preelaborated_Unit return Boolean is\n-      Unit_Entity : constant Entity_Id := Current_Scope;\n+      Unit_Entity : Entity_Id := Current_Scope;\n       Unit_Kind   : constant Node_Kind :=\n                       Nkind (Unit (Cunit (Current_Sem_Unit)));\n \n    begin\n+      --  If evaluating actuals for a child unit instantiation, then ignore\n+      --  the preelaboration status of the parent; use the child instead.\n+\n+      if Is_Compilation_Unit (Unit_Entity)\n+        and then Unit_Kind in N_Generic_Instantiation\n+        and then not In_Same_Source_Unit (Unit_Entity,\n+                                          Cunit (Current_Sem_Unit))\n+      then\n+         Unit_Entity := Cunit_Entity (Current_Sem_Unit);\n+      end if;\n+\n       --  There are no constraints on the body of Remote_Call_Interface or\n       --  Remote_Types packages.\n "}, {"sha": "5fe669d51f24aa97f756d25c4f62704d09991b7f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -1064,23 +1064,24 @@ package body Sem_Ch13 is\n \n                --  Aspects corresponding to attribute definition clauses\n \n-               when Aspect_Address        |\n-                    Aspect_Alignment      |\n-                    Aspect_Bit_Order      |\n-                    Aspect_Component_Size |\n-                    Aspect_External_Tag   |\n-                    Aspect_Input          |\n-                    Aspect_Machine_Radix  |\n-                    Aspect_Object_Size    |\n-                    Aspect_Output         |\n-                    Aspect_Read           |\n-                    Aspect_Size           |\n-                    Aspect_Small          |\n-                    Aspect_Storage_Pool   |\n-                    Aspect_Storage_Size   |\n-                    Aspect_Stream_Size    |\n-                    Aspect_Value_Size     |\n-                    Aspect_Write          =>\n+               when Aspect_Address             |\n+                    Aspect_Alignment           |\n+                    Aspect_Bit_Order           |\n+                    Aspect_Component_Size      |\n+                    Aspect_External_Tag        |\n+                    Aspect_Input               |\n+                    Aspect_Machine_Radix       |\n+                    Aspect_Object_Size         |\n+                    Aspect_Output              |\n+                    Aspect_Read                |\n+                    Aspect_Size                |\n+                    Aspect_Small               |\n+                    Aspect_Simple_Storage_Pool |\n+                    Aspect_Storage_Pool        |\n+                    Aspect_Storage_Size        |\n+                    Aspect_Stream_Size         |\n+                    Aspect_Value_Size          |\n+                    Aspect_Write               =>\n \n                   --  Construct the attribute definition clause\n \n@@ -2210,13 +2211,14 @@ package body Sem_Ch13 is\n             --  legality, e.g. failing to provide a stream attribute for a\n             --  type may make a program illegal.\n \n-            when Attribute_External_Tag |\n-                 Attribute_Input        |\n-                 Attribute_Output       |\n-                 Attribute_Read         |\n-                 Attribute_Storage_Pool |\n-                 Attribute_Storage_Size |\n-                 Attribute_Write        =>\n+            when Attribute_External_Tag        |\n+                 Attribute_Input               |\n+                 Attribute_Output              |\n+                 Attribute_Read                |\n+                 Attribute_Simple_Storage_Pool |\n+                 Attribute_Storage_Pool        |\n+                 Attribute_Storage_Size        |\n+                 Attribute_Write               =>\n                null;\n \n             --  Other cases are errors (\"attribute& cannot be set with\n@@ -3163,7 +3165,7 @@ package body Sem_Ch13 is\n \n          --  Storage_Pool attribute definition clause\n \n-         when Attribute_Storage_Pool => Storage_Pool : declare\n+         when Attribute_Storage_Pool | Attribute_Simple_Storage_Pool => declare\n             Pool : Entity_Id;\n             T    : Entity_Id;\n \n@@ -3194,8 +3196,24 @@ package body Sem_Ch13 is\n                return;\n             end if;\n \n-            Analyze_And_Resolve\n-              (Expr, Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n+            if Id = Attribute_Storage_Pool then\n+               Analyze_And_Resolve\n+                 (Expr, Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n+\n+            --  In the Simple_Storage_Pool case, we allow a variable of any\n+            --  Simple_Storage_Pool type, so we Resolve without imposing an\n+            --  expected type.\n+\n+            else\n+               Analyze_And_Resolve (Expr);\n+\n+               if not Present (Get_Rep_Pragma\n+                                 (Etype (Expr), Name_Simple_Storage_Pool))\n+               then\n+                  Error_Msg_N\n+                    (\"expression must be of a simple storage pool type\", Expr);\n+               end if;\n+            end if;\n \n             if not Denotes_Variable (Expr) then\n                Error_Msg_N (\"storage pool must be a variable\", Expr);\n@@ -3280,7 +3298,7 @@ package body Sem_Ch13 is\n                Error_Msg_N (\"incorrect reference to a Storage Pool\", Expr);\n                return;\n             end if;\n-         end Storage_Pool;\n+         end;\n \n          ------------------\n          -- Storage_Size --\n@@ -6147,6 +6165,13 @@ package body Sem_Ch13 is\n          when Aspect_Small =>\n             T := Universal_Real;\n \n+         --  For a simple storage pool, we have to retrieve the type of the\n+         --  pool object associated with the aspect's corresponding attribute\n+         --  definition clause.\n+\n+         when Aspect_Simple_Storage_Pool =>\n+            T := Etype (Expression (Aspect_Rep_Item (ASN)));\n+\n          when Aspect_Storage_Pool =>\n             T := Class_Wide_Type (RTE (RE_Root_Storage_Pool));\n "}, {"sha": "dda30af7e1c810a159871f763deac21ee02b8c07", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -2664,11 +2664,14 @@ package body Sem_Ch8 is\n \n          if not Is_Actual\n            and then (Old_S = New_S\n-                      or else (Nkind (Nam) /= N_Expanded_Name\n-                        and then Chars (Old_S) = Chars (New_S))\n-                      or else (Nkind (Nam) = N_Expanded_Name\n-                        and then Entity (Prefix (Nam)) = Current_Scope\n-                        and then Chars (Selector_Name (Nam)) = Chars (New_S)))\n+                      or else\n+                        (Nkind (Nam) /= N_Expanded_Name\n+                          and then Chars (Old_S) = Chars (New_S))\n+                      or else\n+                        (Nkind (Nam) = N_Expanded_Name\n+                          and then Entity (Prefix (Nam)) = Current_Scope\n+                          and then\n+                            Chars (Selector_Name (Nam)) = Chars (New_S)))\n          then\n             Error_Msg_N (\"subprogram cannot rename itself\", N);\n          end if;"}, {"sha": "3268c67b1f942852dc57cdb8b3d56a5fc49a20df", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -13150,6 +13150,65 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Short_Descriptors := True;\n \n+         -------------------------\n+         -- Simple_Storage_Pool --\n+         -------------------------\n+\n+         --  pragma Simple_Storage_Pool (type_LOCAL_NAME);\n+\n+         when Pragma_Simple_Storage_Pool => Simple_Storage_Pool : declare\n+               Type_Id : Node_Id;\n+               Typ     : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_Arg_Is_Library_Level_Local_Name (Arg1);\n+\n+            Type_Id := Get_Pragma_Arg (Arg1);\n+            Find_Type (Type_Id);\n+            Typ := Entity (Type_Id);\n+\n+            if Typ = Any_Type then\n+               return;\n+            end if;\n+\n+            --  We require the pragma to apply to a type declared in a package\n+            --  declaration, but not (immediately) within a package body.\n+\n+            if Ekind (Current_Scope) /= E_Package\n+              or else In_Package_Body (Current_Scope)\n+            then\n+               Error_Pragma\n+                 (\"pragma% can only apply to type declared immediately \" &\n+                  \"within a package declaration\");\n+            end if;\n+\n+            --  A simple storage pool type must be an immutably limited record\n+            --  or private type. If the pragma is given for a private type,\n+            --  the full type is similarly restricted (which is checked later\n+            --  in Freeze_Entity).\n+\n+            if Is_Record_Type (Typ)\n+              and then not Is_Immutably_Limited_Type (Typ)\n+            then\n+               Error_Pragma\n+                 (\"pragma% can only apply to explicitly limited record type\");\n+\n+            elsif Is_Private_Type (Typ) and then not Is_Limited_Type (Typ) then\n+               Error_Pragma\n+                 (\"pragma% can only apply to a private type that is limited\");\n+\n+            elsif not Is_Record_Type (Typ)\n+              and then not Is_Private_Type (Typ)\n+            then\n+               Error_Pragma\n+                 (\"pragma% can only apply to limited record or private type\");\n+            end if;\n+\n+            Record_Rep_Item (Typ, N);\n+         end Simple_Storage_Pool;\n+\n          ----------------------\n          -- Source_File_Name --\n          ----------------------\n@@ -15117,6 +15176,7 @@ package body Sem_Prag is\n       Pragma_Shared                         => -1,\n       Pragma_Shared_Passive                 => -1,\n       Pragma_Short_Descriptors              =>  0,\n+      Pragma_Simple_Storage_Pool            =>  0,\n       Pragma_Source_File_Name               => -1,\n       Pragma_Source_File_Name_Project       => -1,\n       Pragma_Source_Reference               => -1,"}, {"sha": "7c8de23f943560d9ee8a3a3082b0f8a087b2c20c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -4228,6 +4228,31 @@ package body Sem_Res is\n             Wrong_Type (Expression (E), Etype (E));\n          end if;\n \n+         --  Calls to build-in-place functions are not currently supported in\n+         --  allocators for access types associated with a simple storage pool.\n+         --  Supporting such allocators may require passing additional implicit\n+         --  parameters to build-in-place functions (or a significant revision\n+         --  of the current b-i-p implementation to unify the handling for\n+         --  multiple kinds of storage pools). ???\n+\n+         if Is_Immutably_Limited_Type (Desig_T)\n+           and then Nkind (Expression (E)) = N_Function_Call\n+         then\n+            declare\n+               Pool : constant Entity_Id\n+                        := Associated_Storage_Pool (Root_Type (Typ));\n+            begin\n+               if Present (Pool)\n+                 and then Present (Get_Rep_Pragma\n+                                     (Etype (Pool), Name_Simple_Storage_Pool))\n+               then\n+                  Error_Msg_N\n+                    (\"limited function calls not yet supported in simple \" &\n+                     \"storage pool allocators\", Expression (E));\n+               end if;\n+            end;\n+         end if;\n+\n          --  A special accessibility check is needed for allocators that\n          --  constrain access discriminants. The level of the type of the\n          --  expression used to constrain an access discriminant cannot be"}, {"sha": "14376bbfa08ab2fb47f7bc893227555f549e5c0b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -7138,18 +7138,14 @@ package body Sem_Util is\n       --  is fully initialized.\n \n       if Is_Scalar_Type (Typ) then\n-         return\n-           Ada_Version >= Ada_2012\n-             and then Has_Default_Aspect (Typ);\n+         return Ada_Version >= Ada_2012 and then Has_Default_Aspect (Typ);\n \n       elsif Is_Access_Type (Typ) then\n          return True;\n \n       elsif Is_Array_Type (Typ) then\n          if Is_Fully_Initialized_Type (Component_Type (Typ))\n-           or else\n-             (Ada_Version >= Ada_2012\n-                and then Has_Default_Aspect (Typ))\n+           or else (Ada_Version >= Ada_2012 and then Has_Default_Aspect (Typ))\n          then\n             return True;\n          end if;"}, {"sha": "f49e75b5dc6707f1d4005c72ba518453abfb87a0", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -217,6 +217,8 @@ package body Snames is\n          return Pragma_Priority;\n       elsif N = Name_Relative_Deadline then\n          return Pragma_Relative_Deadline;\n+      elsif N = Name_Simple_Storage_Pool then\n+         return Pragma_Simple_Storage_Pool;\n       elsif N = Name_Storage_Size then\n          return Pragma_Storage_Size;\n       elsif N = Name_Storage_Unit then\n@@ -414,6 +416,7 @@ package body Snames is\n         or else N = Name_Interface\n         or else N = Name_Relative_Deadline\n         or else N = Name_Priority\n+        or else N = Name_Simple_Storage_Pool\n         or else N = Name_Storage_Size\n         or else N = Name_Storage_Unit;\n    end Is_Pragma_Name;"}, {"sha": "3bf9f12668c7a490f36c48db4615b9f194f42952", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8551b5f9cf959cc54c8277f3ddbd7df1842d154/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a8551b5f9cf959cc54c8277f3ddbd7df1842d154", "patch": "@@ -909,6 +909,7 @@ package Snames is\n    Name_Elab_Body                      : constant Name_Id := N + $; -- GNAT\n    Name_Elab_Spec                      : constant Name_Id := N + $; -- GNAT\n    Name_Elab_Subp_Body                 : constant Name_Id := N + $; -- GNAT\n+   Name_Simple_Storage_Pool            : constant Name_Id := N + $; -- GNAT\n    Name_Storage_Pool                   : constant Name_Id := N + $;\n \n    --  These attributes are the ones that return types\n@@ -1459,6 +1460,7 @@ package Snames is\n       Attribute_Elab_Body,\n       Attribute_Elab_Spec,\n       Attribute_Elab_Subp_Body,\n+      Attribute_Simple_Storage_Pool,\n       Attribute_Storage_Pool,\n \n       --  Type attributes\n@@ -1730,6 +1732,7 @@ package Snames is\n       Pragma_Fast_Math,\n       Pragma_Interface,\n       Pragma_Priority,\n+      Pragma_Simple_Storage_Pool,\n       Pragma_Storage_Size,\n       Pragma_Storage_Unit,\n "}]}