{"sha": "a368a2fabba4c10b491e03316dde72f41efea80b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2OGEyZmFiYmE0YzEwYjQ5MWUwMzMxNmRkZTcyZjQxZWZlYTgwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-25T08:30:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-25T08:30:36Z"}, "message": "flow.c (find_sub_basic_blocks): Fix handling of the last BB in the sequence.\n\n        * flow.c (find_sub_basic_blocks): Fix handling of the last BB in\n        the sequence.\n        (make_edges): New argument update_p; populate the edge cache if set.\n        (find_basic_blocks): Update make_edges invocation.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r44335", "tree": {"sha": "42306c38f625fe102c4718ab277974315c3ef6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42306c38f625fe102c4718ab277974315c3ef6c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a368a2fabba4c10b491e03316dde72f41efea80b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a368a2fabba4c10b491e03316dde72f41efea80b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a368a2fabba4c10b491e03316dde72f41efea80b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a368a2fabba4c10b491e03316dde72f41efea80b/comments", "author": null, "committer": null, "parents": [{"sha": "d38cd8ae50fc7c9f174ce0db55582b7349b4cef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38cd8ae50fc7c9f174ce0db55582b7349b4cef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38cd8ae50fc7c9f174ce0db55582b7349b4cef1"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "e4cd906b7cdfee1b8cdfbc360d1775f69c45c85c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a368a2fabba4c10b491e03316dde72f41efea80b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a368a2fabba4c10b491e03316dde72f41efea80b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a368a2fabba4c10b491e03316dde72f41efea80b", "patch": "@@ -1,3 +1,11 @@\n+2001-07-25  Jan Hubicka  <jh@suse.cz>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c (find_sub_basic_blocks): Fix handling of the last BB in\n+\tthe sequence.\n+\t(make_edges): New argument update_p; populate the edge cache if set.\n+\t(find_basic_blocks): Update make_edges invocation.\n+\n 2001-07-24  Joel Sherrill <joel@OARcorp.com>\n \n \t* config/i960/i960.h (CPP_SPEC): Define _SOFT_FLOAT for -msoft-float."}, {"sha": "67a2db559f254ff7aac7c25e8c6ecfb7a9309ac0", "filename": "gcc/flow.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a368a2fabba4c10b491e03316dde72f41efea80b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a368a2fabba4c10b491e03316dde72f41efea80b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=a368a2fabba4c10b491e03316dde72f41efea80b", "patch": "@@ -374,7 +374,7 @@ static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n static rtx find_label_refs\t\tPARAMS ((rtx, rtx));\n-static void make_edges\t\t\tPARAMS ((rtx, int, int));\n+static void make_edges\t\t\tPARAMS ((rtx, int, int, int));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n@@ -540,7 +540,7 @@ find_basic_blocks (f, nregs, file)\n   compute_bb_for_insn (max_uid);\n \n   /* Discover the edges of our cfg.  */\n-  make_edges (label_value_list, 0, n_basic_blocks - 1);\n+  make_edges (label_value_list, 0, n_basic_blocks - 1, 0);\n \n   /* Do very simple cleanup now, for the benefit of code that runs between\n      here and cleanup_cfg, e.g. thread_prologue_and_epilogue_insns.  */\n@@ -709,8 +709,6 @@ find_sub_basic_blocks (bb)\n   rtx insn = bb->head;\n   rtx end = bb->end;\n   rtx jump_insn = NULL_RTX;\n-  int created = 0;\n-  int barrier = 0;\n   edge falltru = 0;\n   basic_block first_bb = bb;\n \n@@ -729,7 +727,6 @@ find_sub_basic_blocks (bb)\n \tcase BARRIER:\n \t  if (!jump_insn)\n \t    abort ();\n-\t  barrier = 1;\n \t  break;\n \t/* On code label, split current basic block.  */\n \tcase CODE_LABEL:\n@@ -738,9 +735,7 @@ find_sub_basic_blocks (bb)\n \t    bb->end = jump_insn;\n \t  bb = falltru->dest;\n \t  remove_edge (falltru);\n-\t  barrier = 0;\n \t  jump_insn = 0;\n-\t  created = 1;\n \t  if (LABEL_ALTERNATE_NAME (insn))\n \t    make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \t  break;\n@@ -773,10 +768,11 @@ find_sub_basic_blocks (bb)\n       insn = NEXT_INSN (insn);\n     }\n \n-  /* In case we've got barrier at the end of new insn stream, put it\n-     outside basic block.  */\n-  if (GET_CODE (bb->end) == BARRIER)\n-    bb->end = PREV_INSN (bb->end);\n+  /* In case expander replaced normal insn by sequence terminating by\n+     return and barrier, or possibly other sequence not behaving like\n+     ordinary jump, we need to take care and move basic block boundary.  */\n+  if (jump_insn && GET_CODE (bb->end) != JUMP_INSN)\n+    bb->end = jump_insn;\n \n   /* We've possibly replaced the conditional jump by conditional jump\n      followed by cleanup at fallthru edge, so the outgoing edges may\n@@ -785,7 +781,7 @@ find_sub_basic_blocks (bb)\n \n   /* Now re-scan and wire in all edges.  This expect simple (conditional)\n      jumps at the end of each new basic blocks.  */\n-  make_edges (NULL, first_bb->index, bb->index - 1);\n+  make_edges (NULL, first_bb->index, bb->index, 1);\n }\n \n /* Find all basic blocks of the function whose first insn is F.\n@@ -1160,9 +1156,9 @@ clear_edges ()\n    the list of exception regions active at the end of the basic block.  */\n \n static void\n-make_edges (label_value_list, min, max)\n+make_edges (label_value_list, min, max, update_p)\n      rtx label_value_list;\n-     int min, max;\n+     int min, max, update_p;\n {\n   int i;\n   sbitmap *edge_cache = NULL;\n@@ -1177,6 +1173,15 @@ make_edges (label_value_list, min, max)\n     {\n       edge_cache = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n       sbitmap_vector_zero (edge_cache, n_basic_blocks);\n+\n+      if (update_p)\n+\tfor (i = min; i <= max; ++i)\n+\t  {\n+\t    edge e;\n+\t    for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n+\t      if (e->dest != EXIT_BLOCK_PTR)\n+\t        SET_BIT (edge_cache[i], e->dest->index);\n+\t  }\n     }\n \n   /* By nature of the way these get numbered, block 0 is always the entry.  */"}]}