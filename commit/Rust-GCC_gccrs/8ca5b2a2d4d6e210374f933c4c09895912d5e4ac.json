{"sha": "8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhNWIyYTJkNGQ2ZTIxMDM3NGY5MzNjNGMwOTg5NTkxMmQ1ZTRhYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-05-02T20:03:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-05-02T20:03:38Z"}, "message": "re PR c++/26943 ([gomp] firstprivate + lastprivate uses inefficient barrier)\n\n\tPR c++/26943\n\t* omp-low.c (maybe_lookup_decl_in_outer_ctx): New function.\n\t(build_outer_var_ref): Use maybe_lookup_decl_in_outer_ctx\n\tto find if var will be a global variable even in the nested context.\n\t(omp_copy_decl): Only check for global variable at the end, it might\n\tbe overridden in outer contexts.\n\t(scan_sharing_clauses): For global variables don't create a field.\n\t(lower_rec_input_clauses): Do nothing for global shared variables.\n\tEmit a barrier at the end of ILIST if there were any decls in both\n\tfirstprivate and lastprivate clauses.\n\t(lower_send_clauses): Do nothing for global variables except for\n\tCOPYIN.\n\n\t* testsuite/libgomp.c/pr26943-1.c: New test.\n\t* testsuite/libgomp.c/pr26943-2.c: New test.\n\t* testsuite/libgomp.c/pr26943-3.c: New test.\n\t* testsuite/libgomp.c/pr26943-4.c: New test.\n\t* testsuite/libgomp.c++/pr27337.C: Remove barrier.\n\t* testsuite/libgomp.c++/pr26943.C: New test.\n\nFrom-SVN: r113483", "tree": {"sha": "eb02e1dd8220b3599be8ae1486c225f960b5ccf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb02e1dd8220b3599be8ae1486c225f960b5ccf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3428e070102b16998dacc499781306137b9f787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3428e070102b16998dacc499781306137b9f787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3428e070102b16998dacc499781306137b9f787"}], "stats": {"total": 346, "additions": 330, "deletions": 16}, "files": [{"sha": "162af2fe98cad0cc6e46e8684583dcbef012cf4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -1,3 +1,18 @@\n+2006-05-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/26943\n+\t* omp-low.c (maybe_lookup_decl_in_outer_ctx): New function.\n+\t(build_outer_var_ref): Use maybe_lookup_decl_in_outer_ctx\n+\tto find if var will be a global variable even in the nested context.\n+\t(omp_copy_decl): Only check for global variable at the end, it might\n+\tbe overridden in outer contexts.\n+\t(scan_sharing_clauses): For global variables don't create a field.\n+\t(lower_rec_input_clauses): Do nothing for global shared variables.\n+\tEmit a barrier at the end of ILIST if there were any decls in both\n+\tfirstprivate and lastprivate clauses.\n+\t(lower_send_clauses): Do nothing for global variables except for\n+\tCOPYIN.\n+\n 2006-05-02  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* tree.c (unsigned_type_for, signed_type_for): Make sure a type"}, {"sha": "2de13eccdec4f31fc2c968f358e756ad5e3e6b7c", "filename": "gcc/omp-low.c", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -112,6 +112,8 @@ struct omp_region *root_omp_region;\n \n static void scan_omp (tree *, omp_context *);\n static void lower_omp (tree *, omp_context *);\n+static tree lookup_decl_in_outer_ctx (tree, omp_context *);\n+static tree maybe_lookup_decl_in_outer_ctx (tree, omp_context *);\n \n /* Find an OpenMP clause of type KIND within CLAUSES.  */\n \n@@ -560,7 +562,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n {\n   tree x;\n \n-  if (is_global_var (var))\n+  if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx)))\n     x = var;\n   else if (is_variable_sized (var))\n     {\n@@ -674,9 +676,6 @@ omp_copy_decl (tree var, copy_body_data *cb)\n   omp_context *ctx = (omp_context *) cb;\n   tree new_var;\n \n-  if (is_global_var (var) || decl_function_context (var) != ctx->cb.src_fn)\n-    return var;\n-\n   if (TREE_CODE (var) == LABEL_DECL)\n     {\n       new_var = create_artificial_label ();\n@@ -695,6 +694,9 @@ omp_copy_decl (tree var, copy_body_data *cb)\n \treturn new_var;\n     }\n \n+  if (is_global_var (var) || decl_function_context (var) != ctx->cb.src_fn)\n+    return var;\n+\n   return error_mark_node;\n }\n \n@@ -937,6 +939,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  gcc_assert (!is_variable_sized (decl));\n \t  by_ref = use_pointer_for_field (decl, true);\n+\t  /* Global variables don't need to be copied,\n+\t     the receiver side will use them directly.  */\n+\t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n+\t    break;\n \t  if (! TREE_READONLY (decl)\n \t      || TREE_ADDRESSABLE (decl)\n \t      || by_ref\n@@ -963,7 +969,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tdo_private:\n \t  if (is_variable_sized (decl))\n \t    break;\n-\t  else if (is_parallel_ctx (ctx))\n+\t  else if (is_parallel_ctx (ctx)\n+\t\t   && ! is_global_var (maybe_lookup_decl_in_outer_ctx (decl,\n+\t\t\t\t\t\t\t\t       ctx)))\n \t    {\n \t      by_ref = use_pointer_for_field (decl, false);\n \t      install_var_field (decl, by_ref, ctx);\n@@ -1029,7 +1037,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \n \tcase OMP_CLAUSE_SHARED:\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  fixup_remapped_decl (decl, ctx, false);\n+\t  if (! is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n+\t    fixup_remapped_decl (decl, ctx, false);\n \t  break;\n \n \tcase OMP_CLAUSE_COPYPRIVATE:\n@@ -1415,6 +1424,23 @@ lookup_decl_in_outer_ctx (tree decl, omp_context *ctx)\n }\n \n \n+/* Similar to lookup_decl_in_outer_ctx, but return DECL if not found\n+   in outer contexts.  */\n+\n+static tree\n+maybe_lookup_decl_in_outer_ctx (tree decl, omp_context *ctx)\n+{\n+  tree t = NULL;\n+  omp_context *up;\n+\n+  if (ctx->is_nested)\n+    for (up = ctx->outer, t = NULL; up && t == NULL; up = up->outer)\n+      t = maybe_lookup_decl (decl, up);\n+\n+  return t ? t : decl;\n+}\n+\n+\n /* Construct the initialization value for reduction CLAUSE.  */\n \n tree\n@@ -1493,6 +1519,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n   tree_stmt_iterator diter;\n   tree c, dtor, copyin_seq, x, args, ptr;\n   bool copyin_by_ref = false;\n+  bool lastprivate_firstprivate = false;\n   int pass;\n \n   *dlist = alloc_stmt_list ();\n@@ -1518,14 +1545,22 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t\tcontinue;\n \t      break;\n \t    case OMP_CLAUSE_SHARED:\n+\t      if (maybe_lookup_decl (OMP_CLAUSE_DECL (c), ctx) == NULL)\n+\t\t{\n+\t\t  gcc_assert (is_global_var (OMP_CLAUSE_DECL (c)));\n+\t\t  continue;\n+\t\t}\n \t    case OMP_CLAUSE_FIRSTPRIVATE:\n \t    case OMP_CLAUSE_COPYIN:\n \t    case OMP_CLAUSE_REDUCTION:\n \t      break;\n \t    case OMP_CLAUSE_LASTPRIVATE:\n-\t      if (pass != 0\n-\t\t  && OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n-\t\tcontinue;\n+\t      if (OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n+\t\t{\n+\t\t  lastprivate_firstprivate = true;\n+\t\t  if (pass != 0)\n+\t\t    continue;\n+\t\t}\n \t      break;\n \t    default:\n \t      continue;\n@@ -1611,6 +1646,9 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t  switch (OMP_CLAUSE_CODE (c))\n \t    {\n \t    case OMP_CLAUSE_SHARED:\n+\t      /* Shared global vars are just accessed directly.  */\n+\t      if (is_global_var (new_var))\n+\t\tbreak;\n \t      /* Set up the DECL_VALUE_EXPR for shared variables now.  This\n \t\t needs to be delayed until after fixup_child_record_type so\n \t\t that we get the correct type during the dereference.  */\n@@ -1700,8 +1738,10 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \n   /* If any copyin variable is passed by reference, we must ensure the\n      master thread doesn't modify it before it is copied over in all\n-     threads.  */\n-  if (copyin_by_ref)\n+     threads.  Similarly for variables in both firstprivate and\n+     lastprivate clauses we need to ensure the lastprivate copying\n+     happens after firstprivate copying in all threads.  */\n+  if (copyin_by_ref || lastprivate_firstprivate)\n     build_omp_barrier (ilist);\n }\n \n@@ -1919,6 +1959,9 @@ lower_send_clauses (tree clauses, tree *ilist, tree *olist, omp_context *ctx)\n       if (ctx->is_nested)\n \tvar = lookup_decl_in_outer_ctx (val, ctx);\n \n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_COPYIN\n+\t  && is_global_var (var))\n+\tcontinue;\n       if (is_variable_sized (val))\n \tcontinue;\n       by_ref = use_pointer_for_field (val, false);"}, {"sha": "76d5631106fb89dc4429d2c3049d91ca71833bf5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -1,3 +1,13 @@\n+2006-05-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/26943\n+\t* testsuite/libgomp.c/pr26943-1.c: New test.\n+\t* testsuite/libgomp.c/pr26943-2.c: New test.\n+\t* testsuite/libgomp.c/pr26943-3.c: New test.\n+\t* testsuite/libgomp.c/pr26943-4.c: New test.\n+\t* testsuite/libgomp.c++/pr27337.C: Remove barrier.\n+\t* testsuite/libgomp.c++/pr26943.C: New test.\n+\n 2006-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/27337"}, {"sha": "07b7b5dbf74cb14592491f0ed57347c8d6b3551c", "filename": "libgomp/testsuite/libgomp.c++/pr26943.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr26943.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr26943.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr26943.C?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -0,0 +1,62 @@\n+// PR c++/26943\n+// { dg-do run }\n+\n+#include <assert.h>\n+#include <unistd.h>\n+\n+struct S\n+{\n+  public:\n+    int x;\n+    S () : x(-1) { }\n+    S (const S &);\n+    S& operator= (const S &);\n+    void test ();\n+};\n+\n+static volatile int hold;\n+\n+S::S (const S &s)\n+{\n+  #pragma omp master\n+    sleep (1);\n+\n+  assert (s.x == -1);\n+  x = 0;\n+}\n+\n+S&\n+S::operator= (const S& s)\n+{\n+  assert (s.x == 1);\n+  x = 2;\n+  return *this;\n+}\n+\n+void\n+S::test ()\n+{\n+  assert (x == 0);\n+  x = 1;\n+}\n+\n+static S x;\n+\n+void\n+foo ()\n+{\n+  #pragma omp sections firstprivate(x) lastprivate(x)\n+  {\n+    x.test();\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp parallel num_threads(2)\n+    foo();\n+\n+  assert (x.x == 2);\n+  return 0;\n+}"}, {"sha": "6db2465ec3ad5c5c2251a5bd86c4263032851d0c", "filename": "libgomp/testsuite/libgomp.c++/pr27337.C", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr27337.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr27337.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr27337.C?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -48,11 +48,7 @@ foo ()\n #pragma omp parallel for firstprivate (ret) lastprivate (ret) \\\n \t\t\t schedule (static, 1) num_threads (4)\n   for (i = 0; i < 4; i++)\n-    {\n-      ret.i += omp_get_thread_num ();\n-      // FIXME: The following barrier should be unnecessary.\n-#pragma omp barrier\n-    }\n+    ret.i += omp_get_thread_num ();\n \n   return ret;\n }"}, {"sha": "86c43f04bc9897e6f8b59f6e2b7867fd3e066635", "filename": "libgomp/testsuite/libgomp.c/pr26943-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-1.c?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -0,0 +1,24 @@\n+/* PR c++/26943 */\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+extern void omp_set_dynamic (int);\n+int n = 6;\n+\n+int\n+main (void)\n+{\n+  int i, x = 0;\n+  omp_set_dynamic (0);\n+#pragma omp parallel for num_threads (16) firstprivate (n) lastprivate (n) \\\n+\t\t\t schedule (static, 1) reduction (+: x)\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (n != 6)\n+\t++x;\n+      n = i;\n+    }\n+  if (x || n != 15)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "778048492f65fa9b9fdd213792783aa2aab14deb", "filename": "libgomp/testsuite/libgomp.c/pr26943-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -0,0 +1,47 @@\n+/* PR c++/26943 */\n+/* { dg-do run } */\n+\n+extern int omp_set_dynamic (int);\n+extern void abort (void);\n+\n+int a = 8, b = 12, c = 16, d = 20, j = 0;\n+char e[10] = \"a\", f[10] = \"b\", g[10] = \"c\", h[10] = \"d\";\n+\n+int\n+main (void)\n+{\n+  int i;\n+  omp_set_dynamic (0);\n+#pragma omp parallel for shared (a, e) firstprivate (b, f) \\\n+\t\t\t lastprivate (c, g) private (d, h) \\\n+\t\t\t schedule (static, 1) num_threads (4) \\\n+\t\t\t reduction (+:j)\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (a != 8 || b != 12 || e[0] != 'a' || f[0] != 'b')\n+\tj++;\n+#pragma omp barrier\n+#pragma omp atomic\n+      a += i;\n+      b += i;\n+      c = i;\n+      d = i;\n+#pragma omp atomic\n+      e[0] += i;\n+      f[0] += i;\n+      g[0] = 'g' + i;\n+      h[0] = 'h' + i;\n+#pragma omp barrier\n+      if (a != 8 + 6 || b != 12 + i || c != i || d != i)\n+\tj += 8;\n+      if (e[0] != 'a' + 6 || f[0] != 'b' + i || g[0] != 'g' + i)\n+\tj += 64;\n+      if (h[0] != 'h' + i)\n+\tj += 512;\n+    }\n+  if (j || a != 8 + 6 || b != 12 || c != 3 || d != 20)\n+    abort ();\n+  if (e[0] != 'a' + 6 || f[0] != 'b' || g[0] != 'g' + 3 || h[0] != 'd')\n+    abort ();\n+  return 0;\n+}"}, {"sha": "be93cb479d13752c2d2d0dcf12d4b709d59f75d1", "filename": "libgomp/testsuite/libgomp.c/pr26943-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -0,0 +1,56 @@\n+/* PR c++/26943 */\n+/* { dg-do run } */\n+\n+extern int omp_set_dynamic (int);\n+extern int omp_get_thread_num (void);\n+extern void abort (void);\n+\n+int a = 8, b = 12, c = 16, d = 20, j = 0, l = 0;\n+char e[10] = \"a\", f[10] = \"b\", g[10] = \"c\", h[10] = \"d\";\n+volatile int k;\n+\n+int\n+main (void)\n+{\n+  int i;\n+  omp_set_dynamic (0);\n+  omp_set_nested (1);\n+#pragma omp parallel num_threads (2) reduction (+:l)\n+  if (k == omp_get_thread_num ())\n+    {\n+#pragma omp parallel for shared (a, e) firstprivate (b, f) \\\n+\t\t\t lastprivate (c, g) private (d, h) \\\n+\t\t\t schedule (static, 1) num_threads (4) \\\n+\t\t\t reduction (+:j)\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (a != 8 || b != 12 || e[0] != 'a' || f[0] != 'b')\n+\t    j++;\n+#pragma omp barrier\n+#pragma omp atomic\n+\t  a += i;\n+\t  b += i;\n+\t  c = i;\n+\t  d = i;\n+#pragma omp atomic\n+\t  e[0] += i;\n+\t  f[0] += i;\n+\t  g[0] = 'g' + i;\n+\t  h[0] = 'h' + i;\n+#pragma omp barrier\n+\t  if (a != 8 + 6 || b != 12 + i || c != i || d != i)\n+\t    j += 8;\n+\t  if (e[0] != 'a' + 6 || f[0] != 'b' + i || g[0] != 'g' + i)\n+\t    j += 64;\n+\t  if (h[0] != 'h' + i)\n+\t    j += 512;\n+\t}\n+      if (j || a != 8 + 6 || b != 12 || c != 3 || d != 20)\n+\t++l;\n+      if (e[0] != 'a' + 6 || f[0] != 'b' || g[0] != 'g' + 3 || h[0] != 'd')\n+\tl += 8;\n+    }\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "33d368583dd8887c66324074af790b152d1091cb", "filename": "libgomp/testsuite/libgomp.c/pr26943-4.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca5b2a2d4d6e210374f933c4c09895912d5e4ac/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c?ref=8ca5b2a2d4d6e210374f933c4c09895912d5e4ac", "patch": "@@ -0,0 +1,61 @@\n+/* PR c++/26943 */\n+/* { dg-do run } */\n+\n+extern int omp_set_dynamic (int);\n+extern int omp_get_thread_num (void);\n+extern void abort (void);\n+\n+int a = 8, b = 12, c = 16, d = 20, j = 0, l = 0;\n+char e[10] = \"a\", f[10] = \"b\", g[10] = \"c\", h[10] = \"d\";\n+volatile int k;\n+\n+int\n+main (void)\n+{\n+  int i;\n+  omp_set_dynamic (0);\n+  omp_set_nested (1);\n+#pragma omp parallel num_threads (2) reduction (+:l) \\\n+\t\t     firstprivate (a, b, c, d, e, f, g, h, j)\n+  if (k == omp_get_thread_num ())\n+    {\n+#pragma omp parallel for shared (a, e) firstprivate (b, f) \\\n+\t\t\t lastprivate (c, g) private (d, h) \\\n+\t\t\t schedule (static, 1) num_threads (4) \\\n+\t\t\t reduction (+:j)\n+      for (i = 0; i < 4; i++)\n+\t{\n+\t  if (a != 8 || b != 12 || e[0] != 'a' || f[0] != 'b')\n+\t    j++;\n+#pragma omp barrier\n+#pragma omp atomic\n+\t  a += i;\n+\t  b += i;\n+\t  c = i;\n+\t  d = i;\n+#pragma omp atomic\n+\t  e[0] += i;\n+\t  f[0] += i;\n+\t  g[0] = 'g' + i;\n+\t  h[0] = 'h' + i;\n+#pragma omp barrier\n+\t  if (a != 8 + 6 || b != 12 + i || c != i || d != i)\n+\t    j += 8;\n+\t  if (e[0] != 'a' + 6 || f[0] != 'b' + i || g[0] != 'g' + i)\n+\t    j += 64;\n+\t  if (h[0] != 'h' + i)\n+\t    j += 512;\n+\t}\n+      if (j || a != 8 + 6 || b != 12 || c != 3 || d != 20)\n+\t++l;\n+      if (e[0] != 'a' + 6 || f[0] != 'b' || g[0] != 'g' + 3 || h[0] != 'd')\n+\tl += 8;\n+    }\n+  if (l)\n+    abort ();\n+  if (a != 8 || b != 12 || c != 16 || d != 20)\n+    abort ();\n+  if (e[0] != 'a' || f[0] != 'b' || g[0] != 'c' || h[0] != 'd')\n+    abort ();\n+  return 0;\n+}"}]}