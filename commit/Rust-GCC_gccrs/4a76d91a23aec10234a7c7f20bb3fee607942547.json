{"sha": "4a76d91a23aec10234a7c7f20bb3fee607942547", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3NmQ5MWEyM2FlYzEwMjM0YTdjN2YyMGJiM2ZlZTYwNzk0MjU0Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-03-18T10:00:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-03-18T10:00:53Z"}, "message": "cgraph.c (cgraph_remove_node): Avoid loop in code deciding whether function body should be released...\n\n\t* cgraph.c (cgraph_remove_node): Avoid loop in code deciding whether\n\tfunction body should be released; do not proactively release function\n\tbodies in non-unit-at-a-time mode.\n\nFrom-SVN: r96654", "tree": {"sha": "8e3f1acc0058440927b7f644fdf8d1a2972329fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e3f1acc0058440927b7f644fdf8d1a2972329fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a76d91a23aec10234a7c7f20bb3fee607942547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a76d91a23aec10234a7c7f20bb3fee607942547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a76d91a23aec10234a7c7f20bb3fee607942547", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a76d91a23aec10234a7c7f20bb3fee607942547/comments", "author": null, "committer": null, "parents": [{"sha": "49aa94f95f3118743aa7563a29536af95edacac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49aa94f95f3118743aa7563a29536af95edacac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49aa94f95f3118743aa7563a29536af95edacac4"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "68cfec2386320a73fd06da4a98d5a530ec4d0de7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a76d91a23aec10234a7c7f20bb3fee607942547/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a76d91a23aec10234a7c7f20bb3fee607942547/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a76d91a23aec10234a7c7f20bb3fee607942547", "patch": "@@ -1,3 +1,9 @@\n+2005-03-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Avoid loop in code deciding whether \n+\tfunction body should be released; do not proactively release function\n+\tbodies in non-unit-at-a-time mode.\n+\n 2005-03-18  Ralf Corsepius  <ralf.corsepius@rtems.org>\n \n \t* config/i386/t-rtems-i386 (MULTILIBS): Remove k6, athlon,"}, {"sha": "dacc70dfb30b026744972006a8ccca7f2e7111c8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a76d91a23aec10234a7c7f20bb3fee607942547/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a76d91a23aec10234a7c7f20bb3fee607942547/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4a76d91a23aec10234a7c7f20bb3fee607942547", "patch": "@@ -398,7 +398,7 @@ void\n cgraph_remove_node (struct cgraph_node *node)\n {\n   void **slot;\n-  bool check_dead = 1;\n+  bool kill_body = false;\n \n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n@@ -426,12 +426,7 @@ cgraph_remove_node (struct cgraph_node *node)\n       else\n \t{\n           htab_clear_slot (cgraph_hash, slot);\n-\t  if (!dump_enabled_p (TDI_tree_all))\n-\t    {\n-              DECL_SAVED_TREE (node->decl) = NULL;\n-\t      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n-\t    }\n-\t  check_dead = false;\n+\t  kill_body = true;\n \t}\n     }\n   else\n@@ -443,23 +438,23 @@ cgraph_remove_node (struct cgraph_node *node)\n       n->next_clone = node->next_clone;\n     }\n \n-  /* Work out whether we still need a function body (either there is inline\n-     clone or there is out of line function whose body is not written).  */\n-  if (check_dead && flag_unit_at_a_time)\n+  /* While all the clones are removed after being proceeded, the function \n+     itself is kept in the cgraph even after it is compiled.  Check whether\n+     we are done with this body and reclaim it proactively if this is the case.\n+     */\n+  if (!kill_body && *slot)\n     {\n-      struct cgraph_node *n;\n+      struct cgraph_node *n = *slot;\n+      if (!n->next_clone && !n->global.inlined_to\n+\t  && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl)))\n+\tkill_body = true;\n+    }\n \n-      for (n = *slot; n; n = n->next_clone)\n-\tif (n->global.inlined_to\n-\t    || (!n->global.inlined_to\n-\t\t&& !TREE_ASM_WRITTEN (n->decl) && !DECL_EXTERNAL (n->decl)))\n-\t  break;\n-      if (!n && !dump_enabled_p (TDI_tree_all))\n-\t{\n-\t  DECL_SAVED_TREE (node->decl) = NULL;\n-\t  DECL_STRUCT_FUNCTION (node->decl) = NULL;\n-          DECL_INITIAL (node->decl) = error_mark_node;\n-\t}\n+  if (kill_body && !dump_enabled_p (TDI_tree_all) && flag_unit_at_a_time)\n+    {\n+      DECL_SAVED_TREE (node->decl) = NULL;\n+      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+      DECL_INITIAL (node->decl) = error_mark_node;\n     }\n   cgraph_n_nodes--;\n   /* Do not free the structure itself so the walk over chain can continue.  */"}]}