{"sha": "fcaf306523baa9883c680a3a894bb5ff43092073", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNhZjMwNjUyM2JhYTk4ODNjNjgwYTNhODk0YmI1ZmY0MzA5MjA3Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-05T20:13:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-05T20:13:10Z"}, "message": "class.c (add_method): Move slot search and insertion to ...\n\n\t* class.c (add_method): Move slot search and insertion to ...\n\t* name-lookup.c (get_method_slot): ... this new function.\n\t(lookup_fnfields_slot_nolazy): Cope with NULL slot.\n\t* name-lookup.h (get_method_slot): Declare.\n\t* decl.c (cxx_init_decl_processinng): Give conv_op_marker a more\n\trealistic type.\n\t(grok_special_member_properties): Set\n\tTYPE_HAS_CONVERSION. Expicitly look at DECL_NAME for specialness.\n\tImprove TYPE_HAS_CONSTEXPR_CTOR setting.\n\nFrom-SVN: r251737", "tree": {"sha": "8b7422026ce0fcbd3ad25011ec8c5e4cbe41eeee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b7422026ce0fcbd3ad25011ec8c5e4cbe41eeee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcaf306523baa9883c680a3a894bb5ff43092073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcaf306523baa9883c680a3a894bb5ff43092073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcaf306523baa9883c680a3a894bb5ff43092073", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcaf306523baa9883c680a3a894bb5ff43092073/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "146c2e3ad070b6ba29bd48865ebb5c909f27d8e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/146c2e3ad070b6ba29bd48865ebb5c909f27d8e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/146c2e3ad070b6ba29bd48865ebb5c909f27d8e6"}], "stats": {"total": 198, "additions": 107, "deletions": 91}, "files": [{"sha": "637b788777055da60022185e55cb99efb3ce09bb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fcaf306523baa9883c680a3a894bb5ff43092073", "patch": "@@ -1,5 +1,15 @@\n 2017-09-05  Nathan Sidwell  <nathan@acm.org>\n \n+\t* class.c (add_method): Move slot search and insertion to ...\n+\t* name-lookup.c (get_method_slot): ... this new function.\n+\t(lookup_fnfields_slot_nolazy): Cope with NULL slot.\n+\t* name-lookup.h (get_method_slot): Declare.\n+\t* decl.c (cxx_init_decl_processinng): Give conv_op_marker a more\n+\trealistic type.\n+\t(grok_special_member_properties): Set\n+\tTYPE_HAS_CONVERSION. Expicitly look at DECL_NAME for specialness.\n+\tImprove TYPE_HAS_CONSTEXPR_CTOR setting.\t\n+\n \t* cp-tree.h (lang_decl_base): Rename template_conv_p to\n \tunknown_bound_p.\n \t(DECL_CONV_FN_P): Don't check NULL DECL_NAME."}, {"sha": "d04c2acd25bedb33d531a235c35ad28f8bc5f75a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 74, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fcaf306523baa9883c680a3a894bb5ff43092073", "patch": "@@ -1011,57 +1011,12 @@ add_method (tree type, tree method, bool via_using)\n   if (method == error_mark_node)\n     return false;\n \n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (!method_vec)\n-    {\n-      /* Make a new method vector.  We start with 8 entries.  */\n-      vec_alloc (method_vec, 8);\n-      CLASSTYPE_METHOD_VEC (type) = method_vec;\n-    }\n-\n   /* Maintain TYPE_HAS_USER_CONSTRUCTOR, etc.  */\n   grok_special_member_properties (method);\n \n-  bool insert_p = true;\n-  tree method_name = DECL_NAME (method);\n-  bool complete_p = COMPLETE_TYPE_P (type);\n-  bool conv_p = IDENTIFIER_CONV_OP_P (method_name);\n-\n-  if (conv_p)\n-    method_name = conv_op_identifier;\n-\n-  /* See if we already have an entry with this name.  */\n-  unsigned slot;\n-  tree m;\n-  for (slot = 0; vec_safe_iterate (method_vec, slot, &m); ++slot)\n-    {\n-      m = DECL_NAME (OVL_FIRST (m));\n-      if (m == method_name)\n-\t{\n-\t  insert_p = false;\n-\t  break;\n-\t}\n-      if (complete_p && m > method_name)\n-\tbreak;\n-    }\n-  tree current_fns = insert_p ? NULL_TREE : (*method_vec)[slot];\n+  tree *slot = get_method_slot (type, DECL_NAME (method));\n+  tree current_fns = *slot;\n \n-  tree conv_marker = NULL_TREE;\n-  if (conv_p)\n-    {\n-      /* For conversion operators, we prepend a dummy overload\n-\t pointing at conv_op_marker.  That function's DECL_NAME is\n-\t conv_op_identifier, so we can use identifier equality to\n-\t locate it.  */\n-      if (current_fns)\n-\t{\n-\t  gcc_checking_assert (OVL_FUNCTION (current_fns) == conv_op_marker);\n-\t  conv_marker = current_fns;\n-\t  current_fns = OVL_CHAIN (current_fns);\n-\t}\n-      else\n-\tconv_marker = ovl_make (conv_op_marker, NULL_TREE);\n-    }\n   gcc_assert (!DECL_EXTERN_C_P (method));\n \n   /* Check to see if we've already got this method.  */\n@@ -1209,36 +1164,11 @@ add_method (tree type, tree method, bool via_using)\n \n   current_fns = ovl_insert (method, current_fns, via_using);\n \n-  if (conv_p)\n-    {\n-      TYPE_HAS_CONVERSION (type) = 1;\n-      /* Prepend the marker function.  */\n-      OVL_CHAIN (conv_marker) = current_fns;\n-      current_fns = conv_marker;\n-    }\n-  else if (!complete_p && !IDENTIFIER_CDTOR_P (DECL_NAME (method)))\n+  if (!DECL_CONV_FN_P (method) && !COMPLETE_TYPE_P (type))\n     push_class_level_binding (DECL_NAME (method), current_fns);\n \n-  if (insert_p)\n-    {\n-      bool reallocated;\n+  *slot = current_fns;\n \n-      /* We only expect to add few methods in the COMPLETE_P case, so\n-\t just make room for one more method in that case.  */\n-      if (complete_p)\n-\treallocated = vec_safe_reserve_exact (method_vec, 1);\n-      else\n-\treallocated = vec_safe_reserve (method_vec, 1);\n-      if (reallocated)\n-\tCLASSTYPE_METHOD_VEC (type) = method_vec;\n-      if (slot == method_vec->length ())\n-\tmethod_vec->quick_push (current_fns);\n-      else\n-\tmethod_vec->quick_insert (slot, current_fns);\n-    }\n-  else\n-    /* Replace the current slot.  */\n-    (*method_vec)[slot] = current_fns;\n   return true;\n }\n "}, {"sha": "da5e16b685b0cbd0aef922f0bb40db1c410f45f1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fcaf306523baa9883c680a3a894bb5ff43092073", "patch": "@@ -4073,13 +4073,6 @@ cxx_init_decl_processing (void)\n   noexcept_deferred_spec = build_tree_list (make_node (DEFERRED_NOEXCEPT),\n \t\t\t\t\t    NULL_TREE);\n \n-  /* Create the conversion operator marker.  This operator's DECL_NAME\n-     is in the identifier table, so we can use identifier equality to\n-     find it.  This has no type and no context, so we can't\n-     accidentally think it a real function.  */\n-  conv_op_marker = build_lang_decl (FUNCTION_DECL, conv_op_identifier,\n-\t\t\t\t    NULL_TREE);\n-\n #if 0\n   record_builtin_type (RID_MAX, NULL, string_type_node);\n #endif\n@@ -4094,6 +4087,12 @@ cxx_init_decl_processing (void)\n   void_ftype_ptr\n     = build_exception_variant (void_ftype_ptr, empty_except_spec);\n \n+  /* Create the conversion operator marker.  This operator's DECL_NAME\n+     is in the identifier table, so we can use identifier equality to\n+     find it.  */\n+  conv_op_marker = build_lang_decl (FUNCTION_DECL, conv_op_identifier,\n+\t\t\t\t    void_ftype);\n+\n   /* C++ extensions */\n \n   unknown_type_node = make_node (LANG_TYPE);\n@@ -12793,7 +12792,7 @@ grok_special_member_properties (tree decl)\n     return;\n \n   class_type = DECL_CONTEXT (decl);\n-  if (DECL_CONSTRUCTOR_P (decl))\n+  if (IDENTIFIER_CTOR_P (DECL_NAME (decl)))\n     {\n       int ctor = copy_fn_p (decl);\n \n@@ -12823,10 +12822,10 @@ grok_special_member_properties (tree decl)\n \tTYPE_HAS_LIST_CTOR (class_type) = 1;\n \n       if (DECL_DECLARED_CONSTEXPR_P (decl)\n-\t  && !copy_fn_p (decl) && !move_fn_p (decl))\n+\t  && !ctor && !move_fn_p (decl))\n \tTYPE_HAS_CONSTEXPR_CTOR (class_type) = 1;\n     }\n-  else if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n+  else if (DECL_NAME (decl) == cp_assignment_operator_id (NOP_EXPR))\n     {\n       /* [class.copy]\n \n@@ -12847,6 +12846,9 @@ grok_special_member_properties (tree decl)\n       else if (move_fn_p (decl) && user_provided_p (decl))\n \tTYPE_HAS_COMPLEX_MOVE_ASSIGN (class_type) = 1;\n     }\n+  else if (IDENTIFIER_CONV_OP_P (DECL_NAME (decl)))\n+    TYPE_HAS_CONVERSION (class_type) = true;\n+  \n   /* Destructors are handled in check_methods.  */\n }\n "}, {"sha": "eacd515ecfbe60fecc03f2d1b8ed766a974223bd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 80, "deletions": 7, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=fcaf306523baa9883c680a3a894bb5ff43092073", "patch": "@@ -1155,13 +1155,18 @@ lookup_fnfields_slot_nolazy (tree type, tree name)\n     }\n   else\n     for (int i = 0; vec_safe_iterate (method_vec, i, &fns); ++i)\n-      {\n-\tif (OVL_NAME (fns) == lookup)\n-\t  {\n-\t    val = fns;\n-\t    break;\n-\t  }\n-      }\n+      /* We can get a NULL binding during insertion of a new\n+\t method name, because the identifier_binding machinery\n+\t performs a lookup.  If we find such a NULL slot, that's\n+\t the thing we were looking for, so we might as well bail\n+\t out immediately.  */\n+      if (!fns)\n+\tbreak;\n+      else if (OVL_NAME (fns) == lookup)\n+\t{\n+\t  val = fns;\n+\t  break;\n+\t}\n \n   /* Extract the conversion operators asked for, unless the general\n      conversion operator was requested.   */\n@@ -1312,6 +1317,74 @@ lookup_fnfields_slot (tree type, tree name)\n   return lookup_fnfields_slot_nolazy (type, name);\n }\n \n+/* Find the slot containing overloads called 'NAME'.  If there is no\n+   such slot, create an empty one.  KLASS might be complete at this\n+   point, in which case we need to preserve ordering.  Deals with\n+   conv_op marker handling.  */\n+\n+tree *\n+get_method_slot (tree klass, tree name)\n+{\n+  bool complete_p = COMPLETE_TYPE_P (klass);\n+  \n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n+  if (!method_vec)\n+    {\n+      vec_alloc (method_vec, 8);\n+      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+    }\n+\n+  if (IDENTIFIER_CONV_OP_P (name))\n+    name = conv_op_identifier;\n+\n+  unsigned ix, length = method_vec->length ();\n+  for (ix = 0; ix < length; ix++)\n+    {\n+      tree *slot = &(*method_vec)[ix];\n+      tree fn_name = OVL_NAME (*slot);\n+\n+      if (fn_name == name)\n+\t{\n+\t  if (name == conv_op_identifier)\n+\t    {\n+\t      gcc_checking_assert (OVL_FUNCTION (*slot) == conv_op_marker);\n+\t      /* Skip the conv-op marker. */\n+\t      slot = &OVL_CHAIN (*slot);\n+\t    }\n+\t  return slot;\n+\t}\n+\n+      if (complete_p && fn_name > name)\n+\tbreak;\n+    }\n+\n+  /* No slot found.  Create one at IX.  We know in this case that our\n+     caller will succeed in adding the function.  */\n+  if (complete_p)\n+    {\n+      /* Do exact allocation when complete, as we don't expect to add\n+\t many.  */\n+      vec_safe_reserve_exact (method_vec, 1);\n+      method_vec->quick_insert (ix, NULL_TREE);\n+    }\n+  else\n+    {\n+      gcc_checking_assert (ix == length);\n+      vec_safe_push (method_vec, NULL_TREE);\n+    }\n+  CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+\n+  tree *slot = &(*method_vec)[ix];\n+  if (name == conv_op_identifier)\n+    {\n+      /* Install the marker prefix.  */\n+      *slot = ovl_make (conv_op_marker, NULL_TREE);\n+      slot = &OVL_CHAIN (*slot);\n+    }\n+\n+  return slot;\n+}\n+\n static struct {\n   gt_pointer_operator new_value;\n   void *cookie;"}, {"sha": "aa96e15169dc6d65eb9ae093a207bf48bd1e30d5", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcaf306523baa9883c680a3a894bb5ff43092073/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=fcaf306523baa9883c680a3a894bb5ff43092073", "patch": "@@ -322,6 +322,7 @@ extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_fnfields_slot\t\t(tree, tree);\n extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n+extern tree *get_method_slot (tree klass, tree name);\n extern void resort_type_method_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);\n extern void set_class_bindings (tree);"}]}