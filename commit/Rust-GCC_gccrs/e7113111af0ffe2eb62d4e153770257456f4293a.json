{"sha": "e7113111af0ffe2eb62d4e153770257456f4293a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcxMTMxMTFhZjBmZmUyZWI2MmQ0ZTE1Mzc3MDI1NzQ1NmY0MjkzYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-01T22:42:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-09-01T22:42:37Z"}, "message": "(movdf): Simplify by taking advantage of having SECONDARY_MEMORY_NEEDED.\n\nFix bugs relating to order in which moves are done.\n\nFrom-SVN: r5243", "tree": {"sha": "b66891a890cd4790d270186ef56450de560c5bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b66891a890cd4790d270186ef56450de560c5bbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7113111af0ffe2eb62d4e153770257456f4293a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7113111af0ffe2eb62d4e153770257456f4293a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7113111af0ffe2eb62d4e153770257456f4293a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7113111af0ffe2eb62d4e153770257456f4293a/comments", "author": null, "committer": null, "parents": [{"sha": "7ea555a4fc8b9545f7ccd71e8a8e8703c22f5056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea555a4fc8b9545f7ccd71e8a8e8703c22f5056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea555a4fc8b9545f7ccd71e8a8e8703c22f5056"}], "stats": {"total": 147, "additions": 50, "deletions": 97}, "files": [{"sha": "d60358e681a242f6f704deffc2868e63a3f6c4ad", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 50, "deletions": 97, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7113111af0ffe2eb62d4e153770257456f4293a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7113111af0ffe2eb62d4e153770257456f4293a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e7113111af0ffe2eb62d4e153770257456f4293a", "patch": "@@ -2382,106 +2382,28 @@\n   \"\"\n   \"\n {\n-  /* If we are called from reload, we might be getting a SUBREG of a hard\n-     reg.  So expand it.  */\n-  if (GET_CODE (operands[0]) == SUBREG\n-      && GET_CODE (SUBREG_REG (operands[0])) == REG\n-      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER)\n-    operands[0] = alter_subreg (operands[0]);\n-  if (GET_CODE (operands[1]) == SUBREG\n-      && GET_CODE (SUBREG_REG (operands[1])) == REG\n-      && REGNO (SUBREG_REG (operands[1])) < FIRST_PSEUDO_REGISTER)\n-    operands[1] = alter_subreg (operands[1]);\n-\n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n     {\n-      rtx stack_slot;\n-\n-      /* If this is a store to memory or another integer register do the\n-\t move directly.  Otherwise store to a temporary stack slot and\n-\t load from there into a floating point register.  */\n-\n-      if (GET_CODE (operands[0]) == MEM\n-\t  || (GET_CODE (operands[0]) == REG\n-\t      && (REGNO (operands[0]) < 32\n-\t\t  || (reload_in_progress\n-\t\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))))\n-\t{\n-\t  emit_move_insn (operand_subword (operands[0], 0, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 0, 0, DFmode));\n-\t  emit_move_insn (operand_subword (operands[0], 1, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 1, 0, DFmode));\n-\t  DONE;\n-\t}\n-\n-      stack_slot = gen_rtx (MEM, DFmode, plus_constant (stack_pointer_rtx, 8));\n-      emit_move_insn (stack_slot, operands[1]);\n-      emit_move_insn (operands[0], stack_slot);\n+      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 1, DFmode));\n+      emit_move_insn (operand_subword (operands[0], 0, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 0, DFmode));\n       DONE;\n     }\n \n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  emit_move_insn (operand_subword (operands[0], 0, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 0, 0, DFmode));\n-\t  emit_move_insn (operand_subword (operands[0], 1, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 1, 0, DFmode));\n-\t  DONE;\n-\t}\n-      \n-      operands[1] = force_reg (DFmode, operands[1]);\n-    }\n-\n-  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 32)\n-    {\n-      rtx stack_slot;\n-\n-      if (GET_CODE (operands[1]) == MEM\n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && ! defined(REAL_IS_NOT_DOUBLE)\n-\t  || GET_CODE (operands[1]) == CONST_DOUBLE\n-#endif\n-\t  || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n-\t  || (reload_in_progress && GET_CODE (operands[1]) == REG\n-\t      && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))\n-\t{\n-\t  emit_move_insn (operand_subword (operands[0], 0, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 0, 0, DFmode));\n-\t  emit_move_insn (operand_subword (operands[0], 1, 0, DFmode),\n-\t\t\t  operand_subword (operands[1], 1, 0, DFmode));\n-\t  DONE;\n-\t}\n-\n-      if (reload_in_progress)\n-\tstack_slot = gen_rtx (MEM, DFmode,\n-\t\t\t      plus_constant (stack_pointer_rtx, 8));\n-      else\n-\tstack_slot = assign_stack_temp (DFmode, 8, 0);\n-      emit_move_insn (stack_slot, operands[1]);\n-      emit_move_insn (operands[0], stack_slot);\n-      DONE;\n-    }\n+  if (GET_CODE (operands[0]) != REG)\n+    operands[1] = force_reg (DFmode, operands[1]);\n \n-  if (CONSTANT_P (operands[1]))\n+  if (CONSTANT_P (operands[1]) && ! easy_fp_constant (operands[1], DFmode))\n     {\n       operands[1] = force_const_mem (DFmode, operands[1]);\n       if (! memory_address_p (DFmode, XEXP (operands[1], 0))\n \t  && ! reload_in_progress)\n \toperands[1] = change_address (operands[1], DFmode,\n \t\t\t\t      XEXP (operands[1], 0));\n     }\n-}\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(match_operand:DF 1 \"mem_or_easy_const_operand\" \"G,m\"))]\n-  \"REGNO (operands[0]) <= 31\"\n-  \"@\n-   #\n-   l %0,%1\\;l %L0,%L1\"\n-  [(set_attr \"type\" \"*,load\")\n-   (set_attr \"length\" \"*,8\")])\n+}\")\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -2494,17 +2416,48 @@\n   operands[3] = operand_subword (operands[1], 0, 0, DFmode);\n   operands[4] = operand_subword (operands[0], 1, 0, DFmode);\n   operands[5] = operand_subword (operands[1], 1, 0, DFmode); }\")\n-  \n+\n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"fp_reg_or_mem_operand\" \"=f,f,m\")\n-\t(match_operand:DF 1 \"fp_reg_or_mem_operand\" \"f,m,f\"))]\n-  \"gpc_reg_operand (operands[0], DFmode)\n-   || gpc_reg_operand (operands[1], DFmode)\"\n-  \"@\n-   fmr %0,%1\n-   lfd%U1%X1 %0,%1\n-   stfd%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"fp,load,*\")])\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,r,o,r,f,f,m\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,f,m,f\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"oril %L0,%L1,0\\;oril %0,%1,0\\\";\n+      else\n+\treturn \\\"oril %0,%1,0\\;oril %L0,%L1,0\\\";\n+    case 1:\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\treturn \\\"l %L0,%L1\\;l %0,%1\\\";\n+      else\n+\treturn \\\"l%U1 %0,%1\\;l %L0,%L1\\\";\n+    case 2:\n+      return \\\"st%U0 %1,%0\\;st %L1,%L0\\\";\n+    case 3:\n+      return \\\"#\\\";\n+    case 4:\n+      return \\\"fmr %0,%1\\\";\n+    case 5:\n+      return \\\"lfd%U1%X1 %0,%1\\\";\n+    case 6:\n+      return \\\"stfd%U0%X0 %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"*,load,*,*,fp,load,*\")\n+   (set_attr \"length\" \"8,8,8,8,*,*,*\")])\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns."}]}