{"sha": "0fc60c183358be2f2003b94226ab49e21c585b13", "node_id": "C_kwDOANBUbNoAKDBmYzYwYzE4MzM1OGJlMmYyMDAzYjk0MjI2YWI0OWUyMWM1ODViMTM", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-01-05T02:27:18Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-01-05T02:27:18Z"}, "message": "ipa-inline: Add target info into fn summary [PR102059]\n\nPower ISA 2.07 (Power8) introduces transactional memory\nfeature but ISA3.1 (Power10) removes it.  It exposes one\ntroublesome issue as PR102059 shows.  Users define some\nfunction with target pragma cpu=power10 then it calls one\nfunction with attribute always_inline which inherits\ncommand line option -mcpu=power8 which enables HTM\nimplicitly.  The current isa_flags check doesn't allow this\ninlining due to \"target specific option mismatch\" and error\nmesasge is emitted.\n\nNormally, the callee function isn't intended to exploit HTM\nfeature, but the default flag setting make it look it has.\nAs Richi raised in the PR, we have fp_expressions flag in\nfunction summary, and allow us to check the function\nactually contains any floating point expressions to avoid\noverkill.  So this patch follows the similar idea but is\nmore target specific, for this rs6000 port specific\nrequirement on HTM feature check, we would like to check\nrs6000 specific HTM built-in functions and inline assembly,\nit allows targets to do their own customized checks and\nupdates.\n\nIt introduces two target hooks need_ipa_fn_target_info and\nupdate_ipa_fn_target_info.  The former allows target to do\nsome previous check and decides to collect target specific\ninformation for this function or not.  For some special\ncase, it can predict the analysis result and set it early\nwithout any scannings.  The latter allows the\nanalyze_function_body to pass gimple stmts down just like\nfp_expressions handlings, target can do its own tricks.\nI put them together as one hook initially with one boolean\nto indicate whether it's initial time, but the code looks a\nbit ugly, to separate them seems to have better readability.\n\ngcc/ChangeLog:\n\n\tPR ipa/102059\n\t* config/rs6000/rs6000.c (TARGET_NEED_IPA_FN_TARGET_INFO): New macro.\n\t(TARGET_UPDATE_IPA_FN_TARGET_INFO): Likewise.\n\t(rs6000_need_ipa_fn_target_info): New function.\n\t(rs6000_update_ipa_fn_target_info): Likewise.\n\t(rs6000_can_inline_p): Adjust for ipa function summary target info.\n\t* config/rs6000/rs6000.h (RS6000_FN_TARGET_INFO_HTM): New macro.\n\t* ipa-fnsummary.c (ipa_dump_fn_summary): Adjust for ipa function\n\tsummary target info.\n\t(analyze_function_body): Adjust for ipa function summary target info\n\tand call hook rs6000_need_ipa_fn_target_info and\n\trs6000_update_ipa_fn_target_info.\n\t(ipa_merge_fn_summary_after_inlining): Adjust for ipa function summary\n\ttarget info.\n\t(inline_read_section): Likewise.\n\t(ipa_fn_summary_write): Likewise.\n\t* ipa-fnsummary.h (ipa_fn_summary::target_info): New member.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_UPDATE_IPA_FN_TARGET_INFO): Document new hook.\n\t(TARGET_NEED_IPA_FN_TARGET_INFO): Likewise.\n\t* target.def (update_ipa_fn_target_info): New hook.\n\t(need_ipa_fn_target_info): Likewise.\n\t* targhooks.c (default_need_ipa_fn_target_info): New function.\n\t(default_update_ipa_fn_target_info): Likewise.\n\t* targhooks.h (default_update_ipa_fn_target_info): New declare.\n\t(default_need_ipa_fn_target_info): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR ipa/102059\n\t* gcc.dg/lto/pr102059-1_0.c: New test.\n\t* gcc.dg/lto/pr102059-1_1.c: New test.\n\t* gcc.dg/lto/pr102059-1_2.c: New test.\n\t* gcc.dg/lto/pr102059-2_0.c: New test.\n\t* gcc.dg/lto/pr102059-2_1.c: New test.\n\t* gcc.dg/lto/pr102059-2_2.c: New test.\n\t* gcc.target/powerpc/pr102059-1.c: New test.\n\t* gcc.target/powerpc/pr102059-2.c: New test.\n\t* gcc.target/powerpc/pr102059-3.c: New test.", "tree": {"sha": "67baf78775915c9046b8cea2d96a05731d114674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67baf78775915c9046b8cea2d96a05731d114674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fc60c183358be2f2003b94226ab49e21c585b13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc60c183358be2f2003b94226ab49e21c585b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc60c183358be2f2003b94226ab49e21c585b13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc60c183358be2f2003b94226ab49e21c585b13/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0239f852591d368a42ce3b6c9f85cfba6a3aeff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0239f852591d368a42ce3b6c9f85cfba6a3aeff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0239f852591d368a42ce3b6c9f85cfba6a3aeff"}], "stats": {"total": 337, "additions": 331, "deletions": 6}, "files": [{"sha": "319182e94d91b0a95626e22cbcef2c6c7023786a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -71,6 +71,9 @@\n #include \"tree-vector-builder.h\"\n #include \"context.h\"\n #include \"tree-pass.h\"\n+#include \"symbol-summary.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-fnsummary.h\"\n #include \"except.h\"\n #if TARGET_XCOFF\n #include \"xcoffout.h\"  /* get declarations of xcoff_*_section_name */\n@@ -1779,6 +1782,12 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_INVALID_CONVERSION\n #define TARGET_INVALID_CONVERSION rs6000_invalid_conversion\n+\n+#undef TARGET_NEED_IPA_FN_TARGET_INFO\n+#define TARGET_NEED_IPA_FN_TARGET_INFO rs6000_need_ipa_fn_target_info\n+\n+#undef TARGET_UPDATE_IPA_FN_TARGET_INFO\n+#define TARGET_UPDATE_IPA_FN_TARGET_INFO rs6000_update_ipa_fn_target_info\n \f\n \n /* Processor table.  */\n@@ -25308,7 +25317,63 @@ rs6000_generate_version_dispatcher_body (void *node_p)\n   return resolver;\n }\n \n-\f\n+/* Hook to decide if we need to scan function gimple statements to\n+   collect target specific information for inlining, and update the\n+   corresponding RS6000_FN_TARGET_INFO_* bit in INFO if we are able\n+   to predict which ISA feature is used at this time.  Return true\n+   if we need to scan, otherwise return false.  */\n+\n+static bool\n+rs6000_need_ipa_fn_target_info (const_tree decl,\n+\t\t\t\tunsigned int &info ATTRIBUTE_UNUSED)\n+{\n+  tree target = DECL_FUNCTION_SPECIFIC_TARGET (decl);\n+  if (!target)\n+    target = target_option_default_node;\n+  struct cl_target_option *opts = TREE_TARGET_OPTION (target);\n+\n+  /* See PR102059, we only handle HTM for now, so will only do\n+     the consequent scannings when HTM feature enabled.  */\n+  if (opts->x_rs6000_isa_flags & OPTION_MASK_HTM)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Hook to update target specific information INFO for inlining by\n+   checking the given STMT.  Return false if we don't need to scan\n+   any more, otherwise return true.  */\n+\n+static bool\n+rs6000_update_ipa_fn_target_info (unsigned int &info, const gimple *stmt)\n+{\n+  /* Assume inline asm can use any instruction features.  */\n+  if (gimple_code (stmt) == GIMPLE_ASM)\n+    {\n+      /* Should set any bits we concerned, for now OPTION_MASK_HTM is\n+\t the only bit we care about.  */\n+      info |= RS6000_FN_TARGET_INFO_HTM;\n+      return false;\n+    }\n+  else if (gimple_code (stmt) == GIMPLE_CALL)\n+    {\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      if (fndecl && fndecl_built_in_p (fndecl, BUILT_IN_MD))\n+\t{\n+\t  enum rs6000_gen_builtins fcode\n+\t    = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n+\t  /* HTM bifs definitely exploit HTM insns.  */\n+\t  if (bif_is_htm (rs6000_builtin_info[fcode]))\n+\t    {\n+\t      info |= RS6000_FN_TARGET_INFO_HTM;\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Hook to determine if one function can safely inline another.  */\n \n static bool\n@@ -25336,6 +25401,17 @@ rs6000_can_inline_p (tree caller, tree callee)\n       else\n \tcaller_isa = rs6000_isa_flags;\n \n+      cgraph_node *callee_node = cgraph_node::get (callee);\n+      if (ipa_fn_summaries && ipa_fn_summaries->get (callee_node) != NULL)\n+\t{\n+\t  unsigned int info = ipa_fn_summaries->get (callee_node)->target_info;\n+\t  if ((info & RS6000_FN_TARGET_INFO_HTM) == 0)\n+\t    {\n+\t      callee_isa &= ~OPTION_MASK_HTM;\n+\t      explicit_isa &= ~OPTION_MASK_HTM;\n+\t    }\n+\t}\n+\n       /* The callee's options must be a subset of the caller's options, i.e.\n \t a vsx function may inline an altivec function, but a no-vsx function\n \t must not inline a vsx function.  However, for those options that the"}, {"sha": "a02dbbda458556abdbc92e17c5588642e7c35fe8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -604,6 +604,11 @@ extern int rs6000_vector_align[];\n \t\t\t\t\t && TARGET_P8_VECTOR\t\t\\\n \t\t\t\t\t && TARGET_POWERPC64)\n \n+/* Inlining allows targets to define the meanings of bits in target_info\n+   field of ipa_fn_summary by itself, the used bits for rs6000 are listed\n+   below.  */\n+#define RS6000_FN_TARGET_INFO_HTM 1\n+\n /* Whether the various reciprocal divide/square root estimate instructions\n    exist, and whether we should automatically generate code for the instruction\n    by default.  */"}, {"sha": "c934f7acd5849856a487e2433febeb908d9bdc0a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -10713,6 +10713,37 @@ default, inlining is not allowed if the callee function has function\n specific target options and the caller does not use the same options.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_UPDATE_IPA_FN_TARGET_INFO (unsigned int& @var{info}, const gimple* @var{stmt})\n+Allow target to analyze all gimple statements for the given function to\n+record and update some target specific information for inlining.  A typical\n+example is that a caller with one isa feature disabled is normally not\n+allowed to inline a callee with that same isa feature enabled even which is\n+attributed by always_inline, but with the conservative analysis on all\n+statements of the callee if we are able to guarantee the callee does not\n+exploit any instructions from the mismatch isa feature, it would be safe to\n+allow the caller to inline the callee.\n+@var{info} is one @code{unsigned int} value to record information in which\n+one set bit indicates one corresponding feature is detected in the analysis,\n+@var{stmt} is the statement being analyzed.  Return true if target still\n+need to analyze the subsequent statements, otherwise return false to stop\n+subsequent analysis.\n+The default version of this hook returns false.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_NEED_IPA_FN_TARGET_INFO (const_tree @var{decl}, unsigned int& @var{info})\n+Allow target to check early whether it is necessary to analyze all gimple\n+statements in the given function to update target specific information for\n+inlining.  See hook @code{update_ipa_fn_target_info} for usage example of\n+target specific information.  This hook is expected to be invoked ahead of\n+the iterating with hook @code{update_ipa_fn_target_info}.\n+@var{decl} is the function being analyzed, @var{info} is the same as what\n+in hook @code{update_ipa_fn_target_info}, target can do one time update\n+into @var{info} without iterating for some case.  Return true if target\n+decides to analyze all gimple statements to collect information, otherwise\n+return false.\n+The default version of this hook returns false.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_RELAYOUT_FUNCTION (tree @var{fndecl})\n This target hook fixes function @var{fndecl} after attributes are processed.\n Default does nothing. On ARM, the default function's alignment is updated"}, {"sha": "d6359aa5b513b573178672df16898935425aadc7", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -7191,6 +7191,10 @@ on this implementation detail.\n \n @hook TARGET_CAN_INLINE_P\n \n+@hook TARGET_UPDATE_IPA_FN_TARGET_INFO\n+\n+@hook TARGET_NEED_IPA_FN_TARGET_INFO\n+\n @hook TARGET_RELAYOUT_FUNCTION\n \n @node Emulated TLS"}, {"sha": "b95babf2c1d896a97175302363ae38c361451022", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"target.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"alloc-pool.h\"\n@@ -1149,6 +1150,8 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t  fprintf (f, \"  calls:\\n\");\n \t  dump_ipa_call_summary (f, 4, node, s);\n \t  fprintf (f, \"\\n\");\n+\t  if (s->target_info)\n+\t    fprintf (f, \"  target_info: %x\\n\", s->target_info);\n \t}\n       else\n \tfprintf (f, \"IPA summary for %s is missing.\\n\", node->dump_name ());\n@@ -2675,6 +2678,12 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t\t   bb_predicate,\n \t\t           bb_predicate);\n \n+  /* Only look for target information for inlinable functions.  */\n+  bool scan_for_target_info =\n+    info->inlinable\n+    && targetm.target_option.need_ipa_fn_target_info (node->decl,\n+\t\t\t\t\t\t      info->target_info);\n+\n   if (fbi.info)\n     compute_bb_predicates (&fbi, node, info, params_summary);\n   const profile_count entry_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n@@ -2895,6 +2904,15 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t}\n \t    }\n \n+\t  /* For target specific information, we want to scan all statements\n+\t     rather than those statements with non-zero weights, to avoid\n+\t     missing to scan something interesting for target information,\n+\t     such as: internal function calls.  */\n+\t  if (scan_for_target_info)\n+\t    scan_for_target_info =\n+\t      targetm.target_option.update_ipa_fn_target_info\n+\t      (info->target_info, stmt);\n+\n \t  /* Account cost of address calculations in the statements.  */\n \t  for (unsigned int i = 0; i < gimple_num_ops (stmt); i++)\n \t    {\n@@ -4116,6 +4134,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n     toplev_predicate = true;\n \n   info->fp_expressions |= callee_info->fp_expressions;\n+  info->target_info |= callee_info->target_info;\n \n   if (callee_info->conds)\n     {\n@@ -4456,13 +4475,17 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       bp = streamer_read_bitpack (&ib);\n       if (info)\n \t{\n-          info->inlinable = bp_unpack_value (&bp, 1);\n-          info->fp_expressions = bp_unpack_value (&bp, 1);\n+\t  info->inlinable = bp_unpack_value (&bp, 1);\n+\t  info->fp_expressions = bp_unpack_value (&bp, 1);\n+\t  if (!lto_stream_offload_p)\n+\t    info->target_info = streamer_read_uhwi (&ib);\n \t}\n       else\n \t{\n-          bp_unpack_value (&bp, 1);\n-          bp_unpack_value (&bp, 1);\n+\t  bp_unpack_value (&bp, 1);\n+\t  bp_unpack_value (&bp, 1);\n+\t  if (!lto_stream_offload_p)\n+\t    streamer_read_uhwi (&ib);\n \t}\n \n       count2 = streamer_read_uhwi (&ib);\n@@ -4698,6 +4721,8 @@ ipa_fn_summary_write (void)\n \t  bp_pack_value (&bp, info->inlinable, 1);\n \t  bp_pack_value (&bp, info->fp_expressions, 1);\n \t  streamer_write_bitpack (&bp);\n+\t  if (!lto_stream_offload_p)\n+\t    streamer_write_uhwi (ob, info->target_info);\n \t  streamer_write_uhwi (ob, vec_safe_length (info->conds));\n \t  for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)\n \t    {"}, {"sha": "fc386eeb0d0ee622975c4fe4671ee0e80daadffe", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -126,7 +126,7 @@ class GTY(()) ipa_fn_summary\n   ipa_fn_summary ()\n     : min_size (0),\n       inlinable (false), single_caller (false),\n-      fp_expressions (false),\n+      fp_expressions (false), target_info (0),\n       estimated_stack_size (false),\n       time (0), conds (NULL),\n       size_time_table (), call_size_time_table (vNULL),\n@@ -141,6 +141,7 @@ class GTY(()) ipa_fn_summary\n     : min_size (s.min_size),\n     inlinable (s.inlinable), single_caller (s.single_caller),\n     fp_expressions (s.fp_expressions),\n+    target_info (s.target_info),\n     estimated_stack_size (s.estimated_stack_size),\n     time (s.time), conds (s.conds), size_time_table (),\n     call_size_time_table (vNULL),\n@@ -164,6 +165,10 @@ class GTY(()) ipa_fn_summary\n   unsigned int single_caller : 1;\n   /* True if function contains any floating point expressions.  */\n   unsigned int fp_expressions : 1;\n+  /* Like fp_expressions field above, but it's to hold some target specific\n+     information, such as some target specific isa flags.  Note that for\n+     offloading target compilers, this field isn't streamed.  */\n+  unsigned int target_info;\n \n   /* Information about function that will result after applying all the\n      inline decisions present in the callgraph.  Generally kept up to"}, {"sha": "8fd2533e90a1cd3e350f44997852eaf93f965d6b", "filename": "gcc/target.def", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -6535,6 +6535,41 @@ specific target options and the caller does not use the same options.\",\n  bool, (tree caller, tree callee),\n  default_target_can_inline_p)\n \n+DEFHOOK\n+(update_ipa_fn_target_info,\n+ \"Allow target to analyze all gimple statements for the given function to\\n\\\n+record and update some target specific information for inlining.  A typical\\n\\\n+example is that a caller with one isa feature disabled is normally not\\n\\\n+allowed to inline a callee with that same isa feature enabled even which is\\n\\\n+attributed by always_inline, but with the conservative analysis on all\\n\\\n+statements of the callee if we are able to guarantee the callee does not\\n\\\n+exploit any instructions from the mismatch isa feature, it would be safe to\\n\\\n+allow the caller to inline the callee.\\n\\\n+@var{info} is one @code{unsigned int} value to record information in which\\n\\\n+one set bit indicates one corresponding feature is detected in the analysis,\\n\\\n+@var{stmt} is the statement being analyzed.  Return true if target still\\n\\\n+need to analyze the subsequent statements, otherwise return false to stop\\n\\\n+subsequent analysis.\\n\\\n+The default version of this hook returns false.\",\n+ bool, (unsigned int& info, const gimple* stmt),\n+ default_update_ipa_fn_target_info)\n+\n+DEFHOOK\n+(need_ipa_fn_target_info,\n+ \"Allow target to check early whether it is necessary to analyze all gimple\\n\\\n+statements in the given function to update target specific information for\\n\\\n+inlining.  See hook @code{update_ipa_fn_target_info} for usage example of\\n\\\n+target specific information.  This hook is expected to be invoked ahead of\\n\\\n+the iterating with hook @code{update_ipa_fn_target_info}.\\n\\\n+@var{decl} is the function being analyzed, @var{info} is the same as what\\n\\\n+in hook @code{update_ipa_fn_target_info}, target can do one time update\\n\\\n+into @var{info} without iterating for some case.  Return true if target\\n\\\n+decides to analyze all gimple statements to collect information, otherwise\\n\\\n+return false.\\n\\\n+The default version of this hook returns false.\",\n+ bool, (const_tree decl, unsigned int& info),\n+ default_need_ipa_fn_target_info)\n+\n DEFHOOK\n (relayout_function,\n \"This target hook fixes function @var{fndecl} after attributes are processed.\\n\\"}, {"sha": "116a23b8a02df7534b6551186e53ec10e337d66f", "filename": "gcc/targhooks.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -1710,6 +1710,22 @@ default_target_can_inline_p (tree caller, tree callee)\n   return callee_opts == caller_opts;\n }\n \n+/* By default, return false to not need to collect any target information\n+   for inlining.  Target maintainer should re-define the hook if the\n+   target want to take advantage of it.  */\n+\n+bool\n+default_need_ipa_fn_target_info (const_tree, unsigned int &)\n+{\n+  return false;\n+}\n+\n+bool\n+default_update_ipa_fn_target_info (unsigned int &, const gimple *)\n+{\n+  return false;\n+}\n+\n /* If the machine does not have a case insn that compares the bounds,\n    this means extra overhead for dispatch tables, which raises the\n    threshold for using them.  */"}, {"sha": "ecfa11287efe53103d5eccb10a512b350c91fdf7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -188,6 +188,8 @@ extern bool default_new_address_profitable_p (rtx, rtx_insn *, rtx);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n+extern bool default_update_ipa_fn_target_info (unsigned int &, const gimple *);\n+extern bool default_need_ipa_fn_target_info (const_tree, unsigned int &);\n extern bool default_valid_pointer_mode (scalar_int_mode);\n extern bool default_ref_may_alias_errno (class ao_ref *);\n extern scalar_int_mode default_addr_space_pointer_mode (addr_space_t);"}, {"sha": "e1004f5cfbf2f914dc371034ca0246c2ca90f613", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-1_0.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_0.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-lto-do link } */\n+/* { dg-skip-if \"power10 and above only\" { ! { power10_ok } } } */\n+/* -Wno-attributes suppresses always_inline warnings.  */\n+/* { dg-lto-options { \"-O2 -mdejagnu-cpu=power8 -flto -Wno-attributes -mno-power8-fusion\" } } */\n+\n+int __attribute__ ((always_inline))\n+foo1 (int *b)\n+{\n+  *b += 100;\n+  return *b;\n+}\n+"}, {"sha": "7e31fc7fbd9491f6f3c541d0751b10ecc404c2ef", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-1_1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_1.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,9 @@\n+extern int foo1 (int *b);\n+\n+int __attribute__ ((always_inline)) foo2 (int *b)\n+{\n+  int res = foo1 (b);\n+  *b += res;\n+  return *b;\n+}\n+"}, {"sha": "bfa1e62fb7a0a611bf770fd352205e1698c64f0a", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-1_2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-1_2.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,11 @@\n+extern int foo2 (int *b);\n+\n+#pragma GCC target \"cpu=power10\"\n+__attribute__ ((always_inline))\n+int\n+main (int *a)\n+{\n+  *a = foo2 (a);\n+  return 0;\n+}\n+"}, {"sha": "ebb0a7b8fa16304afed12f02b5bebd30cb53d0e7", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-2_0.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_0.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-lto-do link } */\n+/* { dg-skip-if \"power10 and above only\" { ! { power10_ok } } } */\n+/* { dg-lto-options { \"-O2 -mdejagnu-cpu=power8 -mno-power8-fusion -flto -fdump-ipa-inline\" } } */\n+\n+int\n+foo1 (int *b)\n+{\n+  *b += 100;\n+  return *b;\n+}\n+\n+/* { dg-final { scan-wpa-ipa-dump-not \"target specific option mismatch\" \"inline\"  } } */"}, {"sha": "2e5570d127eac4b068982d6ae70828b891a55cf7", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-2_1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_1.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,9 @@\n+extern int foo1 (int *b);\n+\n+int foo2 (int *b)\n+{\n+  int res = foo1 (b);\n+  *b += res;\n+  return *b;\n+}\n+"}, {"sha": "31951701816cdfe33ae75ebc6469b750d5d7ae39", "filename": "gcc/testsuite/gcc.dg/lto/pr102059-2_2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr102059-2_2.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,10 @@\n+extern int foo2 (int *b);\n+\n+#pragma GCC target \"cpu=power10\"\n+int\n+main (int *a)\n+{\n+  *a = foo2 (a);\n+  return 0;\n+}\n+"}, {"sha": "b969c4c4750a6b8632899397c204ea1da1a4e8fb", "filename": "gcc/testsuite/gcc.target/powerpc/pr102059-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-1.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* -Wno-attributes suppresses always_inline warnings.  */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power8 -Wno-attributes\" } */\n+\n+/* Verify the reduced case from PR102059 won't fail.  */\n+\n+__attribute__ ((always_inline)) int\n+foo (int *b)\n+{\n+  *b += 10;\n+  return *b;\n+}\n+\n+#pragma GCC target \"cpu=power10\"\n+int\n+bar (int *a)\n+{\n+  *a = foo (a);\n+  return 0;\n+}\n+"}, {"sha": "52e009289f7179ec161694464b01af6a118e5d2b", "filename": "gcc/testsuite/gcc.target/powerpc/pr102059-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-2.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power8 -mno-htm\" } */\n+\n+/* Verify target info for inlining still works even if callee\n+   disables HTM explicitly while caller enables it.  */\n+\n+static inline int __attribute__ ((always_inline))\n+foo (int *b)\n+{\n+  *b += 10;\n+  return *b;\n+}\n+\n+#pragma GCC target \"htm\"\n+int\n+bar (int *a)\n+{\n+  *a = foo (a);\n+  return 0;\n+}\n+"}, {"sha": "21c982d93f03d7e166e55009b0dd94ce74f7da30", "filename": "gcc/testsuite/gcc.target/powerpc/pr102059-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc60c183358be2f2003b94226ab49e21c585b13/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr102059-3.c?ref=0fc60c183358be2f2003b94226ab49e21c585b13", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power8 -mno-power8-fusion -fdump-tree-einline-optimized\" } */\n+\n+/* Like pr102059-1.c, to verify the inlining still happens\n+   even without always_inline attribute.  */\n+\n+int foo (int *b)\n+{\n+  *b += 10;\n+  return *b;\n+}\n+\n+#pragma GCC target \"cpu=power10\"\n+int\n+bar (int *a)\n+{\n+  *a = foo (a);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {Inlining foo/[0-9]* } 1 \"einline\"} } */"}]}