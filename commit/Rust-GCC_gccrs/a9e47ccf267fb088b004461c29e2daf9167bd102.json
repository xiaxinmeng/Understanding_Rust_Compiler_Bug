{"sha": "a9e47ccf267fb088b004461c29e2daf9167bd102", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTllNDdjY2YyNjdmYjA4OGIwMDQ0NjFjMjllMmRhZjkxNjdiZDEwMg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2019-06-18T08:49:40Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2019-06-18T08:49:40Z"}, "message": "Darwin - strip trailing whitespace from a file, NFC.\n\n2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>\n\n        * config/darwin.c: Strip trailing whitespace.\n\nFrom-SVN: r272410", "tree": {"sha": "1d240b5939ff8b103b0396e9e771194346205d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d240b5939ff8b103b0396e9e771194346205d4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9e47ccf267fb088b004461c29e2daf9167bd102", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e47ccf267fb088b004461c29e2daf9167bd102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e47ccf267fb088b004461c29e2daf9167bd102", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e47ccf267fb088b004461c29e2daf9167bd102/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbe89f49da468fbd42a27bdb7b8f06de76a871b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe89f49da468fbd42a27bdb7b8f06de76a871b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe89f49da468fbd42a27bdb7b8f06de76a871b4"}], "stats": {"total": 258, "additions": 131, "deletions": 127}, "files": [{"sha": "06cdba5d15c115ad4cec79be779668bfb03fd550", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e47ccf267fb088b004461c29e2daf9167bd102/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e47ccf267fb088b004461c29e2daf9167bd102/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9e47ccf267fb088b004461c29e2daf9167bd102", "patch": "@@ -1,3 +1,7 @@\n+2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+        * config/darwin.c: Strip trailing whitespace.\n+\n 2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/darwin.c (darwin_emit_unwind_label): New default to false."}, {"sha": "ef6e3891d9a11f89ee7201031a7772a11af976cf", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e47ccf267fb088b004461c29e2daf9167bd102/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e47ccf267fb088b004461c29e2daf9167bd102/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=a9e47ccf267fb088b004461c29e2daf9167bd102", "patch": "@@ -115,7 +115,7 @@ section * darwin_sections[NUM_DARWIN_SECTIONS];\n /* True if we're setting __attribute__ ((ms_struct)).  */\n int darwin_ms_struct = false;\n \n-/* Earlier versions of Darwin as do not recognize an alignment field in \n+/* Earlier versions of Darwin as do not recognize an alignment field in\n    .comm directives, this should be set for versions that allow it.  */\n int emit_aligned_common = false;\n \n@@ -127,8 +127,8 @@ output_objc_section_asm_op (const void *directive)\n {\n   static bool been_here = false;\n \n-  /* The NeXT ObjC Runtime requires these sections to be present and in \n-     order in the object.  The code below implements this by emitting \n+  /* The NeXT ObjC Runtime requires these sections to be present and in\n+     order in the object.  The code below implements this by emitting\n      a section header for each ObjC section the first time that an ObjC\n      section is requested.  */\n   if (! been_here)\n@@ -238,7 +238,7 @@ name_needs_quotes (const char *name)\n {\n   int c;\n   while ((c = *name++) != '\\0')\n-    if (! ISIDNUM (c) \n+    if (! ISIDNUM (c)\n \t  && c != '.' && c != '$' && c != '_' )\n       return 1;\n   return 0;\n@@ -710,8 +710,8 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n       ptr_ref = gen_const_mem (Pmode, ptr_ref);\n       machopic_define_symbol (ptr_ref);\n \n-      if (DARWIN_X86 \n-          && reg \n+      if (DARWIN_X86\n+          && reg\n           && MACHO_DYNAMIC_NO_PIC_P)\n \t{\n \t    emit_insn (gen_rtx_SET (reg, ptr_ref));\n@@ -727,12 +727,12 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n \t appropriate.  */\n       if (GET_CODE (XEXP (orig, 0)) == PLUS)\n \treturn machopic_indirect_data_reference (XEXP (orig, 0), reg);\n-      else \n+      else\n \treturn orig;\n     }\n   else if (GET_CODE (orig) == MEM)\n     {\n-      XEXP (ptr_ref, 0) = \n+      XEXP (ptr_ref, 0) =\n \t\tmachopic_indirect_data_reference (XEXP (orig, 0), reg);\n       return ptr_ref;\n     }\n@@ -1262,8 +1262,8 @@ static section *\n darwin_mergeable_string_section (tree exp,\n \t\t\t\t unsigned HOST_WIDE_INT align)\n {\n-  /* Darwin's ld expects to see non-writable string literals in the .cstring \n-     section.  Later versions of ld check and complain when CFStrings are \n+  /* Darwin's ld expects to see non-writable string literals in the .cstring\n+     section.  Later versions of ld check and complain when CFStrings are\n      enabled.  Therefore we shall force the strings into .cstring since we\n      don't support writable ones anyway.  */\n   if ((darwin_constant_cfstrings || flag_merge_constants)\n@@ -1296,8 +1296,8 @@ darwin_mergeable_constant_section (tree exp,\n   machine_mode mode = DECL_MODE (exp);\n   unsigned int modesize = GET_MODE_BITSIZE (mode);\n \n-  if (DARWIN_SECTION_ANCHORS \n-      && flag_section_anchors \n+  if (DARWIN_SECTION_ANCHORS\n+      && flag_section_anchors\n       && zsize)\n     return darwin_sections[zobj_const_section];\n \n@@ -1343,14 +1343,14 @@ machopic_reloc_rw_mask (void)\n \n /* We have to deal with ObjC/C++ metadata section placement in the common\n    code, since it will also be called from LTO.\n-   \n+\n    Return metadata attributes, if present (searching for ABI=2 first)\n    Return NULL_TREE if no such attributes are found.  */\n \n static tree\n is_objc_metadata (tree decl)\n {\n-  if (DECL_P (decl) \n+  if (DECL_P (decl)\n       && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)\n       && DECL_ATTRIBUTES (decl))\n     {\n@@ -1529,11 +1529,11 @@ machopic_select_section (tree decl,\n \t  && !lookup_attribute (\"weak_import\", DECL_ATTRIBUTES (decl)));\n \n   zsize = (DECL_P (decl)\n-\t   && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL) \n+\t   && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONST_DECL)\n \t   && tree_to_uhwi (DECL_SIZE_UNIT (decl)) == 0);\n \n   one = DECL_P (decl)\n-\t&& TREE_CODE (decl) == VAR_DECL \n+\t&& TREE_CODE (decl) == VAR_DECL\n \t&& DECL_COMDAT_GROUP (decl);\n \n   use_coal = (weak || one) && ld_uses_coal_sects;\n@@ -1574,17 +1574,17 @@ machopic_select_section (tree decl,\n \t{\n \t  if (ro)\n \t    base_section = darwin_sections[const_data_coal_section];\n-\t  else \n+\t  else\n \t    base_section = darwin_sections[data_coal_section];\n \t}\n-      else if (DARWIN_SECTION_ANCHORS \n+      else if (DARWIN_SECTION_ANCHORS\n \t       && flag_section_anchors\n \t       && zsize)\n \t{\n \t  /* If we're doing section anchors, then punt zero-sized objects into\n \t     their own sections so that they don't interfere with offset\n \t     computation for the remaining vars.  This does not need to be done\n-\t     for stuff in mergeable sections, since these are ineligible for \n+\t     for stuff in mergeable sections, since these are ineligible for\n \t     anchors.  */\n \t  if (ro)\n \t    base_section = darwin_sections[zobj_const_data_section];\n@@ -1616,10 +1616,10 @@ machopic_select_section (tree decl,\n       gcc_unreachable ();\n     }\n \n-  /* Darwin weird special cases.  \n+  /* Darwin weird special cases.\n      a) OBJC Meta-data. */\n-  if (DECL_P (decl) \n-      && (TREE_CODE (decl) == VAR_DECL \n+  if (DECL_P (decl)\n+      && (TREE_CODE (decl) == VAR_DECL\n \t  || TREE_CODE (decl) == CONST_DECL)\n       && DECL_ATTRIBUTES (decl))\n     {\n@@ -1671,10 +1671,10 @@ machopic_select_section (tree decl,\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n       static bool warned_objc_46 = false;\n-      /* We shall assert that zero-sized objects are an error in ObjC \n+      /* We shall assert that zero-sized objects are an error in ObjC\n          meta-data.  */\n       gcc_assert (tree_to_uhwi (DECL_SIZE_UNIT (decl)) != 0);\n-      \n+\n       /* ??? This mechanism for determining the metadata section is\n \t broken when LTO is in use, since the frontend that generated\n \t the data is not identified.  We will keep the capability for\n@@ -1688,7 +1688,7 @@ machopic_select_section (tree decl,\n \t\t      \" and will be removed in 4.7\");\n \t  warned_objc_46 = true;\n \t}\n-      \n+\n       if (!strncmp (name, \"_OBJC_CLASS_METHODS_\", 20))\n         return darwin_sections[objc_cls_meth_section];\n       else if (!strncmp (name, \"_OBJC_INSTANCE_METHODS_\", 23))\n@@ -1814,12 +1814,12 @@ sort_cdtor_records (const void * a, const void * b)\n   return 0;\n }\n \n-static void \n+static void\n finalize_ctors ()\n {\n   unsigned int i;\n   cdtor_record *elt;\n- \n+\n   if (MACHOPIC_INDIRECT)\n     switch_to_section (darwin_sections[mod_init_section]);\n   else\n@@ -1861,11 +1861,11 @@ darwin_globalize_label (FILE *stream, const char *name)\n     default_globalize_label (stream, name);\n }\n \n-/* This routine returns non-zero if 'name' starts with the special objective-c \n-   anonymous file-scope static name.  It accommodates c++'s mangling of such \n+/* This routine returns non-zero if 'name' starts with the special objective-c\n+   anonymous file-scope static name.  It accommodates c++'s mangling of such\n    symbols (in this case the symbols will have form _ZL{d}*_OBJC_* d=digit).  */\n-   \n-int \n+\n+int\n darwin_label_is_anonymous_local_objc_name (const char *name)\n {\n   const unsigned char *p = (const unsigned char *) name;\n@@ -2083,19 +2083,19 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)\n   char buf[32];\n   static int invok_count = 0;\n   static tree last_fun_decl = NULL_TREE;\n-  \n+\n   /* Modern linkers can produce distinct FDEs without compiler support.  */\n   if (! for_eh || ! ld_needs_eh_markers)\n     return;\n \n-  /* FIXME: This only works when the eh for all sections of a function are \n+  /* FIXME: This only works when the eh for all sections of a function are\n      emitted at the same time.  If that changes, we would need to use a lookup\n      table of some form to determine what to do.  Also, we should emit the\n      unadorned label for the partition containing the public label for a\n      function.  This is of limited use, probably, since we do not currently\n      enable partitioning.  */\n   strcpy (buf, \".eh\");\n-  if (decl && TREE_CODE (decl) == FUNCTION_DECL) \n+  if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (decl == last_fun_decl)\n         {\n@@ -2191,8 +2191,8 @@ darwin_non_lazy_pcrel (FILE *file, rtx addr)\n    The machopic_define_symbol calls are telling the machopic subsystem\n    that the name *is* defined in this module, so it doesn't need to\n    make them indirect.  */\n-void \n-darwin_asm_declare_object_name (FILE *file, \n+void\n+darwin_asm_declare_object_name (FILE *file,\n \t\t\t\tconst char *nam, tree decl)\n {\n   const char *xname = nam;\n@@ -2201,11 +2201,11 @@ darwin_asm_declare_object_name (FILE *file,\n \n   weak = (DECL_P (decl)\n \t  && DECL_WEAK (decl)\n-\t  && !lookup_attribute (\"weak_import\", \n+\t  && !lookup_attribute (\"weak_import\",\n \t\t\t\t DECL_ATTRIBUTES (decl)));\n \n-  local_def = DECL_INITIAL (decl) || (TREE_STATIC (decl) \n-\t\t\t\t      && (!DECL_COMMON (decl) \n+  local_def = DECL_INITIAL (decl) || (TREE_STATIC (decl)\n+\t\t\t\t      && (!DECL_COMMON (decl)\n \t\t\t\t\t  || !TREE_PUBLIC (decl)));\n \n   if (GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n@@ -2223,17 +2223,17 @@ darwin_asm_declare_object_name (FILE *file,\n #ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n fprintf (file, \"# dadon: %s %s (%llu, %u) local %d weak %d\"\n \t       \" stat %d com %d pub %d t-const %d t-ro %d init %lx\\n\",\n-\txname, (TREE_CODE (decl) == VAR_DECL?\"var\":\"const\"), \n-\t(unsigned long long)size, DECL_ALIGN (decl), local_def, \n+\txname, (TREE_CODE (decl) == VAR_DECL?\"var\":\"const\"),\n+\t(unsigned long long)size, DECL_ALIGN (decl), local_def,\n \tDECL_WEAK (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n \tTREE_PUBLIC (decl), TREE_CONSTANT (decl), TREE_READONLY (decl),\n-\t(unsigned long)DECL_INITIAL (decl)); \n+\t(unsigned long)DECL_INITIAL (decl));\n #endif\n \n-  /* Darwin needs help to support local zero-sized objects. \n+  /* Darwin needs help to support local zero-sized objects.\n      They must be made at least one byte, and the section containing must be\n      marked as unsuitable for section-anchors (see storage allocators below).\n-     \n+\n      For non-zero objects this output is handled by varasm.c.\n   */\n   if (!size)\n@@ -2254,7 +2254,7 @@ fprintf (file, \"# dadon: %s %s (%llu, %u) local %d weak %d\"\n       /* Check that we've correctly picked up the zero-sized item and placed it\n          properly.  */\n       gcc_assert ((!DARWIN_SECTION_ANCHORS || !flag_section_anchors)\n-\t\t  || (in_section \n+\t\t  || (in_section\n \t\t      && (in_section->common.flags & SECTION_NO_ANCHOR)));\n     }\n   else\n@@ -2275,7 +2275,7 @@ darwin_asm_declare_constant_name (FILE *file, const char *name,\n       /* Check that we've correctly picked up the zero-sized item and placed it\n          properly.  */\n       gcc_assert ((!DARWIN_SECTION_ANCHORS || !flag_section_anchors)\n-\t\t  || (in_section \n+\t\t  || (in_section\n \t\t      && (in_section->common.flags & SECTION_NO_ANCHOR)));\n     }\n }\n@@ -2301,7 +2301,7 @@ darwin_asm_declare_constant_name (FILE *file, const char *name,\n /* Emit a chunk of data for items coalesced by the linker.  */\n static void\n darwin_emit_weak_or_comdat (FILE *fp, tree decl, const char *name,\n-\t\t\t\t  unsigned HOST_WIDE_INT size, \n+\t\t\t\t  unsigned HOST_WIDE_INT size,\n \t\t\t\t  bool use_coal,\n \t\t\t\t  unsigned int align)\n {\n@@ -2323,7 +2323,7 @@ darwin_emit_weak_or_comdat (FILE *fp, tree decl, const char *name,\n   if (TREE_PUBLIC (decl))\n     darwin_globalize_label (fp, name);\n \n-  /* ... and we let it deal with outputting one byte of zero for them too.  */ \n+  /* ... and we let it deal with outputting one byte of zero for them too.  */\n   darwin_asm_declare_object_name (fp, name, decl);\n   if (size)\n     assemble_zeros (size);\n@@ -2332,7 +2332,7 @@ darwin_emit_weak_or_comdat (FILE *fp, tree decl, const char *name,\n /* Emit a chunk of data for ObjC meta-data that got placed in BSS erroneously.  */\n static void\n darwin_emit_objc_zeroed (FILE *fp, tree decl, const char *name,\n-\t\t\t\t  unsigned HOST_WIDE_INT size, \n+\t\t\t\t  unsigned HOST_WIDE_INT size,\n \t\t\t\t  unsigned int align, tree meta)\n {\n   section *ocs = data_section;\n@@ -2348,14 +2348,14 @@ darwin_emit_objc_zeroed (FILE *fp, tree decl, const char *name,\n   gcc_assert (size);\n   fprintf (fp, \"\\t.align\\t%d\\n\", floor_log2 (align / BITS_PER_UNIT));\n \n-  /* ... and we let it deal with outputting one byte of zero for them too.  */ \n+  /* ... and we let it deal with outputting one byte of zero for them too.  */\n   darwin_asm_declare_object_name (fp, name, decl);\n   assemble_zeros (size);\n }\n \n /* This routine emits 'local' storage:\n \n-   When Section Anchors are off this routine emits .zerofill commands in \n+   When Section Anchors are off this routine emits .zerofill commands in\n    sections named for their alignment.\n \n    When Section Anchors are on, smaller (non-zero-sized) items are placed in\n@@ -2364,8 +2364,8 @@ darwin_emit_objc_zeroed (FILE *fp, tree decl, const char *name,\n    The routine has no checking - it is all assumed to be done by the caller.\n */\n static void\n-darwin_emit_local_bss (FILE *fp, tree decl, const char *name, \n-\t\t\tunsigned HOST_WIDE_INT size, \n+darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n+\t\t\tunsigned HOST_WIDE_INT size,\n \t\t\tunsigned int l2align)\n {\n    /* FIXME: We have a fudge to make this work with Java even when the target does\n@@ -2393,17 +2393,17 @@ darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n       if (l2align)\n \tfprintf (fp, \"\\t.align\\t%u\\n\", l2align);\n \n-      assemble_name (fp, name);        \n+      assemble_name (fp, name);\n       fprintf (fp, \":\\n\\t.space\\t\" HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n     }\n-  else \n+  else\n     {\n       /* When we are on a non-section anchor target, we can get zero-sized\n \t items here.  However, all we need to do is to bump them to one byte\n \t and the section alignment will take care of the rest.  */\n       char secnam[64];\n       unsigned int flags ;\n-      snprintf (secnam, 64, \"__DATA,__%sbss%u\", ((size)?\"\":\"zo_\"), \n+      snprintf (secnam, 64, \"__DATA,__%sbss%u\", ((size)?\"\":\"zo_\"),\n \t\t\t\t\t\t(unsigned) l2align);\n       /* We can't anchor (yet, if ever) in zerofill sections, because we can't\n \t switch to them and emit a label.  */\n@@ -2429,12 +2429,12 @@ darwin_emit_local_bss (FILE *fp, tree decl, const char *name,\n /* Emit a chunk of common.  */\n static void\n darwin_emit_common (FILE *fp, const char *name,\n-\t\t    unsigned HOST_WIDE_INT size, unsigned int align) \n+\t\t    unsigned HOST_WIDE_INT size, unsigned int align)\n {\n   unsigned HOST_WIDE_INT rounded;\n   unsigned int l2align;\n \n-  /* Earlier systems complain if the alignment exceeds the page size. \n+  /* Earlier systems complain if the alignment exceeds the page size.\n      The magic number is 4096 * 8 - hard-coded for legacy systems.  */\n   if (!emit_aligned_common && (align > 32768UL))\n     align = 4096UL; /* In units.  */\n@@ -2445,9 +2445,9 @@ darwin_emit_common (FILE *fp, const char *name,\n   if (!align)\n     align = 1;\n \n-  /* For earlier toolchains, we need to emit the var as a rounded size to \n+  /* For earlier toolchains, we need to emit the var as a rounded size to\n      tell ld the alignment.  */\n-  if (size < align) \n+  if (size < align)\n     rounded = align;\n   else\n     rounded = (size + (align-1)) & ~(align-1);\n@@ -2468,7 +2468,7 @@ darwin_emit_common (FILE *fp, const char *name,\n \n   fputs (\"\\t.comm\\t\", fp);\n   assemble_name (fp, name);\n-  fprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED, \n+  fprintf (fp, \",\" HOST_WIDE_INT_PRINT_UNSIGNED,\n \t   emit_aligned_common?size:rounded);\n   if (l2align && emit_aligned_common)\n     fprintf (fp, \",%u\", l2align);\n@@ -2490,18 +2490,18 @@ darwin_output_aligned_bss (FILE *fp, tree decl, const char *name,\n   one = DECL_ONE_ONLY (decl);\n   weak = (DECL_P (decl)\n \t  && DECL_WEAK (decl)\n-\t  && !lookup_attribute (\"weak_import\", \n+\t  && !lookup_attribute (\"weak_import\",\n \t\t\t\t DECL_ATTRIBUTES (decl)));\n \n #ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n \t     \" pub %d weak %d one %d init %lx\\n\",\n-\tname, (long long)size, (int)align, TREE_READONLY (decl), \n+\tname, (long long)size, (int)align, TREE_READONLY (decl),\n \tTREE_CONSTANT (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n-\tpub, weak, one, (unsigned long)DECL_INITIAL (decl)); \n+\tpub, weak, one, (unsigned long)DECL_INITIAL (decl));\n #endif\n \n-  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS\n      before the target has a chance to comment.  */\n   if ((meta = is_objc_metadata (decl)))\n     {\n@@ -2510,8 +2510,8 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n     }\n \n   /* Check that any initializer is valid.  */\n-  gcc_assert ((DECL_INITIAL (decl) == NULL) \n-\t       || (DECL_INITIAL (decl) == error_mark_node) \n+  gcc_assert ((DECL_INITIAL (decl) == NULL)\n+\t       || (DECL_INITIAL (decl) == error_mark_node)\n \t       || initializer_zerop (DECL_INITIAL (decl)));\n \n   gcc_assert (DECL_SECTION_NAME (decl) == NULL);\n@@ -2523,32 +2523,32 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n \n   l2align = floor_log2 (align / BITS_PER_UNIT);\n   gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);\n-  \n+\n   last_assemble_variable_decl = decl;\n \n   /* We would rather not have to check this here - but it seems that we might\n      be passed a decl that should be in coalesced space.  */\n   if (one || weak)\n     {\n       /* Weak or COMDAT objects are put in mergeable sections.  */\n-      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+      darwin_emit_weak_or_comdat (fp, decl, name, size,\n \t\t\t\t  ld_uses_coal_sects, DECL_ALIGN (decl));\n       return;\n-    } \n+    }\n \n   /* If this is not public, then emit according to local rules.  */\n   if (!pub)\n     {\n-      darwin_emit_local_bss (fp, decl, name, size, l2align);\t\n+      darwin_emit_local_bss (fp, decl, name, size, l2align);\n       return;\n     }\n \n   /* So we have a public symbol (small item fudge for Java, see above).  */\n-  if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL) \n+  if ((DARWIN_SECTION_ANCHORS && flag_section_anchors && size < BYTES_ZFILL)\n        || (size && size <= 2))\n     {\n       /* Put smaller objects in data, where the section anchors system can get\n-\t them.  However, if they are zero-sized punt them to yet a different \n+\t them.  However, if they are zero-sized punt them to yet a different\n \t section (that is not allowed to participate in anchoring).  */\n       if (!size)\n \t{\n@@ -2568,7 +2568,7 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n       assemble_name (fp, name);\n       fprintf (fp, \":\\n\\t.space\\t\" HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", size);\n     }\n-  else \n+  else\n     {\n       char secnam[64];\n       unsigned int flags ;\n@@ -2598,7 +2598,7 @@ fprintf (fp, \"# albss: %s (%lld,%d) ro %d cst %d stat %d com %d\"\n    supports this).  */\n void\n darwin_asm_output_aligned_decl_common (FILE *fp, tree decl, const char *name,\n-\t\t\t\t       unsigned HOST_WIDE_INT size, \n+\t\t\t\t       unsigned HOST_WIDE_INT size,\n \t\t\t\t       unsigned int align)\n {\n   unsigned int l2align;\n@@ -2609,7 +2609,7 @@ darwin_asm_output_aligned_decl_common (FILE *fp, tree decl, const char *name,\n   if (decl==NULL)\n     {\n #ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n-fprintf (fp, \"# adcom: %s (%d,%d) decl=0x0\\n\", name, (int)size, (int)align); \n+fprintf (fp, \"# adcom: %s (%d,%d) decl=0x0\\n\", name, (int)size, (int)align);\n #endif\n       darwin_emit_common (fp, name, size, align);\n       return;\n@@ -2618,18 +2618,18 @@ fprintf (fp, \"# adcom: %s (%d,%d) decl=0x0\\n\", name, (int)size, (int)align);\n   one = DECL_ONE_ONLY (decl);\n   weak = (DECL_P (decl)\n \t  && DECL_WEAK (decl)\n-\t  && !lookup_attribute (\"weak_import\", \n+\t  && !lookup_attribute (\"weak_import\",\n \t\t\t\t DECL_ATTRIBUTES (decl)));\n \n #ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n fprintf (fp, \"# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d\"\n \t     \" weak %d one %d init %lx\\n\",\n-\tname,  (long long)size, (int)align, TREE_READONLY (decl), \n+\tname,  (long long)size, (int)align, TREE_READONLY (decl),\n \tTREE_CONSTANT (decl), TREE_STATIC (decl), DECL_COMMON (decl),\n-\tTREE_PUBLIC (decl), weak, one, (unsigned long)DECL_INITIAL (decl)); \n+\tTREE_PUBLIC (decl), weak, one, (unsigned long)DECL_INITIAL (decl));\n #endif\n \n-  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS\n      before the target has a chance to comment.  */\n   if ((meta = is_objc_metadata (decl)))\n     {\n@@ -2645,24 +2645,24 @@ fprintf (fp, \"# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d\"\n   if (one || weak)\n     {\n       /* Weak or COMDAT objects are put in mergable sections.  */\n-      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+      darwin_emit_weak_or_comdat (fp, decl, name, size,\n \t\t\t\t  ld_uses_coal_sects, DECL_ALIGN (decl));\n       return;\n-    } \n+    }\n \n-  /* We should only get here for DECL_COMMON, with a zero init (and, in \n+  /* We should only get here for DECL_COMMON, with a zero init (and, in\n      principle, only for public symbols too - although we deal with local\n      ones below).  */\n \n   /* Check the initializer is OK.  */\n-  gcc_assert (DECL_COMMON (decl) \n-\t      && ((DECL_INITIAL (decl) == NULL) \n-\t       || (DECL_INITIAL (decl) == error_mark_node) \n+  gcc_assert (DECL_COMMON (decl)\n+\t      && ((DECL_INITIAL (decl) == NULL)\n+\t       || (DECL_INITIAL (decl) == error_mark_node)\n \t       || initializer_zerop (DECL_INITIAL (decl))));\n \n   last_assemble_variable_decl = decl;\n \n-  if (!size || !align) \n+  if (!size || !align)\n     align = DECL_ALIGN (decl);\n \n   l2align = floor_log2 (align / BITS_PER_UNIT);\n@@ -2672,13 +2672,13 @@ fprintf (fp, \"# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d\"\n   if (TREE_PUBLIC (decl) != 0)\n     darwin_emit_common (fp, name, size, align);\n   else\n-    darwin_emit_local_bss (fp, decl, name, size, l2align);\t\n+    darwin_emit_local_bss (fp, decl, name, size, l2align);\n }\n \n /* Output a chunk of BSS with alignment specfied.  */\n void\n-darwin_asm_output_aligned_decl_local (FILE *fp, tree decl, const char *name, \n-\t\t\t\t      unsigned HOST_WIDE_INT size, \n+darwin_asm_output_aligned_decl_local (FILE *fp, tree decl, const char *name,\n+\t\t\t\t      unsigned HOST_WIDE_INT size,\n \t\t\t\t      unsigned int align)\n {\n   unsigned long l2align;\n@@ -2688,18 +2688,18 @@ darwin_asm_output_aligned_decl_local (FILE *fp, tree decl, const char *name,\n   one = DECL_ONE_ONLY (decl);\n   weak = (DECL_P (decl)\n \t  && DECL_WEAK (decl)\n-\t  && !lookup_attribute (\"weak_import\", \n+\t  && !lookup_attribute (\"weak_import\",\n \t\t\t\t DECL_ATTRIBUTES (decl)));\n \n #ifdef DEBUG_DARWIN_MEM_ALLOCATORS\n fprintf (fp, \"# adloc: %s (%lld,%d) ro %d cst %d stat %d one %d pub %d\"\n \t     \" weak %d init %lx\\n\",\n-\tname, (long long)size, (int)align, TREE_READONLY (decl), \n+\tname, (long long)size, (int)align, TREE_READONLY (decl),\n \tTREE_CONSTANT (decl), TREE_STATIC (decl), one, TREE_PUBLIC (decl),\n-\tweak , (unsigned long)DECL_INITIAL (decl)); \n+\tweak , (unsigned long)DECL_INITIAL (decl));\n #endif\n \n-  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS \n+  /* ObjC metadata can get put in BSS because varasm.c decides it's BSS\n      before the target has a chance to comment.  */\n   if ((meta = is_objc_metadata (decl)))\n     {\n@@ -2715,16 +2715,16 @@ fprintf (fp, \"# adloc: %s (%lld,%d) ro %d cst %d stat %d one %d pub %d\"\n   if (one || weak)\n     {\n       /* Weak or COMDAT objects are put in mergable sections.  */\n-      darwin_emit_weak_or_comdat (fp, decl, name, size, \n+      darwin_emit_weak_or_comdat (fp, decl, name, size,\n \t\t\t\t  ld_uses_coal_sects, DECL_ALIGN (decl));\n       return;\n-    } \n+    }\n \n   /* .. and it should be suitable for placement in local mem.  */\n   gcc_assert(!TREE_PUBLIC (decl) && !DECL_COMMON (decl));\n   /* .. and any initializer must be all-zero.  */\n-  gcc_assert ((DECL_INITIAL (decl) == NULL) \n-\t       || (DECL_INITIAL (decl) == error_mark_node) \n+  gcc_assert ((DECL_INITIAL (decl) == NULL)\n+\t       || (DECL_INITIAL (decl) == error_mark_node)\n \t       || initializer_zerop (DECL_INITIAL (decl)));\n \n   last_assemble_variable_decl = decl;\n@@ -2763,7 +2763,7 @@ darwin_assemble_visibility (tree decl, int vis)\n \n /* vec used by darwin_asm_dwarf_section.\n    Maybe a hash tab would be better here - but the intention is that this is\n-   a very short list (fewer than 16 items) and each entry should (ideally, \n+   a very short list (fewer than 16 items) and each entry should (ideally,\n    eventually) only be presented once.\n \n    A structure to hold a dwarf debug section used entry.  */\n@@ -2778,7 +2778,7 @@ dwarf_sect_used_entry;\n /* A list of used __DWARF sections.  */\n static GTY (()) vec<dwarf_sect_used_entry, va_gc> *dwarf_sect_names_table;\n \n-/* This is called when we are asked to assemble a named section and the \n+/* This is called when we are asked to assemble a named section and the\n    name begins with __DWARF,.  We keep a list of the section names (without\n    the __DWARF, prefix) and use this to emit our required start label on the\n    first switch to each section.  */\n@@ -2819,7 +2819,7 @@ darwin_asm_dwarf_section (const char *name, unsigned int flags,\n   if (dwarf_sect_names_table == NULL)\n     vec_alloc (dwarf_sect_names_table, 16);\n   else\n-    for (i = 0; \n+    for (i = 0;\n \t dwarf_sect_names_table->iterate (i, &ref);\n \t i++)\n       {\n@@ -3159,9 +3159,9 @@ darwin_override_options (void)\n \t\t\t\t    \" %<-fnext-runtime%>\");\n     }\n \n-  /* Don't emit DWARF3/4 unless specifically selected.  This is a \n+  /* Don't emit DWARF3/4 unless specifically selected.  This is a\n      workaround for tool bugs.  */\n-  if (!global_options_set.x_dwarf_strict) \n+  if (!global_options_set.x_dwarf_strict)\n     dwarf_strict = 1;\n   if (!global_options_set.x_dwarf_version)\n     dwarf_version = 2;\n@@ -3174,7 +3174,7 @@ darwin_override_options (void)\n       global_options_set.x_dwarf_split_debug_info = 0;\n     }\n \n-  /* Do not allow unwind tables to be generated by default for m32.  \n+  /* Do not allow unwind tables to be generated by default for m32.\n      fnon-call-exceptions will override this, regardless of what we do.  */\n   if (generating_for_darwin_version < 10\n       && !global_options_set.x_flag_asynchronous_unwind_tables\n@@ -3208,7 +3208,7 @@ darwin_override_options (void)\n     /* FIXME: flag_objc_sjlj_exceptions is no longer needed since there is only\n        one valid choice of exception scheme for each runtime.  */\n     if (!global_options_set.x_flag_objc_sjlj_exceptions)\n-      global_options.x_flag_objc_sjlj_exceptions = \n+      global_options.x_flag_objc_sjlj_exceptions =\n \t\t\t\tflag_next_runtime && !TARGET_64BIT;\n \n     /* FIXME: and this could be eliminated then too.  */\n@@ -3259,7 +3259,7 @@ darwin_override_options (void)\n \n   /* Linkers >= ld64-62.1 (at least) are capable of making the necessary PIC\n      indirections and we no longer need to emit pic symbol stubs.\n-     However, if we are generating code for earlier ones (or for use in the \n+     However, if we are generating code for earlier ones (or for use in the\n      kernel) the stubs might still be required, and this will be set true.\n      If the user sets it on or off - then that takes precedence.\n \n@@ -3268,18 +3268,18 @@ darwin_override_options (void)\n \n   if (!global_options_set.x_darwin_picsymbol_stubs)\n     {\n-      if (darwin_target_linker) \n+      if (darwin_target_linker)\n \t{\n \t  if (strverscmp (darwin_target_linker, MIN_LD64_OMIT_STUBS) < 0)\n \t    {\n \t      darwin_picsymbol_stubs = true;\n \t      ld_needs_eh_markers = true;\n \t    }\n-\t} \n+\t}\n       else if (generating_for_darwin_version < 9)\n \t{\n \t  /* If we don't know the linker version and we're targeting an old\n-\t     system, we know no better than to assume the use of an earlier \n+\t     system, we know no better than to assume the use of an earlier\n \t     linker.  */\n \t  darwin_picsymbol_stubs = true;\n \t  ld_needs_eh_markers = true;\n@@ -3375,7 +3375,7 @@ static GTY (()) hash_table<cfstring_hasher> *cfstring_htab;\n static tree\n add_builtin_field_decl (tree type, const char *name, tree **chain)\n {\n-  tree field = build_decl (BUILTINS_LOCATION, FIELD_DECL, \n+  tree field = build_decl (BUILTINS_LOCATION, FIELD_DECL,\n \t\t\t    get_identifier (name), type);\n \n   if (*chain != NULL)\n@@ -3391,20 +3391,20 @@ darwin_init_cfstring_builtins (unsigned builtin_cfstring)\n   tree cfsfun, fields, pccfstring_ftype_pcchar;\n   tree *chain = NULL;\n \n-  darwin_builtin_cfstring = \n+  darwin_builtin_cfstring =\n     (enum built_in_function) builtin_cfstring;\n-  \n+\n   /* struct __builtin_CFString {\n        const int *isa;\t\t(will point at\n        int flags;\t\t __CFConstantStringClassReference)\n        const char *str;\n        long length;\n      };  */\n \n-  pcint_type_node = build_pointer_type \n+  pcint_type_node = build_pointer_type\n \t\t   (build_qualified_type (integer_type_node, TYPE_QUAL_CONST));\n \n-  pcchar_type_node = build_pointer_type \n+  pcchar_type_node = build_pointer_type\n \t\t   (build_qualified_type (char_type_node, TYPE_QUAL_CONST));\n \n   cfstring_type_node = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -3420,13 +3420,13 @@ darwin_init_cfstring_builtins (unsigned builtin_cfstring)\n   /* const struct __builtin_CFstring *\n      __builtin___CFStringMakeConstantString (const char *); */\n \n-  ccfstring_type_node = build_qualified_type \n+  ccfstring_type_node = build_qualified_type\n \t\t\t(cfstring_type_node, TYPE_QUAL_CONST);\n   pccfstring_type_node = build_pointer_type (ccfstring_type_node);\n-  pccfstring_ftype_pcchar = build_function_type_list \n+  pccfstring_ftype_pcchar = build_function_type_list\n \t\t\t(pccfstring_type_node, pcchar_type_node, NULL_TREE);\n \n-  cfsfun  = build_decl (BUILTINS_LOCATION, FUNCTION_DECL, \n+  cfsfun  = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n \t\t\tget_identifier (\"__builtin___CFStringMakeConstantString\"),\n \t\t\tpccfstring_ftype_pcchar);\n \n@@ -3451,24 +3451,24 @@ darwin_init_cfstring_builtins (unsigned builtin_cfstring)\n   (*lang_hooks.decls.pushdecl) (cfstring_class_reference);\n   DECL_EXTERNAL (cfstring_class_reference) = 1;\n   rest_of_decl_compilation (cfstring_class_reference, 0, 0);\n-  \n+\n   /* Initialize the hash table used to hold the constant CFString objects.  */\n   cfstring_htab = hash_table<cfstring_hasher>::create_ggc (31);\n \n   return cfstring_type_node;\n }\n \n tree\n-darwin_fold_builtin (tree fndecl, int n_args, tree *argp, \n+darwin_fold_builtin (tree fndecl, int n_args, tree *argp,\n \t\t     bool ARG_UNUSED (ignore))\n {\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-  \n+\n   if (fcode == darwin_builtin_cfstring)\n     {\n       if (!darwin_constant_cfstrings)\n \t{\n-\t  error (\"built-in function %qD requires the\" \n+\t  error (\"built-in function %qD requires the\"\n \t\t \" %<-mconstant-cfstrings%> flag\", fndecl);\n \t  return error_mark_node;\n \t}\n@@ -3607,12 +3607,12 @@ darwin_build_constant_cfstring (tree str)\n \n       /* isa *. */\n       field = TYPE_FIELDS (ccfstring_type_node);\n-      CONSTRUCTOR_APPEND_ELT(v, NULL_TREE, \n-\t\t\t     build1 (ADDR_EXPR,  TREE_TYPE (field),  \n+      CONSTRUCTOR_APPEND_ELT(v, NULL_TREE,\n+\t\t\t     build1 (ADDR_EXPR,  TREE_TYPE (field),\n \t\t\t\t     cfstring_class_reference));\n       /* flags */\n       field = DECL_CHAIN (field);\n-      CONSTRUCTOR_APPEND_ELT(v, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT(v, NULL_TREE,\n \t\t\t     build_int_cst (TREE_TYPE (field), 0x000007c8));\n       /* string *. */\n       field = DECL_CHAIN (field);\n@@ -3636,7 +3636,7 @@ darwin_build_constant_cfstring (tree str)\n \tTREE_LANG_FLAG_4 (constructor) = 1;  /* TREE_HAS_CONSTRUCTOR  */\n \n       /* Create an anonymous global variable for this CFString.  */\n-      var = build_decl (input_location, CONST_DECL, \n+      var = build_decl (input_location, CONST_DECL,\n \t\t\tNULL, TREE_TYPE (constructor));\n       DECL_ARTIFICIAL (var) = 1;\n       TREE_STATIC (var) = 1;\n@@ -3670,7 +3670,7 @@ darwin_cfstring_p (tree str)\n \n   key.literal = str;\n   cfstring_descriptor **loc = cfstring_htab->find_slot (&key, NO_INSERT);\n-  \n+\n   if (loc)\n     return true;\n \n@@ -3702,7 +3702,7 @@ darwin_function_section (tree decl, enum node_frequency freq,\n   bool weak = (decl\n \t       && DECL_WEAK (decl)\n \t       && (!DECL_ATTRIBUTES (decl)\n-\t\t   || !lookup_attribute (\"weak_import\", \n+\t\t   || !lookup_attribute (\"weak_import\",\n \t\t\t\t\t  DECL_ATTRIBUTES (decl))));\n \n   bool use_coal = weak && ld_uses_coal_sects;"}]}