{"sha": "69048af1878e95e26b57febb701f884f513c7b93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwNDhhZjE4NzhlOTVlMjZiNTdmZWJiNzAxZjg4NGY1MTNjN2I5Mw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-29T14:11:41Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:18Z"}, "message": "Added cfg stripping for ExternalItems\n\nFixed non-renaming of has_variadic_outer_attrs()\n\nFixed old as_string function for ExternalItem\n\nFixed parse_named_function_param arguments", "tree": {"sha": "553c3d302a1e9ebf668b7d1629e33b09a525fbbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/553c3d302a1e9ebf668b7d1629e33b09a525fbbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69048af1878e95e26b57febb701f884f513c7b93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69048af1878e95e26b57febb701f884f513c7b93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69048af1878e95e26b57febb701f884f513c7b93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69048af1878e95e26b57febb701f884f513c7b93/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98d429466bf783ff1a7ac59bf800061d3e67061a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d429466bf783ff1a7ac59bf800061d3e67061a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d429466bf783ff1a7ac59bf800061d3e67061a"}], "stats": {"total": 401, "additions": 303, "deletions": 98}, "files": [{"sha": "1e95e479b3e38d143b67cc08322cc8cc6980708a", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -3979,6 +3979,7 @@ EnumItemDiscriminant::as_string () const\n   return str;\n }\n \n+#if 0\n std::string\n ExternalItem::as_string () const\n {\n@@ -3993,31 +3994,43 @@ ExternalItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n \n   return str;\n }\n+#endif\n \n std::string\n ExternalStaticItem::as_string () const\n {\n-  std::string str = ExternalItem::as_string ();\n+  // outer attributes\n+  std::string str = \"outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\t  str += \"\\n  \" + attr.as_string ();\n+    }\n+\n+  // start visibility on new line and with a space\n+  str += \"\\n\" + visibility.as_string () + \" \";\n \n   str += \"static \";\n \n   if (has_mut)\n-    {\n       str += \"mut \";\n-    }\n \n   // add name\n-  str += get_item_name ();\n+  str += item_name;\n \n   // add type on new line\n   str += \"\\n Type: \" + item_type->as_string ();\n@@ -4028,12 +4041,27 @@ ExternalStaticItem::as_string () const\n std::string\n ExternalFunctionItem::as_string () const\n {\n-  std::string str = ExternalItem::as_string ();\n+  // outer attributes\n+  std::string str = \"outer attributes: \";\n+  if (outer_attrs.empty ())\n+    {\n+      str += \"none\";\n+    }\n+  else\n+    {\n+      /* note that this does not print them with \"outer attribute\" syntax -\n+       * just the body */\n+      for (const auto &attr : outer_attrs)\n+\t  str += \"\\n  \" + attr.as_string ();\n+    }\n+\n+  // start visibility on new line and with a space\n+  str += \"\\n\" + visibility.as_string () + \" \";\n \n   str += \"fn \";\n \n   // add name\n-  str += get_item_name ();\n+  str += item_name;\n \n   // generic params\n   str += \"\\n Generic params: \";\n@@ -4061,19 +4089,29 @@ ExternalFunctionItem::as_string () const\n \n   // function params\n   str += \"\\n Function params: \";\n-  if (function_params.empty ())\n+  if (function_params.empty () && !has_variadics)\n     {\n       str += \"none\";\n     }\n   else\n     {\n       for (const auto &param : function_params)\n-\t{\n \t  str += \"\\n  \" + param.as_string ();\n-\t}\n+      \n       if (has_variadics)\n \t{\n-\t  str += \"\\n  .. (variadic)\";\n+    str += \"\\n  variadic outer attrs: \";\n+    if (has_variadic_outer_attrs ()) \n+      {\n+        \n+        for (const auto &attr : variadic_outer_attrs)\n+\t  str += \"\\n   \" + attr.as_string ();\n+      }\n+    else\n+      {\n+        str += \"none\";\n+      }\n+\t  str += \"\\n  ... (variadic)\";\n \t}\n     }\n \n@@ -4083,21 +4121,29 @@ ExternalFunctionItem::as_string () const\n   // where clause\n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n       str += where_clause.as_string ();\n-    }\n   else\n-    {\n       str += \"none\";\n-    }\n \n   return str;\n }\n \n std::string\n NamedFunctionParam::as_string () const\n {\n-  std::string str = name;\n+  std::string str = \"outer attributes: \";\n+\n+  if (!has_outer_attrs ()) \n+    {\n+      str += \"none\";\n+    } \n+  else \n+    {\n+      for (const auto& attr : outer_attrs)\n+        str += \"\\n \" + attr.as_string ();\n+    }\n+\n+  str += \"\\n\" + name;\n \n   str += \"\\n Type: \" + param_type->as_string ();\n "}, {"sha": "4c4b04360b9e2210968bf74d7a4ddf413bb1151e", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -1289,12 +1289,36 @@ class TraitImplItem\n   virtual void accept_vis (ASTVisitor &vis) = 0;\n };\n \n+// Abstract base class for an item used inside an extern block\n+class ExternalItem\n+{\n+public:\n+  virtual ~ExternalItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExternalItem> clone_external_item () const\n+  {\n+    return std::unique_ptr<ExternalItem> (clone_external_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual ExternalItem *clone_external_item_impl () const = 0;\n+};\n+\n /* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n  * invocation) */\n class MacroInvocationSemi : public MacroItem,\n \t\t\t    public TraitItem,\n \t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem\n+\t\t\t    public TraitImplItem, public ExternalItem\n {\n   std::vector<Attribute> outer_attrs;\n   SimplePath path;\n@@ -1394,6 +1418,13 @@ class MacroInvocationSemi : public MacroItem,\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_external_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n };\n \n // A crate AST object - holds all the data for a single compilation unit"}, {"sha": "8542638d96f3246167280dab5e5903fe276083bd", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 141, "deletions": 29, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -2964,6 +2964,7 @@ class TraitImpl : public Impl\n   TraitImpl *clone_item_impl () const override { return new TraitImpl (*this); }\n };\n \n+#if 0\n // Abstract base class for an item used inside an extern block\n class ExternalItem\n {\n@@ -3040,35 +3041,57 @@ class ExternalItem\n   // possibly make this public if required\n   std::string get_item_name () const { return item_name; }\n };\n+#endif\n \n // A static item used in an extern block\n class ExternalStaticItem : public ExternalItem\n {\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  // bool has_visibility;\n+  Visibility visibility;\n+\n+  Identifier item_name;\n+  Location locus;\n+\n   bool has_mut;\n   std::unique_ptr<Type> item_type;\n \n public:\n   ExternalStaticItem (Identifier item_name, std::unique_ptr<Type> item_type,\n-\t\t      bool is_mut, Visibility vis,\n-\t\t      std::vector<Attribute> outer_attrs, Location locus)\n-    : ExternalItem (std::move (item_name), std::move (vis),\n-\t\t    std::move (outer_attrs), locus),\n-      has_mut (is_mut), item_type (std::move (item_type))\n+\t\t      bool is_mut, Visibility vis, std::vector<Attribute> outer_attrs, \n+          Location locus)\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)), \n+      item_name (std::move (item_name)), locus (locus), has_mut (is_mut), \n+      item_type (std::move (item_type))\n   {}\n \n   // Copy constructor\n   ExternalStaticItem (ExternalStaticItem const &other)\n-    : ExternalItem (other), has_mut (other.has_mut),\n-      item_type (other.item_type->clone_type ())\n-  {}\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility), item_name (other.item_name), \n+      locus (other.locus), has_mut (other.has_mut)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.item_type != nullptr)\n+      item_type = other.item_type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   ExternalStaticItem &operator= (ExternalStaticItem const &other)\n   {\n-    ExternalItem::operator= (other);\n-    item_type = other.item_type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    visibility = other.visibility;\n+    item_name = other.item_name;\n+    locus = other.locus;\n     has_mut = other.has_mut;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.item_type != nullptr)\n+      item_type = other.item_type->clone_type ();\n+    else\n+      item_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -3080,6 +3103,22 @@ class ExternalStaticItem : public ExternalItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Returns whether item has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether item has non-default visibility.\n+  bool has_visibility () const { return !visibility.is_error (); }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // Based on idea that type should never be null.\n+  void mark_for_strip () override { item_type = nullptr; };\n+  bool is_marked_for_strip () const override { return item_type == nullptr; };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -3094,17 +3133,22 @@ struct NamedFunctionParam\n {\n private:\n   // bool has_name;   // otherwise is _\n-  Identifier name; // TODO: handle wildcard in identifier?\n+  std::string name; \n \n   std::unique_ptr<Type> param_type;\n \n   // TODO: should this store location data?\n \n+  // seemingly new since writing this node\n+  std::vector<Attribute> outer_attrs; \n+\n public:\n-  // Returns whether the named function parameter has a name (i.e. name is not\n-  // '_').\n+  /* Returns whether the named function parameter has a name (i.e. name is not\n+   * '_'). */\n   bool has_name () const { return name != \"_\"; }\n \n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n   // Returns whether the named function parameter is in an error state.\n   bool is_error () const\n   {\n@@ -3115,26 +3159,36 @@ struct NamedFunctionParam\n   // Creates an error state named function parameter.\n   static NamedFunctionParam create_error ()\n   {\n-    return NamedFunctionParam (\"\", nullptr);\n+    return NamedFunctionParam (\"\", nullptr, {});\n   }\n \n-  NamedFunctionParam (Identifier name, std::unique_ptr<Type> param_type)\n-    : name (std::move (name)), param_type (std::move (param_type))\n+  NamedFunctionParam (std::string name, std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs)\n+    : name (std::move (name)), param_type (std::move (param_type)), outer_attrs (std::move (outer_attrs))\n   {}\n \n   // Copy constructor\n   NamedFunctionParam (NamedFunctionParam const &other)\n-    : name (other.name), param_type (other.param_type->clone_type ())\n-  {}\n+    : name (other.name), outer_attrs (other.outer_attrs)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+  }\n \n   ~NamedFunctionParam () = default;\n \n   // Overloaded assignment operator to clone\n   NamedFunctionParam &operator= (NamedFunctionParam const &other)\n   {\n     name = other.name;\n-    param_type = other.param_type->clone_type ();\n     // has_name = other.has_name;\n+    outer_attrs = other.outer_attrs;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+    else\n+      param_type = nullptr;\n \n     return *this;\n   }\n@@ -3144,11 +3198,28 @@ struct NamedFunctionParam\n   NamedFunctionParam &operator= (NamedFunctionParam &&other) = default;\n \n   std::string as_string () const;\n+\n+  // Based on idea that nane should never be empty.\n+  void mark_for_strip () { param_type = nullptr; };\n+  bool is_marked_for_strip () const { return is_error (); };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n };\n \n // A function item used in an extern block\n class ExternalFunctionItem : public ExternalItem\n {\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  // bool has_visibility;\n+  Visibility visibility;\n+\n+  Identifier item_name;\n+  Location locus;\n+\n   // bool has_generics;\n   // Generics generic_params;\n   std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n@@ -3162,6 +3233,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   std::vector<NamedFunctionParam> function_params;\n   bool has_variadics;\n+  std::vector<Attribute> variadic_outer_attrs;\n \n public:\n   // Returns whether item has generic parameters.\n@@ -3173,28 +3245,48 @@ class ExternalFunctionItem : public ExternalItem\n   // Returns whether item has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  // Returns whether item has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether item has non-default visibility.\n+  bool has_visibility () const { return !visibility.is_error (); }\n+\n+  // Returns whether item has variadic parameters.\n+  bool is_variadic () const { return has_variadics; }\n+\n+  // Returns whether item has outer attributes on its variadic parameters.\n+  bool has_variadic_outer_attrs () const { return !variadic_outer_attrs.empty (); }\n+\n+  Location get_locus () const { return locus; }\n+\n   ExternalFunctionItem (\n     Identifier item_name,\n     std::vector<std::unique_ptr<GenericParam>> generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n-    std::vector<NamedFunctionParam> function_params, bool has_variadics,\n+    std::vector<NamedFunctionParam> function_params, bool has_variadics, std::vector<Attribute> variadic_outer_attrs,\n     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n-    : ExternalItem (std::move (item_name), std::move (vis),\n-\t\t    std::move (outer_attrs), locus),\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)), \n+      item_name (std::move (item_name)), locus (locus),\n       generic_params (std::move (generic_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n       function_params (std::move (function_params)),\n-      has_variadics (has_variadics)\n-  {}\n+      has_variadics (has_variadics), variadic_outer_attrs (std::move (variadic_outer_attrs))\n+  {\n+    // TODO: assert that if has variadic outer attrs, then has_variadics is true?\n+  }\n \n   // Copy constructor with clone\n   ExternalFunctionItem (ExternalFunctionItem const &other)\n-    : ExternalItem (other), return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause),\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility), item_name (other.item_name), \n+      locus (other.locus), where_clause (other.where_clause),\n       function_params (other.function_params),\n-      has_variadics (other.has_variadics)\n+      has_variadics (other.has_variadics), variadic_outer_attrs (other.variadic_outer_attrs)\n   {\n+    // guard to prevent null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -3203,11 +3295,20 @@ class ExternalFunctionItem : public ExternalItem\n   // Overloaded assignment operator with clone\n   ExternalFunctionItem &operator= (ExternalFunctionItem const &other)\n   {\n-    ExternalItem::operator= (other);\n-    return_type = other.return_type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    visibility = other.visibility;\n+    item_name = other.item_name;\n+    locus = other.locus;\n     where_clause = other.where_clause;\n     function_params = other.function_params;\n     has_variadics = other.has_variadics;\n+    variadic_outer_attrs = other.variadic_outer_attrs;\n+\n+    // guard to prevent null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n \n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -3224,6 +3325,17 @@ class ExternalFunctionItem : public ExternalItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Based on idea that nane should never be empty.\n+  void mark_for_strip () override { item_name = \"\"; };\n+  bool is_marked_for_strip () const override { return item_name.empty (); };\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<NamedFunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<NamedFunctionParam> &get_function_params () const { return function_params; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "80ad5d0ff2d1ebdcce2892cfdd2d6f90c6f2efa6", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -125,8 +125,35 @@ namespace Rust {\n         void visit(AST::Trait& trait) override {}\n         void visit(AST::InherentImpl& impl) override {}\n         void visit(AST::TraitImpl& impl) override {}\n-        void visit(AST::ExternalStaticItem& item) override {}\n-        void visit(AST::ExternalFunctionItem& item) override {}\n+        void visit(AST::ExternalStaticItem& item) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::ExternalFunctionItem& item) override {\n+            // strip test based on outer attrs\n+            expander.expand_cfg_attrs(item.get_outer_attrs());\n+            if (expander.fails_cfg(item.get_outer_attrs())) {\n+                item.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip function parameters if required - this is specifically \n+             * allowed by spec */\n+            auto& params = item.get_function_params();\n+            for (auto i = 0; i < params.size(); ) {\n+                if (expander.fails_cfg (params[i].get_outer_attrs ()))\n+                    params.erase (params.begin() + i);\n+                else\n+                    i++;\n+            }\n+\n+            /* TODO: assuming that variadic nature cannot be stripped. If this \n+             * is not true, then have code here to do so. */\n+        }\n         void visit(AST::ExternBlock& block) override {\n             // initial strip test based on outer attrs\n             expander.expand_cfg_attrs(block.get_outer_attrs());\n@@ -154,7 +181,6 @@ namespace Rust {\n                     extern_items.erase (extern_items.begin() + i);\n                 else\n                     i++;\n-                \n             }\n         }\n "}, {"sha": "9c293dca683a1bf4851ca00494eb714459efa270", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 36, "deletions": 47, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -5632,62 +5632,51 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t// parse parameters\n \tstd::vector<AST::NamedFunctionParam> function_params;\n \tbool is_variadic = false;\n+  std::vector<AST::Attribute> variadic_attrs;\n \n \tconst_TokenPtr t = lexer.peek_token ();\n-\twhile (t->get_id () != RIGHT_PAREN)\n-\t  {\n-\t    AST::NamedFunctionParam param = parse_named_function_param ();\n+\twhile (t->get_id () != RIGHT_PAREN) {\n+      std::vector<AST::Attribute> maybe_variadic_attrs = parse_outer_attributes ();\n+      if (lexer.peek_token ()->get_id () == ELLIPSIS) {\n+        // variadic - use attrs for this\n+        lexer.skip_token ();\n+\t\t    is_variadic = true;\n+        variadic_attrs = std::move (maybe_variadic_attrs);\n+\t\t    t = lexer.peek_token ();\n+\n+        if (t->get_id() != RIGHT_PAREN) {\n+          rust_error_at (t->get_locus (),\n+\t\t\t\t   \"expected right parentheses after variadic in named function \"\n+           \"parameters, found %qs\",\n+\t\t\t\t   t->get_token_description ());\n+          skip_after_semicolon ();\n+\t\t      return nullptr;\n+        }\n \n-\t    if (param.is_error ())\n-\t      {\n-\t\t// is this an error? probably\n-\t\trust_error_at (t->get_locus (),\n-\t\t\t       \"could not parse named function parameter in \"\n-\t\t\t       \"external function\");\n-\t\tskip_after_semicolon ();\n-\t\treturn nullptr;\n-\t      }\n+        break;\n+      }\n \n+\t    AST::NamedFunctionParam param = parse_named_function_param (std::move (maybe_variadic_attrs));\n+\t    if (param.is_error ()) {\n+\t\t    rust_error_at (t->get_locus (),\n+\t\t\t       \"could not parse named function parameter in external function\");\n+\t\t    skip_after_semicolon ();\n+\t\t    return nullptr;\n+\t    }\n \t    function_params.push_back (std::move (param));\n \n-\t    t = lexer.peek_token ();\n-\t    if (t->get_id () != COMMA)\n-\t      {\n-\t\tif (t->get_id () != RIGHT_PAREN)\n-\t\t  {\n-\t\t    rust_error_at (t->get_locus (),\n-\t\t\t\t   \"expected comma or right parentheses in \"\n-\t\t\t\t   \"named function parameters, found %qs\",\n-\t\t\t\t   t->get_token_description ());\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    // end of loop\n+\t    if (lexer.peek_token ()->get_id () != COMMA) \n \t\t    break;\n-\t\t  }\n-\t      }\n+      \n \t    // skip comma\n \t    lexer.skip_token ();\n-\n \t    t = lexer.peek_token ();\n+\t}\n \n-\t    // parse variadic ... if it exists\n-\t    if (t->get_id () == ELLIPSIS\n-\t\t&& lexer.peek_token (1)->get_id () == RIGHT_PAREN)\n-\t      {\n-\t\tlexer.skip_token ();\n-\n-\t\tis_variadic = true;\n-\n-\t\tt = lexer.peek_token ();\n-\t      }\n-\t  }\n-\n-\tif (!skip_token (RIGHT_PAREN))\n-\t  {\n+\tif (!skip_token (RIGHT_PAREN)) {\n \t    skip_after_semicolon ();\n \t    return nullptr;\n-\t  }\n+\t}\n \n \t// parse (optional) return type\n \tstd::unique_ptr<AST::Type> return_type = parse_function_return_type ();\n@@ -5705,7 +5694,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \t  new AST::ExternalFunctionItem (\n \t    std::move (ident), std::move (generic_params),\n \t    std::move (return_type), std::move (where_clause),\n-\t    std::move (function_params), is_variadic, std::move (vis),\n+\t    std::move (function_params), is_variadic, std::move (variadic_attrs), std::move (vis),\n \t    std::move (outer_attrs), locus));\n       }\n     default:\n@@ -5722,10 +5711,10 @@ Parser<ManagedTokenSource>::parse_external_item ()\n  * identifier). */\n template <typename ManagedTokenSource>\n AST::NamedFunctionParam\n-Parser<ManagedTokenSource>::parse_named_function_param ()\n+Parser<ManagedTokenSource>::parse_named_function_param (std::vector<AST::Attribute> outer_attrs)\n {\n   // parse identifier/_\n-  Identifier name;\n+  std::string name;\n \n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n@@ -5760,7 +5749,7 @@ Parser<ManagedTokenSource>::parse_named_function_param ()\n       return AST::NamedFunctionParam::create_error ();\n     }\n \n-  return AST::NamedFunctionParam (std::move (name), std::move (param_type));\n+  return AST::NamedFunctionParam (std::move (name), std::move (param_type), std::move (outer_attrs));\n }\n \n // Parses a statement (will further disambiguate any statement)."}, {"sha": "82d8d6f89d9a7ef919026745370c6547f1c4baae", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69048af1878e95e26b57febb701f884f513c7b93/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=69048af1878e95e26b57febb701f884f513c7b93", "patch": "@@ -230,7 +230,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_extern_block (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n-  AST::NamedFunctionParam parse_named_function_param ();\n+  AST::NamedFunctionParam parse_named_function_param (\n+    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> ());\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)"}]}