{"sha": "44de5aeb00a66307236cb5b7ccfca1a21aaca080", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRkZTVhZWIwMGE2NjMwNzIzNmNiNWI3Y2NmY2ExYTIxYWFjYTA4MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-22T03:07:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-22T03:07:05Z"}, "message": "alias.c (adjust_offset_for_component_ref): Use component_ref_field_offset.\n\n\t* alias.c (adjust_offset_for_component_ref): Use\n\tcomponent_ref_field_offset.\n\t* c-decl.c (build_array_declarator): Add news args for ARRAY_REF.\n\t* c-gimplify.c (gimplify_expr_stmt): Use alloc_stmt_list.\n\t(gimplify_decl_stmt): Call gimplify_type_sizes for type.\n\tFor decl, call gimplify_one_sizepos and use statement list.\n\t(gimplify_compound_literal_expr): New arg PRE_P.\n\tAdd statement to PRE_P list and return DECL.\n\t(c_gimplify_expr, case COMPOUND_LITERAL_EXPR): Add arg to\n\tgimplify_compound_literal_expr.\n\t* c-tree.h (getdecls): Deleted.\n\t* c-typeck.c (build_component_ref): Add operand for COMPONENT_REF.\n\t(build_array_ref): Add two operands for ARRAY_REF.\n\t(build_unary_op): Set TREE_INVARIANT and TREE_CONSTANT for\n\tCOMPOUND_LITERAL_EXPR.\n\t* coverage.c (tree_coverage_counter_ref): Add new operands\n\tfor ARRAY_REF.\n\t* emit-rtl.c (component_ref_for_mem_expr): Add new operand\n\tfor COMPONENT_REF.\n\t(set_mem_attributes_minus_bitpos): Use array_ref_low_bound\n\tand array_ref_element_size.\n\t(widen_memory_access):Use component_ref_field_offset.\n\t* explow.c (update_nonlocal_goto_save_area): Add two operands\n\tfor ARRAY_REF.\n\t* expr.c (array_ref_element_size, array_ref_low_bound): New functions.\n\t(component_ref_field_offset): Likewise.\n\t(get_inner_reference): Use them.\n\t(expand_expr_real_1, case ARRAY_REF): Use array_ref_low_bound.\n\t* fold-const.c (fold, case EQ_EXPR): Properly handle DECL_SIZE.\n\t(fold_read_from_constant_string): Use array_ref_low_bound.\n\tVerify that result is a character type.\n\t(build_fold_indirect_ref): Add two operands for ARRAY_REF.\n\t* function.c (expand_function_start): Likewise.\n\t* gimple-low.c (expand_var_p): Delete duplicated line.\n\t* gimplify.c: Add static decls for local functions.\n\t(cgraph.h): Now included.\n\t(create_tmp_var): Remove check for ARRAY_TYPE.\n\t(copy_if_shared_r): Look at bounds and sizes of types.\n\t(build_and_jump): Return alloc_stmt_list instead of build_empty_stmt.\n\t(gimplify_exit_expr, shortcut_cond_expr): Likewise.\n\t(gimplify_save_expr, gimple_push_cleanup): Likewise.\n\t(gimplify_init_constructor): Likewise.\n\tWANT_VALUE now bool.\n\tIf empty list with no result wanted, return GS_UNHANDLED.\n\tAdd additional operands for ARRAY_REF and COMPONENT_REF.\n\t(canonicalize_component_ref): Convert to &array[L].\n\t(gimplify_array_ref_to_plus): Use array_ref_element_size and\n\tarray_ref_lower_bound.\n\t(build_addr_expr_with_type, build_addr_expr): New functions.\n\t(gimplify_compound_lval): WANT_LVALUE now bool.\n\tMajor rework to allow handle_component_p and initialize and\n\tgimplify new operands for ARRAY_REF, ARRAY_RANGE_REF, and\n\tCOMPONENT_REF.\n\t(gimplify_array_ref): Deleted.\n\t(gimplify_self_mod_expr): WANT_VALUE now bool.\n\t(gimplify_modify_expr): Gimplify to_p and from_p later.\n\tFactor out code into gimplify_modify_expr_rhs and call twice.\n\tMove variable-size code earlier and handle PLACEHOLDER_EXPR.\n\t(gimplify_modify_expr_rhs, gimplify_variable_sized_compare): New fns.\n\t(gimplify_addr_expr, case VIEW_CONVERT_EXPR): New case.\n\t(gimplify_expr, case ARRAY_REF): Delete special case.\n\tInstead handle like COMPONENT_REF; also do ARRAY_RANGE_REF,\n\tIMAGPART, and REALPART the same way.\n\t(gimplify_expr, case VIEW_CONVERT_EXPR): New case.\n\t(gimplify_expr): Call gimplify_variable_sized_compare if applicable.\n\tCall alloc_stmt_list instead of build_empty_stmt.\n\tDeal with _REF that's volatile.\n\t(gimplify_type_sizes, gimplify_one_sizepos): New functions.\n\t(unshare_body, unvisit_body): New functions.\n\t(gimplify_body): Call them.\n\t* stmt.c (expand_stack_alloc): Don't expand TYPE_MAX_VALUE.\n\t* stor-layout.c (get_pending_sizes): Don't change SAVE_EXPR_CONTEXT.\n\t* tree-alias-common.c (get_alias_var): Also skip ARRAY_RANGE_REF.\n\t* tree-cfg.c (tree_node_can_be_shared): Treat ARRAY_RANGE_REF\n\tlike ARRAY_REF.\n\t(verify_expr, case ADDR_EXPR): Use handled_component_p.\n\t* tree-dfa.c (get_virtual_var): Likewise.\n\t* tree-dump.c (dequeue_and_dump, case COMPONENT_REF, ARRAY_REF):\n\tNew cases to dump new operands; likewise for ARRAY_RANGE_REF.\n\t* tree-eh.c (tree_could_trap, case ARRAY_RANGE_REF): Like ARRAY_REF.\n\t* tree-gimple.c (is_gimple_addr_expr_arg): Add ARRAY_RANGE_REF\n\tand INDIRECT_REF.\n\t(get_base_address): Use handled_component_p.\n\t* tree-gimple.h (gimplify_type_sizes, gimplify_one_sizepos): New.\n\t* tree-line.c (walk_tree): Walk more things for types and decls.\n\t* tree-mudflap.c (mf_build_check_statement_for): Add new operands\n\tfor ARRAY_REF and COMPONENT_REF.\n\t(mx_xform_derefs_1): Clean up usage of decl sizes.\n\t* tree-nested.c (build_addr): Use handled_component_p.\n\t(walk_stmts, case CATCH_EXPR): Add missing \"break\".\n\t(get_static_chain, get_frame_field): Add new operand for COMPONENT_REF.\n\t(finalize_nesting_tree_1): Likewise.\n\t(convert_nonlocal_reference, case ARRAY_RANGE_REF): Like ARRAY_REF\n\tand process additional operands.\n\t(convert_local_reference): Likewise.\n\t* tree-outof-ssa.c (discover_nonconstant_array_refs_r): Treat\n\tARRAY_RANGE_REF similarly to ARRAY_REF.\n\t* tree-pretty-print.c (dump_generic_node, case QUAL_UNION_TYPE): Handle\n\tlike RECORD_TYPE.\n\t(dump_generic_node, case COMPONENT_REF): Print offset operand.\n\t(dump_generic_node, case ARRAY_RANGE_REF): Treat like ARRAY_REF\n\tand print lower bound and element size for both.\n\t(op_prio, case ARRAY_RANGE_REF): Like ARRAY_REF.\n\t* tree-sra.c (csc_build_component_ref): Add new operand.\n\t(scalarize_call_expr): Use get_base_address.\n\t* tree-ssa-ccp.c (widen_bitfield): Clean up size handling.\n\t(maybe_fold_offset_to_array_ref): Rework to handle input having an\n\tARRAY_REF, refine handling of lower bound, and add new operands\n\tfor ARRAY_REF.\n\t(maybe_fold_to_component_ref): Add new operand for COMPONENT_REF.\n\t(maybe_fold_stmt_indirect): Only fold *&B to B if types match.\n\t(maybe_fold_stmt_addition): Only handle constant lower bound.\n\t* tree-ssa-operands.c (get_expr_operands): Minor rearrangements.\n\tTreat ARRAY_REF and ARRAY_RANGE_REF the same; look at extra operands.\n\tLook at new offset operand of COMPONENT_REF.\n\t* tree-ssa.c (set_is_used): Use handled_component_p.\n\t* tree.c (substitute_in_expr, case COMPONENT_REF): Add new operand.\n\t(stabilize_reference, case COMPONENT_REF): Likewise.\n\t(stabilize_reference, case ARRAY_RANGE_REF, ARRAY_REF): Similarly.\n\t(recompute_tree_invariant_for_addr_expr): Completely rework to\n\tbe more precise.  Also set TREE_SIDE_EFFECTS.\n\t(build1_stat, case ARRAY_EXPR): Don't handle TREE_SIDE_EFFECTS here.\n\t(build2_stat, build3_stat, build4_stat): For references,\n\tpropagate TREE_THIS_VOLATILE.\n\t(get_unwidened): Add new operand for COMPONENT_REF.\n\t(get_narrower): Likewise; use host_integerp for DECL_SIZE.\n\t* tree.def (COMPONENT_REF): Add new operand.\n\t(ARRAY_REF, ARRAY_RANGE_REF): Add two new operands.\n\t* tree.h (array_ref_element_size, array_ref_low_bound): New decls.\n\t(component_ref_field_offset): Likewise.\n\t* config/alpha/alpha.c (alpha_va_start): Add new op for COMPONENT_REF.\n\t(alpha_gimplify_va_arg): Likewise.\n\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n\t* config/i860/i860.c (i860_va_start, i860_va_arg): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_va_arg): Likewise.\n\t* config/mips/mips.c (mips_va_start, mips_va_arg): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg):\n\tLikewise.\n\t* config/s390/s390.c (s390_va_start, s390_gimplify_va_arg): Likewise.\n\t* config/sh/sh.c (sh_va_start, sh_va_arg): Likewise.\n\t* config/stormy16/stormy16.c (xstormy1_expand_builin_va_start):\n\tLikewise.\n\t(xstormy16_expand_builtin_va_arg): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_va_start, xtensa_va_arg): Likewise.\n\n\t* cp/call.c (build_vfield_ref): Add new operand for COMPONENT_REF.\n\t(build_new_method_call): Likewise.\n\t* cp/decl.c (local_variable_p_walkfn): Don't walk into types.\n\t* cp/decl2.c (grok_array_decl): Add new operands for ARRAY_REF.\n\t(build_anon_union_vars): Add new operand for COMPONENT_REF.\n\t* cp/init.c (buld_new): Add new operand for ARRAY_REF.\n\t* cp/method.c (do_build_copy_constructor): New op for COMPONENT_REF.\n\t(do_build_assign_ref): Likewise.\n\t* cp/parser.c (cp_parser_direct_new_declarator): Add new operands\n\tfor ARRAY_REF.\n\t(cp_parser_direct_declarator): Likewise.\n\t* cp/pt.c (tsubst): Likewise.\n\t(tsubst_copy, tsubst_copy_and_build): Likewise; also add new operand\n \tfor COMPONENT_REF.\n\t* cp/semantics.c (finish_non_static_data_member): Add new operand\n\tfor COMPONENT_REF.\n\t* cp/typeck.c (build_class_member_access_expr): Likewise.\n\t(build_class_member_access_expr, finish_class_member_access_expr):\n\tLikewise.\n\t(build_ptrmemfunc_access_expr): Likewise.\n\t(build_array_ref): Add new operands for ARRAY_REF.\n\t* cp/typeck2.c (split_nonconstant_init_1): Likewise; COMPONENT_REF too.\n\t* cp/tree.c (count_trees_r, no_linkage_helper): Don't walk in types.\n\n\t* fortran/f95-lang.c (LANG_HOOKS_GIMPLE_BEFORE_INLINING): Deleted.\n\t* fortran/trans-array.c (gfc_conv_descriptor_data): Add operand\n\tfor COMPONENT_REF.\n\t(gfc_conv_descriptor_offset, gfc_conv_descriptor_dtype): Likewise.\n\t(gfc_conv_descriptor_dimension, gfc_conv_descriptor_stride): Likewise.\n\t(gfc_conv_descriptor_lbound, gfc_conv_descriptor_ubound): Likewise.\n\t* fortran/trans-common.c (create_common): Likewise.\n\t* fortran/trans-expr.c (gfc_conv_component_ref): Likewise.\n\t* fortran/trans-io.c (set_parameter_value): Likewise.\n\t(set_parameter_ref, set_string, set_flag, io_result): Likewise.\n\t(transfer_expr): Likewise.\n\t* fortran/trans-decl.c (gfc_trans_auto_character_variable):\n\tSet up to get DECL_SIZE and DECL_SIZE_UNIT gimplified.\n\t(gfc_simplify_function): New function.\n\t(gfc_generate_function-code): Properly handle nested functions.\n\t* fortran/trans.c (gfc_build_array_ref): Add two new operands\n\tfor ARRAY_REF.\n\n\t* java/class.c (build_class_ref): Add new operand for COMPONENT_REF.\n\t(build_static_field_ref): Likewise and add new operands for ARRAY_REF.\n\t* java/constants.c (build_ref_from_constant_pool): Likewise.\n\t* java/expr.c (build_java_array_length_access): Likewise.\n\t(build_get_class, build_field_ref, build_known_method_ref): Likewise.\n\t(invoke_build_dtable, build_invokevirtual): Likewise.\n\t(build_invokeinterface, java_expand_expr): Likewise.\n\t(emit_init_test_initialization): Likewise.\n\t* java/java-gimplify.c (java_gimplify_new_array_init): Likewise.\n\t* java/parse.y (make_qualifed_name, build_array_ref): Likewise.\n\n\t* objc/ojbc-act.c (generate_static_references): Add additional\n\toperands to ARRAY_REF.\n\t(generate_strings, build_method_prototype_list_template): Likewise.\n\t(generate_protocol_list): Likewise.\n\nFrom-SVN: r83474", "tree": {"sha": "0f08ba8e2fff4040497202121f17db146e774840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f08ba8e2fff4040497202121f17db146e774840"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44de5aeb00a66307236cb5b7ccfca1a21aaca080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44de5aeb00a66307236cb5b7ccfca1a21aaca080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44de5aeb00a66307236cb5b7ccfca1a21aaca080", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44de5aeb00a66307236cb5b7ccfca1a21aaca080/comments", "author": null, "committer": null, "parents": [{"sha": "6264b0a68d820604c6b85a4c093de22bef6382cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6264b0a68d820604c6b85a4c093de22bef6382cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6264b0a68d820604c6b85a4c093de22bef6382cf"}], "stats": {"total": 2428, "additions": 1648, "deletions": 780}, "files": [{"sha": "8829c32b0ff0158374f73796e138d0834852d69f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,3 +1,153 @@\n+2004-06-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (adjust_offset_for_component_ref): Use\n+\tcomponent_ref_field_offset.\n+\t* c-decl.c (build_array_declarator): Add news args for ARRAY_REF.\n+\t* c-gimplify.c (gimplify_expr_stmt): Use alloc_stmt_list.\n+\t(gimplify_decl_stmt): Call gimplify_type_sizes for type.\n+\tFor decl, call gimplify_one_sizepos and use statement list.\n+\t(gimplify_compound_literal_expr): New arg PRE_P.\n+\tAdd statement to PRE_P list and return DECL.\n+\t(c_gimplify_expr, case COMPOUND_LITERAL_EXPR): Add arg to\n+\tgimplify_compound_literal_expr.\n+\t* c-tree.h (getdecls): Deleted.\n+\t* c-typeck.c (build_component_ref): Add operand for COMPONENT_REF.\n+\t(build_array_ref): Add two operands for ARRAY_REF.\n+\t(build_unary_op): Set TREE_INVARIANT and TREE_CONSTANT for\n+\tCOMPOUND_LITERAL_EXPR.\n+\t* coverage.c (tree_coverage_counter_ref): Add new operands\n+\tfor ARRAY_REF.\n+\t* emit-rtl.c (component_ref_for_mem_expr): Add new operand\n+\tfor COMPONENT_REF.\n+\t(set_mem_attributes_minus_bitpos): Use array_ref_low_bound\n+\tand array_ref_element_size.\n+\t(widen_memory_access):Use component_ref_field_offset.\n+\t* explow.c (update_nonlocal_goto_save_area): Add two operands\n+\tfor ARRAY_REF.\n+\t* expr.c (array_ref_element_size, array_ref_low_bound): New functions.\n+\t(component_ref_field_offset): Likewise.\n+\t(get_inner_reference): Use them.\n+\t(expand_expr_real_1, case ARRAY_REF): Use array_ref_low_bound.\n+\t* fold-const.c (fold, case EQ_EXPR): Properly handle DECL_SIZE.\n+\t(fold_read_from_constant_string): Use array_ref_low_bound.\n+\tVerify that result is a character type.\n+\t(build_fold_indirect_ref): Add two operands for ARRAY_REF.\n+\t* function.c (expand_function_start): Likewise.\n+\t* gimple-low.c (expand_var_p): Delete duplicated line.\n+\t* gimplify.c: Add static decls for local functions.\n+\t(cgraph.h): Now included.\n+\t(create_tmp_var): Remove check for ARRAY_TYPE.\n+\t(copy_if_shared_r): Look at bounds and sizes of types.\n+\t(build_and_jump): Return alloc_stmt_list instead of build_empty_stmt.\n+\t(gimplify_exit_expr, shortcut_cond_expr): Likewise.\n+\t(gimplify_save_expr, gimple_push_cleanup): Likewise.\n+\t(gimplify_init_constructor): Likewise.\n+\tWANT_VALUE now bool.\n+\tIf empty list with no result wanted, return GS_UNHANDLED.\n+\tAdd additional operands for ARRAY_REF and COMPONENT_REF.\n+\t(canonicalize_component_ref): Convert to &array[L].\n+\t(gimplify_array_ref_to_plus): Use array_ref_element_size and\n+\tarray_ref_lower_bound.\n+\t(build_addr_expr_with_type, build_addr_expr): New functions.\n+\t(gimplify_compound_lval): WANT_LVALUE now bool.\n+\tMajor rework to allow handle_component_p and initialize and\n+\tgimplify new operands for ARRAY_REF, ARRAY_RANGE_REF, and\n+\tCOMPONENT_REF.\n+\t(gimplify_array_ref): Deleted.\n+\t(gimplify_self_mod_expr): WANT_VALUE now bool.\n+\t(gimplify_modify_expr): Gimplify to_p and from_p later.\n+\tFactor out code into gimplify_modify_expr_rhs and call twice.\n+\tMove variable-size code earlier and handle PLACEHOLDER_EXPR.\n+\t(gimplify_modify_expr_rhs, gimplify_variable_sized_compare): New fns.\n+\t(gimplify_addr_expr, case VIEW_CONVERT_EXPR): New case.\n+\t(gimplify_expr, case ARRAY_REF): Delete special case.\n+\tInstead handle like COMPONENT_REF; also do ARRAY_RANGE_REF,\n+\tIMAGPART, and REALPART the same way.\n+\t(gimplify_expr, case VIEW_CONVERT_EXPR): New case.\n+\t(gimplify_expr): Call gimplify_variable_sized_compare if applicable.\n+\tCall alloc_stmt_list instead of build_empty_stmt.\n+\tDeal with _REF that's volatile.\n+\t(gimplify_type_sizes, gimplify_one_sizepos): New functions.\n+\t(unshare_body, unvisit_body): New functions.\n+\t(gimplify_body): Call them.\n+\t* stmt.c (expand_stack_alloc): Don't expand TYPE_MAX_VALUE.\n+\t* stor-layout.c (get_pending_sizes): Don't change SAVE_EXPR_CONTEXT.\n+\t* tree-alias-common.c (get_alias_var): Also skip ARRAY_RANGE_REF.\n+\t* tree-cfg.c (tree_node_can_be_shared): Treat ARRAY_RANGE_REF\n+\tlike ARRAY_REF.\n+\t(verify_expr, case ADDR_EXPR): Use handled_component_p.\n+\t* tree-dfa.c (get_virtual_var): Likewise.\n+\t* tree-dump.c (dequeue_and_dump, case COMPONENT_REF, ARRAY_REF):\n+\tNew cases to dump new operands; likewise for ARRAY_RANGE_REF.\n+\t* tree-eh.c (tree_could_trap, case ARRAY_RANGE_REF): Like ARRAY_REF.\n+\t* tree-gimple.c (is_gimple_addr_expr_arg): Add ARRAY_RANGE_REF\n+\tand INDIRECT_REF.\n+\t(get_base_address): Use handled_component_p.\n+\t* tree-gimple.h (gimplify_type_sizes, gimplify_one_sizepos): New.\n+\t* tree-inline.c (walk_tree): Walk more things for types and decls.\n+\t* tree-mudflap.c (mf_build_check_statement_for): Add new operands\n+\tfor ARRAY_REF and COMPONENT_REF.\n+\t(mx_xform_derefs_1): Clean up usage of decl sizes.\n+\t* tree-nested.c (build_addr): Use handled_component_p.\n+\t(walk_stmts, case CATCH_EXPR): Add missing \"break\".\n+\t(get_static_chain, get_frame_field): Add new operand for COMPONENT_REF.\n+\t(finalize_nesting_tree_1): Likewise.\n+\t(convert_nonlocal_reference, case ARRAY_RANGE_REF): Like ARRAY_REF\n+\tand process additional operands.\n+\t(convert_local_reference): Likewise.\n+\t* tree-outof-ssa.c (discover_nonconstant_array_refs_r): Treat\n+\tARRAY_RANGE_REF similarly to ARRAY_REF.\n+\t* tree-pretty-print.c (dump_generic_node, case QUAL_UNION_TYPE): Handle\n+\tlike RECORD_TYPE.\n+\t(dump_generic_node, case COMPONENT_REF): Print offset operand.\n+\t(dump_generic_node, case ARRAY_RANGE_REF): Treat like ARRAY_REF\n+\tand print lower bound and element size for both.\n+\t(op_prio, case ARRAY_RANGE_REF): Like ARRAY_REF.\n+\t* tree-sra.c (csc_build_component_ref): Add new operand.\n+\t(scalarize_call_expr): Use get_base_address.\n+\t* tree-ssa-ccp.c (widen_bitfield): Clean up size handling.\n+\t(maybe_fold_offset_to_array_ref): Rework to handle input having an\n+\tARRAY_REF, refine handling of lower bound, and add new operands\n+\tfor ARRAY_REF.\n+\t(maybe_fold_to_component_ref): Add new operand for COMPONENT_REF.\n+\t(maybe_fold_stmt_indirect): Only fold *&B to B if types match.\n+\t(maybe_fold_stmt_addition): Only handle constant lower bound.\n+\t* tree-ssa-operands.c (get_expr_operands): Minor rearrangements.\n+\tTreat ARRAY_REF and ARRAY_RANGE_REF the same; look at extra operands.\n+\tLook at new offset operand of COMPONENT_REF.\n+\t* tree-ssa.c (set_is_used): Use handled_component_p.\n+\t* tree.c (substitute_in_expr, case COMPONENT_REF): Add new operand.\n+\t(stabilize_reference, case COMPONENT_REF): Likewise.\n+\t(stabilize_reference, case ARRAY_RANGE_REF, ARRAY_REF): Similarly.\n+\t(recompute_tree_invariant_for_addr_expr): Completely rework to\n+\tbe more precise.  Also set TREE_SIDE_EFFECTS.\n+\t(build1_stat, case ARRAY_EXPR): Don't handle TREE_SIDE_EFFECTS here.\n+\t(build2_stat, build3_stat, build4_stat): For references,\n+\tpropagate TREE_THIS_VOLATILE.\n+\t(get_unwidened): Add new operand for COMPONENT_REF.\n+\t(get_narrower): Likewise; use host_integerp for DECL_SIZE.\n+\t* tree.def (COMPONENT_REF): Add new operand.\n+\t(ARRAY_REF, ARRAY_RANGE_REF): Add two new operands.\n+\t* tree.h (array_ref_element_size, array_ref_low_bound): New decls.\n+\t(component_ref_field_offset): Likewise.\n+\t* config/alpha/alpha.c (alpha_va_start): Add new op for COMPONENT_REF.\n+\t(alpha_gimplify_va_arg): Likewise.\n+\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n+\t* config/i860/i860.c (i860_va_start, i860_va_arg): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_va_arg): Likewise.\n+\t* config/mips/mips.c (mips_va_start, mips_va_arg): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg):\n+\tLikewise.\n+\t* config/s390/s390.c (s390_va_start, s390_gimplify_va_arg): Likewise.\n+\t* config/sh/sh.c (sh_va_start, sh_va_arg): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy1_expand_builin_va_start):\n+\tLikewise.\n+\t(xstormy16_expand_builtin_va_arg): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_va_start, xtensa_va_arg): Likewise.\n+\t* objc/objc-act.c (generate_static_references): Likewise.\n+\t(generate_strings, build_method_prototype_list_template): Likewise.\n+\t(generate_protocol_list): Likewise.\n+\n 2004-06-21  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR rtl-optimization/14782"}, {"sha": "b8661d7b6bdbe98cabc1042afa983bd004e4c93c", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -2015,11 +2015,12 @@ adjust_offset_for_component_ref (tree x, rtx offset)\n   ioffset = INTVAL (offset);\n   do\n     {\n+      tree offset = component_ref_field_offset (x);\n       tree field = TREE_OPERAND (x, 1);\n \n-      if (! host_integerp (DECL_FIELD_OFFSET (field), 1))\n+      if (! host_integerp (offset, 1))\n \treturn NULL_RTX;\n-      ioffset += (tree_low_cst (DECL_FIELD_OFFSET (field), 1)\n+      ioffset += (tree_low_cst (offset, 1)\n \t\t  + (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n \t\t     / BITS_PER_UNIT));\n "}, {"sha": "4735dabf6448037b94bc2a9b9840e1131d88246a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -2508,7 +2508,7 @@ tree\n build_array_declarator (tree expr, tree quals, int static_p, int vla_unspec_p)\n {\n   tree decl;\n-  decl = build_nt (ARRAY_REF, NULL_TREE, expr);\n+  decl = build_nt (ARRAY_REF, NULL_TREE, expr, NULL_TREE, NULL_TREE);\n   TREE_TYPE (decl) = quals;\n   TREE_STATIC (decl) = (static_p ? 1 : 0);\n   if (pedantic && !flag_isoc99)"}, {"sha": "113a09d1b16ddaad8ac5ff1249b0095119e0d0cc", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -243,7 +243,7 @@ gimplify_expr_stmt (tree *stmt_p)\n     }\n \n   if (stmt == NULL_TREE)\n-    stmt = build_empty_stmt ();\n+    stmt = alloc_stmt_list ();\n \n   *stmt_p = stmt;\n \n@@ -475,8 +475,6 @@ gimplify_decl_stmt (tree *stmt_p)\n {\n   tree stmt = *stmt_p;\n   tree decl = DECL_STMT_DECL (stmt);\n-  tree pre = NULL_TREE;\n-  tree post = NULL_TREE;\n \n   if (TREE_TYPE (decl) == error_mark_node)\n     {\n@@ -485,38 +483,34 @@ gimplify_decl_stmt (tree *stmt_p)\n     }\n     \n   if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      tree type = TREE_TYPE (decl);\n-      if (TYPE_SIZE_UNIT (type)\n-          && !TREE_CONSTANT (TYPE_SIZE_UNIT (type)))\n-        {\n-          /* This is a variable-sized array type.  Simplify its size.  */\n-          tree temp = TYPE_SIZE_UNIT (type);\n-          gimplify_expr (&temp, &pre, &post, is_gimple_val, fb_rvalue);\n-        }\n-    }\n+    *stmt_p = gimplify_type_sizes (TREE_TYPE (decl));\n \n-  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+  else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     {\n       tree init = DECL_INITIAL (decl);\n \n+      *stmt_p = NULL_TREE;\n+      gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n+      gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n+\n       if (!TREE_CONSTANT (DECL_SIZE (decl)))\n \t{\n-\t  tree pt_type = build_pointer_type (TREE_TYPE (decl));\n-\t  tree alloc, size;\n-\n \t  /* This is a variable-sized decl.  Simplify its size and mark it\n \t     for deferred expansion.  Note that mudflap depends on the format\n \t     of the emitted code: see mx_register_decls().  */\n \n-\t  size = get_initialized_tmp_var (DECL_SIZE_UNIT (decl), &pre, &post);\n+\t  tree pt_type = build_pointer_type (TREE_TYPE (decl));\n+\t  tree alloc_stmt\n+\t    = (build_function_call_expr\n+\t       (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n+\t\ttree_cons (NULL_TREE,\n+\t\t\t   build1 (ADDR_EXPR, pt_type, decl),\n+\t\t\t   tree_cons (NULL_TREE, DECL_SIZE_UNIT (decl),\n+\t\t\t\t      NULL_TREE))));\n+\n+\t  gimplify_stmt (&alloc_stmt);\n+\t  append_to_statement_list(alloc_stmt, stmt_p);\n \t  DECL_DEFER_OUTPUT (decl) = 1;\n-\t  alloc = build_function_call_expr\n-\t    (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n-\t     tree_cons (NULL_TREE,\n-\t\t\tbuild1 (ADDR_EXPR, pt_type, decl),\n-\t\t\ttree_cons (NULL_TREE, size, NULL_TREE)));\n-\t  append_to_compound_expr (alloc, &pre);\n \t}\n \n       if (init && init != error_mark_node)\n@@ -531,14 +525,13 @@ gimplify_decl_stmt (tree *stmt_p)\n               \n \t      DECL_INITIAL (decl) = NULL_TREE;\n \t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n-\t      append_to_compound_expr (init, &pre);\n+\t      gimplify_stmt (&init);\n+\t      append_to_statement_list (init, stmt_p);\n \t    }\n \t  else\n-\t    {\n-\t      /* We must still examine initializers for static variables\n-\t\t as they may contain a label address.  */\n-\t      walk_tree (&init, force_labels_r, NULL, NULL);\n-\t    }\n+\t    /* We must still examine initializers for static variables\n+\t       as they may contain a label address.  */\n+\t    walk_tree (&init, force_labels_r, NULL, NULL);\n \t}\n \n       /* This decl isn't mentioned in the enclosing block, so add it to the\n@@ -547,10 +540,10 @@ gimplify_decl_stmt (tree *stmt_p)\n       if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n \tgimple_add_tmp_var (decl);\n     }\n+  else\n+    *stmt_p = alloc_stmt_list ();\n \n-  append_to_compound_expr (post, &pre);\n-  *stmt_p = pre;\n-  return GS_OK;\n+  return GS_ALL_DONE;\n }\n \n /* Gimplification of expression trees.  */\n@@ -560,7 +553,7 @@ gimplify_decl_stmt (tree *stmt_p)\n    instead.  */\n \n static enum gimplify_status\n-gimplify_compound_literal_expr (tree *expr_p)\n+gimplify_compound_literal_expr (tree *expr_p, tree *pre_p)\n {\n   tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (*expr_p);\n   tree decl = DECL_STMT_DECL (decl_s);\n@@ -572,7 +565,8 @@ gimplify_compound_literal_expr (tree *expr_p)\n     gimple_add_tmp_var (decl);\n \n   gimplify_decl_stmt (&decl_s);\n-  *expr_p = decl_s ? decl_s : decl;\n+  append_to_statement_list (decl_s, pre_p);\n+  *expr_p = decl;\n   return GS_OK;\n }\n \n@@ -586,7 +580,7 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n   switch (code)\n     {\n     case COMPOUND_LITERAL_EXPR:\n-      return gimplify_compound_literal_expr (expr_p);\n+      return gimplify_compound_literal_expr (expr_p, pre_p);\n \n     case FOR_STMT:\n       return gimplify_for_stmt (expr_p, pre_p);"}, {"sha": "66691eba29999325321a46091fa9f4abd26115d9", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -147,7 +147,6 @@ extern int c_in_iteration_stmt;\n extern int c_in_case_stmt;\n \n extern int global_bindings_p (void);\n-extern tree getdecls (void);\n extern void push_scope (void);\n extern tree pop_scope (void);\n extern void insert_block (tree);"}, {"sha": "63c91210015b5bc81372b8d18f8ce3c5d647a64f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1222,10 +1222,10 @@ default_function_array_conversion (tree exp)\n \n       if (TREE_CODE (exp) == VAR_DECL)\n \t{\n-\t  /* ??? This is not really quite correct\n-\t     in that the type of the operand of ADDR_EXPR\n-\t     is not the target type of the type of the ADDR_EXPR itself.\n-\t     Question is, can this lossage be avoided?  */\n+\t  /* We are making an ADDR_EXPR of ptrtype.  This is a valid\n+\t     ADDR_EXPR because it's the best way of representing what\n+\t     happens in C when we take the address of an array and place\n+\t     it in a pointer to the element type.  */\n \t  adr = build1 (ADDR_EXPR, ptrtype, exp);\n \t  if (!c_mark_addressable (exp))\n \t    return error_mark_node;\n@@ -1483,7 +1483,8 @@ build_component_ref (tree datum, tree component)\n \t  if (TREE_TYPE (subdatum) == error_mark_node)\n \t    return error_mark_node;\n \n-\t  ref = build (COMPONENT_REF, TREE_TYPE (subdatum), datum, subdatum);\n+\t  ref = build (COMPONENT_REF, TREE_TYPE (subdatum), datum, subdatum,\n+\t\t       NULL_TREE);\n \t  if (TREE_READONLY (datum) || TREE_READONLY (subdatum))\n \t    TREE_READONLY (ref) = 1;\n \t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (subdatum))\n@@ -1636,7 +1637,7 @@ build_array_ref (tree array, tree index)\n \t}\n \n       type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n-      rval = build (ARRAY_REF, type, array, index);\n+      rval = build (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n          or if the array is.  */\n       TREE_READONLY (rval)\n@@ -2562,6 +2563,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \telse\n \t  addr = build1 (code, argtype, arg);\n \n+\tif (TREE_CODE (arg) == COMPOUND_LITERAL_EXPR)\n+\t  TREE_INVARIANT (addr) = TREE_CONSTANT (addr) = 1;\n+\n \treturn addr;\n       }\n "}, {"sha": "dd4409a217651a80e8340b46aee550f43ccf72ef", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -6274,9 +6274,9 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       offset_field = TREE_CHAIN (base_field);\n \n       base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n-\t\t\t  valist, base_field);\n+\t\t\t  valist, base_field, NULL_TREE);\n       offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n-\t\t\t    valist, offset_field);\n+\t\t\t    valist, offset_field, NULL_TREE);\n \n       t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n       t = build (PLUS_EXPR, ptr_type_node, t, build_int_2 (offset, 0));\n@@ -6383,9 +6383,9 @@ alpha_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   base_field = TYPE_FIELDS (va_list_type_node);\n   offset_field = TREE_CHAIN (base_field);\n   base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n-\t\t      valist, base_field);\n+\t\t      valist, base_field, NULL_TREE);\n   offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n-\t\t\tvalist, offset_field);\n+\t\t\tvalist, offset_field, NULL_TREE);\n \n   /* Pull the fields of the structure out into temporaries.  Since we never\n      modify the base field, we can use a formal temporary.  Sign-extend the"}, {"sha": "30d031507e246eeae0f9be8ba589f5e53ea3c1b7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -3136,10 +3136,10 @@ ix86_va_start (tree valist, rtx nextarg)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = current_function_args_info.words;\n@@ -3202,10 +3202,10 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build_fold_indirect_ref (valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n   if (size == -1)"}, {"sha": "d23277d1dbed48649aaf414345553634ac89b3b3", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1877,10 +1877,10 @@ i860_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_fpr = TREE_CHAIN (f_gpr);\n #endif\n \n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n-  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem, NULL_TREE);\n \n   /* Initialize the `mem_ptr' field to the address of the first anonymous\n      stack argument.  */\n@@ -1943,10 +1943,10 @@ i860_va_arg (tree valist, tree type)\n   f_fpr = TREE_CHAIN (f_gpr);\n #endif\n \n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n "}, {"sha": "786a7b6c91e8a9aa23aa1e4fe8dc0b37f2007f38", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1656,11 +1656,11 @@ iq2000_va_arg (tree valist, tree type)\n   f_goff = TREE_CHAIN (f_ftop);\n   f_foff = TREE_CHAIN (f_goff);\n \n-  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n-  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n-  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n-  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n-  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl, NULL_TREE);\n+  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop, NULL_TREE);\n+  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop, NULL_TREE);\n+  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff, NULL_TREE);\n+  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff, NULL_TREE);\n \n   lab_false = gen_label_rtx ();\n   lab_over = gen_label_rtx ();"}, {"sha": "15489b19d767fee46e800131cc46bed551fc21cd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -4045,11 +4045,16 @@ mips_va_start (tree valist, rtx nextarg)\n \t  f_goff = TREE_CHAIN (f_ftop);\n \t  f_foff = TREE_CHAIN (f_goff);\n \n-\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n-\t  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n-\t  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n-\t  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n-\t  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t\tNULL_TREE);\n+\t  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t\tNULL_TREE);\n+\t  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t\tNULL_TREE);\n+\t  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t\tNULL_TREE);\n+\t  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t\tNULL_TREE);\n \n \t  /* Emit code to initialize OVFL, which points to the next varargs\n \t     stack argument.  CUM->STACK_WORDS gives the number of stack\n@@ -4212,12 +4217,15 @@ mips_va_arg (tree valist, tree type)\n \t  lab_false = gen_label_rtx ();\n \t  lab_over = gen_label_rtx ();\n \n-\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl);\n+\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t\tNULL_TREE);\n \t  if (GET_MODE_CLASS (TYPE_MODE (type)) == MODE_FLOAT\n \t      && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_FPVALUE)\n \t    {\n-\t      top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop);\n-\t      off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n+\t      top = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t\t   NULL_TREE);\n+\t      off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t\t   NULL_TREE);\n \n \t      /* When floating-point registers are saved to the stack,\n \t\t each one will take up UNITS_PER_HWFPVALUE bytes, regardless\n@@ -4245,8 +4253,10 @@ mips_va_arg (tree valist, tree type)\n \t    }\n \t  else\n \t    {\n-\t      top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop);\n-\t      off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff);\n+\t      top = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t\t   NULL_TREE);\n+\t      off = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t\t   NULL_TREE);\n \t      if (rsize > UNITS_PER_WORD)\n \t\t{\n \t\t  /* [1] Emit code for: off &= -rsize.\t*/"}, {"sha": "861b00ad514aaa36d4e99b18559454ba19b92438", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -5026,10 +5026,10 @@ rs6000_va_start (tree valist, rtx nextarg)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = current_function_args_info.words;\n@@ -5131,10 +5131,10 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n   rsize = (size + 3) / 4;"}, {"sha": "cc48d015629765c70349746b06734e12f09242c9", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -6381,10 +6381,10 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n \n@@ -6462,10 +6462,10 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n   f_sav = TREE_CHAIN (f_ovf);\n \n   valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n-  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n \n   size = int_size_in_bytes (type);\n "}, {"sha": "2308f1b42d7d619d96367c6ee82e3b780616c18a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -6237,14 +6237,16 @@ sh_va_start (tree valist, rtx nextarg)\n   f_next_fp_limit = TREE_CHAIN (f_next_fp);\n   f_next_stack = TREE_CHAIN (f_next_fp_limit);\n \n-  next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o);\n+  next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n+\t\t  NULL_TREE);\n   next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n-\t\t\tvalist, f_next_o_limit);\n-  next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp), valist, f_next_fp);\n+\t\t\tvalist, f_next_o_limit, NULL_TREE);\n+  next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp), valist, f_next_fp,\n+\t\t   NULL_TREE);\n   next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n-\t\t\t valist, f_next_fp_limit);\n+\t\t\t valist, f_next_fp_limit, NULL_TREE);\n   next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n-\t\t      valist, f_next_stack);\n+\t\t      valist, f_next_stack, NULL_TREE);\n \n   /* Call __builtin_saveregs.  */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n@@ -6317,15 +6319,16 @@ sh_va_arg (tree valist, tree type)\n       f_next_fp_limit = TREE_CHAIN (f_next_fp);\n       f_next_stack = TREE_CHAIN (f_next_fp_limit);\n \n-      next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o);\n+      next_o = build (COMPONENT_REF, TREE_TYPE (f_next_o), valist, f_next_o,\n+\t\t      NULL_TREE);\n       next_o_limit = build (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n-\t\t\t    valist, f_next_o_limit);\n+\t\t\t    valist, f_next_o_limit, NULL_TREE);\n       next_fp = build (COMPONENT_REF, TREE_TYPE (f_next_fp),\n-\t\t       valist, f_next_fp);\n+\t\t       valist, f_next_fp, NULL_TREE);\n       next_fp_limit = build (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n-\t\t\t     valist, f_next_fp_limit);\n+\t\t\t     valist, f_next_fp_limit, NULL_TREE);\n       next_stack = build (COMPONENT_REF, TREE_TYPE (f_next_stack),\n-\t\t\t  valist, f_next_stack);\n+\t\t\t  valist, f_next_stack, NULL_TREE);\n \n       /* Structures with a single member with a distinct mode are passed\n \t like their member.  This is relevant if the latter has a REAL_TYPE"}, {"sha": "821279450fa7490f8b8b62e2a468d7fb78ca9f3b", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1285,8 +1285,9 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n   \n-  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base);\n-  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count);\n+  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n+  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n+\t\t NULL_TREE);\n \n   t = make_tree (TREE_TYPE (base), virtual_incoming_args_rtx);\n   t = build (PLUS_EXPR, TREE_TYPE (base), t, \n@@ -1320,8 +1321,9 @@ xstormy16_expand_builtin_va_arg (tree valist, tree type)\n   f_base = TYPE_FIELDS (va_list_type_node);\n   f_count = TREE_CHAIN (f_base);\n   \n-  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base);\n-  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count);\n+  base = build (COMPONENT_REF, TREE_TYPE (f_base), valist, f_base, NULL_TREE);\n+  count = build (COMPONENT_REF, TREE_TYPE (f_count), valist, f_count,\n+\t\t NULL_TREE);\n \n   must_stack = MUST_PASS_IN_STACK (TYPE_MODE (type), type);\n   size_tree = round_up (size_in_bytes (type), UNITS_PER_WORD);"}, {"sha": "2d9ea5235b9a7adca35f71641edd489183a29fea", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -2430,9 +2430,9 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   f_reg = TREE_CHAIN (f_stk);\n   f_ndx = TREE_CHAIN (f_reg);\n \n-  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk);\n-  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg);\n-  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx);\n+  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n+  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n+  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n \n   /* Call __builtin_saveregs; save the result in __va_reg */\n   u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n@@ -2494,9 +2494,9 @@ xtensa_va_arg (tree valist, tree type)\n   f_reg = TREE_CHAIN (f_stk);\n   f_ndx = TREE_CHAIN (f_reg);\n \n-  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk);\n-  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg);\n-  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx);\n+  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk, NULL_TREE);\n+  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n+  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n \n   type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type));\n "}, {"sha": "e39f0a66cc7f0d07d8f7e3165059cea9bcb7d613", "filename": "gcc/coverage.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -428,16 +428,18 @@ rtl_coverage_counter_ref (unsigned counter, unsigned no)\n tree\n tree_coverage_counter_ref (unsigned counter, unsigned no)\n {\n-  tree t;\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (tree_ctr_tables[counter]));\n \n   if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n     abort ();\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n \n   /* \"no\" here is an array index, scaled to bytes later.  */\n-  t = build (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n-\t     build_int_2 (no, 0));\n-  return t;\n+  return build (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n+\t\tfold_convert (domain_type, build_int_2 (no, 0)),\n+\t\tTYPE_MIN_VALUE (domain_type),\n+\t\tsize_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (GCOV_TYPE_NODE),\n+\t\t\t    size_int (TYPE_ALIGN (GCOV_TYPE_NODE))));\n }\n \f\n /* Generate a checksum for a string.  CHKSUM is the current"}, {"sha": "d8b494bdff6887cd9f4da8f0c78231f1186773a1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,3 +1,29 @@\n+2004-06-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* call.c (build_vfield_ref): Add new operand for COMPONENT_REF.\n+\t(build_new_method_call): Likewise.\n+\t* decl.c (local_variable_p_walkfn): Don't walk into types.\n+\t* decl2.c (grok_array_decl): Add new operands for ARRAY_REF.\n+\t(build_anon_union_vars): Add new operand for COMPONENT_REF.\n+\t* init.c (buld_new): Add new operand for ARRAY_REF.\n+\t* method.c (do_build_copy_constructor): New op for COMPONENT_REF.\n+\t(do_build_assign_ref): Likewise.\n+\t* parser.c (cp_parser_direct_new_declarator): Add new operands\n+\tfor ARRAY_REF.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t* pt.c (tsubst): Likewise.\n+\t(tsubst_copy, tsubst_copy_and_build): Likewise; also add new operand\n+ \tfor COMPONENT_REF.\n+\t* semantics.c (finish_non_static_data_member): Add new operand\n+\tfor COMPONENT_REF.\n+\t* typeck.c (build_class_member_access_expr): Likewise.\n+\t(build_class_member_access_expr, finish_class_member_access_expr):\n+\tLikewise.\n+\t(build_ptrmemfunc_access_expr): Likewise.\n+\t(build_array_ref): Add new operands for ARRAY_REF.\n+\t* typeck2.c (split_nonconstant_init_1): Likewise; COMPONENT_REF too.\n+\t* tree.c (count_trees_r, no_linkage_helper): Don't walk in types.\n+\n 2004-06-21  Richard Henderson  <rth@redhat.com>\n \n \t* dump.c (cp_dump_tree): Don't use dump_next_stmt."}, {"sha": "0c247b8127a435a313d711c6f2d401bbc52abbc0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -203,7 +203,7 @@ build_vfield_ref (tree datum, tree type)\n     datum = convert_to_base (datum, type, /*check_access=*/false);\n \n   return build (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n-\t\tdatum, TYPE_VFIELD (type));\n+\t\tdatum, TYPE_VFIELD (type), NULL_TREE);\n }\n \n /* Returns nonzero iff the destructor name specified in NAME\n@@ -3868,8 +3868,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       return build_conditional_expr (arg1, arg2, arg3);\n \n     case MEMBER_REF:\n-      return build_m_component_ref\n-\t(build_indirect_ref (arg1, NULL), arg2);\n+      return build_m_component_ref (build_indirect_ref (arg1, NULL), arg2);\n \n       /* The caller will deal with these.  */\n     case ADDR_EXPR:\n@@ -5360,7 +5359,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n   if (processing_template_decl && call != error_mark_node)\n     call = (build_min_non_dep\n \t    (CALL_EXPR, call,\n-\t     build_min_nt (COMPONENT_REF, orig_instance, orig_fns),\n+\t     build_min_nt (COMPONENT_REF, orig_instance, orig_fns, NULL_TREE),\n \t     orig_args, NULL_TREE));\n \n  /* Free all the conversions we allocated.  */"}, {"sha": "55ce6841723c7cd0af8bade3869a99bc8d042c79", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -8508,14 +8508,18 @@ nonstatic_local_decl_p (tree t)\n    function.  */\n \n static tree\n-local_variable_p_walkfn (tree* tp,\n-                         int* walk_subtrees ATTRIBUTE_UNUSED ,\n-                         void* data ATTRIBUTE_UNUSED )\n+local_variable_p_walkfn (tree *tp, int *walk_subtrees,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n-  return ((local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp))\n-\t  ? *tp : NULL_TREE);\n+  if (local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp))\n+    return *tp;\n+  else if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n }\n \n+\n /* Check that ARG, which is a default-argument expression for a\n    parameter DECL, is valid.  Returns ARG, or ERROR_MARK_NODE, if\n    something goes wrong.  DECL may also be a _TYPE node, rather than a"}, {"sha": "00105a6d2a6945153a804484be9b644eebdeaafe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -369,7 +369,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n     {\n       if (type_dependent_expression_p (array_expr)\n \t  || type_dependent_expression_p (index_exp))\n-\treturn build_min_nt (ARRAY_REF, array_expr, index_exp);\n+\treturn build_min_nt (ARRAY_REF, array_expr, index_exp,\n+\t\t\t     NULL_TREE, NULL_TREE);\n       array_expr = build_non_dependent_expr (array_expr);\n       index_exp = build_non_dependent_expr (index_exp);\n     }\n@@ -426,8 +427,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n       expr = build_array_ref (array_expr, index_exp);\n     }\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (ARRAY_REF, expr,\n-\t\t\t      orig_array_expr, orig_index_exp);\n+    return build_min_non_dep (ARRAY_REF, expr, orig_array_expr, orig_index_exp,\n+\t\t\t      NULL_TREE, NULL_TREE);\n   return expr;\n }\n \n@@ -1175,7 +1176,8 @@ build_anon_union_vars (tree object)\n \tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n \n       if (processing_template_decl)\n-\tref = build_min_nt (COMPONENT_REF, object, DECL_NAME (field));\n+\tref = build_min_nt (COMPONENT_REF, object,\n+\t\t\t    DECL_NAME (field), NULL_TREE);\n       else\n \tref = build_class_member_access_expr (object, field, NULL_TREE,\n \t\t\t\t\t      false);"}, {"sha": "2af51185e7ba2d1f63e04a9661227938f273cfde", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1777,7 +1777,8 @@ build_new (tree placement, tree decl, tree init, int use_global_new)\n     {\n       if (has_array)\n \tt = tree_cons (tree_cons (NULL_TREE, type, NULL_TREE),\n-\t\t       build_min_nt (ARRAY_REF, NULL_TREE, nelts),\n+\t\t       build_min_nt (ARRAY_REF, NULL_TREE, nelts,\n+\t\t\t\t     NULL_TREE, NULL_TREE),\n \t\t       NULL_TREE);\n       else\n \tt = type;\n@@ -1815,7 +1816,7 @@ build_new (tree placement, tree decl, tree init, int use_global_new)\n     }\n \n   if (has_array)\n-    t = build_nt (ARRAY_REF, type, nelts);\n+    t = build_nt (ARRAY_REF, type, nelts, NULL_TREE, NULL_TREE);\n   else\n     t = type;\n "}, {"sha": "495244fa748fb9433a4f3995f278fc5ea422c7dd", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -591,7 +591,7 @@ do_build_copy_constructor (tree fndecl)\n \t  expr_type = TREE_TYPE (field);\n \t  if (TREE_CODE (expr_type) != REFERENCE_TYPE)\n \t    expr_type = cp_build_qualified_type (expr_type, cvquals);\n-\t  init = build (COMPONENT_REF, expr_type, init, field);\n+\t  init = build (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \t  init = build_tree_list (NULL_TREE, init);\n \n \t  member_init_list\n@@ -687,10 +687,11 @@ do_build_assign_ref (tree fndecl)\n \t  else\n \t    continue;\n \n-\t  comp = build (COMPONENT_REF, TREE_TYPE (field), comp, field);\n+\t  comp = build (COMPONENT_REF, TREE_TYPE (field), comp, field,\n+\t\t\tNULL_TREE);\n \t  init = build (COMPONENT_REF,\n \t                cp_build_qualified_type (TREE_TYPE (field), cvquals),\n-\t                init, field);\n+\t                init, field, NULL_TREE);\n \n \t  if (DECL_NAME (field))\n \t    finish_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));"}, {"sha": "5ad4250ee0a8e7ab874516bb67a8ed5ee547a5eb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -4767,7 +4767,8 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n \n       /* Add this bound to the declarator.  */\n-      declarator = build_nt (ARRAY_REF, declarator, expression);\n+      declarator = build_nt (ARRAY_REF, declarator, expression,\n+\t\t\t     NULL_TREE, NULL_TREE);\n \n       /* If the next token is not a `[', then there are no more\n \t bounds.  */\n@@ -10714,7 +10715,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      break;\n \t    }\n \n-\t  declarator = build_nt (ARRAY_REF, declarator, bounds);\n+\t  declarator = build_nt (ARRAY_REF, declarator, bounds,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{"}, {"sha": "1e23acbcf079adb2ae5d4969c76c8c8cc78e4eb8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -7201,7 +7201,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn build_nt (ARRAY_REF, e1, e2);\n+\treturn build_nt (ARRAY_REF, e1, e2, NULL_TREE, NULL_TREE);\n       }\n \n     case CALL_EXPR:\n@@ -7563,7 +7563,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t  in_decl);\n \telse\n \t  name = tsubst_copy (name, args, complain, in_decl);\n-\treturn build_nt (COMPONENT_REF, object, name);\n+\treturn build_nt (COMPONENT_REF, object, name, NULL_TREE);\n       }\n \n     case PLUS_EXPR:\n@@ -8143,7 +8143,7 @@ tsubst_copy_and_build (tree t,\n \t\n \tif (object)\n \t  return build (COMPONENT_REF, TREE_TYPE (template), \n-\t\t\tobject, template);\n+\t\t\tobject, template, NULL_TREE);\n \telse\n \t  return template;\n       }\n@@ -8255,7 +8255,8 @@ tsubst_copy_and_build (tree t,\n       if (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl)\n \t  == NULL_TREE)\n \t/* new-type-id */\n-\treturn build_nt (ARRAY_REF, NULL_TREE, RECUR (TREE_OPERAND (t, 1)));\n+\treturn build_nt (ARRAY_REF, NULL_TREE, RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t NULL_TREE, NULL_TREE);\n \n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);"}, {"sha": "9e4b884c3b3b08942e1659cb1df51097db9e7a25", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1233,7 +1233,7 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t  type = cp_build_qualified_type (type, quals);\n \t}\n       \n-      return build_min (COMPONENT_REF, type, object, decl);\n+      return build_min (COMPONENT_REF, type, object, decl, NULL_TREE);\n     }\n   else\n     {"}, {"sha": "527e9c27d50cd0f2c82965cdb5230d8d5eba4c27", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1026,11 +1026,13 @@ bind_template_template_parm (tree t, tree newargs)\n /* Called from count_trees via walk_tree.  */\n \n static tree\n-count_trees_r (tree* tp ATTRIBUTE_UNUSED , \n-               int* walk_subtrees ATTRIBUTE_UNUSED , \n-               void* data)\n+count_trees_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  ++ *((int*) data);\n+  ++*((int *) data);\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+\n   return NULL_TREE;\n }\n \n@@ -1107,9 +1109,8 @@ find_tree (tree t, tree x)\n /* Passed to walk_tree.  Checks for the use of types with no linkage.  */\n \n static tree\n-no_linkage_helper (tree* tp, \n-                   int* walk_subtrees ATTRIBUTE_UNUSED , \n-                   void* data ATTRIBUTE_UNUSED )\n+no_linkage_helper (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t   void *data ATTRIBUTE_UNUSED)\n {\n   tree t = *tp;\n \n@@ -1118,6 +1119,7 @@ no_linkage_helper (tree* tp,\n       && (decl_function_context (TYPE_MAIN_DECL (t))\n \t  || TYPE_ANONYMOUS_P (t)))\n     return t;\n+\n   return NULL_TREE;\n }\n "}, {"sha": "880000783cf3e15dd1fe35ad2aeb821b2ddff004", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1752,7 +1752,8 @@ build_class_member_access_expr (tree object, tree member,\n \t  member_type = cp_build_qualified_type (member_type, type_quals);\n \t}\n \n-      result = fold (build (COMPONENT_REF, member_type, object, member));\n+      result = fold (build (COMPONENT_REF, member_type, object, member,\n+\t\t\t    NULL_TREE));\n \n       /* Mark the expression const or volatile, as appropriate.  Even\n \t though we've dealt with the type above, we still have to mark the\n@@ -1779,7 +1780,7 @@ build_class_member_access_expr (tree object, tree member,\n \ttype = unknown_type_node;\n       /* Note that we do not convert OBJECT to the BASELINK_BINFO\n \t base.  That will happen when the function is called.  */\n-      result = build (COMPONENT_REF, type, object, member);\n+      result = build (COMPONENT_REF, type, object, member, NULL_TREE);\n     }\n   else if (TREE_CODE (member) == CONST_DECL)\n     {\n@@ -1878,7 +1879,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t  || (TREE_CODE (name) == SCOPE_REF\n \t      && TYPE_P (TREE_OPERAND (name, 0))\n \t      && dependent_type_p (TREE_OPERAND (name, 0))))\n-\treturn build_min_nt (COMPONENT_REF, object, name);\n+\treturn build_min_nt (COMPONENT_REF, object, name, NULL_TREE);\n       object = build_non_dependent_expr (object);\n     }\n   \n@@ -2005,7 +2006,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t\t\t\t\t /*preserve_reference=*/false);\n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (COMPONENT_REF, expr,\n-\t\t\t      orig_object, orig_name);\n+\t\t\t      orig_object, orig_name, NULL_TREE);\n   return expr;\n }\n \n@@ -2033,7 +2034,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n \t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t\t cp_type_quals (ptrmem_type));\n-  return fold (build (COMPONENT_REF, member_type, ptrmem, member));\n+  return fold (build (COMPONENT_REF, member_type, ptrmem, member, NULL_TREE));\n }\n \n /* Given an expression PTR for a pointer, return an expression\n@@ -2249,7 +2250,7 @@ build_array_ref (tree array, tree idx)\n \t}\n \n       type = TREE_TYPE (TREE_TYPE (array));\n-      rval = build (ARRAY_REF, type, array, idx);\n+      rval = build (ARRAY_REF, type, array, idx, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n \t or if the array is..  */\n       TREE_READONLY (rval)"}, {"sha": "2e08d563079bfce1f05425219d21b219d4c0cb10", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -320,9 +320,11 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n \t      if (array_type_p)\n-\t        sub = build (ARRAY_REF, inner_type, dest, field_index);\n+\t        sub = build (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t     NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build (COMPONENT_REF, inner_type, dest, field_index);\n+\t        sub = build (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t     NULL_TREE);\n \n \t      split_nonconstant_init_1 (sub, value);\n \t    }\n@@ -331,9 +333,11 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t      *pelt = TREE_CHAIN (elt);\n \n \t      if (array_type_p)\n-\t        sub = build (ARRAY_REF, inner_type, dest, field_index);\n+\t        sub = build (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t     NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build (COMPONENT_REF, inner_type, dest, field_index);\n+\t        sub = build (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t     NULL_TREE);\n \n \t      code = build (MODIFY_EXPR, inner_type, sub, value);\n \t      code = build_stmt (EXPR_STMT, code);"}, {"sha": "984f81ffd6acb5dacca9c5641b22a89a6673a08f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1460,8 +1460,8 @@ component_ref_for_mem_expr (tree ref)\n   if (inner == TREE_OPERAND (ref, 0))\n     return ref;\n   else\n-    return build (COMPONENT_REF, TREE_TYPE (ref), inner,\n-\t\t  TREE_OPERAND (ref, 1));\n+    return build (COMPONENT_REF, TREE_TYPE (ref), inner, TREE_OPERAND (ref, 1),\n+\t\t  NULL_TREE);\n }\n \n /* Returns 1 if both MEM_EXPR can be considered equal\n@@ -1625,28 +1625,22 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  do\n \t    {\n \t      tree index = TREE_OPERAND (t2, 1);\n-\t      tree array = TREE_OPERAND (t2, 0);\n-\t      tree domain = TYPE_DOMAIN (TREE_TYPE (array));\n-\t      tree low_bound = (domain ? TYPE_MIN_VALUE (domain) : 0);\n-\t      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (array)));\n+\t      tree low_bound = array_ref_low_bound (t2);\n+\t      tree unit_size = array_ref_element_size (t2);\n \n \t      /* We assume all arrays have sizes that are a multiple of a byte.\n \t\t First subtract the lower bound, if any, in the type of the\n-\t\t index, then convert to sizetype and multiply by the size of the\n-\t\t array element.  */\n-\t      if (low_bound != 0 && ! integer_zerop (low_bound))\n+\t\t index, then convert to sizetype and multiply by the size of\n+\t\t the array element.  */\n+\t      if (! integer_zerop (low_bound))\n \t\tindex = fold (build (MINUS_EXPR, TREE_TYPE (index),\n \t\t\t\t     index, low_bound));\n \n-\t      /* If the index has a self-referential type, instantiate it;\n-\t\t likewise for the component size.  */\n-\t      index = SUBSTITUTE_PLACEHOLDER_IN_EXPR (index, t2);\n-\t      unit_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (unit_size, array);\n-\t      off_tree\n-\t\t= fold (build (PLUS_EXPR, sizetype,\n-\t\t\t       fold (build (MULT_EXPR, sizetype,\n-\t\t\t\t\t    index, unit_size)),\n-\t\t\t       off_tree));\n+\t      off_tree = size_binop (PLUS_EXPR,\n+\t\t\t\t     size_binop (MULT_EXPR, convert (sizetype,\n+\t\t\t\t\t\t\t\t     index),\n+\t\t\t\t\t\t unit_size),\n+\t\t\t\t     off_tree);\n \t      t2 = TREE_OPERAND (t2, 0);\n \t    }\n \t  while (TREE_CODE (t2) == ARRAY_REF);\n@@ -2042,6 +2036,7 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n       if (TREE_CODE (expr) == COMPONENT_REF)\n \t{\n \t  tree field = TREE_OPERAND (expr, 1);\n+\t  tree offset = component_ref_field_offset (expr);\n \n \t  if (! DECL_SIZE_UNIT (field))\n \t    {\n@@ -2056,17 +2051,18 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n \t      && INTVAL (memoffset) >= 0)\n \t    break;\n \n-\t  if (! host_integerp (DECL_FIELD_OFFSET (field), 1))\n+\t  if (! host_integerp (offset, 1))\n \t    {\n \t      expr = NULL_TREE;\n \t      break;\n \t    }\n \n \t  expr = TREE_OPERAND (expr, 0);\n-\t  memoffset = (GEN_INT (INTVAL (memoffset)\n-\t\t       + tree_low_cst (DECL_FIELD_OFFSET (field), 1)\n-\t\t       + (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n-\t\t          / BITS_PER_UNIT)));\n+\t  memoffset\n+\t    = (GEN_INT (INTVAL (memoffset)\n+\t\t\t+ tree_low_cst (offset, 1)\n+\t\t\t+ (tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n+\t\t\t   / BITS_PER_UNIT)));\n \t}\n       /* Similarly for the decl.  */\n       else if (DECL_P (expr)"}, {"sha": "672d3f6525a3ecdcf04a8611f63905a7a49a434e", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1100,7 +1100,7 @@ update_nonlocal_goto_save_area (void)\n      STACK_SAVEAREA_MODE.  Create a reference to array index 1, the first\n      of the stack save area slots.  */\n   t_save = build (ARRAY_REF, ptr_type_node, cfun->nonlocal_goto_save_area,\n-\t\t  integer_one_node);\n+\t\t  integer_one_node, NULL_TREE, NULL_TREE);\n   r_save = expand_expr (t_save, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n   emit_stack_save (SAVE_NONLOCAL, &r_save, NULL_RTX);"}, {"sha": "989a5fa6dca55a15b5489b77a4a20ce571a4f227", "filename": "gcc/expr.c", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -5591,15 +5591,13 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n       else if (TREE_CODE (exp) == COMPONENT_REF)\n \t{\n \t  tree field = TREE_OPERAND (exp, 1);\n-\t  tree this_offset = DECL_FIELD_OFFSET (field);\n+\t  tree this_offset = component_ref_field_offset (exp);\n \n \t  /* If this field hasn't been filled in yet, don't go\n \t     past it.  This should only happen when folding expressions\n \t     made during type construction.  */\n \t  if (this_offset == 0)\n \t    break;\n-\t  else\n-\t    this_offset = SUBSTITUTE_PLACEHOLDER_IN_EXPR (this_offset, exp);\n \n \t  offset = size_binop (PLUS_EXPR, offset, this_offset);\n \t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n@@ -5612,23 +5610,17 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t       || TREE_CODE (exp) == ARRAY_RANGE_REF)\n \t{\n \t  tree index = TREE_OPERAND (exp, 1);\n-\t  tree array = TREE_OPERAND (exp, 0);\n-\t  tree domain = TYPE_DOMAIN (TREE_TYPE (array));\n-\t  tree low_bound = (domain ? TYPE_MIN_VALUE (domain) : 0);\n-\t  tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (array)));\n+\t  tree low_bound = array_ref_low_bound (exp);\n+\t  tree unit_size = array_ref_element_size (exp);\n \n \t  /* We assume all arrays have sizes that are a multiple of a byte.\n \t     First subtract the lower bound, if any, in the type of the\n \t     index, then convert to sizetype and multiply by the size of the\n \t     array element.  */\n-\t  if (low_bound != 0 && ! integer_zerop (low_bound))\n+\t  if (! integer_zerop (low_bound))\n \t    index = fold (build (MINUS_EXPR, TREE_TYPE (index),\n \t\t\t\t index, low_bound));\n \n-\t  /* If the index has a self-referential type, instantiate it with\n-\t     the object; likewise for the component size.  */\n-\t  index = SUBSTITUTE_PLACEHOLDER_IN_EXPR (index, exp);\n-\t  unit_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (unit_size, array);\n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       size_binop (MULT_EXPR,\n \t\t\t\t\t   convert (sizetype, index),\n@@ -5676,6 +5668,70 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   return exp;\n }\n \n+/* Return a tree of sizetype representing the size, in bytes, of the element\n+   of EXP, an ARRAY_REF.  */\n+\n+tree\n+array_ref_element_size (tree exp)\n+{\n+  tree aligned_size = TREE_OPERAND (exp, 3);\n+  tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  /* If a size was specified in the ARRAY_REF, it's the size measured\n+     in alignment units of the element type.  So multiply by that value.  */\n+  if (aligned_size)\n+    return size_binop (MULT_EXPR, aligned_size,\n+\t\t       size_int (TYPE_ALIGN (elmt_type) / BITS_PER_UNIT));\n+\n+  /* Otherwise, take the size from that of the element type.  Substitute \n+     any PLACEHOLDER_EXPR that we have.  */\n+  else\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elmt_type), exp);\n+}\n+\n+/* Return a tree representing the lower bound of the array mentioned in\n+   EXP, an ARRAY_REF.  */\n+\n+tree\n+array_ref_low_bound (tree exp)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+  /* If a lower bound is specified in EXP, use it.  */\n+  if (TREE_OPERAND (exp, 2))\n+    return TREE_OPERAND (exp, 2);\n+\n+  /* Otherwise, if there is a domain type and it has a lower bound, use it,\n+     substituting for a PLACEHOLDER_EXPR as needed.  */\n+  if (domain_type && TYPE_MIN_VALUE (domain_type))\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MIN_VALUE (domain_type), exp);\n+\n+  /* Otherwise, return a zero of the appropriate type.  */\n+  return fold_convert (TREE_TYPE (TREE_OPERAND (exp, 1)), integer_zero_node);\n+}\n+\n+/* Return a tree representing the offset, in bytes, of the field referenced\n+   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n+\n+tree\n+component_ref_field_offset (tree exp)\n+{\n+  tree aligned_offset = TREE_OPERAND (exp, 2);\n+  tree field = TREE_OPERAND (exp, 1);\n+\n+  /* If an offset was specified in the COMPONENT_REF, it's the offset measured\n+     in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  So multiply by that\n+     value.  */\n+  if (aligned_offset)\n+    return size_binop (MULT_EXPR, aligned_offset,\n+\t\t       size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT));\n+\n+  /* Otherwise, take the offset from that of the field.  Substitute \n+     any PLACEHOLDER_EXPR that we have.  */\n+  else\n+    return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n+}\n+\n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n int\n@@ -7001,8 +7057,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       {\n \ttree array = TREE_OPERAND (exp, 0);\n-\ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n-\ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n+\ttree low_bound = array_ref_low_bound (exp);\n \ttree index = convert (sizetype, TREE_OPERAND (exp, 1));\n \tHOST_WIDE_INT i;\n "}, {"sha": "3d4cccaaa6b7426aeb934d080dc368090b9b0ec8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -2019,9 +2019,9 @@ non_lvalue (tree x)\n   case COMPONENT_REF:\n   case INDIRECT_REF:\n   case ARRAY_REF:\n+  case ARRAY_RANGE_REF:\n   case BIT_FIELD_REF:\n   case BUFFER_REF:\n-  case ARRAY_RANGE_REF:\n   case VTABLE_REF:\n \n   case REALPART_EXPR:\n@@ -7901,24 +7901,26 @@ fold (tree expr)\n \t  /* If VAROP is a reference to a bitfield, we must mask\n \t     the constant by the width of the field.  */\n \t  if (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n-\t      && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (varop, 0), 1)))\n+\t      && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (varop, 0), 1))\n+\t      && host_integerp (DECL_SIZE (TREE_OPERAND\n+\t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)), 1))\n \t    {\n \t      tree fielddecl = TREE_OPERAND (TREE_OPERAND (varop, 0), 1);\n-\t      int size = TREE_INT_CST_LOW (DECL_SIZE (fielddecl));\n+\t      HOST_WIDE_INT size = tree_low_cst (DECL_SIZE (fielddecl), 1);\n \t      tree folded_compare, shift;\n \n \t      /* First check whether the comparison would come out\n \t\t always the same.  If we don't do that we would\n \t\t change the meaning with the masking.  */\n \t      folded_compare = fold (build2 (code, type,\n-\t\t\t\t\t     TREE_OPERAND (varop, 0),\n-\t\t\t\t\t     arg1));\n+\t\t\t\t\t     TREE_OPERAND (varop, 0), arg1));\n \t      if (integer_zerop (folded_compare)\n \t\t  || integer_onep (folded_compare))\n \t\treturn omit_one_operand (type, folded_compare, varop);\n \n \t      shift = build_int_2 (TYPE_PRECISION (TREE_TYPE (varop)) - size,\n \t\t\t\t   0);\n+\t      shift = fold_convert (TREE_TYPE (varop), shift);\n \t      newconst = fold (build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n \t\t\t\t       newconst, shift));\n \t      newconst = fold (build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n@@ -10106,13 +10108,10 @@ fold_read_from_constant_string (tree exp)\n       tree string;\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\t{\n-\t  string = string_constant (exp1, &index);\n-\t}\n+\tstring = string_constant (exp1, &index);\n       else\n \t{\n-\t  tree domain = TYPE_DOMAIN (TREE_TYPE (exp1));\n-\t  tree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n+\t  tree low_bound = array_ref_low_bound (exp);\n \t  index = fold_convert (sizetype, TREE_OPERAND (exp, 1));\n \t  \n \t  /* Optimize the special-case of a zero lower bound.\n@@ -10129,6 +10128,7 @@ fold_read_from_constant_string (tree exp)\n \t}\n \n       if (string\n+\t  && TREE_TYPE (exp) == TREE_TYPE (TREE_TYPE (string))\n \t  && TREE_CODE (string) == STRING_CST\n \t  && TREE_CODE (index) == INTEGER_CST\n \t  && compare_tree_int (index, TREE_STRING_LENGTH (string)) < 0\n@@ -10456,7 +10456,7 @@ build_fold_indirect_ref (tree t)\n       /* *(foo *)&fooarray => fooarray[0] */\n       else if (TREE_CODE (optype) == ARRAY_TYPE\n \t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n-\treturn build2 (ARRAY_REF, type, op, size_zero_node);\n+\treturn build4 (ARRAY_REF, type, op, size_zero_node, NULL_TREE, NULL_TREE);\n     }\n \n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n@@ -10465,7 +10465,7 @@ build_fold_indirect_ref (tree t)\n       && lang_hooks.types_compatible_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n     {\n       sub = build_fold_indirect_ref (sub);\n-      return build2 (ARRAY_REF, type, sub, size_zero_node);\n+      return build4 (ARRAY_REF, type, sub, size_zero_node, NULL_TREE, NULL_TREE);\n     }\n \n   return build1 (INDIRECT_REF, type, t);"}, {"sha": "a2bb02c019c59c4919654df9339f407970bcfde7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,3 +1,22 @@\n+2004-06-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* f95-lang.c (LANG_HOOKS_GIMPLE_BEFORE_INLINING): Deleted.\n+\t* trans-array.c (gfc_conv_descriptor_data): Add operand\n+\tfor COMPONENT_REF.\n+\t(gfc_conv_descriptor_offset, gfc_conv_descriptor_dtype): Likewise.\n+\t(gfc_conv_descriptor_dimension, gfc_conv_descriptor_stride): Likewise.\n+\t(gfc_conv_descriptor_lbound, gfc_conv_descriptor_ubound): Likewise.\n+\t* trans-common.c (create_common): Likewise.\n+\t* trans-expr.c (gfc_conv_component_ref): Likewise.\n+\t* trans-io.c (set_parameter_value): Likewise.\n+\t(set_parameter_ref, set_string, set_flag, io_result): Likewise.\n+\t(transfer_expr): Likewise.\n+\t* trans-decl.c (gfc_trans_auto_character_variable):\n+\tSet up to get DECL_SIZE and DECL_SIZE_UNIT gimplified.\n+\t(gfc_simplify_function): New function.\n+\t(gfc_generate_function-code): Properly handle nested functions.\n+\t* trans.c (gfc_build_array_ref): Add two new operands for ARRAY_REF.\n+\n 2004-06-22  Janne Blomqvist  <jblomqvi@cc.hut.fi>\n \n \tPR fortran/15750"}, {"sha": "fd4fe5c2616d6873acf11f7447809ed82a543caa", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -122,7 +122,6 @@ static void gfc_expand_function (tree);\n #undef LANG_HOOKS_UNSIGNED_TYPE\n #undef LANG_HOOKS_SIGNED_TYPE\n #undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n-#undef LANG_HOOKS_GIMPLE_BEFORE_INLINING\n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n \n /* Define lang hooks.  */\n@@ -141,7 +140,6 @@ static void gfc_expand_function (tree);\n #define LANG_HOOKS_UNSIGNED_TYPE           gfc_unsigned_type\n #define LANG_HOOKS_SIGNED_TYPE             gfc_signed_type\n #define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE gfc_signed_or_unsigned_type\n-#define LANG_HOOKS_GIMPLE_BEFORE_INLINING false\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION gfc_expand_function\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;"}, {"sha": "bccaf414895808f6180bdf80c84c10c79ead8e58", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -189,7 +189,7 @@ gfc_conv_descriptor_data (tree desc)\n \t  && TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == ARRAY_TYPE);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field);\n+  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n tree\n@@ -204,7 +204,7 @@ gfc_conv_descriptor_offset (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field);\n+  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n tree\n@@ -219,7 +219,7 @@ gfc_conv_descriptor_dtype (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field);\n+  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n static tree\n@@ -237,7 +237,7 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), desc, field);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n   tmp = gfc_build_array_ref (tmp, dim);\n   return tmp;\n }\n@@ -253,7 +253,7 @@ gfc_conv_descriptor_stride (tree desc, tree dim)\n   field = gfc_advance_chain (field, STRIDE_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -268,7 +268,7 @@ gfc_conv_descriptor_lbound (tree desc, tree dim)\n   field = gfc_advance_chain (field, LBOUND_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -283,7 +283,7 @@ gfc_conv_descriptor_ubound (tree desc, tree dim)\n   field = gfc_advance_chain (field, UBOUND_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n "}, {"sha": "f0c385adfbb94979536f63e9a9e236a35b7199e7", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -425,7 +425,7 @@ create_common (gfc_symbol *sym)\n   for (h = current_common; h; h = next_s)\n     {\n       h->sym->backend_decl = build (COMPONENT_REF, TREE_TYPE (h->field),\n-                                    decl, h->field);\n+                                    decl, h->field, NULL_TREE);\n \n       next_s = h->next;\n       gfc_free (h);"}, {"sha": "8cf6cbb185de95d14fed6d28b394fb7d06bab70b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1645,6 +1645,14 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n \n   DECL_DEFER_OUTPUT (decl) = 1;\n \n+  /* Since we don't use a DECL_STMT or equivalent, we have to deal\n+     with getting these gimplified.  But we can't gimplify it yet since\n+     we're still generating statements.\n+\n+     ??? This should be cleaned up and handled like other front ends.  */\n+  gfc_add_expr_to_block (&body, save_expr (DECL_SIZE (decl)));\n+  gfc_add_expr_to_block (&body, save_expr (DECL_SIZE_UNIT (decl)));\n+\n   /* Generate code to allocate the automatic variable.  It will be freed\n      automatically.  */\n   tmp = gfc_build_addr_expr (NULL, decl);\n@@ -1949,6 +1957,24 @@ gfc_finalize (tree decl)\n   cgraph_finalize_function (decl, false);\n }\n \n+/* Convert FNDECL's code to GIMPLE and handle any nested functions.  */\n+\n+static void\n+gfc_gimplify_function (tree fndecl)\n+{\n+  struct cgraph_node *cgn;\n+\n+  gimplify_function_tree (fndecl);\n+  dump_function (TDI_generic, fndecl);\n+\n+  /* Convert all nested functions to GIMPLE now.  We do things in this order\n+     so that items like VLA sizes are expanded properly in the context of the\n+     correct function.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    gfc_gimplify_function (cgn->decl);\n+}\n+\n /* Generate code for a function.  */\n \n void\n@@ -2120,26 +2146,17 @@ gfc_generate_function_code (gfc_namespace * ns)\n   current_function_decl = old_context;\n \n   if (decl_function_context (fndecl))\n-    {\n-      /* Register this function with cgraph just far enough to get it\n-\t added to our parent's nested function list.  */\n-      (void) cgraph_node (fndecl);\n-\n-      /* Lowering nested functions requires gimple input.  */\n-      gimplify_function_tree (fndecl);\n-    }\n+    /* Register this function with cgraph just far enough to get it\n+       added to our parent's nested function list.  */\n+    (void) cgraph_node (fndecl);\n   else\n     {\n-      if (cgraph_node (fndecl)->nested)\n-\t{\n-\t  gimplify_function_tree (fndecl);\n-          lower_nested_functions (fndecl);\n-\t}\n+      gfc_gimplify_function (fndecl);\n+      lower_nested_functions (fndecl);\n       gfc_finalize (fndecl);\n     }\n }\n \n-\n void\n gfc_generate_constructors (void)\n {"}, {"sha": "717a5d83bb3e73c4cf45b5ef52157433a356fedb", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -221,7 +221,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), decl, field);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n \n   se->expr = tmp;\n "}, {"sha": "f3aa37d28d8634964c198a82a0a4a8d1a9482834", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -359,7 +359,7 @@ set_parameter_value (stmtblock_t * block, tree var, gfc_expr * e)\n   gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n }\n \n@@ -379,7 +379,7 @@ set_parameter_ref (stmtblock_t * block, tree var, gfc_expr * e)\n   gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var);\n+  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n }\n \n@@ -400,8 +400,9 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   gfc_init_se (&se, NULL);\n   gfc_conv_expr (&se, e);\n \n-  io = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var);\n-  len = build (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len);\n+  io = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n+  len = build (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len,\n+\t       NULL_TREE);\n \n   /*  Integer variable assigned a format label.  */\n   if (e->ts.type == BT_INTEGER && e->symtree->n.sym->attr.assign == 1)\n@@ -433,7 +434,7 @@ set_flag (stmtblock_t *block, tree var)\n {\n   tree tmp;\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE(var), ioparm_var, var);\n+  tmp = build (COMPONENT_REF, TREE_TYPE(var), ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, integer_one_node);\n }\n \n@@ -496,7 +497,7 @@ io_result (stmtblock_t * block, gfc_st_label * err_label,\n   tmp = gfc_finish_block (&body);\n \n   rc = build (COMPONENT_REF, TREE_TYPE (ioparm_library_return), ioparm_var,\n-\t      ioparm_library_return);\n+\t      ioparm_library_return, NULL_TREE);\n \n   tmp = build_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n \n@@ -1127,7 +1128,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \t  field = c->backend_decl;\n \t  assert (field && TREE_CODE (field) == FIELD_DECL);\n \n-\t  tmp = build (COMPONENT_REF, TREE_TYPE (field), expr, field);\n+\t  tmp = build (COMPONENT_REF, TREE_TYPE (field), expr, field,\n+\t\t       NULL_TREE);\n \n \t  if (c->ts.type == BT_CHARACTER)\n \t    {"}, {"sha": "29277282b5e89463ca6f823359b940086062c48d", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -306,7 +306,7 @@ gfc_build_array_ref (tree base, tree offset)\n   if (DECL_P (base))\n     TREE_ADDRESSABLE (base) = 1;\n \n-  return build (ARRAY_REF, type, base, offset);\n+  return build (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n }\n \n "}, {"sha": "8fd0a6f35abe4f8b4a0b602490b640a5212471b1", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -6544,7 +6544,7 @@ expand_function_start (tree subr, int parms_have_cleanups)\n       expand_var (TREE_OPERAND (cfun->nonlocal_goto_save_area, 0));\n \n       t_save = build (ARRAY_REF, ptr_type_node, cfun->nonlocal_goto_save_area,\n-\t\t      integer_zero_node);\n+\t\t      integer_zero_node, NULL_TREE, NULL_TREE);\n       r_save = expand_expr (t_save, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n       emit_move_insn (r_save, virtual_stack_vars_rtx);"}, {"sha": "32e5ceec5f489dd06355c5cf5449b1074a67ead4", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -476,8 +476,6 @@ expand_var_p (tree var)\n   if (TREE_CODE (var) != VAR_DECL)\n     return true;\n \n-  ann = var_ann (var);\n-\n   /* Remove all unused, unaliased temporaries.  Also remove unused, unaliased\n      local variables during highly optimizing compilations.  */\n   ann = var_ann (var);"}, {"sha": "36492720ff96d83f9096e9a4b787104aa8370717", "filename": "gcc/gimplify.c", "status": "modified", "additions": 576, "deletions": 195, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,6 +1,5 @@\n /* Tree lowering pass.  This pass converts the GENERIC functions-as-trees\n    tree representation into the GIMPLE form.\n-\n    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Major work done by Sebastian Pop <s.pop@laposte.net>,\n    Diego Novillo <dnovillo@redhat.com> and Jason Merrill <jason@redhat.com>.\n@@ -36,6 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n #include \"tree-flow.h\"\n+#include \"cgraph.h\"\n #include \"timevar.h\"\n #include \"except.h\"\n #include \"hashtab.h\"\n@@ -71,6 +71,73 @@ typedef struct gimple_temp_hash_elt\n   tree temp;  /* Value */\n } elt_t;\n \n+/* Forward declarations.  */\n+static hashval_t gimple_tree_hash (const void *);\n+static int gimple_tree_eq (const void *, const void *);\n+static bool gimple_conditional_context (void);\n+static void gimple_push_condition (void);\n+static void gimple_pop_condition (tree *);\n+static void append_to_statement_list_1 (tree, tree *, bool);\n+static inline void remove_suffix (char *, int);\n+static inline tree create_tmp_from_val (tree);\n+static tree lookup_tmp_var (tree, bool);\n+static tree internal_get_tmp_var (tree, tree *, tree *, bool);\n+static bool should_carry_locus_p (tree);\n+static tree mostly_copy_tree_r (tree *, int *, void *);\n+static tree mark_decls_volatile_r (tree *, int *, void *);\n+static tree copy_if_shared_r (tree *, int *, void *);\n+static tree unmark_visited_r (tree *, int *, void *);\n+static void unshare_body (tree *, tree);\n+static void unvisit_body (tree *, tree);\n+static void build_stack_save_restore (tree *, tree *);\n+static enum gimplify_status gimplify_bind_expr (tree *, tree, tree *);\n+static enum gimplify_status gimplify_return_expr (tree, tree *);\n+static enum gimplify_status gimplify_loop_expr (tree *, tree *);\n+static int compare_case_labels (const void *, const void *);\n+static enum gimplify_status gimplify_switch_expr (tree *, tree *);\n+static enum gimplify_status gimplify_case_label_expr (tree *);\n+static enum gimplify_status gimplify_labeled_block_expr (tree *);\n+static enum gimplify_status gimplify_exit_block_expr (tree *);\n+static enum gimplify_status gimplify_exit_expr (tree *);\n+static enum gimplify_status gimplify_init_constructor (tree *, tree *, tree *,\n+\t\t\t\t\t\t       bool);\n+static void canonicalize_component_ref (tree *);\n+static void canonicalize_addr_expr (tree *);\n+static enum gimplify_status gimplify_conversion (tree *);\n+static enum gimplify_status gimplify_minimax_expr (tree *, tree *, tree *);\n+static enum gimplify_status gimplify_array_ref_to_plus (tree *, tree *,\n+\t\t\t\t\t\t\ttree *);\n+static tree build_addr_expr_with_type (tree, tree);\n+static tree build_addr_expr (tree);\n+static enum gimplify_status gimplify_compound_lval (tree *, tree *, tree *,\n+\t\t\t\t\t\t    bool);\n+static enum gimplify_status gimplify_self_mod_expr (tree *, tree *, tree *,\n+\t\t\t\t\t\t    bool);\n+static enum gimplify_status gimplify_call_expr (tree *, tree *,\n+\t\t\t\t\t\tbool (*) (tree));\n+static tree shortcut_cond_r (tree, tree *, tree *);\n+static tree shortcut_cond_expr (tree);\n+static tree gimple_boolify (tree);\n+static enum gimplify_status gimplify_cond_expr (tree *, tree *, tree);\n+static enum gimplify_status gimplify_modify_expr (tree *, tree *, tree *,\n+\t\t\t\t\t\t  bool);\n+static enum gimplify_status gimplify_modify_expr_rhs (tree *, tree *, tree *,\n+\t\t\t\t\t\t      tree *, tree *, bool);\n+static enum gimplify_status gimplify_variable_sized_compare (tree *);\n+static enum gimplify_status gimplify_boolean_expr (tree *);\n+static enum gimplify_status gimplify_compound_expr (tree *, tree *, bool);\n+static enum gimplify_status gimplify_statement_list (tree *);\n+static enum gimplify_status gimplify_save_expr (tree *, tree *, tree *);\n+static enum gimplify_status gimplify_addr_expr (tree *, tree *, tree *);\n+static enum gimplify_status gimplify_asm_expr (tree *, tree *, tree *);\n+static enum gimplify_status gimplify_cleanup_point_expr (tree *, tree *);\n+static void gimple_push_cleanup (tree, tree, tree *);\n+static enum gimplify_status gimplify_target_expr (tree *, tree *, tree *);\n+#ifdef ENABLE_CHECKING\n+static bool cpt_same_type (tree, tree);\n+static tree check_pointer_types_r (tree *, int *, void *);\n+#endif\n+\n /* Return a hash value for a formal temporary table entry.  */\n \n static hashval_t\n@@ -355,15 +422,11 @@ create_tmp_var (tree type, const char *prefix)\n   tree tmp_var;\n \n #if defined ENABLE_CHECKING\n-  /* If the type is an array or a type which must be created by the\n-     frontend, something is wrong.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE || TREE_ADDRESSABLE (type))\n-    abort ();\n-  if (!COMPLETE_TYPE_P (type))\n-    abort ();\n-  /* Variable sized types require lots of machinery to create; the\n-     optimizers shouldn't be doing anything of the sort.  */\n-  if (TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n+  /* We don't allow types that are addressable (meaning we can't make copies),\n+     incomplete, or of variable size.  */\n+  if (TREE_ADDRESSABLE (type)\n+      || !COMPLETE_TYPE_P (type)\n+      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n     abort ();\n #endif\n \n@@ -653,11 +716,19 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   tree t = *tp;\n   enum tree_code code = TREE_CODE (t);\n \n-  /* Skip types, decls, and constants.  */\n+  /* Skip types, decls, and constants.  But we do want to look at their\n+     types and the bounds of types.  Mark them as visited so we properly\n+     unmark their subtrees on the unmark pass.  If we've already seen them,\n+     don't look down further.  */\n   if (TREE_CODE_CLASS (code) == 't'\n       || TREE_CODE_CLASS (code) == 'd'\n       || TREE_CODE_CLASS (code) == 'c')\n-    *walk_subtrees = 0;\n+    {\n+      if (TREE_VISITED (t))\n+\t*walk_subtrees = 0;\n+      else\n+\tTREE_VISITED (t) = 1;\n+    }\n \n   /* Special-case BIND_EXPR.  We should never be copying these, therefore\n      we can omit examining BIND_EXPR_VARS.  Which also avoids problems with\n@@ -715,6 +786,31 @@ unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Unshare all the trees in BODY_P, a pointer to the body of FNDECL, and the\n+   bodies of any nested functions.  */\n+\n+static void\n+unshare_body (tree *body_p, tree fndecl)\n+{\n+  struct cgraph_node *cgn = cgraph_node (fndecl);\n+\n+  walk_tree (body_p, copy_if_shared_r, NULL, NULL);\n+  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+}\n+\n+/* Likewise, but mark all trees as not visited.  */\n+\n+static void\n+unvisit_body (tree *body_p, tree fndecl)\n+{\n+  struct cgraph_node *cgn = cgraph_node (fndecl);\n+\n+  walk_tree (body_p, unmark_visited_r, NULL, NULL);\n+  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+    unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+}\n+\n /* Unshare T and all the trees reached from T via TREE_CHAIN.  */\n \n void\n@@ -1192,7 +1288,7 @@ build_and_jump (tree *label_p)\n {\n   if (label_p == NULL)\n     /* If there's nowhere to jump, just fall through.  */\n-    return build_empty_stmt ();\n+    return alloc_stmt_list ();\n \n   if (*label_p == NULL_TREE)\n     {\n@@ -1214,7 +1310,7 @@ gimplify_exit_expr (tree *expr_p)\n   tree expr;\n \n   expr = build_and_jump (&gimplify_ctxp->exit_label);\n-  expr = build (COND_EXPR, void_type_node, cond, expr, build_empty_stmt ());\n+  expr = build (COND_EXPR, void_type_node, cond, expr, alloc_stmt_list ());\n   *expr_p = expr;\n \n   return GS_OK;\n@@ -1243,7 +1339,7 @@ force_labels_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n static enum gimplify_status\n gimplify_init_constructor (tree *expr_p, tree *pre_p,\n-\t\t\t   tree *post_p, int want_value)\n+\t\t\t   tree *post_p, bool want_value)\n {\n   tree object = TREE_OPERAND (*expr_p, 0);\n   tree ctor = TREE_OPERAND (*expr_p, 1);\n@@ -1279,7 +1375,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\treturn GS_OK;\n \t      }\n \t    else\n-\t      return GS_ALL_DONE;\n+\t      return GS_UNHANDLED;\n \t  }\n \n \tcategorize_ctor_elements (ctor, &num_nonzero_elements,\n@@ -1307,7 +1403,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t       TU-local symbol, we must invoke the lhd version now.  */\n \t    lhd_set_decl_assembler_name (object);\n \n-\t    *expr_p = build_empty_stmt ();\n+\t    *expr_p = alloc_stmt_list ();\n \t    break;\n \t  }\n \n@@ -1416,21 +1512,19 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t\tif (TREE_CODE (purpose) == RANGE_EXPR)\n \t\t  abort ();\n \n-\t\tcref = build (ARRAY_REF, t, object, purpose);\n+\t\tcref = build (ARRAY_REF, t, object, purpose, NULL_TREE, NULL_TREE);\n \t      }\n \t    else\n-\t      {\n-\t\tcref = build (COMPONENT_REF, TREE_TYPE (purpose),\n-\t\t\t      object, purpose);\n-\t      }\n+\t      cref = build (COMPONENT_REF, TREE_TYPE (purpose), object,\n+\t\t\t    purpose, NULL_TREE);\n \n \t    init = build (MODIFY_EXPR, TREE_TYPE (purpose), cref, value);\n \t    /* Each member initialization is a full-expression.  */\n \t    gimplify_stmt (&init);\n \t    append_to_statement_list (init, pre_p);\n \t  }\n \n-\t*expr_p = build_empty_stmt ();\n+\t*expr_p = alloc_stmt_list ();\n       }\n       break;\n \n@@ -1552,18 +1646,17 @@ canonicalize_component_ref (tree *expr_p)\n }\n \n /* If a NOP conversion is changing a pointer to array of foo to a pointer\n-   to foo, embed that change in the ADDR_EXPR.  Lest we perturb the type\n-   system too badly, we must take extra steps to ensure that the ADDR_EXPR\n-   and the addressed object continue to agree on types.  */\n-/* ??? We might could do better if we recognize\n-\tT array[N][M];\n-\t(T *)&array\n+   to foo, embed that change in the ADDR_EXPR by converting \n+      T array[U];\n+      (T *)&array\n    ==>\n-\t&array[0][0];\n-*/\n+      &array[L]\n+   where L is the lower bound.  Only do this for constant lower bound since\n+   we have no place to put any statements made during gimplification of\n+   the lower bound.  */\n \n static void\n-canonicalize_addr_expr (tree* expr_p)\n+canonicalize_addr_expr (tree *expr_p)\n {\n   tree expr = *expr_p;\n   tree ctype = TREE_TYPE (expr);\n@@ -1592,8 +1685,20 @@ canonicalize_addr_expr (tree* expr_p)\n   if (!lang_hooks.types_compatible_p (otype, datype))\n     return;\n \n+  /* The lower bound and element sizes must be constant.  */\n+  if (TREE_CODE (TYPE_SIZE_UNIT (dctype)) != INTEGER_CST\n+      || !TYPE_DOMAIN (datype) || !TYPE_MIN_VALUE (TYPE_DOMAIN (datype))\n+      || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (datype))) != INTEGER_CST)\n+    return;\n+\n   /* All checks succeeded.  Build a new node to merge the cast.  */\n-  *expr_p = build1 (ADDR_EXPR, ctype, obj_expr);\n+  *expr_p = build4 (ARRAY_REF, dctype, obj_expr,\n+\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n+\t\t    TYPE_MIN_VALUE (TYPE_DOMAIN (datype)),\n+\t\t    size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (dctype),\n+\t\t\t\tsize_int (TYPE_ALIGN (dctype)\n+\t\t\t\t\t  / BITS_PER_UNIT)));\n+  *expr_p = build1 (ADDR_EXPR, ctype, *expr_p);\n }\n \n /* *EXPR_P is a NOP_EXPR or CONVERT_EXPR.  Remove it and/or other conversions\n@@ -1666,7 +1771,7 @@ gimplify_minimax_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     return GS_OK;\n }\n \n-/* Subroutine of gimplify_compound_lval and gimplify_array_ref.\n+/* Subroutine of gimplify_compound_lval.\n    Converts an ARRAY_REF to the equivalent *(&array + offset) form.  */\n \n static enum gimplify_status\n@@ -1675,25 +1780,21 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n   tree array = TREE_OPERAND (*expr_p, 0);\n   tree arrtype = TREE_TYPE (array);\n   tree elttype = TREE_TYPE (arrtype);\n-  tree size = size_in_bytes (elttype);\n+  tree size = array_ref_element_size (*expr_p);\n   tree ptrtype = build_pointer_type (elttype);\n   enum tree_code add_code = PLUS_EXPR;\n   tree idx = TREE_OPERAND (*expr_p, 1);\n-  tree minidx, offset, addr, result;\n+  tree minidx = unshare_expr (array_ref_low_bound (*expr_p));\n+  tree offset, addr, result;\n   enum gimplify_status ret;\n \n   /* If the array domain does not start at zero, apply the offset.  */\n-  minidx = TYPE_DOMAIN (arrtype);\n-  if (minidx)\n+  if (!integer_zerop (minidx))\n     {\n-      minidx = TYPE_MIN_VALUE (minidx);\n-      if (minidx && !integer_zerop (minidx))\n-\t{\n-\t  idx = convert (TREE_TYPE (minidx), idx);\n-\t  idx = fold (build (MINUS_EXPR, TREE_TYPE (minidx), idx, minidx));\n-\t}\n+      idx = convert (TREE_TYPE (minidx), idx);\n+      idx = fold (build (MINUS_EXPR, TREE_TYPE (minidx), idx, minidx));\n     }\n-\n+  \n   /* If the index is negative -- a technically invalid situation now\n      that we've biased the index back to zero -- then casting it to\n      unsigned has ill effects.  In particular, -1*4U/4U != -1.\n@@ -1707,7 +1808,7 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n     }\n \n   /* Pointer arithmetic must be done in sizetype.  */\n-  idx = convert (sizetype, idx);\n+  idx = fold_convert (sizetype, idx);\n \n   /* Convert the index to a byte offset.  */\n   offset = size_binop (MULT_EXPR, size, idx);\n@@ -1723,6 +1824,44 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n   return GS_OK;\n }\n \n+/*  Build an expression for the address of T.  Folds away INDIRECT_REF to\n+    avoid confusing the gimplify process.  */\n+\n+static tree\n+build_addr_expr_with_type (tree t, tree ptrtype)\n+{\n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+      if (TREE_TYPE (t) != ptrtype)\n+\tt = build1 (NOP_EXPR, ptrtype, t);\n+    }\n+  else\n+    {\n+      tree base = t;\n+\n+      if (TREE_CODE (base) == REALPART_EXPR\n+\t  || TREE_CODE (base) == IMAGPART_EXPR)\n+\tbase = TREE_OPERAND (base, 0);\n+      else\n+\twhile (handled_component_p (base))\n+\t  base = TREE_OPERAND (base, 0);\n+\n+      if (DECL_P (base))\n+\tTREE_ADDRESSABLE (base) = 1;\n+\n+      t = build1 (ADDR_EXPR, ptrtype, t);\n+    }\n+\n+  return t;\n+}\n+\n+static tree\n+build_addr_expr (tree t)\n+{\n+  return build_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n+}\n+\n /* Gimplify the COMPONENT_REF, ARRAY_REF, REALPART_EXPR or IMAGPART_EXPR\n    node pointed by EXPR_P.\n \n@@ -1747,63 +1886,49 @@ gimplify_array_ref_to_plus (tree *expr_p, tree *pre_p, tree *post_p)\n \n static enum gimplify_status\n gimplify_compound_lval (tree *expr_p, tree *pre_p,\n-\t\t\ttree *post_p, int want_lvalue)\n+\t\t\ttree *post_p, bool want_lvalue)\n {\n   tree *p;\n-  enum tree_code code;\n   varray_type stack;\n-  enum gimplify_status ret;\n+  enum gimplify_status ret = GS_OK, tret;\n \n #if defined ENABLE_CHECKING\n   if (TREE_CODE (*expr_p) != ARRAY_REF\n+      && TREE_CODE (*expr_p) != ARRAY_RANGE_REF\n       && TREE_CODE (*expr_p) != COMPONENT_REF\n+      && TREE_CODE (*expr_p) != BIT_FIELD_REF\n       && TREE_CODE (*expr_p) != REALPART_EXPR\n       && TREE_CODE (*expr_p) != IMAGPART_EXPR)\n     abort ();\n #endif\n \n-  code = ERROR_MARK;\t/* [GIMPLE] Avoid uninitialized use warning.  */\n-\n   /* Create a stack of the subexpressions so later we can walk them in\n      order from inner to outer.  */\n   VARRAY_TREE_INIT (stack, 10, \"stack\");\n \n-  for (p = expr_p;\n-       TREE_CODE (*p) == ARRAY_REF\n-       || TREE_CODE (*p) == COMPONENT_REF\n-       || TREE_CODE (*p) == REALPART_EXPR\n-       || TREE_CODE (*p) == IMAGPART_EXPR;\n-       p = &TREE_OPERAND (*p, 0))\n-    {\n-      code = TREE_CODE (*p);\n-      if (code == ARRAY_REF)\n-\t{\n-\t  tree elttype = TREE_TYPE (TREE_TYPE (TREE_OPERAND (*p, 0)));\n-\t  if (!TREE_CONSTANT (TYPE_SIZE_UNIT (elttype)))\n-\t    /* If the size of the array elements is not constant,\n-\t       computing the offset is non-trivial, so expose it.  */\n-\t    break;\n-\t}\n+  /* We can either handle one REALPART_EXPR or IMAGEPART_EXPR or\n+     nest of handled components.  */\n+  if (TREE_CODE (*expr_p) == REALPART_EXPR\n+      || TREE_CODE (*expr_p) == IMAGPART_EXPR)\n+    p = &TREE_OPERAND (*expr_p, 0);\n+  else\n+    for (p = expr_p; handled_component_p (*p); p = &TREE_OPERAND (*p, 0))\n       VARRAY_PUSH_TREE (stack, *p);\n-    }\n-\n-  /* Now 'p' points to the first bit that isn't a ref, 'code' is the\n-     TREE_CODE of the last bit that was, and 'stack' is a stack of pointers\n-     to all the refs we've walked through.\n \n-     Gimplify the base, and then process each of the outer nodes from left\n-     to right.  */\n-  ret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n-\t\t       code != ARRAY_REF ? fb_either : fb_lvalue);\n+  /* Now STACK is a stack of pointers to all the refs we've walked through\n+     and P points to the innermost expression.\n \n+     Process each of the outer nodes from left to right, then gimplify the\n+     base.  We need to do it in this order so that PLACEHOLDER_EXPRs\n+     can be resolved.  */\n   for (; VARRAY_ACTIVE_SIZE (stack) > 0; )\n     {\n       tree t = VARRAY_TOP_TREE (stack);\n-      if (TREE_CODE (t) == ARRAY_REF)\n+\n+      if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n-\t  /* Gimplify the dimension.  */\n-\t  enum gimplify_status tret;\n-\t  /* Temporary fix for gcc.c-torture/execute/20040313-1.c.\n+\t  /* Gimplify the dimension.\n+\t     Temporary fix for gcc.c-torture/execute/20040313-1.c.\n \t     Gimplify non-constant array indices into a temporary\n \t     variable.\n \t     FIXME - The real fix is to gimplify post-modify\n@@ -1815,14 +1940,82 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t    {\n \t      tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n \t\t\t\t    is_gimple_tmp_var, fb_rvalue);\n-\t      if (tret == GS_ERROR)\n-\t\tret = GS_ERROR;\n+\t      ret = MIN (ret, tret);\n+\t    }\n+\n+\t  /* Gimplify the low bound and element type size and put them into\n+\t     the ARRAY_REF.  If these values are set, they have already been\n+\t     gimplified.  */\n+\t  if (!TREE_OPERAND (t, 2))\n+\t    {\n+\t      TREE_OPERAND (t, 2) = unshare_expr (array_ref_low_bound (t));\n+\t      if (!is_gimple_min_invariant (TREE_OPERAND (t, 2)))\n+\t\t{\n+\t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,\n+\t\t\t\t\tis_gimple_tmp_var, fb_rvalue);\n+\t\t  ret = MIN (ret, tret);\n+\t\t}\n+\t    }\n+\n+\t  if (!TREE_OPERAND (t, 3))\n+\t    {\n+\t      tree elmt_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 0)));\n+\t      tree elmt_size = unshare_expr (array_ref_element_size (t));\n+\t      tree factor = size_int (TYPE_ALIGN (elmt_type) / BITS_PER_UNIT);\n+\n+\t      /* Divide the element size by the alignment of the element\n+\t\t type (above).  */\n+\t      elmt_size = size_binop (EXACT_DIV_EXPR, elmt_size, factor);\n+\n+\t      TREE_OPERAND (t, 3) = elmt_size;\n+\t      if (!is_gimple_min_invariant (TREE_OPERAND (t, 3)))\n+\t\t{\n+\t\t  tret = gimplify_expr (&TREE_OPERAND (t, 3), pre_p, post_p,\n+\t\t\t\t\tis_gimple_tmp_var, fb_rvalue);\n+\t\t  ret = MIN (ret, tret);\n+\t\t}\n \t    }\n \t}\n+      else if (TREE_CODE (t) == COMPONENT_REF)\n+\t{\n+\t  /* Set the field offset into T and gimplify it.  */\n+\t  if (!TREE_OPERAND (t, 2))\n+\t    {\n+\t      tree offset = unshare_expr (component_ref_field_offset (t));\n+\t      tree field = TREE_OPERAND (t, 1);\n+\t      tree factor\n+\t\t= size_int (DECL_OFFSET_ALIGN (field) / BITS_PER_UNIT);\n+\n+\t      /* Divide the offset by its alignment.  */\n+\t      offset = size_binop (EXACT_DIV_EXPR, offset, factor);\n+\n+\t      TREE_OPERAND (t, 2) = offset;\n+\t      if (!is_gimple_min_invariant (TREE_OPERAND (t, 2)))\n+\t\t{\n+\t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,\n+\t\t\t\t\tis_gimple_tmp_var, fb_rvalue);\n+\t\t  ret = MIN (ret, tret);\n+\t\t}\n+\t    }\n+\t}\n+      else if (TREE_CODE (t) == BIT_FIELD_REF)\n+\t{\n+\t  tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n+\t\t\t\tis_gimple_val, fb_rvalue);\n+\t  ret = MIN (ret, tret);\n+\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,\n+\t\t\t\tis_gimple_val, fb_rvalue);\n+\t  ret = MIN (ret, tret);\n+\t}\n+\t  \n       recalculate_side_effects (t);\n       VARRAY_POP (stack);\n     }\n \n+  tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval,\n+\t\t\twant_lvalue ? fb_lvalue : fb_rvalue);\n+  ret = MIN (ret, tret);\n+\n   /* If the outermost expression is a COMPONENT_REF, canonicalize its type.  */\n   if (!want_lvalue && TREE_CODE (*expr_p) == COMPONENT_REF)\n     {\n@@ -1833,33 +2026,6 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   return ret;\n }\n \n-/*  Re-write the ARRAY_REF node pointed by EXPR_P.\n-\n-    PRE_P points to the list where side effects that must happen before\n-\t*EXPR_P should be stored.\n-\n-    POST_P points to the list where side effects that must happen after\n-\t*EXPR_P should be stored.\n-\n-    FIXME: ARRAY_REF currently doesn't accept a pointer as the array\n-    argument, so this gimplification uses an INDIRECT_REF of ARRAY_TYPE.\n-    ARRAY_REF should be extended.  */\n-\n-static enum gimplify_status\n-gimplify_array_ref (tree *expr_p, tree *pre_p,\n-\t\t    tree *post_p, int want_lvalue)\n-{\n-  tree elttype = TREE_TYPE (TREE_TYPE (TREE_OPERAND (*expr_p, 0)));\n-  if (!TREE_CONSTANT (TYPE_SIZE_UNIT (elttype)))\n-    /* If the size of the array elements is not constant,\n-       computing the offset is non-trivial, so expose it.  */\n-    return gimplify_array_ref_to_plus (expr_p, pre_p, post_p);\n-  else\n-    /* Handle array and member refs together for now.  When alias analysis\n-       improves, we may want to go back to handling them separately.  */\n-    return gimplify_compound_lval (expr_p, pre_p, post_p, want_lvalue);\n-}\n-\n /*  Gimplify the self modifying expression pointed by EXPR_P (++, --, +=, -=).\n \n     PRE_P points to the list where side effects that must happen before\n@@ -1873,7 +2039,7 @@ gimplify_array_ref (tree *expr_p, tree *pre_p,\n \n static enum gimplify_status\n gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n-\t\t\tint want_value)\n+\t\t\tbool want_value)\n {\n   enum tree_code code;\n   tree lhs, lvalue, rhs, t1;\n@@ -2166,7 +2332,7 @@ shortcut_cond_expr (tree expr)\n \t  then_ = shortcut_cond_expr (expr);\n \t  pred = TREE_OPERAND (pred, 0);\n \t  expr = build (COND_EXPR, void_type_node, pred, then_,\n-\t\t\tbuild_empty_stmt ());\n+\t\t\talloc_stmt_list ());\n \t}\n     }\n   if (!TREE_SIDE_EFFECTS (then_))\n@@ -2181,7 +2347,7 @@ shortcut_cond_expr (tree expr)\n \t  else_ = shortcut_cond_expr (expr);\n \t  pred = TREE_OPERAND (pred, 0);\n \t  expr = build (COND_EXPR, void_type_node, pred,\n-\t\t\tbuild_empty_stmt (), else_);\n+\t\t\talloc_stmt_list (), else_);\n \t}\n     }\n \n@@ -2207,14 +2373,14 @@ shortcut_cond_expr (tree expr)\n       && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n     {\n       true_label = GOTO_DESTINATION (then_);\n-      then_ = build_empty_stmt ();\n+      then_ = alloc_stmt_list ();\n     }\n \n   if (TREE_CODE (else_) == GOTO_EXPR\n       && TREE_CODE (GOTO_DESTINATION (else_)) == LABEL_DECL)\n     {\n       false_label = GOTO_DESTINATION (else_);\n-      else_ = build_empty_stmt ();\n+      else_ = alloc_stmt_list ();\n     }\n \n   /* If we aren't hijacking a label for the 'then' branch, it falls through.  */\n@@ -2329,6 +2495,8 @@ gimple_boolify (tree expr)\n \n     The second form is used when *EXPR_P is of type void.\n \n+    TARGET is the tree for T1 above.\n+\n     PRE_P points to the list where side effects that must happen before\n \t*EXPR_P should be stored.  */\n \n@@ -2456,7 +2624,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n {\n   tree *from_p = &TREE_OPERAND (*expr_p, 1);\n   tree *to_p = &TREE_OPERAND (*expr_p, 0);\n-  enum gimplify_status ret;\n+  enum gimplify_status ret = GS_UNHANDLED;\n \n #if defined ENABLE_CHECKING\n   if (TREE_CODE (*expr_p) != MODIFY_EXPR && TREE_CODE (*expr_p) != INIT_EXPR)\n@@ -2467,40 +2635,51 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   if (TREE_CODE (*expr_p) == INIT_EXPR)\n     TREE_SET_CODE (*expr_p, MODIFY_EXPR);\n \n-  ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n-  if (ret == GS_ERROR)\n+  /* See if any simplifications can be done based on what the RHS is.  */\n+  ret = gimplify_modify_expr_rhs (expr_p, from_p, to_p, pre_p, post_p,\n+\t\t\t\t  want_value);\n+  if (ret != GS_UNHANDLED)\n     return ret;\n \n-  /* If we are initializing something from a TARGET_EXPR, strip the\n-     TARGET_EXPR and initialize it directly, if possible.  This can't\n-     be done if the initializer is void, since that implies that the\n-     temporary is set in some non-trivial way.  */\n-  /* What about code that pulls out the temp and uses it elsewhere?  I\n-     think that such code never uses the TARGET_EXPR as an initializer.  If\n-     I'm wrong, we'll abort because the temp won't have any RTL.  In that\n-     case, I guess we'll need to replace references somehow.  */\n-  if (TREE_CODE (*from_p) == TARGET_EXPR)\n+  /* If the value being copied is of variable width, expose the length\n+     if the copy by converting the whole thing to a memcpy.  Note that\n+     we need to do this before gimplifying any of the operands\n+     so that we can resolve any PLACEHOLDER_EXPRs in the size.  */\n+  if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*to_p))) != INTEGER_CST)\n     {\n-      tree init = TARGET_EXPR_INITIAL (*from_p);\n-      if (!VOID_TYPE_P (TREE_TYPE (init)))\n-        *from_p = init;\n+      tree args, t, dest;\n+\n+      t = TYPE_SIZE_UNIT (TREE_TYPE (*to_p));\n+      t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, *to_p);\n+      t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, *from_p);\n+      t = unshare_expr (t);\n+      args = tree_cons (NULL, t, NULL);\n+      t = build_fold_addr_expr (*from_p);\n+      args = tree_cons (NULL, t, args);\n+      dest = build_fold_addr_expr (*to_p);\n+      args = tree_cons (NULL, dest, args);\n+      t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      t = build_function_call_expr (t, args);\n+      if (want_value)\n+\t{\n+\t  t = build1 (NOP_EXPR, TREE_TYPE (dest), t);\n+\t  t = build1 (INDIRECT_REF, TREE_TYPE (*to_p), t);\n+\t}\n+      *expr_p = t;\n+      return GS_OK;\n     }\n \n-  /* If we're assigning from a ?: expression with ADDRESSABLE type, push\n-     the assignment down into the branches, since we can't generate a\n-     temporary of such a type.  */\n-  if (TREE_CODE (*from_p) == COND_EXPR\n-      && TREE_ADDRESSABLE (TREE_TYPE (*from_p)))\n-    {\n-      *expr_p = *from_p;\n-      return gimplify_cond_expr (expr_p, pre_p, *to_p);\n-    }\n+  ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n+  if (ret == GS_ERROR)\n+    return ret;\n \n   ret = gimplify_expr (from_p, pre_p, post_p, is_gimple_rhs, fb_rvalue);\n   if (ret == GS_ERROR)\n     return ret;\n \n-  ret = gimplify_init_constructor (expr_p, pre_p, post_p, want_value);\n+  /* Now see if the above changed *from_p to something we handle specially.  */\n+  ret = gimplify_modify_expr_rhs (expr_p, from_p, to_p, pre_p, post_p,\n+\t\t\t\t  want_value);\n   if (ret != GS_UNHANDLED)\n     return ret;\n \n@@ -2530,35 +2709,6 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \t\t   && !is_gimple_reg (*to_p)))\n \tgimplify_expr (from_p, pre_p, post_p, is_gimple_val, fb_rvalue);\n \n-      /* If the value being copied is of variable width, expose the length\n-\t if the copy by converting the whole thing to a memcpy.  */\n-      /* ??? Except that we can't manage this with VA_ARG_EXPR.  Yes, this\n-\t does leave us with an edge condition that doesn't work.  The only\n-\t way out is to rearrange how VA_ARG_EXPR works.  */\n-      if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*to_p))) != INTEGER_CST\n-\t  && TREE_CODE (*from_p) != VA_ARG_EXPR)\n-\t{\n-\t  tree args, t, dest;\n-\n-\t  t = TYPE_SIZE_UNIT (TREE_TYPE (*to_p));\n-\t  t = unshare_expr (t);\n-\t  args = tree_cons (NULL, t, NULL);\n-\t  t = build_fold_addr_expr (*from_p);\n-\t  args = tree_cons (NULL, t, args);\n-\t  dest = build_fold_addr_expr (*to_p);\n-\t  args = tree_cons (NULL, dest, args);\n-\t  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-\t  t = build_function_call_expr (t, args);\n-\t  if (want_value)\n-\t    {\n-\t      t = build1 (NOP_EXPR, TREE_TYPE (dest), t);\n-\t      t = build1 (INDIRECT_REF, TREE_TYPE (*to_p), t);\n-\t    }\n-\t  *expr_p = t;\n-\n-\t  return GS_OK;\n-\t}\n-\n       ret = want_value ? GS_OK : GS_ALL_DONE;\n     }\n \n@@ -2571,6 +2721,101 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   return ret;\n }\n \n+/*  Subroutine of above to do simplications of MODIFY_EXPRs based on\n+    the code of the RHS.  We loop for as long as we can do something.  */\n+\n+static enum gimplify_status\n+gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n+\t\t\t  tree *post_p, bool want_value)\n+{\n+  enum gimplify_status ret = GS_OK;\n+\n+  while (ret != GS_UNHANDLED)\n+    switch (TREE_CODE (*from_p))\n+      {\n+      case TARGET_EXPR:\n+\t{\n+\t  /* If we are initializing something from a TARGET_EXPR, strip the\n+\t     TARGET_EXPR and initialize it directly, if possible.  This can't\n+\t     be done if the initializer is void, since that implies that the\n+\t     temporary is set in some non-trivial way.\n+\n+\t     ??? What about code that pulls out the temp and uses it\n+\t     elsewhere? I think that such code never uses the TARGET_EXPR as\n+\t     an initializer.  If I'm wrong, we'll abort because the temp won't\n+\t     have any RTL.  In that case, I guess we'll need to replace\n+\t     references somehow.  */\n+\t  tree init = TARGET_EXPR_INITIAL (*from_p);\n+\n+\t  if (!VOID_TYPE_P (TREE_TYPE (init)))\n+\t    {\n+\t      *from_p = init;\n+\t      ret = GS_OK;\n+\t    }\n+\t  else\n+\t    ret = GS_UNHANDLED;\n+\t}\n+\tbreak;\n+\n+      case COMPOUND_EXPR:\n+\t/* Remove any COMPOUND_EXPR in the RHS so the following cases will be\n+\t   caught.  */\n+\tgimplify_compound_expr (from_p, pre_p, true);\n+\tret = GS_OK;\n+\tbreak;\n+\n+      case CONSTRUCTOR:\n+\t/* If we're initializing from a CONSTRUCTOR, break this into\n+\t   individual MODIFY_EXPRs.  */\n+\treturn gimplify_init_constructor (expr_p, pre_p, post_p, want_value);\n+\n+      case COND_EXPR:\n+\t/* If we're assigning from a ?: expression with ADDRESSABLE type, push\n+\t   the assignment down into the branches, since we can't generate a\n+\t   temporary of such a type.  */\n+\tif (TREE_ADDRESSABLE (TREE_TYPE (*from_p)))\n+\t  {\n+\t    *expr_p = *from_p;\n+\t    return gimplify_cond_expr (expr_p, pre_p, *to_p);\n+\t  }\n+\telse\n+\t  ret = GS_UNHANDLED;\n+\tbreak;\n+\n+      default:\n+\tret = GS_UNHANDLED;\n+\tbreak;\n+      }\n+\n+  return ret;\n+}\n+\n+/*  Gimplify a comparison between two variable-sized objects.  Do this\n+    with a call to BUILT_IN_MEMCMP.  */\n+\n+static enum gimplify_status\n+gimplify_variable_sized_compare (tree *expr_p)\n+{\n+  tree op0 = TREE_OPERAND (*expr_p, 0);\n+  tree op1 = TREE_OPERAND (*expr_p, 1);\n+  tree args, t, dest;\n+\n+  t = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n+  t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, op0);\n+  t = unshare_expr (t);\n+  args = tree_cons (NULL, t, NULL);\n+  t = build_addr_expr (op1);\n+  args = tree_cons (NULL, t, args);\n+  dest = build_addr_expr (op0);\n+  args = tree_cons (NULL, dest, args);\n+  t = implicit_built_in_decls[BUILT_IN_MEMCMP];\n+  t = build_function_call_expr (t, args);\n+  *expr_p\n+    = build (TREE_CODE (*expr_p), TREE_TYPE (*expr_p), t, integer_zero_node);\n+\n+  return GS_OK;\n+}\n+\n /*  Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P\n     points to the expression to gimplify.\n \n@@ -2696,7 +2941,7 @@ gimplify_save_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       tree body = TREE_OPERAND (*expr_p, 0);\n       ret = gimplify_expr (& body, pre_p, post_p, is_gimple_stmt, fb_none);\n       append_to_statement_list (body, pre_p);\n-      *expr_p = build_empty_stmt ();\n+      *expr_p = alloc_stmt_list ();\n     }\n   else\n     *expr_p = TREE_OPERAND (*expr_p, 0)\n@@ -2742,9 +2987,15 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t\t\t\t\tpre_p, post_p);\n \n       /* This added an INDIRECT_REF.  Fold it away.  */\n-      op0 = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);\n+      *expr_p = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);\n+      break;\n \n-      *expr_p = op0;\n+    case VIEW_CONVERT_EXPR:\n+      /* Take the address of our operand and then convert it to the type of\n+\t this ADDR_EXPR.  */\n+      *expr_p = fold_convert (TREE_TYPE (expr),\n+\t\t\t      build_addr_expr (TREE_OPERAND (op0, 0)));\n+      ret = GS_OK;\n       break;\n \n     default:\n@@ -2993,7 +3244,7 @@ gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n       tree ftrue = build (MODIFY_EXPR, void_type_node, flag,\n \t\t\t  boolean_true_node);\n       cleanup = build (COND_EXPR, void_type_node, flag, cleanup,\n-\t\t       build_empty_stmt ());\n+\t\t       alloc_stmt_list ());\n       wce = build (WITH_CLEANUP_EXPR, void_type_node, NULL_TREE,\n \t\t   cleanup, NULL_TREE);\n       append_to_statement_list (ffalse, &gimplify_ctxp->conditional_cleanups);\n@@ -3208,10 +3459,9 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase ARRAY_REF:\n-\t  ret = gimplify_array_ref (expr_p, pre_p, post_p,\n-\t\t\t\t    fallback & fb_lvalue);\n-\t  break;\n-\n+\tcase ARRAY_RANGE_REF:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n \tcase COMPONENT_REF:\n \t  ret = gimplify_compound_lval (expr_p, pre_p, post_p,\n \t\t\t\t\tfallback & fb_lvalue);\n@@ -3232,12 +3482,6 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_compound_expr (expr_p, pre_p, fallback != fb_none);\n \t  break;\n \n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\t  ret = gimplify_compound_lval (expr_p, pre_p, post_p,\n-\t\t\t\t\tfallback & fb_lvalue);\n-\t  break;\n-\n \tcase MODIFY_EXPR:\n \tcase INIT_EXPR:\n \t  ret = gimplify_modify_expr (expr_p, pre_p, post_p,\n@@ -3265,6 +3509,34 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_va_arg_expr (expr_p, pre_p, post_p);\n \t  break;\n \n+\tcase VIEW_CONVERT_EXPR:\n+\t  if (VOID_TYPE_P (TREE_TYPE (*expr_p))\n+\t      || fallback == fb_none)\n+\t    {\n+\t      /* Just strip a conversion to void (or in void context) and\n+\t\t try again.  */\n+\t      *expr_p = TREE_OPERAND (*expr_p, 0);\n+\t      break;\n+\t    }\n+\n+\t  /* If both types are BLKmode or if one type is of variable size,\n+\t     convert this into a pointer punning operation.  This avoids\n+\t     copies of large data or making a variable-size temporary.  */\n+\t  if ((TYPE_MODE (TREE_TYPE (*expr_p)) == BLKmode\n+\t       && TYPE_MODE (TREE_TYPE (TREE_OPERAND (*expr_p, 0))) == BLKmode)\n+\t      || !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (*expr_p)))\n+\t      || !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE\n+\t\t\t\t\t    (TREE_OPERAND (*expr_p,0)))))\n+\t    {\n+\t      tree restype = TREE_TYPE (*expr_p);\n+\t      *expr_p = build1 (INDIRECT_REF, TREE_TYPE (*expr_p),\n+\t\t\t\tfold_convert (build_pointer_type (restype),\n+\t\t\t\t\t      build_addr_expr\n+\t\t\t\t\t      (TREE_OPERAND (*expr_p, 0))));\n+\t      break;\n+\t    }\n+\t  goto unary;\n+\n \tcase CONVERT_EXPR:\n \tcase NOP_EXPR:\n \t  if (IS_EMPTY_STMT (*expr_p))\n@@ -3293,6 +3565,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase FIX_CEIL_EXPR:\n \tcase FIX_FLOOR_EXPR:\n \tcase FIX_ROUND_EXPR:\n+\tunary:\n \t  /* unary_expr: ... | '(' cast ')' val | ...  */\n \t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t\t       is_gimple_val, fb_rvalue);\n@@ -3484,9 +3757,18 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tdefault:\n+\t  /* If this is a comparison of objects of aggregate type, handle\n+\t     it specially (by converting to a call to memcmp).  It would be\n+\t     nice to only have to do this for variable-sized objects, but\n+\t     then we'd have to allow the same nest of reference nodes we\n+\t     allow for MODIFY_EXPR and that's too complex.  */\n+\t  if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '<'\n+\t      && (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 1)))))\n+\t    ret = gimplify_variable_sized_compare (expr_p);\n+\n \t  /* If *EXPR_P does not need to be special-cased, handle it\n \t     according to its class.  */\n-\t  if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '1')\n+\t  else if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '1')\n \t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n \t\t\t\t post_p, is_gimple_val, fb_rvalue);\n \t  else if (TREE_CODE_CLASS (TREE_CODE (*expr_p)) == '2'\n@@ -3529,7 +3811,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n   if (ret == GS_ERROR)\n     {\n       if (is_statement)\n-\t*expr_p = build_empty_stmt ();\n+\t*expr_p = alloc_stmt_list ();\n       goto out;\n     }\n \n@@ -3541,17 +3823,37 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n #endif\n \n   if (!*expr_p)\n-    *expr_p = build_empty_stmt ();\n+    *expr_p = alloc_stmt_list ();\n   if (fallback == fb_none && !is_gimple_stmt (*expr_p))\n     {\n       /* We aren't looking for a value, and we don't have a valid\n \t statement.  If it doesn't have side-effects, throw it away.  */\n       if (!TREE_SIDE_EFFECTS (*expr_p))\n-\t*expr_p = build_empty_stmt ();\n+\t*expr_p = alloc_stmt_list ();\n       else if (!TREE_THIS_VOLATILE (*expr_p))\n-\t/* We only handle volatiles here; anything else with side-effects\n-\t   must be converted to a valid statement before we get here.  */\n-\tabort ();\n+\t{\n+\t  /* This is probably a _REF that contains something nested that\n+\t     has side effects.  Recurse through the operands to find it.  */\n+\t  enum tree_code code = TREE_CODE (*expr_p);\n+\n+\t  if (code == COMPONENT_REF\n+\t      || code == REALPART_EXPR || code == IMAGPART_EXPR)\n+\t    gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t   gimple_test_f, fallback);\n+\t  else if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+\t    {\n+\t      gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t     gimple_test_f, fallback);\n+\t      gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n+\t\t\t   gimple_test_f, fallback);\n+\t    }\n+\t  else\n+\t    /* Anything else with side-effects\n+\t       must be converted to a valid statement before we get here.  */\n+\t    abort ();\n+\n+\t  *expr_p = alloc_stmt_list ();\n+\t}\n       else if (COMPLETE_TYPE_P (TREE_TYPE (*expr_p)))\n \t{\n \t  /* Historically, the compiler has treated a bare\n@@ -3562,7 +3864,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       else\n \t/* We can't do anything useful with a volatile reference to\n \t   incomplete type, so just throw it away.  */\n-\t*expr_p = build_empty_stmt ();\n+\t*expr_p = alloc_stmt_list ();\n     }\n \n   /* If we are gimplifying at the statement level, we're done.  Tack\n@@ -3660,6 +3962,78 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n   return ret;\n }\n \n+/* Look through TYPE for variable-sized objects and gimplify each such\n+   size that we find.  Return a STATEMENT_LIST containing the result.  */\n+\n+tree\n+gimplify_type_sizes (tree type)\n+{\n+  tree stmts = NULL_TREE;\n+  tree field;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case ERROR_MARK:\n+      return alloc_stmt_list ();\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+      gimplify_one_sizepos (&TYPE_MIN_VALUE (type), &stmts);\n+      gimplify_one_sizepos (&TYPE_MAX_VALUE (type), &stmts);\n+      break;\n+\n+    case ARRAY_TYPE:\n+      /* These anonymous types don't have declarations, so handle them here. */\n+      append_to_statement_list (gimplify_type_sizes (TYPE_DOMAIN (type)),\n+\t\t\t\t&stmts);\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  gimplify_one_sizepos (&DECL_FIELD_OFFSET (field), &stmts);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  gimplify_one_sizepos (&TYPE_SIZE (type), &stmts);\n+  gimplify_one_sizepos (&TYPE_SIZE_UNIT (type), &stmts);\n+\n+  if (!stmts)\n+    stmts = alloc_stmt_list ();\n+\n+  return stmts;\n+}\n+\n+/* Subroutine of the above to gimplify one size or position, *EXPR_P.\n+   We add any required statements to STMT_P.  */\n+\n+void\n+gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n+{\n+  tree pre = NULL_TREE, post = NULL_TREE;\n+\n+  /* We don't do anything if the value isn't there, is constant, or contains\n+     A PLACEHOLDER_EXPR.  */\n+  if (*expr_p == NULL_TREE || TREE_CONSTANT (*expr_p)\n+      || CONTAINS_PLACEHOLDER_P (*expr_p))\n+    return;\n+\n+  gimplify_expr (expr_p, &pre, &post, is_gimple_val, fb_rvalue);\n+\n+  if (pre)\n+    append_to_statement_list (pre, stmt_p);\n+  if (post)\n+    append_to_statement_list (post, stmt_p);\n+}\n+\f\n #ifdef ENABLE_CHECKING\n /* Compare types A and B for a \"close enough\" match.  */\n \n@@ -3720,8 +4094,10 @@ check_pointer_types_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       dtype = TREE_TYPE (ptype);\n       if (!cpt_same_type (otype, dtype))\n \t{\n-\t  /* &array is allowed to produce a pointer to the element,\n-\t     rather than a pointer to the array type.  */\n+\t  /* &array is allowed to produce a pointer to the element, rather than\n+\t     a pointer to the array type.  We must allow this in order to\n+\t     properly represent assigning the address of an array in C into\n+\t     pointer to the element type.  */\n \t  if (TREE_CODE (otype) == ARRAY_TYPE\n \t      && POINTER_TYPE_P (ptype)\n \t      && cpt_same_type (TREE_TYPE (otype), dtype))\n@@ -3751,8 +4127,12 @@ gimplify_body (tree *body_p, tree fndecl)\n   timevar_push (TV_TREE_GIMPLIFY);\n   push_gimplify_context ();\n \n-  /* Unshare most shared trees in the body.  */\n-  unshare_all_trees (*body_p);\n+  /* Unshare most shared trees in the body and in that of any nested functions.\n+     It would seem we don't have to do this for nested functions because\n+     they are supposed to be output and then the outer function gimplified\n+     first, but the g++ front end doesn't always do it that way.  */\n+  unshare_body (body_p, fndecl);\n+  unvisit_body (body_p, fndecl);\n \n   /* Make sure input_location isn't set to something wierd.  */\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n@@ -3764,13 +4144,14 @@ gimplify_body (tree *body_p, tree fndecl)\n   /* Unshare again, in case gimplification was sloppy.  */\n   unshare_all_trees (body);\n \n-  /* If there isn't an outer BIND_EXPR, add one.  */\n   if (TREE_CODE (body) == STATEMENT_LIST)\n     {\n       tree t = expr_only (*body_p);\n       if (t)\n \tbody = t;\n     }\n+\n+  /* If there isn't an outer BIND_EXPR, add one.  */\n   if (TREE_CODE (body) != BIND_EXPR)\n     {\n       tree b = build (BIND_EXPR, void_type_node, NULL_TREE,"}, {"sha": "fd899174028c6c55f2843d8c4e0d76bb60fa34cd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,3 +1,16 @@\n+2004-06-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* class.c (build_class_ref): Add new operand for COMPONENT_REF.\n+\t(build_static_field_ref): Likewise and add new operands for ARRAY_REF.\n+\t* constants.c (build_ref_from_constant_pool): Likewise.\n+\t* expr.c (build_java_array_length_access): Likewise.\n+\t(build_get_class, build_field_ref, build_known_method_ref): Likewise.\n+\t(invoke_build_dtable, build_invokevirtual): Likewise.\n+\t(build_invokeinterface, java_expand_expr): Likewise.\n+\t(emit_init_test_initialization): Likewise.\n+\t* java-gimplify.c (java_gimplify_new_array_init): Likewise.\n+\t* parse.y (make_qualifed_name, build_array_ref): Likewise.\n+\t\n 2004-06-21  Andrew Haley  <aph@redhat.com>\n \n \t* java-gimplify.c (java_gimplify_block): set TREE_USED on the new"}, {"sha": "ca9d62721c7e62ebce99c91fcf84e2db88ddec97", "filename": "gcc/java/class.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1023,7 +1023,7 @@ build_class_ref (tree type)\n \n \t      prim_class = lookup_class (get_identifier (prim_class_name));\n \t      return build (COMPONENT_REF, NULL_TREE,\n-\t\t\t    prim_class, TYPE_identifier_node);\n+\t\t\t    prim_class, TYPE_identifier_node, NULL_TREE);\n \t    }\n \t  decl_name = TYPE_NAME (type);\n \t  if (TREE_CODE (decl_name) == TYPE_DECL)\n@@ -1088,7 +1088,8 @@ build_static_field_ref (tree fdecl)\n \t\t       (fdecl, &TYPE_ATABLE_METHODS (output_class)), 0);\n       tree field_address\n \t= build (ARRAY_REF, build_pointer_type (TREE_TYPE (fdecl)), \n-\t\t TYPE_ATABLE_DECL (output_class), table_index);\n+\t\t TYPE_ATABLE_DECL (output_class), table_index,\n+\t\t NULL_TREE, NULL_TREE);\n       return fold (build1 (INDIRECT_REF, TREE_TYPE (fdecl), \n \t\t\t   field_address));\n     }\n@@ -1101,7 +1102,8 @@ build_static_field_ref (tree fdecl)\n       int field_index = 0;\n       ref = build1 (INDIRECT_REF, class_type_node, ref);\n       ref = build (COMPONENT_REF, field_ptr_type_node, ref,\n-\t\t   lookup_field (&class_type_node, fields_ident));\n+\t\t   lookup_field (&class_type_node, fields_ident),\n+\t\t   NULL_TREE);\n \n       for (fld = TYPE_FIELDS (fclass); ; fld = TREE_CHAIN (fld))\n \t{\n@@ -1118,9 +1120,11 @@ build_static_field_ref (tree fdecl)\n \t\t\t ref, build_int_2 (field_index, 0)));\n       ref = build1 (INDIRECT_REF, field_type_node, ref);\n       ref = build (COMPONENT_REF, field_info_union_node,\n-\t\t   ref, lookup_field (&field_type_node, info_ident));\n+\t\t   ref, lookup_field (&field_type_node, info_ident),\n+\t\t   NULL_TREE);\n       ref = build (COMPONENT_REF, ptr_type_node,\n-\t\t   ref, TREE_CHAIN (TYPE_FIELDS (field_info_union_node)));\n+\t\t   ref, TREE_CHAIN (TYPE_FIELDS (field_info_union_node)),\n+\t\t   NULL_TREE);\n       return fold (build1 (INDIRECT_REF, TREE_TYPE(fdecl), ref));\n     }\n }"}, {"sha": "98127f590db86c8850b75164037b157ee2a3cc2b", "filename": "gcc/java/constants.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -424,7 +424,8 @@ build_ref_from_constant_pool (int index)\n {\n   tree d = build_constant_data_ref ();\n   tree i = build_int_2 (index, 0);\n-  return build (ARRAY_REF, TREE_TYPE (TREE_TYPE (d)), d, i);\n+  return build (ARRAY_REF, TREE_TYPE (TREE_TYPE (d)), d, i,\n+\t\tNULL_TREE, NULL_TREE);\n }\n \n /* Build an initializer for the constants field of the current constant pool."}, {"sha": "446f8afe2db45907a6f0e4f62a070bfd6809987a", "filename": "gcc/java/expr.c", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -698,7 +698,8 @@ build_java_array_length_access (tree node)\n   node = build (COMPONENT_REF, int_type_node,\n \t\tbuild_java_indirect_ref (array_type, node,\n \t\t\t\t\t flag_check_references),\n-\t\tlookup_field (&array_type, get_identifier (\"length\")));\n+\t\tlookup_field (&array_type, get_identifier (\"length\")),\n+\t\tNULL_TREE);\n   IS_ARRAY_LENGTH_ACCESS (node) = 1;\n   return node;\n }\n@@ -780,9 +781,9 @@ build_java_arrayaccess (tree array, tree type, tree index)\n   ref = build (COMPONENT_REF, TREE_TYPE (data_field),    \n \t       build_java_indirect_ref (array_type, array, \n \t\t\t\t\tflag_check_references),\n-\t       data_field);\n+\t       data_field, NULL_TREE);\n   \n-  node = build (ARRAY_REF, type, ref, index);\n+  node = build (ARRAY_REF, type, ref, index, NULL_TREE, NULL_TREE);\n   return node;\n }\n \n@@ -1181,8 +1182,8 @@ build_get_class (tree value)\n \t\t\tbuild (COMPONENT_REF, dtable_ptr_type,\n \t\t\t       build_java_indirect_ref (object_type_node, value,\n \t\t\t\t\t\t\tflag_check_references),\n-\t\t\t       vtable_field)),\n-\t\tclass_field);\n+\t\t\t       vtable_field, NULL_TREE)),\n+\t\tclass_field, NULL_TREE);\n }\n \n /* This builds the tree representation of the `instanceof' operator.\n@@ -1531,13 +1532,16 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \t   in the same translation unit as output_class.  If it is,\n \t   we can make a direct reference.  */\n \t{\n-\t  tree otable_index =\n-\t    build_int_2 (get_symbol_table_index \n-\t\t\t (field_decl, &TYPE_OTABLE_METHODS (output_class)), 0);\n-\t  tree field_offset = \n-\t    build (ARRAY_REF, integer_type_node, TYPE_OTABLE_DECL (output_class), \n-\t\t   otable_index);\n+\t  tree otable_index\n+\t    = build_int_2 (get_symbol_table_index \n+\t\t\t   (field_decl, &TYPE_OTABLE_METHODS (output_class)),\n+\t\t\t   0);\n+\t  tree field_offset\n+\t    = build (ARRAY_REF, integer_type_node,\n+\t\t     TYPE_OTABLE_DECL (output_class), otable_index,\n+\t\t     NULL_TREE, NULL_TREE);\n \t  tree address;\n+\n \t  field_offset = fold (convert (sizetype, field_offset));\n \t  address \n \t    = fold (build (PLUS_EXPR, \n@@ -1549,7 +1553,7 @@ build_field_ref (tree self_value, tree self_class, tree name)\n       self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n \t\t\t\t\t    self_value, check);\n       return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n-\t\t\t  self_value, field_decl));\n+\t\t\t  self_value, field_decl, NULL_TREE));\n     }\n }\n \n@@ -1826,12 +1830,12 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t}\n       else\n \t{\n-\t  tree table_index = \n-\t    build_int_2 (get_symbol_table_index \n-\t\t\t (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n-\t  func = \n-\t    build (ARRAY_REF,  method_ptr_type_node, \n-\t\t   TYPE_ATABLE_DECL (output_class), table_index);\n+\t  tree table_index\n+\t    = build_int_2 (get_symbol_table_index \n+\t\t\t   (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n+\t  func = build (ARRAY_REF,  method_ptr_type_node, \n+\t\t\tTYPE_ATABLE_DECL (output_class), table_index,\n+\t\t\tNULL_TREE, NULL_TREE);\n \t}\n       func = convert (method_ptr_type_node, func);\n     }\n@@ -1858,7 +1862,7 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n       if (methods_ident == NULL_TREE)\n \tmethods_ident = get_identifier (\"methods\");\n       ref = build (COMPONENT_REF, method_ptr_type_node, ref,\n-\t\t   lookup_field (&class_type_node, methods_ident));\n+\t\t   lookup_field (&class_type_node, methods_ident), NULL_TREE);\n       for (meth = TYPE_METHODS (self_type);\n \t   ; meth = TREE_CHAIN (meth))\n \t{\n@@ -1874,8 +1878,8 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t\t\t ref, build_int_2 (method_index, 0)));\n       ref = build1 (INDIRECT_REF, method_type_node, ref);\n       func = build (COMPONENT_REF, nativecode_ptr_type_node,\n-\t\t    ref,\n-\t\t    lookup_field (&method_type_node, ncode_ident));\n+\t\t    ref, lookup_field (&method_type_node, ncode_ident),\n+\t\t    NULL_TREE);\n     }\n   return func;\n }\n@@ -1899,7 +1903,7 @@ invoke_build_dtable (int is_invoke_interface, tree arg_list)\n   dtable = build_java_indirect_ref (object_type_node, objectref, \n \t\t\t\t    flag_check_references);\n   dtable = build (COMPONENT_REF, dtable_ptr_type, dtable,\n-\t\t  lookup_field (&object_type_node, dtable_ident));\n+\t\t  lookup_field (&object_type_node, dtable_ident), NULL_TREE);\n \n   return dtable;\n }\n@@ -1955,7 +1959,7 @@ build_invokevirtual (tree dtable, tree method)\n \t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n       method_index = build (ARRAY_REF, integer_type_node, \n \t\t\t    TYPE_OTABLE_DECL (output_class), \n-\t\t\t    otable_index);\n+\t\t\t    otable_index, NULL_TREE, NULL_TREE);\n     }\n   else\n     {\n@@ -2001,7 +2005,7 @@ build_invokeinterface (tree dtable, tree method)\n   dtable = build_java_indirect_ref (dtable_type, dtable,\n \t\t\t\t    flag_check_references);\n   dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n-\t\t  lookup_field (&dtable_type, class_ident));\n+\t\t  lookup_field (&dtable_type, class_ident), NULL_TREE);\n \n   interface = DECL_CONTEXT (method);\n   if (! CLASS_INTERFACE (TYPE_NAME (interface)))\n@@ -2010,17 +2014,15 @@ build_invokeinterface (tree dtable, tree method)\n   \n   if (flag_indirect_dispatch)\n     {\n-      otable_index =\n-\tbuild_int_2 (get_symbol_table_index \n-\t\t     (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n-      idx = \n-\tbuild (ARRAY_REF, integer_type_node, TYPE_OTABLE_DECL (output_class),\n-\t       otable_index);\n+      otable_index\n+\t= build_int_2 (get_symbol_table_index \n+\t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n+      idx = build (ARRAY_REF, integer_type_node,\n+\t\t   TYPE_OTABLE_DECL (output_class), otable_index,\n+\t\t   NULL_TREE, NULL_TREE);\n     }\n   else\n-    {\n-      idx = build_int_2 (get_interface_method_index (method, interface), 0);\n-    }\n+    idx = build_int_2 (get_interface_method_index (method, interface), 0);\n \n   lookup_arg = tree_cons (NULL_TREE, dtable,\n                           tree_cons (NULL_TREE, build_class_ref (interface),\n@@ -2577,7 +2579,8 @@ java_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n \texpand_assignment (build (COMPONENT_REF, TREE_TYPE (data_fld),\n \t\t\t\t  build_java_indirect_ref (array_type, \n \t\t\t\t\t  array_decl, flag_check_references), \n-\t\t\t\t  data_fld), init, 0);\n+\t\t\t\t  data_fld, NULL_TREE),\n+\t\t\t   init, 0);\n \treturn tmp;\n       }\n     case BLOCK:\n@@ -3460,7 +3463,8 @@ emit_init_test_initialization (void **entry, void *x ATTRIBUTE_UNUSED)\n \t\t build (COMPONENT_REF, byte_type_node,\n \t\t\tbuild1 (INDIRECT_REF, class_type_node, klass),\n \t\t\tlookup_field (&class_type_node,\n-\t\t\t\t      get_identifier (\"state\"))),\n+\t\t\t\t      get_identifier (\"state\")),\n+\t\t\tNULL_TREE),\n \t\t build_int_2 (JV_STATE_DONE, 0));\n \n   expand_expr_stmt (build (MODIFY_EXPR, boolean_type_node, "}, {"sha": "766995e8254d10378dbed291e57ce907a6993362", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1,5 +1,4 @@\n /* Java(TM) language-specific gimplification routines.\n-\n    Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -223,10 +222,11 @@ java_gimplify_new_array_init (tree exp)\n \t bounds checking.  */\n       tree lhs = build (COMPONENT_REF, TREE_TYPE (data_field),    \n \t\t\tbuild_java_indirect_ref (array_type, tmp, 0),\n-\t\t\tdata_field);\n+\t\t\tdata_field, NULL_TREE);\n       tree assignment = build (MODIFY_EXPR, element_type,\n   \t\t\t       build (ARRAY_REF, element_type, lhs,\n-\t\t\t\t      build_int_2 (index++, 0)),\n+\t\t\t\t      build_int_2 (index++, 0),\n+\t\t\t\t      NULL_TREE, NULL_TREE),\n \t\t\t       TREE_VALUE (values));\n       body = build (COMPOUND_EXPR, element_type, body, assignment);\n       values = TREE_CHAIN (values);"}, {"sha": "ed1f05040ec9f81cdec2f3561649b3c70ad483a9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -9254,7 +9254,7 @@ static tree\n make_qualified_name (tree left, tree right, int location)\n {\n #ifdef USE_COMPONENT_REF\n-  tree node = build (COMPONENT_REF, NULL_TREE, left, right);\n+  tree node = build (COMPONENT_REF, NULL_TREE, left, right, NULL_TREE);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n #else\n@@ -14353,7 +14353,7 @@ build_null_of_type (tree type)\n static tree\n build_array_ref (int location, tree array, tree index)\n {\n-  tree node = build (ARRAY_REF, NULL_TREE, array, index);\n+  tree node = build (ARRAY_REF, NULL_TREE, array, index, NULL_TREE, NULL_TREE);\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }"}, {"sha": "bf739565cad9ec47378d68db4d79b31ddd823298", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1975,7 +1975,7 @@ generate_static_references (void)\n       sprintf (buf, \"_OBJC_STATIC_INSTANCES_%d\", num_class);\n       ident = get_identifier (buf);\n \n-      expr_decl = build_nt (ARRAY_REF, ident, NULL_TREE);\n+      expr_decl = build_nt (ARRAY_REF, ident, NULL_TREE, NULL_TREE, NULL_TREE);\n       decl_spec = tree_cons (NULL_TREE, build_pointer_type (void_type_node),\n \t\t\t     build_tree_list (NULL_TREE,\n \t\t\t\t\t      ridpointers[(int) RID_STATIC]));\n@@ -2014,7 +2014,7 @@ generate_static_references (void)\n \n   decls = tree_cons (NULL_TREE, build_int_2 (0, 0), decls);\n   ident = get_identifier (\"_OBJC_STATIC_INSTANCES\");\n-  expr_decl = build_nt (ARRAY_REF, ident, NULL_TREE);\n+  expr_decl = build_nt (ARRAY_REF, ident, NULL_TREE, NULL_TREE, NULL_TREE);\n   decl_spec = tree_cons (NULL_TREE, build_pointer_type (void_type_node),\n \t\t\t build_tree_list (NULL_TREE,\n \t\t\t\t\t  ridpointers[(int) RID_STATIC]));\n@@ -2044,7 +2044,8 @@ generate_strings (void)\n       sc_spec\n \t= tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n       decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_CHAR], sc_spec);\n-      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE);\n+      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE,\n+\t\t\t    NULL_TREE, NULL_TREE);\n       decl = start_decl (expr_decl, decl_specs, 1, NULL_TREE);\n       DECL_CONTEXT (decl) = NULL_TREE;\n       string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n@@ -2059,7 +2060,8 @@ generate_strings (void)\n       sc_spec\n \t= tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n       decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_CHAR], sc_spec);\n-      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE);\n+      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE,\n+\t\t\t    NULL_TREE, NULL_TREE);\n       decl = start_decl (expr_decl, decl_specs, 1, NULL_TREE);\n       DECL_CONTEXT (decl) = NULL_TREE;\n       string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n@@ -2074,7 +2076,8 @@ generate_strings (void)\n       sc_spec\n \t= tree_cons (NULL_TREE, ridpointers[(int) RID_STATIC], NULL_TREE);\n       decl_specs = tree_cons (NULL_TREE, ridpointers[(int) RID_CHAR], sc_spec);\n-      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE);\n+      expr_decl = build_nt (ARRAY_REF, DECL_NAME (decl), NULL_TREE,\n+\t\t\t    NULL_TREE, NULL_TREE);\n       decl = start_decl (expr_decl, decl_specs, 1, NULL_TREE);\n       DECL_CONTEXT (decl) = NULL_TREE;\n       string_expr = my_build_string (IDENTIFIER_LENGTH (string) + 1,\n@@ -3521,7 +3524,7 @@ build_method_prototype_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n-\t\t\t build_int_2 (size, 0));\n+\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -4405,7 +4408,7 @@ build_ivar_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"ivar_list\"),\n-\t\t\t build_int_2 (size, 0));\n+\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n \n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n@@ -4453,7 +4456,7 @@ build_method_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n-\t\t\t build_int_2 (size, 0));\n+\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n \n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n@@ -4860,18 +4863,18 @@ generate_protocol_list (tree i_or_p)\n     expr_decl = build_nt (ARRAY_REF,\n \t\t\t  synth_id_with_class_suffix (\"_OBJC_PROTOCOL_REFS\",\n \t\t\t\t\t\t      i_or_p),\n-\t\t\t  build_int_2 (size + 2, 0));\n+\t\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n   else if (TREE_CODE (i_or_p) == CLASS_INTERFACE_TYPE)\n     expr_decl = build_nt (ARRAY_REF,\n \t\t\t  synth_id_with_class_suffix (\"_OBJC_CLASS_PROTOCOLS\",\n \t\t\t\t\t\t      i_or_p),\n-\t\t\t  build_int_2 (size + 2, 0));\n+\t\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n   else if (TREE_CODE (i_or_p) == CATEGORY_INTERFACE_TYPE)\n     expr_decl\n       = build_nt (ARRAY_REF,\n \t\t  synth_id_with_class_suffix (\"_OBJC_CATEGORY_PROTOCOLS\",\n \t\t\t\t\t      i_or_p),\n-\t\t  build_int_2 (size + 2, 0));\n+\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n   else\n     abort ();\n "}, {"sha": "5ee55b9e6999c944e0ec00cb8957e84f796f0f3e", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -3391,12 +3391,6 @@ expand_stack_alloc (tree alloc, tree t_size)\n \n   type = TREE_TYPE (var);\n \n-  /* In function-at-a-time mode, variable_size doesn't expand this,\n-     so do it now.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n-    expand_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n-\t\t const0_rtx, VOIDmode, 0);\n-\n   /* Compute the variable's size, in bytes.  */\n   size = expand_expr (t_size, NULL_RTX, VOIDmode, 0);\n   free_temp_slots ();"}, {"sha": "b2ef41dbda2f473b278f9df5e814bf9939b85dba", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -93,11 +93,6 @@ tree\n get_pending_sizes (void)\n {\n   tree chain = pending_sizes;\n-  tree t;\n-\n-  /* Put each SAVE_EXPR into the current function.  */\n-  for (t = chain; t; t = TREE_CHAIN (t))\n-    SAVE_EXPR_CONTEXT (TREE_VALUE (t)) = current_function_decl;\n \n   pending_sizes = 0;\n   return chain;"}, {"sha": "561feb5210a57bf2a989b3e57e066c23edd59880", "filename": "gcc/tree-alias-common.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-alias-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-alias-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-alias-common.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -207,12 +207,15 @@ get_alias_var (tree expr)\n   switch (TREE_CODE (expr))\n     {\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       {\n-\t/* Find the first non-array ref, and return it's alias\n-\t   variable */\n+\t/* Find the first non-array ref, and return its alias variable.  */\n \ttree p;\n-\tfor (p = expr; TREE_CODE (p) == ARRAY_REF;\n-\t     p = TREE_OPERAND (p, 0));\n+\n+\tfor (p = expr;\n+\t     TREE_CODE (p) == ARRAY_REF || TREE_CODE (p) == ARRAY_RANGE_REF;\n+\t     p = TREE_OPERAND (p, 0))\n+\t  ;\n \treturn get_alias_var (p);\n       }\n       break;"}, {"sha": "9b42073376631ce4c649706284dcc9490d61dd69", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -3156,12 +3156,10 @@ verify_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       break;\n \n     case ADDR_EXPR:\n-      x = TREE_OPERAND (t, 0);\n-      while (TREE_CODE (x) == ARRAY_REF\n-\t     || TREE_CODE (x) == COMPONENT_REF\n-\t     || TREE_CODE (x) == REALPART_EXPR\n-\t     || TREE_CODE (x) == IMAGPART_EXPR)\n-\tx = TREE_OPERAND (x, 0);\n+      for (x = TREE_OPERAND (t, 0); handled_component_p (x);\n+\t   x = TREE_OPERAND (x, 0))\n+\t;\n+\n       if (TREE_CODE (x) != VAR_DECL && TREE_CODE (x) != PARM_DECL)\n \treturn NULL;\n       if (!TREE_ADDRESSABLE (x))\n@@ -3309,7 +3307,7 @@ tree_node_can_be_shared (tree t)\n       || TREE_CODE (t) == SSA_NAME)\n     return true;\n \n-  while ((TREE_CODE (t) == ARRAY_REF\n+  while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t  /* We check for constants explicitly since they are not considered\n \t     gimple invariants if they overflowed.  */\n \t  && (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 1))) == 'c'"}, {"sha": "307086bedb776197fae5c04978cb95dfbc5293f2", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -926,24 +926,17 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n tree\n get_virtual_var (tree var)\n {\n-  enum tree_code code;\n-\n   STRIP_NOPS (var);\n \n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n \n-  code = TREE_CODE (var);\n-\n-  while (code == ARRAY_REF\n-         || code == COMPONENT_REF\n-\t || code == REALPART_EXPR\n-\t || code == IMAGPART_EXPR)\n-    {\n+  if (TREE_CODE (var) == REALPART_EXPR || TREE_CODE (var) == IMAGPART_EXPR)\n+    var = TREE_OPERAND (var, 0);\n+  else\n+    while (handled_component_p (var))\n       var = TREE_OPERAND (var, 0);\n-      code = TREE_CODE (var);\n-    }\n-\n+    \n #ifdef ENABLE_CHECKING\n   /* Treating GIMPLE registers as virtual variables makes no sense.\n      Also complain if we couldn't extract a _DECL out of the original"}, {"sha": "39aeeaddf4163a26a8ffcb8e0e022a9f9f32b415", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -536,9 +536,7 @@ dequeue_and_dump (dump_info_p di)\n     case TRUTH_ORIF_EXPR:\n     case INIT_EXPR:\n     case MODIFY_EXPR:\n-    case COMPONENT_REF:\n     case COMPOUND_EXPR:\n-    case ARRAY_REF:\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n@@ -548,6 +546,20 @@ dequeue_and_dump (dump_info_p di)\n       dump_child (\"op 1\", TREE_OPERAND (t, 1));\n       break;\n \n+    case COMPONENT_REF:\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n+      break;\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      dump_child (\"op 0\", TREE_OPERAND (t, 0));\n+      dump_child (\"op 1\", TREE_OPERAND (t, 1));\n+      dump_child (\"op 2\", TREE_OPERAND (t, 2));\n+      dump_child (\"op 3\", TREE_OPERAND (t, 3));\n+      break;\n+\n     case COND_EXPR:\n       dump_child (\"op 0\", TREE_OPERAND (t, 0));\n       dump_child (\"op 1\", TREE_OPERAND (t, 1));"}, {"sha": "21c3a1c3815b23079973d2ffd0233b441804db58", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1682,6 +1682,7 @@ tree_could_trap_p (tree expr)\n   switch (code)\n     {\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:"}, {"sha": "7c992b36adcdca8d3cd51eb1f8b05c08f4ee339f", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -119,17 +119,34 @@ Boston, MA 02111-1307, USA.  */\n    min-lval: ID | '*' ID\n    bitfieldref :\n      BIT_FIELD_REF\n-       op0 -> compref | min-lval\n+       op0 -> inner_compref\n        op1 -> CONST\n-       op2 -> CONST\n+       op2 -> var\n    compref :\n      COMPONENT_REF\n-       op0 -> compref | min-lval\n+       op0 -> inner_compref\n      | ARRAY_REF\n-       op0 -> compref | min-lval\n+       op0 -> inner_compref\n        op1 -> val\n+       op2 -> val\n+       op3 -> val\n+     | ARRAY_RANGE_REF\n+       op0 -> inner_compref\n+       op1 -> val\n+       op2 -> val\n+       op3 -> val\n      | REALPART_EXPR\n+       op0 -> inner_compref\n      | IMAGPART_EXPR\n+       op0 -> inner_compref\n+\n+   inner_compref : compref | min_lval\n+     | VIEW_CONVERT_EXPR\n+       op0 -> inner_compref\n+     | NOP_EXPR\n+       op0 -> inner_compref\n+     | CONVERT_EXPR\n+       op0 -> inner_compref\n \n    condition : val | val relop val\n    val : ID | CONST\n@@ -284,9 +301,11 @@ is_gimple_addr_expr_arg (tree t)\n {\n   return (is_gimple_id (t)\n \t  || TREE_CODE (t) == ARRAY_REF\n+\t  || TREE_CODE (t) == ARRAY_RANGE_REF\n \t  || TREE_CODE (t) == COMPONENT_REF\n \t  || TREE_CODE (t) == REALPART_EXPR\n-\t  || TREE_CODE (t) == IMAGPART_EXPR);\n+\t  || TREE_CODE (t) == IMAGPART_EXPR\n+\t  || TREE_CODE (t) == INDIRECT_REF);\n }\n \n /* Return nonzero if T is function invariant.  Or rather a restricted\n@@ -581,19 +600,12 @@ get_base_address (tree t)\n \t  || TREE_CODE (t) == INDIRECT_REF)\n \treturn t;\n \n-      switch (TREE_CODE (t))\n-\t{\n-\tcase ARRAY_REF:\n-\tcase COMPONENT_REF:\n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\tcase BIT_FIELD_REF:\n-\t  t = TREE_OPERAND (t, 0);\n-\t  break;\n-\n-\tdefault:\n-\t  return NULL_TREE;\n-\t}\n+      if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)\n+\tt = TREE_OPERAND (t, 0);\n+      else if (handled_component_p (t))\n+\tt = get_base_address (TREE_OPERAND (t, 0));\n+      else\n+\treturn NULL_TREE;\n     }\n   while (t);\n "}, {"sha": "98f46951af4b525f1c629d6874a751e7d5ec5ec3", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -42,45 +42,45 @@ extern void annotate_all_with_locus (tree *, location_t);\n    underlying nodes are also of the right form.  */\n \n /* Returns true iff T is a valid GIMPLE statement.  */\n-bool is_gimple_stmt (tree);\n+extern bool is_gimple_stmt (tree);\n \n /* Returns true iff TYPE is a valid type for a scalar register variable.  */\n-bool is_gimple_reg_type (tree);\n+extern bool is_gimple_reg_type (tree);\n /* Returns true iff T is a scalar register variable.  */\n-bool is_gimple_reg (tree);\n+extern bool is_gimple_reg (tree);\n /* Returns true iff T is any sort of variable.  */\n-bool is_gimple_variable (tree);\n+extern bool is_gimple_variable (tree);\n /* Returns true iff T is a variable or an INDIRECT_REF (of a variable).  */\n-bool is_gimple_min_lval (tree);\n+extern bool is_gimple_min_lval (tree);\n /* Returns true iff T is an lvalue other than an INDIRECT_REF.  */\n-bool is_gimple_addr_expr_arg (tree);\n+extern bool is_gimple_addr_expr_arg (tree);\n /* Returns true iff T is any valid GIMPLE lvalue.  */\n-bool is_gimple_lvalue (tree);\n+extern bool is_gimple_lvalue (tree);\n \n /* Returns true iff T is a GIMPLE restricted function invariant.  */\n-bool is_gimple_min_invariant (tree);\n+extern bool is_gimple_min_invariant (tree);\n /* Returns true iff T is a GIMPLE rvalue.  */\n-bool is_gimple_val (tree);\n+extern bool is_gimple_val (tree);\n /* Returns true iff T is a valid rhs for a MODIFY_EXPR.  */\n-bool is_gimple_rhs (tree);\n+extern bool is_gimple_rhs (tree);\n \n /* Returns true iff T is a valid if-statement condition.  */\n-bool is_gimple_condexpr (tree);\n+extern bool is_gimple_condexpr (tree);\n \n /* Returns true iff T is a type conversion.  */\n-bool is_gimple_cast (tree);\n+extern bool is_gimple_cast (tree);\n /* Returns true iff T is a valid CONSTRUCTOR element (either an rvalue or\n    another CONSTRUCTOR).  */\n-bool is_gimple_constructor_elt (tree);\n+extern bool is_gimple_constructor_elt (tree);\n /* Returns true iff T is a variable that does not need to live in memory.  */\n-bool is_gimple_non_addressable (tree t);\n+extern bool is_gimple_non_addressable (tree t);\n \n /* If T makes a function call, returns the CALL_EXPR operand.  */\n-tree get_call_expr_in (tree t);\n+extern tree get_call_expr_in (tree t);\n \n-void recalculate_side_effects (tree);\n+extern void recalculate_side_effects (tree);\n \n-void append_to_compound_expr (tree, tree *);\n+extern void append_to_compound_expr (tree, tree *);\n \n /* FIXME we should deduce this from the predicate.  */\n typedef enum fallback_t {\n@@ -98,29 +98,31 @@ enum gimplify_status {\n   GS_ALL_DONE\t= 1\t/* The expression is fully gimplified.  */\n };\n \n-enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n-\t\t\t\t    bool (*) (tree), fallback_t);\n-void gimplify_stmt (tree *);\n-void gimplify_to_stmt_list (tree *);\n-void gimplify_body (tree *, tree);\n-void push_gimplify_context (void);\n-void pop_gimplify_context (tree);\n-void gimplify_and_add (tree, tree *);\n+extern enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n+\t\t\t\t\t   bool (*) (tree), fallback_t);\n+extern tree gimplify_type_sizes (tree);\n+extern void gimplify_one_sizepos (tree *, tree *);\n+extern void gimplify_stmt (tree *);\n+extern void gimplify_to_stmt_list (tree *);\n+extern void gimplify_body (tree *, tree);\n+extern void push_gimplify_context (void);\n+extern void pop_gimplify_context (tree);\n+extern void gimplify_and_add (tree, tree *);\n \n /* Miscellaneous helpers.  */\n-tree get_base_address (tree t);\n-void gimple_add_tmp_var (tree);\n-tree gimple_current_bind_expr (void);\n-void gimple_push_bind_expr (tree);\n-void gimple_pop_bind_expr (void);\n-void unshare_all_trees (tree);\n-tree voidify_wrapper_expr (tree, tree);\n-tree gimple_build_eh_filter (tree, tree, tree);\n-tree build_and_jump (tree *);\n-tree alloc_stmt_list (void);\n-void free_stmt_list (tree);\n-tree force_labels_r (tree *, int *, void *);\n-enum gimplify_status gimplify_va_arg_expr (tree *, tree *, tree *);\n+extern tree get_base_address (tree t);\n+extern void gimple_add_tmp_var (tree);\n+extern tree gimple_current_bind_expr (void);\n+extern void gimple_push_bind_expr (tree);\n+extern void gimple_pop_bind_expr (void);\n+extern void unshare_all_trees (tree);\n+extern tree voidify_wrapper_expr (tree, tree);\n+extern tree gimple_build_eh_filter (tree, tree, tree);\n+extern tree build_and_jump (tree *);\n+extern tree alloc_stmt_list (void);\n+extern void free_stmt_list (tree);\n+extern tree force_labels_r (tree *, int *, void *);\n+extern enum gimplify_status gimplify_va_arg_expr (tree *, tree *, tree *);\n \n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);"}, {"sha": "deb73605ca2591541ac4c3b510ee5e7f64e4df92", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -2054,8 +2054,14 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t}\n #endif\n     }\n-  else if (TREE_CODE_CLASS (code) == 'd')\n+\n+  /* Look inside the sizes of decls, but we don't ever use the values for\n+     FIELD_DECL and RESULT_DECL, so ignore them.  */\n+  else if (TREE_CODE_CLASS (code) == 'd'\n+\t   && code != FIELD_DECL && code != RESULT_DECL)\n     {\n+      WALK_SUBTREE (DECL_SIZE (*tp));\n+      WALK_SUBTREE (DECL_SIZE_UNIT (*tp));\n       WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n     }\n   else\n@@ -2077,23 +2083,20 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \tcase REAL_CST:\n \tcase VECTOR_CST:\n \tcase STRING_CST:\n-\tcase REAL_TYPE:\n-\tcase COMPLEX_TYPE:\n \tcase VECTOR_TYPE:\n \tcase VOID_TYPE:\n-\tcase BOOLEAN_TYPE:\n-\tcase UNION_TYPE:\n-\tcase ENUMERAL_TYPE:\n \tcase BLOCK:\n-\tcase RECORD_TYPE:\n \tcase PLACEHOLDER_EXPR:\n \tcase SSA_NAME:\n+\tcase FIELD_DECL:\n+\tcase RESULT_DECL:\n \t  /* None of thse have subtrees other than those already walked\n \t     above.  */\n \t  break;\n \n \tcase POINTER_TYPE:\n \tcase REFERENCE_TYPE:\n+\tcase COMPLEX_TYPE:\n \t  WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n \t  break;\n \n@@ -2126,6 +2129,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \n \tcase METHOD_TYPE:\n \t  WALK_SUBTREE (TYPE_METHOD_BASETYPE (*tp));\n+\n \t  /* Fall through.  */\n \n \tcase FUNCTION_TYPE:\n@@ -2139,12 +2143,43 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t  }\n \t  break;\n \n+\tcase RECORD_TYPE:\n+\tcase UNION_TYPE:\n+\tcase QUAL_UNION_TYPE:\n+\t  {\n+\t    tree field;\n+\n+\t    for (field = TYPE_FIELDS (*tp); field; field = TREE_CHAIN (field))\n+\t      {\n+\t\t/* We would like to look at the type of the field, but we\n+\t\t   can easily get infinite recursion.  So assume it's\n+\t\t   pointed to elsewhere in the tree.  Also, ignore things that\n+\t\t   aren't fields.  */\n+\t\tif (TREE_CODE (field) != FIELD_DECL)\n+\t\t  continue;\n+\n+\t\tWALK_SUBTREE (DECL_FIELD_OFFSET (field));\n+\t\tWALK_SUBTREE (DECL_SIZE (field));\n+\t\tWALK_SUBTREE (DECL_SIZE_UNIT (field));\n+\t\tif (code == QUAL_UNION_TYPE)\n+\t\t  WALK_SUBTREE (DECL_QUALIFIER (field));\n+\t      }\n+\t  }\n+\t  break;\n+\n \tcase ARRAY_TYPE:\n-\t  WALK_SUBTREE (TREE_TYPE (*tp));\n+\t  /* Don't follow this nodes's type if a pointer for fear that we'll\n+\t     have infinite recursion.  Those types are uninteresting anyway. */\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (*tp))\n+\t      && TREE_CODE (TREE_TYPE (*tp)) != OFFSET_TYPE)\n+\t    WALK_SUBTREE (TREE_TYPE (*tp));\n \t  WALK_SUBTREE_TAIL (TYPE_DOMAIN (*tp));\n \n+\tcase BOOLEAN_TYPE:\n+\tcase ENUMERAL_TYPE:\n \tcase INTEGER_TYPE:\n \tcase CHAR_TYPE:\n+\tcase REAL_TYPE:\n \t  WALK_SUBTREE (TYPE_MIN_VALUE (*tp));\n \t  WALK_SUBTREE_TAIL (TYPE_MAX_VALUE (*tp));\n \n@@ -2166,8 +2201,8 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t\t/* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n \t\t   into declarations that are just mentioned, rather than\n \t\t   declared; they don't really belong to this part of the tree.\n-\t\t   And, we can see cycles: the initializer for a declaration can\n-\t\t   refer to the declaration itself.  */\n+\t\t   And, we can see cycles: the initializer for a declaration\n+\t\t   can refer to the declaration itself.  */\n \t\tWALK_SUBTREE (DECL_INITIAL (decl));\n \t\tWALK_SUBTREE (DECL_SIZE (decl));\n \t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n@@ -2185,7 +2220,9 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  /* ??? This could be a language-defined node.  We really should make\n+\t     a hook for it, but right now just ignore it.  */\n+\t  break;\n \t}\n     }\n "}, {"sha": "6181bb6ab13ad3f3cca282a3848a04490b06dd9e", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -463,7 +463,7 @@ mf_build_check_statement_for (tree addr, tree size,\n              (flag_mudflap_threads ? mf_cache_mask_decl : mf_cache_mask_decl_l));\n   t = build (ARRAY_REF,\n              TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n-             mf_cache_array_decl, t);\n+             mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n   t = build (MODIFY_EXPR, void_type_node, mf_elem, t);\n   SET_EXPR_LOCUS (t, locus);\n@@ -487,7 +487,7 @@ mf_build_check_statement_for (tree addr, tree size,\n   /* Construct t <-- '__mf_elem->low  > __mf_base'.  */\n   t = build (COMPONENT_REF, mf_uintptr_type,\n              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-             TYPE_FIELDS (mf_cache_struct_type));\n+             TYPE_FIELDS (mf_cache_struct_type), NULL_TREE);\n   t = build (GT_EXPR, boolean_type_node, t, mf_base);\n \n   /* Construct '__mf_elem->high < __mf_base + sizeof(T) - 1'.\n@@ -501,7 +501,7 @@ mf_build_check_statement_for (tree addr, tree size,\n \n   u = build (COMPONENT_REF, mf_uintptr_type,\n              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-             TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)));\n+             TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n \n   v = convert (mf_uintptr_type,\n \t       size_binop (MINUS_EXPR, size, size_one_node));\n@@ -660,14 +660,14 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n            things the hard way with PLUS.  */\n         if (DECL_BIT_FIELD_TYPE (field))\n           {\n-            size = bitsize_int (BITS_PER_UNIT);\n-            size = size_binop (CEIL_DIV_EXPR, DECL_SIZE (field), size);\n-            size = convert (sizetype, size);\n+\t    if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n+\t      size = DECL_SIZE_UNIT (field);\n \n             addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-            addr = convert (ptr_type_node, addr);\n+            addr = fold_convert (ptr_type_node, addr);\n             addr = fold (build (PLUS_EXPR, ptr_type_node,\n-                                addr, byte_position (field)));\n+                                addr, fold_convert (ptr_type_node,\n+\t\t\t\t\t\t    byte_position (field))));\n           }\n         else\n           {"}, {"sha": "1f32e1f60f9520564d678c3d0b51bb696532681c", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -157,8 +157,13 @@ static tree\n build_addr (tree exp)\n {\n   tree base = exp;\n-  while (TREE_CODE (base) == COMPONENT_REF || TREE_CODE (base) == ARRAY_REF)\n+\n+  if (TREE_CODE (base) == REALPART_EXPR || TREE_CODE (base) == IMAGPART_EXPR)\n     base = TREE_OPERAND (base, 0);\n+  else\n+    while (handled_component_p (base))\n+      base = TREE_OPERAND (base, 0);\n+\n   if (DECL_P (base))\n     TREE_ADDRESSABLE (base) = 1;\n \n@@ -550,6 +555,7 @@ walk_stmts (struct walk_stmt_info *wi, tree *tp)\n       break;\n     case CATCH_EXPR:\n       walk_stmts (wi, &CATCH_BODY (t));\n+      break;\n     case EH_FILTER_EXPR:\n       walk_stmts (wi, &EH_FILTER_FAILURE (t));\n       break;\n@@ -657,7 +663,7 @@ get_static_chain (struct nesting_info *info, tree target_context,\n \t  tree field = get_chain_field (i);\n \n \t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n-\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field);\n+\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, tsi);\n \t}\n     }\n@@ -691,14 +697,14 @@ get_frame_field (struct nesting_info *info, tree target_context,\n \t  tree field = get_chain_field (i);\n \n \t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n-\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field);\n+\t  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, tsi);\n \t}\n \n       x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n     }\n \n-  x = build (COMPONENT_REF, TREE_TYPE (field), x, field);\n+  x = build (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n   return x;\n }\n \n@@ -800,10 +806,13 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       wi->val_only = false;\n       walk_tree (&TREE_OPERAND (t, 0), convert_nonlocal_reference, wi, NULL);\n       wi->val_only = true;\n       walk_tree (&TREE_OPERAND (t, 1), convert_nonlocal_reference, wi, NULL);\n+      walk_tree (&TREE_OPERAND (t, 2), convert_nonlocal_reference, wi, NULL);\n+      walk_tree (&TREE_OPERAND (t, 3), convert_nonlocal_reference, wi, NULL);\n       break;\n \n     case BIT_FIELD_REF:\n@@ -932,10 +941,13 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       wi->val_only = false;\n       walk_tree (&TREE_OPERAND (t, 0), convert_local_reference, wi, NULL);\n       wi->val_only = true;\n       walk_tree (&TREE_OPERAND (t, 1), convert_local_reference, wi, NULL);\n+      walk_tree (&TREE_OPERAND (t, 2), convert_local_reference, wi, NULL);\n+      walk_tree (&TREE_OPERAND (t, 3), convert_local_reference, wi, NULL);\n       break;\n \n     case BIT_FIELD_REF:\n@@ -1242,7 +1254,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t    x = p;\n \n \t  y = build (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     root->frame_decl, field);\n+\t\t     root->frame_decl, field, NULL_TREE);\n \t  x = build (MODIFY_EXPR, TREE_TYPE (field), y, x);\n \t  append_to_statement_list (x, &stmt_list);\n \t}\n@@ -1252,9 +1264,8 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n      from chain_decl.  */\n   if (root->chain_field)\n     {\n-      tree x;\n-      x = build (COMPONENT_REF, TREE_TYPE (root->chain_field),\n-\t\t root->frame_decl, root->chain_field);\n+      tree x = build (COMPONENT_REF, TREE_TYPE (root->chain_field),\n+\t\t      root->frame_decl, root->chain_field, NULL_TREE);\n       x = build (MODIFY_EXPR, TREE_TYPE (x), x, get_chain_decl (root));\n       append_to_statement_list (x, &stmt_list);\n     }\n@@ -1281,7 +1292,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  arg = tree_cons (NULL, x, arg);\n \n \t  x = build (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     root->frame_decl, field);\n+\t\t     root->frame_decl, field, NULL_TREE);\n \t  x = build_addr (x);\n \t  arg = tree_cons (NULL, x, arg);\n "}, {"sha": "f19afdde6a1a6ce1a982f0b996bc310bea4a4d65", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1763,17 +1763,20 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n \n   if (TYPE_P (t) || DECL_P (t))\n     *walk_subtrees = 0;\n-  else if (TREE_CODE (t) == ARRAY_REF)\n+  else if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n     {\n-      while ((TREE_CODE (t) == ARRAY_REF\n+      while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t      && is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n \t     || (TREE_CODE (t) == COMPONENT_REF\n \t\t || TREE_CODE (t) == BIT_FIELD_REF\n \t\t || TREE_CODE (t) == REALPART_EXPR\n-\t\t || TREE_CODE (t) == IMAGPART_EXPR))\n+\t\t || TREE_CODE (t) == IMAGPART_EXPR\n+\t\t || TREE_CODE (t) == VIEW_CONVERT_EXPR\n+\t\t || TREE_CODE (t) == NOP_EXPR\n+\t\t || TREE_CODE (t) == CONVERT_EXPR))\n \tt = TREE_OPERAND (t, 0);\n \n-      if (TREE_CODE (t) == ARRAY_REF)\n+      if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n \t  t = get_base_address (t);\n \t  if (t && DECL_P (t))"}, {"sha": "52aa18194171c920e6f62fd2dbd412bb03db639f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -392,6 +392,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n       /* Print the name of the structure.  */\n       if (TREE_CODE (node) == RECORD_TYPE)\n \tpp_string (buffer, \"struct \");\n@@ -404,11 +405,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tprint_struct_decl (buffer, node, spc, flags);\n       break;\n \n-    case QUAL_UNION_TYPE:\n-      NIY;\n-      break;\n-\n-\n     case LANG_TYPE:\n       NIY;\n       break;\n@@ -598,6 +594,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tpp_character (buffer, ')');\n       pp_string (buffer, str);\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      if (TREE_OPERAND (node, 2)\n+\t  && TREE_CODE (TREE_OPERAND (node, 2)) != INTEGER_CST)\n+\t{\n+\t  pp_string (buffer, \"{off: \");\n+\t  dump_generic_node (buffer, TREE_OPERAND (node, 2),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, '}');\n+\t}\n       break;\n \n     case BIT_FIELD_REF:\n@@ -615,6 +619,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       op0 = TREE_OPERAND (node, 0);\n       if (op_prio (op0) < op_prio (node))\n \tpp_character (buffer, '(');\n@@ -623,11 +628,23 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tpp_character (buffer, ')');\n       pp_character (buffer, '[');\n       dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      if (TREE_CODE (node) == ARRAY_RANGE_REF)\n+\tpp_string (buffer, \" ...\");\n       pp_character (buffer, ']');\n-      break;\n \n-    case ARRAY_RANGE_REF:\n-      NIY;\n+      if ((TREE_OPERAND (node, 2)\n+\t   && TREE_CODE (TREE_OPERAND (node, 2)) != INTEGER_CST)\n+\t  || (TREE_OPERAND (node, 3)\n+\t      && TREE_CODE (TREE_OPERAND (node, 3)) != INTEGER_CST))\n+\t{\n+\t  pp_string (buffer, \"{lb: \");\n+\t  dump_generic_node (buffer, TREE_OPERAND (node, 2),\n+\t\t\t     spc, flags, false);\n+\t  pp_string (buffer, \" sz: \");\n+\t  dump_generic_node (buffer, TREE_OPERAND (node, 3),\n+\t\t\t     spc, flags, false);\n+\t  pp_character (buffer, '}');\n+\t}\n       break;\n \n     case CONSTRUCTOR:\n@@ -1490,10 +1507,10 @@ print_struct_decl (pretty_printer *buffer, tree node, int spc, int flags)\n       INDENT (spc);\n       if (TREE_CODE (node) == RECORD_TYPE)\n \tpp_string (buffer, \"struct \");\n-      else if (TREE_CODE (node) == UNION_TYPE)\n+      else if ((TREE_CODE (node) == UNION_TYPE\n+\t\t|| TREE_CODE (node) == QUAL_UNION_TYPE))\n \tpp_string (buffer, \"union \");\n-      else\n-\tNIY;\n+\n       dump_generic_node (buffer, TYPE_NAME (node), spc, 0, false);\n     }\n \n@@ -1515,8 +1532,8 @@ print_struct_decl (pretty_printer *buffer, tree node, int spc, int flags)\n \t   Maybe this could be solved by looking at the scope in which the\n \t   structure was declared.  */\n \tif (TREE_TYPE (tmp) != node\n-\t    || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE &&\n-\t\tTREE_TYPE (TREE_TYPE (tmp)) != node))\n+\t    || (TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE\n+\t\t&& TREE_TYPE (TREE_TYPE (tmp)) != node))\n \t  {\n \t    print_declaration (buffer, tmp, spc+2, flags);\n \t    pp_newline (buffer);\n@@ -1656,6 +1673,7 @@ op_prio (tree op)\n \n     case CALL_EXPR:\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n     case COMPONENT_REF:\n       return 15;\n "}, {"sha": "bbb5942db2446ebfc862723ddf302e465e93d219", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -621,7 +621,7 @@ csc_build_component_ref (tree base, tree field)\n       break;\n     }\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), base, field);\n+  return build (COMPONENT_REF, TREE_TYPE (field), base, field, NULL_TREE);\n }\n \n /* Similarly for REALPART_EXPR and IMAGPART_EXPR for complex types.  */\n@@ -1011,7 +1011,7 @@ scalarize_call_expr (block_stmt_iterator *si_p)\n   /* Scalarize the return value, if any.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n-      tree var = TREE_OPERAND (stmt, 0);\n+      tree var = get_base_address (TREE_OPERAND (stmt, 0));\n \n       /* If the LHS of the assignment is a scalarizable structure, insert\n \t copies into the scalar replacements after the call.  */"}, {"sha": "658a2cb9061be819002a733aaf293d8f3b4132e5", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 101, "deletions": 50, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1041,51 +1041,54 @@ dump_lattice_value (FILE *outf, const char *prefix, value val)\n tree\n widen_bitfield (tree val, tree field, tree var)\n {\n-  unsigned var_size, field_size;\n+  unsigned HOST_WIDE_INT var_size, field_size;\n   tree wide_val;\n   unsigned HOST_WIDE_INT mask;\n-  unsigned i;\n+  unsigned int i;\n \n-  var_size = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE ((var))));\n-  field_size = TREE_INT_CST_LOW (DECL_SIZE (field));\n+  /* We can only do this if the size of the type and field and VAL are\n+     all constants representable in HOST_WIDE_INT.  */\n+  if (!host_integerp (TYPE_SIZE (TREE_TYPE (var)), 1)\n+      || !host_integerp (DECL_SIZE (field), 1)\n+      || !host_integerp (val, 0))\n+    return NULL_TREE;\n+\n+  var_size = tree_low_cst (TYPE_SIZE (TREE_TYPE (var)), 1);\n+  field_size = tree_low_cst (DECL_SIZE (field), 1);\n \n   /* Give up if either the bitfield or the variable are too wide.  */\n   if (field_size > HOST_BITS_PER_WIDE_INT || var_size > HOST_BITS_PER_WIDE_INT)\n-    return NULL;\n+    return NULL_TREE;\n \n #if defined ENABLE_CHECKING\n   if (var_size < field_size)\n     abort ();\n #endif\n \n-  /* If VAL is not an integer constant, then give up.  */\n-  if (TREE_CODE (val) != INTEGER_CST)\n-    return NULL;\n-\n-  /* If the sign bit of the value is not set, or the field's type is\n-     unsigned, then just mask off the high order bits of the value.  */\n-  if ((TREE_INT_CST_LOW (val) & (1 << (field_size - 1))) == 0\n-      || DECL_UNSIGNED (field))\n+  /* If the sign bit of the value is not set or the field's type is unsigned,\n+     just mask off the high order bits of the value.  */\n+  if (DECL_UNSIGNED (field)\n+      || !(tree_low_cst (val, 0) & (((HOST_WIDE_INT)1) << (field_size - 1))))\n     {\n       /* Zero extension.  Build a mask with the lower 'field_size' bits\n \t set and a BIT_AND_EXPR node to clear the high order bits of\n \t the value.  */\n       for (i = 0, mask = 0; i < field_size; i++)\n-\tmask |= 1 << i;\n+\tmask |= ((HOST_WIDE_INT) 1) << i;\n \n       wide_val = build (BIT_AND_EXPR, TREE_TYPE (var), val, \n-\t\t\tbuild_int_2 (mask, 0));\n+\t\t\tfold_convert (TREE_TYPE (var), build_int_2 (mask, 0)));\n     }\n   else\n     {\n       /* Sign extension.  Create a mask with the upper 'field_size'\n \t bits set and a BIT_IOR_EXPR to set the high order bits of the\n \t value.  */\n       for (i = 0, mask = 0; i < (var_size - field_size); i++)\n-\tmask |= 1 << (var_size - i - 1);\n+\tmask |= ((HOST_WIDE_INT) 1) << (var_size - i - 1);\n \n       wide_val = build (BIT_IOR_EXPR, TREE_TYPE (var), val,\n-\t\t\tbuild_int_2 (mask, 0));\n+\t\t\tfold_convert (TREE_TYPE (var), build_int_2 (mask, 0)));\n     }\n \n   return fold (wide_val);\n@@ -1493,10 +1496,26 @@ likely_value (tree stmt)\n static tree\n maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n {\n-  unsigned HOST_WIDE_INT lquo, lrem;\n-  HOST_WIDE_INT hquo, hrem;\n-  tree elt_size, min_idx, idx;\n-  tree array_type, elt_type;\n+  tree min_idx, idx, elt_offset = integer_zero_node;\n+  tree array_type, elt_type, elt_size;\n+\n+  /* If BASE is an ARRAY_REF, we can pick up another offset (this time\n+     measured in units of the size of elements type) from that ARRAY_REF).\n+     We can't do anything if either is variable.\n+\n+     The case we handle here is *(&A[N]+O).  */\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      tree low_bound = array_ref_low_bound (base);\n+\n+      elt_offset = TREE_OPERAND (base, 1);\n+      if (TREE_CODE (low_bound) != INTEGER_CST\n+\t  || TREE_CODE (elt_offset) != INTEGER_CST)\n+\treturn NULL_TREE;\n+\n+      elt_offset = int_const_binop (MINUS_EXPR, elt_offset, low_bound, 0);\n+      base = TREE_OPERAND (base, 0);\n+    }\n \n   /* Ignore stupid user tricks of indexing non-array variables.  */\n   array_type = TREE_TYPE (base);\n@@ -1506,37 +1525,62 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n   if (!lang_hooks.types_compatible_p (orig_type, elt_type))\n     return NULL_TREE;\n \t\n-  /* Whee.  Ignore indexing of variable sized types.  */\n+  /* If OFFSET and ELT_OFFSET are zero, we don't care about the size of the\n+     element type (so we can use the alignment if it's not constant).\n+     Otherwise, compute the offset as an index by using a division.  If the\n+     division isn't exact, then don't do anything.  */\n   elt_size = TYPE_SIZE_UNIT (elt_type);\n-  if (TREE_CODE (elt_size) != INTEGER_CST)\n-    return NULL_TREE;\n+  if (integer_zerop (offset))\n+    {\n+      if (TREE_CODE (elt_size) != INTEGER_CST)\n+\telt_size = size_int (TYPE_ALIGN (elt_type));\n \n-  /* If the division isn't exact, then don't do anything.  Equally\n-     invalid as the above indexing of non-array variables.  */\n-  if (div_and_round_double (TRUNC_DIV_EXPR, 1,\n-\t\t\t    TREE_INT_CST_LOW (offset),\n-\t\t\t    TREE_INT_CST_HIGH (offset),\n-\t\t\t    TREE_INT_CST_LOW (elt_size),\n-\t\t\t    TREE_INT_CST_HIGH (elt_size),\n-\t\t\t    &lquo, &hquo, &lrem, &hrem)\n-      || lrem || hrem)\n-    return NULL_TREE;\n-  idx = build_int_2_wide (lquo, hquo);\n+      idx = integer_zero_node;\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT lquo, lrem;\n+      HOST_WIDE_INT hquo, hrem;\n+\n+      if (TREE_CODE (elt_size) != INTEGER_CST\n+\t  || div_and_round_double (TRUNC_DIV_EXPR, 1,\n+\t\t\t\t   TREE_INT_CST_LOW (offset),\n+\t\t\t\t   TREE_INT_CST_HIGH (offset),\n+\t\t\t\t   TREE_INT_CST_LOW (elt_size),\n+\t\t\t\t   TREE_INT_CST_HIGH (elt_size),\n+\t\t\t\t   &lquo, &hquo, &lrem, &hrem)\n+\t  || lrem || hrem)\n+\treturn NULL_TREE;\n \n-  /* Re-bias the index by the min index of the array type.  */\n-  min_idx = TYPE_DOMAIN (TREE_TYPE (base));\n-  if (min_idx)\n+      idx = build_int_2_wide (lquo, hquo);\n+    }\n+\n+  /* Assume the low bound is zero.  If there is a domain type, get the\n+     low bound, if any, convert the index into that type, and add the\n+     low bound.  */\n+  min_idx = integer_zero_node;\n+  if (TYPE_DOMAIN (array_type))\n     {\n-      min_idx = TYPE_MIN_VALUE (min_idx);\n-      if (min_idx)\n-\t{\n-\t  idx = convert (TREE_TYPE (min_idx), idx);\n-\t  if (!integer_zerop (min_idx))\n-\t    idx = int_const_binop (PLUS_EXPR, idx, min_idx, 1);\n-\t}\n+      if (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n+\tmin_idx = TYPE_MIN_VALUE (TYPE_DOMAIN (array_type));\n+      else\n+\tmin_idx = fold_convert (TYPE_DOMAIN (array_type), min_idx);\n+\n+      if (TREE_CODE (min_idx) != INTEGER_CST)\n+\treturn NULL_TREE;\n+\n+      idx = fold_convert (TYPE_DOMAIN (array_type), idx);\n+      elt_offset = fold_convert (TYPE_DOMAIN (array_type), elt_offset);\n     }\n \n-  return build (ARRAY_REF, orig_type, base, idx);\n+  if (!integer_zerop (min_idx))\n+    idx = int_const_binop (PLUS_EXPR, idx, min_idx, 0);\n+  if (!integer_zerop (elt_offset))\n+    idx = int_const_binop (PLUS_EXPR, idx, elt_offset, 0);\n+\n+  return build (ARRAY_REF, orig_type, base, idx, min_idx,\n+\t\tsize_int (tree_low_cst (elt_size, 1)\n+\t\t\t  / (TYPE_ALIGN (elt_type) / BITS_PER_UNIT)));\n }\n \n /* A subroutine of fold_stmt_r.  Attempts to fold *(S+O) to S.X.\n@@ -1617,7 +1661,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \t{\n \t  if (base_is_ptr)\n \t    base = build1 (INDIRECT_REF, record_type, base);\n-\t  t = build (COMPONENT_REF, field_type, base, f);\n+\t  t = build (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \t  return t;\n \t}\n \n@@ -1639,7 +1683,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n      nonzero offset into them.  Recurse and hope for a valid match.  */\n   if (base_is_ptr)\n     base = build1 (INDIRECT_REF, record_type, base);\n-  base = build (COMPONENT_REF, field_type, base, f);\n+  base = build (COMPONENT_REF, field_type, base, f, NULL_TREE);\n \n   t = maybe_fold_offset_to_array_ref (base, offset, orig_type);\n   if (t)\n@@ -1697,8 +1741,12 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n       if (t)\n \treturn t;\n \n-      /* Fold *&B to B.  */\n-      if (integer_zerop (offset))\n+      /* Fold *&B to B.  We can only do this if EXPR is the same type\n+\t as BASE.  We can't do this if EXPR is the element type of an array\n+\t and BASE is the array.  */\n+      if (integer_zerop (offset)\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (base),\n+\t\t\t\t\t    TREE_TYPE (expr)))\n \treturn base;\n     }\n   else\n@@ -1803,6 +1851,9 @@ maybe_fold_stmt_addition (tree expr)\n \t  min_idx = TYPE_MIN_VALUE (min_idx);\n \t  if (min_idx)\n \t    {\n+\t      if (TREE_CODE (min_idx) != INTEGER_CST)\n+\t\tbreak;\n+\n \t      array_idx = convert (TREE_TYPE (min_idx), array_idx);\n \t      if (!integer_zerop (min_idx))\n \t\tarray_idx = int_const_binop (MINUS_EXPR, array_idx,"}, {"sha": "08330abd51f9934577a342f9a6565dbadc62c6a6", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -897,30 +897,18 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n   code = TREE_CODE (expr);\n   class = TREE_CODE_CLASS (code);\n \n-  /* Expressions that make no memory references.  */\n-  if (class == 'c'\n-      || class == 't'\n-      || code == BLOCK\n-      || code == FUNCTION_DECL\n-      || code == EXC_PTR_EXPR\n-      || code == FILTER_EXPR\n-      || code == LABEL_DECL)\n-    return;\n-\n   /* We could have the address of a component, array member, etc which\n      has interesting variable references.  */\n   if (code == ADDR_EXPR)\n     {\n-      enum tree_code subcode = TREE_CODE (TREE_OPERAND (expr, 0));\n-\n       /* Taking the address of a variable does not represent a\n \t reference to it, but the fact that STMT takes its address will be\n \t of interest to some passes (e.g. alias resolution).  */\n       add_stmt_operand (expr_p, stmt, 0, NULL);\n \n-      /* If the address is invariant, there may be no interesting variable\n-\t references inside.  */\n-      if (is_gimple_min_invariant (expr))\n+      /* If the address is constant (invariant is not sufficient), there will\n+\t be no interesting variable references inside.  */\n+      if (TREE_CONSTANT (expr))\n \treturn;\n \n       /* There should be no VUSEs created, since the referenced objects are\n@@ -930,12 +918,22 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       flags |= opf_no_vops;\n \n       /* Avoid recursion.  */\n-      code = subcode;\n-      class = TREE_CODE_CLASS (code);\n       expr_p = &TREE_OPERAND (expr, 0);\n       expr = *expr_p;\n+      code =  TREE_CODE (expr);\n+      class = TREE_CODE_CLASS (code);\n     }\n \n+  /* Expressions that make no memory references.  */\n+  if (class == 'c'\n+      || class == 't'\n+      || code == BLOCK\n+      || code == FUNCTION_DECL\n+      || code == EXC_PTR_EXPR\n+      || code == FILTER_EXPR\n+      || code == LABEL_DECL)\n+    return;\n+\n   /* If we found a variable, add it to DEFS or USES depending on the\n      operand flags.  */\n   if (SSA_VAR_P (expr))\n@@ -1043,7 +1041,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n   /* Treat array references as references to the virtual variable\n      representing the array.  The virtual variable for an ARRAY_REF\n      is the VAR_DECL for the array.  */\n-  if (code == ARRAY_REF)\n+  if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n     {\n       /* Add the virtual variable for the ARRAY_REF to VDEFS or VUSES\n \t according to the value of IS_DEF.  Recurse if the LHS of the\n@@ -1054,6 +1052,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n \n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none, prev_vops);\n       return;\n     }\n \n@@ -1078,6 +1078,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       else\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n \n+      if (code == COMPONENT_REF)\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n       return;\n     }\n "}, {"sha": "89d40a1b918ee9dc9f3d5d9bfc1a8c1ee8631ac6", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -473,20 +473,11 @@ set_is_used (tree t)\n       if (SSA_VAR_P (t))\n \tbreak;\n \n-      switch (TREE_CODE (t))\n-\t{\n-\tcase ARRAY_REF:\n-\tcase COMPONENT_REF:\n-\tcase REALPART_EXPR:\n-\tcase IMAGPART_EXPR:\n-\tcase BIT_FIELD_REF:\n-\tcase INDIRECT_REF:\n+      if (TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR)\n+\tt = TREE_OPERAND (t, 0);\n+      else\n+\twhile (handled_component_p (t))\n \t  t = TREE_OPERAND (t, 0);\n-\t  break;\n-\n-\tdefault:\n-\t  return;\n-\t}\n     }\n \n   if (TREE_CODE (t) == SSA_NAME)"}, {"sha": "716bc35fa70cdf2ca48cbfb5d82f42e4571ecba8", "filename": "gcc/tree.c", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -1927,7 +1927,8 @@ substitute_in_expr (tree exp, tree f, tree r)\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n-     new = fold (build2 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1)));\n+     new = fold (build (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n+\t\t\tNULL_TREE));\n    }\n   else\n     switch (TREE_CODE_CLASS (code))\n@@ -2157,7 +2158,7 @@ stabilize_reference (tree ref)\n     case COMPONENT_REF:\n       result = build_nt (COMPONENT_REF,\n \t\t\t stabilize_reference (TREE_OPERAND (ref, 0)),\n-\t\t\t TREE_OPERAND (ref, 1));\n+\t\t\t TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n@@ -2170,13 +2171,15 @@ stabilize_reference (tree ref)\n     case ARRAY_REF:\n       result = build_nt (ARRAY_REF,\n \t\t\t stabilize_reference (TREE_OPERAND (ref, 0)),\n-\t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)));\n+\t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)),\n+\t\t\t TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n     case ARRAY_RANGE_REF:\n       result = build_nt (ARRAY_RANGE_REF,\n \t\t\t stabilize_reference (TREE_OPERAND (ref, 0)),\n-\t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)));\n+\t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)),\n+\t\t\t TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n     case COMPOUND_EXPR:\n@@ -2292,41 +2295,77 @@ stabilize_reference_1 (tree e)\n \f\n /* Low-level constructors for expressions.  */\n \n-/* A helper function for build1 and constant folders.\n-   Set TREE_CONSTANT and TREE_INVARIANT for an ADDR_EXPR.  */\n+/* A helper function for build1 and constant folders.  Set TREE_CONSTANT,\n+   TREE_INVARIANT, and TREE_SIDE_EFFECTS for an ADDR_EXPR.  */\n \n void\n recompute_tree_invarant_for_addr_expr (tree t)\n {\n-  tree node = TREE_OPERAND (t, 0);\n-  bool tc = false, ti = false;\n+  tree node;\n+  bool tc = true, ti = true, se = false;\n \n-  /* Addresses of constants and static variables are constant;\n-     all other decl addresses are invariant.  */\n-  if (staticp (node))\n-    tc = ti = true;\n-  else\n+  /* We started out assuming this address is both invariant and constant, but\n+     does not have side effects.  Now go down any handled components and see if\n+     any of them involve offsets that are either non-constant or non-invariant.\n+     Also check for side-effects.\n+\n+     ??? Note that this code makes no attempt to deal with the case where\n+     taking the address of something causes a copy due to misalignment.  */\n+\n+#define UPDATE_TITCSE(NODE)  \\\n+do { tree _node = (NODE); \\\n+     if (_node && !TREE_INVARIANT (_node)) ti = false; \\\n+     if (_node && !TREE_CONSTANT (_node)) tc = false; \\\n+     if (_node && TREE_SIDE_EFFECTS (_node)) se = true; } while (0)\n+\n+  for (node = TREE_OPERAND (t, 0); handled_component_p (node);\n+       node = TREE_OPERAND (node, 0))\n     {\n-      /* Step past constant offsets.  */\n-      while (1)\n+      /* If the first operand doesn't have an ARRAY_TYPE, this is a bogus\n+\t array reference (probably made temporarily by the G++ front end),\n+\t so ignore all the operands.  */\n+      if ((TREE_CODE (node) == ARRAY_REF\n+\t   || TREE_CODE (node) == ARRAY_RANGE_REF)\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (node, 0))) == ARRAY_TYPE)\n \t{\n-\t  if (TREE_CODE (node) == COMPONENT_REF\n-\t      && TREE_CODE (TREE_OPERAND (node, 1)) == FIELD_DECL\n-\t      && ! DECL_BIT_FIELD (TREE_OPERAND (node, 1)))\n-\t    ;\n-\t  else if (TREE_CODE (node) == ARRAY_REF\n-\t           && TREE_CONSTANT (TREE_OPERAND (node, 1)))\n-\t    ;\n-\t  else\n-\t    break;\n-\t  node = TREE_OPERAND (node, 0);\n+\t  UPDATE_TITCSE (TREE_OPERAND (node, 1));\n+\t  UPDATE_TITCSE (array_ref_low_bound (node));\n+\t  UPDATE_TITCSE (array_ref_element_size (node));\n \t}\n-      if (DECL_P (node))\n-        ti = true;\n+      /* Likewise, just because this is a COMPONENT_REF doesn't mean we have a\n+\t FIELD_DECL, apparently.  The G++ front end can put something else\n+\t there, at least temporarily.  */\n+      else if (TREE_CODE (node) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_OPERAND (node, 1)) == FIELD_DECL)\n+\tUPDATE_TITCSE (component_ref_field_offset (node));\n+      else if (TREE_CODE (node) == BIT_FIELD_REF)\n+\tUPDATE_TITCSE (TREE_OPERAND (node, 2));\n+    }\n+\t      \n+  /* Now see what's inside.  If it's an INDIRECT_REF, copy our properties from\n+     it.  If it's a decl, it's definitely invariant and it's constant if the\n+     decl is static.  (Taking the address of a volatile variable is not\n+     volatile.)  If it's a constant, the address is both invariant and\n+     constant.  Otherwise it's neither.  */\n+  if (TREE_CODE (node) == INDIRECT_REF)\n+    UPDATE_TITCSE (node);\n+  else if (DECL_P (node))\n+    {\n+      if (!staticp (node))\n+\ttc = false;\n+    }\n+  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 'c')\n+    ;\n+  else\n+    {\n+      ti = tc = false;\n+      se |= TREE_SIDE_EFFECTS (node);\n     }\n \n   TREE_CONSTANT (t) = tc;\n   TREE_INVARIANT (t) = ti;\n+  TREE_SIDE_EFFECTS (t) = se;\n+#undef UPDATE_TITCSE\n }\n \n /* Build an expression of code CODE, data type TYPE, and operands as\n@@ -2429,27 +2468,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n \n     case ADDR_EXPR:\n       if (node)\n-\t{\n-\t  recompute_tree_invarant_for_addr_expr (t);\n-\n-\t  /* The address of a volatile decl or reference does not have\n-\t     side-effects.  But be careful not to ignore side-effects from\n-\t     other sources deeper in the expression--if node is a _REF and\n-\t     one of its operands has side-effects, so do we.  */\n-\t  if (TREE_THIS_VOLATILE (node))\n-\t    {\n-\t      TREE_SIDE_EFFECTS (t) = 0;\n-\t      if (!DECL_P (node))\n-\t\t{\n-\t\t  int i = first_rtl_op (TREE_CODE (node)) - 1;\n-\t\t  for (; i >= 0; --i)\n-\t\t    {\n-\t\t      if (TREE_SIDE_EFFECTS (TREE_OPERAND (node, i)))\n-\t\t\tTREE_SIDE_EFFECTS (t) = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+\trecompute_tree_invarant_for_addr_expr (t);\n       break;\n \n     default:\n@@ -2516,6 +2535,8 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   TREE_CONSTANT (t) = constant;\n   TREE_INVARIANT (t) = invariant;\n   TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_THIS_VOLATILE (t)\n+    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n   return t;\n }\n@@ -2565,6 +2586,8 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n     }\n \n   TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_THIS_VOLATILE (t)\n+    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n   return t;\n }\n@@ -2595,6 +2618,8 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   PROCESS_ARG(3);\n \n   TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_THIS_VOLATILE (t)\n+    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n   return t;\n }\n@@ -4457,8 +4482,8 @@ get_unwidened (tree op, tree for_type)\n \t  && (for_type || ! DECL_BIT_FIELD (TREE_OPERAND (op, 1)))\n \t  && (! uns || final_prec <= innerprec || unsignedp))\n \t{\n-\t  win = build2 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n-\t\t\tTREE_OPERAND (op, 1));\n+\t  win = build3 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n+\t\t\tTREE_OPERAND (op, 1), NULL_TREE);\n \t  TREE_SIDE_EFFECTS (win) = TREE_SIDE_EFFECTS (op);\n \t  TREE_THIS_VOLATILE (win) = TREE_THIS_VOLATILE (op);\n \t}\n@@ -4523,7 +4548,8 @@ get_narrower (tree op, int *unsignedp_ptr)\n       /* Since type_for_size always gives an integer type.  */\n       && TREE_CODE (TREE_TYPE (op)) != REAL_TYPE\n       /* Ensure field is laid out already.  */\n-      && DECL_SIZE (TREE_OPERAND (op, 1)) != 0)\n+      && DECL_SIZE (TREE_OPERAND (op, 1)) != 0\n+      && host_integerp (DECL_SIZE (TREE_OPERAND (op, 1)), 1))\n     {\n       unsigned HOST_WIDE_INT innerprec\n \t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n@@ -4546,8 +4572,8 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t{\n \t  if (first)\n \t    uns = DECL_UNSIGNED (TREE_OPERAND (op, 1));\n-\t  win = build2 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n-\t\t\tTREE_OPERAND (op, 1));\n+\t  win = build3 (COMPONENT_REF, type, TREE_OPERAND (op, 0),\n+\t\t\tTREE_OPERAND (op, 1), NULL_TREE);\n \t  TREE_SIDE_EFFECTS (win) = TREE_SIDE_EFFECTS (op);\n \t  TREE_THIS_VOLATILE (win) = TREE_THIS_VOLATILE (op);\n \t}"}, {"sha": "12a6394c5b109ef6936455a9517419b598c4e63c", "filename": "gcc/tree.def", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -354,9 +354,11 @@ DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\", 'd', 0)\n /* References to storage.  */\n \n /* Value is structure or union component.\n-   Operand 0 is the structure or union (an expression);\n-   operand 1 is the field (a node of type FIELD_DECL).  */\n-DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 2)\n+   Operand 0 is the structure or union (an expression).\n+   Operand 1 is the field (a node of type FIELD_DECL).\n+   Operand 2, if present, is the value of DECL_FIELD_OFFSET, measured\n+   in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  */\n+DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 3)\n \n /* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n    except the position is given explicitly rather than via a FIELD_DECL.\n@@ -374,13 +376,16 @@ DEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n DEFTREECODE (BUFFER_REF, \"buffer_ref\", 'r', 1)\n \n /* Array indexing.\n-   Operand 0 is the array; operand 1 is a (single) array index.  */\n-DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n+   Operand 0 is the array; operand 1 is a (single) array index.\n+   Operand 2, if present, is a copy of TYPE_MIN_VALUE of the index.\n+   Operand 3, if present, is the element size, measured in units of\n+   the alignment of the element type.  */\n+DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 4)\n \n /* Likewise, except that the result is a range (\"slice\") of the array.  The\n    starting index of the resulting array is taken from operand 1 and the size\n    of the range is taken from the type of the expression.  */\n-DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 2)\n+DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 4)\n \n /* Vtable indexing.  Carries data useful for emitting information\n    for vtable garbage collection."}, {"sha": "9b753a341f6ef2d3dad02ce82d8c2697d30ead57", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44de5aeb00a66307236cb5b7ccfca1a21aaca080/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=44de5aeb00a66307236cb5b7ccfca1a21aaca080", "patch": "@@ -3166,6 +3166,21 @@ extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \n extern int handled_component_p (tree);\n \n+/* Return a tree of sizetype representing the size, in bytes, of the element\n+   of EXP, an ARRAY_REF.  */\n+\n+extern tree array_ref_element_size (tree);\n+\n+/* Return a tree representing the lower bound of the array mentioned in\n+   EXP, an ARRAY_REF.  */\n+\n+extern tree array_ref_low_bound (tree);\n+\n+/* Return a tree representing the offset, in bytes, of the field referenced\n+   by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n+\n+extern tree component_ref_field_offset (tree);\n+\n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n "}]}