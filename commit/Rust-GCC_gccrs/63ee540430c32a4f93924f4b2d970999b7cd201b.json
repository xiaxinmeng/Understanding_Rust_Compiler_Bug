{"sha": "63ee540430c32a4f93924f4b2d970999b7cd201b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlZTU0MDQzMGMzMmE0ZjkzOTI0ZjRiMmQ5NzA5OTliN2NkMjAxYg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-11-08T11:51:00Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-11-08T11:51:00Z"}, "message": "PR 82869 Introduce logical_type_node and use it\n\nEarlier GFortran used to redefine boolean_type_node, which in the rest\nof the compiler means the C/C++ _Bool/bool type, to the Fortran\ndefault logical type.  When this redefinition was removed, a few\nissues surfaced. Namely,\n\n1) PR 82869, where we created a boolean tmp variable, and passed it to\nthe runtime library as a Fortran logical variable of a different size.\n\n2) Fortran specifies that logical operations should be done with the\ndefault logical kind, not in any other kind.\n\n3) Using 8-bit variables have some issues, such as\n   - on x86, partial register stalls and length prefix changes.\n   - s390 has a compare with immediate and jump instruction which\n     works with 32-bit but not 8-bit quantities.\n\nThis patch addresses these issues by introducing a type\nlogical_type_node which is a Fortran LOGICAL variable of default\nkind. It is then used in places were the Fortran standard mandates, as\nwell as for compiler generated temporary variables.\n\nFor x86-64, using the Polyhedron benchmark suite, no performance or\ncode size difference worth mentioning was observed.\n\nRegtested on x86_64-pc-linux-gnu.\n\ngcc/fortran/ChangeLog:\n\n2017-11-08  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR 82869\n\t* convert.c (truthvalue_conversion): Use logical_type_node.\n\t* trans-array.c (gfc_trans_allocate_array_storage): Likewise.\n\t(gfc_trans_create_temp_array): Likewise.\n\t(gfc_trans_array_ctor_element): Likewise.\n\t(gfc_trans_array_constructor_value): Likewise.\n\t(trans_array_constructor): Likewise.\n\t(trans_array_bound_check): Likewise.\n\t(gfc_conv_array_ref): Likewise.\n\t(gfc_trans_scalarized_loop_end): Likewise.\n\t(gfc_conv_array_extent_dim): Likewise.\n\t(gfc_array_init_size): Likewise.\n\t(gfc_array_allocate): Likewise.\n\t(gfc_trans_array_bounds): Likewise.\n\t(gfc_trans_dummy_array_bias): Likewise.\n\t(gfc_conv_array_parameter): Likewise.\n\t(duplicate_allocatable): Likewise.\n\t(duplicate_allocatable_coarray): Likewise.\n\t(structure_alloc_comps): Likewise\n\t(get_std_lbound): Likewise\n\t(gfc_alloc_allocatable_for_assignment): Likewise\n\t* trans-decl.c (add_argument_checking): Likewise\n\t(gfc_generate_function_code): Likewise\n\t* trans-expr.c (gfc_copy_class_to_class): Likewise\n\t(gfc_trans_class_array_init_assign): Likewise\n\t(gfc_trans_class_init_assign): Likewise\n\t(gfc_conv_expr_present): Likewise\n\t(gfc_conv_substring): Likewise\n\t(gfc_conv_cst_int_power): Likewise\n\t(gfc_conv_expr_op): Likewise\n\t(gfc_conv_procedure_call): Likewise\n\t(fill_with_spaces): Likewise\n\t(gfc_trans_string_copy): Likewise\n\t(gfc_trans_alloc_subarray_assign): Likewise\n\t(gfc_trans_pointer_assignment): Likewise\n\t(gfc_trans_scalar_assign): Likewise\n\t(fcncall_realloc_result): Likewise\n\t(alloc_scalar_allocatable_for_assignment): Likewise\n\t(trans_class_assignment): Likewise\n\t(gfc_trans_assignment_1): Likewise\n\t* trans-intrinsic.c (build_fixbound_expr): Likewise\n\t(gfc_conv_intrinsic_aint): Likewise\n\t(gfc_trans_same_strlen_check): Likewise\n\t(conv_caf_send): Likewise\n\t(trans_this_image): Likewise\n\t(conv_intrinsic_image_status): Likewise\n\t(trans_image_index): Likewise\n\t(gfc_conv_intrinsic_bound): Likewise\n\t(conv_intrinsic_cobound): Likewise\n\t(gfc_conv_intrinsic_mod): Likewise\n\t(gfc_conv_intrinsic_dshift): Likewise\n\t(gfc_conv_intrinsic_dim): Likewise\n\t(gfc_conv_intrinsic_sign): Likewise\n\t(gfc_conv_intrinsic_ctime): Likewise\n\t(gfc_conv_intrinsic_fdate): Likewise\n\t(gfc_conv_intrinsic_ttynam): Likewise\n\t(gfc_conv_intrinsic_minmax): Likewise\n\t(gfc_conv_intrinsic_minmax_char): Likewise\n\t(gfc_conv_intrinsic_anyall): Likewise\n\t(gfc_conv_intrinsic_arith): Likewise\n\t(gfc_conv_intrinsic_minmaxloc): Likewise\n\t(gfc_conv_intrinsic_minmaxval): Likewise\n\t(gfc_conv_intrinsic_btest): Likewise\n\t(gfc_conv_intrinsic_bitcomp): Likewise\n\t(gfc_conv_intrinsic_shift): Likewise\n\t(gfc_conv_intrinsic_ishft): Likewise\n\t(gfc_conv_intrinsic_ishftc): Likewise\n\t(gfc_conv_intrinsic_leadz): Likewise\n\t(gfc_conv_intrinsic_trailz): Likewise\n\t(gfc_conv_intrinsic_mask): Likewise\n\t(gfc_conv_intrinsic_spacing): Likewise\n\t(gfc_conv_intrinsic_rrspacing): Likewise\n\t(gfc_conv_intrinsic_size): Likewise\n\t(gfc_conv_intrinsic_sizeof): Likewise\n\t(gfc_conv_intrinsic_transfer): Likewise\n\t(gfc_conv_allocated): Likewise\n\t(gfc_conv_associated): Likewise\n\t(gfc_conv_same_type_as): Likewise\n\t(gfc_conv_intrinsic_trim): Likewise\n\t(gfc_conv_intrinsic_repeat): Likewise\n\t(conv_isocbinding_function): Likewise\n\t(conv_intrinsic_ieee_is_normal): Likewise\n\t(conv_intrinsic_ieee_is_negative): Likewise\n\t(conv_intrinsic_ieee_copy_sign): Likewise\n\t(conv_intrinsic_move_alloc): Likewise\n\t* trans-io.c (set_parameter_value_chk): Likewise\n\t(set_parameter_value_inquire): Likewise\n\t(set_string): Likewise\n\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise\n\t(gfc_omp_clause_default_ctor): Likewise\n\t(gfc_omp_clause_copy_ctor): Likewise\n\t(gfc_omp_clause_assign_op): Likewise\n\t(gfc_omp_clause_dtor): Likewise\n\t(gfc_omp_finish_clause): Likewise\n\t(gfc_trans_omp_clauses): Likewise\n\t(gfc_trans_omp_do): Likewise\n\t* trans-stmt.c (gfc_trans_goto): Likewise\n\t(gfc_trans_sync): Likewise\n\t(gfc_trans_arithmetic_if): Likewise\n\t(gfc_trans_simple_do): Likewise\n\t(gfc_trans_do): Likewise\n\t(gfc_trans_forall_loop): Likewise\n\t(gfc_trans_where_2): Likewise\n\t(gfc_trans_allocate): Likewise\n\t(gfc_trans_deallocate): Likewise\n\t* trans-types.c (gfc_init_types): Initialize logical_type_node and\n\tits true/false trees.\n\t(gfc_get_array_descr_info): Use logical_type_node.\n\t* trans-types.h (logical_type_node): New tree.\n\t(logical_true_node): Likewise.\n\t(logical_false_node): Likewise.\n\t* trans.c (gfc_trans_runtime_check): Use logical_type_node.\n\t(gfc_call_malloc): Likewise\n\t(gfc_allocate_using_malloc): Likewise\n\t(gfc_allocate_allocatable): Likewise\n\t(gfc_add_comp_finalizer_call): Likewise\n\t(gfc_add_finalizer_call): Likewise\n\t(gfc_deallocate_with_status): Likewise\n\t(gfc_deallocate_scalar_with_status): Likewise\n\t(gfc_call_realloc): Likewise\n\ngcc/testsuite/ChangeLog:\n\n2017-11-08  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR 82869\n\t* gfortran.dg/logical_temp_io.f90: New test.\n\t* gfortran.dg/logical_temp_io_kind8.f90: New test.\n\nFrom-SVN: r254526", "tree": {"sha": "490c0d79ce827b128def2d2dcfe98a59d0a21aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/490c0d79ce827b128def2d2dcfe98a59d0a21aa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63ee540430c32a4f93924f4b2d970999b7cd201b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ee540430c32a4f93924f4b2d970999b7cd201b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ee540430c32a4f93924f4b2d970999b7cd201b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ee540430c32a4f93924f4b2d970999b7cd201b/comments", "author": null, "committer": null, "parents": [{"sha": "c8ce479d39e94b4b7898776efcbbbd81505c57e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ce479d39e94b4b7898776efcbbbd81505c57e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ce479d39e94b4b7898776efcbbbd81505c57e9"}], "stats": {"total": 868, "additions": 527, "deletions": 341}, "files": [{"sha": "8de4c1b98334cc125f0155114a4d651486489877", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -1,4 +1,127 @@\n- 2017-11-06  Paul Thomas  <pault@gcc.gnu.org>\n+2017-11-08  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR 82869\n+\t* convert.c (truthvalue_conversion): Use logical_type_node.\n+\t* trans-array.c (gfc_trans_allocate_array_storage): Likewise.\n+\t(gfc_trans_create_temp_array): Likewise.\n+\t(gfc_trans_array_ctor_element): Likewise.\n+\t(gfc_trans_array_constructor_value): Likewise.\n+\t(trans_array_constructor): Likewise.\n+\t(trans_array_bound_check): Likewise.\n+\t(gfc_conv_array_ref): Likewise.\n+\t(gfc_trans_scalarized_loop_end): Likewise.\n+\t(gfc_conv_array_extent_dim): Likewise.\n+\t(gfc_array_init_size): Likewise.\n+\t(gfc_array_allocate): Likewise.\n+\t(gfc_trans_array_bounds): Likewise.\n+\t(gfc_trans_dummy_array_bias): Likewise.\n+\t(gfc_conv_array_parameter): Likewise.\n+\t(duplicate_allocatable): Likewise.\n+\t(duplicate_allocatable_coarray): Likewise.\n+\t(structure_alloc_comps): Likewise\n+\t(get_std_lbound): Likewise\n+\t(gfc_alloc_allocatable_for_assignment): Likewise\n+\t* trans-decl.c (add_argument_checking): Likewise\n+\t(gfc_generate_function_code): Likewise\n+\t* trans-expr.c (gfc_copy_class_to_class): Likewise\n+\t(gfc_trans_class_array_init_assign): Likewise\n+\t(gfc_trans_class_init_assign): Likewise\n+\t(gfc_conv_expr_present): Likewise\n+\t(gfc_conv_substring): Likewise\n+\t(gfc_conv_cst_int_power): Likewise\n+\t(gfc_conv_expr_op): Likewise\n+\t(gfc_conv_procedure_call): Likewise\n+\t(fill_with_spaces): Likewise\n+\t(gfc_trans_string_copy): Likewise\n+\t(gfc_trans_alloc_subarray_assign): Likewise\n+\t(gfc_trans_pointer_assignment): Likewise\n+\t(gfc_trans_scalar_assign): Likewise\n+\t(fcncall_realloc_result): Likewise\n+\t(alloc_scalar_allocatable_for_assignment): Likewise\n+\t(trans_class_assignment): Likewise\n+\t(gfc_trans_assignment_1): Likewise\n+\t* trans-intrinsic.c (build_fixbound_expr): Likewise\n+\t(gfc_conv_intrinsic_aint): Likewise\n+\t(gfc_trans_same_strlen_check): Likewise\n+\t(conv_caf_send): Likewise\n+\t(trans_this_image): Likewise\n+\t(conv_intrinsic_image_status): Likewise\n+\t(trans_image_index): Likewise\n+\t(gfc_conv_intrinsic_bound): Likewise\n+\t(conv_intrinsic_cobound): Likewise\n+\t(gfc_conv_intrinsic_mod): Likewise\n+\t(gfc_conv_intrinsic_dshift): Likewise\n+\t(gfc_conv_intrinsic_dim): Likewise\n+\t(gfc_conv_intrinsic_sign): Likewise\n+\t(gfc_conv_intrinsic_ctime): Likewise\n+\t(gfc_conv_intrinsic_fdate): Likewise\n+\t(gfc_conv_intrinsic_ttynam): Likewise\n+\t(gfc_conv_intrinsic_minmax): Likewise\n+\t(gfc_conv_intrinsic_minmax_char): Likewise\n+\t(gfc_conv_intrinsic_anyall): Likewise\n+\t(gfc_conv_intrinsic_arith): Likewise\n+\t(gfc_conv_intrinsic_minmaxloc): Likewise\n+\t(gfc_conv_intrinsic_minmaxval): Likewise\n+\t(gfc_conv_intrinsic_btest): Likewise\n+\t(gfc_conv_intrinsic_bitcomp): Likewise\n+\t(gfc_conv_intrinsic_shift): Likewise\n+\t(gfc_conv_intrinsic_ishft): Likewise\n+\t(gfc_conv_intrinsic_ishftc): Likewise\n+\t(gfc_conv_intrinsic_leadz): Likewise\n+\t(gfc_conv_intrinsic_trailz): Likewise\n+\t(gfc_conv_intrinsic_mask): Likewise\n+\t(gfc_conv_intrinsic_spacing): Likewise\n+\t(gfc_conv_intrinsic_rrspacing): Likewise\n+\t(gfc_conv_intrinsic_size): Likewise\n+\t(gfc_conv_intrinsic_sizeof): Likewise\n+\t(gfc_conv_intrinsic_transfer): Likewise\n+\t(gfc_conv_allocated): Likewise\n+\t(gfc_conv_associated): Likewise\n+\t(gfc_conv_same_type_as): Likewise\n+\t(gfc_conv_intrinsic_trim): Likewise\n+\t(gfc_conv_intrinsic_repeat): Likewise\n+\t(conv_isocbinding_function): Likewise\n+\t(conv_intrinsic_ieee_is_normal): Likewise\n+\t(conv_intrinsic_ieee_is_negative): Likewise\n+\t(conv_intrinsic_ieee_copy_sign): Likewise\n+\t(conv_intrinsic_move_alloc): Likewise\n+\t* trans-io.c (set_parameter_value_chk): Likewise\n+\t(set_parameter_value_inquire): Likewise\n+\t(set_string): Likewise\n+\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise\n+\t(gfc_omp_clause_default_ctor): Likewise\n+\t(gfc_omp_clause_copy_ctor): Likewise\n+\t(gfc_omp_clause_assign_op): Likewise\n+\t(gfc_omp_clause_dtor): Likewise\n+\t(gfc_omp_finish_clause): Likewise\n+\t(gfc_trans_omp_clauses): Likewise\n+\t(gfc_trans_omp_do): Likewise\n+\t* trans-stmt.c (gfc_trans_goto): Likewise\n+\t(gfc_trans_sync): Likewise\n+\t(gfc_trans_arithmetic_if): Likewise\n+\t(gfc_trans_simple_do): Likewise\n+\t(gfc_trans_do): Likewise\n+\t(gfc_trans_forall_loop): Likewise\n+\t(gfc_trans_where_2): Likewise\n+\t(gfc_trans_allocate): Likewise\n+\t(gfc_trans_deallocate): Likewise\n+\t* trans-types.c (gfc_init_types): Initialize logical_type_node and\n+\ttheir true/false trees.\n+\t(gfc_get_array_descr_info): Use logical_type_node.\n+\t* trans-types.h (logical_type_node): New tree.\n+\t(logical_true_node): Likewise.\n+\t(logical_false_node): Likewise.\n+\t* trans.c (gfc_trans_runtime_check): Use logical_type_node.\n+\t(gfc_call_malloc): Likewise\n+\t(gfc_allocate_using_malloc): Likewise\n+\t(gfc_allocate_allocatable): Likewise\n+\t(gfc_add_comp_finalizer_call): Likewise\n+\t(gfc_add_finalizer_call): Likewise\n+\t(gfc_deallocate_with_status): Likewise\n+\t(gfc_deallocate_scalar_with_status): Likewise\n+\t(gfc_call_realloc): Likewise\n+\n+2017-11-06  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69739\n \t* trans-expr.c (gfc_map_intrinsic_function): Return false for"}, {"sha": "13bff7345aa8e02dd6790a2931ee5038592298cb", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -29,36 +29,44 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"convert.h\"\n \n+#include \"gfortran.h\"\n+#include \"trans.h\"\n+#include \"trans-types.h\"\n+\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n    or validate its data type for a GIMPLE `if' or `while' statement.\n \n-   The resulting type should always be `boolean_type_node'.  */\n+   The resulting type should always be `logical_type_node'.  */\n \n static tree\n truthvalue_conversion (tree expr)\n {\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case BOOLEAN_TYPE:\n-      if (TREE_TYPE (expr) == boolean_type_node)\n+      if (TREE_TYPE (expr) == logical_type_node)\n \treturn expr;\n       else if (COMPARISON_CLASS_P (expr))\n \t{\n-\t  TREE_TYPE (expr) = boolean_type_node;\n+\t  TREE_TYPE (expr) = logical_type_node;\n \t  return expr;\n \t}\n       else if (TREE_CODE (expr) == NOP_EXPR)\n         return fold_build1_loc (input_location, NOP_EXPR,\n-\t\t\t    boolean_type_node, TREE_OPERAND (expr, 0));\n+\t\t\t\tlogical_type_node,\n+\t\t\t\tTREE_OPERAND (expr, 0));\n       else\n-        return fold_build1_loc (input_location, NOP_EXPR, boolean_type_node,\n+        return fold_build1_loc (input_location, NOP_EXPR,\n+\t\t\t\tlogical_type_node,\n \t\t\t\texpr);\n \n     case INTEGER_TYPE:\n       if (TREE_CODE (expr) == INTEGER_CST)\n-\treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n+\treturn integer_zerop (expr) ? logical_false_node\n+\t  : logical_true_node;\n       else\n-        return fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+        return fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\tlogical_type_node,\n \t\t\t\texpr, build_int_cst (TREE_TYPE (expr), 0));\n \n     default:"}, {"sha": "93ce68e2a524f34357ad6014c80dc5fbac0e80f5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -1034,7 +1034,7 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t      gfc_add_expr_to_block (&do_copying, tmp);\n \n \t      was_packed = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\t    boolean_type_node, packed,\n+\t\t\t\t\t    logical_type_node, packed,\n \t\t\t\t\t    source_data);\n \t      tmp = gfc_finish_block (&do_copying);\n \t      tmp = build3_v (COND_EXPR, was_packed, tmp,\n@@ -1302,15 +1302,15 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t\t\t\t to[n], gfc_index_one_node);\n \n \t  /* Check whether the size for this dimension is negative.  */\n-\t  cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t\t  tmp, gfc_index_zero_node);\n \t  cond = gfc_evaluate_now (cond, pre);\n \n \t  if (n == 0)\n \t    or_expr = cond;\n \t  else\n \t    or_expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t       boolean_type_node, or_expr, cond);\n+\t\t\t\t       logical_type_node, or_expr, cond);\n \n \t  size = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t  gfc_array_index_type, size, tmp);\n@@ -1570,7 +1570,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t      /* Verify that all constructor elements are of the same\n \t\t length.  */\n \t      tree cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node, first_len_val,\n+\t\t\t\t\t   logical_type_node, first_len_val,\n \t\t\t\t\t   se->string_length);\n \t      gfc_trans_runtime_check\n \t\t(true, false, cond, &se->pre, &expr->where,\n@@ -1912,14 +1912,14 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  /* Generate the exit condition.  Depending on the sign of\n \t     the step variable we have to generate the correct\n \t     comparison.  */\n-\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t\t step, build_int_cst (TREE_TYPE (step), 0));\n \t  cond = fold_build3_loc (input_location, COND_EXPR,\n-\t\t      boolean_type_node, tmp,\n+\t\t      logical_type_node, tmp,\n \t\t      fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t       boolean_type_node, shadow_loopvar, end),\n+\t\t\t\t       logical_type_node, shadow_loopvar, end),\n \t\t      fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t       boolean_type_node, shadow_loopvar, end));\n+\t\t\t\t       logical_type_node, shadow_loopvar, end));\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n \t  tmp = build3_v (COND_EXPR, cond, tmp,\n@@ -2427,7 +2427,7 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t  /* Check if the character length is negative.  If it is, then\n \t     set LEN = 0.  */\n \t  neg_len = fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t     boolean_type_node, ss_info->string_length,\n+\t\t\t\t     logical_type_node, ss_info->string_length,\n \t\t\t\t     build_int_cst (gfc_charlen_type_node, 0));\n \t  /* Print a warning if bounds checking is enabled.  */\n \t  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n@@ -3065,13 +3065,13 @@ trans_array_bound_check (gfc_se * se, gfc_ss *ss, tree index, int n,\n \tmsg = xasprintf (\"Index '%%ld' of dimension %d \"\n \t\t\t \"outside of expected range (%%ld:%%ld)\", n+1);\n \n-      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      fault = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       index, tmp_lo);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp_lo),\n \t\t\t       fold_convert (long_integer_type_node, tmp_up));\n-      fault = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      fault = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t       index, tmp_up);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n@@ -3090,7 +3090,7 @@ trans_array_bound_check (gfc_se * se, gfc_ss *ss, tree index, int n,\n \tmsg = xasprintf (\"Index '%%ld' of dimension %d \"\n \t\t\t \"below lower bound of %%ld\", n+1);\n \n-      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      fault = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       index, tmp_lo);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n@@ -3597,7 +3597,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n \t      tmp = tmpse.expr;\n \t    }\n \n-\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  indexse.expr, tmp);\n \t  msg = xasprintf (\"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t   \"below lower bound of %%ld\", n+1, var_name);\n@@ -3622,7 +3622,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n \t\t}\n \n \t      cond = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t      boolean_type_node, indexse.expr, tmp);\n+\t\t\t\t      logical_type_node, indexse.expr, tmp);\n \t      msg = xasprintf (\"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t       \"above upper bound of %%ld\", n+1, var_name);\n \t      gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n@@ -3890,7 +3890,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       OMP_FOR_INIT (stmt) = init;\n       /* The exit condition.  */\n       TREE_VEC_ELT (cond, 0) = build2_loc (input_location, LE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   loop->loopvar[n], loop->to[n]);\n       SET_EXPR_LOCATION (TREE_VEC_ELT (cond, 0), input_location);\n       OMP_FOR_COND (stmt) = cond;\n@@ -3925,7 +3925,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n \n       /* The exit condition.  */\n       cond = fold_build2_loc (input_location, reverse_loop ? LT_EXPR : GT_EXPR,\n-\t\t\t  boolean_type_node, loop->loopvar[n], loop->to[n]);\n+\t\t\t  logical_type_node, loop->loopvar[n], loop->to[n]);\n       tmp = build1_v (GOTO_EXPR, exit_label);\n       TREE_USED (exit_label) = 1;\n       tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -4357,7 +4357,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\tcheck_upper = true;\n \n \t      /* Zero stride is not allowed.  */\n-\t      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t     info->stride[dim], gfc_index_zero_node);\n \t      msg = xasprintf (\"Zero stride is not allowed, for dimension %d \"\n \t\t\t       \"of array '%s'\", dim + 1, expr_name);\n@@ -4380,23 +4380,23 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      /* non_zerosized is true when the selected range is not\n \t\t empty.  */\n \t      stride_pos = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\tboolean_type_node, info->stride[dim],\n+\t\t\t\t\tlogical_type_node, info->stride[dim],\n \t\t\t\t\tgfc_index_zero_node);\n-\t      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t      tmp = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t\t     info->start[dim], end);\n \t      stride_pos = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t    boolean_type_node, stride_pos, tmp);\n+\t\t\t\t\t    logical_type_node, stride_pos, tmp);\n \n \t      stride_neg = fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t     boolean_type_node,\n+\t\t\t\t     logical_type_node,\n \t\t\t\t     info->stride[dim], gfc_index_zero_node);\n-\t      tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t      tmp = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t\t     info->start[dim], end);\n \t      stride_neg = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    logical_type_node,\n \t\t\t\t\t    stride_neg, tmp);\n \t      non_zerosized = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       logical_type_node,\n \t\t\t\t\t       stride_pos, stride_neg);\n \n \t      /* Check the start of the range against the lower and upper\n@@ -4406,16 +4406,16 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      if (check_upper)\n \t\t{\n \t\t  tmp = fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t logical_type_node,\n \t\t\t\t\t info->start[dim], lbound);\n \t\t  tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t logical_type_node,\n \t\t\t\t\t non_zerosized, tmp);\n \t\t  tmp2 = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  logical_type_node,\n \t\t\t\t\t  info->start[dim], ubound);\n \t\t  tmp2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  logical_type_node,\n \t\t\t\t\t  non_zerosized, tmp2);\n \t\t  msg = xasprintf (\"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t\t   \"outside of expected range (%%ld:%%ld)\",\n@@ -4435,10 +4435,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      else\n \t\t{\n \t\t  tmp = fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t logical_type_node,\n \t\t\t\t\t info->start[dim], lbound);\n \t\t  tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t boolean_type_node, non_zerosized, tmp);\n+\t\t\t\t\t logical_type_node, non_zerosized, tmp);\n \t\t  msg = xasprintf (\"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t\t   \"below lower bound of %%ld\",\n \t\t\t\t   dim + 1, expr_name);\n@@ -4462,15 +4462,15 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t     gfc_array_index_type, end, tmp);\n \t      tmp2 = fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t      boolean_type_node, tmp, lbound);\n+\t\t\t\t      logical_type_node, tmp, lbound);\n \t      tmp2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t      boolean_type_node, non_zerosized, tmp2);\n+\t\t\t\t      logical_type_node, non_zerosized, tmp2);\n \t      if (check_upper)\n \t\t{\n \t\t  tmp3 = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\t  boolean_type_node, tmp, ubound);\n+\t\t\t\t\t  logical_type_node, tmp, ubound);\n \t\t  tmp3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t\t  boolean_type_node, non_zerosized, tmp3);\n+\t\t\t\t\t  logical_type_node, non_zerosized, tmp3);\n \t\t  msg = xasprintf (\"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t\t   \"outside of expected range (%%ld:%%ld)\",\n \t\t\t\t   dim + 1, expr_name);\n@@ -4516,7 +4516,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      if (size[n])\n \t\t{\n \t\t  tmp3 = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t  boolean_type_node, tmp, size[n]);\n+\t\t\t\t\t  logical_type_node, tmp, size[n]);\n \t\t  msg = xasprintf (\"Array bound mismatch for dimension %d \"\n \t\t\t\t   \"of array '%s' (%%ld/%%ld)\",\n \t\t\t\t   dim + 1, expr_name);\n@@ -5203,15 +5203,15 @@ gfc_conv_array_extent_dim (tree lbound, tree ubound, tree* or_expr)\n \t\t\t gfc_index_one_node);\n \n   /* Check whether the size for this dimension is negative.  */\n-  cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, res,\n+  cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node, res,\n \t\t\t  gfc_index_zero_node);\n   res = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type, cond,\n \t\t\t gfc_index_zero_node, res);\n \n   /* Build OR expression.  */\n   if (or_expr)\n     *or_expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\tboolean_type_node, *or_expr, cond);\n+\t\t\t\tlogical_type_node, *or_expr, cond);\n \n   return res;\n }\n@@ -5340,7 +5340,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       gfc_add_modify (pblock, tmp, gfc_get_dtype (type));\n     }\n \n-  or_expr = boolean_false_node;\n+  or_expr = logical_false_node;\n \n   for (n = 0; n < rank; n++)\n     {\n@@ -5448,12 +5448,12 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t\t\t\t   TYPE_MAX_VALUE (gfc_array_index_type)),\n \t\t\t\t\t   size);\n       cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\t    boolean_type_node, tmp, stride),\n+\t\t\t\t\t    logical_type_node, tmp, stride),\n \t\t\t   PRED_FORTRAN_OVERFLOW);\n       tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t     integer_one_node, integer_zero_node);\n       cond = gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\t    boolean_type_node, size,\n+\t\t\t\t\t    logical_type_node, size,\n \t\t\t\t\t    gfc_index_zero_node),\n \t\t\t   PRED_FORTRAN_SIZE_ZERO);\n       tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n@@ -5549,12 +5549,12 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t\t size_type_node,\n \t\t\t TYPE_MAX_VALUE (size_type_node), element_size);\n   cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\tboolean_type_node, tmp, stride),\n+\t\t\t\t\tlogical_type_node, tmp, stride),\n \t\t       PRED_FORTRAN_OVERFLOW);\n   tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t integer_one_node, integer_zero_node);\n   cond = gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\tboolean_type_node, element_size,\n+\t\t\t\t\tlogical_type_node, element_size,\n \t\t\t\t\tbuild_int_cst (size_type_node, 0)),\n \t\t       PRED_FORTRAN_SIZE_ZERO);\n   tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n@@ -5812,7 +5812,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (dimension)\n     {\n       cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t   boolean_type_node, var_overflow, integer_zero_node),\n+\t\t\t   logical_type_node, var_overflow, integer_zero_node),\n \t\t\t   PRED_FORTRAN_OVERFLOW);\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\t     error, gfc_finish_block (&elseblock));\n@@ -5843,7 +5843,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (status != NULL_TREE)\n     {\n       cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t  boolean_type_node, status,\n+\t\t\t  logical_type_node, status,\n \t\t\t  build_int_cst (TREE_TYPE (status), 0));\n       gfc_add_expr_to_block (&se->pre,\n \t\t fold_build3_loc (input_location, COND_EXPR, void_type_node,\n@@ -6093,7 +6093,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n \t  /* Make sure that negative size arrays are translated\n \t     to being zero size.  */\n-\t  tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t\t stride, gfc_index_zero_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t gfc_array_index_type, tmp,\n@@ -6380,10 +6380,10 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       /* For non-constant shape arrays we only check if the first dimension\n \t is contiguous.  Repacking higher dimensions wouldn't gain us\n \t anything as we still don't know the array stride.  */\n-      partial = gfc_create_var (boolean_type_node, \"partial\");\n+      partial = gfc_create_var (logical_type_node, \"partial\");\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, tmp,\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, tmp,\n \t\t\t     gfc_index_one_node);\n       gfc_add_modify (&init, partial, tmp);\n     }\n@@ -6398,7 +6398,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       stride = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n       stride = gfc_evaluate_now (stride, &init);\n \n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t     stride, gfc_index_zero_node);\n       tmp = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n \t\t\t     tmp, gfc_index_one_node, stride);\n@@ -6639,7 +6639,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       else\n \ttmp = build_fold_indirect_ref_loc (input_location, dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t     tmp, tmpdesc);\n       stmtCleanup = build3_v (COND_EXPR, tmp, stmtCleanup,\n \t\t\t      build_empty_stmt (input_location));\n@@ -7922,12 +7922,12 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t desc);\n \t  tmp = gfc_conv_array_data (tmp);\n-\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n \n \t  if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n \t    tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t   boolean_type_node,\n+\t\t\t\t   logical_type_node,\n \t\t\t\t   gfc_conv_expr_present (sym), tmp);\n \n \t  gfc_trans_runtime_check (false, true, tmp, &se->pre,\n@@ -7957,12 +7957,12 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n       tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     desc);\n       tmp = gfc_conv_array_data (tmp);\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t     fold_convert (TREE_TYPE (tmp), ptr), tmp);\n \n       if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n \ttmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t       boolean_type_node,\n+\t\t\t       logical_type_node,\n \t\t\t       gfc_conv_expr_present (sym), tmp);\n \n       tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n@@ -8101,7 +8101,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n     null_cond = gfc_conv_descriptor_data_get (src);\n \n   null_cond = convert (pvoid_type_node, null_cond);\n-  null_cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  null_cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       null_cond, null_pointer_node);\n   return build3_v (COND_EXPR, null_cond, tmp, null_data);\n }\n@@ -8235,7 +8235,7 @@ duplicate_allocatable_coarray (tree dest, tree dest_tok, tree src,\n     null_cond = gfc_conv_descriptor_data_get (src);\n \n   null_cond = convert (pvoid_type_node, null_cond);\n-  null_cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  null_cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       null_cond, null_pointer_node);\n   gfc_add_expr_to_block (&globalblock, build3_v (COND_EXPR, null_cond, tmp,\n \t\t\t\t\t\t null_data));\n@@ -8350,7 +8350,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  null_cond = gfc_conv_descriptor_data_get (decl);\n \t  null_cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t       boolean_type_node, null_cond,\n+\t\t\t\t       logical_type_node, null_cond,\n \t\t\t\t       build_int_cst (TREE_TYPE (null_cond), 0));\n \t}\n       else\n@@ -8601,7 +8601,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t\t\t    dealloc_fndecl);\n \t      tmp = build_int_cst (TREE_TYPE (comp), 0);\n \t      is_allocated = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t      boolean_type_node, tmp,\n+\t\t\t\t\t      logical_type_node, tmp,\n \t\t\t\t\t      comp);\n \t      cdesc = gfc_build_addr_expr (NULL_TREE, cdesc);\n \n@@ -8881,7 +8881,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      null_data = gfc_finish_block (&tmpblock);\n \n \t      null_cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node, src_data,\n+\t\t\t\t\t   logical_type_node, src_data,\n \t\t\t\t           null_pointer_node);\n \n \t      gfc_add_expr_to_block (&fnblock, build3_v (COND_EXPR, null_cond,\n@@ -9143,7 +9143,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    {\n \t      tmp = gfc_conv_descriptor_data_get (comp);\n \t      null_cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node, tmp,\n+\t\t\t\t\t   logical_type_node, tmp,\n \t\t\t\t\t   build_int_cst (TREE_TYPE (tmp), 0));\n \t      tmp = gfc_call_free (tmp);\n \t      tmp = build3_v (COND_EXPR, null_cond, tmp,\n@@ -9154,7 +9154,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  else if (c->attr.pdt_string)\n \t    {\n \t      null_cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node, comp,\n+\t\t\t\t\t   logical_type_node, comp,\n \t\t\t\t\t   build_int_cst (TREE_TYPE (comp), 0));\n \t      tmp = gfc_call_free (comp);\n \t      tmp = build3_v (COND_EXPR, null_cond, tmp,\n@@ -9201,7 +9201,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  tree error, cond, cname;\n \t\t  gfc_conv_expr_type (&tse, c_expr, TREE_TYPE (comp));\n \t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  logical_type_node,\n \t\t\t\t\t  comp, tse.expr);\n \t\t  cname = gfc_build_cstring_const (c->name);\n \t\t  cname = gfc_build_addr_expr (pchar_type_node, cname);\n@@ -9361,25 +9361,25 @@ get_std_lbound (gfc_expr *expr, tree desc, int dim, bool assumed_size)\n       lbound = gfc_conv_descriptor_lbound_get (desc, tmp);\n       ubound = gfc_conv_descriptor_ubound_get (desc, tmp);\n       stride = gfc_conv_descriptor_stride_get (desc, tmp);\n-      cond1 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+      cond1 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t       ubound, lbound);\n-      cond3 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+      cond3 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t       stride, gfc_index_zero_node);\n       cond3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t       boolean_type_node, cond3, cond1);\n-      cond4 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       logical_type_node, cond3, cond1);\n+      cond4 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       stride, gfc_index_zero_node);\n       if (assumed_size)\n-\tcond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\tcond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\ttmp, build_int_cst (gfc_array_index_type,\n \t\t\t\t\t\t    expr->rank - 1));\n       else\n-\tcond = boolean_false_node;\n+\tcond = logical_false_node;\n \n       cond1 = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t       boolean_type_node, cond3, cond4);\n+\t\t\t       logical_type_node, cond3, cond4);\n       cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t      boolean_type_node, cond, cond1);\n+\t\t\t      logical_type_node, cond, cond1);\n \n       return fold_build3_loc (input_location, COND_EXPR,\n \t\t\t      gfc_array_index_type, cond,\n@@ -9632,11 +9632,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   jump_label2 = gfc_build_label_decl (NULL_TREE);\n \n   /* Allocate if data is NULL.  */\n-  cond_null = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  cond_null = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t array1, build_int_cst (TREE_TYPE (array1), 0));\n \n   if (expr1->ts.deferred)\n-    cond_null = gfc_evaluate_now (boolean_true_node, &fblock);\n+    cond_null = gfc_evaluate_now (logical_true_node, &fblock);\n   else\n     cond_null= gfc_evaluate_now (cond_null, &fblock);\n \n@@ -9676,7 +9676,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t     gfc_array_index_type,\n \t\t\t     tmp, ubound);\n       cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t      boolean_type_node,\n+\t\t\t      logical_type_node,\n \t\t\t      tmp, gfc_index_zero_node);\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label1),\n@@ -9726,13 +9726,13 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n     }\n   size2 = gfc_evaluate_now (size2, &fblock);\n \n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t  size1, size2);\n \n   /* If the lhs is deferred length, assume that the element size\n      changes and force a reallocation.  */\n   if (expr1->ts.deferred)\n-    neq_size = gfc_evaluate_now (boolean_true_node, &fblock);\n+    neq_size = gfc_evaluate_now (logical_true_node, &fblock);\n   else\n     neq_size = gfc_evaluate_now (cond, &fblock);\n \n@@ -10012,7 +10012,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   /* Malloc if not allocated; realloc otherwise.  */\n   tmp = build_int_cst (TREE_TYPE (array1), 0);\n   cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t  boolean_type_node,\n+\t\t\t  logical_type_node,\n \t\t\t  array1, tmp);\n   tmp = build3_v (COND_EXPR, cond, alloc_expr, realloc_expr);\n   gfc_add_expr_to_block (&fblock, tmp);"}, {"sha": "8efaae79ebcdeecf0d666f0c3f83976440351e77", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -5784,7 +5784,7 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t/* Build the condition.  For optional arguments, an actual length\n \t   of 0 is also acceptable if the associated string is NULL, which\n \t   means the argument was not passed.  */\n-\tcond = fold_build2_loc (input_location, comparison, boolean_type_node,\n+\tcond = fold_build2_loc (input_location, comparison, logical_type_node,\n \t\t\t\tcl->passed_length, cl->backend_decl);\n \tif (fsym->attr.optional)\n \t  {\n@@ -5793,19 +5793,19 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t    tree absent_failed;\n \n \t    not_0length = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   cl->passed_length,\n \t\t\t\t\t   build_zero_cst (gfc_charlen_type_node));\n \t    /* The symbol needs to be referenced for gfc_get_symbol_decl.  */\n \t    fsym->attr.referenced = 1;\n \t    not_absent = gfc_conv_expr_present (fsym);\n \n \t    absent_failed = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t\t     boolean_type_node, not_0length,\n+\t\t\t\t\t     logical_type_node, not_0length,\n \t\t\t\t\t     not_absent);\n \n \t    cond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t    boolean_type_node, cond, absent_failed);\n+\t\t\t\t    logical_type_node, cond, absent_failed);\n \t  }\n \n \t/* Build the runtime check.  */\n@@ -6376,13 +6376,13 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n       msg = xasprintf (\"Recursive call to nonrecursive procedure '%s'\",\n \t\t       sym->name);\n-      recurcheckvar = gfc_create_var (boolean_type_node, \"is_recursive\");\n+      recurcheckvar = gfc_create_var (logical_type_node, \"is_recursive\");\n       TREE_STATIC (recurcheckvar) = 1;\n-      DECL_INITIAL (recurcheckvar) = boolean_false_node;\n+      DECL_INITIAL (recurcheckvar) = logical_false_node;\n       gfc_add_expr_to_block (&init, recurcheckvar);\n       gfc_trans_runtime_check (true, false, recurcheckvar, &init,\n \t\t\t       &sym->declared_at, msg);\n-      gfc_add_modify (&init, recurcheckvar, boolean_true_node);\n+      gfc_add_modify (&init, recurcheckvar, logical_true_node);\n       free (msg);\n     }\n \n@@ -6511,7 +6511,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n       && !is_recursive && !flag_openmp && recurcheckvar != NULL_TREE)\n     {\n-      gfc_add_modify (&cleanup, recurcheckvar, boolean_false_node);\n+      gfc_add_modify (&cleanup, recurcheckvar, logical_false_node);\n       recurcheckvar = NULL;\n     }\n "}, {"sha": "c5e1d72bd04bd2c14c29b413a9cd2fddc40ab939", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -1287,7 +1287,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \n \t  from_len = gfc_conv_descriptor_size (from_data, 1);\n \t  tmp = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  boolean_type_node, from_len, orig_nelems);\n+\t\t\t\t  logical_type_node, from_len, orig_nelems);\n \t  msg = xasprintf (\"Array bound mismatch for dimension %d \"\n \t\t\t   \"of array '%s' (%%ld/%%ld)\",\n \t\t\t   1, name);\n@@ -1338,7 +1338,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t  extcopy = gfc_finish_block (&ifbody);\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t logical_type_node, from_len,\n \t\t\t\t integer_zero_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n@@ -1366,7 +1366,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t  vec_safe_push (args, to_len);\n \t  extcopy = build_call_vec (fcn_type, fcn, args);\n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t logical_type_node, from_len,\n \t\t\t\t integer_zero_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n@@ -1380,7 +1380,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n     {\n       tree cond;\n       cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t      boolean_type_node,\n+\t\t\t      logical_type_node,\n \t\t\t      from_data, null_pointer_node);\n       tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t     void_type_node, cond,\n@@ -1425,7 +1425,7 @@ gfc_trans_class_array_init_assign (gfc_expr *rhs, gfc_expr *lhs, gfc_expr *obj)\n       gfc_init_se (&src, NULL);\n       gfc_conv_expr (&src, rhs);\n       src.expr = gfc_build_addr_expr (NULL_TREE, src.expr);\n-      tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tree cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   src.expr, fold_convert (TREE_TYPE (src.expr),\n \t\t\t\t\t\t\t   null_pointer_node));\n       res = build3_loc (input_location, COND_EXPR, TREE_TYPE (res), cond, res,\n@@ -1492,7 +1492,7 @@ gfc_trans_class_init_assign (gfc_code *code)\n \t{\n \t  /* Check if _def_init is non-NULL. */\n \t  tree cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t       boolean_type_node, src.expr,\n+\t\t\t\t       logical_type_node, src.expr,\n \t\t\t\t       fold_convert (TREE_TYPE (src.expr),\n \t\t\t\t\t\t     null_pointer_node));\n \t  tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp), cond,\n@@ -1662,7 +1662,7 @@ gfc_conv_expr_present (gfc_symbol * sym)\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n \n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, decl,\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node, decl,\n \t\t\t  fold_convert (TREE_TYPE (decl), null_pointer_node));\n \n   /* Fortran 2008 allows to pass null pointers and non-associated pointers\n@@ -1699,10 +1699,10 @@ gfc_conv_expr_present (gfc_symbol * sym)\n \n       if (tmp != NULL_TREE)\n \t{\n-\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node, tmp,\n \t\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n \t  cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond, tmp);\n+\t\t\t\t  logical_type_node, cond, tmp);\n \t}\n     }\n \n@@ -2264,15 +2264,15 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n     {\n       tree nonempty = fold_build2_loc (input_location, LE_EXPR,\n-\t\t\t\t       boolean_type_node, start.expr,\n+\t\t\t\t       logical_type_node, start.expr,\n \t\t\t\t       end.expr);\n \n       /* Check lower bound.  */\n-      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      fault = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       start.expr,\n \t\t\t       build_int_cst (gfc_charlen_type_node, 1));\n       fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t       boolean_type_node, nonempty, fault);\n+\t\t\t       logical_type_node, nonempty, fault);\n       if (name)\n \tmsg = xasprintf (\"Substring out of bounds: lower bound (%%ld) of '%s' \"\n \t\t\t \"is less than one\", name);\n@@ -2285,10 +2285,10 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       free (msg);\n \n       /* Check upper bound.  */\n-      fault = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      fault = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t       end.expr, se->string_length);\n       fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t       boolean_type_node, nonempty, fault);\n+\t\t\t       logical_type_node, nonempty, fault);\n       if (name)\n \tmsg = xasprintf (\"Substring out of bounds: upper bound (%%ld) of '%s' \"\n \t\t\t \"exceeds string length (%%ld)\", name);\n@@ -2890,17 +2890,17 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   /* If rhs < 0 and lhs is an integer, the result is -1, 0 or 1.  */\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t     lhs, build_int_cst (TREE_TYPE (lhs), -1));\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t      lhs, build_int_cst (TREE_TYPE (lhs), 1));\n \n       /* If rhs is even,\n \t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n \t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t boolean_type_node, tmp, cond);\n+\t\t\t\t logical_type_node, tmp, cond);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR, type,\n \t\t\t\t      tmp, build_int_cst (type, 1),\n \t\t\t\t      build_int_cst (type, 0));\n@@ -3386,8 +3386,8 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n \n   if (lop)\n     {\n-      /* The result of logical ops is always boolean_type_node.  */\n-      tmp = fold_build2_loc (input_location, code, boolean_type_node,\n+      /* The result of logical ops is always logical_type_node.  */\n+      tmp = fold_build2_loc (input_location, code, logical_type_node,\n \t\t\t     lse.expr, rse.expr);\n       se->expr = convert (type, tmp);\n     }\n@@ -4985,7 +4985,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tree descriptor_data;\n \n \t      descriptor_data = ss->info->data.array.data;\n-\t      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t     descriptor_data,\n \t\t\t\t     fold_convert (TREE_TYPE (descriptor_data),\n \t\t\t\t\t\t   null_pointer_node));\n@@ -5149,7 +5149,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  tree cond;\n \t\t\t  tmp = gfc_build_addr_expr (NULL_TREE, parmse.expr);\n \t\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t\t  boolean_type_node, tmp,\n+\t\t\t\t\t\t  logical_type_node, tmp,\n \t\t\t\t\t\t  fold_convert (TREE_TYPE (tmp),\n \t\t\t\t\t\t\t    null_pointer_node));\n \t\t\t  gfc_start_block (&block);\n@@ -5681,16 +5681,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      present = gfc_conv_expr_present (e->symtree->n.sym);\n \t      type = TREE_TYPE (present);\n \t      present = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\t boolean_type_node, present,\n+\t\t\t\t\t logical_type_node, present,\n \t\t\t\t\t fold_convert (type,\n \t\t\t\t\t\t       null_pointer_node));\n \t      type = TREE_TYPE (parmse.expr);\n \t      null_ptr = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t\t  boolean_type_node, parmse.expr,\n+\t\t\t\t\t  logical_type_node, parmse.expr,\n \t\t\t\t\t  fold_convert (type,\n \t\t\t\t\t\t\tnull_pointer_node));\n \t      cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n-\t\t\t\t      boolean_type_node, present, null_ptr);\n+\t\t\t\t      logical_type_node, present, null_ptr);\n \t    }\n           else\n \t    {\n@@ -5717,7 +5717,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\ttmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \n \t      cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t      boolean_type_node, tmp,\n+\t\t\t\t      logical_type_node, tmp,\n \t\t\t\t      fold_convert (TREE_TYPE (tmp),\n \t\t\t\t\t\t    null_pointer_node));\n \t    }\n@@ -6213,7 +6213,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t     happen in a function returning a pointer.  */\n \t\t  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n \t\t  tmp = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t logical_type_node,\n \t\t\t\t\t tmp, info->data);\n \t\t  gfc_trans_runtime_check (true, false, tmp, &se->pre, NULL,\n \t\t\t\t\t   gfc_msg_fault);\n@@ -6339,7 +6339,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  final_fndecl = gfc_class_vtab_final_get (se->expr);\n \t  is_final = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t      boolean_type_node,\n+\t\t\t\t      logical_type_node,\n  \t\t\t    \t      final_fndecl,\n \t\t\t\t      fold_convert (TREE_TYPE (final_fndecl),\n \t\t\t\t\t   \t    null_pointer_node));\n@@ -6413,7 +6413,7 @@ fill_with_spaces (tree start, tree type, tree size)\n   gfc_init_block (&loop);\n \n   /* Exit condition.  */\n-  cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, i,\n+  cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node, i,\n \t\t\t  build_zero_cst (sizetype));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n@@ -6506,7 +6506,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   */\n \n   /* Do nothing if the destination length is zero.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, dlen,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node, dlen,\n \t\t\t  build_int_cst (size_type_node, 0));\n \n   /* For non-default character kinds, we have to multiply the string\n@@ -6542,7 +6542,7 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   gfc_add_expr_to_block (&tmpblock2, tmp2);\n \n   /* If the destination is longer, fill the end with spaces.  */\n-  cond2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, slen,\n+  cond2 = fold_build2_loc (input_location, LT_EXPR, logical_type_node, slen,\n \t\t\t   dlen);\n \n   /* Wstringop-overflow appears at -O3 even though this warning is not\n@@ -7127,7 +7127,7 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \t\t\t\t\tnull_pointer_node);\n \t  null_expr = gfc_finish_block (&block);\n \t  tmp = gfc_conv_descriptor_data_get (arg->symtree->n.sym->backend_decl);\n-\t  tmp = build2_loc (input_location, EQ_EXPR, boolean_type_node, tmp,\n+\t  tmp = build2_loc (input_location, EQ_EXPR, logical_type_node, tmp,\n \t\t\t    fold_convert (TREE_TYPE (tmp), null_pointer_node));\n \t  return build3_v (COND_EXPR, tmp,\n \t\t\t   null_expr, non_null_expr);\n@@ -8684,7 +8684,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n \t  lsize = gfc_evaluate_now (lsize, &block);\n \t  rsize = gfc_evaluate_now (rsize, &block);\n-\t  fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  fault = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t   rsize, lsize);\n \n \t  msg = _(\"Target of rank remapping is too small (%ld < %ld)\");\n@@ -8803,7 +8803,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       /* Are the rhs and the lhs the same?  */\n       if (deep_copy)\n \t{\n-\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t  gfc_build_addr_expr (NULL_TREE, lse->expr),\n \t\t\t\t  gfc_build_addr_expr (NULL_TREE, rse->expr));\n \t  cond = gfc_evaluate_now (cond, &lse->pre);\n@@ -9078,7 +9078,7 @@ fcncall_realloc_result (gfc_se *se, int rank)\n      the lhs descriptor.  */\n   tmp = gfc_conv_descriptor_data_get (desc);\n   zero_cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t       boolean_type_node, tmp,\n+\t\t\t       logical_type_node, tmp,\n \t\t\t       build_int_cst (TREE_TYPE (tmp), 0));\n   zero_cond = gfc_evaluate_now (zero_cond, &se->post);\n   tmp = gfc_call_free (tmp);\n@@ -9102,11 +9102,11 @@ fcncall_realloc_result (gfc_se *se, int rank)\n       tmp = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t     gfc_array_index_type, tmp, tmp1);\n       tmp = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t     boolean_type_node, tmp,\n+\t\t\t     logical_type_node, tmp,\n \t\t\t     gfc_index_zero_node);\n       tmp = gfc_evaluate_now (tmp, &se->post);\n       zero_cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t   boolean_type_node, tmp,\n+\t\t\t\t   logical_type_node, tmp,\n \t\t\t\t   zero_cond);\n     }\n \n@@ -9545,7 +9545,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \n   /* Do the allocation if the lhs is NULL. Otherwise go to label 1.  */\n   tmp = build_int_cst (TREE_TYPE (lse.expr), 0);\n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t  lse.expr, tmp);\n   tmp = build3_v (COND_EXPR, cond,\n \t\t  build1_v (GOTO_EXPR, jump_label1),\n@@ -9623,7 +9623,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n      rhs are different.  */\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t      lse.string_length, size);\n       /* Jump past the realloc if the lengths are the same.  */\n       tmp = build3_v (COND_EXPR, cond,\n@@ -9769,7 +9769,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n       gfc_init_block (&alloc);\n       gfc_allocate_using_malloc (&alloc, class_han, tmp, NULL_TREE);\n       tmp = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t     boolean_type_node, class_han,\n+\t\t\t     logical_type_node, class_han,\n \t\t\t     build_int_cst (prvoid_type_node, 0));\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t     gfc_unlikely (tmp,\n@@ -9822,7 +9822,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \t  extcopy = build_call_vec (TREE_TYPE (TREE_TYPE (fcn)), fcn, args);\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t logical_type_node, from_len,\n \t\t\t\t integer_zero_node);\n \t  return fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t  void_type_node, tmp,\n@@ -10051,7 +10051,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  if (TREE_CODE (lse.expr) == ARRAY_REF)\n \t    tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n \n-\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), 0));\n \t  msg = _(\"Assignment of scalar to unallocated array\");\n \t  gfc_trans_runtime_check (true, false, cond, &loop.pre,"}, {"sha": "ed4496c845df88753fd4e592677c42a7fcb134b7", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 134, "deletions": 134, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -358,7 +358,7 @@ build_fixbound_expr (stmtblock_t * pblock, tree arg, tree type, int up)\n \n   tmp = convert (argtype, intval);\n   cond = fold_build2_loc (input_location, up ? GE_EXPR : LE_EXPR,\n-\t\t\t  boolean_type_node, tmp, arg);\n+\t\t\t  logical_type_node, tmp, arg);\n \n   tmp = fold_build2_loc (input_location, up ? PLUS_EXPR : MINUS_EXPR, type,\n \t\t\t intval, build_int_cst (type, 1));\n@@ -490,14 +490,14 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   n = gfc_validate_kind (BT_INTEGER, kind, false);\n   mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind, 0);\n-  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, arg[0],\n+  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node, arg[0],\n \t\t\t  tmp);\n \n   mpfr_neg (huge, huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind, 0);\n-  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, arg[0],\n+  tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node, arg[0],\n \t\t\t tmp);\n-  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR, logical_type_node,\n \t\t\t  cond, tmp);\n   itype = gfc_get_int_type (kind);\n \n@@ -885,7 +885,7 @@ gfc_trans_same_strlen_check (const char* intr_name, locus* where,\n     return;\n \n   /* Compare the two string lengths.  */\n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, a, b);\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node, a, b);\n \n   /* Output the runtime-check.  */\n   name = gfc_build_cstring_const (intr_name);\n@@ -1961,7 +1961,7 @@ conv_caf_send (gfc_code *code) {\n \t\t\t\t    TYPE_SIZE_UNIT (\n \t\t\t\t       gfc_typenode_for_spec (&lhs_expr->ts)),\n \t\t\t\t    NULL_TREE);\n-\t  tmp = fold_build2 (EQ_EXPR, boolean_type_node, scal_se.expr,\n+\t  tmp = fold_build2 (EQ_EXPR, logical_type_node, scal_se.expr,\n \t\t\t     null_pointer_node);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t tmp, gfc_finish_block (&scal_se.pre),\n@@ -2254,14 +2254,14 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n      else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n \t{\n \t  dim_arg = gfc_evaluate_now (dim_arg, &se->pre);\n-\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  dim_arg,\n \t\t\t\t  build_int_cst (TREE_TYPE (dim_arg), 1));\n \t  tmp = gfc_rank_cst[GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))];\n-\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t\t dim_arg, tmp);\n \t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond, tmp);\n+\t\t\t\t  logical_type_node, cond, tmp);\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t           gfc_msg_fault);\n \t}\n@@ -2352,7 +2352,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \t\t\t  m, extent));\n \n   /* Exit condition:  if (i >= min_var) goto exit_label.  */\n-  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, loop_var,\n+  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, loop_var,\n \t\t  min_var);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n@@ -2377,7 +2377,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n   /*  sub(co_dim) = (co_dim < corank) ? ml - m*extent + lcobound(dim_arg)\n \t\t\t\t      : m + lcobound(corank) */\n \n-  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, dim_arg,\n+  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node, dim_arg,\n \t\t\t  build_int_cst (TREE_TYPE (dim_arg), corank));\n \n   lbound = gfc_conv_descriptor_lbound_get (desc,\n@@ -2415,7 +2415,7 @@ conv_intrinsic_image_status (gfc_se *se, gfc_expr *expr)\n     {\n       tree arg;\n       arg = gfc_evaluate_now (args[0], &se->pre);\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t     fold_convert (integer_type_node, arg),\n \t\t\t     integer_one_node);\n       tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n@@ -2466,7 +2466,7 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \n   lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[rank+corank-1]);\n   tmp = gfc_build_array_ref (subdesc, gfc_rank_cst[corank-1], NULL);\n-  invalid_bound = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+  invalid_bound = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t fold_convert (gfc_array_index_type, tmp),\n \t\t\t\t lbound);\n \n@@ -2475,16 +2475,16 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n       lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[codim]);\n       ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[codim]);\n       tmp = gfc_build_array_ref (subdesc, gfc_rank_cst[codim-rank], NULL);\n-      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t      fold_convert (gfc_array_index_type, tmp),\n \t\t\t      lbound);\n       invalid_bound = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t       boolean_type_node, invalid_bound, cond);\n-      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t\t       logical_type_node, invalid_bound, cond);\n+      cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t      fold_convert (gfc_array_index_type, tmp),\n \t\t\t      ubound);\n       invalid_bound = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t       boolean_type_node, invalid_bound, cond);\n+\t\t\t\t       logical_type_node, invalid_bound, cond);\n     }\n \n   invalid_bound = gfc_unlikely (invalid_bound, PRED_FORTRAN_INVALID_BOUND);\n@@ -2544,11 +2544,11 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n   tmp = gfc_create_var (type, NULL);\n   gfc_add_modify (&se->pre, tmp, coindex);\n \n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, tmp,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node, tmp,\n \t\t\t  num_images);\n-  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, logical_type_node,\n \t\t\t  cond,\n-\t\t\t  fold_convert (boolean_type_node, invalid_bound));\n+\t\t\t  fold_convert (logical_type_node, invalid_bound));\n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n \t\t\t      build_int_cst (type, 0), tmp);\n }\n@@ -2680,16 +2680,16 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n-          cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+          cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  bound, build_int_cst (TREE_TYPE (bound), 0));\n \t  if (as && as->type == AS_ASSUMED_RANK)\n \t    tmp = gfc_conv_descriptor_rank (desc);\n \t  else\n \t    tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n-          tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+          tmp = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t\t bound, fold_convert(TREE_TYPE (bound), tmp));\n           cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond, tmp);\n+\t\t\t\t  logical_type_node, cond, tmp);\n           gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t\t   gfc_msg_fault);\n         }\n@@ -2735,27 +2735,27 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n     {\n       tree stride = gfc_conv_descriptor_stride_get (desc, bound);\n \n-      cond1 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+      cond1 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t       ubound, lbound);\n-      cond3 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+      cond3 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t       stride, gfc_index_zero_node);\n       cond3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t       boolean_type_node, cond3, cond1);\n-      cond4 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       logical_type_node, cond3, cond1);\n+      cond4 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       stride, gfc_index_zero_node);\n \n       if (upper)\n \t{\n \t  tree cond5;\n \t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  boolean_type_node, cond3, cond4);\n-\t  cond5 = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  logical_type_node, cond3, cond4);\n+\t  cond5 = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t   gfc_index_one_node, lbound);\n \t  cond5 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t   boolean_type_node, cond4, cond5);\n+\t\t\t\t   logical_type_node, cond4, cond5);\n \n \t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  boolean_type_node, cond, cond5);\n+\t\t\t\t  logical_type_node, cond, cond5);\n \n \t  if (assumed_rank_lb_one)\n \t    {\n@@ -2774,16 +2774,16 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       else\n \t{\n \t  if (as->type == AS_ASSUMED_SIZE)\n-\t    cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t    cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t    bound, build_int_cst (TREE_TYPE (bound),\n \t\t\t\t\t\t\t  arg->expr->rank - 1));\n \t  else\n-\t    cond = boolean_false_node;\n+\t    cond = logical_false_node;\n \n \t  cond1 = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t   boolean_type_node, cond3, cond4);\n+\t\t\t\t   logical_type_node, cond3, cond4);\n \t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  boolean_type_node, cond, cond1);\n+\t\t\t\t  logical_type_node, cond, cond1);\n \n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t      gfc_array_index_type, cond,\n@@ -2874,13 +2874,13 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n       else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n         {\n \t  bound = gfc_evaluate_now (bound, &se->pre);\n-\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  bound, build_int_cst (TREE_TYPE (bound), 1));\n \t  tmp = gfc_rank_cst[GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))];\n-\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t\t bound, tmp);\n \t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond, tmp);\n+\t\t\t\t  logical_type_node, cond, tmp);\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t\t   gfc_msg_fault);\n \t}\n@@ -2949,7 +2949,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \n       if (corank > 1)\n \t{\n-\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t  bound,\n \t\t\t\t  build_int_cst (TREE_TYPE (bound),\n \t\t\t\t\t\t arg->expr->rank + corank - 1));\n@@ -3138,16 +3138,16 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       tmp = gfc_evaluate_now (se->expr, &se->pre);\n       if (!flag_signed_zeros)\n \t{\n-\t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  test = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  args[0], zero);\n-\t  test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  test2 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t   args[1], zero);\n \t  test2 = fold_build2_loc (input_location, TRUTH_XOR_EXPR,\n-\t\t\t\t   boolean_type_node, test, test2);\n-\t  test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   logical_type_node, test, test2);\n+\t  test = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t  tmp, zero);\n \t  test = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t  boolean_type_node, test, test2);\n+\t\t\t\t  logical_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n \t\t\t\t      fold_build2_loc (input_location,\n@@ -3160,18 +3160,18 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t  tree expr1, copysign, cscall;\n \t  copysign = gfc_builtin_decl_for_float_kind (BUILT_IN_COPYSIGN,\n \t\t\t\t\t\t      expr->ts.kind);\n-\t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  test = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t  args[0], zero);\n-\t  test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  test2 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t   args[1], zero);\n \t  test2 = fold_build2_loc (input_location, TRUTH_XOR_EXPR,\n-\t\t\t\t   boolean_type_node, test, test2);\n+\t\t\t\t   logical_type_node, test, test2);\n \t  expr1 = fold_build3_loc (input_location, COND_EXPR, type, test2,\n \t\t\t\t   fold_build2_loc (input_location,\n \t\t\t\t\t\t    PLUS_EXPR,\n \t\t\t\t\t\t    type, tmp, args[1]),\n \t\t\t\t   tmp);\n-\t  test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  test = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t  tmp, zero);\n \t  cscall = build_call_expr_loc (input_location, copysign, 2, zero,\n \t\t\t\t\targs[1]);\n@@ -3227,12 +3227,12 @@ gfc_conv_intrinsic_dshift (gfc_se * se, gfc_expr * expr, bool dshiftl)\n   res = fold_build2_loc (input_location, BIT_IOR_EXPR, type, left, right);\n \n   /* Special cases.  */\n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, shift,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, shift,\n \t\t\t  build_int_cst (stype, 0));\n   res = fold_build3_loc (input_location, COND_EXPR, type, cond,\n \t\t\t dshiftl ? arg1 : arg2, res);\n \n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, shift,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, shift,\n \t\t\t  build_int_cst (stype, bitsize));\n   res = fold_build3_loc (input_location, COND_EXPR, type, cond,\n \t\t\t dshiftl ? arg2 : arg1, res);\n@@ -3259,7 +3259,7 @@ gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n-  tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, val, zero);\n+  tmp = fold_build2_loc (input_location, LE_EXPR, logical_type_node, val, zero);\n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, tmp, zero, val);\n }\n \n@@ -3292,7 +3292,7 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t{\n \t  tree cond, zero;\n \t  zero = build_real_from_int_cst (TREE_TYPE (args[1]), integer_zero_node);\n-\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t  args[1], zero);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t  TREE_TYPE (args[0]), cond,\n@@ -3413,7 +3413,7 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -3452,7 +3452,7 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -3662,7 +3662,7 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -3726,7 +3726,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n \tcond = fold_build2_loc (input_location,\n-\t\t\t\tNE_EXPR, boolean_type_node,\n+\t\t\t\tNE_EXPR, logical_type_node,\n \t\t\t\tTREE_OPERAND (val, 0),\n \t\t\tbuild_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n       else\n@@ -3740,7 +3740,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t     convert (type, val), mvar);\n \n       /* FIXME: When the IEEE_ARITHMETIC module is implemented, the call to\n@@ -3752,8 +3752,8 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t\t\t       builtin_decl_explicit (BUILT_IN_ISNAN),\n \t\t\t\t       1, mvar);\n \t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t boolean_type_node, tmp,\n-\t\t\t\t fold_convert (boolean_type_node, isnan));\n+\t\t\t\t logical_type_node, tmp,\n+\t\t\t\t fold_convert (logical_type_node, isnan));\n \t}\n       tmp = build3_v (COND_EXPR, tmp, thencase,\n \t\t      build_empty_stmt (input_location));\n@@ -3805,7 +3805,7 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -4005,7 +4005,7 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_expr_val (&arrayse, actual->expr);\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n-  tmp = fold_build2_loc (input_location, op, boolean_type_node, arrayse.expr,\n+  tmp = fold_build2_loc (input_location, op, logical_type_node, arrayse.expr,\n \t\t\t build_int_cst (TREE_TYPE (arrayse.expr), 0));\n   tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n@@ -4284,13 +4284,13 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n       gfc_add_modify (&ifblock3, resvar, res2);\n       res2 = gfc_finish_block (&ifblock3);\n \n-      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t      absX, scale);\n       tmp = build3_v (COND_EXPR, cond, res1, res2);\n       gfc_add_expr_to_block (&ifblock1, tmp);\n       tmp = gfc_finish_block (&ifblock1);\n \n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      arrayse.expr,\n \t\t\t      gfc_build_const (type, integer_zero_node));\n \n@@ -4596,7 +4596,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);\n \t  nonempty = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t      boolean_type_node, nonempty,\n+\t\t\t\t      logical_type_node, nonempty,\n \t\t\t\t      gfc_index_zero_node);\n \t}\n       maskss = NULL;\n@@ -4660,7 +4660,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   gcc_assert (loop.dimen == 1);\n   if (nonempty == NULL && maskss == NULL && loop.from[0] && loop.to[0])\n-    nonempty = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+    nonempty = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t\tloop.from[0], loop.to[0]);\n \n   lab1 = NULL;\n@@ -4736,7 +4736,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t\t\t     loop.loopvar[0], offset);\n       gfc_add_modify (&ifblock2, pos, tmp);\n       ifbody2 = gfc_finish_block (&ifblock2);\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pos,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, pos,\n \t\t\t      gfc_index_zero_node);\n       tmp = build3_v (COND_EXPR, cond, ifbody2,\n \t\t      build_empty_stmt (input_location));\n@@ -4757,9 +4757,9 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (lab1)\n \tcond = fold_build2_loc (input_location,\n \t\t\t\top == GT_EXPR ? GE_EXPR : LE_EXPR,\n-\t\t\t\tboolean_type_node, arrayse.expr, limit);\n+\t\t\t\tlogical_type_node, arrayse.expr, limit);\n       else\n-\tcond = fold_build2_loc (input_location, op, boolean_type_node,\n+\tcond = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t\tarrayse.expr, limit);\n \n       ifbody = build3_v (COND_EXPR, cond, ifbody,\n@@ -4830,7 +4830,7 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n       ifbody = gfc_finish_block (&ifblock);\n \n-      cond = fold_build2_loc (input_location, op, boolean_type_node,\n+      cond = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t      arrayse.expr, limit);\n \n       tmp = build3_v (COND_EXPR, cond, ifbody,\n@@ -5082,7 +5082,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);\n \t  nonempty = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t      boolean_type_node, nonempty,\n+\t\t\t\t      logical_type_node, nonempty,\n \t\t\t\t      gfc_index_zero_node);\n \t}\n       maskss = NULL;\n@@ -5116,15 +5116,15 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (nonempty == NULL && maskss == NULL\n       && loop.dimen == 1 && loop.from[0] && loop.to[0])\n-    nonempty = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+    nonempty = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t\tloop.from[0], loop.to[0]);\n   nonempty_var = NULL;\n   if (nonempty == NULL\n       && (HONOR_INFINITIES (DECL_MODE (limit))\n \t  || HONOR_NANS (DECL_MODE (limit))))\n     {\n-      nonempty_var = gfc_create_var (boolean_type_node, \"nonempty\");\n-      gfc_add_modify (&se->pre, nonempty_var, boolean_false_node);\n+      nonempty_var = gfc_create_var (logical_type_node, \"nonempty\");\n+      gfc_add_modify (&se->pre, nonempty_var, logical_false_node);\n       nonempty = nonempty_var;\n     }\n   lab = NULL;\n@@ -5138,8 +5138,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t}\n       else\n \t{\n-\t  fast = gfc_create_var (boolean_type_node, \"fast\");\n-\t  gfc_add_modify (&se->pre, fast, boolean_false_node);\n+\t  fast = gfc_create_var (logical_type_node, \"fast\");\n+\t  gfc_add_modify (&se->pre, fast, logical_false_node);\n \t}\n     }\n \n@@ -5173,12 +5173,12 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_init_block (&block2);\n \n   if (nonempty_var)\n-    gfc_add_modify (&block2, nonempty_var, boolean_true_node);\n+    gfc_add_modify (&block2, nonempty_var, logical_true_node);\n \n   if (HONOR_NANS (DECL_MODE (limit)))\n     {\n       tmp = fold_build2_loc (input_location, op == GT_EXPR ? GE_EXPR : LE_EXPR,\n-\t\t\t     boolean_type_node, arrayse.expr, limit);\n+\t\t\t     logical_type_node, arrayse.expr, limit);\n       if (lab)\n \tifbody = build1_v (GOTO_EXPR, lab);\n       else\n@@ -5187,7 +5187,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n \t  gfc_init_block (&ifblock);\n \t  gfc_add_modify (&ifblock, limit, arrayse.expr);\n-\t  gfc_add_modify (&ifblock, fast, boolean_true_node);\n+\t  gfc_add_modify (&ifblock, fast, logical_true_node);\n \t  ifbody = gfc_finish_block (&ifblock);\n \t}\n       tmp = build3_v (COND_EXPR, tmp, ifbody,\n@@ -5200,7 +5200,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t signed zeros.  */\n       if (HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n@@ -5225,7 +5225,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (HONOR_NANS (DECL_MODE (limit))\n \t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  ifbody = build3_v (COND_EXPR, tmp, ifbody,\n@@ -5288,7 +5288,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (HONOR_NANS (DECL_MODE (limit))\n \t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n@@ -5378,7 +5378,7 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n \t\t\t build_int_cst (type, 1), args[1]);\n   tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type, args[0], tmp);\n-  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node, tmp,\n \t\t\t build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, tmp);\n@@ -5406,7 +5406,7 @@ gfc_conv_intrinsic_bitcomp (gfc_se * se, gfc_expr * expr, enum tree_code op)\n     args[0] = fold_convert (TREE_TYPE (args[1]), args[0]);\n \n   /* Now, we compare them.  */\n-  se->expr = fold_build2_loc (input_location, op, boolean_type_node,\n+  se->expr = fold_build2_loc (input_location, op, logical_type_node,\n \t\t\t      args[0], args[1]);\n }\n \n@@ -5507,7 +5507,7 @@ gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n-  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t  args[1], num_bits);\n \n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n@@ -5553,15 +5553,15 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   rshift = fold_convert (type, fold_build2_loc (input_location, RSHIFT_EXPR,\n \t\t\t\t    utype, convert (utype, args[0]), width));\n \n-  tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, args[1],\n+  tmp = fold_build2_loc (input_location, GE_EXPR, logical_type_node, args[1],\n \t\t\t build_int_cst (TREE_TYPE (args[1]), 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, type, tmp, lshift, rshift);\n \n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n-  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, width,\n+  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, width,\n \t\t\t  num_bits);\n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n \t\t\t      build_int_cst (type, 0), tmp);\n@@ -5645,12 +5645,12 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   rrot = fold_build2_loc (input_location,RROTATE_EXPR, type, args[0], tmp);\n \n   zero = build_int_cst (TREE_TYPE (args[1]), 0);\n-  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, args[1],\n+  tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node, args[1],\n \t\t\t zero);\n   rrot = fold_build3_loc (input_location, COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, args[1],\n+  tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, args[1],\n \t\t\t zero);\n   se->expr = fold_build3_loc (input_location, COND_EXPR, type, tmp, args[0],\n \t\t\t      rrot);\n@@ -5748,7 +5748,7 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n \t\t\t      fold_convert (arg_type, ullmax), ullsize);\n       cond = fold_build2_loc (input_location, BIT_AND_EXPR, arg_type,\n \t\t\t      arg, cond);\n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      cond, build_int_cst (arg_type, 0));\n \n       tmp1 = fold_build2_loc (input_location, RSHIFT_EXPR, arg_type,\n@@ -5772,7 +5772,7 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n   /* Build BIT_SIZE.  */\n   bit_size = build_int_cst (result_type, argsize);\n \n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t  arg, build_int_cst (arg_type, 0));\n   se->expr = fold_build3_loc (input_location, COND_EXPR, result_type, cond,\n \t\t\t      bit_size, leadz);\n@@ -5857,7 +5857,7 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n \n       cond = fold_build2_loc (input_location, BIT_AND_EXPR, arg_type, arg,\n \t\t\t      fold_convert (arg_type, ullmax));\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, cond,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, cond,\n \t\t\t      build_int_cst (arg_type, 0));\n \n       tmp1 = fold_build2_loc (input_location, RSHIFT_EXPR, arg_type,\n@@ -5881,7 +5881,7 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n   /* Build BIT_SIZE.  */\n   bit_size = build_int_cst (result_type, argsize);\n \n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t  arg, build_int_cst (arg_type, 0));\n   se->expr = fold_build3_loc (input_location, COND_EXPR, result_type, cond,\n \t\t\t      bit_size, trailz);\n@@ -6314,7 +6314,7 @@ gfc_conv_intrinsic_mask (gfc_se * se, gfc_expr * expr, int left)\n \n       /* Special case arg == 0, because SHIFT_EXPR wants a shift strictly\n \t smaller than type width.  */\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, arg,\n \t\t\t      build_int_cst (TREE_TYPE (arg), 0));\n       res = fold_build3_loc (input_location, COND_EXPR, utype, cond,\n \t\t\t     build_int_cst (utype, 0), res);\n@@ -6328,7 +6328,7 @@ gfc_conv_intrinsic_mask (gfc_se * se, gfc_expr * expr, int left)\n \n       /* Special case agr == bit_size, because SHIFT_EXPR wants a shift\n \t strictly smaller than type width.  */\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t      arg, bitsize);\n       res = fold_build3_loc (input_location, COND_EXPR, utype,\n \t\t\t     cond, allones, res);\n@@ -6449,7 +6449,7 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n   gfc_add_modify (&block, res, tmp);\n \n   /* Finish by building the IF statement for value zero.  */\n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, arg,\n \t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, build2_v (MODIFY_EXPR, res, tiny),\n \t\t  gfc_finish_block (&block));\n@@ -6520,7 +6520,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n   stmt = gfc_finish_block (&block);\n \n   /* if (x != 0) */\n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, x,\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node, x,\n \t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, stmt, build_empty_stmt (input_location));\n \n@@ -6650,7 +6650,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n \t  argse.data_not_needed = 1;\n \t  gfc_conv_expr (&argse, actual->expr);\n \t  gfc_add_block_to_block (&se->pre, &argse.pre);\n-\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t argse.expr, null_pointer_node);\n \t  tmp = gfc_evaluate_now (tmp, &se->pre);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n@@ -6819,7 +6819,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n \t\t}\n \t      exit:  */\n \t  gfc_start_block (&body);\n-\t  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n \t\t\t\t  loop_var, tmp);\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n@@ -7090,7 +7090,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t  /* Clean up if it was repacked.  */\n \t  gfc_init_block (&block);\n \t  tmp = gfc_conv_array_data (argse.expr);\n-\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t source, tmp);\n \t  tmp = build3_v (COND_EXPR, tmp, stmt,\n \t\t\t  build_empty_stmt (input_location));\n@@ -7315,14 +7315,14 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       indirect = gfc_finish_block (&block);\n \n       /* Wrap it up with the condition.  */\n-      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t     dest_word_len, source_bytes);\n       tmp = build3_v (COND_EXPR, tmp, direct, indirect);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n       /* Free the temporary string, if necessary.  */\n       free = gfc_call_free (tmpdecl);\n-      tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t     dest_word_len, source_bytes);\n       tmp = build3_v (COND_EXPR, tmp, free, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se->post, tmp);\n@@ -7464,7 +7464,7 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n \t  tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n \t}\n \n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node, tmp,\n \t\t\t     fold_convert (TREE_TYPE (tmp), null_pointer_node));\n     }\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n@@ -7532,7 +7532,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n         }\n       gfc_add_block_to_block (&se->pre, &arg1se.pre);\n       gfc_add_block_to_block (&se->post, &arg1se.post);\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp2,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node, tmp2,\n \t\t\t     fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n       se->expr = tmp;\n     }\n@@ -7545,7 +7545,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n \tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n \t\t\t\t\t   integer_zero_node);\n       if (scalar)\n@@ -7570,12 +7570,12 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t  gfc_add_block_to_block (&se->post, &arg1se.post);\n \t  gfc_add_block_to_block (&se->pre, &arg2se.pre);\n \t  gfc_add_block_to_block (&se->post, &arg2se.post);\n-          tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+          tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t arg1se.expr, arg2se.expr);\n-          tmp2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+          tmp2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t  arg1se.expr, null_pointer_node);\n           se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t      boolean_type_node, tmp, tmp2);\n+\t\t\t\t      logical_type_node, tmp, tmp2);\n         }\n       else\n         {\n@@ -7593,7 +7593,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t    tmp = gfc_rank_cst[arg1->expr->rank - 1];\n \t  tmp = gfc_conv_descriptor_stride_get (arg1se.expr, tmp);\n \t  nonzero_arraylen = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t      boolean_type_node, tmp,\n+\t\t\t\t\t      logical_type_node, tmp,\n \t\t\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));\n \n           /* A pointer to an array, call library function _gfor_associated.  */\n@@ -7607,17 +7607,17 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           se->expr = build_call_expr_loc (input_location,\n \t\t\t\t      gfor_fndecl_associated, 2,\n \t\t\t\t      arg1se.expr, arg2se.expr);\n-\t  se->expr = convert (boolean_type_node, se->expr);\n+\t  se->expr = convert (logical_type_node, se->expr);\n \t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t      boolean_type_node, se->expr,\n+\t\t\t\t      logical_type_node, se->expr,\n \t\t\t\t      nonzero_arraylen);\n         }\n \n       /* If target is present zero character length pointers cannot\n \t be associated.  */\n       if (nonzero_charlen != NULL_TREE)\n \tse->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t    boolean_type_node,\n+\t\t\t\t    logical_type_node,\n \t\t\t\t    se->expr, nonzero_charlen);\n     }\n \n@@ -7645,14 +7645,14 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   if (UNLIMITED_POLY (a))\n     {\n       tmp = gfc_class_vptr_get (a->symtree->n.sym->backend_decl);\n-      conda = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      conda = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       tmp, build_int_cst (TREE_TYPE (tmp), 0));\n     }\n \n   if (UNLIMITED_POLY (b))\n     {\n       tmp = gfc_class_vptr_get (b->symtree->n.sym->backend_decl);\n-      condb = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      condb = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       tmp, build_int_cst (TREE_TYPE (tmp), 0));\n     }\n \n@@ -7678,16 +7678,16 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr (&se2, b);\n \n   tmp = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t boolean_type_node, se1.expr,\n+\t\t\t logical_type_node, se1.expr,\n \t\t\t fold_convert (TREE_TYPE (se1.expr), se2.expr));\n \n   if (conda)\n     tmp = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t   boolean_type_node, conda, tmp);\n+\t\t\t   logical_type_node, conda, tmp);\n \n   if (condb)\n     tmp = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t   boolean_type_node, condb, tmp);\n+\t\t\t   logical_type_node, condb, tmp);\n \n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n@@ -7813,7 +7813,7 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n@@ -7847,7 +7847,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   ncopies_type = TREE_TYPE (ncopies);\n \n   /* Check that NCOPIES is not negative.  */\n-  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, ncopies,\n+  cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node, ncopies,\n \t\t\t  build_int_cst (ncopies_type, 0));\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative \"\n@@ -7857,7 +7857,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* If the source length is zero, any non negative value of NCOPIES\n      is valid, and nothing happens.  */\n   n = gfc_create_var (ncopies_type, \"ncopies\");\n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, slen,\n \t\t\t  build_int_cst (size_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, ncopies_type, cond,\n \t\t\t build_int_cst (ncopies_type, 0), ncopies);\n@@ -7874,13 +7874,13 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \t\t\t  fold_convert (size_type_node, max), slen);\n   largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n \t      ? size_type_node : ncopies_type;\n-  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  fold_convert (largest, ncopies),\n \t\t\t  fold_convert (largest, max));\n-  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n+  tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, slen,\n \t\t\t build_int_cst (size_type_node, 0));\n-  cond = fold_build3_loc (input_location, COND_EXPR, boolean_type_node, tmp,\n-\t\t\t  boolean_false_node, cond);\n+  cond = fold_build3_loc (input_location, COND_EXPR, logical_type_node, tmp,\n+\t\t\t  logical_false_node, cond);\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\");\n \n@@ -7903,7 +7903,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   gfc_start_block (&body);\n \n   /* Exit the loop if count >= ncopies.  */\n-  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, count,\n+  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, count,\n \t\t\t  ncopies);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n@@ -8052,7 +8052,7 @@ conv_isocbinding_function (gfc_se *se, gfc_expr *expr)\n       if (arg->next->expr == NULL)\n \t/* Only given one arg so generate a null and do a\n \t   not-equal comparison against the first arg.  */\n-\tse->expr = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\tse->expr = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t    arg1se.expr,\n \t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n \t\t\t\t\t\t  null_pointer_node));\n@@ -8068,17 +8068,17 @@ conv_isocbinding_function (gfc_se *se, gfc_expr *expr)\n \t  gfc_add_block_to_block (&se->post, &arg2se.post);\n \n \t  /* Generate test to compare that the two args are equal.  */\n-\t  eq_expr = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t  eq_expr = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t     arg1se.expr, arg2se.expr);\n \t  /* Generate test to ensure that the first arg is not null.  */\n \t  not_null_expr = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   arg1se.expr, null_pointer_node);\n \n \t  /* Finally, the generated test must check that both arg1 is not\n \t     NULL and that it is equal to the second arg.  */\n \t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t\t      boolean_type_node,\n+\t\t\t\t      logical_type_node,\n \t\t\t\t      not_null_expr, eq_expr);\n \t}\n     }\n@@ -8308,11 +8308,11 @@ conv_intrinsic_ieee_is_normal (gfc_se * se, gfc_expr * expr)\n   isnormal = build_call_expr_loc (input_location,\n \t\t\t\t  builtin_decl_explicit (BUILT_IN_ISNORMAL),\n \t\t\t\t  1, arg);\n-  iszero = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+  iszero = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, arg,\n \t\t\t    build_real_from_int_cst (TREE_TYPE (arg),\n \t\t\t\t\t\t     integer_zero_node));\n   se->expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t      boolean_type_node, isnormal, iszero);\n+\t\t\t      logical_type_node, isnormal, iszero);\n   se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n }\n \n@@ -8337,11 +8337,11 @@ conv_intrinsic_ieee_is_negative (gfc_se * se, gfc_expr * expr)\n   signbit = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_SIGNBIT),\n \t\t\t\t 1, arg);\n-  signbit = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  signbit = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t     signbit, integer_zero_node);\n \n   se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t      boolean_type_node, signbit,\n+\t\t\t      logical_type_node, signbit,\n \t\t\t      fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n \t\t\t\t\t       TREE_TYPE(isnan), isnan));\n \n@@ -8487,7 +8487,7 @@ conv_intrinsic_ieee_copy_sign (gfc_se * se, gfc_expr * expr)\n   sign = build_call_expr_loc (input_location,\n \t\t\t      builtin_decl_explicit (BUILT_IN_SIGNBIT),\n \t\t\t      1, args[1]);\n-  sign = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  sign = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t  sign, integer_zero_node);\n \n   /* Create a value of one, with the right sign.  */\n@@ -10553,7 +10553,7 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \n       tmp = gfc_conv_descriptor_data_get (to_se.expr);\n       cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t      boolean_type_node, tmp,\n+\t\t\t      logical_type_node, tmp,\n \t\t\t      fold_convert (TREE_TYPE (tmp),\n \t\t\t\t\t    null_pointer_node));\n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_all,"}, {"sha": "9cd33b331e19d2b76faba4ae31ca5db13133dd95", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -581,7 +581,7 @@ set_parameter_value_chk (stmtblock_t *block, bool has_iostat, tree var,\n       /* UNIT numbers should be greater than the min.  */\n       i = gfc_validate_kind (BT_INTEGER, 4, false);\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].pedantic_min_int, 4);\n-      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t      se.expr,\n \t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n       gfc_trans_io_runtime_check (has_iostat, cond, var, LIBERROR_BAD_UNIT,\n@@ -590,7 +590,7 @@ set_parameter_value_chk (stmtblock_t *block, bool has_iostat, tree var,\n \n       /* UNIT numbers should be less than the max.  */\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n-      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t      se.expr,\n \t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n       gfc_trans_io_runtime_check (has_iostat, cond, var, LIBERROR_BAD_UNIT,\n@@ -641,17 +641,17 @@ set_parameter_value_inquire (stmtblock_t *block, tree var,\n \n       /* UNIT numbers should be greater than zero.  */\n       i = gfc_validate_kind (BT_INTEGER, 4, false);\n-      cond1 = build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      cond1 = build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t  se.expr,\n \t\t\t  fold_convert (TREE_TYPE (se.expr),\n \t\t\t  integer_zero_node));\n       /* UNIT numbers should be less than the max.  */\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n-      cond2 = build2_loc (input_location, GT_EXPR, boolean_type_node,\n+      cond2 = build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  se.expr,\n \t\t\t  fold_convert (TREE_TYPE (se.expr), val));\n       cond3 = build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t  boolean_type_node, cond1, cond2);\n+\t\t\t  logical_type_node, cond1, cond2);\n \n       gfc_start_block (&newblock);\n \n@@ -826,7 +826,7 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \n       gfc_conv_label_variable (&se, e);\n       tmp = GFC_DECL_STRING_LEN (se.expr);\n-      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t      tmp, build_int_cst (TREE_TYPE (tmp), 0));\n \n       msg = xasprintf (\"Label assigned to variable '%s' (%%ld) is not a format \""}, {"sha": "75eafe42f93659eb8ccc7323c935a993e8a35ec2", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -413,7 +413,7 @@ gfc_walk_alloc_comps (tree decl, tree dest, tree var,\n \t    {\n \t      tem = fold_convert (pvoid_type_node, tem);\n \t      tem = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t     boolean_type_node, tem,\n+\t\t\t\t     logical_type_node, tem,\n \t\t\t\t     null_pointer_node);\n \t      then_b = build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t   tem, then_b,\n@@ -540,7 +540,7 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n \t\t\t       GFC_DESCRIPTOR_TYPE_P (type)\n \t\t\t       ? gfc_conv_descriptor_data_get (outer) : outer);\n       tem = unshare_expr (tem);\n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      tem, null_pointer_node);\n       gfc_add_expr_to_block (&block,\n \t\t\t     build3_loc (input_location, COND_EXPR,\n@@ -646,7 +646,7 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n \t\t    build_zero_cst (TREE_TYPE (dest)));\n   else_b = gfc_finish_block (&cond_block);\n \n-  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t  unshare_expr (srcptr), null_pointer_node);\n   gfc_add_expr_to_block (&block,\n \t\t\t build3_loc (input_location, COND_EXPR,\n@@ -699,7 +699,7 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n \t\t\t       GFC_DESCRIPTOR_TYPE_P (type)\n \t\t\t       ? gfc_conv_descriptor_data_get (dest) : dest);\n       tem = unshare_expr (tem);\n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      tem, null_pointer_node);\n       tem = build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\tthen_b, build_empty_stmt (input_location));\n@@ -739,7 +739,7 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n   destptr = fold_convert (pvoid_type_node, destptr);\n   gfc_add_modify (&cond_block, ptr, destptr);\n \n-  nonalloc = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  nonalloc = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t      destptr, null_pointer_node);\n   cond = nonalloc;\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n@@ -755,11 +755,11 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n \t  tem = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t gfc_array_index_type, tem,\n \t\t\t\t gfc_conv_descriptor_lbound_get (dest, rank));\n-\t  tem = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  tem = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t tem, gfc_conv_descriptor_ubound_get (dest,\n \t\t\t\t\t\t\t\t      rank));\n \t  cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond, tem);\n+\t\t\t\t  logical_type_node, cond, tem);\n \t}\n     }\n \n@@ -835,7 +835,7 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n \t}\n       else_b = gfc_finish_block (&cond_block);\n \n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      unshare_expr (srcptr), null_pointer_node);\n       gfc_add_expr_to_block (&block,\n \t\t\t     build3_loc (input_location, COND_EXPR,\n@@ -1028,7 +1028,7 @@ gfc_omp_clause_dtor (tree clause, tree decl)\n \t\t\t  GFC_DESCRIPTOR_TYPE_P (type)\n \t\t\t  ? gfc_conv_descriptor_data_get (decl) : decl);\n       tem = unshare_expr (tem);\n-      tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tree cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   tem, null_pointer_node);\n       tem = build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\tthen_b, build_empty_stmt (input_location));\n@@ -1129,7 +1129,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \t  tem = gfc_conv_descriptor_data_get (decl);\n \t  tem = fold_convert (pvoid_type_node, tem);\n \t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  boolean_type_node, tem, null_pointer_node);\n+\t\t\t\t  logical_type_node, tem, null_pointer_node);\n \t  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t\t     void_type_node, cond,\n \t\t\t\t\t\t     then_b, else_b));\n@@ -2155,7 +2155,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  tem = gfc_conv_descriptor_data_get (decl);\n \t\t\t  tem = fold_convert (pvoid_type_node, tem);\n \t\t\t  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t\t  logical_type_node,\n \t\t\t\t\t\t  tem, null_pointer_node);\n \t\t\t  gfc_add_expr_to_block (block,\n \t\t\t\t\t\t build3_loc (input_location,\n@@ -3599,7 +3599,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, simple > 0\n \t\t\t\t\t       ? LE_EXPR : GE_EXPR,\n-\t\t\t\t\t       boolean_type_node, dovar, to);\n+\t\t\t\t\t       logical_type_node, dovar, to);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t\t\t    type, dovar, step);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n@@ -3626,7 +3626,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t\t\t\t     build_int_cst (type, 0));\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       logical_type_node,\n \t\t\t\t\t       count, tmp);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t\t\t    type, count,"}, {"sha": "d058e5f449d2036e6206cca004d01f11f082414d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -150,7 +150,7 @@ gfc_trans_goto (gfc_code * code)\n   gfc_start_block (&se.pre);\n   gfc_conv_label_variable (&se, code->expr1);\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n-  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node, tmp,\n \t\t\t build_int_cst (TREE_TYPE (tmp), -1));\n   gfc_trans_runtime_check (true, false, tmp, &se.pre, &loc,\n \t\t\t   \"Assigned label is not a target label\");\n@@ -1107,21 +1107,21 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n     {\n       tree cond;\n       if (flag_coarray != GFC_FCOARRAY_LIB)\n-\tcond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\tcond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\timages, build_int_cst (TREE_TYPE (images), 1));\n       else\n \t{\n \t  tree cond2;\n \t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_num_images,\n \t\t\t\t     2, integer_zero_node,\n \t\t\t\t     build_int_cst (integer_type_node, -1));\n-\t  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t\t  images, tmp);\n-\t  cond2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t\t   images,\n \t\t\t\t   build_int_cst (TREE_TYPE (images), 1));\n \t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t  boolean_type_node, cond, cond2);\n+\t\t\t\t  logical_type_node, cond, cond2);\n \t}\n       gfc_trans_runtime_check (true, false, cond, &se.pre,\n \t\t\t       &code->expr1->where, \"Invalid image number \"\n@@ -1413,10 +1413,10 @@ gfc_trans_arithmetic_if (gfc_code * code)\n       branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label2));\n \n       if (code->label1->value != code->label3->value)\n-        tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+        tmp = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       se.expr, zero);\n       else\n-        tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+        tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       se.expr, zero);\n \n       branch1 = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n@@ -1430,7 +1430,7 @@ gfc_trans_arithmetic_if (gfc_code * code)\n     {\n       /* if (cond <= 0) take branch1 else take branch2.  */\n       branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label3));\n-      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t     se.expr, zero);\n       branch1 = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t tmp, branch1, branch2);\n@@ -1966,10 +1966,10 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \n   /* Evaluate the loop condition.  */\n   if (is_step_positive)\n-    cond = fold_build2_loc (loc, GT_EXPR, boolean_type_node, dovar,\n+    cond = fold_build2_loc (loc, GT_EXPR, logical_type_node, dovar,\n \t\t\t    fold_convert (type, to));\n   else\n-    cond = fold_build2_loc (loc, LT_EXPR, boolean_type_node, dovar,\n+    cond = fold_build2_loc (loc, LT_EXPR, logical_type_node, dovar,\n \t\t\t    fold_convert (type, to));\n \n   cond = gfc_evaluate_now_loc (loc, cond, &body);\n@@ -1988,7 +1988,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n       tree boundary = is_step_positive ? TYPE_MAX_VALUE (type)\n \t: TYPE_MIN_VALUE (type);\n \n-      tmp = fold_build2_loc (loc, EQ_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (loc, EQ_EXPR, logical_type_node,\n \t\t\t     dovar, boundary);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop iterates infinitely\");\n@@ -2008,7 +2008,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   /* Check whether someone has modified the loop variable.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2_loc (loc, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (loc, NE_EXPR, logical_type_node,\n \t\t\t     dovar, saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n@@ -2117,7 +2117,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, step,\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, step,\n \t\t\t     build_zero_cst (type));\n       gfc_trans_runtime_check (true, false, tmp, &block, &code->loc,\n \t\t\t       \"DO step value is zero\");\n@@ -2184,7 +2184,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* For a positive step, when to < from, exit, otherwise compute\n          countm1 = ((unsigned)to - (unsigned)from) / (unsigned)step  */\n-      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, to, from);\n+      tmp = fold_build2_loc (loc, LT_EXPR, logical_type_node, to, from);\n       tmp2 = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype,\n \t\t\t      fold_build2_loc (loc, MINUS_EXPR, utype,\n \t\t\t\t\t       tou, fromu),\n@@ -2199,7 +2199,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* For a negative step, when to > from, exit, otherwise compute\n          countm1 = ((unsigned)from - (unsigned)to) / -(unsigned)step  */\n-      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, to, from);\n+      tmp = fold_build2_loc (loc, GT_EXPR, logical_type_node, to, from);\n       tmp2 = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype,\n \t\t\t      fold_build2_loc (loc, MINUS_EXPR, utype,\n \t\t\t\t\t       fromu, tou),\n@@ -2212,7 +2212,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t\t\t\tbuild1_loc (loc, GOTO_EXPR, void_type_node,\n \t\t\t\t\t    exit_label), NULL_TREE));\n \n-      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, step,\n+      tmp = fold_build2_loc (loc, LT_EXPR, logical_type_node, step,\n \t\t\t     build_int_cst (TREE_TYPE (step), 0));\n       tmp = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp, neg, pos);\n \n@@ -2233,13 +2233,13 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* We need a special check for empty loops:\n \t empty = (step > 0 ? to < from : to > from);  */\n-      pos_step = fold_build2_loc (loc, GT_EXPR, boolean_type_node, step,\n+      pos_step = fold_build2_loc (loc, GT_EXPR, logical_type_node, step,\n \t\t\t\t  build_zero_cst (type));\n-      tmp = fold_build3_loc (loc, COND_EXPR, boolean_type_node, pos_step,\n+      tmp = fold_build3_loc (loc, COND_EXPR, logical_type_node, pos_step,\n \t\t\t     fold_build2_loc (loc, LT_EXPR,\n-\t\t\t\t\t      boolean_type_node, to, from),\n+\t\t\t\t\t      logical_type_node, to, from),\n \t\t\t     fold_build2_loc (loc, GT_EXPR,\n-\t\t\t\t\t      boolean_type_node, to, from));\n+\t\t\t\t\t      logical_type_node, to, from));\n       /* If the loop is empty, go directly to the exit label.  */\n       tmp = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n@@ -2264,7 +2264,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   /* Check whether someone has modified the loop variable.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2_loc (loc, NE_EXPR, boolean_type_node, dovar,\n+      tmp = fold_build2_loc (loc, NE_EXPR, logical_type_node, dovar,\n \t\t\t     saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n@@ -2297,7 +2297,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   gfc_add_modify_loc (loc, &body, countm1, tmp);\n \n   /* End with the loop condition.  Loop until countm1t == 0.  */\n-  cond = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, countm1t,\n+  cond = fold_build2_loc (loc, EQ_EXPR, logical_type_node, countm1t,\n \t\t\t  build_int_cst (utype, 0));\n   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n   tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n@@ -3450,7 +3450,7 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n       gfc_init_block (&block);\n \n       /* The exit condition.  */\n-      cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node,\n \t\t\t      count, build_int_cst (TREE_TYPE (count), 0));\n       if (forall_tmp->do_concurrent)\n \tcond = build2 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n@@ -5128,7 +5128,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t\t\t\t\t  &inner_size_body, block);\n \n       /* Check whether the size is negative.  */\n-      cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, size,\n+      cond = fold_build2_loc (input_location, LE_EXPR, logical_type_node, size,\n \t\t\t      gfc_index_zero_node);\n       size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n \t\t\t      cond, gfc_index_zero_node, size);\n@@ -6134,7 +6134,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t     polymorphic and stores a _len dependent object,\n \t\t     e.g., a string.  */\n \t\t  memsz = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\t   boolean_type_node, expr3_len,\n+\t\t\t\t\t   logical_type_node, expr3_len,\n \t\t\t\t\t   integer_zero_node);\n \t\t  memsz = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t TREE_TYPE (expr3_esize),\n@@ -6267,7 +6267,7 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  tmp = build1_v (GOTO_EXPR, label_errmsg);\n \t  parm = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t  boolean_type_node, stat,\n+\t\t\t\t  logical_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (parm, PRED_FORTRAN_FAIL_ALLOC),\n@@ -6515,7 +6515,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t     gfc_default_character_kind);\n       dlen = gfc_finish_block (&errmsg_block);\n \n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t     stat, build_int_cst (TREE_TYPE (stat), 0));\n \n       tmp = build3_v (COND_EXPR, tmp,\n@@ -6768,7 +6768,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t{\n           tree cond;\n \n-\t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC),\n@@ -6808,7 +6808,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t\t     slen, errmsg_str, gfc_default_character_kind);\n       tmp = gfc_finish_block (&errmsg_block);\n \n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node, stat,\n \t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t     gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC), tmp,"}, {"sha": "b4ddfdb37cf384783ff369157ea6be11843b5f65", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -62,6 +62,9 @@ tree ppvoid_type_node;\n tree pchar_type_node;\n tree pfunc_type_node;\n \n+tree logical_type_node;\n+tree logical_true_node;\n+tree logical_false_node;\n tree gfc_charlen_type_node;\n \n tree gfc_float128_type_node = NULL_TREE;\n@@ -1003,6 +1006,11 @@ gfc_init_types (void)\n \t\t\twi::mask (n, UNSIGNED,\n \t\t\t\t  TYPE_PRECISION (size_type_node)));\n \n+\n+  logical_type_node = gfc_get_logical_type (gfc_default_logical_kind);\n+  logical_true_node = build_int_cst (logical_type_node, 1);\n+  logical_false_node = build_int_cst (logical_type_node, 0);\n+\n   /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n   gfc_charlen_int_kind = 4;\n   gfc_charlen_type_node = gfc_get_int_type (gfc_charlen_int_kind);\n@@ -3257,11 +3265,11 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   t = build1 (NOP_EXPR, build_pointer_type (ptr_type_node), t);\n   info->data_location = build1 (INDIRECT_REF, ptr_type_node, t);\n   if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n-    info->allocated = build2 (NE_EXPR, boolean_type_node,\n+    info->allocated = build2 (NE_EXPR, logical_type_node,\n \t\t\t      info->data_location, null_pointer_node);\n   else if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER\n \t   || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT)\n-    info->associated = build2 (NE_EXPR, boolean_type_node,\n+    info->associated = build2 (NE_EXPR, logical_type_node,\n \t\t\t       info->data_location, null_pointer_node);\n   if ((GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_RANK\n        || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_RANK_CONT)"}, {"sha": "6dba78e36715a02548dba0d75ac09bb2e6d71f22", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -33,6 +33,20 @@ extern GTY(()) tree pchar_type_node;\n extern GTY(()) tree gfc_float128_type_node;\n extern GTY(()) tree gfc_complex_float128_type_node;\n \n+/* logical_type_node is the Fortran LOGICAL type of default kind.  In\n+   addition to uses mandated by the Fortran standard, also prefer it\n+   for compiler generated temporary variables, is it avoids some minor\n+   issues with boolean_type_node (the C/C++ _Bool/bool). Namely:\n+   - On x86, partial register stalls with 8/16 bit register access,\n+     and length prefix changes.\n+   - On s390 there is a compare with immediate and jump instruction,\n+     but it works only with 32-bit quantities and not 8-bit such as\n+     boolean_type_node.\n+*/\n+extern GTY(()) tree logical_type_node;\n+extern GTY(()) tree logical_true_node;\n+extern GTY(()) tree logical_false_node;\n+\n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */\n /* TODO: This is still hardcoded as kind=4 in some bits of the compiler"}, {"sha": "8c1733448f4233f59e636054d5857f2285419b8a", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -537,9 +537,9 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \n   if (once)\n     {\n-       tmpvar = gfc_create_var (boolean_type_node, \"print_warning\");\n+       tmpvar = gfc_create_var (logical_type_node, \"print_warning\");\n        TREE_STATIC (tmpvar) = 1;\n-       DECL_INITIAL (tmpvar) = boolean_true_node;\n+       DECL_INITIAL (tmpvar) = logical_true_node;\n        gfc_add_expr_to_block (pblock, tmpvar);\n     }\n \n@@ -558,7 +558,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n   va_end (ap);\n \n   if (once)\n-    gfc_add_modify (&block, tmpvar, boolean_false_node);\n+    gfc_add_modify (&block, tmpvar, logical_false_node);\n \n   body = gfc_finish_block (&block);\n \n@@ -611,7 +611,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   if (gfc_option.rtcheck & GFC_RTCHECK_MEM)\n     {\n       null_result = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\t     boolean_type_node, res,\n+\t\t\t\t     logical_type_node, res,\n \t\t\t\t     build_int_cst (pvoid_type_node, 0));\n       msg = gfc_build_addr_expr (pchar_type_node,\n \t      gfc_build_localized_cstring_const (\"Memory allocation failed\"));\n@@ -697,7 +697,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n     }\n \n   error_cond = fold_build2_loc (input_location, EQ_EXPR,\n-\t\t\t\tboolean_type_node, pointer,\n+\t\t\t\tlogical_type_node, pointer,\n \t\t\t\tbuild_int_cst (prvoid_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t gfc_unlikely (error_cond, PRED_FORTRAN_FAIL_ALLOC),\n@@ -799,7 +799,7 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n \n   size = fold_convert (size_type_node, size);\n   null_mem = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t    boolean_type_node, mem,\n+\t\t\t\t\t    logical_type_node, mem,\n \t\t\t\t\t    build_int_cst (type, 0)),\n \t\t\t   PRED_FORTRAN_REALLOC);\n \n@@ -877,7 +877,7 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n \t{\n \t  TREE_USED (label_finish) = 1;\n \t  tmp = build1_v (GOTO_EXPR, label_finish);\n-\t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t  status, build_zero_cst (TREE_TYPE (status)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC),\n@@ -1094,12 +1094,12 @@ gfc_add_comp_finalizer_call (stmtblock_t *block, tree decl, gfc_component *comp,\n     {\n       tmp = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (array))\n \t    ?  gfc_conv_descriptor_data_get (array) : array;\n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t    tmp, fold_convert (TREE_TYPE (tmp),\n \t\t\t\t\t\t null_pointer_node));\n     }\n   else\n-    cond = boolean_true_node;\n+    cond = logical_true_node;\n \n   if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (array)))\n     {\n@@ -1115,12 +1115,12 @@ gfc_add_comp_finalizer_call (stmtblock_t *block, tree decl, gfc_component *comp,\n \n   if (!final_expr)\n     {\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t     final_fndecl,\n \t\t\t     fold_convert (TREE_TYPE (final_fndecl),\n \t\t\t\t\t   null_pointer_node));\n       cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t      boolean_type_node, cond, tmp);\n+\t\t\t      logical_type_node, cond, tmp);\n     }\n \n   if (POINTER_TYPE_P (TREE_TYPE (final_fndecl)))\n@@ -1216,7 +1216,7 @@ gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n       gfc_init_se (&se, NULL);\n       se.want_pointer = 1;\n       gfc_conv_expr (&se, final_expr);\n-      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t      se.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n \n       /* For CLASS(*) not only sym->_vtab->_final can be NULL\n@@ -1234,11 +1234,11 @@ gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n \t  gfc_conv_expr (&se, vptr_expr);\n \t  gfc_free_expr (vptr_expr);\n \n-\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   se.expr,\n \t\t\t\t   build_int_cst (TREE_TYPE (se.expr), 0));\n \t  cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t\t  boolean_type_node, cond2, cond);\n+\t\t\t\t  logical_type_node, cond2, cond);\n \t}\n \n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n@@ -1344,7 +1344,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n   else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)))\n     pointer = gfc_conv_descriptor_data_get (pointer);\n \n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n \n   /* When POINTER is NULL, we set STATUS to 1 if it's present, otherwise\n@@ -1371,7 +1371,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n       tree cond2;\n \n       status_type = TREE_TYPE (TREE_TYPE (status));\n-      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n       tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n \t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n@@ -1404,7 +1404,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t  tree status_type = TREE_TYPE (TREE_TYPE (status));\n \t  tree cond2;\n \n-\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   status,\n \t\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n \t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n@@ -1467,7 +1467,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \n \t  TREE_USED (label_finish) = 1;\n \t  tmp = build1_v (GOTO_EXPR, label_finish);\n-\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_REALLOC),\n@@ -1503,7 +1503,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n       && comp_ref)\n     caf_dereg_type = GFC_CAF_COARRAY_DEALLOCATE_ONLY;\n \n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n+  cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n \n   /* When POINTER is NULL, we set STATUS to 1 if it's present, otherwise\n@@ -1530,7 +1530,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n       tree status_type = TREE_TYPE (TREE_TYPE (status));\n       tree cond2;\n \n-      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n       tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n \t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n@@ -1575,7 +1575,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n \t  tree status_type = TREE_TYPE (TREE_TYPE (status));\n \t  tree cond2;\n \n-\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   status,\n \t\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n \t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n@@ -1625,7 +1625,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n \n \t  TREE_USED (label_finish) = 1;\n \t  tmp = build1_v (GOTO_EXPR, label_finish);\n-\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n \t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_REALLOC),\n@@ -1668,11 +1668,11 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n \t\t\t builtin_decl_explicit (BUILT_IN_REALLOC), 2,\n \t\t\t fold_convert (pvoid_type_node, mem), size);\n   gfc_add_modify (block, res, fold_convert (type, tmp));\n-  null_result = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+  null_result = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n \t\t\t\t res, build_int_cst (pvoid_type_node, 0));\n-  nonzero = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, size,\n+  nonzero = fold_build2_loc (input_location, NE_EXPR, logical_type_node, size,\n \t\t\t     build_int_cst (size_type_node, 0));\n-  null_result = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+  null_result = fold_build2_loc (input_location, TRUTH_AND_EXPR, logical_type_node,\n \t\t\t\t null_result, nonzero);\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t     (\"Allocation would exceed memory limit\"));"}, {"sha": "0d429f161244166fb424c237ce2ad5edf9dffc81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -1,3 +1,9 @@\n+2017-11-08  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR 82869\n+\t* gfortran.dg/logical_temp_io.f90: New test.\n+\t* gfortran.dg/logical_temp_io_kind8.f90: New test.\n+\n 2017-11-08  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/tree-ssa/vrp101.c: Update expected pattern as"}, {"sha": "77260a9c6690e2b65c0fb8955d3226d6f7df920b", "filename": "gcc/testsuite/gfortran.dg/logical_temp_io.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io.f90?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 82869\n+! A temp variable of type logical was incorrectly transferred\n+! to the I/O library as a logical type of a different kind.\n+program pr82869\n+  use, intrinsic :: iso_c_binding\n+  type(c_ptr) :: p = c_null_ptr\n+  character(len=4) :: s\n+  write (s, *) c_associated(p), c_associated(c_null_ptr)\n+  if (s /= ' F F') then\n+     call abort()\n+  end if\n+end program pr82869"}, {"sha": "662289e1c344caa57bba535b862eb33d02231696", "filename": "gcc/testsuite/gfortran.dg/logical_temp_io_kind8.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io_kind8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ee540430c32a4f93924f4b2d970999b7cd201b/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io_kind8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flogical_temp_io_kind8.f90?ref=63ee540430c32a4f93924f4b2d970999b7cd201b", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+! { dg-options \"-fdefault-integer-8\" }\n+! PR 82869\n+! A temp variable of type logical was incorrectly transferred\n+! to the I/O library as a logical type of a different kind.\n+program pr82869_8\n+  use, intrinsic :: iso_c_binding\n+  type(c_ptr) :: p = c_null_ptr\n+  character(len=4) :: s\n+  write (s, *) c_associated(p), c_associated(c_null_ptr)\n+  if (s /= ' F F') then\n+     call abort()\n+  end if\n+end program pr82869_8"}]}