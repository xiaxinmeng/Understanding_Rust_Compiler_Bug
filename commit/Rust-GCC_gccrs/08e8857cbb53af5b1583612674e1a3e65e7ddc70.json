{"sha": "08e8857cbb53af5b1583612674e1a3e65e7ddc70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlODg1N2NiYjUzYWY1YjE1ODM2MTI2NzRlMWEzZTY1ZTdkZGM3MA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-09-18T10:41:10Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-09-18T10:41:10Z"}, "message": "(m88k_volatile_code): New variable.\n\n\t(print_operand): Track volatile memory references and output a\n\tserializing instruction before a load when necessary.\n(m88k_version, m88k_version_0300): New variables.\n\nFrom-SVN: r2150", "tree": {"sha": "91e9e532e04ca5e3ec6b551fa261390444fe0dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91e9e532e04ca5e3ec6b551fa261390444fe0dd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08e8857cbb53af5b1583612674e1a3e65e7ddc70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e8857cbb53af5b1583612674e1a3e65e7ddc70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e8857cbb53af5b1583612674e1a3e65e7ddc70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e8857cbb53af5b1583612674e1a3e65e7ddc70/comments", "author": null, "committer": null, "parents": [{"sha": "0380c535b1adbf21ab9e0f180c925a77c4e57bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0380c535b1adbf21ab9e0f180c925a77c4e57bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0380c535b1adbf21ab9e0f180c925a77c4e57bf5"}], "stats": {"total": 41, "additions": 39, "deletions": 2}, "files": [{"sha": "04c671fb7f1c08341c8a0984fb98439a21ed97b9", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e8857cbb53af5b1583612674e1a3e65e7ddc70/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e8857cbb53af5b1583612674e1a3e65e7ddc70/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=08e8857cbb53af5b1583612674e1a3e65e7ddc70", "patch": "@@ -46,18 +46,21 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.2.7.3 09/02/92 09:45:23\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.2.12.1 09/12/92 07:06:48\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n char *m88k_short_data;\n+char *m88k_version;\n+char m88k_volatile_code;\n \n int m88k_gp_threshold;\n int m88k_prologue_done\t= 0;\t/* Ln directives can now be emitted */\n int m88k_function_number = 0;\t/* Counter unique to each function */\n int m88k_fp_offset\t= 0;\t/* offset of frame pointer if used */\n int m88k_stack_size\t= 0;\t/* size of allocated stack (including frame) */\n int m88k_case_index;\n+int m88k_version_0300;\t\t/* Version is at least 03.00 */\n \n rtx m88k_compare_reg;\t\t/* cmp output pseudo register */\n rtx m88k_compare_op0;\t\t/* cmpsi operand 0 */\n@@ -501,7 +504,7 @@ block_move_loop (dest, dest_mem, src, src_mem, size, align)\n   MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n   MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n \n-  emit_insn (gen_call_block_move_loop\n+  emit_insn (gen_call_movstrsi_loop\n \t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n \t      dest, src, offset_rtx, value_rtx,\n \t      gen_rtx (REG, GET_MODE (value_rtx), ((units & 1) ? 4 : 5)),\n@@ -2517,6 +2520,40 @@ print_operand (file, x, code)\n     case '#': /* SVR4 pound-sign syntax character (empty if SVR3) */\n       fputs (m88k_pound_sign, file); return;\n \n+    case 'V': /* Output a serializing instruction as needed if the operand\n+\t\t (assumed to be a MEM) is a volatile load.  */\n+    case 'v': /* ditto for a volatile store.  */\n+      if (MEM_VOLATILE_P (x) && TARGET_SERIALIZE_VOLATILE)\n+\t{\n+\t  /* The m88110 implements two FIFO queues, one for loads and\n+\t     one for stores.  These queues mean that loads complete in\n+\t     their issue order as do stores.  An interaction between the\n+\t     history buffer and the store reservation station ensures\n+\t     that a store will not bypass load.  Finally, a load will not\n+\t     bypass store, but only when they reference the same address.\n+\n+\t     To avoid this reordering (a load bypassing a store) for\n+\t     volatile references, a serializing instruction is output.\n+\t     We choose the fldcr instruction as it does not serialize on\n+\t     the m88100 so that -m88000 code will not be degraded.\n+\n+\t     The mechanism below is completed by having CC_STATUS_INIT set\n+\t     the code to the unknown value.  */\n+\n+\t  static rtx last_addr = 0;\n+\t  if (code == 'V' /* Only need to serialize before a load.  */\n+\t      && m88k_volatile_code != 'V' /* Loads complete in FIFO order.  */\n+\t      && !(m88k_volatile_code == 'v'\n+\t\t   && GET_CODE (XEXP (x, 0)) == LO_SUM\n+\t\t   && rtx_equal_p (XEXP (XEXP (x, 0), 1), last_addr)))\n+\t    fprintf (file, \"fldcr\\t %s,%sfcr63\\n\\t\",\n+\t\t     reg_names[0], m88k_pound_sign);\n+\t  m88k_volatile_code = code;\n+\t  last_addr = (GET_CODE (XEXP (x, 0)) == LO_SUM\n+\t\t       ? XEXP (XEXP (x, 0), 1) : 0);\n+\t}\n+      return;\n+\n     case 'X': /* print the upper 16 bits... */\n       value >>= 16;\n     case 'x': /* print the lower 16 bits of the integer constant in hex */"}]}