{"sha": "7433458d871f6bfe2169b9d7d04fec64bb142924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzMzQ1OGQ4NzFmNmJmZTIxNjliOWQ3ZDA0ZmVjNjRiYjE0MjkyNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-16T05:40:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-16T05:40:51Z"}, "message": "[multiple changes]\n\n2007-05-16  Brooks Moses  <brooks.moses@codesourcery.com>\n\n\tPR fortran/18769\n\tPR fortran/30881\n\tPR fortran/31194\n\tPR fortran/31216\n\tPR fortran/31427\n\t* target-memory.c: New file.\n\t* target-memory.h: New file.\n\t* simplify.c: Add #include \"target-memory.h\".\n\t(gfc_simplify_transfer): Implement constant-\n\tfolding for TRANSFER intrinsic.\n\t* Make-lang.in: Add dependencies on new target-memory.* files.\n\n2007-05-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/18769\n\tPR fortran/30881\n\tPR fortran/31194\n\tPR fortran/31216\n\tPR fortran/31427\n\t* transfer_simplify_1.f90: New test.\n\t* transfer_simplify_2.f90: New test.\n\nFrom-SVN: r124759", "tree": {"sha": "23f07d1d6c5d1258327e93048c7cc22109070eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23f07d1d6c5d1258327e93048c7cc22109070eb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7433458d871f6bfe2169b9d7d04fec64bb142924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7433458d871f6bfe2169b9d7d04fec64bb142924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7433458d871f6bfe2169b9d7d04fec64bb142924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7433458d871f6bfe2169b9d7d04fec64bb142924/comments", "author": null, "committer": null, "parents": [{"sha": "9847030dba03c81f6104cdcc1e5993eb4ff4a9d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9847030dba03c81f6104cdcc1e5993eb4ff4a9d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9847030dba03c81f6104cdcc1e5993eb4ff4a9d3"}], "stats": {"total": 838, "additions": 831, "deletions": 7}, "files": [{"sha": "d89c888bc8a6bc2476c6f15f02fa2c9bffe801b8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -1,3 +1,17 @@\n+2007-05-16  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\tPR fortran/18769\n+\tPR fortran/30881\n+\tPR fortran/31194\n+\tPR fortran/31216\n+\tPR fortran/31427\n+\t* target-memory.c: New file.\n+\t* target-memory.h: New file.\n+\t* simplify.c: Add #include \"target-memory.h\".\n+\t(gfc_simplify_transfer): Implement constant-\n+\tfolding for TRANSFER intrinsic.\n+\t* Make-lang.in: Add dependencies on new target-memory.* files.\n+\n 2007-05-15  Paul Brook  <paul@codesourcery.com>\n \n \t* trans-types.c (gfc_type_for_size): Handle signed TImode."}, {"sha": "f9053dc519e2f5945ed69a2984216a6dfb750ff9", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -66,7 +66,7 @@ F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \\\n     fortran/match.o fortran/matchexp.o fortran/misc.o fortran/module.o \\\n     fortran/openmp.o fortran/options.o fortran/parse.o fortran/primary.o \\\n     fortran/resolve.o fortran/scanner.o fortran/simplify.o fortran/st.o \\\n-    fortran/symbol.o\n+    fortran/symbol.o fortran/target-memory.o\n \n F95_OBJS = $(F95_PARSER_OBJS) \\\n     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \\\n@@ -297,7 +297,7 @@ fortran.stagefeedback: stageprofile-start\n # TODO: Add dependencies on the backend/tree header files\n \n $(F95_PARSER_OBJS): fortran/gfortran.h fortran/intrinsic.h fortran/match.h \\\n-\t\tfortran/parse.h \\\n+\t\tfortran/parse.h fortran/arith.h fortran/target-memory.h \\\n \t\t$(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TM_P_H) coretypes.h \\\n \t\t$(RTL_H) $(TREE_H) $(TREE_DUMP_H) $(GGC_H) $(EXPR_H) \\\n \t\t$(FLAGS_H) output.h $(DIAGNOSTIC_H) errors.h $(FUNCTION_H) "}, {"sha": "87fe6f14708a614656b900714033a6984017417e", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 75, "deletions": 5, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -26,6 +26,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gfortran.h\"\n #include \"arith.h\"\n #include \"intrinsic.h\"\n+#include \"target-memory.h\"\n \n gfc_expr gfc_bad_expr;\n \n@@ -3865,12 +3866,81 @@ gfc_simplify_tiny (gfc_expr *e)\n gfc_expr *\n gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n {\n-  /* Reference mold and size to suppress warning.  */\n-  if (gfc_init_expr && (mold || size))\n-    gfc_error (\"TRANSFER intrinsic not implemented for initialization at %L\",\n-\t       &source->where);\n+  gfc_expr *result;\n+  gfc_expr *mold_element;\n+  size_t source_size;\n+  size_t result_size;\n+  size_t result_elt_size;\n+  size_t buffer_size;\n+  mpz_t tmp;\n+  unsigned char *buffer;\n+\n+  if (!gfc_is_constant_expr (source)\n+\t|| !gfc_is_constant_expr (size))\n+    return NULL;\n \n-  return NULL;\n+  /* Calculate the size of the source.  */\n+  if (source->expr_type == EXPR_ARRAY\n+      && gfc_array_size (source, &tmp) == FAILURE)\n+    gfc_internal_error (\"Failure getting length of a constant array.\");\n+\n+  source_size = gfc_target_expr_size (source);\n+\n+  /* Create an empty new expression with the appropriate characteristics.  */\n+  result = gfc_constant_result (mold->ts.type, mold->ts.kind,\n+\t\t\t\t&source->where);\n+  result->ts = mold->ts;\n+\n+  mold_element = mold->expr_type == EXPR_ARRAY\n+\t\t ? mold->value.constructor->expr\n+\t\t : mold;\n+\n+  /* Set result character length, if needed.  Note that this needs to be\n+     set even for array expressions, in order to pass this information into \n+     gfc_target_interpret_expr.  */\n+  if (result->ts.type == BT_CHARACTER)\n+    result->value.character.length = mold_element->value.character.length;\n+  \n+  /* Set the number of elements in the result, and determine its size.  */\n+  result_elt_size = gfc_target_expr_size (mold_element);\n+  if (mold->expr_type == EXPR_ARRAY || size)\n+    {\n+      int result_length;\n+\n+      result->expr_type = EXPR_ARRAY;\n+      result->rank = 1;\n+\n+      if (size)\n+\tresult_length = (size_t)mpz_get_ui (size->value.integer);\n+      else\n+\t{\n+\t  result_length = source_size / result_elt_size;\n+\t  if (result_length * result_elt_size < source_size)\n+\t    result_length += 1;\n+\t}\n+\n+      result->shape = gfc_get_shape (1);\n+      mpz_init_set_ui (result->shape[0], result_length);\n+\n+      result_size = result_length * result_elt_size;\n+    }\n+  else\n+    {\n+      result->rank = 0;\n+      result_size = result_elt_size;\n+    }\n+\n+  /* Allocate the buffer to store the binary version of the source.  */\n+  buffer_size = MAX (source_size, result_size);\n+  buffer = (unsigned char*)alloca (buffer_size);\n+\n+  /* Now write source to the buffer.  */\n+  gfc_target_encode_expr (source, buffer, buffer_size);\n+\n+  /* And read the buffer back into the new expression.  */\n+  gfc_target_interpret_expr (buffer, buffer_size, result);\n+\n+  return result;\n }\n \n "}, {"sha": "ba2363adf9c397c7d55e531b4ad886fa15a8fb0b", "filename": "gcc/fortran/target-memory.c", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -0,0 +1,451 @@\n+/* Simulate storage of variables into target memory.\n+   Copyright (C) 2007\n+   Free Software Foundation, Inc.\n+   Contributed by Paul Thomas and Brooks Moses\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"flags.h\"\n+#include \"machmode.h\"\n+#include \"tree.h\"\n+#include \"gfortran.h\"\n+#include \"arith.h\"\n+#include \"trans.h\"\n+#include \"trans-const.h\"\n+#include \"trans-types.h\"\n+#include \"target-memory.h\"\n+\n+/* --------------------------------------------------------------- */ \n+/* Calculate the size of an expression.  */\n+\n+static size_t\n+size_array (gfc_expr *e)\n+{\n+  mpz_t array_size;\n+  size_t elt_size = gfc_target_expr_size (e->value.constructor->expr);\n+\n+  gfc_array_size (e, &array_size);\n+  return (size_t)mpz_get_ui (array_size) * elt_size;\n+}\n+\n+static size_t\n+size_integer (int kind)\n+{\n+  return GET_MODE_SIZE (TYPE_MODE (gfc_get_int_type (kind)));;\n+}\n+\n+\n+static size_t\n+size_float (int kind)\n+{\n+  return GET_MODE_SIZE (TYPE_MODE (gfc_get_real_type (kind)));;\n+}\n+\n+\n+static size_t\n+size_complex (int kind)\n+{\n+  return 2 * size_float (kind);\n+}\n+\n+\n+static size_t\n+size_logical (int kind)\n+{\n+  return GET_MODE_SIZE (TYPE_MODE (gfc_get_logical_type (kind)));;\n+}\n+\n+\n+static size_t\n+size_character (int length)\n+{\n+  return length;\n+}\n+\n+\n+size_t\n+gfc_target_expr_size (gfc_expr *e)\n+{\n+  tree type;\n+\n+  gcc_assert (e != NULL);\n+\n+  if (e->expr_type == EXPR_ARRAY)\n+    return size_array (e);\n+\n+  switch (e->ts.type)\n+    {\n+    case BT_INTEGER:\n+      return size_integer (e->ts.kind);\n+    case BT_REAL:\n+      return size_float (e->ts.kind);\n+    case BT_COMPLEX:\n+      return size_complex (e->ts.kind);\n+    case BT_LOGICAL:\n+      return size_logical (e->ts.kind);\n+    case BT_CHARACTER:\n+      return size_character (e->value.character.length);\n+    case BT_DERIVED:\n+      type = gfc_typenode_for_spec (&e->ts);\n+      return int_size_in_bytes (type);\n+    default:\n+      gfc_internal_error (\"Invalid expression in gfc_target_expr_size.\");\n+      return 0;\n+    }\n+}\n+\n+\n+/* The encode_* functions export a value into a buffer, and \n+   return the number of bytes of the buffer that have been\n+   used.  */\n+\n+static int\n+encode_array (gfc_expr *expr, unsigned char *buffer, size_t buffer_size)\n+{\n+  mpz_t array_size;\n+  int i;\n+  int ptr = 0;\n+\n+  gfc_array_size (expr, &array_size);\n+  for (i = 0; i < (int)mpz_get_ui (array_size); i++)\n+    {\n+      ptr += gfc_target_encode_expr (gfc_get_array_element (expr, i),\n+\t\t\t\t     &buffer[ptr], buffer_size - ptr);\n+    }\n+\n+  mpz_clear (array_size);\n+  return ptr;\n+}\n+\n+\n+static int\n+encode_integer (int kind, mpz_t integer, unsigned char *buffer,\n+\t\tsize_t buffer_size)\n+{\n+  return native_encode_expr (gfc_conv_mpz_to_tree (integer, kind),\n+\t\t\t     buffer, buffer_size);\n+}\n+\n+\n+static int\n+encode_float (int kind, mpfr_t real, unsigned char *buffer, size_t buffer_size)\n+{\n+  return native_encode_expr (gfc_conv_mpfr_to_tree (real, kind), buffer,\n+\t\t\t     buffer_size);\n+}\n+\n+\n+static int\n+encode_complex (int kind, mpfr_t real, mpfr_t imaginary, unsigned char *buffer,\n+\t\tsize_t buffer_size)\n+{\n+  int size;\n+  size = encode_float (kind, real, &buffer[0], buffer_size);\n+  size += encode_float (kind, imaginary, &buffer[size], buffer_size - size);\n+  return size;\n+}\n+\n+\n+static int\n+encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size)\n+{\n+  return native_encode_expr (build_int_cst (gfc_get_logical_type (kind),\n+\t\t\t\t\t    logical),\n+\t\t\t     buffer, buffer_size);\n+}\n+\n+\n+static int\n+encode_character (int length, char *string, unsigned char *buffer,\n+\t\t  size_t buffer_size)\n+{\n+  gcc_assert (buffer_size >= size_character (length));\n+  memcpy (buffer, string, length);\n+  return length;\n+}\n+\n+\n+static int\n+encode_derived (gfc_expr *source, unsigned char *buffer, size_t buffer_size)\n+{\n+  gfc_constructor *ctr;\n+  gfc_component *cmp;\n+  int ptr;\n+  tree type;\n+\n+  type = gfc_typenode_for_spec (&source->ts);\n+\n+  ctr = source->value.constructor;\n+  cmp = source->ts.derived->components;\n+  for (;ctr; ctr = ctr->next, cmp = cmp->next)\n+    {\n+      gcc_assert (ctr->expr && cmp);\n+      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n+      gfc_target_encode_expr (ctr->expr, &buffer[ptr],\n+\t\t\t      buffer_size - ptr);\n+    }\n+\n+  return int_size_in_bytes (type);\n+}\n+\n+\n+/* Write a constant expression in binary form to a buffer.  */\n+int\n+gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n+\t\t\tsize_t buffer_size)\n+{\n+  if (source == NULL)\n+    return 0;\n+\n+  if (source->expr_type == EXPR_ARRAY)\n+    return encode_array (source, buffer, buffer_size);\n+\n+  gcc_assert (source->expr_type == EXPR_CONSTANT\n+\t      || source->expr_type == EXPR_STRUCTURE);\n+\n+  switch (source->ts.type)\n+    {\n+    case BT_INTEGER:\n+      return encode_integer (source->ts.kind, source->value.integer, buffer,\n+\t\t\t     buffer_size);\n+    case BT_REAL:\n+      return encode_float (source->ts.kind, source->value.real, buffer,\n+\t\t\t   buffer_size);\n+    case BT_COMPLEX:\n+      return encode_complex (source->ts.kind, source->value.complex.r,\n+\t\t\t     source->value.complex.i, buffer, buffer_size);\n+    case BT_LOGICAL:\n+      return encode_logical (source->ts.kind, source->value.logical, buffer,\n+\t\t\t     buffer_size);\n+    case BT_CHARACTER:\n+      return encode_character (source->value.character.length, \n+\t\t\t       source->value.character.string, buffer,\n+\t\t\t       buffer_size);\n+    case BT_DERIVED:\n+      return encode_derived (source, buffer, buffer_size);\n+    default:\n+      gfc_internal_error (\"Invalid expression in gfc_target_encode_expr.\");\n+      return 0;\n+    }\n+}\n+\n+\n+static int\n+interpret_array (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+{\n+  int array_size = 1;\n+  int i;\n+  int ptr = 0;\n+  gfc_constructor *head = NULL, *tail = NULL;\n+\n+  /* Calculate array size from its shape and rank.  */\n+  gcc_assert (result->rank > 0 && result->shape);\n+\n+  for (i = 0; i < result->rank; i++)\n+    array_size *= (int)mpz_get_ui (result->shape[i]);\n+\n+  /* Iterate over array elements, producing constructors.  */\n+  for (i = 0; i < array_size; i++)\n+    {\n+      if (head == NULL)\n+\thead = tail = gfc_get_constructor ();\n+      else\n+\t{\n+\t  tail->next = gfc_get_constructor ();\n+\t  tail = tail->next;\n+\t}\n+\n+      tail->where = result->where;\n+      tail->expr = gfc_constant_result (result->ts.type,\n+\t\t\t\t\t  result->ts.kind, &result->where);\n+      tail->expr->ts = result->ts;\n+\n+      if (tail->expr->ts.type == BT_CHARACTER)\n+\ttail->expr->value.character.length = result->value.character.length;\n+\n+      ptr += gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr,\n+\t\t\t\t\ttail->expr);\n+    }\n+  result->value.constructor = head;\n+\n+  return ptr;\n+}\n+\n+\n+static int\n+interpret_integer (int kind, unsigned char *buffer, size_t buffer_size,\n+\t\t   mpz_t integer)\n+{\n+  mpz_init (integer);\n+  gfc_conv_tree_to_mpz (integer,\n+\t\t\tnative_interpret_expr (gfc_get_int_type (kind),\n+\t\t\t\t\t       buffer, buffer_size));\n+  return size_integer (kind);\n+}\n+\n+\n+static int\n+interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n+\t\t mpfr_t real)\n+{\n+  mpfr_init (real);\n+  gfc_conv_tree_to_mpfr (real,\n+\t\t\t native_interpret_expr (gfc_get_real_type (kind),\n+\t\t\t\t\t\tbuffer, buffer_size));\n+\n+  return size_float (kind);\n+}\n+\n+\n+static int\n+interpret_complex (int kind, unsigned char *buffer, size_t buffer_size,\n+\t\t   mpfr_t real, mpfr_t imaginary)\n+{\n+  int size;\n+  size = interpret_float (kind, &buffer[0], buffer_size, real);\n+  size += interpret_float (kind, &buffer[size], buffer_size - size, imaginary);\n+  return size;\n+}\n+\n+\n+static int\n+interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n+\t\t   int *logical)\n+{\n+  tree t = native_interpret_expr (gfc_get_logical_type (kind), buffer,\n+\t\t\t\t  buffer_size);\n+  *logical = double_int_zero_p (tree_to_double_int (t))\n+\t     ? 0 : 1;\n+  return size_logical (kind);\n+}\n+\n+\n+static int\n+interpret_character (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+{\n+  if (result->ts.cl && result->ts.cl->length)\n+    result->value.character.length =\n+      (int)mpz_get_ui (result->ts.cl->length->value.integer);\n+\n+  gcc_assert (buffer_size >= size_character (result->value.character.length));\n+  result->value.character.string =\n+    gfc_getmem (result->value.character.length + 1);\n+  memcpy (result->value.character.string, buffer,\n+\t  result->value.character.length);\n+  result->value.character.string [result->value.character.length] = '\\0';\n+\n+  return result->value.character.length;\n+}\n+\n+\n+static int\n+interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+{\n+  gfc_component *cmp;\n+  gfc_constructor *head = NULL, *tail = NULL;\n+  int ptr;\n+  tree type;\n+\n+  /* The attributes of the derived type need to be bolted to the floor.  */\n+  result->expr_type = EXPR_STRUCTURE;\n+\n+  type = gfc_typenode_for_spec (&result->ts);\n+  cmp = result->ts.derived->components;\n+\n+  /* Run through the derived type components.  */\n+  for (;cmp; cmp = cmp->next)\n+    {\n+      if (head == NULL)\n+\thead = tail = gfc_get_constructor ();\n+      else\n+\t{\n+\t  tail->next = gfc_get_constructor ();\n+\t  tail = tail->next;\n+\t}\n+\n+      /* The constructor points to the component.  */\n+      tail->n.component = cmp;\n+\n+      tail->expr = gfc_constant_result (cmp->ts.type, cmp->ts.kind,\n+\t\t\t\t\t&result->where);\n+      tail->expr->ts = cmp->ts;\n+\n+      /* Copy shape, if needed.  */\n+      if (cmp->as && cmp->as->rank)\n+\t{\n+\t  int n;\n+\n+\t  tail->expr->expr_type = EXPR_ARRAY;\n+\t  tail->expr->rank = cmp->as->rank;\n+\n+\t  tail->expr->shape = gfc_get_shape (tail->expr->rank);\n+\t  for (n = 0; n < tail->expr->rank; n++)\n+\t     {\n+\t       mpz_init_set_ui (tail->expr->shape[n], 1);\n+\t       mpz_add (tail->expr->shape[n], tail->expr->shape[n],\n+\t\t\tcmp->as->upper[n]->value.integer);\n+\t       mpz_sub (tail->expr->shape[n], tail->expr->shape[n],\n+\t\t\tcmp->as->lower[n]->value.integer);\n+\t     }\n+\t}\n+\n+      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n+      gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr,\n+\t\t\t\t tail->expr);\n+\n+      result->value.constructor = head;\n+    }\n+    \n+  return int_size_in_bytes (type);\n+}\n+\n+\n+/* Read a binary buffer to a constant expression.  */\n+int\n+gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n+\t\t\t   gfc_expr *result)\n+{\n+  if (result->expr_type == EXPR_ARRAY)\n+    return interpret_array (buffer, buffer_size, result);\n+\n+  switch (result->ts.type)\n+    {\n+    case BT_INTEGER:\n+      return interpret_integer (result->ts.kind, buffer, buffer_size,\n+\t\t\t\tresult->value.integer);\n+    case BT_REAL:\n+      return interpret_float (result->ts.kind, buffer, buffer_size,\n+\t\t\t      result->value.real);\n+    case BT_COMPLEX:\n+      return interpret_complex (result->ts.kind, buffer, buffer_size,\n+\t\t\t\tresult->value.complex.r,\n+\t\t\t\tresult->value.complex.i);\n+    case BT_LOGICAL:\n+      return interpret_logical (result->ts.kind, buffer, buffer_size,\n+\t\t\t\t&result->value.logical);\n+    case BT_CHARACTER:\n+      return interpret_character (buffer, buffer_size, result);\n+    case BT_DERIVED:\n+      return interpret_derived (buffer, buffer_size, result);\n+    default:\n+      gfc_internal_error (\"Invalid expression in gfc_target_interpret_expr.\");\n+    }\n+  return 0;\n+}"}, {"sha": "85ae552aec3e43aa807f547ad480b8743bc433e2", "filename": "gcc/fortran/target-memory.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -0,0 +1,37 @@\n+/* Simulate storage of variables into target memory, header.\n+   Copyright (C) 2007\n+   Free Software Foundation, Inc.\n+   Contributed by Paul Thomas and Brooks Moses\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef GFC_TARGET_MEMORY_H\n+#define GFC_TARGET_MEMORY_H\n+\n+#include \"gfortran.h\"\n+\n+/* Return the size of an expression in its target representation.  */\n+size_t gfc_target_expr_size (gfc_expr *);\n+\n+/* Write a constant expression in binary form to a target buffer.  */\n+int gfc_target_encode_expr (gfc_expr *, unsigned char *, size_t);\n+\n+/* Read a target buffer into a constant expression.  */\n+int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *);\n+\n+#endif /* GFC_TARGET_MEMORY_H  */"}, {"sha": "ee74a8f7fc0434691bf8eff3480d37ff22c5cf34", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -1,3 +1,13 @@\n+2007-05-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/18769\n+\tPR fortran/30881\n+\tPR fortran/31194\n+\tPR fortran/31216\n+\tPR fortran/31427\n+\t* transfer_simplify_1.f90: New test.\n+\t* transfer_simplify_2.f90: New test.\n+\n 2007-05-15  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \t* gfortran.dg/unf_io_convert_3.f90: Fix dg directive."}, {"sha": "c1b241fb99db937c3331a97ea74607ada80d7d45", "filename": "gcc/testsuite/gfortran.dg/transfer_simplify_1.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_1.f90?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -0,0 +1,87 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+! Tests that the PRs caused by the lack of gfc_simplify_transfer are\n+! now fixed. These were brought together in the meta-bug PR31237\n+! (TRANSFER intrinsic).\n+! Remaining PRs on 20070409 :-18769 30881 31194 31216 31424 31427\n+!\n+program simplify_transfer\n+  CHARACTER(LEN=100) :: buffer=\"1.0 3.0\"\n+  call pr18769 ()\n+  call pr30881 ()\n+  call pr31194 ()\n+  call pr31216 ()\n+  call pr31427 ()\n+contains\n+  subroutine pr18769 ()\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+    implicit none\n+    type t\n+       integer :: i\n+    end type t\n+    type (t), parameter :: u = t (42)\n+    integer,  parameter :: idx_list(1) = (/ 1 /)\n+    integer             :: j(1) = transfer (u,  idx_list)\n+    if (j(1) .ne. 42) call abort ()\n+  end subroutine pr18769\n+\n+  subroutine pr30881 ()\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+    INTEGER, PARAMETER :: K=1\n+    INTEGER ::  I\n+    I=TRANSFER(.TRUE.,K)\n+    SELECT CASE(I)\n+      CASE(TRANSFER(.TRUE.,K))\n+      CASE(TRANSFER(.FALSE.,K))\n+        CALL ABORT()\n+      CASE DEFAULT\n+        CALL ABORT()\n+    END SELECT\n+    I=TRANSFER(.FALSE.,K)\n+    SELECT CASE(I)\n+      CASE(TRANSFER(.TRUE.,K))\n+        CALL ABORT()\n+      CASE(TRANSFER(.FALSE.,K))\n+      CASE DEFAULT\n+      CALL ABORT()\n+    END SELECT\n+  END subroutine pr30881\n+\n+  subroutine pr31194 ()\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+    real(kind(0d0)) :: NaN = transfer(ishft(int(z'FFF80000',8),32),0d0)\n+    write (buffer,'(e12.5)') NaN\n+    if (buffer(10:12) .ne. \"NaN\") call abort ()\n+  end subroutine pr31194\n+\n+  subroutine pr31216 ()\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+    INTEGER :: I\n+    REAL :: C,D\n+    buffer = \"  1.0  3.0\"\n+    READ(buffer,*) C,D\n+    I=TRANSFER(C/D,I)\n+    SELECT CASE(I)\n+      CASE (TRANSFER(1.0/3.0,1))\n+      CASE DEFAULT\n+        CALL ABORT()\n+    END SELECT\n+  END subroutine pr31216\n+\n+  subroutine pr31427 ()\n+!\n+! Contributed by Michael Richmond <michael.a.richmond@nasa.gov>\n+!\n+    INTEGER(KIND=1) :: i(1)\n+    i = (/ TRANSFER(\"a\", 0_1) /)\n+    if (i(1) .ne. ichar (\"a\")) call abort ()\n+  END subroutine pr31427\n+end program simplify_transfer"}, {"sha": "8f0380af9d24429a29f8ccb5db14f36f43620f47", "filename": "gcc/testsuite/gfortran.dg/transfer_simplify_2.f90", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7433458d871f6bfe2169b9d7d04fec64bb142924/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90?ref=7433458d871f6bfe2169b9d7d04fec64bb142924", "patch": "@@ -0,0 +1,155 @@\n+! { dg-do run }\n+! { dg-options \"-O2\" }\n+! Tests the fix for the meta-bug PR31237 (TRANSFER intrinsic)\n+! Exercises gfc_simplify_transfer a random walk through types and shapes\n+! and compares its results with the middle-end version that operates on\n+! variables.\n+!\n+  implicit none\n+  call integer4_to_real4\n+  call real4_to_integer8\n+  call integer4_to_integer8\n+  call logical4_to_real8\n+  call real8_to_integer4\n+  call integer8_to_real4\n+  call integer8_to_complex4\n+  call character16_to_complex8\n+  call character16_to_real8\n+  call real8_to_character2\n+  call dt_to_integer1\n+  call character16_to_dt\n+contains\n+  subroutine integer4_to_real4\n+    integer(4), parameter ::  i1 = 11111_4\n+    integer(4)            ::  i2 = i1\n+    real(4), parameter    ::  r1 = transfer (i1, 1.0_4)\n+    real(4)               ::  r2\n+\n+    r2 = transfer (i2, r2);\n+    if (r1 .ne. r2) call abort ()\n+  end subroutine integer4_to_real4\n+\n+  subroutine real4_to_integer8\n+    real(4), parameter    ::  r1(2) = (/3.14159_4, 0.0_4/)\n+    real(4)               ::  r2(2) = r1\n+    integer(8), parameter ::  i1 = transfer (r1, 1_8)\n+    integer(8)            ::  i2\n+\n+    i2 = transfer (r2, 1_8);\n+    if (i1 .ne. i2) call abort ()\n+  end subroutine real4_to_integer8\n+\n+  subroutine integer4_to_integer8\n+    integer(4), parameter ::  i1(2) = (/11111_4, 22222_4/)\n+    integer(4)            ::  i2(2) = i1\n+    integer(8), parameter ::  i3 = transfer (i1, 1_8)\n+    integer(8)            ::  i4\n+\n+    i4 = transfer (i2, 1_8);\n+    if (i3 .ne. i4) call abort ()\n+  end subroutine integer4_to_integer8\n+\n+  subroutine logical4_to_real8\n+    logical(4), parameter ::  l1(2) = (/.false., .true./)\n+    logical(4)            ::  l2(2) = l1\n+    real(8), parameter    ::  r1 = transfer (l1, 1_8)\n+    real(8)               ::  r2\n+\n+    r2 = transfer (l2, 1_8);\n+    if (r1 .ne. r2) call abort ()\n+  end subroutine logical4_to_real8\n+\n+  subroutine real8_to_integer4\n+    real(8), parameter    ::  r1 = 3.14159_8\n+    real(8)               ::  r2 = r1\n+    integer(4), parameter ::  i1(2) = transfer (r1, 1_4, 2)\n+    integer(4)            ::  i2(2)\n+\n+    i2 = transfer (r2, i2, 2);\n+    if (any (i1 .ne. i2)) call abort ()\n+  end subroutine real8_to_integer4\n+\n+  subroutine integer8_to_real4\n+    integer               ::  k\n+    integer(8), parameter ::  i1(2) = transfer ((/asin (1.0_8), log (1.0_8)/), i1)\n+    integer(8)            ::  i2(2) = i1\n+    real(4), parameter    ::  r1(4) = transfer (i1, (/(1.0_4,k=1,4)/))\n+    real(4)               ::  r2(4)\n+\n+    r2 = transfer (i2, r2);\n+    if (any (r1 .ne. r2)) call abort ()\n+  end subroutine integer8_to_real4\n+\n+  subroutine integer8_to_complex4\n+    integer               ::  k\n+    integer(8), parameter ::  i1(2) = transfer ((/asin (1.0_8), log (1.0_8)/), i1)\n+    integer(8)            ::  i2(2) = i1\n+    complex(4), parameter ::  z1(2) = transfer (i1, (/((1.0_4,2.0_4),k=1,2)/))\n+    complex(4)            ::  z2(2)\n+\n+    z2 = transfer (i2, z2);\n+    if (any (z1 .ne. z2)) call abort ()\n+  end subroutine integer8_to_complex4\n+\n+  subroutine character16_to_complex8\n+    character(16), parameter ::  c1(2) = (/\"abcdefghijklmnop\",\"qrstuvwxyz1234567890\"/)\n+    character(16)            ::  c2(2) = c1\n+    complex(8), parameter    ::  z1(2) = transfer (c1, (1.0_8,1.0_8), 2)\n+    complex(8)               ::  z2(2)\n+\n+    z2 = transfer (c2, z2, 2);\n+    if (any (z1 .ne. z2)) call abort ()\n+  end subroutine character16_to_complex8\n+\n+  subroutine character16_to_real8\n+    character(16), parameter ::  c1 = \"abcdefghijklmnop\"\n+    character(16)            ::  c2 = c1\n+    real(8), parameter    ::  r1(2) = transfer (c1, 1.0_8, 2)\n+    real(8)               ::  r2(2)\n+\n+    r2 = transfer (c2, r2, 2);\n+    if (any (r1 .ne. r2)) call abort ()\n+  end subroutine character16_to_real8\n+\n+  subroutine real8_to_character2\n+    real(8), parameter    ::  r1 = 3.14159_8\n+    real(8)               ::  r2 = r1\n+    character(2), parameter ::  c1(4) = transfer (r1, \"ab\", 4)\n+    character(2)            ::  c2(4)\n+\n+    c2 = transfer (r2, \"ab\", 4);\n+    if (any (c1 .ne. c2)) call abort ()\n+  end subroutine real8_to_character2\n+\n+  subroutine dt_to_integer1\n+    integer, parameter    :: i1(4) = (/1_4,2_4,3_4,4_4/)\n+    real, parameter       :: r1(4) = (/1.0_4,2.0_4,3.0_4,4.0_4/)\n+    type :: mytype\n+      integer(4) :: i(4)\n+      real(4) :: x(4)\n+    end type mytype\n+    type (mytype), parameter :: dt1 = mytype (i1, r1)\n+    type (mytype)            :: dt2 = dt1\n+    integer(1), parameter :: i2(32) = transfer (dt1, 1_1, 32)\n+    integer(1)            :: i3(32)\n+\n+    i3 = transfer (dt2, 1_1, 32);\n+    if (any (i2 .ne. i3)) call abort ()\n+  end subroutine dt_to_integer1\n+\n+  subroutine character16_to_dt\n+    character(16), parameter ::  c1 = \"abcdefghijklmnop\"\n+    character(16)            ::  c2 = c1\n+    type :: mytype\n+      real(4) :: x(2)\n+    end type mytype\n+\n+    type (mytype), parameter :: dt1(2) = transfer (c1, mytype ((/1.0,2.0,3.0,4.0/)), 2)\n+    type (mytype)            :: dt2(2)\n+\n+    dt2 = transfer (c2, dt2);\n+    if (any (dt1(1)%x .ne. dt2(1)%x)) call abort ()\n+    if (any (dt1(2)%x .ne. dt2(2)%x)) call abort ()\n+  end subroutine character16_to_dt\n+\n+end"}]}