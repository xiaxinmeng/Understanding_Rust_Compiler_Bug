{"sha": "78be79d534fbcf2799c2c4e0b2c768134c9990d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiZTc5ZDUzNGZiY2YyNzk5YzJjNGUwYjJjNzY4MTM0Yzk5OTBkNA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2011-05-24T18:02:22Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2011-05-24T18:02:22Z"}, "message": "re PR tree-optimization/46728 (GCC does not generate fmadd for pow (x, 0.75)+y on powerpc)\n\n2011-05-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\t\n\tPR tree-optimization/46728\n\t* tree-ssa-math-opts.c (powi_table): New.\n\t(powi_lookup_cost): New.\n\t(powi_cost): New.\n\t(powi_as_mults_1): New.\n\t(powi_as_mults): New.\n\t(gimple_expand_builtin_powi): New.\n\t(execute_cse_sincos): Add switch case for BUILT_IN_POWI.\n\t(gate_cse_sincos): Remove sincos/cexp restriction.\n\nFrom-SVN: r174129", "tree": {"sha": "5d87bb0e9ded13761747ce42efda4d73a2801348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d87bb0e9ded13761747ce42efda4d73a2801348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78be79d534fbcf2799c2c4e0b2c768134c9990d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78be79d534fbcf2799c2c4e0b2c768134c9990d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78be79d534fbcf2799c2c4e0b2c768134c9990d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78be79d534fbcf2799c2c4e0b2c768134c9990d4/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "caee412b75f90163b2ef164881a9737408f61a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caee412b75f90163b2ef164881a9737408f61a4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caee412b75f90163b2ef164881a9737408f61a4e"}], "stats": {"total": 275, "additions": 269, "deletions": 6}, "files": [{"sha": "15658231c19f71958503349baee4183f42203f0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78be79d534fbcf2799c2c4e0b2c768134c9990d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78be79d534fbcf2799c2c4e0b2c768134c9990d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78be79d534fbcf2799c2c4e0b2c768134c9990d4", "patch": "@@ -1,3 +1,15 @@\n+2011-05-24  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\t\n+\tPR tree-optimization/46728\n+\t* tree-ssa-math-opts.c (powi_table): New.\n+\t(powi_lookup_cost): New.\n+\t(powi_cost): New.\n+\t(powi_as_mults_1): New.\n+\t(powi_as_mults): New.\n+\t(gimple_expand_builtin_powi): New.\n+\t(execute_cse_sincos): Add switch case for BUILT_IN_POWI.\n+\t(gate_cse_sincos): Remove sincos/cexp restriction.\n+\t\n 2011-05-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/3746"}, {"sha": "26cdc6935063217ec6aec3dcb6a0bc64258ffe30", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 257, "deletions": 6, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78be79d534fbcf2799c2c4e0b2c768134c9990d4/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78be79d534fbcf2799c2c4e0b2c768134c9990d4/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=78be79d534fbcf2799c2c4e0b2c768134c9990d4", "patch": "@@ -795,8 +795,238 @@ execute_cse_sincos_1 (tree name)\n   return cfg_changed;\n }\n \n+/* To evaluate powi(x,n), the floating point value x raised to the\n+   constant integer exponent n, we use a hybrid algorithm that\n+   combines the \"window method\" with look-up tables.  For an\n+   introduction to exponentiation algorithms and \"addition chains\",\n+   see section 4.6.3, \"Evaluation of Powers\" of Donald E. Knuth,\n+   \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer Programming\",\n+   3rd Edition, 1998, and Daniel M. Gordon, \"A Survey of Fast Exponentiation\n+   Methods\", Journal of Algorithms, Vol. 27, pp. 129-146, 1998.  */\n+\n+/* Provide a default value for POWI_MAX_MULTS, the maximum number of\n+   multiplications to inline before calling the system library's pow\n+   function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,\n+   so this default never requires calling pow, powf or powl.  */\n+\n+#ifndef POWI_MAX_MULTS\n+#define POWI_MAX_MULTS  (2*HOST_BITS_PER_WIDE_INT-2)\n+#endif\n+\n+/* The size of the \"optimal power tree\" lookup table.  All\n+   exponents less than this value are simply looked up in the\n+   powi_table below.  This threshold is also used to size the\n+   cache of pseudo registers that hold intermediate results.  */\n+#define POWI_TABLE_SIZE 256\n+\n+/* The size, in bits of the window, used in the \"window method\"\n+   exponentiation algorithm.  This is equivalent to a radix of\n+   (1<<POWI_WINDOW_SIZE) in the corresponding \"m-ary method\".  */\n+#define POWI_WINDOW_SIZE 3\n+\n+/* The following table is an efficient representation of an\n+   \"optimal power tree\".  For each value, i, the corresponding\n+   value, j, in the table states than an optimal evaluation\n+   sequence for calculating pow(x,i) can be found by evaluating\n+   pow(x,j)*pow(x,i-j).  An optimal power tree for the first\n+   100 integers is given in Knuth's \"Seminumerical algorithms\".  */\n+\n+static const unsigned char powi_table[POWI_TABLE_SIZE] =\n+  {\n+      0,   1,   1,   2,   2,   3,   3,   4,  /*   0 -   7 */\n+      4,   6,   5,   6,   6,  10,   7,   9,  /*   8 -  15 */\n+      8,  16,   9,  16,  10,  12,  11,  13,  /*  16 -  23 */\n+     12,  17,  13,  18,  14,  24,  15,  26,  /*  24 -  31 */\n+     16,  17,  17,  19,  18,  33,  19,  26,  /*  32 -  39 */\n+     20,  25,  21,  40,  22,  27,  23,  44,  /*  40 -  47 */\n+     24,  32,  25,  34,  26,  29,  27,  44,  /*  48 -  55 */\n+     28,  31,  29,  34,  30,  60,  31,  36,  /*  56 -  63 */\n+     32,  64,  33,  34,  34,  46,  35,  37,  /*  64 -  71 */\n+     36,  65,  37,  50,  38,  48,  39,  69,  /*  72 -  79 */\n+     40,  49,  41,  43,  42,  51,  43,  58,  /*  80 -  87 */\n+     44,  64,  45,  47,  46,  59,  47,  76,  /*  88 -  95 */\n+     48,  65,  49,  66,  50,  67,  51,  66,  /*  96 - 103 */\n+     52,  70,  53,  74,  54, 104,  55,  74,  /* 104 - 111 */\n+     56,  64,  57,  69,  58,  78,  59,  68,  /* 112 - 119 */\n+     60,  61,  61,  80,  62,  75,  63,  68,  /* 120 - 127 */\n+     64,  65,  65, 128,  66, 129,  67,  90,  /* 128 - 135 */\n+     68,  73,  69, 131,  70,  94,  71,  88,  /* 136 - 143 */\n+     72, 128,  73,  98,  74, 132,  75, 121,  /* 144 - 151 */\n+     76, 102,  77, 124,  78, 132,  79, 106,  /* 152 - 159 */\n+     80,  97,  81, 160,  82,  99,  83, 134,  /* 160 - 167 */\n+     84,  86,  85,  95,  86, 160,  87, 100,  /* 168 - 175 */\n+     88, 113,  89,  98,  90, 107,  91, 122,  /* 176 - 183 */\n+     92, 111,  93, 102,  94, 126,  95, 150,  /* 184 - 191 */\n+     96, 128,  97, 130,  98, 133,  99, 195,  /* 192 - 199 */\n+    100, 128, 101, 123, 102, 164, 103, 138,  /* 200 - 207 */\n+    104, 145, 105, 146, 106, 109, 107, 149,  /* 208 - 215 */\n+    108, 200, 109, 146, 110, 170, 111, 157,  /* 216 - 223 */\n+    112, 128, 113, 130, 114, 182, 115, 132,  /* 224 - 231 */\n+    116, 200, 117, 132, 118, 158, 119, 206,  /* 232 - 239 */\n+    120, 240, 121, 162, 122, 147, 123, 152,  /* 240 - 247 */\n+    124, 166, 125, 214, 126, 138, 127, 153,  /* 248 - 255 */\n+  };\n+\n+\n+/* Return the number of multiplications required to calculate\n+   powi(x,n) where n is less than POWI_TABLE_SIZE.  This is a\n+   subroutine of powi_cost.  CACHE is an array indicating\n+   which exponents have already been calculated.  */\n+\n+static int\n+powi_lookup_cost (unsigned HOST_WIDE_INT n, bool *cache)\n+{\n+  /* If we've already calculated this exponent, then this evaluation\n+     doesn't require any additional multiplications.  */\n+  if (cache[n])\n+    return 0;\n+\n+  cache[n] = true;\n+  return powi_lookup_cost (n - powi_table[n], cache)\n+\t + powi_lookup_cost (powi_table[n], cache) + 1;\n+}\n+\n+/* Return the number of multiplications required to calculate\n+   powi(x,n) for an arbitrary x, given the exponent N.  This\n+   function needs to be kept in sync with powi_as_mults below.  */\n+\n+static int\n+powi_cost (HOST_WIDE_INT n)\n+{\n+  bool cache[POWI_TABLE_SIZE];\n+  unsigned HOST_WIDE_INT digit;\n+  unsigned HOST_WIDE_INT val;\n+  int result;\n+\n+  if (n == 0)\n+    return 0;\n+\n+  /* Ignore the reciprocal when calculating the cost.  */\n+  val = (n < 0) ? -n : n;\n+\n+  /* Initialize the exponent cache.  */\n+  memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));\n+  cache[1] = true;\n+\n+  result = 0;\n+\n+  while (val >= POWI_TABLE_SIZE)\n+    {\n+      if (val & 1)\n+\t{\n+\t  digit = val & ((1 << POWI_WINDOW_SIZE) - 1);\n+\t  result += powi_lookup_cost (digit, cache)\n+\t\t    + POWI_WINDOW_SIZE + 1;\n+\t  val >>= POWI_WINDOW_SIZE;\n+\t}\n+      else\n+\t{\n+\t  val >>= 1;\n+\t  result++;\n+\t}\n+    }\n+\n+  return result + powi_lookup_cost (val, cache);\n+}\n+\n+/* Recursive subroutine of powi_as_mults.  This function takes the\n+   array, CACHE, of already calculated exponents and an exponent N and\n+   returns a tree that corresponds to CACHE[1]**N, with type TYPE.  */\n+\n+static tree\n+powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,\n+\t\t HOST_WIDE_INT n, tree *cache, tree target)\n+{\n+  tree op0, op1, ssa_target;\n+  unsigned HOST_WIDE_INT digit;\n+  gimple mult_stmt;\n+\n+  if (n < POWI_TABLE_SIZE && cache[n])\n+    return cache[n];\n+\n+  ssa_target = make_ssa_name (target, NULL);\n+\n+  if (n < POWI_TABLE_SIZE)\n+    {\n+      cache[n] = ssa_target;\n+      op0 = powi_as_mults_1 (gsi, loc, type, n - powi_table[n], cache, target);\n+      op1 = powi_as_mults_1 (gsi, loc, type, powi_table[n], cache, target);\n+    }\n+  else if (n & 1)\n+    {\n+      digit = n & ((1 << POWI_WINDOW_SIZE) - 1);\n+      op0 = powi_as_mults_1 (gsi, loc, type, n - digit, cache, target);\n+      op1 = powi_as_mults_1 (gsi, loc, type, digit, cache, target);\n+    }\n+  else\n+    {\n+      op0 = powi_as_mults_1 (gsi, loc, type, n >> 1, cache, target);\n+      op1 = op0;\n+    }\n+\n+  mult_stmt = gimple_build_assign_with_ops (MULT_EXPR, ssa_target, op0, op1);\n+  gsi_insert_before (gsi, mult_stmt, GSI_SAME_STMT);\n+\n+  return ssa_target;\n+}\n+\n+/* Convert ARG0**N to a tree of multiplications of ARG0 with itself.\n+   This function needs to be kept in sync with powi_cost above.  */\n+\n+static tree\n+powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,\n+\t       tree arg0, HOST_WIDE_INT n)\n+{\n+  tree cache[POWI_TABLE_SIZE], result, type = TREE_TYPE (arg0), target;\n+  gimple div_stmt;\n+\n+  if (n == 0)\n+    return build_real (type, dconst1);\n+\n+  memset (cache, 0,  sizeof (cache));\n+  cache[1] = arg0;\n+\n+  target = create_tmp_var (type, \"powmult\");\n+  add_referenced_var (target);\n+\n+  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache, target);\n+\n+  if (n >= 0)\n+    return result;\n+\n+  /* If the original exponent was negative, reciprocate the result.  */\n+  target = make_ssa_name (target, NULL);\n+  div_stmt = gimple_build_assign_with_ops (RDIV_EXPR, target, \n+\t\t\t\t\t   build_real (type, dconst1),\n+\t\t\t\t\t   result);\n+  gsi_insert_before (gsi, div_stmt, GSI_SAME_STMT);\n+\n+  return target;\n+}\n+\n+/* ARG0 and N are the two arguments to a powi builtin in GSI with\n+   location info LOC.  If the arguments are appropriate, create an\n+   equivalent sequence of statements prior to GSI using an optimal\n+   number of multiplications, and return an expession holding the\n+   result.  */\n+\n+static tree\n+gimple_expand_builtin_powi (gimple_stmt_iterator *gsi, location_t loc, \n+\t\t\t    tree arg0, HOST_WIDE_INT n)\n+{\n+  /* Avoid largest negative number.  */\n+  if (n != -n\n+      && ((n >= -1 && n <= 2)\n+\t  || (optimize_function_for_speed_p (cfun)\n+\t      && powi_cost (n) <= POWI_MAX_MULTS)))\n+    return powi_as_mults (gsi, loc, arg0, n);\n+\n+  return NULL_TREE;\n+}\n+\n /* Go through all calls to sin, cos and cexpi and call execute_cse_sincos_1\n-   on the SSA_NAME argument of each of them.  */\n+   on the SSA_NAME argument of each of them.  Also expand powi(x,n) into\n+   an optimal number of multiplies, when n is a constant.  */\n \n static unsigned int\n execute_cse_sincos (void)\n@@ -821,7 +1051,9 @@ execute_cse_sincos (void)\n \t      && (fndecl = gimple_call_fndecl (stmt))\n \t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n \t    {\n-\t      tree arg;\n+\t      tree arg, arg0, arg1, result;\n+\t      HOST_WIDE_INT n;\n+\t      location_t loc;\n \n \t      switch (DECL_FUNCTION_CODE (fndecl))\n \t\t{\n@@ -833,6 +1065,26 @@ execute_cse_sincos (void)\n \t\t    cfg_changed |= execute_cse_sincos_1 (arg);\n \t\t  break;\n \n+\t\tCASE_FLT_FN (BUILT_IN_POWI):\n+\t\t  arg0 = gimple_call_arg (stmt, 0);\n+\t\t  arg1 = gimple_call_arg (stmt, 1);\n+\t\t  if (!host_integerp (arg1, 0))\n+\t\t    break;\n+\n+\t\t  n = TREE_INT_CST_LOW (arg1);\n+\t\t  loc = gimple_location (stmt);\n+\t\t  result = gimple_expand_builtin_powi (&gsi, loc, arg0, n);\n+\n+\t\t  if (result)\n+\t\t    {\n+\t\t      tree lhs = gimple_get_lhs (stmt);\n+\t\t      gimple new_stmt = gimple_build_assign (lhs, result);\n+\t\t      gimple_set_location (new_stmt, loc);\n+\t\t      unlink_stmt_vdef (stmt);\n+\t\t      gsi_replace (&gsi, new_stmt, true);\n+\t\t    }\n+\t\t  break;\n+\n \t\tdefault:;\n \t\t}\n \t    }\n@@ -849,10 +1101,9 @@ execute_cse_sincos (void)\n static bool\n gate_cse_sincos (void)\n {\n-  /* Make sure we have either sincos or cexp.  */\n-  return (TARGET_HAS_SINCOS\n-\t  || TARGET_C99_FUNCTIONS)\n-\t && optimize;\n+  /* We no longer require either sincos or cexp, since powi expansion\n+     piggybacks on this pass.  */\n+  return optimize;\n }\n \n struct gimple_opt_pass pass_cse_sincos ="}]}