{"sha": "e675826dea44873ffe26d9d2e71526334425d8e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3NTgyNmRlYTQ0ODczZmZlMjZkOWQyZTcxNTI2MzM0NDI1ZDhlMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-08-15T22:34:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-08-15T22:34:52Z"}, "message": "expr.c (expand_expr_real_1): When converting to BLKmode, try to fetch an inner memory reference.\n\n\t* expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: When converting\n\tto BLKmode, try to fetch an inner memory reference.  Use 'mode' in\n\tlieu of TYPE_MODE (type) throughout.\n\nFrom-SVN: r139139", "tree": {"sha": "aa2269ed96c51ccd901f9a4af5d73c91dd71b1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa2269ed96c51ccd901f9a4af5d73c91dd71b1cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e675826dea44873ffe26d9d2e71526334425d8e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e675826dea44873ffe26d9d2e71526334425d8e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e675826dea44873ffe26d9d2e71526334425d8e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e675826dea44873ffe26d9d2e71526334425d8e0/comments", "author": null, "committer": null, "parents": [{"sha": "853ff9e23ea76554cfef2657733e6e8aa14ebbdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/853ff9e23ea76554cfef2657733e6e8aa14ebbdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/853ff9e23ea76554cfef2657733e6e8aa14ebbdb"}], "stats": {"total": 109, "additions": 90, "deletions": 19}, "files": [{"sha": "a13ac05b864152058d2df7097e421a67cefdc417", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e675826dea44873ffe26d9d2e71526334425d8e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e675826dea44873ffe26d9d2e71526334425d8e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e675826dea44873ffe26d9d2e71526334425d8e0", "patch": "@@ -1,3 +1,9 @@\n+2008-08-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (expand_expr_real_1) <VIEW_CONVERT_EXPR>: When converting\n+\tto BLKmode, try to fetch an inner memory reference.  Use 'mode' in\n+\tlieu of TYPE_MODE (type) throughout.\n+\n 2008-08-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/arm/arm.c (add_minipool_backward_ref): Check for"}, {"sha": "1d994c55b081763c82260ab09d099ce31cd291dc", "filename": "gcc/expr.c", "status": "modified", "additions": 84, "deletions": 19, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e675826dea44873ffe26d9d2e71526334425d8e0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e675826dea44873ffe26d9d2e71526334425d8e0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e675826dea44873ffe26d9d2e71526334425d8e0", "patch": "@@ -8157,26 +8157,89 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return REDUCE_BIT_FIELD (op0);\n \n     case VIEW_CONVERT_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);\n+      op0 = NULL_RTX;\n+\n+      /* If we are converting to BLKmode, try to avoid an intermediate\n+\t temporary by fetching an inner memory reference.  */\n+      if (mode == BLKmode\n+\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n+\t  && TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != BLKmode\n+\t  && handled_component_p (TREE_OPERAND (exp, 0)))\n+      {\n+\tenum machine_mode mode1;\n+\tHOST_WIDE_INT bitsize, bitpos;\n+\ttree offset;\n+\tint unsignedp;\n+\tint volatilep = 0;\n+\ttree tem\n+\t  = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, &bitpos,\n+\t\t\t\t &offset, &mode1, &unsignedp, &volatilep,\n+\t\t\t\t true);\n+\trtx orig_op0;\n+\n+\t/* ??? We should work harder and deal with non-zero offsets.  */\n+\tif (!offset\n+\t    && (bitpos % BITS_PER_UNIT) == 0\n+\t    && bitsize >= 0\n+\t    && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) == 0)\n+\t  {\n+\t    /* See the normal_inner_ref case for the rationale.  */\n+\t    orig_op0\n+\t      = expand_expr (tem,\n+\t\t\t     (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n+\t\t\t      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n+\t\t\t\t  != INTEGER_CST)\n+\t\t\t      && modifier != EXPAND_STACK_PARM\n+\t\t\t      ? target : NULL_RTX),\n+\t\t\t     VOIDmode,\n+\t\t\t     (modifier == EXPAND_INITIALIZER\n+\t\t\t      || modifier == EXPAND_CONST_ADDRESS\n+\t\t\t      || modifier == EXPAND_STACK_PARM)\n+\t\t\t     ? modifier : EXPAND_NORMAL);\n+\n+\t    if (MEM_P (orig_op0))\n+\t      {\n+\t\top0 = orig_op0;\n+\n+\t\t/* Get a reference to just this component.  */\n+\t\tif (modifier == EXPAND_CONST_ADDRESS\n+\t\t    || modifier == EXPAND_SUM\n+\t\t    || modifier == EXPAND_INITIALIZER)\n+\t\t  op0 = adjust_address_nv (op0, mode, bitpos / BITS_PER_UNIT);\n+\t\telse\n+\t\t  op0 = adjust_address (op0, mode, bitpos / BITS_PER_UNIT);\n+\n+\t\tif (op0 == orig_op0)\n+\t\t  op0 = copy_rtx (op0);\n+\n+\t\tset_mem_attributes (op0, TREE_OPERAND (exp, 0), 0);\n+\t\tif (REG_P (XEXP (op0, 0)))\n+\t\t  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n+\n+\t\tMEM_VOLATILE_P (op0) |= volatilep;\n+\t      }\n+\t  }\n+      }\n+\n+      if (!op0)\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, modifier);\n \n       /* If the input and output modes are both the same, we are done.  */\n-      if (TYPE_MODE (type) == GET_MODE (op0))\n+      if (mode == GET_MODE (op0))\n \t;\n       /* If neither mode is BLKmode, and both modes are the same size\n \t then we can use gen_lowpart.  */\n-      else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode\n-\t       && GET_MODE_SIZE (TYPE_MODE (type))\n-\t\t   == GET_MODE_SIZE (GET_MODE (op0)))\n+      else if (mode != BLKmode && GET_MODE (op0) != BLKmode\n+\t       && GET_MODE_SIZE (mode) == GET_MODE_SIZE (GET_MODE (op0)))\n \t{\n \t  if (GET_CODE (op0) == SUBREG)\n \t    op0 = force_reg (GET_MODE (op0), op0);\n-\t  op0 = gen_lowpart (TYPE_MODE (type), op0);\n+\t  op0 = gen_lowpart (mode, op0);\n \t}\n       /* If both modes are integral, then we can convert from one to the\n \t other.  */\n-      else if (SCALAR_INT_MODE_P (GET_MODE (op0))\n-\t       && SCALAR_INT_MODE_P (TYPE_MODE (type)))\n-\top0 = convert_modes (TYPE_MODE (type), GET_MODE (op0), op0,\n+      else if (SCALAR_INT_MODE_P (GET_MODE (op0)) && SCALAR_INT_MODE_P (mode))\n+\top0 = convert_modes (mode, GET_MODE (op0), op0, \n \t\t\t     TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n@@ -8200,8 +8263,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  op0 = target;\n \t}\n \n-      /* At this point, OP0 is in the correct mode.  If the output type is such\n-\t that the operand is known to be aligned, indicate that it is.\n+      /* At this point, OP0 is in the correct mode.  If the output type is\n+\t such that the operand is known to be aligned, indicate that it is.\n \t Otherwise, we need only be concerned about alignment for non-BLKmode\n \t results.  */\n       if (MEM_P (op0))\n@@ -8210,22 +8273,24 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t  if (TYPE_ALIGN_OK (type))\n \t    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));\n-\t  else if (TYPE_MODE (type) != BLKmode && STRICT_ALIGNMENT\n-\t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t  else if (STRICT_ALIGNMENT\n+\t\t   && mode != BLKmode\n+\t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (mode))\n \t    {\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t      HOST_WIDE_INT temp_size\n \t\t= MAX (int_size_in_bytes (inner_type),\n-\t\t       (HOST_WIDE_INT) GET_MODE_SIZE (TYPE_MODE (type)));\n-\t      rtx new_rtx = assign_stack_temp_for_type (TYPE_MODE (type),\n-\t\t\t\t\t\t\ttemp_size, 0, type);\n-\t      rtx new_with_op0_mode = adjust_address (new_rtx, GET_MODE (op0), 0);\n+\t\t       (HOST_WIDE_INT) GET_MODE_SIZE (mode));\n+\t      rtx new_rtx\n+\t\t= assign_stack_temp_for_type (mode, temp_size, 0, type);\n+\t      rtx new_with_op0_mode\n+\t\t= adjust_address (new_rtx, GET_MODE (op0), 0);\n \n \t      gcc_assert (!TREE_ADDRESSABLE (exp));\n \n \t      if (GET_MODE (op0) == BLKmode)\n \t\temit_block_move (new_with_op0_mode, op0,\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))),\n+\t\t\t\t GEN_INT (GET_MODE_SIZE (mode)),\n \t\t\t\t (modifier == EXPAND_STACK_PARM\n \t\t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t      else\n@@ -8234,7 +8299,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      op0 = new_rtx;\n \t    }\n \n-\t  op0 = adjust_address (op0, TYPE_MODE (type), 0);\n+\t  op0 = adjust_address (op0, mode, 0);\n \t}\n \n       return op0;"}]}