{"sha": "a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhZWRiYzI2ZDYxZmJlMmZlZjUzMjU0NDA4ZGJiYjM3YzM5OTJmYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-16T21:10:32Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-16T21:10:32Z"}, "message": "71st Cygnus<->FSF merge\n\nFrom-SVN: r9719", "tree": {"sha": "028f47896fbbf644d31fd3de7372df8ca1a6bd39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/028f47896fbbf644d31fd3de7372df8ca1a6bd39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/comments", "author": null, "committer": null, "parents": [{"sha": "45ca9d09a13dac9ef4d013ede726cfa1e270649c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ca9d09a13dac9ef4d013ede726cfa1e270649c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ca9d09a13dac9ef4d013ede726cfa1e270649c"}], "stats": {"total": 795, "additions": 622, "deletions": 173}, "files": [{"sha": "9e97ca62db7a31647d65811a4e7eab009dc58e29", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -1,3 +1,73 @@\n+Tue May 16 12:40:16 1995  Jason Merrill  <jason@lisa.cygnus.com>\n+\n+\t* lex.c (handle_sysv_pragma): Don't use token_buffer.\n+\n+Tue May 16 12:05:26 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (resolve_scope_to_name): Add initial semantic support for\n+\tnamespaces.\n+\t* class.c (finish_struct): Ditto.\n+\t* cp-tree.h (NAMESPACE_LEVEL): Ditto.\n+\t* cvt.c (build_up_reference, convert_to_reference): Ditto. \n+\t* decl.c (binding_level::namespace_p, suspend_binding_level): Ditto.\n+\t(resume_binding_level, toplevel_bindings_p): Ditto\n+\t(namespace_bindings_p, declare_namespace_level): Ditto.\n+\t(resume_level, push_namespace, pop_namespace): Ditto.\n+\t(pop_everything, pushtag, duplicate_decls, pushdecl): Ditto.\n+\t(implicitly_declare, lookup_namespace_name, lookup_name_real): Ditto.\n+\t(start_decl, make_temporary_for_reference), Ditto.\n+\t(obscure_complex_init, finish_decl, expand_static_init): Ditto.\n+\t(grokvardecl, grokdeclarator, parmlist_is_exprlist): Ditto.\n+\t(store_parm_decls, hack_incomplete_structures): Ditto.\n+\t* decl2.c (get_temp_name, finish_anon_union, current_namespace): Ditto.\n+\t(push_namespace, pop_namespace, do_namespace_alias): Ditto.\n+\t(do_toplevel_using_decl, do_class_using_decl): Ditto.\n+\t* error.c (dump_decl): Ditto.\n+\t* init.c (build_member_call, build_offset_ref): Ditto.\n+\t* lex.c (identifier_type): Ditto.\n+\t* parse.y (lang_extdef, using_decl, extdef, component_decl_1): Ditto.\n+\t(nested_name_specifier_1): Ditto.\n+\t* spew.c (yylex): Ditto.\n+\t* tree.def (NAMESPACE_DECL): Ditto.\n+\n+Tue May 16 11:55:35 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (push_overloaded_decl): Return the new decl even if it\n+\tcan't be pushed.\n+\n+Tue May 16 11:00:37 1995  Jason Merrill  <jason@lisa.cygnus.com>\n+\n+\t* typeck.c (decay_conversion): Split out from default_conversion.\n+\t(default_conversion): Call it.\n+\t(build_binary_op): Ditto.\n+\t(build_binary_op_nodefault): Use decay_conversion for truth ops.\n+\n+Mon May 15 12:47:56 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (warn_extern_redeclared_static): This is a pedwarn.\n+\t(duplicate_decls): Always use the old decl's linkage info.  Don't\n+\tplay with linkage of consts.\n+\t(pushdecl): Don't play with linkage of consts.\n+\t(redeclaration_error_message): Don't complain about an old public\n+\tdecl and a new non-public decl here.\n+\t(grokvardecl): Handle linkage of consts here.\n+\t(grokdeclarator): An 'extern inline' is public.  Pass constp to\n+\tgrokvardecl.\n+\t(start_function): Wait until after the pushdecl to do some linkage\n+\tstuff.\n+\n+\t* decl2.c (import_export_vtable): Make duplicates weak rather than\n+\tstatic if supported.\n+\t(import_export_inline): Ditto.\n+\t* pt.c (do_pending_expansions): Ditto.\n+\n+\t* class.c (build_vbase_path): flag_assume_nonnull_objects only\n+\taffects reference conversion.\n+\n+\t* init.c (emit_base_init): Build up an RTL_EXPR and add it to\n+        rtl_expr_chain.\n+\t* decl.c, decl2.c: s/base_init_insns/base_init_expr/.\n+\n Tue May 16 07:06:28 1995  Paul Eggert  <eggert@twinsun.com>\n \n \t* method.c (numeric_output_need_bar): Renamed from misspelling."}, {"sha": "ae14d8f54a22140175b5ec7cce23f17a82dc031a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -1380,6 +1380,7 @@ resolve_scope_to_name (outer_type, inner_stuff)\n \n   if (outer_type == NULL_TREE)\n     {\n+      tree x;\n       /* If we have something that's already a type by itself,\n \t use that.  */\n       if (IDENTIFIER_HAS_TYPE_VALUE (inner_name))\n@@ -1389,6 +1390,14 @@ resolve_scope_to_name (outer_type, inner_stuff)\n \t\t\t\t\t  inner_type);\n \t  return inner_name;\n \t}\n+      \n+      x = lookup_name (inner_name, 0);\n+\n+      if (x && TREE_CODE (x) == NAMESPACE_DECL)\n+\t{\n+\t  x = lookup_namespace_name (x, inner_type);\n+\t  return x;\n+\t}\n       return NULL_TREE;\n     }\n "}, {"sha": "7463058e760abf365f654810b684971df01aafa9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -237,7 +237,9 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t\t    }\n \t\t  ind = build_indirect_ref (nonnull_expr, NULL_PTR);\n \t\t  nonnull_expr = build_vbase_pointer (ind, last_virtual);\n-\t\t  if (nonnull == 0 && !flag_assume_nonnull_objects\n+\t\t  if (nonnull == 0\n+\t\t      && (TREE_CODE (type) == POINTER_TYPE\n+\t\t\t  || !flag_assume_nonnull_objects)\n \t\t      && null_expr == NULL_TREE)\n \t\t    {\n \t\t      null_expr = build1 (NOP_EXPR, TYPE_POINTER_TO (last_virtual), integer_zero_node);\n@@ -4106,7 +4108,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n \n   /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (t, global_bindings_p ());\n+  rest_of_type_compilation (t, toplevel_bindings_p ());\n \n   return t;\n }"}, {"sha": "f8a2fc7a596dd98043a14092d0f756233702260b", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -101,3 +101,6 @@ DEFTREECODE (UNINSTANTIATED_P_TYPE, \"uninstantiated_p_type\", \"t\", 0)\n \n    Other kinds of thunks may be defined later. */\n DEFTREECODE (THUNK_DECL, \"thunk_decl\", \"d\", 0)\n+\n+/* A namespace declaration.  */\n+DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", \"d\", 0)"}, {"sha": "e2e72d440a4eb81828c866814958e7cc0cf07f53", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -928,6 +928,9 @@ struct lang_type\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  */\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_NONCOPIED_PARTS (NODE)\n+\n+/* The binding level associated with the namespace. */\n+#define NAMESPACE_LEVEL(NODE) ((NODE)->decl.arguments)\n \f\n struct lang_decl_flags\n {\n@@ -1956,6 +1959,7 @@ extern tree type_promotes_to\t\t\tPROTO((tree));\n \n /* decl.c */\n extern int global_bindings_p\t\t\tPROTO((void));\n+extern int toplevel_bindings_p\t\t\tPROTO((void));\n extern void keep_next_level\t\t\tPROTO((void));\n extern int kept_level_p\t\t\t\tPROTO((void));\n extern void declare_parm_level\t\t\tPROTO((void));\n@@ -2002,6 +2006,7 @@ extern tree gettags\t\t\t\tPROTO((void));\n extern void set_current_level_tags_transparency\tPROTO((int));\n extern tree typedecl_for_tag\t\t\tPROTO((tree));\n extern tree lookup_name\t\t\t\tPROTO((tree, int));\n+extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n extern void init_decl_processing\t\tPROTO((void));\n /* skipped define_function */\n@@ -2072,7 +2077,8 @@ extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree check_cp_case_value\t\t\tPROTO((tree));\n-extern tree do_using_decl\t\t\tPROTO((tree));\n+extern tree do_toplevel_using_decl\t\tPROTO((tree));\n+extern tree do_class_using_decl\t\t\tPROTO((tree));\n extern tree current_namespace_id\t\tPROTO((tree));\n extern tree get_namespace_id\t\t\tPROTO((void));\n "}, {"sha": "adc8b6408fed85bc98f7c6fc6567b0018309e7d2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -593,7 +593,7 @@ build_up_reference (type, arg, flags, checkconst)\n       else\n \t{\n \t  temp = get_temp_name (argtype, 0);\n-\t  if (global_bindings_p ())\n+\t  if (toplevel_bindings_p ())\n \t    {\n \t      /* Give this new temp some rtl and initialize it.  */\n \t      DECL_INITIAL (temp) = targ;\n@@ -770,10 +770,10 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t{\n \t  tree init;\n \n-\t  if (global_bindings_p ())\n+\t  if (toplevel_bindings_p ())\n \t    {\n \t      extern tree static_aggregates;\n-\t      tree t = get_temp_name (type, global_bindings_p ());\n+\t      tree t = get_temp_name (type, toplevel_bindings_p ());\n \t      init = build_method_call (t, constructor_name_full (type),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),"}, {"sha": "8ca4e232afc21ea0b0d61061262ec2c9b4789679", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 347, "deletions": 97, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -286,7 +286,7 @@ extern rtx cleanup_label, return_label;\n rtx original_result_rtx;\n \n /* Sequence of insns which represents base initialization.  */\n-rtx base_init_insns;\n+tree base_init_expr;\n \n /* C++: Keep these around to reduce calls to `get_identifier'.\n    Identifiers for `this' in member functions and the auto-delete\n@@ -578,7 +578,10 @@ struct binding_level\n        unfortunately.)  */\n     unsigned pseudo_global : 1;\n \n-    /* Two bits left for this word.  */\n+    /* This is set for a namespace binding level.  */\n+    unsigned namespace_p : 1;\n+\n+    /* One bit left for this word.  */\n \n #if defined(DEBUG_CP_BINDING_LEVELS)\n     /* Binding depth at which this level began.  */\n@@ -713,6 +716,90 @@ pop_binding_level ()\n       current_binding_level = current_binding_level->level_chain;\n   }\n }\n+\n+static void\n+suspend_binding_level ()\n+{\n+  if (class_binding_level)\n+    current_binding_level = class_binding_level;\n+\n+  if (global_binding_level)\n+    {\n+      /* cannot suspend a level, if there are none left to suspend. */\n+      if (current_binding_level == global_binding_level)\n+\tmy_friendly_abort (123);\n+    }\n+  /* Suspend the current level.  */\n+#if defined(DEBUG_CP_BINDING_LEVELS)\n+  binding_depth--;\n+  indent ();\n+  fprintf (stderr, \"suspend  %s level 0x%08x line %d\\n\",\n+\t  (is_class_level) ? \"class\" : \"block\",\n+\t  current_binding_level, lineno);\n+  if (is_class_level != (current_binding_level == class_binding_level))\n+#if 0 /* XXX Don't abort when we're watching how things are being managed.  */\n+    abort ();\n+#else\n+  {\n+    indent ();\n+    fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n+  }\n+#endif\n+  is_class_level = 0;\n+#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+  {\n+    register struct binding_level *level = current_binding_level;\n+    current_binding_level = current_binding_level->level_chain;\n+#if 0 /* defined(DEBUG_CP_BINDING_LEVELS) */\n+    if (level->binding_depth != binding_depth)\n+      abort ();\n+#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+\n+    class_binding_level = current_binding_level;\n+    if (class_binding_level->parm_flag != 2)\n+      class_binding_level = 0;\n+    while (current_binding_level->parm_flag == 2)\n+      current_binding_level = current_binding_level->level_chain;\n+  }\n+}\n+\n+void\n+resume_binding_level (b)\n+     struct binding_level *b;\n+{\n+  if (class_binding_level)\n+    {\n+#if 1\n+      /* These are here because we cannot deal with shadows yet. */\n+      sorry (\"cannot resume a namespace inside class\");\n+      return;\n+#else\n+      b->level_chain = class_binding_level;\n+      class_binding_level = (struct binding_level *)0;\n+#endif\n+    }\n+  else\n+    {\n+#if 1\n+      /* These are here because we cannot deal with shadows yet. */\n+      if (b->level_chain != current_binding_level)\n+\t{\n+\t  sorry (\"cannot resume a namespace inside a different namespace\");\n+\t  return;\n+\t}\n+#endif\n+      b->level_chain = current_binding_level;\n+    }\n+  current_binding_level = b;\n+#if defined(DEBUG_CP_BINDING_LEVELS)\n+  b->binding_depth = binding_depth;\n+  indent ();\n+  fprintf (stderr, \"resume %s level 0x%08x line %d\\n\",\n+\t   (is_class_level) ? \"class\" : \"block\", b, lineno);\n+  is_class_level = 0;\n+  binding_depth++;\n+#endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n+}\n \f\n /* Nonzero if we are currently in the global binding level.  */\n \n@@ -722,6 +809,33 @@ global_bindings_p ()\n   return current_binding_level == global_binding_level;\n }\n \n+/* Nonzero if we are currently in a toplevel binding level.  This\n+   means either the global binding level or a namespace in a toplevel\n+   binding level.  */\n+\n+int\n+toplevel_bindings_p ()\n+{\n+  struct binding_level *b = current_binding_level;\n+\n+  while (1)\n+    {\n+      if (b == global_binding_level)\n+\treturn 1;\n+      if (! b->namespace_p)\n+\treturn 0;\n+      b=b->level_chain;\n+    }\n+}\n+\n+/* Nonzero if this is a namespace scope.  */\n+\n+int\n+namespace_bindings_p ()\n+{\n+  return current_binding_level->namespace_p;\n+}\n+\n void\n keep_next_level ()\n {\n@@ -766,6 +880,12 @@ declare_pseudo_global_level ()\n   current_binding_level->pseudo_global = 1;\n }\n \n+void\n+declare_namespace_level ()\n+{\n+  current_binding_level->namespace_p = 1;\n+}\n+\n int\n pseudo_global_level_p ()\n {\n@@ -1110,6 +1230,31 @@ poplevel (keep, reverse, functionbody)\n   return block;\n }\n \n+/* Resume a binding level for a namespace.  */\n+void\n+resume_level (b)\n+     struct binding_level *b;\n+{\n+  tree decls, link;\n+\n+  resume_binding_level (b);\n+\n+  /* Resume the variable caches.  */\n+  decls = current_binding_level->names;\n+\n+  /* Restore the meanings of the local variables of this level.  */\n+\n+  for (link = decls; link; link = TREE_CHAIN (link))\n+    {\n+      if (DECL_NAME (link) != NULL_TREE)\n+\tIDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = link;\n+\n+      /* If this is a TYPE_DECL, push it into the type value slot.  */\n+      if (TREE_CODE (link) == TYPE_DECL)\n+\tSET_IDENTIFIER_TYPE_VALUE (DECL_NAME (link), TREE_TYPE (link));\n+    }\n+}\n+\n /* Delete the node BLOCK from the current binding level.\n    This is used for the block inside a stmt expr ({...})\n    so that the block can be reinserted where appropriate.  */\n@@ -1428,6 +1573,95 @@ print_binding_stack ()\n   fprintf (stderr, \"global:\\n\");\n   print_binding_level (global_binding_level);\n }\n+\n+/* Push into the scope of the NAME namespace.  */\n+void\n+push_namespace (name)\n+     tree name;\n+{\n+  extern tree current_namespace;\n+  tree old_id = get_namespace_id ();\n+  char *buf;\n+  tree d = make_node (NAMESPACE_DECL);\n+\n+  DECL_NAME (d) = name;\n+  DECL_ASSEMBLER_NAME (d) = name;\n+  /* pushdecl wants to check the size of it to see if it is incomplete... */\n+  TREE_TYPE (d) = void_type_node;\n+  /* Mark them as external, so redeclaration_error_message doesn't think\n+     they are duplicates. */\n+  DECL_EXTERNAL (d) = 1;\n+  d = pushdecl (d);\n+\n+  if (NAMESPACE_LEVEL (d) == 0)\n+    {\n+      /* This is new for this compilation unit.  */\n+      pushlevel (0);\n+      declare_namespace_level ();\n+      NAMESPACE_LEVEL (d) = (tree)current_binding_level;\n+    }\n+  else\n+    {\n+      resume_level ((struct binding_level*)NAMESPACE_LEVEL (d));\n+    }\n+\n+  /* This code is just is bit old now... */ \n+  current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n+  buf = (char *) alloca (4 + (old_id ? IDENTIFIER_LENGTH (old_id) : 0)\n+\t\t\t + IDENTIFIER_LENGTH (name));\n+  sprintf (buf, \"%s%s\", old_id ? IDENTIFIER_POINTER (old_id) : \"\",\n+\t   IDENTIFIER_POINTER (name));\n+  TREE_PURPOSE (current_namespace) = get_identifier (buf);\n+}\n+\n+/* Pop from the scope of the current namespace.  */\n+void\n+pop_namespace ()\n+{\n+  extern tree current_namespace;\n+  tree decls, link;\n+  current_namespace = TREE_CHAIN (current_namespace);\n+\n+  /* Just in case we get out of sync. */\n+  if (! namespace_bindings_p ())\n+    poplevel (0, 0, 0);\n+\n+  decls = current_binding_level->names;\n+\n+  /* Clear out the meanings of the local variables of this level.  */\n+\n+  for (link = decls; link; link = TREE_CHAIN (link))\n+    {\n+      if (DECL_NAME (link) != NULL_TREE)\n+\t{\n+\t  /* If the ident. was used or addressed via a local extern decl,\n+\t     don't forget that fact.  */\n+\t  if (DECL_EXTERNAL (link))\n+\t    {\n+\t      if (TREE_USED (link))\n+\t\tTREE_USED (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t      if (TREE_ADDRESSABLE (link))\n+\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t    }\n+\t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = NULL_TREE;\n+\t}\n+    }\n+\n+  /* Restore all name-meanings of the outer levels\n+     that were shadowed by this level.  */\n+\n+  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  for (link = current_binding_level->class_shadowed;\n+       link; link = TREE_CHAIN (link))\n+    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  for (link = current_binding_level->type_shadowed;\n+       link; link = TREE_CHAIN (link))\n+    IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\n+  /* suspend a level.  */\n+  suspend_binding_level ();\n+}\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n    of templates and such.  We actually need to clear out the class- and\n@@ -1677,15 +1911,16 @@ set_nested_typename (decl, classname, name, type)\n   }\n }\n \n-/* Pop off extraneous binding levels left over due to syntax errors.  */\n+/* Pop off extraneous binding levels left over due to syntax errors.\n+\n+   We don't pop past namespaces, as they might be valid.  */\n void\n pop_everything ()\n {\n #ifdef DEBUG_CP_BINDING_LEVELS\n   fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n #endif\n-  while (current_binding_level != global_binding_level\n-\t && ! current_binding_level->pseudo_global)\n+  while (! toplevel_bindings_p () && ! pseudo_global_level_p ())\n     {\n       if (class_binding_level)\n \tpop_nested_class (1);\n@@ -1747,7 +1982,7 @@ pushtag (name, type, globalize)\n \t || (globalize && b->parm_flag == 2))\n     b = b->level_chain;\n \n-  if (b == global_binding_level)\n+  if (toplevel_bindings_p ())\n     b->tags = perm_tree_cons (name, type, b->tags);\n   else\n     b->tags = saveable_tree_cons (name, type, b->tags);\n@@ -2092,11 +2327,11 @@ warn_extern_redeclared_static (newdecl, olddecl)\n \t     && (DECL_BUILT_IN (olddecl)\n \t\t || DECL_BUILT_IN_NONANSI (olddecl))))\n \t{\n-\t  cp_warning (IDENTIFIER_IMPLICIT_DECL (name)\n+\t  cp_pedwarn (IDENTIFIER_IMPLICIT_DECL (name)\n \t\t      ? implicit_extern_static_warning\n \t\t      : explicit_extern_static_warning, newdecl);\n \t  if (olddecl != NULL_TREE)\n-\t    cp_warning_at (\"previous declaration of `%D'\", olddecl);\n+\t    cp_pedwarn_at (\"previous declaration of `%D'\", olddecl);\n \t}\n     }\n }\n@@ -2507,35 +2742,17 @@ duplicate_decls (newdecl, olddecl)\n     }\n \n   /* Merge the storage class information.  */\n-  if (DECL_EXTERNAL (newdecl) && ! DECL_INTERFACE_KNOWN (newdecl)\n-      && ! (DECL_LANG_SPECIFIC (newdecl) && DECL_NOT_REALLY_EXTERN (newdecl)))\n-    {\n-      TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n-      DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n-      TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n+  DECL_WEAK (newdecl) |= DECL_WEAK (olddecl);\n+  TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n+  TREE_STATIC (olddecl) = TREE_STATIC (newdecl) |= TREE_STATIC (olddecl);\n+  if (! DECL_EXTERNAL (olddecl))\n+    DECL_EXTERNAL (newdecl) = 0;\n \n-      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\t{\n-\t  DECL_C_STATIC (newdecl) = DECL_C_STATIC (olddecl);\n-\t  DECL_INTERFACE_KNOWN (newdecl) = DECL_INTERFACE_KNOWN (olddecl);\n-\t  DECL_NOT_REALLY_EXTERN (newdecl) = DECL_NOT_REALLY_EXTERN (olddecl);\n-\t}\n-    }\n-  else\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n-      /* A `const' which was not declared `extern' gets internal linkage.  */\n-      if (TREE_CODE (newdecl) == VAR_DECL\n-\t  && TREE_READONLY (newdecl) && ! DECL_THIS_EXTERN (newdecl))\n-\tTREE_PUBLIC (newdecl) = 0;\n-      else\n-\t{\n-\t  TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-\n-\t  /* If this clears PUBLIC, clear it in the identifier too.  */\n-\t  if (TREE_CODE (newdecl) == FUNCTION_DECL && ! TREE_PUBLIC (olddecl))\n-\t    TREE_PUBLIC (DECL_ASSEMBLER_NAME (olddecl)) = 0;\n-\t}\n+      DECL_C_STATIC (newdecl) = DECL_C_STATIC (olddecl);\n+      DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);\n+      DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -2588,6 +2805,11 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_MAIN_VARIANT (newdecl) = DECL_MAIN_VARIANT (olddecl);\n     }\n \n+  if (TREE_CODE (newdecl) == NAMESPACE_DECL)\n+    {\n+      NAMESPACE_LEVEL (newdecl) = NAMESPACE_LEVEL (olddecl);\n+    }\n+\n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n       if (DECL_TEMPLATE_INFO (olddecl)->length)\n@@ -2722,7 +2944,8 @@ pushdecl (x)\n #else\n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use. */\n-  if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL)\n+  if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n+      || TREE_CODE (x) == NAMESPACE_DECL)\n     name = DECL_NAME (x);\n #endif\n \n@@ -2907,12 +3130,6 @@ pushdecl (x)\n \t{\n \t  /* Install a global value.  */\n \n-\t  /* Rule for VAR_DECLs, but not for other kinds of _DECLs:\n-\t     A `const' which was not declared `extern' is invisible.  */\n-\t  if (TREE_CODE (x) == VAR_DECL\n-\t      && TREE_READONLY (x) && ! DECL_THIS_EXTERN (x))\n-\t    TREE_PUBLIC (x) = 0;\n-\n \t  /* If the first global decl has external linkage,\n \t     warn if we later see static one.  */\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && DECL_PUBLIC (x))\n@@ -2968,6 +3185,12 @@ pushdecl (x)\n \t  if (TREE_CODE (x) == TYPE_DECL)\n \t    set_identifier_type_value_with_scope (name, TREE_TYPE (x), b);\n \n+\t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n+\t     we won't think this is a type.  The C struct hack doesn't\n+\t     go through namespaces.  */\n+\t  if (TREE_CODE (x) == NAMESPACE_DECL)\n+\t    set_identifier_type_value_with_scope (name, NULL_TREE, b);\n+\n \t  /* If this is an extern function declaration, see if we\n \t     have a global definition or declaration for the function.  */\n \t  if (oldlocal == NULL_TREE\n@@ -3352,7 +3575,7 @@ push_overloaded_decl (decl, forgettable)\n \t{\n \t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n \t  cp_error (\"conflicts with function declaration `%#D'\", decl);\n-\t  return error_mark_node;\n+\t  return decl;\n \t}\n     }\n \n@@ -3392,8 +3615,7 @@ implicitly_declare (functionid)\n   /* Save the decl permanently so we can warn if definition follows.\n      In ANSI C, warn_implicit is usually false, so the saves little space.\n      But in C++, it's usually true, hence the extra code.  */\n-  if (temp && (flag_traditional || !warn_implicit\n-\t       || current_binding_level == global_binding_level))\n+  if (temp && (flag_traditional || !warn_implicit || toplevel_bindings_p ()))\n     end_temporary_allocation ();\n \n   /* We used to reuse an old implicit decl here,\n@@ -3475,9 +3697,6 @@ redeclaration_error_message (newdecl, olddecl)\n   else if (current_binding_level == global_binding_level)\n     {\n       /* Objects declared at top level:  */\n-      /* Insist that the linkage match.  */\n-      if (! TREE_PUBLIC (newdecl) && TREE_PUBLIC (olddecl))\n-\treturn \"conflicting declarations of `%#D'\";\n       /* If at least one is a reference, it's ok.  */\n       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n@@ -3998,6 +4217,25 @@ lookup_nested_type (type, context)\n   return NULL_TREE;\n }\n \n+/* Look up NAME in the NAMESPACE.  */\n+tree\n+lookup_namespace_name (namespace, name)\n+     tree namespace, name;\n+{\n+  struct binding_level *b = (struct binding_level *)NAMESPACE_LEVEL (namespace);\n+  tree x;\n+\n+  for (x = NULL_TREE; b && !x; b = b->level_chain)\n+    {\n+      for (x = b->names; x; x = TREE_CHAIN (x))\n+\tif (DECL_NAME (x) == name || DECL_ASSEMBLER_NAME (x) == name)\n+\t  break;\n+      /* Must find directly in the namespace.  */\n+      break;\n+    }\n+  return x;\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -4045,6 +4283,10 @@ lookup_name_real (name, prefer_type, nonclass)\n \t      else\n \t\tval = NULL_TREE;\n \t    }\n+\t  else if (TREE_CODE (type) == NAMESPACE_DECL)\n+\t    {\n+\t      val = lookup_namespace_name (type, name);\n+\t    }\n \t  else if (! IS_AGGR_TYPE (type))\n \t    /* Someone else will give an error about this if needed. */\n \t    val = NULL_TREE;\n@@ -5579,12 +5821,12 @@ start_decl (declarator, declspecs, initialized, raises)\n \n   if (initialized)\n     {\n-      if (current_binding_level != global_binding_level\n+      if (! toplevel_bindings_p ()\n \t  && DECL_EXTERNAL (decl))\n \tcp_warning (\"declaration of `%#D' has `extern' and is initialized\",\n \t\t    decl);\n       DECL_EXTERNAL (decl) = 0;\n-      if (current_binding_level == global_binding_level)\n+      if ( toplevel_bindings_p ())\n \tTREE_STATIC (decl) = 1;\n \n       /* Tell `pushdecl' this is an initialized decl\n@@ -5636,7 +5878,7 @@ start_decl (declarator, declspecs, initialized, raises)\n #if 0\n   /* We don't do this yet for GNU C++.  */\n   /* For a local variable, define the RTL now.  */\n-  if (current_binding_level != global_binding_level\n+  if (! toplevel_bindings_p ()\n       /* But not if this is a duplicate decl\n \t and we preserved the rtl from the previous one\n \t (which may or may not happen).  */\n@@ -5713,7 +5955,7 @@ start_decl (declarator, declspecs, initialized, raises)\n     {\n       /* When parsing and digesting the initializer,\n \t use temporary storage.  Do this even if we will ignore the value.  */\n-      if (current_binding_level == global_binding_level && debug_temp_inits)\n+      if (toplevel_bindings_p () && debug_temp_inits)\n \t{\n \t  if (TYPE_NEEDS_CONSTRUCTING (type)\n \t      || TREE_CODE (type) == REFERENCE_TYPE)\n@@ -5751,8 +5993,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n     }\n   else\n     {\n-      tmp = get_temp_name (target_type,\n-\t\t\t   current_binding_level == global_binding_level);\n+      tmp = get_temp_name (target_type, toplevel_bindings_p ());\n       tmp_addr = build_unary_op (ADDR_EXPR, tmp, 0);\n     }\n \n@@ -5761,7 +6002,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n   TREE_TYPE (DECL_INITIAL (decl)) = type;\n   if (TYPE_NEEDS_CONSTRUCTING (target_type))\n     {\n-      if (current_binding_level == global_binding_level)\n+      if (toplevel_bindings_p ())\n \t{\n \t  /* lay this variable out now.  Otherwise `output_addressed_constants'\n \t     gets confused by its initializer.  */\n@@ -5784,7 +6025,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n   else\n     {\n       DECL_INITIAL (tmp) = init;\n-      TREE_STATIC (tmp) = current_binding_level == global_binding_level;\n+      TREE_STATIC (tmp) = toplevel_bindings_p ();\n       finish_decl (tmp, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   if (TREE_STATIC (tmp))\n@@ -5920,8 +6161,7 @@ obscure_complex_init (decl, init)\n \treturn NULL_TREE;\n     }\n \n-  if (current_binding_level == global_binding_level\n-      && ! DECL_COMMON (decl))\n+  if (toplevel_bindings_p () && ! DECL_COMMON (decl))\n     DECL_INITIAL (decl) = build (CONSTRUCTOR, TREE_TYPE (decl), NULL_TREE,\n \t\t\t\t NULL_TREE);\n   else\n@@ -5988,7 +6228,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \n   if (type == error_mark_node)\n     {\n-      if (current_binding_level == global_binding_level && temporary)\n+      if (toplevel_bindings_p () && temporary)\n \tend_temporary_allocation ();\n \n       return;\n@@ -6081,7 +6321,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     {\n       if (TREE_STATIC (decl))\n \tmake_decl_rtl (decl, NULL_PTR,\n-\t\t       current_binding_level == global_binding_level\n+\t\t       toplevel_bindings_p ()\n \t\t       || pseudo_global_level_p ());\n       grok_reference_init (decl, type, init, &cleanup);\n       init = NULL_TREE;\n@@ -6220,7 +6460,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n      must go in the permanent obstack; but don't discard the\n      temporary data yet.  */\n \n-  if (current_binding_level == global_binding_level && temporary)\n+  if (toplevel_bindings_p () && temporary)\n     end_temporary_allocation ();\n \n   /* Deduce size of array from initialization, if not already known.  */\n@@ -6339,8 +6579,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       || TREE_CODE (decl) == RESULT_DECL)\n     {\n       /* ??? FIXME: What about nested classes?  */\n-      int toplev = (current_binding_level == global_binding_level\n-\t\t    || pseudo_global_level_p ());\n+      int toplev = toplevel_bindings_p () || pseudo_global_level_p ();\n       int was_temp\n \t= ((flag_traditional\n \t    || (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)))\n@@ -6350,7 +6589,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \tend_temporary_allocation ();\n \n       if (TREE_CODE (decl) == VAR_DECL\n-\t  && current_binding_level != global_binding_level\n+\t  && ! toplevel_bindings_p ()\n \t  && ! TREE_STATIC (decl)\n \t  && type_needs_gc_entry (type))\n \tDECL_GC_OFFSET (decl) = size_int (++current_function_obstack_index);\n@@ -6606,8 +6845,7 @@ expand_static_init (decl, init)\n       if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n \tcp_error (\"multiple initializations given for `%D'\", decl);\n     }\n-  else if (current_binding_level != global_binding_level\n-\t   && current_binding_level->pseudo_global == 0)\n+  else if (! toplevel_bindings_p () && ! pseudo_global_level_p ())\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n@@ -7005,11 +7243,12 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n }\n \n static tree\n-grokvardecl (type, declarator, specbits, initialized)\n+grokvardecl (type, declarator, specbits, initialized, constp)\n      tree type;\n      tree declarator;\n      RID_BIT_TYPE specbits;\n      int initialized;\n+     int constp;\n {\n   tree decl;\n \n@@ -7046,9 +7285,10 @@ grokvardecl (type, declarator, specbits, initialized)\n     }\n   /* At top level, either `static' or no s.c. makes a definition\n      (perhaps tentative), and absence of `static' makes it public.  */\n-  else if (current_binding_level == global_binding_level)\n+  else if (toplevel_bindings_p ())\n     {\n-      TREE_PUBLIC (decl) = RIDBIT_NOTSETP (RID_STATIC, specbits);\n+      TREE_PUBLIC (decl) = (RIDBIT_NOTSETP (RID_STATIC, specbits)\n+\t\t\t    && (DECL_EXTERNAL (decl) || ! constp));\n       TREE_STATIC (decl) = ! DECL_EXTERNAL (decl);\n     }\n   /* Not at top level, only `static' makes a static definition.  */\n@@ -7471,11 +7711,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n      Since we now wait to push a class scope until we are sure that\n      we are in a legitimate method context, we must set oldcname\n-     explicitly (since current_class_name is not yet alive).  */\n+     explicitly (since current_class_name is not yet alive).\n+\n+     We also want to avoid calling this a PARM if it is in a namespace.  */\n \n-  if (decl_context == NORMAL\n-      && current_binding_level->level_chain == global_binding_level)\n-    decl_context = PARM;\n+  if (decl_context == NORMAL && ! namespace_bindings_p ())\n+    {\n+      struct binding_level *b = current_binding_level;\n+      current_binding_level = b->level_chain;\n+      if (current_binding_level != 0 && toplevel_bindings_p ())\n+\tdecl_context = PARM;\n+      current_binding_level = b;\n+    }\n \n   /* Look through the decl specs and record which ones appear.\n      Some typespecs are defined as built-in typenames.\n@@ -8048,7 +8295,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     }\n   else if (RIDBIT_SETP (RID_EXTERN, specbits) && initialized && !funcdef_flag)\n     {\n-      if (current_binding_level == global_binding_level)\n+      if (toplevel_bindings_p ())\n \t{\n \t  /* It's common practice (and completely valid) to have a const\n \t     be initialized and declared extern.  */\n@@ -8059,9 +8306,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \terror (\"`%s' has both `extern' and initializer\", name);\n     }\n   else if (RIDBIT_SETP (RID_EXTERN, specbits) && funcdef_flag\n-\t   && current_binding_level != global_binding_level)\n+\t   && ! toplevel_bindings_p ())\n     error (\"nested function `%s' declared `extern'\", name);\n-  else if (current_binding_level == global_binding_level)\n+  else if (toplevel_bindings_p ())\n     {\n       if (RIDBIT_SETP (RID_AUTO, specbits))\n \terror (\"top-level declaration of `%s' specifies `auto'\", name);\n@@ -9240,7 +9487,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t/* Function declaration not at top level.\n \t   Storage classes other than `extern' are not allowed\n \t   and `extern' makes no difference.  */\n-\tif (current_binding_level != global_binding_level\n+\tif (! toplevel_bindings_p ()\n \t    && ! processing_template_decl\n \t    && (RIDBIT_SETP (RID_STATIC, specbits)\n \t\t|| RIDBIT_SETP (RID_INLINE, specbits))\n@@ -9277,6 +9524,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t/* Record presence of `static'.  In C++, `inline' implies `static'.  */\n \tpublicp = (ctype != NULL_TREE\n+\t\t   || RIDBIT_SETP (RID_EXTERN, specbits)\n \t\t   || (!RIDBIT_SETP (RID_STATIC, specbits)\n \t\t       && !RIDBIT_SETP (RID_INLINE, specbits)));\n \n@@ -9346,7 +9594,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  }\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, declarator, specbits, initialized);\n+\tdecl = grokvardecl (type, declarator, specbits, initialized, constp);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n@@ -9416,7 +9664,7 @@ parmlist_is_exprlist (exprs)\n   if (exprs == NULL_TREE || TREE_PARMLIST (exprs))\n     return 0;\n \n-  if (current_binding_level == global_binding_level)\n+  if (toplevel_bindings_p ())\n     {\n       /* At the global level, if these are all identifiers,\n \t then it is a parmlist.  */\n@@ -10724,7 +10972,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   original_result_rtx = NULL_RTX;\n   current_function_obstack_index = 0;\n   current_function_obstack_usage = 0;\n-  base_init_insns = NULL_RTX;\n+  base_init_expr = NULL_TREE;\n   protect_list = NULL_TREE;\n   current_base_init_list = NULL_TREE;\n   current_member_init_list = NULL_TREE;\n@@ -10905,14 +11153,8 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t So clear DECL_EXTERNAL.  */\n       DECL_EXTERNAL (decl1) = 0;\n \n-      if (DECL_THIS_INLINE (decl1) && ! DECL_C_STATIC (decl1))\n-\tDECL_DEFER_OUTPUT (decl1) = 1;\n-      else\n-\t{\n-\t  DECL_INTERFACE_KNOWN (decl1) = 1;\n-\t  if (DECL_C_STATIC (decl1))\n-\t    TREE_PUBLIC (decl1) = 0;\n-\t}\n+      if (DECL_C_STATIC (decl1))\n+\tTREE_PUBLIC (decl1) = 0;\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -10928,6 +11170,11 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   else\n     current_function_decl = decl1;\n \n+  if (DECL_THIS_INLINE (decl1) && ! DECL_INTERFACE_KNOWN (decl1))\n+    DECL_DEFER_OUTPUT (decl1) = 1;\n+  else\n+    DECL_INTERFACE_KNOWN (decl1) = 1;\n+\n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n     {\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n@@ -11065,7 +11312,7 @@ store_parm_decls ()\n      then CONST_DECLs for foo and bar are put here.  */\n   tree nonparms = NULL_TREE;\n \n-  if (current_binding_level == global_binding_level)\n+  if (toplevel_bindings_p ())\n     fatal (\"parse errors have confused me too much\");\n \n   /* Initialize RTL machinery.  */\n@@ -11512,7 +11759,7 @@ finish_function (lineno, call_poplevel, nested)\n \n       current_function_assigns_this = 0;\n       current_function_just_assigned_this = 0;\n-      base_init_insns = NULL_RTX;\n+      base_init_expr = NULL_TREE;\n     }\n   else if (DECL_CONSTRUCTOR_P (fndecl))\n     {\n@@ -11556,8 +11803,11 @@ finish_function (lineno, call_poplevel, nested)\n \n       /* Emit insns from `emit_base_init' which sets up virtual\n \t function table pointer(s).  */\n-      emit_insns (base_init_insns);\n-      base_init_insns = NULL_RTX;\n+      if (base_init_expr)\n+\t{\n+\t  expand_expr_stmt (base_init_expr);\n+\t  base_init_expr = NULL_TREE;\n+\t}\n \n       /* This is where the body of the constructor begins.\n \t If there were no insns in this function body, then the\n@@ -12006,7 +12256,7 @@ hack_incomplete_structures (type)\n \t  layout_type (TREE_TYPE (decl));\n \telse\n \t  {\n-\t    int toplevel = global_binding_level == current_binding_level;\n+\t    int toplevel = toplevel_bindings_p ();\n \t    if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n \t\t&& TREE_TYPE (TREE_TYPE (decl)) == type)\n \t      layout_type (TREE_TYPE (decl));\n@@ -12154,7 +12404,7 @@ finish_stmt ()\n \t zones before calling base constructors.  */\n       if (cond_stack || loop_stack || case_stack)\n \treturn;\n-      emit_insns (base_init_insns);\n+      expand_expr_stmt (base_init_expr);\n       check_base_init (current_class_type);\n     }\n   current_function_assigns_this = 1;\n@@ -12215,8 +12465,8 @@ struct cp_function\n   tree protect_list;\n   tree base_init_list;\n   tree member_init_list;\n+  tree base_init_expr;\n   rtx result_rtx;\n-  rtx base_init_insns;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n };\n@@ -12252,7 +12502,7 @@ push_cp_function_context (context)\n   p->just_assigned_this = current_function_just_assigned_this;\n   p->parms_stored = current_function_parms_stored;\n   p->result_rtx = original_result_rtx;\n-  p->base_init_insns = base_init_insns;\n+  p->base_init_expr = base_init_expr;\n   p->protect_list = protect_list;\n   p->temp_name_counter = temp_name_counter;\n   p->base_init_list = current_base_init_list;\n@@ -12302,7 +12552,7 @@ pop_cp_function_context (context)\n   current_function_just_assigned_this = p->just_assigned_this;\n   current_function_parms_stored = p->parms_stored;\n   original_result_rtx = p->result_rtx;\n-  base_init_insns = p->base_init_insns;\n+  base_init_expr = p->base_init_expr;\n   temp_name_counter = p->temp_name_counter;\n   current_base_init_list = p->base_init_list;\n   current_member_init_list = p->member_init_list;"}, {"sha": "5bbc9c8e872a7c0db98e3027c1f146494a8c1b00", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -35,6 +35,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"decl.h\"\n #include \"lex.h\"\n #include \"output.h\"\n+#include \"defaults.h\"\n \n extern tree grokdeclarator ();\n extern tree get_file_function_name ();\n@@ -2031,9 +2032,9 @@ constructor_name (thing)\n void\n setup_vtbl_ptr ()\n {\n-  extern rtx base_init_insns;\n+  extern rtx base_init_expr;\n \n-  if (base_init_insns == 0\n+  if (base_init_expr == 0\n       && DECL_CONSTRUCTOR_P (current_function_decl))\n     emit_base_init (current_class_type, 0);\n \n@@ -2145,7 +2146,7 @@ get_temp_name (type, staticp)\n {\n   char buf[sizeof (AUTO_TEMP_FORMAT) + 20];\n   tree decl;\n-  int toplev = global_bindings_p ();\n+  int toplev = toplevel_bindings_p ();\n \n   push_obstacks_nochange ();\n   if (toplev || staticp)\n@@ -2278,7 +2279,7 @@ finish_anon_union (anon_union_decl)\n     {\n       if (main_decl)\n \t{\n-\t  make_decl_rtl (main_decl, 0, global_bindings_p ());\n+\t  make_decl_rtl (main_decl, 0, toplevel_bindings_p ());\n \t  DECL_RTL (anon_union_decl) = DECL_RTL (main_decl);\n \t}\n       else\n@@ -2568,7 +2569,10 @@ import_export_vtable (decl, type, final)\n \t  if (TREE_PUBLIC (decl))\n \t    cp_error (\"all virtual functions redeclared inline\");\n #endif\n-\t  TREE_PUBLIC (decl) = 0;\n+\t  if (SUPPORTS_WEAK)\n+\t    DECL_WEAK (decl) = 1;\n+\t  else\n+\t    TREE_PUBLIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 0;\n \t}\n       else\n@@ -2788,7 +2792,12 @@ import_export_inline (decl)\n   if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n-\tTREE_PUBLIC (decl) = 0;\n+\t{\n+\t  if (SUPPORTS_WEAK)\n+\t    DECL_WEAK (decl) = 1;\n+\t  else\n+\t    TREE_PUBLIC (decl) = 0;\n+\t}\n       else\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n     }\n@@ -2801,9 +2810,15 @@ import_export_inline (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n+      else if (SUPPORTS_WEAK)\n+\tDECL_WEAK (decl) = 1;\n       else\n \tTREE_PUBLIC (decl) = 0;\n     }\n+  else if (DECL_C_STATIC (decl))\n+    TREE_PUBLIC (decl) = 0;\n+  else if (SUPPORTS_WEAK)\n+    DECL_WEAK (decl) = 1;\n   else\n     TREE_PUBLIC (decl) = 0;\n \n@@ -3116,7 +3131,8 @@ finish_file ()\n       tree decl = TREE_VALUE (fnname);\n       import_export_inline (decl);\n       if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n-\t  && TREE_PUBLIC (decl) && DECL_NOT_REALLY_EXTERN (decl))\n+\t  && TREE_PUBLIC (decl) && ! DECL_WEAK (decl)\n+\t  && DECL_NOT_REALLY_EXTERN (decl))\n \tsynthesize_method (decl);\n     }\n \n@@ -3169,7 +3185,7 @@ finish_file ()\n \t\tcontinue;\n \t      }\n \n-\t    if (TREE_PUBLIC (decl)\n+\t    if ((TREE_PUBLIC (decl) && ! DECL_WEAK (decl))\n \t\t|| TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t\t|| flag_keep_inline_functions)\n \t      {\n@@ -3426,7 +3442,7 @@ check_cp_case_value (value)\n   return value;\n }\n \n-static tree current_namespace;\n+tree current_namespace;\n \n /* Get the inner part of a namespace id.  It doesn't have any prefix, nor\n    postfix.  Returns 0 if in global namespace.  */\n@@ -3458,37 +3474,37 @@ current_namespace_id (name)\n   return get_identifier (buf);\n }\n \n-/* Push into the scopre of the NAME namespace.  */\n void\n-push_namespace (name)\n-     tree name;\n+do_namespace_alias (alias, namespace)\n+     tree alias, namespace;\n {\n-  tree old_id = get_namespace_id ();\n-  char *buf;\n-\n-  current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n-  buf = (char *) alloca (4 + (old_id ? IDENTIFIER_LENGTH (old_id) : 0)\n-\t\t\t + IDENTIFIER_LENGTH (name));\n-  sprintf (buf, \"%s%s\", old_id ? IDENTIFIER_POINTER (old_id) : \"\",\n-\t   IDENTIFIER_POINTER (name));\n-  TREE_PURPOSE (current_namespace) = get_identifier (buf);\n }\n \n-/* Pop from the scope of the current namespace.  */\n-void\n-pop_namespace ()\n+tree\n+do_toplevel_using_decl (decl)\n+     tree decl;\n {\n-  current_namespace = TREE_CHAIN (current_namespace);\n-}\n+  if (decl == NULL_TREE || decl == error_mark_node)\n+    return;\n \n-void\n-do_namespace_alias (alias, namespace)\n-     tree alias, namespace;\n-{\n+  if (TREE_CODE (decl) == SCOPE_REF)\n+    decl = resolve_scope_to_name (NULL_TREE, decl);\n+\n+  /* Is this the right way to do an id list? */\n+  if (TREE_CODE (decl) != TREE_LIST)\n+    {\n+      pushdecl (decl);\n+    }\n+  else\n+    while (decl)\n+      {\n+\tpushdecl (TREE_VALUE (decl));\n+\tdecl = TREE_CHAIN (decl);\n+      }\n }\n \n tree\n-do_using_decl (decl)\n+do_class_using_decl (decl)\n      tree decl;\n {\n   return error_mark_node;"}, {"sha": "918572465807629d0301e42de5128f376fb0e88c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -616,6 +616,10 @@ dump_decl (t, v)\n \tdump_type_suffix (TREE_TYPE (t), v);\n       break;\n \n+    case NAMESPACE_DECL:\n+      OB_PUTID (DECL_NAME (t));\n+      break;\n+\n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), v);\n       OB_PUTC ('[');"}, {"sha": "a70e95f888afa5d1e4156f68e2b7b6bfe4f034ad", "filename": "gcc/cp/init.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -492,12 +492,14 @@ build_partial_cleanup_for (binfo)\n \n    Argument IMMEDIATELY, if zero, forces a new sequence to be\n    generated to contain these new insns, so it can be emitted later.\n-   This sequence is saved in the global variable BASE_INIT_INSNS.\n+   This sequence is saved in the global variable BASE_INIT_EXPR.\n    Otherwise, the insns are emitted into the current sequence.\n \n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n-   \n+\n+extern tree base_init_expr, rtl_expr_chain;\n+\n void\n emit_base_init (t, immediately)\n      tree t;\n@@ -511,13 +513,20 @@ emit_base_init (t, immediately)\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  tree expr = NULL_TREE;\n \n   my_friendly_assert (protect_list == NULL_TREE, 999);\n \n   if (! immediately)\n     {\n+      int momentary;\n       do_pending_stack_adjust ();\n-      start_sequence ();\n+      /* Make the RTL_EXPR node temporary, not momentary,\n+\t so that rtl_expr_chain doesn't become garbage.  */\n+      momentary = suspend_momentary ();\n+      expr = make_node (RTL_EXPR);\n+      resume_momentary (momentary);\n+      start_sequence_for_rtl_expr (expr); \n     }\n \n   if (write_symbols == NO_DEBUG)\n@@ -670,12 +679,15 @@ emit_base_init (t, immediately)\n \n   if (! immediately)\n     {\n-      extern rtx base_init_insns;\n-\n       do_pending_stack_adjust ();\n-      my_friendly_assert (base_init_insns == 0, 207);\n-      base_init_insns = get_insns ();\n+      my_friendly_assert (base_init_expr == 0, 207);\n+      base_init_expr = expr;\n+      TREE_TYPE (expr) = void_type_node;\n+      RTL_EXPR_RTL (expr) = const0_rtx;\n+      RTL_EXPR_SEQUENCE (expr) = get_insns ();\n+      rtl_expr_chain = tree_cons (NULL_TREE, expr, rtl_expr_chain);\n       end_sequence ();\n+      TREE_SIDE_EFFECTS (expr) = 1;\n     }\n \n   /* All the implicit try blocks we built up will be zapped\n@@ -1728,6 +1740,18 @@ build_member_call (cname, name, parmlist)\n   if (TREE_CODE (cname) == SCOPE_REF)\n     cname = resolve_scope_to_name (NULL_TREE, cname);\n \n+  /* This shouldn't be here, and build_member_call shouldn't appear in\n+     parse.y!  (mrs)  */\n+  if (cname && get_aggr_from_typedef (cname, 0) == 0\n+      && TREE_CODE (cname) == IDENTIFIER_NODE)\n+    {\n+      tree ns = lookup_name (cname, 0);\n+      if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n+\t{\n+\t  return build_x_function_call (build_offset_ref (cname, name), parmlist, current_class_decl);\n+\t}\n+    }\n+\n   if (cname == NULL_TREE || ! (type = get_aggr_from_typedef (cname, 1)))\n     return error_mark_node;\n \n@@ -1839,6 +1863,22 @@ build_offset_ref (cname, name)\n   if (TREE_CODE (cname) == SCOPE_REF)\n     cname = resolve_scope_to_name (NULL_TREE, cname);\n \n+  /* Handle namespace names fully here.  */\n+  if (TREE_CODE (cname) == IDENTIFIER_NODE\n+      && get_aggr_from_typedef (cname, 0) == 0)\n+    {\n+      tree ns = lookup_name (cname, 0);\n+      tree val;\n+      if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n+\t{\n+\t  val = lookup_namespace_name (ns, name);\n+\t  if (val)\n+\t    return val;\n+\t  cp_error (\"namespace `%D' has no member named `%D'\", ns, name);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n   if (cname == NULL_TREE || ! is_aggr_typedef (cname, 1))\n     return error_mark_node;\n "}, {"sha": "2d5b8b6977d77a12eca5f2dfd3d3bd34d1b91d6a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -2806,6 +2806,8 @@ identifier_type (decl)\n   if (TREE_CODE (decl) == TEMPLATE_DECL\n       && DECL_TEMPLATE_IS_CLASS (decl))\n     return PTYPENAME;\n+  if (TREE_CODE (decl) == NAMESPACE_DECL)\n+    return NSNAME;\n   if (TREE_CODE (decl) != TYPE_DECL)\n     return IDENTIFIER;\n   return TYPENAME;\n@@ -4606,13 +4608,26 @@ handle_sysv_pragma ()\n \tcase TYPENAME:\n \tcase STRING:\n \tcase CONSTANT:\n-\t  handle_pragma_token (token_buffer, yylval.ttype);\n+\t  handle_pragma_token (\"ignored\", yylval.ttype);\n+\t  break;\n+\tcase '(':\n+\t  handle_pragma_token (\"(\", NULL_TREE);\n+\t  break;\n+\tcase ')':\n+\t  handle_pragma_token (\")\", NULL_TREE);\n+\t  break;\n+\tcase '=':\n+\t  handle_pragma_token (\"=\", NULL_TREE);\n+\t  break;\n+\tcase LEFT_RIGHT:\n+\t  handle_pragma_token (\"(\", NULL_TREE);\n+\t  handle_pragma_token (\")\", NULL_TREE);\n \t  break;\n \tcase END_OF_LINE:\n \t  handle_pragma_token (NULL_PTR, NULL_TREE);\n \t  return;\n \tdefault:\n-\t  handle_pragma_token (token_buffer, NULL_TREE);\n+\t  abort ();\n \t}\n     }\n }"}, {"sha": "84849c12b57218c5ecbf66d0705136405ac9288e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -330,7 +330,7 @@ asm_keyword:\n lang_extdef:\n \t  { if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n-\t  { if (! global_bindings_p () && ! pseudo_global_level_p())\n+\t  { if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n \t      pop_everything ();\n \t    prefix_attributes = NULL_TREE; }\n \t;\n@@ -365,18 +365,18 @@ extdef:\n \t| NAMESPACE identifier '=' any_id ';'\n \t\t{ do_namespace_alias ($2, $4); }\n \t| using_decl ';'\n-\t\t{ }\n+\t\t{ do_toplevel_using_decl ($1); }\n \t| USING NAMESPACE any_id ';'\n \t\t{ do_using_directive ($3); }\n \t;\n \n using_decl:\n \t  USING qualified_id\n-\t\t{ $$ = do_using_decl ($2); }\n+\t\t{ $$ = $2; }\n \t| USING global_scope qualified_id\n-\t\t{ $$ = do_using_decl ($3); }\n+\t\t{ $$ = $3; }\n \t| USING global_scope unqualified_id\n-\t\t{ $$ = do_using_decl ($3); }\n+\t\t{ $$ = $3; }\n \t;\n \n any_id:\n@@ -2645,6 +2645,7 @@ component_decl_1:\n \t\t  $$ = grokfield ($$, TREE_CHAIN ($1), $4, $7, $5);\n \t\t  cplus_decl_attributes ($$, $6, prefix_attributes); }\n \t| using_decl\n+\t\t{ $$ = do_class_using_decl ($1); }\n \t;\n \n /* The case of exactly one component is handled directly by component_decl. */\n@@ -2956,7 +2957,7 @@ nested_name_specifier_1:\n \t  TYPENAME SCOPE\n \t\t{ got_scope = TREE_TYPE ($$); }\n \t| NSNAME SCOPE\n-\t\t{ got_scope = TREE_TYPE ($$); }\n+\t\t{ got_scope = $$; }\n \t| template_type SCOPE\n \t\t{ got_scope = TREE_TYPE ($$); }\n /* \tThese break 'const i;'"}, {"sha": "2bf8edd99b9d5b92174b30dd136b15c3d22faae4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -39,6 +39,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"parse.h\"\n #include \"lex.h\"\n #include \"output.h\"\n+#include \"defaults.h\"\n \n extern struct obstack permanent_obstack;\n extern tree grokdeclarator ();\n@@ -2395,7 +2396,12 @@ do_pending_expansions ()\n \n       if (i->interface == 1)\n \t/* OK, it was an implicit instantiation.  */\n-\tTREE_PUBLIC (t) = 0;\n+\t{\n+\t  if (SUPPORTS_WEAK)\n+\t    DECL_WEAK (t) = 1;\n+\t  else\n+\t    TREE_PUBLIC (t) = 0;\n+\t}\n \n       /* If it's a method, let the class type decide it.\n \t @@ What if the method template is in a separate file?"}, {"sha": "68915a4cedbb145740fce07e591eefaf8ec70fd0", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -327,6 +327,11 @@ yylex()\n \t    case PTYPENAME:\n \t      lastiddecl = NULL_TREE;\n \t      break;\n+\t    case NSNAME:\n+\t      lastiddecl = trrr;\n+\t      if (got_scope || got_object)\n+\t\ttmp_token.yylval.ttype = trrr;\n+\t      break;\n \t    default:\n \t      my_friendly_abort (101);\n \t    }"}, {"sha": "c2eb1e0f8f36743bf25e1529e98dc8e5bb5f536d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9aedbc26d61fbe2fef53254408dbbb37c3992fa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a9aedbc26d61fbe2fef53254408dbbb37c3992fa", "patch": "@@ -1337,7 +1337,7 @@ c_alignof (type)\n    C++: this will automatically bash references to their target type.  */\n \n tree\n-default_conversion (exp)\n+decay_conversion (exp)\n      tree exp;\n {\n   register tree type = TREE_TYPE (exp);\n@@ -1346,7 +1346,7 @@ default_conversion (exp)\n   if (code == OFFSET_TYPE /* || TREE_CODE (exp) == OFFSET_REF */ )\n     {\n       if (TREE_CODE (exp) == OFFSET_REF)\n-\treturn default_conversion (resolve_offset_ref (exp));\n+\treturn decay_conversion (resolve_offset_ref (exp));\n \n       type = TREE_TYPE (type);\n       code = TREE_CODE (type);\n@@ -1372,15 +1372,6 @@ default_conversion (exp)\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n \n-  if (INTEGRAL_CODE_P (code))\n-    {\n-      tree t = type_promotes_to (type);\n-      if (t != type)\n-\treturn convert (t, exp);\n-    }\n-  if (flag_traditional\n-      && TYPE_MAIN_VARIANT (type) == float_type_node)\n-    return convert (double_type_node, exp);\n   if (code == VOID_TYPE)\n     {\n       error (\"void value not ignored as it ought to be\");\n@@ -1424,7 +1415,7 @@ default_conversion (exp)\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n \t{\n-\t  tree op1 = default_conversion (TREE_OPERAND (exp, 1));\n+\t  tree op1 = decay_conversion (TREE_OPERAND (exp, 1));\n \t  return build (COMPOUND_EXPR, TREE_TYPE (op1),\n \t\t\tTREE_OPERAND (exp, 0), op1);\n \t}\n@@ -1470,6 +1461,32 @@ default_conversion (exp)\n       adr = build_unary_op (ADDR_EXPR, exp, 1);\n       return convert (ptrtype, adr);\n     }\n+\n+  return exp;\n+}\n+\n+tree\n+default_conversion (exp)\n+     tree exp;\n+{\n+  tree type;\n+  enum tree_code code;\n+\n+  exp = decay_conversion (exp);\n+\n+  type = TREE_TYPE (exp);\n+  code = TREE_CODE (type);\n+\n+  if (INTEGRAL_CODE_P (code))\n+    {\n+      tree t = type_promotes_to (type);\n+      if (t != type)\n+\treturn convert (t, exp);\n+    }\n+  if (flag_traditional\n+      && TYPE_MAIN_VARIANT (type) == float_type_node)\n+    return convert (double_type_node, exp);\n+\n   return exp;\n }\n \f\n@@ -2809,8 +2826,8 @@ build_binary_op (code, arg1, arg2, convert_p)\n     {\n       tree args_save [2];\n       tree type0, type1;\n-      args[0] = args_save [0] = default_conversion (args[0]);\n-      args[1] = args_save [1] = default_conversion (args[1]);\n+      args[0] = decay_conversion (args[0]);\n+      args[1] = decay_conversion (args[1]);\n \n       if (args[0] == error_mark_node || args[1] == error_mark_node)\n \treturn error_mark_node;\n@@ -2821,13 +2838,13 @@ build_binary_op (code, arg1, arg2, convert_p)\n       if (type_unknown_p (args[0]))\n \t{\n \t  args[0] = instantiate_type (type1, args[0], 1);\n-\t  args[0] = default_conversion (args[0]);\n+\t  args[0] = decay_conversion (args[0]);\n \t}\n       else if (type_unknown_p (args[1]))\n \t{\n \t  args[1] = require_instantiated_type (type0, args[1],\n \t\t\t\t\t       error_mark_node);\n-\t  args[1] = default_conversion (args[1]);\n+\t  args[1] = decay_conversion (args[1]);\n \t}\n \n       if (IS_AGGR_TYPE (type0) || IS_AGGR_TYPE (type1))\n@@ -2840,11 +2857,6 @@ build_binary_op (code, arg1, arg2, convert_p)\n \t      return error_mark_node;\n \t    }\n \t}\n-      \n-      if (args[0] == args_save[0])\n-\targs[0] = arg1;\n-      if (args[1] == args_save[1])\n-\targs[1] = arg2;\n     }\n   return build_binary_op_nodefault (code, args[0], args[1], code);\n }\n@@ -2923,8 +2935,18 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   int common = 0;\n \n   /* Apply default conversions.  */\n-  op0 = default_conversion (orig_op0);\n-  op1 = default_conversion (orig_op1);\n+  if (code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n+      || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n+      || code == TRUTH_XOR_EXPR)\n+    {\n+      op0 = decay_conversion (orig_op0);\n+      op1 = decay_conversion (orig_op1);\n+    }\n+  else\n+    {\n+      op0 = default_conversion (orig_op0);\n+      op1 = default_conversion (orig_op1);\n+    }\n \n   type0 = TREE_TYPE (op0);\n   type1 = TREE_TYPE (op1);"}]}