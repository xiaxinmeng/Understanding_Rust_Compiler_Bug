{"sha": "1eae67f812a0b7b6b7132d0375e662bc6200d68a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhZTY3ZjgxMmEwYjdiNmI3MTMyZDAzNzVlNjYyYmM2MjAwZDY4YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-09T14:22:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-09T14:22:39Z"}, "message": "Base subreg rules on REGMODE_NATURAL_SIZE rather than UNITS_PER_WORD\n\nOriginally subregs operated at the word level and subreg offsets\nwere measured in words.  The offset units were later changed from\nwords to bytes (SUBREG_WORD became SUBREG_BYTE), but the fundamental\nassumption that subregs should operate at the word level remained.\nWhether (subreg:M1 (reg:M2 R2) N) is well-formed depended on the\nway that M1 and M2 partitioned into words and whether the subword\npart of N represented a lowpart.  However, some questions depended\ninstead on the macro REGMODE_NATURAL_SIZE, which was introduced\nas part of the patch that moved from SUBREG_WORD to SUBREG_BYTE.\nIt is used to decide whether setting (subreg:M1 (reg:M2 R2) N)\nclobbers all of R2 or just part of it (df_read_modify_subreg).\n\nUsing words doesn't really make sense for modern vector\narchitectures.  Vector registers are usually bigger than\na word and:\n\n(a) setting the scalar lowpart of them usually clobbers the\n    rest of the register (contrary to the subreg rules,\n    where only the containing words should be clobbered).\n\n(b) high words of vector registers are often not independently\n    addressable, even though that's what the subreg rules expect.\n\nThis patch therefore uses REGMODE_NATURAL_SIZE instead of\nUNITS_PER_WORD to determine the size of the independently\naddressable blocks in an inner register.\n\nThis is needed for SVE because the number of words in a vector\nmode isn't known at compile time, so isn't a sensible basis\nfor calculating the number of registers.\n\nThe only existing port to define REGMODE_NATURAL_SIZE is\n64-bit SPARC, where FP registers are 32 bits.  (This is the\nopposite of the use case for SVE, since the natural division\nis smaller than a word.)  I compiled the testsuite before and\nafter the patch for sparc64-linux-gnu and the only test whose\nassembly changed was g++.dg/debug/pr65678.C, where the order\nof two independent stores was reversed and where a different\nregister was picked for one pseudo.  The new code was\notherwise equivalent to the old code.\n\n2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/rtl.texi: Rewrite the subreg rules so that they partition\n\tthe inner register into REGMODE_NATURAL_SIZE bytes rather than\n\tUNITS_PER_WORD bytes.\n\t* emit-rtl.c (validate_subreg): Divide subregs into blocks\n\tbased on REGMODE_NATURAL_SIZE of the inner mode.\n\t(gen_lowpart_common): Split the SCALAR_FLOAT_MODE_P and\n\t!SCALAR_FLOAT_MODE_P cases.  Use REGMODE_NATURAL_SIZE for the latter.\n\t* expmed.c (lowpart_bit_field_p): Divide the value up into\n\tchunks of REGMODE_NATURAL_SIZE rather than UNITS_PER_WORD.\n\t* expr.c (store_constructor): Use REGMODE_NATURAL_SIZE to test\n\twhether something is likely to occupy more than one register.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254583", "tree": {"sha": "e02e90a2cdf27652857018bc9d0d760419f103b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e02e90a2cdf27652857018bc9d0d760419f103b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eae67f812a0b7b6b7132d0375e662bc6200d68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eae67f812a0b7b6b7132d0375e662bc6200d68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eae67f812a0b7b6b7132d0375e662bc6200d68a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eae67f812a0b7b6b7132d0375e662bc6200d68a/comments", "author": null, "committer": null, "parents": [{"sha": "e4373d41d67060e14bab0c984fb9f7cbc4c93f1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4373d41d67060e14bab0c984fb9f7cbc4c93f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4373d41d67060e14bab0c984fb9f7cbc4c93f1b"}], "stats": {"total": 117, "additions": 82, "deletions": 35}, "files": [{"sha": "c4e9444b51024b79699e3d7c362029abacaf686a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eae67f812a0b7b6b7132d0375e662bc6200d68a", "patch": "@@ -1,3 +1,19 @@\n+2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/rtl.texi: Rewrite the subreg rules so that they partition\n+\tthe inner register into REGMODE_NATURAL_SIZE bytes rather than\n+\tUNITS_PER_WORD bytes.\n+\t* emit-rtl.c (validate_subreg): Divide subregs into blocks\n+\tbased on REGMODE_NATURAL_SIZE of the inner mode.\n+\t(gen_lowpart_common): Split the SCALAR_FLOAT_MODE_P and\n+\t!SCALAR_FLOAT_MODE_P cases.  Use REGMODE_NATURAL_SIZE for the latter.\n+\t* expmed.c (lowpart_bit_field_p): Divide the value up into\n+\tchunks of REGMODE_NATURAL_SIZE rather than UNITS_PER_WORD.\n+\t* expr.c (store_constructor): Use REGMODE_NATURAL_SIZE to test\n+\twhether something is likely to occupy more than one register.\n+\n 2017-11-09  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/82879"}, {"sha": "7e2925ad92a9f1f5c61839081859d8114b8b80de", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=1eae67f812a0b7b6b7132d0375e662bc6200d68a", "patch": "@@ -1925,19 +1925,32 @@ false.\n When @var{m1} is at least as narrow as @var{m2} the @code{subreg}\n expression is called @dfn{normal}.\n \n+@findex REGMODE_NATURAL_SIZE\n Normal @code{subreg}s restrict consideration to certain bits of\n-@var{reg}.  There are two cases.  If @var{m1} is smaller than a word,\n-the @code{subreg} refers to the least-significant part (or\n-@dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or\n-greater, the @code{subreg} refers to one or more complete words.\n-\n-When used as an lvalue, @code{subreg} is a word-based accessor.\n-Storing to a @code{subreg} modifies all the words of @var{reg} that\n-overlap the @code{subreg}, but it leaves the other words of @var{reg}\n+@var{reg}.  For this purpose, @var{reg} is divided into\n+individually-addressable blocks in which each block has:\n+\n+@smallexample\n+REGMODE_NATURAL_SIZE (@var{m2})\n+@end smallexample\n+\n+bytes.  Usually the value is @code{UNITS_PER_WORD}; that is,\n+most targets usually treat each word of a register as being\n+independently addressable.\n+\n+There are two types of normal @code{subreg}.  If @var{m1} is known\n+to be no bigger than a block, the @code{subreg} refers to the\n+least-significant part (or @dfn{lowpart}) of one block of @var{reg}.\n+If @var{m1} is known to be larger than a block, the @code{subreg} refers\n+to two or more complete blocks.\n+\n+When used as an lvalue, @code{subreg} is a block-based accessor.\n+Storing to a @code{subreg} modifies all the blocks of @var{reg} that\n+overlap the @code{subreg}, but it leaves the other blocks of @var{reg}\n alone.\n \n-When storing to a normal @code{subreg} that is smaller than a word,\n-the other bits of the referenced word are usually left in an undefined\n+When storing to a normal @code{subreg} that is smaller than a block,\n+the other bits of the referenced block are usually left in an undefined\n state.  This laxity makes it easier to generate efficient code for\n such instructions.  To represent an instruction that preserves all the\n bits outside of those in the @code{subreg}, use @code{strict_low_part}\n@@ -1995,10 +2008,11 @@ number of undefined bits.  For example:\n (subreg:PSI (reg:SI 0) 0)\n @end smallexample\n \n+@findex REGMODE_NATURAL_SIZE\n accesses the whole of @samp{(reg:SI 0)}, but the exact relationship\n between the @code{PSImode} value and the @code{SImode} value is not\n-defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following\n-two @code{subreg}s:\n+defined.  If we assume @samp{REGMODE_NATURAL_SIZE (DImode) <= 4},\n+then the following two @code{subreg}s:\n \n @smallexample\n (subreg:PSI (reg:DI 0) 0)\n@@ -2009,7 +2023,7 @@ represent independent 4-byte accesses to the two halves of\n @samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number\n of undefined bits.\n \n-If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:\n+If @samp{REGMODE_NATURAL_SIZE (PSImode) <= 2} then these two @code{subreg}s:\n \n @smallexample\n (subreg:HI (reg:PSI 0) 0)\n@@ -2882,7 +2896,7 @@ The presence of @code{strict_low_part} says that the part of the\n register which is meaningful in mode @var{n}, but is not part of\n mode @var{m}, is not to be altered.  Normally, an assignment to such\n a subreg is allowed to have undefined effects on the rest of the\n-register when @var{m} is less than a word.\n+register when @var{m} is smaller than @samp{REGMODE_NATURAL_SIZE (@var{n})}.\n @end table\n \n @node Side Effects"}, {"sha": "ac6fd6a98ad2de89d4b831286bd72fbcf9e81598", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1eae67f812a0b7b6b7132d0375e662bc6200d68a", "patch": "@@ -816,6 +816,8 @@ validate_subreg (machine_mode omode, machine_mode imode,\n   if (offset >= isize)\n     return false;\n \n+  unsigned int regsize = REGMODE_NATURAL_SIZE (imode);\n+\n   /* ??? This should not be here.  Temporarily continue to allow word_mode\n      subregs of anything.  The most common offender is (subreg:SI (reg:DF)).\n      Generally, backends are doing something sketchy but it'll take time to\n@@ -824,7 +826,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n     ;\n   /* ??? Similarly, e.g. with (subreg:DF (reg:TI)).  Though store_bit_field\n      is the culprit here, and not the backends.  */\n-  else if (osize >= UNITS_PER_WORD && isize >= osize)\n+  else if (osize >= regsize && isize >= osize)\n     ;\n   /* Allow component subregs of complex and vector.  Though given the below\n      extraction rules, it's not always clear what that means.  */\n@@ -876,17 +878,23 @@ validate_subreg (machine_mode omode, machine_mode imode,\n     }\n \n   /* For pseudo registers, we want most of the same checks.  Namely:\n-     If the register no larger than a word, the subreg must be lowpart.\n-     If the register is larger than a word, the subreg must be the lowpart\n-     of a subword.  A subreg does *not* perform arbitrary bit extraction.\n-     Given that we've already checked mode/offset alignment, we only have\n-     to check subword subregs here.  */\n-  if (osize < UNITS_PER_WORD\n+\n+     Assume that the pseudo register will be allocated to hard registers\n+     that can hold REGSIZE bytes each.  If OSIZE is not a multiple of REGSIZE,\n+     the remainder must correspond to the lowpart of the containing hard\n+     register.  If BYTES_BIG_ENDIAN, the lowpart is at the highest offset,\n+     otherwise it is at the lowest offset.\n+\n+     Given that we've already checked the mode and offset alignment,\n+     we only have to check subblock subregs here.  */\n+  if (osize < regsize\n       && ! (lra_in_progress && (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))))\n     {\n-      machine_mode wmode = isize > UNITS_PER_WORD ? word_mode : imode;\n-      unsigned int low_off = subreg_lowpart_offset (omode, wmode);\n-      if (offset % UNITS_PER_WORD != low_off)\n+      unsigned int block_size = MIN (isize, regsize);\n+      unsigned int offset_within_block = offset % block_size;\n+      if (BYTES_BIG_ENDIAN\n+\t  ? offset_within_block != block_size - osize\n+\t  : offset_within_block != 0)\n \treturn false;\n     }\n   return true;\n@@ -1439,14 +1447,21 @@ gen_lowpart_common (machine_mode mode, rtx x)\n   if (innermode == mode)\n     return x;\n \n-  /* MODE must occupy no more words than the mode of X.  */\n-  if ((msize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n-      > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-    return 0;\n-\n-  /* Don't allow generating paradoxical FLOAT_MODE subregs.  */\n-  if (SCALAR_FLOAT_MODE_P (mode) && msize > xsize)\n-    return 0;\n+  if (SCALAR_FLOAT_MODE_P (mode))\n+    {\n+      /* Don't allow paradoxical FLOAT_MODE subregs.  */\n+      if (msize > xsize)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      /* MODE must occupy no more of the underlying registers than X.  */\n+      unsigned int regsize = REGMODE_NATURAL_SIZE (innermode);\n+      unsigned int mregs = CEIL (msize, regsize);\n+      unsigned int xregs = CEIL (xsize, regsize);\n+      if (mregs > xregs)\n+\treturn 0;\n+    }\n \n   scalar_int_mode int_mode, int_innermode, from_mode;\n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)"}, {"sha": "8e9f15d6a65fb06acd317da5b9ad9e3e42e9aeaa", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1eae67f812a0b7b6b7132d0375e662bc6200d68a", "patch": "@@ -506,12 +506,13 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n \t\t     unsigned HOST_WIDE_INT bitsize,\n \t\t     machine_mode struct_mode)\n {\n+  unsigned HOST_WIDE_INT regsize = REGMODE_NATURAL_SIZE (struct_mode);\n   if (BYTES_BIG_ENDIAN)\n     return (bitnum % BITS_PER_UNIT == 0\n \t    && (bitnum + bitsize == GET_MODE_BITSIZE (struct_mode)\n-\t\t|| (bitnum + bitsize) % BITS_PER_WORD == 0));\n+\t\t|| (bitnum + bitsize) % (regsize * BITS_PER_UNIT) == 0));\n   else\n-    return bitnum % BITS_PER_WORD == 0;\n+    return bitnum % (regsize * BITS_PER_UNIT) == 0;\n }\n \n /* Return true if -fstrict-volatile-bitfields applies to an access of OP0"}, {"sha": "76684c11cc3ee2c98f4ae73d11565c0a899bd6cf", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eae67f812a0b7b6b7132d0375e662bc6200d68a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1eae67f812a0b7b6b7132d0375e662bc6200d68a", "patch": "@@ -6186,7 +6186,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \t   a constant.  But if more than one register is involved,\n \t   this probably loses.  */\n \telse if (REG_P (target) && TREE_STATIC (exp)\n-\t\t && GET_MODE_SIZE (GET_MODE (target)) <= UNITS_PER_WORD)\n+\t\t && (GET_MODE_SIZE (GET_MODE (target))\n+\t\t     <= REGMODE_NATURAL_SIZE (GET_MODE (target))))\n \t  {\n \t    emit_move_insn (target, CONST0_RTX (GET_MODE (target)));\n \t    cleared = 1;"}]}