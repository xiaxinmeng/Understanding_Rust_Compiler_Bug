{"sha": "774672d2a238085337753d082c70e862a7b3f1a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0NjcyZDJhMjM4MDg1MzM3NzUzZDA4MmM3MGU4NjJhN2IzZjFhMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-28T10:02:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-28T10:02:05Z"}, "message": "(eliminate_regs_in_insn): When checking for moves and adds, use\nsingle_set.\n\nFrom-SVN: r7582", "tree": {"sha": "d88872fb2e1f6d682f93ecd48a0ad5374d351c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d88872fb2e1f6d682f93ecd48a0ad5374d351c9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/774672d2a238085337753d082c70e862a7b3f1a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774672d2a238085337753d082c70e862a7b3f1a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774672d2a238085337753d082c70e862a7b3f1a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774672d2a238085337753d082c70e862a7b3f1a2/comments", "author": null, "committer": null, "parents": [{"sha": "adab4fc5030c2589d3c289dd0f13ed5777483585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adab4fc5030c2589d3c289dd0f13ed5777483585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adab4fc5030c2589d3c289dd0f13ed5777483585"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "6f9d93db54e2a9e3cf91720cf11ae9775f79ebbf", "filename": "gcc/reload1.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774672d2a238085337753d082c70e862a7b3f1a2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774672d2a238085337753d082c70e862a7b3f1a2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=774672d2a238085337753d082c70e862a7b3f1a2", "patch": "@@ -3118,19 +3118,20 @@ eliminate_regs_in_insn (insn, replace)\n      int replace;\n {\n   rtx old_body = PATTERN (insn);\n+  rtx old_set = single_set (insn);\n   rtx new_body;\n   int val = 0;\n   struct elim_table *ep;\n \n   if (! replace)\n     push_obstacks (&reload_obstack, &reload_obstack);\n \n-  if (GET_CODE (old_body) == SET && GET_CODE (SET_DEST (old_body)) == REG\n-      && REGNO (SET_DEST (old_body)) < FIRST_PSEUDO_REGISTER)\n+  if (old_set != 0 && GET_CODE (SET_DEST (old_set)) == REG\n+      && REGNO (SET_DEST (old_set)) < FIRST_PSEUDO_REGISTER)\n     {\n       /* Check for setting an eliminable register.  */\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->from_rtx == SET_DEST (old_body) && ep->can_eliminate)\n+\tif (ep->from_rtx == SET_DEST (old_set) && ep->can_eliminate)\n \t  {\n \t    /* In this case this insn isn't serving a useful purpose.  We\n \t       will delete it in reload_as_needed once we know that this\n@@ -3151,22 +3152,25 @@ eliminate_regs_in_insn (insn, replace)\n \t We have to do this here, rather than in eliminate_regs, do that we can\n \t change the insn code.  */\n \n-      if (GET_CODE (SET_SRC (old_body)) == PLUS\n-\t  && GET_CODE (XEXP (SET_SRC (old_body), 0)) == REG\n-\t  && GET_CODE (XEXP (SET_SRC (old_body), 1)) == CONST_INT)\n+      if (GET_CODE (SET_SRC (old_set)) == PLUS\n+\t  && GET_CODE (XEXP (SET_SRC (old_set), 0)) == REG\n+\t  && GET_CODE (XEXP (SET_SRC (old_set), 1)) == CONST_INT)\n \tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t     ep++)\n-\t  if (ep->from_rtx == XEXP (SET_SRC (old_body), 0)\n+\t  if (ep->from_rtx == XEXP (SET_SRC (old_set), 0)\n \t      && ep->can_eliminate)\n \t    {\n \t      /* We must stop at the first elimination that will be used.\n \t\t If this one would replace the PLUS with a REG, do it\n \t\t now.  Otherwise, quit the loop and let eliminate_regs\n \t\t do its normal replacement.  */\n-\t      if (ep->offset == - INTVAL (XEXP (SET_SRC (old_body), 1)))\n+\t      if (ep->offset == - INTVAL (XEXP (SET_SRC (old_set), 1)))\n \t\t{\n+\t\t  /* We assume here that we don't need a PARALLEL of\n+\t\t     any CLOBBERs for this assignment.  There's not\n+\t\t     much we can do if we do need it.  */\n \t\t  PATTERN (insn) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t    SET_DEST (old_body), ep->to_rtx);\n+\t\t\t\t\t    SET_DEST (old_set), ep->to_rtx);\n \t\t  INSN_CODE (insn) = -1;\n \t\t  val = 1;\n \t\t  goto done;\n@@ -3199,22 +3203,25 @@ eliminate_regs_in_insn (insn, replace)\n       if (! replace && asm_noperands (old_body) < 0)\n \tnew_body = copy_rtx (new_body);\n \n-      /* If we had a move insn but now we don't, rerecognize it.  */\n-      if ((GET_CODE (old_body) == SET && GET_CODE (SET_SRC (old_body)) == REG\n-\t   && (GET_CODE (new_body) != SET\n-\t       || GET_CODE (SET_SRC (new_body)) != REG))\n-\t  /* If this was a load from or store to memory, compare\n-\t     the MEM in recog_operand to the one in the insn.  If they\n-\t     are not equal, then rerecognize the insn.  */\n-\t  || (GET_CODE (old_body) == SET\n-\t      && ((GET_CODE (SET_SRC (old_body)) == MEM\n-\t\t   && SET_SRC (old_body) != recog_operand[1])\n-\t\t  || (GET_CODE (SET_DEST (old_body)) == MEM\n-\t\t      && SET_DEST (old_body) != recog_operand[0])))\n-\t  /* If this was an add insn before, rerecognize.  */\n-\t  ||\n-\t  (GET_CODE (old_body) == SET\n-\t   && GET_CODE (SET_SRC (old_body)) == PLUS))\n+      /* If we had a move insn but now we don't, rerecognize it.  This will\n+\t cause spurious re-recognition if the old move had a PARALLEL since\n+\t the new one still will, but we can't call single_set without\n+\t having put NEW_BODY into the insn and the re-recognition won't\n+\t hurt in this rare case.  */\n+      if (old_set != 0\n+\t  && ((GET_CODE (SET_SRC (old_set)) == REG\n+\t       && (GET_CODE (new_body) != SET\n+\t\t   || GET_CODE (SET_SRC (new_body)) != REG))\n+\t      /* If this was a load from or store to memory, compare\n+\t\t the MEM in recog_operand to the one in the insn.  If they\n+\t\t are not equal, then rerecognize the insn.  */\n+\t      || (old_set != 0\n+\t\t  && ((GET_CODE (SET_SRC (old_set)) == MEM\n+\t\t       && SET_SRC (old_set) != recog_operand[1])\n+\t\t      || (GET_CODE (SET_DEST (old_set)) == MEM\n+\t\t\t  && SET_DEST (old_set) != recog_operand[0])))\n+\t      /* If this was an add insn before, rerecognize.  */\n+\t      || GET_CODE (SET_SRC (old_set)) == PLUS))\n \t{\n \t  if (! validate_change (insn, &PATTERN (insn), new_body, 0))\n \t    /* If recognition fails, store the new body anyway."}]}