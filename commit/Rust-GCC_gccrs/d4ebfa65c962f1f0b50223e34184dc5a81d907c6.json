{"sha": "d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlYmZhNjVjOTYyZjFmMGI1MDIyM2UzNDE4NGRjNWE4MWQ5MDdjNg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-10-26T21:57:10Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-10-26T21:57:10Z"}, "message": "tm.texi (TARGET_ADDR_SPACE_POINTER_MODE): Document.\n\n2009-10-26  Ben Elliston  <bje@au.ibm.com>\n\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* doc/tm.texi (TARGET_ADDR_SPACE_POINTER_MODE): Document.\n\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.\n\t(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.\n\n\t* target.h (struct target_def): Add pointer_mode, address_mode,\n\tand valid_pointer_mode to addr_space substructure.\n\t* target-def.h (TARGET_ADDR_SPACE_POINTER_MODE): Define.\n\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.\n\t(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.\n\t(TARGET_ADDR_SPACE_HOOKS): Add them.\n\t* targhooks.c (target_default_pointer_address_modes_p): New function.\n\t* target.h (target_default_pointer_address_modes_p): Add prototype.\n\t* targhooks.c (default_addr_space_pointer_mode): New function.\n\t(default_addr_space_address_mode): Likewise.\n\t(default_addr_space_valid_pointer_mode): Likewise.\n\t* targhooks.h (default_addr_space_pointer_mode): Add prototype.\n\t(default_addr_space_address_mode): Likewise.\n\t(default_addr_space_valid_pointer_mode): Likewise.\n\t* output.h (default_valid_pointer_mode): Move to ...\n\t* targhooks.h (default_valid_pointer_mode): ... here.\n\t* varasm.c (default_valid_pointer_mode): Move to ...\n\t* targhooks.c (default_valid_pointer_mode): ... here.\n\n\t* varasm.c (output_constant): Use targetm.addr_space.valid_pointer_mode\n\tinstead of targetm.valid_pointer_mode.\n\n\t* fold-const.c (fit_double_type): Use int_or_pointer_precision.\n\t* tree.c (integer_pow2p): Likewise.\n\t(tree_log2): Likewise.\n\t(tree_floor_log2): Likewise.\n\t(signed_or_unsigned_type_for): Support pointer type of different size.\n\t(int_or_pointer_precision): New function.\n\t* tree.h (int_or_pointer_precision): Add prototype.\n\t* stor-layout.c (layout_type): Set TYPE_PRECISION for offset types.\n\t* varasm.c (initializer_constant_valid_p): Use TYPE_PRECISION of\n\tincoming pointer type instead of POINTER_SIZE.\n\n\t* tree.c (build_pointer_type): Use appropriate pointer mode\n\tinstead of ptr_mode.\n\t(build_reference_type): Likewise.\n\t* expr.c (store_expr): Likewise.\n\t(expand_expr_addr_expr): Likewise.\n\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t\n\t* auto-inc-dec.c: Include \"target.h\".\n\t(try_merge): Use appropriate address mode instead of Pmode.\n\t(find_inc): Likewise.\n\t* combine.c (find_split_point): Likewise.\n\t* cselib.c (cselib_record_sets): Likewise.\n\t* dse.c (replace_inc_dec): Likewise.\n\t(canon_address): Likewise.\n\t* var-tracking.c (replace_expr_with_values): Likewise.\n\t(count_uses): Likewise.\n\t(add_uses): Likewise.\n\t(add_stores): Likewise.\n\t* emit-rtl.c: Include \"target.h\".\n\t(adjust_address_1): Use appropriate address mode instead of Pmode.\n\t(offset_address): Likewise.\n\t* explow.c (break_out_memory_refs): Likewise.\n\t(memory_address_addr_space): Likewise.\n\t(promote_mode): Likewise.\n\t* expr.c (move_by_pieces): Likewise.\n\t(emit_block_move_via_loop): Likewise.\n\t(store_by_pieces): Likewise.\n\t(store_by_pieces_1): Likewise.\n\t(expand_assignment): Likewise.\n\t(store_constructor): Likewise.\n\t(expand_expr_addr_expr): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* cfgexpand.c (expand_debug_expr): Likewise.\n\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n\t* regcprop.c (kill_autoinc_value): Likewise.\n\t* regmove.c (try_auto_increment): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t(find_reloads_address): Likewise.\n\t(find_reloads_address_1): Likewise.\n\t* sched-deps.c: Include \"target.h\".\n\t(sched_analyze_1): Use appropriate address mode instead of Pmode.\n\t(sched_analyze_2): Likewise.\n\t* sel-sched-dump.c: Include \"target.h\".\n\t(debug_mem_addr_value): Use appropriate address mode instead of Pmode.\n\t* stor-layout.c (layout_type): Likewise.\n\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n\t(multiplier_allowed_in_address_p): Likewise.\n\t(get_address_cost): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\t\n\t* expr.c (expand_assignment): Always convert offsets to appropriate\n\taddress mode.\n\t(store_expr): Likewise.\n\t(store_constructor): Likewise.\n\t(expand_expr_real_1): Likewise.\n\n\t* reload.h (form_sum): Add MODE argument.\n\t* reload.c (form_sum): Add MODE argument, use it instead of Pmode.\n\tUpdate recursive calls.\n\t(subst_indexed_address): Update calls to form_sum.\n\t\n\t* tree-flow.h (addr_for_mem_ref): Add ADDRSPACE argument.\n\t* tree-ssa-address.c: Include \"target.h\".\n\t(templates): Replace by ...\n\t(mem_addr_template_list): ... this new vector.\n\t(TEMPL_IDX): Handle address space numbers.\n\t(gen_addr_rtx): Add address mode argument, use it instead of Pmode.\n\t(addr_for_mem_ref): Add ADDRSPACE argument.  Use per-address-space\n\tinstead of global cache.  Update call to gen_addr_rtx.\n\t(valid_mem_ref_p): Update call to addr_for_mem_ref.\n\t* expr.c (expand_expr_real_1): Update call to addr_for_mem_ref.\n\t\n\t* rtl.h (convert_memory_address_addr_space): Add prototype.\n\t(convert_memory_address): Define as macro.\n\t* explow.c (convert_memory_address): Rename to ...\n\t(convert_memory_address_addr_space): ... this.  Add ADDRSPACE argument.\n\tUse appropriate pointer and address modes instead of ptr_mode / Pmode.\n\tUpdate recursive calls.\n\t(memory_address_addr_space): Call convert_memory_address_addr_space.\n\t* expmed.c (make_tree): Likewise.\n\t* expr.c (expand_assignment): Likewise.\n\t(expand_expr_addr_expr_1): Likewise.  Also, add ADDRSPACE argument.\n\t(expand_expr_addr_expr): Likewise.  Also, update call.\n\n\t* alias.c (find_base_value): Guard pointer size optimizations.\n\t(find_base_term): Likewise.\n\t* rtlanal.c (nonzero_bits1): Likewise.\n\t(num_sign_bit_copies1): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\n\t* Makefile.in (tree-ssa-address.o): Add $(TARGET_H) dependency.\n\t(emit-rtl.o): Likewise.\n\t(auto-inc-dec.o): Likewise.\n\t(sched-deps.o): Likewise.\n\nCo-Authored-By: Michael Meissner <meissner@linux.vnet.ibm.com>\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r153573", "tree": {"sha": "0b006fa60cd37b4bd974ed32a7adc7f005e9eb0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b006fa60cd37b4bd974ed32a7adc7f005e9eb0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/comments", "author": null, "committer": null, "parents": [{"sha": "09e881c9e21a9209b2092e400ea4c38948614f78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09e881c9e21a9209b2092e400ea4c38948614f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09e881c9e21a9209b2092e400ea4c38948614f78"}], "stats": {"total": 1032, "additions": 756, "deletions": 276}, "files": [{"sha": "658274da3038c3228345ebcdb9aeb85ca49ec471", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1,3 +1,140 @@\n+2009-10-26  Ben Elliston  <bje@au.ibm.com>\n+\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* doc/tm.texi (TARGET_ADDR_SPACE_POINTER_MODE): Document.\n+\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.\n+\t(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.\n+\n+\t* target.h (struct target_def): Add pointer_mode, address_mode,\n+\tand valid_pointer_mode to addr_space substructure.\n+\t* target-def.h (TARGET_ADDR_SPACE_POINTER_MODE): Define.\n+\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.\n+\t(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.\n+\t(TARGET_ADDR_SPACE_HOOKS): Add them.\n+\t* targhooks.c (target_default_pointer_address_modes_p): New function.\n+\t* target.h (target_default_pointer_address_modes_p): Add prototype.\n+\t* targhooks.c (default_addr_space_pointer_mode): New function.\n+\t(default_addr_space_address_mode): Likewise.\n+\t(default_addr_space_valid_pointer_mode): Likewise.\n+\t* targhooks.h (default_addr_space_pointer_mode): Add prototype.\n+\t(default_addr_space_address_mode): Likewise.\n+\t(default_addr_space_valid_pointer_mode): Likewise.\n+\t* output.h (default_valid_pointer_mode): Move to ...\n+\t* targhooks.h (default_valid_pointer_mode): ... here.\n+\t* varasm.c (default_valid_pointer_mode): Move to ...\n+\t* targhooks.c (default_valid_pointer_mode): ... here.\n+\n+\t* varasm.c (output_constant): Use targetm.addr_space.valid_pointer_mode\n+\tinstead of targetm.valid_pointer_mode.\n+\n+\t* fold-const.c (fit_double_type): Use int_or_pointer_precision.\n+\t* tree.c (integer_pow2p): Likewise.\n+\t(tree_log2): Likewise.\n+\t(tree_floor_log2): Likewise.\n+\t(signed_or_unsigned_type_for): Support pointer type of different size.\n+\t(int_or_pointer_precision): New function.\n+\t* tree.h (int_or_pointer_precision): Add prototype.\n+\t* stor-layout.c (layout_type): Set TYPE_PRECISION for offset types.\n+\t* varasm.c (initializer_constant_valid_p): Use TYPE_PRECISION of\n+\tincoming pointer type instead of POINTER_SIZE.\n+\n+\t* tree.c (build_pointer_type): Use appropriate pointer mode\n+\tinstead of ptr_mode.\n+\t(build_reference_type): Likewise.\n+\t* expr.c (store_expr): Likewise.\n+\t(expand_expr_addr_expr): Likewise.\n+\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t\n+\t* auto-inc-dec.c: Include \"target.h\".\n+\t(try_merge): Use appropriate address mode instead of Pmode.\n+\t(find_inc): Likewise.\n+\t* combine.c (find_split_point): Likewise.\n+\t* cselib.c (cselib_record_sets): Likewise.\n+\t* dse.c (replace_inc_dec): Likewise.\n+\t(canon_address): Likewise.\n+\t* var-tracking.c (replace_expr_with_values): Likewise.\n+\t(count_uses): Likewise.\n+\t(add_uses): Likewise.\n+\t(add_stores): Likewise.\n+\t* emit-rtl.c: Include \"target.h\".\n+\t(adjust_address_1): Use appropriate address mode instead of Pmode.\n+\t(offset_address): Likewise.\n+\t* explow.c (break_out_memory_refs): Likewise.\n+\t(memory_address_addr_space): Likewise.\n+\t(promote_mode): Likewise.\n+\t* expr.c (move_by_pieces): Likewise.\n+\t(emit_block_move_via_loop): Likewise.\n+\t(store_by_pieces): Likewise.\n+\t(store_by_pieces_1): Likewise.\n+\t(expand_assignment): Likewise.\n+\t(store_constructor): Likewise.\n+\t(expand_expr_addr_expr): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Likewise.\n+\t* ifcvt.c (noce_try_cmove_arith): Likewise.\n+\t* regcprop.c (kill_autoinc_value): Likewise.\n+\t* regmove.c (try_auto_increment): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t(find_reloads_address): Likewise.\n+\t(find_reloads_address_1): Likewise.\n+\t* sched-deps.c: Include \"target.h\".\n+\t(sched_analyze_1): Use appropriate address mode instead of Pmode.\n+\t(sched_analyze_2): Likewise.\n+\t* sel-sched-dump.c: Include \"target.h\".\n+\t(debug_mem_addr_value): Use appropriate address mode instead of Pmode.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.\n+\t(multiplier_allowed_in_address_p): Likewise.\n+\t(get_address_cost): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\t\n+\t* expr.c (expand_assignment): Always convert offsets to appropriate\n+\taddress mode.\n+\t(store_expr): Likewise.\n+\t(store_constructor): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\n+\t* reload.h (form_sum): Add MODE argument.\n+\t* reload.c (form_sum): Add MODE argument, use it instead of Pmode.\n+\tUpdate recursive calls.\n+\t(subst_indexed_address): Update calls to form_sum.\n+\t\n+\t* tree-flow.h (addr_for_mem_ref): Add ADDRSPACE argument.\n+\t* tree-ssa-address.c: Include \"target.h\".\n+\t(templates): Replace by ...\n+\t(mem_addr_template_list): ... this new vector.\n+\t(TEMPL_IDX): Handle address space numbers.\n+\t(gen_addr_rtx): Add address mode argument, use it instead of Pmode.\n+\t(addr_for_mem_ref): Add ADDRSPACE argument.  Use per-address-space\n+\tinstead of global cache.  Update call to gen_addr_rtx.\n+\t(valid_mem_ref_p): Update call to addr_for_mem_ref.\n+\t* expr.c (expand_expr_real_1): Update call to addr_for_mem_ref.\n+\t\n+\t* rtl.h (convert_memory_address_addr_space): Add prototype.\n+\t(convert_memory_address): Define as macro.\n+\t* explow.c (convert_memory_address): Rename to ...\n+\t(convert_memory_address_addr_space): ... this.  Add ADDRSPACE argument.\n+\tUse appropriate pointer and address modes instead of ptr_mode / Pmode.\n+\tUpdate recursive calls.\n+\t(memory_address_addr_space): Call convert_memory_address_addr_space.\n+\t* expmed.c (make_tree): Likewise.\n+\t* expr.c (expand_assignment): Likewise.\n+\t(expand_expr_addr_expr_1): Likewise.  Also, add ADDRSPACE argument.\n+\t(expand_expr_addr_expr): Likewise.  Also, update call.\n+\n+\t* alias.c (find_base_value): Guard pointer size optimizations.\n+\t(find_base_term): Likewise.\n+\t* rtlanal.c (nonzero_bits1): Likewise.\n+\t(num_sign_bit_copies1): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\n+\t* Makefile.in (tree-ssa-address.o): Add $(TARGET_H) dependency.\n+\t(emit-rtl.o): Likewise.\n+\t(auto-inc-dec.o): Likewise.\n+\t(sched-deps.o): Likewise.\n+\n 2009-10-26  Ben Elliston  <bje@au.ibm.com>\n \t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>"}, {"sha": "5dd47e57f39955f8e0513802f5f03227bd38f1c3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -2432,7 +2432,7 @@ tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TREE_INLINE_H) $(RECOG_H) insn-config.h \\\n-   $(EXPR_H) gt-tree-ssa-address.h $(GGC_H) tree-affine.h\n+   $(EXPR_H) gt-tree-ssa-address.h $(GGC_H) tree-affine.h $(TARGET_H)\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n    $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n@@ -2824,7 +2824,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(TOPLEV_H) $(BASIC_BLOCK_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h $(TREE_PASS_H) gt-emit-rtl.h \\\n-   $(REAL_H) $(DF_H) $(PARAMS_H)\n+   $(REAL_H) $(DF_H) $(PARAMS_H) $(TARGET_H)\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TOPLEV_H) $(TM_P_H) $(REAL_H) dfp.h\n dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n@@ -3034,7 +3034,7 @@ alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)\n auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \\\n    $(REGS_H) $(FLAGS_H) output.h $(FUNCTION_H) $(EXCEPT_H) $(TOPLEV_H) $(RECOG_H) \\\n-   $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)\n+   $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h $(TOPLEV_H) $(FUNCTION_H) $(EXCEPT_H) $(GGC_H) \\\n    $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h \\\n@@ -3215,7 +3215,7 @@ haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) cselib.h \\\n-   ira.h $(PARAMS_H) $(TM_P_H) ira.h\n+   ira.h $(PARAMS_H) $(TM_P_H) ira.h $(TARGET_H)\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\"}, {"sha": "40226f26b17193fc613cb4752ec29f0a555348c2", "filename": "gcc/alias.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1060,6 +1060,11 @@ find_base_value (rtx src)\n       return 0;\n \n     case TRUNCATE:\n+      /* As we do not know which address space the pointer is refering to, we can\n+\t handle this only if the target does not support different pointer or\n+\t address modes depending on the address space.  */\n+      if (!target_default_pointer_address_modes_p ())\n+\tbreak;\n       if (GET_MODE_SIZE (GET_MODE (src)) < GET_MODE_SIZE (Pmode))\n \tbreak;\n       /* Fall through.  */\n@@ -1074,6 +1079,12 @@ find_base_value (rtx src)\n \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\t/* used for NT/Alpha pointers */\n+      /* As we do not know which address space the pointer is refering to, we can\n+\t handle this only if the target does not support different pointer or\n+\t address modes depending on the address space.  */\n+      if (!target_default_pointer_address_modes_p ())\n+\tbreak;\n+\n       {\n \trtx temp = find_base_value (XEXP (src, 0));\n \n@@ -1466,6 +1477,11 @@ find_base_term (rtx x)\n       return REG_BASE_VALUE (x);\n \n     case TRUNCATE:\n+      /* As we do not know which address space the pointer is refering to, we can\n+\t handle this only if the target does not support different pointer or\n+\t address modes depending on the address space.  */\n+      if (!target_default_pointer_address_modes_p ())\n+\treturn 0;\n       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (Pmode))\n \treturn 0;\n       /* Fall through.  */\n@@ -1480,6 +1496,12 @@ find_base_term (rtx x)\n \n     case ZERO_EXTEND:\n     case SIGN_EXTEND:\t/* Used for Alpha/NT pointers */\n+      /* As we do not know which address space the pointer is refering to, we can\n+\t handle this only if the target does not support different pointer or\n+\t address modes depending on the address space.  */\n+      if (!target_default_pointer_address_modes_p ())\n+\treturn 0;\n+\n       {\n \trtx temp = find_base_term (XEXP (x, 0));\n "}, {"sha": "3b3006c985fa414d021f4eae72502c79fd28f1d2", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"dbgcnt.h\"\n+#include \"target.h\"\n \n /* This pass was originally removed from flow.c. However there is\n    almost nothing that remains of that code.\n@@ -613,6 +614,7 @@ try_merge (void)\n   /* The width of the mem being accessed.  */\n   int size = GET_MODE_SIZE (GET_MODE (mem));\n   rtx last_insn = NULL;\n+  enum machine_mode reg_mode = GET_MODE (inc_reg);\n \n   switch (inc_insn.form)\n     {\n@@ -667,33 +669,33 @@ try_merge (void)\n     case SIMPLE_PRE_INC:     /* ++size  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_PRE_INC\\n\");\n-      return attempt_change (gen_rtx_PRE_INC (Pmode, inc_reg), inc_reg);\n+      return attempt_change (gen_rtx_PRE_INC (reg_mode, inc_reg), inc_reg);\n       break;\n       \n     case SIMPLE_POST_INC:    /* size++  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_POST_INC\\n\");\n-      return attempt_change (gen_rtx_POST_INC (Pmode, inc_reg), inc_reg);\n+      return attempt_change (gen_rtx_POST_INC (reg_mode, inc_reg), inc_reg);\n       break;\n       \n     case SIMPLE_PRE_DEC:     /* --size  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_PRE_DEC\\n\");\n-      return attempt_change (gen_rtx_PRE_DEC (Pmode, inc_reg), inc_reg);\n+      return attempt_change (gen_rtx_PRE_DEC (reg_mode, inc_reg), inc_reg);\n       break;\n       \n     case SIMPLE_POST_DEC:    /* size--  */\n       if (dump_file)\n \tfprintf (dump_file, \"trying SIMPLE_POST_DEC\\n\");\n-      return attempt_change (gen_rtx_POST_DEC (Pmode, inc_reg), inc_reg);\n+      return attempt_change (gen_rtx_POST_DEC (reg_mode, inc_reg), inc_reg);\n       break;\n       \n     case DISP_PRE:           /* ++con   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying DISP_PRE\\n\");\n-      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, \n+      return attempt_change (gen_rtx_PRE_MODIFY (reg_mode,\n \t\t\t\t\t\t inc_reg,\n-\t\t\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t gen_rtx_PLUS (reg_mode,\n \t\t\t\t\t\t\t       inc_reg,\n \t\t\t\t\t\t\t       inc_insn.reg1)),\n \t\t\t     inc_reg);\n@@ -702,9 +704,9 @@ try_merge (void)\n     case DISP_POST:          /* con++   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying POST_DISP\\n\");\n-      return attempt_change (gen_rtx_POST_MODIFY (Pmode,\n+      return attempt_change (gen_rtx_POST_MODIFY (reg_mode,\n \t\t\t\t\t\t  inc_reg,\n-\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t  gen_rtx_PLUS (reg_mode,\n \t\t\t\t\t\t\t\tinc_reg,\n \t\t\t\t\t\t\t\tinc_insn.reg1)),\n \t\t\t     inc_reg);\n@@ -713,9 +715,9 @@ try_merge (void)\n     case REG_PRE:            /* ++reg   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying PRE_REG\\n\");\n-      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, \n+      return attempt_change (gen_rtx_PRE_MODIFY (reg_mode,\n \t\t\t\t\t\t inc_reg,\n-\t\t\t\t\t\t gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t gen_rtx_PLUS (reg_mode,\n \t\t\t\t\t\t\t       inc_reg,\n \t\t\t\t\t\t\t       inc_insn.reg1)),\n \t\t\t     inc_reg);\n@@ -724,9 +726,9 @@ try_merge (void)\n     case REG_POST:            /* reg++   */\n       if (dump_file)\n \tfprintf (dump_file, \"trying POST_REG\\n\");\n-      return attempt_change (gen_rtx_POST_MODIFY (Pmode, \n+      return attempt_change (gen_rtx_POST_MODIFY (reg_mode,\n \t\t\t\t\t\t  inc_reg,\n-\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t  gen_rtx_PLUS (reg_mode,\n \t\t\t\t\t\t\t\tinc_reg,\n \t\t\t\t\t\t\t\tinc_insn.reg1)),\n \t\t\t     inc_reg);\n@@ -1089,7 +1091,9 @@ find_inc (bool first_try)\n \t\t     we are going to increment the result of the add insn.\n \t\t     For this trick to be correct, the result reg of\n \t\t     the inc must be a valid addressing reg.  */\n-\t\t  if (GET_MODE (inc_insn.reg_res) != Pmode)\n+\t\t  addr_space_t as = MEM_ADDR_SPACE (*mem_insn.mem_loc);\n+\t\t  if (GET_MODE (inc_insn.reg_res)\n+\t\t      != targetm.addr_space.address_mode (as))\n \t\t    {\n \t\t      if (dump_file)\n \t\t\tfprintf (dump_file, \"base reg mode failure.\\n\");\n@@ -1138,7 +1142,9 @@ find_inc (bool first_try)\n \t{\n \t  /* For this trick to be correct, the result reg of the inc\n \t     must be a valid addressing reg.  */\n-\t  if (GET_MODE (inc_insn.reg_res) != Pmode)\n+\t  addr_space_t as = MEM_ADDR_SPACE (*mem_insn.mem_loc);\n+\t  if (GET_MODE (inc_insn.reg_res)\n+\t      != targetm.addr_space.address_mode (as))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"base reg mode failure.\\n\");"}, {"sha": "fdc4de586ef7acb06e80b0d1c4f3c6fa7a03c0e9", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -2236,6 +2236,8 @@ expand_debug_expr (tree exp)\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n   addr_space_t as;\n+  enum machine_mode address_mode;\n+  enum machine_mode pointer_mode;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -2434,15 +2436,18 @@ expand_debug_expr (tree exp)\n       else\n \tas = ADDR_SPACE_GENERIC;\n \n-      gcc_assert (GET_MODE (op0) == Pmode\n-\t\t  || GET_MODE (op0) == ptr_mode\n+      address_mode = targetm.addr_space.address_mode (as);\n+      pointer_mode = targetm.addr_space.pointer_mode (as);\n+\n+      gcc_assert (GET_MODE (op0) == address_mode\n+\t\t  || GET_MODE (op0) == pointer_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n \t\t  || GET_CODE (op0) == CONST_DOUBLE);\n \n       if (TREE_CODE (exp) == ALIGN_INDIRECT_REF)\n \t{\n \t  int align = TYPE_ALIGN_UNIT (TREE_TYPE (exp));\n-\t  op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));\n+\t  op0 = gen_rtx_AND (address_mode, op0, GEN_INT (-align));\n \t}\n \n       op0 = gen_rtx_MEM (mode, op0);\n@@ -2463,9 +2468,11 @@ expand_debug_expr (tree exp)\n \treturn NULL;\n \n       as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n+      address_mode = targetm.addr_space.address_mode (as);\n+      pointer_mode = targetm.addr_space.pointer_mode (as);\n \n-      gcc_assert (GET_MODE (op0) == Pmode\n-\t\t  || GET_MODE (op0) == ptr_mode\n+      gcc_assert (GET_MODE (op0) == address_mode\n+\t\t  || GET_MODE (op0) == pointer_mode\n \t\t  || GET_CODE (op0) == CONST_INT\n \t\t  || GET_CODE (op0) == CONST_DOUBLE);\n "}, {"sha": "2311755691cf1e91c044c77961c3092607cfa701", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -4159,9 +4159,12 @@ find_split_point (rtx *loc, rtx insn)\n       if (GET_CODE (XEXP (x, 0)) == CONST\n \t  || GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n+\t  enum machine_mode address_mode\n+\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n+\n \t  SUBST (XEXP (x, 0),\n-\t\t gen_rtx_LO_SUM (Pmode,\n-\t\t\t\t gen_rtx_HIGH (Pmode, XEXP (x, 0)),\n+\t\t gen_rtx_LO_SUM (address_mode,\n+\t\t\t\t gen_rtx_HIGH (address_mode, XEXP (x, 0)),\n \t\t\t\t XEXP (x, 0)));\n \t  return &XEXP (XEXP (x, 0), 0);\n \t}"}, {"sha": "0aa22a4fe1b07431359a5ebb6451b8fbd1fac882", "filename": "gcc/cselib.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1890,7 +1890,13 @@ cselib_record_sets (rtx insn)\n \t    src = gen_rtx_IF_THEN_ELSE (GET_MODE (dest), cond, src, dest);\n \t  sets[i].src_elt = cselib_lookup (src, GET_MODE (dest), 1);\n \t  if (MEM_P (dest))\n-\t    sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0), Pmode, 1);\n+\t    {\n+\t      enum machine_mode address_mode\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n+\n+\t      sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0),\n+\t\t\t\t\t\t     address_mode, 1);\n+\t    }\n \t  else\n \t    sets[i].dest_addr_elt = 0;\n \t}"}, {"sha": "26b5a14a3d78457cacc30a1b8e79241644d49187", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -9855,6 +9855,30 @@ Internally, address spaces are represented as a small integer in the\n range 0 to 15 with address space 0 being reserved for the generic\n address space.\n \n+@deftypefn {Target Hook} {enum machine_mode} TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t @var{address_space})\n+Define this to return the machine mode to use for pointers to\n+@var{address_space} if the target supports named address spaces.\n+The default version of this hook returns @code{ptr_mode} for the\n+generic address space only.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {enum machine_mode} TARGET_ADDR_SPACE_ADDRESS_MODE (addr_space_t @var{address_space})\n+Define this to return the machine mode to use for addresses in\n+@var{address_space} if the target supports named address spaces.\n+The default version of this hook returns @code{Pmode} for the\n+generic address space only.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_VALID_POINTER_MODE (enum machine_mode @var{mode}, addr_space_t @var{as})\n+Define this to return nonzero if the port can handle pointers\n+with machine mode @var{mode} to address space @var{as}.  This target\n+hook is the same as the @code{TARGET_VALID_POINTER_MODE} target hook,\n+except that it includes explicit named address space support.  The default\n+version of this hook returns true for the modes returned by either the\n+@code{TARGET_ADDR_SPACE_POINTER_MODE} or @code{TARGET_ADDR_SPACE_ADDRESS_MODE}\n+target hooks for the given address space.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {bool} TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P (enum machine_mode @var{mode}, rtx @var{exp}, bool @var{strict}, addr_space_t @var{as})\n Define this to return true if @var{exp} is a valid address for mode\n @var{mode} in the named address space @var{as}.  The @var{strict}"}, {"sha": "a883bcd3d693478db69708a6622cc59f283e6d86", "filename": "gcc/dse.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -826,9 +826,9 @@ replace_inc_dec (rtx *r, void *d)\n     case POST_INC:\n       {\n \trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (data->size, Pmode);\n-\temit_insn_before (gen_rtx_SET (Pmode, r1, \n-\t\t\t\t       gen_rtx_PLUS (Pmode, r1, c)),\n+\trtx c = gen_int_mode (data->size, GET_MODE (r1));\n+\temit_insn_before (gen_rtx_SET (VOIDmode, r1,\n+\t\t\t\t       gen_rtx_PLUS (GET_MODE (r1), r1, c)),\n \t\t\t  data->insn);\n \treturn -1;\n       }\n@@ -837,9 +837,9 @@ replace_inc_dec (rtx *r, void *d)\n     case POST_DEC:\n       {\n \trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (-data->size, Pmode);\n-\temit_insn_before (gen_rtx_SET (Pmode, r1, \n-\t\t\t\t       gen_rtx_PLUS (Pmode, r1, c)),\n+\trtx c = gen_int_mode (-data->size, GET_MODE (r1));\n+\temit_insn_before (gen_rtx_SET (VOIDmode, r1,\n+\t\t\t\t       gen_rtx_PLUS (GET_MODE (r1), r1, c)),\n \t\t\t  data->insn);\n \treturn -1;\n       }\n@@ -851,7 +851,7 @@ replace_inc_dec (rtx *r, void *d)\n \t   insn that contained it.  */\n \trtx add = XEXP (x, 0);\n \trtx r1 = XEXP (add, 0);\n-\temit_insn_before (gen_rtx_SET (Pmode, r1, add), data->insn);\n+\temit_insn_before (gen_rtx_SET (VOIDmode, r1, add), data->insn);\n \treturn -1;\n       }\n \n@@ -1068,6 +1068,8 @@ canon_address (rtx mem,\n \t       HOST_WIDE_INT *offset, \n \t       cselib_val **base)\n {\n+  enum machine_mode address_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n   rtx mem_address = XEXP (mem, 0);\n   rtx expanded_address, address;\n   int expanded;\n@@ -1107,7 +1109,7 @@ canon_address (rtx mem,\n \n   *alias_set_out = 0;\n \n-  cselib_lookup (mem_address, Pmode, 1);\n+  cselib_lookup (mem_address, address_mode, 1);\n \n   if (dump_file)\n     {\n@@ -1187,7 +1189,7 @@ canon_address (rtx mem,\n \t}\n     }\n \n-  *base = cselib_lookup (address, Pmode, true);\n+  *base = cselib_lookup (address, address_mode, true);\n   *group_id = -1;\n \n   if (*base == NULL)"}, {"sha": "d7600bccc26b17476ebdd598850a17e3d0ecbf9b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"params.h\"\n+#include \"target.h\"\n \n /* Commonly used modes.  */\n \n@@ -1975,6 +1976,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n   rtx size = 0;\n   unsigned int memalign = MEM_ALIGN (memref);\n   addr_space_t as = MEM_ADDR_SPACE (memref);\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n   int pbits;\n \n   /* If there are no changes, just return the original memory reference.  */\n@@ -1989,7 +1991,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \n   /* Convert a possibly large offset to a signed value within the\n      range of the target address space.  */\n-  pbits = GET_MODE_BITSIZE (Pmode);\n+  pbits = GET_MODE_BITSIZE (address_mode);\n   if (HOST_BITS_PER_WIDE_INT > pbits)\n     {\n       int shift = HOST_BITS_PER_WIDE_INT - pbits;\n@@ -2005,7 +2007,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \t  && offset >= 0\n \t  && (unsigned HOST_WIDE_INT) offset\n \t      < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)\n-\taddr = gen_rtx_LO_SUM (Pmode, XEXP (addr, 0),\n+\taddr = gen_rtx_LO_SUM (address_mode, XEXP (addr, 0),\n \t\t\t       plus_constant (XEXP (addr, 1), offset));\n       else\n \taddr = plus_constant (addr, offset);\n@@ -2068,8 +2070,9 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n   addr_space_t as = MEM_ADDR_SPACE (memref);\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n \n-  new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+  new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);\n \n   /* At this point we don't know _why_ the address is invalid.  It\n      could have secondary memory references, multiplies or anything.\n@@ -2083,7 +2086,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n       && XEXP (addr, 0) == pic_offset_table_rtx)\n     {\n       addr = force_reg (GET_MODE (addr), addr);\n-      new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+      new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);\n     }\n \n   update_temp_slot_address (XEXP (memref, 0), new_rtx);"}, {"sha": "c38682d4ce5e74aa2e1c3b1295aa57a87cd4c2e4", "filename": "gcc/explow.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -306,35 +306,37 @@ break_out_memory_refs (rtx x)\n       rtx op1 = break_out_memory_refs (XEXP (x, 1));\n \n       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = simplify_gen_binary (GET_CODE (x), Pmode, op0, op1);\n+\tx = simplify_gen_binary (GET_CODE (x), GET_MODE (x), op0, op1);\n     }\n \n   return x;\n }\n \n-/* Given X, a memory address in ptr_mode, convert it to an address\n-   in Pmode, or vice versa (TO_MODE says which way).  We take advantage of\n-   the fact that pointers are not allowed to overflow by commuting arithmetic\n-   operations over conversions so that address arithmetic insns can be\n-   used.  */\n+/* Given X, a memory address in address space AS' pointer mode, convert it to\n+   an address in the address space's address mode, or vice versa (TO_MODE says\n+   which way).  We take advantage of the fact that pointers are not allowed to\n+   overflow by commuting arithmetic operations over conversions so that address\n+   arithmetic insns can be used.  */\n \n rtx\n-convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED, \n-\t\t\trtx x)\n+convert_memory_address_addr_space (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n+\t\t\t\t   rtx x, addr_space_t as ATTRIBUTE_UNUSED)\n {\n #ifndef POINTERS_EXTEND_UNSIGNED\n   gcc_assert (GET_MODE (x) == to_mode || GET_MODE (x) == VOIDmode);\n   return x;\n #else /* defined(POINTERS_EXTEND_UNSIGNED) */\n-  enum machine_mode from_mode;\n+  enum machine_mode pointer_mode, address_mode, from_mode;\n   rtx temp;\n   enum rtx_code code;\n \n   /* If X already has the right mode, just return it.  */\n   if (GET_MODE (x) == to_mode)\n     return x;\n \n-  from_mode = to_mode == ptr_mode ? Pmode : ptr_mode;\n+  pointer_mode = targetm.addr_space.pointer_mode (as);\n+  address_mode = targetm.addr_space.address_mode (as);\n+  from_mode = to_mode == pointer_mode ? address_mode : pointer_mode;\n \n   /* Here we handle some special cases.  If none of them apply, fall through\n      to the default case.  */\n@@ -375,7 +377,8 @@ convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n \n     case CONST:\n       return gen_rtx_CONST (to_mode,\n-\t\t\t    convert_memory_address (to_mode, XEXP (x, 0)));\n+\t\t\t    convert_memory_address_addr_space\n+\t\t\t      (to_mode, XEXP (x, 0), as));\n       break;\n \n     case PLUS:\n@@ -389,10 +392,12 @@ convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED,\n       if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n \t  || (GET_CODE (x) == PLUS\n \t      && CONST_INT_P (XEXP (x, 1))\n-\t      && (XEXP (x, 1) == convert_memory_address (to_mode, XEXP (x, 1))\n+\t      && (XEXP (x, 1) == convert_memory_address_addr_space\n+\t\t\t\t   (to_mode, XEXP (x, 1), as)\n                  || POINTERS_EXTEND_UNSIGNED < 0)))\n \treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode,\n-\t\t\t       convert_memory_address (to_mode, XEXP (x, 0)),\n+\t\t\t       convert_memory_address_addr_space\n+\t\t\t\t (to_mode, XEXP (x, 0), as),\n \t\t\t       XEXP (x, 1));\n       break;\n \n@@ -413,13 +418,14 @@ rtx\n memory_address_addr_space (enum machine_mode mode, rtx x, addr_space_t as)\n {\n   rtx oldx = x;\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n \n-  x = convert_memory_address (Pmode, x);\n+  x = convert_memory_address_addr_space (address_mode, x, as);\n \n   /* By passing constant addresses through registers\n      we get a chance to cse them.  */\n   if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))\n-    x = force_reg (Pmode, x);\n+    x = force_reg (address_mode, x);\n \n   /* We get better cse by rejecting indirect addressing at this stage.\n      Let the combiner create indirect addresses where appropriate.\n@@ -490,7 +496,7 @@ memory_address_addr_space (enum machine_mode mode, rtx x, addr_space_t as)\n       /* Last resort: copy the value to a register, since\n \t the register is a valid address.  */\n       else\n-\tx = force_reg (Pmode, x);\n+\tx = force_reg (address_mode, x);\n     }\n \n  done:\n@@ -801,7 +807,8 @@ promote_mode (const_tree type ATTRIBUTE_UNUSED, enum machine_mode mode,\n     case REFERENCE_TYPE:\n     case POINTER_TYPE:\n       *punsignedp = POINTERS_EXTEND_UNSIGNED;\n-      return Pmode;\n+      return targetm.addr_space.address_mode\n+\t       (TYPE_ADDR_SPACE (TREE_TYPE (type)));\n       break;\n #endif\n "}, {"sha": "12370d073335207dbba43c83d85a06bfe6e4942e", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -5089,10 +5089,11 @@ make_tree (tree type, rtx x)\n     default:\n       t = build_decl (RTL_LOCATION (x), VAR_DECL, NULL_TREE, type);\n \n-      /* If TYPE is a POINTER_TYPE, X might be Pmode with TYPE_MODE being\n-\t ptr_mode.  So convert.  */\n+      /* If TYPE is a POINTER_TYPE, we might need to convert X from\n+\t address mode to pointer mode.  */\n       if (POINTER_TYPE_P (type))\n-\tx = convert_memory_address (TYPE_MODE (type), x);\n+\tx = convert_memory_address_addr_space\n+\t      (TYPE_MODE (type), x, TYPE_ADDR_SPACE (TREE_TYPE (type)));\n \n       /* Note that we do *not* use SET_DECL_RTL here, because we do not\n \t want set_decl_rtl to go adjusting REG_ATTRS for this temporary.  */"}, {"sha": "e62b530211484d1be209f5c1c674b47dfe6a2a5b", "filename": "gcc/expr.c", "status": "modified", "additions": 90, "deletions": 54, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -877,6 +877,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \t\tunsigned int align, int endp)\n {\n   struct move_by_pieces_d data;\n+  enum machine_mode to_addr_mode, from_addr_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (from));\n   rtx to_addr, from_addr = XEXP (from, 0);\n   unsigned int max_size = MOVE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n@@ -888,6 +890,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n   data.from_addr = from_addr;\n   if (to)\n     {\n+      to_addr_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));\n       to_addr = XEXP (to, 0);\n       data.to = to;\n       data.autinc_to\n@@ -898,6 +901,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n     }\n   else\n     {\n+      to_addr_mode = VOIDmode;\n       to_addr = NULL_RTX;\n       data.to = NULL_RTX;\n       data.autinc_to = 1;\n@@ -933,32 +937,34 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \n       if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)\n \t{\n-\t  data.from_addr = copy_addr_to_reg (plus_constant (from_addr, len));\n+\t  data.from_addr = copy_to_mode_reg (from_addr_mode,\n+\t\t\t\t\t     plus_constant (from_addr, len));\n \t  data.autinc_from = 1;\n \t  data.explicit_inc_from = -1;\n \t}\n       if (USE_LOAD_POST_INCREMENT (mode) && ! data.autinc_from)\n \t{\n-\t  data.from_addr = copy_addr_to_reg (from_addr);\n+\t  data.from_addr = copy_to_mode_reg (from_addr_mode, from_addr);\n \t  data.autinc_from = 1;\n \t  data.explicit_inc_from = 1;\n \t}\n       if (!data.autinc_from && CONSTANT_P (from_addr))\n-\tdata.from_addr = copy_addr_to_reg (from_addr);\n+\tdata.from_addr = copy_to_mode_reg (from_addr_mode, from_addr);\n       if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)\n \t{\n-\t  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));\n+\t  data.to_addr = copy_to_mode_reg (to_addr_mode,\n+\t\t\t\t\t   plus_constant (to_addr, len));\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = -1;\n \t}\n       if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_to)\n \t{\n-\t  data.to_addr = copy_addr_to_reg (to_addr);\n+\t  data.to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = 1;\n \t}\n       if (!data.autinc_to && CONSTANT_P (to_addr))\n-\tdata.to_addr = copy_addr_to_reg (to_addr);\n+\tdata.to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n     }\n \n   tmode = mode_for_size (MOVE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n@@ -1013,7 +1019,8 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n \t      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)\n \t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n \t      else\n-\t\tdata.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,\n+\t\tdata.to_addr = copy_to_mode_reg (to_addr_mode,\n+\t\t\t\t\t\t plus_constant (data.to_addr,\n \t\t\t\t\t\t\t\t-1));\n \t    }\n \t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n@@ -1468,6 +1475,10 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n \t\t\t  unsigned int align ATTRIBUTE_UNUSED)\n {\n   rtx cmp_label, top_label, iter, x_addr, y_addr, tmp;\n+  enum machine_mode x_addr_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n+  enum machine_mode y_addr_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (y));\n   enum machine_mode iter_mode;\n \n   iter_mode = GET_MODE (size);\n@@ -1487,9 +1498,13 @@ emit_block_move_via_loop (rtx x, rtx y, rtx size,\n   emit_jump (cmp_label);\n   emit_label (top_label);\n \n-  tmp = convert_modes (Pmode, iter_mode, iter, true);\n-  x_addr = gen_rtx_PLUS (Pmode, x_addr, tmp);\n-  y_addr = gen_rtx_PLUS (Pmode, y_addr, tmp);\n+  tmp = convert_modes (x_addr_mode, iter_mode, iter, true);\n+  x_addr = gen_rtx_PLUS (x_addr_mode, x_addr, tmp);\n+\n+  if (x_addr_mode != y_addr_mode)\n+    tmp = convert_modes (y_addr_mode, iter_mode, iter, true);\n+  y_addr = gen_rtx_PLUS (y_addr_mode, y_addr, tmp);\n+\n   x = change_address (x, QImode, x_addr);\n   y = change_address (y, QImode, y_addr);\n \n@@ -2384,6 +2399,8 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\t rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n \t\t void *constfundata, unsigned int align, bool memsetp, int endp)\n {\n+  enum machine_mode to_addr_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));\n   struct store_by_pieces_d data;\n \n   if (len == 0)\n@@ -2412,7 +2429,8 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)\n \t\temit_insn (gen_add2_insn (data.to_addr, constm1_rtx));\n \t      else\n-\t\tdata.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,\n+\t\tdata.to_addr = copy_to_mode_reg (to_addr_mode,\n+\t\t\t\t\t\t plus_constant (data.to_addr,\n \t\t\t\t\t\t\t\t-1));\n \t    }\n \t  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,\n@@ -2467,6 +2485,8 @@ static void\n store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n \t\t   unsigned int align ATTRIBUTE_UNUSED)\n {\n+  enum machine_mode to_addr_mode\n+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (data->to));\n   rtx to_addr = XEXP (data->to, 0);\n   unsigned int max_size = STORE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n@@ -2498,21 +2518,22 @@ store_by_pieces_1 (struct store_by_pieces_d *data ATTRIBUTE_UNUSED,\n \n       if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)\n \t{\n-\t  data->to_addr = copy_addr_to_reg (plus_constant (to_addr, data->len));\n+\t  data->to_addr = copy_to_mode_reg (to_addr_mode,\n+\t\t\t\t\t    plus_constant (to_addr, data->len));\n \t  data->autinc_to = 1;\n \t  data->explicit_inc_to = -1;\n \t}\n \n       if (USE_STORE_POST_INCREMENT (mode) && ! data->reverse\n \t  && ! data->autinc_to)\n \t{\n-\t  data->to_addr = copy_addr_to_reg (to_addr);\n+\t  data->to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n \t  data->autinc_to = 1;\n \t  data->explicit_inc_to = 1;\n \t}\n \n       if ( !data->autinc_to && CONSTANT_P (to_addr))\n-\tdata->to_addr = copy_addr_to_reg (to_addr);\n+\tdata->to_addr = copy_to_mode_reg (to_addr_mode, to_addr);\n     }\n \n   tmode = mode_for_size (STORE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n@@ -4214,6 +4235,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       if (offset != 0)\n \t{\n+\t  enum machine_mode address_mode;\n \t  rtx offset_rtx;\n \n \t  if (!MEM_P (to_rtx))\n@@ -4226,13 +4248,10 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t    }\n \n \t  offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t  if (GET_MODE (offset_rtx) != Pmode)\n-\t    offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);\n-#else\n-\t  if (GET_MODE (offset_rtx) != ptr_mode)\n-\t    offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n-#endif\n+\t  address_mode\n+\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));\n+\t  if (GET_MODE (offset_rtx) != address_mode)\n+\t    offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n \n \t  /* A constant address in TO_RTX can have VOIDmode, we must not try\n \t     to call force_reg for that case.  Avoid that case.  */\n@@ -4371,7 +4390,10 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       else\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (to)))\n-\t    value = convert_memory_address (GET_MODE (to_rtx), value);\n+\t    value = convert_memory_address_addr_space\n+\t\t      (GET_MODE (to_rtx), value,\n+\t\t       TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (to))));\n+\n \t  emit_move_insn (to_rtx, value);\n \t}\n       preserve_temp_slots (to_rtx);\n@@ -4731,6 +4753,11 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \t  else\n \t    {\n+\t      enum machine_mode pointer_mode\n+\t\t= targetm.addr_space.pointer_mode (MEM_ADDR_SPACE (target));\n+\t      enum machine_mode address_mode\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (target));\n+\n \t      /* Compute the size of the data to copy from the string.  */\n \t      tree copy_size\n \t\t= size_binop_loc (loc, MIN_EXPR,\n@@ -4743,14 +4770,14 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n-\t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx,\n+\t      copy_size_rtx = convert_to_mode (pointer_mode, copy_size_rtx,\n \t\t\t\t\t       TYPE_UNSIGNED (sizetype));\n \t      emit_block_move (target, temp, copy_size_rtx,\n \t\t\t       (call_param_p\n \t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n-\t\t Do all calculations in ptr_mode.  */\n+\t\t Do all calculations in pointer_mode.  */\n \t      if (CONST_INT_P (copy_size_rtx))\n \t\t{\n \t\t  size = plus_constant (size, -INTVAL (copy_size_rtx));\n@@ -4763,11 +4790,10 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t\t  if (GET_MODE (copy_size_rtx) != Pmode)\n-\t\t    copy_size_rtx = convert_to_mode (Pmode, copy_size_rtx,\n+\t\t  if (GET_MODE (copy_size_rtx) != address_mode)\n+\t\t    copy_size_rtx = convert_to_mode (address_mode,\n+\t\t\t\t\t\t     copy_size_rtx,\n \t\t\t\t\t\t     TYPE_UNSIGNED (sizetype));\n-#endif\n \n \t\t  target = offset_address (target, copy_size_rtx,\n \t\t\t\t\t   highest_pow2_factor (copy_size));\n@@ -5257,6 +5283,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t    if (offset)\n \t      {\n+\t        enum machine_mode address_mode;\n \t\trtx offset_rtx;\n \n \t\toffset\n@@ -5267,13 +5294,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\toffset_rtx = expand_normal (offset);\n \t\tgcc_assert (MEM_P (to_rtx));\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t\tif (GET_MODE (offset_rtx) != Pmode)\n-\t\t  offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);\n-#else\n-\t\tif (GET_MODE (offset_rtx) != ptr_mode)\n-\t\t  offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n-#endif\n+\t\taddress_mode\n+\t\t  = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));\n+\t\tif (GET_MODE (offset_rtx) != address_mode)\n+\t\t  offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n \n \t\tto_rtx = offset_address (to_rtx, offset_rtx,\n \t\t\t\t\t highest_pow2_factor (offset));\n@@ -6796,7 +6820,7 @@ expand_expr_constant (tree exp, int defer, enum expand_modifier modifier)\n \n static rtx\n expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n-\t\t         enum expand_modifier modifier)\n+\t\t         enum expand_modifier modifier, addr_space_t as)\n {\n   rtx result, subtarget;\n   tree inner, offset;\n@@ -6823,7 +6847,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n     case CONST_DECL:\n       /* Recurse and make the output_constant_def clause above handle this.  */\n       return expand_expr_addr_expr_1 (DECL_INITIAL (exp), target,\n-\t\t\t\t      tmode, modifier);\n+\t\t\t\t      tmode, modifier, as);\n \n     case REALPART_EXPR:\n       /* The real part of the complex number is always first, therefore\n@@ -6913,7 +6937,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n       TYPE_ALIGN (TREE_TYPE (inner)) = TYPE_ALIGN (TREE_TYPE (exp));\n       TYPE_USER_ALIGN (TREE_TYPE (inner)) = 1;\n     }\n-  result = expand_expr_addr_expr_1 (inner, subtarget, tmode, modifier);\n+  result = expand_expr_addr_expr_1 (inner, subtarget, tmode, modifier, as);\n \n   if (offset)\n     {\n@@ -6925,8 +6949,8 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t modifier == EXPAND_INITIALIZER\n \t\t\t  ? EXPAND_INITIALIZER : EXPAND_NORMAL);\n \n-      result = convert_memory_address (tmode, result);\n-      tmp = convert_memory_address (tmode, tmp);\n+      result = convert_memory_address_addr_space (tmode, result, as);\n+      tmp = convert_memory_address_addr_space (tmode, tmp, as);\n \n       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n \tresult = gen_rtx_PLUS (tmode, result, tmp);\n@@ -6959,21 +6983,31 @@ static rtx\n expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n \t\t       enum expand_modifier modifier)\n {\n+  addr_space_t as = ADDR_SPACE_GENERIC;\n+  enum machine_mode address_mode = Pmode;\n+  enum machine_mode pointer_mode = ptr_mode;\n   enum machine_mode rmode;\n   rtx result;\n \n   /* Target mode of VOIDmode says \"whatever's natural\".  */\n   if (tmode == VOIDmode)\n     tmode = TYPE_MODE (TREE_TYPE (exp));\n \n+  if (POINTER_TYPE_P (TREE_TYPE (exp)))\n+    {\n+      as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));\n+      address_mode = targetm.addr_space.address_mode (as);\n+      pointer_mode = targetm.addr_space.pointer_mode (as);\n+    }\n+\n   /* We can get called with some Weird Things if the user does silliness\n      like \"(short) &a\".  In that case, convert_memory_address won't do\n      the right thing, so ignore the given target mode.  */\n-  if (tmode != Pmode && tmode != ptr_mode)\n-    tmode = Pmode;\n+  if (tmode != address_mode && tmode != pointer_mode)\n+    tmode = address_mode;\n \n   result = expand_expr_addr_expr_1 (TREE_OPERAND (exp, 0), target,\n-\t\t\t\t    tmode, modifier);\n+\t\t\t\t    tmode, modifier, as);\n \n   /* Despite expand_expr claims concerning ignoring TMODE when not\n      strictly convenient, stuff breaks if we don't honor it.  Note\n@@ -6982,7 +7016,7 @@ expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n   if (rmode == VOIDmode)\n     rmode = tmode;\n   if (rmode != tmode)\n-    result = convert_memory_address (tmode, result);\n+    result = convert_memory_address_addr_space (tmode, result, as);\n \n   return result;\n }\n@@ -8657,6 +8691,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \ttree exp1 = treeop0;\n \taddr_space_t as = ADDR_SPACE_GENERIC;\n+\tenum machine_mode address_mode = Pmode;\n \n \tif (modifier != EXPAND_WRITE)\n \t  {\n@@ -8668,15 +8703,18 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  }\n \n \tif (POINTER_TYPE_P (TREE_TYPE (exp1)))\n-\t  as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n+\t  {\n+\t    as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));\n+\t    address_mode = targetm.addr_space.address_mode (as);\n+\t  }\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address_addr_space (mode, op0, as);\n \n \tif (code == ALIGN_INDIRECT_REF)\n \t  {\n \t    int align = TYPE_ALIGN_UNIT (type);\n-\t    op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));\n+\t    op0 = gen_rtx_AND (address_mode, op0, GEN_INT (-align));\n \t    op0 = memory_address_addr_space (mode, op0, as);\n \t  }\n \n@@ -8719,7 +8757,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tstruct mem_address addr;\n \n \tget_address_description (exp, &addr);\n-\top0 = addr_for_mem_ref (&addr, true);\n+\top0 = addr_for_mem_ref (&addr, as, true);\n \top0 = memory_address_addr_space (mode, op0, as);\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, TMR_ORIGINAL (exp), 0);\n@@ -9011,18 +9049,16 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \tif (offset)\n \t  {\n+\t    enum machine_mode address_mode;\n \t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,\n \t\t\t\t\t  EXPAND_SUM);\n \n \t    gcc_assert (MEM_P (op0));\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t    if (GET_MODE (offset_rtx) != Pmode)\n-\t      offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);\n-#else\n-\t    if (GET_MODE (offset_rtx) != ptr_mode)\n-\t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n-#endif\n+\t    address_mode\n+\t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (op0));\n+\t    if (GET_MODE (offset_rtx) != address_mode)\n+\t      offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);\n \n \t    if (GET_MODE (op0) == BLKmode\n \t\t/* A constant address in OP0 can have VOIDmode, we must"}, {"sha": "102929d1e20f1a495e19333fbc3392657c79dd95", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -206,15 +206,9 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n {\n   unsigned HOST_WIDE_INT low0 = l1;\n   HOST_WIDE_INT high0 = h1;\n-  unsigned int prec;\n+  unsigned int prec = int_or_pointer_precision (type);\n   int sign_extended_type;\n \n-  if (POINTER_TYPE_P (type)\n-      || TREE_CODE (type) == OFFSET_TYPE)\n-    prec = POINTER_SIZE;\n-  else\n-    prec = TYPE_PRECISION (type);\n-\n   /* Size types *are* sign extended.  */\n   sign_extended_type = (!TYPE_UNSIGNED (type)\n \t\t\t|| (TREE_CODE (type) == INTEGER_TYPE"}, {"sha": "d8d15a59be1e1c7feb070869a99168f7f962f5ea", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1332,9 +1332,12 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n       && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b)\n       && if_info->branch_cost >= 5)\n     {\n+      enum machine_mode address_mode\n+\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (a));\n+\n       a = XEXP (a, 0);\n       b = XEXP (b, 0);\n-      x = gen_reg_rtx (Pmode);\n+      x = gen_reg_rtx (address_mode);\n       is_mem = 1;\n     }\n "}, {"sha": "5d771d7d06f5e9044e858efce8941ec53610e5e7", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -626,7 +626,6 @@ extern void default_emit_except_table_label (FILE *);\n extern void default_internal_label (FILE *, const char *, unsigned long);\n extern void default_file_start (void);\n extern void file_end_indicate_exec_stack (void);\n-extern bool default_valid_pointer_mode (enum machine_mode);\n \n extern void default_elf_asm_output_external (FILE *file, tree,\n \t\t\t\t\t     const char *);"}, {"sha": "ac8350d1f4e2cec29685afba5593c3bec65ac0ea", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -247,7 +247,7 @@ kill_autoinc_value (rtx *px, void *data)\n     {\n       x = XEXP (x, 0);\n       kill_value (x, vd);\n-      set_value_regno (REGNO (x), Pmode, vd);\n+      set_value_regno (REGNO (x), GET_MODE (x), vd);\n       return -1;\n     }\n "}, {"sha": "581af4c7edca3e8d1cfc2cf158e7a95afeef2a8b", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -185,7 +185,9 @@ try_auto_increment (rtx insn, rtx inc_insn, rtx inc_insn_set, rtx reg,\n \t\t   &SET_SRC (inc_insn_set),\n \t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n \t      validate_change (insn, &XEXP (use, 0),\n-\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, reg), 1);\n+\t\t\t       gen_rtx_fmt_e (inc_code,\n+\t\t\t\t\t      GET_MODE (XEXP (use, 0)), reg),\n+\t\t\t       1);\n \t      if (apply_change_group ())\n \t\t{\n \t\t  /* If there is a REG_DEAD note on this insn, we must"}, {"sha": "3333697f2e06053fc8e3acd93c2b7b232b814f71", "filename": "gcc/reload.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -3987,12 +3987,15 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t && MEM_P (recog_data.operand[i]))\n \t  {\n \t    /* If the address to be reloaded is a VOIDmode constant,\n-\t       use Pmode as mode of the reload register, as would have\n-\t       been done by find_reloads_address.  */\n+\t       use the default address mode as mode of the reload register,\n+\t       as would have been done by find_reloads_address.  */\n \t    enum machine_mode address_mode;\n \t    address_mode = GET_MODE (XEXP (recog_data.operand[i], 0));\n \t    if (address_mode == VOIDmode)\n-\t      address_mode = Pmode;\n+\t      {\n+\t\taddr_space_t as = MEM_ADDR_SPACE (recog_data.operand[i]);\n+\t\taddress_mode = targetm.addr_space.address_mode (as);\n+\t      }\n \n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n@@ -5113,7 +5116,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t     That will at least work.  */\n \t  find_reloads_address_part (ad, loc,\n \t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n-\t\t\t\t     Pmode, opnum, type, ind_levels);\n+\t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n \t}\n       return ! removed_and;\n     }\n@@ -5235,6 +5238,10 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n      into a register.  */\n   if (CONSTANT_P (ad) && ! strict_memory_address_addr_space_p (mode, ad, as))\n     {\n+      enum machine_mode address_mode = GET_MODE (ad);\n+      if (ad == VOIDmode)\n+\taddress_mode = targetm.addr_space.address_mode (as);\n+\n       /* If AD is an address in the constant pool, the MEM rtx may be shared.\n \t Unshare it so we can safely alter it.  */\n       if (memrefloc && GET_CODE (ad) == SYMBOL_REF\n@@ -5247,7 +5254,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t}\n \n       find_reloads_address_part (ad, loc, base_reg_class (mode, MEM, SCRATCH),\n-\t\t\t\t Pmode, opnum, type, ind_levels);\n+\t\t\t\t address_mode, opnum, type, ind_levels);\n       return ! removed_and;\n     }\n \n@@ -5334,16 +5341,12 @@ subst_reg_equivs (rtx ad, rtx insn)\n    This routine assumes both inputs are already in canonical form.  */\n \n rtx\n-form_sum (rtx x, rtx y)\n+form_sum (enum machine_mode mode, rtx x, rtx y)\n {\n   rtx tem;\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (y);\n \n-  if (mode == VOIDmode)\n-    mode = Pmode;\n+  gcc_assert (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode);\n+  gcc_assert (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode);\n \n   if (CONST_INT_P (x))\n     return plus_constant (y, INTVAL (x));\n@@ -5353,12 +5356,12 @@ form_sum (rtx x, rtx y)\n     tem = x, x = y, y = tem;\n \n   if (GET_CODE (x) == PLUS && CONSTANT_P (XEXP (x, 1)))\n-    return form_sum (XEXP (x, 0), form_sum (XEXP (x, 1), y));\n+    return form_sum (mode, XEXP (x, 0), form_sum (mode, XEXP (x, 1), y));\n \n   /* Note that if the operands of Y are specified in the opposite\n      order in the recursive calls below, infinite recursion will occur.  */\n   if (GET_CODE (y) == PLUS && CONSTANT_P (XEXP (y, 1)))\n-    return form_sum (form_sum (x, XEXP (y, 0)), XEXP (y, 1));\n+    return form_sum (mode, form_sum (mode, x, XEXP (y, 0)), XEXP (y, 1));\n \n   /* If both constant, encapsulate sum.  Otherwise, just form sum.  A\n      constant will have been placed second.  */\n@@ -5425,9 +5428,9 @@ subst_indexed_address (rtx addr)\n \n       /* Compute the sum.  */\n       if (op2 != 0)\n-\top1 = form_sum (op1, op2);\n+\top1 = form_sum (GET_MODE (addr), op1, op2);\n       if (op1 != 0)\n-\top0 = form_sum (op0, op1);\n+\top0 = form_sum (GET_MODE (addr), op0, op1);\n \n       return op0;\n     }\n@@ -5827,17 +5830,18 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t      rtx equiv = (MEM_P (XEXP (x, 0))\n \t\t\t   ? XEXP (x, 0)\n \t\t\t   : reg_equiv_mem[regno]);\n-\t      int icode = (int) optab_handler (add_optab, Pmode)->insn_code;\n+\t      int icode\n+\t\t= (int) optab_handler (add_optab, GET_MODE (x))->insn_code;\n \t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n #endif\n \t\t  && ! (icode != CODE_FOR_nothing\n \t\t\t&& ((*insn_data[icode].operand[0].predicate)\n-\t\t\t    (equiv, Pmode))\n+\t\t\t    (equiv, GET_MODE (x)))\n \t\t\t&& ((*insn_data[icode].operand[1].predicate)\n-\t\t\t    (equiv, Pmode))))\n+\t\t\t    (equiv, GET_MODE (x)))))\n \t\t{\n \t\t  /* We use the original pseudo for loc, so that\n \t\t     emit_reload_insns() knows which pseudo this"}, {"sha": "5d8375b9589c74cc6c4304be27532bc7e06a8156", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -289,7 +289,7 @@ extern int find_reloads (rtx, int, int, int, short *);\n    address, namely: sum constant integers, surround the sum of two\n    constants with a CONST, put the constant as the second operand, and\n    group the constant on the outermost sum.  */\n-extern rtx form_sum (rtx, rtx);\n+extern rtx form_sum (enum machine_mode, rtx, rtx);\n \n /* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  */"}, {"sha": "ce049220608804b4d2ebf89707f7cfa8b67b9a0e", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -2658,7 +2658,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t     && reg_equiv_constant[REGNO (new0)] != 0)\n \t      new0 = reg_equiv_constant[REGNO (new0)];\n \n-\t    new_rtx = form_sum (new0, new1);\n+\t    new_rtx = form_sum (GET_MODE (x), new0, new1);\n \n \t    /* As above, if we are not inside a MEM we do not want to\n \t       turn a PLUS into something else.  We might try to do so here"}, {"sha": "7cf3a7fe2e012480608aa380787b3d44af3ed988", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1613,7 +1613,10 @@ extern unsigned int subreg_highpart_offset (enum machine_mode,\n \t\t\t\t\t    enum machine_mode);\n extern int byte_lowpart_offset (enum machine_mode, enum machine_mode);\n extern rtx make_safe_from (rtx, rtx);\n-extern rtx convert_memory_address (enum machine_mode, rtx);\n+extern rtx convert_memory_address_addr_space (enum machine_mode, rtx,\n+\t\t\t\t\t      addr_space_t);\n+#define convert_memory_address(to_mode,x) \\\n+\tconvert_memory_address_addr_space ((to_mode), (x), ADDR_SPACE_GENERIC)\n extern rtx get_insns (void);\n extern const char *get_insn_name (int);\n extern rtx get_last_insn (void);"}, {"sha": "d14bbe58bf7577e8ffc7cbbde46d386f154b39e8", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -3748,7 +3748,11 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend unsigned and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be zero.  */\n-      if (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+      /* As we do not know which address space the pointer is refering to,\n+\t we can do this only if the target does not support different pointer\n+\t or address modes depending on the address space.  */\n+      if (target_default_pointer_address_modes_p ()\n+\t  && POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n \t  && REG_POINTER (x))\n \tnonzero &= GET_MODE_MASK (ptr_mode);\n #endif\n@@ -3985,7 +3989,11 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t/* If pointers extend unsigned and this is an addition or subtraction\n \t   to a pointer in Pmode, all the bits above ptr_mode are known to be\n \t   zero.  */\n-\tif (POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode\n+\t/* As we do not know which address space the pointer is refering to,\n+\t   we can do this only if the target does not support different pointer\n+\t   or address modes depending on the address space.  */\n+\tif (target_default_pointer_address_modes_p ()\n+\t    && POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode\n \t    && (code == PLUS || code == MINUS)\n \t    && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))\n \t  nonzero &= GET_MODE_MASK (ptr_mode);\n@@ -4259,8 +4267,12 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend signed and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be sign bit copies.  */\n-      if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode && mode == Pmode\n-\t  && REG_POINTER (x))\n+      /* As we do not know which address space the pointer is refering to,\n+\t we can do this only if the target does not support different pointer\n+\t or address modes depending on the address space.  */\n+      if (target_default_pointer_address_modes_p ()\n+\t  && ! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+\t  && mode == Pmode && REG_POINTER (x))\n \treturn GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;\n #endif\n \n@@ -4456,7 +4468,11 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       /* If pointers extend signed and this is an addition or subtraction\n \t to a pointer in Pmode, all the bits above ptr_mode are known to be\n \t sign bit copies.  */\n-      if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+      /* As we do not know which address space the pointer is refering to,\n+\t we can do this only if the target does not support different pointer\n+\t or address modes depending on the address space.  */\n+      if (target_default_pointer_address_modes_p ()\n+\t  && ! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n \t  && (code == PLUS || code == MINUS)\n \t  && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))\n \tresult = MAX ((int) (GET_MODE_BITSIZE (Pmode)"}, {"sha": "1f1a76c10901496c3deeccfd8e77098bb89ccff7", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"cselib.h\"\n #include \"ira.h\"\n+#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -2281,8 +2282,11 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \n       if (sched_deps_info->use_cselib)\n \t{\n+\t  enum machine_mode address_mode\n+\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n+\n \t  t = shallow_copy_rtx (dest);\n-\t  cselib_lookup (XEXP (t, 0), Pmode, 1);\n+\t  cselib_lookup (XEXP (t, 0), address_mode, 1);\n \t  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t}\n       t = canon_rtx (t);\n@@ -2435,8 +2439,11 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \n \tif (sched_deps_info->use_cselib)\n \t  {\n+\t    enum machine_mode address_mode\n+\t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (t));\n+\n \t    t = shallow_copy_rtx (t);\n-\t    cselib_lookup (XEXP (t, 0), Pmode, 1);\n+\t    cselib_lookup (XEXP (t, 0), address_mode, 1);\n \t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t  }\n "}, {"sha": "b307f52b841470d18ad585651ab8e1e69306dee8", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"basic-block.h\"\n #include \"cselib.h\"\n+#include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n #include \"sel-sched-ir.h\"\n@@ -931,10 +932,13 @@ rtx\n debug_mem_addr_value (rtx x)\n {\n   rtx t, addr;\n+  enum machine_mode address_mode;\n \n   gcc_assert (MEM_P (x));\n+  address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n+\n   t = shallow_copy_rtx (x);\n-  if (cselib_lookup (XEXP (t, 0), Pmode, 0))\n+  if (cselib_lookup (XEXP (t, 0), address_mode, 0))\n     XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \n   t = canon_rtx (t);"}, {"sha": "39a791d9890838f157b89359c30d60371106070c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1012,7 +1012,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n \n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n-      if (! POINTERS_EXTEND_UNSIGNED\n+      /* As we do not know which address space the pointer is refering to,\n+\t we can do this only if the target does not support different pointer\n+\t or address modes depending on the address space.  */\n+      if (target_default_pointer_address_modes_p ()\n+\t  && ! POINTERS_EXTEND_UNSIGNED\n \t  && mode == Pmode && GET_MODE (op) == ptr_mode\n \t  && (CONSTANT_P (op)\n \t      || (GET_CODE (op) == SUBREG\n@@ -1034,7 +1038,11 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \treturn rtl_hooks.gen_lowpart_no_emit (mode, op);\n \n #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n-      if (POINTERS_EXTEND_UNSIGNED > 0\n+      /* As we do not know which address space the pointer is refering to,\n+\t we can do this only if the target does not support different pointer\n+\t or address modes depending on the address space.  */\n+      if (target_default_pointer_address_modes_p ()\n+\t  && POINTERS_EXTEND_UNSIGNED > 0\n \t  && mode == Pmode && GET_MODE (op) == ptr_mode\n \t  && (CONSTANT_P (op)\n \t      || (GET_CODE (op) == SUBREG"}, {"sha": "e512db83979362439cbd8366f5ada7e6f90cf09f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -52,9 +52,9 @@ unsigned int maximum_field_alignment = TARGET_DEFAULT_PACK_STRUCT * BITS_PER_UNI\n /* ... and its original value in bytes, specified via -fpack-struct=<value>.  */\n unsigned int initial_max_fld_align = TARGET_DEFAULT_PACK_STRUCT;\n \n-/* Nonzero if all REFERENCE_TYPEs are internal and hence should be\n-   allocated in Pmode, not ptr_mode.   Set only by internal_reference_types\n-   called only by a front end.  */\n+/* Nonzero if all REFERENCE_TYPEs are internal and hence should be allocated\n+   in the address spaces' address_mode, not pointer_mode.   Set only by\n+   internal_reference_types called only by a front end.  */\n static int reference_types_internal = 0;\n \n static tree self_referential_size (tree);\n@@ -71,8 +71,8 @@ extern void debug_rli (record_layout_info);\n \n static GTY(()) tree pending_sizes;\n \n-/* Show that REFERENCE_TYPES are internal and should be Pmode.  Called only\n-   by front end.  */\n+/* Show that REFERENCE_TYPES are internal and should use address_mode.\n+   Called only by front end.  */\n \n void\n internal_reference_types (void)\n@@ -1917,6 +1917,7 @@ layout_type (tree type)\n       /* A pointer might be MODE_PARTIAL_INT,\n \t but ptrdiff_t must be integral.  */\n       SET_TYPE_MODE (type, mode_for_size (POINTER_SIZE, MODE_INT, 0));\n+      TYPE_PRECISION (type) = POINTER_SIZE;\n       break;\n \n     case FUNCTION_TYPE:\n@@ -1932,16 +1933,17 @@ layout_type (tree type)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n-\tenum machine_mode mode = ((TREE_CODE (type) == REFERENCE_TYPE\n-\t\t\t\t   && reference_types_internal)\n-\t\t\t\t  ? Pmode : TYPE_MODE (type));\n-\n-\tint nbits = GET_MODE_BITSIZE (mode);\n+\tenum machine_mode mode = TYPE_MODE (type);\n+\tif (TREE_CODE (type) == REFERENCE_TYPE && reference_types_internal)\n+\t  {\n+\t    addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));\n+\t    mode = targetm.addr_space.address_mode (as);\n+\t  }\n \n-\tTYPE_SIZE (type) = bitsize_int (nbits);\n+\tTYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));\n \tTYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));\n \tTYPE_UNSIGNED (type) = 1;\n-\tTYPE_PRECISION (type) = nbits;\n+\tTYPE_PRECISION (type) = GET_MODE_BITSIZE (mode);\n       }\n       break;\n "}, {"sha": "547a5fb89f8a2e24a3fe8644c4114a237dff9658", "filename": "gcc/target-def.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -471,6 +471,19 @@\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n \n+#ifndef TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE default_addr_space_pointer_mode\n+#endif\n+\n+#ifndef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE default_addr_space_address_mode\n+#endif\n+\n+#ifndef TARGET_ADDR_SPACE_VALID_POINTER_MODE\n+#define TARGET_ADDR_SPACE_VALID_POINTER_MODE \\\n+\tdefault_addr_space_valid_pointer_mode\n+#endif\n+\n #ifndef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n #define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n   default_addr_space_legitimate_address_p\n@@ -491,6 +504,9 @@\n \n #define TARGET_ADDR_SPACE_HOOKS\t\t\t\\\n   {\t\t\t\t\t\t\\\n+    TARGET_ADDR_SPACE_POINTER_MODE,\t\t\\\n+    TARGET_ADDR_SPACE_ADDRESS_MODE,\t\t\\\n+    TARGET_ADDR_SPACE_VALID_POINTER_MODE,\t\\\n     TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P,\t\\\n     TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS,\t\\\n     TARGET_ADDR_SPACE_SUBSET_P,\t\t\t\\"}, {"sha": "a243bcd3bfbd248ebfd774305201b7a5bf9f6573", "filename": "gcc/target.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -68,6 +68,12 @@ typedef int (* print_switch_fn_type) (print_switch_type, const char *);\n /* An example implementation for ELF targets.  Defined in varasm.c  */\n extern int elf_record_gcc_switches (print_switch_type type, const char *);\n \n+/* Some places still assume that all pointer or address modes are the\n+   standard Pmode and ptr_mode.  These optimizations become invalid if\n+   the target actually supports multiple different modes.  For now,\n+   we disable such optimizations on such targets, using this function.  */\n+extern bool target_default_pointer_address_modes_p (void);\n+\n struct stdarg_info;\n struct spec_info_def;\n \n@@ -696,6 +702,16 @@ struct gcc_target\n \n   /* Support for named address spaces.  */\n   struct addr_space {\n+    /* MODE to use for a pointer into another address space.  */\n+    enum machine_mode (* pointer_mode) (addr_space_t);\n+\n+    /* MODE to use for an address in another address space.  */\n+    enum machine_mode (* address_mode) (addr_space_t);\n+\n+    /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\")))\n+       in another address space.  */\n+    bool (* valid_pointer_mode) (enum machine_mode, addr_space_t);\n+\n     /* True if an address is a valid memory address to a given named address\n        space for a given mode.  */\n     bool (* legitimate_address_p) (enum machine_mode, rtx, bool, addr_space_t);"}, {"sha": "35ed9eed4a6feed96592faecdb58b80e870420bb", "filename": "gcc/targhooks.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -831,6 +831,62 @@ default_builtin_support_vector_misalignment (enum machine_mode mode,\n   return false;\n }\n \n+/* Determine whether or not a pointer mode is valid. Assume defaults\n+   of ptr_mode or Pmode - can be overridden.  */\n+bool\n+default_valid_pointer_mode (enum machine_mode mode)\n+{\n+  return (mode == ptr_mode || mode == Pmode);\n+}\n+\n+/* Return the mode for a pointer to a given ADDRSPACE, defaulting to ptr_mode\n+   for the generic address space only.  */\n+\n+enum machine_mode\n+default_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (ADDR_SPACE_GENERIC_P (addrspace));\n+  return ptr_mode;\n+}\n+\n+/* Return the mode for an address in a given ADDRSPACE, defaulting to Pmode\n+   for the generic address space only.  */\n+\n+enum machine_mode\n+default_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (ADDR_SPACE_GENERIC_P (addrspace));\n+  return Pmode;\n+}\n+\n+/* Named address space version of valid_pointer_mode.  */\n+\n+bool\n+default_addr_space_valid_pointer_mode (enum machine_mode mode, addr_space_t as)\n+{\n+  if (!ADDR_SPACE_GENERIC_P (as))\n+    return (mode == targetm.addr_space.pointer_mode (as)\n+\t    || mode == targetm.addr_space.address_mode (as));\n+\n+  return targetm.valid_pointer_mode (mode);\n+}\n+\n+/* Some places still assume that all pointer or address modes are the\n+   standard Pmode and ptr_mode.  These optimizations become invalid if\n+   the target actually supports multiple different modes.  For now,\n+   we disable such optimizations on such targets, using this function.  */\n+\n+bool\n+target_default_pointer_address_modes_p (void)\n+{\n+  if (targetm.addr_space.address_mode != default_addr_space_address_mode)\n+    return false;\n+  if (targetm.addr_space.pointer_mode != default_addr_space_pointer_mode)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Named address space version of legitimate_address_p.  */\n \n bool"}, {"sha": "cbbbee89d2ef9f3cde26676865771284318bdb69", "filename": "gcc/targhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -119,6 +119,11 @@ extern bool default_hard_regno_scratch_ok (unsigned int);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n+extern bool default_valid_pointer_mode (enum machine_mode);\n+extern enum machine_mode default_addr_space_pointer_mode (addr_space_t);\n+extern enum machine_mode default_addr_space_address_mode (addr_space_t);\n+extern bool default_addr_space_valid_pointer_mode (enum machine_mode,\n+\t\t\t\t\t\t   addr_space_t);\n extern bool default_addr_space_legitimate_address_p (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool, addr_space_t);\n extern rtx default_addr_space_legitimize_address (rtx, rtx, enum machine_mode,"}, {"sha": "a70156918118081886e0697211f33c332322f52f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -922,7 +922,7 @@ struct mem_address\n struct affine_tree_combination;\n tree create_mem_ref (gimple_stmt_iterator *, tree, \n \t\t     struct affine_tree_combination *, bool);\n-rtx addr_for_mem_ref (struct mem_address *, bool);\n+rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);\n "}, {"sha": "1428803272f309c1f61dfb154bea8c1ea34a352f", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"ggc.h\"\n #include \"tree-affine.h\"\n+#include \"target.h\"\n \n /* TODO -- handling of symbols (according to Richard Hendersons\n    comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):\n@@ -70,32 +71,38 @@ along with GCC; see the file COPYING3.  If not see\n /* A \"template\" for memory address, used to determine whether the address is\n    valid for mode.  */\n \n-struct GTY (()) mem_addr_template {\n+typedef struct GTY (()) mem_addr_template {\n   rtx ref;\t\t\t/* The template.  */\n   rtx * GTY ((skip)) step_p;\t/* The point in template where the step should be\n \t\t\t\t   filled in.  */\n   rtx * GTY ((skip)) off_p;\t/* The point in template where the offset should\n \t\t\t\t   be filled in.  */\n-};\n+} mem_addr_template;\n \n-/* The templates.  Each of the five bits of the index corresponds to one\n-   component of TARGET_MEM_REF being present, see TEMPL_IDX.  */\n+DEF_VEC_O (mem_addr_template);\n+DEF_VEC_ALLOC_O (mem_addr_template, gc);\n \n-static GTY (()) struct mem_addr_template templates[32];\n+/* The templates.  Each of the low five bits of the index corresponds to one\n+   component of TARGET_MEM_REF being present, while the high bits identify\n+   the address space.  See TEMPL_IDX.  */\n \n-#define TEMPL_IDX(SYMBOL, BASE, INDEX, STEP, OFFSET) \\\n-  (((SYMBOL != 0) << 4) \\\n+static GTY(()) VEC (mem_addr_template, gc) *mem_addr_template_list;\n+\n+#define TEMPL_IDX(AS, SYMBOL, BASE, INDEX, STEP, OFFSET) \\\n+  (((int) (AS) << 5) \\\n+   | ((SYMBOL != 0) << 4) \\\n    | ((BASE != 0) << 3) \\\n    | ((INDEX != 0) << 2) \\\n    | ((STEP != 0) << 1) \\\n    | (OFFSET != 0))\n \n /* Stores address for memory reference with parameters SYMBOL, BASE, INDEX,\n-   STEP and OFFSET to *ADDR.  Stores pointers to where step is placed to\n-   *STEP_P and offset to *OFFSET_P.  */\n+   STEP and OFFSET to *ADDR using address mode ADDRESS_MODE.  Stores pointers\n+   to where step is placed to *STEP_P and offset to *OFFSET_P.  */\n \n static void\n-gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n+gen_addr_rtx (enum machine_mode address_mode,\n+\t      rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n \t      rtx *addr, rtx **step_p, rtx **offset_p)\n {\n   rtx act_elem;\n@@ -111,7 +118,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n       act_elem = index;\n       if (step)\n \t{\n-\t  act_elem = gen_rtx_MULT (Pmode, act_elem, step);\n+\t  act_elem = gen_rtx_MULT (address_mode, act_elem, step);\n \n \t  if (step_p)\n \t    *step_p = &XEXP (act_elem, 1);\n@@ -123,7 +130,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n   if (base)\n     {\n       if (*addr)\n-\t*addr = simplify_gen_binary (PLUS, Pmode, base, *addr);\n+\t*addr = simplify_gen_binary (PLUS, address_mode, base, *addr);\n       else\n \t*addr = base;\n     }\n@@ -133,27 +140,27 @@ gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n       act_elem = symbol;\n       if (offset)\n \t{\n-\t  act_elem = gen_rtx_PLUS (Pmode, act_elem, offset);\n+\t  act_elem = gen_rtx_PLUS (address_mode, act_elem, offset);\n \n \t  if (offset_p)\n \t    *offset_p = &XEXP (act_elem, 1);\n \n \t  if (GET_CODE (symbol) == SYMBOL_REF\n \t      || GET_CODE (symbol) == LABEL_REF\n \t      || GET_CODE (symbol) == CONST)\n-\t    act_elem = gen_rtx_CONST (Pmode, act_elem);\n+\t    act_elem = gen_rtx_CONST (address_mode, act_elem);\n \t}\n \n       if (*addr)\n-\t*addr = gen_rtx_PLUS (Pmode, *addr, act_elem);\n+\t*addr = gen_rtx_PLUS (address_mode, *addr, act_elem);\n       else\n \t*addr = act_elem;\n     }\n   else if (offset)\n     {\n       if (*addr)\n \t{\n-\t  *addr = gen_rtx_PLUS (Pmode, *addr, offset);\n+\t  *addr = gen_rtx_PLUS (address_mode, *addr, offset);\n \t  if (offset_p)\n \t    *offset_p = &XEXP (*addr, 1);\n \t}\n@@ -169,55 +176,64 @@ gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,\n     *addr = const0_rtx;\n }\n \n-/* Returns address for TARGET_MEM_REF with parameters given by ADDR.\n+/* Returns address for TARGET_MEM_REF with parameters given by ADDR\n+   in address space AS.\n    If REALLY_EXPAND is false, just make fake registers instead \n    of really expanding the operands, and perform the expansion in-place\n    by using one of the \"templates\".  */\n \n rtx\n-addr_for_mem_ref (struct mem_address *addr, bool really_expand)\n+addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n+\t\t  bool really_expand)\n {\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n   rtx address, sym, bse, idx, st, off;\n-  static bool templates_initialized = false;\n   struct mem_addr_template *templ;\n \n   if (addr->step && !integer_onep (addr->step))\n     st = immed_double_const (TREE_INT_CST_LOW (addr->step),\n-\t\t\t     TREE_INT_CST_HIGH (addr->step), Pmode);\n+\t\t\t     TREE_INT_CST_HIGH (addr->step), address_mode);\n   else\n     st = NULL_RTX;\n \n   if (addr->offset && !integer_zerop (addr->offset))\n     off = immed_double_const (TREE_INT_CST_LOW (addr->offset),\n-\t\t\t      TREE_INT_CST_HIGH (addr->offset), Pmode);\n+\t\t\t      TREE_INT_CST_HIGH (addr->offset), address_mode);\n   else\n     off = NULL_RTX;\n \n   if (!really_expand)\n     {\n+      unsigned int templ_index\n+\t= TEMPL_IDX (as, addr->symbol, addr->base, addr->index, st, off);\n+\n+      if (templ_index\n+\t  >= VEC_length (mem_addr_template, mem_addr_template_list))\n+\tVEC_safe_grow_cleared (mem_addr_template, gc, mem_addr_template_list,\n+\t\t\t       templ_index + 1);\n+\n       /* Reuse the templates for addresses, so that we do not waste memory.  */\n-      if (!templates_initialized)\n+      templ = VEC_index (mem_addr_template, mem_addr_template_list, templ_index);\n+      if (!templ->ref)\n \t{\n-\t  unsigned i;\n-\n-\t  templates_initialized = true;\n-\t  sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"test_symbol\"));\n-\t  bse = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n-\t  idx = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);\n-\n-\t  for (i = 0; i < 32; i++)\n-\t    gen_addr_rtx ((i & 16 ? sym : NULL_RTX),\n-\t\t\t  (i & 8 ? bse : NULL_RTX),\n-\t\t\t  (i & 4 ? idx : NULL_RTX),\n-\t\t\t  (i & 2 ? const0_rtx : NULL_RTX),\n-\t\t\t  (i & 1 ? const0_rtx : NULL_RTX),\n-\t\t\t  &templates[i].ref,\n-\t\t\t  &templates[i].step_p,\n-\t\t\t  &templates[i].off_p);\n+\t  sym = (addr->symbol ?\n+\t\t gen_rtx_SYMBOL_REF (address_mode, ggc_strdup (\"test_symbol\"))\n+\t\t : NULL_RTX);\n+\t  bse = (addr->base ?\n+\t\t gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1)\n+\t\t : NULL_RTX);\n+\t  idx = (addr->index ?\n+\t\t gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2)\n+\t\t : NULL_RTX);\n+\n+\t  gen_addr_rtx (address_mode, sym, bse, idx,\n+\t\t\tst? const0_rtx : NULL_RTX,\n+\t\t\toff? const0_rtx : NULL_RTX,\n+\t\t\t&templ->ref,\n+\t\t\t&templ->step_p,\n+\t\t\t&templ->off_p);\n \t}\n \n-      templ = templates + TEMPL_IDX (addr->symbol, addr->base, addr->index,\n-\t\t\t\t     st, off);\n       if (st)\n \t*templ->step_p = st;\n       if (off)\n@@ -229,16 +245,16 @@ addr_for_mem_ref (struct mem_address *addr, bool really_expand)\n   /* Otherwise really expand the expressions.  */\n   sym = (addr->symbol\n \t ? expand_expr (build_addr (addr->symbol, current_function_decl),\n-\t\t\tNULL_RTX, Pmode, EXPAND_NORMAL)\n+\t\t\tNULL_RTX, address_mode, EXPAND_NORMAL)\n \t : NULL_RTX);\n   bse = (addr->base\n-\t ? expand_expr (addr->base, NULL_RTX, Pmode, EXPAND_NORMAL)\n+\t ? expand_expr (addr->base, NULL_RTX, address_mode, EXPAND_NORMAL)\n \t : NULL_RTX);\n   idx = (addr->index\n-\t ? expand_expr (addr->index, NULL_RTX, Pmode, EXPAND_NORMAL)\n+\t ? expand_expr (addr->index, NULL_RTX, address_mode, EXPAND_NORMAL)\n \t : NULL_RTX);\n \n-  gen_addr_rtx (sym, bse, idx, st, off, &address, NULL, NULL);\n+  gen_addr_rtx (address_mode, sym, bse, idx, st, off, &address, NULL, NULL);\n   return address;\n }\n \n@@ -310,7 +326,7 @@ valid_mem_ref_p (enum machine_mode mode, addr_space_t as,\n {\n   rtx address;\n \n-  address = addr_for_mem_ref (addr, false);\n+  address = addr_for_mem_ref (addr, as, false);\n   if (!address)\n     return false;\n "}, {"sha": "82e45d2db4d30762fe749c8a9ea6ce05ee3c8d02", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -2643,21 +2643,22 @@ static rtx\n produce_memory_decl_rtl (tree obj, int *regno)\n {\n   addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (obj));\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n   rtx x;\n   \n   gcc_assert (obj);\n   if (TREE_STATIC (obj) || DECL_EXTERNAL (obj))\n     {\n       const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (obj));\n-      x = gen_rtx_SYMBOL_REF (Pmode, name);\n+      x = gen_rtx_SYMBOL_REF (address_mode, name);\n       SET_SYMBOL_REF_DECL (x, obj);\n       x = gen_rtx_MEM (DECL_MODE (obj), x);\n       set_mem_addr_space (x, as);\n       targetm.encode_section_info (obj, x, true);\n     }\n   else\n     {\n-      x = gen_raw_REG (Pmode, (*regno)++);\n+      x = gen_raw_REG (address_mode, (*regno)++);\n       x = gen_rtx_MEM (DECL_MODE (obj), x);\n       set_mem_addr_space (x, as);\n     }\n@@ -3045,16 +3046,17 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n   valid_mult = VEC_index (sbitmap, valid_mult_list, data_index);\n   if (!valid_mult)\n     {\n-      rtx reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n+      enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n+      rtx reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n       rtx addr;\n       HOST_WIDE_INT i;\n \n       valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n       sbitmap_zero (valid_mult);\n-      addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);\n+      addr = gen_rtx_fmt_ee (MULT, address_mode, reg1, NULL_RTX);\n       for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n \t{\n-\t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n+\t  XEXP (addr, 1) = gen_int_mode (i, address_mode);\n \t  if (memory_address_addr_space_p (mode, addr, as))\n \t    SET_BIT (valid_mult, i + MAX_RATIO);\n \t}\n@@ -3108,6 +3110,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t\t  addr_space_t as, bool speed,\n \t\t  bool stmt_after_inc, bool *may_autoinc)\n {\n+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);\n   static VEC(address_cost_data, heap) *address_cost_data_list;\n   unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mem_mode;\n   address_cost_data data;\n@@ -3136,12 +3139,12 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       data = (address_cost_data) xcalloc (1, sizeof (*data));\n \n-      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n+      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n \n-      addr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, NULL_RTX);\n+      addr = gen_rtx_fmt_ee (PLUS, address_mode, reg1, NULL_RTX);\n       for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n-\t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n+\t  XEXP (addr, 1) = gen_int_mode (i, address_mode);\n \t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n \t}\n@@ -3150,7 +3153,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       for (i = start; i <= 1 << 20; i <<= 1)\n \t{\n-\t  XEXP (addr, 1) = gen_int_mode (-i, Pmode);\n+\t  XEXP (addr, 1) = gen_int_mode (-i, address_mode);\n \t  if (!memory_address_addr_space_p (mem_mode, addr, as))\n \t    break;\n \t}\n@@ -3177,30 +3180,30 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       /* Compute the cost of various addressing modes.  */\n       acost = 0;\n-      reg0 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n-      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);\n+      reg0 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n+      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2);\n \n       if (HAVE_PRE_DECREMENT)\n \t{\n-\t  addr = gen_rtx_PRE_DEC (Pmode, reg0);\n+\t  addr = gen_rtx_PRE_DEC (address_mode, reg0);\n \t  has_predec[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_POST_DECREMENT)\n \t{\n-\t  addr = gen_rtx_POST_DEC (Pmode, reg0);\n+\t  addr = gen_rtx_POST_DEC (address_mode, reg0);\n \t  has_postdec[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_PRE_INCREMENT)\n \t{\n-\t  addr = gen_rtx_PRE_INC (Pmode, reg0);\n+\t  addr = gen_rtx_PRE_INC (address_mode, reg0);\n \t  has_preinc[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n       if (HAVE_POST_INCREMENT)\n \t{\n-\t  addr = gen_rtx_POST_INC (Pmode, reg0);\n+\t  addr = gen_rtx_POST_INC (address_mode, reg0);\n \t  has_postinc[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n \t}\n@@ -3213,34 +3216,34 @@ get_address_cost (bool symbol_present, bool var_present,\n \n \t  addr = reg0;\n \t  if (rat_p)\n-\t    addr = gen_rtx_fmt_ee (MULT, Pmode, addr,\n-\t\t\t\t   gen_int_mode (rat, Pmode));\n+\t    addr = gen_rtx_fmt_ee (MULT, address_mode, addr,\n+\t\t\t\t   gen_int_mode (rat, address_mode));\n \n \t  if (var_p)\n-\t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n+\t    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, reg1);\n \n \t  if (sym_p)\n \t    {\n-\t      base = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"\"));\n+\t      base = gen_rtx_SYMBOL_REF (address_mode, ggc_strdup (\"\"));\n \t      /* ??? We can run into trouble with some backends by presenting\n \t\t it with symbols which haven't been properly passed through\n \t\t targetm.encode_section_info.  By setting the local bit, we\n \t\t enhance the probability of things working.  */\n \t      SYMBOL_REF_FLAGS (base) = SYMBOL_FLAG_LOCAL;\n \n \t      if (off_p)\n-\t\tbase = gen_rtx_fmt_e (CONST, Pmode,\n+\t\tbase = gen_rtx_fmt_e (CONST, address_mode,\n \t\t\t\t      gen_rtx_fmt_ee\n-\t\t\t\t\t(PLUS, Pmode, base,\n-\t\t\t\t\t gen_int_mode (off, Pmode)));\n+\t\t\t\t\t(PLUS, address_mode, base,\n+\t\t\t\t\t gen_int_mode (off, address_mode)));\n \t    }\n \t  else if (off_p)\n-\t    base = gen_int_mode (off, Pmode);\n+\t    base = gen_int_mode (off, address_mode);\n \t  else\n \t    base = NULL_RTX;\n     \n \t  if (base)\n-\t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);\n+\t    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, base);\n \n \t  start_sequence ();\n \t  /* To avoid splitting addressing modes, pretend that no cse will\n@@ -3272,7 +3275,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n \t if this is the case, use it.  */\n-      add_c = add_cost (Pmode, speed);\n+      add_c = add_cost (address_mode, speed);\n       for (i = 0; i < 8; i++)\n \t{\n \t  var_p = i & 1;\n@@ -3321,7 +3324,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t\t   data_index, data);\n     }\n \n-  bits = GET_MODE_BITSIZE (Pmode);\n+  bits = GET_MODE_BITSIZE (address_mode);\n   mask = ~(~(unsigned HOST_WIDE_INT) 0 << (bits - 1) << 1);\n   offset &= mask;\n   if ((offset >> (bits - 1) & 1))\n@@ -3353,10 +3356,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     && multiplier_allowed_in_address_p (ratio, mem_mode, as));\n \n   if (ratio != 1 && !ratio_p)\n-    cost += multiply_by_cost (ratio, Pmode, speed);\n+    cost += multiply_by_cost (ratio, address_mode, speed);\n \n   if (s_offset && !offset_p && !symbol_present)\n-    cost += add_cost (Pmode, speed);\n+    cost += add_cost (address_mode, speed);\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;"}, {"sha": "ea3a508966f82abdba1d37da59d2b26174c8e912", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -2376,7 +2376,9 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n   if (!alias_sets_conflict_p (get_deref_alias_set (vect_ptr),\n \t\t\t      get_alias_set (DR_REF (dr))))\n     {\n-      vect_ptr_type = build_pointer_type_for_mode (vectype, ptr_mode, true);\n+      vect_ptr_type\n+\t= build_pointer_type_for_mode (vectype,\n+\t\t\t\t       TYPE_MODE (vect_ptr_type), true);\n       vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n \t\t\t\t\tget_name (base_name));\n     }\n@@ -2392,7 +2394,8 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\t\t\t      get_alias_set (lhs)))\n \t    {\n \t      vect_ptr_type\n-\t\t= build_pointer_type_for_mode (vectype, ptr_mode, true);\n+\t\t= build_pointer_type_for_mode (vectype,\n+\t\t\t\t\t       TYPE_MODE (vect_ptr_type), true);\n \t      vect_ptr\n \t\t= vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n \t\t\t\t\t get_name (base_name));"}, {"sha": "43434150231c17143ae11f3942c62d2e25b57ef9", "filename": "gcc/tree.c", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1684,8 +1684,7 @@ integer_pow2p (const_tree expr)\n   if (TREE_CODE (expr) != INTEGER_CST)\n     return 0;\n \n-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n-\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n+  prec = int_or_pointer_precision (TREE_TYPE (expr));\n   high = TREE_INT_CST_HIGH (expr);\n   low = TREE_INT_CST_LOW (expr);\n \n@@ -1749,9 +1748,7 @@ tree_log2 (const_tree expr)\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return tree_log2 (TREE_REALPART (expr));\n \n-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n-\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n-\n+  prec = int_or_pointer_precision (TREE_TYPE (expr));\n   high = TREE_INT_CST_HIGH (expr);\n   low = TREE_INT_CST_LOW (expr);\n \n@@ -1787,9 +1784,7 @@ tree_floor_log2 (const_tree expr)\n   if (TREE_CODE (expr) == COMPLEX_CST)\n     return tree_log2 (TREE_REALPART (expr));\n \n-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n-\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n-\n+  prec = int_or_pointer_precision (TREE_TYPE (expr));\n   high = TREE_INT_CST_HIGH (expr);\n   low = TREE_INT_CST_LOW (expr);\n \n@@ -6746,7 +6741,10 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n tree\n build_pointer_type (tree to_type)\n {\n-  return build_pointer_type_for_mode (to_type, ptr_mode, false);\n+  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC\n+\t\t\t\t\t      : TYPE_ADDR_SPACE (to_type);\n+  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n+  return build_pointer_type_for_mode (to_type, pointer_mode, false);\n }\n \n /* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */\n@@ -6810,7 +6808,10 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n tree\n build_reference_type (tree to_type)\n {\n-  return build_reference_type_for_mode (to_type, ptr_mode, false);\n+  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC\n+\t\t\t\t\t      : TYPE_ADDR_SPACE (to_type);\n+  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n+  return build_reference_type_for_mode (to_type, pointer_mode, false);\n }\n \n /* Build a type that is compatible with t but has no cv quals anywhere\n@@ -9675,7 +9676,19 @@ signed_or_unsigned_type_for (int unsignedp, tree type)\n {\n   tree t = type;\n   if (POINTER_TYPE_P (type))\n-    t = size_type_node;\n+    {\n+      /* If the pointer points to the normal address space, use the\n+\t size_type_node.  Otherwise use an appropriate size for the pointer\n+\t based on the named address space it points to.  */\n+      if (!TYPE_ADDR_SPACE (TREE_TYPE (t)))\n+\tt = size_type_node;\n+\n+      else\n+\t{\n+\t  int prec = int_or_pointer_precision (t);\n+\t  return lang_hooks.types.type_for_size (prec, unsignedp);\n+\t}\n+    }\n \n   if (!INTEGRAL_TYPE_P (t) || TYPE_UNSIGNED (t) == unsignedp)\n     return t;\n@@ -10549,6 +10562,41 @@ build_target_option_node (void)\n   return t;\n }\n \n+/* Return the size in bits of an integer or pointer type.  TYPE_PRECISION\n+   contains the bits, but in the past it was not set in some cases and there\n+   was special purpose code that checked for POINTER_TYPE_P or OFFSET_TYPE, so\n+   check that it is consitant when assertion checking is used.  */\n+\n+unsigned int\n+int_or_pointer_precision (const_tree type)\n+{\n+#if ENABLE_ASSERT_CHECKING\n+  unsigned int prec;\n+\n+  if (POINTER_TYPE_P (type))\n+    {\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));\n+      prec = GET_MODE_BITSIZE (targetm.addr_space.pointer_mode (as));\n+      gcc_assert (prec == TYPE_PRECISION (type));\n+    }\n+  else if (TREE_CODE (type) == OFFSET_TYPE)\n+    {\n+      prec = POINTER_SIZE;\n+      gcc_assert (prec == TYPE_PRECISION (type));\n+    }\n+  else\n+    {\n+      prec = TYPE_PRECISION (type);\n+      gcc_assert (prec != 0);\n+    }\n+\n+  return prec;\n+\n+#else\n+  return TYPE_PRECISION (type);\n+#endif\n+}\n+\n /* Determine the \"ultimate origin\" of a block.  The block may be an inlined\n    instance of an inlined instance of a block which is local to an inline\n    function, so we have to trace all of the way back through the origin chain"}, {"sha": "36deb0d51e58a0cc84fad8dc7baf7b5f65df7f3a", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -4703,6 +4703,7 @@ extern const char *get_name (tree);\n extern bool stdarg_p (tree);\n extern bool prototype_p (tree);\n extern bool auto_var_in_fn_p (const_tree, const_tree);\n+extern unsigned int int_or_pointer_precision (const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n extern tree tree_strip_nop_conversions (tree);\n extern tree tree_strip_sign_nop_conversions (tree);"}, {"sha": "9fa1921918616bcc75f5428580e27a83b62e56eb", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -4359,7 +4359,9 @@ replace_expr_with_values (rtx loc)\n     return NULL;\n   else if (MEM_P (loc))\n     {\n-      cselib_val *addr = cselib_lookup (XEXP (loc, 0), Pmode, 0);\n+      enum machine_mode address_mode\n+\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (loc));\n+      cselib_val *addr = cselib_lookup (XEXP (loc, 0), address_mode, 0);\n       if (addr)\n \treturn replace_equiv_address_nv (loc, addr->val_rtx);\n       else\n@@ -4493,7 +4495,9 @@ count_uses (rtx *loc, void *cuip)\n \t  if (MEM_P (*loc)\n \t      && !REG_P (XEXP (*loc, 0)) && !MEM_P (XEXP (*loc, 0)))\n \t    {\n-\t      val = cselib_lookup (XEXP (*loc, 0), Pmode, false);\n+\t      enum machine_mode address_mode\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (*loc));\n+\t      val = cselib_lookup (XEXP (*loc, 0), address_mode, false);\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n@@ -4613,7 +4617,10 @@ add_uses (rtx *loc, void *data)\n \t      && !REG_P (XEXP (vloc, 0)) && !MEM_P (XEXP (vloc, 0)))\n \t    {\n \t      rtx mloc = vloc;\n-\t      cselib_val *val = cselib_lookup (XEXP (mloc, 0), Pmode, 0);\n+\t      enum machine_mode address_mode\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n+\t      cselib_val *val\n+\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n@@ -4624,7 +4631,8 @@ add_uses (rtx *loc, void *data)\n \t\t  cselib_preserve_value (val);\n \t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t\t  mo->u.loc = gen_rtx_CONCAT (Pmode, val->val_rtx, mloc);\n+\t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n+\t\t\t\t\t      val->val_rtx, mloc);\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    log_op_type (mo->u.loc, cui->bb, cui->insn,\n \t\t\t\t mo->type, dump_file);\n@@ -4680,7 +4688,10 @@ add_uses (rtx *loc, void *data)\n \t      && !REG_P (XEXP (oloc, 0)) && !MEM_P (XEXP (oloc, 0)))\n \t    {\n \t      rtx mloc = oloc;\n-\t      cselib_val *val = cselib_lookup (XEXP (mloc, 0), Pmode, 0);\n+\t      enum machine_mode address_mode\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n+\t      cselib_val *val\n+\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n@@ -4691,7 +4702,8 @@ add_uses (rtx *loc, void *data)\n \t\t  cselib_preserve_value (val);\n \t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t\t  mo->u.loc = gen_rtx_CONCAT (Pmode, val->val_rtx, mloc);\n+\t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n+\t\t\t\t\t      val->val_rtx, mloc);\n \t\t  mo->insn = cui->insn;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    log_op_type (mo->u.loc, cui->bb, cui->insn,\n@@ -4824,14 +4836,16 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t  && !REG_P (XEXP (loc, 0)) && !MEM_P (XEXP (loc, 0)))\n \t{\n \t  rtx mloc = loc;\n-\t  cselib_val *val = cselib_lookup (XEXP (mloc, 0), Pmode, 0);\n+\t  enum machine_mode address_mode\n+\t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mloc));\n+\t  cselib_val *val = cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n \n \t  if (val && !cselib_preserved_value_p (val))\n \t    {\n \t      cselib_preserve_value (val);\n \t      mo->type = MO_VAL_USE;\n \t      mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t      mo->u.loc = gen_rtx_CONCAT (Pmode, val->val_rtx, mloc);\n+\t      mo->u.loc = gen_rtx_CONCAT (address_mode, val->val_rtx, mloc);\n \t      mo->insn = cui->insn;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tlog_op_type (mo->u.loc, cui->bb, cui->insn,"}, {"sha": "b6ff4ae149dd0311326c5a94f23ceeb2cbce6206", "filename": "gcc/varasm.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ebfa65c962f1f0b50223e34184dc5a81d907c6/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "patch": "@@ -1447,7 +1447,15 @@ make_decl_rtl (tree decl)\n   if (use_object_blocks_p () && use_blocks_for_decl_p (decl))\n     x = create_block_symbol (name, get_block_for_decl (decl), -1);\n   else\n-    x = gen_rtx_SYMBOL_REF (Pmode, name);\n+    {\n+      enum machine_mode address_mode = Pmode;\n+      if (TREE_TYPE (decl) != error_mark_node)\n+\t{\n+\t  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n+\t  address_mode = targetm.addr_space.address_mode (as);\n+\t}\n+      x = gen_rtx_SYMBOL_REF (address_mode, name);\n+    }\n   SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);\n   SET_SYMBOL_REF_DECL (x, decl);\n \n@@ -4315,7 +4323,8 @@ initializer_constant_valid_p (tree value, tree endtype)\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (! INTEGRAL_TYPE_P (endtype)\n-\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+\t  || TYPE_PRECISION (endtype)\n+\t     >= int_or_pointer_precision (TREE_TYPE (value)))\n \t{\n \t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n \t\t\t\t\t\t      endtype);\n@@ -4337,7 +4346,8 @@ initializer_constant_valid_p (tree value, tree endtype)\n \n     case MINUS_EXPR:\n       if (! INTEGRAL_TYPE_P (endtype)\n-\t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)\n+\t  || TYPE_PRECISION (endtype)\n+\t     >= int_or_pointer_precision (TREE_TYPE (value)))\n \t{\n \t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n \t\t\t\t\t\t      endtype);\n@@ -4458,15 +4468,19 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n      resolving it.  */\n   if (TREE_CODE (exp) == NOP_EXPR\n       && POINTER_TYPE_P (TREE_TYPE (exp))\n-      && targetm.valid_pointer_mode (TYPE_MODE (TREE_TYPE (exp))))\n+      && targetm.addr_space.valid_pointer_mode\n+\t   (TYPE_MODE (TREE_TYPE (exp)),\n+\t    TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))\n     {\n       tree saved_type = TREE_TYPE (exp);\n \n       /* Peel off any intermediate conversions-to-pointer for valid\n \t pointer modes.  */\n       while (TREE_CODE (exp) == NOP_EXPR\n \t     && POINTER_TYPE_P (TREE_TYPE (exp))\n-\t     && targetm.valid_pointer_mode (TYPE_MODE (TREE_TYPE (exp))))\n+\t     && targetm.addr_space.valid_pointer_mode\n+\t\t  (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t   TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))\n \texp = TREE_OPERAND (exp, 0);\n \n       /* If what we're left with is the address of something, we can\n@@ -6562,14 +6576,6 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n   return local_p;\n }\n \n-/* Determine whether or not a pointer mode is valid. Assume defaults\n-   of ptr_mode or Pmode - can be overridden.  */\n-bool\n-default_valid_pointer_mode (enum machine_mode mode)\n-{\n-  return (mode == ptr_mode || mode == Pmode);\n-}\n-\n /* Default function to output code that will globalize a label.  A\n    target must define GLOBAL_ASM_OP or provide its own function to\n    globalize a label.  */"}]}