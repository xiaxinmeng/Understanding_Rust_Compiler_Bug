{"sha": "ab09753510d568c1bbca882b0e9b599e1c36e599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwOTc1MzUxMGQ1NjhjMWJiY2E4ODJiMGU5YjU5OWUxYzM2ZTU5OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-11-23T15:19:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-11-23T15:19:36Z"}, "message": "pt.c (lookup_template_class): Simplify loop exit constructs.\n\ncp:\n\t* pt.c (lookup_template_class): Simplify loop exit constructs.\n\tCope when there is no partial instantiation of a template\n\ttemplate member.\ntestsuite:\n\t* g++.old-deja/g++.pt/instantiate9.C: New test.\n\nFrom-SVN: r37698", "tree": {"sha": "bc7f90c4051308ea11815a052b69c8fae03eea0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc7f90c4051308ea11815a052b69c8fae03eea0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab09753510d568c1bbca882b0e9b599e1c36e599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab09753510d568c1bbca882b0e9b599e1c36e599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab09753510d568c1bbca882b0e9b599e1c36e599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab09753510d568c1bbca882b0e9b599e1c36e599/comments", "author": null, "committer": null, "parents": [{"sha": "8d4af2d7a964c875fd51a271eec2ede50c88068d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4af2d7a964c875fd51a271eec2ede50c88068d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4af2d7a964c875fd51a271eec2ede50c88068d"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "ec50f9e11a8c97e9bd8a02017bb0adcd83a72093", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ab09753510d568c1bbca882b0e9b599e1c36e599", "patch": "@@ -1,3 +1,9 @@\n+2000-11-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* pt.c (lookup_template_class): Simplify loop exit constructs.\n+\tCope when there is no partial instantiation of a template\n+\ttemplate member.\n+\n Thu Nov 23 02:16:47 2000  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* Make-lang.in (g++spec.o, cxxmain.o): Depend on $(CONFIG_H)."}, {"sha": "bbc67009509156faac3a4f3a4d6ec4b83b81e6b9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ab09753510d568c1bbca882b0e9b599e1c36e599", "patch": "@@ -3700,9 +3700,7 @@ maybe_get_template_decl_from_type_decl (decl)\n    D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.\n    (Actually ARGLIST may be either a TREE_LIST or a TREE_VEC.  It will\n    be a TREE_LIST if called directly from the parser, and a TREE_VEC\n-   otherwise.)  Since ARGLIST is build on the temp_decl_obstack, we must\n-   copy it here to keep it from being reclaimed when the decl storage\n-   is reclaimed.\n+   otherwise.)\n \n    IN_DECL, if non-NULL, is the template declaration we are trying to\n    instantiate.  \n@@ -3925,23 +3923,16 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t\tfound = NULL_TREE;\n \t    }\n \t}\n-      \n-      if (!found)\n-\t{\n-\t  for (found = DECL_TEMPLATE_INSTANTIATIONS (template);\n-\t       found; found = TREE_CHAIN (found))\n-\t    if (comp_template_args (TREE_PURPOSE (found), arglist))\n-\t      break;\n-\n-\t  if (found)\n-\t    found = TREE_VALUE (found);\n-\t}\n-\n       if (found)\n-\treturn found;\n+        return found;\n+      \n+      for (found = DECL_TEMPLATE_INSTANTIATIONS (template);\n+\t   found; found = TREE_CHAIN (found))\n+\tif (comp_template_args (TREE_PURPOSE (found), arglist))\n+\t   return TREE_VALUE (found);\n \n       /* This type is a \"partial instantiation\" if any of the template\n-\t arguments still inolve template parameters.  Note that we set\n+\t arguments still involve template parameters.  Note that we set\n \t IS_PARTIAL_INSTANTIATION for partial specializations as\n \t well.  */\n       is_partial_instantiation = uses_template_parms (arglist);\n@@ -4016,9 +4007,8 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \tfound = template;\n       else\n \t{\n-\t  /* This is a full instantiation of a member template.  There\n-\t     should be some partial instantiation of which this is an\n-\t     instance.  */\n+\t  /* This is a full instantiation of a member template.  Look\n+\t     for a partial instantiation of which this is an instance.  */\n \n \t  for (found = DECL_TEMPLATE_INSTANTIATIONS (template);\n \t       found; found = TREE_CHAIN (found))\n@@ -4054,11 +4044,24 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t    }\n \n \t  if (!found)\n-\t    my_friendly_abort (0);\n+\t    {\n+\t      /* There was no partial instantiation. This happens\n+                 where C<T> is a member template of A<T> and it's used\n+                 in something like\n+                \n+                  template <typename T> struct B { A<T>::C<int> m; };\n+                  B<float>;\n+                \n+                 Create the partial instantiation.\n+               */\n+              TREE_VEC_LENGTH (arglist)--;\n+              template = tsubst (template, arglist, /*complain=*/0, NULL_TREE);\n+              TREE_VEC_LENGTH (arglist)++;\n+              found = template;\n+            }\n \t}\n \n-      SET_TYPE_TEMPLATE_INFO (t,\n-\t\t\t      tree_cons (found, arglist, NULL_TREE));  \n+      SET_TYPE_TEMPLATE_INFO (t, tree_cons (found, arglist, NULL_TREE));  \n       DECL_TEMPLATE_INSTANTIATIONS (template) \n \t= tree_cons (arglist, t, \n \t\t     DECL_TEMPLATE_INSTANTIATIONS (template));"}, {"sha": "b3220ffc5018d5c920ab8554abe1b27c59e09ad5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab09753510d568c1bbca882b0e9b599e1c36e599", "patch": "@@ -1,3 +1,7 @@\n+2000-11-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.pt/instantiate9.C: New test.\n+\n 2000-11-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.old-deja/g++.other/decl4.C: Tweak so that it fails with the"}, {"sha": "30ad03b46fc0d974a29cc34d662e24f91137c95f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/instantiate9.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab09753510d568c1bbca882b0e9b599e1c36e599/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate9.C?ref=ab09753510d568c1bbca882b0e9b599e1c36e599", "patch": "@@ -0,0 +1,25 @@\n+// Build don't link:\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Nov 2000 <nathan@codesourcery.com>\n+\n+// Bug 789. We ICE'd trying to instantiate B<float> because there was no\n+// existing partial specialization of C in A<float>.\n+\n+template <typename T>\n+struct A {\n+    template <typename D1>\n+    struct C { };\n+};\n+\n+template <typename T1>\n+struct B {\n+   A<T1>::C<int> s1;\n+};\n+\n+int main()\n+{\n+    B<float> b;\n+    \n+    return 0;\n+}"}]}