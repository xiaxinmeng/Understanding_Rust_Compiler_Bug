{"sha": "f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmMTI5NjE4YjdlN2RlZDQ2ZTFmODhmNjE1MzZmN2IxYjYwZmNmYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-04-23T21:31:16Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-04-23T21:31:16Z"}, "message": "tree-ssa-loop-ivopts.c (struct cost_pair): Add value field.\n\n\t* tree-ssa-loop-ivopts.c (struct cost_pair): Add value field.\n\t(find_interesting_uses_cond): Do not use integer_zerop and\n\tinteger_nonzerop to check for integer constants.\n\t(set_use_iv_cost): Record the value field.\n\t(determine_use_iv_cost_generic, determine_use_iv_cost_address,\n\tdetermine_use_iv_cost_outer): Set the value field of the cost pair.\n\t(may_eliminate_iv): Do not return the comparison code.\n\t(iv_elimination_compare): New function.\n\t(determine_use_iv_cost_condition): Set the value field.  Record\n\tnoneliminable invariants correctly.\n\t(rewrite_use_compare, rewrite_use_outer): Use the value field.\n\nFrom-SVN: r98634", "tree": {"sha": "dbfe75c1789fcde717a5009f418ee23185011c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbfe75c1789fcde717a5009f418ee23185011c69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc/comments", "author": null, "committer": null, "parents": [{"sha": "d4ee4d252515ac2d2bdb8ed085edc7feaf5b943d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ee4d252515ac2d2bdb8ed085edc7feaf5b943d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ee4d252515ac2d2bdb8ed085edc7feaf5b943d"}], "stats": {"total": 116, "additions": 79, "deletions": 37}, "files": [{"sha": "096c1d797666b699058c163df576f99090ed2974", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "patch": "@@ -1,3 +1,17 @@\n+2005-04-23  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (struct cost_pair): Add value field.\n+\t(find_interesting_uses_cond): Do not use integer_zerop and\n+\tinteger_nonzerop to check for integer constants.\n+\t(set_use_iv_cost): Record the value field.\n+\t(determine_use_iv_cost_generic, determine_use_iv_cost_address,\n+\tdetermine_use_iv_cost_outer): Set the value field of the cost pair.\n+\t(may_eliminate_iv): Do not return the comparison code.\n+\t(iv_elimination_compare): New function.\n+\t(determine_use_iv_cost_condition): Set the value field.  Record\n+\tnoneliminable invariants correctly.\n+\t(rewrite_use_compare, rewrite_use_outer): Use the value field.\n+\n 2005-04-23  DJ Delorie  <dj@redhat.com>\n \n \t* diagnostic.c (warning): Accept parameter to classify warning option."}, {"sha": "00965bcac24a002677a6d61693079ed981d2016e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f129618b7e7ded46e1f88f61536f7b1b60fcfc/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f5f129618b7e7ded46e1f88f61536f7b1b60fcfc", "patch": "@@ -143,6 +143,9 @@ struct cost_pair\n   unsigned cost;\t/* The cost.  */\n   bitmap depends_on;\t/* The list of invariants that have to be\n \t\t\t   preserved.  */\n+  tree value;\t\t/* For final value elimination, the expression for\n+\t\t\t   the final value of the iv.  For iv elimination,\n+\t\t\t   the new bound to compare with.  */\n };\n \n /* Use.  */\n@@ -1276,8 +1279,8 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n \n   const_iv.step = NULL_TREE;\n \n-  if (integer_zerop (*cond_p)\n-      || integer_nonzerop (*cond_p))\n+  if (TREE_CODE (*cond_p) != SSA_NAME\n+      && !COMPARISON_CLASS_P (*cond_p))\n     return;\n \n   if (TREE_CODE (*cond_p) == SSA_NAME)\n@@ -2270,12 +2273,13 @@ alloc_use_cost_map (struct ivopts_data *data)\n }\n \n /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n-   on invariants DEPENDS_ON.  */\n+   on invariants DEPENDS_ON and that the value used in expressing it\n+   is VALUE.*/\n \n static void\n set_use_iv_cost (struct ivopts_data *data,\n \t\t struct iv_use *use, struct iv_cand *cand, unsigned cost,\n-\t\t bitmap depends_on)\n+\t\t bitmap depends_on, tree value)\n {\n   unsigned i, s;\n \n@@ -2290,6 +2294,7 @@ set_use_iv_cost (struct ivopts_data *data,\n       use->cost_map[cand->id].cand = cand;\n       use->cost_map[cand->id].cost = cost;\n       use->cost_map[cand->id].depends_on = depends_on;\n+      use->cost_map[cand->id].value = value;\n       return;\n     }\n \n@@ -2308,6 +2313,7 @@ set_use_iv_cost (struct ivopts_data *data,\n   use->cost_map[i].cand = cand;\n   use->cost_map[i].cost = cost;\n   use->cost_map[i].depends_on = depends_on;\n+  use->cost_map[i].value = value;\n }\n \n /* Gets cost of (USE, CANDIDATE) pair.  */\n@@ -3307,12 +3313,12 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, 0, NULL);\n+      set_use_iv_cost (data, use, cand, 0, NULL, NULL_TREE);\n       return true;\n     }\n \n   cost = get_computation_cost (data, use, cand, false, &depends_on);\n-  set_use_iv_cost (data, use, cand, cost, depends_on);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n   return cost != INFTY;\n }\n@@ -3326,7 +3332,7 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n   bitmap depends_on;\n   unsigned cost = get_computation_cost (data, use, cand, true, &depends_on);\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n   return cost != INFTY;\n }\n@@ -3382,14 +3388,29 @@ iv_period (struct iv *iv)\n   return period;\n }\n \n+/* Returns the comparison operator used when eliminating the iv USE.  */\n+\n+static enum tree_code\n+iv_elimination_compare (struct ivopts_data *data, struct iv_use *use)\n+{\n+  struct loop *loop = data->current_loop;\n+  basic_block ex_bb;\n+  edge exit;\n+\n+  ex_bb = bb_for_stmt (use->stmt);\n+  exit = EDGE_SUCC (ex_bb, 0);\n+  if (flow_bb_inside_loop_p (loop, exit->dest))\n+    exit = EDGE_SUCC (ex_bb, 1);\n+\n+  return (exit->flags & EDGE_TRUE_VALUE ? EQ_EXPR : NE_EXPR);\n+}\n+\n /* Check whether it is possible to express the condition in USE by comparison\n-   of candidate CAND.  If so, store the comparison code to COMPARE and the\n-   value compared with to BOUND.  */\n+   of candidate CAND.  If so, store the value compared with to BOUND.  */\n \n static bool\n may_eliminate_iv (struct ivopts_data *data,\n-\t\t  struct iv_use *use, struct iv_cand *cand,\n-\t\t  enum tree_code *compare, tree *bound)\n+\t\t  struct iv_use *use, struct iv_cand *cand, tree *bound)\n {\n   basic_block ex_bb;\n   edge exit;\n@@ -3440,11 +3461,6 @@ may_eliminate_iv (struct ivopts_data *data,\n \t\t\t\t       fold_convert (wider_type, nit)))))\n     return false;\n \n-  if (exit->flags & EDGE_TRUE_VALUE)\n-    *compare = EQ_EXPR;\n-  else\n-    *compare = NE_EXPR;\n-\n   *bound = cand_value_at (loop, cand, use->stmt, nit);\n   return true;\n }\n@@ -3455,37 +3471,46 @@ static bool\n determine_use_iv_cost_condition (struct ivopts_data *data,\n \t\t\t\t struct iv_use *use, struct iv_cand *cand)\n {\n-  tree bound;\n-  enum tree_code compare;\n+  tree bound = NULL_TREE, op, cond;\n+  bitmap depends_on = NULL;\n+  unsigned cost;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n     {\n-      set_use_iv_cost (data, use, cand, INFTY, NULL);\n+      set_use_iv_cost (data, use, cand, INFTY, NULL, NULL_TREE);\n       return false;\n     }\n \n-  if (may_eliminate_iv (data, use, cand, &compare, &bound))\n+  if (may_eliminate_iv (data, use, cand, &bound))\n     {\n-      bitmap depends_on = NULL;\n-      unsigned cost = force_var_cost (data, bound, &depends_on);\n+      cost = force_var_cost (data, bound, &depends_on);\n \n-      set_use_iv_cost (data, use, cand, cost, depends_on);\n+      set_use_iv_cost (data, use, cand, cost, depends_on, bound);\n       return cost != INFTY;\n     }\n \n   /* The induction variable elimination failed; just express the original\n      giv.  If it is compared with an invariant, note that we cannot get\n      rid of it.  */\n-  if (TREE_CODE (*use->op_p) == SSA_NAME)\n-    record_invariant (data, *use->op_p, true);\n-  else\n+  cost = get_computation_cost (data, use, cand, false, &depends_on);\n+\n+  cond = *use->op_p;\n+  if (TREE_CODE (cond) != SSA_NAME)\n     {\n-      record_invariant (data, TREE_OPERAND (*use->op_p, 0), true);\n-      record_invariant (data, TREE_OPERAND (*use->op_p, 1), true);\n+      op = TREE_OPERAND (cond, 0);\n+      if (TREE_CODE (op) == SSA_NAME && !zero_p (get_iv (data, op)->step))\n+\top = TREE_OPERAND (cond, 1);\n+      if (TREE_CODE (op) == SSA_NAME)\n+\t{\n+\t  op = get_iv (data, op)->base;\n+\t  fd_ivopts_data = data;\n+\t  walk_tree (&op, find_depends, &depends_on, NULL);\n+\t}\n     }\n \n-  return determine_use_iv_cost_generic (data, use, cand);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL);\n+  return cost != INFTY;\n }\n \n /* Checks whether it is possible to replace the final value of USE by\n@@ -3525,7 +3550,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n   bitmap depends_on;\n   unsigned cost;\n   edge exit;\n-  tree value;\n+  tree value = NULL_TREE;\n   struct loop *loop = data->current_loop;\n \n   /* The simple case first -- if we need to express value of the preserved\n@@ -3535,15 +3560,15 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, 0, NULL);\n+      set_use_iv_cost (data, use, cand, 0, NULL, NULL_TREE);\n       return true;\n     }\n \n   if (!cand->iv)\n     {\n       if (!may_replace_final_value (data, use, &value))\n \t{\n-\t  set_use_iv_cost (data, use, cand, INFTY, NULL);\n+\t  set_use_iv_cost (data, use, cand, INFTY, NULL, NULL_TREE);\n \t  return false;\n \t}\n \n@@ -3552,7 +3577,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n \n       cost /= AVG_LOOP_NITER (loop);\n \n-      set_use_iv_cost (data, use, cand, cost, depends_on);\n+      set_use_iv_cost (data, use, cand, cost, depends_on, value);\n       return cost != INFTY;\n     }\n \n@@ -3572,7 +3597,7 @@ determine_use_iv_cost_outer (struct ivopts_data *data,\n       cost = get_computation_cost (data, use, cand, false, &depends_on);\n     }\n \t\t\t\t   \n-  set_use_iv_cost (data, use, cand, cost, depends_on);\n+  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n   return cost != INFTY;\n }\n@@ -4907,12 +4932,15 @@ rewrite_use_compare (struct ivopts_data *data,\n   tree *op_p, cond, op, stmts, bound;\n   block_stmt_iterator bsi = bsi_for_stmt (use->stmt);\n   enum tree_code compare;\n+  struct cost_pair *cp = get_use_iv_cost (data, use, cand);\n   \n-  if (may_eliminate_iv (data, use, cand, &compare, &bound))\n+  bound = cp->value;\n+  if (bound)\n     {\n       tree var = var_at_stmt (data->current_loop, cand, use->stmt);\n       tree var_type = TREE_TYPE (var);\n \n+      compare = iv_elimination_compare (data, use);\n       bound = fold_convert (var_type, bound);\n       op = force_gimple_operand (unshare_expr (bound), &stmts,\n \t\t\t\t true, NULL_TREE);\n@@ -5087,8 +5115,8 @@ rewrite_use_outer (struct ivopts_data *data,\n     {\n       if (!cand->iv)\n \t{\n-\t  bool ok = may_replace_final_value (data, use, &value);\n-\t  gcc_assert (ok);\n+\t  struct cost_pair *cp = get_use_iv_cost (data, use, cand);\n+\t  value = cp->value;\n \t}\n       else\n \tvalue = get_computation_at (data->current_loop,"}]}