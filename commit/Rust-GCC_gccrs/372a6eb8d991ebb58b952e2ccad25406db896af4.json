{"sha": "372a6eb8d991ebb58b952e2ccad25406db896af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcyYTZlYjhkOTkxZWJiNThiOTUyZTJjY2FkMjU0MDZkYjg5NmFmNA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-06-12T13:38:16Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-06-12T13:38:16Z"}, "message": "opts.c: Add -fhoist-adjacent-loads to -O2 and above.\n\n2012-06-12  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* opts.c: Add -fhoist-adjacent-loads to -O2 and above.\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Add argument to forward\n\tdeclaration.\n\t(hoist_adjacent_loads, gate_hoist_loads): New forward declarations.\n\t(tree_ssa_phiopt): Call gate_hoist_loads.\n\t(tree_ssa_cs_elim): Add parm to tree_ssa_phiopt_worker call.\n\t(tree_ssa_phiopt_worker): Add do_hoist_loads to formal arg list; call\n\thoist_adjacent_loads.\n\t(local_mem_dependence): New function.\n\t(hoist_adjacent_loads): Likewise.\n\t(gate_hoist_loads): Likewise.\n\t* common.opt (fhoist-adjacent-loads): New switch.\n\t* Makefile.in (tree-ssa-phiopt.o): Added dependencies.\n\nFrom-SVN: r188457", "tree": {"sha": "4844a9d49d0608a170eeaa9cc4a3f4c4e4621aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4844a9d49d0608a170eeaa9cc4a3f4c4e4621aa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/372a6eb8d991ebb58b952e2ccad25406db896af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/372a6eb8d991ebb58b952e2ccad25406db896af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/372a6eb8d991ebb58b952e2ccad25406db896af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/372a6eb8d991ebb58b952e2ccad25406db896af4/comments", "author": null, "committer": null, "parents": [{"sha": "02e4edeaf41e6a15fdd59c476ef7592275b568c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e4edeaf41e6a15fdd59c476ef7592275b568c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e4edeaf41e6a15fdd59c476ef7592275b568c6"}], "stats": {"total": 314, "additions": 307, "deletions": 7}, "files": [{"sha": "77a8e64163339a7625406246a28de57ce6c54dba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=372a6eb8d991ebb58b952e2ccad25406db896af4", "patch": "@@ -1,3 +1,19 @@\n+2012-06-12  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* opts.c: Add -fhoist-adjacent-loads to -O2 and above.\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Add argument to forward\n+\tdeclaration.\n+\t(hoist_adjacent_loads, gate_hoist_loads): New forward declarations.\n+\t(tree_ssa_phiopt): Call gate_hoist_loads.\n+\t(tree_ssa_cs_elim): Add parm to tree_ssa_phiopt_worker call.\n+\t(tree_ssa_phiopt_worker): Add do_hoist_loads to formal arg list; call\n+\thoist_adjacent_loads.\n+\t(local_mem_dependence): New function.\n+\t(hoist_adjacent_loads): Likewise.\n+\t(gate_hoist_loads): Likewise.\n+\t* common.opt (fhoist-adjacent-loads): New switch.\n+\t* Makefile.in (tree-ssa-phiopt.o): Added dependencies.\n+\n 2012-06-12  Michael Matz  <matz@suse.de>\n \n \t* alias.c (nonoverlapping_component_refs_p): Take two rtx arguments."}, {"sha": "d95b32e7adc93a9f81a3b3432e79eba5fa419e08", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=372a6eb8d991ebb58b952e2ccad25406db896af4", "patch": "@@ -2368,7 +2368,8 @@ tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) $(TIMEVAR_H) pointer-set.h domwalk.h $(CFGLOOP_H) \\\n-   $(TREE_DATA_REF_H) $(TREE_PRETTY_PRINT_H)\n+   $(TREE_DATA_REF_H) $(TREE_PRETTY_PRINT_H) $(GIMPLE_PRETTY_PRINT_H) \\\n+   insn-config.h $(EXPR_H) $(OPTABS_H)\n tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(FUNCTION_H) $(BASIC_BLOCK_H) $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_PASS_H) \\"}, {"sha": "02c7cd3ee7a0ede002ee24ca8a9b068bfb18420c", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=372a6eb8d991ebb58b952e2ccad25406db896af4", "patch": "@@ -1186,6 +1186,11 @@ fgraphite-identity\n Common Report Var(flag_graphite_identity) Optimization\n Enable Graphite Identity transformation\n \n+fhoist-adjacent-loads\n+Common Report Var(flag_hoist_adjacent_loads) Optimization\n+Enable hoisting adjacent loads to encourage generating conditional move\n+instructions\n+\n floop-parallelize-all\n Common Report Var(flag_loop_parallelize_all) Optimization\n Mark all loops as parallel"}, {"sha": "d189e90cce0a68b21232ceba63eafd4273a93efb", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=372a6eb8d991ebb58b952e2ccad25406db896af4", "patch": "@@ -489,6 +489,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "6e47f6f85b3125867968e145629c6f8b01590b69", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 283, "deletions": 6, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/372a6eb8d991ebb58b952e2ccad25406db896af4/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=372a6eb8d991ebb58b952e2ccad25406db896af4", "patch": "@@ -37,9 +37,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"insn-config.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+\n+#ifndef HAVE_conditional_move\n+#define HAVE_conditional_move (0)\n+#endif\n \n static unsigned int tree_ssa_phiopt (void);\n-static unsigned int tree_ssa_phiopt_worker (bool);\n+static unsigned int tree_ssa_phiopt_worker (bool, bool);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gimple, tree, tree);\n static int value_replacement (basic_block, basic_block,\n@@ -53,6 +61,9 @@ static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n static struct pointer_set_t * get_non_trapping (void);\n static void replace_phi_edge_with_variable (basic_block, edge, gimple, tree);\n+static void hoist_adjacent_loads (basic_block, basic_block,\n+\t\t\t\t  basic_block, basic_block);\n+static bool gate_hoist_loads (void);\n \n /* This pass tries to replaces an if-then-else block with an\n    assignment.  We have four kinds of transformations.  Some of these\n@@ -138,12 +149,56 @@ static void replace_phi_edge_with_variable (basic_block, edge, gimple, tree);\n      bb2:\n        x = PHI <x' (bb0), ...>;\n \n-   A similar transformation is done for MAX_EXPR.  */\n+   A similar transformation is done for MAX_EXPR.\n+\n+\n+   This pass also performs a fifth transformation of a slightly different\n+   flavor.\n+\n+   Adjacent Load Hoisting\n+   ----------------------\n+   \n+   This transformation replaces\n+\n+     bb0:\n+       if (...) goto bb2; else goto bb1;\n+     bb1:\n+       x1 = (<expr>).field1;\n+       goto bb3;\n+     bb2:\n+       x2 = (<expr>).field2;\n+     bb3:\n+       # x = PHI <x1, x2>;\n+\n+   with\n+\n+     bb0:\n+       x1 = (<expr>).field1;\n+       x2 = (<expr>).field2;\n+       if (...) goto bb2; else goto bb1;\n+     bb1:\n+       goto bb3;\n+     bb2:\n+     bb3:\n+       # x = PHI <x1, x2>;\n+\n+   The purpose of this transformation is to enable generation of conditional\n+   move instructions such as Intel CMOVE or PowerPC ISEL.  Because one of\n+   the loads is speculative, the transformation is restricted to very\n+   specific cases to avoid introducing a page fault.  We are looking for\n+   the common idiom:\n+\n+     if (...)\n+       x = y->left;\n+     else\n+       x = y->right;\n+\n+   where left and right are typically adjacent pointers in a tree structure.  */\n \n static unsigned int\n tree_ssa_phiopt (void)\n {\n-  return tree_ssa_phiopt_worker (false);\n+  return tree_ssa_phiopt_worker (false, gate_hoist_loads ());\n }\n \n /* This pass tries to transform conditional stores into unconditional\n@@ -190,7 +245,7 @@ tree_ssa_phiopt (void)\n static unsigned int\n tree_ssa_cs_elim (void)\n {\n-  return tree_ssa_phiopt_worker (true);\n+  return tree_ssa_phiopt_worker (true, false);\n }\n \n /* Return the singleton PHI in the SEQ of PHIs for edges E0 and E1. */\n@@ -227,9 +282,11 @@ static tree condstoretemp;\n /* The core routine of conditional store replacement and normal\n    phi optimizations.  Both share much of the infrastructure in how\n    to match applicable basic block patterns.  DO_STORE_ELIM is true\n-   when we want to do conditional store replacement, false otherwise.  */\n+   when we want to do conditional store replacement, false otherwise.\n+   DO_HOIST_LOADS is true when we want to hoist adjacent loads out \n+   of diamond control flow patterns, false otherwise.  */\n static unsigned int\n-tree_ssa_phiopt_worker (bool do_store_elim)\n+tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n {\n   basic_block bb;\n   basic_block *bb_order;\n@@ -312,6 +369,25 @@ tree_ssa_phiopt_worker (bool do_store_elim)\n \t    cfgchanged = true;\n \t  continue;\n \t}\n+      else if (do_hoist_loads\n+\t\t && EDGE_SUCC (bb1, 0)->dest == EDGE_SUCC (bb2, 0)->dest)\n+\t{\n+\t  basic_block bb3 = EDGE_SUCC (bb1, 0)->dest;\n+\n+\t  if (!FLOAT_TYPE_P (TREE_TYPE (gimple_cond_lhs (cond_stmt)))\n+\t      && single_succ_p (bb1)\n+\t      && single_succ_p (bb2)\n+\t      && single_pred_p (bb1)\n+\t      && single_pred_p (bb2)\n+\t      && EDGE_COUNT (bb->succs) == 2\n+\t      && EDGE_COUNT (bb3->preds) == 2\n+\t      /* If one edge or the other is dominant, a conditional move\n+\t\t is likely to perform worse than the well-predicted branch.  */\n+\t      && !predictable_edge_p (EDGE_SUCC (bb, 0))\n+\t      && !predictable_edge_p (EDGE_SUCC (bb, 1)))\n+\t    hoist_adjacent_loads (bb, bb1, bb2, bb3);\n+\t  continue;\n+\t}\n       else\n \tcontinue;      \n \n@@ -1707,6 +1783,207 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n   return ok;\n }\n \n+/* Return TRUE if STMT has a VUSE whose corresponding VDEF is in BB.  */\n+\n+static bool\n+local_mem_dependence (gimple stmt, basic_block bb)\n+{\n+  tree vuse = gimple_vuse (stmt);\n+  gimple def;\n+\n+  if (!vuse)\n+    return false;\n+\n+  def = SSA_NAME_DEF_STMT (vuse);\n+  return (def && gimple_bb (def) == bb);\n+}\n+\n+/* Given a \"diamond\" control-flow pattern where BB0 tests a condition,\n+   BB1 and BB2 are \"then\" and \"else\" blocks dependent on this test,\n+   and BB3 rejoins control flow following BB1 and BB2, look for \n+   opportunities to hoist loads as follows.  If BB3 contains a PHI of\n+   two loads, one each occurring in BB1 and BB2, and the loads are\n+   provably of adjacent fields in the same structure, then move both\n+   loads into BB0.  Of course this can only be done if there are no\n+   dependencies preventing such motion.\n+\n+   One of the hoisted loads will always be speculative, so the\n+   transformation is currently conservative:\n+\n+    - The fields must be strictly adjacent.\n+    - The two fields must occupy a single memory block that is\n+      guaranteed to not cross a page boundary.\n+\n+    The last is difficult to prove, as such memory blocks should be\n+    aligned on the minimum of the stack alignment boundary and the\n+    alignment guaranteed by heap allocation interfaces.  Thus we rely\n+    on a parameter for the alignment value.\n+\n+    Provided a good value is used for the last case, the first\n+    restriction could possibly be relaxed.  */\n+\n+static void\n+hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n+\t\t      basic_block bb2, basic_block bb3)\n+{\n+  int param_align = PARAM_VALUE (PARAM_L1_CACHE_LINE_SIZE);\n+  unsigned param_align_bits = (unsigned) (param_align * BITS_PER_UNIT);\n+  gimple_stmt_iterator gsi;\n+\n+  /* Walk the phis in bb3 looking for an opportunity.  We are looking\n+     for phis of two SSA names, one each of which is defined in bb1 and\n+     bb2.  */\n+  for (gsi = gsi_start_phis (bb3); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi_stmt = gsi_stmt (gsi);\n+      gimple def1, def2, defswap;\n+      tree arg1, arg2, ref1, ref2, field1, field2, fieldswap;\n+      tree tree_offset1, tree_offset2, tree_size2, next;\n+      int offset1, offset2, size2;\n+      unsigned align1;\n+      gimple_stmt_iterator gsi2;\n+      basic_block bb_for_def1, bb_for_def2;\n+\n+      if (gimple_phi_num_args (phi_stmt) != 2)\n+\tcontinue;\n+\n+      arg1 = gimple_phi_arg_def (phi_stmt, 0);\n+      arg2 = gimple_phi_arg_def (phi_stmt, 1);\n+      \n+      if (TREE_CODE (arg1) != SSA_NAME\n+\t  || TREE_CODE (arg2) != SSA_NAME\n+\t  || SSA_NAME_IS_DEFAULT_DEF (arg1)\n+\t  || SSA_NAME_IS_DEFAULT_DEF (arg2))\n+\tcontinue;\n+\n+      def1 = SSA_NAME_DEF_STMT (arg1);\n+      def2 = SSA_NAME_DEF_STMT (arg2);\n+\n+      if ((gimple_bb (def1) != bb1 || gimple_bb (def2) != bb2)\n+\t  && (gimple_bb (def2) != bb1 || gimple_bb (def1) != bb2))\n+\tcontinue;\n+\n+      /* Check the mode of the arguments to be sure a conditional move\n+\t can be generated for it.  */\n+      if (!optab_handler (cmov_optab, TYPE_MODE (TREE_TYPE (arg1))))\n+\tcontinue;\n+\n+      /* Both statements must be assignments whose RHS is a COMPONENT_REF.  */\n+      if (!gimple_assign_single_p (def1)\n+\t  || !gimple_assign_single_p (def2))\n+\tcontinue;\n+\n+      ref1 = gimple_assign_rhs1 (def1);\n+      ref2 = gimple_assign_rhs1 (def2);\n+\n+      if (TREE_CODE (ref1) != COMPONENT_REF\n+\t  || TREE_CODE (ref2) != COMPONENT_REF)\n+\tcontinue;\n+\n+      /* The zeroth operand of the two component references must be\n+\t identical.  It is not sufficient to compare get_base_address of\n+\t the two references, because this could allow for different\n+\t elements of the same array in the two trees.  It is not safe to\n+\t assume that the existence of one array element implies the\n+\t existence of a different one.  */\n+      if (!operand_equal_p (TREE_OPERAND (ref1, 0), TREE_OPERAND (ref2, 0), 0))\n+\tcontinue;\n+\n+      field1 = TREE_OPERAND (ref1, 1);\n+      field2 = TREE_OPERAND (ref2, 1);\n+\n+      /* Check for field adjacency, and ensure field1 comes first.  */\n+      for (next = DECL_CHAIN (field1);\n+\t   next && TREE_CODE (next) != FIELD_DECL;\n+\t   next = DECL_CHAIN (next))\n+\t;\n+\n+      if (next != field2)\n+\t{\n+\t  for (next = DECL_CHAIN (field2);\n+\t       next && TREE_CODE (next) != FIELD_DECL;\n+\t       next = DECL_CHAIN (next))\n+\t    ;\n+\n+\t  if (next != field1)\n+\t    continue;\n+\n+\t  fieldswap = field1;\n+\t  field1 = field2;\n+\t  field2 = fieldswap;\n+\t  defswap = def1;\n+\t  def1 = def2;\n+\t  def2 = defswap;\n+\t  /* Don't swap bb1 and bb2 as we may have more than one\n+\t     phi to process successfully.  */\n+\t  bb_for_def1 = bb2;\n+\t  bb_for_def2 = bb1;\n+\t}\n+      else\n+\t{\n+\t  bb_for_def1 = bb1;\n+\t  bb_for_def2 = bb2;\n+\t}\n+\n+      /* Check for proper alignment of the first field.  */\n+      tree_offset1 = bit_position (field1);\n+      tree_offset2 = bit_position (field2);\n+      tree_size2 = DECL_SIZE (field2);\n+\n+      if (!host_integerp (tree_offset1, 1)\n+\t  || !host_integerp (tree_offset2, 1)\n+\t  || !host_integerp (tree_size2, 1))\n+\tcontinue;\n+\n+      offset1 = TREE_INT_CST_LOW (tree_offset1);\n+      offset2 = TREE_INT_CST_LOW (tree_offset2);\n+      size2 = TREE_INT_CST_LOW (tree_size2);\n+      align1 = DECL_ALIGN (field1) % param_align_bits;\n+\n+      if (offset1 % BITS_PER_UNIT != 0)\n+\tcontinue;\n+\n+      /* For profitability, the two field references should fit within\n+\t a single cache line.  */\n+      if (align1 + offset2 - offset1 + size2 > param_align_bits)\n+\tcontinue;\n+\n+      /* The two expressions cannot be dependent upon vdefs defined\n+\t in bb1/bb2.  */\n+      if (local_mem_dependence (def1, bb_for_def1)\n+\t  || local_mem_dependence (def2, bb_for_def2))\n+\tcontinue;\n+\n+      /* The conditions are satisfied; hoist the loads from bb1 and bb2 into\n+\t bb0.  We hoist the first one first so that a cache miss is handled\n+         efficiently regardless of hardware cache-fill policy.  */\n+      gsi2 = gsi_for_stmt (def1);\n+      gsi_move_to_bb_end (&gsi2, bb0);\n+      gsi2 = gsi_for_stmt (def2);\n+      gsi_move_to_bb_end (&gsi2, bb0);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"\\nHoisting adjacent loads from %d and %d into %d: \\n\",\n+\t\t   bb_for_def1->index, bb_for_def2->index, bb0->index);\n+\t  print_gimple_stmt (dump_file, def1, 0, TDF_VOPS|TDF_MEMSYMS);\n+\t  print_gimple_stmt (dump_file, def2, 0, TDF_VOPS|TDF_MEMSYMS);\n+\t}\n+    }\n+}\n+\n+/* Determine whether we should attempt to hoist adjacent loads out of\n+   diamond patterns in pass_phiopt.  Always hoist loads if\n+   -fhoist-adjacent-loads is specified and the target machine has\n+   a conditional move instruction.  */\n+\n+static bool\n+gate_hoist_loads (void)\n+{\n+  return (flag_hoist_adjacent_loads == 1 && HAVE_conditional_move);\n+}\n+\n /* Always do these optimizations if we have SSA\n    trees to work on.  */\n static bool"}]}