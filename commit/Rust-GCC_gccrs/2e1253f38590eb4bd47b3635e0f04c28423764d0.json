{"sha": "2e1253f38590eb4bd47b3635e0f04c28423764d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxMjUzZjM4NTkwZWI0YmQ0N2IzNjM1ZTBmMDRjMjg0MjM3NjRkMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-31T22:09:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-01-31T22:09:12Z"}, "message": "If we can't substitute an equiv reg only used once, move the\nassignment\n\nFrom-SVN: r13572", "tree": {"sha": "66cba0586dcc5fbf7654d5a7c5b51b06bb69bfc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66cba0586dcc5fbf7654d5a7c5b51b06bb69bfc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e1253f38590eb4bd47b3635e0f04c28423764d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1253f38590eb4bd47b3635e0f04c28423764d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e1253f38590eb4bd47b3635e0f04c28423764d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e1253f38590eb4bd47b3635e0f04c28423764d0/comments", "author": null, "committer": null, "parents": [{"sha": "856b07a15774986e00506b65b891c494d7ef6be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/856b07a15774986e00506b65b891c494d7ef6be2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/856b07a15774986e00506b65b891c494d7ef6be2"}], "stats": {"total": 118, "additions": 93, "deletions": 25}, "files": [{"sha": "0657cc7797a1a990eb099ce475f73d3ae3ab8419", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 93, "deletions": 25, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e1253f38590eb4bd47b3635e0f04c28423764d0/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e1253f38590eb4bd47b3635e0f04c28423764d0/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=2e1253f38590eb4bd47b3635e0f04c28423764d0", "patch": "@@ -1,5 +1,5 @@\n /* Allocate registers within a basic block, for GNU compiler.\n-   Copyright (C) 1987, 88, 91, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 91, 93-6, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -965,6 +965,7 @@ update_equiv_regs ()\n   char *reg_equiv_replace\n     = (char *) alloca (max_regno * sizeof *reg_equiv_replace);\n   rtx insn;\n+  int block, depth;\n \n   reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx *));\n \n@@ -1114,36 +1115,103 @@ update_equiv_regs ()\n \t}\n     }\n \n-  /* Now scan all regs killed in an insn to see if any of them are registers\n-     only used that once.  If so, see if we can replace the reference with\n-     the equivalent from.  If we can, delete the initializing reference\n-     and this register will go away.  */\n-  for (insn = next_active_insn (get_insns ());\n-       insn;\n-       insn = next_active_insn (insn))\n+  /* Now scan all regs killed in an insn to see if any of them are\n+     registers only used that once.  If so, see if we can replace the\n+     reference with the equivalent from.  If we can, delete the\n+     initializing reference and this register will go away.  If we\n+     can't replace the reference, and the instruction is not in a\n+     loop, then move the register initialization just before the use,\n+     so that they are in the same basic block.  */\n+  block = -1;\n+  depth = 0;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx link;\n \n+      /* Keep track of which basic block we are in.  */\n+      if (block + 1 < n_basic_blocks\n+\t  && basic_block_head[block + 1] == insn)\n+\t++block;\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\t{\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    {\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t\t++depth;\n+\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t\t{\n+\t\t  --depth;\n+\t\t  if (depth < 0)\n+\t\t    abort ();\n+\t\t}\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n       for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\tif (REG_NOTE_KIND (link) == REG_DEAD\n-\t    /* Make sure this insn still refers to the register.  */\n-\t    && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n-\t  {\n-\t    int regno = REGNO (XEXP (link, 0));\n+\t{\n+\t  if (REG_NOTE_KIND (link) == REG_DEAD\n+\t      /* Make sure this insn still refers to the register.  */\n+\t      && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n+\t    {\n+\t      int regno = REGNO (XEXP (link, 0));\n+\t      rtx equiv_insn;\n \n-\t    if (reg_equiv_replace[regno]\n-\t\t&& validate_replace_rtx (regno_reg_rtx[regno],\n-\t\t\t\t\t reg_equiv_replacement[regno], insn))\n-\t      {\n-\t\trtx equiv_insn = reg_equiv_init_insn[regno];\n+\t      if (! reg_equiv_replace[regno])\n+\t\tcontinue;\n \n-\t\tremove_death (regno, insn);\n-\t\treg_n_refs[regno] = 0;\n-\t\tPUT_CODE (equiv_insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (equiv_insn) = 0;\n-\t      }\n-\t  }\n+\t      equiv_insn = reg_equiv_init_insn[regno];\n+\n+\t      if (validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t\treg_equiv_replacement[regno], insn))\n+\t\t{\n+\t\t  remove_death (regno, insn);\n+\t\t  reg_n_refs[regno] = 0;\n+\t\t  PUT_CODE (equiv_insn, NOTE);\n+\t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t}\n+\t      /* If we aren't in a loop, and there are no calls in\n+\t\t INSN or in the initialization of the register, then\n+\t\t move the initialization of the register to just\n+\t\t before INSN.  Update the flow information.  */\n+\t      else if (depth == 0\n+\t\t       && GET_CODE (equiv_insn) == INSN\n+\t\t       && GET_CODE (insn) == INSN\n+\t\t       && reg_basic_block[regno] < 0)\n+\t\t{\n+\t\t  int l, offset, bit;\n+\n+\t\t  emit_insn_before (copy_rtx (PATTERN (equiv_insn)),\n+\t\t\t\t    insn);\n+\t\t  REG_NOTES (PREV_INSN (insn)) =\n+\t\t    REG_NOTES (equiv_insn);\n+\n+\t\t  PUT_CODE (equiv_insn, NOTE);\n+\t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t  REG_NOTES (equiv_insn) = 0;\n+\n+\t\t  if (block < 0)\n+\t\t    reg_basic_block[regno] = 0;\n+\t\t  else\n+\t\t    reg_basic_block[regno] = block;\n+\t\t  reg_n_calls_crossed[regno] = 0;\n+\t\t  reg_live_length[regno] = 2;\n+\n+\t\t  if (block >= 0 && insn == basic_block_head[block])\n+\t\t    basic_block_head[block] = PREV_INSN (insn);\n+\n+\t\t  offset = regno / REGSET_ELT_BITS;\n+\t\t  bit = ((REGSET_ELT_TYPE) 1\n+\t\t\t << (regno % REGSET_ELT_BITS));\n+\t\t  for (l = 0; l < n_basic_blocks; l++)\n+\t\t    basic_block_live_at_start[l][offset] &= ~ bit;\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \f"}]}