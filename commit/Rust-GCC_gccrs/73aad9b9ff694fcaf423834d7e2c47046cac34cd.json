{"sha": "73aad9b9ff694fcaf423834d7e2c47046cac34cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhYWQ5YjlmZjY5NGZjYWY0MjM4MzRkN2UyYzQ3MDQ2Y2FjMzRjZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1996-08-13T15:39:22Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-13T15:39:22Z"}, "message": "87th Cygnus<->FSF quick merge\n\nFrom-SVN: r12630", "tree": {"sha": "e2b752085bc40e641e8888cd283761f6cb564dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2b752085bc40e641e8888cd283761f6cb564dc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73aad9b9ff694fcaf423834d7e2c47046cac34cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73aad9b9ff694fcaf423834d7e2c47046cac34cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73aad9b9ff694fcaf423834d7e2c47046cac34cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73aad9b9ff694fcaf423834d7e2c47046cac34cd/comments", "author": null, "committer": null, "parents": [{"sha": "c8c2dcdce1e0144357f43f9d3c015dfbab58957a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8c2dcdce1e0144357f43f9d3c015dfbab58957a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8c2dcdce1e0144357f43f9d3c015dfbab58957a"}], "stats": {"total": 577, "additions": 463, "deletions": 114}, "files": [{"sha": "cf363840de5fc51f5755f87f12712dcfe230ccfc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -1,3 +1,49 @@\n+Mon Aug 12 00:09:18 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (end_template_decl): If we don't actually have parms, return.\n+\t* parse.y (template_header): Accept 'template <>'.\n+\n+\t* errfn.c: Allow 5 args.\n+\n+Sun Aug 11 15:20:58 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (make_temp_vec): New fn.\n+\t* pt.c (push_template_decl): Handle partial specs.\n+\t(instantiate_class_template): Ditto.\n+\t(more_specialized): Use get_bindings.\n+\t(more_specialized_class): New fn.\n+\t(get_class_bindings): New fn.\n+\t(most_specialized_class): New fn.\n+\t(do_function_instantiation): List candidates for ambiguous case.\n+\t* decl.c (duplicate_decls): Lose reference to DECL_TEMPLATE_MEMBERS.\n+\t(shadow_tag): Call push_template_decl for partial specializations.\n+\t* parse.y: Ditto.\n+\t* cp-tree.h (DECL_TEMPLATE_SPECIALIZATIONS): Replaces\n+ \tDECL_TEMPLATE_MEMBERS.\n+\t* call.c (print_z_candidates): Reduce duplication.\n+\n+Fri Aug  9 14:36:08 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (lang_decode_option): Allow -fansi-overloading.\n+\n+Thu Aug  8 17:04:18 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (get_bindings): New fn.\n+\t(most_specialized): Ditto.\n+\t(do_function_instantiation): Use them.\n+\t(add_maybe_template): New fn.\n+\t* cp-tree.h (DECL_MAYBE_TEMPLATE): New macro.\n+\t* call.c (build_new_op): Handle guiding decls.\n+\t(build_new_function_call): Ditto.\n+\t* decl2.c (finish_file): Ditto.\n+\n+\t* decl2.c (mark_used): Do synthesis here.\n+\t* call.c (build_method_call): Not here.\n+\t(build_over_call): Or here.\n+\t* typeck.c (build_function_call_real): Or here.\n+\t* tree.c (bot_manip): Call mark_used on functions used in default\n+ \targs.\n+\n Thu Aug  8 17:48:16 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n \n \t* decl2.c (import_export_vtable): Delete code that disabled vtable"}, {"sha": "8bc96d1ac66d8b60c37456baffb38c03029e648a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -2468,12 +2468,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   function = DECL_MAIN_VARIANT (function);\n   mark_used (function);\n \n-  /* Is it a synthesized method that needs to be synthesized?  */\n-  if (DECL_ARTIFICIAL (function) && ! DECL_INITIAL (function)\n-      /* Kludge: don't synthesize for default args.  */\n-      && current_function_decl)\n-    synthesize_method (function);\n-\n   if (pedantic && DECL_THIS_INLINE (function) && ! DECL_ARTIFICIAL (function)\n       && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function)\n       && ! (DECL_TEMPLATE_INFO (function)\n@@ -4157,48 +4151,27 @@ static void\n print_z_candidates (candidates)\n      struct z_candidate *candidates;\n {\n-  if (! candidates)\n-    return;\n-\n-  if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n-    {\n-      if (candidates->fn == ansi_opname [COND_EXPR])\n-\tcp_error (\"candidates are: %D(%T, %T, %T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n-      else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\tcp_error (\"candidates are: %D(%T, %T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n-      else\n-\tcp_error (\"candidates are: %D(%T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n-    }\n-  else\n-    cp_error_at (\"candidates are: %D\", candidates->fn);\n-  candidates = candidates->next;\n-\n+  char *str = \"candidates are:\";\n   for (; candidates; candidates = candidates->next)\n     {\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n \t{\n \t  if (candidates->fn == ansi_opname [COND_EXPR])\n-\t    cp_error (\"                %D(%T, %T, %T) <builtin>\",\n-\t\t      candidates->fn,\n+\t    cp_error (\"%s %D(%T, %T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n \t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\t    cp_error (\"                %D(%T, %T) <builtin>\", candidates->fn,\n+\t    cp_error (\"%s %D(%T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n \t  else\n-\t    cp_error (\"                %D(%T) <builtin>\", candidates->fn,\n+\t    cp_error (\"%s %D(%T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n \t}\n       else\n-\tcp_error_at (\"                %D\", candidates->fn);\n+\tcp_error_at (\"%s %+D\", str, candidates->fn);\n+      str = \"               \"; \n     }\n }\n \n@@ -4334,6 +4307,7 @@ build_new_function_call (fn, args, obj)\n   if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n     {\n       tree t;\n+      tree templates = NULL_TREE;\n \n       for (t = args; t; t = TREE_CHAIN (t))\n \tif (TREE_VALUE (t) == error_mark_node)\n@@ -4342,8 +4316,11 @@ build_new_function_call (fn, args, obj)\n       for (t = TREE_VALUE (fn); t; t = DECL_CHAIN (t))\n \t{\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    candidates = add_template_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t    {\n+\t      templates = decl_tree_cons (NULL_TREE, t, templates);\n+\t      candidates = add_template_candidate\n+\t\t(candidates, t, args, LOOKUP_NORMAL);\n+\t    }\n \t  else\n \t    candidates = add_function_candidate\n \t      (candidates, t, args, LOOKUP_NORMAL);\n@@ -4369,6 +4346,12 @@ build_new_function_call (fn, args, obj)\n \t  return error_mark_node;\n \t}\n \n+      /* Pedantically, it is ill-formed to define a function that could\n+\t also be a template instantiation, but we won't implement that\n+\t until things settle down.  */\n+      if (templates && ! cand->template && ! DECL_INITIAL (cand->fn))\n+\tadd_maybe_template (cand->fn, templates);\n+\n       return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n     }\n \n@@ -4482,6 +4465,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, mem_arglist, arglist, fnname, *p;\n   enum tree_code code2 = NOP_EXPR;\n+  tree templates = NULL_TREE;\n \n   if (arg1 == error_mark_node)\n     return error_mark_node;\n@@ -4602,7 +4586,11 @@ build_new_op (code, flags, arg1, arg2, arg3)\n   for (; fns; fns = DECL_CHAIN (fns))\n     {\n       if (TREE_CODE (fns) == TEMPLATE_DECL)\n-\tcandidates = add_template_candidate (candidates, fns, arglist, flags);\n+\t{\n+\t  templates = decl_tree_cons (NULL_TREE, fns, templates);\n+\t  candidates = add_template_candidate\n+\t    (candidates, fns, arglist, flags);\n+\t}\n       else\n \tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n     }\n@@ -4715,6 +4703,13 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       if (DECL_FUNCTION_MEMBER_P (cand->fn))\n \tenforce_access (cand->basetype_path, cand->fn);\n \n+      /* Pedantically, it is ill-formed to define a function that could\n+\t also be a template instantiation, but we won't implement that\n+\t until things settle down.  */\n+      if (templates && ! cand->template && ! DECL_INITIAL (cand->fn)\n+\t  && TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE)\n+\tadd_maybe_template (cand->fn, templates);\n+\n       return build_over_call\n \t(cand->fn, cand->convs,\n \t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n@@ -4999,12 +4994,6 @@ build_over_call (fn, convs, args, flags)\n   converted_args = nreverse (converted_args);\n \n   mark_used (fn);\n-  /* Is it a synthesized method that needs to be synthesized?  */\n-  if (DECL_ARTIFICIAL (fn) && ! DECL_INITIAL (fn)\n-      && DECL_CLASS_CONTEXT (fn)\n-      /* Kludge: don't synthesize for default args.  */\n-      && current_function_decl)\n-    synthesize_method (fn);\n \n   if (pedantic && DECL_THIS_INLINE (fn) && ! DECL_ARTIFICIAL (fn)\n       && ! DECL_INITIAL (fn) && ! DECL_PENDING_INLINE_INFO (fn)"}, {"sha": "8b9c6ba662bfd9b21ab2eccfe4fce7a0f7828f4e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -1135,7 +1135,7 @@ struct lang_decl\n #if 0\t\t\t\t/* UNUSED */\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n    should be looked up in a non-standard way.  */\n-#define DECL_OVERLOADED(NODE) (DECL_LANG_FLAG_4 (NODE))\n+#define DECL_OVERLOADED(NODE) (FOO)\n #endif\n \n /* Nonzero if this (non-TYPE)_DECL has its virtual attribute set.\n@@ -1331,7 +1331,7 @@ extern int flag_new_for_scope;\n /* Accessor macros for C++ template decl nodes.  */\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n /* For class templates.  */\n-#define DECL_TEMPLATE_MEMBERS(NODE)     DECL_SIZE(NODE)\n+#define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n /* For function, method, class-data templates.  */\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n@@ -1380,6 +1380,8 @@ extern int flag_new_for_scope;\n #define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n   (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n \n+/* This function may be a guiding decl for a template.  */\n+#define DECL_MAYBE_TEMPLATE(NODE) DECL_LANG_FLAG_4 (NODE)\n /* We know what we're doing with this decl now.  */\n #define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n \n@@ -2308,6 +2310,7 @@ extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree classtype_mangled_name\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n+extern tree *get_bindings\t\t\tPROTO((tree, tree));\n \n /* in search.c */\n extern void push_memoized_context\t\tPROTO((tree, int));"}, {"sha": "3486634591da5b282709cc063f2d0a59ec082bcb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -2869,7 +2869,6 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      DECL_TEMPLATE_MEMBERS (newdecl) = DECL_TEMPLATE_MEMBERS (olddecl);\n       DECL_TEMPLATE_INSTANTIATIONS (newdecl)\n \t= DECL_TEMPLATE_INSTANTIATIONS (olddecl);\n       if (DECL_CHAIN (newdecl) == NULL_TREE)\n@@ -5646,7 +5645,11 @@ shadow_tag (declspecs)\n \t    {\n \t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (value)\n \t\t  && TYPE_SIZE (value) == NULL_TREE)\n-\t\tSET_CLASSTYPE_TEMPLATE_SPECIALIZATION (value);\n+\t\t{\n+\t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (value);\n+\t\t  if (current_template_parms)\n+\t\t    push_template_decl (TYPE_MAIN_DECL (value));\n+\t\t}\n \t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (value))\n \t\tcp_error (\"specialization after instantiation of `%T'\", value);\n \t    }"}, {"sha": "b5a0529fc007b5f336dd90e16dee473e5d8abf4d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -498,11 +498,6 @@ lang_decode_option (p)\n \t  flag_alt_external_templates = 0;\n \t  found = 1;\n \t}\n-      else if (!strcmp (p, \"ansi-overloading\"))\n-\t{\n-\t  warning (\"-fansi-overloading is no longer meaningful\");\n-\t  found = 1;\n-\t}\n       else if (!strcmp (p, \"repo\"))\n \t{\n \t  flag_use_repository = 1;\n@@ -2876,6 +2871,7 @@ build_cleanup (decl)\n \n extern int parse_time, varconst_time;\n extern tree pending_templates;\n+extern tree maybe_templates;\n \n #define TIMEVAR(VAR, BODY)    \\\n do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)\n@@ -2952,6 +2948,20 @@ finish_file ()\n \tinstantiate_decl (decl);\n     }\n \n+  for (fnname = maybe_templates; fnname; fnname = TREE_CHAIN (fnname))\n+    {\n+      tree *args, fn, decl = TREE_VALUE (fnname);\n+\n+      if (DECL_INITIAL (decl))\n+\tcontinue;\n+\n+      fn = TREE_PURPOSE (fnname);\n+      args = get_bindings (fn, decl);\n+      fn = instantiate_template (fn, args);\n+      free (args);\n+      instantiate_decl (fn);\n+    }\n+\n   /* Push into C language context, because that's all\n      we'll need here.  */\n   push_lang_context (lang_name_c);\n@@ -3848,6 +3858,12 @@ mark_used (decl)\n   if (current_template_parms)\n     return;\n   assemble_external (decl);\n+  /* Is it a synthesized method that needs to be synthesized?  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_CLASS_CONTEXT (decl)\n+      && DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl)\n+      /* Kludge: don't synthesize for default args.  */\n+      && current_function_decl)\n+    synthesize_method (decl);\n   if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n     instantiate_decl (decl);\n }"}, {"sha": "b5ab8f7b676123ab7599f21bf610374647c39b53", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -44,11 +44,12 @@ extern int   cp_line_of PROTO((tree));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n \n-#define NARGS 4\n-#define arglist a1, a2, a3, a4\n-#define arglist_dcl HOST_WIDE_INT a1, a2, a3, a4;\n-#define ARGSINIT args[0] = a1; args[1] = a2; args[2] = a3; args[3] = a4;\n-#define ARGSLIST args[0], args[1], args[2], args[3]\n+#define NARGS 5\n+#define arglist a1, a2, a3, a4, a5\n+#define arglist_dcl HOST_WIDE_INT a1, a2, a3, a4, a5;\n+#define ARGSINIT \\\n+  args[0] = a1; args[1] = a2; args[2] = a3; args[3] = a4; args[4] = a5;\n+#define ARGSLIST args[0], args[1], args[2], args[3], args[4]\n \n static void\n cp_thing (errfn, atarg1, format, arglist)"}, {"sha": "06c4d82a0ab0e41966237d0bfc22125b0211c73b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -418,6 +418,8 @@ template_header:\n \t\t{ begin_template_parm_list (); }\n \t  template_parm_list '>'\n \t\t{ $$ = end_template_parm_list ($4); }\n+\t| TEMPLATE '<' '>'\n+\t\t{ $$ = NULL_TREE; }\n \t;\n \n template_parm_list:\n@@ -2321,7 +2323,11 @@ named_class_head:\n \t\t        {\n \t\t          if (CLASSTYPE_IMPLICIT_INSTANTIATION ($$)\n \t\t\t      && TYPE_SIZE ($$) == NULL_TREE)\n-\t\t\t    SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);\n+\t\t\t    {\n+\t\t\t      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);\n+\t\t\t      if (current_template_parms)\n+\t\t\t\tpush_template_decl (TYPE_MAIN_DECL ($$));\n+\t\t\t    }\n \t\t\t  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))\n \t\t\t    cp_error (\"specialization after instantiation of `%T'\", $$);\n \t\t\t}\n@@ -2525,7 +2531,11 @@ left_curly: '{'\n \t\t    {\n \t\t      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)\n \t\t\t  && TYPE_SIZE (t) == NULL_TREE)\n-\t\t\tSET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t\t\t{\n+\t\t\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n+\t\t\t  if (current_template_parms)\n+\t\t\t    push_template_decl (TYPE_MAIN_DECL (t));\n+\t\t\t}\n \t\t      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))\n \t\t\tcp_error (\"specialization after instantiation of `%T'\", t);\n \t\t    }"}, {"sha": "bb037060577a9c517e77d43fbdbc92d532ba1ab5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 307, "deletions": 45, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -53,6 +53,9 @@ HOST_WIDE_INT processing_template_decl;\n tree pending_templates;\n static tree *template_tail = &pending_templates;\n \n+tree maybe_templates;\n+static tree *maybe_template_tail = &maybe_templates;\n+\n int minimal_parse_mode;\n \n #define obstack_chunk_alloc xmalloc\n@@ -65,6 +68,9 @@ void pop_template_decls ();\n tree classtype_mangled_name ();\n static char * mangle_class_name_for_template ();\n tree tsubst_expr_values ();\n+tree most_specialized_class PROTO((tree, tree));\n+tree get_class_bindings PROTO((tree, tree, tree));\n+tree make_temp_vec PROTO((int));\n \n /* We've got a template header coming up; push to a new level for storing\n    the parms.  */\n@@ -181,6 +187,9 @@ end_template_parm_list (parms)\n void\n end_template_decl ()\n {\n+  if (! current_template_parms)\n+    return;\n+\n   /* This matches the pushlevel in begin_template_parm_list.  */\n   poplevel (0, 0, 0);\n \n@@ -229,6 +238,30 @@ push_template_decl (decl)\n   args = nreverse (args);\n   args = TREE_VALUE (args);\n \n+  /* Partial specialization.  */\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n+    {\n+      tree type = TREE_TYPE (decl);\n+      tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n+      tree mainargs = CLASSTYPE_TI_ARGS (type);\n+      tree spec = DECL_TEMPLATE_SPECIALIZATIONS (maintmpl);\n+\n+      for (; spec; spec = TREE_CHAIN (spec))\n+\t{\n+\t  /* purpose: args to main template\n+\t     value: spec template */\n+\t  if (comp_template_args (TREE_PURPOSE (spec), mainargs))\n+\t    return;\n+\t}\n+\n+      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = perm_tree_cons\n+\t(mainargs, TREE_VALUE (current_template_parms),\n+\t DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n+      TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n+      return;\n+    }\n+\n   if (! ctx || TYPE_BEING_DEFINED (ctx))\n     {\n       tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n@@ -237,6 +270,9 @@ push_template_decl (decl)\n     }\n   else\n     {\n+      if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n+\tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n+\t\t  ctx, decl);\n       if (TREE_CODE (decl) == TYPE_DECL)\n \ttmpl = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n       else if (! DECL_TEMPLATE_INFO (decl))\n@@ -1004,11 +1040,36 @@ instantiate_class_template (type)\n   template = TI_TEMPLATE (template_info);\n   my_friendly_assert (TREE_CODE (template) == TEMPLATE_DECL, 279);\n   args = TI_ARGS (template_info);\n-  pattern = TREE_TYPE (template);\n+\n+  t = most_specialized_class\n+    (DECL_TEMPLATE_SPECIALIZATIONS (template), args);\n+\n+  if (t == error_mark_node)\n+    {\n+      char *str = \"candidates are:\";\n+      cp_error (\"ambiguous class template instantiation for `%#T'\", type);\n+      for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; t = TREE_CHAIN (t))\n+\t{\n+\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args))\n+\t    {\n+\t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n+\t      str = \"               \";\n+\t    }\n+\t}\n+      TYPE_BEING_DEFINED (type) = 1;\n+      return;\n+    }\n+  else if (t)\n+    pattern = TREE_TYPE (t);\n+  else\n+    pattern = TREE_TYPE (template);\n \n   if (TYPE_SIZE (pattern) == NULL_TREE)\n     return type;\n \n+  if (t)\n+    args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args);\n+\n   TYPE_BEING_DEFINED (type) = 1;\n \n   if (! push_tinst_level (type))\n@@ -2785,34 +2846,207 @@ int\n more_specialized (pat1, pat2)\n      tree pat1, pat2;\n {\n-  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (pat1));\n-  tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n-  int i, dummy = 0, winner = 0;\n+  tree *targs;\n+  int winner = 0;\n \n-  i = type_unification (DECL_TEMPLATE_PARMS (pat1), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat1)),\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat2)),\n-\t\t\t&dummy, 0, 1);\n+  targs = get_bindings (pat1, pat2);\n+  if (targs)\n+    {\n+      free (targs);\n+      --winner;\n+    }\n \n-  free (targs);\n-  if (i == 0)\n-    --winner;\n+  targs = get_bindings (pat2, pat1);\n+  if (targs)\n+    {\n+      free (targs);\n+      ++winner;\n+    }\n \n-  ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (pat2));\n-  targs = (tree *) malloc (sizeof (tree) * ntparms);\n+  return winner;\n+}\n \n-  i = type_unification (DECL_TEMPLATE_PARMS (pat2), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat2)),\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat1)),\n-\t\t\t&dummy, 0, 1);\n+/* Given two class template specialization list nodes PAT1 and PAT2, return:\n \n-  free (targs);\n-  if (i == 0)\n+   1 if PAT1 is more specialized than PAT2 as described in [temp.class.order].\n+   -1 if PAT2 is more specialized than PAT1.\n+   0 if neither is more specialized.  */\n+   \n+int\n+more_specialized_class (pat1, pat2)\n+     tree pat1, pat2;\n+{\n+  tree targs;\n+  int winner = 0;\n+\n+  targs = get_class_bindings\n+    (TREE_VALUE (pat1), TREE_PURPOSE (pat1), TREE_PURPOSE (pat2));\n+  if (targs)\n+    --winner;\n+\n+  targs = get_class_bindings\n+    (TREE_VALUE (pat2), TREE_PURPOSE (pat2), TREE_PURPOSE (pat1));\n+  if (targs)\n     ++winner;\n \n   return winner;\n }\n-  \n+\n+/* Return the template arguments that will produce the function signature\n+   DECL from the function template FN.  */\n+\n+tree *\n+get_bindings (fn, decl)\n+     tree fn, decl;\n+{\n+  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n+  tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n+  int i, dummy = 0;\n+  i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t&dummy, 0, 1);\n+  if (i == 0)\n+    return targs;\n+  free (targs);\n+  return 0;\n+}\n+\n+tree\n+get_class_bindings (tparms, parms, args)\n+     tree tparms, parms, args;\n+{\n+  int i, dummy, ntparms = TREE_VEC_LENGTH (tparms);\n+  tree vec = make_temp_vec (ntparms);\n+\n+  for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n+    {\n+      switch (unify (tparms, &TREE_VEC_ELT (vec, 0), ntparms,\n+\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i),\n+\t\t     &dummy, 1))\n+\t{\n+\tcase 0:\n+\t  break;\n+\tcase 1:\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  for (i =  0; i < ntparms; ++i)\n+    if (! TREE_VEC_ELT (vec, i))\n+      return NULL_TREE;\n+\n+  return vec;\n+}\n+\n+/* Return the most specialized of the list of templates in FNS that can\n+   produce an instantiation matching DECL.  */\n+\n+tree\n+most_specialized (fns, decl)\n+     tree fns, decl;\n+{\n+  tree fn, champ, *args, *p;\n+  int fate;\n+\n+  for (p = &fns; *p; )\n+    {\n+      args = get_bindings (TREE_VALUE (*p), decl);\n+      if (args)\n+\t{\n+\t  free (args);\n+\t  p = &TREE_CHAIN (*p);\n+\t}\n+      else\n+\t*p = TREE_CHAIN (*p);\n+    }\n+\n+  if (! fns)\n+    return NULL_TREE;\n+\n+  fn = fns;\n+  champ = TREE_VALUE (fn);\n+  fn = TREE_CHAIN (fn);\n+  for (; fn; fn = TREE_CHAIN (fn))\n+    {\n+      fate = more_specialized (champ, TREE_VALUE (fn));\n+      if (fate == 1)\n+\t;\n+      else\n+\t{\n+\t  if (fate == 0)\n+\t    {\n+\t      fn = TREE_CHAIN (fn);\n+\t      if (! fn)\n+\t\treturn error_mark_node;\n+\t    }\n+\t  champ = TREE_VALUE (fn);\n+\t}\n+    }\n+\n+  for (fn = fns; fn && TREE_VALUE (fn) != champ; fn = TREE_CHAIN (fn))\n+    {\n+      fate = more_specialized (champ, TREE_VALUE (fn));\n+      if (fate != 1)\n+\treturn error_mark_node;\n+    }\n+\n+  return champ;\n+}\n+\n+/* Return the most specialized of the class template specializations in\n+   SPECS that can produce an instantiation matching ARGS.  */\n+\n+tree\n+most_specialized_class (specs, mainargs)\n+     tree specs, mainargs;\n+{\n+  tree list = NULL_TREE, t, args, champ;\n+  int fate;\n+\n+  for (t = specs; t; t = TREE_CHAIN (t))\n+    {\n+      args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), mainargs);\n+      if (args)\n+\t{\n+\t  list = decl_tree_cons (TREE_PURPOSE (t), TREE_VALUE (t), list);\n+\t  TREE_TYPE (list) = TREE_TYPE (t);\n+\t}\n+    }\n+\n+  if (! list)\n+    return NULL_TREE;\n+\n+  t = list;\n+  champ = t;\n+  t = TREE_CHAIN (t);\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      fate = more_specialized_class (champ, t);\n+      if (fate == 1)\n+\t;\n+      else\n+\t{\n+\t  if (fate == 0)\n+\t    {\n+\t      t = TREE_CHAIN (t);\n+\t      if (! t)\n+\t\treturn error_mark_node;\n+\t    }\n+\t  champ = t;\n+\t}\n+    }\n+\n+  for (t = list; t && t != champ; t = TREE_CHAIN (t))\n+    {\n+      fate = more_specialized (champ, t);\n+      if (fate != 1)\n+\treturn error_mark_node;\n+    }\n+\n+  return champ;\n+}\n+\n /* called from the parser.  */\n \n void\n@@ -2844,6 +3078,7 @@ do_function_instantiation (declspecs, declarator, storage)\n     }\n   else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n     {\n+      tree templates = NULL_TREE;\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n \tif (decls_match (fn, decl)\n \t    && DECL_DEFER_OUTPUT (fn))\n@@ -2852,31 +3087,30 @@ do_function_instantiation (declspecs, declarator, storage)\n \t    break;\n \t  }\n \telse if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t  {\n-\t    int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n-\t    tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n-\t    int i, dummy = 0;\n-\t    i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n-\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (fn)),\n-\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t\t  &dummy, 0, 1);\n-\t    if (i == 0)\n-\t      {\n-\t\tif (result)\n-\t\t  {\n-\t\t    int win = more_specialized (DECL_TI_TEMPLATE (result), fn);\n-\n-\t\t    if (win == 0)\n-\t\t      cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n-\t\t    else if (win == -1)\n-\t\t      result = instantiate_template (fn, targs);\n-\t\t    /* else keep current winner */\n-\t\t  }\n-\t\telse\n-\t\t  result = instantiate_template (fn, targs);\n-\t      }\n-\t    free (targs);\n-\t  }\n+\t  templates = decl_tree_cons (NULL_TREE, fn, templates);\n+\n+      if (! result)\n+\t{\n+\t  tree *args;\n+\t  result = most_specialized (templates, decl);\n+\t  if (result == error_mark_node)\n+\t    {\n+\t      char *str = \"candidates are:\";\n+\t      cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n+\t      for (fn = templates; fn; fn = TREE_CHAIN (fn))\n+\t\t{\n+\t\t  cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n+\t\t  str = \"               \";\n+\t\t}\n+\t      return;\n+\t    }\n+\t  else if (result)\n+\t    {\n+\t      args = get_bindings (result, decl);\n+\t      result = instantiate_template (result, args);\n+\t      free (args);\n+\t    }\n+\t}\n     }\n   if (! result)\n     {\n@@ -3195,3 +3429,31 @@ add_tree (t)\n {\n   last_tree = TREE_CHAIN (last_tree) = t;\n }\n+\n+/* D is an undefined function declaration in the presence of templates with\n+   the same name, listed in FNS.  If one of them can produce D as an\n+   instantiation, remember this so we can instantiate it at EOF if D has\n+   not been defined by that time.  */\n+\n+void\n+add_maybe_template (d, fns)\n+     tree d, fns;\n+{\n+  tree t;\n+\n+  if (DECL_MAYBE_TEMPLATE (d))\n+    return;\n+\n+  t = most_specialized (fns, d);\n+  if (! t)\n+    return;\n+  if (t == error_mark_node)\n+    {\n+      cp_error (\"ambiguous template instantiation for `%D'\", d);\n+      return;\n+    }\n+\n+  *maybe_template_tail = perm_tree_cons (t, d, NULL_TREE);\n+  maybe_template_tail = &TREE_CHAIN (*maybe_template_tail);\n+  DECL_MAYBE_TEMPLATE (d) = 1;\n+}"}, {"sha": "4551177ab3c230350cde454a8d04b0a9d784c5f7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -1772,8 +1772,21 @@ bot_manip (t)\n   if (TREE_CODE (t) != TREE_LIST && ! TREE_SIDE_EFFECTS (t))\n     return t;\n   else if (TREE_CODE (t) == TARGET_EXPR)\n-    return build_cplus_new (TREE_TYPE (t),\n-\t\t\t    break_out_target_exprs (TREE_OPERAND (t, 1)));\n+    {\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == NEW_EXPR)\n+\t{\n+\t  mark_used (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 1), 0), 0));\n+\t  return build_cplus_new\n+\t    (TREE_TYPE (t), break_out_target_exprs (TREE_OPERAND (t, 1)));\n+\t}\n+      t = copy_node (t);\n+      TREE_OPERAND (t, 0) = build (VAR_DECL, TREE_TYPE (t));\n+      layout_decl (TREE_OPERAND (t, 0), 0);\n+      return t;\n+    }\n+  else if (TREE_CODE (t) == CALL_EXPR)\n+    mark_used (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\n   return NULL_TREE;\n }\n   \n@@ -2078,3 +2091,17 @@ cp_tree_equal (t1, t2)\n \n   return -1;\n }\n+\n+/* Similar to make_tree_vec, but build on a temporary obstack.  */\n+\n+tree\n+make_temp_vec (len)\n+     int len;\n+{\n+  register tree node;\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+  node = make_tree_vec (len);\n+  pop_obstacks ();\n+  return node;\n+}"}, {"sha": "f2f069bbc45aa7f4d3cf496df31911bdb6ef83d6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73aad9b9ff694fcaf423834d7e2c47046cac34cd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=73aad9b9ff694fcaf423834d7e2c47046cac34cd", "patch": "@@ -2545,15 +2545,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t needs to be separately compiled).  */\n \n       if (DECL_INLINE (function))\n-\t{\n-\t  /* Is it a synthesized method that needs to be synthesized?  */\n-\t  if (DECL_ARTIFICIAL (function) && ! DECL_INITIAL (function)\n-\t      /* Kludge: don't synthesize for default args.  */\n-\t      && current_function_decl)\n-\t    synthesize_method (function);\n-\n-\t  function = inline_conversion (function);\n-\t}\n+\tfunction = inline_conversion (function);\n       else\n \tfunction = build_addr_func (function);\n     }"}]}