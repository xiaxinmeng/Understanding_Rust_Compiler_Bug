{"sha": "ba6739078139fc22634a0b45c4c34147a14665df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE2NzM5MDc4MTM5ZmMyMjYzNGEwYjQ1YzRjMzQxNDdhMTQ2NjVkZg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-15T09:37:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:37:10Z"}, "message": "einfo.ads, einfo.adb (First_Tag_Component): Protect the frontend against errors in the source program...\n\n2006-02-13  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* einfo.ads, einfo.adb (First_Tag_Component): Protect the frontend\n\tagainst errors in the source program: a private types for which the\n\tcorresponding full type declaration is missing and pragma CPP_Virtual\n\tis used.\n\t(Is_Unchecked_Union): Check flag on Implementation_Base_Type.\n\t(Is_Known_Null): New flag\n\t(Has_Pragma_Pure): New flag\n\t(No_Return): Present in all entities, set only for procedures\n\t(Is_Limited_Type): A type whose ancestor is an interface is limited if\n\texplicitly declared limited.\n\t(DT_Offset_To_Top_Func): New attribute that is present in E_Component\n\tentities. Only used for component marked Is_Tag. If present it stores\n\tthe Offset_To_Top function used to provide this value in tagged types\n\twhose ancestor has discriminants.\n\n\t* exp_ch2.adb: Update status of new Is_Known_Null flag\n\n\t* sem_ch7.adb: Maintain status of new Is_Known_Null flag\n\n\t* sem_cat.adb (Get_Categorization): Don't treat function as Pure in\n\tthe categorization sense if Is_Pure was set by pragma Pure_Function.\n\nFrom-SVN: r111055", "tree": {"sha": "2466e63ba49637bfbc14d86f34bd4a00ef77ddd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2466e63ba49637bfbc14d86f34bd4a00ef77ddd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba6739078139fc22634a0b45c4c34147a14665df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba6739078139fc22634a0b45c4c34147a14665df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba6739078139fc22634a0b45c4c34147a14665df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba6739078139fc22634a0b45c4c34147a14665df/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f6a2b51d1d0c2a3a835cc47d34c0c52b0f56945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6a2b51d1d0c2a3a835cc47d34c0c52b0f56945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6a2b51d1d0c2a3a835cc47d34c0c52b0f56945"}], "stats": {"total": 393, "additions": 217, "deletions": 176}, "files": [{"sha": "c9361f152c3df1173b90d178977fbf23c1e58774", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ba6739078139fc22634a0b45c4c34147a14665df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -209,6 +209,7 @@ package body Einfo is\n    --    Privals_Chain                   Elist23\n    --    Protected_Operation             Node23\n \n+   --    DT_Offset_To_Top_Func           Node24\n    --    Obsolescent_Warning             Node24\n    --    Task_Body_Procedure             Node24\n    --    Abstract_Interfaces             Elist24\n@@ -453,9 +454,9 @@ package body Einfo is\n \n    --    Has_Anon_Block_Suffix          Flag201\n    --    Itype_Printed                  Flag202\n+   --    Has_Pragma_Pure                Flag203\n+   --    Is_Known_Null                  Flag204\n \n-   --    (unused)                       Flag203\n-   --    (unused)                       Flag204\n    --    (unused)                       Flag205\n    --    (unused)                       Flag206\n    --    (unused)                       Flag207\n@@ -832,6 +833,12 @@ package body Einfo is\n       return Uint15 (Id);\n    end DT_Entry_Count;\n \n+   function DT_Offset_To_Top_Func (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Component and then Is_Tag (Id));\n+      return Node24 (Id);\n+   end DT_Offset_To_Top_Func;\n+\n    function DT_Position (Id : E) return U is\n    begin\n       pragma Assert\n@@ -1256,9 +1263,13 @@ package body Einfo is\n       return Flag121 (Implementation_Base_Type (Id));\n    end Has_Pragma_Pack;\n \n+   function Has_Pragma_Pure (Id : E) return B is\n+   begin\n+      return Flag203 (Id);\n+   end Has_Pragma_Pure;\n+\n    function Has_Pragma_Pure_Function (Id : E) return B is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n       return Flag179 (Id);\n    end Has_Pragma_Pure_Function;\n \n@@ -1666,6 +1677,11 @@ package body Einfo is\n       return Flag37 (Id);\n    end Is_Known_Non_Null;\n \n+   function Is_Known_Null (Id : E) return B is\n+   begin\n+      return Flag204 (Id);\n+   end Is_Known_Null;\n+\n    function Is_Known_Valid (Id : E) return B is\n    begin\n       return Flag170 (Id);\n@@ -1848,7 +1864,7 @@ package body Einfo is\n \n    function Is_Unchecked_Union (Id : E) return B is\n    begin\n-      return Flag117 (Id);\n+      return Flag117 (Implementation_Base_Type (Id));\n    end Is_Unchecked_Union;\n \n    function Is_Unsigned_Type (Id : E) return B is\n@@ -1995,10 +2011,6 @@ package body Einfo is\n \n    function No_Return (Id : E) return B is\n    begin\n-      pragma Assert\n-        (Id = Any_Id\n-          or else Ekind (Id) = E_Procedure\n-          or else Ekind (Id) = E_Generic_Procedure);\n       return Flag113 (Id);\n    end No_Return;\n \n@@ -2931,6 +2943,12 @@ package body Einfo is\n       Set_Uint15 (Id, V);\n    end Set_DT_Entry_Count;\n \n+   procedure Set_DT_Offset_To_Top_Func (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Component and then Is_Tag (Id));\n+      Set_Node24 (Id, V);\n+   end Set_DT_Offset_To_Top_Func;\n+\n    procedure Set_DT_Position (Id : E; V : U) is\n    begin\n       pragma Assert (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure);\n@@ -3362,9 +3380,13 @@ package body Einfo is\n       Set_Flag121 (Id, V);\n    end Set_Has_Pragma_Pack;\n \n+   procedure Set_Has_Pragma_Pure (Id : E; V : B := True) is\n+   begin\n+      Set_Flag203 (Id, V);\n+   end Set_Has_Pragma_Pure;\n+\n    procedure Set_Has_Pragma_Pure_Function (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n       Set_Flag179 (Id, V);\n    end Set_Has_Pragma_Pure_Function;\n \n@@ -3799,6 +3821,11 @@ package body Einfo is\n       Set_Flag37 (Id, V);\n    end Set_Is_Known_Non_Null;\n \n+   procedure Set_Is_Known_Null (Id : E; V : B := True) is\n+   begin\n+      Set_Flag204 (Id, V);\n+   end Set_Is_Known_Null;\n+\n    procedure Set_Is_Known_Valid (Id : E; V : B := True) is\n    begin\n       Set_Flag170 (Id, V);\n@@ -4134,7 +4161,9 @@ package body Einfo is\n    procedure Set_No_Return (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        (Ekind (Id) = E_Procedure or else Ekind (Id) = E_Generic_Procedure);\n+        (V = False\n+          or else Ekind (Id) = E_Procedure\n+          or else Ekind (Id) = E_Generic_Procedure);\n       Set_Flag113 (Id, V);\n    end Set_No_Return;\n \n@@ -5749,6 +5778,16 @@ package body Einfo is\n       elsif Is_Concurrent_Type (Btype) then\n          return True;\n \n+         --  The Is_Limited_Record flag normally indicates that the type is\n+         --  limited. The exception is that a type does not inherit limitedness\n+         --  from its interface ancestor. So the type may be derived from a\n+         --  limited interface, but is not limited.\n+\n+      elsif Is_Limited_Record (Id)\n+        and then not Is_Interface (Id)\n+      then\n+         return True;\n+\n       --  Otherwise we will look around to see if there is some other reason\n       --  for it to be limited, except that if an error was posted on the\n       --  entity, then just assume it is non-limited, because it can cause\n@@ -5967,7 +6006,7 @@ package body Einfo is\n \n       loop\n          D := Next_Entity (D);\n-         if not Present (D)\n+         if No (D)\n            or else (Ekind (D) /= E_Discriminant\n                       and then not Is_Itype (D))\n          then\n@@ -6382,6 +6421,14 @@ package body Einfo is\n \n       if Is_Private_Type (Typ) then\n          Typ := Underlying_Type (Typ);\n+\n+         --  If the underlying type is missing then the source program has\n+         --  errors and there is nothing else to do (the full-type declaration\n+         --  associated with the private type declaration is missing).\n+\n+         if No (Typ) then\n+            return Empty;\n+         end if;\n       end if;\n \n       Comp := First_Entity (Typ);\n@@ -6613,6 +6660,7 @@ package body Einfo is\n       W (\"Has_Pragma_Elaborate_Body\",     Flag150 (Id));\n       W (\"Has_Pragma_Inline\",             Flag157 (Id));\n       W (\"Has_Pragma_Pack\",               Flag121 (Id));\n+      W (\"Has_Pragma_Pure\",               Flag203 (Id));\n       W (\"Has_Pragma_Pure_Function\",      Flag179 (Id));\n       W (\"Has_Pragma_Unreferenced\",       Flag180 (Id));\n       W (\"Has_Primitive_Operations\",      Flag120 (Id));\n@@ -6684,7 +6732,8 @@ package body Einfo is\n       W (\"Is_Interrupt_Handler\",          Flag89  (Id));\n       W (\"Is_Intrinsic_Subprogram\",       Flag64  (Id));\n       W (\"Is_Itype\",                      Flag91  (Id));\n-      W (\"Is_Known_Valid\",                Flag37  (Id));\n+      W (\"Is_Known_Non_Null\",             Flag37  (Id));\n+      W (\"Is_Known_Null\",                 Flag204 (Id));\n       W (\"Is_Known_Valid\",                Flag170 (Id));\n       W (\"Is_Limited_Composite\",          Flag106 (Id));\n       W (\"Is_Limited_Interface\",          Flag197 (Id));\n@@ -7638,6 +7687,9 @@ package body Einfo is\n               E_Record_Subtype_With_Private              =>\n             Write_Str (\"Abstract_Interfaces\");\n \n+         when E_Component                                =>\n+            Write_Str (\"DT_Offset_To_Top_Func\");\n+\n          when Subprogram_Kind                            |\n               E_Package                                  |\n               E_Generic_Package                          =>"}, {"sha": "b8a4c461ed28f3d461b5699d2252638ddc49d420", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ba6739078139fc22634a0b45c4c34147a14665df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -361,7 +361,7 @@ package Einfo is\n --       back-end for back annotation.\n \n --    Alignment_Clause (synthesized)\n---       Appllies to all entities for types and objects. If an alignment\n+--       Applies to all entities for types and objects. If an alignment\n --       attribute definition clause is present for the entity, then this\n --       function returns the N_Attribute_Definition clause that specifies the\n --       alignment. If no alignment clause applies to the type, then the call\n@@ -384,7 +384,13 @@ package Einfo is\n --       Present in all type and subtype entities. Set non-Empty only for\n --       Itypes. Set to point to the associated node for the Itype, i.e.\n --       the node whose elaboration generated the Itype. This is used for\n---       copying trees, to determine whether or not to copy an Itype.\n+--       copying trees, to determine whether or not to copy an Itype, and\n+--       also for accessibility checks on anonymous access types. This\n+--       node is typically an object declaration, component declaration,\n+--       type or subtype declaration. For an access discriminant in a type\n+--       declaration, the associated_node_for_itype is the discriminant\n+--       specification. For an access parameter it is the enclosing subprogram\n+--       declaration.\n \n --    Associated_Storage_Pool (Node22) [root type only]\n --       Present in simple and general access type entities. References the\n@@ -796,6 +802,11 @@ package Einfo is\n --       Present in E_Component entities. Only used for component marked\n --       Is_Tag. Store the number of entries in the Vtable (or Dispatch Table)\n \n+--    DT_Offset_To_Top_Func (Node24)\n+--       Present in E_Component entities. Only used for component marked\n+--       Is_Tag. If present it stores the Offset_To_Top function used to\n+--       provide this value in tagged types whose ancestor has discriminants.\n+\n --    DT_Position (Uint15)\n --       Present in function and procedure entities which are dispatching\n --       (should not be referenced without first checking that flag\n@@ -1142,7 +1153,7 @@ package Einfo is\n --       as First_Discriminant.\n --\n --       For derived non-tagged types that rename discriminants in the root\n---       type this is the first of the discriminants that occurr in the\n+--       type this is the first of the discriminants that occur in the\n --       root type. To be precise, in this case stored discriminants are\n --       entities attached to the entity chain of the derived type which\n --       are a copy of the discriminants of the root type. Furthermore their\n@@ -1159,6 +1170,10 @@ package Einfo is\n --       subtype of the type. For subtypes, yields the first subtype of\n --       the base type of the subtype.\n \n+--    First_Tag_Component (synthesized)\n+--       Applies to tagged record types, returns the entity for the first\n+--       _Tag field in this record.\n+\n --    Freeze_Node (Node7)\n --       Present in all entities. If there is an associated freeze node for\n --       the entity, this field references this freeze node. If no freeze\n@@ -1465,12 +1480,17 @@ package Einfo is\n --       for the entity.\n \n --    Has_Pragma_Pack (Flag121) [implementation base type only]\n---       Present in all entities. It indicates that a valid pragma Pack was\n---       was given for the type. Note that this flag is not inherited by a\n+--       Present in all entities. If set, indicates that a valid pragma Pack\n+--       was was given for the type. Note that this flag is not inherited by\n --       derived type. See also the Is_Packed flag.\n \n+--    Has_Pragma_Pure (Flag203)\n+--       Present in all entities. If set, indicates that a valid pragma Pure\n+--       was given for the entity. In some cases, we need to test whether\n+--       Is_Pure was explicitly set using this pragma.\n+\n --    Has_Pragma_Pure_Function (Flag179)\n---       Present in subprogram entities. It indicates that a valid pragma\n+--       Present in all entities. If set, indicates that a valid pragma\n --       Pure_Function was given for the entity. In some cases, we need to\n --       know that Is_Pure was explicitly set using this pragma.\n \n@@ -2052,7 +2072,7 @@ package Einfo is\n --       objects of an access type. It is set if the object is currently\n --       known to have a non-null value (meaning that no access checks\n --       are needed). The indication can for example come from assignment\n---       of an access parameter or an allocator.\n+--       of an access parameter or an allocator whose value is known non-null.\n --\n --       Note: this flag is set according to the sequential flow of the\n --       program, watching the current value of the variable. However,\n@@ -2068,6 +2088,16 @@ package Einfo is\n --       fully constructed, since it simply indicates the last state.\n --       Thus this flag has no meaning to the back end.\n \n+--    Is_Known_Null (Flag204)\n+--       Present in all entities. Relevant (and can be set True) only for\n+--       objects of an access type. It is set if the object is currently known\n+--       to have a null value (meaning that a dereference will surely raise\n+--       constraint error exception). The indication can come from an\n+--       assignment or object declaration.\n+--\n+--       The comments above about sequential flow and aliased and volatile for\n+--       the Is_Known_Non_Null flag apply equally to the Is_Known_Null flag.\n+\n --    Is_Known_Valid (Flag170)\n --       Present in all entities. Relevant for types (and subtype) and\n --       for objects (and enumeration literals) of a discrete type.\n@@ -2419,7 +2449,7 @@ package Einfo is\n --    Is_Type (synthesized)\n --       Applies to all entities, true for a type entity\n \n---    Is_Unchecked_Union (Flag117)\n+--    Is_Unchecked_Union (Flag117) [implementation base type only]\n --       Present in all entities. Set only in record types to which the\n --       pragma Unchecked_Union has been validly applied.\n \n@@ -2680,6 +2710,10 @@ package Einfo is\n --       Empty if applied to the last literal. This is actually a synonym\n --       for Next, but its use is preferred in this context.\n \n+--    Next_Tag_Component (synthesized)\n+--       Applies to components of tagged record types. Given a _Tag field\n+--       of a record, returns the next _Tag field in this record.\n+\n --    Non_Binary_Modulus (Flag58) [base type only]\n --       Present in modular integer types. Set if the modulus for the type\n --       is other than a power of 2.\n@@ -2702,8 +2736,8 @@ package Einfo is\n --       type, since derived types must have the same pool.\n \n --    No_Return (Flag113)\n---       Present in procedure and generic procedure entries. Indicates that\n---       a pragma No_Return applies to the procedure.\n+--       Present in all entities. Always false except in the case of procedures\n+--       and generic procedures for which a pragma No_Return is given.\n \n --    Normalized_First_Bit (Uint8)\n --       Present in components and discriminants. Indicates the normalized\n@@ -2985,7 +3019,7 @@ package Einfo is\n \n --    Returns_By_Ref (Flag90)\n --       Present in function entities, to indicate that the function\n---       returns the result by reference, either because its return typ is a\n+--       returns the result by reference, either because its return type is a\n --       by-reference-type or because it uses explicitly the secondary stack.\n \n --    Reverse_Bit_Order (Flag164) [base type only]\n@@ -3033,7 +3067,9 @@ package Einfo is\n --       Present in all entities. Points to the entity for the scope (block,\n --       loop, subprogram, package etc.) in which the entity is declared.\n --       Since this field is in the base part of the entity node, the access\n---       routines for this field are in Sinfo.\n+--       routines for this field are in Sinfo. Note that for a child package,\n+--       the Scope will be the parent package, and for a non-child package,\n+--       the Scope will be Standard.\n \n --    Scope_Depth (synth)\n --       Applies to program units, blocks, concurrent types and entries,\n@@ -3181,14 +3217,6 @@ package Einfo is\n --       bodies are expanded into procedures). A convenient function to\n --       retrieve this field is Sem_Util.Get_Task_Body_Procedure.\n \n---    First_Tag_Component (synthesized)\n---       Applies to tagged record types, returns the entity for the first\n---       _Tag field in this record.\n-\n---    Next_Tag_Component (synthesized)\n---       Applies to components of tagged record types. Given a _Tag field\n---       of a record, returns the next _Tag field in this record.\n-\n --    Treat_As_Volatile (Flag41)\n --       Present in all type entities, and also in constants, components and\n --       variables. Set if this entity is to be treated as volatile for code\n@@ -4054,6 +4082,8 @@ package Einfo is\n    --    Has_Persistent_BSS            (Flag188)\n    --    Has_Pragma_Elaborate_Body     (Flag150)\n    --    Has_Pragma_Inline             (Flag157)\n+   --    Has_Pragma_Pure               (Flag203)\n+   --    Has_Pragma_Pure_Function      (Flag179)\n    --    Has_Pragma_Unreferenced       (Flag180)\n    --    Has_Private_Declaration       (Flag155)\n    --    Has_Qualified_Name            (Flag161)\n@@ -4078,6 +4108,7 @@ package Einfo is\n    --    Is_Internal                   (Flag17)\n    --    Is_Itype                      (Flag91)\n    --    Is_Known_Non_Null             (Flag37)\n+   --    Is_Known_Null                 (Flag204)\n    --    Is_Known_Valid                (Flag170)\n    --    Is_Limited_Composite          (Flag106)\n    --    Is_Limited_Record             (Flag25)\n@@ -4100,6 +4131,7 @@ package Einfo is\n    --    Kill_Tag_Checks               (Flag34)\n    --    Materialize_Entity            (Flag168)\n    --    Needs_Debug_Info              (Flag147)\n+   --    No_Return                     (Flag113)\n    --    Referenced                    (Flag156)\n    --    Referenced_As_LHS             (Flag36)\n    --    Suppress_Elaboration_Warnings (Flag148)\n@@ -4296,6 +4328,7 @@ package Einfo is\n    --    Interface_Name                (Node21)   (JGNAT usage only)\n    --    Original_Record_Component     (Node22)\n    --    Protected_Operation           (Node23)\n+   --    DT_Offset_To_Top_Func         (Node24)\n    --    Has_Biased_Representation     (Flag139)\n    --    Has_Per_Object_Constraint     (Flag154)\n    --    Is_Atomic                     (Flag85)\n@@ -4474,7 +4507,6 @@ package Einfo is\n    --    Has_Master_Entity             (Flag21)\n    --    Has_Missing_Return            (Flag142)\n    --    Has_Nested_Block_With_Handler (Flag101)\n-   --    Has_Pragma_Pure_Function      (Flag179)  (non-generic case only)\n    --    Has_Recursive_Call            (Flag143)\n    --    Has_Subprogram_Descriptor     (Flag93)\n    --    Is_Abstract                   (Flag19)\n@@ -4604,7 +4636,6 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram       (Flag64)\n    --    Is_Overriding_Operation       (Flag39)\n    --    Default_Expressions_Processed (Flag108)\n-   --    Has_Pragma_Pure_Function      (Flag179)\n \n    --  E_Ordinary_Fixed_Point_Type\n    --  E_Ordinary_Fixed_Point_Subtype\n@@ -4712,7 +4743,6 @@ package Einfo is\n    --    Abstract_Interface_Alias      (Node25)\n    --    Overridden_Operation          (Node26)\n    --    Wrapped_Entity                (Node27)   (non-generic case only)\n-\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)  (always False for procedure)\n@@ -4723,7 +4753,6 @@ package Einfo is\n    --    Has_Completion                (Flag26)\n    --    Has_Master_Entity             (Flag21)\n    --    Has_Nested_Block_With_Handler (Flag101)\n-   --    Has_Pragma_Pure_Function      (Flag179)  (non-generic case only)\n    --    Has_Subprogram_Descriptor     (Flag93)\n    --    Is_Visible_Child_Unit         (Flag116)\n    --    Is_Abstract                   (Flag19)\n@@ -4738,7 +4767,6 @@ package Einfo is\n    --    Is_Null_Init_Proc             (Flag178)\n    --    Is_Overriding_Operation       (Flag39)   (non-generic case only)\n    --    Is_Primitive_Wrapper          (Flag195)  (non-generic case only)\n-\n    --    Is_Private_Descendant         (Flag53)\n    --    Is_Pure                       (Flag44)\n    --    Is_Thread_Body                (Flag77)   (non-generic case only)\n@@ -5192,6 +5220,7 @@ package Einfo is\n    function Debug_Renaming_Link                (Id : E) return E;\n    function DTC_Entity                         (Id : E) return E;\n    function DT_Entry_Count                     (Id : E) return U;\n+   function DT_Offset_To_Top_Func              (Id : E) return E;\n    function DT_Position                        (Id : E) return U;\n    function Default_Expr_Function              (Id : E) return E;\n    function Default_Expressions_Processed      (Id : E) return B;\n@@ -5283,6 +5312,7 @@ package Einfo is\n    function Has_Pragma_Elaborate_Body          (Id : E) return B;\n    function Has_Pragma_Inline                  (Id : E) return B;\n    function Has_Pragma_Pack                    (Id : E) return B;\n+   function Has_Pragma_Pure                    (Id : E) return B;\n    function Has_Pragma_Pure_Function           (Id : E) return B;\n    function Has_Pragma_Unreferenced            (Id : E) return B;\n    function Has_Primitive_Operations           (Id : E) return B;\n@@ -5354,6 +5384,7 @@ package Einfo is\n    function Is_Intrinsic_Subprogram            (Id : E) return B;\n    function Is_Itype                           (Id : E) return B;\n    function Is_Known_Non_Null                  (Id : E) return B;\n+   function Is_Known_Null                      (Id : E) return B;\n    function Is_Known_Valid                     (Id : E) return B;\n    function Is_Limited_Composite               (Id : E) return B;\n    function Is_Limited_Interface               (Id : E) return B;\n@@ -5691,6 +5722,7 @@ package Einfo is\n    procedure Set_Debug_Renaming_Link           (Id : E; V : E);\n    procedure Set_DTC_Entity                    (Id : E; V : E);\n    procedure Set_DT_Entry_Count                (Id : E; V : U);\n+   procedure Set_DT_Offset_To_Top_Func         (Id : E; V : E);\n    procedure Set_DT_Position                   (Id : E; V : U);\n    procedure Set_Default_Expr_Function         (Id : E; V : E);\n    procedure Set_Default_Expressions_Processed (Id : E; V : B := True);\n@@ -5780,6 +5812,7 @@ package Einfo is\n    procedure Set_Has_Pragma_Elaborate_Body     (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline             (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pack               (Id : E; V : B := True);\n+   procedure Set_Has_Pragma_Pure               (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Pure_Function      (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Unreferenced       (Id : E; V : B := True);\n    procedure Set_Has_Primitive_Operations      (Id : E; V : B := True);\n@@ -5856,6 +5889,7 @@ package Einfo is\n    procedure Set_Is_Intrinsic_Subprogram       (Id : E; V : B := True);\n    procedure Set_Is_Itype                      (Id : E; V : B := True);\n    procedure Set_Is_Known_Non_Null             (Id : E; V : B := True);\n+   procedure Set_Is_Known_Null                 (Id : E; V : B := True);\n    procedure Set_Is_Known_Valid                (Id : E; V : B := True);\n    procedure Set_Is_Limited_Composite          (Id : E; V : B := True);\n    procedure Set_Is_Limited_Interface          (Id : E; V : B := True);\n@@ -6244,6 +6278,7 @@ package Einfo is\n    pragma Inline (Debug_Renaming_Link);\n    pragma Inline (DTC_Entity);\n    pragma Inline (DT_Entry_Count);\n+   pragma Inline (DT_Offset_To_Top_Func);\n    pragma Inline (DT_Position);\n    pragma Inline (Default_Expr_Function);\n    pragma Inline (Default_Expressions_Processed);\n@@ -6333,6 +6368,7 @@ package Einfo is\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n    pragma Inline (Has_Pragma_Pack);\n+   pragma Inline (Has_Pragma_Pure);\n    pragma Inline (Has_Pragma_Pure_Function);\n    pragma Inline (Has_Pragma_Unreferenced);\n    pragma Inline (Has_Primitive_Operations);\n@@ -6429,6 +6465,7 @@ package Einfo is\n    pragma Inline (Is_Intrinsic_Subprogram);\n    pragma Inline (Is_Itype);\n    pragma Inline (Is_Known_Non_Null);\n+   pragma Inline (Is_Known_Null);\n    pragma Inline (Is_Known_Valid);\n    pragma Inline (Is_Limited_Composite);\n    pragma Inline (Is_Limited_Interface);\n@@ -6616,6 +6653,8 @@ package Einfo is\n    pragma Inline (Set_Debug_Info_Off);\n    pragma Inline (Set_Debug_Renaming_Link);\n    pragma Inline (Set_DTC_Entity);\n+   pragma Inline (Set_DT_Entry_Count);\n+   pragma Inline (Set_DT_Offset_To_Top_Func);\n    pragma Inline (Set_DT_Position);\n    pragma Inline (Set_Default_Expr_Function);\n    pragma Inline (Set_Default_Expressions_Processed);\n@@ -6703,6 +6742,7 @@ package Einfo is\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n    pragma Inline (Set_Has_Pragma_Pack);\n+   pragma Inline (Set_Has_Pragma_Pure);\n    pragma Inline (Set_Has_Pragma_Pure_Function);\n    pragma Inline (Set_Has_Pragma_Unreferenced);\n    pragma Inline (Set_Has_Primitive_Operations);\n@@ -6778,6 +6818,7 @@ package Einfo is\n    pragma Inline (Set_Is_Intrinsic_Subprogram);\n    pragma Inline (Set_Is_Itype);\n    pragma Inline (Set_Is_Known_Non_Null);\n+   pragma Inline (Set_Is_Known_Null);\n    pragma Inline (Set_Is_Known_Valid);\n    pragma Inline (Set_Is_Limited_Composite);\n    pragma Inline (Set_Is_Limited_Interface);"}, {"sha": "255c0db7fb9f441a43cfaaf36f2e6720d713ea04", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 66, "deletions": 132, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=ba6739078139fc22634a0b45c4c34147a14665df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,7 +25,6 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -42,7 +41,6 @@ with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n-with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -53,13 +51,12 @@ package body Exp_Ch2 is\n    -----------------------\n \n    procedure Expand_Current_Value (N : Node_Id);\n-   --  Given a node N for a variable whose Current_Value field is set.\n-   --  If the node is for a discrete type, replaces the node with a\n-   --  copy of the referenced value. This provides a limited form of\n-   --  value propagation for variables which are initialized or assigned\n-   --  not been further modified at the time of reference. The call has\n-   --  no effect if the Current_Value refers to a conditional with a\n-   --  condition other than equality.\n+   --  N is a node for a variable whose Current_Value field is set. If N is\n+   --  node is for a discrete type, replaces node with a copy of the referenced\n+   --  value. This provides a limited form of value propagation for variables\n+   --  which are initialized or assigned not been further modified at the time\n+   --  of reference. The call has no effect if the Current_Value refers to a\n+   --  conditional with condition other than equality.\n \n    procedure Expand_Discriminant (N : Node_Id);\n    --  An occurrence of a discriminant within a discriminated type is replaced\n@@ -69,42 +66,42 @@ package body Exp_Ch2 is\n    --  discriminants of records that appear in constraints of component of the\n    --  record, because Gigi uses the discriminant name to retrieve its value.\n    --  In the other hand, it has to be performed for default expressions of\n-   --  components because they are used in the record init procedure. See\n-   --  Einfo for more details, and Exp_Ch3, Exp_Ch9 for examples of use.\n-   --  For discriminants of tasks and protected types, the transformation is\n-   --  more complex when it occurs within a default expression for an entry\n-   --  or protected operation. The corresponding default_expression_function\n-   --  has an additional parameter which is the target of an entry call, and\n-   --  the discriminant of the task must be replaced with a reference to the\n+   --  components because they are used in the record init procedure. See Einfo\n+   --  for more details, and Exp_Ch3, Exp_Ch9 for examples of use. For\n+   --  discriminants of tasks and protected types, the transformation is more\n+   --  complex when it occurs within a default expression for an entry or\n+   --  protected operation. The corresponding default_expression_function has\n+   --  an additional parameter which is the target of an entry call, and the\n+   --  discriminant of the task must be replaced with a reference to the\n    --  discriminant of that formal parameter.\n \n    procedure Expand_Entity_Reference (N : Node_Id);\n    --  Common processing for expansion of identifiers and expanded names\n \n    procedure Expand_Entry_Index_Parameter (N : Node_Id);\n-   --  A reference to the identifier in the entry index specification\n-   --  of a protected entry body is modified to a reference to a constant\n-   --  definintion equal to the index of the entry family member being\n-   --  called. This constant is calculated as part of the elaboration\n-   --  of the expanded code for the body, and is calculated from the\n-   --  object-wide entry index returned by Next_Entry_Call.\n+   --  A reference to the identifier in the entry index specification of\n+   --  protected entry body is modified to a reference to a constant definition\n+   --  equal to the index of the entry family member being called. This\n+   --  constant is calculated as part of the elaboration of the expanded code\n+   --  for the body, and is calculated from the object-wide entry index\n+   --  returned by Next_Entry_Call.\n \n    procedure Expand_Entry_Parameter (N : Node_Id);\n-   --  A reference to an entry parameter is modified to be a reference to\n-   --  the corresponding component of the entry parameter record that is\n-   --  passed by the runtime to the accept body procedure\n+   --  A reference to an entry parameter is modified to be a reference to the\n+   --  corresponding component of the entry parameter record that is passed by\n+   --  the runtime to the accept body procedure\n \n    procedure Expand_Formal (N : Node_Id);\n-   --  A reference to a formal parameter of a protected subprogram is\n-   --  expanded to the corresponding formal of the unprotected procedure\n-   --  used to represent the protected subprogram within the protected object.\n+   --  A reference to a formal parameter of a protected subprogram is expanded\n+   --  to the corresponding formal of the unprotected procedure used to\n+   --  represent the protected subprogram within the protected object.\n \n    procedure Expand_Protected_Private (N : Node_Id);\n-   --  A reference to a private object of a protected type is expanded\n-   --  to a component selected from the record used to implement\n-   --  the protected object. Such a record is passed to all operations\n-   --  on a protected object in a parameter named _object. Such an object\n-   --  is a constant within a function, and a variable otherwise.\n+   --  A reference to a private object of a protected type is expanded to a\n+   --  component selected from the record used to implement the protected\n+   --  object. Such a record is passed to all operations on a protected object\n+   --  in a parameter named _object. Such an object is a constant within a\n+   --  function, and a variable otherwise.\n \n    procedure Expand_Renaming (N : Node_Id);\n    --  For renamings, just replace the identifier by the corresponding\n@@ -124,51 +121,6 @@ package body Exp_Ch2 is\n       Val : Node_Id;\n       Op  : Node_Kind;\n \n-      function In_Appropriate_Scope return Boolean;\n-      --  Returns true if the current scope is the scope of E, or is a nested\n-      --  (to any level) package declaration, package body, or block of this\n-      --  scope. The idea is that such references are in the sequential\n-      --  execution sequence of statements executed after E is elaborated.\n-\n-      --------------------------\n-      -- In_Appropriate_Scope --\n-      --------------------------\n-\n-      function In_Appropriate_Scope return Boolean is\n-         ES : constant Entity_Id := Scope (E);\n-         CS : Entity_Id;\n-\n-      begin\n-         CS := Current_Scope;\n-\n-         loop\n-            --  If we are in right scope, replacement is safe\n-\n-            if CS = ES then\n-               return True;\n-\n-            --  Packages do not affect the determination of safety\n-\n-            elsif Ekind (CS) = E_Package then\n-               CS := Scope (CS);\n-               exit when CS = Standard_Standard;\n-\n-            --  Blocks do not affect the determination of safety\n-\n-            elsif Ekind (CS) = E_Block then\n-               CS := Scope (CS);\n-\n-            --  Otherwise, the reference is dubious, and we cannot be\n-            --  sure that it is safe to do the replacement.\n-\n-            else\n-               exit;\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end In_Appropriate_Scope;\n-\n    --  Start of processing for Expand_Current_Value\n \n    begin\n@@ -191,25 +143,9 @@ package body Exp_Ch2 is\n \n          and then not Is_Lvalue (N)\n \n-         --  Do not replace occurrences that are not in the current scope,\n-         --  because in a nested subprogram we know absolutely nothing about\n-         --  the sequence of execution.\n-\n-         and then In_Appropriate_Scope\n-\n-         --  Do not replace statically allocated objects, because they may\n-         --  be modified outside the current scope.\n-\n-         and then not Is_Statically_Allocated (E)\n-\n-         --  Do not replace aliased or volatile objects, since we don't know\n-         --  what else might change the value\n-\n-         and then not Is_Aliased (E) and then not Treat_As_Volatile (E)\n-\n-         --  Debug flag -gnatdM disconnects this optimization\n+         --  Check that entity is suitable for replacement\n \n-         and then not Debug_Flag_MM\n+         and then OK_To_Do_Constant_Replacement (E)\n \n          --  Do not replace occurrences in pragmas (where names typically\n          --  appear not as values, but as simply names. If there are cases\n@@ -316,11 +252,11 @@ package body Exp_Ch2 is\n             Parent_P := Parent (Parent_P);\n          end loop;\n \n-         --  If the discriminant occurs within the default expression for\n-         --  a formal of an entry or protected operation, create a default\n-         --  function for it, and replace the discriminant with a reference\n-         --  to the discriminant of the formal of the default function.\n-         --  The discriminant entity is the one defined in the corresponding\n+         --  If the discriminant occurs within the default expression for a\n+         --  formal of an entry or protected operation, create a default\n+         --  function for it, and replace the discriminant with a reference to\n+         --  the discriminant of the formal of the default function. The\n+         --  discriminant entity is the one defined in the corresponding\n          --  record.\n \n          if Present (Parent_P)\n@@ -422,8 +358,8 @@ package body Exp_Ch2 is\n       then\n          Expand_Current_Value (N);\n \n-         --  We do want to warn for the case of a boolean variable (not\n-         --  a boolean constant) whose value is known at compile time.\n+         --  We do want to warn for the case of a boolean variable (not a\n+         --  boolean constant) whose value is known at compile time.\n \n          if Is_Boolean_Type (Etype (N)) then\n             Warn_On_Known_Condition (N);\n@@ -454,8 +390,8 @@ package body Exp_Ch2 is\n       P_Comp_Ref : Entity_Id;\n \n       function In_Assignment_Context (N : Node_Id) return Boolean;\n-      --  Check whether this is a context in which the entry formal may\n-      --  be assigned to.\n+      --  Check whether this is a context in which the entry formal may be\n+      --  assigned to.\n \n       ---------------------------\n       -- In_Assignment_Context --\n@@ -491,13 +427,12 @@ package body Exp_Ch2 is\n       if Is_Task_Type (Scope (Ent_Spec))\n         and then Comes_From_Source (Ent_Formal)\n       then\n-         --  Before replacing the formal with the local renaming that is\n-         --  used in the accept block, note if this is an assignment\n-         --  context, and note the modification to avoid spurious warnings,\n-         --  because the original entity is not used further.\n-         --  If the formal is unconstrained, we also generate an extra\n-         --  parameter to hold the Constrained attribute of the actual. No\n-         --  renaming is generated for this flag.\n+         --  Before replacing the formal with the local renaming that is used\n+         --  in the accept block, note if this is an assignment context, and\n+         --  note the modification to avoid spurious warnings, because the\n+         --  original entity is not used further. If formal is unconstrained,\n+         --  we also generate an extra parameter to hold the Constrained\n+         --  attribute of the actual. No renaming is generated for this flag.\n \n          if Ekind (Entity (N)) /= E_In_Parameter\n            and then In_Assignment_Context (N)\n@@ -510,11 +445,11 @@ package body Exp_Ch2 is\n       end if;\n \n       --  What we need is a reference to the corresponding component of the\n-      --  parameter record object. The Accept_Address field of the entry\n-      --  entity references the address variable that contains the address\n-      --  of the accept parameters record. We first have to do an unchecked\n-      --  conversion to turn this into a pointer to the parameter record and\n-      --  then we select the required parameter field.\n+      --  parameter record object. The Accept_Address field of the entry entity\n+      --  references the address variable that contains the address of the\n+      --  accept parameters record. We first have to do an unchecked conversion\n+      --  to turn this into a pointer to the parameter record and then we\n+      --  select the required parameter field.\n \n       P_Comp_Ref :=\n         Make_Selected_Component (Loc,\n@@ -525,11 +460,10 @@ package body Exp_Ch2 is\n           Selector_Name =>\n             New_Reference_To (Entry_Component (Ent_Formal), Loc));\n \n-      --  For all types of parameters, the constructed parameter record\n-      --  object contains a pointer to the parameter. Thus we must\n-      --  dereference them to access them (this will often be redundant,\n-      --  since the needed deference is implicit, but no harm is done by\n-      --  making it explicit).\n+      --  For all types of parameters, the constructed parameter record object\n+      --  contains a pointer to the parameter. Thus we must dereference them to\n+      --  access them (this will often be redundant, since the needed deference\n+      --  is implicit, but no harm is done by making it explicit).\n \n       Rewrite (N,\n         Make_Explicit_Dereference (Loc, P_Comp_Ref));\n@@ -655,8 +589,8 @@ package body Exp_Ch2 is\n          end if;\n       end if;\n \n-      --  The type of the reference is the type of the prival, which may\n-      --  differ from that of the original component if it is an itype.\n+      --  The type of the reference is the type of the prival, which may differ\n+      --  from that of the original component if it is an itype.\n \n       Set_Entity (N, Prival (E));\n       Set_Etype  (N, Etype (Prival (E)));\n@@ -682,10 +616,10 @@ package body Exp_Ch2 is\n    begin\n       Rewrite (N, New_Copy_Tree (Renamed_Object (E)));\n \n-      --  We mark the copy as unanalyzed, so that it is sure to be\n-      --  reanalyzed at the top level. This is needed in the packed\n-      --  case since we specifically avoided expanding packed array\n-      --  references when the renaming declaration was analyzed.\n+      --  We mark the copy as unanalyzed, so that it is sure to be reanalyzed\n+      --  at the top level. This is needed in the packed case since we\n+      --  specifically avoided expanding packed array references when the\n+      --  renaming declaration was analyzed.\n \n       Reset_Analyzed_Flags (N);\n       Analyze_And_Resolve (N, T);\n@@ -696,9 +630,9 @@ package body Exp_Ch2 is\n    ------------------\n \n    --  This would be trivial, simply a test for an identifier that was a\n-   --  reference to a formal, if it were not for the fact that a previous\n-   --  call to Expand_Entry_Parameter will have modified the reference\n-   --  to the identifier. A formal of a protected entity is rewritten as\n+   --  reference to a formal, if it were not for the fact that a previous call\n+   --  to Expand_Entry_Parameter will have modified the reference to the\n+   --  identifier. A formal of a protected entity is rewritten as\n \n    --    typ!(recobj).rec.all'Constrained\n "}, {"sha": "a888216d908f738989c0651984c567926f252662", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=ba6739078139fc22634a0b45c4c34147a14665df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -145,14 +145,24 @@ package body Sem_Cat is\n       begin\n          if Is_Preelaborated (E) then\n             return Preelaborated;\n-         elsif Is_Pure (E) then\n+\n+            --  Ignore Pure specification if set by pragma Pure_Function\n+\n+         elsif Is_Pure (E)\n+           and then not\n+             (Has_Pragma_Pure_Function (E) and not Has_Pragma_Pure (E))\n+         then\n             return Pure;\n+\n          elsif Is_Shared_Passive (E) then\n             return Shared_Passive;\n+\n          elsif Is_Remote_Types (E) then\n             return Remote_Types;\n+\n          elsif Is_Remote_Call_Interface (E) then\n             return Remote_Call_Interface;\n+\n          else\n             return Normal;\n          end if;\n@@ -967,7 +977,7 @@ package body Sem_Cat is\n       --  on instantiations).\n \n       if Inside_A_Generic\n-        and then not Present (Enclosing_Generic_Body (Id))\n+        and then No (Enclosing_Generic_Body (Id))\n       then\n          return;\n       end if;"}, {"sha": "77d28720673789a50779b8b43061d1a99fdec358", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba6739078139fc22634a0b45c4c34147a14665df/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=ba6739078139fc22634a0b45c4c34147a14665df", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -746,7 +746,11 @@ package body Sem_Ch7 is\n                Set_Never_Set_In_Source (E, False);\n                Set_Is_True_Constant    (E, False);\n                Set_Current_Value       (E, Empty);\n-               Set_Is_Known_Non_Null   (E, False);\n+               Set_Is_Known_Null       (E, False);\n+\n+               if not Can_Never_Be_Null (E) then\n+                  Set_Is_Known_Non_Null (E, False);\n+               end if;\n \n             elsif Ekind (E) = E_Package\n                     or else"}]}