{"sha": "7190fdc1906cfdfee00dc32197bee568d8174b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE5MGZkYzE5MDZjZmRmZWUwMGRjMzIxOTdiZWU1NjhkODE3NGI3MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-11-07T14:31:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-07T14:31:00Z"}, "message": "tree-ssa-loop-niter.c: Include tree-ssanames.h.\n\n\t* tree-ssa-loop-niter.c: Include tree-ssanames.h.\n\t(determine_value_range): Add loop argument.  Use get_range_info to\n\timprove range.\n\t(bound_difference): Adjust caller.\n\n\t* gcc.dg/tree-ssa/loop-39.c: New test.\n\nFrom-SVN: r204516", "tree": {"sha": "34f58737caa85eb5c8e9db1492758091f6afb58e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f58737caa85eb5c8e9db1492758091f6afb58e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7190fdc1906cfdfee00dc32197bee568d8174b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7190fdc1906cfdfee00dc32197bee568d8174b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7190fdc1906cfdfee00dc32197bee568d8174b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7190fdc1906cfdfee00dc32197bee568d8174b71/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d23c0a32ab98d6c170970bb1ee319c6fc967852d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23c0a32ab98d6c170970bb1ee319c6fc967852d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23c0a32ab98d6c170970bb1ee319c6fc967852d"}], "stats": {"total": 111, "additions": 107, "deletions": 4}, "files": [{"sha": "a4bb664c35e0e511f972a2d945221899cdf68385", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7190fdc1906cfdfee00dc32197bee568d8174b71", "patch": "@@ -1,3 +1,10 @@\n+2013-11-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-ssa-loop-niter.c: Include tree-ssanames.h.\n+\t(determine_value_range): Add loop argument.  Use get_range_info to\n+\timprove range.\n+\t(bound_difference): Adjust caller.\n+\n 2013-11-07  Richard Biener  <rguenther@suse.de>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "e28fce632c6c6b160fde5ec435e7576fff204c2f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7190fdc1906cfdfee00dc32197bee568d8174b71", "patch": "@@ -1,5 +1,7 @@\n 2013-11-07  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/tree-ssa/loop-39.c: New test.\n+\n         * gcc.dg/unroll_1.c: Add -fno-tree-vrp to dg-options.\n         * gcc.dg/unroll_2.c: Likewise.\n         * gcc.dg/unroll_3.c: Likewise."}, {"sha": "1f6bba42fd44f5cc5d912d577e810219f488f474", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-39.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-39.c?ref=7190fdc1906cfdfee00dc32197bee568d8174b71", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-sccp-details\" } */\n+\n+int\n+foo (unsigned int n)\n+{\n+  int i, r = 1;\n+  if (n > 0)\n+    {\n+      asm (\"\");\n+      if (n < 10)\n+\t{\n+\t  asm (\"\");\n+\t  do\n+\t    {\n+\t      --n;\n+\t      r *= 2;\n+\t    }\n+\t  while (n > 0);\n+\t}\n+    }\n+  return r + n;\n+}\n+\n+/* { dg-final { scan-tree-dump \"# of iterations \\[^\\n\\r]*, bounded by 8\" \"sccp\" } } */\n+/* { dg-final { cleanup-tree-dump \"sccp\" } } */"}, {"sha": "3014faae7968d0bc6f3249e8dedc7b945c04c1b1", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 72, "deletions": 4, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7190fdc1906cfdfee00dc32197bee568d8174b71/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=7190fdc1906cfdfee00dc32197bee568d8174b71", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"tree-inline.h\"\n #include \"tree-pass.h\"\n+#include \"tree-ssanames.h\"\n \n \n #define SWAP(X, Y) do { affine_iv *tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n@@ -119,9 +120,12 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n    in TYPE to MIN and MAX.  */\n \n static void\n-determine_value_range (tree type, tree var, mpz_t off,\n+determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n \t\t       mpz_t min, mpz_t max)\n {\n+  double_int minv, maxv;\n+  enum value_range_type rtype = VR_VARYING;\n+\n   /* If the expression is a constant, we know its value exactly.  */\n   if (integer_zerop (var))\n     {\n@@ -130,9 +134,73 @@ determine_value_range (tree type, tree var, mpz_t off,\n       return;\n     }\n \n+  get_type_static_bounds (type, min, max);\n+\n+  /* See if we have some range info from VRP.  */\n+  if (TREE_CODE (var) == SSA_NAME && INTEGRAL_TYPE_P (type))\n+    {\n+      edge e = loop_preheader_edge (loop);\n+      gimple_stmt_iterator gsi;\n+\n+      /* Either for VAR itself...  */\n+      rtype = get_range_info (var, &minv, &maxv);\n+      /* Or for PHI results in loop->header where VAR is used as\n+\t PHI argument from the loop preheader edge.  */\n+      for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple phi = gsi_stmt (gsi);\n+\t  double_int minc, maxc;\n+\t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var\n+\t      && (get_range_info (gimple_phi_result (phi), &minc, &maxc)\n+\t\t  == VR_RANGE))\n+\t    {\n+\t      if (rtype != VR_RANGE)\n+\t\t{\n+\t\t  rtype = VR_RANGE;\n+\t\t  minv = minc;\n+\t\t  maxv = maxc;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  minv = minv.max (minc, TYPE_UNSIGNED (type));\n+\t\t  maxv = maxv.min (maxc, TYPE_UNSIGNED (type));\n+\t\t  gcc_assert (minv.cmp (maxv, TYPE_UNSIGNED (type)) <= 0);\n+\t\t}\n+\t    }\n+\t}\n+      if (rtype == VR_RANGE)\n+\t{\n+\t  mpz_t minm, maxm;\n+\t  gcc_assert (minv.cmp (maxv, TYPE_UNSIGNED (type)) <= 0);\n+\t  mpz_init (minm);\n+\t  mpz_init (maxm);\n+\t  mpz_set_double_int (minm, minv, TYPE_UNSIGNED (type));\n+\t  mpz_set_double_int (maxm, maxv, TYPE_UNSIGNED (type));\n+\t  mpz_add (minm, minm, off);\n+\t  mpz_add (maxm, maxm, off);\n+\t  /* If the computation may not wrap or off is zero, then this\n+\t     is always fine.  If off is negative and minv + off isn't\n+\t     smaller than type's minimum, or off is positive and\n+\t     maxv + off isn't bigger than type's maximum, use the more\n+\t     precise range too.  */\n+\t  if (nowrap_type_p (type)\n+\t      || mpz_sgn (off) == 0\n+\t      || (mpz_sgn (off) < 0 && mpz_cmp (minm, min) >= 0)\n+\t      || (mpz_sgn (off) > 0 && mpz_cmp (maxm, max) <= 0))\n+\t    {\n+\t      mpz_set (min, minm);\n+\t      mpz_set (max, maxm);\n+\t      mpz_clear (minm);\n+\t      mpz_clear (maxm);\n+\t      return;\n+\t    }\n+\t  mpz_clear (minm);\n+\t  mpz_clear (maxm);\n+\t}\n+    }\n+\n   /* If the computation may wrap, we know nothing about the value, except for\n      the range of the type.  */\n-  get_type_static_bounds (type, min, max);\n   if (!nowrap_type_p (type))\n     return;\n \n@@ -405,8 +473,8 @@ bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n       mpz_init (maxx);\n       mpz_init (miny);\n       mpz_init (maxy);\n-      determine_value_range (type, varx, offx, minx, maxx);\n-      determine_value_range (type, vary, offy, miny, maxy);\n+      determine_value_range (loop, type, varx, offx, minx, maxx);\n+      determine_value_range (loop, type, vary, offy, miny, maxy);\n \n       mpz_sub (bnds->below, minx, maxy);\n       mpz_sub (bnds->up, maxx, miny);"}]}