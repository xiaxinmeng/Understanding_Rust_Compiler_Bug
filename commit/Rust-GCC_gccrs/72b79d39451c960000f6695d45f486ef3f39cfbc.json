{"sha": "72b79d39451c960000f6695d45f486ef3f39cfbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiNzlkMzk0NTFjOTYwMDAwZjY2OTVkNDVmNDg2ZWYzZjM5Y2ZiYw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2009-12-28T18:19:18Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2009-12-28T18:19:18Z"}, "message": "ffi_darwin.c (ffi_prep_args): Copy abi and nargs to local variables.\n\n        * src/powerpc/ffi_darwin.c (ffi_prep_args): Copy abi and nargs to\n        local variables.\n        (aix_adjust_aggregate_sizes): New function.\n        (ffi_prep_cif_machdep): Call it.\n\nFrom-SVN: r155492", "tree": {"sha": "822e0a93187ea3e72313f478c604a72eacfeab2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/822e0a93187ea3e72313f478c604a72eacfeab2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b79d39451c960000f6695d45f486ef3f39cfbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b79d39451c960000f6695d45f486ef3f39cfbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b79d39451c960000f6695d45f486ef3f39cfbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b79d39451c960000f6695d45f486ef3f39cfbc/comments", "author": null, "committer": null, "parents": [{"sha": "36960f2e207ca12b6908646c51b4c4d0fdbd0ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36960f2e207ca12b6908646c51b4c4d0fdbd0ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36960f2e207ca12b6908646c51b4c4d0fdbd0ef4"}], "stats": {"total": 82, "additions": 69, "deletions": 13}, "files": [{"sha": "bb1ca904a6d21d41346df50648dfb90cae237547", "filename": "libffi/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b79d39451c960000f6695d45f486ef3f39cfbc/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b79d39451c960000f6695d45f486ef3f39cfbc/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=72b79d39451c960000f6695d45f486ef3f39cfbc", "patch": "@@ -1,3 +1,10 @@\n+2009-12-28  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Copy abi and nargs to\n+\tlocal variables.\n+\t(aix_adjust_aggregate_sizes): New function.\n+\t(ffi_prep_cif_machdep): Call it.\n+\n 2009-12-26  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* configure.ac: Define FFI_MMAP_EXEC_WRIT for the given targets."}, {"sha": "d84f1c393a8d5b2c6f489cf799ce74fa27b58330", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 62, "deletions": 13, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b79d39451c960000f6695d45f486ef3f39cfbc/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b79d39451c960000f6695d45f486ef3f39cfbc/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=72b79d39451c960000f6695d45f486ef3f39cfbc", "patch": "@@ -32,7 +32,7 @@\n \n #include <stdlib.h>\n \n-extern void ffi_closure_ASM(void);\n+extern void ffi_closure_ASM (void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n@@ -80,10 +80,13 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n    */\n \n-void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n+void\n+ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n+  const unsigned nargs = ecif->cif->nargs;\n+  const ffi_abi abi = ecif->cif->abi;\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n   unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));\n@@ -118,7 +121,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n     *next_arg++ = (unsigned long) (char *) ecif->rvalue;\n \n   /* Now for the arguments.  */\n-  for (i = ecif->cif->nargs; i > 0; i--, ptr++, p_argv++)\n+  for (i = nargs; i > 0; i--, ptr++, p_argv++)\n     {\n       switch ((*ptr)->type)\n \t{\n@@ -213,7 +216,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \t  size_al = (*ptr)->size;\n \t  if ((*ptr)->elements[0]->type == 3)\n \t    size_al = ALIGN((*ptr)->size, 8);\n-\t  if (size_al < 3 && ecif->cif->abi == FFI_DARWIN)\n+\t  if (size_al < 3 && abi == FFI_DARWIN)\n \t    dest_cpy += 4 - size_al;\n \n \t  memcpy ((char *) dest_cpy, (char *) *p_argv, size_al);\n@@ -229,7 +232,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \t     the struct to double-word.  */\n \t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN((*ptr)->size, 8);\n-\t  if (size_al < 3 && ecif->cif->abi == FFI_DARWIN)\n+\t  if (size_al < 3 && abi == FFI_DARWIN)\n \t    dest_cpy += 4 - size_al;\n \n \t  memcpy((char *) dest_cpy, (char *) *p_argv, size_al);\n@@ -301,8 +304,44 @@ darwin_adjust_aggregate_sizes (ffi_type *s)\n   /* Do not add additional tail padding.  */\n }\n \n+/* Adjust the size of S to be correct for AIX.\n+   Word-align double unless it is the first member of a structure.  */\n+\n+static void\n+aix_adjust_aggregate_sizes (ffi_type *s)\n+{\n+  int i;\n+\n+  if (s->type != FFI_TYPE_STRUCT)\n+    return;\n+\n+  s->size = 0;\n+  for (i = 0; s->elements[i] != NULL; i++)\n+    {\n+      ffi_type *p;\n+      int align;\n+      \n+      p = s->elements[i];\n+      aix_adjust_aggregate_sizes (p);\n+      align = p->alignment;\n+      if (i != 0 && p->type == FFI_TYPE_DOUBLE)\n+\talign = 4;\n+      s->size = ALIGN(s->size, align) + p->size;\n+    }\n+  \n+  s->size = ALIGN(s->size, s->alignment);\n+  \n+  if (s->elements[0]->type == FFI_TYPE_UINT64\n+      || s->elements[0]->type == FFI_TYPE_SINT64\n+      || s->elements[0]->type == FFI_TYPE_DOUBLE\n+      || s->elements[0]->alignment == 8)\n+    s->alignment = s->alignment > 8 ? s->alignment : 8;\n+  /* Do not add additional tail padding.  */\n+}\n+\n /* Perform machine dependent cif processing.  */\n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n   /* All this is for the DARWIN ABI.  */\n   int i;\n@@ -323,6 +362,13 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \tdarwin_adjust_aggregate_sizes (cif->arg_types[i]);\n     }\n \n+  if (cif->abi == FFI_AIX)\n+    {\n+      aix_adjust_aggregate_sizes (cif->rtype);\n+      for (i = 0; i < cif->nargs; i++)\n+\taix_adjust_aggregate_sizes (cif->arg_types[i]);\n+    }\n+\n   /* Space for the frame pointer, callee's LR, CR, etc, and for\n      the asm's temp regs.  */\n \n@@ -473,7 +519,8 @@ extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,\n extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,\n \t\t\t    void (*fn)(void), void (*fn2)(void));\n \n-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -486,7 +533,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n   if ((rvalue == NULL) &&\n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      ecif.rvalue = alloca(cif->rtype->size);\n+      ecif.rvalue = alloca (cif->rtype->size);\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -661,8 +708,9 @@ typedef union\n   double d;\n } ffi_dblfl;\n \n-int ffi_closure_helper_DARWIN (ffi_closure*, void*,\n-\t\t\t       unsigned long*, ffi_dblfl*);\n+int\n+ffi_closure_helper_DARWIN (ffi_closure *, void *,\n+\t\t\t   unsigned long *, ffi_dblfl *);\n \n /* Basically the trampoline invokes ffi_closure_ASM, and on\n    entry, r11 holds the address of the closure.\n@@ -671,8 +719,9 @@ int ffi_closure_helper_DARWIN (ffi_closure*, void*,\n    up space for a return value, ffi_closure_ASM invokes the\n    following helper function to do most of the work.  */\n \n-int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n-\t\t\t       unsigned long * pgr, ffi_dblfl * pfr)\n+int\n+ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n+\t\t\t   unsigned long *pgr, ffi_dblfl *pfr)\n {\n   /* rvalue is the pointer to space for return value in closure assembly\n      pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM\n@@ -694,7 +743,7 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   unsigned         size_al;\n \n   cif = closure->cif;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n+  avalue = alloca (cif->nargs * sizeof(void *));\n \n   /* Copy the caller's structure return value address so that the closure\n      returns the data directly to the caller.  */"}]}