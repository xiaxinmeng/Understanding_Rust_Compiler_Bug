{"sha": "66db6b625975e68716f897ecf6bf60632d9432ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkYjZiNjI1OTc1ZTY4NzE2Zjg5N2VjZjZiZjYwNjMyZDk0MzJhYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-27T20:07:04Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-27T20:07:04Z"}, "message": "c-decl.c (store_parm_decls_newstyle, [...]): New functions split out of store_parm_decls.\n\n\t* c-decl.c (store_parm_decls_newstyle, store_parm_decls_oldstyle):\n\tNew functions split out of store_parm_decls.\n\tAvoid unnecessary work. Use local variables consistently.\n\t(store_parm_decls): Likewise.\n\n\t(finish_function): No need to set functionbody flag on call to\n\tpoplevel.\n\t(struct language_function): Remove scope field.\n\t(c_push_function_context, c_pop_function_context): No need to\n\tsave and restore current_scope.\n\nFrom-SVN: r69862", "tree": {"sha": "e10a618214636051676f634783f7323c70eef843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e10a618214636051676f634783f7323c70eef843"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66db6b625975e68716f897ecf6bf60632d9432ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66db6b625975e68716f897ecf6bf60632d9432ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66db6b625975e68716f897ecf6bf60632d9432ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66db6b625975e68716f897ecf6bf60632d9432ac/comments", "author": null, "committer": null, "parents": [{"sha": "f17163688b81896920ad917e224a27f4007e9360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17163688b81896920ad917e224a27f4007e9360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17163688b81896920ad917e224a27f4007e9360"}], "stats": {"total": 589, "additions": 285, "deletions": 304}, "files": [{"sha": "4c73c855204e7e91facb93a105e90f2a846b974a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66db6b625975e68716f897ecf6bf60632d9432ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66db6b625975e68716f897ecf6bf60632d9432ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66db6b625975e68716f897ecf6bf60632d9432ac", "patch": "@@ -1,3 +1,16 @@\n+2003-07-27  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (store_parm_decls_newstyle, store_parm_decls_oldstyle):\n+\tNew functions split out of store_parm_decls.\n+\tAvoid unnecessary work. Use local variables consistently.\n+\t(store_parm_decls): Likewise.\n+\n+\t(finish_function): No need to set functionbody flag on call to\n+\tpoplevel.\n+\t(struct language_function): Remove scope field.\n+\t(c_push_function_context, c_pop_function_context): No need to\n+\tsave and restore current_scope.\n+\n 2003-07-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* doc/extend.texi (Deprecated Features): Implicit typename is\n@@ -49,7 +62,7 @@\n \n 2003-07-26  Geoffrey Keating  <geoffk@apple.com>\n \n-\t* varasm.c (output_constant_def_contents): Use \n+\t* varasm.c (output_constant_def_contents): Use\n \tASM_DECLARE_CONSTANT_NAME if defined.\n \t* doc/tm.texi (Label Output): Document ASM_DECLARE_CONSTANT_NAME.\n \t* config/darwin.h (ASM_DECLARE_OBJECT_NAME): Ensure zero-sized\n@@ -95,7 +108,7 @@\n 2003-07-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tRemove pedwarn_with_decl, warning_with_decl and error_with_decl\n-\tfrom GCC. \n+\tfrom GCC.\n \t* calls.c (try_to_integrate): Don't use xxx_with_decl.\n \t(expand_call): Likewise.\n \t* dwarfout.c (output_reg_number): Likewise.\n@@ -117,7 +130,7 @@\n \t* toplev.h (pedwarn_with_decl): Remove declaration.\n \t(warning_with_decl): Likewise.\n \t(error_with_decl): Likewise.\n-\t(pedwarn): Remove attribute for the time being. \n+\t(pedwarn): Remove attribute for the time being.\n \t* tree-inline.c (expand_call_inline): Don't use xxx_with_decl.\n \t* varasm.c (named_section): Likewise.\n \t(make_decl_rtl): Likewise."}, {"sha": "2d177da0dc255db83f61224310a59805409ed2c9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 269, "deletions": 301, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66db6b625975e68716f897ecf6bf60632d9432ac/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66db6b625975e68716f897ecf6bf60632d9432ac/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=66db6b625975e68716f897ecf6bf60632d9432ac", "patch": "@@ -275,6 +275,8 @@ static tree lookup_name_current_level (tree);\n static tree grokdeclarator (tree, tree, enum decl_context, int);\n static tree grokparms (tree, int);\n static void layout_array_type (tree);\n+static void store_parm_decls_newstyle (void);\n+static void store_parm_decls_oldstyle (void);\n static tree c_make_fname_decl (tree, int);\n static void c_expand_body_1 (tree, int);\n static tree any_external_decl (tree);\n@@ -5724,368 +5726,337 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   return 1;\n }\n \f\n-/* Store the parameter declarations into the current function declaration.\n-   This is called after parsing the parameter declarations, before\n-   digesting the body of the function.\n-\n-   For an old-style definition, modify the function's type\n-   to specify at least the number of arguments.  */\n-\n-void\n-store_parm_decls (void)\n+/* Subroutine of store_parm_decls which handles new-style function\n+   definitions (prototype format). The parms already have decls, so we\n+   need only record them as in effect and complain if any redundant\n+   old-style parm decls were written.  */\n+static void\n+store_parm_decls_newstyle (void)\n {\n+  tree decl, next;\n   tree fndecl = current_function_decl;\n-  tree parm;\n+  tree parms = current_function_parms;\n+  tree tags = current_function_parm_tags;\n \n-  /* This is either a chain of PARM_DECLs (if a prototype was used)\n-     or a list of IDENTIFIER_NODEs (for an old-fashioned C definition).  */\n-  tree specparms = current_function_parms;\n+  /* This is anything which appeared in current_function_parms that\n+     wasn't a PARM_DECL.  */\n+  tree nonparms = 0;\n \n-  /* This is a list of types declared among parms in a prototype.  */\n-  tree parmtags = current_function_parm_tags;\n+  if (current_scope->names || current_scope->tags)\n+    {\n+      error (\"%Hold-style parameter declarations in prototyped \"\n+\t     \"function definition\", &DECL_SOURCE_LOCATION (fndecl));\n \n-  /* This is a chain of PARM_DECLs from old-style parm declarations.  */\n-  tree parmdecls = getdecls ();\n+      /* Get rid of the old-style declarations.  */\n+      poplevel (0, 0, 0);\n+      pushlevel (0);\n+    }\n \n-  /* This is a chain of any other decls that came in among the parm\n-     declarations.  If a parm is declared with  enum {foo, bar} x;\n-     then CONST_DECLs for foo and bar are put here.  */\n-  tree nonparms = 0;\n+  /* Now make all the parameter declarations visible in the function body.  */\n+  parms = nreverse (parms);\n+  for (decl = parms; decl; decl = next)\n+    {\n+      next = TREE_CHAIN (decl);\n+      if (TREE_CODE (decl) != PARM_DECL)\n+\t{\n+\t  /* If we find an enum constant or a type tag,\n+\t     put it aside for the moment.  */\n+\t  TREE_CHAIN (decl) = 0;\n+\t  nonparms = chainon (nonparms, decl);\n+\t  continue;\n+\t}\n \n-  /* The function containing FNDECL, if any.  */\n-  tree context = decl_function_context (fndecl);\n+      if (DECL_NAME (decl) == 0)\n+\terror (\"%Hparameter name omitted\", &DECL_SOURCE_LOCATION (decl));\n+      else\n+\tpushdecl (decl);\n+    }\n \n-  /* Nonzero if this definition is written with a prototype.  */\n-  int prototype = 0;\n+  /* Record the parameter list in the function declaration.  */\n+  DECL_ARGUMENTS (fndecl) = getdecls ();\n \n-  bool saved_warn_shadow = warn_shadow;\n+  /* Now make all the ancillary declarations visible, likewise.  */\n+  for (decl = nonparms; decl; decl = TREE_CHAIN (decl))\n+    if (DECL_NAME (decl) != 0\n+\t&& TYPE_MAIN_VARIANT (TREE_TYPE (decl)) != void_type_node)\n+      pushdecl (decl);\n \n-  /* Don't re-emit shadow warnings.  */\n-  warn_shadow = false;\n+  /* And all the tag declarations.  */\n+  storetags (tags);\n+}\n \n-  if (specparms != 0 && TREE_CODE (specparms) != TREE_LIST)\n-    {\n-      /* This case is when the function was defined with an ANSI prototype.\n-\t The parms already have decls, so we need not do anything here\n-\t except record them as in effect\n-\t and complain if any redundant old-style parm decls were written.  */\n+/* Subroutine of store_parm_decls which handles old-style function\n+   definitions (separate parameter list and declarations).  */\n \n-      tree next;\n-      tree others = 0;\n+static void\n+store_parm_decls_oldstyle (void)\n+{\n+  tree parm, decl, next;\n+  tree fndecl = current_function_decl;\n \n-      prototype = 1;\n+  /* This is the identifier list from the function declarator.  */\n+  tree parmids = current_function_parms;\n \n-      if (parmdecls != 0)\n+  /* This is anything which appeared in current_scope->names that\n+     wasn't a PARM_DECL.  */\n+  tree nonparms;\n+  \n+  /* We use DECL_WEAK as a flag to show which parameters have been\n+     seen already, since it is not used on PARM_DECL or CONST_DECL.  */\n+  for (parm = current_scope->names; parm; parm = TREE_CHAIN (parm))\n+    DECL_WEAK (parm) = 0;\n+\n+  /* Match each formal parameter name with its declaration.  Save each\n+     decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */\n+  for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n+    {\n+      if (TREE_VALUE (parm) == 0)\n \t{\n-\t  tree decl, link;\n-\n-\t  error (\"%Hparm types given both in parmlist and separately\",\n-                 &DECL_SOURCE_LOCATION (fndecl));\n-\t  /* Get rid of the erroneous decls; don't keep them on\n-\t     the list of parms, since they might not be PARM_DECLs.  */\n-\t  for (decl = current_scope->names;\n-\t       decl; decl = TREE_CHAIN (decl))\n-\t    if (DECL_NAME (decl))\n-\t      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = 0;\n-\t  for (link = current_scope->shadowed;\n-\t       link; link = TREE_CHAIN (link))\n-\t    IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-\t  current_scope->names = 0;\n-\t  current_scope->shadowed = 0;\n+\t  error (\"%Hparameter name missing from parameter list\",\n+\t\t &DECL_SOURCE_LOCATION (fndecl));\n+\t  TREE_PURPOSE (parm) = 0;\n+\t  continue;\n \t}\n \n-      specparms = nreverse (specparms);\n-      for (parm = specparms; parm; parm = next)\n+      decl = IDENTIFIER_SYMBOL_VALUE (TREE_VALUE (parm));\n+      if (decl && DECL_CONTEXT (decl) == fndecl)\n \t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n-\t  next = TREE_CHAIN (parm);\n-\t  if (TREE_CODE (parm) == PARM_DECL)\n+\t  const location_t *locus = &DECL_SOURCE_LOCATION (decl);\n+\t  /* If we got something other than a PARM_DECL it is an error.  */\n+\t  if (TREE_CODE (decl) != PARM_DECL)\n+\t    error (\"%H\\\"%D\\\" declared as a non-parameter\", locus, decl);\n+\t  /* If the declaration is already marked, we have a duplicate\n+\t     name.  Complain and ignore the duplicate.  */\n+\t  else if (DECL_WEAK (decl))\n \t    {\n-\t      if (DECL_NAME (parm) == 0)\n-                error (\"%Hparameter name omitted\", locus);\n-\t      else if (TREE_CODE (TREE_TYPE (parm)) != ERROR_MARK\n-\t\t       && VOID_TYPE_P (TREE_TYPE (parm)))\n-\t\t{\n-\t\t  error (\"%Hparameter '%D' declared void\", locus, parm);\n-\t\t  /* Change the type to error_mark_node so this parameter\n-\t\t     will be ignored by assign_parms.  */\n-\t\t  TREE_TYPE (parm) = error_mark_node;\n-\t\t}\n-\t      pushdecl (parm);\n+\t      error (\"%Hmultiple parameters named \\\"%D\\\"\", locus, decl);\n+\t      TREE_PURPOSE (parm) = 0;\n+\t      continue;\n \t    }\n-\t  else\n+\t  /* If the declaration says \"void\", complain and turn it into\n+\t     an int.  */\n+\t  else if (VOID_TYPE_P (TREE_TYPE (decl)))\n \t    {\n-\t      /* If we find an enum constant or a type tag,\n-\t\t put it aside for the moment.  */\n-\t      TREE_CHAIN (parm) = 0;\n-\t      others = chainon (others, parm);\n+\t      error (\"%Hparameter \\\"%D\\\" declared void\", locus, decl);\n+\t      TREE_TYPE (decl) = integer_type_node;\n+\t      DECL_ARG_TYPE (decl) = integer_type_node;\n+\t      layout_decl (decl, 0);\n \t    }\n \t}\n-\n-      /* Get the decls in their original chain order\n-\t and record in the function.  */\n-      DECL_ARGUMENTS (fndecl) = getdecls ();\n-\n-      /* Now pushdecl the enum constants.  */\n-      for (parm = others; parm; parm = next)\n+      /* If no declaration found, default to int.  */\n+      else\n \t{\n-\t  next = TREE_CHAIN (parm);\n-\t  if (DECL_NAME (parm) == 0)\n-\t    ;\n-\t  else if (TYPE_MAIN_VARIANT (TREE_TYPE (parm)) == void_type_node)\n-\t    ;\n-\t  else if (TREE_CODE (parm) != PARM_DECL)\n-\t    pushdecl (parm);\n+\t  const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n+\t  decl = build_decl (PARM_DECL, TREE_VALUE (parm), integer_type_node);\n+\t  DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n+\t  DECL_SOURCE_LOCATION (decl) = *locus;\n+\t  pushdecl (decl);\n+\n+\t  if (flag_isoc99)\n+\t    pedwarn (\"%Htype of \\\"%D\\\" defaults to \\\"int\\\"\", locus, decl);\n+\t  else if (extra_warnings)\n+\t    warning (\"%Htype of \\\"%D\\\" defaults to \\\"int\\\"\", locus, decl);\n \t}\n \n-      storetags (chainon (parmtags, gettags ()));\n+      TREE_PURPOSE (parm) = decl;\n+      DECL_WEAK (decl) = 1;\n     }\n-  else\n-    {\n-      /* SPECPARMS is an identifier list--a chain of TREE_LIST nodes\n-\t each with a parm name as the TREE_VALUE.\n-\n-\t PARMDECLS is a chain of declarations for parameters.\n-\t Warning! It can also contain CONST_DECLs which are not parameters\n-\t but are names of enumerators of any enum types\n-\t declared among the parameters.\n \n-\t First match each formal parameter name with its declaration.\n-\t Associate decls with the names and store the decls\n-\t into the TREE_PURPOSE slots.  */\n+  /* Put anything which is in current_scope->names and which is\n+     not a PARM_DECL onto the list NONPARMS.  (The types of\n+     non-parm things which might appear on the list include\n+     enumerators and NULL-named TYPE_DECL nodes.) Complain about\n+     any actual PARM_DECLs not matched with any names.  */\n \n-      /* We use DECL_WEAK as a flag to show which parameters have been\n-\t seen already since it is not used on PARM_DECL or CONST_DECL.  */\n-      for (parm = parmdecls; parm; parm = TREE_CHAIN (parm))\n-\tDECL_WEAK (parm) = 0;\n+  nonparms = 0;\n+  for (parm = current_scope->names; parm; parm = next)\n+    {\n+      const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n+      next = TREE_CHAIN (parm);\n+      TREE_CHAIN (parm) = 0;\n \n-      for (parm = specparms; parm; parm = TREE_CHAIN (parm))\n+      if (TREE_CODE (parm) != PARM_DECL)\n \t{\n-\t  tree tail, found = NULL;\n-\n-\t  if (TREE_VALUE (parm) == 0)\n-\t    {\n-\t      error (\"%Hparameter name missing from parameter list\",\n-                     &DECL_SOURCE_LOCATION (fndecl));\n-\t      TREE_PURPOSE (parm) = 0;\n-\t      continue;\n-\t    }\n-\n-\t  /* See if any of the parmdecls specifies this parm by name.\n-\t     Ignore any enumerator decls.  */\n-\t  for (tail = parmdecls; tail; tail = TREE_CHAIN (tail))\n-\t    if (DECL_NAME (tail) == TREE_VALUE (parm)\n-\t\t&& TREE_CODE (tail) == PARM_DECL)\n-\t      {\n-\t\tfound = tail;\n-\t\tbreak;\n-\t      }\n-\n-\t  /* If declaration already marked, we have a duplicate name.\n-\t     Complain, and don't use this decl twice.  */\n-\t  if (found && DECL_WEAK (found))\n-\t    {\n-\t      error (\"%Hmultiple parameters named '%D'\",\n-                     &DECL_SOURCE_LOCATION (found), found);\n-\t      found = 0;\n-\t    }\n-\n-\t  /* If the declaration says \"void\", complain and ignore it.  */\n-\t  if (found && VOID_TYPE_P (TREE_TYPE (found)))\n-\t    {\n-\t      error (\"%Hparameter '%D' declared void\",\n-                     &DECL_SOURCE_LOCATION (found), found);\n-\t      TREE_TYPE (found) = integer_type_node;\n-\t      DECL_ARG_TYPE (found) = integer_type_node;\n-\t      layout_decl (found, 0);\n-\t    }\n-\n-\t  /* If no declaration found, default to int.  */\n-\t  if (!found)\n-\t    {\n-\t      found = build_decl (PARM_DECL, TREE_VALUE (parm),\n-\t\t\t\t  integer_type_node);\n-\t      DECL_ARG_TYPE (found) = TREE_TYPE (found);\n-\t      DECL_SOURCE_LOCATION (found) = DECL_SOURCE_LOCATION (fndecl);\n-\t      if (flag_isoc99)\n-\t\tpedwarn (\"%Htype of '%D' defaults to `int'\",\n-                         &DECL_SOURCE_LOCATION (found), found);\n-\t      else if (extra_warnings)\n-\t\twarning (\"%Htype of '%D' defaults to `int'\",\n-                         &DECL_SOURCE_LOCATION (found), found);\n-\t      pushdecl (found);\n-\t    }\n-\n-\t  TREE_PURPOSE (parm) = found;\n-\n-\t  /* Mark this decl as \"already found\".  */\n-\t  DECL_WEAK (found) = 1;\n+\t  nonparms = chainon (nonparms, parm);\n+\t  continue;\n \t}\n \n-      /* Put anything which is on the parmdecls chain and which is\n-\t not a PARM_DECL onto the list NONPARMS.  (The types of\n-\t non-parm things which might appear on the list include\n-\t enumerators and NULL-named TYPE_DECL nodes.) Complain about\n-\t any actual PARM_DECLs not matched with any names.  */\n-\n-      nonparms = 0;\n-      for (parm = parmdecls; parm;)\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n-\t  tree next = TREE_CHAIN (parm);\n-\t  TREE_CHAIN (parm) = 0;\n-\n-\t  if (TREE_CODE (parm) != PARM_DECL)\n-\t    nonparms = chainon (nonparms, parm);\n-\t  else\n-\t    {\n-\t      /* Complain about args with incomplete types.  */\n-\t      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n-\t\t{\n-\t\t  error (\"%Hparameter '%D' has incomplete type\", locus, parm);\n-\t\t  TREE_TYPE (parm) = error_mark_node;\n-\t\t}\n+\t  error (\"%Hparameter \\\"%D\\\" has incomplete type\", locus, parm);\n+\t  TREE_TYPE (parm) = error_mark_node;\n+\t}\n \n-\t      if (! DECL_WEAK (parm))\n-\t\t{\n-\t\t  error (\"%Hdeclaration for parameter '%D' but no such \"\n-                         \"parameter\", locus, parm);\n-\t          /* Pretend the parameter was not missing.\n-\t\t     This gets us to a standard state and minimizes\n-\t\t     further error messages.  */\n-\t\t  specparms\n-\t\t    = chainon (specparms,\n-\t\t\t       tree_cons (parm, NULL_TREE, NULL_TREE));\n-\t\t}\n-\t    }\n+      if (! DECL_WEAK (parm))\n+\t{\n+\t  error (\"%Hdeclaration for parameter \\\"%D\\\" but no such parameter\",\n+\t\t locus, parm);\n \n-\t  parm = next;\n+\t  /* Pretend the parameter was not missing.\n+\t     This gets us to a standard state and minimizes\n+\t     further error messages.  */\n+\t  parmids = chainon (parmids, tree_cons (parm, 0, 0));\n \t}\n+    }\n \n-      /* Chain the declarations together in the order of the list of\n-         names.  Store that chain in the function decl, replacing the\n-         list of names.  */\n-      parm = specparms;\n-      DECL_ARGUMENTS (fndecl) = 0;\n+  /* Chain the declarations together in the order of the list of\n+     names.  Store that chain in the function decl, replacing the\n+     list of names.  */\n+  DECL_ARGUMENTS (fndecl) = 0;\n+  {\n+    tree last;\n+    for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n+      if (TREE_PURPOSE (parm))\n+\tbreak;\n+    if (parm && TREE_PURPOSE (parm))\n       {\n-\ttree last;\n-\tfor (last = 0; parm; parm = TREE_CHAIN (parm))\n+\tlast = TREE_PURPOSE (parm);\n+\tDECL_ARGUMENTS (fndecl) = last;\n+\tDECL_WEAK (last) = 0;\n+\n+\tfor (parm = TREE_CHAIN (parm); parm; parm = TREE_CHAIN (parm))\n \t  if (TREE_PURPOSE (parm))\n \t    {\n-\t      if (last == 0)\n-\t\tDECL_ARGUMENTS (fndecl) = TREE_PURPOSE (parm);\n-\t      else\n-\t\tTREE_CHAIN (last) = TREE_PURPOSE (parm);\n+\t      TREE_CHAIN (last) = TREE_PURPOSE (parm);\n \t      last = TREE_PURPOSE (parm);\n-\t      TREE_CHAIN (last) = 0;\n+\t      DECL_WEAK (last) = 0;\n \t    }\n+\tTREE_CHAIN (last) = 0;\n       }\n+  }\n \n-      /* If there was a previous prototype,\n-\t set the DECL_ARG_TYPE of each argument according to\n-\t the type previously specified, and report any mismatches.  */\n+  /* If there was a previous prototype,\n+     set the DECL_ARG_TYPE of each argument according to\n+     the type previously specified, and report any mismatches.  */\n \n-      if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n+  if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n+    {\n+      tree type;\n+      for (parm = DECL_ARGUMENTS (fndecl),\n+\t     type = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\t   parm || (type && (TYPE_MAIN_VARIANT (TREE_VALUE (type))\n+\t\t\t     != void_type_node));\n+\t   parm = TREE_CHAIN (parm), type = TREE_CHAIN (type))\n \t{\n-\t  tree type;\n-\t  for (parm = DECL_ARGUMENTS (fndecl),\n-\t       type = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-\t       parm || (type && (TYPE_MAIN_VARIANT (TREE_VALUE (type))\n-\t\t\t\t != void_type_node));\n-\t       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type))\n+\t  if (parm == 0 || type == 0\n+\t      || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t    {\n-\t      if (parm == 0 || type == 0\n-\t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n-\t\t{\n-\t\t  error (\"number of arguments doesn't match prototype\");\n-\t\t  error (\"%Hprototype declaration\",\n-                         &current_function_prototype_locus);\n-\t\t  break;\n-\t\t}\n-\t      /* Type for passing arg must be consistent with that\n-\t\t declared for the arg.  ISO C says we take the unqualified\n-\t\t type for parameters declared with qualified type.  */\n-\t      if (! comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n-\t\t\t       TYPE_MAIN_VARIANT (TREE_VALUE (type)),\n-\t\t\t       COMPARE_STRICT))\n+\t      error (\"number of arguments doesn't match prototype\");\n+\t      error (\"%Hprototype declaration\",\n+\t\t     &current_function_prototype_locus);\n+\t      break;\n+\t    }\n+\t  /* Type for passing arg must be consistent with that\n+\t     declared for the arg.  ISO C says we take the unqualified\n+\t     type for parameters declared with qualified type.  */\n+\t  if (! comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n+\t\t\t   TYPE_MAIN_VARIANT (TREE_VALUE (type)),\n+\t\t\t   COMPARE_STRICT))\n+\t    {\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n+\t\t  == TYPE_MAIN_VARIANT (TREE_VALUE (type)))\n \t\t{\n-\t\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n-\t\t      == TYPE_MAIN_VARIANT (TREE_VALUE (type)))\n-\t\t    {\n-\t\t      /* Adjust argument to match prototype.  E.g. a previous\n-\t\t\t `int foo(float);' prototype causes\n-\t\t\t `int foo(x) float x; {...}' to be treated like\n-\t\t\t `int foo(float x) {...}'.  This is particularly\n-\t\t\t useful for argument types like uid_t.  */\n-\t\t      DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n-\n-\t\t      if (PROMOTE_PROTOTYPES\n-\t\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (parm))\n-\t\t\t  && TYPE_PRECISION (TREE_TYPE (parm))\n-\t\t\t  < TYPE_PRECISION (integer_type_node))\n-\t\t\tDECL_ARG_TYPE (parm) = integer_type_node;\n-\n-\t\t      if (pedantic)\n-\t\t\t{\n-\t\t\t  pedwarn (\"promoted argument `%s' doesn't match prototype\",\n-\t\t\t\t   IDENTIFIER_POINTER (DECL_NAME (parm)));\n-\t\t\t  warning (\"%Hprototype declaration\",\n-                                   &current_function_prototype_locus);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n+\t\t  /* Adjust argument to match prototype.  E.g. a previous\n+\t\t     `int foo(float);' prototype causes\n+\t\t     `int foo(x) float x; {...}' to be treated like\n+\t\t     `int foo(float x) {...}'.  This is particularly\n+\t\t     useful for argument types like uid_t.  */\n+\t\t  DECL_ARG_TYPE (parm) = TREE_TYPE (parm);\n+\n+\t\t  if (PROMOTE_PROTOTYPES\n+\t\t      && INTEGRAL_TYPE_P (TREE_TYPE (parm))\n+\t\t      && TYPE_PRECISION (TREE_TYPE (parm))\n+\t\t      < TYPE_PRECISION (integer_type_node))\n+\t\t    DECL_ARG_TYPE (parm) = integer_type_node;\n+\n+\t\t  if (pedantic)\n \t\t    {\n-\t\t      error (\"argument `%s' doesn't match prototype\",\n-\t\t\t     IDENTIFIER_POINTER (DECL_NAME (parm)));\n-\t\t      error (\"%Hprototype declaration\",\n-                             &current_function_prototype_locus);\n+\t\t      pedwarn (\"promoted argument \\\"%D\\\" \"\n+\t\t\t       \"doesn't match prototype\", parm);\n+\t\t      pedwarn (\"%Hprototype declaration\",\n+\t\t\t       &current_function_prototype_locus);\n \t\t    }\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  error (\"argument \\\"%D\\\" doesn't match prototype\", parm);\n+\t\t  error (\"%Hprototype declaration\",\n+\t\t\t &current_function_prototype_locus);\n+\t\t}\n \t    }\n-\t  TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = 0;\n \t}\n+      TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = 0;\n+    }\n \n-      /* Otherwise, create a prototype that would match.  */\n+  /* Otherwise, create a prototype that would match.  */\n \n-      else\n-\t{\n-\t  tree actual = 0, last = 0, type;\n+  else\n+    {\n+      tree actual = 0, last = 0, type;\n \n-\t  for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n-\t    {\n-\t      type = tree_cons (NULL_TREE, DECL_ARG_TYPE (parm), NULL_TREE);\n-\t      if (last)\n-\t\tTREE_CHAIN (last) = type;\n-\t      else\n-\t\tactual = type;\n-\t      last = type;\n-\t    }\n-\t  type = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+      for (parm = DECL_ARGUMENTS (fndecl); parm; parm = TREE_CHAIN (parm))\n+\t{\n+\t  type = tree_cons (NULL_TREE, DECL_ARG_TYPE (parm), NULL_TREE);\n \t  if (last)\n \t    TREE_CHAIN (last) = type;\n \t  else\n \t    actual = type;\n+\t  last = type;\n+\t}\n+      type = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+      if (last)\n+\tTREE_CHAIN (last) = type;\n+      else\n+\tactual = type;\n \n-\t  /* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES\n-\t     of the type of this function, but we need to avoid having this\n-\t     affect the types of other similarly-typed functions, so we must\n-\t     first force the generation of an identical (but separate) type\n-\t     node for the relevant function type.  The new node we create\n-\t     will be a variant of the main variant of the original function\n-\t     type.  */\n+      /* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES\n+\t of the type of this function, but we need to avoid having this\n+\t affect the types of other similarly-typed functions, so we must\n+\t first force the generation of an identical (but separate) type\n+\t node for the relevant function type.  The new node we create\n+\t will be a variant of the main variant of the original function\n+\t type.  */\n \n-\t  TREE_TYPE (fndecl) = build_type_copy (TREE_TYPE (fndecl));\n+      TREE_TYPE (fndecl) = build_type_copy (TREE_TYPE (fndecl));\n \n-\t  TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = actual;\n-\t}\n+      TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = actual;\n+    }\n \n-      /* Now store the final chain of decls for the arguments\n-\t as the decl-chain of the current lexical scope.\n-\t Put the enumerators in as well, at the front so that\n-\t DECL_ARGUMENTS is not modified.  */\n+  /* Now store the final chain of decls for the arguments\n+     as the decl-chain of the current lexical scope.\n+     Put the enumerators in as well, at the front so that\n+     DECL_ARGUMENTS is not modified.  */\n \n-      storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n-    }\n+  storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n+}\n+\n+/* Store the parameter declarations into the current function declaration.\n+   This is called after parsing the parameter declarations, before\n+   digesting the body of the function.\n+\n+   For an old-style definition, construct a prototype out of the old-style\n+   parameter declarations and inject it into the function's type.  */\n+\n+void\n+store_parm_decls (void)\n+{\n+  tree fndecl = current_function_decl;\n+\n+  /* The function containing FNDECL, if any.  */\n+  tree context = decl_function_context (fndecl);\n+\n+  /* True if this definition is written with a prototype.  */\n+  bool prototype = (current_function_parms\n+\t\t    && TREE_CODE (current_function_parms) != TREE_LIST);\n+\n+  /* Don't re-emit shadow warnings.  */\n+  bool saved_warn_shadow = warn_shadow;\n+  warn_shadow = false;\n+\n+  if (prototype)\n+    store_parm_decls_newstyle ();\n+  else\n+    store_parm_decls_oldstyle ();\n \n   /* Make sure the scope for the top of the function body\n      gets a BLOCK if there are any in the function.\n@@ -6102,7 +6073,7 @@ store_parm_decls (void)\n   init_function_start (fndecl);\n \n   /* Begin the statement tree for this function.  */\n-  begin_stmt_tree (&DECL_SAVED_TREE (current_function_decl));\n+  begin_stmt_tree (&DECL_SAVED_TREE (fndecl));\n \n   /* If this is a nested function, save away the sizes of any\n      variable-size types so that we can expand them when generating\n@@ -6158,7 +6129,7 @@ finish_function (int nested, int can_defer_p)\n   if (current_scope->parm_flag && keep_next_if_subblocks)\n     {\n       pushlevel (0);\n-      poplevel (1, 0, 1);\n+      poplevel (1, 0, 0);\n     }\n \n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n@@ -6560,7 +6531,6 @@ struct language_function GTY(())\n   int returns_abnormally;\n   int warn_about_return_type;\n   int extern_inline;\n-  struct c_scope *scope;\n };\n \n /* Save and reinitialize the variables\n@@ -6580,7 +6550,6 @@ c_push_function_context (struct function *f)\n   p->returns_abnormally = current_function_returns_abnormally;\n   p->warn_about_return_type = warn_about_return_type;\n   p->extern_inline = current_extern_inline;\n-  p->scope = current_scope;\n }\n \n /* Restore the variables used during compilation of a C function.  */\n@@ -6607,7 +6576,6 @@ c_pop_function_context (struct function *f)\n   current_function_returns_abnormally = p->returns_abnormally;\n   warn_about_return_type = p->warn_about_return_type;\n   current_extern_inline = p->extern_inline;\n-  current_scope = p->scope;\n \n   f->language = NULL;\n }"}]}