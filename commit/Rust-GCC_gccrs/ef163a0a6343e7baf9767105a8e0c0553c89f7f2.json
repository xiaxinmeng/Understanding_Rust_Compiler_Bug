{"sha": "ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxNjNhMGE2MzQzZTdiYWY5NzY3MTA1YThlMGMwNTUzYzg5ZjdmMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-15T10:33:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-15T10:33:29Z"}, "message": "[multiple changes]\n\n2013-10-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Constituent): When\n\ta state acts as a constituent of another state, ensure that\n\tthe said state has a Part_Of dependency in its corresponding\n\taspect/pragma Abstract_State.\n\n2013-10-15  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch4.adb (P_If_expression): Handle redundant ELSE cleanly.\n\n2013-10-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* atree.ads (New_Copy, Relocate_Node): Improve documentation\n\t(note that these subprograms reset Is_Overloaded).\n\n2013-10-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* checks.adb (Check_Needed): Handle the case where the test in\n\tthe left operand of the short circuit is wrapped in a qualified\n\texpression, type conversion, or expression with actions.\n\n2013-10-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_type.adb, sem_type.ads (Save_Interps): Also propagate\n\tIs_Overloaded to New_N, for consistency.\n\n2013-10-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-tienau.adb (Put): Use file parameter to query values of\n\tcurrent column and line length.\n\nFrom-SVN: r203595", "tree": {"sha": "ed41a8b405240d78469b5cb5efbb964e603d72d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed41a8b405240d78469b5cb5efbb964e603d72d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/comments", "author": null, "committer": null, "parents": [{"sha": "99f97947832b35ee949d5779faa3f6377c63349d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99f97947832b35ee949d5779faa3f6377c63349d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99f97947832b35ee949d5779faa3f6377c63349d"}], "stats": {"total": 145, "additions": 116, "deletions": 29}, "files": [{"sha": "382274eeb4b0d0f75f392def6b76ebceb8f7b162", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -1,3 +1,35 @@\n+2013-10-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Constituent): When\n+\ta state acts as a constituent of another state, ensure that\n+\tthe said state has a Part_Of dependency in its corresponding\n+\taspect/pragma Abstract_State.\n+\n+2013-10-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch4.adb (P_If_expression): Handle redundant ELSE cleanly.\n+\n+2013-10-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* atree.ads (New_Copy, Relocate_Node): Improve documentation\n+\t(note that these subprograms reset Is_Overloaded).\n+\n+2013-10-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* checks.adb (Check_Needed): Handle the case where the test in\n+\tthe left operand of the short circuit is wrapped in a qualified\n+\texpression, type conversion, or expression with actions.\n+\n+2013-10-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_type.adb, sem_type.ads (Save_Interps): Also propagate\n+\tIs_Overloaded to New_N, for consistency.\n+\n+2013-10-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-tienau.adb (Put): Use file parameter to query values of\n+\tcurrent column and line length.\n+\n 2013-10-15  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb, exp_ch11.adb, a-except-2005.adb, a-except-2005.ads:"}, {"sha": "6ee9bbadc60e74d44df22c1f9dc784200f75a8da", "filename": "gcc/ada/a-tienau.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fa-tienau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fa-tienau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tienau.adb?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -126,19 +126,19 @@ package body Ada.Text_IO.Enumeration_Aux is\n       Actual_Width : constant Count := Count'Max (Count (Width), Item'Length);\n \n    begin\n-      --  Deal with limited line length\n+      --  Deal with limited line length of output file\n \n-      if Line_Length /= 0 then\n+      if Line_Length (File) /= 0 then\n \n          --  If actual width exceeds line length, raise Layout_Error\n \n-         if Actual_Width > Line_Length then\n+         if Actual_Width > Line_Length (File) then\n             raise Layout_Error;\n          end if;\n \n          --  If full width cannot fit on current line move to new line\n \n-         if Actual_Width + (Col - 1) > Line_Length then\n+         if Actual_Width + (Col (File) - 1) > Line_Length (File) then\n             New_Line (File);\n          end if;\n       end if;"}, {"sha": "0f47e862f45147bec59c629715bbccde40288a69", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -462,25 +462,26 @@ package Atree is\n    --  with copying aspect specifications where this is required.\n \n    function New_Copy (Source : Node_Id) return Node_Id;\n-   --  This function allocates a completely new node, and then initializes it\n-   --  by copying the contents of the source node into it. The contents of the\n-   --  source node is not affected. The target node is always marked as not\n-   --  being in a list (even if the source is a list member). The new node will\n-   --  have an extension if the source has an extension. New_Copy (Empty)\n-   --  returns Empty and New_Copy (Error) returns Error. Note that, unlike\n-   --  Copy_Separate_Tree, New_Copy does not recursively copy any descendents,\n-   --  so in general parent pointers are not set correctly for the descendents\n-   --  of the copied node. Both normal and extended nodes (entities) may be\n-   --  copied using New_Copy.\n+   --  This function allocates a completely new node, and then initializes\n+   --  it by copying the contents of the source node into it. The contents of\n+   --  the source node is not affected. The target node is always marked as\n+   --  not being in a list (even if the source is a list member), and not\n+   --  overloaded. The new node will have an extension if the source has\n+   --  an extension. New_Copy (Empty) returns Empty, and New_Copy (Error)\n+   --  returns Error. Note that, unlike Copy_Separate_Tree, New_Copy does not\n+   --  recursively copy any descendents, so in general parent pointers are not\n+   --  set correctly for the descendents of the copied node. Both normal and\n+   --  extended nodes (entities) may be copied using New_Copy.\n \n    function Relocate_Node (Source : Node_Id) return Node_Id;\n    --  Source is a non-entity node that is to be relocated. A new node is\n-   --  allocated and the contents of Source are copied to this node using\n-   --  Copy_Node. The parent pointers of descendents of the node are then\n+   --  allocated, and the contents of Source are copied to this node, using\n+   --  New_Copy. The parent pointers of descendents of the node are then\n    --  adjusted to point to the relocated copy. The original node is not\n    --  modified, but the parent pointers of its descendents are no longer\n-   --  valid. This routine is used in conjunction with the tree rewrite\n-   --  routines (see descriptions of Replace/Rewrite).\n+   --  valid. The new copy is always marked as not overloaded. This routine is\n+   --  used in conjunction with the tree rewrite routines (see descriptions of\n+   --  Replace/Rewrite).\n    --\n    --  Note that the resulting node has the same parent as the source node, and\n    --  is thus still attached to the tree. It is valid for Source to be Empty,"}, {"sha": "65dedc20a95aaf4597f7bc9c6f6ab02112b8edbb", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -3554,6 +3554,32 @@ package body Checks is\n       L : Node_Id;\n       R : Node_Id;\n \n+      function Left_Expression (Op : Node_Id) return Node_Id;\n+      --  Return the relevant expression from the left operand of the given\n+      --  short circuit form: this is LO itself, except if LO is a qualified\n+      --  expression, a type conversion, or an expression with actions, in\n+      --  which case this is Left_Expression (Expression (LO)).\n+\n+      ---------------------\n+      -- Left_Expression --\n+      ---------------------\n+\n+      function Left_Expression (Op : Node_Id) return Node_Id is\n+         LE : Node_Id := Left_Opnd (Op);\n+      begin\n+         while Nkind_In (LE,\n+                 N_Qualified_Expression,\n+                 N_Type_Conversion,\n+                 N_Expression_With_Actions)\n+         loop\n+            LE := Expression (LE);\n+         end loop;\n+\n+         return LE;\n+      end Left_Expression;\n+\n+   --  Start of processing for Check_Needed\n+\n    begin\n       --  Always check if not simple entity\n \n@@ -3587,37 +3613,40 @@ package body Checks is\n \n          elsif K = N_Op_Or then\n             exit when N = Right_Opnd (P)\n-              and then Nkind (Left_Opnd (P)) = N_Op_Eq;\n+              and then Nkind (Left_Expression (P)) = N_Op_Eq;\n \n          elsif K = N_Or_Else then\n             exit when (N = Right_Opnd (P)\n                         or else\n                           (Is_List_Member (N)\n                              and then List_Containing (N) = Actions (P)))\n-              and then Nkind (Left_Opnd (P)) = N_Op_Eq;\n+              and then Nkind (Left_Expression (P)) = N_Op_Eq;\n \n          --  Similar test for the And/And then case, where the left operand\n          --  is an inequality test.\n \n          elsif K = N_Op_And then\n             exit when N = Right_Opnd (P)\n-              and then Nkind (Left_Opnd (P)) = N_Op_Ne;\n+              and then Nkind (Left_Expression (P)) = N_Op_Ne;\n \n          elsif K = N_And_Then then\n             exit when (N = Right_Opnd (P)\n                         or else\n                           (Is_List_Member (N)\n                              and then List_Containing (N) = Actions (P)))\n-              and then Nkind (Left_Opnd (P)) = N_Op_Ne;\n+              and then Nkind (Left_Expression (P)) = N_Op_Ne;\n          end if;\n \n          N := P;\n       end loop;\n \n       --  If we fall through the loop, then we have a conditional with an\n-      --  appropriate test as its left operand. So test further.\n+      --  appropriate test as its left operand, so look further.\n+\n+      L := Left_Expression (P);\n+\n+      --  L is an \"=\" or \"/=\" operator: extract its operands\n \n-      L := Left_Opnd (P);\n       R := Right_Opnd (L);\n       L := Left_Opnd (L);\n "}, {"sha": "cdf0dab653ab64071f3c566b6b5af3e4364b7783", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -3120,6 +3120,14 @@ package body Ch4 is\n          Scan; -- Past ELSE\n          Append_To (Exprs, P_Expression);\n \n+         --  Skip redundant ELSE parts\n+\n+         while Token = Tok_Else loop\n+            Error_Msg_SC (\"only one ELSE part is allowed\");\n+            Scan; -- past ELSE\n+            Discard_Junk_Node (P_Expression);\n+         end loop;\n+\n       --  Two expression case (implied True, filled in during semantics)\n \n       else"}, {"sha": "64d684d91e6492e1379ffd92ac6258bbc6ff7fb3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -21521,6 +21521,20 @@ package body Sem_Prag is\n \n                   if Ekind_In (Constit_Id, E_Abstract_State, E_Variable) then\n                      Check_Matching_Constituent (Constit_Id);\n+\n+                     --  A state can act as a constituent only when it is part\n+                     --  of another state. This relation is expressed by option\n+                     --  \"Part_Of\" of pragma Abstract_State.\n+\n+                     if Ekind (Constit_Id) = E_Abstract_State\n+                       and then not Is_Part_Of (Constit_Id, State_Id)\n+                     then\n+                        Error_Msg_Name_1 := Chars (State_Id);\n+                        Error_Msg_NE\n+                          (\"state & is not a valid constituent of ancestor \"\n+                           & \"state %\", Constit, Constit_Id);\n+                     end if;\n+\n                   else\n                      Error_Msg_NE\n                        (\"constituent & must denote a variable or state\","}, {"sha": "7239410ab523fa44e25206b353553bc046f1abad", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -3209,6 +3209,8 @@ package body Sem_Type is\n \n    begin\n       if Is_Overloaded (Old_N) then\n+         Set_Is_Overloaded (New_N);\n+\n          if Nkind (Old_N) = N_Selected_Component\n            and then Is_Overloaded (Selector_Name (Old_N))\n          then"}, {"sha": "60eefa51c75babbf16fade35670cd7b066bf6d68", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef163a0a6343e7baf9767105a8e0c0553c89f7f2/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=ef163a0a6343e7baf9767105a8e0c0553c89f7f2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -124,7 +124,7 @@ package Sem_Type is\n    --  denotes whether an interpretation has been disabled by an abstract\n    --  operator. Add_One_Interp includes semantic processing to deal with\n    --  adding entries that hide one another etc.\n-\n+   --\n    --  For operators, the legality of the operation depends on the visibility\n    --  of T and its scope. If the operator is an equality or comparison, T is\n    --  always Boolean, and we use Opnd_Type, which is a candidate type for one\n@@ -158,8 +158,9 @@ package Sem_Type is\n    procedure Save_Interps (Old_N : Node_Id; New_N : Node_Id);\n    --  If an overloaded node is rewritten during semantic analysis, its\n    --  possible interpretations must be linked to the copy. This procedure\n-   --  transfers the overload information from Old_N, the old node, to\n-   --  New_N, its new copy. It has no effect in the non-overloaded case.\n+   --  transfers the overload information (Is_Overloaded flag, and list of\n+   --  interpretations) from Old_N, the old node, to New_N, its new copy.\n+   --  It has no effect in the non-overloaded case.\n \n    function Covers (T1, T2 : Entity_Id) return Boolean;\n    --  This is the basic type compatibility routine. T1 is the expected type,"}]}