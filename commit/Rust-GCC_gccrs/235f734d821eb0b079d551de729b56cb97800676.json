{"sha": "235f734d821eb0b079d551de729b56cb97800676", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1ZjczNGQ4MjFlYjBiMDc5ZDU1MWRlNzI5YjU2Y2I5NzgwMDY3Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-16T00:15:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-16T00:15:26Z"}, "message": "decl.c (warn_about_implicit_typename_lookup): New function.\n\n\t* decl.c (warn_about_implicit_typename_lookup): New function.\n\t(lookup_name_real): Use it.  Rework handling of implicit typename\n\textension.\n\nFrom-SVN: r26487", "tree": {"sha": "36e9d12d45904be2c30de0bc4854d6d8427051d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36e9d12d45904be2c30de0bc4854d6d8427051d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235f734d821eb0b079d551de729b56cb97800676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235f734d821eb0b079d551de729b56cb97800676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235f734d821eb0b079d551de729b56cb97800676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235f734d821eb0b079d551de729b56cb97800676/comments", "author": null, "committer": null, "parents": [{"sha": "a9ba8a885857f6b7a14722dbd741bc07121ee72c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ba8a885857f6b7a14722dbd741bc07121ee72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ba8a885857f6b7a14722dbd741bc07121ee72c"}], "stats": {"total": 162, "additions": 113, "deletions": 49}, "files": [{"sha": "8f6159813ee0be21bd9fe945c04158118815bb54", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235f734d821eb0b079d551de729b56cb97800676/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235f734d821eb0b079d551de729b56cb97800676/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=235f734d821eb0b079d551de729b56cb97800676", "patch": "@@ -1,3 +1,9 @@\n+1999-04-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (warn_about_implicit_typename_lookup): New function.\n+\t(lookup_name_real): Use it.  Rework handling of implicit typename\n+\textension.\n+\n 1999-04-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (lookup_nested_field): Remove."}, {"sha": "fe30586454d2d2d5b30ae67ea1e86ab4c77e7425", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235f734d821eb0b079d551de729b56cb97800676/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235f734d821eb0b079d551de729b56cb97800676/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=235f734d821eb0b079d551de729b56cb97800676", "patch": "@@ -192,6 +192,7 @@ static const char *tag_name PROTO((enum tag_types code));\n static void find_class_binding_level PROTO((void));\n static struct binding_level *innermost_nonclass_level PROTO((void));\n static tree poplevel_class PROTO((void));\n+static void warn_about_implicit_typename_lookup PROTO((tree, tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -5526,6 +5527,32 @@ qualify_lookup (val, flags)\n   return val;\n }\n \n+/* Any other BINDING overrides an implicit TYPENAME.  Warn about\n+   that.  */\n+\n+static void\n+warn_about_implicit_typename_lookup (typename, binding)\n+     tree typename;\n+     tree binding;\n+{\n+  tree subtype = TREE_TYPE (TREE_TYPE (typename));\n+  tree name = DECL_NAME (typename);\n+\n+  if (! (TREE_CODE (binding) == TEMPLATE_DECL\n+\t && CLASSTYPE_TEMPLATE_INFO (subtype)\n+\t && CLASSTYPE_TI_TEMPLATE (subtype) == binding)\n+      && ! (TREE_CODE (binding) == TYPE_DECL\n+\t    && same_type_p (TREE_TYPE (binding), subtype)))\n+    {\n+      cp_warning (\"lookup of `%D' finds `%#D'\", \n+\t\t  name, binding);\n+      cp_warning (\"  instead of `%D' from dependent base class\",\n+\t\t  typename);\n+      cp_warning (\"  (use `typename %T::%D' if that's what you meant)\",\n+\t\t  constructor_name (current_class_type), name);\n+    }\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -5545,10 +5572,12 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n      tree name;\n      int prefer_type, nonclass, namespaces_only;\n {\n-  register tree val;\n+  tree t;\n+  tree val = NULL_TREE;\n   int yylex = 0;\n   tree from_obj = NULL_TREE;\n   int flags;\n+  int val_is_implicit_typename = 0;\n \n   /* Hack: copy flag set by parser, if set. */\n   if (only_namespace_names)\n@@ -5623,67 +5652,49 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n     }\n \n   /* First, look in non-namespace scopes.  */\n-  for (val = IDENTIFIER_BINDING (name); val; val = TREE_CHAIN (val))\n+  for (t = IDENTIFIER_BINDING (name); t; t = TREE_CHAIN (t))\n     {\n-      if (!LOCAL_BINDING_P (val) && nonclass)\n+      tree binding;\n+\n+      if (!LOCAL_BINDING_P (t) && nonclass)\n \t/* We're not looking for class-scoped bindings, so keep going.  */\n \tcontinue;\n       \n       /* If this is the kind of thing we're looking for, we're done.  */\n-      if (qualify_lookup (BINDING_VALUE (val), flags))\n-\t{\n-\t  val = BINDING_VALUE (val);\n-\t  break;\n-\t}\n+      if (qualify_lookup (BINDING_VALUE (t), flags))\n+\tbinding = BINDING_VALUE (t);\n       else if ((flags & LOOKUP_PREFER_TYPES) \n-\t       && qualify_lookup (BINDING_TYPE (val), flags))\n-\t{\n-\t  val = BINDING_TYPE (val);\n-\t  break;\n+\t       && qualify_lookup (BINDING_TYPE (t), flags))\n+\tbinding = BINDING_TYPE (t);\n+      else\n+\tbinding = NULL_TREE;\n+\n+      if (binding\n+\t  && (!val || !(TREE_CODE (binding) == TYPE_DECL\n+\t\t\t&& IMPLICIT_TYPENAME_P (TREE_TYPE (binding)))))\n+\t{\n+\t  if (val_is_implicit_typename && !yylex)\n+\t    warn_about_implicit_typename_lookup (val, binding);\n+\t  val = binding;\n+\t  val_is_implicit_typename \n+\t    = (TREE_CODE (val) == TYPE_DECL\n+\t       && IMPLICIT_TYPENAME_P (TREE_TYPE (val)));\n+\t  if (!val_is_implicit_typename)\n+\t    break;\n \t}\n     }\n \n-  /* If we found a type from a dependent base class (using the\n-     implicit typename extension) make sure that there's not some\n-     global name which should be chosen instead.  */\n-  if (val && TREE_CODE (val) == TYPE_DECL\n-      && IMPLICIT_TYPENAME_P (TREE_TYPE (val)))\n+  /* Now lookup in namespace scopes.  */\n+  if (!val || val_is_implicit_typename)\n     {\n-      tree global_val;\n-\n-      /* Any other name takes precedence over an implicit typename.  Warn the\n-\t user about this potentially confusing lookup.  */\n-      global_val = unqualified_namespace_lookup (name, flags);\n-\n-      if (global_val)\n+      t = unqualified_namespace_lookup (name, flags);\n+      if (t)\n \t{\n-\t  tree subtype;\n-\n-\t  /* Only warn when not lexing; we don't want to warn if they\n-\t     use this name as a declarator.  */\n-\t  subtype = TREE_TYPE (TREE_TYPE (val));\n-\t  if (! yylex\n-\t      && ! (TREE_CODE (global_val) == TEMPLATE_DECL\n-\t\t    && CLASSTYPE_TEMPLATE_INFO (subtype)\n-\t\t    && CLASSTYPE_TI_TEMPLATE (subtype) == global_val)\n-\t      && ! (TREE_CODE (global_val) == TYPE_DECL\n-\t\t    && same_type_p (TREE_TYPE (global_val), subtype)))\n-\t    {\n-\t      cp_warning (\"lookup of `%D' finds `%#D'\", name, global_val);\n-\t      cp_warning (\"  instead of `%D' from dependent base class\",\n-\t\t\t  val);\n-\t      cp_warning (\"  (use `typename %T::%D' if that's what you meant)\",\n-\t\t\t  constructor_name (current_class_type), name);\n-\t    }\n-\n-\t  /* Use the global value instead of the implicit typename.  */\n-\t  val = global_val;\n+\t  if (val_is_implicit_typename && !yylex)\n+\t    warn_about_implicit_typename_lookup (val, t);\n+\t  val = t;\n \t}\n     }\n-  else if (!val)\n-    /* No local, or class-scoped binding.  Look for a namespace-scope\n-       declaration.  */\n-    val = unqualified_namespace_lookup (name, flags);\n \n  done:\n   if (val)"}, {"sha": "ed423e77becbcd2c805dc0dd2c281bc77d3d82f3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename18.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235f734d821eb0b079d551de729b56cb97800676/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235f734d821eb0b079d551de729b56cb97800676/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename18.C?ref=235f734d821eb0b079d551de729b56cb97800676", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Special g++ Options:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+void X();\n+\n+template <class T>\n+struct J {\n+  typedef T X;\n+};\n+\n+template <class T>\n+struct S {\n+  typedef T X;\n+\n+  struct I : public J<X> {\n+    static X* f();\n+  };\n+};\n+\n+S<int> si;"}, {"sha": "be93a9832670eda9e6332ad6b8d691380399e6e5", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename19.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235f734d821eb0b079d551de729b56cb97800676/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235f734d821eb0b079d551de729b56cb97800676/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C?ref=235f734d821eb0b079d551de729b56cb97800676", "patch": "@@ -0,0 +1,26 @@\n+// Special g++ Options:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+struct O {\n+  typedef char X;\n+};\n+\n+template <class T>\n+struct S {\n+  typedef double X;\n+\n+  template <class U>\n+  struct I : public O<U> {\n+    static X x; // WARNING - lookup finds S<T>::X\n+  };\n+};\n+\n+template <class T>\n+template <class U>\n+typename S<T>::X S<T>::I<U>::x;\n+\n+int main()\n+{\n+  return sizeof (S<int>::I<double>::x) == 1;\n+}"}]}