{"sha": "9e9ef331eb145aeff45079d4967c520ae4ff86a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5ZWYzMzFlYjE0NWFlZmY0NTA3OWQ0OTY3YzUyMGFlNGZmODZhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-13T15:47:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-13T15:47:38Z"}, "message": "re PR middle-end/32628 (bogus integer overflow warning)\n\n\tPR middle-end/32628\n\t* c-common.c (pointer_int_sum): Disregard overflow that occured only\n\tbecause of sign-extension change when converting to sizetype here...\n\t* fold-const.c (fold_convert_const_int_from_int): ...and not here.\n\n\t* fold-const.c (fold_binary_op_with_conditional_arg): Do not restrict\n\tthe folding to constants.  Remove redundant final conversion.\n\t(fold_binary) <associate>: Do not associate if the re-association of\n\tconstants alone overflows.\n\t(fold_binary) <FLOOR_MOD_EXPR>: Move transformation into BIT_AND_EXPR\n\tto the end of the list.\n\t(multiple_of_p) <COND_EXPR>: New case.\n\nFrom-SVN: r158274", "tree": {"sha": "04470a1e966906835dc05e1a512d55c9904ce185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04470a1e966906835dc05e1a512d55c9904ce185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9ef331eb145aeff45079d4967c520ae4ff86a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9ef331eb145aeff45079d4967c520ae4ff86a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9ef331eb145aeff45079d4967c520ae4ff86a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9ef331eb145aeff45079d4967c520ae4ff86a8/comments", "author": null, "committer": null, "parents": [{"sha": "9db94baaef1eb984eb5ed91700b1091342831161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db94baaef1eb984eb5ed91700b1091342831161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db94baaef1eb984eb5ed91700b1091342831161"}], "stats": {"total": 185, "additions": 106, "deletions": 79}, "files": [{"sha": "a20c3799a9b77d89d09a5a94a8115727dc12b6c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e9ef331eb145aeff45079d4967c520ae4ff86a8", "patch": "@@ -1,3 +1,18 @@\n+2010-04-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/32628\n+\t* c-common.c (pointer_int_sum): Disregard overflow that occured only\n+\tbecause of sign-extension change when converting to sizetype here...\n+\t* fold-const.c (fold_convert_const_int_from_int): ...and not here.\n+\n+\t* fold-const.c (fold_binary_op_with_conditional_arg): Do not restrict\n+\tthe folding to constants.  Remove redundant final conversion.\n+\t(fold_binary) <associate>: Do not associate if the re-association of\n+\tconstants alone overflows.\n+\t(fold_binary) <FLOOR_MOD_EXPR>: Move transformation into BIT_AND_EXPR\n+\tto the end of the list.\n+\t(multiple_of_p) <COND_EXPR>: New case.\n+\n 2010-04-13  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* opt-functions.awk (opt_sanitized_name): New."}, {"sha": "0669ba0ab73cd6aafd126213ab52e6b72fae8ce1", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9e9ef331eb145aeff45079d4967c520ae4ff86a8", "patch": "@@ -3806,12 +3806,18 @@ pointer_int_sum (location_t loc, enum tree_code resultcode,\n \t\t\t\t\t     TYPE_UNSIGNED (sizetype)), intop);\n \n   /* Replace the integer argument with a suitable product by the object size.\n-     Do this multiplication as signed, then convert to the appropriate\n-     type for the pointer operation.  */\n-  intop = convert (sizetype,\n-\t\t   build_binary_op (loc,\n-\t\t\t\t    MULT_EXPR, intop,\n-\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n+     Do this multiplication as signed, then convert to the appropriate type\n+     for the pointer operation and disregard an overflow that occured only\n+     because of the sign-extension change in the latter conversion.  */\n+  {\n+    tree t = build_binary_op (loc,\n+\t\t\t      MULT_EXPR, intop,\n+\t\t\t      convert (TREE_TYPE (intop), size_exp), 1);\n+    intop = convert (sizetype, t);\n+    if (TREE_OVERFLOW_P (intop) && !TREE_OVERFLOW (t))\n+      intop = build_int_cst_wide (TREE_TYPE (intop), TREE_INT_CST_LOW (intop),\n+\t\t\t\t  TREE_INT_CST_HIGH (intop));\n+  }\n \n   /* Create the sum or difference.  */\n   if (resultcode == MINUS_EXPR)"}, {"sha": "34e5874eadd8f1b0c415388e85a258942c05df0c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 79, "deletions": 73, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9ef331eb145aeff45079d4967c520ae4ff86a8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9e9ef331eb145aeff45079d4967c520ae4ff86a8", "patch": "@@ -2252,23 +2252,7 @@ fold_convert_const_int_from_int (tree type, const_tree arg1)\n      appropriately sign-extended or truncated.  */\n   t = force_fit_type_double (type, TREE_INT_CST_LOW (arg1),\n \t\t\t     TREE_INT_CST_HIGH (arg1),\n-\t\t             /* Don't set the overflow when\n-\t\t      \t\tconverting from a pointer,  */\n-\t\t\t     !POINTER_TYPE_P (TREE_TYPE (arg1))\n-\t\t\t     /* or to a sizetype with same signedness\n-\t\t\t\tand the precision is unchanged.\n-\t\t\t\t???  sizetype is always sign-extended,\n-\t\t\t\tbut its signedness depends on the\n-\t\t\t\tfrontend.  Thus we see spurious overflows\n-\t\t\t\there if we do not check this.  */\n-\t\t\t     && !((TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t\t\t   == TYPE_PRECISION (type))\n-\t\t\t\t  && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t\t\t      == TYPE_UNSIGNED (type))\n-\t\t\t\t  && ((TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n-\t\t\t\t       && TYPE_IS_SIZETYPE (TREE_TYPE (arg1)))\n-\t\t\t\t      || (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t\t\t  && TYPE_IS_SIZETYPE (type)))),\n+\t\t\t     !POINTER_TYPE_P (TREE_TYPE (arg1)),\n \t\t\t     (TREE_INT_CST_HIGH (arg1) < 0\n \t\t \t      && (TYPE_UNSIGNED (type)\n \t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n@@ -6731,12 +6715,6 @@ fold_binary_op_with_conditional_arg (location_t loc,\n   tree lhs = NULL_TREE;\n   tree rhs = NULL_TREE;\n \n-  /* This transformation is only worthwhile if we don't have to wrap\n-     arg in a SAVE_EXPR, and the operation can be simplified on at least\n-     one of the branches once its pushed inside the COND_EXPR.  */\n-  if (!TREE_CONSTANT (arg))\n-    return NULL_TREE;\n-\n   if (TREE_CODE (cond) == COND_EXPR)\n     {\n       test = TREE_OPERAND (cond, 0);\n@@ -6758,6 +6736,14 @@ fold_binary_op_with_conditional_arg (location_t loc,\n       false_value = constant_boolean_node (false, testtype);\n     }\n \n+  /* This transformation is only worthwhile if we don't have to wrap ARG\n+     in a SAVE_EXPR and the operation can be simplified on at least one\n+     of the branches once its pushed inside the COND_EXPR.  */\n+  if (!TREE_CONSTANT (arg)\n+      && (TREE_SIDE_EFFECTS (arg)\n+\t  || TREE_CONSTANT (true_value) || TREE_CONSTANT (false_value)))\n+    return NULL_TREE;\n+\n   arg = fold_convert_loc (loc, arg_type, arg);\n   if (lhs == 0)\n     {\n@@ -6776,8 +6762,11 @@ fold_binary_op_with_conditional_arg (location_t loc,\n \trhs = fold_build2_loc (loc, code, type, arg, false_value);\n     }\n \n-  test = fold_build3_loc (loc, COND_EXPR, type, test, lhs, rhs);\n-  return fold_convert_loc (loc, type, test);\n+  /* Check that we have simplified at least one of the branches.  */\n+  if (!TREE_CONSTANT (arg) && !TREE_CONSTANT (lhs) && !TREE_CONSTANT (rhs))\n+    return NULL_TREE;\n+\n+  return fold_build3_loc (loc, COND_EXPR, type, test, lhs, rhs);\n }\n \n \f\n@@ -10628,23 +10617,39 @@ fold_binary_loc (location_t loc,\n \t  var1 = split_tree (arg1, code, &con1, &lit1, &minus_lit1,\n \t\t\t     code == MINUS_EXPR);\n \n-\t  /* With undefined overflow we can only associate constants\n-\t     with one variable.  */\n-\t  if (((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n-\t       || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n-\t      && var0 && var1)\n+\t  /* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */\n+\t  if (code == MINUS_EXPR)\n+\t    code = PLUS_EXPR;\n+\n+\t  /* With undefined overflow we can only associate constants with one\n+\t     variable, and constants whose association doesn't overflow.  */\n+\t  if ((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n+\t      || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n \t    {\n-\t      tree tmp0 = var0;\n-\t      tree tmp1 = var1;\n-\n-\t      if (TREE_CODE (tmp0) == NEGATE_EXPR)\n-\t        tmp0 = TREE_OPERAND (tmp0, 0);\n-\t      if (TREE_CODE (tmp1) == NEGATE_EXPR)\n-\t        tmp1 = TREE_OPERAND (tmp1, 0);\n-\t      /* The only case we can still associate with two variables\n-\t\t is if they are the same, modulo negation.  */\n-\t      if (!operand_equal_p (tmp0, tmp1, 0))\n-\t        ok = false;\n+\t      if (var0 && var1)\n+\t\t{\n+\t\t  tree tmp0 = var0;\n+\t\t  tree tmp1 = var1;\n+\n+\t\t  if (TREE_CODE (tmp0) == NEGATE_EXPR)\n+\t\t    tmp0 = TREE_OPERAND (tmp0, 0);\n+\t\t  if (TREE_CODE (tmp1) == NEGATE_EXPR)\n+\t\t    tmp1 = TREE_OPERAND (tmp1, 0);\n+\t\t  /* The only case we can still associate with two variables\n+\t\t     is if they are the same, modulo negation.  */\n+\t\t  if (!operand_equal_p (tmp0, tmp1, 0))\n+\t\t    ok = false;\n+\t\t}\n+\n+\t      if (ok && lit0 && lit1)\n+\t\t{\n+\t\t  tree tmp0 = fold_convert (type, lit0);\n+\t\t  tree tmp1 = fold_convert (type, lit1);\n+\n+\t\t  if (!TREE_OVERFLOW (tmp0) && !TREE_OVERFLOW (tmp1)\n+\t\t      && TREE_OVERFLOW (fold_build2 (code, type, tmp0, tmp1)))\n+\t\t    ok = false;\n+\t\t}\n \t    }\n \n \t  /* Only do something if we found more than two objects.  Otherwise,\n@@ -10655,10 +10660,6 @@ fold_binary_loc (location_t loc,\n \t\t       + (lit0 != 0) + (lit1 != 0)\n \t\t       + (minus_lit0 != 0) + (minus_lit1 != 0))))\n \t    {\n-\t      /* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */\n-\t      if (code == MINUS_EXPR)\n-\t\tcode = PLUS_EXPR;\n-\n \t      var0 = associate_trees (loc, var0, var1, code, type);\n \t      con0 = associate_trees (loc, con0, con1, code, type);\n \t      lit0 = associate_trees (loc, lit0, lit1, code, type);\n@@ -12222,34 +12223,6 @@ fold_binary_loc (location_t loc,\n \t  && TREE_INT_CST_HIGH (arg1) == -1)\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n \n-      /* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,\n-         i.e. \"X % C\" into \"X & (C - 1)\", if X and C are positive.  */\n-      strict_overflow_p = false;\n-      if ((code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR)\n-\t  && (TYPE_UNSIGNED (type)\n-\t      || tree_expr_nonnegative_warnv_p (op0, &strict_overflow_p)))\n-\t{\n-\t  tree c = arg1;\n-\t  /* Also optimize A % (C << N)  where C is a power of 2,\n-\t     to A & ((C << N) - 1).  */\n-\t  if (TREE_CODE (arg1) == LSHIFT_EXPR)\n-\t    c = TREE_OPERAND (arg1, 0);\n-\n-\t  if (integer_pow2p (c) && tree_int_cst_sgn (c) > 0)\n-\t    {\n-\t      tree mask = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (arg1), arg1,\n-\t\t\t\t       build_int_cst (TREE_TYPE (arg1), 1));\n-\t      if (strict_overflow_p)\n-\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n-\t\t\t\t\t\"occur when simplifying \"\n-\t\t\t\t\t\"X % (power of two)\"),\n-\t\t\t\t       WARN_STRICT_OVERFLOW_MISC);\n-\t      return fold_build2_loc (loc, BIT_AND_EXPR, type,\n-\t\t\t\t  fold_convert_loc (loc, type, arg0),\n-\t\t\t\t  fold_convert_loc (loc, type, mask));\n-\t    }\n-\t}\n-\n       /* X % -C is the same as X % C.  */\n       if (code == TRUNC_MOD_EXPR\n \t  && !TYPE_UNSIGNED (type)\n@@ -12273,6 +12246,7 @@ fold_binary_loc (location_t loc,\n \t\t\t    fold_convert_loc (loc, type,\n \t\t\t\t\t      TREE_OPERAND (arg1, 0)));\n \n+      strict_overflow_p = false;\n       if (TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n \t\t\t\t\t &strict_overflow_p)))\n@@ -12284,6 +12258,34 @@ fold_binary_loc (location_t loc,\n \t  return fold_convert_loc (loc, type, tem);\n \t}\n \n+      /* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,\n+         i.e. \"X % C\" into \"X & (C - 1)\", if X and C are positive.  */\n+      if ((code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR)\n+\t  && (TYPE_UNSIGNED (type)\n+\t      || tree_expr_nonnegative_warnv_p (op0, &strict_overflow_p)))\n+\t{\n+\t  tree c = arg1;\n+\t  /* Also optimize A % (C << N)  where C is a power of 2,\n+\t     to A & ((C << N) - 1).  */\n+\t  if (TREE_CODE (arg1) == LSHIFT_EXPR)\n+\t    c = TREE_OPERAND (arg1, 0);\n+\n+\t  if (integer_pow2p (c) && tree_int_cst_sgn (c) > 0)\n+\t    {\n+\t      tree mask\n+\t\t= fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (arg1), arg1,\n+\t\t\t\t   build_int_cst (TREE_TYPE (arg1), 1));\n+\t      if (strict_overflow_p)\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when simplifying \"\n+\t\t\t\t\t\"X % (power of two)\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_MISC);\n+\t      return fold_build2_loc (loc, BIT_AND_EXPR, type,\n+\t\t\t\t      fold_convert_loc (loc, type, arg0),\n+\t\t\t\t      fold_convert_loc (loc, type, mask));\n+\t    }\n+\t}\n+\n       return NULL_TREE;\n \n     case LROTATE_EXPR:\n@@ -14820,6 +14822,10 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n     case SAVE_EXPR:\n       return multiple_of_p (type, TREE_OPERAND (top, 0), bottom);\n \n+    case COND_EXPR:\n+      return (multiple_of_p (type, TREE_OPERAND (top, 1), bottom)\n+\t      && multiple_of_p (type, TREE_OPERAND (top, 2), bottom));\n+\n     case INTEGER_CST:\n       if (TREE_CODE (bottom) != INTEGER_CST\n \t  || integer_zerop (bottom)"}]}