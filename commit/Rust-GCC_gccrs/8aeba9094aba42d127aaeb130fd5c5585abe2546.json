{"sha": "8aeba9094aba42d127aaeb130fd5c5585abe2546", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlYmE5MDk0YWJhNDJkMTI3YWFlYjEzMGZkNWM1NTg1YWJlMjU0Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-01-19T20:24:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-19T20:24:22Z"}, "message": "genoutput.c (name_for_index): New function.\n\n        * genoutput.c (name_for_index): New function.\n        (scan_operands, validate_insn_alternatives): Use it.\n        * genrecog.c (insn_name_ptr_size): New variable.\n        (make_insn_sequence): Fill in insn_name_ptr.\n        (merge_trees): Use it.\n\nFrom-SVN: r24770", "tree": {"sha": "7f380dcbcd21e0f2b8a59a6b0b459bcd22438961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f380dcbcd21e0f2b8a59a6b0b459bcd22438961"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aeba9094aba42d127aaeb130fd5c5585abe2546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeba9094aba42d127aaeb130fd5c5585abe2546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aeba9094aba42d127aaeb130fd5c5585abe2546", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeba9094aba42d127aaeb130fd5c5585abe2546/comments", "author": null, "committer": null, "parents": [{"sha": "67e5db2c3947db5c50d6f7a80dd71795df7d2c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e5db2c3947db5c50d6f7a80dd71795df7d2c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e5db2c3947db5c50d6f7a80dd71795df7d2c4a"}], "stats": {"total": 100, "additions": 84, "deletions": 16}, "files": [{"sha": "457463471328d64de31bc989b2bfa9325dab0277", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aeba9094aba42d127aaeb130fd5c5585abe2546", "patch": "@@ -1,3 +1,11 @@\n+Tue Jan 19 16:56:03 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genoutput.c (name_for_index): New function.\n+\t(scan_operands, validate_insn_alternatives): Use it.\n+\t* genrecog.c (insn_name_ptr_size): New variable.\n+\t(make_insn_sequence): Fill in insn_name_ptr.\n+\t(merge_trees): Use it.\n+\n Tue Jan 19 16:37:36 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* i386/isc.h (TARGET_DEFAULT): Define symbolicly."}, {"sha": "04667fee0ee7c5a1958e96d183db4a9ddf425513", "filename": "gcc/genoutput.c", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=8aeba9094aba42d127aaeb130fd5c5585abe2546", "patch": "@@ -170,6 +170,7 @@ int have_constraints;\n \n static int have_error;\n \f\n+static char * name_for_index PROTO((int));\n static void output_prologue PROTO((void));\n static void output_epilogue PROTO((void));\n static void scan_operands PROTO((rtx, int, int));\n@@ -181,6 +182,29 @@ static void gen_expand PROTO((rtx));\n static void gen_split PROTO((rtx));\n static int n_occurrences PROTO((int, char *));\n \f\n+static char *\n+name_for_index (index)\n+     int index;\n+{\n+  static char buf[100];\n+\n+  struct data *i, *last_named = NULL;\n+  for (i = insn_data; i ; i = i->next)\n+    {\n+      if (i->index_number == index)\n+\treturn i->name;\n+      if (i->name)\n+\tlast_named = i;\n+    }\n+\n+  if (last_named)\n+    sprintf(buf, \"%s+%d\", last_named->name, index - last_named->index_number);\n+  else\n+    sprintf(buf, \"insn %d\", index);\n+\n+  return buf;\n+}\n+\n static void\n output_prologue ()\n {\n@@ -440,13 +464,13 @@ scan_operands (part, this_address_p, this_strict_low)\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error (\"Too many operands (%d) in definition %d.\\n\",\n-\t\t max_opno + 1, next_index_number);\n+\t  error (\"Too many operands (%d) in definition %s.\\n\",\n+\t\t max_opno + 1, name_for_index (next_index_number));\n \t  return;\n \t}\n       if (seen[opno])\n-\terror (\"Definition %d specified operand number %d more than once.\\n\",\n-\t       next_index_number, opno);\n+\terror (\"Definition %s specified operand number %d more than once.\\n\",\n+\t       name_for_index (next_index_number), opno);\n       seen[opno] = 1;\n       modes[opno] = GET_MODE (part);\n       strict_low[opno] = this_strict_low;\n@@ -466,13 +490,13 @@ scan_operands (part, this_address_p, this_strict_low)\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error (\"Too many operands (%d) in definition %d.\\n\",\n-\t\t max_opno + 1, next_index_number);\n+\t  error (\"Too many operands (%d) in definition %s.\\n\",\n+\t\t max_opno + 1, name_for_index (next_index_number));\n \t  return;\n \t}\n       if (seen[opno])\n-\terror (\"Definition %d specified operand number %d more than once.\\n\",\n-\t       next_index_number, opno);\n+\terror (\"Definition %s specified operand number %d more than once.\\n\",\n+\t       name_for_index (next_index_number), opno);\n       seen[opno] = 1;\n       modes[opno] = GET_MODE (part);\n       strict_low[opno] = 0;\n@@ -493,13 +517,13 @@ scan_operands (part, this_address_p, this_strict_low)\n \tmax_opno = opno;\n       if (max_opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error (\"Too many operands (%d) in definition %d.\\n\",\n-\t\t max_opno + 1, next_index_number);\n+\t  error (\"Too many operands (%d) in definition %s.\\n\",\n+\t\t max_opno + 1, name_for_index (next_index_number));\n \t  return;\n \t}\n       if (seen[opno])\n-\terror (\"Definition %d specified operand number %d more than once.\\n\",\n-\t       next_index_number, opno);\n+\terror (\"Definition %s specified operand number %d more than once.\\n\",\n+\t       name_for_index (next_index_number), opno);\n       seen[opno] = 1;\n       modes[opno] = GET_MODE (part);\n       strict_low[opno] = 0;\n@@ -644,8 +668,8 @@ validate_insn_alternatives (d)\n \tif (n == 0)\n \t  n = d->op_n_alternatives[start];\n \telse if (n != d->op_n_alternatives[start])\n-\t  error (\"wrong number of alternatives in operand %d of insn number %d\",\n-\t\t start, d->index_number);\n+\t  error (\"wrong number of alternatives in operand %d of insn %s\",\n+\t\t start, name_for_index (d->index_number));\n       }\n   /* Record the insn's overall number of alternatives.  */\n   d->n_alternatives = n;"}, {"sha": "da2a0cf36e9722b1b4cfed6875505523f07d8804", "filename": "gcc/genrecog.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeba9094aba42d127aaeb130fd5c5585abe2546/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=8aeba9094aba42d127aaeb130fd5c5585abe2546", "patch": "@@ -60,8 +60,9 @@ struct obstack *rtl_obstack = &obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+/* Holds an array of names indexed by insn_code_number.  */\n char **insn_name_ptr = 0;\n+int insn_name_ptr_size = 0;\n \n /* Data structure for a listhead of decision trees.  The alternatives\n    to a node are kept in a doublely-linked list so we can easily add nodes\n@@ -210,6 +211,37 @@ make_insn_sequence (insn, type)\n   struct decision *last;\n   struct decision_head head;\n \n+  {\n+    static char *last_real_name = \"insn\";\n+    static int last_real_code = 0;\n+    char *name;\n+\n+    if (insn_name_ptr_size <= next_insn_code)\n+      {\n+\tint new_size;\n+\tnew_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n+\tinsn_name_ptr = xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n+\tbzero (insn_name_ptr + insn_name_ptr_size,\n+\t       sizeof(char *) * (new_size - insn_name_ptr_size));\n+\tinsn_name_ptr_size = new_size;\n+      }\n+\n+    name = XSTR (insn, 0);\n+    if (!name || name[0] == '\\0')\n+      {\n+\tname = xmalloc (strlen (last_real_name) + 10);\n+\tsprintf (name, \"%s+%d\", last_real_name,\n+\t\t next_insn_code - last_real_code);\n+      }\n+    else\n+      {\n+\tlast_real_name = name;\n+\tlast_real_code = next_insn_code;\n+      }\n+  \n+    insn_name_ptr[next_insn_code] = name;\n+  }  \n+\n   if (XVECLEN (insn, type == RECOG) == 1)\n     x = XVECEXP (insn, type == RECOG, 0);\n   else\n@@ -896,7 +928,11 @@ merge_trees (oldh, addh)\n \t\t      old->num_clobbers_to_add = 0;\n \t\t    }\n \t\t  else\n-\t\t    fatal (\"Two actions at one point in tree\");\n+\t\t    fatal (\"Two actions at one point in tree for insns \\\"%s\\\" (%d) and \\\"%s\\\" (%d)\",\n+\t\t\t   insn_name_ptr[old->insn_code_number],\n+\t\t\t   old->insn_code_number,\n+\t\t\t   insn_name_ptr[add->insn_code_number],\n+\t\t\t   add->insn_code_number);\n \t\t}\n \n \t      if (old->insn_code_number == -1)"}]}