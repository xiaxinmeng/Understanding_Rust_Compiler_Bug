{"sha": "f29b857f303d388e8697e64414a27e6cafe9cce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5Yjg1N2YzMDNkMzg4ZTg2OTdlNjQ0MTRhMjdlNmNhZmU5Y2NlMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-12-19T16:24:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-19T16:24:34Z"}, "message": "PR ada/15803, ada/15805\n\n2007-12-19  Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\tPR ada/15803, ada/15805\n\t* sem_ch6.adb, sem_ch3.adb (Constrain_Access): In Ada2005, diagnose\n\tillegal access subtypes when there is a constrained partial view.\n\t(Check_For_Premature_Usage): New procedure inside\n\tAccess_Subprogram_Declaration for checking that an access-to-subprogram\n\ttype doesn't reference its own name within any formal parameters or\n\tresult type (including within nested anonymous access types).\n\t(Access_Subprogram_Declaration): Add call to Check_For_Premature_Usage.\n\t(Sem_Ch3.Analyze_Object_Declaration, Sem_ch6.Process_Formals): if the\n\tcontext is an access_to_variable, the expression cannot be an\n\taccess_to_constant.\n\nFrom-SVN: r131079", "tree": {"sha": "7bd8f604f676059fb88629a80dabde0b96b3e2f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd8f604f676059fb88629a80dabde0b96b3e2f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29b857f303d388e8697e64414a27e6cafe9cce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29b857f303d388e8697e64414a27e6cafe9cce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29b857f303d388e8697e64414a27e6cafe9cce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29b857f303d388e8697e64414a27e6cafe9cce2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce914b984f952bfe69b9425a967b0bb4490a2ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce914b984f952bfe69b9425a967b0bb4490a2ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce914b984f952bfe69b9425a967b0bb4490a2ac0"}], "stats": {"total": 100, "additions": 79, "deletions": 21}, "files": [{"sha": "920b1494040362c706c5070253ff977b62723af6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29b857f303d388e8697e64414a27e6cafe9cce2/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29b857f303d388e8697e64414a27e6cafe9cce2/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f29b857f303d388e8697e64414a27e6cafe9cce2", "patch": "@@ -917,13 +917,66 @@ package body Sem_Ch3 is\n      (T_Name : Entity_Id;\n       T_Def  : Node_Id)\n    is\n-      Formals : constant List_Id := Parameter_Specifications (T_Def);\n-      Formal  : Entity_Id;\n-      D_Ityp  : Node_Id;\n \n+      procedure Check_For_Premature_Usage (Def : Node_Id);\n+      --  Check that type T_Name is not used, directly or recursively,\n+      --  as a parameter or a return type in Def. Def is either a subtype,\n+      --  an access_definition, or an access_to_subprogram_definition.\n+\n+      -------------------------------\n+      -- Check_For_Premature_Usage --\n+      -------------------------------\n+\n+      procedure Check_For_Premature_Usage (Def : Node_Id) is\n+         Param : Node_Id;\n+\n+      begin\n+         --  Check for a subtype mark\n+\n+         if Nkind (Def) in N_Has_Etype then\n+            if Etype (Def) = T_Name then\n+               Error_Msg_N\n+                 (\"type& cannot be used before end of its declaration\", Def);\n+            end if;\n+\n+         --  If this is not a subtype, then this is an access_definition\n+\n+         elsif Nkind (Def) = N_Access_Definition then\n+            if Present (Access_To_Subprogram_Definition (Def)) then\n+               Check_For_Premature_Usage\n+                 (Access_To_Subprogram_Definition (Def));\n+            else\n+               Check_For_Premature_Usage (Subtype_Mark (Def));\n+            end if;\n+\n+         --  The only cases left are N_Access_Function_Definition and\n+         --  N_Access_Procedure_Definition.\n+\n+         else\n+            if Present (Parameter_Specifications (Def)) then\n+               Param := First (Parameter_Specifications (Def));\n+               while Present (Param) loop\n+                  Check_For_Premature_Usage (Parameter_Type (Param));\n+                  Param := Next (Param);\n+               end loop;\n+            end if;\n+\n+            if Nkind (Def) = N_Access_Function_Definition then\n+               Check_For_Premature_Usage (Result_Definition (Def));\n+            end if;\n+         end if;\n+      end Check_For_Premature_Usage;\n+\n+      --  Local variables\n+\n+      Formals    : constant List_Id := Parameter_Specifications (T_Def);\n+      Formal     : Entity_Id;\n+      D_Ityp     : Node_Id;\n       Desig_Type : constant Entity_Id :=\n                      Create_Itype (E_Subprogram_Type, Parent (T_Def));\n \n+   --  Start of processing for Access_Subprogram_Declaration\n+\n    begin\n       --  Associate the Itype node with the inner full-type declaration or\n       --  subprogram spec. This is required to handle nested anonymous\n@@ -1018,6 +1071,10 @@ package body Sem_Ch3 is\n          Set_Parent (Desig_Type, Empty);\n       end if;\n \n+      --  Check for premature usage of the type being defined\n+\n+      Check_For_Premature_Usage (T_Def);\n+\n       --  The return type and/or any parameter type may be incomplete. Mark\n       --  the subprogram_type as depending on the incomplete type, so that\n       --  it can be updated when the full type declaration is seen. This\n@@ -2355,7 +2412,7 @@ package body Sem_Ch3 is\n          Analyze (E);\n \n          --  In case of errors detected in the analysis of the expression,\n-         --  decorate it with the expected type to avoid cascade errors\n+         --  decorate it with the expected type to avoid cascaded errors\n \n          if No (Etype (E)) then\n             Set_Etype (E, T);\n@@ -2367,18 +2424,17 @@ package body Sem_Ch3 is\n \n          Set_Is_True_Constant (Id, True);\n \n-         --  If the initialization expression is an access to constant,\n-         --  it cannot be used with an access type.\n+         --  If the object is an access to variable, the initialization\n+         --  expression cannot be an access to constant.\n \n-         if Is_Access_Type (Etype (E))\n-           and then Is_Access_Constant (Etype (E))\n-           and then Is_Access_Type (T)\n+         if Is_Access_Type (T)\n            and then not Is_Access_Constant (T)\n+           and then Is_Access_Type (Etype (E))\n+           and then Is_Access_Constant (Etype (E))\n          then\n-            Error_Msg_NE (\"object of type& cannot be initialized with \" &\n-                          \"an access-to-constant expression\",\n-                          E,\n-                          T);\n+            Error_Msg_N\n+              (\"object that is an access to variable cannot be initialized \" &\n+                \"with an access-to-constant expression\", E);\n          end if;\n \n          --  If we are analyzing a constant declaration, set its completion\n@@ -8999,9 +9055,11 @@ package body Sem_Ch3 is\n             return;\n          end if;\n \n-         if Ekind (T) = E_General_Access_Type\n+         if (Ekind (T) = E_General_Access_Type\n+              or else Ada_Version >= Ada_05)\n            and then Has_Private_Declaration (Desig_Type)\n            and then In_Open_Scopes (Scope (Desig_Type))\n+           and then Has_Discriminants (Desig_Type)\n          then\n             --  Enforce rule that the constraint is illegal if there is\n             --  an unconstrained view of the designated type. This means\n@@ -9012,7 +9070,8 @@ package body Sem_Ch3 is\n \n             --  Rule updated for Ada 2005: the private type is said to have\n             --  a constrained partial view, given that objects of the type\n-            --  can be declared.\n+            --  can be declared. Furthermore, the rule applies to all access\n+            --  types, unlike the rule concerning default discriminants.\n \n             declare\n                Pack  : constant Node_Id :="}, {"sha": "9aaa37f9fb4f3968bb9d40dbbf85f084c80af848", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29b857f303d388e8697e64414a27e6cafe9cce2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29b857f303d388e8697e64414a27e6cafe9cce2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f29b857f303d388e8697e64414a27e6cafe9cce2", "patch": "@@ -6996,18 +6996,17 @@ package body Sem_Ch6 is\n \n             Analyze_Per_Use_Expression (Default, Formal_Type);\n \n-            --  Check that an access to constant is not used with an\n-            --  access type.\n+            --  An access to constant cannot be the default for\n+            --  an access parameter that is an access to variable.\n \n             if Ekind (Formal_Type) = E_Anonymous_Access_Type\n               and then not Is_Access_Constant (Formal_Type)\n               and then Is_Access_Type (Etype (Default))\n               and then Is_Access_Constant (Etype (Default))\n             then\n-               Error_Msg_NE (\"parameter of type& cannot be initialized \" &\n-                             \"with an access-to-constant expression\",\n-                             Default,\n-                             Formal_Type);\n+               Error_Msg_N\n+                 (\"formal that is access to variable cannot be initialized \" &\n+                    \"with an access-to-constant expression\", Default);\n             end if;\n \n             --  Check that the designated type of an access parameter's default"}]}