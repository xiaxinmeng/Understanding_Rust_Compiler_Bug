{"sha": "38f31687815ca01c8851a8322e67e75e2afce1ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmMzE2ODc4MTVjYTAxYzg4NTFhODMyMmU2N2U3NWUyYWZjZTFhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-07-09T18:28:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-07-09T18:28:23Z"}, "message": "alpha.c (emit_insxl, [...]): New functions.\n\n        * config/alpha/alpha.c (emit_insxl, alpha_expand_compare_and_swap_12,\n        alpha_split_compare_and_swap_12, alpha_expand_lock_test_and_set_12,\n        alpha_split_lock_test_and_set_12): New functions.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.md (UNSPEC_MB, UNSPEC_ATOMIC,\n        UNSPEC_CMPXCHG, UNSPEC_XCHG): Rename from UNSPECV_FOO.\n        * config/alpha/sync.md (I12MODE): New.\n        (memory_barrier, mb_internal): Use unspec instead of unspec_volatile.\n        (sync_<fetchop_name><I48MODE>): Likewise.\n        (sync_nand<I48MODE>): Likewise.\n        (sync_old_<fetchop_name><I48MODE>): Likewise.\n        (sync_new_<fetchop_name><I48MODE>): Likewise.\n        (sync_old_nand<I48MODE>, sync_new_nand<I48MODE>): Likewise.\n        (sync_compare_and_swap<I48MODE>): Likewise.\n        (sync_lock_test_and_set<I48MODE>): Likewise.\n        (sync_compare_and_swap<I12MODE>): New.\n        (sync_compare_and_swap<I12MODE>_1): New.\n        (sync_lock_test_and_set<I12MODE>): New.\n        (sync_lock_test_and_set<I12MODE>_1): New.\n\n        * lib/target-supports.exp (check_effective_target_sync_char_short):\n        Add alpha.\n\nFrom-SVN: r101833", "tree": {"sha": "fa5c58ca03b4af0a62ad46d5f7e3bd0344b48e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa5c58ca03b4af0a62ad46d5f7e3bd0344b48e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38f31687815ca01c8851a8322e67e75e2afce1ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f31687815ca01c8851a8322e67e75e2afce1ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f31687815ca01c8851a8322e67e75e2afce1ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f31687815ca01c8851a8322e67e75e2afce1ab/comments", "author": null, "committer": null, "parents": [{"sha": "563cb6be0f31cea2cece0482aff2ede0acc1d259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563cb6be0f31cea2cece0482aff2ede0acc1d259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/563cb6be0f31cea2cece0482aff2ede0acc1d259"}], "stats": {"total": 322, "additions": 294, "deletions": 28}, "files": [{"sha": "f6a729a9695072ec5fecdfadb9cb601e6a5953ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -1,9 +1,30 @@\n+2005-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (emit_insxl, alpha_expand_compare_and_swap_12,\n+\talpha_split_compare_and_swap_12, alpha_expand_lock_test_and_set_12,\n+\talpha_split_lock_test_and_set_12): New functions.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.md (UNSPEC_MB, UNSPEC_ATOMIC,\n+\tUNSPEC_CMPXCHG, UNSPEC_XCHG): Rename from UNSPECV_FOO.\n+\t* config/alpha/sync.md (I12MODE): New.\n+\t(memory_barrier, mb_internal): Use unspec instead of unspec_volatile.\n+\t(sync_<fetchop_name><I48MODE>): Likewise.\n+\t(sync_nand<I48MODE>): Likewise.\n+\t(sync_old_<fetchop_name><I48MODE>): Likewise.\n+\t(sync_new_<fetchop_name><I48MODE>): Likewise.\n+\t(sync_old_nand<I48MODE>, sync_new_nand<I48MODE>): Likewise.\n+\t(sync_compare_and_swap<I48MODE>): Likewise.\n+\t(sync_lock_test_and_set<I48MODE>): Likewise.\n+\t(sync_compare_and_swap<I12MODE>): New.\n+\t(sync_compare_and_swap<I12MODE>_1): New.\n+\t(sync_lock_test_and_set<I12MODE>): New.\n+\t(sync_lock_test_and_set<I12MODE>_1): New.\n+\n 2005-07-09  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 21356\n \tPR 22332\n-\t* passes.c (execute_todo): Cleanup the CFG before updating\n-\tSSA.\n+\t* passes.c (execute_todo): Cleanup the CFG before updating SSA.\n \n 2005-07-09  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "5dd57343c582740ea5c881ccf0d49603c62aad26", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -103,7 +103,13 @@ extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n extern void alpha_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern void alpha_split_compare_and_swap (rtx, rtx, rtx, rtx, rtx);\n+extern void alpha_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n+extern void alpha_split_compare_and_swap_12 (enum machine_mode, rtx, rtx,\n+\t\t\t\t\t     rtx, rtx, rtx, rtx, rtx);\n extern void alpha_split_lock_test_and_set (rtx, rtx, rtx, rtx);\n+extern void alpha_expand_lock_test_and_set_12 (rtx, rtx, rtx);\n+extern void alpha_split_lock_test_and_set_12 (enum machine_mode, rtx, rtx,\n+\t\t\t\t\t      rtx, rtx, rtx);\n #endif\n \n extern rtx alpha_need_linkage (const char *, int);"}, {"sha": "5d8f72df2b102570197fc354cede94599df81e08", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -4453,6 +4453,34 @@ emit_store_conditional (enum machine_mode mode, rtx res, rtx mem, rtx val)\n   emit_insn (fn (res, mem, val));\n }\n \n+/* A subroutine of the atomic operation splitters.  Emit an insxl\n+   instruction in MODE.  */\n+\n+static rtx\n+emit_insxl (enum machine_mode mode, rtx op1, rtx op2)\n+{\n+  rtx ret = gen_reg_rtx (DImode);\n+  rtx (*fn) (rtx, rtx, rtx);\n+\n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      if (mode == QImode)\n+\tfn = gen_insbl_be;\n+      else\n+\tfn = gen_inswl_be;\n+    }\n+  else\n+    {\n+      if (mode == QImode)\n+\tfn = gen_insbl_le;\n+      else\n+\tfn = gen_inswl_le;\n+    }\n+  emit_insn (fn (ret, op1, op2));\n+\n+  return ret;\n+}\n+\n /* Expand an an atomic fetch-and-operate pattern.  CODE is the binary operation\n    to perform.  MEM is the memory on which to operate.  VAL is the second \n    operand of the binary operator.  BEFORE and AFTER are optional locations to\n@@ -4530,6 +4558,79 @@ alpha_split_compare_and_swap (rtx retval, rtx mem, rtx oldval, rtx newval,\n   emit_label (XEXP (label2, 0));\n }\n \n+void\n+alpha_expand_compare_and_swap_12 (rtx dst, rtx mem, rtx oldval, rtx newval)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx addr, align, wdst;\n+  rtx (*fn5) (rtx, rtx, rtx, rtx, rtx);\n+\n+  addr = force_reg (DImode, XEXP (mem, 0));\n+  align = expand_simple_binop (Pmode, AND, addr, GEN_INT (-8),\n+\t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+\n+  oldval = convert_modes (DImode, mode, oldval, 1);\n+  newval = emit_insxl (mode, newval, addr);\n+\n+  wdst = gen_reg_rtx (DImode);\n+  if (mode == QImode)\n+    fn5 = gen_sync_compare_and_swapqi_1;\n+  else\n+    fn5 = gen_sync_compare_and_swaphi_1;\n+  emit_insn (fn5 (wdst, addr, oldval, newval, align));\n+\n+  emit_move_insn (dst, gen_lowpart (mode, wdst));\n+}\n+\n+void\n+alpha_split_compare_and_swap_12 (enum machine_mode mode, rtx dest, rtx addr,\n+\t\t\t\t rtx oldval, rtx newval, rtx align,\n+\t\t\t\t rtx scratch, rtx cond)\n+{\n+  rtx label1, label2, mem, width, mask, x;\n+\n+  mem = gen_rtx_MEM (DImode, align);\n+  MEM_VOLATILE_P (mem) = 1;\n+\n+  emit_insn (gen_memory_barrier ());\n+  label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label1, 0));\n+\n+  emit_load_locked (DImode, scratch, mem);\n+  \n+  width = GEN_INT (GET_MODE_BITSIZE (mode));\n+  mask = GEN_INT (mode == QImode ? 0xff : 0xffff);\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_extxl_be (dest, scratch, width, addr));\n+  else\n+    emit_insn (gen_extxl_le (dest, scratch, width, addr));\n+\n+  if (oldval == const0_rtx)\n+    x = gen_rtx_NE (DImode, dest, const0_rtx);\n+  else\n+    {\n+      x = gen_rtx_EQ (DImode, dest, oldval);\n+      emit_insn (gen_rtx_SET (VOIDmode, cond, x));\n+      x = gen_rtx_EQ (DImode, cond, const0_rtx);\n+    }\n+  emit_unlikely_jump (x, label2);\n+\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_mskxl_be (scratch, scratch, mask, addr));\n+  else\n+    emit_insn (gen_mskxl_le (scratch, scratch, mask, addr));\n+  emit_insn (gen_iordi3 (scratch, scratch, newval));\n+\n+  emit_store_conditional (DImode, scratch, mem, scratch);\n+\n+  x = gen_rtx_EQ (DImode, scratch, const0_rtx);\n+  emit_unlikely_jump (x, label1);\n+\n+  emit_insn (gen_memory_barrier ());\n+  emit_label (XEXP (label2, 0));\n+}\n+\n /* Expand an atomic exchange operation.  */\n \n void\n@@ -4550,6 +4651,68 @@ alpha_split_lock_test_and_set (rtx retval, rtx mem, rtx val, rtx scratch)\n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   emit_unlikely_jump (x, label);\n }\n+\n+void\n+alpha_expand_lock_test_and_set_12 (rtx dst, rtx mem, rtx val)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx addr, align, wdst;\n+  rtx (*fn4) (rtx, rtx, rtx, rtx);\n+\n+  /* Force the address into a register.  */\n+  addr = force_reg (DImode, XEXP (mem, 0));\n+\n+  /* Align it to a multiple of 8.  */\n+  align = expand_simple_binop (Pmode, AND, addr, GEN_INT (-8),\n+\t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+\n+  /* Insert val into the correct byte location within the word.  */\n+  val = emit_insxl (mode, val, addr);\n+\n+  wdst = gen_reg_rtx (DImode);\n+  if (mode == QImode)\n+    fn4 = gen_sync_lock_test_and_setqi_1;\n+  else\n+    fn4 = gen_sync_lock_test_and_sethi_1;\n+  emit_insn (fn4 (wdst, addr, val, align));\n+\n+  emit_move_insn (dst, gen_lowpart (mode, wdst));\n+}\n+\n+void\n+alpha_split_lock_test_and_set_12 (enum machine_mode mode, rtx dest, rtx addr,\n+\t\t\t\t  rtx val, rtx align, rtx scratch)\n+{\n+  rtx label, mem, width, mask, x;\n+\n+  mem = gen_rtx_MEM (DImode, align);\n+  MEM_VOLATILE_P (mem) = 1;\n+\n+  emit_insn (gen_memory_barrier ());\n+  label = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n+  emit_label (XEXP (label, 0));\n+\n+  emit_load_locked (DImode, scratch, mem);\n+  \n+  width = GEN_INT (GET_MODE_BITSIZE (mode));\n+  mask = GEN_INT (mode == QImode ? 0xff : 0xffff);\n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      emit_insn (gen_extxl_be (dest, scratch, width, addr));\n+      emit_insn (gen_mskxl_be (scratch, scratch, mask, addr));\n+    }\n+  else\n+    {\n+      emit_insn (gen_extxl_le (dest, scratch, width, addr));\n+      emit_insn (gen_mskxl_le (scratch, scratch, mask, addr));\n+    }\n+  emit_insn (gen_iordi3 (scratch, scratch, val));\n+\n+  emit_store_conditional (DImode, scratch, mem, scratch);\n+\n+  x = gen_rtx_EQ (DImode, scratch, const0_rtx);\n+  emit_unlikely_jump (x, label);\n+}\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */"}, {"sha": "d9f9e09e8087db83c9b2fc9f207e54b04e40413a", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -56,6 +56,12 @@\n    (UNSPEC_IMPLVER\t25)\n    (UNSPEC_PERR\t\t26)\n    (UNSPEC_COPYSIGN     27)\n+\n+   ;; Atomic operations\n+   (UNSPEC_MB\t\t28)\n+   (UNSPEC_ATOMIC\t31)\n+   (UNSPEC_CMPXCHG\t32)\n+   (UNSPEC_XCHG\t\t33)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -76,12 +82,8 @@\n    (UNSPECV_SET_TP\t12)\n    (UNSPECV_RPCC\t13)\n    (UNSPECV_SETJMPR_ER\t14)\t; builtin_setjmp_receiver fragment\n-   (UNSPECV_MB\t\t15)\n-   (UNSPECV_LL\t\t16)\t; load-locked\n-   (UNSPECV_SC\t\t17)\t; store-conditional\n-   (UNSPECV_ATOMIC\t18)\n-   (UNSPECV_CMPXCHG\t19)\n-   (UNSPECV_XCHG\t20)\n+   (UNSPECV_LL\t\t15)\t; load-locked\n+   (UNSPECV_SC\t\t16)\t; store-conditional\n   ])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between"}, {"sha": "1c34ce54b1c34462812f93f0dbed19cccc69e66e", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 88, "deletions": 20, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -19,6 +19,7 @@\n ;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n ;; Boston, MA 02110-1301, USA.\n \n+(define_mode_macro I12MODE [QI HI])\n (define_mode_macro I48MODE [SI DI])\n (define_mode_attr modesuffix [(SI \"l\") (DI \"q\")])\n \n@@ -34,7 +35,7 @@\n \n (define_expand \"memory_barrier\"\n   [(set (mem:BLK (match_dup 0))\n-\t(unspec_volatile:BLK [(mem:BLK (match_dup 0))] UNSPECV_MB))]\n+\t(unspec:BLK [(mem:BLK (match_dup 0))] UNSPEC_MB))]\n   \"\"\n {\n   operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n@@ -43,7 +44,7 @@\n \n (define_insn \"*mb_internal\"\n   [(set (match_operand:BLK 0 \"\" \"\")\n-\t(unspec_volatile:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPECV_MB))]\n+\t(unspec:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPEC_MB))]\n   \"\"\n   \"mb\"\n   [(set_attr \"type\" \"mb\")])\n@@ -75,10 +76,10 @@\n \n (define_insn_and_split \"sync_<fetchop_name><mode>\"\n   [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(FETCHOP:I48MODE (match_dup 0)\n \t     (match_operand:I48MODE 1 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -93,10 +94,10 @@\n \n (define_insn_and_split \"sync_nand<mode>\"\n   [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(and:I48MODE (not:I48MODE (match_dup 0))\n \t     (match_operand:I48MODE 1 \"register_operand\" \"r\"))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -113,10 +114,10 @@\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(FETCHOP:I48MODE (match_dup 1)\n \t     (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\"))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -133,10 +134,10 @@\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(and:I48MODE (not:I48MODE (match_dup 1))\n \t     (match_operand:I48MODE 2 \"register_operand\" \"r\"))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -155,9 +156,9 @@\n \t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")\n \t  (match_operand:I48MODE 2 \"<fetchop_pred>\" \"<fetchop_constr>\")))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(FETCHOP:I48MODE (match_dup 1) (match_dup 2))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -176,9 +177,9 @@\n \t  (not:I48MODE (match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n \t  (match_operand:I48MODE 2 \"register_operand\" \"r\")))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(and:I48MODE (not:I48MODE (match_dup 1)) (match_dup 2))]\n-\t  UNSPECV_ATOMIC))\n+\t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -191,15 +192,51 @@\n }\n   [(set_attr \"type\" \"multi\")])\n \n+(define_expand \"sync_compare_and_swap<mode>\"\n+  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n+   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I12MODE 2 \"register_operand\" \"\")\n+   (match_operand:I12MODE 3 \"add_operand\" \"\")]\n+  \"\"\n+{\n+  alpha_expand_compare_and_swap_12 (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"sync_compare_and_swap<mode>_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,&r\")\n+\t(zero_extend:DI\n+\t  (mem:I12MODE (match_operand:DI 1 \"register_operand\" \"r,r\"))))\n+   (set (mem:I12MODE (match_dup 1))\n+\t(unspec:I12MODE\n+\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"J,rI\")\n+\t   (match_operand:DI 3 \"register_operand\" \"r,r\")\n+\t   (match_operand:DI 4 \"register_operand\" \"r,r\")]\n+\t  UNSPEC_CMPXCHG))\n+   (clobber (match_scratch:DI 5 \"=&r,&r\"))\n+   (clobber (match_scratch:DI 6 \"=X,&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_compare_and_swap_12 (<MODE>mode, operands[0], operands[1],\n+\t\t\t\t   operands[2], operands[3], operands[4],\n+\t\t\t\t   operands[5], operands[6]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_expand \"sync_compare_and_swap<mode>\"\n   [(parallel\n      [(set (match_operand:I48MODE 0 \"register_operand\" \"\")\n \t   (match_operand:I48MODE 1 \"memory_operand\" \"\"))\n       (set (match_dup 1)\n-\t   (unspec_volatile:I48MODE\n+\t   (unspec:I48MODE\n \t     [(match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"\")\n \t      (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n-\t     UNSPECV_CMPXCHG))\n+\t     UNSPEC_CMPXCHG))\n       (clobber (match_scratch:I48MODE 4 \"=&r\"))])]\n   \"\"\n {\n@@ -211,10 +248,10 @@\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t   (match_operand:I48MODE 3 \"add_operand\" \"rKL\")]\n-\t  UNSPECV_CMPXCHG))\n+\t  UNSPEC_CMPXCHG))\n    (clobber (match_scratch:I48MODE 4 \"=&r\"))]\n   \"\"\n   \"#\"\n@@ -227,13 +264,44 @@\n }\n   [(set_attr \"type\" \"multi\")])\n \n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(match_operand:I12MODE 0 \"register_operand\" \"\")\n+   (match_operand:I12MODE 1 \"memory_operand\" \"\")\n+   (match_operand:I12MODE 2 \"register_operand\" \"\")]\n+  \"\"\n+{\n+  alpha_expand_lock_test_and_set_12 (operands[0], operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"sync_lock_test_and_set<mode>_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t(zero_extend:DI\n+\t  (mem:I12MODE (match_operand:DI 1 \"register_operand\" \"r\"))))\n+   (set (mem:I12MODE (match_dup 1))\n+\t(unspec:I12MODE\n+\t  [(match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t   (match_operand:DI 3 \"register_operand\" \"r\")]\n+\t  UNSPEC_XCHG))\n+   (clobber (match_scratch:DI 4 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  alpha_split_lock_test_and_set_12 (<MODE>mode, operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3], operands[4]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_insn_and_split \"sync_lock_test_and_set<mode>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:I48MODE\n+\t(unspec:I48MODE\n \t  [(match_operand:I48MODE 2 \"add_operand\" \"rKL\")]\n-\t  UNSPECV_XCHG))\n+\t  UNSPEC_XCHG))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n   \"#\""}, {"sha": "9a982a7fa8b4014cd0af35fa4b556ecf60ec5c5b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -1,3 +1,8 @@\n+2005-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_sync_char_short):\n+\tAdd alpha.\n+\n 2005-07-09  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/22217"}, {"sha": "14426ec82c3462f4f07ecca1627f9b7942cbe689", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38f31687815ca01c8851a8322e67e75e2afce1ab/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=38f31687815ca01c8851a8322e67e75e2afce1ab", "patch": "@@ -1122,6 +1122,7 @@ proc check_effective_target_sync_char_short { } {\n         if { [istarget ia64-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*]\n+\t     || [istarget alpha*-*-*] \n \t     || [istarget powerpc*-*-*] } {\n            set et_sync_char_short_saved 1\n         }"}]}