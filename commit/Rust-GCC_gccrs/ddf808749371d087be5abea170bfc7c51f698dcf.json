{"sha": "ddf808749371d087be5abea170bfc7c51f698dcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRmODA4NzQ5MzcxZDA4N2JlNWFiZWExNzBiZmM3YzUxZjY5OGRjZg==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-28T20:13:45Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-28T20:13:45Z"}, "message": "sparc.c (arith_operand, [...]): Mark mode as unused.\n\n\t* config/sparc/sparc.c (arith_operand, const64_operand,\n\tconst64_high_operand, arith_double_4096_operand): Mark mode as\n\tunused.\n\t(create_simple_focus_bits): Remove unused arg highest_bit_set, all\n\tcallers changed.\n\t(sparc_emit_set_const64): Remove unused variable i.\n\t(sparc_splitdi_legitimate): Likewise for addr_part.\n\t(ultra_code_from_mask): Likewise for mask.\n\t(ultra_cmove_results_ready_p): Fixup entry modulo calc.\n\t(ultra_flush_pipeline): Likewise.\n\t(ultra_fpmode_conflict_exists): Likewise, remove unused variable\n\tthis_type, and allow loads and stores of differing FP modes as\n\tthey do not create a conflict.\n\t(ultra_find_type): Initialize fpmode to SFmode, fix\n\tparenthesization thinkos in large conditional.\n\t(ultrasparc_sched_init): Mark dump and sched_verbose as unused.\n\tInit free_slot_mask after ultra_cur_hist is reset, not before.\n\t(ultrasparc_rescan_pipeline_state): Remove unused variable ucode.\n\t(ultrasparc_sched_reorder): Don't bzero current pipeline state,\n\tuse ultra_flush_pipeline instead, then re-init group pointer.\n\tFix statement with no effect.  If no progress made in, and no\n\tinstructions scheduled at all, advance to new pipeline cycle else\n\twe get into an endless loop.\n\t(ultrasparc_adjust_cost): Remove previous arg.\n\t* config/sparc/sparc.h (ADJUST_COST): Update to reflect that.\n\nFrom-SVN: r22068", "tree": {"sha": "78b5264483b1d114963eff88885bb2a4089d0227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78b5264483b1d114963eff88885bb2a4089d0227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddf808749371d087be5abea170bfc7c51f698dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf808749371d087be5abea170bfc7c51f698dcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf808749371d087be5abea170bfc7c51f698dcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf808749371d087be5abea170bfc7c51f698dcf/comments", "author": null, "committer": null, "parents": [{"sha": "0078ab63c47b8d811d38d2743e3fe539f8e7de87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0078ab63c47b8d811d38d2743e3fe539f8e7de87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0078ab63c47b8d811d38d2743e3fe539f8e7de87"}], "stats": {"total": 115, "additions": 73, "deletions": 42}, "files": [{"sha": "2cf43c870e61779a23ac6b30d229c18fd8a7d5e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddf808749371d087be5abea170bfc7c51f698dcf", "patch": "@@ -1,3 +1,31 @@\n+Fri Aug 28 19:00:44 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (arith_operand, const64_operand,\n+\tconst64_high_operand, arith_double_4096_operand): Mark mode as\n+\tunused.\n+\t(create_simple_focus_bits): Remove unused arg highest_bit_set, all\n+\tcallers changed.\n+\t(sparc_emit_set_const64): Remove unused variable i.\n+\t(sparc_splitdi_legitimate): Likewise for addr_part.\n+\t(ultra_code_from_mask): Likewise for mask.\n+\t(ultra_cmove_results_ready_p): Fixup entry modulo calc.\n+\t(ultra_flush_pipeline): Likewise.\n+\t(ultra_fpmode_conflict_exists): Likewise, remove unused variable\n+\tthis_type, and allow loads and stores of differing FP modes as\n+\tthey do not create a conflict.\n+\t(ultra_find_type): Initialize fpmode to SFmode, fix\n+\tparenthesization thinkos in large conditional.\n+\t(ultrasparc_sched_init): Mark dump and sched_verbose as unused.\n+\tInit free_slot_mask after ultra_cur_hist is reset, not before.\n+\t(ultrasparc_rescan_pipeline_state): Remove unused variable ucode.\n+\t(ultrasparc_sched_reorder): Don't bzero current pipeline state,\n+\tuse ultra_flush_pipeline instead, then re-init group pointer.\n+\tFix statement with no effect.  If no progress made in, and no\n+\tinstructions scheduled at all, advance to new pipeline cycle else\n+\twe get into an endless loop.\n+\t(ultrasparc_adjust_cost): Remove previous arg.\n+\t* config/sparc/sparc.h (ADJUST_COST): Update to reflect that.\n+\t\n Fri Aug 28 13:52:35 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* sparc.md (DImode, DFmode, TFmode splits): Delete self_reference"}, {"sha": "2edc1703625da524037d54ca93759f87f98ab3d2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ddf808749371d087be5abea170bfc7c51f698dcf", "patch": "@@ -789,7 +789,7 @@ arith_operand (op, mode)\n int\n arith_4096_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   int val;\n   if (GET_CODE (op) != CONST_INT)\n@@ -814,7 +814,7 @@ arith_add_operand (op, mode)\n int\n const64_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && SPARC_SIMM13_P (INTVAL (op)))\n@@ -823,7 +823,7 @@ const64_operand (op, mode)\n \t      && SPARC_SIMM13_P (CONST_DOUBLE_LOW (op))\n \t      && (CONST_DOUBLE_HIGH (op) ==\n \t\t  ((CONST_DOUBLE_LOW (op) & 0x80000000) != 0 ?\n-\t\t   0xffffffff : 0)))\n+\t\t   (HOST_WIDE_INT)0xffffffff : 0)))\n #endif\n \t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n@@ -832,7 +832,7 @@ const64_operand (op, mode)\n int\n const64_high_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (INTVAL (op) & 0xfffffc00) != 0\n@@ -912,7 +912,7 @@ arith_double_operand (op, mode)\n int\n arith_double_4096_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (TARGET_ARCH64 &&\n   \t  ((GET_CODE (op) == CONST_INT && INTVAL (op) == 4096) ||\n@@ -1689,12 +1689,12 @@ const64_is_2insns (high_bits, low_bits)\n \n static unsigned HOST_WIDE_INT create_simple_focus_bits\n \tPROTO((unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t       int, int, int));\n+\t       int, int));\n \n static unsigned HOST_WIDE_INT\n-create_simple_focus_bits (high_bits, low_bits, highest_bit_set, lowest_bit_set, shift)\n+create_simple_focus_bits (high_bits, low_bits, lowest_bit_set, shift)\n      unsigned HOST_WIDE_INT high_bits, low_bits;\n-     int highest_bit_set, lowest_bit_set, shift;\n+     int lowest_bit_set, shift;\n {\n   HOST_WIDE_INT hi, lo;\n \n@@ -1725,7 +1725,6 @@ sparc_emit_set_const64 (op0, op1)\n   unsigned HOST_WIDE_INT high_bits, low_bits;\n   int lowest_bit_set, highest_bit_set;\n   int all_bits_between_are_set;\n-  int i;\n   rtx temp;\n \n   /* Sanity check that we know what we are working with.  */\n@@ -1802,7 +1801,6 @@ sparc_emit_set_const64 (op0, op1)\n \t{\n \t  the_const =\n \t    create_simple_focus_bits (high_bits, low_bits,\n-\t\t\t\t      highest_bit_set,\n \t\t\t\t      lowest_bit_set, 0);\n \t}\n       else if (lowest_bit_set == 0)\n@@ -1839,7 +1837,7 @@ sparc_emit_set_const64 (op0, op1)\n     {\n       unsigned HOST_WIDE_INT focus_bits =\n \tcreate_simple_focus_bits (high_bits, low_bits,\n-\t\t\t\t  highest_bit_set, lowest_bit_set, 10);\n+\t\t\t\t  lowest_bit_set, 10);\n \n       if (! SPARC_SETHI_P (focus_bits))\n \t abort ();\n@@ -1953,7 +1951,7 @@ sparc_emit_set_const64 (op0, op1)\n     {\n       unsigned HOST_WIDE_INT focus_bits =\n \tcreate_simple_focus_bits (high_bits, low_bits,\n-\t\t\t\t  highest_bit_set, lowest_bit_set, 0);\n+\t\t\t\t  lowest_bit_set, 0);\n \n       /* We can't get here in this state.  */\n       if (highest_bit_set < 32\n@@ -4751,8 +4749,6 @@ sparc_splitdi_legitimate (reg, mem)\n      rtx reg;\n      rtx mem;\n {\n-  rtx addr_part = XEXP (mem, 0);\n-\n   /* Punt if we are here by mistake.  */\n   if (! reload_completed)\n     abort ();\n@@ -6272,8 +6268,6 @@ static enum ultra_code\n ultra_code_from_mask (type_mask)\n      int type_mask;\n {\n-  int mask;\n-\n   if (type_mask & (TMASK (TYPE_SHIFT) | TMASK (TYPE_CMOVE)))\n     return IEU0;\n   else if (type_mask & (TMASK (TYPE_COMPARE) |\n@@ -6311,7 +6305,7 @@ ultra_cmove_results_ready_p (insn)\n \n   /* If this got dispatched in the previous\n      group, the results are not ready.  */\n-  entry = (ultra_cur_hist - 1) % ULTRA_NUM_HIST;\n+  entry = (ultra_cur_hist - 1) % (ULTRA_NUM_HIST - 1);\n   up = &ultra_pipe_hist[entry];\n   slot = 4;\n   while (--slot >= 0)\n@@ -6332,7 +6326,7 @@ ultra_fpmode_conflict_exists (fpmode)\n   int hist_ent;\n   int hist_lim;\n \n-  hist_ent = (ultra_cur_hist - 1) % ULTRA_NUM_HIST;\n+  hist_ent = (ultra_cur_hist - 1) % (ULTRA_NUM_HIST - 1);\n   if (ultra_cycles_elapsed < 4)\n     hist_lim = ultra_cycles_elapsed;\n   else\n@@ -6346,7 +6340,6 @@ ultra_fpmode_conflict_exists (fpmode)\n \t{\n \t  rtx insn = up->group[slot];\n \t  enum machine_mode this_mode;\n-\t  enum attr_type this_type;\n \t  rtx pat;\n \n \t  if (! insn\n@@ -6362,16 +6355,18 @@ ultra_fpmode_conflict_exists (fpmode)\n \t    continue;\n \n \t  /* If it is not FMOV, FABS, FNEG, FDIV, or FSQRT then\n-\t     we will get a stall.  */\n+\t     we will get a stall.  Loads and stores are independant\n+\t     of these rules.  */\n \t  if (GET_CODE (SET_SRC (pat)) != ABS\n \t      && GET_CODE (SET_SRC (pat)) != NEG\n \t      && ((TMASK (get_attr_type (insn)) &\n \t\t   (TMASK (TYPE_FPDIVS) | TMASK (TYPE_FPDIVD) |\n-\t\t    TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPSQRT))) == 0))\n+\t\t    TMASK (TYPE_FPMOVE) | TMASK (TYPE_FPSQRT) |\n+                    TMASK (TYPE_LOAD) | TMASK (TYPE_STORE))) == 0))\n \t    return 1;\n \t}\n       hist_lim--;\n-      hist_ent = (hist_ent - 1) % ULTRA_NUM_HIST;\n+      hist_ent = (hist_ent - 1) % (ULTRA_NUM_HIST - 1);\n     }\n \n   /* No conflicts, safe to dispatch.  */\n@@ -6407,7 +6402,7 @@ ultra_find_type (type_mask, list, start)\n       if (recog_memoized (insn) >= 0\n \t  && (TMASK(get_attr_type (insn)) & type_mask))\n \t{\n-\t  enum machine_mode fpmode;\n+\t  enum machine_mode fpmode = SFmode;\n \t  rtx pat = 0;\n \t  int slot;\n \t  int check_depend = 0;\n@@ -6451,13 +6446,13 @@ ultra_find_type (type_mask, list, start)\n \t\t\t\t  && REGNO (SUBREG_REG (SET_DEST (slot_pat))) ==\n \t\t\t\t       REGNO (SUBREG_REG (SET_SRC (pat)))\n \t\t\t\t  && SUBREG_WORD (SET_DEST (slot_pat)) ==\n-\t\t\t\t       SUBREG_WORD (SET_SRC (pat))))\n+\t\t\t\t       SUBREG_WORD (SET_SRC (pat)))))\n \t\t      || (check_fpmode_conflict == 1\n \t\t\t  && GET_CODE (slot_insn) == INSN\n \t\t\t  && GET_CODE (slot_pat) == SET\n-\t\t\t  && ((GET_MODE (SET_DEST (slot_pat)) == SFmode\n-\t\t\t       || GET_MODE (SET_DEST (slot_pat)) == DFmode)\n-\t\t\t      && GET_MODE (SET_DEST (slot_pat)) != fpmode)))))\n+\t\t\t  && (GET_MODE (SET_DEST (slot_pat)) == SFmode\n+\t\t\t      || GET_MODE (SET_DEST (slot_pat)) == DFmode)\n+\t\t\t  && GET_MODE (SET_DEST (slot_pat)) != fpmode)))\n \t\tgoto next;\n \t    }\n \n@@ -6558,7 +6553,7 @@ ultra_schedule_insn (ip, ready, this, type)\n static void\n ultra_flush_pipeline ()\n {\n-  ultra_cur_hist = (ultra_cur_hist + 1) % ULTRA_NUM_HIST;\n+  ultra_cur_hist = (ultra_cur_hist + 1) % (ULTRA_NUM_HIST - 1);\n   ultra_cycles_elapsed += 1;\n   bzero ((char *) &ultra_pipe, sizeof ultra_pipe);\n   ultra_pipe.free_slot_mask = 0xf;\n@@ -6569,14 +6564,14 @@ static int ultra_reorder_called_this_block;\n /* Init our data structures for this current block.  */\n void\n ultrasparc_sched_init (dump, sched_verbose)\n-     FILE *dump;\n-     int sched_verbose;\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n {\n   bzero ((char *) &ultra_pipe_hist, sizeof ultra_pipe_hist);\n-  ultra_pipe.free_slot_mask = 0xf;\n   ultra_cur_hist = 0;\n   ultra_cycles_elapsed = 0;\n   ultra_reorder_called_this_block = 0;\n+  ultra_pipe.free_slot_mask = 0xf;\n }\n \n /* INSN has been scheduled, update pipeline commit state\n@@ -6621,7 +6616,6 @@ ultra_rescan_pipeline_state (ready, n_ready)\n   for (i = 0; i < 4; i++)\n     {\n       rtx insn = up->group[i];\n-      enum ultra_code ucode;\n       int j;\n \n       if (! insn)\n@@ -6723,8 +6717,8 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n \tif (num_committed == 0\n \t    || num_committed == up->group_size)\n \t  {\n-\t    bzero ((char *) &ultra_pipe, sizeof ultra_pipe);\n-\t    ultra_pipe.free_slot_mask = 0xf;\n+\t    ultra_flush_pipeline ();\n+\t    up = &ultra_pipe;\n \t    old_group_size = 0;\n \t  }\n \telse\n@@ -6737,7 +6731,7 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n \t       formed group so the code at the end of the loop\n \t       knows that progress was in fact made.  */\n \t    if (up->group_size != old_group_size)\n-\t      old_group_size == 0;\n+\t      old_group_size = 0;\n \t  }\n       }\n \n@@ -6905,9 +6899,20 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n       break;\n \n     /* Clean out the (current cycle's) pipeline state\n-       and try once more.  */\n-    bzero ((char *) &ultra_pipe, sizeof ultra_pipe);\n-    ultra_pipe.free_slot_mask = 0xf;\n+       and try once more.  If we placed no instructions\n+       into the pipeline at all, it means a real hard\n+       conflict exists with some earlier issued instruction\n+       so we must advance to the next cycle to clear it up.  */\n+    if (up->group_size == 0)\n+      {\n+\tultra_flush_pipeline ();\n+\tup = &ultra_pipe;\n+      }\n+    else\n+      {\n+\tbzero ((char *) &ultra_pipe, sizeof ultra_pipe);\n+\tultra_pipe.free_slot_mask = 0xf;\n+      }\n   }\n \n   if (sched_verbose)\n@@ -6938,11 +6943,10 @@ ultrasparc_sched_reorder (dump, sched_verbose, ready, n_ready)\n }\n \n int\n-ultrasparc_adjust_cost (insn, link, dep_insn, previous, cost)\n+ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;\n      rtx link;\n      rtx dep_insn;\n-     rtx previous;\n      int cost;\n {\n   enum attr_type insn_type, dep_type;"}, {"sha": "35f563b8e8361cf0173ab3358f1ada21b7c316ae", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddf808749371d087be5abea170bfc7c51f698dcf/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ddf808749371d087be5abea170bfc7c51f698dcf", "patch": "@@ -2732,8 +2732,7 @@ extern struct rtx_def *legitimize_pic_address ();\n   if (sparc_cpu == PROCESSOR_SUPERSPARC)\t\t\t\\\n     (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n   else if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\\\n-    (COST) = ultrasparc_adjust_cost (INSN, LINK, DEP,\t\t\\\n-\t\t\t\t     last_scheduled_insn, COST);\\\n+    (COST) = ultrasparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n   else\n \n extern void ultrasparc_sched_reorder ();"}]}