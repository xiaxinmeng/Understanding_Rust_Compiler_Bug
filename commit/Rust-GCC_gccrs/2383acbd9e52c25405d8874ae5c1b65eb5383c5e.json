{"sha": "2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM4M2FjYmQ5ZTUyYzI1NDA1ZDg4NzRhZTVjMWI2NWViNTM4M2M1ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-17T14:26:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-17T14:26:42Z"}, "message": "[multiple changes]\n\n2010-06-17  Robert Dewar  <dewar@adacore.com>\n\n\t* par.adb: Minor comment fix\n\t* sem_aggr.adb, sem_ch3.adb: Minor reformatting\n\n2010-06-17  Doug Rupp  <rupp@adacore.com>\n\n\t* s-auxdec-vms_64.ads: Revert Integer to Long_Integer change, instead\n\tchange Address to Short_Address in functions where both must be the\n\tsame size for intrinsics to work.\n\n2010-06-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): A selected component may\n\tnot denote a (private) component of a protected object.\n\n2010-06-17  Bob Duff  <duff@adacore.com>\n\n\t* par-labl.adb (Try_Loop): Test whether the label and the goto are in\n\tthe same list.\n\n2010-06-17  Joel Brobecker  <brobecker@adacore.com brobecker>\n\n\t* gnat_ugn.texi: Update the documentation about GDB re: exception\n\tcatchpoints.\n\nFrom-SVN: r160919", "tree": {"sha": "69d543f5118c0ca29afe54976eb4924dafee2703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d543f5118c0ca29afe54976eb4924dafee2703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/comments", "author": null, "committer": null, "parents": [{"sha": "2f20343325947cf0eba52ddb13bf8a7d03b6b727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f20343325947cf0eba52ddb13bf8a7d03b6b727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f20343325947cf0eba52ddb13bf8a7d03b6b727"}], "stats": {"total": 203, "additions": 134, "deletions": 69}, "files": [{"sha": "9c9bdd8682b58526b1b803aa43562a93f5d7c9cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -1,3 +1,29 @@\n+2010-06-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par.adb: Minor comment fix\n+\t* sem_aggr.adb, sem_ch3.adb: Minor reformatting\n+\n+2010-06-17  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-auxdec-vms_64.ads: Revert Integer to Long_Integer change, instead\n+\tchange Address to Short_Address in functions where both must be the\n+\tsame size for intrinsics to work.\n+\n+2010-06-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): A selected component may\n+\tnot denote a (private) component of a protected object.\n+\n+2010-06-17  Bob Duff  <duff@adacore.com>\n+\n+\t* par-labl.adb (Try_Loop): Test whether the label and the goto are in\n+\tthe same list.\n+\n+2010-06-17  Joel Brobecker  <brobecker@adacore.com brobecker>\n+\n+\t* gnat_ugn.texi: Update the documentation about GDB re: exception\n+\tcatchpoints.\n+\n 2010-06-17  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnatvsn.ads: Bump to 4.6 version."}, {"sha": "07f1cdaa84fc11bc3cda1e8cfd67317e67ec8784", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -22520,11 +22520,10 @@ and execution encounters the breakpoint, then the program\n stops and @code{GDB} signals that the breakpoint was encountered by\n printing the line of code before which the program is halted.\n \n-@item breakpoint exception @var{name}\n-A special form of the breakpoint command which breakpoints whenever\n-exception @var{name} is raised.\n-If @var{name} is omitted,\n-then a breakpoint will occur when any exception is raised.\n+@item catch exception @var{name}\n+This command causes the program execution to stop whenever exception\n+@var{name} is raised.  If @var{name} is omitted, then the execution is\n+suspended when any exception is raised.\n \n @item print @var{expression}\n This will print the value of the given expression. Most simple\n@@ -22686,25 +22685,25 @@ The value returned is always that from the first return statement\n that was stepped through.\n \n @node Ada Exceptions\n-@section Breaking on Ada Exceptions\n+@section Stopping when Ada Exceptions are Raised\n @cindex Exceptions\n \n @noindent\n-You can set breakpoints that trip when your program raises\n-selected exceptions.\n+You can set catchpoints that stop the program execution when your program\n+raises selected exceptions.\n \n @table @code\n-@item break exception\n-Set a breakpoint that trips whenever (any task in the) program raises\n-any exception.\n+@item catch exception\n+Set a catchpoint that stops execution whenever (any task in the) program\n+raises any exception.\n \n-@item break exception @var{name}\n-Set a breakpoint that trips whenever (any task in the) program raises\n-the exception @var{name}.\n+@item catch exception @var{name}\n+Set a catchpoint that stops execution whenever (any task in the) program\n+raises the exception @var{name}.\n \n-@item break exception unhandled\n-Set a breakpoint that trips whenever (any task in the) program raises an\n-exception for which there is no handler.\n+@item catch exception unhandled\n+Set a catchpoint that stops executino whenever (any task in the) program\n+raises an exception for which there is no handler.\n \n @item info exceptions\n @itemx info exceptions @var{regexp}"}, {"sha": "e9ab0daa076473b7e6dc55e82c260278415cdfe3", "filename": "gcc/ada/par-labl.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fpar-labl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fpar-labl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-labl.adb?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -375,7 +375,15 @@ procedure Labl is\n               and then Matches (Node (N), Node (S1))\n             then\n                if not Found then\n-                  if Parent (Node (N)) = Parent (Node (S1)) then\n+\n+                  --  If the label and the goto are both in the same statement\n+                  --  list, then we've found a loop. Note that labels and goto\n+                  --  statements are always part of some list, so\n+                  --  List_Containing always makes sense.\n+\n+                  if\n+                    List_Containing (Node (N)) = List_Containing (Node (S1))\n+                  then\n                      Source := S1;\n                      Found  := True;\n "}, {"sha": "145dda49e92a327fa2e2a1736fbd5569728cbc00", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -1182,12 +1182,12 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    --------------\n \n    procedure Labl;\n-   --  This procedure creates implicit label declarations for all label that\n-   --  are declared in the current unit. Note that this could conceptually\n-   --  be done at the point where the labels are declared, but it is tricky\n-   --  to do it then, since the tree is not hooked up at the point where the\n-   --  label is declared (e.g. a sequence of statements is not yet attached\n-   --  to its containing scope at the point a label in the sequence is found)\n+   --  This procedure creates implicit label declarations for all labels that\n+   --  are declared in the current unit. Note that this could conceptually be\n+   --  done at the point where the labels are declared, but it is tricky to do\n+   --  it then, since the tree is not hooked up at the point where the label is\n+   --  declared (e.g. a sequence of statements is not yet attached to its\n+   --  containing scope at the point a label in the sequence is found).\n \n    --------------\n    -- Par.Load --"}, {"sha": "be90c03d951b892ca75a4c9747b1326d51a0b206", "filename": "gcc/ada/s-auxdec-vms_64.ads", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fs-auxdec-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fs-auxdec-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms_64.ads?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -107,10 +107,10 @@ package System.Aux_DEC is\n    Address_Size       : constant := Standard'Address_Size;\n    Short_Address_Size : constant := 32;\n \n-   function \"+\" (Left : Address; Right : Long_Integer) return Address;\n-   function \"+\" (Left : Long_Integer; Right : Address) return Address;\n-   function \"-\" (Left : Address; Right : Address) return Long_Integer;\n-   function \"-\" (Left : Address; Right : Long_Integer) return Address;\n+   function \"+\" (Left : Short_Address; Right : Integer) return Short_Address;\n+   function \"+\" (Left : Integer; Right : Short_Address) return Short_Address;\n+   function \"-\" (Left : Short_Address; Right : Short_Address) return Integer;\n+   function \"-\" (Left : Short_Address; Right : Integer) return Short_Address;\n \n    pragma Import (Intrinsic, \"+\");\n    pragma Import (Intrinsic, \"-\");\n@@ -230,16 +230,16 @@ package System.Aux_DEC is\n    type Unsigned_Quadword_Array is\n       array (Integer range <>) of Unsigned_Quadword;\n \n-   function To_Address      (X : Integer)           return Address;\n+   function To_Address      (X : Integer)           return Short_Address;\n    pragma Pure_Function (To_Address);\n \n-   function To_Address_Long (X : Unsigned_Longword) return Address;\n+   function To_Address_Long (X : Unsigned_Longword) return Short_Address;\n    pragma Pure_Function (To_Address_Long);\n \n-   function To_Integer      (X : Address)           return Integer;\n+   function To_Integer      (X : Short_Address)     return Integer;\n \n-   function To_Unsigned_Longword (X : Address)     return Unsigned_Longword;\n-   function To_Unsigned_Longword (X : AST_Handler) return Unsigned_Longword;\n+   function To_Unsigned_Longword (X : Short_Address) return Unsigned_Longword;\n+   function To_Unsigned_Longword (X : AST_Handler)   return Unsigned_Longword;\n \n    --  Conventional names for static subtypes of type UNSIGNED_LONGWORD\n \n@@ -657,31 +657,31 @@ private\n    --  want warnings when we compile on such systems.\n \n    function To_Address_A is new\n-     Ada.Unchecked_Conversion (Integer, Address);\n+     Ada.Unchecked_Conversion (Integer, Short_Address);\n    pragma Pure_Function (To_Address_A);\n \n-   function To_Address (X : Integer) return Address\n+   function To_Address (X : Integer) return Short_Address\n      renames To_Address_A;\n    pragma Pure_Function (To_Address);\n \n    function To_Address_Long_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Longword, Address);\n+     Ada.Unchecked_Conversion (Unsigned_Longword, Short_Address);\n    pragma Pure_Function (To_Address_Long_A);\n \n-   function To_Address_Long (X : Unsigned_Longword) return Address\n+   function To_Address_Long (X : Unsigned_Longword) return Short_Address\n      renames To_Address_Long_A;\n    pragma Pure_Function (To_Address_Long);\n \n    function To_Integer_A is new\n-     Ada.Unchecked_Conversion (Address, Integer);\n+     Ada.Unchecked_Conversion (Short_Address, Integer);\n \n-   function To_Integer (X : Address) return Integer\n+   function To_Integer (X : Short_Address) return Integer\n      renames To_Integer_A;\n \n    function To_Unsigned_Longword_A is new\n-     Ada.Unchecked_Conversion (Address, Unsigned_Longword);\n+     Ada.Unchecked_Conversion (Short_Address, Unsigned_Longword);\n \n-   function To_Unsigned_Longword (X : Address) return Unsigned_Longword\n+   function To_Unsigned_Longword (X : Short_Address) return Unsigned_Longword\n      renames To_Unsigned_Longword_A;\n \n    function To_Unsigned_Longword_A is new"}, {"sha": "a632b6a546fa02eada53a744da27ba43c6b5386f", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -2489,8 +2489,8 @@ package body Sem_Aggr is\n       --  This routine checks whether this is indeed the case and if so returns\n       --  False, signaling that no value for Discr should appear in N's\n       --  aggregate part. Also, in this case, the routine appends to\n-      --  New_Assoc_List the discriminant value specified in the ancestor\n-      --  part.\n+      --  New_Assoc_List the discriminant value specified in the ancestor part.\n+      --\n       --  If the aggregate is in a context with expansion delayed, it will be\n       --  reanalyzed, The inherited discriminant values must not be reinserted\n       --  in the component list to prevent spurious errors, but it must be\n@@ -2507,6 +2507,7 @@ package body Sem_Aggr is\n       --  a list of N_Component_Association nodes.\n       --  What is this referring to??? There is no \"following function\" in\n       --  sight???\n+      --\n       --  If no component association has a choice for the searched component,\n       --  the value provided by the others choice is returned, if there is one,\n       --  and Consider_Others_Choice is set to true. Otherwise Empty is\n@@ -2585,6 +2586,7 @@ package body Sem_Aggr is\n                if Inherited_Discriminant (Comp_Assoc) then\n                   return True;\n                end if;\n+\n                Next (Comp_Assoc);\n             end loop;\n          end if;"}, {"sha": "fb8e77690c37df138714b8f64589bc6ae764e4b4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -17491,21 +17491,20 @@ package body Sem_Ch3 is\n                Make_Class_Wide_Type (Typ);\n                Error_Msg_N\n                  (\"incomplete view of tagged type should be declared tagged?\",\n-                    Parent (Current_Entity (Typ)));\n+                  Parent (Current_Entity (Typ)));\n             end if;\n             return;\n \n          else\n             Inc_T := Make_Defining_Identifier (Loc, Chars (Typ));\n             Decl  := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n \n-            --  Type has already been inserted into the current scope.\n-            --  Remove it, and add incomplete declaration for type, so\n-            --  that subsequent anonymous access types can use it.\n-            --  The entity is unchained from the homonym list and from\n-            --  immediate visibility. After analysis, the entity in the\n-            --  incomplete declaration becomes immediately visible in the\n-            --  record declaration that follows.\n+            --  Type has already been inserted into the current scope. Remove\n+            --  it, and add incomplete declaration for type, so that subsequent\n+            --  anonymous access types can use it. The entity is unchained from\n+            --  the homonym list and from immediate visibility. After analysis,\n+            --  the entity in the incomplete declaration becomes immediately\n+            --  visible in the record declaration that follows.\n \n             H := Current_Entity (Typ);\n \n@@ -17526,8 +17525,9 @@ package body Sem_Ch3 is\n             Set_Full_View (Inc_T, Typ);\n \n             if Is_Tagged then\n-               --  Create a common class-wide type for both views, and set\n-               --  the Etype of the class-wide type to the full view.\n+\n+               --  Create a common class-wide type for both views, and set the\n+               --  Etype of the class-wide type to the full view.\n \n                Make_Class_Wide_Type (Inc_T);\n                Set_Class_Wide_Type (Typ, Class_Wide_Type (Inc_T));"}, {"sha": "aa936bbeaff55289a72c436efd26208aa152bdff", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2383acbd9e52c25405d8874ae5c1b65eb5383c5e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2383acbd9e52c25405d8874ae5c1b65eb5383c5e", "patch": "@@ -3105,8 +3105,8 @@ package body Sem_Ch4 is\n    -- Analyze_Selected_Component --\n    --------------------------------\n \n-   --  Prefix is a record type or a task or protected type. In the\n-   --  later case, the selector must denote a visible entry.\n+   --  Prefix is a record type or a task or protected type. In the latter case,\n+   --  the selector must denote a visible entry.\n \n    procedure Analyze_Selected_Component (N : Node_Id) is\n       Name          : constant Node_Id := Prefix (N);\n@@ -3124,6 +3124,9 @@ package body Sem_Ch4 is\n       --  a class-wide type, we use its root type, whose components are\n       --  present in the class-wide type.\n \n+      Is_Single_Concurrent_Object : Boolean;\n+      --  Set True if the prefix is a single task or a single protected object\n+\n       function Has_Mode_Conformant_Spec (Comp : Entity_Id) return Boolean;\n       --  It is known that the parent of N denotes a subprogram call. Comp\n       --  is an overloadable component of the concurrent type of the prefix.\n@@ -3294,6 +3297,15 @@ package body Sem_Ch4 is\n          Type_To_Use := Root_Type (Prefix_Type);\n       end if;\n \n+      --  If the prefix is a single concurrent object, use its name in error\n+      --  messages, rather than that of its anonymous type.\n+\n+      Is_Single_Concurrent_Object :=\n+        Is_Concurrent_Type (Prefix_Type)\n+          and then Is_Internal_Name (Chars (Prefix_Type))\n+          and then not Is_Derived_Type (Prefix_Type)\n+          and then Is_Entity_Name (Name);\n+\n       Comp := First_Entity (Type_To_Use);\n \n       --  If the selector has an original discriminant, the node appears in\n@@ -3532,9 +3544,8 @@ package body Sem_Ch4 is\n                   return;\n \n                else\n-                  Error_Msg_NE\n-                    (\"invisible selector for }\",\n-                     N, First_Subtype (Prefix_Type));\n+                  Error_Msg_Node_2 := First_Subtype (Prefix_Type);\n+                  Error_Msg_NE (\"invisible selector& for }\", N, Sel);\n                   Set_Entity (Sel, Any_Id);\n                   Set_Etype (N, Any_Type);\n                end if;\n@@ -3579,8 +3590,13 @@ package body Sem_Ch4 is\n                      Has_Candidate := True;\n                   end if;\n \n+               --  Note: a selected component may not denote a component of a\n+               --  protected type (4.1.3(7)).\n+\n                elsif Ekind_In (Comp, E_Discriminant, E_Entry_Family)\n-                 or else (In_Scope and then Is_Entity_Name (Name))\n+                 or else (In_Scope\n+                            and then not Is_Protected_Type (Prefix_Type)\n+                            and then Is_Entity_Name (Name))\n                then\n                   Set_Entity_With_Style_Check (Sel, Comp);\n                   Generate_Reference (Comp, Sel);\n@@ -3644,6 +3660,28 @@ package body Sem_Ch4 is\n             end if;\n          end if;\n \n+         if Etype (N) = Any_Type and then Is_Protected_Type (Prefix_Type) then\n+            --  Case of a prefix of a protected type: selector might denote\n+            --  an invisible private component.\n+\n+            Comp := First_Private_Entity (Base_Type (Prefix_Type));\n+            while Present (Comp) and then Chars (Comp) /= Chars (Sel) loop\n+               Next_Entity (Comp);\n+            end loop;\n+\n+            if Present (Comp) then\n+               if Is_Single_Concurrent_Object then\n+                  Error_Msg_Node_2 := Entity (Name);\n+                  Error_Msg_NE (\"invisible selector& for &\", N, Sel);\n+\n+               else\n+                  Error_Msg_Node_2 := First_Subtype (Prefix_Type);\n+                  Error_Msg_NE (\"invisible selector& for }\", N, Sel);\n+               end if;\n+               return;\n+            end if;\n+         end if;\n+\n          Set_Is_Overloaded (N, Is_Overloaded (Sel));\n \n       else\n@@ -3656,15 +3694,7 @@ package body Sem_Ch4 is\n \n       if Etype (N) = Any_Type then\n \n-         --  If the prefix is a single concurrent object, use its name in the\n-         --  error message, rather than that of its anonymous type.\n-\n-         if Is_Concurrent_Type (Prefix_Type)\n-           and then Is_Internal_Name (Chars (Prefix_Type))\n-           and then not Is_Derived_Type (Prefix_Type)\n-           and then Is_Entity_Name (Name)\n-         then\n-\n+         if Is_Single_Concurrent_Object then\n             Error_Msg_Node_2 := Entity (Name);\n             Error_Msg_NE (\"no selector& for&\", N, Sel);\n "}]}