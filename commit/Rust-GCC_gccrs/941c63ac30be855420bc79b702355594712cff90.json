{"sha": "941c63ac30be855420bc79b702355594712cff90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxYzYzYWMzMGJlODU1NDIwYmM3OWI3MDIzNTU1OTQ3MTJjZmY5MA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-12-12T23:03:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-12-12T23:03:54Z"}, "message": "rtlanal.c (multiple_sets): New function.\n\n        * rtlanal.c (multiple_sets): New function.\n        * rtl.h (multiple_sets): Declare it.\n        * local-alloc.c (wipe_dead_reg): Use it.\n        * global.c (global_conflicts): Likewise.\nShould fix the m68k bootstrap problems.\n\nFrom-SVN: r24283", "tree": {"sha": "8cb9f662656a67c7745f1ade226aa8d33838a4e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cb9f662656a67c7745f1ade226aa8d33838a4e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/941c63ac30be855420bc79b702355594712cff90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941c63ac30be855420bc79b702355594712cff90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941c63ac30be855420bc79b702355594712cff90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941c63ac30be855420bc79b702355594712cff90/comments", "author": null, "committer": null, "parents": [{"sha": "8d4c79be50f79381b6306600b304ea3182a8d63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4c79be50f79381b6306600b304ea3182a8d63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4c79be50f79381b6306600b304ea3182a8d63c"}], "stats": {"total": 64, "additions": 59, "deletions": 5}, "files": [{"sha": "b0e12f6249f1fe022e5a86bcac663d1a85219d1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941c63ac30be855420bc79b702355594712cff90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941c63ac30be855420bc79b702355594712cff90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=941c63ac30be855420bc79b702355594712cff90", "patch": "@@ -1,3 +1,10 @@\n+Sat Dec 12 23:39:10 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* rtlanal.c (multiple_sets): New function.\n+\t* rtl.h (multiple_sets): Declare it.\n+\t* local-alloc.c (wipe_dead_reg): Use it.\n+\t* global.c (global_conflicts): Likewise.\n+\n Sat Dec 12 22:13:02 1998  Mark Mitchell  <mark@markmitchell.com>\n \n \t* global.c (record_conflicts): Don't use an array of shorts to"}, {"sha": "06277ee5365ff4e99dc11efde04acc38beb0f52d", "filename": "gcc/global.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941c63ac30be855420bc79b702355594712cff90/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941c63ac30be855420bc79b702355594712cff90/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=941c63ac30be855420bc79b702355594712cff90", "patch": "@@ -739,9 +739,16 @@ global_conflicts ()\n \n \t      /* If INSN has multiple outputs, then any reg that dies here\n \t\t and is used inside of an output\n-\t\t must conflict with the other outputs.  */\n-\n-\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && !single_set (insn))\n+\t\t must conflict with the other outputs.\n+\n+\t\t It is unsafe to use !single_set here since it will ignore an\n+\t\t unused output.  Just because an output is unused does not mean\n+\t\t the compiler can assume the side effect will not occur.\n+\t\t Consider if REG appears in the address of an output and we\n+\t\t reload the output.  If we allocate REG to the same hard\n+\t\t register as an unused output we could set the hard register\n+\t\t before the output reload insn.  */\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL && multiple_sets (insn))\n \t\tfor (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t  if (REG_NOTE_KIND (link) == REG_DEAD)\n \t\t    {"}, {"sha": "85cb8af555b44c8ec40873a3f8cf971293e1b15d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941c63ac30be855420bc79b702355594712cff90/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941c63ac30be855420bc79b702355594712cff90/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=941c63ac30be855420bc79b702355594712cff90", "patch": "@@ -1876,9 +1876,16 @@ wipe_dead_reg (reg, output_p)\n   /* If this insn has multiple results,\n      and the dead reg is used in one of the results,\n      extend its life to after this insn,\n-     so it won't get allocated together with any other result of this insn.  */\n+     so it won't get allocated together with any other result of this insn. \n+\n+     It is unsafe to use !single_set here since it will ignore an unused\n+     output.  Just because an output is unused does not mean the compiler\n+     can assume the side effect will not occur.   Consider if REG appears\n+     in the address of an output and we reload the output.  If we allocate\n+     REG to the same hard register as an unused output we could set the hard\n+     register before the output reload insn.  */\n   if (GET_CODE (PATTERN (this_insn)) == PARALLEL\n-      && !single_set (this_insn))\n+      && multiple_sets (this_insn))\n     {\n       int i;\n       for (i = XVECLEN (PATTERN (this_insn), 0) - 1; i >= 0; i--)"}, {"sha": "95ddbd1617c234b6ee9079b3a6d8e3b4248ab170", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941c63ac30be855420bc79b702355594712cff90/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941c63ac30be855420bc79b702355594712cff90/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=941c63ac30be855420bc79b702355594712cff90", "patch": "@@ -988,6 +988,7 @@ extern int no_labels_between_p\t\tPROTO((rtx, rtx));\n extern int modified_in_p\t\tPROTO((rtx, rtx));\n extern int reg_set_p\t\t\tPROTO((rtx, rtx));\n extern rtx single_set\t\t\tPROTO((rtx));\n+extern rtx multiple_sets\t\tPROTO((rtx));\n extern rtx find_last_value\t\tPROTO((rtx, rtx *, rtx));\n extern int refers_to_regno_p\t\tPROTO((int, int, rtx, rtx *));\n extern int reg_overlap_mentioned_p\tPROTO((rtx, rtx));"}, {"sha": "f298ab2f5efb7d64b895719dcc0ebddf906189ed", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941c63ac30be855420bc79b702355594712cff90/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941c63ac30be855420bc79b702355594712cff90/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=941c63ac30be855420bc79b702355594712cff90", "patch": "@@ -690,6 +690,38 @@ single_set (insn)\n   \n   return 0;\n }\n+\n+/* Given an INSN, return nonzero if it has more than one SET, else return\n+   zero.  */\n+\n+rtx\n+multiple_sets (insn)\n+     rtx insn;\n+{\n+  rtx found;\n+  int i;\n+  \n+  /* INSN must be an insn.  */\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return 0;\n+\n+  /* Only a PARALLEL can have multiple SETs.  */\n+  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+    {\n+      for (i = 0, found = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n+\t  {\n+\t    /* If we have already found a SET, then return now.  */\n+\t    if (found)\n+\t      return 1;\n+\t    else\n+\t      found = 1;\n+\t  }\n+    }\n+  \n+  /* Either zero or one SET.  */\n+  return 0;\n+}\n \f\n /* Return the last thing that X was assigned from before *PINSN.  Verify that\n    the object is not modified up to VALID_TO.  If it was, if we hit"}]}