{"sha": "98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkMWNkNDU3MTliYzhhOTZhZDhiMmFkYTAyZTlkMTc5MWQ2MmIyNQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "2000-05-25T01:21:52Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-05-25T01:21:52Z"}, "message": "revert: loop.h (struct induction): Add multi_insn_incr.\n\n\t* Back out this patch:\n\tTue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n          * loop.h (struct induction): Add multi_insn_incr.\n          * loop.c (basic_induction_var): New multi_insn_incr argument.\n          Set it if we search back through previous insns for the biv.\n          (record_biv): New multi_insn_incr argument; fill in struct induction.\n          (strength_reduce): Discard an iv with multiple bivs, any of\n          which require multiple insns to increment.\n\n\t* loop.c (check_insn_for_bivs): Remove bits copied from above patch.\n\nFrom-SVN: r34151", "tree": {"sha": "390cf3ef60e0d5012c2076e1463d38cbc6fc70b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/390cf3ef60e0d5012c2076e1463d38cbc6fc70b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/comments", "author": null, "committer": null, "parents": [{"sha": "db7ba7424119d53c01667af6957ca943c0cd2ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7ba7424119d53c01667af6957ca943c0cd2ff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7ba7424119d53c01667af6957ca943c0cd2ff1"}], "stats": {"total": 83, "additions": 30, "deletions": 53}, "files": [{"sha": "ded3ed7474f25d05cbbfbfaeb7e2093a4b5d37f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "patch": "@@ -1,3 +1,16 @@\n+Thu May 25 02:19:27 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* Back out this patch:\n+\tTue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n+          * loop.h (struct induction): Add multi_insn_incr.\n+          * loop.c (basic_induction_var): New multi_insn_incr argument.\n+          Set it if we search back through previous insns for the biv.\n+          (record_biv): New multi_insn_incr argument; fill in struct induction.\n+          (strength_reduce): Discard an iv with multiple bivs, any of\n+          which require multiple insns to increment.\n+\n+\t* loop.c (check_insn_for_bivs): Remove bits copied from above patch.\n+\n Thu May 25 02:09:10 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* rtl.h (loc_mentioned_in_p): Declare."}, {"sha": "ed396f4ab8ffcae784c47c7ef19373da384533e4", "filename": "gcc/loop.c", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "patch": "@@ -265,8 +265,8 @@ static void strength_reduce PARAMS ((struct loop *, int, int));\n static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n static void find_mem_givs PARAMS ((const struct loop *, rtx, rtx, int, int));\n-static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *, \n-\t\t\t\tint, int, int));\n+static void record_biv PARAMS ((struct induction *, rtx, rtx, rtx, rtx, rtx *,\n+\t\t\t\tint, int));\n static void check_final_value PARAMS ((const struct loop *,\n \t\t\t\t       struct induction *));\n static void record_giv PARAMS ((const struct loop *, struct induction *, \n@@ -275,7 +275,7 @@ static void record_giv PARAMS ((const struct loop *, struct induction *,\n static void update_giv_derive PARAMS ((const struct loop *, rtx));\n static int basic_induction_var PARAMS ((const struct loop *, rtx, \n \t\t\t\t\tenum machine_mode, rtx, rtx,\n-\t\t\t\t\trtx *, rtx *, rtx **, int *));\n+\t\t\t\t\trtx *, rtx *, rtx **));\n static rtx simplify_giv_expr PARAMS ((const struct loop *, rtx, int *));\n static int general_induction_var PARAMS ((const struct loop *loop, rtx, rtx *,\n \t\t\t\t\t  rtx *, rtx *, int, int *, enum machine_mode));\n@@ -3906,30 +3906,13 @@ strength_reduce (loop, insn_count, flags)\n      Make a sanity check against n_times_set.  */\n   for (backbl = &loop_iv_list, bl = *backbl; bl; bl = bl->next)\n     {\n-      int fail = 0;\n-\n       if (REG_IV_TYPE (bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n \t  /* Make sure it is not recognized as a basic induction var: */\n \t  || VARRAY_INT (n_times_set, bl->regno) != bl->biv_count\n \t  /* If never incremented, it is invariant that we decided not to\n \t     move.  So leave it alone.  */\n \t  || ! bl->incremented)\n-\tfail = 1;\n-      else if (bl->biv_count > 1)\n-\t{\n-\t  /* ??? If we have multiple increments for this BIV, and any of\n-\t     them take multiple insns to perform the increment, drop the\n-\t     BIV, since the bit below that converts the extra increments\n-\t     into GIVs can't handle the multiple insn increment.  */\n-\t  \n-\t  struct induction *v;\n-\t  for (v = bl->biv; v ; v = v->next_iv)\n-\t    if (v->multi_insn_incr)\n-\t      fail = 1;\n-\t}\n-\n-      if (fail)\n \t{\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv discarded, %s\\n\",\n@@ -4395,7 +4378,7 @@ strength_reduce (loop, insn_count, flags)\n \n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream,\n-\t\t\t \"Increment %d of biv %d converted to giv %d.\\n\",\n+\t\t\t \"Increment %d of biv %d converted to giv %d.\\n\\n\",\n \t\t\t INSN_UID (v->insn), old_regno, new_regno);\n \t    }\n \t}\n@@ -5083,12 +5066,10 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n \t  && REGNO (dest_reg) >= FIRST_PSEUDO_REGISTER\n \t  && REG_IV_TYPE (REGNO (dest_reg)) != NOT_BASIC_INDUCT)\n \t{\n-\t  int multi_insn_incr = 0;\n-\n \t  if (basic_induction_var (loop, SET_SRC (set),\n \t\t\t\t   GET_MODE (SET_SRC (set)),\n \t\t\t\t   dest_reg, p, &inc_val, &mult_val,\n-\t\t\t\t   &location, &multi_insn_incr))\n+\t\t\t\t   &location))\n \t    {\n \t      /* It is a possible basic induction variable.\n \t         Create and initialize an induction structure for it.  */\n@@ -5097,8 +5078,7 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n \t      = (struct induction *) oballoc (sizeof (struct induction));\n \n \t      record_biv (v, p, dest_reg, inc_val, mult_val, location,\n-\t\t\t  not_every_iteration, maybe_multiple,\n-\t\t\t  multi_insn_incr);\n+\t\t\t  not_every_iteration, maybe_multiple);\n \t      REG_IV_TYPE (REGNO (dest_reg)) = BASIC_INDUCT;\n \t    }\n \t  else if (REGNO (dest_reg) < max_reg_before_loop)\n@@ -5332,7 +5312,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \n static void\n record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n-\t    not_every_iteration, maybe_multiple, multi_insn_incr)\n+\t    not_every_iteration, maybe_multiple)\n      struct induction *v;\n      rtx insn;\n      rtx dest_reg;\n@@ -5341,7 +5321,6 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n      rtx *location;\n      int not_every_iteration;\n      int maybe_multiple;\n-     int multi_insn_incr;\n {\n   struct iv_class *bl;\n \n@@ -5355,7 +5334,6 @@ record_biv (v, insn, dest_reg, inc_val, mult_val, location,\n   v->always_computable = ! not_every_iteration;\n   v->always_executed = ! not_every_iteration;\n   v->maybe_multiple = maybe_multiple;\n-  v->multi_insn_incr = multi_insn_incr;\n \n   /* Add this to the reg's iv_class, creating a class\n      if this is the first incrementation of the reg.  */\n@@ -5468,7 +5446,6 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->cant_derive = 0;\n   v->combined_with = 0;\n   v->maybe_multiple = maybe_multiple;\n-  v->multi_insn_incr = 0;\n   v->maybe_dead = 0;\n   v->derive_adjustment = 0;\n   v->same = 0;\n@@ -5960,8 +5937,7 @@ update_giv_derive (loop, p)\n    If we cannot find a biv, we return 0.  */\n \n static int\n-basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n-\t\t     location, multi_insn_incr)\n+basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n      const struct loop *loop;\n      register rtx x;\n      enum machine_mode mode;\n@@ -5970,7 +5946,6 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n      rtx *inc_val;\n      rtx *mult_val;\n      rtx **location;\n-     int *multi_insn_incr;\n {\n   register enum rtx_code code;\n   rtx *argp, arg;\n@@ -6013,8 +5988,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n       if (SUBREG_PROMOTED_VAR_P (x))\n \treturn basic_induction_var (loop, SUBREG_REG (x),\n \t\t\t\t    GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t    dest_reg, p, inc_val, mult_val, location,\n-\t\t\t\t    multi_insn_incr);\n+\t\t\t\t    dest_reg, p, inc_val, mult_val, location);\n       return 0;\n \n     case REG:\n@@ -6047,12 +6021,8 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n \t\t\t\t       ? GET_MODE (x)\n \t\t\t\t       : GET_MODE (SET_SRC (set))),\n \t\t\t\t      dest_reg, insn,\n-\t\t\t\t      inc_val, mult_val, location,\n-\t\t\t\t      multi_insn_incr))\n-\t    {\n-\t      *multi_insn_incr = 1;\n-\t      return 1;\n-\t    }\n+\t\t\t\t      inc_val, mult_val, location))\n+\t    return 1;\n \t}\n       /* ... fall through ...  */\n \n@@ -6083,8 +6053,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n \n     case SIGN_EXTEND:\n       return basic_induction_var (loop, XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, p, inc_val, mult_val, location,\n-\t\t\t\t  multi_insn_incr);\n+\t\t\t\t  dest_reg, p, inc_val, mult_val, location);\n \n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n@@ -6101,15 +6070,11 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val,\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0\n \t  && GET_CODE (SET_SRC (set)) == ASHIFT\n-\t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1)\n-\t  && basic_induction_var (loop, XEXP (SET_SRC (set), 0),\n-\t\t\t\t  GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  dest_reg, insn, inc_val, mult_val,\n-\t\t\t\t  location, multi_insn_incr))\n-\t{\n-\t  *multi_insn_incr = 1;\n-\t  return 1;\n-\t}\n+\t  && XEXP (x, 1) == XEXP (SET_SRC (set), 1))\n+\treturn basic_induction_var (loop, XEXP (SET_SRC (set), 0),\n+\t\t\t\t    GET_MODE (XEXP (x, 0)),\n+\t\t\t\t    dest_reg, insn, inc_val, mult_val,\n+\t\t\t\t    location);\n       return 0;\n \n     default:"}, {"sha": "1409b498997964f870ea14deaa0a2f526406ce3b", "filename": "gcc/loop.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d1cd45719bc8a96ad8b2ada02e9d1791d62b25/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=98d1cd45719bc8a96ad8b2ada02e9d1791d62b25", "patch": "@@ -110,7 +110,6 @@ struct induction\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n   unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n-  unsigned multi_insn_incr : 1;\t/* 1 if multiple insns updated the biv.  */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv"}]}