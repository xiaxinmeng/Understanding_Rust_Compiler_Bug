{"sha": "095a2d76a26fa4ee17fa56bff21bf4f269db2368", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1YTJkNzZhMjZmYTRlZTE3ZmE1NmJmZjIxYmY0ZjI2OWRiMjM2OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:18:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:18:59Z"}, "message": "[62/77] Big machine_mode to scalar_int_mode replacement\n\nThis patch changes the types of various things from machine_mode\nto scalar_int_mode, in cases where (after previous patches)\nsimply changing the type is enough on its own.  The patch does\nnothing other than that.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* builtins.h (builtin_strncpy_read_str): Take a scalar_int_mode\n\tinstead of a machine_mode.\n\t(builtin_memset_read_str): Likewise.\n\t* builtins.c (c_readstr): Likewise.\n\t(builtin_memcpy_read_str): Likewise.\n\t(builtin_strncpy_read_str): Likewise.\n\t(builtin_memset_read_str): Likewise.\n\t(builtin_memset_gen_str): Likewise.\n\t(expand_builtin_signbit): Use scalar_int_mode for local variables.\n\t* cfgexpand.c (convert_debug_memory_address): Take a scalar_int_mode\n\tinstead of a machine_mode.\n\t* combine.c (simplify_if_then_else): Use scalar_int_mode for local\n\tvariables.\n\t(make_extraction): Likewise.\n\t(try_widen_shift_mode): Take and return scalar_int_modes instead\n\tof machine_modes.\n\t* config/aarch64/aarch64.c (aarch64_libgcc_cmp_return_mode): Return\n\ta scalar_int_mode instead of a machine_mode.\n\t* config/avr/avr.c (avr_addr_space_address_mode): Likewise.\n\t(avr_addr_space_pointer_mode): Likewise.\n\t* config/cr16/cr16.c (cr16_unwind_word_mode): Likewise.\n\t* config/msp430/msp430.c (msp430_addr_space_pointer_mode): Likewise.\n\t(msp430_unwind_word_mode): Likewise.\n\t* config/spu/spu.c (spu_unwind_word_mode): Likewise.\n\t(spu_addr_space_pointer_mode): Likewise.\n\t(spu_addr_space_address_mode): Likewise.\n\t(spu_libgcc_cmp_return_mode): Likewise.\n\t(spu_libgcc_shift_count_mode): Likewise.\n\t* config/rl78/rl78.c (rl78_addr_space_address_mode): Likewise.\n\t(rl78_addr_space_pointer_mode): Likewise.\n\t(fl78_unwind_word_mode): Likewise.\n\t(rl78_valid_pointer_mode): Take a scalar_int_mode instead of a\n\tmachine_mode.\n\t* config/alpha/alpha.c (vms_valid_pointer_mode): Likewise.\n\t* config/ia64/ia64.c (ia64_vms_valid_pointer_mode): Likewise.\n\t* config/mips/mips.c (mips_mode_rep_extended): Likewise.\n\t(mips_valid_pointer_mode): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_mode_rep_extended): Likewise.\n\t* config/ft32/ft32.c (ft32_valid_pointer_mode): Likewise.\n\t(ft32_addr_space_pointer_mode): Return a scalar_int_mode instead\n\tof a machine_mode.\n\t(ft32_addr_space_address_mode): Likewise.\n\t* config/m32c/m32c.c (m32c_valid_pointer_mode): Take a\n\tscalar_int_mode instead of a machine_mode.\n\t(m32c_addr_space_pointer_mode): Return a scalar_int_mode instead\n\tof a machine_mode.\n\t(m32c_addr_space_address_mode): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_abi_word_mode): Likewise.\n\t(rs6000_eh_return_filter_mode): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_abi_word_mode): Likewise.\n\t(rs6000_eh_return_filter_mode): Likewise.\n\t* config/s390/s390.c (s390_libgcc_cmp_return_mode): Likewise.\n\t(s390_libgcc_shift_count_mode): Likewise.\n\t(s390_unwind_word_mode): Likewise.\n\t(s390_valid_pointer_mode): Take a scalar_int_mode rather than a\n\tmachine_mode.\n\t* target.def (mode_rep_extended): Likewise.\n\t(valid_pointer_mode): Likewise.\n\t(addr_space.valid_pointer_mode): Likewise.\n\t(eh_return_filter_mode): Return a scalar_int_mode rather than\n\ta machine_mode.\n\t(libgcc_cmp_return_mode): Likewise.\n\t(libgcc_shift_count_mode): Likewise.\n\t(unwind_word_mode): Likewise.\n\t(addr_space.pointer_mode): Likewise.\n\t(addr_space.address_mode): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* dojump.c (prefer_and_bit_test): Take a scalar_int_mode rather than\n\ta machine_mode.\n\t(do_jump): Use scalar_int_mode for local variables.\n\t* dwarf2cfi.c (init_return_column_size): Take a scalar_int_mode\n\trather than a machine_mode.\n\t* dwarf2out.c (convert_descriptor_to_mode): Likewise.\n\t(scompare_loc_descriptor_wide): Likewise.\n\t(scompare_loc_descriptor_narrow): Likewise.\n\t* emit-rtl.c (adjust_address_1): Use scalar_int_mode for local\n\tvariables.\n\t* except.c (sjlj_emit_dispatch_table): Likewise.\n\t(expand_builtin_eh_copy_values): Likewise.\n\t* explow.c (convert_memory_address_addr_space_1): Likewise.\n\tTake a scalar_int_mode rather than a machine_mode.\n\t(convert_memory_address_addr_space): Take a scalar_int_mode rather\n\tthan a machine_mode.\n\t(memory_address_addr_space): Use scalar_int_mode for local variables.\n\t* expmed.h (expand_mult_highpart_adjust): Take a scalar_int_mode\n\trather than a machine_mode.\n\t* expmed.c (mask_rtx): Likewise.\n\t(init_expmed_one_conv): Likewise.\n\t(expand_mult_highpart_adjust): Likewise.\n\t(extract_high_half): Likewise.\n\t(expmed_mult_highpart_optab): Likewise.\n\t(expmed_mult_highpart): Likewise.\n\t(expand_smod_pow2): Likewise.\n\t(expand_sdiv_pow2): Likewise.\n\t(emit_store_flag_int): Likewise.\n\t(adjust_bit_field_mem_for_reg): Use scalar_int_mode for local\n\tvariables.\n\t(extract_low_bits): Likewise.\n\t* expr.h (by_pieces_constfn): Take a scalar_int_mode rather than\n\ta machine_mode.\n\t* expr.c (pieces_addr::adjust):  Likewise.\n\t(can_store_by_pieces): Likewise.\n\t(store_by_pieces): Likewise.\n\t(clear_by_pieces_1): Likewise.\n\t(expand_expr_addr_expr_1): Likewise.\n\t(expand_expr_addr_expr): Use scalar_int_mode for local variables.\n\t(expand_expr_real_1): Likewise.\n\t(try_casesi): Likewise.\n\t* final.c (shorten_branches): Likewise.\n\t* fold-const.c (fold_convert_const_int_from_fixed): Change the\n\ttype of \"mode\" to machine_mode.\n\t* internal-fn.c (expand_arith_overflow_result_store): Take a\n\tscalar_int_mode rather than a machine_mode.\n\t(expand_mul_overflow): Use scalar_int_mode for local variables.\n\t* loop-doloop.c (doloop_modify): Likewise.\n\t(doloop_optimize): Likewise.\n\t* optabs.c (expand_subword_shift): Take a scalar_int_mode rather\n\tthan a machine_mode.\n\t(expand_doubleword_shift_condmove): Likewise.\n\t(expand_doubleword_shift): Likewise.\n\t(expand_doubleword_clz): Likewise.\n\t(expand_doubleword_popcount): Likewise.\n\t(expand_doubleword_parity): Likewise.\n\t(expand_absneg_bit): Use scalar_int_mode for local variables.\n\t(prepare_float_lib_cmp): Likewise.\n\t* rtl.h (convert_memory_address_addr_space_1): Take a scalar_int_mode\n\trather than a machine_mode.\n\t(convert_memory_address_addr_space): Likewise.\n\t(get_mode_bounds): Likewise.\n\t(get_address_mode): Return a scalar_int_mode rather than a\n\tmachine_mode.\n\t* rtlanal.c (get_address_mode): Likewise.\n\t* stor-layout.c (get_mode_bounds): Take a scalar_int_mode rather\n\tthan a machine_mode.\n\t* targhooks.c (default_mode_rep_extended): Likewise.\n\t(default_valid_pointer_mode): Likewise.\n\t(default_addr_space_valid_pointer_mode): Likewise.\n\t(default_eh_return_filter_mode): Return a scalar_int_mode rather\n\tthan a machine_mode.\n\t(default_libgcc_cmp_return_mode): Likewise.\n\t(default_libgcc_shift_count_mode): Likewise.\n\t(default_unwind_word_mode): Likewise.\n\t(default_addr_space_pointer_mode): Likewise.\n\t(default_addr_space_address_mode): Likewise.\n\t* targhooks.h (default_eh_return_filter_mode): Likewise.\n\t(default_libgcc_cmp_return_mode): Likewise.\n\t(default_libgcc_shift_count_mode): Likewise.\n\t(default_unwind_word_mode): Likewise.\n\t(default_addr_space_pointer_mode): Likewise.\n\t(default_addr_space_address_mode): Likewise.\n\t(default_mode_rep_extended): Take a scalar_int_mode rather than\n\ta machine_mode.\n\t(default_valid_pointer_mode): Likewise.\n\t(default_addr_space_valid_pointer_mode): Likewise.\n\t* tree-ssa-address.c (addr_for_mem_ref): Use scalar_int_mode for\n\tlocal variables.\n\t* tree-ssa-loop-ivopts.c (get_shiftadd_cost): Take a scalar_int_mode\n\trather than a machine_mode.\n\t* tree-switch-conversion.c (array_value_type): Use scalar_int_mode\n\tfor local variables.\n\t* tree-vrp.c (simplify_float_conversion_using_ranges): Likewise.\n\t* var-tracking.c (use_narrower_mode): Take a scalar_int_mode rather\n\tthan a machine_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251513", "tree": {"sha": "8ae047a4a1de314bb5626316e362e598a1fc4e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ae047a4a1de314bb5626316e362e598a1fc4e2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095a2d76a26fa4ee17fa56bff21bf4f269db2368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a2d76a26fa4ee17fa56bff21bf4f269db2368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095a2d76a26fa4ee17fa56bff21bf4f269db2368", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a2d76a26fa4ee17fa56bff21bf4f269db2368/comments", "author": null, "committer": null, "parents": [{"sha": "d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d787ba568aa9bfa00c71f55b86ddb95a3d153db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d787ba568aa9bfa00c71f55b86ddb95a3d153db0"}], "stats": {"total": 504, "additions": 336, "deletions": 168}, "files": [{"sha": "d7ee5c29afadcac7158e1aa0b6e7fcfff99bc067", "filename": "gcc/ChangeLog", "status": "modified", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1,3 +1,171 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* builtins.h (builtin_strncpy_read_str): Take a scalar_int_mode\n+\tinstead of a machine_mode.\n+\t(builtin_memset_read_str): Likewise.\n+\t* builtins.c (c_readstr): Likewise.\n+\t(builtin_memcpy_read_str): Likewise.\n+\t(builtin_strncpy_read_str): Likewise.\n+\t(builtin_memset_read_str): Likewise.\n+\t(builtin_memset_gen_str): Likewise.\n+\t(expand_builtin_signbit): Use scalar_int_mode for local variables.\n+\t* cfgexpand.c (convert_debug_memory_address): Take a scalar_int_mode\n+\tinstead of a machine_mode.\n+\t* combine.c (simplify_if_then_else): Use scalar_int_mode for local\n+\tvariables.\n+\t(make_extraction): Likewise.\n+\t(try_widen_shift_mode): Take and return scalar_int_modes instead\n+\tof machine_modes.\n+\t* config/aarch64/aarch64.c (aarch64_libgcc_cmp_return_mode): Return\n+\ta scalar_int_mode instead of a machine_mode.\n+\t* config/avr/avr.c (avr_addr_space_address_mode): Likewise.\n+\t(avr_addr_space_pointer_mode): Likewise.\n+\t* config/cr16/cr16.c (cr16_unwind_word_mode): Likewise.\n+\t* config/msp430/msp430.c (msp430_addr_space_pointer_mode): Likewise.\n+\t(msp430_unwind_word_mode): Likewise.\n+\t* config/spu/spu.c (spu_unwind_word_mode): Likewise.\n+\t(spu_addr_space_pointer_mode): Likewise.\n+\t(spu_addr_space_address_mode): Likewise.\n+\t(spu_libgcc_cmp_return_mode): Likewise.\n+\t(spu_libgcc_shift_count_mode): Likewise.\n+\t* config/rl78/rl78.c (rl78_addr_space_address_mode): Likewise.\n+\t(rl78_addr_space_pointer_mode): Likewise.\n+\t(fl78_unwind_word_mode): Likewise.\n+\t(rl78_valid_pointer_mode): Take a scalar_int_mode instead of a\n+\tmachine_mode.\n+\t* config/alpha/alpha.c (vms_valid_pointer_mode): Likewise.\n+\t* config/ia64/ia64.c (ia64_vms_valid_pointer_mode): Likewise.\n+\t* config/mips/mips.c (mips_mode_rep_extended): Likewise.\n+\t(mips_valid_pointer_mode): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_mode_rep_extended): Likewise.\n+\t* config/ft32/ft32.c (ft32_valid_pointer_mode): Likewise.\n+\t(ft32_addr_space_pointer_mode): Return a scalar_int_mode instead\n+\tof a machine_mode.\n+\t(ft32_addr_space_address_mode): Likewise.\n+\t* config/m32c/m32c.c (m32c_valid_pointer_mode): Take a\n+\tscalar_int_mode instead of a machine_mode.\n+\t(m32c_addr_space_pointer_mode): Return a scalar_int_mode instead\n+\tof a machine_mode.\n+\t(m32c_addr_space_address_mode): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_abi_word_mode): Likewise.\n+\t(rs6000_eh_return_filter_mode): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_abi_word_mode): Likewise.\n+\t(rs6000_eh_return_filter_mode): Likewise.\n+\t* config/s390/s390.c (s390_libgcc_cmp_return_mode): Likewise.\n+\t(s390_libgcc_shift_count_mode): Likewise.\n+\t(s390_unwind_word_mode): Likewise.\n+\t(s390_valid_pointer_mode): Take a scalar_int_mode rather than a\n+\tmachine_mode.\n+\t* target.def (mode_rep_extended): Likewise.\n+\t(valid_pointer_mode): Likewise.\n+\t(addr_space.valid_pointer_mode): Likewise.\n+\t(eh_return_filter_mode): Return a scalar_int_mode rather than\n+\ta machine_mode.\n+\t(libgcc_cmp_return_mode): Likewise.\n+\t(libgcc_shift_count_mode): Likewise.\n+\t(unwind_word_mode): Likewise.\n+\t(addr_space.pointer_mode): Likewise.\n+\t(addr_space.address_mode): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* dojump.c (prefer_and_bit_test): Take a scalar_int_mode rather than\n+\ta machine_mode.\n+\t(do_jump): Use scalar_int_mode for local variables.\n+\t* dwarf2cfi.c (init_return_column_size): Take a scalar_int_mode\n+\trather than a machine_mode.\n+\t* dwarf2out.c (convert_descriptor_to_mode): Likewise.\n+\t(scompare_loc_descriptor_wide): Likewise.\n+\t(scompare_loc_descriptor_narrow): Likewise.\n+\t* emit-rtl.c (adjust_address_1): Use scalar_int_mode for local\n+\tvariables.\n+\t* except.c (sjlj_emit_dispatch_table): Likewise.\n+\t(expand_builtin_eh_copy_values): Likewise.\n+\t* explow.c (convert_memory_address_addr_space_1): Likewise.\n+\tTake a scalar_int_mode rather than a machine_mode.\n+\t(convert_memory_address_addr_space): Take a scalar_int_mode rather\n+\tthan a machine_mode.\n+\t(memory_address_addr_space): Use scalar_int_mode for local variables.\n+\t* expmed.h (expand_mult_highpart_adjust): Take a scalar_int_mode\n+\trather than a machine_mode.\n+\t* expmed.c (mask_rtx): Likewise.\n+\t(init_expmed_one_conv): Likewise.\n+\t(expand_mult_highpart_adjust): Likewise.\n+\t(extract_high_half): Likewise.\n+\t(expmed_mult_highpart_optab): Likewise.\n+\t(expmed_mult_highpart): Likewise.\n+\t(expand_smod_pow2): Likewise.\n+\t(expand_sdiv_pow2): Likewise.\n+\t(emit_store_flag_int): Likewise.\n+\t(adjust_bit_field_mem_for_reg): Use scalar_int_mode for local\n+\tvariables.\n+\t(extract_low_bits): Likewise.\n+\t* expr.h (by_pieces_constfn): Take a scalar_int_mode rather than\n+\ta machine_mode.\n+\t* expr.c (pieces_addr::adjust):  Likewise.\n+\t(can_store_by_pieces): Likewise.\n+\t(store_by_pieces): Likewise.\n+\t(clear_by_pieces_1): Likewise.\n+\t(expand_expr_addr_expr_1): Likewise.\n+\t(expand_expr_addr_expr): Use scalar_int_mode for local variables.\n+\t(expand_expr_real_1): Likewise.\n+\t(try_casesi): Likewise.\n+\t* final.c (shorten_branches): Likewise.\n+\t* fold-const.c (fold_convert_const_int_from_fixed): Change the\n+\ttype of \"mode\" to machine_mode.\n+\t* internal-fn.c (expand_arith_overflow_result_store): Take a\n+\tscalar_int_mode rather than a machine_mode.\n+\t(expand_mul_overflow): Use scalar_int_mode for local variables.\n+\t* loop-doloop.c (doloop_modify): Likewise.\n+\t(doloop_optimize): Likewise.\n+\t* optabs.c (expand_subword_shift): Take a scalar_int_mode rather\n+\tthan a machine_mode.\n+\t(expand_doubleword_shift_condmove): Likewise.\n+\t(expand_doubleword_shift): Likewise.\n+\t(expand_doubleword_clz): Likewise.\n+\t(expand_doubleword_popcount): Likewise.\n+\t(expand_doubleword_parity): Likewise.\n+\t(expand_absneg_bit): Use scalar_int_mode for local variables.\n+\t(prepare_float_lib_cmp): Likewise.\n+\t* rtl.h (convert_memory_address_addr_space_1): Take a scalar_int_mode\n+\trather than a machine_mode.\n+\t(convert_memory_address_addr_space): Likewise.\n+\t(get_mode_bounds): Likewise.\n+\t(get_address_mode): Return a scalar_int_mode rather than a\n+\tmachine_mode.\n+\t* rtlanal.c (get_address_mode): Likewise.\n+\t* stor-layout.c (get_mode_bounds): Take a scalar_int_mode rather\n+\tthan a machine_mode.\n+\t* targhooks.c (default_mode_rep_extended): Likewise.\n+\t(default_valid_pointer_mode): Likewise.\n+\t(default_addr_space_valid_pointer_mode): Likewise.\n+\t(default_eh_return_filter_mode): Return a scalar_int_mode rather\n+\tthan a machine_mode.\n+\t(default_libgcc_cmp_return_mode): Likewise.\n+\t(default_libgcc_shift_count_mode): Likewise.\n+\t(default_unwind_word_mode): Likewise.\n+\t(default_addr_space_pointer_mode): Likewise.\n+\t(default_addr_space_address_mode): Likewise.\n+\t* targhooks.h (default_eh_return_filter_mode): Likewise.\n+\t(default_libgcc_cmp_return_mode): Likewise.\n+\t(default_libgcc_shift_count_mode): Likewise.\n+\t(default_unwind_word_mode): Likewise.\n+\t(default_addr_space_pointer_mode): Likewise.\n+\t(default_addr_space_address_mode): Likewise.\n+\t(default_mode_rep_extended): Take a scalar_int_mode rather than\n+\ta machine_mode.\n+\t(default_valid_pointer_mode): Likewise.\n+\t(default_addr_space_valid_pointer_mode): Likewise.\n+\t* tree-ssa-address.c (addr_for_mem_ref): Use scalar_int_mode for\n+\tlocal variables.\n+\t* tree-ssa-loop-ivopts.c (get_shiftadd_cost): Take a scalar_int_mode\n+\trather than a machine_mode.\n+\t* tree-switch-conversion.c (array_value_type): Use scalar_int_mode\n+\tfor local variables.\n+\t* tree-vrp.c (simplify_float_conversion_using_ranges): Likewise.\n+\t* var-tracking.c (use_narrower_mode): Take a scalar_int_mode rather\n+\tthan a machine_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "35be33531b13419fda00c8455363a77a3a3ebed5", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -93,7 +93,7 @@ builtin_info_type builtin_info[(int)END_BUILTINS];\n /* Non-zero if __builtin_constant_p should be folded right away.  */\n bool force_folding_builtin_constant_p;\n \n-static rtx c_readstr (const char *, machine_mode);\n+static rtx c_readstr (const char *, scalar_int_mode);\n static int target_char_cast (tree, char *);\n static rtx get_memory_rtx (tree, tree);\n static int apply_args_size (void);\n@@ -119,7 +119,7 @@ static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n-static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n+static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memcpy_with_bounds (tree, rtx);\n@@ -136,7 +136,7 @@ static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n static rtx expand_builtin_stpncpy (tree, rtx);\n static rtx expand_builtin_strncat (tree, rtx);\n static rtx expand_builtin_strncpy (tree, rtx);\n-static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, machine_mode);\n+static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, scalar_int_mode);\n static rtx expand_builtin_memset (tree, rtx, machine_mode);\n static rtx expand_builtin_memset_with_bounds (tree, rtx, machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, machine_mode, tree);\n@@ -669,7 +669,7 @@ c_strlen (tree src, int only_value)\n    GET_MODE_BITSIZE (MODE) bits from string constant STR.  */\n \n static rtx\n-c_readstr (const char *str, machine_mode mode)\n+c_readstr (const char *str, scalar_int_mode mode)\n {\n   HOST_WIDE_INT ch;\n   unsigned int i, j;\n@@ -2883,7 +2883,7 @@ expand_builtin_strlen (tree exp, rtx target,\n \n static rtx\n builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n-\t\t\t machine_mode mode)\n+\t\t\t scalar_int_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -3744,7 +3744,7 @@ expand_builtin_stpncpy (tree exp, rtx)\n \n rtx\n builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n-\t\t\t  machine_mode mode)\n+\t\t\t  scalar_int_mode mode)\n {\n   const char *str = (const char *) data;\n \n@@ -3952,7 +3952,7 @@ expand_builtin_strncpy (tree exp, rtx target)\n \n rtx\n builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode)\n+\t\t\t scalar_int_mode mode)\n {\n   const char *c = (const char *) data;\n   char *p = XALLOCAVEC (char, GET_MODE_SIZE (mode));\n@@ -3969,7 +3969,7 @@ builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n \n static rtx\n builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode)\n+\t\t\tscalar_int_mode mode)\n {\n   rtx target, coeff;\n   size_t size;\n@@ -5302,7 +5302,7 @@ expand_builtin_signbit (tree exp, rtx target)\n {\n   const struct real_format *fmt;\n   scalar_float_mode fmode;\n-  machine_mode imode, rmode;\n+  scalar_int_mode rmode, imode;\n   tree arg;\n   int word, bitpos;\n   enum insn_code icode;"}, {"sha": "4ae70566f59b4764490fe4343fb585d05656bed7", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -63,8 +63,8 @@ extern void expand_builtin_setjmp_receiver (rtx);\n extern void expand_builtin_update_setjmp_buf (rtx);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree mathfn_built_in (tree, combined_fn);\n-extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, machine_mode);\n-extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, machine_mode);\n+extern rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n+extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n extern rtx expand_builtin_saveregs (void);\n extern tree std_build_builtin_va_list (void);\n extern tree std_fn_abi_va_list (tree);"}, {"sha": "a32f7648d41d034203e2e4368bb4407036b0243e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -3962,7 +3962,7 @@ round_udiv_adjust (machine_mode mode, rtx mod, rtx op1)\n    any rtl.  */\n \n static rtx\n-convert_debug_memory_address (machine_mode mode, rtx x,\n+convert_debug_memory_address (scalar_int_mode mode, rtx x,\n \t\t\t      addr_space_t as)\n {\n #ifndef POINTERS_EXTEND_UNSIGNED"}, {"sha": "bc31280ec3be0514b86789d1a7ef23474a17f900", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -6494,7 +6494,7 @@ simplify_if_then_else (rtx x)\n       rtx cond_op0 = XEXP (cond, 0);\n       rtx cond_op1 = XEXP (cond, 1);\n       enum rtx_code op = UNKNOWN, extend_op = UNKNOWN;\n-      machine_mode m = int_mode;\n+      scalar_int_mode m = int_mode;\n       rtx z = 0, c1 = NULL_RTX;\n \n       if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n@@ -7427,9 +7427,9 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      ignore the POS lowest bits, etc.  */\n   machine_mode is_mode = GET_MODE (inner);\n   machine_mode inner_mode;\n-  machine_mode wanted_inner_mode;\n-  machine_mode wanted_inner_reg_mode = word_mode;\n-  machine_mode pos_mode = word_mode;\n+  scalar_int_mode wanted_inner_mode;\n+  scalar_int_mode wanted_inner_reg_mode = word_mode;\n+  scalar_int_mode pos_mode = word_mode;\n   machine_mode extraction_mode = word_mode;\n   rtx new_rtx = 0;\n   rtx orig_pos_rtx = pos_rtx;\n@@ -10316,9 +10316,9 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n    result of the shift is subject to operation OUTER_CODE with operand\n    OUTER_CONST.  */\n \n-static machine_mode\n+static scalar_int_mode\n try_widen_shift_mode (enum rtx_code code, rtx op, int count,\n-\t\t      machine_mode orig_mode, machine_mode mode,\n+\t\t      scalar_int_mode orig_mode, scalar_int_mode mode,\n \t\t      enum rtx_code outer_code, HOST_WIDE_INT outer_const)\n {\n   gcc_assert (GET_MODE_PRECISION (mode) > GET_MODE_PRECISION (orig_mode));"}, {"sha": "09f592718c64562aa6c4c3f95e22cdab2c6325d5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2653,7 +2653,7 @@ aarch64_pad_reg_upward (machine_mode mode, const_tree type,\n   return !BYTES_BIG_ENDIAN;\n }\n \n-static machine_mode\n+static scalar_int_mode\n aarch64_libgcc_cmp_return_mode (void)\n {\n   return SImode;"}, {"sha": "dbfd29862fc25756bcd41db02b809ef4501fc7d8", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -209,7 +209,7 @@ static void alpha_override_options_after_change (void);\n \n #if TARGET_ABI_OPEN_VMS\n static void alpha_write_linkage (FILE *, const char *);\n-static bool vms_valid_pointer_mode (machine_mode);\n+static bool vms_valid_pointer_mode (scalar_int_mode);\n #else\n #define vms_patch_builtins()  gcc_unreachable()\n #endif\n@@ -819,7 +819,7 @@ alpha_in_small_data_p (const_tree exp)\n \n #if TARGET_ABI_OPEN_VMS\n static bool\n-vms_valid_pointer_mode (machine_mode mode)\n+vms_valid_pointer_mode (scalar_int_mode mode)\n {\n   return (mode == SImode || mode == DImode);\n }"}, {"sha": "ad777e081fd627228acedff35a48e1da43feee03", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -12929,7 +12929,7 @@ avr_case_values_threshold (void)\n \n /* Implement `TARGET_ADDR_SPACE_ADDRESS_MODE'.  */\n \n-static machine_mode\n+static scalar_int_mode\n avr_addr_space_address_mode (addr_space_t as)\n {\n   return avr_addrspace[as].pointer_size == 3 ? PSImode : HImode;\n@@ -12938,7 +12938,7 @@ avr_addr_space_address_mode (addr_space_t as)\n \n /* Implement `TARGET_ADDR_SPACE_POINTER_MODE'.  */\n \n-static machine_mode\n+static scalar_int_mode\n avr_addr_space_pointer_mode (addr_space_t as)\n {\n   return avr_addr_space_address_mode (as);"}, {"sha": "729eec80c9175b0245a2525383d2035c51f9209b", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2092,7 +2092,7 @@ notice_update_cc (rtx exp)\n   return;\n }\n \n-static machine_mode\n+static scalar_int_mode\n cr16_unwind_word_mode (void)\n {\n   return SImode;"}, {"sha": "fada9248329f4e4762ee8f5b8ce50c4144c8845e", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -792,7 +792,7 @@ ft32_is_mem_pm (rtx o)\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE ft32_valid_pointer_mode\n static bool\n-ft32_valid_pointer_mode (machine_mode mode)\n+ft32_valid_pointer_mode (scalar_int_mode mode)\n {\n   if (mode == SImode)\n     return 1;\n@@ -801,15 +801,15 @@ ft32_valid_pointer_mode (machine_mode mode)\n \n #undef TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE ft32_addr_space_pointer_mode\n-static machine_mode\n+static scalar_int_mode\n ft32_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return Pmode;\n }\n \n #undef TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE ft32_addr_space_address_mode\n-static machine_mode\n+static scalar_int_mode\n ft32_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return Pmode;"}, {"sha": "579751605107e6191a0396deb8e95c0c8db86600", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -299,7 +299,7 @@ static void ia64_vms_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n static void ia64_soft_fp_init_libfuncs (void)\n      ATTRIBUTE_UNUSED;\n-static bool ia64_vms_valid_pointer_mode (machine_mode mode)\n+static bool ia64_vms_valid_pointer_mode (scalar_int_mode mode)\n      ATTRIBUTE_UNUSED;\n static tree ia64_vms_common_object_attribute (tree *, tree, tree, int, bool *)\n      ATTRIBUTE_UNUSED;\n@@ -10728,7 +10728,7 @@ ia64_soft_fp_init_libfuncs (void)\n }\n \n static bool\n-ia64_vms_valid_pointer_mode (machine_mode mode)\n+ia64_vms_valid_pointer_mode (scalar_int_mode mode)\n {\n   return (mode == SImode || mode == DImode);\n }"}, {"sha": "8552ae69a11bccb8661a971d3000399d2b62ae81", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1437,7 +1437,7 @@ m32c_function_arg_regno_p (int r)\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE m32c_valid_pointer_mode\n static bool\n-m32c_valid_pointer_mode (machine_mode mode)\n+m32c_valid_pointer_mode (scalar_int_mode mode)\n {\n   if (mode == HImode\n       || mode == PSImode\n@@ -1930,7 +1930,7 @@ m32c_legitimize_reload_address (rtx * x,\n /* Return the appropriate mode for a named address pointer.  */\n #undef TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE m32c_addr_space_pointer_mode\n-static machine_mode\n+static scalar_int_mode\n m32c_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1947,7 +1947,7 @@ m32c_addr_space_pointer_mode (addr_space_t addrspace)\n /* Return the appropriate mode for a named address address.  */\n #undef TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE m32c_addr_space_address_mode\n-static machine_mode\n+static scalar_int_mode\n m32c_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)"}, {"sha": "1f42c5671499970f329aa1ab0ef12a288ce2e418", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -13262,7 +13262,7 @@ mips_secondary_reload_class (enum reg_class rclass,\n /* Implement TARGET_MODE_REP_EXTENDED.  */\n \n static int\n-mips_mode_rep_extended (machine_mode mode, machine_mode mode_rep)\n+mips_mode_rep_extended (scalar_int_mode mode, scalar_int_mode mode_rep)\n {\n   /* On 64-bit targets, SImode register values are sign-extended to DImode.  */\n   if (TARGET_64BIT && mode == SImode && mode_rep == DImode)\n@@ -13274,7 +13274,7 @@ mips_mode_rep_extended (machine_mode mode, machine_mode mode_rep)\n /* Implement TARGET_VALID_POINTER_MODE.  */\n \n static bool\n-mips_valid_pointer_mode (machine_mode mode)\n+mips_valid_pointer_mode (scalar_int_mode mode)\n {\n   return mode == SImode || (TARGET_64BIT && mode == DImode);\n }"}, {"sha": "d597812ec3e455f7c91d787e14aa5dadb87a9e08", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1023,7 +1023,7 @@ msp430_initial_elimination_offset (int from, int to)\n #undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE msp430_addr_space_pointer_mode\n \n-static machine_mode\n+static scalar_int_mode\n msp430_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1043,7 +1043,7 @@ msp430_addr_space_pointer_mode (addr_space_t addrspace)\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE msp430_unwind_word_mode\n \n-static machine_mode\n+static scalar_int_mode\n msp430_unwind_word_mode (void)\n {\n   /* This needs to match msp430_init_dwarf_reg_sizes_extra (below).  */"}, {"sha": "3f418b027fa9ea93b92f2c4f8a695227f533f068", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -11881,7 +11881,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n /* The mode the ABI uses for a word.  This is not the same as word_mode\n    for -m32 -mpowerpc64.  This is used to implement various target hooks.  */\n \n-static machine_mode\n+static scalar_int_mode\n rs6000_abi_word_mode (void)\n {\n   return TARGET_32BIT ? SImode : DImode;\n@@ -39148,7 +39148,7 @@ rs6000_dbx_register_number (unsigned int regno, unsigned int format)\n }\n \n /* target hook eh_return_filter_mode */\n-static machine_mode\n+static scalar_int_mode\n rs6000_eh_return_filter_mode (void)\n {\n   return TARGET_32BIT ? SImode : word_mode;"}, {"sha": "429e934f37a048539aa5d520c6398240ac892589", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -998,7 +998,7 @@ rl78_hl_b_c_addr_p (rtx op)\n #undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n \n-static machine_mode\n+static scalar_int_mode\n rl78_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1038,7 +1038,7 @@ rl78_far_p (rtx x)\n #undef  TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE rl78_addr_space_pointer_mode\n \n-static machine_mode\n+static scalar_int_mode\n rl78_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -1059,7 +1059,7 @@ rl78_addr_space_pointer_mode (addr_space_t addrspace)\n #define TARGET_VALID_POINTER_MODE rl78_valid_pointer_mode\n \n static bool\n-rl78_valid_pointer_mode (machine_mode m)\n+rl78_valid_pointer_mode (scalar_int_mode m)\n {\n   return (m == HImode || m == SImode);\n }\n@@ -4638,7 +4638,7 @@ rl78_asm_out_integer (rtx x, unsigned int size, int aligned_p)\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE rl78_unwind_word_mode\n \n-static machine_mode\n+static scalar_int_mode\n rl78_unwind_word_mode (void)\n {\n   return HImode;"}, {"sha": "97a7005e2cdd89ef1d959817c087c282ad4b329a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -11316,7 +11316,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n /* The mode the ABI uses for a word.  This is not the same as word_mode\n    for -m32 -mpowerpc64.  This is used to implement various target hooks.  */\n \n-static machine_mode\n+static scalar_int_mode\n rs6000_abi_word_mode (void)\n {\n   return TARGET_32BIT ? SImode : DImode;\n@@ -35905,7 +35905,7 @@ rs6000_dbx_register_number (unsigned int regno, unsigned int format)\n }\n \n /* target hook eh_return_filter_mode */\n-static machine_mode\n+static scalar_int_mode\n rs6000_eh_return_filter_mode (void)\n {\n   return TARGET_32BIT ? SImode : word_mode;"}, {"sha": "e013751c7ad65b9aa4894153dd9c293bb3b685e7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1209,19 +1209,19 @@ s390_got_symbol (void)\n   return got_symbol;\n }\n \n-static machine_mode\n+static scalar_int_mode\n s390_libgcc_cmp_return_mode (void)\n {\n   return TARGET_64BIT ? DImode : SImode;\n }\n \n-static machine_mode\n+static scalar_int_mode\n s390_libgcc_shift_count_mode (void)\n {\n   return TARGET_64BIT ? DImode : SImode;\n }\n \n-static machine_mode\n+static scalar_int_mode\n s390_unwind_word_mode (void)\n {\n   return TARGET_64BIT ? DImode : SImode;\n@@ -13138,7 +13138,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n }\n \n static bool\n-s390_valid_pointer_mode (machine_mode mode)\n+s390_valid_pointer_mode (scalar_int_mode mode)\n {\n   return (mode == SImode || (TARGET_64BIT && mode == DImode));\n }"}, {"sha": "20c88e6953d8a793c40c874a15de0fd6bc627487", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -5323,7 +5323,7 @@ spu_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-static machine_mode\n+static scalar_int_mode\n spu_unwind_word_mode (void)\n {\n   return SImode;\n@@ -6699,7 +6699,7 @@ spu_vector_alignment_reachable (const_tree type ATTRIBUTE_UNUSED, bool is_packed\n }\n \n /* Return the appropriate mode for a named address pointer.  */\n-static machine_mode\n+static scalar_int_mode\n spu_addr_space_pointer_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -6714,7 +6714,7 @@ spu_addr_space_pointer_mode (addr_space_t addrspace)\n }\n \n /* Return the appropriate mode for a named address address.  */\n-static machine_mode\n+static scalar_int_mode\n spu_addr_space_address_mode (addr_space_t addrspace)\n {\n   switch (addrspace)\n@@ -6860,7 +6860,7 @@ spu_init_expanders (void)\n     }\n }\n \n-static machine_mode\n+static scalar_int_mode\n spu_libgcc_cmp_return_mode (void)\n {\n \n@@ -6869,7 +6869,7 @@ spu_libgcc_cmp_return_mode (void)\n   return SImode;\n }\n \n-static machine_mode\n+static scalar_int_mode\n spu_libgcc_shift_count_mode (void)\n {\n /* For SPU word mode is TI mode so it is better to use SImode"}, {"sha": "250bb34917ff2413acddeda5b8983f0f26ace855", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -188,7 +188,7 @@ tilegx_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n \n /* Implement TARGET_MODE_REP_EXTENDED.  */\n static int\n-tilegx_mode_rep_extended (machine_mode mode, machine_mode mode_rep)\n+tilegx_mode_rep_extended (scalar_int_mode mode, scalar_int_mode mode_rep)\n {\n   /* SImode register values are sign-extended to DImode.  */\n   if (mode == SImode && mode_rep == DImode)"}, {"sha": "b415bf82d771430401b319af4ec1eb8bb1f6101e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1339,21 +1339,21 @@ You would most commonly define this macro if the @code{allocate_stack}\n pattern needs to support both a 32- and a 64-bit mode.\n @end defmac\n \n-@deftypefn {Target Hook} machine_mode TARGET_LIBGCC_CMP_RETURN_MODE (void)\n+@deftypefn {Target Hook} scalar_int_mode TARGET_LIBGCC_CMP_RETURN_MODE (void)\n This target hook should return the mode to be used for the return value\n of compare instructions expanded to libgcc calls.  If not defined\n @code{word_mode} is returned which is the right choice for a majority of\n targets.\n @end deftypefn\n \n-@deftypefn {Target Hook} machine_mode TARGET_LIBGCC_SHIFT_COUNT_MODE (void)\n+@deftypefn {Target Hook} scalar_int_mode TARGET_LIBGCC_SHIFT_COUNT_MODE (void)\n This target hook should return the mode to be used for the shift count operand\n of shift instructions expanded to libgcc calls.  If not defined\n @code{word_mode} is returned which is the right choice for a majority of\n targets.\n @end deftypefn\n \n-@deftypefn {Target Hook} machine_mode TARGET_UNWIND_WORD_MODE (void)\n+@deftypefn {Target Hook} scalar_int_mode TARGET_UNWIND_WORD_MODE (void)\n Return machine mode to be used for @code{_Unwind_Word} type.\n The default is to use @code{word_mode}.\n @end deftypefn\n@@ -4203,7 +4203,7 @@ arguments to @code{va_arg}; the latter two are as in\n @code{gimplify.c:gimplify_expr}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VALID_POINTER_MODE (machine_mode @var{mode})\n+@deftypefn {Target Hook} bool TARGET_VALID_POINTER_MODE (scalar_int_mode @var{mode})\n Define this to return nonzero if the port can handle pointers\n with machine mode @var{mode}.  The default version of this\n hook returns true for both @code{ptr_mode} and @code{Pmode}.\n@@ -10527,19 +10527,19 @@ named address space #1:\n c_register_addr_space (\"__ea\", ADDR_SPACE_EA);\n @end smallexample\n \n-@deftypefn {Target Hook} machine_mode TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t @var{address_space})\n+@deftypefn {Target Hook} scalar_int_mode TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t @var{address_space})\n Define this to return the machine mode to use for pointers to\n @var{address_space} if the target supports named address spaces.\n The default version of this hook returns @code{ptr_mode}.\n @end deftypefn\n \n-@deftypefn {Target Hook} machine_mode TARGET_ADDR_SPACE_ADDRESS_MODE (addr_space_t @var{address_space})\n+@deftypefn {Target Hook} scalar_int_mode TARGET_ADDR_SPACE_ADDRESS_MODE (addr_space_t @var{address_space})\n Define this to return the machine mode to use for addresses in\n @var{address_space} if the target supports named address spaces.\n The default version of this hook returns @code{Pmode}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_VALID_POINTER_MODE (machine_mode @var{mode}, addr_space_t @var{as})\n+@deftypefn {Target Hook} bool TARGET_ADDR_SPACE_VALID_POINTER_MODE (scalar_int_mode @var{mode}, addr_space_t @var{as})\n Define this to return nonzero if the port can handle pointers\n with machine mode @var{mode} to address space @var{as}.  This target\n hook is the same as the @code{TARGET_VALID_POINTER_MODE} target hook,\n@@ -10802,7 +10802,7 @@ If this is the case, making @code{TRULY_NOOP_TRUNCATION} return 0 in\n such cases may improve things.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_MODE_REP_EXTENDED (machine_mode @var{mode}, machine_mode @var{rep_mode})\n+@deftypefn {Target Hook} int TARGET_MODE_REP_EXTENDED (scalar_int_mode @var{mode}, scalar_int_mode @var{rep_mode})\n The representation of an integral mode can be such that the values\n are always extended to a wider integral mode.  Return\n @code{SIGN_EXTEND} if values of @var{mode} are represented in"}, {"sha": "db8b278b982b6208196c8673b5571d91ee3d1658", "filename": "gcc/dojump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -37,7 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"langhooks.h\"\n \n-static bool prefer_and_bit_test (machine_mode, int);\n+static bool prefer_and_bit_test (scalar_int_mode, int);\n static void do_jump_by_parts_greater (scalar_int_mode, tree, tree, int,\n \t\t\t\t      rtx_code_label *, rtx_code_label *,\n \t\t\t\t      profile_probability);\n@@ -161,7 +161,7 @@ static GTY(()) rtx shift_test;\n    is preferred.  */\n \n static bool\n-prefer_and_bit_test (machine_mode mode, int bitnum)\n+prefer_and_bit_test (scalar_int_mode mode, int bitnum)\n {\n   bool speed_p;\n   wide_int mask = wi::set_bit_in_zero (bitnum, GET_MODE_PRECISION (mode));\n@@ -427,7 +427,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n   rtx temp;\n   int i;\n   tree type;\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   rtx_code_label *drop_through_label = NULL;\n \n   switch (code)"}, {"sha": "b2ee8d6cf027453f27463f724a6d485cb93cb6ac", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -232,7 +232,7 @@ expand_builtin_dwarf_sp_column (void)\n    which has mode MODE.  Initialize column C as a return address column.  */\n \n static void\n-init_return_column_size (machine_mode mode, rtx mem, unsigned int c)\n+init_return_column_size (scalar_int_mode mode, rtx mem, unsigned int c)\n {\n   HOST_WIDE_INT offset = c * GET_MODE_SIZE (mode);\n   HOST_WIDE_INT size = GET_MODE_SIZE (Pmode);"}, {"sha": "f857a2773a27476bf8b15b7076f9d1e137f91e2b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -13890,7 +13890,7 @@ base_type_for_mode (machine_mode mode, bool unsignedp)\n    possible.  */\n \n static dw_loc_descr_ref\n-convert_descriptor_to_mode (machine_mode mode, dw_loc_descr_ref op)\n+convert_descriptor_to_mode (scalar_int_mode mode, dw_loc_descr_ref op)\n {\n   machine_mode outer_mode = mode;\n   dw_die_ref type_die;\n@@ -13935,7 +13935,7 @@ compare_loc_descriptor (enum dwarf_location_atom op, dw_loc_descr_ref op0,\n \n static dw_loc_descr_ref\n scompare_loc_descriptor_wide (enum dwarf_location_atom op,\n-\t\t\t      machine_mode op_mode,\n+\t\t\t      scalar_int_mode op_mode,\n \t\t\t      dw_loc_descr_ref op0, dw_loc_descr_ref op1)\n {\n   dw_die_ref type_die = base_type_for_mode (op_mode, 0);\n@@ -13962,7 +13962,7 @@ scompare_loc_descriptor_wide (enum dwarf_location_atom op,\n \n static dw_loc_descr_ref\n scompare_loc_descriptor_narrow (enum dwarf_location_atom op, rtx rtl,\n-\t\t\t\tmachine_mode op_mode,\n+\t\t\t\tscalar_int_mode op_mode,\n \t\t\t\tdw_loc_descr_ref op0, dw_loc_descr_ref op1)\n {\n   int shift = (DWARF2_ADDR_SIZE - GET_MODE_SIZE (op_mode)) * BITS_PER_UNIT;"}, {"sha": "f0c09ffebe781eb7f7305cdf8999242e71a0959c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2211,12 +2211,12 @@ adjust_address_1 (rtx memref, machine_mode mode, HOST_WIDE_INT offset,\n {\n   rtx addr = XEXP (memref, 0);\n   rtx new_rtx;\n-  machine_mode address_mode;\n+  scalar_int_mode address_mode;\n   int pbits;\n   struct mem_attrs attrs = *get_mem_attrs (memref), *defattrs;\n   unsigned HOST_WIDE_INT max_align;\n #ifdef POINTERS_EXTEND_UNSIGNED\n-  machine_mode pointer_mode\n+  scalar_int_mode pointer_mode\n     = targetm.addr_space.pointer_mode (attrs.addrspace);\n #endif\n "}, {"sha": "1159b188c57124d1d69a71427c97e6545b212097", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1251,8 +1251,8 @@ sjlj_emit_function_exit (void)\n static void\n sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n {\n-  machine_mode unwind_word_mode = targetm.unwind_word_mode ();\n-  machine_mode filter_mode = targetm.eh_return_filter_mode ();\n+  scalar_int_mode unwind_word_mode = targetm.unwind_word_mode ();\n+  scalar_int_mode filter_mode = targetm.eh_return_filter_mode ();\n   eh_landing_pad lp;\n   rtx mem, fc, exc_ptr_reg, filter_reg;\n   rtx_insn *seq;\n@@ -2073,7 +2073,7 @@ expand_builtin_eh_copy_values (tree exp)\n     = expand_builtin_eh_common (CALL_EXPR_ARG (exp, 0));\n   eh_region src\n     = expand_builtin_eh_common (CALL_EXPR_ARG (exp, 1));\n-  machine_mode fmode = targetm.eh_return_filter_mode ();\n+  scalar_int_mode fmode = targetm.eh_return_filter_mode ();\n \n   if (dst->exc_ptr_reg == NULL)\n     dst->exc_ptr_reg = gen_reg_rtx (ptr_mode);"}, {"sha": "5079629bf6f7ebd59c0109282fb4f2679fe7c57a", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -275,7 +275,7 @@ break_out_memory_refs (rtx x)\n    it should return NULL if it can't be simplified without emitting insns.  */\n \n rtx\n-convert_memory_address_addr_space_1 (machine_mode to_mode ATTRIBUTE_UNUSED,\n+convert_memory_address_addr_space_1 (scalar_int_mode to_mode ATTRIBUTE_UNUSED,\n \t\t\t\t     rtx x, addr_space_t as ATTRIBUTE_UNUSED,\n \t\t\t\t     bool in_const ATTRIBUTE_UNUSED,\n \t\t\t\t     bool no_emit ATTRIBUTE_UNUSED)\n@@ -284,7 +284,7 @@ convert_memory_address_addr_space_1 (machine_mode to_mode ATTRIBUTE_UNUSED,\n   gcc_assert (GET_MODE (x) == to_mode || GET_MODE (x) == VOIDmode);\n   return x;\n #else /* defined(POINTERS_EXTEND_UNSIGNED) */\n-  machine_mode pointer_mode, address_mode, from_mode;\n+  scalar_int_mode pointer_mode, address_mode, from_mode;\n   rtx temp;\n   enum rtx_code code;\n \n@@ -380,7 +380,8 @@ convert_memory_address_addr_space_1 (machine_mode to_mode ATTRIBUTE_UNUSED,\n    arithmetic insns can be used.  */\n \n rtx\n-convert_memory_address_addr_space (machine_mode to_mode, rtx x, addr_space_t as)\n+convert_memory_address_addr_space (scalar_int_mode to_mode, rtx x,\n+\t\t\t\t   addr_space_t as)\n {\n   return convert_memory_address_addr_space_1 (to_mode, x, as, false, false);\n }\n@@ -394,7 +395,7 @@ rtx\n memory_address_addr_space (machine_mode mode, rtx x, addr_space_t as)\n {\n   rtx oldx = x;\n-  machine_mode address_mode = targetm.addr_space.address_mode (as);\n+  scalar_int_mode address_mode = targetm.addr_space.address_mode (as);\n \n   x = convert_memory_address_addr_space (address_mode, x, as);\n "}, {"sha": "5873df423837c3acb1b2fd3d49a8fb066babf6f9", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -72,16 +72,16 @@ static rtx extract_split_bit_field (rtx, opt_scalar_int_mode,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT, int, bool);\n static void do_cmp_and_jump (rtx, rtx, enum rtx_code, machine_mode, rtx_code_label *);\n-static rtx expand_smod_pow2 (machine_mode, rtx, HOST_WIDE_INT);\n-static rtx expand_sdiv_pow2 (machine_mode, rtx, HOST_WIDE_INT);\n+static rtx expand_smod_pow2 (scalar_int_mode, rtx, HOST_WIDE_INT);\n+static rtx expand_sdiv_pow2 (scalar_int_mode, rtx, HOST_WIDE_INT);\n \n /* Return a constant integer mask value of mode MODE with BITSIZE ones\n    followed by BITPOS zeros, or the complement of that if COMPLEMENT.\n    The mask is truncated if necessary to the width of mode MODE.  The\n    mask is zero-extended if BITSIZE+BITPOS is too small for MODE.  */\n \n static inline rtx\n-mask_rtx (machine_mode mode, int bitpos, int bitsize, bool complement)\n+mask_rtx (scalar_int_mode mode, int bitpos, int bitsize, bool complement)\n {\n   return immed_wide_int_const\n     (wi::shifted_mask (bitpos, bitsize, complement,\n@@ -118,8 +118,8 @@ struct init_expmed_rtl\n };\n \n static void\n-init_expmed_one_conv (struct init_expmed_rtl *all, machine_mode to_mode,\n-\t\t      machine_mode from_mode, bool speed)\n+init_expmed_one_conv (struct init_expmed_rtl *all, scalar_int_mode to_mode,\n+\t\t      scalar_int_mode from_mode, bool speed)\n {\n   int to_size, from_size;\n   rtx which;\n@@ -478,7 +478,7 @@ adjust_bit_field_mem_for_reg (enum extraction_pattern pattern,\n \t{\n \t  /* Limit the search to the mode required by the corresponding\n \t     register insertion or extraction instruction, if any.  */\n-\t  machine_mode limit_mode = word_mode;\n+\t  scalar_int_mode limit_mode = word_mode;\n \t  extraction_insn insn;\n \t  if (get_best_reg_extraction_insn (&insn, pattern,\n \t\t\t\t\t    GET_MODE_BITSIZE (best_mode),\n@@ -2269,7 +2269,7 @@ extract_split_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n rtx\n extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n {\n-  machine_mode int_mode, src_int_mode;\n+  scalar_int_mode int_mode, src_int_mode;\n \n   if (mode == src_mode)\n     return src;\n@@ -2600,9 +2600,9 @@ static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT,\n static rtx expand_mult_const (machine_mode, rtx, HOST_WIDE_INT, rtx,\n \t\t\t      const struct algorithm *, enum mult_variant);\n static unsigned HOST_WIDE_INT invert_mod2n (unsigned HOST_WIDE_INT, int);\n-static rtx extract_high_half (machine_mode, rtx);\n-static rtx expmed_mult_highpart (machine_mode, rtx, rtx, rtx, int, int);\n-static rtx expmed_mult_highpart_optab (machine_mode, rtx, rtx, rtx,\n+static rtx extract_high_half (scalar_int_mode, rtx);\n+static rtx expmed_mult_highpart (scalar_int_mode, rtx, rtx, rtx, int, int);\n+static rtx expmed_mult_highpart_optab (scalar_int_mode, rtx, rtx, rtx,\n \t\t\t\t       int, int);\n /* Compute and return the best algorithm for multiplying by T.\n    The algorithm must cost less than cost_limit\n@@ -3645,7 +3645,7 @@ invert_mod2n (unsigned HOST_WIDE_INT x, int n)\n    MODE is the mode of operation.  */\n \n rtx\n-expand_mult_highpart_adjust (machine_mode mode, rtx adj_operand, rtx op0,\n+expand_mult_highpart_adjust (scalar_int_mode mode, rtx adj_operand, rtx op0,\n \t\t\t     rtx op1, rtx target, int unsignedp)\n {\n   rtx tem;\n@@ -3670,7 +3670,7 @@ expand_mult_highpart_adjust (machine_mode mode, rtx adj_operand, rtx op0,\n /* Subroutine of expmed_mult_highpart.  Return the MODE high part of OP.  */\n \n static rtx\n-extract_high_half (machine_mode mode, rtx op)\n+extract_high_half (scalar_int_mode mode, rtx op)\n {\n   machine_mode wider_mode;\n \n@@ -3689,7 +3689,7 @@ extract_high_half (machine_mode mode, rtx op)\n    optab.  OP1 is an rtx for the constant operand.  */\n \n static rtx\n-expmed_mult_highpart_optab (machine_mode mode, rtx op0, rtx op1,\n+expmed_mult_highpart_optab (scalar_int_mode mode, rtx op0, rtx op1,\n \t\t\t    rtx target, int unsignedp, int max_cost)\n {\n   rtx narrow_op1 = gen_int_mode (INTVAL (op1), mode);\n@@ -3804,7 +3804,7 @@ expmed_mult_highpart_optab (machine_mode mode, rtx op0, rtx op1,\n    MAX_COST is the total allowed cost for the expanded RTL.  */\n \n static rtx\n-expmed_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n+expmed_mult_highpart (scalar_int_mode mode, rtx op0, rtx op1,\n \t\t      rtx target, int unsignedp, int max_cost)\n {\n   machine_mode wider_mode = GET_MODE_WIDER_MODE (mode).require ();\n@@ -3868,7 +3868,7 @@ expmed_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n /* Expand signed modulus of OP0 by a power of two D in mode MODE.  */\n \n static rtx\n-expand_smod_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n+expand_smod_pow2 (scalar_int_mode mode, rtx op0, HOST_WIDE_INT d)\n {\n   rtx result, temp, shift;\n   rtx_code_label *label;\n@@ -3965,7 +3965,7 @@ expand_smod_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n    This routine is only called for positive values of D.  */\n \n static rtx\n-expand_sdiv_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n+expand_sdiv_pow2 (scalar_int_mode mode, rtx op0, HOST_WIDE_INT d)\n {\n   rtx temp;\n   rtx_code_label *label;\n@@ -5630,7 +5630,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n rtx\n emit_store_flag_int (rtx target, rtx subtarget, enum rtx_code code, rtx op0,\n-\t\t     rtx op1, machine_mode mode, int unsignedp,\n+\t\t     rtx op1, scalar_int_mode mode, int unsignedp,\n \t\t     int normalizep, rtx trueval)\n {\n   machine_mode target_mode = target ? GET_MODE (target) : VOIDmode;"}, {"sha": "712c7715ec812a1181660f76e64e07866c20afe2", "filename": "gcc/expmed.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -728,6 +728,7 @@ extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      machine_mode, machine_mode, bool, rtx *);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);\n extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int);\n-extern rtx expand_mult_highpart_adjust (machine_mode, rtx, rtx, rtx, rtx, int);\n+extern rtx expand_mult_highpart_adjust (scalar_int_mode, rtx, rtx, rtx,\n+\t\t\t\t\trtx, int);\n \n #endif  // EXPMED_H"}, {"sha": "fcad2e39445a4102fd12c0af9a1f571bd3f15de9", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -842,7 +842,7 @@ class pieces_addr\n   void *m_cfndata;\n public:\n   pieces_addr (rtx, bool, by_pieces_constfn, void *);\n-  rtx adjust (machine_mode, HOST_WIDE_INT);\n+  rtx adjust (scalar_int_mode, HOST_WIDE_INT);\n   void increment_address (HOST_WIDE_INT);\n   void maybe_predec (HOST_WIDE_INT);\n   void maybe_postinc (HOST_WIDE_INT);\n@@ -944,7 +944,7 @@ pieces_addr::decide_autoinc (machine_mode ARG_UNUSED (mode), bool reverse,\n    but we still modify the MEM's properties.  */\n \n rtx\n-pieces_addr::adjust (machine_mode mode, HOST_WIDE_INT offset)\n+pieces_addr::adjust (scalar_int_mode mode, HOST_WIDE_INT offset)\n {\n   if (m_constfn)\n     return m_constfn (m_cfndata, offset, mode);\n@@ -1277,7 +1277,7 @@ store_by_pieces_d::finish_endp (int endp)\n \n int\n can_store_by_pieces (unsigned HOST_WIDE_INT len,\n-\t\t     rtx (*constfun) (void *, HOST_WIDE_INT, machine_mode),\n+\t\t     rtx (*constfun) (void *, HOST_WIDE_INT, scalar_int_mode),\n \t\t     void *constfundata, unsigned int align, bool memsetp)\n {\n   unsigned HOST_WIDE_INT l;\n@@ -1356,7 +1356,7 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \n rtx\n store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n-\t\t rtx (*constfun) (void *, HOST_WIDE_INT, machine_mode),\n+\t\t rtx (*constfun) (void *, HOST_WIDE_INT, scalar_int_mode),\n \t\t void *constfundata, unsigned int align, bool memsetp, int endp)\n {\n   if (len == 0)\n@@ -1383,7 +1383,7 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n    Return const0_rtx unconditionally.  */\n \n static rtx\n-clear_by_pieces_1 (void *, HOST_WIDE_INT, machine_mode)\n+clear_by_pieces_1 (void *, HOST_WIDE_INT, scalar_int_mode)\n {\n   return const0_rtx;\n }\n@@ -7706,7 +7706,7 @@ expand_expr_constant (tree exp, int defer, enum expand_modifier modifier)\n    The TARGET, TMODE and MODIFIER arguments are as for expand_expr.  */\n \n static rtx\n-expand_expr_addr_expr_1 (tree exp, rtx target, machine_mode tmode,\n+expand_expr_addr_expr_1 (tree exp, rtx target, scalar_int_mode tmode,\n \t\t         enum expand_modifier modifier, addr_space_t as)\n {\n   rtx result, subtarget;\n@@ -7891,8 +7891,8 @@ expand_expr_addr_expr (tree exp, rtx target, machine_mode tmode,\n \t\t       enum expand_modifier modifier)\n {\n   addr_space_t as = ADDR_SPACE_GENERIC;\n-  machine_mode address_mode = Pmode;\n-  machine_mode pointer_mode = ptr_mode;\n+  scalar_int_mode address_mode = Pmode;\n+  scalar_int_mode pointer_mode = ptr_mode;\n   machine_mode rmode;\n   rtx result;\n \n@@ -7910,9 +7910,9 @@ expand_expr_addr_expr (tree exp, rtx target, machine_mode tmode,\n   /* We can get called with some Weird Things if the user does silliness\n      like \"(short) &a\".  In that case, convert_memory_address won't do\n      the right thing, so ignore the given target mode.  */\n-  machine_mode new_tmode = (tmode == pointer_mode\n-\t\t\t    ? pointer_mode\n-\t\t\t    : address_mode);\n+  scalar_int_mode new_tmode = (tmode == pointer_mode\n+\t\t\t       ? pointer_mode\n+\t\t\t       : address_mode);\n \n   result = expand_expr_addr_expr_1 (TREE_OPERAND (exp, 0), target,\n \t\t\t\t    new_tmode, modifier, as);\n@@ -9999,7 +9999,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t  /* Writing into CONST_DECL is always invalid, but handle it\n \t     gracefully.  */\n \t  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));\n-\t  machine_mode address_mode = targetm.addr_space.address_mode (as);\n+\t  scalar_int_mode address_mode = targetm.addr_space.address_mode (as);\n \t  op0 = expand_expr_addr_expr_1 (exp, NULL_RTX, address_mode,\n \t\t\t\t\t EXPAND_NORMAL, as);\n \t  op0 = memory_address_addr_space (mode, op0, as);\n@@ -11538,7 +11538,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n             profile_probability default_probability)\n {\n   struct expand_operand ops[5];\n-  machine_mode index_mode = SImode;\n+  scalar_int_mode index_mode = SImode;\n   rtx op1, op2, index;\n \n   if (! targetm.have_casesi ())"}, {"sha": "0603797d8670b311620973f5b6f260a8a4568871", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -103,7 +103,7 @@ enum block_op_methods\n   BLOCK_OP_TAILCALL\n };\n \n-typedef rtx (*by_pieces_constfn) (void *, HOST_WIDE_INT, machine_mode);\n+typedef rtx (*by_pieces_constfn) (void *, HOST_WIDE_INT, scalar_int_mode);\n \n extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,"}, {"sha": "eff2ee6c4966e2f7e48fd355c09a594c1b7ff02f", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1276,7 +1276,7 @@ shorten_branches (rtx_insn *first)\n \t      rtx_insn *prev;\n \t      int rel_align = 0;\n \t      addr_diff_vec_flags flags;\n-\t      machine_mode vec_mode;\n+\t      scalar_int_mode vec_mode;\n \n \t      /* Avoid automatic aggregate initialization.  */\n \t      flags = ADDR_DIFF_VEC_FLAGS (body);"}, {"sha": "e61195d9763c769970de49b1356d42082faf7b83", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1944,7 +1944,7 @@ fold_convert_const_int_from_fixed (tree type, const_tree arg1)\n {\n   tree t;\n   double_int temp, temp_trunc;\n-  unsigned int mode;\n+  machine_mode mode;\n \n   /* Right shift FIXED_CST to temp by fbit.  */\n   temp = TREE_FIXED_CST (arg1).data;"}, {"sha": "051f78715c220992e071aff67471281fe7bbb7f2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -568,7 +568,7 @@ expand_arith_set_overflow (tree lhs, rtx target)\n \n static void\n expand_arith_overflow_result_store (tree lhs, rtx target,\n-\t\t\t\t    machine_mode mode, rtx res)\n+\t\t\t\t    scalar_int_mode mode, rtx res)\n {\n   scalar_int_mode tgtmode\n     = as_a <scalar_int_mode> (GET_MODE_INNER (GET_MODE (target)));\n@@ -1460,8 +1460,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       struct separate_ops ops;\n       int prec = GET_MODE_PRECISION (mode);\n-      scalar_int_mode hmode;\n-      machine_mode wmode;\n+      scalar_int_mode hmode, wmode;\n       ops.op0 = make_tree (type, op0);\n       ops.op1 = make_tree (type, op1);\n       ops.op2 = NULL_TREE;"}, {"sha": "5769d9deccb364acb99bd9b4e78a68eb1703ab9c", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -418,7 +418,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n   int nonneg = 0;\n   bool increment_count;\n   basic_block loop_end = desc->out_edge->src;\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   widest_int iterations;\n \n   jump_insn = BB_END (loop_end);\n@@ -609,7 +609,7 @@ record_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n static bool\n doloop_optimize (struct loop *loop)\n {\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   rtx doloop_reg;\n   rtx count;\n   widest_int iterations, iterations_max;"}, {"sha": "86b5926af2158457200647e39e2e84aedf132316", "filename": "gcc/optabs.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -435,7 +435,7 @@ expand_superword_shift (optab binoptab, rtx outof_input, rtx superword_op1,\n    value are the same as for the parent routine.  */\n \n static bool\n-expand_subword_shift (machine_mode op1_mode, optab binoptab,\n+expand_subword_shift (scalar_int_mode op1_mode, optab binoptab,\n \t\t      rtx outof_input, rtx into_input, rtx op1,\n \t\t      rtx outof_target, rtx into_target,\n \t\t      int unsignedp, enum optab_methods methods,\n@@ -518,7 +518,7 @@ expand_subword_shift (machine_mode op1_mode, optab binoptab,\n    arguments are the same as the parent routine.  */\n \n static bool\n-expand_doubleword_shift_condmove (machine_mode op1_mode, optab binoptab,\n+expand_doubleword_shift_condmove (scalar_int_mode op1_mode, optab binoptab,\n \t\t\t\t  enum rtx_code cmp_code, rtx cmp1, rtx cmp2,\n \t\t\t\t  rtx outof_input, rtx into_input,\n \t\t\t\t  rtx subword_op1, rtx superword_op1,\n@@ -601,7 +601,7 @@ expand_doubleword_shift_condmove (machine_mode op1_mode, optab binoptab,\n    Return true if the shift could be successfully synthesized.  */\n \n static bool\n-expand_doubleword_shift (machine_mode op1_mode, optab binoptab,\n+expand_doubleword_shift (scalar_int_mode op1_mode, optab binoptab,\n \t\t\t rtx outof_input, rtx into_input, rtx op1,\n \t\t\t rtx outof_target, rtx into_target,\n \t\t\t int unsignedp, enum optab_methods methods,\n@@ -2167,7 +2167,7 @@ widen_leading (scalar_int_mode mode, rtx op0, rtx target, optab unoptab)\n /* Try calculating clz of a double-word quantity as two clz's of word-sized\n    quantities, choosing which based on whether the high word is nonzero.  */\n static rtx\n-expand_doubleword_clz (machine_mode mode, rtx op0, rtx target)\n+expand_doubleword_clz (scalar_int_mode mode, rtx op0, rtx target)\n {\n   rtx xop0 = force_reg (mode, op0);\n   rtx subhi = gen_highpart (word_mode, xop0);\n@@ -2238,7 +2238,7 @@ expand_doubleword_clz (machine_mode mode, rtx op0, rtx target)\n /* Try calculating popcount of a double-word quantity as two popcount's of\n    word-sized quantities and summing up the results.  */\n static rtx\n-expand_doubleword_popcount (machine_mode mode, rtx op0, rtx target)\n+expand_doubleword_popcount (scalar_int_mode mode, rtx op0, rtx target)\n {\n   rtx t0, t1, t;\n   rtx_insn *seq;\n@@ -2278,7 +2278,7 @@ expand_doubleword_popcount (machine_mode mode, rtx op0, rtx target)\n    as\n \t(parity:narrow (low (x) ^ high (x))) */\n static rtx\n-expand_doubleword_parity (machine_mode mode, rtx op0, rtx target)\n+expand_doubleword_parity (scalar_int_mode mode, rtx op0, rtx target)\n {\n   rtx t = expand_binop (word_mode, xor_optab,\n \t\t\toperand_subword_force (op0, 0, mode),\n@@ -2555,7 +2555,7 @@ expand_absneg_bit (enum rtx_code code, scalar_float_mode mode,\n {\n   const struct real_format *fmt;\n   int bitpos, word, nwords, i;\n-  machine_mode imode;\n+  scalar_int_mode imode;\n   rtx temp;\n   rtx_insn *insns;\n \n@@ -4067,13 +4067,13 @@ prepare_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison,\n   enum rtx_code swapped = swap_condition (comparison);\n   enum rtx_code reversed = reverse_condition_maybe_unordered (comparison);\n   machine_mode orig_mode = GET_MODE (x);\n-  machine_mode mode, cmp_mode;\n+  machine_mode mode;\n   rtx true_rtx, false_rtx;\n   rtx value, target, equiv;\n   rtx_insn *insns;\n   rtx libfunc = 0;\n   bool reversed_p = false;\n-  cmp_mode = targetm.libgcc_cmp_return_mode ();\n+  scalar_int_mode cmp_mode = targetm.libgcc_cmp_return_mode ();\n \n   FOR_EACH_MODE_FROM (mode, orig_mode)\n     {"}, {"sha": "7363bd653523c84076c6fbec57fe237ee5e62da3", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2865,9 +2865,9 @@ subreg_highpart_offset (machine_mode outermode, machine_mode innermode)\n \n extern int byte_lowpart_offset (machine_mode, machine_mode);\n extern rtx make_safe_from (rtx, rtx);\n-extern rtx convert_memory_address_addr_space_1 (machine_mode, rtx,\n+extern rtx convert_memory_address_addr_space_1 (scalar_int_mode, rtx,\n \t\t\t\t\t\taddr_space_t, bool, bool);\n-extern rtx convert_memory_address_addr_space (machine_mode, rtx,\n+extern rtx convert_memory_address_addr_space (scalar_int_mode, rtx,\n \t\t\t\t\t      addr_space_t);\n #define convert_memory_address(to_mode,x) \\\n \tconvert_memory_address_addr_space ((to_mode), (x), ADDR_SPACE_GENERIC)\n@@ -3066,7 +3066,7 @@ inline rtx single_set (const rtx_insn *insn)\n   return single_set_2 (insn, PATTERN (insn));\n }\n \n-extern machine_mode get_address_mode (rtx mem);\n+extern scalar_int_mode get_address_mode (rtx mem);\n extern int rtx_addr_can_trap_p (const_rtx);\n extern bool nonzero_address_p (const_rtx);\n extern int rtx_unstable_p (const_rtx);\n@@ -3800,8 +3800,8 @@ extern GTY(()) rtx stack_limit_rtx;\n extern unsigned int variable_tracking_main (void);\n \n /* In stor-layout.c.  */\n-extern void get_mode_bounds (machine_mode, int, machine_mode,\n-\t\t\t     rtx *, rtx *);\n+extern void get_mode_bounds (scalar_int_mode, int,\n+\t\t\t     scalar_int_mode, rtx *, rtx *);\n \n /* In loop-iv.c  */\n extern rtx canon_condition (rtx);"}, {"sha": "1765dbeb9043840ebe7935ef2ceb960dc6766ce8", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -5793,7 +5793,7 @@ low_bitmask_len (machine_mode mode, unsigned HOST_WIDE_INT m)\n \n /* Return the mode of MEM's address.  */\n \n-machine_mode\n+scalar_int_mode\n get_address_mode (rtx mem)\n {\n   machine_mode mode;"}, {"sha": "012602d22985e23f2629221783bbba9c0a2e45d4", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2917,8 +2917,8 @@ get_best_mode (int bitsize, int bitpos,\n    SIGN).  The returned constants are made to be usable in TARGET_MODE.  */\n \n void\n-get_mode_bounds (machine_mode mode, int sign,\n-\t\t machine_mode target_mode,\n+get_mode_bounds (scalar_int_mode mode, int sign,\n+\t\t scalar_int_mode target_mode,\n \t\t rtx *mmin, rtx *mmax)\n {\n   unsigned size = GET_MODE_PRECISION (mode);"}, {"sha": "b4f6cb4d617453a586522b12683d28279846a737", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -2009,7 +2009,7 @@ char *, (void), hook_charptr_void_null)\n DEFHOOK_UNDOC\n (eh_return_filter_mode,\n  \"Return machine mode for filter value.\",\n- machine_mode, (void),\n+ scalar_int_mode, (void),\n  default_eh_return_filter_mode)\n \n /* Return machine mode for libgcc expanded cmp instructions.  */\n@@ -2019,7 +2019,7 @@ DEFHOOK\n of compare instructions expanded to libgcc calls.  If not defined\\n\\\n @code{word_mode} is returned which is the right choice for a majority of\\n\\\n targets.\",\n- machine_mode, (void),\n+ scalar_int_mode, (void),\n  default_libgcc_cmp_return_mode)\n \n /* Return machine mode for libgcc expanded shift instructions.  */\n@@ -2029,15 +2029,15 @@ DEFHOOK\n of shift instructions expanded to libgcc calls.  If not defined\\n\\\n @code{word_mode} is returned which is the right choice for a majority of\\n\\\n targets.\",\n- machine_mode, (void),\n+ scalar_int_mode, (void),\n  default_libgcc_shift_count_mode)\n \n /* Return machine mode to be used for _Unwind_Word type.  */\n DEFHOOK\n (unwind_word_mode,\n  \"Return machine mode to be used for @code{_Unwind_Word} type.\\n\\\n The default is to use @code{word_mode}.\",\n- machine_mode, (void),\n+ scalar_int_mode, (void),\n  default_unwind_word_mode)\n \n /* Given two decls, merge their attributes and return the result.  */\n@@ -3156,7 +3156,7 @@ extension.\\n\\\n In order to enforce the representation of @code{mode},\\n\\\n @code{TRULY_NOOP_TRUNCATION} should return false when truncating to\\n\\\n @code{mode}.\",\n- int, (machine_mode mode, machine_mode rep_mode),\n+ int, (scalar_int_mode mode, scalar_int_mode rep_mode),\n  default_mode_rep_extended)\n \n /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n@@ -3165,7 +3165,7 @@ DEFHOOK\n  \"Define this to return nonzero if the port can handle pointers\\n\\\n with machine mode @var{mode}.  The default version of this\\n\\\n hook returns true for both @code{ptr_mode} and @code{Pmode}.\",\n- bool, (machine_mode mode),\n+ bool, (scalar_int_mode mode),\n  default_valid_pointer_mode)\n \n /* Disambiguate with errno.  */\n@@ -3190,7 +3190,7 @@ DEFHOOK\n  \"Define this to return the machine mode to use for pointers to\\n\\\n @var{address_space} if the target supports named address spaces.\\n\\\n The default version of this hook returns @code{ptr_mode}.\",\n- machine_mode, (addr_space_t address_space),\n+ scalar_int_mode, (addr_space_t address_space),\n  default_addr_space_pointer_mode)\n \n /* MODE to use for an address in another address space.  */\n@@ -3199,7 +3199,7 @@ DEFHOOK\n  \"Define this to return the machine mode to use for addresses in\\n\\\n @var{address_space} if the target supports named address spaces.\\n\\\n The default version of this hook returns @code{Pmode}.\",\n- machine_mode, (addr_space_t address_space),\n+ scalar_int_mode, (addr_space_t address_space),\n  default_addr_space_address_mode)\n \n /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\")))\n@@ -3213,7 +3213,7 @@ except that it includes explicit named address space support.  The default\\n\\\n version of this hook returns true for the modes returned by either the\\n\\\n @code{TARGET_ADDR_SPACE_POINTER_MODE} or @code{TARGET_ADDR_SPACE_ADDRESS_MODE}\\n\\\n target hooks for the given address space.\",\n- bool, (machine_mode mode, addr_space_t as),\n+ bool, (scalar_int_mode mode, addr_space_t as),\n  default_addr_space_valid_pointer_mode)\n \n /* True if an address is a valid memory address to a given named address"}, {"sha": "48a339f1db3aecc2c9df16c9ca2e1c7124c3c4d2", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -216,25 +216,25 @@ default_pretend_outgoing_varargs_named (cumulative_args_t ca ATTRIBUTE_UNUSED)\n \t  != default_setup_incoming_varargs);\n }\n \n-machine_mode\n+scalar_int_mode\n default_eh_return_filter_mode (void)\n {\n   return targetm.unwind_word_mode ();\n }\n \n-machine_mode\n+scalar_int_mode\n default_libgcc_cmp_return_mode (void)\n {\n   return word_mode;\n }\n \n-machine_mode\n+scalar_int_mode\n default_libgcc_shift_count_mode (void)\n {\n   return word_mode;\n }\n \n-machine_mode\n+scalar_int_mode\n default_unwind_word_mode (void)\n {\n   return word_mode;\n@@ -259,8 +259,7 @@ default_min_divisions_for_recip_mul (machine_mode mode ATTRIBUTE_UNUSED)\n /* The default implementation of TARGET_MODE_REP_EXTENDED.  */\n \n int\n-default_mode_rep_extended (machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode_rep ATTRIBUTE_UNUSED)\n+default_mode_rep_extended (scalar_int_mode, scalar_int_mode)\n {\n   return UNKNOWN;\n }\n@@ -1256,7 +1255,7 @@ default_destroy_cost_data (void *data)\n /* Determine whether or not a pointer mode is valid. Assume defaults\n    of ptr_mode or Pmode - can be overridden.  */\n bool\n-default_valid_pointer_mode (machine_mode mode)\n+default_valid_pointer_mode (scalar_int_mode mode)\n {\n   return (mode == ptr_mode || mode == Pmode);\n }\n@@ -1291,7 +1290,7 @@ default_ref_may_alias_errno (ao_ref *ref)\n /* Return the mode for a pointer to a given ADDRSPACE,\n    defaulting to ptr_mode for all address spaces.  */\n \n-machine_mode\n+scalar_int_mode\n default_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return ptr_mode;\n@@ -1300,7 +1299,7 @@ default_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n /* Return the mode for an address in a given ADDRSPACE,\n    defaulting to Pmode for all address spaces.  */\n \n-machine_mode\n+scalar_int_mode\n default_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n {\n   return Pmode;\n@@ -1310,7 +1309,7 @@ default_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)\n    To match the above, the same modes apply to all address spaces.  */\n \n bool\n-default_addr_space_valid_pointer_mode (machine_mode mode,\n+default_addr_space_valid_pointer_mode (scalar_int_mode mode,\n \t\t\t\t       addr_space_t as ATTRIBUTE_UNUSED)\n {\n   return targetm.valid_pointer_mode (mode);"}, {"sha": "a1f55e52e9a168547d38e657dae0d4dc6ef01ab4", "filename": "gcc/targhooks.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -43,14 +43,14 @@ extern void default_setup_incoming_varargs (cumulative_args_t, machine_mode, tre\n extern rtx default_builtin_setjmp_frame_value (void);\n extern bool default_pretend_outgoing_varargs_named (cumulative_args_t);\n \n-extern machine_mode default_eh_return_filter_mode (void);\n-extern machine_mode default_libgcc_cmp_return_mode (void);\n-extern machine_mode default_libgcc_shift_count_mode (void);\n-extern machine_mode default_unwind_word_mode (void);\n+extern scalar_int_mode default_eh_return_filter_mode (void);\n+extern scalar_int_mode default_libgcc_cmp_return_mode (void);\n+extern scalar_int_mode default_libgcc_shift_count_mode (void);\n+extern scalar_int_mode default_unwind_word_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (machine_mode);\n extern unsigned int default_min_divisions_for_recip_mul (machine_mode);\n-extern int default_mode_rep_extended (machine_mode, machine_mode);\n+extern int default_mode_rep_extended (scalar_int_mode, scalar_int_mode);\n \n extern tree default_stack_protect_guard (void);\n extern tree default_external_stack_protect_fail (void);\n@@ -169,11 +169,11 @@ extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n-extern bool default_valid_pointer_mode (machine_mode);\n+extern bool default_valid_pointer_mode (scalar_int_mode);\n extern bool default_ref_may_alias_errno (struct ao_ref *);\n-extern machine_mode default_addr_space_pointer_mode (addr_space_t);\n-extern machine_mode default_addr_space_address_mode (addr_space_t);\n-extern bool default_addr_space_valid_pointer_mode (machine_mode,\n+extern scalar_int_mode default_addr_space_pointer_mode (addr_space_t);\n+extern scalar_int_mode default_addr_space_address_mode (addr_space_t);\n+extern bool default_addr_space_valid_pointer_mode (scalar_int_mode,\n \t\t\t\t\t\t   addr_space_t);\n extern bool default_addr_space_legitimate_address_p (machine_mode, rtx,\n \t\t\t\t\t\t     bool, addr_space_t);"}, {"sha": "5e354a17ce97c7a8edf30aea77a83a0845bf8409", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -191,8 +191,8 @@ rtx\n addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n \t\t  bool really_expand)\n {\n-  machine_mode address_mode = targetm.addr_space.address_mode (as);\n-  machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n+  scalar_int_mode address_mode = targetm.addr_space.address_mode (as);\n+  scalar_int_mode pointer_mode = targetm.addr_space.pointer_mode (as);\n   rtx address, sym, bse, idx, st, off;\n   struct mem_addr_template *templ;\n "}, {"sha": "bbea619171a52dfedae6ffb642a0d6fe5c062d5c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -3960,7 +3960,7 @@ adjust_setup_cost (struct ivopts_data *data, unsigned cost,\n    the cost in COST.  */\n \n static bool\n-get_shiftadd_cost (tree expr, machine_mode mode, comp_cost cost0,\n+get_shiftadd_cost (tree expr, scalar_int_mode mode, comp_cost cost0,\n \t\t   comp_cost cost1, tree mult, bool speed, comp_cost *cost)\n {\n   comp_cost res;"}, {"sha": "d0d0897280437a2aa46092fc75dd272fa38fcd22", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -1051,7 +1051,7 @@ array_value_type (gswitch *swtch, tree type, int num,\n     return type;\n \n   scalar_int_mode type_mode = SCALAR_INT_TYPE_MODE (type);\n-  machine_mode mode = get_narrowest_mode (type_mode);\n+  scalar_int_mode mode = get_narrowest_mode (type_mode);\n   if (GET_MODE_SIZE (type_mode) <= GET_MODE_SIZE (mode))\n     return type;\n "}, {"sha": "84cdd178bfaf5d841bcb1218154f6d08f4f25e3b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -10095,7 +10095,7 @@ simplify_float_conversion_using_ranges (gimple_stmt_iterator *gsi,\n   value_range *vr = get_value_range (rhs1);\n   scalar_float_mode fltmode\n     = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (gimple_assign_lhs (stmt)));\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   tree tem;\n   gassign *conv;\n "}, {"sha": "06673ccb4f94e7506ba61b7aa69eba6c53cd561d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095a2d76a26fa4ee17fa56bff21bf4f269db2368/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=095a2d76a26fa4ee17fa56bff21bf4f269db2368", "patch": "@@ -970,7 +970,7 @@ use_narrower_mode_test (rtx x, const_rtx subreg)\n /* Transform X into narrower mode MODE from wider mode WMODE.  */\n \n static rtx\n-use_narrower_mode (rtx x, machine_mode mode, machine_mode wmode)\n+use_narrower_mode (rtx x, scalar_int_mode mode, scalar_int_mode wmode)\n {\n   rtx op0, op1;\n   if (CONSTANT_P (x))"}]}