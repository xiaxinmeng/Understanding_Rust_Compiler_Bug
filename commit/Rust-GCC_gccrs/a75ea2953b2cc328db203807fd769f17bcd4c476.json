{"sha": "a75ea2953b2cc328db203807fd769f17bcd4c476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1ZWEyOTUzYjJjYzMyOGRiMjAzODA3ZmQ3NjlmMTdiY2Q0YzQ3Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-02-06T10:47:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-02-06T10:47:24Z"}, "message": "snames.ads-tmpl (Name_Loop_Optimize, [...]): New pragma-related names.\n\n2013-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* snames.ads-tmpl (Name_Loop_Optimize, Name_No_Unroll,\n\tName_Unroll, Name_No_Vector, Name_Vector): New pragma-related\n\tnames.\n\t(Pragma_Id): Add Pragma_Loop_Optimize value.\n\t* par-prag.adb (Prag): Handle Pragma_Loop_Optimize.\n\t* sem_prag.adb (Check_Loop_Invariant_Variant_Placement): Rename to...\n\t(Check_Loop_Pragma_Placement): ...this.\n\t(Analyze_Pragma)\n\t<Pragma_Loop_Invariant>: Adjust to above renaming.\n\t<Loop_Variant>: Likewise.\n\t <Pragma_Loop_Optimize>: Implement new pragma Loop_Optimize.\n\t(Sig_Flags): Add Pragma_Loop_Optimize.\n\t* gnat_rm.texi (Implementation Defined Pragmas): Add Loop_Optimize.\n\t* gnat_ugn.texi (Vectorization of loops): Mention Loop_Optimize.\n\nFrom-SVN: r195799", "tree": {"sha": "faab0c1f5011b395ce016d1d0669a8ce65902b00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faab0c1f5011b395ce016d1d0669a8ce65902b00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a75ea2953b2cc328db203807fd769f17bcd4c476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75ea2953b2cc328db203807fd769f17bcd4c476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a75ea2953b2cc328db203807fd769f17bcd4c476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75ea2953b2cc328db203807fd769f17bcd4c476/comments", "author": null, "committer": null, "parents": [{"sha": "9b7424a705ede81bcf45b214744872e54ffb9297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7424a705ede81bcf45b214744872e54ffb9297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7424a705ede81bcf45b214744872e54ffb9297"}], "stats": {"total": 158, "additions": 147, "deletions": 11}, "files": [{"sha": "af5365384e9dec0273460e21b23e87f13b0ebbf1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -1,3 +1,20 @@\n+2013-02-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* snames.ads-tmpl (Name_Loop_Optimize, Name_No_Unroll,\n+\tName_Unroll, Name_No_Vector, Name_Vector): New pragma-related\n+\tnames.\n+\t(Pragma_Id): Add Pragma_Loop_Optimize value.\n+\t* par-prag.adb (Prag): Handle Pragma_Loop_Optimize.\n+\t* sem_prag.adb (Check_Loop_Invariant_Variant_Placement): Rename to...\n+\t(Check_Loop_Pragma_Placement): ...this.\n+\t(Analyze_Pragma)\n+\t<Pragma_Loop_Invariant>: Adjust to above renaming.\n+\t<Loop_Variant>: Likewise.\n+\t <Pragma_Loop_Optimize>: Implement new pragma Loop_Optimize.\n+\t(Sig_Flags): Add Pragma_Loop_Optimize.\n+\t* gnat_rm.texi (Implementation Defined Pragmas): Add Loop_Optimize.\n+\t* gnat_ugn.texi (Vectorization of loops): Mention Loop_Optimize.\n+\n 2013-02-06  Robert Dewar  <dewar@adacore.com>\n \n \t* osint.ads: Minor fix of typo."}, {"sha": "1c250d068a5b04ecaa81931e3b038c91349c470d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -176,6 +176,7 @@ Implementation Defined Pragmas\n * Pragma Linker_Destructor::\n * Pragma Linker_Section::\n * Pragma Long_Float::\n+* Pragma Loop_Optimize::\n * Pragma Machine_Attribute::\n * Pragma Main::\n * Pragma Main_Storage::\n@@ -925,6 +926,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Linker_Destructor::\n * Pragma Linker_Section::\n * Pragma Long_Float::\n+* Pragma Loop_Optimize::\n * Pragma Machine_Attribute::\n * Pragma Main::\n * Pragma Main_Storage::\n@@ -2927,6 +2929,7 @@ the target's overriding subprogram kind.\n @node Pragma Implicit_Packing\n @unnumberedsec Pragma Implicit_Packing\n @findex Implicit_Packing\n+@cindex Rational Profile\n @noindent\n Syntax:\n \n@@ -3845,6 +3848,55 @@ For further details on this pragma, see the\n @cite{DEC Ada Language Reference Manual}, section 3.5.7b.  Note that to use\n this pragma, the standard runtime libraries must be recompiled.\n \n+@node Pragma Loop_Optimize\n+@unnumberedsec Pragma Loop_Optimize\n+@findex Loop_Optimize\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Loop_Optimize (OPTIMIZATION_HINT @{, OPTIMIZATION_HINT@});\n+\n+OPTIMIZATION_HINT ::= No_Unroll | Unroll | No_Vector | Vector\n+@end smallexample\n+\n+@noindent\n+This pragma must appear immediately within a loop statement.  It allows the\n+programmer to specify optimization hints for the enclosing loop.  The hints\n+are not mutually exclusive and can be freely mixed, but not all combinations\n+will yield a sensible outcome.\n+\n+There are four supported optimization hints for a loop:\n+@itemize @bullet\n+@item No_Unroll\n+\n+The loop must not be unrolled.  This is a strong hint: the compiler will not\n+unroll a loop marked with this hint.\n+\n+@item Unroll\n+\n+The loop should be unrolled.  This is a weak hint: the compiler will try to\n+apply unrolling to this loop preferably to other optimizations, notably\n+vectorization, but there is no guarantee that the loop will be unrolled.\n+\n+@item No_Vector\n+\n+The loop must not be vectorized.  This is a strong hint: the compiler will not\n+vectorize a loop marked with this hint.\n+\n+@item Vector\n+\n+The loop should be vectorized.  This is a weak hint: the compiler will try to\n+apply vectorization to this loop preferably to other optimizations, notably\n+unrolling, but there is no guarantee that the loop will be vectorized.\n+\n+@end itemize\n+\n+These hints do not void the need to pass the appropriate switches to the\n+compiler in order to enable the relevant optimizations, that is to say\n+@option{-funroll-loops} for unrolling and @option{-ftree-vectorize} for\n+vectorization.\n+\n @node Pragma Machine_Attribute\n @unnumberedsec Pragma Machine_Attribute\n @findex Machine_Attribute\n@@ -4865,6 +4917,29 @@ This set of restrictions causes the automatic selection of a simplified\n version of the run time that provides improved performance for the\n limited set of tasking functionality permitted by this set of restrictions.\n \n+@node Pragma Profile (Rational)\n+@unnumberedsec Pragma Profile (Rational)\n+@findex Rational compatibility mode\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Profile (Rational);\n+@end smallexample\n+\n+@noindent\n+The Rational profile is intended to facilitate porting legacy code that\n+compiles with the Rational APEX compiler, even when the code includes non-\n+conforming Ada constructs.  The profile enables the following three pragmas:\n+\n+\n+@itemize @bullet\n+pragma Implicit_Packing;\n+pragma Overriding_Renamings;\n+pragma Use_VADS_Size;\n+@end itemize\n+\n+@noindent\n @node Pragma Psect_Object\n @unnumberedsec Pragma Psect_Object\n @findex Psect_Object\n@@ -6021,6 +6096,7 @@ of Ada as an implementation-defined pragma.\n @node Pragma Use_VADS_Size\n @unnumberedsec Pragma Use_VADS_Size\n @cindex @code{Size}, VADS compatibility\n+@cindex Rational profile\n @findex Use_VADS_Size\n @noindent\n Syntax:"}, {"sha": "bf00fc7c6226505b2d15355da4d45a7c5b8bcab5", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -10978,6 +10978,17 @@ types.  This is so because, the less information the compiler has about the\n bounds of the array, the more fallback code it needs to generate in order to\n fix things up at run time.\n \n+It is possible to specify that a given loop should be subject to vectorization\n+preferably to other optimizations by means of pragma @code{Loop_Optimize}:\n+\n+@smallexample @c ada\n+  pragma Loop_Optimize (Vector);\n+@end smallexample\n+\n+@noindent\n+placed immediately within the loop will convey the appropriate hint to the\n+compiler for this loop.\n+\n You can obtain information about the vectorization performed by the compiler\n by specifying @option{-ftree-vectorizer-verbose=N}.  For more details of\n this switch, see @ref{Debugging Options,,Options for Debugging Your Program"}, {"sha": "60bc6c1f55e2061eff49e3b4de0a5a3f6b1c6ca9", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -1203,6 +1203,7 @@ begin\n            Pragma_Locking_Policy                 |\n            Pragma_Long_Float                     |\n            Pragma_Loop_Invariant                 |\n+           Pragma_Loop_Optimize                  |\n            Pragma_Loop_Variant                   |\n            Pragma_Machine_Attribute              |\n            Pragma_Main                           |"}, {"sha": "2a67b8503511722b7439253dc1e9943db261b516", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -618,9 +618,9 @@ package body Sem_Prag is\n       --  Common processing for first argument of pragma Interrupt_Handler or\n       --  pragma Attach_Handler.\n \n-      procedure Check_Loop_Invariant_Variant_Placement;\n-      --  Verify whether pragma Loop_Invariant or pragma Loop_Variant appear\n-      --  immediately within a construct restricted to loops.\n+      procedure Check_Loop_Pragma_Placement;\n+      --  Verify whether pragma Loop_Invariant or Loop_Optimize or Loop_Variant\n+      --  appear immediately within a construct restricted to loops.\n \n       procedure Check_Is_In_Decl_Part_Or_Package_Spec;\n       --  Check that pragma appears in a declarative part, or in a package\n@@ -1922,11 +1922,11 @@ package body Sem_Prag is\n          end if;\n       end Check_Interrupt_Or_Attach_Handler;\n \n-      --------------------------------------------\n-      -- Check_Loop_Invariant_Variant_Placement --\n-      --------------------------------------------\n+      ---------------------------------\n+      -- Check_Loop_Pragma_Placement --\n+      ---------------------------------\n \n-      procedure Check_Loop_Invariant_Variant_Placement is\n+      procedure Check_Loop_Pragma_Placement is\n          procedure Placement_Error (Constr : Node_Id);\n          pragma No_Return (Placement_Error);\n          --  Node Constr denotes the last loop restricted construct before we\n@@ -1955,7 +1955,7 @@ package body Sem_Prag is\n          Prev : Node_Id;\n          Stmt : Node_Id;\n \n-      --  Start of processing for Check_Loop_Invariant_Variant_Placement\n+      --  Start of processing for Check_Loop_Pragma_Placement\n \n       begin\n          Prev := N;\n@@ -2011,7 +2011,7 @@ package body Sem_Prag is\n                return;\n             end if;\n          end loop;\n-      end Check_Loop_Invariant_Variant_Placement;\n+      end Check_Loop_Pragma_Placement;\n \n       -------------------------------------------\n       -- Check_Is_In_Decl_Part_Or_Package_Spec --\n@@ -12341,7 +12341,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n-            Check_Loop_Invariant_Variant_Placement;\n+            Check_Loop_Pragma_Placement;\n \n             --  Completely ignore if disabled\n \n@@ -12370,6 +12370,30 @@ package body Sem_Prag is\n             Analyze (N);\n          end Loop_Invariant;\n \n+         -------------------\n+         -- Loop_Optimize --\n+         -------------------\n+\n+         --  pragma Loop_Optimize ( OPTIMIZATION_HINT {, OPTIMIZATION_HINT } );\n+\n+         --  OPTIMIZATION_HINT ::= No_Unroll | Unroll | No_Vector | Vector\n+\n+         when Pragma_Loop_Optimize => Loop_Optimize : declare\n+            Hint      : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_No_Identifiers;\n+            Hint := First (Pragma_Argument_Associations (N));\n+            while Present (Hint) loop\n+               Check_Arg_Is_One_Of (Hint, Name_No_Unroll, Name_Unroll,\n+                                    Name_No_Vector, Name_Vector);\n+               Next (Hint);\n+            end loop;\n+            Check_Loop_Pragma_Placement;\n+         end Loop_Optimize;\n+\n          ------------------\n          -- Loop_Variant --\n          ------------------\n@@ -12388,7 +12412,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_At_Least_N_Arguments (1);\n-            Check_Loop_Invariant_Variant_Placement;\n+            Check_Loop_Pragma_Placement;\n \n             --  Completely ignore if disabled\n \n@@ -16598,6 +16622,7 @@ package body Sem_Prag is\n       Pragma_Locking_Policy                 => -1,\n       Pragma_Long_Float                     => -1,\n       Pragma_Loop_Invariant                 => -1,\n+      Pragma_Loop_Optimize                  => -1,\n       Pragma_Loop_Variant                   => -1,\n       Pragma_Machine_Attribute              => -1,\n       Pragma_Main                           => -1,"}, {"sha": "91c9aee32f98dae096be2e90c913b93b102d0b4d", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a75ea2953b2cc328db203807fd769f17bcd4c476/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a75ea2953b2cc328db203807fd769f17bcd4c476", "patch": "@@ -408,6 +408,7 @@ package Snames is\n    Name_Locking_Policy                 : constant Name_Id := N + $;\n    Name_Long_Float                     : constant Name_Id := N + $; -- VMS\n    Name_Loop_Invariant                 : constant Name_Id := N + $; -- GNAT\n+   Name_Loop_Optimize                  : constant Name_Id := N + $; -- GNAT\n    Name_Loop_Variant                   : constant Name_Id := N + $; -- GNAT\n    Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT\n    Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT\n@@ -727,6 +728,8 @@ package Snames is\n    Name_No_Specification_Of_Aspect     : constant Name_Id := N + $;\n    Name_No_Task_Attributes             : constant Name_Id := N + $;\n    Name_No_Task_Attributes_Package     : constant Name_Id := N + $;\n+   Name_No_Unroll                      : constant Name_Id := N + $;\n+   Name_No_Vector                      : constant Name_Id := N + $;\n    Name_Nominal                        : constant Name_Id := N + $;\n    Name_On                             : constant Name_Id := N + $;\n    Name_Optional                       : constant Name_Id := N + $;\n@@ -762,10 +765,12 @@ package Snames is\n    Name_Unit_Name                      : constant Name_Id := N + $;\n    Name_Unknown                        : constant Name_Id := N + $;\n    Name_Unrestricted                   : constant Name_Id := N + $;\n+   Name_Unroll                         : constant Name_Id := N + $;\n    Name_Uppercase                      : constant Name_Id := N + $;\n    Name_User                           : constant Name_Id := N + $;\n    Name_Variant                        : constant Name_Id := N + $;\n    Name_VAX_Float                      : constant Name_Id := N + $;\n+   Name_Vector                         : constant Name_Id := N + $;\n    Name_VMS                            : constant Name_Id := N + $;\n    Name_Vtable_Ptr                     : constant Name_Id := N + $;\n    Name_Working_Storage                : constant Name_Id := N + $;\n@@ -1705,6 +1710,7 @@ package Snames is\n       Pragma_Locking_Policy,\n       Pragma_Long_Float,\n       Pragma_Loop_Invariant,\n+      Pragma_Loop_Optimize,\n       Pragma_Loop_Variant,\n       Pragma_No_Run_Time,\n       Pragma_No_Strict_Aliasing,"}]}