{"sha": "de953b38a3adb0580dd8caf88991fc78226b1f4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU5NTNiMzhhM2FkYjA1ODBkZDhjYWY4ODk5MWZjNzgyMjZiMWY0ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:55:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-14T21:55:38Z"}, "message": "(min_precision): New function.\n\n(finish_enum): Rewrite code to determine precision required for enumeral type.\n\nFrom-SVN: r7471", "tree": {"sha": "3eda82c90eedb1671f261ada97220ea214cdc83b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eda82c90eedb1671f261ada97220ea214cdc83b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de953b38a3adb0580dd8caf88991fc78226b1f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de953b38a3adb0580dd8caf88991fc78226b1f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de953b38a3adb0580dd8caf88991fc78226b1f4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de953b38a3adb0580dd8caf88991fc78226b1f4e/comments", "author": null, "committer": null, "parents": [{"sha": "62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c0ea12e975a682cb5446eb4ca6f3b76b7be031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c0ea12e975a682cb5446eb4ca6f3b76b7be031"}], "stats": {"total": 70, "additions": 38, "deletions": 32}, "files": [{"sha": "44face4730b922a3a57a313550e3ff66bb8308f2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de953b38a3adb0580dd8caf88991fc78226b1f4e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de953b38a3adb0580dd8caf88991fc78226b1f4e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=de953b38a3adb0580dd8caf88991fc78226b1f4e", "patch": "@@ -5621,6 +5621,37 @@ start_enum (name)\n   return enumtype;\n }\n \n+/* Return the minimum number of bits needed to represent VALUE in a\n+   signed or unsigned type, UNSIGNEDP says which.  */\n+\n+static int\n+min_precision (value, unsignedp)\n+     tree value;\n+     int unsignedp;\n+{\n+  int log;\n+\n+  /* If the value is negative, compute its negative minus 1.  The latter\n+     adjustment is because the absolute value of the largest negative value\n+     is one larger than the largest positive value.  This is equivalent to\n+     a bit-wise negation, so use that operation instead.  */\n+\n+  if (tree_int_cst_sgn (value) < 0)\n+    value = fold (build1 (BIT_NOT_EXPR, TREE_TYPE (value), value));\n+\n+  /* Return the number of bits needed, taking into account the fact\n+     that we need one more bit for a signed than unsigned type.  */\n+\n+  if (integer_zerop (value))\n+    log = 0;\n+  else if (TREE_INT_CST_HIGH (value) != 0)\n+    log = HOST_BITS_PER_WIDE_INT + floor_log2 (TREE_INT_CST_HIGH (value));\n+  else\n+    log = floor_log2 (TREE_INT_CST_LOW (value));\n+\n+  return log + 1 + ! unsignedp;\n+}\n+\n /* After processing and defining all the values of an enumeration type,\n    install their decls in the enumeration type and finish it off.\n    ENUMTYPE is the type object and VALUES a list of decl-value pairs.\n@@ -5632,9 +5663,7 @@ finish_enum (enumtype, values)\n {\n   register tree pair, tem;\n   tree minnode = 0, maxnode = 0;\n-  register HOST_WIDE_INT maxvalue = 0;\n-  register HOST_WIDE_INT minvalue = 0;\n-  unsigned precision = 0;\n+  int lowprec, highprec, precision;\n   int toplevel = global_binding_level == current_binding_level;\n \n   if (in_parm_level_p ())\n@@ -5662,34 +5691,14 @@ finish_enum (enumtype, values)\n   TYPE_MIN_VALUE (enumtype) = minnode;\n   TYPE_MAX_VALUE (enumtype) = maxnode;\n \n-  /* Determine the precision this type needs.  */\n-\n-  if (TREE_INT_CST_HIGH (minnode) >= 0\n-      ? tree_int_cst_lt (TYPE_MAX_VALUE (unsigned_type_node), maxnode)\n-      : (tree_int_cst_lt (minnode, TYPE_MIN_VALUE (integer_type_node))\n-\t || tree_int_cst_lt (TYPE_MAX_VALUE (integer_type_node), maxnode)))\n-    precision = TYPE_PRECISION (long_long_integer_type_node);\n-  else\n-    {\n-      maxvalue = TREE_INT_CST_LOW (maxnode);\n-      minvalue = TREE_INT_CST_LOW (minnode);\n+  /* An enum can have some negative values; then it is signed.  */\n+  TREE_UNSIGNED (enumtype) = tree_int_cst_sgn (minnode) >= 0;\n \n-      if (maxvalue > 0)\n-\tprecision = floor_log2 (maxvalue) + 1;\n-      if (minvalue < 0)\n-\t{\n-\t  /* Compute number of bits to represent magnitude of a negative value.\n-\t     Add one to MINVALUE since range of negative numbers\n-\t     includes the power of two.  */\n-\t  unsigned negprecision = floor_log2 (-minvalue - 1) + 1;\n-\t  if (negprecision > precision)\n-\t    precision = negprecision;\n-\t  precision += 1;\t/* room for sign bit */\n-\t}\n+  /* Determine the precision this type needs.  */\n \n-      if (!precision)\n-\tprecision = 1;\n-    }\n+  lowprec = min_precision (minnode, TREE_UNSIGNED (enumtype));\n+  highprec = min_precision (maxnode, TREE_UNSIGNED (enumtype));\n+  precision = MAX (lowprec, highprec);\n \n   if (flag_short_enums || precision > TYPE_PRECISION (integer_type_node))\n     /* Use the width of the narrowest normal C type which is wide enough.  */\n@@ -5700,9 +5709,6 @@ finish_enum (enumtype, values)\n   TYPE_SIZE (enumtype) = 0;\n   layout_type (enumtype);\n \n-  /* An enum can have some negative values; then it is signed.  */\n-  TREE_UNSIGNED (enumtype) = tree_int_cst_sgn (minnode) >= 0;\n-\n   if (values != error_mark_node)\n     {\n       /* Change the type of the enumerators to be the enum type."}]}