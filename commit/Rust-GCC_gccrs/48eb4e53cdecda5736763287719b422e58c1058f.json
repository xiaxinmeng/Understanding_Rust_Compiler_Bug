{"sha": "48eb4e53cdecda5736763287719b422e58c1058f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhlYjRlNTNjZGVjZGE1NzM2NzYzMjg3NzE5YjQyMmU1OGMxMDU4Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-07-05T16:39:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-07-05T16:39:15Z"}, "message": "tree.h (DECL_SEEN_IN_BIND_EXPR_P): New macro.\n\n\t* tree.h (DECL_SEEN_IN_BIND_EXPR_P): New macro.\n\t* gimplify.c (gimple_add_tmp_var, gimplify_bind_expr): Use it.\n\t(gimplify_target_expr, gimplify_expr): Likewise.\n\t(copy_if_shared_r): No longer need special case for BIND_EXPR.\n\t(unshare_body, unvisit_body): Only look at nested if BODY_P is\n\twhole function.\n\t(gimplify_compound_lval): See if we can strip any useless conversion.\n\t(gimplify_modify_expr, gimplify_modify_expr_to_memcpy): Take size\n\tfrom RHS, not LHS.\n\t(gimplify_modify_expr_to_memset): Likewise.\n\t(gimplify_expr, case CONSTRUCTOR): Handle use as statement.\n\t* tree-inline.c (setup_one_parameter): Use DECL_SEEN_IN_BIND_EXPR_P.\n\t(declare_inline_vars): Likewise.\n\t(walk_type_fields): New function.\n\t(walk_tree): Use it.\n\t* tree-nested.c (create_tmp_var_for): Show seen in BIND_EXPR.\n\nFrom-SVN: r84121", "tree": {"sha": "42718a212a3b7e4859ae71b0215c10ef83e6404c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42718a212a3b7e4859ae71b0215c10ef83e6404c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48eb4e53cdecda5736763287719b422e58c1058f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48eb4e53cdecda5736763287719b422e58c1058f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48eb4e53cdecda5736763287719b422e58c1058f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48eb4e53cdecda5736763287719b422e58c1058f/comments", "author": null, "committer": null, "parents": [{"sha": "402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402a3dec96e3ca23e00e78279e6dde6c2df6ef52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/402a3dec96e3ca23e00e78279e6dde6c2df6ef52"}], "stats": {"total": 330, "additions": 193, "deletions": 137}, "files": [{"sha": "8d30f72266a60cbc514c7ade0e62ba63ad3805b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48eb4e53cdecda5736763287719b422e58c1058f", "patch": "@@ -5,6 +5,23 @@\n \n 2004-07-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree.h (DECL_SEEN_IN_BIND_EXPR_P): New macro.\n+\t* gimplify.c (gimple_add_tmp_var, gimplify_bind_expr): Use it.\n+\t(gimplify_target_expr, gimplify_expr): Likewise.\n+\t(copy_if_shared_r): No longer need special case for BIND_EXPR.\n+\t(unshare_body, unvisit_body): Only look at nested if BODY_P is\n+\twhole function.\n+\t(gimplify_compound_lval): See if we can strip any useless conversion.\n+\t(gimplify_modify_expr, gimplify_modify_expr_to_memcpy): Take size\n+\tfrom RHS, not LHS.\n+\t(gimplify_modify_expr_to_memset): Likewise.\n+\t(gimplify_expr, case CONSTRUCTOR): Handle use as statement.\n+\t* tree-inline.c (setup_one_parameter): Use DECL_SEEN_IN_BIND_EXPR_P.\n+\t(declare_inline_vars): Likewise.\n+\t(walk_type_fields): New function.\n+\t(walk_tree): Use it.\n+\t* tree-nested.c (create_tmp_var_for): Show seen in BIND_EXPR.\n+\t\n \t* tree-sra.c (struct sra_walk_fns): Init function now returns bool.\n \t(sra_walk_modify_expr): Allow init function to fail.\n \t(scan_init): Now returns bool."}, {"sha": "20196fecfedfb347538058f646af1edb5c3cdee7", "filename": "gcc/gimplify.c", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=48eb4e53cdecda5736763287719b422e58c1058f", "patch": "@@ -509,20 +509,17 @@ declare_tmp_vars (tree vars, tree scope)\n       temps = nreverse (last);\n       TREE_CHAIN (last) = BIND_EXPR_VARS (scope);\n       BIND_EXPR_VARS (scope) = temps;\n-\n-      /* We don't add the temps to the block for this BIND_EXPR, as we're\n-\t not interested in debugging info for them.  */\n     }\n }\n \n void\n gimple_add_tmp_var (tree tmp)\n {\n-  if (TREE_CHAIN (tmp) || tmp->decl.seen_in_bind_expr)\n+  if (TREE_CHAIN (tmp) || DECL_SEEN_IN_BIND_EXPR_P (tmp))\n     abort ();\n \n   DECL_CONTEXT (tmp) = current_function_decl;\n-  tmp->decl.seen_in_bind_expr = 1;\n+  DECL_SEEN_IN_BIND_EXPR_P (tmp) = 1;\n \n   if (gimplify_ctxp)\n     {\n@@ -657,19 +654,6 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \tTREE_VISITED (t) = 1;\n     }\n \n-  /* Special-case BIND_EXPR.  We should never be copying these, therefore\n-     we can omit examining BIND_EXPR_VARS.  Which also avoids problems with\n-     double processing of the DECL_INITIAL, which could be seen via both\n-     the BIND_EXPR_VARS and a DECL_EXPR.  */\n-  else if (code == BIND_EXPR)\n-    {\n-      if (TREE_VISITED (t))\n-\tabort ();\n-      TREE_VISITED (t) = 1;\n-      *walk_subtrees = 0;\n-      walk_tree (&BIND_EXPR_BODY (t), copy_if_shared_r, NULL, NULL);\n-    }\n-\n   /* If this node has been visited already, unshare it and don't look\n      any deeper.  */\n   else if (TREE_VISITED (t))\n@@ -713,17 +697,19 @@ unmark_visited_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n-/* Unshare all the trees in BODY_P, a pointer to the body of FNDECL, and the\n-   bodies of any nested functions.  */\n+/* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the\n+   bodies of any nested functions if we are unsharing the entire body of\n+   FNDECL.  */\n \n static void\n unshare_body (tree *body_p, tree fndecl)\n {\n   struct cgraph_node *cgn = cgraph_node (fndecl);\n \n   walk_tree (body_p, copy_if_shared_r, NULL, NULL);\n-  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-    unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+  if (body_p == &DECL_SAVED_TREE (fndecl))\n+    for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+      unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n }\n \n /* Likewise, but mark all trees as not visited.  */\n@@ -734,8 +720,9 @@ unvisit_body (tree *body_p, tree fndecl)\n   struct cgraph_node *cgn = cgraph_node (fndecl);\n \n   walk_tree (body_p, unmark_visited_r, NULL, NULL);\n-  for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-    unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+  if (body_p == &DECL_SAVED_TREE (fndecl))\n+    for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n+      unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n }\n \n /* Unshare T and all the trees reached from T via TREE_CHAIN.  */\n@@ -890,7 +877,7 @@ gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n \n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n-    t->decl.seen_in_bind_expr = 1;\n+    DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n \n   gimple_push_bind_expr (bind_expr);\n   gimplify_ctxp->save_stack = false;\n@@ -1668,7 +1655,8 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   tret = gimplify_expr (p, pre_p, post_p, is_gimple_min_lval, fallback);\n   ret = MIN (ret, tret);\n \n-  /* And finally, the indices and operands to BIT_FIELD_REF.  */\n+  /* And finally, the indices and operands to BIT_FIELD_REF.  During this\n+     loop we also remove any useless conversions.  */\n   for (; VARRAY_ACTIVE_SIZE (stack) > 0; )\n     {\n       tree t = VARRAY_TOP_TREE (stack);\n@@ -1700,7 +1688,9 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t\t\tis_gimple_val, fb_rvalue);\n \t  ret = MIN (ret, tret);\n \t}\n-\t  \n+\n+      STRIP_USELESS_TYPE_CONVERSION (TREE_OPERAND (t, 0));\n+\n       /* The innermost expression P may have originally had TREE_SIDE_EFFECTS\n \t set which would have caused all the outer expressions in EXPR_P\n \t leading to P to also have had TREE_SIDE_EFFECTS set.  */\n@@ -2321,7 +2311,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, bool want_value)\n   to = TREE_OPERAND (*expr_p, 0);\n   from = TREE_OPERAND (*expr_p, 1);\n \n-  t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n+  t = TYPE_SIZE_UNIT (TREE_TYPE (from));\n   t = unshare_expr (t);\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, from);\n@@ -2356,7 +2346,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, bool want_value)\n \n   to = TREE_OPERAND (*expr_p, 0);\n \n-  t = TYPE_SIZE_UNIT (TREE_TYPE (to));\n+  t = TYPE_SIZE_UNIT (TREE_TYPE (TREE_OPERAND (*expr_p, 1)));\n   t = unshare_expr (t);\n   t = SUBSTITUTE_PLACEHOLDER_IN_EXPR (t, to);\n   args = tree_cons (NULL, t, NULL);\n@@ -2772,8 +2762,15 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   /* If the value being copied is of variable width, expose the length\n      if the copy by converting the whole thing to a memcpy/memset.\n      Note that we need to do this before gimplifying any of the operands\n-     so that we can resolve any PLACEHOLDER_EXPRs in the size.  */\n-  if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*to_p))) != INTEGER_CST)\n+     so that we can resolve any PLACEHOLDER_EXPRs in the size. \n+     Also note that the RTL expander uses the size of the expression to\n+     be copied, not of the destination, so that is what we must here.\n+     The types on both sides of the MODIFY_EXPR should be the same,\n+     but they aren't always and there are problems with class-wide types\n+     in Ada where it's hard to make it \"correct\".  */\n+  if (TREE_CODE (TREE_TYPE (*from_p)) != ERROR_MARK\n+      && TYPE_SIZE_UNIT (TREE_TYPE (*from_p))\n+      && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*from_p))) != INTEGER_CST)\n     {\n       if (TREE_CODE (*from_p) == CONSTRUCTOR)\n \treturn gimplify_modify_expr_to_memset (expr_p, want_value);\n@@ -3361,7 +3358,7 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       TREE_OPERAND (targ, 3) = init;\n       TARGET_EXPR_INITIAL (targ) = NULL_TREE;\n     }\n-  else if (!temp->decl.seen_in_bind_expr)\n+  else if (!DECL_SEEN_IN_BIND_EXPR_P (temp))\n     /* We should have expanded this before.  */\n     abort ();\n \n@@ -3699,8 +3696,20 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase CONSTRUCTOR:\n-\t  /* Don't reduce this in place; let gimplify_init_constructor work\n-\t     its magic.  */\n+\t  /* Don't reduce this in place; let gimplify_init_constructor work its\n+\t     magic.  Buf if we're just elaborating this for side effects, just\n+\t     gimplify any element that has side-effects.  */\n+\t  if (fallback == fb_none)\n+\t    {\n+\t      for (tmp = CONSTRUCTOR_ELTS (*expr_p); tmp;\n+\t\t   tmp = TREE_CHAIN (tmp))\n+\t\tif (TREE_SIDE_EFFECTS (TREE_VALUE (tmp)))\n+\t\t  gimplify_expr (&TREE_VALUE (tmp), pre_p, post_p,\n+\t\t\t\t gimple_test_f, fallback);\n+\n+\t      *expr_p = NULL_TREE;\n+\t    }\n+\t\t  \n \t  ret = GS_ALL_DONE;\n \t  break;\n \n@@ -3801,7 +3810,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  tmp = *expr_p;\n \t  if (!TREE_STATIC (tmp) && !DECL_EXTERNAL (tmp)\n \t      && decl_function_context (tmp) == current_function_decl\n-\t      && !tmp->decl.seen_in_bind_expr)\n+\t      && !DECL_SEEN_IN_BIND_EXPR_P (tmp))\n \t    {\n #ifdef ENABLE_CHECKING\n \t      if (!errorcount && !sorrycount)"}, {"sha": "34a158c20f66abe70ef91c5417c7b628a93e74db", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 126, "deletions": 102, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=48eb4e53cdecda5736763287719b422e58c1058f", "patch": "@@ -766,7 +766,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   *vars = var;\n \n   /* Make gimplifier happy about this variable.  */\n-  var->decl.seen_in_bind_expr = lang_hooks.gimple_before_inlining;\n+  DECL_SEEN_IN_BIND_EXPR_P (var) = lang_hooks.gimple_before_inlining;\n \n   /* Even if P was TREE_READONLY, the new VAR should not be.\n      In the original code, we would have constructed a\n@@ -1951,6 +1951,100 @@ save_body (tree fn, tree *arg_copy)\n   return body;\n }\n \n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_tree (&(NODE), func, data, htab);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is a subroutine of walk_tree that walks field of TYPE that are to\n+   be walked whenever a type is seen in the tree.  Rest of operands and return\n+   value are as for walk_tree.  */\n+\n+static tree\n+walk_type_fields (tree type, walk_tree_fn func, void *data, void *htab)\n+{\n+  tree result = NULL_TREE;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* We have to worry about mutually recursive pointers.  These can't\n+\t be written in C.  They can in Ada.  It's pathlogical, but\n+\t there's an ACATS test (c38102a) that checks it.  Deal with this\n+\t by checking if we're pointing to another pointer, that one\n+\t points to another pointer, that one does too, and we have no htab.\n+\t If so, get a hash table.  We check three levels deep to avoid\n+\t the cost of the hash table if we don't need one.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (type))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (type)))\n+\t  && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (TREE_TYPE (type))))\n+\t  && !htab)\n+\t{\n+\t  result = walk_tree_without_duplicates (&TREE_TYPE (type),\n+\t\t\t\t\t\t func, data);\n+\t  if (result)\n+\t    return result;\n+\n+\t  break;\n+\t}\n+\n+      /* ... fall through ... */\n+\n+    case COMPLEX_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      break;\n+\n+    case METHOD_TYPE:\n+      WALK_SUBTREE (TYPE_METHOD_BASETYPE (type));\n+\n+      /* Fall through.  */\n+\n+    case FUNCTION_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      {\n+\ttree arg;\n+\n+\t/* We never want to walk into default arguments.  */\n+\tfor (arg = TYPE_ARG_TYPES (type); arg; arg = TREE_CHAIN (arg))\n+\t  WALK_SUBTREE (TREE_VALUE (arg));\n+      }\n+      break;\n+\n+    case ARRAY_TYPE:\n+      /* Don't follow this nodes's type if a pointer for fear that we'll\n+\t have infinite recursion.  Those types are uninteresting anyway. */\n+      if (!POINTER_TYPE_P (TREE_TYPE (type))\n+\t  && TREE_CODE (TREE_TYPE (type)) != OFFSET_TYPE)\n+\tWALK_SUBTREE (TREE_TYPE (type));\n+      WALK_SUBTREE (TYPE_DOMAIN (type));\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+    case ENUMERAL_TYPE:\n+    case INTEGER_TYPE:\n+    case CHAR_TYPE:\n+    case REAL_TYPE:\n+      WALK_SUBTREE (TYPE_MIN_VALUE (type));\n+      WALK_SUBTREE (TYPE_MAX_VALUE (type));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      WALK_SUBTREE (TREE_TYPE (type));\n+      WALK_SUBTREE (TYPE_OFFSET_BASETYPE (type));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Apply FUNC to all the sub-trees of TP in a pre-order traversal.  FUNC is\n    called with the DATA and the address of each sub-tree.  If FUNC returns a\n    non-NULL value, the traversal is aborted, and the value returned by FUNC\n@@ -1965,15 +2059,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n   int walk_subtrees;\n   tree result;\n \n-#define WALK_SUBTREE(NODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      result = walk_tree (&(NODE), func, data, htab);\t\\\n-      if (result)\t\t\t\t\t\\\n-\treturn result;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n #define WALK_SUBTREE_TAIL(NODE)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -2025,43 +2110,42 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n   if (result || ! walk_subtrees)\n     return result;\n \n-  /* If this is a DECL_EXPR, walk into various fields of the type or variable\n-     that it's defining.  We only want to walk into these fields of a decl\n-     or type in this case.\n+  /* If this is a DECL_EXPR, walk into various fields of the type that it's\n+     defining.  We only want to walk into these fields of a type in this\n+     case.  Note that decls get walked as part of the processing of a\n+     BIND_EXPR.\n \n      ??? Precisely which fields of types that we are supposed to walk in\n      this case vs. the normal case aren't well defined.  */\n   if (code == DECL_EXPR\n-      && TREE_CODE (DECL_EXPR_DECL (*tp)) != ERROR_MARK\n+      && TREE_CODE (DECL_EXPR_DECL (*tp)) == TYPE_DECL\n       && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (*tp))) != ERROR_MARK)\n     {\n-      tree decl = DECL_EXPR_DECL (*tp);\n-      tree type = TREE_TYPE (decl);\n+      tree *type_p = &TREE_TYPE (DECL_EXPR_DECL (*tp));\n \n-      /* Walk into fields of the DECL if it's not a type.  */\n-      if (TREE_CODE (decl) != TYPE_DECL)\n-\t{\n-\t  if (TREE_CODE (decl) != FIELD_DECL && TREE_CODE (decl) != PARM_DECL)\n-\t    WALK_SUBTREE (DECL_INITIAL (decl));\n+      /* Call the function for the type.  See if it returns anything or\n+\t doesn't want us to continue.  If we are to continue, walk both\n+\t the normal fields and those for the declaration case.  */\n+      result = (*func) (type_p, &walk_subtrees, data);\n+      if (result || !walk_subtrees)\n+\treturn NULL_TREE;\n \n-\t  WALK_SUBTREE (DECL_SIZE (decl));\n-\t  WALK_SUBTREE_TAIL (DECL_SIZE_UNIT (decl));\n-\t}\n+      result = walk_type_fields (*type_p, func, data, htab_);\n+      if (result)\n+\treturn result;\n \n-      /* Otherwise, we are declaring a type.  First do the common fields via\n-\t recursion, then the fields we only do when we are declaring the type\n-\t or object.  */\n-      WALK_SUBTREE (type);\n-      WALK_SUBTREE (TYPE_SIZE (type));\n-      WALK_SUBTREE (TYPE_SIZE_UNIT (type));\n+      WALK_SUBTREE (TYPE_SIZE (*type_p));\n+      WALK_SUBTREE (TYPE_SIZE_UNIT (*type_p));\n \n       /* If this is a record type, also walk the fields.  */\n-      if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n-\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n+      if (TREE_CODE (*type_p) == RECORD_TYPE\n+\t  || TREE_CODE (*type_p) == UNION_TYPE\n+\t  || TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n \t{\n \t  tree field;\n \n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  for (field = TYPE_FIELDS (*type_p); field;\n+\t       field = TREE_CHAIN (field))\n \t    {\n \t      /* We'd like to look at the type of the field, but we can easily\n \t\t get infinite recursion.  So assume it's pointed to elsewhere\n@@ -2072,7 +2156,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t      WALK_SUBTREE (DECL_FIELD_OFFSET (field));\n \t      WALK_SUBTREE (DECL_SIZE (field));\n \t      WALK_SUBTREE (DECL_SIZE_UNIT (field));\n-\t      if (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t      if (TREE_CODE (*type_p) == QUAL_UNION_TYPE)\n \t\tWALK_SUBTREE (DECL_QUALIFIER (field));\n \t    }\n \t}\n@@ -2114,6 +2198,13 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n #endif\n     }\n \n+  /* If this is a type, walk the needed fields in the type.  */\n+  else if (TYPE_P (*tp))\n+    {\n+      result = walk_type_fields (*tp, func, data, htab_);\n+      if (result)\n+\treturn result;\n+    }\n   else\n     {\n       /* Not one of the easy cases.  We must explicitly go through the\n@@ -2126,8 +2217,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \tcase REAL_CST:\n \tcase VECTOR_CST:\n \tcase STRING_CST:\n-\tcase VECTOR_TYPE:\n-\tcase VOID_TYPE:\n \tcase BLOCK:\n \tcase PLACEHOLDER_EXPR:\n \tcase SSA_NAME:\n@@ -2183,7 +2272,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t\tWALK_SUBTREE (DECL_INITIAL (decl));\n \t\tWALK_SUBTREE (DECL_SIZE (decl));\n \t\tWALK_SUBTREE (DECL_SIZE_UNIT (decl));\n-\t\tWALK_SUBTREE (TREE_TYPE (decl));\n \t      }\n \t    WALK_SUBTREE_TAIL (BIND_EXPR_BODY (*tp));\n \t  }\n@@ -2196,70 +2284,6 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t  }\n \t  break;\n \n-\tcase POINTER_TYPE:\n-\tcase REFERENCE_TYPE:\n-\t  /* We have to worry about mutually recursive pointers.  These can't\n-\t     be written in C.  They can in Ada.  It's pathlogical, but\n-\t     there's an ACATS test (c38102a) that checks it.  Deal with this\n-\t     by checking if we're pointing to another pointer, that one\n-\t     points to another pointer, that one does too, and we have no htab.\n-\t     If so, get a hash table.  We check three levels deep to avoid\n-\t     the cost of the hash table if we don't need one.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (*tp))\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (*tp)))\n-\t      && POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (TREE_TYPE (*tp))))\n-\t      && !htab)\n-\t    {\n-\t      result = walk_tree_without_duplicates (&TREE_TYPE (*tp),\n-\t\t\t\t\t\t     func, data);\n-\t      if (result)\n-\t\treturn result;\n-\n-\t      break;\n-\t    }\n-\n-\t  /* ... fall through ... */\n-\n-\tcase COMPLEX_TYPE:\n-\t  WALK_SUBTREE_TAIL (TREE_TYPE (*tp));\n-\t  break;\n-\n-\tcase METHOD_TYPE:\n-\t  WALK_SUBTREE (TYPE_METHOD_BASETYPE (*tp));\n-\n-\t  /* Fall through.  */\n-\n-\tcase FUNCTION_TYPE:\n-\t  WALK_SUBTREE (TREE_TYPE (*tp));\n-\t  {\n-\t    tree arg;\n-\n-\t    /* We never want to walk into default arguments.  */\n-\t    for (arg = TYPE_ARG_TYPES (*tp); arg; arg = TREE_CHAIN (arg))\n-\t      WALK_SUBTREE (TREE_VALUE (arg));\n-\t  }\n-\t  break;\n-\n-\tcase ARRAY_TYPE:\n-\t  /* Don't follow this nodes's type if a pointer for fear that we'll\n-\t     have infinite recursion.  Those types are uninteresting anyway. */\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (*tp))\n-\t      && TREE_CODE (TREE_TYPE (*tp)) != OFFSET_TYPE)\n-\t    WALK_SUBTREE (TREE_TYPE (*tp));\n-\t  WALK_SUBTREE_TAIL (TYPE_DOMAIN (*tp));\n-\n-\tcase BOOLEAN_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\tcase INTEGER_TYPE:\n-\tcase CHAR_TYPE:\n-\tcase REAL_TYPE:\n-\t  WALK_SUBTREE (TYPE_MIN_VALUE (*tp));\n-\t  WALK_SUBTREE_TAIL (TYPE_MAX_VALUE (*tp));\n-\n-\tcase OFFSET_TYPE:\n-\t  WALK_SUBTREE (TREE_TYPE (*tp));\n-\t  WALK_SUBTREE_TAIL (TYPE_OFFSET_BASETYPE (*tp));\n-\n \tdefault:\n \t  /* ??? This could be a language-defined node.  We really should make\n \t     a hook for it, but right now just ignore it.  */\n@@ -2498,7 +2522,7 @@ declare_inline_vars (tree bind_expr, tree vars)\n       tree t;\n \n       for (t = vars; t; t = TREE_CHAIN (t))\n-\tvars->decl.seen_in_bind_expr = 1;\n+\tDECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n     }\n \n   add_var_to_bind_expr (bind_expr, vars);"}, {"sha": "fdcaaf82436ebb48f844cd970e775e05fd8956aa", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=48eb4e53cdecda5736763287719b422e58c1058f", "patch": "@@ -145,6 +145,7 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n   tmp_var = create_tmp_var_raw (type, prefix);\n   DECL_CONTEXT (tmp_var) = info->context;\n   TREE_CHAIN (tmp_var) = info->new_local_var_chain;\n+  DECL_SEEN_IN_BIND_EXPR_P (tmp_var) = 1;\n   info->new_local_var_chain = tmp_var;\n \n   return tmp_var;"}, {"sha": "f093f7999873579b1ccea1a9c70d052daf086c44", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48eb4e53cdecda5736763287719b422e58c1058f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=48eb4e53cdecda5736763287719b422e58c1058f", "patch": "@@ -1985,6 +1985,11 @@ extern GTY (()) unsigned binfo_lang_slots;\n #define DECL_DECLARED_INLINE_P(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.declared_inline_flag)\n \n+/* Nonzero in a decl means that the gimplifier has seen (or placed)\n+   this variable in a BIND_EXPR.  */\n+#define DECL_SEEN_IN_BIND_EXPR_P(NODE) \\\n+  (DECL_CHECK (NODE)->decl.seen_in_bind_expr)\n+\n /* In a VAR_DECL, nonzero if the decl is a register variable with\n    an explicit asm specification.  */\n #define DECL_HARD_REGISTER(NODE)  (DECL_CHECK (NODE)->decl.inline_flag)"}]}