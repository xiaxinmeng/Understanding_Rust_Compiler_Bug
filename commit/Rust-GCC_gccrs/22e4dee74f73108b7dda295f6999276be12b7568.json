{"sha": "22e4dee74f73108b7dda295f6999276be12b7568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlNGRlZTc0ZjczMTA4YjdkZGEyOTVmNjk5OTI3NmJlMTJiNzU2OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-25T21:29:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-25T21:29:48Z"}, "message": "Change vec_perm checking and expansion level.\n\nThe can_vec_perm_p interface changed to use a C integer array.  This\nallows easy re-use from the rtl level and the gimple level within\nthe vectorizer.  It allows both to determine if a given permutation\nis (un-)supported without having to create tree/rtl garbage.\n\nThe expand_vec_perm interface changed to use rtl.  This allows easy\nre-use from the rtl level, so that expand_vec_perm can be used in the\nfallback implementation of other optabs.\n\n        * target.def (vec_perm_const_ok): Change parameters to mode and\n        array of indicies.\n        * doc/tm.texi: Rebuild.\n        * config/i386/i386.c (ix86_vectorize_vec_perm_const_ok): Change\n        parameters to mode and array of indicies.\n        * expr.c (expand_expr_real_2) [VEC_PERM_EXPR]: Expand operands here.\n        * optabs.c (can_vec_perm_p): Rename from can_vec_perm_expr_p.\n        Change parameters to mode and array of indicies.\n        (expand_vec_perm_1): Rename from expand_vec_perm_expr_1.\n        (expand_vec_perm): Rename from expand_vec_perm_expr.  Change\n        parameters to mode and rtx inputs.  Try lowering to QImode\n        vec_perm_const before trying fully variable permutation.\n        * optabs.h: Update decls.\n        * tree-vect-generic.c (lower_vec_perm): Extract array of indices from\n        VECTOR_CST to pass to can_vec_perm_p.\n        * tree-vect-slp.c (vect_get_mask_element): Change mask parameter type\n        from int pointer to unsigned char pointer.\n        (vect_transform_slp_perm_load): Update for change to can_vec_perm_p.\n        * tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n\nFrom-SVN: r180449", "tree": {"sha": "646bec23201b08685d3560602023733c6d9f7259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646bec23201b08685d3560602023733c6d9f7259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e4dee74f73108b7dda295f6999276be12b7568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e4dee74f73108b7dda295f6999276be12b7568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e4dee74f73108b7dda295f6999276be12b7568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e4dee74f73108b7dda295f6999276be12b7568/comments", "author": null, "committer": null, "parents": [{"sha": "c3962b13f70898c51173b9f3a6bb1e369a84b459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3962b13f70898c51173b9f3a6bb1e369a84b459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3962b13f70898c51173b9f3a6bb1e369a84b459"}], "stats": {"total": 346, "additions": 198, "deletions": 148}, "files": [{"sha": "af51915eae5be19ff3e3be734edf573e3e01b8a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -1,5 +1,25 @@\n 2011-10-25  Richard Henderson  <rth@redhat.com>\n \n+\t* target.def (vec_perm_const_ok): Change parameters to mode and\n+\tarray of indicies.\n+\t* doc/tm.texi: Rebuild.\n+\t* config/i386/i386.c (ix86_vectorize_vec_perm_const_ok): Change\n+\tparameters to mode and array of indicies.\n+\t* expr.c (expand_expr_real_2) [VEC_PERM_EXPR]: Expand operands here.\n+\t* optabs.c (can_vec_perm_p): Rename from can_vec_perm_expr_p.\n+\tChange parameters to mode and array of indicies.\n+\t(expand_vec_perm_1): Rename from expand_vec_perm_expr_1.\n+\t(expand_vec_perm): Rename from expand_vec_perm_expr.  Change\n+\tparameters to mode and rtx inputs.  Try lowering to QImode\n+\tvec_perm_const before trying fully variable permutation.\n+\t* optabs.h: Update decls.\n+\t* tree-vect-generic.c (lower_vec_perm): Extract array of indices from\n+\tVECTOR_CST to pass to can_vec_perm_p.\n+\t* tree-vect-slp.c (vect_get_mask_element): Change mask parameter type\n+\tfrom int pointer to unsigned char pointer.\n+\t(vect_transform_slp_perm_load): Update for change to can_vec_perm_p.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n+\n \t* tree.def (VEC_EXTRACT_EVEN_EXPR): Fix typo in text name.\n \t(VEC_EXTRACT_ODD_EXPR, VEC_INTERLEAVE_HIGH_EXPR,\n \tVEC_INTERLEAVE_LOW_EXPR): Likewise."}, {"sha": "0d5063e0e7e6967133d2d58de11cd5aeb0600a7a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -36477,14 +36477,14 @@ ix86_expand_vec_perm_const (rtx operands[4])\n /* Implement targetm.vectorize.vec_perm_const_ok.  */\n \n static bool\n-ix86_vectorize_vec_perm_const_ok (tree vec_type, tree mask)\n+ix86_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t  const unsigned char *sel)\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n   bool ret, one_vec;\n-  tree list;\n \n-  d.vmode = TYPE_MODE (vec_type);\n+  d.vmode = vmode;\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n   d.testing_p = true;\n \n@@ -36505,19 +36505,13 @@ ix86_vectorize_vec_perm_const_ok (tree vec_type, tree mask)\n \n   /* Extract the values from the vector CST into the permutation\n      array in D.  */\n-  list = TREE_VECTOR_CST_ELTS (mask);\n-  for (i = which = 0; i < nelt; ++i, list = TREE_CHAIN (list))\n+  memcpy (d.perm, sel, nelt);\n+  for (i = which = 0; i < nelt; ++i)\n     {\n-      unsigned HOST_WIDE_INT e;\n-\n-      gcc_checking_assert (host_integerp (TREE_VALUE (list), 1));\n-      e = tree_low_cst (TREE_VALUE (list), 1);\n+      unsigned char e = d.perm[i];\n       gcc_assert (e < 2 * nelt);\n-\n       which |= (e < nelt ? 1 : 2);\n-      d.perm[i] = e;\n     }\n-  gcc_assert (list == NULL);\n \n   /* For all elements from second vector, fold the elements to first.  */\n   if (which == 2)"}, {"sha": "422f74c5874e4421d54ed80f223172d2c663114a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -5711,7 +5711,7 @@ misalignment value (@var{misalign}).\n Return true if vector alignment is reachable (by peeling N iterations) for the given type.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (tree @var{vec_type}, tree @var{mask})\n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST_OK (enum @var{machine_mode}, const unsigned char *@var{sel})\n Return true if a vector created for @code{vec_perm_const} is valid.\n @end deftypefn\n "}, {"sha": "121db5eaf218484a38d7f431b65bb6a6c8202f6f", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -8752,9 +8752,11 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n       goto binop;\n \n     case VEC_PERM_EXPR:\n-      target = expand_vec_perm_expr (type, treeop0, treeop1, treeop2, target);\n-      gcc_assert (target);\n-      return target;\n+      expand_operands (treeop0, treeop1, target, &op0, &op1, EXPAND_NORMAL);\n+      op2 = expand_normal (treeop2);\n+      temp = expand_vec_perm (mode, op0, op1, op2, target);\n+      gcc_assert (temp);\n+      return temp;\n \n     case DOT_PROD_EXPR:\n       {"}, {"sha": "26669f404ff0d9a51c1bec7a9ceb1bb366af71c6", "filename": "gcc/optabs.c", "status": "modified", "additions": 115, "deletions": 100, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -6701,27 +6701,31 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n    of the CPU.  SEL may be NULL, which stands for an unknown constant.  */\n \n bool\n-can_vec_perm_expr_p (tree type, tree sel)\n+can_vec_perm_p (enum machine_mode mode, bool variable,\n+\t\tconst unsigned char *sel)\n {\n-  enum machine_mode mode, qimode;\n-  mode = TYPE_MODE (type);\n+  enum machine_mode qimode;\n \n   /* If the target doesn't implement a vector mode for the vector type,\n      then no operations are supported.  */\n   if (!VECTOR_MODE_P (mode))\n     return false;\n \n-  if (sel == NULL || TREE_CODE (sel) == VECTOR_CST)\n+  if (!variable)\n     {\n       if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n-\t  && (sel == NULL || targetm.vectorize.vec_perm_const_ok (type, sel)))\n+\t  && (sel == NULL\n+\t      || targetm.vectorize.vec_perm_const_ok == NULL\n+\t      || targetm.vectorize.vec_perm_const_ok (mode, sel)))\n \treturn true;\n     }\n \n   if (direct_optab_handler (vec_perm_optab, mode) != CODE_FOR_nothing)\n     return true;\n \n   /* We allow fallback to a QI vector mode, and adjust the mask.  */\n+  if (GET_MODE_INNER (mode) == QImode)\n+    return false;\n   qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n   if (!VECTOR_MODE_P (qimode))\n     return false;\n@@ -6732,9 +6736,9 @@ can_vec_perm_expr_p (tree type, tree sel)\n   if (direct_optab_handler (vec_perm_optab, qimode) == CODE_FOR_nothing)\n     return false;\n \n-  /* In order to support the lowering of non-constant permutations,\n+  /* In order to support the lowering of variable permutations,\n      we need to support shifts and adds.  */\n-  if (sel != NULL && TREE_CODE (sel) != VECTOR_CST)\n+  if (variable)\n     {\n       if (GET_MODE_UNIT_SIZE (mode) > 2\n \t  && optab_handler (ashl_optab, mode) == CODE_FOR_nothing\n@@ -6747,11 +6751,11 @@ can_vec_perm_expr_p (tree type, tree sel)\n   return true;\n }\n \n-/* A subroutine of expand_vec_perm_expr for expanding one vec_perm insn.  */\n+/* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n \n static rtx\n-expand_vec_perm_expr_1 (enum insn_code icode, rtx target,\n-\t\t\trtx v0, rtx v1, rtx sel)\n+expand_vec_perm_1 (enum insn_code icode, rtx target,\n+\t\t   rtx v0, rtx v1, rtx sel)\n {\n   enum machine_mode tmode = GET_MODE (target);\n   enum machine_mode smode = GET_MODE (sel);\n@@ -6783,119 +6787,130 @@ expand_vec_perm_expr_1 (enum insn_code icode, rtx target,\n   return NULL_RTX;\n }\n \n-/* Generate instructions for VEC_PERM_EXPR given its type and three\n-   operands.  */\n+/* Generate instructions for vec_perm optab given its mode\n+   and three operands.  */\n+\n rtx\n-expand_vec_perm_expr (tree type, tree v0, tree v1, tree sel, rtx target)\n+expand_vec_perm (enum machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n {\n   enum insn_code icode;\n-  enum machine_mode mode = TYPE_MODE (type);\n   enum machine_mode qimode;\n-  rtx v0_rtx, v1_rtx, sel_rtx, *vec, vt, tmp;\n   unsigned int i, w, e, u;\n+  rtx tmp, sel_qi;\n+  rtvec vec;\n \n-  if (!target)\n+  if (!target || GET_MODE (target) != mode)\n     target = gen_reg_rtx (mode);\n-  v0_rtx = expand_normal (v0);\n-  if (operand_equal_p (v0, v1, 0))\n-    v1_rtx = v0_rtx;\n-  else\n-    v1_rtx = expand_normal (v1);\n-  sel_rtx = expand_normal (sel);\n+\n+  w = GET_MODE_SIZE (mode);\n+  e = GET_MODE_NUNITS (mode);\n+  u = GET_MODE_UNIT_SIZE (mode);\n+\n+  /* Set QIMODE to a different vector mode with byte elements.\n+     If no such mode, or if MODE already has byte elements, use VOIDmode.  */\n+  qimode = VOIDmode;\n+  if (GET_MODE_INNER (mode) != QImode)\n+    {\n+      qimode = mode_for_vector (QImode, w);\n+      if (!VECTOR_MODE_P (qimode))\n+\tqimode = VOIDmode;\n+    }\n \n   /* If the input is a constant, expand it specially.  */\n-  if (CONSTANT_P (sel_rtx))\n+  if (CONSTANT_P (sel))\n     {\n       icode = direct_optab_handler (vec_perm_const_optab, mode);\n-      if (icode != CODE_FOR_nothing\n-\t  && targetm.vectorize.vec_perm_const_ok (TREE_TYPE (v0), sel)\n-\t  && (tmp = expand_vec_perm_expr_1 (icode, target, v0_rtx,\n-\t\t\t\t\t    v1_rtx, sel_rtx)) != NULL)\n-\treturn tmp;\n+      if (icode != CODE_FOR_nothing)\n+\t{\n+\t  tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+\n+      /* Fall back to a constant byte-based permutation.  */\n+      if (qimode != VOIDmode)\n+\t{\n+\t  icode = direct_optab_handler (vec_perm_const_optab, qimode);\n+\t  if (icode != CODE_FOR_nothing)\n+\t    {\n+\t      vec = rtvec_alloc (w);\n+\t      for (i = 0; i < e; ++i)\n+\t\t{\n+\t\t  unsigned int j, this_e;\n+\n+\t\t  this_e = INTVAL (XVECEXP (sel, 0, i));\n+\t\t  this_e &= 2 * e - 1;\n+\t\t  this_e *= u;\n+\n+\t\t  for (j = 0; j < u; ++j)\n+\t\t    RTVEC_ELT (vec, i * u + j) = GEN_INT (this_e + j);\n+\t\t}\n+\t      sel_qi = gen_rtx_CONST_VECTOR (qimode, vec);\n+\n+\t      tmp = expand_vec_perm_1 (icode, gen_lowpart (qimode, target),\n+\t\t\t\t       gen_lowpart (qimode, v0),\n+\t\t\t\t       gen_lowpart (qimode, v1), sel_qi);\n+\t      if (tmp)\n+\t\treturn gen_lowpart (mode, tmp);\n+\t    }\n+\t}\n     }\n \n-  /* Otherwise fall back to a fully variable permuation.  */\n+  /* Otherwise expand as a fully variable permuation.  */\n   icode = direct_optab_handler (vec_perm_optab, mode);\n-  if (icode != CODE_FOR_nothing\n-      && (tmp = expand_vec_perm_expr_1 (icode, target, v0_rtx,\n-\t\t\t\t\tv1_rtx, sel_rtx)) != NULL)\n-    return tmp;\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      tmp = expand_vec_perm_1 (icode, target, v0, v1, sel);\n+      if (tmp)\n+\treturn tmp;\n+    }\n \n   /* As a special case to aid several targets, lower the element-based\n      permutation to a byte-based permutation and try again.  */\n-  qimode = mode_for_vector (QImode, GET_MODE_SIZE (mode));\n-  if (!VECTOR_MODE_P (qimode))\n+  if (qimode == VOIDmode)\n     return NULL_RTX;\n-\n-  /* ??? For completeness, we ought to check the QImode version of\n-     vec_perm_const_optab.  But all users of this implicit lowering\n-     feature implement the variable vec_perm_optab.  */\n   icode = direct_optab_handler (vec_perm_optab, qimode);\n   if (icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  w = GET_MODE_SIZE (mode);\n-  e = GET_MODE_NUNITS (mode);\n-  u = GET_MODE_UNIT_SIZE (mode);\n-  vec = XALLOCAVEC (rtx, w);\n-\n-  if (CONSTANT_P (sel_rtx))\n-    {\n-      unsigned int j;\n-      for (i = 0; i < e; ++i)\n-\t{\n-\t  unsigned int this_e = INTVAL (XVECEXP (sel_rtx, 0, i));\n-\t  this_e &= 2 * e - 1;\n-          this_e *= u;\n-\n-\t  for (j = 0; j < u; ++j)\n-\t    vec[i * u + j] = GEN_INT (this_e + j);\n-\t}\n-      sel_rtx = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n-    }\n+  /* Multiply each element by its byte size.  */\n+  if (u == 2)\n+    sel = expand_simple_binop (mode, PLUS, sel, sel, sel, 0, OPTAB_DIRECT);\n   else\n-    {\n-      /* Multiply each element by its byte size.  */\n-      if (u == 2)\n-\tsel_rtx = expand_simple_binop (mode, PLUS, sel_rtx, sel_rtx,\n-\t\t\t\t       sel_rtx, 0, OPTAB_DIRECT);\n-      else\n-\tsel_rtx = expand_simple_binop (mode, ASHIFT, sel_rtx,\n-\t\t\t\t       GEN_INT (exact_log2 (u)),\n-\t\t\t\t       sel_rtx, 0, OPTAB_DIRECT);\n-      gcc_assert (sel_rtx);\n-\n-      /* Broadcast the low byte each element into each of its bytes.  */\n-      for (i = 0; i < w; ++i)\n-\t{\n-\t  int this_e = i / u * u;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    this_e += u - 1;\n-\t  vec[i] = GEN_INT (this_e);\n-\t}\n-      vt = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n-      sel_rtx = gen_lowpart (qimode, sel_rtx);\n-      sel_rtx = expand_vec_perm_expr_1 (icode, gen_reg_rtx (qimode),\n-\t\t\t\t\tsel_rtx, sel_rtx, vt);\n-      gcc_assert (sel_rtx != NULL);\n-\n-      /* Add the byte offset to each byte element.  */\n-      /* Note that the definition of the indicies here is memory ordering,\n-\t so there should be no difference between big and little endian.  */\n-      for (i = 0; i < w; ++i)\n-\tvec[i] = GEN_INT (i % u);\n-      vt = gen_rtx_CONST_VECTOR (qimode, gen_rtvec_v (w, vec));\n-      sel_rtx = expand_simple_binop (qimode, PLUS, sel_rtx, vt,\n-\t\t\t\t     NULL_RTX, 0, OPTAB_DIRECT);\n-      gcc_assert (sel_rtx);\n-    }\n-\n-  tmp = expand_vec_perm_expr_1 (icode, gen_lowpart (qimode, target),\n-\t\t\t        gen_lowpart (qimode, v0_rtx),\n-\t\t\t        gen_lowpart (qimode, v1_rtx), sel_rtx);\n-  gcc_assert (tmp != NULL);\n-\n-  return gen_lowpart (mode, tmp);\n+    sel = expand_simple_binop (mode, ASHIFT, sel, GEN_INT (exact_log2 (u)),\n+\t\t\t       sel, 0, OPTAB_DIRECT);\n+  gcc_assert (sel != NULL);\n+\n+  /* Broadcast the low byte each element into each of its bytes.  */\n+  vec = rtvec_alloc (w);\n+  for (i = 0; i < w; ++i)\n+    {\n+      int this_e = i / u * u;\n+      if (BYTES_BIG_ENDIAN)\n+\tthis_e += u - 1;\n+      RTVEC_ELT (vec, i) = GEN_INT (this_e);\n+    }\n+  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+  sel = gen_lowpart (qimode, sel);\n+  sel = expand_vec_perm (qimode, sel, sel, tmp, NULL);\n+  gcc_assert (sel != NULL);\n+\n+  /* Add the byte offset to each byte element.  */\n+  /* Note that the definition of the indicies here is memory ordering,\n+     so there should be no difference between big and little endian.  */\n+  vec = rtvec_alloc (w);\n+  for (i = 0; i < w; ++i)\n+    RTVEC_ELT (vec, i) = GEN_INT (i % u);\n+  tmp = gen_rtx_CONST_VECTOR (qimode, vec);\n+  sel = expand_simple_binop (qimode, PLUS, sel, tmp, sel, 0, OPTAB_DIRECT);\n+  gcc_assert (sel != NULL);\n+\n+  tmp = expand_vec_perm_1 (icode, gen_lowpart (qimode, target),\n+\t\t\t   gen_lowpart (qimode, v0),\n+\t\t\t   gen_lowpart (qimode, v1), sel);\n+  if (tmp)\n+    tmp = gen_lowpart (mode, tmp);\n+  return tmp;\n }\n \n "}, {"sha": "9e3c5b06fc470bf136dc5e481dd9d4f3eb13f2a4", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -901,10 +901,10 @@ extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n extern rtx expand_vec_shift_expr (sepops, rtx);\n \n /* Return tree if target supports vector operations for VEC_PERM_EXPR.  */\n-extern bool can_vec_perm_expr_p (tree, tree);\n+extern bool can_vec_perm_p (enum machine_mode, bool, const unsigned char *);\n \n /* Generate code for VEC_PERM_EXPR.  */\n-extern rtx expand_vec_perm_expr (tree, tree, tree, tree, rtx);\n+extern rtx expand_vec_perm (enum machine_mode, rtx, rtx, rtx, rtx);\n \n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */"}, {"sha": "f89bb5193691e8c8cc936a0060819159f8f611e3", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -985,12 +985,13 @@ DEFHOOK\n  bool, (const_tree type, bool is_packed),\n  default_builtin_vector_alignment_reachable)\n \n-/* Return true if a vector created for vec_perm_const is valid.  */\n+/* Return true if a vector created for vec_perm_const is valid.\n+   A NULL indicates that all constants are valid permutations.  */\n DEFHOOK\n (vec_perm_const_ok,\n  \"\",\n- bool, (tree vec_type, tree mask),\n- hook_bool_tree_tree_true)\n+ bool, (enum machine_mode, const unsigned char *sel),\n+ NULL)\n \n /* Return true if the target supports misaligned store/load of a\n    specific factor denoted in the third parameter.  The last parameter"}, {"sha": "42ce2e3d729274977d226d71b1d68f352b623631", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -641,13 +641,23 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n   unsigned i;\n \n-  if (can_vec_perm_expr_p (vect_type, mask))\n+  if (TREE_CODE (mask) == VECTOR_CST)\n+    {\n+      unsigned char *sel_int = XALLOCAVEC (unsigned char, elements);\n+      tree vals = TREE_VECTOR_CST_ELTS (mask);\n+\n+      for (i = 0; i < elements; ++i, vals = TREE_CHAIN (vals))\n+\tsel_int[i] = TREE_INT_CST_LOW (TREE_VALUE (vals));\n+\n+      if (can_vec_perm_p (TYPE_MODE (vect_type), false, sel_int))\n+\treturn;\n+    }\n+  else if (can_vec_perm_p (TYPE_MODE (vect_type), true, NULL))\n     return;\n   \n   warning_at (loc, OPT_Wvector_operation_performance,\n               \"vector shuffling operation will be expanded piecewise\");\n \n-\n   v = VEC_alloc (constructor_elt, gc, elements);\n   for (i = 0; i < elements; i++)\n     {"}, {"sha": "790f2dd0a75c2d1ca12b46a3a27d90449f6ab03a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -2356,7 +2356,7 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n static bool\n vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n                        int mask_nunits, bool only_one_vec, int index,\n-                       int *mask, int *current_mask_element,\n+\t\t       unsigned char *mask, int *current_mask_element,\n                        bool *need_next_vector, int *number_of_mask_fixes,\n                        bool *mask_fixed, bool *needs_first_vector)\n {\n@@ -2443,14 +2443,18 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n   gimple next_scalar_stmt;\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n   int first_mask_element;\n-  int index, unroll_factor, *mask, current_mask_element, ncopies;\n+  int index, unroll_factor, current_mask_element, ncopies;\n+  unsigned char *mask;\n   bool only_one_vec = false, need_next_vector = false;\n   int first_vec_index, second_vec_index, orig_vec_stmts_num, vect_stmts_counter;\n   int number_of_mask_fixes = 1;\n   bool mask_fixed = false;\n   bool needs_first_vector = false;\n+  enum machine_mode mode;\n \n-  if (!can_vec_perm_expr_p (vectype, NULL_TREE))\n+  mode = TYPE_MODE (vectype);\n+\n+  if (!can_vec_perm_p (mode, false, NULL))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n@@ -2467,7 +2471,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n     (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (vectype))), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  mask = (int *) xmalloc (sizeof (int) * nunits);\n+  mask = XALLOCAVEC (unsigned char, nunits);\n   unroll_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_node_instance);\n \n   /* The number of vector stmts to generate based only on SLP_NODE_INSTANCE\n@@ -2529,6 +2533,18 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n                 {\n \t\t  tree mask_vec = NULL;\n \n+\t\t  if (!can_vec_perm_p (mode, false, mask))\n+\t\t    {\n+\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (vect_dump, \"unsupported vect permute { \");\n+\t\t\t  for (i = 0; i < nunits; ++i)\n+\t\t\t    fprintf (vect_dump, \"%d \", mask[i]);\n+\t\t\t  fprintf (vect_dump, \"}\\n\");\n+\t\t\t}\n+\t\t      return false;\n+\t\t    }\n+\n \t\t  while (--index >= 0)\n \t\t    {\n \t\t      tree t = build_int_cst (mask_element_type, mask[index]);\n@@ -2537,17 +2553,6 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \t\t  mask_vec = build_vector (mask_type, mask_vec);\n \t\t  index = 0;\n \n-\t\t  if (!can_vec_perm_expr_p (vectype, mask_vec))\n-\t\t    {\n-\t\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (vect_dump, \"unsupported vect permute \");\n-\t\t\t  print_generic_expr (vect_dump, mask_vec, 0);\n-\t\t\t}\n-\t\t      free (mask);\n-\t\t      return false;\n-\t\t    }\n-\n                   if (!analyze_only)\n                     {\n                       if (need_next_vector)\n@@ -2569,7 +2574,6 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n         }\n     }\n \n-  free (mask);\n   return true;\n }\n "}, {"sha": "4cd582dad892ac403e931bf740b9b915c0fb6200", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e4dee74f73108b7dda295f6999276be12b7568/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=22e4dee74f73108b7dda295f6999276be12b7568", "patch": "@@ -4090,25 +4090,29 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n static tree\n perm_mask_for_reverse (tree vectype)\n {\n-  tree mask_element_type, mask_type, mask_vec = NULL;\n+  tree mask_elt_type, mask_type, mask_vec;\n   int i, nunits;\n+  unsigned char *sel;\n \n-  if (!can_vec_perm_expr_p (vectype, NULL_TREE))\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  sel = XALLOCAVEC (unsigned char, nunits);\n+\n+  for (i = 0; i < nunits; ++i)\n+    sel[i] = nunits - 1 - i;\n+\n+  if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n     return NULL;\n \n-  mask_element_type\n+  mask_elt_type\n     = lang_hooks.types.type_for_size\n     (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (vectype))), 1);\n-  mask_type = get_vectype_for_scalar_type (mask_element_type);\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n+  mask_vec = NULL;\n   for (i = 0; i < nunits; i++)\n-    mask_vec = tree_cons (NULL, build_int_cst (mask_element_type, i), mask_vec);\n+    mask_vec = tree_cons (NULL, build_int_cst (mask_elt_type, i), mask_vec);\n   mask_vec = build_vector (mask_type, mask_vec);\n \n-  if (!can_vec_perm_expr_p (vectype, mask_vec))\n-    return NULL;\n-\n   return mask_vec;\n }\n "}]}