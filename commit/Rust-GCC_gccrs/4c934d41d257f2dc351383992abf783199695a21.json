{"sha": "4c934d41d257f2dc351383992abf783199695a21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5MzRkNDFkMjU3ZjJkYzM1MTM4Mzk5MmFiZjc4MzE5OTY5NWEyMQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-12-06T04:13:34Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-12-06T04:13:34Z"}, "message": "re PR fortran/38291 (Rejects I/O with POS= if FMT=*)\n\n2008-12-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/38291\n\t* io.c (match_dt_element): Use dt->pos in matcher.\n\t(gfc_free_dt): Free dt->pos after use.\n\t(gfc_resolve_dt): Use dt->pos in resolution of stream position tag.\n\n2008-12-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/38291\n\t* io/transfer.c (data_transfer_init): Add checks for POS= valid range.\n\tAdd check for unit opened with ACCESS=\"stream\". Flush and seek if\n\tcurrent stream position does not match. Check ENDFILE on read.\n\nFrom-SVN: r142515", "tree": {"sha": "1a43d93b6dfb18632fadb7aba84fb6dd58edb485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a43d93b6dfb18632fadb7aba84fb6dd58edb485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c934d41d257f2dc351383992abf783199695a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c934d41d257f2dc351383992abf783199695a21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c934d41d257f2dc351383992abf783199695a21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c934d41d257f2dc351383992abf783199695a21/comments", "author": null, "committer": null, "parents": [{"sha": "a2a6f3cf6be67b838c80b304a9bf29887b831d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2a6f3cf6be67b838c80b304a9bf29887b831d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2a6f3cf6be67b838c80b304a9bf29887b831d26"}], "stats": {"total": 111, "additions": 85, "deletions": 26}, "files": [{"sha": "5cdbb230293c393f30f4e422f474b4060ecfd491", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c934d41d257f2dc351383992abf783199695a21/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c934d41d257f2dc351383992abf783199695a21/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4c934d41d257f2dc351383992abf783199695a21", "patch": "@@ -1,3 +1,10 @@\n+2008-12-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/38291\n+\t* io.c (match_dt_element): Use dt->pos in matcher.\n+\t(gfc_free_dt): Free dt->pos after use.\n+\t(gfc_resolve_dt): Use dt->pos in resolution of stream position tag.\n+\n 2008-12-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR bootstrap/38262"}, {"sha": "97f304b19170fe63951904bea210b9292fc2a7df", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c934d41d257f2dc351383992abf783199695a21/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c934d41d257f2dc351383992abf783199695a21/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=4c934d41d257f2dc351383992abf783199695a21", "patch": "@@ -2412,7 +2412,7 @@ match_dt_element (io_kind k, gfc_dt *dt)\n   m = match_etag (&tag_rec, &dt->rec);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_etag (&tag_spos, &dt->rec);\n+  m = match_etag (&tag_spos, &dt->pos);\n   if (m != MATCH_NO)\n     return m;\n   m = match_out_tag (&tag_iomsg, &dt->iomsg);\n@@ -2478,6 +2478,7 @@ gfc_free_dt (gfc_dt *dt)\n   gfc_free_expr (dt->blank);\n   gfc_free_expr (dt->decimal);\n   gfc_free_expr (dt->extra_comma);\n+  gfc_free_expr (dt->pos);\n   gfc_free (dt);\n }\n \n@@ -2491,7 +2492,7 @@ gfc_resolve_dt (gfc_dt *dt)\n \n   RESOLVE_TAG (&tag_format, dt->format_expr);\n   RESOLVE_TAG (&tag_rec, dt->rec);\n-  RESOLVE_TAG (&tag_spos, dt->rec);\n+  RESOLVE_TAG (&tag_spos, dt->pos);\n   RESOLVE_TAG (&tag_advance, dt->advance);\n   RESOLVE_TAG (&tag_id, dt->id);\n   RESOLVE_TAG (&tag_iomsg, dt->iomsg);"}, {"sha": "7aba0260ccd1d63f847c931ae9ef685ee9d6c31d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c934d41d257f2dc351383992abf783199695a21/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c934d41d257f2dc351383992abf783199695a21/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4c934d41d257f2dc351383992abf783199695a21", "patch": "@@ -1,3 +1,10 @@\n+2008-12-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/38291\n+\t* io/transfer.c (data_transfer_init): Add checks for POS= valid range.\n+\tAdd check for unit opened with ACCESS=\"stream\". Flush and seek if\n+\tcurrent stream position does not match. Check ENDFILE on read.\n+\n 2008-12-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/38285"}, {"sha": "4ddfd9f9a989a9b1fec288b0fec5e735fb79f3c5", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c934d41d257f2dc351383992abf783199695a21/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c934d41d257f2dc351383992abf783199695a21/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=4c934d41d257f2dc351383992abf783199695a21", "patch": "@@ -2116,6 +2116,62 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   \n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n+  \n+  /* Check the POS= specifier: that it is in range and that it is used with a\n+     unit that has been connected for STREAM access. F2003 9.5.1.10.  */\n+  \n+  if (((cf & IOPARM_DT_HAS_POS) != 0))\n+    {\n+      if (is_stream_io (dtp))\n+\t{\n+\n+\t  if (dtp->pos <= 0)\n+\t    {\n+\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t      \"POS=specifier must be positive\");\n+\t      return;\n+\t    }\n+\n+\t  if (dtp->rec >= dtp->u.p.current_unit->maxrec)\n+\t    {\n+\t      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t      \"POS=specifier too large\");\n+\t      return;\n+\t    }\n+\n+\t  dtp->rec = dtp->pos;\n+\n+\t  if (dtp->u.p.mode == READING)\n+\t    {\n+\t      /* Required for compatibility between 4.3 and 4.4 runtime. Check\n+\t      to see if we might be reading what we wrote before  */\n+\t      if (dtp->u.p.current_unit->mode == WRITING)\n+\t\tflush(dtp->u.p.current_unit->s);\n+\n+\t      if (dtp->pos < file_length (dtp->u.p.current_unit->s))\n+\t\tdtp->u.p.current_unit->endfile = NO_ENDFILE;\n+\t    }\n+\n+\t  if (dtp->pos != dtp->u.p.current_unit->strm_pos)\n+\t    {\n+\t      fbuf_flush (dtp->u.p.current_unit, 1);\n+\t      flush (dtp->u.p.current_unit->s);\n+\t      if (sseek (dtp->u.p.current_unit->s, dtp->pos - 1) == FAILURE)\n+\t\t{\n+\t\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t\t  return;\n+\t\t}\n+\t      dtp->u.p.current_unit->strm_pos = dtp->pos;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t\t  \"POS=specifier not allowed, \"\n+\t\t\t  \"Try OPEN with ACCESS='stream'\");\n+\t  return;\n+\t}\n+    }\n \n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n@@ -2139,10 +2195,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       if (dtp->u.p.mode == READING\n \t  && dtp->u.p.current_unit->mode == WRITING\n \t  && !is_internal_unit (dtp))\n-        {\n-          fbuf_flush (dtp->u.p.current_unit, 1);      \n+\t{\n+\t  fbuf_flush (dtp->u.p.current_unit, 1);      \n \t  flush(dtp->u.p.current_unit->s);\n-        }\n+\t}\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n@@ -2156,29 +2212,17 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t}\n \n       /* Position the file.  */\n-      if (!is_stream_io (dtp))\n+      if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n+\t\t * dtp->u.p.current_unit->recl) == FAILURE)\n \t{\n-\t  if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n-\t\t     * dtp->u.p.current_unit->recl) == FAILURE)\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t      return;\n-\t    }\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  return;\n \t}\n-      else\n-        {\n-\t  if (dtp->u.p.current_unit->strm_pos != dtp->rec)\n-\t    {\n-\t      fbuf_flush (dtp->u.p.current_unit, 1);\n-\t      flush (dtp->u.p.current_unit->s);\n-\t      if (sseek (dtp->u.p.current_unit->s, dtp->rec - 1) == FAILURE)\n-\t        {\n-\t          generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t          return;\n-\t        }\n-\t      dtp->u.p.current_unit->strm_pos = dtp->rec;\n-\t    }\n-        }\n+\n+      /* This is required to maintain compatibility between\n+\t 4.3 and 4.4 runtime.  */\n+      if (is_stream_io (dtp))\n+\tdtp->u.p.current_unit->strm_pos = dtp->rec;\n \n     }\n "}]}