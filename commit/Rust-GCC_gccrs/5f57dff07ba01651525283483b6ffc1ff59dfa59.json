{"sha": "5f57dff07ba01651525283483b6ffc1ff59dfa59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1N2RmZjA3YmEwMTY1MTUyNTI4MzQ4M2I2ZmZjMWZmNTlkZmE1OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-28T00:55:33Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-02-28T00:55:33Z"}, "message": "(store_split_bit_field): If OP0 is a SUBREG, then compute WORD from the base register, instead of from the SUBREG.\n\n(store_split_bit_field): If OP0 is a SUBREG, then\ncompute WORD from the base register, instead of from the SUBREG.\n(extract_split_bit_field): Likewise.\n(extract_bit_field): Sign-extend multiword bitfield if necessary.\n\nFrom-SVN: r6668", "tree": {"sha": "fb59a6276e5779219ed40a789de47de0988a93bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb59a6276e5779219ed40a789de47de0988a93bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f57dff07ba01651525283483b6ffc1ff59dfa59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f57dff07ba01651525283483b6ffc1ff59dfa59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f57dff07ba01651525283483b6ffc1ff59dfa59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f57dff07ba01651525283483b6ffc1ff59dfa59/comments", "author": null, "committer": null, "parents": [{"sha": "81284a6ad220981f2d6a0e13ce3dade55c10cab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81284a6ad220981f2d6a0e13ce3dade55c10cab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81284a6ad220981f2d6a0e13ce3dade55c10cab8"}], "stats": {"total": 40, "additions": 35, "deletions": 5}, "files": [{"sha": "1d5d75eddac7b45fbcea06f7293fc5b586f64fee", "filename": "gcc/expmed.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f57dff07ba01651525283483b6ffc1ff59dfa59/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f57dff07ba01651525283483b6ffc1ff59dfa59/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5f57dff07ba01651525283483b6ffc1ff59dfa59", "patch": "@@ -757,8 +757,19 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n #endif\n \n       /* If OP0 is a register, then handle OFFSET here.\n-\t In the register case, UNIT must be a whole word.  */\n-      if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+\n+\t When handling multiword bitfields, extract_bit_field may pass\n+\t down a word_mode SUBREG of a larger REG for a bitfield that actually\n+\t crosses a word boundary.  Thus, for a SUBREG, we must find\n+\t the current word starting from the base register.  */\n+      if (GET_CODE (op0) == SUBREG)\n+\t{\n+\t  word = operand_subword (SUBREG_REG (op0),\n+\t\t\t\t  SUBREG_WORD (op0) + offset, 1,\n+\t\t\t\t  GET_MODE (SUBREG_REG (op0)));\n+\t  offset = 0;\n+\t}\n+      else if (GET_CODE (op0) == REG)\n \t{\n \t  word = operand_subword (op0, offset, 1, GET_MODE (op0));\n \t  offset = 0;\n@@ -917,7 +928,15 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t    emit_move_insn (target_part, result_part);\n \t}\n \n-      return target;\n+      if (unsignedp)\n+\treturn target;\n+      /* Signed bit field: sign-extend with two arithmetic shifts.  */\n+      target = expand_shift (LSHIFT_EXPR, mode, target,\n+\t\t\t     build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n+\t\t\t     NULL_RTX, 0);\n+      return expand_shift (RSHIFT_EXPR, mode, target,\n+\t\t\t   build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n+\t\t\t   NULL_RTX, 0);\n     }\n   \n   /* From here on we know the desired field is smaller than a word\n@@ -1505,8 +1524,19 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n       thissize = MIN (thissize, unit - thispos);\n \n       /* If OP0 is a register, then handle OFFSET here.\n-\t In the register case, UNIT must be a whole word.  */\n-      if (GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n+\n+\t When handling multiword bitfields, extract_bit_field may pass\n+\t down a word_mode SUBREG of a larger REG for a bitfield that actually\n+\t crosses a word boundary.  Thus, for a SUBREG, we must find\n+\t the current word starting from the base register.  */\n+      if (GET_CODE (op0) == SUBREG)\n+\t{\n+\t  word = operand_subword_force (SUBREG_REG (op0),\n+\t\t\t\t\tSUBREG_WORD (op0) + offset,\n+\t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n+\t  offset = 0;\n+\t}\n+      else if (GET_CODE (op0) == REG)\n \t{\n \t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n \t  offset = 0;"}]}