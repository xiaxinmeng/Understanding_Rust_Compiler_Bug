{"sha": "b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY0OTI1ZGM0Yjc1ZDQ4ZmUzNmMwZmNkNDFmZDAyMTUxYTVmZmE1NQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-23T12:11:10Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-03-23T12:11:10Z"}, "message": "avr.c, [...]: Where applicable...\n\n\n\t* config/avr/avr.c, config/bfin/bfin.c, config/c6x/c6x.c,\n\tconfig/epiphany/epiphany.c, config/frv/frv.c, config/ia64/ia64.c,\n\tconfig/iq2000/iq2000.c, config/mcore/mcore.c, config/mep/mep.c,\n\tconfig/mmix/mmix.c, config/pa/pa.c, config/rs6000/rs6000.c,\n\tconfig/s390/s390.c, config/sparc/sparc.c, config/spu/spu.c,\n\tconfig/stormy16/stormy16.c, config/v850/v850.c, config/xtensa/xtensa.c,\n\tdwarf2out.c, hw-doloop.c, resource.c, rtl.h : Where applicable, use\n\tthe predicates NOTE_P, NONJUMP_INSN_P, JUMP_P, CALL_P, LABEL_P, and\n\tBARRIER_P instead of GET_CODE.\n\nFrom-SVN: r197005", "tree": {"sha": "17531e80a4ee959e96e3b55b923dbe168f1daa80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17531e80a4ee959e96e3b55b923dbe168f1daa80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/comments", "author": null, "committer": null, "parents": [{"sha": "b9aaf52e25a78e5b150ecc7a8b5226392e569b5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9aaf52e25a78e5b150ecc7a8b5226392e569b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9aaf52e25a78e5b150ecc7a8b5226392e569b5e"}], "stats": {"total": 335, "additions": 163, "deletions": 172}, "files": [{"sha": "98fe9d13016eac5c0feef1d781e552262ac887fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1,3 +1,15 @@\n+2013-03-23  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* config/avr/avr.c, config/bfin/bfin.c, config/c6x/c6x.c,\n+\tconfig/epiphany/epiphany.c, config/frv/frv.c, config/ia64/ia64.c,\n+\tconfig/iq2000/iq2000.c, config/mcore/mcore.c, config/mep/mep.c,\n+\tconfig/mmix/mmix.c, config/pa/pa.c, config/rs6000/rs6000.c,\n+\tconfig/s390/s390.c, config/sparc/sparc.c, config/spu/spu.c,\n+\tconfig/stormy16/stormy16.c, config/v850/v850.c, config/xtensa/xtensa.c,\n+\tdwarf2out.c, hw-doloop.c, resource.c, rtl.h : Where applicable, use\n+\tthe predicates NOTE_P, NONJUMP_INSN_P, JUMP_P, CALL_P, LABEL_P, and\n+\tBARRIER_P instead of GET_CODE.\n+\n 2013-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.c (sparc_emit_probe_stack_range): Fix small"}, {"sha": "3f2b54a169c3555c2e4ae5ede477ce63024927f5", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -7629,9 +7629,9 @@ _reg_unused_after (rtx insn, rtx reg)\n \t      rtx this_insn = XVECEXP (PATTERN (insn), 0, i);\n \t      rtx set = single_set (this_insn);\n \n-\t      if (GET_CODE (this_insn) == CALL_INSN)\n+\t      if (CALL_P (this_insn))\n \t\tcode = CALL_INSN;\n-\t      else if (GET_CODE (this_insn) == JUMP_INSN)\n+\t      else if (JUMP_P (this_insn))\n \t\t{\n \t\t  if (INSN_ANNULLED_BRANCH_P (this_insn))\n \t\t    return 0;"}, {"sha": "a2d22c1c26f89628146805c895921a7a89ac0838", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -3887,8 +3887,7 @@ gen_one_bundle (rtx slot[3])\n       rtx t = NEXT_INSN (slot[0]);\n       while (t != slot[1])\n \t{\n-\t  if (GET_CODE (t) != NOTE\n-\t      || NOTE_KIND (t) != NOTE_INSN_DELETED)\n+\t  if (! NOTE_P (t) || NOTE_KIND (t) != NOTE_INSN_DELETED)\n \t    return false;\n \t  t = NEXT_INSN (t);\n \t}\n@@ -3898,8 +3897,7 @@ gen_one_bundle (rtx slot[3])\n       rtx t = NEXT_INSN (slot[1]);\n       while (t != slot[2])\n \t{\n-\t  if (GET_CODE (t) != NOTE\n-\t      || NOTE_KIND (t) != NOTE_INSN_DELETED)\n+\t  if (! NOTE_P (t) || NOTE_KIND (t) != NOTE_INSN_DELETED)\n \t    return false;\n \t  t = NEXT_INSN (t);\n \t}"}, {"sha": "f66ad55978e299b932b13941f3940d630a208e78", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -4848,7 +4848,7 @@ reorg_split_calls (rtx *call_labels)\n {\n   unsigned int reservation_mask = 0;\n   rtx insn = get_insns ();\n-  gcc_assert (GET_CODE (insn) == NOTE);\n+  gcc_assert (NOTE_P (insn));\n   insn = next_real_insn (insn);\n   while (insn)\n     {"}, {"sha": "5520a633c1fb1fcd693f30ee3b6a587e7e83776e", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -2386,7 +2386,7 @@ epiphany_mode_after (int entity, int last_mode, rtx insn)\n      calls.  */\n   if (entity == EPIPHANY_MSW_ENTITY_AND || entity == EPIPHANY_MSW_ENTITY_OR)\n     {\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \treturn 0;\n       return last_mode;\n     }"}, {"sha": "fd5349f218e25e9349520320c6c38cf091b2fdd9", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1408,7 +1408,7 @@ frv_function_contains_far_jump (void)\n {\n   rtx insn = get_insns ();\n   while (insn != NULL\n-\t && !(GET_CODE (insn) == JUMP_INSN\n+\t && !(JUMP_P (insn)\n \t      /* Ignore tablejump patterns.  */\n \t      && GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t      && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n@@ -1446,7 +1446,7 @@ frv_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t simply emit a different assembly directive because bralr and jmpl\n \t execute in different units.  */\n       for (insn = get_insns(); insn != NULL; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == JUMP_INSN)\n+\tif (JUMP_P (insn))\n \t  {\n \t    rtx pattern = PATTERN (insn);\n \t    if (GET_CODE (pattern) == PARALLEL\n@@ -2649,7 +2649,7 @@ frv_print_operand_jump_hint (rtx insn)\n   HOST_WIDE_INT prob = -1;\n   enum { UNKNOWN, BACKWARD, FORWARD } jump_type = UNKNOWN;\n \n-  gcc_assert (GET_CODE (insn) == JUMP_INSN);\n+  gcc_assert (JUMP_P (insn));\n \n   /* Assume any non-conditional jump is likely.  */\n   if (! any_condjump_p (insn))\n@@ -7387,7 +7387,7 @@ frv_pack_insn_p (rtx insn)\n        - There's no point putting a call in its own packet unless\n \t we have to.  */\n   if (frv_packet.num_insns > 0\n-      && GET_CODE (insn) == INSN\n+      && NONJUMP_INSN_P (insn)\n       && GET_MODE (insn) == TImode\n       && GET_CODE (PATTERN (insn)) != COND_EXEC)\n     return false;\n@@ -7430,7 +7430,7 @@ frv_insert_nop_in_packet (rtx insn)\n \n   packet_group = &frv_packet.groups[frv_unit_groups[frv_insn_unit (insn)]];\n   last = frv_packet.insns[frv_packet.num_insns - 1];\n-  if (GET_CODE (last) != INSN)\n+  if (! NONJUMP_INSN_P (last))\n     {\n       insn = emit_insn_before (PATTERN (insn), last);\n       frv_packet.insns[frv_packet.num_insns - 1] = insn;\n@@ -7492,7 +7492,7 @@ frv_for_each_packet (void (*handle_packet) (void))\n \n \t  default:\n \t    /* Calls mustn't be packed on a TOMCAT.  */\n-\t    if (GET_CODE (insn) == CALL_INSN && frv_cpu_type == FRV_CPU_TOMCAT)\n+\t    if (CALL_P (insn) && frv_cpu_type == FRV_CPU_TOMCAT)\n \t      frv_finish_packet (handle_packet);\n \n \t    /* Since the last instruction in a packet determines the EH\n@@ -7913,7 +7913,7 @@ frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n   CLEAR_HARD_REG_SET (used_regs);\n \n   for (insn = BB_END (bb); insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n-    if (GET_CODE (insn) == CALL_INSN)\n+    if (CALL_P (insn))\n       {\n \t/* We can't predict what a call will do to volatile memory.  */\n \tmemset (next_io, 0, sizeof (struct frv_io));"}, {"sha": "0e328ff827bf54204479a6305f742c5b97052b50", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -5470,7 +5470,7 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \t    else\n \t      which = \".sptk\";\n \t  }\n-\telse if (GET_CODE (current_output_insn) == CALL_INSN)\n+\telse if (CALL_P (current_output_insn))\n \t  which = \".sptk\";\n \telse\n \t  which = \".dptk\";\n@@ -6811,8 +6811,7 @@ group_barrier_needed (rtx insn)\n       memset (rws_insn, 0, sizeof (rws_insn));\n \n       /* Don't bundle a call following another call.  */\n-      if ((pat = prev_active_insn (insn))\n-\t  && GET_CODE (pat) == CALL_INSN)\n+      if ((pat = prev_active_insn (insn)) && CALL_P (pat))\n \t{\n \t  need_barrier = 1;\n \t  break;\n@@ -6826,8 +6825,7 @@ group_barrier_needed (rtx insn)\n \tflags.is_branch = 1;\n \n       /* Don't bundle a jump following a call.  */\n-      if ((pat = prev_active_insn (insn))\n-\t  && GET_CODE (pat) == CALL_INSN)\n+      if ((pat = prev_active_insn (insn)) && CALL_P (pat))\n \t{\n \t  need_barrier = 1;\n \t  break;\n@@ -6929,20 +6927,20 @@ emit_insn_group_barriers (FILE *dump)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \t{\n \t  if (insns_since_last_label)\n \t    last_label = insn;\n \t  insns_since_last_label = 0;\n \t}\n-      else if (GET_CODE (insn) == NOTE\n+      else if (NOTE_P (insn)\n \t       && NOTE_KIND (insn) == NOTE_INSN_BASIC_BLOCK)\n \t{\n \t  if (insns_since_last_label)\n \t    last_label = insn;\n \t  insns_since_last_label = 0;\n \t}\n-      else if (GET_CODE (insn) == INSN\n+      else if (NONJUMP_INSN_P (insn)\n \t       && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n \t       && XINT (PATTERN (insn), 1) == UNSPECV_INSN_GROUP_BARRIER)\n \t{\n@@ -6983,13 +6981,13 @@ emit_all_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == BARRIER)\n+      if (BARRIER_P (insn))\n \t{\n \t  rtx last = prev_active_insn (insn);\n \n \t  if (! last)\n \t    continue;\n-\t  if (GET_CODE (last) == JUMP_INSN\n+\t  if (JUMP_P (last)\n \t      && GET_CODE (PATTERN (last)) == ADDR_DIFF_VEC)\n \t    last = prev_active_insn (last);\n \t  if (recog_memoized (last) != CODE_FOR_insn_group_barrier)\n@@ -7487,7 +7485,7 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n       int needed = group_barrier_needed (insn);\n       \n       gcc_assert (!needed);\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \tinit_insn_group_barriers ();\n       stops_p [INSN_UID (insn)] = stop_before_p;\n       stop_before_p = 0;\n@@ -7576,7 +7574,7 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n \t       && last_scheduled_insn\n \t       && scheduled_good_insn (last_scheduled_insn))))\n       || (last_scheduled_insn\n-\t  && (GET_CODE (last_scheduled_insn) == CALL_INSN\n+\t  && (CALL_P (last_scheduled_insn)\n \t      || unknown_for_bundling_p (last_scheduled_insn))))\n     {\n       init_insn_group_barriers ();\n@@ -7594,7 +7592,7 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n \t  state_transition (curr_state, dfa_stop_insn);\n \t  if (TARGET_EARLY_STOP_BITS)\n \t    *sort_p = (last_scheduled_insn == NULL_RTX\n-\t\t       || GET_CODE (last_scheduled_insn) != CALL_INSN);\n+\t\t       || ! CALL_P (last_scheduled_insn));\n \t  else\n \t    *sort_p = 0;\n \t  return 1;\n@@ -8936,9 +8934,9 @@ ia64_add_bundle_selector_before (int template0, rtx insn)\n \t{\n \t  do\n \t    insn = next_active_insn (insn);\n-\t  while (GET_CODE (insn) == INSN\n+\t  while (NONJUMP_INSN_P (insn)\n \t\t && get_attr_empty (insn) == EMPTY_YES);\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \t  else if (note)\n \t    {\n@@ -9372,13 +9370,13 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n        insn != current_sched_info->next_tail;\n        insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == BARRIER)\n+      if (BARRIER_P (insn))\n \t{\n \t  rtx last = prev_active_insn (insn);\n \n \t  if (! last)\n \t    continue;\n-\t  if (GET_CODE (last) == JUMP_INSN\n+\t  if (JUMP_P (last)\n \t      && GET_CODE (PATTERN (last)) == ADDR_DIFF_VEC)\n \t    last = prev_active_insn (last);\n \t  if (recog_memoized (last) != CODE_FOR_insn_group_barrier)\n@@ -9445,8 +9443,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t  else if (recog_memoized (insn) >= 0\n \t\t   && important_for_bundling_p (insn))\n \t    seen_good_insn = 1;\n-\t  need_barrier_p = (GET_CODE (insn) == CALL_INSN\n-\t\t\t    || unknown_for_bundling_p (insn));\n+\t  need_barrier_p = (CALL_P (insn) || unknown_for_bundling_p (insn));\n \t}\n     }\n }\n@@ -9590,7 +9587,7 @@ emit_predicate_relation_info (void)\n       rtx head = BB_HEAD (bb);\n \n       /* We only need such notes at code labels.  */\n-      if (GET_CODE (head) != CODE_LABEL)\n+      if (! LABEL_P (head))\n \tcontinue;\n       if (NOTE_INSN_BASIC_BLOCK_P (NEXT_INSN (head)))\n \thead = NEXT_INSN (head);\n@@ -9618,7 +9615,7 @@ emit_predicate_relation_info (void)\n \n       while (1)\n \t{\n-\t  if (GET_CODE (insn) == CALL_INSN\n+\t  if (CALL_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == COND_EXEC\n \t      && find_reg_note (insn, REG_NORETURN, NULL_RTX))\n \t    {\n@@ -9766,15 +9763,15 @@ ia64_reorg (void)\n       if (insn)\n \t{\n \t  /* Skip over insns that expand to nothing.  */\n-\t  while (GET_CODE (insn) == INSN\n+\t  while (NONJUMP_INSN_P (insn)\n \t\t && get_attr_empty (insn) == EMPTY_YES)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE\n \t\t  && XINT (PATTERN (insn), 1) == UNSPECV_INSN_GROUP_BARRIER)\n \t\tsaw_stop = 1;\n \t      insn = prev_active_insn (insn);\n \t    }\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      if (! saw_stop)\n \t\temit_insn (gen_insn_group_barrier (GEN_INT (3)));\n@@ -10184,7 +10181,7 @@ ia64_asm_unwind_emit (FILE *asm_out_file, rtx insn)\n \t}\n     }\n \n-  if (GET_CODE (insn) == NOTE || ! RTX_FRAME_RELATED_P (insn))\n+  if (NOTE_P (insn) || ! RTX_FRAME_RELATED_P (insn))\n     return;\n \n   /* Look for the ALLOC insn.  */"}, {"sha": "7e19366ae9364bd9d9d989149f03ae7428c1e062", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -381,8 +381,7 @@ iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n   /* Make sure that we don't put nop's after labels.  */\n   next_insn = NEXT_INSN (cur_insn);\n   while (next_insn != 0\n-\t && (GET_CODE (next_insn) == NOTE\n-\t     || GET_CODE (next_insn) == CODE_LABEL))\n+\t && (NOTE_P (next_insn) || LABEL_P (next_insn)))\n     next_insn = NEXT_INSN (next_insn);\n \n   dslots_load_total += num_nops;\n@@ -391,7 +390,7 @@ iq2000_fill_delay_slot (const char *ret, enum delay_type type, rtx operands[],\n       || operands == 0\n       || cur_insn == 0\n       || next_insn == 0\n-      || GET_CODE (next_insn) == CODE_LABEL\n+      || LABEL_P (next_insn)\n       || (set_reg = operands[0]) == 0)\n     {\n       dslots_number_nops = 0;\n@@ -1533,8 +1532,8 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n       iq2000_load_reg4 = 0;\n     }\n \n-  if (   (GET_CODE (insn) == JUMP_INSN\n-       || GET_CODE (insn) == CALL_INSN\n+  if (   (JUMP_P (insn)\n+       || CALL_P (insn)\n        || (GET_CODE (PATTERN (insn)) == RETURN))\n \t   && NEXT_INSN (PREV_INSN (insn)) == insn)\n     {\n@@ -1544,7 +1543,7 @@ final_prescan_insn (rtx insn, rtx opvec[] ATTRIBUTE_UNUSED,\n     }\n   \n   if (TARGET_STATS\n-      && (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN))\n+      && (JUMP_P (insn) || CALL_P (insn)))\n     dslots_jump_total ++;\n }\n \f\n@@ -2285,8 +2284,8 @@ iq2000_adjust_insn_length (rtx insn, int length)\n   /* A unconditional jump has an unfilled delay slot if it is not part\n      of a sequence.  A conditional jump normally has a delay slot.  */\n   if (simplejump_p (insn)\n-      || (   (GET_CODE (insn) == JUMP_INSN\n-\t   || GET_CODE (insn) == CALL_INSN)))\n+      || (   (JUMP_P (insn)\n+\t   || CALL_P (insn))))\n     length += 4;\n \n   return length;"}, {"sha": "6550b6905f0a7a5b9f47616757ac104664f744e1", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -914,10 +914,10 @@ mcore_is_dead (rtx first, rtx reg)\n      to assume that it is live.  */\n   for (insn = NEXT_INSN (first); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \treturn 0;\t/* We lose track, assume it is alive.  */\n \n-      else if (GET_CODE(insn) == CALL_INSN)\n+      else if (CALL_P (insn))\n \t{\n \t  /* Call's might use it for target or register parms.  */\n \t  if (reg_referenced_p (reg, PATTERN (insn))\n@@ -926,7 +926,7 @@ mcore_is_dead (rtx first, rtx reg)\n \t  else if (dead_or_set_p (insn, reg))\n             return 1;\n \t}\n-      else if (GET_CODE (insn) == INSN)\n+      else if (NONJUMP_INSN_P (insn))\n \t{\n \t  if (reg_referenced_p (reg, PATTERN (insn)))\n             return 0;\n@@ -2254,7 +2254,7 @@ is_cond_candidate (rtx insn)\n      changed into a conditional.  Only bother with SImode items.  If \n      we wanted to be a little more aggressive, we could also do other\n      modes such as DImode with reg-reg move or load 0.  */\n-  if (GET_CODE (insn) == INSN)\n+  if (NONJUMP_INSN_P (insn))\n     {\n       rtx pat = PATTERN (insn);\n       rtx src, dst;\n@@ -2305,9 +2305,9 @@ is_cond_candidate (rtx insn)\n       */            \n \n     }\n-  else if (GET_CODE (insn) == JUMP_INSN &&\n-\t   GET_CODE (PATTERN (insn)) == SET &&\n-\t   GET_CODE (XEXP (PATTERN (insn), 1)) == LABEL_REF)\n+  else if (JUMP_P (insn)\n+\t   && GET_CODE (PATTERN (insn)) == SET\n+\t   && GET_CODE (XEXP (PATTERN (insn), 1)) == LABEL_REF)\n     return COND_BRANCH_INSN;\n \n   return COND_NO;\n@@ -2328,7 +2328,7 @@ emit_new_cond_insn (rtx insn, int cond)\n \n   pat = PATTERN (insn);\n \n-  if (GET_CODE (insn) == INSN)\n+  if (NONJUMP_INSN_P (insn))\n     {\n       dst = SET_DEST (pat);\n       src = SET_SRC (pat);\n@@ -2449,9 +2449,9 @@ conditionalize_block (rtx first)\n   /* Check that the first insn is a candidate conditional jump.  This is\n      the one that we'll eliminate.  If not, advance to the next insn to\n      try.  */\n-  if (GET_CODE (first) != JUMP_INSN ||\n-      GET_CODE (PATTERN (first)) != SET ||\n-      GET_CODE (XEXP (PATTERN (first), 1)) != IF_THEN_ELSE)\n+  if (! JUMP_P (first)\n+      || GET_CODE (PATTERN (first)) != SET\n+      || GET_CODE (XEXP (PATTERN (first), 1)) != IF_THEN_ELSE)\n     return NEXT_INSN (first);\n \n   /* Extract some information we need.  */"}, {"sha": "60054f9ae573cce522c1cf0e12e07e3fa29fbef9", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -4882,7 +4882,7 @@ mep_reorg_regmove (rtx insns)\n \n   if (dump_file)\n     for (insn = insns; insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == INSN)\n+      if (NONJUMP_INSN_P (insn))\n \tbefore++;\n \n   /* We're looking for (set r2 r1) moves where r1 dies, followed by a\n@@ -4896,7 +4896,7 @@ mep_reorg_regmove (rtx insns)\n       for (insn = insns; insn; insn = next)\n \t{\n \t  next = next_nonnote_nondebug_insn (insn);\n-\t  if (GET_CODE (insn) != INSN)\n+\t  if (! NONJUMP_INSN_P (insn))\n \t    continue;\n \t  pat = PATTERN (insn);\n \n@@ -4912,7 +4912,7 @@ mep_reorg_regmove (rtx insns)\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"superfluous moves: considering %d\\n\", INSN_UID (insn));\n \n-\t      while (follow && GET_CODE (follow) == INSN\n+\t      while (follow && NONJUMP_INSN_P (follow)\n \t\t     && GET_CODE (PATTERN (follow)) == SET\n \t\t     && !dead_or_set_p (follow, SET_SRC (pat))\n \t\t     && !mep_mentioned_p (PATTERN (follow), SET_SRC (pat), 0)\n@@ -4925,7 +4925,7 @@ mep_reorg_regmove (rtx insns)\n \n \t      if (dump_file)\n \t\tfprintf (dump_file, \"\\tfollow is %d\\n\", INSN_UID (follow));\n-\t      if (follow && GET_CODE (follow) == INSN\n+\t      if (follow && NONJUMP_INSN_P (follow)\n \t\t  && GET_CODE (PATTERN (follow)) == SET\n \t\t  && find_regno_note (follow, REG_DEAD, REGNO (SET_DEST (pat))))\n \t\t{\n@@ -5523,8 +5523,7 @@ mep_reorg_erepeat (rtx insns)\n \tcount = simplejump_p (insn) ? 0 : 1;\n \tfor (prev = PREV_INSN (insn); prev; prev = PREV_INSN (prev))\n \t  {\n-\t    if (GET_CODE (prev) == CALL_INSN\n-\t\t|| BARRIER_P (prev))\n+\t    if (CALL_P (prev) || BARRIER_P (prev))\n \t      break;\n \n \t    if (prev == JUMP_LABEL (insn))\n@@ -5543,10 +5542,10 @@ mep_reorg_erepeat (rtx insns)\n \t\t       *after* the label.  */\n \t\t    rtx barrier;\n \t\t    for (barrier = PREV_INSN (prev);\n-\t\t\t barrier && GET_CODE (barrier) == NOTE;\n+\t\t\t barrier && NOTE_P (barrier);\n \t\t\t barrier = PREV_INSN (barrier))\n \t\t      ;\n-\t\t    if (barrier && GET_CODE (barrier) != BARRIER)\n+\t\t    if (barrier && ! BARRIER_P (barrier))\n \t\t      break;\n \t\t  }\n \t\telse\n@@ -5590,10 +5589,9 @@ mep_reorg_erepeat (rtx insns)\n \t\tif (LABEL_NUSES (prev) == 1)\n \t\t  {\n \t\t    for (user = PREV_INSN (prev);\n-\t\t\t user && (INSN_P (user) || GET_CODE (user) == NOTE);\n+\t\t\t user && (INSN_P (user) || NOTE_P (user));\n \t\t\t user = PREV_INSN (user))\n-\t\t      if (GET_CODE (user) == JUMP_INSN\n-\t\t\t  && JUMP_LABEL (user) == prev)\n+\t\t      if (JUMP_P (user) && JUMP_LABEL (user) == prev)\n \t\t\t{\n \t\t\t  safe = INSN_UID (user);\n \t\t\t  break;\n@@ -5631,8 +5629,8 @@ mep_jmp_return_reorg (rtx insns)\n       /* Find the fist real insn the jump jumps to.  */\n       label = ret = JUMP_LABEL (insn);\n       while (ret\n-\t     && (GET_CODE (ret) == NOTE\n-\t\t || GET_CODE (ret) == CODE_LABEL\n+\t     && (NOTE_P (ret)\n+\t\t || LABEL_P (ret)\n \t\t || GET_CODE (PATTERN (ret)) == USE))\n \tret = NEXT_INSN (ret);\n \n@@ -7018,7 +7016,7 @@ mep_bundle_insns (rtx insns)\n       if (recog_memoized (insn) >= 0\n \t  && get_attr_slot (insn) == SLOT_COP)\n \t{\n-\t  if (GET_CODE (insn) == JUMP_INSN\n+\t  if (JUMP_P (insn)\n \t      || ! last\n \t      || recog_memoized (last) < 0\n \t      || get_attr_slot (last) != SLOT_CORE"}, {"sha": "1af09e559b017ce9a89c9e0adc63cbd2fe50f672", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1728,7 +1728,7 @@ mmix_print_operand (FILE *stream, rtx x, int code)\n       if (CONSTANT_P (modified_x)\n \t  /* Strangely enough, this is not included in CONSTANT_P.\n \t     FIXME: Ask/check about sanity here.  */\n-\t  || GET_CODE (modified_x) == CODE_LABEL)\n+\t  || LABEL_P (modified_x))\n \t{\n \t  output_addr_const (stream, modified_x);\n \t  return;"}, {"sha": "1cad695cf0d067919b3e992a2248f69e965869aa", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -3320,7 +3320,7 @@ remove_useless_addtr_insns (int check_notes)\n \t  rtx tmp;\n \n \t  /* Ignore anything that isn't an INSN or a JUMP_INSN.  */\n-\t  if (GET_CODE (insn) != INSN && GET_CODE (insn) != JUMP_INSN)\n+\t  if (! NONJUMP_INSN_P (insn) && ! JUMP_P (insn))\n \t    continue;\n \n \t  tmp = PATTERN (insn);\n@@ -3359,7 +3359,7 @@ remove_useless_addtr_insns (int check_notes)\n \t  rtx tmp, next;\n \n \t  /* Ignore anything that isn't an INSN.  */\n-\t  if (GET_CODE (insn) != INSN)\n+\t  if (! NONJUMP_INSN_P (insn))\n \t    continue;\n \n \t  tmp = PATTERN (insn);\n@@ -3382,13 +3382,11 @@ remove_useless_addtr_insns (int check_notes)\n \t  while (next)\n \t    {\n \t      /* Jumps, calls and labels stop our search.  */\n-\t      if (GET_CODE (next) == JUMP_INSN\n-\t\t  || GET_CODE (next) == CALL_INSN\n-\t\t  || GET_CODE (next) == CODE_LABEL)\n+\t      if (JUMP_P (next) || CALL_P (next) || LABEL_P (next))\n \t\tbreak;\n \n \t      /* As does another fcmp insn.  */\n-\t      if (GET_CODE (next) == INSN\n+\t      if (NONJUMP_INSN_P (next)\n \t\t  && GET_CODE (PATTERN (next)) == SET\n \t\t  && GET_CODE (SET_DEST (PATTERN (next))) == REG\n \t\t  && REGNO (SET_DEST (PATTERN (next))) == 0)\n@@ -3398,8 +3396,7 @@ remove_useless_addtr_insns (int check_notes)\n \t    }\n \n \t  /* Is NEXT_INSN a branch?  */\n-\t  if (next\n-\t      && GET_CODE (next) == JUMP_INSN)\n+\t  if (next && JUMP_P (next))\n \t    {\n \t      rtx pattern = PATTERN (next);\n \n@@ -4160,16 +4157,16 @@ pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      always point to a valid instruction in the current function.  */\n \n   /* Get the last real insn.  */\n-  if (GET_CODE (insn) == NOTE)\n+  if (NOTE_P (insn))\n     insn = prev_real_insn (insn);\n \n   /* If it is a sequence, then look inside.  */\n-  if (insn && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+  if (insn && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n   /* If insn is a CALL_INSN, then it must be a call to a volatile\n      function (otherwise there would be epilogue insns).  */\n-  if (insn && GET_CODE (insn) == CALL_INSN)\n+  if (insn && CALL_P (insn))\n     {\n       fputs (\"\\tnop\\n\", file);\n       last_address += 4;\n@@ -4930,12 +4927,12 @@ pa_adjust_insn_length (rtx insn, int length)\n \n   /* Jumps inside switch tables which have unfilled delay slots need\n      adjustment.  */\n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && GET_CODE (pat) == PARALLEL\n       && get_attr_type (insn) == TYPE_BTABLE_BRANCH)\n     length += 4;\n   /* Block move pattern.  */\n-  else if (GET_CODE (insn) == INSN\n+  else if (NONJUMP_INSN_P (insn)\n \t   && GET_CODE (pat) == PARALLEL\n \t   && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n \t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 0)) == MEM\n@@ -4944,15 +4941,15 @@ pa_adjust_insn_length (rtx insn, int length)\n \t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 1)) == BLKmode)\n     length += compute_movmem_length (insn) - 4;\n   /* Block clear pattern.  */\n-  else if (GET_CODE (insn) == INSN\n+  else if (NONJUMP_INSN_P (insn)\n \t   && GET_CODE (pat) == PARALLEL\n \t   && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n \t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 0)) == MEM\n \t   && XEXP (XVECEXP (pat, 0, 0), 1) == const0_rtx\n \t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 0)) == BLKmode)\n     length += compute_clrmem_length (insn) - 4;\n   /* Conditional branch with an unfilled delay slot.  */\n-  else if (GET_CODE (insn) == JUMP_INSN && ! simplejump_p (insn))\n+  else if (JUMP_P (insn) && ! simplejump_p (insn))\n     {\n       /* Adjust a short backwards conditional with an unfilled delay slot.  */\n       if (GET_CODE (pat) == SET\n@@ -5846,7 +5843,7 @@ pa_output_arg_descriptor (rtx call_insn)\n       return;\n     }\n \n-  gcc_assert (GET_CODE (call_insn) == CALL_INSN);\n+  gcc_assert (CALL_P (call_insn));\n   for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n        link; link = XEXP (link, 1))\n     {\n@@ -6641,7 +6638,7 @@ pa_output_lbranch (rtx dest, rtx insn, int xdelay)\n   if (xdelay && dbr_sequence_length () != 0)\n     {\n       /* We can't handle a jump in the delay slot.  */\n-      gcc_assert (GET_CODE (NEXT_INSN (insn)) != JUMP_INSN);\n+      gcc_assert (! JUMP_P (NEXT_INSN (insn)));\n \n       final_scan_insn (NEXT_INSN (insn), asm_out_file,\n \t\t       optimize, 0, NULL);\n@@ -7650,7 +7647,7 @@ pa_output_millicode_call (rtx insn, rtx call_dest)\n     output_asm_insn (\"nop\", xoperands);\n \n   /* We are done if there isn't a jump in the delay slot.  */\n-  if (seq_length == 0 || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+  if (seq_length == 0 || ! JUMP_P (NEXT_INSN (insn)))\n     return \"\";\n \n   /* This call has an unconditional jump in its delay slot.  */\n@@ -7708,7 +7705,7 @@ pa_attr_length_call (rtx insn, int sibcall)\n   rtx pat = PATTERN (insn);\n   unsigned long distance = -1;\n \n-  gcc_assert (GET_CODE (insn) == CALL_INSN);\n+  gcc_assert (CALL_P (insn));\n \n   if (INSN_ADDRESSES_SET_P ())\n     {\n@@ -7822,7 +7819,7 @@ pa_output_call (rtx insn, rtx call_dest, int sibcall)\n \t     delay slot.  We can't do this in a sibcall as we don't\n \t     have a second call-clobbered scratch register available.  */\n \t  if (seq_length != 0\n-\t      && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      && ! JUMP_P (NEXT_INSN (insn))\n \t      && !sibcall)\n \t    {\n \t      final_scan_insn (NEXT_INSN (insn), asm_out_file,\n@@ -7866,7 +7863,7 @@ pa_output_call (rtx insn, rtx call_dest, int sibcall)\n \t    indirect_call = 1;\n \n \t  if (seq_length != 0\n-\t      && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      && ! JUMP_P (NEXT_INSN (insn))\n \t      && !sibcall\n \t      && (!TARGET_PA_20\n \t\t  || indirect_call\n@@ -8032,7 +8029,7 @@ pa_output_call (rtx insn, rtx call_dest, int sibcall)\n   /* We are done if there isn't a jump in the delay slot.  */\n   if (seq_length == 0\n       || delay_insn_deleted\n-      || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+      || ! JUMP_P (NEXT_INSN (insn)))\n     return \"\";\n \n   /* A sibcall should never have a branch in the delay slot.  */\n@@ -8826,12 +8823,12 @@ int\n pa_jump_in_call_delay (rtx insn)\n {\n \n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (! JUMP_P (insn))\n     return 0;\n \n   if (PREV_INSN (insn)\n       && PREV_INSN (PREV_INSN (insn))\n-      && GET_CODE (next_real_insn (PREV_INSN (PREV_INSN (insn)))) == INSN)\n+      && NONJUMP_INSN_P (next_real_insn (PREV_INSN (PREV_INSN (insn)))))\n     {\n       rtx test_insn = next_real_insn (PREV_INSN (PREV_INSN (insn)));\n \n@@ -8928,14 +8925,14 @@ pa_following_call (rtx insn)\n \n   /* Find the previous real insn, skipping NOTEs.  */\n   insn = PREV_INSN (insn);\n-  while (insn && GET_CODE (insn) == NOTE)\n+  while (insn && NOTE_P (insn))\n     insn = PREV_INSN (insn);\n \n   /* Check for CALL_INSNs and millicode calls.  */\n   if (insn\n-      && ((GET_CODE (insn) == CALL_INSN\n+      && ((CALL_P (insn)\n \t   && get_attr_type (insn) != TYPE_DYNCALL)\n-\t  || (GET_CODE (insn) == INSN\n+\t  || (NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) != SEQUENCE\n \t      && GET_CODE (PATTERN (insn)) != USE\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n@@ -9000,7 +8997,7 @@ pa_reorg (void)\n \t  unsigned int length, i;\n \n \t  /* Find an ADDR_VEC or ADDR_DIFF_VEC insn to explode.  */\n-\t  if (GET_CODE (insn) != JUMP_INSN\n+\t  if (! JUMP_P (insn)\n \t      || (GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC))\n \t    continue;\n@@ -9059,7 +9056,7 @@ pa_reorg (void)\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n \t  /* Find an ADDR_VEC insn.  */\n-\t  if (GET_CODE (insn) != JUMP_INSN\n+\t  if (! JUMP_P (insn)\n \t      || (GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC))\n \t    continue;\n@@ -9140,9 +9137,7 @@ pa_combine_instructions (void)\n \n       /* We only care about INSNs, JUMP_INSNs, and CALL_INSNs.\n \t Also ignore any special USE insns.  */\n-      if ((GET_CODE (anchor) != INSN\n-\t  && GET_CODE (anchor) != JUMP_INSN\n-\t  && GET_CODE (anchor) != CALL_INSN)\n+      if ((! NONJUMP_INSN_P (anchor) && ! JUMP_P (anchor) && ! CALL_P (anchor))\n \t  || GET_CODE (PATTERN (anchor)) == USE\n \t  || GET_CODE (PATTERN (anchor)) == CLOBBER\n \t  || GET_CODE (PATTERN (anchor)) == ADDR_VEC\n@@ -9162,14 +9157,14 @@ pa_combine_instructions (void)\n \t       floater;\n \t       floater = PREV_INSN (floater))\n \t    {\n-\t      if (GET_CODE (floater) == NOTE\n-\t\t  || (GET_CODE (floater) == INSN\n+\t      if (NOTE_P (floater)\n+\t\t  || (NONJUMP_INSN_P (floater)\n \t\t      && (GET_CODE (PATTERN (floater)) == USE\n \t\t\t  || GET_CODE (PATTERN (floater)) == CLOBBER)))\n \t\tcontinue;\n \n \t      /* Anything except a regular INSN will stop our search.  */\n-\t      if (GET_CODE (floater) != INSN\n+\t      if (! NONJUMP_INSN_P (floater)\n \t\t  || GET_CODE (PATTERN (floater)) == ADDR_VEC\n \t\t  || GET_CODE (PATTERN (floater)) == ADDR_DIFF_VEC)\n \t\t{\n@@ -9223,15 +9218,15 @@ pa_combine_instructions (void)\n \t    {\n \t      for (floater = anchor; floater; floater = NEXT_INSN (floater))\n \t\t{\n-\t\t  if (GET_CODE (floater) == NOTE\n-\t\t      || (GET_CODE (floater) == INSN\n+\t\t  if (NOTE_P (floater)\n+\t\t      || (NONJUMP_INSN_P (floater)\n \t\t\t  && (GET_CODE (PATTERN (floater)) == USE\n \t\t\t      || GET_CODE (PATTERN (floater)) == CLOBBER)))\n \n \t\t    continue;\n \n \t\t  /* Anything except a regular INSN will stop our search.  */\n-\t\t  if (GET_CODE (floater) != INSN\n+\t\t  if (! NONJUMP_INSN_P (floater)\n \t\t      || GET_CODE (PATTERN (floater)) == ADDR_VEC\n \t\t      || GET_CODE (PATTERN (floater)) == ADDR_DIFF_VEC)\n \t\t    {\n@@ -9386,7 +9381,7 @@ pa_can_combine_p (rtx new_rtx, rtx anchor, rtx floater, int reversed, rtx dest,\n int\n pa_insn_refs_are_delayed (rtx insn)\n {\n-  return ((GET_CODE (insn) == INSN\n+  return ((NONJUMP_INSN_P (insn)\n \t   && GET_CODE (PATTERN (insn)) != SEQUENCE\n \t   && GET_CODE (PATTERN (insn)) != USE\n \t   && GET_CODE (PATTERN (insn)) != CLOBBER"}, {"sha": "0fe45d8b1516512389b6f53a9b80a769ff195e5c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -17843,9 +17843,8 @@ compute_save_world_info (rs6000_stack_t *info_ptr)\n   if (WORLD_SAVE_P (info_ptr))\n     {\n       rtx insn;\n-      for ( insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n-\tif ( GET_CODE (insn) == CALL_INSN\n-\t     && SIBLING_CALL_P (insn))\n+      for (insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n+\tif (CALL_P (insn) && SIBLING_CALL_P (insn))\n \t  {\n \t    info_ptr->world_save_p = 0;\n \t    break;\n@@ -23837,7 +23836,7 @@ is_load_insn (rtx insn, rtx *load_mem)\n   if (!insn || !INSN_P (insn))\n     return false;\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     return false;\n \n   return is_load_insn1 (PATTERN (insn), load_mem);\n@@ -24232,7 +24231,7 @@ insn_must_be_first_in_group (rtx insn)\n   enum attr_type type;\n \n   if (!insn\n-      || GET_CODE (insn) == NOTE\n+      || NOTE_P (insn)\n       || DEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n@@ -24363,7 +24362,7 @@ insn_must_be_last_in_group (rtx insn)\n   enum attr_type type;\n \n   if (!insn\n-      || GET_CODE (insn) == NOTE\n+      || NOTE_P (insn)\n       || DEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)"}, {"sha": "f6aa581e4b8cc0a461af28d5b8db4fcc874eba54", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -5738,7 +5738,7 @@ addr_generation_dependency_p (rtx dep_rtx, rtx insn)\n {\n   rtx target, pat;\n \n-  if (GET_CODE (dep_rtx) == INSN)\n+  if (NONJUMP_INSN_P (dep_rtx))\n       dep_rtx = PATTERN (dep_rtx);\n \n   if (GET_CODE (dep_rtx) == SET)\n@@ -5978,7 +5978,7 @@ s390_split_branches (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) != JUMP_INSN)\n+      if (! JUMP_P (insn))\n \tcontinue;\n \n       pat = PATTERN (insn);\n@@ -6398,7 +6398,7 @@ s390_find_constant (struct constant_pool *pool, rtx val,\n static rtx\n s390_execute_label (rtx insn)\n {\n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == PARALLEL\n       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC\n       && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)\n@@ -6603,7 +6603,7 @@ s390_mainpool_start (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == INSN\n+      if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC_VOLATILE\n \t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPECV_MAIN_POOL)\n@@ -6616,7 +6616,7 @@ s390_mainpool_start (void)\n \t{\n \t  s390_add_execute (pool, insn);\n \t}\n-      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+      else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -6758,7 +6758,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n       if (INSN_P (insn))\n \treplace_ltrel_base (&PATTERN (insn));\n \n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+      if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n         {\n           rtx addr, pool_ref = NULL_RTX;\n           find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -6840,7 +6840,7 @@ s390_chunkify_start (void)\n \t  s390_add_execute (curr_pool, insn);\n \t  s390_add_pool_insn (curr_pool, insn);\n \t}\n-      else if (GET_CODE (insn) == INSN || CALL_P (insn))\n+      else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -6867,7 +6867,7 @@ s390_chunkify_start (void)\n \t    }\n \t}\n \n-      if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CODE_LABEL)\n+      if (JUMP_P (insn) || LABEL_P (insn))\n \t{\n \t  if (curr_pool)\n \t    s390_add_pool_insn (curr_pool, insn);\n@@ -6911,7 +6911,7 @@ s390_chunkify_start (void)\n \t     Those will have an effect on code size, which we need to\n \t     consider here.  This calculation makes rather pessimistic\n \t     worst-case assumptions.  */\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    extra_size += 6;\n \n \t  if (chunk_size < S390_POOL_CHUNK_MIN\n@@ -6920,7 +6920,7 @@ s390_chunkify_start (void)\n \t    continue;\n \n \t  /* Pool chunks can only be inserted after BARRIERs ...  */\n-\t  if (GET_CODE (insn) == BARRIER)\n+\t  if (BARRIER_P (insn))\n \t    {\n \t      s390_end_pool (curr_pool, insn);\n \t      curr_pool = NULL;\n@@ -6937,7 +6937,7 @@ s390_chunkify_start (void)\n \t      if (!section_switch_p)\n \t\t{\n \t\t  /* We can insert the barrier only after a 'real' insn.  */\n-\t\t  if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+\t\t  if (! NONJUMP_INSN_P (insn) && ! CALL_P (insn))\n \t\t    continue;\n \t\t  if (get_attr_length (insn) == 0)\n \t\t    continue;\n@@ -7009,11 +7009,11 @@ s390_chunkify_start (void)\n \t Don't do that, however, if it is the label before\n \t a jump table.  */\n \n-      if (GET_CODE (insn) == CODE_LABEL\n+      if (LABEL_P (insn)\n \t  && (LABEL_PRESERVE_P (insn) || LABEL_NAME (insn)))\n \t{\n \t  rtx vec_insn = next_real_insn (insn);\n-\t  rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ?\n+\t  rtx vec_pat = vec_insn && JUMP_P (vec_insn) ?\n \t\t\tPATTERN (vec_insn) : NULL_RTX;\n \t  if (!vec_pat\n \t      || !(GET_CODE (vec_pat) == ADDR_VEC\n@@ -7023,7 +7023,7 @@ s390_chunkify_start (void)\n \n       /* If we have a direct jump (conditional or unconditional)\n \t or a casesi jump, check all potential targets.  */\n-      else if (GET_CODE (insn) == JUMP_INSN)\n+      else if (JUMP_P (insn))\n \t{\n           rtx pat = PATTERN (insn);\n \t  if (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) > 2)\n@@ -7048,7 +7048,7 @@ s390_chunkify_start (void)\n \t      /* Find the jump table used by this casesi jump.  */\n \t      rtx vec_label = XEXP (XEXP (XVECEXP (pat, 0, 1), 0), 0);\n \t      rtx vec_insn = next_real_insn (vec_label);\n-\t      rtx vec_pat = vec_insn && GET_CODE (vec_insn) == JUMP_INSN ?\n+\t      rtx vec_pat = vec_insn && JUMP_P (vec_insn) ?\n \t\t\t    PATTERN (vec_insn) : NULL_RTX;\n \t      if (vec_pat\n \t\t  && (GET_CODE (vec_pat) == ADDR_VEC\n@@ -7082,7 +7082,7 @@ s390_chunkify_start (void)\n   /* Insert base register reload insns at every far label.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL\n+    if (LABEL_P (insn)\n         && bitmap_bit_p (far_labels, CODE_LABEL_NUMBER (insn)))\n       {\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n@@ -7128,7 +7128,7 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n       if (!curr_pool)\n \tcontinue;\n \n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+      if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n         {\n           rtx addr, pool_ref = NULL_RTX;\n           find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -7181,9 +7181,9 @@ s390_chunkify_cancel (struct constant_pool *pool_list)\n       rtx jump = barrier? PREV_INSN (barrier) : NULL_RTX;\n       rtx label = NEXT_INSN (curr_pool->pool_insn);\n \n-      if (jump && GET_CODE (jump) == JUMP_INSN\n-\t  && barrier && GET_CODE (barrier) == BARRIER\n-\t  && label && GET_CODE (label) == CODE_LABEL\n+      if (jump && JUMP_P (jump)\n+\t  && barrier && BARRIER_P (barrier)\n+\t  && label && LABEL_P (label)\n \t  && GET_CODE (PATTERN (jump)) == SET\n \t  && SET_DEST (PATTERN (jump)) == pc_rtx\n \t  && GET_CODE (SET_SRC (PATTERN (jump))) == LABEL_REF\n@@ -7203,7 +7203,7 @@ s390_chunkify_cancel (struct constant_pool *pool_list)\n     {\n       rtx next_insn = NEXT_INSN (insn);\n \n-      if (GET_CODE (insn) == INSN\n+      if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n \t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPEC_RELOAD_BASE)\n@@ -10080,7 +10080,7 @@ s390_optimize_prologue (void)\n \n       next_insn = NEXT_INSN (insn);\n \n-      if (GET_CODE (insn) != INSN)\n+      if (! NONJUMP_INSN_P (insn))\n \tcontinue;\n \n       if (GET_CODE (PATTERN (insn)) == PARALLEL"}, {"sha": "3e98325bd3baa48ddc503409a40a68bbf4f7609e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -3063,10 +3063,10 @@ emit_cbcond_nop (rtx insn)\n   if (!next)\n     return 1;\n \n-  if (GET_CODE (next) == INSN\n+  if (NONJUMP_INSN_P (next)\n       && GET_CODE (PATTERN (next)) == SEQUENCE)\n     next = XVECEXP (PATTERN (next), 0, 0);\n-  else if (GET_CODE (next) == CALL_INSN\n+  else if (CALL_P (next)\n \t   && GET_CODE (PATTERN (next)) == PARALLEL)\n     {\n       rtx delay = XVECEXP (PATTERN (next), 0, 1);\n@@ -3222,7 +3222,7 @@ eligible_for_return_delay (rtx trial)\n   int regno;\n   rtx pat;\n \n-  if (GET_CODE (trial) != INSN)\n+  if (! NONJUMP_INSN_P (trial))\n     return 0;\n \n   if (get_attr_length (trial) != 1)\n@@ -3293,7 +3293,7 @@ eligible_for_sibcall_delay (rtx trial)\n {\n   rtx pat;\n \n-  if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n+  if (! NONJUMP_INSN_P (trial) || GET_CODE (PATTERN (trial)) != SET)\n     return 0;\n \n   if (get_attr_length (trial) != 1)\n@@ -5424,7 +5424,7 @@ sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n   last_real_insn = prev_real_insn (insn);\n   if (last_real_insn\n-      && GET_CODE (last_real_insn) == INSN\n+      && NONJUMP_INSN_P (last_real_insn)\n       && GET_CODE (PATTERN (last_real_insn)) == SEQUENCE)\n     last_real_insn = XVECEXP (PATTERN (last_real_insn), 0, 0);\n "}, {"sha": "2d8ec9c89b21a582ab5c34903ae1b5dbb9bb1381", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1962,7 +1962,7 @@ struct spu_bb_info\n static struct spu_bb_info *spu_bb_info;\n \n #define STOP_HINT_P(INSN) \\\n-\t\t(GET_CODE(INSN) == CALL_INSN \\\n+\t\t(CALL_P(INSN) \\\n \t\t || INSN_CODE(INSN) == CODE_FOR_divmodsi4 \\\n \t\t || INSN_CODE(INSN) == CODE_FOR_udivmodsi4)\n \n@@ -2163,7 +2163,7 @@ spu_emit_branch_hint (rtx before, rtx branch, rtx target,\n static rtx\n get_branch_target (rtx branch)\n {\n-  if (GET_CODE (branch) == JUMP_INSN)\n+  if (JUMP_P (branch))\n     {\n       rtx set, src;\n \n@@ -2212,7 +2212,7 @@ get_branch_target (rtx branch)\n \n       return src;\n     }\n-  else if (GET_CODE (branch) == CALL_INSN)\n+  else if (CALL_P (branch))\n     {\n       rtx call;\n       /* All of our call patterns are in a PARALLEL and the CALL is"}, {"sha": "30d6d781576c3a4c13b9f066fbe709d3070de4ec", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -2441,8 +2441,7 @@ combine_bnp (rtx insn)\n \t  if (reg_mentioned_p (reg, and_insn))\n \t    return;\n \n-\t  if (GET_CODE (and_insn) != NOTE\n-\t      && GET_CODE (and_insn) != INSN)\n+\t  if (! NOTE_P (and_insn) && ! NONJUMP_INSN_P (and_insn))\n \t    return;\n \t}\n     }\n@@ -2461,8 +2460,7 @@ combine_bnp (rtx insn)\n \t  if (reg_mentioned_p (reg, and_insn))\n \t    return;\n \n-\t  if (GET_CODE (and_insn) != NOTE\n-\t      && GET_CODE (and_insn) != INSN)\n+\t  if (! NOTE_P (and_insn) && ! NONJUMP_INSN_P (and_insn))\n \t    return;\n \t}\n \n@@ -2486,8 +2484,7 @@ combine_bnp (rtx insn)\n \t\tbreak;\n \n \t      if (reg_mentioned_p (reg, shift)\n-\t\t  || (GET_CODE (shift) != NOTE\n-\t\t      && GET_CODE (shift) != INSN))\n+\t\t  || (! NOTE_P (shift) && ! NONJUMP_INSN_P (shift)))\n \t\t{\n \t\t  shift = NULL_RTX;\n \t\t  break;\n@@ -2534,8 +2531,7 @@ combine_bnp (rtx insn)\n       if (reg_mentioned_p (reg, load))\n \treturn;\n \n-      if (GET_CODE (load) != NOTE\n-\t  && GET_CODE (load) != INSN)\n+      if (! NOTE_P (load) && ! NONJUMP_INSN_P (load))\n \treturn;\n     }\n   if (!load)"}, {"sha": "4a746aa142493c0fe4f18bb07bcc00da8bfdb9b5", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1133,13 +1133,13 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n \t     IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\n \t     INSN_UID (first_insn), INSN_UID (last_insn));\n \n-  if (GET_CODE (first_insn) == NOTE)\n+  if (NOTE_P (first_insn))\n     first_insn = next_nonnote_insn (first_insn);\n \n   last_insn = next_nonnote_insn (last_insn);\n   for (insn = first_insn; insn && insn != last_insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == INSN)\n+      if (NONJUMP_INSN_P (insn))\n \t{\n \t  rtx pattern = single_set (insn);\n \n@@ -1199,7 +1199,7 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n \n   /* Optimize back to back cases of ep <- r1 & r1 <- ep.  */\n   insn = prev_nonnote_insn (first_insn);\n-  if (insn && GET_CODE (insn) == INSN\n+  if (insn && NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SET\n       && SET_DEST (PATTERN (insn)) == *p_ep\n       && SET_SRC (PATTERN (insn)) == *p_r1)"}, {"sha": "7faf7de996820a5d791a08a7296051a993208728", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -1650,7 +1650,7 @@ xtensa_emit_loop_end (rtx insn, rtx *operands)\n \t  {\n \t    rtx body = PATTERN (insn);\n \n-\t    if (GET_CODE (body) == JUMP_INSN)\n+\t    if (JUMP_P (body))\n \t      {\n \t\toutput_asm_insn (TARGET_DENSITY ? \"nop.n\" : \"nop\", operands);\n \t\tdone = 1;"}, {"sha": "8cf3b767f9f00917fdfcd82dbf4c9938c2d3de42", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -5059,7 +5059,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n   if (temp->last\n       && temp->first == temp->last\n       && TREE_CODE (decl) == PARM_DECL\n-      && GET_CODE (temp->first->loc) == NOTE\n+      && NOTE_P (temp->first->loc)\n       && NOTE_VAR_LOCATION_DECL (temp->first->loc) == decl\n       && DECL_INCOMING_RTL (decl)\n       && NOTE_VAR_LOCATION_LOC (temp->first->loc)\n@@ -13475,7 +13475,7 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \t    *listp = new_loc_list (descr, node->label, endname, secname);\n \t    if (TREE_CODE (decl) == PARM_DECL\n \t\t&& node == loc_list->first\n-\t\t&& GET_CODE (node->loc) == NOTE\n+\t\t&& NOTE_P (node->loc)\n \t\t&& strcmp (node->label, endname) == 0)\n \t      (*listp)->force = true;\n \t    listp = &(*listp)->dw_loc_next;\n@@ -20702,7 +20702,7 @@ dwarf2out_var_location (rtx loc_note)\n   next_note = NEXT_INSN (loc_note);\n   if (! next_note\n       || INSN_DELETED_P (next_note)\n-      || GET_CODE (next_note) != NOTE\n+      || ! NOTE_P (next_note)\n       || (NOTE_KIND (next_note) != NOTE_INSN_VAR_LOCATION\n \t  && NOTE_KIND (next_note) != NOTE_INSN_CALL_ARG_LOCATION))\n     next_note = NULL_RTX;"}, {"sha": "9b59f5ddc6dee8695dc45e332c0fd64775430b33", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -365,7 +365,7 @@ discover_loops (bitmap_obstack *loop_stack, struct hw_doloop_hooks *hooks)\n       rtx tail = BB_END (bb);\n       rtx insn, reg;\n \n-      while (tail && GET_CODE (tail) == NOTE && tail != BB_HEAD (bb))\n+      while (tail && NOTE_P (tail) && tail != BB_HEAD (bb))\n \ttail = PREV_INSN (tail);\n \n       if (tail == NULL_RTX)"}, {"sha": "333c28f57e8a2411879ebde9913c6c1f15a7aafc", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -175,14 +175,12 @@ next_insn_no_annul (rtx insn)\n \t  && NEXT_INSN (PREV_INSN (insn)) != insn)\n \t{\n \t  rtx next = NEXT_INSN (insn);\n-\t  enum rtx_code code = GET_CODE (next);\n \n-\t  while ((code == INSN || code == JUMP_INSN || code == CALL_INSN)\n+\t  while ((NONJUMP_INSN_P (next) || JUMP_P (next) || CALL_P (next))\n \t\t && INSN_FROM_TARGET_P (next))\n \t    {\n \t      insn = next;\n \t      next = NEXT_INSN (insn);\n-\t      code = GET_CODE (next);\n \t    }\n \t}\n "}, {"sha": "b9defcceba4ebf0f19ea6e5a750e6f84f6b87f24", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b64925dc4b75d48fe36c0fcd41fd02151a5ffa55/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b64925dc4b75d48fe36c0fcd41fd02151a5ffa55", "patch": "@@ -960,9 +960,8 @@ extern const char * const reg_note_name[];\n #define NOTE_KIND(INSN) XCINT (INSN, 5, NOTE)\n \n /* Nonzero if INSN is a note marking the beginning of a basic block.  */\n-#define NOTE_INSN_BASIC_BLOCK_P(INSN)\t\t\t\\\n-  (GET_CODE (INSN) == NOTE\t\t\t\t\\\n-   && NOTE_KIND (INSN) == NOTE_INSN_BASIC_BLOCK)\n+#define NOTE_INSN_BASIC_BLOCK_P(INSN) \\\n+  (NOTE_P (INSN) && NOTE_KIND (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n /* Variable declaration and the location of a variable.  */\n #define PAT_VAR_LOCATION_DECL(PAT) (XCTREE ((PAT), 0, VAR_LOCATION))\n@@ -1063,7 +1062,7 @@ enum label_kind\n /* Retrieve the kind of LABEL.  */\n #define LABEL_KIND(LABEL) __extension__\t\t\t\t\t\\\n ({ __typeof (LABEL) const _label = (LABEL);\t\t\t\t\\\n-   if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n+   if (! LABEL_P (_label))\t\t\t\t\t\t\\\n      rtl_check_failed_flag (\"LABEL_KIND\", _label, __FILE__, __LINE__,\t\\\n \t\t\t    __FUNCTION__);\t\t\t\t\\\n    (enum label_kind) ((_label->jump << 1) | _label->call); })\n@@ -1072,7 +1071,7 @@ enum label_kind\n #define SET_LABEL_KIND(LABEL, KIND) do {\t\t\t\t\\\n    __typeof (LABEL) const _label = (LABEL);\t\t\t\t\\\n    const unsigned int _kind = (KIND);\t\t\t\t\t\\\n-   if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n+   if (! LABEL_P (_label))\t\t\t\t\t\t\\\n      rtl_check_failed_flag (\"SET_LABEL_KIND\", _label, __FILE__, __LINE__, \\\n \t\t\t    __FUNCTION__);\t\t\t\t\\\n    _label->jump = ((_kind >> 1) & 1);\t\t\t\t\t\\"}]}