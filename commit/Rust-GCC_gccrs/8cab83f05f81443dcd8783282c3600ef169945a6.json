{"sha": "8cab83f05f81443dcd8783282c3600ef169945a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhYjgzZjA1ZjgxNDQzZGNkODc4MzI4MmMzNjAwZWYxNjk5NDVhNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-08-05T08:09:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-08-05T08:09:00Z"}, "message": "loop-unroll.c (struct iv_to_split): Remove n_loc and loc fields.\n\n\t* loop-unroll.c (struct iv_to_split): Remove n_loc and loc fields.\n\t(analyze_iv_to_split_insn): Don't initialize them.\n\t(get_ivts_expr): Removed.\n\t(allocate_basic_variable, insert_base_initialization): Use\n\tSET_SRC instead of *get_ivts_expr.\n\t(split_iv): Use &SET_SRC instead of get_ivts_expr.\n\nFrom-SVN: r213621", "tree": {"sha": "c56909cb2b95226d2283be3e1429ab12c283d59f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56909cb2b95226d2283be3e1429ab12c283d59f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cab83f05f81443dcd8783282c3600ef169945a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cab83f05f81443dcd8783282c3600ef169945a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cab83f05f81443dcd8783282c3600ef169945a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cab83f05f81443dcd8783282c3600ef169945a6/comments", "author": null, "committer": null, "parents": [{"sha": "574921c272ca69e7a224d5e45f287d9c2fd49530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574921c272ca69e7a224d5e45f287d9c2fd49530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574921c272ca69e7a224d5e45f287d9c2fd49530"}], "stats": {"total": 81, "additions": 33, "deletions": 48}, "files": [{"sha": "fd8e8209b756db3fab04a5a56fecf22c3808d2b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cab83f05f81443dcd8783282c3600ef169945a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cab83f05f81443dcd8783282c3600ef169945a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cab83f05f81443dcd8783282c3600ef169945a6", "patch": "@@ -1,3 +1,12 @@\n+2014-08-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* loop-unroll.c (struct iv_to_split): Remove n_loc and loc fields.\n+\t(analyze_iv_to_split_insn): Don't initialize them.\n+\t(get_ivts_expr): Removed.\n+\t(allocate_basic_variable, insert_base_initialization): Use\n+\tSET_SRC instead of *get_ivts_expr.\n+\t(split_iv): Use &SET_SRC instead of get_ivts_expr.\n+\n 2014-08-05  Roman Gareev  <gareevroman@gmail.com>\n \n \t* graphite-isl-ast-to-gimple.c: Add a new struct ast_build_info.\n@@ -18,29 +27,27 @@\n 2014-08-04  Rohit  <rohitarulraj@freescale.com>\n \n \tPR target/60102\n-\t* config/rs6000/rs6000.c\n-\t  (rs6000_reg_names) : Add SPE high register names.\n-\t  (alt_reg_names) : Likewise.\n-\t  (rs6000_dwarf_register_span) : For SPE high registers, replace\n-\t  dwarf register numbers with GCC hard register numbers.\n-\t  (rs6000_init_dwarf_reg_sizes_extra) : Likewise.\n-\t  (rs6000_dbx_register_number): For SPE high registers, return dwarf\n-\t  register number for the corresponding GCC hard register number.\n-\t* config/rs6000/rs6000.h\n-\t  (FIRST_PSEUDO_REGISTER) : Update based on 32 newly added GCC hard\n-\t  register numbers for SPE high registers.\n-\t  (DWARF_FRAME_REGISTERS) :  Likewise.\n-\t  (DWARF_REG_TO_UNWIND_COLUMN) : Likewise.\n-\t  (DWARF_FRAME_REGNUM) : Likewise.\n-\t  (FIXED_REGISTERS) : Likewise.\n-\t  (CALL_USED_REGISTERS) : Likewise.\n-\t  (CALL_REALLY_USED_REGISTERS) : Likewise.\n-\t  (REG_ALLOC_ORDER) : Likewise.\n-\t  (enum reg_class) : Likewise.\n-\t  (REG_CLASS_NAMES) : Likewise.\n-\t  (REG_CLASS_CONTENTS) : Likewise.\n-\t  (SPE_HIGH_REGNO_P) : New macro to identify SPE high registers.\n-\t* gcc.target/powerpc/pr60102.c: New testcase.\n+\t* config/rs6000/rs6000.c (rs6000_reg_names): Add SPE high register\n+\tnames.\n+\t(alt_reg_names): Likewise.\n+\t(rs6000_dwarf_register_span): For SPE high registers, replace\n+\tdwarf register numbers with GCC hard register numbers.\n+\t(rs6000_init_dwarf_reg_sizes_extra): Likewise.\n+\t(rs6000_dbx_register_number): For SPE high registers, return dwarf\n+\tregister number for the corresponding GCC hard register number.\n+\t* config/rs6000/rs6000.h (FIRST_PSEUDO_REGISTER): Update based on 32\n+\tnewly added GCC hard register numbers for SPE high registers.\n+\t(DWARF_FRAME_REGISTERS):  Likewise.\n+\t(DWARF_REG_TO_UNWIND_COLUMN): Likewise.\n+\t(DWARF_FRAME_REGNUM): Likewise.\n+\t(FIXED_REGISTERS): Likewise.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(CALL_REALLY_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER): Likewise.\n+\t(enum reg_class): Likewise.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(SPE_HIGH_REGNO_P): New macro to identify SPE high registers.\n \n 2014-08-04  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "707ffff70b066c1bf28427ddcb37527ad8970bbb", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cab83f05f81443dcd8783282c3600ef169945a6/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cab83f05f81443dcd8783282c3600ef169945a6/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=8cab83f05f81443dcd8783282c3600ef169945a6", "patch": "@@ -79,11 +79,6 @@ struct iv_to_split\n \t\t\t   iterations are based.  */\n   rtx step;\t\t/* Step of the induction variable.  */\n   struct iv_to_split *next; /* Next entry in walking order.  */\n-  unsigned n_loc;\n-  unsigned loc[3];\t/* Location where the definition of the induction\n-\t\t\t   variable occurs in the insn.  For example if\n-\t\t\t   N_LOC is 2, the expression is located at\n-\t\t\t   XEXP (XEXP (single_set, loc[0]), loc[1]).  */\n };\n \n /* Information about accumulators to expand.  */\n@@ -1942,8 +1937,6 @@ analyze_iv_to_split_insn (rtx insn)\n   ivts->base_var = NULL_RTX;\n   ivts->step = iv.step;\n   ivts->next = NULL;\n-  ivts->n_loc = 1;\n-  ivts->loc[0] = 1;\n \n   return ivts;\n }\n@@ -2080,27 +2073,12 @@ determine_split_iv_delta (unsigned n_copy, unsigned n_copies, bool unrolling)\n     }\n }\n \n-/* Locate in EXPR the expression corresponding to the location recorded\n-   in IVTS, and return a pointer to the RTX for this location.  */\n-\n-static rtx *\n-get_ivts_expr (rtx expr, struct iv_to_split *ivts)\n-{\n-  unsigned i;\n-  rtx *ret = &expr;\n-\n-  for (i = 0; i < ivts->n_loc; i++)\n-    ret = &XEXP (*ret, ivts->loc[i]);\n-\n-  return ret;\n-}\n-\n /* Allocate basic variable for the induction variable chain.  */\n \n static void\n allocate_basic_variable (struct iv_to_split *ivts)\n {\n-  rtx expr = *get_ivts_expr (single_set (ivts->insn), ivts);\n+  rtx expr = SET_SRC (single_set (ivts->insn));\n \n   ivts->base_var = gen_reg_rtx (GET_MODE (expr));\n }\n@@ -2111,7 +2089,7 @@ allocate_basic_variable (struct iv_to_split *ivts)\n static void\n insert_base_initialization (struct iv_to_split *ivts, rtx insn)\n {\n-  rtx expr = copy_rtx (*get_ivts_expr (single_set (insn), ivts));\n+  rtx expr = copy_rtx (SET_SRC (single_set (insn)));\n   rtx seq;\n \n   start_sequence ();\n@@ -2146,7 +2124,7 @@ split_iv (struct iv_to_split *ivts, rtx insn, unsigned delta)\n     }\n \n   /* Figure out where to do the replacement.  */\n-  loc = get_ivts_expr (single_set (insn), ivts);\n+  loc = &SET_SRC (single_set (insn));\n \n   /* If we can make the replacement right away, we're done.  */\n   if (validate_change (insn, loc, expr, 0))"}]}