{"sha": "b1012ca4be23e00404c49f8520196af908110a10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEwMTJjYTRiZTIzZTAwNDA0YzQ5Zjg1MjAxOTZhZjkwODExMGExMA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-09-09T18:47:11Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2010-09-09T18:47:11Z"}, "message": "acinclude.m4 (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE, [...]): Remove.\n\n\t* acinclude.m4 (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE,\n\tLIBGFOR_CHECK_FOR_BROKEN_ISNAN,\n\tLIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): Remove.\n\t* configure.ac: Remove above checks.\n\t* libgfortran.h: Define isnan, isinf, isfinite, isnormal and\n\tsignbit in terms of the respective built-ins.\n\t* io/write_float.def (WRITE_FLOAT): Use signbit() instead of\n\t__builtin_signbit().\n\t* intrinsics/c99_functions.c (tgamma): Use isnan() instead of\n\t__builtin_isnan().\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\nFrom-SVN: r164119", "tree": {"sha": "b0229dad035aa2b5e40711de60b627e662093e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0229dad035aa2b5e40711de60b627e662093e81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1012ca4be23e00404c49f8520196af908110a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1012ca4be23e00404c49f8520196af908110a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1012ca4be23e00404c49f8520196af908110a10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1012ca4be23e00404c49f8520196af908110a10/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82916e7e24ad8ce033780aa3217de74c0c4f58f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82916e7e24ad8ce033780aa3217de74c0c4f58f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82916e7e24ad8ce033780aa3217de74c0c4f58f9"}], "stats": {"total": 381, "additions": 32, "deletions": 349}, "files": [{"sha": "913c0e56bb7972ac9f3b1b70eacedfc7e93c1dfe", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -1,3 +1,18 @@\n+2010-09-09  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* acinclude.m4 (LIBGFOR_CHECK_FOR_BROKEN_ISFINITE,\n+\tLIBGFOR_CHECK_FOR_BROKEN_ISNAN,\n+\tLIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY): Remove.\n+\t* configure.ac: Remove above checks.\n+\t* libgfortran.h: Define isnan, isinf, isfinite, isnormal and\n+\tsignbit in terms of the respective built-ins.\n+\t* io/write_float.def (WRITE_FLOAT): Use signbit() instead of\n+\t__builtin_signbit().\n+\t* intrinsics/c99_functions.c (tgamma): Use isnan() instead of\n+\t__builtin_isnan().\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\n 2010-09-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/38282"}, {"sha": "09cd29213cea178fb962eb23fe8884ec1506be43", "filename": "libgfortran/acinclude.m4", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Facinclude.m4?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -196,119 +196,6 @@ if test x\"$libgfor_cv_have_crlf\" = xyes; then\n   AC_DEFINE(HAVE_CRLF, 1, [Define if CRLF is line terminator.])\n fi])\n \n-dnl Check whether isfinite is broken.\n-dnl The most common problem is that it does not work on long doubles.\n-AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_ISFINITE], [\n-  AC_CACHE_CHECK([whether isfinite is broken],\n-                  libgfor_cv_have_broken_isfinite, [\n-  libgfor_check_for_broken_isfinite_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  AC_TRY_RUN([\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef isfinite\n-#ifdef LDBL_MAX\n-  if (!isfinite(LDBL_MAX)) return 1;\n-#endif\n-#ifdef DBL_MAX\n-  if (!isfinite(DBL_MAX)) return 1;\n-#endif\n-#endif\n-return 0;\n-}], libgfor_cv_have_broken_isfinite=no, libgfor_cv_have_broken_isfinite=yes, [\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_isfinite=yes ;;\n-  *) libgfor_cv_have_broken_isfinite=no ;;\n-esac])]\n-  LIBS=$libgfor_check_for_broken_isfinite_save_LIBS)\n-if test x\"$libgfor_cv_have_broken_isfinite\" = xyes; then\n-  AC_DEFINE(HAVE_BROKEN_ISFINITE, 1, [Define if isfinite is broken.])\n-fi])\n-\n-dnl Check whether isnan is broken.\n-dnl The most common problem is that it does not work on long doubles.\n-AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_ISNAN], [\n-  AC_CACHE_CHECK([whether isnan is broken],\n-                  libgfor_cv_have_broken_isnan, [\n-  libgfor_check_for_broken_isnan_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  AC_TRY_RUN([\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef isnan\n-#ifdef LDBL_MAX\n-  {\n-    long double x;\n-    x = __builtin_nanl (\"\");\n-    if (!isnan(x)) return 1;\n-    if (isnan(LDBL_MAX)) return 1;\n-#ifdef NAN\n-    x = (long double) NAN;\n-    if (!isnan(x)) return 1;\n-#endif\n-  }\n-#endif\n-#ifdef DBL_MAX\n-  {\n-    double y;\n-    y = __builtin_nan (\"\");\n-    if (!isnan(y)) return 1;\n-    if (isnan(DBL_MAX)) return 1;\n-#ifdef NAN\n-    y = (double) NAN;\n-    if (!isnan(y)) return 1;\n-#endif\n-  }\n-#endif\n-#endif\n-return 0;\n-}], libgfor_cv_have_broken_isnan=no, libgfor_cv_have_broken_isnan=yes, [\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_isnan=yes ;;\n-  *) libgfor_cv_have_broken_isnan=no ;;\n-esac])]\n-  LIBS=$libgfor_check_for_broken_isnan_save_LIBS)\n-if test x\"$libgfor_cv_have_broken_isnan\" = xyes; then\n-  AC_DEFINE(HAVE_BROKEN_ISNAN, 1, [Define if isnan is broken.])\n-fi])\n-\n-dnl Check whether fpclassify is broken.\n-dnl The most common problem is that it does not work on long doubles.\n-AC_DEFUN([LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY], [\n-  AC_CACHE_CHECK([whether fpclassify is broken],\n-                  libgfor_cv_have_broken_fpclassify, [\n-  libgfor_check_for_broken_fpclassify_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  AC_TRY_RUN([\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef fpclassify\n-#ifdef LDBL_MAX\n-        if (fpclassify(LDBL_MAX) == FP_NAN\n-            || fpclassify(LDBL_MAX) == FP_INFINITE) return 1;\n-#endif\n-#ifdef DBL_MAX\n-        if (fpclassify(DBL_MAX) == FP_NAN\n-            || fpclassify(DBL_MAX) == FP_INFINITE) return 1;\n-#endif\n-#endif\n-return 0;\n-}], libgfor_cv_have_broken_fpclassify=no, libgfor_cv_have_broken_fpclassify=yes, [\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_fpclassify=yes ;;\n-  *) libgfor_cv_have_broken_fpclassify=no ;;\n-esac])]\n-  LIBS=$libgfor_check_for_broken_fpclassify_save_LIBS)\n-if test x\"$libgfor_cv_have_broken_fpclassify\" = xyes; then\n-  AC_DEFINE(HAVE_BROKEN_FPCLASSIFY, 1, [Define if fpclassify is broken.])\n-fi])\n-\n dnl Check whether the st_ino and st_dev stat fields taken together uniquely\n dnl identify the file within the system. This is should be true for POSIX\n dnl systems; it is known to be false on mingw32."}, {"sha": "f5f367fd2366531e724b3fd69a1855e57a825ac6", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -87,15 +87,6 @@\n /* Define to 1 if you have the `backtrace_symbols' function. */\n #undef HAVE_BACKTRACE_SYMBOLS\n \n-/* Define if fpclassify is broken. */\n-#undef HAVE_BROKEN_FPCLASSIFY\n-\n-/* Define if isfinite is broken. */\n-#undef HAVE_BROKEN_ISFINITE\n-\n-/* Define if isnan is broken. */\n-#undef HAVE_BROKEN_ISNAN\n-\n /* Define if powf is broken. */\n #undef HAVE_BROKEN_POWF\n "}, {"sha": "cf2b58748dcb5b46ec4cbd8ba4dc1e50012dfe10", "filename": "libgfortran/configure", "status": "modified", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -24162,188 +24162,6 @@ $as_echo \"#define HAVE_CLOG 1\" >>confdefs.h\n fi\n \n \n-# Check for a isfinite macro that works on long doubles.\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether isfinite is broken\" >&5\n-$as_echo_n \"checking whether isfinite is broken... \" >&6; }\n-if test \"${libgfor_cv_have_broken_isfinite+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-  libgfor_check_for_broken_isfinite_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  if test \"$cross_compiling\" = yes; then :\n-\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_isfinite=yes ;;\n-  *) libgfor_cv_have_broken_isfinite=no ;;\n-esac\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef isfinite\n-#ifdef LDBL_MAX\n-  if (!isfinite(LDBL_MAX)) return 1;\n-#endif\n-#ifdef DBL_MAX\n-  if (!isfinite(DBL_MAX)) return 1;\n-#endif\n-#endif\n-return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_run \"$LINENO\"; then :\n-  libgfor_cv_have_broken_isfinite=no\n-else\n-  libgfor_cv_have_broken_isfinite=yes\n-fi\n-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n-  conftest.$ac_objext conftest.beam conftest.$ac_ext\n-fi\n-\n-  LIBS=$libgfor_check_for_broken_isfinite_save_LIBS\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgfor_cv_have_broken_isfinite\" >&5\n-$as_echo \"$libgfor_cv_have_broken_isfinite\" >&6; }\n-if test x\"$libgfor_cv_have_broken_isfinite\" = xyes; then\n-\n-$as_echo \"#define HAVE_BROKEN_ISFINITE 1\" >>confdefs.h\n-\n-fi\n-\n-# Check for a isnan macro that works on long doubles.\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether isnan is broken\" >&5\n-$as_echo_n \"checking whether isnan is broken... \" >&6; }\n-if test \"${libgfor_cv_have_broken_isnan+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-  libgfor_check_for_broken_isnan_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  if test \"$cross_compiling\" = yes; then :\n-\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_isnan=yes ;;\n-  *) libgfor_cv_have_broken_isnan=no ;;\n-esac\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef isnan\n-#ifdef LDBL_MAX\n-  {\n-    long double x;\n-    x = __builtin_nanl (\"\");\n-    if (!isnan(x)) return 1;\n-    if (isnan(LDBL_MAX)) return 1;\n-#ifdef NAN\n-    x = (long double) NAN;\n-    if (!isnan(x)) return 1;\n-#endif\n-  }\n-#endif\n-#ifdef DBL_MAX\n-  {\n-    double y;\n-    y = __builtin_nan (\"\");\n-    if (!isnan(y)) return 1;\n-    if (isnan(DBL_MAX)) return 1;\n-#ifdef NAN\n-    y = (double) NAN;\n-    if (!isnan(y)) return 1;\n-#endif\n-  }\n-#endif\n-#endif\n-return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_run \"$LINENO\"; then :\n-  libgfor_cv_have_broken_isnan=no\n-else\n-  libgfor_cv_have_broken_isnan=yes\n-fi\n-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n-  conftest.$ac_objext conftest.beam conftest.$ac_ext\n-fi\n-\n-  LIBS=$libgfor_check_for_broken_isnan_save_LIBS\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgfor_cv_have_broken_isnan\" >&5\n-$as_echo \"$libgfor_cv_have_broken_isnan\" >&6; }\n-if test x\"$libgfor_cv_have_broken_isnan\" = xyes; then\n-\n-$as_echo \"#define HAVE_BROKEN_ISNAN 1\" >>confdefs.h\n-\n-fi\n-\n-# Check for a fpclassify macro that works on long doubles.\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether fpclassify is broken\" >&5\n-$as_echo_n \"checking whether fpclassify is broken... \" >&6; }\n-if test \"${libgfor_cv_have_broken_fpclassify+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-\n-  libgfor_check_for_broken_fpclassify_save_LIBS=$LIBS\n-  LIBS=\"$LIBS -lm\"\n-  if test \"$cross_compiling\" = yes; then :\n-\n-case \"${target}\" in\n-  hppa*-*-hpux*) libgfor_cv_have_broken_fpclassify=yes ;;\n-  *) libgfor_cv_have_broken_fpclassify=no ;;\n-esac\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-#include <math.h>\n-#include <float.h>\n-int main ()\n-{\n-#ifdef fpclassify\n-#ifdef LDBL_MAX\n-        if (fpclassify(LDBL_MAX) == FP_NAN\n-            || fpclassify(LDBL_MAX) == FP_INFINITE) return 1;\n-#endif\n-#ifdef DBL_MAX\n-        if (fpclassify(DBL_MAX) == FP_NAN\n-            || fpclassify(DBL_MAX) == FP_INFINITE) return 1;\n-#endif\n-#endif\n-return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_run \"$LINENO\"; then :\n-  libgfor_cv_have_broken_fpclassify=no\n-else\n-  libgfor_cv_have_broken_fpclassify=yes\n-fi\n-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n-  conftest.$ac_objext conftest.beam conftest.$ac_ext\n-fi\n-\n-  LIBS=$libgfor_check_for_broken_fpclassify_save_LIBS\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgfor_cv_have_broken_fpclassify\" >&5\n-$as_echo \"$libgfor_cv_have_broken_fpclassify\" >&6; }\n-if test x\"$libgfor_cv_have_broken_fpclassify\" = xyes; then\n-\n-$as_echo \"#define HAVE_BROKEN_FPCLASSIFY 1\" >>confdefs.h\n-\n-fi\n-\n # Check whether the system has a working stat()\n \n   { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the target stat is reliable\" >&5"}, {"sha": "e5517a19587a9f828599c269feef180dad737232", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -450,15 +450,6 @@ AC_CHECK_LIB([m],[catanl],[AC_DEFINE([HAVE_CATANL],[1],[libm includes catanl])])\n # On AIX, clog is present in libm as __clog\n AC_CHECK_LIB([m],[__clog],[AC_DEFINE([HAVE_CLOG],[1],[libm includes clog])])\n \n-# Check for a isfinite macro that works on long doubles.\n-LIBGFOR_CHECK_FOR_BROKEN_ISFINITE\n-\n-# Check for a isnan macro that works on long doubles.\n-LIBGFOR_CHECK_FOR_BROKEN_ISNAN\n-\n-# Check for a fpclassify macro that works on long doubles.\n-LIBGFOR_CHECK_FOR_BROKEN_FPCLASSIFY\n-\n # Check whether the system has a working stat()\n LIBGFOR_CHECK_WORKING_STAT\n "}, {"sha": "20fc7e00edb45f0c49f7855e60e66e78fcf09da0", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -558,7 +558,6 @@ powf (float x, float y)\n }\n #endif\n \n-/* Note that if fpclassify is not defined, then NaN is not handled */\n \n /* Algorithm by Steven G. Kargl.  */\n \n@@ -1854,7 +1853,7 @@ tgamma (double x)\n   n = 0;\n   y = x;\n \n-  if (__builtin_isnan (x))\n+  if (isnan (x))\n     return x;\n \n   if (y <= 0)"}, {"sha": "b9157dfdcebf29b3298334a0e4927d01ade005cf", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -977,7 +977,7 @@ sprintf (buffer, \"%+-#\" STR(MIN_FIELD_WIDTH) \".*\" \\\n {\\\n \tGFC_REAL_ ## x tmp;\\\n \ttmp = * (GFC_REAL_ ## x *)source;\\\n-\tsign_bit = __builtin_signbit (tmp);\\\n+\tsign_bit = signbit (tmp);\\\n \tif (!isfinite (tmp))\\\n \t  { \\\n \t    write_infnan (dtp, f, isnan (tmp), sign_bit);\\"}, {"sha": "8c08c7b3e9f5746c34d5d664bc80f442ca847163", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1012ca4be23e00404c49f8520196af908110a10/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=b1012ca4be23e00404c49f8520196af908110a10", "patch": "@@ -221,42 +221,24 @@ extern int __mingw_snprintf (char *, size_t, const char *, ...)\n #define offsetof(TYPE, MEMBER)  ((size_t) &((TYPE *) 0)->MEMBER)\n #endif\n \n-/* The isfinite macro is only available with C99, but some non-C99\n-   systems still provide fpclassify, and there is a `finite' function\n-   in BSD.\n+/* The C99 classification macros isfinite, isinf, isnan, isnormal\n+   and signbit are broken or inconsistent on quite a few targets.\n+   So, we use GCC's builtins instead.\n \n-   Also, isfinite is broken on Cygwin.\n+   Another advantage for GCC's builtins for these type-generic macros\n+   is that it handles floating-point types that the system headers\n+   may not support (like __float128).  */\n \n-   When isfinite is not available, try to use one of the\n-   alternatives, or bail out.  */\n-\n-#if defined(HAVE_BROKEN_ISFINITE) || defined(__CYGWIN__)\n-#undef isfinite\n-#endif\n-\n-#if defined(HAVE_BROKEN_ISNAN)\n #undef isnan\n-#endif\n-\n-#if defined(HAVE_BROKEN_FPCLASSIFY)\n-#undef fpclassify\n-#endif\n-\n-#if !defined(isfinite)\n-#if !defined(fpclassify)\n-#define isfinite(x) ((x) - (x) == 0)\n-#else\n-#define isfinite(x) (fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)\n-#endif /* !defined(fpclassify) */\n-#endif /* !defined(isfinite)  */\n-\n-#if !defined(isnan)\n-#if !defined(fpclassify)\n-#define isnan(x) ((x) != (x))\n-#else\n-#define isnan(x) (fpclassify(x) == FP_NAN)\n-#endif /* !defined(fpclassify) */\n-#endif /* !defined(isfinite)  */\n+#define isnan(x) __builtin_isnan(x)\n+#undef isfinite\n+#define isfinite(x) __builtin_isfinite(x)\n+#undef isinf\n+#define isinf(x) __builtin_isinf(x)\n+#undef isnormal\n+#define isnormal(x) __builtin_isnormal(x)\n+#undef signbit\n+#define signbit(x) __builtin_signbit(x)\n \n /* TODO: find the C99 version of these an move into above ifdef.  */\n #define REALPART(z) (__real__(z))"}]}