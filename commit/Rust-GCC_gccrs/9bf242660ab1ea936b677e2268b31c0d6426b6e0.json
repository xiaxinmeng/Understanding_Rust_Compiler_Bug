{"sha": "9bf242660ab1ea936b677e2268b31c0d6426b6e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmMjQyNjYwYWIxZWE5MzZiNjc3ZTIyNjhiMzFjMGQ2NDI2YjZlMA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-09-30T22:52:06Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-09-30T22:52:06Z"}, "message": "c-tree.h (readonly_error): Remove.\n\n\t* c-tree.h (readonly_error): Remove.\n\t* c-typeck (enum lvalue_use): New.\n\t(lvalue_or_else, readonly_error): Use it.  All callers changed.\n\t(readonly_error): Make static.\n\ntestsuite:\n\t* gcc.dg/lvalue-2.c: New test.\n\nFrom-SVN: r88362", "tree": {"sha": "25f8a76ac5b8cc292d4354c7806f2ac445779968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25f8a76ac5b8cc292d4354c7806f2ac445779968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bf242660ab1ea936b677e2268b31c0d6426b6e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf242660ab1ea936b677e2268b31c0d6426b6e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bf242660ab1ea936b677e2268b31c0d6426b6e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bf242660ab1ea936b677e2268b31c0d6426b6e0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e12ba8ca90d773132e59adb730b4093a348028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e12ba8ca90d773132e59adb730b4093a348028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e12ba8ca90d773132e59adb730b4093a348028"}], "stats": {"total": 149, "additions": 126, "deletions": 23}, "files": [{"sha": "bac245f32bc3b87b8ed5d88bdcdc8c2fa615e1a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bf242660ab1ea936b677e2268b31c0d6426b6e0", "patch": "@@ -1,3 +1,10 @@\n+2004-09-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-tree.h (readonly_error): Remove.\n+\t* c-typeck (enum lvalue_use): New.\n+\t(lvalue_or_else, readonly_error): Use it.  All callers changed.\n+\t(readonly_error): Make static.\n+\n 2004-09-30  Jan Hubicka  <jh@suse.cz>\n \n \tPR debug/13974"}, {"sha": "f6e195fa101c673e4ef55a2070cbf263234145d0", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=9bf242660ab1ea936b677e2268b31c0d6426b6e0", "patch": "@@ -428,7 +428,6 @@ extern struct c_expr c_expr_sizeof_expr (struct c_expr);\n extern struct c_expr c_expr_sizeof_type (struct c_type_name *);\n extern struct c_expr parser_build_binary_op (enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n-extern void readonly_error (tree, const char *);\n extern tree build_conditional_expr (tree, tree, tree);\n extern tree build_compound_expr (tree, tree);\n extern tree c_cast_expr (struct c_type_name *, tree);"}, {"sha": "70d39389fa8d457e8b49e185fb5a61cc4ad0d98d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 67, "deletions": 22, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=9bf242660ab1ea936b677e2268b31c0d6426b6e0", "patch": "@@ -44,6 +44,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-iterator.h\"\n #include \"tree-gimple.h\"\n \n+/* Places where an lvalue, or modifiable lvalue, may be required.\n+   Used to select diagnostic messages in lvalue_or_else and\n+   readonly_error.  */\n+enum lvalue_use {\n+  lv_assign,\n+  lv_increment,\n+  lv_decrement,\n+  lv_addressof,\n+  lv_asm\n+};\n+\n /* The level of nesting inside \"__alignof__\".  */\n int in_alignof;\n \n@@ -89,7 +100,8 @@ static void add_pending_init (tree, tree);\n static void set_nonincremental_init (void);\n static void set_nonincremental_init_from_string (tree);\n static tree find_init_member (tree);\n-static int lvalue_or_else (tree, const char *);\n+static int lvalue_or_else (tree, enum lvalue_use);\n+static void readonly_error (tree, enum lvalue_use);\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n@@ -2545,16 +2557,16 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t\t   ? \"invalid lvalue in increment\"\n-\t\t\t\t   : \"invalid lvalue in decrement\")))\n+\t\t\t\t   ? lv_increment\n+\t\t\t\t   : lv_decrement)))\n \t  return error_mark_node;\n \n \t/* Report a read-only lvalue.  */\n \tif (TREE_READONLY (arg))\n \t  readonly_error (arg,\n \t\t\t  ((code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t   ? \"increment\" : \"decrement\"));\n+\t\t\t   ? lv_increment : lv_decrement));\n \n \tif (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n \t  val = boolean_increment (code, arg);\n@@ -2591,7 +2603,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n       else if (typecode != FUNCTION_TYPE && !flag\n-\t       && !lvalue_or_else (arg, \"invalid lvalue in unary %<&%>\"))\n+\t       && !lvalue_or_else (arg, lv_addressof))\n \treturn error_mark_node;\n \n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n@@ -2682,40 +2694,73 @@ lvalue_p (tree ref)\n }\n \n /* Return nonzero if REF is an lvalue valid for this language;\n-   otherwise, print an error message and return zero.  MSGID\n-   is a format string which receives no arguments, but in which\n-   formats such as %< and %> may occur.  */\n+   otherwise, print an error message and return zero.  USE says\n+   how the lvalue is being used and so selects the error message.  */\n \n static int\n-lvalue_or_else (tree ref, const char *msgid)\n+lvalue_or_else (tree ref, enum lvalue_use use)\n {\n   int win = lvalue_p (ref);\n \n-  if (! win)\n-    error (msgid);\n+  if (!win)\n+    {\n+      switch (use)\n+\t{\n+\tcase lv_assign:\n+\t  error (\"invalid lvalue in assignment\");\n+\t  break;\n+\tcase lv_increment:\n+\t  error (\"invalid lvalue in increment\");\n+\t  break;\n+\tcase lv_decrement:\n+\t  error (\"invalid lvalue in decrement\");\n+\t  break;\n+\tcase lv_addressof:\n+\t  error (\"invalid lvalue in unary %<&%>\");\n+\t  break;\n+\tcase lv_asm:\n+\t  error (\"invalid lvalue in asm statement\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n \n   return win;\n }\n \n \f\n-/* Warn about storing in something that is `const'.  */\n+/* Give an error for storing in something that is 'const'.  */\n \n-void\n-readonly_error (tree arg, const char *msgid)\n+static void\n+readonly_error (tree arg, enum lvalue_use use)\n {\n+  gcc_assert (use == lv_assign || use == lv_increment || use == lv_decrement);\n+  /* Using this macro rather than (for example) arrays of messages\n+     ensures that all the format strings are checked at compile\n+     time.  */\n+#define READONLY_MSG(A, I, D) (use == lv_assign\t\t\t\t\\\n+\t\t\t       ? (A)\t\t\t\t\t\\\n+\t\t\t       : (use == lv_increment ? (I) : (D)))\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\treadonly_error (TREE_OPERAND (arg, 0), msgid);\n+\treadonly_error (TREE_OPERAND (arg, 0), use);\n       else\n-\terror (\"%s of read-only member %qs\", _(msgid),\n+\terror (READONLY_MSG (N_(\"assignment of read-only member %qs\"),\n+\t\t\t     N_(\"increment of read-only member %qs\"),\n+\t\t\t     N_(\"decrement of read-only member %qs\")),\n \t       IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (arg, 1))));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n-    error (\"%s of read-only variable %qs\", _(msgid),\n+    error (READONLY_MSG (N_(\"assignment of read-only variable %qs\"),\n+\t\t\t N_(\"increment of read-only variable %qs\"),\n+\t\t\t N_(\"decrement of read-only variable %qs\")),\n \t   IDENTIFIER_POINTER (DECL_NAME (arg)));\n   else\n-    error (\"%s of read-only location\", _(msgid));\n+    error (READONLY_MSG (N_(\"assignment of read-only location\"),\n+\t\t\t N_(\"increment of read-only location\"),\n+\t\t\t N_(\"decrement of read-only location\")));\n }\n \f\n /* Mark EXP saying that we need to be able to take the\n@@ -3283,16 +3328,16 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n     }\n \n-  if (!lvalue_or_else (lhs, \"invalid lvalue in assignment\"))\n+  if (!lvalue_or_else (lhs, lv_assign))\n     return error_mark_node;\n \n-  /* Warn about storing in something that is `const'.  */\n+  /* Give an error for storing in something that is 'const'.  */\n \n   if (TREE_READONLY (lhs) || TYPE_READONLY (lhstype)\n       || ((TREE_CODE (lhstype) == RECORD_TYPE\n \t   || TREE_CODE (lhstype) == UNION_TYPE)\n \t  && C_TYPE_FIELDS_READONLY (lhstype)))\n-    readonly_error (lhs, \"assignment\");\n+    readonly_error (lhs, lv_assign);\n \n   /* If storing into a structure or union member,\n      it has probably been given type `int'.\n@@ -6249,7 +6294,7 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n       tree output = TREE_VALUE (tail);\n       STRIP_NOPS (output);\n       TREE_VALUE (tail) = output;\n-      lvalue_or_else (output, \"invalid lvalue in asm statement\");\n+      lvalue_or_else (output, lv_asm);\n \n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n "}, {"sha": "7fb09784030751ff101f384bc9e686edba537989", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bf242660ab1ea936b677e2268b31c0d6426b6e0", "patch": "@@ -1,3 +1,7 @@\n+2004-09-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.dg/lvalue-2.c: New test.\n+\n 2004-09-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/17730"}, {"sha": "5ad648eece9376b1a623cc7e00ff7fb373e288fd", "filename": "gcc/testsuite/gcc.dg/lvalue-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bf242660ab1ea936b677e2268b31c0d6426b6e0/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flvalue-2.c?ref=9bf242660ab1ea936b677e2268b31c0d6426b6e0", "patch": "@@ -0,0 +1,48 @@\n+/* Test diagnostic messages for invalid lvalues and non-modifiable\n+   lvalues.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int a, b;\n+\n+void\n+f0 (void)\n+{\n+  (a+b) = 1; /* { dg-error \"error: invalid lvalue in assignment\" } */\n+  (a+b)++; /* { dg-error \"error: invalid lvalue in increment\" } */\n+  ++(a+b); /* { dg-error \"error: invalid lvalue in increment\" } */\n+  (a+b)--; /* { dg-error \"error: invalid lvalue in decrement\" } */\n+  --(a+b); /* { dg-error \"error: invalid lvalue in decrement\" } */\n+  &(a+b); /* { dg-error \"error: invalid lvalue in unary '&'\" } */\n+}\n+\n+const int c;\n+const struct { int x; } d;\n+struct { const int x; } e;\n+const int *f;\n+\n+void\n+f1 (void)\n+{\n+  c = 1; /* { dg-error \"error: assignment of read-only variable 'c'\" } */\n+  d.x = 1; /* { dg-error \"error: assignment of read-only variable 'd'\" } */\n+  e.x = 1; /* { dg-error \"error: assignment of read-only member 'x'\" } */\n+  *f = 1; /* { dg-error \"error: assignment of read-only location\" } */\n+  c++; /* { dg-error \"error: increment of read-only variable 'c'\" } */\n+  d.x++; /* { dg-error \"error: increment of read-only variable 'd'\" } */\n+  e.x++; /* { dg-error \"error: increment of read-only member 'x'\" } */\n+  (*f)++; /* { dg-error \"error: increment of read-only location\" } */\n+  ++c; /* { dg-error \"error: increment of read-only variable 'c'\" } */\n+  ++d.x; /* { dg-error \"error: increment of read-only variable 'd'\" } */\n+  ++e.x; /* { dg-error \"error: increment of read-only member 'x'\" } */\n+  ++(*f); /* { dg-error \"error: increment of read-only location\" } */\n+  c--; /* { dg-error \"error: decrement of read-only variable 'c'\" } */\n+  d.x--; /* { dg-error \"error: decrement of read-only variable 'd'\" } */\n+  e.x--; /* { dg-error \"error: decrement of read-only member 'x'\" } */\n+  (*f)--; /* { dg-error \"error: decrement of read-only location\" } */\n+  --c; /* { dg-error \"error: decrement of read-only variable 'c'\" } */\n+  --d.x; /* { dg-error \"error: decrement of read-only variable 'd'\" } */\n+  --e.x; /* { dg-error \"error: decrement of read-only member 'x'\" } */\n+  --(*f); /* { dg-error \"error: decrement of read-only location\" } */\n+}"}]}