{"sha": "4c85ff754927c518ed97da5e0221eeea742c9aa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM4NWZmNzU0OTI3YzUxOGVkOTdkYTVlMDIyMWVlZWE3NDJjOWFhNw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T15:41:30Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-23T14:26:16Z"}, "message": "Split gimple-range into gimple-range-fold and gimple-range.\n\nSplit the fold_using_range functions from gimple-range into gimple-range-fold.\nAlso move the gimple_range_calc* routines into gimple-range-gori.\n\n\t* Makefile.in (OBJS): Add gimple-range-fold.o\n\t* gimple-range-fold.cc: New.\n\t* gimple-range-fold.h: New.\n\t* gimple-range-gori.cc (gimple_range_calc_op1): Move to here.\n\t(gimple_range_calc_op2): Ditto.\n\t* gimple-range-gori.h: Move prototypes to here.\n\t* gimple-range.cc: Adjust include files.\n\t(fur_source:fur_source): Relocate to gimple-range-fold.cc.\n\t(fur_source::get_operand): Ditto.\n\t(fur_source::get_phi_operand): Ditto.\n\t(fur_source::query_relation): Ditto.\n\t(fur_source::register_relation): Ditto.\n\t(class fur_edge): Ditto.\n\t(fur_edge::fur_edge): Ditto.\n\t(fur_edge::get_operand): Ditto.\n\t(fur_edge::get_phi_operand): Ditto.\n\t(fur_stmt::fur_stmt): Ditto.\n\t(fur_stmt::get_operand): Ditto.\n\t(fur_stmt::get_phi_operand): Ditto.\n\t(fur_stmt::query_relation): Ditto.\n\t(class fur_depend): Relocate to gimple-range-fold.h.\n\t(fur_depend::fur_depend): Relocate to gimple-range-fold.cc.\n\t(fur_depend::register_relation): Ditto.\n\t(fur_depend::register_relation): Ditto.\n\t(class fur_list): Ditto.\n\t(fur_list::fur_list): Ditto.\n\t(fur_list::get_operand): Ditto.\n\t(fur_list::get_phi_operand): Ditto.\n\t(fold_range): Ditto.\n\t(adjust_pointer_diff_expr): Ditto.\n\t(gimple_range_adjustment): Ditto.\n\t(gimple_range_base_of_assignment): Ditto.\n\t(gimple_range_operand1): Ditto.\n\t(gimple_range_operand2): Ditto.\n\t(gimple_range_calc_op1): Relocate to gimple-range-gori.cc.\n\t(gimple_range_calc_op2): Ditto.\n\t(fold_using_range::fold_stmt): Relocate to gimple-range-fold.cc.\n\t(fold_using_range::range_of_range_op): Ditto.\n\t(fold_using_range::range_of_address): Ditto.\n\t(fold_using_range::range_of_phi): Ditto.\n\t(fold_using_range::range_of_call): Ditto.\n\t(fold_using_range::range_of_builtin_ubsan_call): Ditto.\n\t(fold_using_range::range_of_builtin_call): Ditto.\n\t(fold_using_range::range_of_cond_expr): Ditto.\n\t(fold_using_range::range_of_ssa_name_with_loop_info): Ditto.\n\t(fold_using_range::relation_fold_and_or): Ditto.\n\t(fold_using_range::postfold_gcond_edges): Ditto.\n\t* gimple-range.h: Add gimple-range-fold.h to include files. Change\n\tGIMPLE_RANGE_STMT_H to GIMPLE_RANGE_H.\n\t(gimple_range_handler): Relocate to gimple-range-fold.h.\n\t(gimple_range_ssa_p): Ditto.\n\t(range_compatible_p): Ditto.\n\t(class fur_source): Ditto.\n\t(class fur_stmt): Ditto.\n\t(class fold_using_range): Ditto.\n\t(gimple_range_calc_op1): Relocate to gimple-range-gori.h\n\t(gimple_range_calc_op2): Ditto.", "tree": {"sha": "79cdc22d855c971de3847197e544f3914cee985e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79cdc22d855c971de3847197e544f3914cee985e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c85ff754927c518ed97da5e0221eeea742c9aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c85ff754927c518ed97da5e0221eeea742c9aa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c85ff754927c518ed97da5e0221eeea742c9aa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c85ff754927c518ed97da5e0221eeea742c9aa7/comments", "author": null, "committer": null, "parents": [{"sha": "a03e944e92ee51ae583382079d4739b64bd93b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03e944e92ee51ae583382079d4739b64bd93b35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03e944e92ee51ae583382079d4739b64bd93b35"}], "stats": {"total": 3093, "additions": 1574, "deletions": 1519}, "files": [{"sha": "d32de22e4f27bc6fe5a1afbe5a79943acdd27417", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -1398,6 +1398,7 @@ OBJS = \\\n \tgimple-range.o \\\n \tgimple-range-cache.o \\\n \tgimple-range-edge.o \\\n+\tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-evrp.o \\"}, {"sha": "583348e6e3654d4af76086ad56fdb95088f605e2", "filename": "gcc/gimple-range-fold.cc", "status": "added", "additions": 1331, "deletions": 0, "changes": 1331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -0,0 +1,1331 @@\n+/* Code for GIMPLE range related routines.\n+   Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"insn-codes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"optabs-tree.h\"\n+#include \"gimple-fold.h\"\n+#include \"wide-int.h\"\n+#include \"fold-const.h\"\n+#include \"case-cfn-macros.h\"\n+#include \"omp-general.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"vr-values.h\"\n+#include \"range.h\"\n+#include \"value-query.h\"\n+#include \"range-op.h\"\n+#include \"gimple-range-fold.h\"\n+#include \"gimple-range-edge.h\"\n+#include \"gimple-range-gori.h\"\n+// Construct a fur_source, and set the m_query field.\n+\n+fur_source::fur_source (range_query *q)\n+{\n+  if (q)\n+    m_query = q;\n+  else if (cfun)\n+    m_query = get_range_query (cfun);\n+  else\n+    m_query = get_global_range_query ();\n+  m_gori = NULL;\n+}\n+\n+// Invoke range_of_expr on EXPR.\n+\n+bool\n+fur_source::get_operand (irange &r, tree expr)\n+{\n+  return m_query->range_of_expr (r, expr);\n+}\n+\n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_source::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  return m_query->range_on_edge (r, e, expr);\n+}\n+\n+// Default is no relation.\n+\n+relation_kind\n+fur_source::query_relation (tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t    tree op2 ATTRIBUTE_UNUSED)\n+{\n+  return VREL_NONE;\n+}\n+\n+// Default registers nothing.\n+\n+void\n+fur_source::register_relation (gimple *s ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n+\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+// Default registers nothing.\n+\n+void\n+fur_source::register_relation (edge e ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n+\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n+\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+// This version of fur_source will pick a range up off an edge.\n+\n+class fur_edge : public fur_source\n+{\n+public:\n+  fur_edge (edge e, range_query *q = NULL);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+private:\n+  edge m_edge;\n+};\n+\n+// Instantiate an edge based fur_source.\n+\n+inline\n+fur_edge::fur_edge (edge e, range_query *q) : fur_source (q)\n+{\n+  m_edge = e;\n+}\n+\n+// Get the value of EXPR on edge m_edge.\n+\n+bool\n+fur_edge::get_operand (irange &r, tree expr)\n+{\n+  return m_query->range_on_edge (r, m_edge, expr);\n+}\n+\n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_edge::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  // Edge to edge recalculations not supoprted yet, until we sort it out.\n+  gcc_checking_assert (e == m_edge);\n+  return m_query->range_on_edge (r, e, expr);\n+}\n+\n+// Instantiate a stmt based fur_source.\n+\n+fur_stmt::fur_stmt (gimple *s, range_query *q) : fur_source (q)\n+{\n+  m_stmt = s;\n+}\n+\n+// Retreive range of EXPR as it occurs as a use on stmt M_STMT.\n+\n+bool\n+fur_stmt::get_operand (irange &r, tree expr)\n+{\n+  return m_query->range_of_expr (r, expr, m_stmt);\n+}\n+\n+// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n+// range_query to get the range on the edge.\n+\n+bool\n+fur_stmt::get_phi_operand (irange &r, tree expr, edge e)\n+{\n+  // Pick up the range of expr from edge E.\n+  fur_edge e_src (e, m_query);\n+  return e_src.get_operand (r, expr);\n+}\n+\n+// Return relation based from m_stmt.\n+\n+relation_kind\n+fur_stmt::query_relation (tree op1, tree op2)\n+{\n+  return m_query->query_relation (m_stmt, op1, op2);\n+}\n+\n+// Instantiate a stmt based fur_source with a GORI object.\n+\n+\n+fur_depend::fur_depend (gimple *s, gori_compute *gori, range_query *q)\n+  : fur_stmt (s, q)\n+{\n+  gcc_checking_assert (gori);\n+  m_gori = gori;\n+  // Set relations if there is an oracle in the range_query.\n+  // This will enable registering of relationships as they are discovered.\n+  m_oracle = q->oracle ();\n+\n+}\n+\n+// Register a relation on a stmt if there is an oracle.\n+\n+void\n+fur_depend::register_relation (gimple *s, relation_kind k, tree op1, tree op2)\n+{\n+  if (m_oracle)\n+    m_oracle->register_relation (s, k, op1, op2);\n+}\n+\n+// Register a relation on an edge if there is an oracle.\n+\n+void\n+fur_depend::register_relation (edge e, relation_kind k, tree op1, tree op2)\n+{\n+  if (m_oracle)\n+    m_oracle->register_relation (e, k, op1, op2);\n+}\n+\n+// This version of fur_source will pick a range up from a list of ranges\n+// supplied by the caller.\n+\n+class fur_list : public fur_source\n+{\n+public:\n+  fur_list (irange &r1);\n+  fur_list (irange &r1, irange &r2);\n+  fur_list (unsigned num, irange *list);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+private:\n+  int_range_max m_local[2];\n+  irange *m_list;\n+  unsigned m_index;\n+  unsigned m_limit;\n+};\n+\n+// One range supplied for unary operations.\n+\n+fur_list::fur_list (irange &r1) : fur_source (NULL)\n+{\n+  m_list = m_local;\n+  m_index = 0;\n+  m_limit = 1;\n+  m_local[0] = r1;\n+}\n+\n+// Two ranges supplied for binary operations.\n+\n+fur_list::fur_list (irange &r1, irange &r2) : fur_source (NULL)\n+{\n+  m_list = m_local;\n+  m_index = 0;\n+  m_limit = 2;\n+  m_local[0] = r1;\n+  m_local[0] = r2;\n+}\n+\n+// Arbitrary number of ranges in a vector.\n+\n+fur_list::fur_list (unsigned num, irange *list) : fur_source (NULL)\n+{\n+  m_list = list;\n+  m_index = 0;\n+  m_limit = num;\n+}\n+\n+// Get the next operand from the vector, ensure types are compatible.\n+\n+bool\n+fur_list::get_operand (irange &r, tree expr)\n+{\n+  if (m_index >= m_limit)\n+    return m_query->range_of_expr (r, expr);\n+  r = m_list[m_index++];\n+  gcc_checking_assert (range_compatible_p (TREE_TYPE (expr), r.type ()));\n+  return true;\n+}\n+\n+// This will simply pick the next operand from the vector.\n+bool\n+fur_list::get_phi_operand (irange &r, tree expr, edge e ATTRIBUTE_UNUSED)\n+{\n+  return get_operand (r, expr);\n+}\n+\n+// Fold stmt S into range R using R1 as the first operand.\n+\n+bool\n+fold_range (irange &r, gimple *s, irange &r1)\n+{\n+  fold_using_range f;\n+  fur_list src (r1);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Fold stmt S into range R using R1  and R2 as the first two operands.\n+\n+bool\n+fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n+{\n+  fold_using_range f;\n+  fur_list src (r1, r2);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Fold stmt S into range R using NUM_ELEMENTS from VECTOR as the initial\n+// operands encountered.\n+\n+bool\n+fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector)\n+{\n+  fold_using_range f;\n+  fur_list src (num_elements, vector);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Fold stmt S into range R using range query Q.\n+\n+bool\n+fold_range (irange &r, gimple *s, range_query *q)\n+{\n+  fold_using_range f;\n+  fur_stmt src (s, q);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n+\n+bool\n+fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n+{\n+  fold_using_range f;\n+  fur_edge src (on_edge, q);\n+  return f.fold_stmt (r, s, src);\n+}\n+\n+// -------------------------------------------------------------------------\n+\n+// Adjust the range for a pointer difference where the operands came\n+// from a memchr.\n+//\n+// This notices the following sequence:\n+//\n+//\tdef = __builtin_memchr (arg, 0, sz)\n+//\tn = def - arg\n+//\n+// The range for N can be narrowed to [0, PTRDIFF_MAX - 1].\n+\n+static void\n+adjust_pointer_diff_expr (irange &res, const gimple *diff_stmt)\n+{\n+  tree op0 = gimple_assign_rhs1 (diff_stmt);\n+  tree op1 = gimple_assign_rhs2 (diff_stmt);\n+  tree op0_ptype = TREE_TYPE (TREE_TYPE (op0));\n+  tree op1_ptype = TREE_TYPE (TREE_TYPE (op1));\n+  gimple *call;\n+\n+  if (TREE_CODE (op0) == SSA_NAME\n+      && TREE_CODE (op1) == SSA_NAME\n+      && (call = SSA_NAME_DEF_STMT (op0))\n+      && is_gimple_call (call)\n+      && gimple_call_builtin_p (call, BUILT_IN_MEMCHR)\n+      && TYPE_MODE (op0_ptype) == TYPE_MODE (char_type_node)\n+      && TYPE_PRECISION (op0_ptype) == TYPE_PRECISION (char_type_node)\n+      && TYPE_MODE (op1_ptype) == TYPE_MODE (char_type_node)\n+      && TYPE_PRECISION (op1_ptype) == TYPE_PRECISION (char_type_node)\n+      && gimple_call_builtin_p (call, BUILT_IN_MEMCHR)\n+      && vrp_operand_equal_p (op1, gimple_call_arg (call, 0))\n+      && integer_zerop (gimple_call_arg (call, 1)))\n+    {\n+      tree max = vrp_val_max (ptrdiff_type_node);\n+      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n+      tree expr_type = gimple_expr_type (diff_stmt);\n+      tree range_min = build_zero_cst (expr_type);\n+      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n+      int_range<2> r (range_min, range_max);\n+      res.intersect (r);\n+    }\n+}\n+\n+// This function looks for situations when walking the use/def chains\n+// may provide additonal contextual range information not exposed on\n+// this statement.  Like knowing the IMAGPART return value from a\n+// builtin function is a boolean result.\n+\n+// We should rework how we're called, as we have an op_unknown entry\n+// for IMAGPART_EXPR and POINTER_DIFF_EXPR in range-ops just so this\n+// function gets called.\n+\n+static void\n+gimple_range_adjustment (irange &res, const gimple *stmt)\n+{\n+  switch (gimple_expr_code (stmt))\n+    {\n+    case POINTER_DIFF_EXPR:\n+      adjust_pointer_diff_expr (res, stmt);\n+      return;\n+\n+    case IMAGPART_EXPR:\n+      {\n+\ttree name = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+\tif (TREE_CODE (name) == SSA_NAME)\n+\t  {\n+\t    gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\t    if (def_stmt && is_gimple_call (def_stmt)\n+\t\t&& gimple_call_internal_p (def_stmt))\n+\t      {\n+\t\tswitch (gimple_call_internal_fn (def_stmt))\n+\t\t  {\n+\t\t  case IFN_ADD_OVERFLOW:\n+\t\t  case IFN_SUB_OVERFLOW:\n+\t\t  case IFN_MUL_OVERFLOW:\n+\t\t  case IFN_ATOMIC_COMPARE_EXCHANGE:\n+\t\t    {\n+\t\t      int_range<2> r;\n+\t\t      r.set_varying (boolean_type_node);\n+\t\t      tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n+\t\t      range_cast (r, type);\n+\t\t      res.intersect (r);\n+\t\t    }\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+// Return the base of the RHS of an assignment.\n+\n+static tree\n+gimple_range_base_of_assignment (const gimple *stmt)\n+{\n+  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n+  tree op1 = gimple_assign_rhs1 (stmt);\n+  if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+    return get_base_address (TREE_OPERAND (op1, 0));\n+  return op1;\n+}\n+\n+// Return the first operand of this statement if it is a valid operand\n+// supported by ranges, otherwise return NULL_TREE.  Special case is\n+// &(SSA_NAME expr), return the SSA_NAME instead of the ADDR expr.\n+\n+tree\n+gimple_range_operand1 (const gimple *stmt)\n+{\n+  gcc_checking_assert (gimple_range_handler (stmt));\n+\n+  switch (gimple_code (stmt))\n+    {\n+      case GIMPLE_COND:\n+\treturn gimple_cond_lhs (stmt);\n+      case GIMPLE_ASSIGN:\n+\t{\n+\t  tree base = gimple_range_base_of_assignment (stmt);\n+\t  if (base && TREE_CODE (base) == MEM_REF)\n+\t    {\n+\t      // If the base address is an SSA_NAME, we return it\n+\t      // here.  This allows processing of the range of that\n+\t      // name, while the rest of the expression is simply\n+\t      // ignored.  The code in range_ops will see the\n+\t      // ADDR_EXPR and do the right thing.\n+\t      tree ssa = TREE_OPERAND (base, 0);\n+\t      if (TREE_CODE (ssa) == SSA_NAME)\n+\t\treturn ssa;\n+\t    }\n+\t  return base;\n+\t}\n+      default:\n+\tbreak;\n+    }\n+  return NULL;\n+}\n+\n+// Return the second operand of statement STMT, otherwise return NULL_TREE.\n+\n+tree\n+gimple_range_operand2 (const gimple *stmt)\n+{\n+  gcc_checking_assert (gimple_range_handler (stmt));\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_COND:\n+      return gimple_cond_rhs (stmt);\n+    case GIMPLE_ASSIGN:\n+      if (gimple_num_ops (stmt) >= 3)\n+\treturn gimple_assign_rhs2 (stmt);\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+// Calculate a range for statement S and return it in R. If NAME is provided it\n+// represents the SSA_NAME on the LHS of the statement. It is only required\n+// if there is more than one lhs/output.  If a range cannot\n+// be calculated, return false.\n+\n+bool\n+fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n+{\n+  bool res = false;\n+  // If name and S are specified, make sure it is an LHS of S.\n+  gcc_checking_assert (!name || !gimple_get_lhs (s) ||\n+\t\t       name == gimple_get_lhs (s));\n+\n+  if (!name)\n+    name = gimple_get_lhs (s);\n+\n+  // Process addresses.\n+  if (gimple_code (s) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (s) == ADDR_EXPR)\n+    return range_of_address (r, s, src);\n+\n+  if (gimple_range_handler (s))\n+    res = range_of_range_op (r, s, src);\n+  else if (is_a<gphi *>(s))\n+    res = range_of_phi (r, as_a<gphi *> (s), src);\n+  else if (is_a<gcall *>(s))\n+    res = range_of_call (r, as_a<gcall *> (s), src);\n+  else if (is_a<gassign *> (s) && gimple_assign_rhs_code (s) == COND_EXPR)\n+    res = range_of_cond_expr (r, as_a<gassign *> (s), src);\n+\n+  if (!res)\n+    {\n+      // If no name is specified, try the expression kind.\n+      if (!name)\n+\t{\n+\t  tree t = gimple_expr_type (s);\n+\t  if (!irange::supports_type_p (t))\n+\t    return false;\n+\t  r.set_varying (t);\n+\t  return true;\n+\t}\n+      if (!gimple_range_ssa_p (name))\n+\treturn false;\n+      // We don't understand the stmt, so return the global range.\n+      r = gimple_range_global (name);\n+      return true;\n+    }\n+\n+  if (r.undefined_p ())\n+    return true;\n+\n+  // We sometimes get compatible types copied from operands, make sure\n+  // the correct type is being returned.\n+  if (name && TREE_TYPE (name) != r.type ())\n+    {\n+      gcc_checking_assert (range_compatible_p (r.type (), TREE_TYPE (name)));\n+      range_cast (r, TREE_TYPE (name));\n+    }\n+  return true;\n+}\n+\n+// Calculate a range for range_op statement S and return it in R.  If any\n+// If a range cannot be calculated, return false.\n+\n+bool\n+fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n+{\n+  int_range_max range1, range2;\n+  tree type = gimple_expr_type (s);\n+  range_operator *handler = gimple_range_handler (s);\n+  gcc_checking_assert (handler);\n+  gcc_checking_assert (irange::supports_type_p (type));\n+\n+  tree lhs = gimple_get_lhs (s);\n+  tree op1 = gimple_range_operand1 (s);\n+  tree op2 = gimple_range_operand2 (s);\n+\n+  if (src.get_operand (range1, op1))\n+    {\n+      if (!op2)\n+\t{\n+\t  // Fold range, and register any dependency if available.\n+\t  int_range<2> r2 (type);\n+\t  handler->fold_range (r, type, range1, r2);\n+\t  if (lhs && gimple_range_ssa_p (op1))\n+\t    {\n+\t      if (src.gori ())\n+\t\tsrc.gori ()->register_dependency (lhs, op1);\n+\t      relation_kind rel;\n+\t      rel = handler->lhs_op1_relation (r, range1, range1);\n+\t      if (rel != VREL_NONE)\n+\t\tsrc.register_relation (s, rel, lhs, op1);\n+\t    }\n+\t}\n+      else if (src.get_operand (range2, op2))\n+\t{\n+\t  relation_kind rel = src.query_relation (op1, op2);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_NONE)\n+\t    {\n+\t      fprintf (dump_file, \" folding with relation \");\n+\t      print_relation (dump_file, rel);\n+\t      fputc ('\\n', dump_file);\n+\t    }\n+\t  // Fold range, and register any dependency if available.\n+\t  handler->fold_range (r, type, range1, range2, rel);\n+\t  relation_fold_and_or (r, s, src);\n+\t  if (lhs)\n+\t    {\n+\t      if (src.gori ())\n+\t\t{\n+\t\t  src.gori ()->register_dependency (lhs, op1);\n+\t\t  src.gori ()->register_dependency (lhs, op2);\n+\t\t}\n+\t      if (gimple_range_ssa_p (op1))\n+\t\t{\n+\t\t  rel = handler->lhs_op1_relation (r, range1, range2);\n+\t\t  if (rel != VREL_NONE)\n+\t\t    src.register_relation (s, rel, lhs, op1);\n+\t\t}\n+\t      if (gimple_range_ssa_p (op2))\n+\t\t{\n+\t\t  rel= handler->lhs_op2_relation (r, range1, range2);\n+\t\t  if (rel != VREL_NONE)\n+\t\t    src.register_relation (s, rel, lhs, op2);\n+\t\t}\n+\t    }\n+\t  else if (is_a<gcond *> (s))\n+\t    postfold_gcond_edges (as_a<gcond *> (s), src);\n+\t}\n+      else\n+\tr.set_varying (type);\n+    }\n+  else\n+    r.set_varying (type);\n+  // Make certain range-op adjustments that aren't handled any other way.\n+  gimple_range_adjustment (r, s);\n+  return true;\n+}\n+\n+// Calculate the range of an assignment containing an ADDR_EXPR.\n+// Return the range in R.\n+// If a range cannot be calculated, set it to VARYING and return true.\n+\n+bool\n+fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n+{\n+  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n+  gcc_checking_assert (gimple_assign_rhs_code (stmt) == ADDR_EXPR);\n+\n+  bool strict_overflow_p;\n+  tree expr = gimple_assign_rhs1 (stmt);\n+  poly_int64 bitsize, bitpos;\n+  tree offset;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep;\n+  tree base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n+\t\t\t\t   &bitpos, &offset, &mode, &unsignedp,\n+\t\t\t\t   &reversep, &volatilep);\n+\n+\n+  if (base != NULL_TREE\n+      && TREE_CODE (base) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n+    {\n+      tree ssa = TREE_OPERAND (base, 0);\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && gimple_range_ssa_p (ssa) && src.gori ())\n+\tsrc.gori ()->register_dependency (lhs, ssa);\n+      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n+      src.get_operand (r, ssa);\n+      range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+\n+      poly_offset_int off = 0;\n+      bool off_cst = false;\n+      if (offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)\n+\t{\n+\t  off = mem_ref_offset (base);\n+\t  if (offset)\n+\t    off += poly_offset_int::from (wi::to_poly_wide (offset),\n+\t\t\t\t\t  SIGNED);\n+\t  off <<= LOG2_BITS_PER_UNIT;\n+\t  off += bitpos;\n+\t  off_cst = true;\n+\t}\n+      /* If &X->a is equal to X, the range of X is the result.  */\n+      if (off_cst && known_eq (off, 0))\n+\t  return true;\n+      else if (flag_delete_null_pointer_checks\n+\t       && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n+\t{\n+\t /* For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n+\t allow going from non-NULL pointer to NULL.  */\n+\t   if(!range_includes_zero_p (&r))\n+\t    return true;\n+\t}\n+      /* If MEM_REF has a \"positive\" offset, consider it non-NULL\n+\t always, for -fdelete-null-pointer-checks also \"negative\"\n+\t ones.  Punt for unknown offsets (e.g. variable ones).  */\n+      if (!TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n+\t  && off_cst\n+\t  && known_ne (off, 0)\n+\t  && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n+\t{\n+\t  r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+\t  return true;\n+\t}\n+      r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      return true;\n+    }\n+\n+  // Handle \"= &a\".\n+  if (tree_single_nonzero_warnv_p (expr, &strict_overflow_p))\n+    {\n+      r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+      return true;\n+    }\n+\n+  // Otherwise return varying.\n+  r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n+  return true;\n+}\n+\n+// Calculate a range for phi statement S and return it in R.\n+// If a range cannot be calculated, return false.\n+\n+bool\n+fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n+{\n+  tree phi_def = gimple_phi_result (phi);\n+  tree type = TREE_TYPE (phi_def);\n+  int_range_max arg_range;\n+  unsigned x;\n+\n+  if (!irange::supports_type_p (type))\n+    return false;\n+\n+  // Start with an empty range, unioning in each argument's range.\n+  r.set_undefined ();\n+  for (x = 0; x < gimple_phi_num_args (phi); x++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, x);\n+      edge e = gimple_phi_arg_edge (phi, x);\n+\n+      // Register potential dependencies for stale value tracking.\n+      if (gimple_range_ssa_p (arg) && src.gori ())\n+\tsrc.gori ()->register_dependency (phi_def, arg);\n+\n+      // Get the range of the argument on its edge.\n+      src.get_phi_operand (arg_range, arg, e);\n+      // If we're recomputing the argument elsewhere, try to refine it.\n+      r.union_ (arg_range);\n+      // Once the value reaches varying, stop looking.\n+      if (r.varying_p ())\n+\tbreak;\n+    }\n+\n+  // If SCEV is available, query if this PHI has any knonwn values.\n+  if (scev_initialized_p () && !POINTER_TYPE_P (TREE_TYPE (phi_def)))\n+    {\n+      value_range loop_range;\n+      class loop *l = loop_containing_stmt (phi);\n+      if (l && loop_outer (l))\n+\t{\n+\t  range_of_ssa_name_with_loop_info (loop_range, phi_def, l, phi, src);\n+\t  if (!loop_range.varying_p ())\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"   Loops range found for \");\n+\t\t  print_generic_expr (dump_file, phi_def, TDF_SLIM);\n+\t\t  fprintf (dump_file, \": \");\n+\t\t  loop_range.dump (dump_file);\n+\t\t  fprintf (dump_file, \" and calculated range :\");\n+\t\t  r.dump (dump_file);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      r.intersect (loop_range);\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+// Calculate a range for call statement S and return it in R.\n+// If a range cannot be calculated, return false.\n+\n+bool\n+fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n+{\n+  tree type = gimple_call_return_type (call);\n+  tree lhs = gimple_call_lhs (call);\n+  bool strict_overflow_p;\n+\n+  if (!irange::supports_type_p (type))\n+    return false;\n+\n+  if (range_of_builtin_call (r, call, src))\n+    ;\n+  else if (gimple_stmt_nonnegative_warnv_p (call, &strict_overflow_p))\n+    r.set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n+  else if (gimple_call_nonnull_result_p (call)\n+\t   || gimple_call_nonnull_arg (call))\n+    r = range_nonzero (type);\n+  else\n+    r.set_varying (type);\n+\n+  // If there is an LHS, intersect that with what is known.\n+  if (lhs)\n+    {\n+      value_range def;\n+      def = gimple_range_global (lhs);\n+      r.intersect (def);\n+    }\n+  return true;\n+}\n+\n+// Return the range of a __builtin_ubsan* in CALL and set it in R.\n+// CODE is the type of ubsan call (PLUS_EXPR, MINUS_EXPR or\n+// MULT_EXPR).\n+\n+void\n+fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n+\t\t\t\t\t       tree_code code, fur_source &src)\n+{\n+  gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n+\t\t       || code == MULT_EXPR);\n+  tree type = gimple_call_return_type (call);\n+  range_operator *op = range_op_handler (code, type);\n+  gcc_checking_assert (op);\n+  int_range_max ir0, ir1;\n+  tree arg0 = gimple_call_arg (call, 0);\n+  tree arg1 = gimple_call_arg (call, 1);\n+  src.get_operand (ir0, arg0);\n+  src.get_operand (ir1, arg1);\n+\n+  bool saved_flag_wrapv = flag_wrapv;\n+  // Pretend the arithmetic is wrapping.  If there is any overflow,\n+  // we'll complain, but will actually do wrapping operation.\n+  flag_wrapv = 1;\n+  op->fold_range (r, type, ir0, ir1);\n+  flag_wrapv = saved_flag_wrapv;\n+\n+  // If for both arguments vrp_valueize returned non-NULL, this should\n+  // have been already folded and if not, it wasn't folded because of\n+  // overflow.  Avoid removing the UBSAN_CHECK_* calls in that case.\n+  if (r.singleton_p ())\n+    r.set_varying (type);\n+}\n+\n+// For a builtin in CALL, return a range in R if known and return\n+// TRUE.  Otherwise return FALSE.\n+\n+bool\n+fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n+\t\t\t\t\t fur_source &src)\n+{\n+  combined_fn func = gimple_call_combined_fn (call);\n+  if (func == CFN_LAST)\n+    return false;\n+\n+  tree type = gimple_call_return_type (call);\n+  tree arg;\n+  int mini, maxi, zerov = 0, prec;\n+  scalar_int_mode mode;\n+\n+  switch (func)\n+    {\n+    case CFN_BUILT_IN_CONSTANT_P:\n+      if (cfun->after_inlining)\n+\t{\n+\t  r.set_zero (type);\n+\t  // r.equiv_clear ();\n+\t  return true;\n+\t}\n+      arg = gimple_call_arg (call, 0);\n+      if (src.get_operand (r, arg) && r.singleton_p ())\n+\t{\n+\t  r.set (build_one_cst (type), build_one_cst (type));\n+\t  return true;\n+\t}\n+      break;\n+\n+    CASE_CFN_FFS:\n+    CASE_CFN_POPCOUNT:\n+      // __builtin_ffs* and __builtin_popcount* return [0, prec].\n+      arg = gimple_call_arg (call, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec;\n+      src.get_operand (r, arg);\n+      // If arg is non-zero, then ffs or popcount are non-zero.\n+      if (!range_includes_zero_p (&r))\n+\tmini = 1;\n+      // If some high bits are known to be zero, decrease the maximum.\n+      if (!r.undefined_p ())\n+\t{\n+\t  if (TYPE_SIGN (r.type ()) == SIGNED)\n+\t    range_cast (r, unsigned_type_for (r.type ()));\n+\t  wide_int max = r.upper_bound ();\n+\t  maxi = wi::floor_log2 (max) + 1;\n+\t}\n+      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+      return true;\n+\n+    CASE_CFN_PARITY:\n+      r.set (build_zero_cst (type), build_one_cst (type));\n+      return true;\n+\n+    CASE_CFN_CLZ:\n+      // __builtin_c[lt]z* return [0, prec-1], except when the\n+      // argument is 0, but that is undefined behavior.\n+      //\n+      // For __builtin_c[lt]z* consider argument of 0 always undefined\n+      // behavior, for internal fns depending on C?Z_DEFINED_VALUE_AT_ZERO.\n+      arg = gimple_call_arg (call, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec - 1;\n+      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+      if (gimple_call_internal_p (call))\n+\t{\n+\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n+\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t    {\n+\t      // Only handle the single common value.\n+\t      if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t// Magic value to give up, unless we can prove arg is non-zero.\n+\t\tmini = -2;\n+\t    }\n+\t}\n+\n+      src.get_operand (r, arg);\n+      // From clz of minimum we can compute result maximum.\n+      if (!r.undefined_p ())\n+\t{\n+\t  // From clz of minimum we can compute result maximum.\n+\t  if (wi::gt_p (r.lower_bound (), 0, TYPE_SIGN (r.type ())))\n+\t    {\n+\t      maxi = prec - 1 - wi::floor_log2 (r.lower_bound ());\n+\t      if (mini == -2)\n+\t\tmini = 0;\n+\t    }\n+\t  else if (!range_includes_zero_p (&r))\n+\t    {\n+\t      mini = 0;\n+\t      maxi = prec - 1;\n+\t    }\n+\t  if (mini == -2)\n+\t    break;\n+\t  // From clz of maximum we can compute result minimum.\n+\t  wide_int max = r.upper_bound ();\n+\t  int newmini = prec - 1 - wi::floor_log2 (max);\n+\t  if (max == 0)\n+\t    {\n+\t      // If CLZ_DEFINED_VALUE_AT_ZERO is 2 with VALUE of prec,\n+\t      // return [prec, prec], otherwise ignore the range.\n+\t      if (maxi == prec)\n+\t\tmini = prec;\n+\t    }\n+\t  else\n+\t    mini = newmini;\n+\t}\n+      if (mini == -2)\n+\tbreak;\n+      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+      return true;\n+\n+    CASE_CFN_CTZ:\n+      // __builtin_ctz* return [0, prec-1], except for when the\n+      // argument is 0, but that is undefined behavior.\n+      //\n+      // For __builtin_ctz* consider argument of 0 always undefined\n+      // behavior, for internal fns depending on CTZ_DEFINED_VALUE_AT_ZERO.\n+      arg = gimple_call_arg (call, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      mini = 0;\n+      maxi = prec - 1;\n+      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n+      if (gimple_call_internal_p (call))\n+\t{\n+\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t    {\n+\t      // Handle only the two common values.\n+\t      if (zerov == -1)\n+\t\tmini = -1;\n+\t      else if (zerov == prec)\n+\t\tmaxi = prec;\n+\t      else\n+\t\t// Magic value to give up, unless we can prove arg is non-zero.\n+\t\tmini = -2;\n+\t    }\n+\t}\n+      src.get_operand (r, arg);\n+      if (!r.undefined_p ())\n+\t{\n+\t  // If arg is non-zero, then use [0, prec - 1].\n+\t  if (!range_includes_zero_p (&r))\n+\t    {\n+\t      mini = 0;\n+\t      maxi = prec - 1;\n+\t    }\n+\t  // If some high bits are known to be zero, we can decrease\n+\t  // the maximum.\n+\t  wide_int max = r.upper_bound ();\n+\t  if (max == 0)\n+\t    {\n+\t      // Argument is [0, 0].  If CTZ_DEFINED_VALUE_AT_ZERO\n+\t      // is 2 with value -1 or prec, return [-1, -1] or [prec, prec].\n+\t      // Otherwise ignore the range.\n+\t      if (mini == -1)\n+\t\tmaxi = -1;\n+\t      else if (maxi == prec)\n+\t\tmini = prec;\n+\t    }\n+\t  // If value at zero is prec and 0 is in the range, we can't lower\n+\t  // the upper bound.  We could create two separate ranges though,\n+\t  // [0,floor_log2(max)][prec,prec] though.\n+\t  else if (maxi != prec)\n+\t    maxi = wi::floor_log2 (max);\n+\t}\n+      if (mini == -2)\n+\tbreak;\n+      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+      return true;\n+\n+    CASE_CFN_CLRSB:\n+      arg = gimple_call_arg (call, 0);\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      r.set (build_int_cst (type, 0), build_int_cst (type, prec - 1));\n+      return true;\n+    case CFN_UBSAN_CHECK_ADD:\n+      range_of_builtin_ubsan_call (r, call, PLUS_EXPR, src);\n+      return true;\n+    case CFN_UBSAN_CHECK_SUB:\n+      range_of_builtin_ubsan_call (r, call, MINUS_EXPR, src);\n+      return true;\n+    case CFN_UBSAN_CHECK_MUL:\n+      range_of_builtin_ubsan_call (r, call, MULT_EXPR, src);\n+      return true;\n+\n+    case CFN_GOACC_DIM_SIZE:\n+    case CFN_GOACC_DIM_POS:\n+      // Optimizing these two internal functions helps the loop\n+      // optimizer eliminate outer comparisons.  Size is [1,N]\n+      // and pos is [0,N-1].\n+      {\n+\tbool is_pos = func == CFN_GOACC_DIM_POS;\n+\tint axis = oacc_get_ifn_dim_arg (call);\n+\tint size = oacc_get_fn_dim_size (current_function_decl, axis);\n+\tif (!size)\n+\t  // If it's dynamic, the backend might know a hardware limitation.\n+\t  size = targetm.goacc.dim_limit (axis);\n+\n+\tr.set (build_int_cst (type, is_pos ? 0 : 1),\n+\t       size\n+\t       ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n+\treturn true;\n+      }\n+\n+    case CFN_BUILT_IN_STRLEN:\n+      if (tree lhs = gimple_call_lhs (call))\n+\tif (ptrdiff_type_node\n+\t    && (TYPE_PRECISION (ptrdiff_type_node)\n+\t\t== TYPE_PRECISION (TREE_TYPE (lhs))))\n+\t  {\n+\t    tree type = TREE_TYPE (lhs);\n+\t    tree max = vrp_val_max (ptrdiff_type_node);\n+\t    wide_int wmax\n+\t      = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n+\t    tree range_min = build_zero_cst (type);\n+\t    // To account for the terminating NULL, the maximum length\n+\t    // is one less than the maximum array size, which in turn\n+\t    // is one less than PTRDIFF_MAX (or SIZE_MAX where it's\n+\t    // smaller than the former type).\n+\t    // FIXME: Use max_object_size() - 1 here.\n+\t    tree range_max = wide_int_to_tree (type, wmax - 2);\n+\t    r.set (range_min, range_max);\n+\t    return true;\n+\t  }\n+      break;\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+\n+// Calculate a range for COND_EXPR statement S and return it in R.\n+// If a range cannot be calculated, return false.\n+\n+bool\n+fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n+{\n+  int_range_max cond_range, range1, range2;\n+  tree cond = gimple_assign_rhs1 (s);\n+  tree op1 = gimple_assign_rhs2 (s);\n+  tree op2 = gimple_assign_rhs3 (s);\n+\n+  gcc_checking_assert (gimple_assign_rhs_code (s) == COND_EXPR);\n+  gcc_checking_assert (useless_type_conversion_p  (TREE_TYPE (op1),\n+\t\t\t\t\t\t   TREE_TYPE (op2)));\n+  if (!irange::supports_type_p (TREE_TYPE (op1)))\n+    return false;\n+\n+  src.get_operand (cond_range, cond);\n+  src.get_operand (range1, op1);\n+  src.get_operand (range2, op2);\n+\n+  // If the condition is known, choose the appropriate expression.\n+  if (cond_range.singleton_p ())\n+    {\n+      // False, pick second operand.\n+      if (cond_range.zero_p ())\n+\tr = range2;\n+      else\n+\tr = range1;\n+    }\n+  else\n+    {\n+      r = range1;\n+      r.union_ (range2);\n+    }\n+  return true;\n+}\n+\n+// If SCEV has any information about phi node NAME, return it as a range in R.\n+\n+void\n+fold_using_range::range_of_ssa_name_with_loop_info (irange &r, tree name,\n+\t\t\t\t\t\t    class loop *l, gphi *phi,\n+\t\t\t\t\t\t    fur_source &src)\n+{\n+  gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n+  tree min, max, type = TREE_TYPE (name);\n+  if (bounds_of_var_in_loop (&min, &max, src.query (), l, phi, name))\n+    {\n+      if (TREE_CODE (min) != INTEGER_CST)\n+\t{\n+\t  if (src.query ()->range_of_expr (r, min, phi) && !r.undefined_p ())\n+\t    min = wide_int_to_tree (type, r.lower_bound ());\n+\t  else\n+\t    min = vrp_val_min (type);\n+\t}\n+      if (TREE_CODE (max) != INTEGER_CST)\n+\t{\n+\t  if (src.query ()->range_of_expr (r, max, phi) && !r.undefined_p ())\n+\t    max = wide_int_to_tree (type, r.upper_bound ());\n+\t  else\n+\t    max = vrp_val_max (type);\n+\t}\n+      r.set (min, max);\n+    }\n+  else\n+    r.set_varying (type);\n+}\n+\n+// -----------------------------------------------------------------------\n+\n+// Check if an && or || expression can be folded based on relations. ie\n+//   c_2 = a_6 > b_7\n+//   c_3 = a_6 < b_7\n+//   c_4 = c_2 && c_3\n+// c_2 and c_3 can never be true at the same time,\n+// Therefore c_4 can always resolve to false based purely on the relations.\n+\n+void\n+fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n+\t\t\t\t\tfur_source &src)\n+{\n+  // No queries or already folded.\n+  if (!src.gori () || !src.query ()->oracle () || lhs_range.singleton_p ())\n+    return;\n+\n+  // Only care about AND and OR expressions.\n+  enum tree_code code = gimple_expr_code (s);\n+  bool is_and = false;\n+  if (code == BIT_AND_EXPR || code == TRUTH_AND_EXPR)\n+    is_and = true;\n+  else if (code != BIT_IOR_EXPR && code != TRUTH_OR_EXPR)\n+    return;\n+\n+  tree lhs = gimple_get_lhs (s);\n+  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n+  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+\n+  // Deal with || and && only when there is a full set of symbolics.\n+  if (!lhs || !ssa1 || !ssa2\n+      || (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n+      || (TREE_CODE (TREE_TYPE (ssa1)) != BOOLEAN_TYPE)\n+      || (TREE_CODE (TREE_TYPE (ssa2)) != BOOLEAN_TYPE))\n+    return;\n+\n+  // Now we know its a boolean AND or OR expression with boolean operands.\n+  // Ideally we search dependencies for common names, and see what pops out.\n+  // until then, simply try to resolve direct dependencies.\n+\n+  // Both names will need to have 2 direct dependencies.\n+  tree ssa1_dep2 = src.gori ()->depend2 (ssa1);\n+  tree ssa2_dep2 = src.gori ()->depend2 (ssa2);\n+  if (!ssa1_dep2 || !ssa2_dep2)\n+    return;\n+\n+  tree ssa1_dep1 = src.gori ()->depend1 (ssa1);\n+  tree ssa2_dep1 = src.gori ()->depend1 (ssa2);\n+  // Make sure they are the same dependencies, and detect the order of the\n+  // relationship.\n+  bool reverse_op2 = true;\n+  if (ssa1_dep1 == ssa2_dep1 && ssa1_dep2 == ssa2_dep2)\n+    reverse_op2 = false;\n+  else if (ssa1_dep1 != ssa2_dep2 || ssa1_dep2 != ssa2_dep1)\n+    return;\n+\n+  range_operator *handler1 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa1));\n+  range_operator *handler2 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa2));\n+\n+  int_range<2> bool_one (boolean_true_node, boolean_true_node);\n+\n+  relation_kind relation1 = handler1->op1_op2_relation (bool_one);\n+  relation_kind relation2 = handler2->op1_op2_relation (bool_one);\n+  if (relation1 == VREL_NONE || relation2 == VREL_NONE)\n+    return;\n+\n+  if (reverse_op2)\n+    relation2 = relation_negate (relation2);\n+\n+  // x && y is false if the relation intersection of the true cases is NULL.\n+  if (is_and && relation_intersect (relation1, relation2) == VREL_EMPTY)\n+    lhs_range = int_range<2> (boolean_false_node, boolean_false_node);\n+  // x || y is true if the union of the true cases is NO-RELATION..\n+  // ie, one or the other being true covers the full range of possibilties.\n+  else if (!is_and && relation_union (relation1, relation2) == VREL_NONE)\n+    lhs_range = bool_one;\n+  else\n+    return;\n+\n+  range_cast (lhs_range, TREE_TYPE (lhs));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  Relation adjustment: \");\n+      print_generic_expr (dump_file, ssa1, TDF_SLIM);\n+      fprintf (dump_file, \"  and \");\n+      print_generic_expr (dump_file, ssa2, TDF_SLIM);\n+      fprintf (dump_file, \"  combine to produce \");\n+      lhs_range.dump (dump_file);\n+      fputc ('\\n', dump_file);\n+    }\n+\n+  return;\n+}\n+\n+// Register any outgoing edge relations from a conditional branch.\n+\n+void\n+fold_using_range::postfold_gcond_edges (gcond *s, fur_source &src)\n+{\n+  int_range_max r;\n+  tree name;\n+  range_operator *handler;\n+  basic_block bb = gimple_bb (s);\n+\n+  edge e0 = EDGE_SUCC (bb, 0);\n+  if (!single_pred_p (e0->dest))\n+    e0 = NULL;\n+\n+  edge e1 = EDGE_SUCC (bb, 1);\n+  if (!single_pred_p (e1->dest))\n+    e1 = NULL;\n+\n+  // At least one edge needs to be single pred.\n+  if (!e0 && !e1)\n+    return;\n+\n+  // First, register the gcond itself.  This will catch statements like\n+  // if (a_2 < b_5)\n+  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n+  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n+  if (ssa1 && ssa2)\n+    {\n+      handler = gimple_range_handler (s);\n+      gcc_checking_assert (handler);\n+      if (e0)\n+\t{\n+\t  gcond_edge_range (r, e0);\n+\t  relation_kind relation = handler->op1_op2_relation (r);\n+\t  if (relation != VREL_NONE)\n+\t    src.register_relation (e0, relation, ssa1, ssa2);\n+\t}\n+      if (e1)\n+\t{\n+\t  gcond_edge_range (r, e1);\n+\t  relation_kind relation = handler->op1_op2_relation (r);\n+\t  if (relation != VREL_NONE)\n+\t    src.register_relation (e1, relation, ssa1, ssa2);\n+\t}\n+    }\n+\n+  // Outgoing relations of GORI exports require a gori engine.\n+  if (!src.gori ())\n+    return;\n+\n+  range_query *q = src.query ();\n+  // Now look for other relations in the exports.  This will find stmts\n+  // leading to the condition such as:\n+  // c_2 = a_4 < b_7\n+  // if (c_2)\n+\n+  FOR_EACH_GORI_EXPORT_NAME (*(src.gori ()), bb, name)\n+    {\n+      if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n+\tcontinue;\n+      gimple *stmt = SSA_NAME_DEF_STMT (name);\n+      handler = gimple_range_handler (stmt);\n+      if (!handler)\n+\tcontinue;\n+      tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n+      tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n+      if (ssa1 && ssa2)\n+\t{\n+\t  if (e0 && src.gori ()->outgoing_edge_range_p (r, e0, name, *q)\n+\t      && r.singleton_p ())\n+\t    {\n+\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      if (relation != VREL_NONE)\n+\t\tsrc.register_relation (e0, relation, ssa1, ssa2);\n+\t    }\n+\t  if (e1 && src.gori ()->outgoing_edge_range_p (r, e1, name, *q)\n+\t      && r.singleton_p ())\n+\t    {\n+\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      if (relation != VREL_NONE)\n+\t\tsrc.register_relation (e1, relation, ssa1, ssa2);\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "aeb923145ca749ad11aff30a3656e6880133c97d", "filename": "gcc/gimple-range-fold.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -0,0 +1,163 @@\n+/* Header file for the GIMPLE fold_using_range interface.\n+   Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_RANGE_FOLD_H\n+#define GCC_GIMPLE_RANGE_FOLD_H\n+\n+// This file is the main include point for gimple range folding.\n+// These routines will fold stmt S into the result irange R.\n+// Any ssa_names on the stmt will be calculated using the range_query\n+// parameter via a call to range_of_expr.\n+// If no range_query is provided, current global range info will be used.\n+// The second variation specifies an edge, and stmt S is recalculated as if\n+// it appeared on that edge.\n+\n+// Fold stmt S into range R using range query Q.\n+bool fold_range (irange &r, gimple *s, range_query *q = NULL);\n+// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n+bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL);\n+\n+// These routines the operands to be specified when manually folding.\n+// Any excess queries will be drawn from the current range_query.\n+bool fold_range (irange &r, gimple *s, irange &r1);\n+bool fold_range (irange &r, gimple *s, irange &r1, irange &r2);\n+bool fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector);\n+\n+// Return the range_operator pointer for this statement.  This routine\n+// can also be used to gate whether a routine is range-ops enabled.\n+\n+static inline range_operator *\n+gimple_range_handler (const gimple *s)\n+{\n+  if (const gassign *ass = dyn_cast<const gassign *> (s))\n+    return range_op_handler (gimple_assign_rhs_code (ass),\n+\t\t\t     TREE_TYPE (gimple_assign_lhs (ass)));\n+  if (const gcond *cond = dyn_cast<const gcond *> (s))\n+    return range_op_handler (gimple_cond_code (cond),\n+\t\t\t     TREE_TYPE (gimple_cond_lhs (cond)));\n+  return NULL;\n+}\n+\n+// Return EXP if it is an SSA_NAME with a type supported by gimple ranges.\n+\n+static inline tree\n+gimple_range_ssa_p (tree exp)\n+{\n+  if (exp && TREE_CODE (exp) == SSA_NAME &&\n+      !SSA_NAME_IS_VIRTUAL_OPERAND (exp) &&\n+      irange::supports_type_p (TREE_TYPE (exp)))\n+    return exp;\n+  return NULL_TREE;\n+}\n+\n+// Return true if TYPE1 and TYPE2 are compatible range types.\n+\n+static inline bool\n+range_compatible_p (tree type1, tree type2)\n+{\n+  // types_compatible_p requires conversion in both directions to be useless.\n+  // GIMPLE only requires a cast one way in order to be compatible.\n+  // Ranges really only need the sign and precision to be the same.\n+  return (TYPE_PRECISION (type1) == TYPE_PRECISION (type2)\n+\t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n+}\n+\n+\n+// Source of all operands for fold_using_range and gori_compute.\n+// It abstracts out the source of an operand so it can come from a stmt or\n+// and edge or anywhere a derived class of fur_source wants.\n+// The default simply picks up ranges from the current range_query.\n+\n+class fur_source\n+{\n+public:\n+  fur_source (range_query *q = NULL);\n+  inline range_query *query () { return m_query; }\n+  inline class gori_compute *gori () { return m_gori; };\n+  virtual bool get_operand (irange &r, tree expr);\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e);\n+  virtual relation_kind query_relation (tree op1, tree op2);\n+  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\t  tree op2);\n+  virtual void register_relation (edge e, relation_kind k, tree op1,\n+\t\t\t\t  tree op2);\n+protected:\n+  range_query *m_query;\n+  gori_compute *m_gori;\n+};\n+\n+// fur_stmt is the specification for drawing an operand from range_query Q\n+// via a range_of_Expr call on stmt S.\n+\n+class fur_stmt : public fur_source\n+{\n+public:\n+  fur_stmt (gimple *s, range_query *q = NULL);\n+  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n+  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n+  virtual relation_kind query_relation (tree op1, tree op2) OVERRIDE;\n+private:\n+  gimple *m_stmt;\n+};\n+\n+// This version of fur_source will pick a range from a stmt, and also register\n+// dependencies via a gori_compute object.  This is mostly an internal API.\n+\n+class fur_depend : public fur_stmt\n+{\n+public:\n+  fur_depend (gimple *s, gori_compute *gori, range_query *q = NULL);\n+  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\t  tree op2) OVERRIDE;\n+  virtual void register_relation (edge e, relation_kind k, tree op1,\n+\t\t\t\t  tree op2) OVERRIDE;\n+private:\n+  relation_oracle *m_oracle;\n+};\n+\n+extern tree gimple_range_operand1 (const gimple *s);\n+extern tree gimple_range_operand2 (const gimple *s);\n+\n+// This class uses ranges to fold a gimple statement producinf a range for\n+// the LHS.  The source of all operands is supplied via the fur_source class\n+// which provides a range_query as well as a source location and any other\n+// required information.\n+\n+class fold_using_range\n+{\n+public:\n+  bool fold_stmt (irange &r, gimple *s, class fur_source &src,\n+\t\t  tree name = NULL_TREE);\n+protected:\n+  bool range_of_range_op (irange &r, gimple *s, fur_source &src);\n+  bool range_of_call (irange &r, gcall *call, fur_source &src);\n+  bool range_of_cond_expr (irange &r, gassign* cond, fur_source &src);\n+  bool range_of_address (irange &r, gimple *s, fur_source &src);\n+  bool range_of_builtin_call (irange &r, gcall *call, fur_source &src);\n+  void range_of_builtin_ubsan_call (irange &r, gcall *call, tree_code code,\n+\t\t\t\t    fur_source &src);\n+  bool range_of_phi (irange &r, gphi *phi, fur_source &src);\n+  void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n+\t\t\t\t\t fur_source &src);\n+  void relation_fold_and_or (irange& lhs_range, gimple *s, fur_source &src);\n+  void postfold_gcond_edges (gcond *s, fur_source &src);\n+};\n+#endif // GCC_GIMPLE_RANGE_FOLD_H"}, {"sha": "17032acf8d7fb6221d917dfa4334af56dfe8d00b", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -29,6 +29,72 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n \n+// Calculate what we can determine of the range of this unary\n+// statement's operand if the lhs of the expression has the range\n+// LHS_RANGE.  Return false if nothing can be determined.\n+\n+bool\n+gimple_range_calc_op1 (irange &r, const gimple *stmt, const irange &lhs_range)\n+{\n+  gcc_checking_assert (gimple_num_ops (stmt) < 3);\n+\n+  // An empty range is viral.\n+  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n+  if (lhs_range.undefined_p ())\n+    {\n+      r.set_undefined ();\n+      return true;\n+    }\n+  // Unary operations require the type of the first operand in the\n+  // second range position.\n+  int_range<2> type_range (type);\n+  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n+\t\t\t\t\t\t type_range);\n+}\n+\n+// Calculate what we can determine of the range of this statement's\n+// first operand if the lhs of the expression has the range LHS_RANGE\n+// and the second operand has the range OP2_RANGE.  Return false if\n+// nothing can be determined.\n+\n+bool\n+gimple_range_calc_op1 (irange &r, const gimple *stmt,\n+\t\t       const irange &lhs_range, const irange &op2_range)\n+{\n+  // Unary operation are allowed to pass a range in for second operand\n+  // as there are often additional restrictions beyond the type which\n+  // can be imposed.  See operator_cast::op1_range().\n+  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n+  // An empty range is viral.\n+  if (op2_range.undefined_p () || lhs_range.undefined_p ())\n+    {\n+      r.set_undefined ();\n+      return true;\n+    }\n+  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n+\t\t\t\t\t\t op2_range);\n+}\n+\n+// Calculate what we can determine of the range of this statement's\n+// second operand if the lhs of the expression has the range LHS_RANGE\n+// and the first operand has the range OP1_RANGE.  Return false if\n+// nothing can be determined.\n+\n+bool\n+gimple_range_calc_op2 (irange &r, const gimple *stmt,\n+\t\t       const irange &lhs_range, const irange &op1_range)\n+{\n+  tree type = TREE_TYPE (gimple_range_operand2 (stmt));\n+  // An empty range is viral.\n+  if (op1_range.undefined_p () || lhs_range.undefined_p ())\n+    {\n+      r.set_undefined ();\n+      return true;\n+    }\n+  return gimple_range_handler (stmt)->op2_range (r, type, lhs_range,\n+\t\t\t\t\t\t op1_range);\n+}\n+\n // Return TRUE if GS is a logical && or || expression.\n \n static inline bool"}, {"sha": "ad833240bbbedbcba79fa3719a566e01cf4a494b", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -182,6 +182,15 @@ class gori_compute : public gori_map\n   gimple_outgoing_range outgoing;\t// Edge values for COND_EXPR & SWITCH_EXPR.\n };\n \n+// These routines provide a GIMPLE interface to the range-ops code.\n+extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n+\t\t\t\t   const irange &lhs_range);\n+extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n+\t\t\t\t   const irange &lhs_range,\n+\t\t\t\t   const irange &op2_range);\n+extern bool gimple_range_calc_op2 (irange &r, const gimple *s,\n+\t\t\t\t   const irange &lhs_range,\n+\t\t\t\t   const irange &op1_range);\n \n // For each name that is an import into BB's exports..\n #define FOR_EACH_GORI_IMPORT_NAME(gori, bb, name)\t\t\t\\"}, {"sha": "1851339c5280ae6199a9a56ac899e39067d14097", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 0, "deletions": 1379, "changes": 1379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -23,1186 +23,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n-#include \"insn-codes.h\"\n-#include \"rtl.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gimple-iterator.h\"\n-#include \"optabs-tree.h\"\n-#include \"gimple-fold.h\"\n #include \"tree-cfg.h\"\n #include \"fold-const.h\"\n #include \"tree-cfg.h\"\n-#include \"wide-int.h\"\n-#include \"fold-const.h\"\n-#include \"case-cfn-macros.h\"\n-#include \"omp-general.h\"\n #include \"cfgloop.h\"\n-#include \"tree-ssa-loop.h\"\n #include \"tree-scalar-evolution.h\"\n-#include \"dbgcnt.h\"\n-#include \"alloc-pool.h\"\n-#include \"vr-values.h\"\n #include \"gimple-range.h\"\n \n-// Construct a fur_source, and set the m_query field.\n-\n-fur_source::fur_source (range_query *q)\n-{\n-  if (q)\n-    m_query = q;\n-  else if (cfun)\n-    m_query = get_range_query (cfun);\n-  else\n-    m_query = get_global_range_query ();\n-  m_gori = NULL;\n-}\n-\n-// Invoke range_of_expr on EXPR.\n-\n-bool\n-fur_source::get_operand (irange &r, tree expr)\n-{\n-  return m_query->range_of_expr (r, expr);\n-}\n-\n-// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n-// range_query to get the range on the edge.\n-\n-bool\n-fur_source::get_phi_operand (irange &r, tree expr, edge e)\n-{\n-  return m_query->range_on_edge (r, e, expr);\n-}\n-\n-// Default is no relation.\n-\n-relation_kind\n-fur_source::query_relation (tree op1 ATTRIBUTE_UNUSED,\n-\t\t\t    tree op2 ATTRIBUTE_UNUSED)\n-{\n-  return VREL_NONE;\n-}\n-\n-// Default registers nothing.\n-\n-void\n-fur_source::register_relation (gimple *s ATTRIBUTE_UNUSED,\n-\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n-\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n-\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-// Default registers nothing.\n-\n-void\n-fur_source::register_relation (edge e ATTRIBUTE_UNUSED,\n-\t\t\t       relation_kind k ATTRIBUTE_UNUSED,\n-\t\t\t       tree op1 ATTRIBUTE_UNUSED,\n-\t\t\t       tree op2 ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-// This version of fur_source will pick a range up off an edge.\n-\n-class fur_edge : public fur_source\n-{\n-public:\n-  fur_edge (edge e, range_query *q = NULL);\n-  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n-private:\n-  edge m_edge;\n-};\n-\n-// Instantiate an edge based fur_source.\n-\n-inline\n-fur_edge::fur_edge (edge e, range_query *q) : fur_source (q)\n-{\n-  m_edge = e;\n-}\n-\n-// Get the value of EXPR on edge m_edge.\n-\n-bool\n-fur_edge::get_operand (irange &r, tree expr)\n-{\n-  return m_query->range_on_edge (r, m_edge, expr);\n-}\n-\n-// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n-// range_query to get the range on the edge.\n-\n-bool\n-fur_edge::get_phi_operand (irange &r, tree expr, edge e)\n-{\n-  // Edge to edge recalculations not supoprted yet, until we sort it out.\n-  gcc_checking_assert (e == m_edge);\n-  return m_query->range_on_edge (r, e, expr);\n-}\n-\n-// Instantiate a stmt based fur_source.\n-\n-fur_stmt::fur_stmt (gimple *s, range_query *q) : fur_source (q)\n-{\n-  m_stmt = s;\n-}\n-\n-// Retreive range of EXPR as it occurs as a use on stmt M_STMT.\n-\n-bool\n-fur_stmt::get_operand (irange &r, tree expr)\n-{\n-  return m_query->range_of_expr (r, expr, m_stmt);\n-}\n-\n-// Evaluate EXPR for this stmt as a PHI argument on edge E.  Use the current\n-// range_query to get the range on the edge.\n-\n-bool\n-fur_stmt::get_phi_operand (irange &r, tree expr, edge e)\n-{\n-  // Pick up the range of expr from edge E.\n-  fur_edge e_src (e, m_query);\n-  return e_src.get_operand (r, expr);\n-}\n-\n-// Return relation based from m_stmt.\n-\n-relation_kind\n-fur_stmt::query_relation (tree op1, tree op2)\n-{\n-  return m_query->query_relation (m_stmt, op1, op2);\n-}\n-\n-// This version of fur_source will pick a range from a stmt, and also register\n-// dependencies via a gori_compute object.  This is mostly an internal API.\n-\n-class fur_depend : public fur_stmt\n-{\n-public:\n-  fur_depend (gimple *s, gori_compute *gori, range_query *q = NULL);\n-  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n-\t\t\t\t  tree op2) OVERRIDE;\n-  virtual void register_relation (edge e, relation_kind k, tree op1,\n-\t\t\t\t  tree op2) OVERRIDE;\n-private:\n-  relation_oracle *m_oracle;\n-};\n-\n-// Instantiate a stmt based fur_source with a GORI object.\n-\n-inline\n-fur_depend::fur_depend (gimple *s, gori_compute *gori, range_query *q)\n-  : fur_stmt (s, q)\n-{\n-  gcc_checking_assert (gori);\n-  m_gori = gori;\n-  // Set relations if there is an oracle in the range_query.\n-  // This will enable registering of relationships as they are discovered.\n-  m_oracle = q->oracle ();\n-\n-}\n-\n-// Register a relation on a stmt if there is an oracle.\n-\n-void\n-fur_depend::register_relation (gimple *s, relation_kind k, tree op1, tree op2)\n-{\n-  if (m_oracle)\n-    m_oracle->register_relation (s, k, op1, op2);\n-}\n-\n-// Register a relation on an edge if there is an oracle.\n-\n-void\n-fur_depend::register_relation (edge e, relation_kind k, tree op1, tree op2)\n-{\n-  if (m_oracle)\n-    m_oracle->register_relation (e, k, op1, op2);\n-}\n-\n-// This version of fur_source will pick a range up from a list of ranges\n-// supplied by the caller.\n-\n-class fur_list : public fur_source\n-{\n-public:\n-  fur_list (irange &r1);\n-  fur_list (irange &r1, irange &r2);\n-  fur_list (unsigned num, irange *list);\n-  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n-private:\n-  int_range_max m_local[2];\n-  irange *m_list;\n-  unsigned m_index;\n-  unsigned m_limit;\n-};\n-\n-// One range supplied for unary operations.\n-\n-fur_list::fur_list (irange &r1) : fur_source (NULL)\n-{\n-  m_list = m_local;\n-  m_index = 0;\n-  m_limit = 1;\n-  m_local[0] = r1;\n-}\n-\n-// Two ranges supplied for binary operations.\n-\n-fur_list::fur_list (irange &r1, irange &r2) : fur_source (NULL)\n-{\n-  m_list = m_local;\n-  m_index = 0;\n-  m_limit = 2;\n-  m_local[0] = r1;\n-  m_local[0] = r2;\n-}\n-\n-// Arbitrary number of ranges in a vector.\n-\n-fur_list::fur_list (unsigned num, irange *list) : fur_source (NULL)\n-{\n-  m_list = list;\n-  m_index = 0;\n-  m_limit = num;\n-}\n-\n-// Get the next operand from the vector, ensure types are compatible.\n-\n-bool\n-fur_list::get_operand (irange &r, tree expr)\n-{\n-  if (m_index >= m_limit)\n-    return m_query->range_of_expr (r, expr);\n-  r = m_list[m_index++];\n-  gcc_checking_assert (range_compatible_p (TREE_TYPE (expr), r.type ()));\n-  return true;\n-}\n-\n-// This will simply pick the next operand from the vector.\n-bool\n-fur_list::get_phi_operand (irange &r, tree expr, edge e ATTRIBUTE_UNUSED)\n-{\n-  return get_operand (r, expr);\n-}\n-\n-// Fold stmt S into range R using R1 as the first operand.\n-\n-bool\n-fold_range (irange &r, gimple *s, irange &r1)\n-{\n-  fold_using_range f;\n-  fur_list src (r1);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// Fold stmt S into range R using R1  and R2 as the first two operands.\n-\n-bool\n-fold_range (irange &r, gimple *s, irange &r1, irange &r2)\n-{\n-  fold_using_range f;\n-  fur_list src (r1, r2);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// Fold stmt S into range R using NUM_ELEMENTS from VECTOR as the initial\n-// operands encountered.\n-\n-bool\n-fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector)\n-{\n-  fold_using_range f;\n-  fur_list src (num_elements, vector);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// Fold stmt S into range R using range query Q.\n-\n-bool\n-fold_range (irange &r, gimple *s, range_query *q)\n-{\n-  fold_using_range f;\n-  fur_stmt src (s, q);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n-\n-bool\n-fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n-{\n-  fold_using_range f;\n-  fur_edge src (on_edge, q);\n-  return f.fold_stmt (r, s, src);\n-}\n-\n-// -------------------------------------------------------------------------\n-\n-// Adjust the range for a pointer difference where the operands came\n-// from a memchr.\n-//\n-// This notices the following sequence:\n-//\n-//\tdef = __builtin_memchr (arg, 0, sz)\n-//\tn = def - arg\n-//\n-// The range for N can be narrowed to [0, PTRDIFF_MAX - 1].\n-\n-static void\n-adjust_pointer_diff_expr (irange &res, const gimple *diff_stmt)\n-{\n-  tree op0 = gimple_assign_rhs1 (diff_stmt);\n-  tree op1 = gimple_assign_rhs2 (diff_stmt);\n-  tree op0_ptype = TREE_TYPE (TREE_TYPE (op0));\n-  tree op1_ptype = TREE_TYPE (TREE_TYPE (op1));\n-  gimple *call;\n-\n-  if (TREE_CODE (op0) == SSA_NAME\n-      && TREE_CODE (op1) == SSA_NAME\n-      && (call = SSA_NAME_DEF_STMT (op0))\n-      && is_gimple_call (call)\n-      && gimple_call_builtin_p (call, BUILT_IN_MEMCHR)\n-      && TYPE_MODE (op0_ptype) == TYPE_MODE (char_type_node)\n-      && TYPE_PRECISION (op0_ptype) == TYPE_PRECISION (char_type_node)\n-      && TYPE_MODE (op1_ptype) == TYPE_MODE (char_type_node)\n-      && TYPE_PRECISION (op1_ptype) == TYPE_PRECISION (char_type_node)\n-      && gimple_call_builtin_p (call, BUILT_IN_MEMCHR)\n-      && vrp_operand_equal_p (op1, gimple_call_arg (call, 0))\n-      && integer_zerop (gimple_call_arg (call, 1)))\n-    {\n-      tree max = vrp_val_max (ptrdiff_type_node);\n-      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-      tree expr_type = gimple_expr_type (diff_stmt);\n-      tree range_min = build_zero_cst (expr_type);\n-      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-      int_range<2> r (range_min, range_max);\n-      res.intersect (r);\n-    }\n-}\n-\n-// This function looks for situations when walking the use/def chains\n-// may provide additonal contextual range information not exposed on\n-// this statement.  Like knowing the IMAGPART return value from a\n-// builtin function is a boolean result.\n-\n-// We should rework how we're called, as we have an op_unknown entry\n-// for IMAGPART_EXPR and POINTER_DIFF_EXPR in range-ops just so this\n-// function gets called.\n-\n-static void\n-gimple_range_adjustment (irange &res, const gimple *stmt)\n-{\n-  switch (gimple_expr_code (stmt))\n-    {\n-    case POINTER_DIFF_EXPR:\n-      adjust_pointer_diff_expr (res, stmt);\n-      return;\n-\n-    case IMAGPART_EXPR:\n-      {\n-\ttree name = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n-\tif (TREE_CODE (name) == SSA_NAME)\n-\t  {\n-\t    gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-\t    if (def_stmt && is_gimple_call (def_stmt)\n-\t\t&& gimple_call_internal_p (def_stmt))\n-\t      {\n-\t\tswitch (gimple_call_internal_fn (def_stmt))\n-\t\t  {\n-\t\t  case IFN_ADD_OVERFLOW:\n-\t\t  case IFN_SUB_OVERFLOW:\n-\t\t  case IFN_MUL_OVERFLOW:\n-\t\t  case IFN_ATOMIC_COMPARE_EXCHANGE:\n-\t\t    {\n-\t\t      int_range<2> r;\n-\t\t      r.set_varying (boolean_type_node);\n-\t\t      tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\t\t      range_cast (r, type);\n-\t\t      res.intersect (r);\n-\t\t    }\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-\tbreak;\n-      }\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-// Return the base of the RHS of an assignment.\n-\n-static tree\n-gimple_range_base_of_assignment (const gimple *stmt)\n-{\n-  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n-  tree op1 = gimple_assign_rhs1 (stmt);\n-  if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n-    return get_base_address (TREE_OPERAND (op1, 0));\n-  return op1;\n-}\n-\n-// Return the first operand of this statement if it is a valid operand\n-// supported by ranges, otherwise return NULL_TREE.  Special case is\n-// &(SSA_NAME expr), return the SSA_NAME instead of the ADDR expr.\n-\n-tree\n-gimple_range_operand1 (const gimple *stmt)\n-{\n-  gcc_checking_assert (gimple_range_handler (stmt));\n-\n-  switch (gimple_code (stmt))\n-    {\n-      case GIMPLE_COND:\n-\treturn gimple_cond_lhs (stmt);\n-      case GIMPLE_ASSIGN:\n-\t{\n-\t  tree base = gimple_range_base_of_assignment (stmt);\n-\t  if (base && TREE_CODE (base) == MEM_REF)\n-\t    {\n-\t      // If the base address is an SSA_NAME, we return it\n-\t      // here.  This allows processing of the range of that\n-\t      // name, while the rest of the expression is simply\n-\t      // ignored.  The code in range_ops will see the\n-\t      // ADDR_EXPR and do the right thing.\n-\t      tree ssa = TREE_OPERAND (base, 0);\n-\t      if (TREE_CODE (ssa) == SSA_NAME)\n-\t\treturn ssa;\n-\t    }\n-\t  return base;\n-\t}\n-      default:\n-\tbreak;\n-    }\n-  return NULL;\n-}\n-\n-// Return the second operand of statement STMT, otherwise return NULL_TREE.\n-\n-tree\n-gimple_range_operand2 (const gimple *stmt)\n-{\n-  gcc_checking_assert (gimple_range_handler (stmt));\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_COND:\n-      return gimple_cond_rhs (stmt);\n-    case GIMPLE_ASSIGN:\n-      if (gimple_num_ops (stmt) >= 3)\n-\treturn gimple_assign_rhs2 (stmt);\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-}\n-\n-// Calculate what we can determine of the range of this unary\n-// statement's operand if the lhs of the expression has the range\n-// LHS_RANGE.  Return false if nothing can be determined.\n-\n-bool\n-gimple_range_calc_op1 (irange &r, const gimple *stmt, const irange &lhs_range)\n-{\n-  gcc_checking_assert (gimple_num_ops (stmt) < 3);\n-\n-  // An empty range is viral.\n-  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n-  if (lhs_range.undefined_p ())\n-    {\n-      r.set_undefined ();\n-      return true;\n-    }\n-  // Unary operations require the type of the first operand in the\n-  // second range position.\n-  int_range<2> type_range (type);\n-  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n-\t\t\t\t\t\t type_range);\n-}\n-\n-// Calculate what we can determine of the range of this statement's\n-// first operand if the lhs of the expression has the range LHS_RANGE\n-// and the second operand has the range OP2_RANGE.  Return false if\n-// nothing can be determined.\n-\n-bool\n-gimple_range_calc_op1 (irange &r, const gimple *stmt,\n-\t\t       const irange &lhs_range, const irange &op2_range)\n-{\n-  // Unary operation are allowed to pass a range in for second operand\n-  // as there are often additional restrictions beyond the type which\n-  // can be imposed.  See operator_cast::op1_range().\n-  tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n-  // An empty range is viral.\n-  if (op2_range.undefined_p () || lhs_range.undefined_p ())\n-    {\n-      r.set_undefined ();\n-      return true;\n-    }\n-  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n-\t\t\t\t\t\t op2_range);\n-}\n-\n-// Calculate what we can determine of the range of this statement's\n-// second operand if the lhs of the expression has the range LHS_RANGE\n-// and the first operand has the range OP1_RANGE.  Return false if\n-// nothing can be determined.\n-\n-bool\n-gimple_range_calc_op2 (irange &r, const gimple *stmt,\n-\t\t       const irange &lhs_range, const irange &op1_range)\n-{\n-  tree type = TREE_TYPE (gimple_range_operand2 (stmt));\n-  // An empty range is viral.\n-  if (op1_range.undefined_p () || lhs_range.undefined_p ())\n-    {\n-      r.set_undefined ();\n-      return true;\n-    }\n-  return gimple_range_handler (stmt)->op2_range (r, type, lhs_range,\n-\t\t\t\t\t\t op1_range);\n-}\n-\n-// Calculate a range for statement S and return it in R. If NAME is provided it\n-// represents the SSA_NAME on the LHS of the statement. It is only required\n-// if there is more than one lhs/output.  If a range cannot\n-// be calculated, return false.\n-\n-bool\n-fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n-{\n-  bool res = false;\n-  // If name and S are specified, make sure it is an LHS of S.\n-  gcc_checking_assert (!name || !gimple_get_lhs (s) ||\n-\t\t       name == gimple_get_lhs (s));\n-\n-  if (!name)\n-    name = gimple_get_lhs (s);\n-\n-  // Process addresses.\n-  if (gimple_code (s) == GIMPLE_ASSIGN\n-      && gimple_assign_rhs_code (s) == ADDR_EXPR)\n-    return range_of_address (r, s, src);\n-\n-  if (gimple_range_handler (s))\n-    res = range_of_range_op (r, s, src);\n-  else if (is_a<gphi *>(s))\n-    res = range_of_phi (r, as_a<gphi *> (s), src);\n-  else if (is_a<gcall *>(s))\n-    res = range_of_call (r, as_a<gcall *> (s), src);\n-  else if (is_a<gassign *> (s) && gimple_assign_rhs_code (s) == COND_EXPR)\n-    res = range_of_cond_expr (r, as_a<gassign *> (s), src);\n-\n-  if (!res)\n-    {\n-      // If no name is specified, try the expression kind.\n-      if (!name)\n-\t{\n-\t  tree t = gimple_expr_type (s);\n-\t  if (!irange::supports_type_p (t))\n-\t    return false;\n-\t  r.set_varying (t);\n-\t  return true;\n-\t}\n-      if (!gimple_range_ssa_p (name))\n-\treturn false;\n-      // We don't understand the stmt, so return the global range.\n-      r = gimple_range_global (name);\n-      return true;\n-    }\n-\n-  if (r.undefined_p ())\n-    return true;\n-\n-  // We sometimes get compatible types copied from operands, make sure\n-  // the correct type is being returned.\n-  if (name && TREE_TYPE (name) != r.type ())\n-    {\n-      gcc_checking_assert (range_compatible_p (r.type (), TREE_TYPE (name)));\n-      range_cast (r, TREE_TYPE (name));\n-    }\n-  return true;\n-}\n-\n-// Calculate a range for range_op statement S and return it in R.  If any\n-// If a range cannot be calculated, return false.\n-\n-bool\n-fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n-{\n-  int_range_max range1, range2;\n-  tree type = gimple_expr_type (s);\n-  range_operator *handler = gimple_range_handler (s);\n-  gcc_checking_assert (handler);\n-  gcc_checking_assert (irange::supports_type_p (type));\n-\n-  tree lhs = gimple_get_lhs (s);\n-  tree op1 = gimple_range_operand1 (s);\n-  tree op2 = gimple_range_operand2 (s);\n-\n-  if (src.get_operand (range1, op1))\n-    {\n-      if (!op2)\n-\t{\n-\t  // Fold range, and register any dependency if available.\n-\t  int_range<2> r2 (type);\n-\t  handler->fold_range (r, type, range1, r2);\n-\t  if (lhs && gimple_range_ssa_p (op1))\n-\t    {\n-\t      if (src.gori ())\n-\t\tsrc.gori ()->register_dependency (lhs, op1);\n-\t      relation_kind rel;\n-\t      rel = handler->lhs_op1_relation (r, range1, range1);\n-\t      if (rel != VREL_NONE)\n-\t\tsrc.register_relation (s, rel, lhs, op1);\n-\t    }\n-\t}\n-      else if (src.get_operand (range2, op2))\n-\t{\n-\t  relation_kind rel = src.query_relation (op1, op2);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS) && rel != VREL_NONE)\n-\t    {\n-\t      fprintf (dump_file, \" folding with relation \");\n-\t      print_relation (dump_file, rel);\n-\t      fputc ('\\n', dump_file);\n-\t    }\n-\t  // Fold range, and register any dependency if available.\n-\t  handler->fold_range (r, type, range1, range2, rel);\n-\t  relation_fold_and_or (r, s, src);\n-\t  if (lhs)\n-\t    {\n-\t      if (src.gori ())\n-\t\t{\n-\t\t  src.gori ()->register_dependency (lhs, op1);\n-\t\t  src.gori ()->register_dependency (lhs, op2);\n-\t\t}\n-\t      if (gimple_range_ssa_p (op1))\n-\t\t{\n-\t\t  rel = handler->lhs_op1_relation (r, range1, range2);\n-\t\t  if (rel != VREL_NONE)\n-\t\t    src.register_relation (s, rel, lhs, op1);\n-\t\t}\n-\t      if (gimple_range_ssa_p (op2))\n-\t\t{\n-\t\t  rel= handler->lhs_op2_relation (r, range1, range2);\n-\t\t  if (rel != VREL_NONE)\n-\t\t    src.register_relation (s, rel, lhs, op2);\n-\t\t}\n-\t    }\n-\t  else if (is_a<gcond *> (s))\n-\t    postfold_gcond_edges (as_a<gcond *> (s), src);\n-\t}\n-      else\n-\tr.set_varying (type);\n-    }\n-  else\n-    r.set_varying (type);\n-  // Make certain range-op adjustments that aren't handled any other way.\n-  gimple_range_adjustment (r, s);\n-  return true;\n-}\n-\n-// Calculate the range of an assignment containing an ADDR_EXPR.\n-// Return the range in R.\n-// If a range cannot be calculated, set it to VARYING and return true.\n-\n-bool\n-fold_using_range::range_of_address (irange &r, gimple *stmt, fur_source &src)\n-{\n-  gcc_checking_assert (gimple_code (stmt) == GIMPLE_ASSIGN);\n-  gcc_checking_assert (gimple_assign_rhs_code (stmt) == ADDR_EXPR);\n-\n-  bool strict_overflow_p;\n-  tree expr = gimple_assign_rhs1 (stmt);\n-  poly_int64 bitsize, bitpos;\n-  tree offset;\n-  machine_mode mode;\n-  int unsignedp, reversep, volatilep;\n-  tree base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n-\t\t\t\t   &bitpos, &offset, &mode, &unsignedp,\n-\t\t\t\t   &reversep, &volatilep);\n-\n-\n-  if (base != NULL_TREE\n-      && TREE_CODE (base) == MEM_REF\n-      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-    {\n-      tree ssa = TREE_OPERAND (base, 0);\n-      tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && gimple_range_ssa_p (ssa) && src.gori ())\n-\tsrc.gori ()->register_dependency (lhs, ssa);\n-      gcc_checking_assert (irange::supports_type_p (TREE_TYPE (ssa)));\n-      src.get_operand (r, ssa);\n-      range_cast (r, TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-\n-      poly_offset_int off = 0;\n-      bool off_cst = false;\n-      if (offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)\n-\t{\n-\t  off = mem_ref_offset (base);\n-\t  if (offset)\n-\t    off += poly_offset_int::from (wi::to_poly_wide (offset),\n-\t\t\t\t\t  SIGNED);\n-\t  off <<= LOG2_BITS_PER_UNIT;\n-\t  off += bitpos;\n-\t  off_cst = true;\n-\t}\n-      /* If &X->a is equal to X, the range of X is the result.  */\n-      if (off_cst && known_eq (off, 0))\n-\t  return true;\n-      else if (flag_delete_null_pointer_checks\n-\t       && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n-\t{\n-\t /* For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n-\t allow going from non-NULL pointer to NULL.  */\n-\t   if(!range_includes_zero_p (&r))\n-\t    return true;\n-\t}\n-      /* If MEM_REF has a \"positive\" offset, consider it non-NULL\n-\t always, for -fdelete-null-pointer-checks also \"negative\"\n-\t ones.  Punt for unknown offsets (e.g. variable ones).  */\n-      if (!TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n-\t  && off_cst\n-\t  && known_ne (off, 0)\n-\t  && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n-\t{\n-\t  r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-\t  return true;\n-\t}\n-      r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-      return true;\n-    }\n-\n-  // Handle \"= &a\".\n-  if (tree_single_nonzero_warnv_p (expr, &strict_overflow_p))\n-    {\n-      r = range_nonzero (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-      return true;\n-    }\n-\n-  // Otherwise return varying.\n-  r = int_range<2> (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-  return true;\n-}\n-\n-// Calculate a range for phi statement S and return it in R.\n-// If a range cannot be calculated, return false.\n-\n-bool\n-fold_using_range::range_of_phi (irange &r, gphi *phi, fur_source &src)\n-{\n-  tree phi_def = gimple_phi_result (phi);\n-  tree type = TREE_TYPE (phi_def);\n-  int_range_max arg_range;\n-  unsigned x;\n-\n-  if (!irange::supports_type_p (type))\n-    return false;\n-\n-  // Start with an empty range, unioning in each argument's range.\n-  r.set_undefined ();\n-  for (x = 0; x < gimple_phi_num_args (phi); x++)\n-    {\n-      tree arg = gimple_phi_arg_def (phi, x);\n-      edge e = gimple_phi_arg_edge (phi, x);\n-\n-      // Register potential dependencies for stale value tracking.\n-      if (gimple_range_ssa_p (arg) && src.gori ())\n-\tsrc.gori ()->register_dependency (phi_def, arg);\n-\n-      // Get the range of the argument on its edge.\n-      src.get_phi_operand (arg_range, arg, e);\n-      // If we're recomputing the argument elsewhere, try to refine it.\n-      r.union_ (arg_range);\n-      // Once the value reaches varying, stop looking.\n-      if (r.varying_p ())\n-\tbreak;\n-    }\n-\n-  // If SCEV is available, query if this PHI has any knonwn values.\n-  if (scev_initialized_p () && !POINTER_TYPE_P (TREE_TYPE (phi_def)))\n-    {\n-      value_range loop_range;\n-      class loop *l = loop_containing_stmt (phi);\n-      if (l && loop_outer (l))\n-        {\n-\t  range_of_ssa_name_with_loop_info (loop_range, phi_def, l, phi, src);\n-\t  if (!loop_range.varying_p ())\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"   Loops range found for \");\n-\t\t  print_generic_expr (dump_file, phi_def, TDF_SLIM);\n-\t\t  fprintf (dump_file, \": \");\n-\t\t  loop_range.dump (dump_file);\n-\t\t  fprintf (dump_file, \" and calculated range :\");\n-\t\t  r.dump (dump_file);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      r.intersect (loop_range);\n-\t    }\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n-// Calculate a range for call statement S and return it in R.\n-// If a range cannot be calculated, return false.\n-\n-bool\n-fold_using_range::range_of_call (irange &r, gcall *call, fur_source &src)\n-{\n-  tree type = gimple_call_return_type (call);\n-  tree lhs = gimple_call_lhs (call);\n-  bool strict_overflow_p;\n-\n-  if (!irange::supports_type_p (type))\n-    return false;\n-\n-  if (range_of_builtin_call (r, call, src))\n-    ;\n-  else if (gimple_stmt_nonnegative_warnv_p (call, &strict_overflow_p))\n-    r.set (build_int_cst (type, 0), TYPE_MAX_VALUE (type));\n-  else if (gimple_call_nonnull_result_p (call)\n-\t   || gimple_call_nonnull_arg (call))\n-    r = range_nonzero (type);\n-  else\n-    r.set_varying (type);\n-\n-  // If there is an LHS, intersect that with what is known.\n-  if (lhs)\n-    {\n-      value_range def;\n-      def = gimple_range_global (lhs);\n-      r.intersect (def);\n-    }\n-  return true;\n-}\n-\n-// Return the range of a __builtin_ubsan* in CALL and set it in R.\n-// CODE is the type of ubsan call (PLUS_EXPR, MINUS_EXPR or\n-// MULT_EXPR).\n-\n-void\n-fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n-\t\t\t\t\t       tree_code code, fur_source &src)\n-{\n-  gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n-\t\t       || code == MULT_EXPR);\n-  tree type = gimple_call_return_type (call);\n-  range_operator *op = range_op_handler (code, type);\n-  gcc_checking_assert (op);\n-  int_range_max ir0, ir1;\n-  tree arg0 = gimple_call_arg (call, 0);\n-  tree arg1 = gimple_call_arg (call, 1);\n-  src.get_operand (ir0, arg0);\n-  src.get_operand (ir1, arg1);\n-\n-  bool saved_flag_wrapv = flag_wrapv;\n-  // Pretend the arithmetic is wrapping.  If there is any overflow,\n-  // we'll complain, but will actually do wrapping operation.\n-  flag_wrapv = 1;\n-  op->fold_range (r, type, ir0, ir1);\n-  flag_wrapv = saved_flag_wrapv;\n-\n-  // If for both arguments vrp_valueize returned non-NULL, this should\n-  // have been already folded and if not, it wasn't folded because of\n-  // overflow.  Avoid removing the UBSAN_CHECK_* calls in that case.\n-  if (r.singleton_p ())\n-    r.set_varying (type);\n-}\n-\n-// For a builtin in CALL, return a range in R if known and return\n-// TRUE.  Otherwise return FALSE.\n-\n-bool\n-fold_using_range::range_of_builtin_call (irange &r, gcall *call,\n-\t\t\t\t\t fur_source &src)\n-{\n-  combined_fn func = gimple_call_combined_fn (call);\n-  if (func == CFN_LAST)\n-    return false;\n-\n-  tree type = gimple_call_return_type (call);\n-  tree arg;\n-  int mini, maxi, zerov = 0, prec;\n-  scalar_int_mode mode;\n-\n-  switch (func)\n-    {\n-    case CFN_BUILT_IN_CONSTANT_P:\n-      if (cfun->after_inlining)\n-\t{\n-\t  r.set_zero (type);\n-\t  // r.equiv_clear ();\n-\t  return true;\n-\t}\n-      arg = gimple_call_arg (call, 0);\n-      if (src.get_operand (r, arg) && r.singleton_p ())\n-\t{\n-\t  r.set (build_one_cst (type), build_one_cst (type));\n-\t  return true;\n-\t}\n-      break;\n-\n-    CASE_CFN_FFS:\n-    CASE_CFN_POPCOUNT:\n-      // __builtin_ffs* and __builtin_popcount* return [0, prec].\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec;\n-      src.get_operand (r, arg);\n-      // If arg is non-zero, then ffs or popcount are non-zero.\n-      if (!range_includes_zero_p (&r))\n-\tmini = 1;\n-      // If some high bits are known to be zero, decrease the maximum.\n-      if (!r.undefined_p ())\n-\t{\n-\t  if (TYPE_SIGN (r.type ()) == SIGNED)\n-\t    range_cast (r, unsigned_type_for (r.type ()));\n-\t  wide_int max = r.upper_bound ();\n-\t  maxi = wi::floor_log2 (max) + 1;\n-\t}\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n-    CASE_CFN_PARITY:\n-      r.set (build_zero_cst (type), build_one_cst (type));\n-      return true;\n-\n-    CASE_CFN_CLZ:\n-      // __builtin_c[lt]z* return [0, prec-1], except when the\n-      // argument is 0, but that is undefined behavior.\n-      //\n-      // For __builtin_c[lt]z* consider argument of 0 always undefined\n-      // behavior, for internal fns depending on C?Z_DEFINED_VALUE_AT_ZERO.\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (call))\n-\t{\n-\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      // Only handle the single common value.\n-\t      if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t// Magic value to give up, unless we can prove arg is non-zero.\n-\t\tmini = -2;\n-\t    }\n-\t}\n-\n-      src.get_operand (r, arg);\n-      // From clz of minimum we can compute result maximum.\n-      if (!r.undefined_p ())\n-\t{\n-\t  // From clz of minimum we can compute result maximum.\n-\t  if (wi::gt_p (r.lower_bound (), 0, TYPE_SIGN (r.type ())))\n-\t    {\n-\t      maxi = prec - 1 - wi::floor_log2 (r.lower_bound ());\n-\t      if (mini == -2)\n-\t\tmini = 0;\n-\t    }\n-\t  else if (!range_includes_zero_p (&r))\n-\t    {\n-\t      mini = 0;\n-\t      maxi = prec - 1;\n-\t    }\n-\t  if (mini == -2)\n-\t    break;\n-\t  // From clz of maximum we can compute result minimum.\n-\t  wide_int max = r.upper_bound ();\n-\t  int newmini = prec - 1 - wi::floor_log2 (max);\n-\t  if (max == 0)\n-\t    {\n-\t      // If CLZ_DEFINED_VALUE_AT_ZERO is 2 with VALUE of prec,\n-\t      // return [prec, prec], otherwise ignore the range.\n-\t      if (maxi == prec)\n-\t\tmini = prec;\n-\t    }\n-\t  else\n-\t    mini = newmini;\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n-    CASE_CFN_CTZ:\n-      // __builtin_ctz* return [0, prec-1], except for when the\n-      // argument is 0, but that is undefined behavior.\n-      //\n-      // For __builtin_ctz* consider argument of 0 always undefined\n-      // behavior, for internal fns depending on CTZ_DEFINED_VALUE_AT_ZERO.\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (call))\n-\t{\n-\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      // Handle only the two common values.\n-\t      if (zerov == -1)\n-\t\tmini = -1;\n-\t      else if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t// Magic value to give up, unless we can prove arg is non-zero.\n-\t\tmini = -2;\n-\t    }\n-\t}\n-      src.get_operand (r, arg);\n-      if (!r.undefined_p ())\n-\t{\n-\t  // If arg is non-zero, then use [0, prec - 1].\n-\t  if (!range_includes_zero_p (&r))\n-\t    {\n-\t      mini = 0;\n-\t      maxi = prec - 1;\n-\t    }\n-\t  // If some high bits are known to be zero, we can decrease\n-\t  // the maximum.\n-\t  wide_int max = r.upper_bound ();\n-\t  if (max == 0)\n-\t    {\n-\t      // Argument is [0, 0].  If CTZ_DEFINED_VALUE_AT_ZERO\n-\t      // is 2 with value -1 or prec, return [-1, -1] or [prec, prec].\n-\t      // Otherwise ignore the range.\n-\t      if (mini == -1)\n-\t\tmaxi = -1;\n-\t      else if (maxi == prec)\n-\t\tmini = prec;\n-\t    }\n-\t  // If value at zero is prec and 0 is in the range, we can't lower\n-\t  // the upper bound.  We could create two separate ranges though,\n-\t  // [0,floor_log2(max)][prec,prec] though.\n-\t  else if (maxi != prec)\n-\t    maxi = wi::floor_log2 (max);\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n-    CASE_CFN_CLRSB:\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      r.set (build_int_cst (type, 0), build_int_cst (type, prec - 1));\n-      return true;\n-    case CFN_UBSAN_CHECK_ADD:\n-      range_of_builtin_ubsan_call (r, call, PLUS_EXPR, src);\n-      return true;\n-    case CFN_UBSAN_CHECK_SUB:\n-      range_of_builtin_ubsan_call (r, call, MINUS_EXPR, src);\n-      return true;\n-    case CFN_UBSAN_CHECK_MUL:\n-      range_of_builtin_ubsan_call (r, call, MULT_EXPR, src);\n-      return true;\n-\n-    case CFN_GOACC_DIM_SIZE:\n-    case CFN_GOACC_DIM_POS:\n-      // Optimizing these two internal functions helps the loop\n-      // optimizer eliminate outer comparisons.  Size is [1,N]\n-      // and pos is [0,N-1].\n-      {\n-\tbool is_pos = func == CFN_GOACC_DIM_POS;\n-\tint axis = oacc_get_ifn_dim_arg (call);\n-\tint size = oacc_get_fn_dim_size (current_function_decl, axis);\n-\tif (!size)\n-\t  // If it's dynamic, the backend might know a hardware limitation.\n-\t  size = targetm.goacc.dim_limit (axis);\n-\n-\tr.set (build_int_cst (type, is_pos ? 0 : 1),\n-\t       size\n-\t       ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n-\treturn true;\n-      }\n-\n-    case CFN_BUILT_IN_STRLEN:\n-      if (tree lhs = gimple_call_lhs (call))\n-\tif (ptrdiff_type_node\n-\t    && (TYPE_PRECISION (ptrdiff_type_node)\n-\t\t== TYPE_PRECISION (TREE_TYPE (lhs))))\n-\t  {\n-\t    tree type = TREE_TYPE (lhs);\n-\t    tree max = vrp_val_max (ptrdiff_type_node);\n-\t    wide_int wmax\n-\t      = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-\t    tree range_min = build_zero_cst (type);\n-\t    // To account for the terminating NULL, the maximum length\n-\t    // is one less than the maximum array size, which in turn\n-\t    // is one less than PTRDIFF_MAX (or SIZE_MAX where it's\n-\t    // smaller than the former type).\n-\t    // FIXME: Use max_object_size() - 1 here.\n-\t    tree range_max = wide_int_to_tree (type, wmax - 2);\n-\t    r.set (range_min, range_max);\n-\t    return true;\n-\t  }\n-      break;\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n-\n-// Calculate a range for COND_EXPR statement S and return it in R.\n-// If a range cannot be calculated, return false.\n-\n-bool\n-fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n-{\n-  int_range_max cond_range, range1, range2;\n-  tree cond = gimple_assign_rhs1 (s);\n-  tree op1 = gimple_assign_rhs2 (s);\n-  tree op2 = gimple_assign_rhs3 (s);\n-\n-  gcc_checking_assert (gimple_assign_rhs_code (s) == COND_EXPR);\n-  gcc_checking_assert (useless_type_conversion_p  (TREE_TYPE (op1),\n-\t\t\t\t\t\t   TREE_TYPE (op2)));\n-  if (!irange::supports_type_p (TREE_TYPE (op1)))\n-    return false;\n-\n-  src.get_operand (cond_range, cond);\n-  src.get_operand (range1, op1);\n-  src.get_operand (range2, op2);\n-\n-  // If the condition is known, choose the appropriate expression.\n-  if (cond_range.singleton_p ())\n-    {\n-      // False, pick second operand.\n-      if (cond_range.zero_p ())\n-\tr = range2;\n-      else\n-\tr = range1;\n-    }\n-  else\n-    {\n-      r = range1;\n-      r.union_ (range2);\n-    }\n-  return true;\n-}\n-\n gimple_ranger::gimple_ranger ()\n {\n   // If the cache has a relation oracle, use it.\n@@ -1493,217 +325,6 @@ gimple_ranger::dump (FILE *f)\n   m_cache.dump (f);\n }\n \n-// If SCEV has any information about phi node NAME, return it as a range in R.\n-\n-void\n-fold_using_range::range_of_ssa_name_with_loop_info (irange &r, tree name,\n-\t\t\t\t\t\t    class loop *l, gphi *phi,\n-\t\t\t\t\t\t    fur_source &src)\n-{\n-  gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n-  tree min, max, type = TREE_TYPE (name);\n-  if (bounds_of_var_in_loop (&min, &max, src.query (), l, phi, name))\n-    {\n-      if (TREE_CODE (min) != INTEGER_CST)\n-\t{\n-\t  if (src.query ()->range_of_expr (r, min, phi) && !r.undefined_p ())\n-\t    min = wide_int_to_tree (type, r.lower_bound ());\n-\t  else\n-\t    min = vrp_val_min (type);\n-\t}\n-      if (TREE_CODE (max) != INTEGER_CST)\n-\t{\n-\t  if (src.query ()->range_of_expr (r, max, phi) && !r.undefined_p ())\n-\t    max = wide_int_to_tree (type, r.upper_bound ());\n-\t  else\n-\t    max = vrp_val_max (type);\n-\t}\n-      r.set (min, max);\n-    }\n-  else\n-    r.set_varying (type);\n-}\n-\n-// -----------------------------------------------------------------------\n-\n-// Check if an && or || expression can be folded based on relations. ie\n-//   c_2 = a_6 > b_7\n-//   c_3 = a_6 < b_7\n-//   c_4 = c_2 && c_3\n-// c_2 and c_3 can never be true at the same time,\n-// Therefore c_4 can always resolve to false based purely on the relations.\n-\n-void\n-fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n-\t\t\t\t\tfur_source &src)\n-{\n-  // No queries or already folded.\n-  if (!src.gori () || !src.query ()->oracle () || lhs_range.singleton_p ())\n-    return;\n-\n-  // Only care about AND and OR expressions.\n-  enum tree_code code = gimple_expr_code (s);\n-  bool is_and = false;\n-  if (code == BIT_AND_EXPR || code == TRUTH_AND_EXPR)\n-    is_and = true;\n-  else if (code != BIT_IOR_EXPR && code != TRUTH_OR_EXPR)\n-    return;\n-\n-  tree lhs = gimple_get_lhs (s);\n-  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n-  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n-\n-  // Deal with || and && only when there is a full set of symbolics.\n-  if (!lhs || !ssa1 || !ssa2\n-      || (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n-      || (TREE_CODE (TREE_TYPE (ssa1)) != BOOLEAN_TYPE)\n-      || (TREE_CODE (TREE_TYPE (ssa2)) != BOOLEAN_TYPE))\n-    return;\n-\n-  // Now we know its a boolean AND or OR expression with boolean operands.\n-  // Ideally we search dependencies for common names, and see what pops out.\n-  // until then, simply try to resolve direct dependencies.\n-\n-  // Both names will need to have 2 direct dependencies.\n-  tree ssa1_dep2 = src.gori ()->depend2 (ssa1);\n-  tree ssa2_dep2 = src.gori ()->depend2 (ssa2);\n-  if (!ssa1_dep2 || !ssa2_dep2)\n-    return;\n-\n-  tree ssa1_dep1 = src.gori ()->depend1 (ssa1);\n-  tree ssa2_dep1 = src.gori ()->depend1 (ssa2);\n-  // Make sure they are the same dependencies, and detect the order of the\n-  // relationship.\n-  bool reverse_op2 = true;\n-  if (ssa1_dep1 == ssa2_dep1 && ssa1_dep2 == ssa2_dep2)\n-    reverse_op2 = false;\n-  else if (ssa1_dep1 != ssa2_dep2 || ssa1_dep2 != ssa2_dep1)\n-    return;\n-\n-  range_operator *handler1 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa1));\n-  range_operator *handler2 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa2));\n-\n-  int_range<2> bool_one (boolean_true_node, boolean_true_node);\n-\n-  relation_kind relation1 = handler1->op1_op2_relation (bool_one);\n-  relation_kind relation2 = handler2->op1_op2_relation (bool_one);\n-  if (relation1 == VREL_NONE || relation2 == VREL_NONE)\n-    return;\n-\n-  if (reverse_op2)\n-    relation2 = relation_negate (relation2);\n-\n-  // x && y is false if the relation intersection of the true cases is NULL.\n-  if (is_and && relation_intersect (relation1, relation2) == VREL_EMPTY)\n-    lhs_range = int_range<2> (boolean_false_node, boolean_false_node);\n-  // x || y is true if the union of the true cases is NO-RELATION..\n-  // ie, one or the other being true covers the full range of possibilties.\n-  else if (!is_and && relation_union (relation1, relation2) == VREL_NONE)\n-    lhs_range = bool_one;\n-  else\n-    return;\n-\n-  range_cast (lhs_range, TREE_TYPE (lhs));\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"  Relation adjustment: \");\n-      print_generic_expr (dump_file, ssa1, TDF_SLIM);\n-      fprintf (dump_file, \"  and \");\n-      print_generic_expr (dump_file, ssa2, TDF_SLIM);\n-      fprintf (dump_file, \"  combine to produce \");\n-      lhs_range.dump (dump_file);\n-      fputc ('\\n', dump_file);\n-    }\n-\n-  return;\n-}\n-\n-// Register any outgoing edge relations from a conditional branch.\n-\n-void\n-fold_using_range::postfold_gcond_edges (gcond *s, fur_source &src)\n-{\n-  int_range_max r;\n-  tree name;\n-  range_operator *handler;\n-  basic_block bb = gimple_bb (s);\n-\n-  edge e0 = EDGE_SUCC (bb, 0);\n-  if (!single_pred_p (e0->dest))\n-    e0 = NULL;\n-\n-  edge e1 = EDGE_SUCC (bb, 1);\n-  if (!single_pred_p (e1->dest))\n-    e1 = NULL;\n-\n-  // At least one edge needs to be single pred.\n-  if (!e0 && !e1)\n-    return;\n-\n-  // First, register the gcond itself.  This will catch statements like\n-  // if (a_2 < b_5)\n-  tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (s));\n-  tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n-  if (ssa1 && ssa2)\n-    {\n-      handler = gimple_range_handler (s);\n-      gcc_checking_assert (handler);\n-      if (e0)\n-\t{\n-\t  gcond_edge_range (r, e0);\n-\t  relation_kind relation = handler->op1_op2_relation (r);\n-\t  if (relation != VREL_NONE)\n-\t    src.register_relation (e0, relation, ssa1, ssa2);\n-\t}\n-      if (e1)\n-\t{\n-\t  gcond_edge_range (r, e1);\n-\t  relation_kind relation = handler->op1_op2_relation (r);\n-\t  if (relation != VREL_NONE)\n-\t    src.register_relation (e1, relation, ssa1, ssa2);\n-\t}\n-    }\n-\n-  // Outgoing relations of GORI exports require a gori engine.\n-  if (!src.gori ())\n-    return;\n-\n-  range_query *q = src.query ();\n-  // Now look for other relations in the exports.  This will find stmts\n-  // leading to the condition such as:\n-  // c_2 = a_4 < b_7\n-  // if (c_2)\n-\n-  FOR_EACH_GORI_EXPORT_NAME (*(src.gori ()), bb, name)\n-    {\n-      if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n-\tcontinue;\n-      gimple *stmt = SSA_NAME_DEF_STMT (name);\n-      handler = gimple_range_handler (stmt);\n-      if (!handler)\n-\tcontinue;\n-      tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n-      tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n-      if (ssa1 && ssa2)\n-\t{\n-\t  if (e0 && src.gori ()->outgoing_edge_range_p (r, e0, name, *q)\n-\t      && r.singleton_p ())\n-\t    {\n-\t      relation_kind relation = handler->op1_op2_relation (r);\n-\t      if (relation != VREL_NONE)\n-\t\tsrc.register_relation (e0, relation, ssa1, ssa2);\n-\t    }\n-\t  if (e1 && src.gori ()->outgoing_edge_range_p (r, e1, name, *q)\n-\t      && r.singleton_p ())\n-\t    {\n-\t      relation_kind relation = handler->op1_op2_relation (r);\n-\t      if (relation != VREL_NONE)\n-\t\tsrc.register_relation (e1, relation, ssa1, ssa2);\n-\t    }\n-\t}\n-    }\n-}\n-// --------------------------------------------------------------------------\n // trace_ranger implementation.\n \n "}, {"sha": "aa620393dea923c7ee7de062b03059c877a86b69", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 4, "deletions": 140, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c85ff754927c518ed97da5e0221eeea742c9aa7/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=4c85ff754927c518ed97da5e0221eeea742c9aa7", "patch": "@@ -19,29 +19,18 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-#ifndef GCC_GIMPLE_RANGE_STMT_H\n-#define GCC_GIMPLE_RANGE_STMT_H\n+#ifndef GCC_GIMPLE_RANGE_H\n+#define GCC_GIMPLE_RANGE_H\n \n \n #include \"range.h\"\n #include \"value-query.h\"\n #include \"range-op.h\"\n #include \"gimple-range-edge.h\"\n+#include \"gimple-range-fold.h\"\n #include \"gimple-range-gori.h\"\n #include \"gimple-range-cache.h\"\n \n-// This file is the main include point for gimple ranges.\n-// There are two fold_range routines of interest:\n-//   bool fold_range (irange &r, gimple *s, range_query *q)\n-//   bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q)\n-// These routines will fold stmt S into the result irange R.\n-// Any ssa_names on the stmt will be calculated using the range_query\n-// parameter via a call to range_of_expr.\n-// If no range_query is provided, current global range info will be used.\n-// The second variation specifies an edge, and stmt S is recalculated as if\n-// it appeared on that edge.\n-\n-\n // This is the basic range generator interface.\n //\n // This base class provides all the API entry points, but only provides\n@@ -73,131 +62,6 @@ class gimple_ranger : public range_query\n   ranger_cache m_cache;\n };\n \n-// Source of all operands for fold_using_range and gori_compute.\n-// It abstracts out the source of an operand so it can come from a stmt or\n-// and edge or anywhere a derived class of fur_source wants.\n-// THe default simply picks up ranges from the current range_query.\n-\n-class fur_source\n-{\n-public:\n-  fur_source (range_query *q = NULL);\n-  inline range_query *query () { return m_query; }\n-  inline class gori_compute *gori () { return m_gori; };\n-  virtual bool get_operand (irange &r, tree expr);\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e);\n-  virtual relation_kind query_relation (tree op1, tree op2);\n-  virtual void register_relation (gimple *stmt, relation_kind k, tree op1,\n-\t\t\t\t  tree op2);\n-  virtual void register_relation (edge e, relation_kind k, tree op1,\n-\t\t\t\t  tree op2);\n-protected:\n-  range_query *m_query;\n-  gori_compute *m_gori;\n-};\n-\n-// fur_stmt is the specification for drawing an operand from range_query Q\n-// via a range_of_Expr call on stmt S.\n-\n-class fur_stmt : public fur_source\n-{\n-public:\n-  fur_stmt (gimple *s, range_query *q = NULL);\n-  virtual bool get_operand (irange &r, tree expr) OVERRIDE;\n-  virtual bool get_phi_operand (irange &r, tree expr, edge e) OVERRIDE;\n-  virtual relation_kind query_relation (tree op1, tree op2) OVERRIDE;\n-private:\n-  gimple *m_stmt;\n-};\n-\n-\n-// Fold stmt S into range R using range query Q.\n-bool fold_range (irange &r, gimple *s, range_query *q = NULL);\n-// Recalculate stmt S into R using range query Q as if it were on edge ON_EDGE.\n-bool fold_range (irange &r, gimple *s, edge on_edge, range_query *q = NULL);\n-// These routines allow you to specify the operands to use when folding.\n-// Any excess queries will be drawn from the current range_query.\n-bool fold_range (irange &r, gimple *s, irange &r1);\n-bool fold_range (irange &r, gimple *s, irange &r1, irange &r2);\n-bool fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector);\n-\n-// This class uses ranges to fold a gimple statement producinf a range for\n-// the LHS.  The source of all operands is supplied via the fur_source class\n-// which provides a range_query as well as a source location and any other\n-// required information.\n-\n-class fold_using_range\n-{\n-public:\n-  bool fold_stmt (irange &r, gimple *s, class fur_source &src,\n-\t\t  tree name = NULL_TREE);\n-protected:\n-  bool range_of_range_op (irange &r, gimple *s, fur_source &src);\n-  bool range_of_call (irange &r, gcall *call, fur_source &src);\n-  bool range_of_cond_expr (irange &r, gassign* cond, fur_source &src);\n-  bool range_of_address (irange &r, gimple *s, fur_source &src);\n-  bool range_of_builtin_call (irange &r, gcall *call, fur_source &src);\n-  void range_of_builtin_ubsan_call (irange &r, gcall *call, tree_code code,\n-\t\t\t\t    fur_source &src);\n-  bool range_of_phi (irange &r, gphi *phi, fur_source &src);\n-  void range_of_ssa_name_with_loop_info (irange &, tree, class loop *, gphi *,\n-\t\t\t\t\t fur_source &src);\n-  void relation_fold_and_or (irange& lhs_range, gimple *s, fur_source &src);\n-  void postfold_gcond_edges (gcond *s, fur_source &src);\n-};\n-\n-\n-// These routines provide a GIMPLE interface to the range-ops code.\n-extern tree gimple_range_operand1 (const gimple *s);\n-extern tree gimple_range_operand2 (const gimple *s);\n-extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range);\n-extern bool gimple_range_calc_op1 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range,\n-\t\t\t\t   const irange &op2_range);\n-extern bool gimple_range_calc_op2 (irange &r, const gimple *s,\n-\t\t\t\t   const irange &lhs_range,\n-\t\t\t\t   const irange &op1_range);\n-\n-\n-// Return the range_operator pointer for this statement.  This routine\n-// can also be used to gate whether a routine is range-ops enabled.\n-\n-static inline range_operator *\n-gimple_range_handler (const gimple *s)\n-{\n-  if (const gassign *ass = dyn_cast<const gassign *> (s))\n-    return range_op_handler (gimple_assign_rhs_code (ass),\n-\t\t\t     TREE_TYPE (gimple_assign_lhs (ass)));\n-  if (const gcond *cond = dyn_cast<const gcond *> (s))\n-    return range_op_handler (gimple_cond_code (cond),\n-\t\t\t     TREE_TYPE (gimple_cond_lhs (cond)));\n-  return NULL;\n-}\n-\n-// Return EXP if it is an SSA_NAME with a type supported by gimple ranges.\n-\n-static inline tree\n-gimple_range_ssa_p (tree exp)\n-{\n-  if (exp && TREE_CODE (exp) == SSA_NAME &&\n-      !SSA_NAME_IS_VIRTUAL_OPERAND (exp) &&\n-      irange::supports_type_p (TREE_TYPE (exp)))\n-    return exp;\n-  return NULL_TREE;\n-}\n-\n-// Return true if TYPE1 and TYPE2 are compatible range types.\n-\n-static inline bool\n-range_compatible_p (tree type1, tree type2)\n-{\n-  // types_compatible_p requires conversion in both directions to be useless.\n-  // GIMPLE only requires a cast one way in order to be compatible.\n-  // Ranges really only need the sign and precision to be the same.\n-  return (TYPE_PRECISION (type1) == TYPE_PRECISION (type2)\n-\t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n-}\n \n // This class overloads the ranger routines to provide tracing facilties\n // Entry and exit values to each of the APIs is placed in the dumpfile.\n@@ -227,4 +91,4 @@ class trace_ranger : public gimple_ranger\n extern gimple_ranger *enable_ranger (struct function *);\n extern void disable_ranger (struct function *);\n \n-#endif // GCC_GIMPLE_RANGE_STMT_H\n+#endif // GCC_GIMPLE_RANGE_H"}]}