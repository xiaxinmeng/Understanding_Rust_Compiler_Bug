{"sha": "0e2b736c8077b268b5beb83fb6ab3745405a5407", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUyYjczNmM4MDc3YjI2OGI1YmViODNmYjZhYjM3NDU0MDVhNTQwNw==", "commit": {"author": {"name": "Robert Lipe", "email": "robertl@dgii.com", "date": "1998-01-13T22:27:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-13T22:27:40Z"}, "message": "* sco5.h (ASM_OUTPUT_SECTION_NAME): Refresh from ../svr4.h.\n\nFrom-SVN: r17351", "tree": {"sha": "01c03d40cd731f60b59c224af8c1cbfc8606c2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c03d40cd731f60b59c224af8c1cbfc8606c2a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e2b736c8077b268b5beb83fb6ab3745405a5407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2b736c8077b268b5beb83fb6ab3745405a5407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e2b736c8077b268b5beb83fb6ab3745405a5407", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e2b736c8077b268b5beb83fb6ab3745405a5407/comments", "author": null, "committer": null, "parents": [{"sha": "a3aa3d8c2c1d5551389125a3ee37f4e47c75de3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3aa3d8c2c1d5551389125a3ee37f4e47c75de3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3aa3d8c2c1d5551389125a3ee37f4e47c75de3d"}], "stats": {"total": 61, "additions": 51, "deletions": 10}, "files": [{"sha": "6483c61f2fb24ef5b87d693f7aea441da8eeb96d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e2b736c8077b268b5beb83fb6ab3745405a5407/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e2b736c8077b268b5beb83fb6ab3745405a5407/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e2b736c8077b268b5beb83fb6ab3745405a5407", "patch": "@@ -1,3 +1,7 @@\n+Tue Jan 13 23:27:54 1998  Robert Lipe   (robertl@dgii.com)\n+\n+\t* sco5.h (ASM_OUTPUT_SECTION_NAME): Refresh from ../svr4.h.\n+\n Tue Jan 13 22:47:02 1998  Herman ten Brugge <herman@htbrug.net.HCC.nl>\n \n \t* cppexp.c: Include gansidecl.h"}, {"sha": "6180bd33f34f442c7ec882624f60461bbd0eb7c4", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e2b736c8077b268b5beb83fb6ab3745405a5407/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e2b736c8077b268b5beb83fb6ab3745405a5407/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=0e2b736c8077b268b5beb83fb6ab3745405a5407", "patch": "@@ -508,19 +508,56 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"\"\n \n+/* \n+ * Compensate for the difference between ELF and COFF assembler syntax.\n+ * Otherwise, this is cribbed from ../svr4.h.\n+ * We rename 'gcc_except_table' to the shorter name in preparation\n+ * for the day when we're ready to do DWARF2 eh unwinding under COFF \n+ */\n #undef ASM_OUTPUT_SECTION_NAME\n #define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC) \\\n do {\t\t\t\t\t\t\t\t\t\\\n-  char *snam = NAME ;\t\t\t\t\t\t\t\\\n-  if (strcmp(NAME, \".gcc_except_table\") == 0) snam = \".gccexc\" ;\t\\\n-  if (TARGET_ELF)\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, \t\t\\\n-\t   (DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"ax\" : \t\\\n-\t   (DECL) && DECL_READONLY_SECTION (DECL, RELOC) ? \"a\" : \"aw\");\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \".section\\t%s,\\\"%s\\\"\\n\", snam,\t\t\t\\\n-\t(DECL) && TREE_CODE (DECL) == FUNCTION_DECL ? \"x\" : \t\t\\\n-\t(DECL) && DECL_READONLY_SECTION (DECL, RELOC) ? \"a\" : \"w\");\t\\\n+  static struct section_info                                            \\\n+    {                                                                   \\\n+      struct section_info *next;                                        \\\n+      char *name;                                                       \\\n+      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;                \\\n+    } *sections;                                                        \\\n+  struct section_info *s;                                               \\\n+  char *mode;                                                           \\\n+  enum sect_enum type;                                                  \\\n+  char *sname = NAME ;\t\t\t\t\t\t\t\\\n+  if (strcmp(NAME, \".gcc_except_table\") == 0) sname = \".gccexc\" ;\t\\\n+                                                                        \\\n+  for (s = sections; s; s = s->next)                                    \\\n+    if (!strcmp (NAME, s->name))                                        \\\n+      break;                                                            \\\n+                                                                        \\\n+  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)                        \\\n+    type = SECT_EXEC, mode = (TARGET_ELF) ? \"ax\" : \"x\" ;                \\\n+  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))                 \\\n+    type = SECT_RO, mode = \"a\";                                         \\\n+  else                                                                  \\\n+    type = SECT_RW, mode = (TARGET_ELF) ? \"aw\" : \"w\" ;                  \\\n+                                                                        \\\n+  if (s == 0)                                                           \\\n+    {                                                                   \\\n+      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n+      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));         \\\n+      strcpy (s->name, NAME);                                           \\\n+      s->type = type;                                                   \\\n+      s->next = sections;                                               \\\n+      sections = s;                                                     \\\n+      fprintf (FILE, \".section\\t%s,\\\"%s\\\"%s\\n\", sname, mode,\t\t\\\n+\t\t(TARGET_ELF) ? \",@progbits\" : \"\" );    \t\t\t\\\n+    }                                                                   \\\n+  else                                                                  \\\n+    {                                                                   \\\n+      if (DECL && s->type != type)                                      \\\n+        error_with_decl (DECL, \"%s causes a section type conflict\");    \\\n+                                                                        \\\n+      fprintf (FILE, \".section\\t%s\\n\", sname);                          \\\n+    }                                                                   \\\n } while (0)\n \n #undef ASM_OUTPUT_SKIP"}]}