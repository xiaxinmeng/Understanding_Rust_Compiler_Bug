{"sha": "ce917b0422c145779b83e005afd8433c0c86fb06", "node_id": "C_kwDOANBUbNoAKGNlOTE3YjA0MjJjMTQ1Nzc5YjgzZTAwNWFmZDg0MzNjMGM4NmZiMDY", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-24T01:43:33Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-24T01:43:33Z"}, "message": "analyzer: revamp of heap-allocated regions [PR106473]\n\nPR analyzer/106473 reports a false positive from -Wanalyzer-malloc-leak\non:\n\n  void foo(char **args[], int *argc) {\n      *argc = 1;\n      (*args)[0] = __builtin_malloc(42);\n  }\n\nThe issue is that at the write to *argc we don't know if argc could\npoint within *args, and so we conservatiely set *args to be unknown.\nAt the write \"(*args)[0] = __builtin_malloc(42)\" we have the result of\nthe allocation written through an unknown pointer, so we mark the\nheap_allocated_region as having escaped.\nUnfortunately, within store::canonicalize we overzealously purge the\nheap allocated region, losing the information that it has escaped, and\nthus errnoeously report a leak.\n\nThe first part of the fix is to update store::canonicalize so that it\ndoesn't purge heap_allocated_regions that are marked as escaping.\n\nDoing so fixes the leak false positive, but leads to various state\nexplosions relating to anywhere we have a malloc/free pair in a loop,\nwhere the analysis of the iteration appears to only have been reaching\na fixed state due to a bug in the state merger code that was erroneously\nmerging state about the region allocated in one iteration with that\nof another.  On touching that, the analyzer fails to reach a fixed state\non any loops containing a malloc/free pair, since each analysis of a\nmalloc was creating a new heap_allocated_region instance.\n\nHence the second part of the fix is to revamp how heap_allocated_regions\nare managed within the analyzer.  Rather than create a new one at each\nanalysis of a malloc call, instead we reuse them across the analysis,\nonly creating a new one if the current path's state is referencing all\nof the existing ones.  Hence the heap_allocated_region instances get\nused in a fixed order along every analysis path, so e.g. at:\n\n  if (flag)\n    p = malloc (4096);\n  else\n    p = malloc (1024);\n\nboth paths now use the same heap_allocated_region for their malloc\ncalls - but we still end up with two enodes after the CFG merger, by\nrejecting merger of states with non-equal dynamic extents.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106473\n\t* call-summary.cc\n\t(call_summary_replay::convert_region_from_summary_1): Update for\n\tchange to creation of heap-allocated regions.\n\t* program-state.cc (test_program_state_1): Likewise.\n\t(test_program_state_merging): Likewise.\n\t* region-model-impl-calls.cc (kf_calloc::impl_call_pre): Likewise.\n\t(kf_malloc::impl_call_pre): Likewise.\n\t(kf_operator_new::impl_call_pre): Likewise.\n\t(kf_realloc::impl_call_postsuccess_with_move::update_model): Likewise.\n\t* region-model-manager.cc\n\t(region_model_manager::create_region_for_heap_alloc): Convert\n\tto...\n\t(region_model_manager::get_or_create_region_for_heap_alloc):\n\t...this, reusing an existing region if it's unreferenced in the\n\tclient state.\n\t* region-model-manager.h (region_model_manager::get_num_regions): New.\n\t (region_model_manager::create_region_for_heap_alloc): Convert to...\n\t (region_model_manager::get_or_create_region_for_heap_alloc): ...this.\n\t* region-model.cc (region_to_value_map::can_merge_with_p): Reject\n\tmerger when the values are different.\n\t(region_model::create_region_for_heap_alloc): Convert to...\n\t(region_model::get_or_create_region_for_heap_alloc): ...this.\n\t(region_model::get_referenced_base_regions): New.\n\t(selftest::test_state_merging):  Update for change to creation of\n\theap-allocated regions.\n\t(selftest::test_malloc_constraints): Likewise.\n\t(selftest::test_malloc): Likewise.\n\t* region-model.h: Include \"sbitmap.h\".\n\t(region_model::create_region_for_heap_alloc): Convert to...\n\t(region_model::get_or_create_region_for_heap_alloc): ...this.\n\t(region_model::get_referenced_base_regions): New decl.\n\t* store.cc (store::canonicalize): Don't purge a heap-allocated region\n\tthat's been marked as escaping.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106473\n\t* gcc.dg/analyzer/aliasing-pr106473.c: New test.\n\t* gcc.dg/analyzer/allocation-size-2.c: Add\n\t-fanalyzer-fine-grained\".\n\t* gcc.dg/analyzer/allocation-size-3.c: Likewise.\n\t* gcc.dg/analyzer/explode-1.c: Mark leak with XFAIL.\n\t* gcc.dg/analyzer/explode-3.c: New test.\n\t* gcc.dg/analyzer/malloc-reuse.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "7170a35adfcf6256567f029cc076a97c05f8c010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7170a35adfcf6256567f029cc076a97c05f8c010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce917b0422c145779b83e005afd8433c0c86fb06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce917b0422c145779b83e005afd8433c0c86fb06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce917b0422c145779b83e005afd8433c0c86fb06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce917b0422c145779b83e005afd8433c0c86fb06/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f18b87bfaf0b60f4fd0aaffefb4ca2869aff52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f18b87bfaf0b60f4fd0aaffefb4ca2869aff52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f18b87bfaf0b60f4fd0aaffefb4ca2869aff52"}], "stats": {"total": 232, "additions": 206, "deletions": 26}, "files": [{"sha": "31674736ac57ea2c1d34fe5b291e8d7d7e741d3e", "filename": "gcc/analyzer/call-summary.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fcall-summary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fcall-summary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -726,7 +726,9 @@ call_summary_replay::convert_region_from_summary_1 (const region *summary_reg)\n \t/* If we have a heap-allocated region in the summary, then\n \t   it was allocated within the callee.\n \t   Create a new heap-allocated region to summarize this.  */\n-\treturn mgr->create_region_for_heap_alloc ();\n+\tauto_sbitmap heap_regs_in_use (mgr->get_num_regions ());\n+\tget_caller_model ()->get_referenced_base_regions (heap_regs_in_use);\n+\treturn mgr->get_or_create_region_for_heap_alloc (heap_regs_in_use);\n       }\n       break;\n     case RK_ALLOCA:"}, {"sha": "037dbecb6f1edef95522c6be7eaa8fc91e2da036", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -1733,7 +1733,7 @@ test_program_state_1 ()\n   const svalue *size_in_bytes\n     = mgr->get_or_create_unknown_svalue (size_type_node);\n   const region *new_reg\n-    = model->create_region_for_heap_alloc (size_in_bytes, NULL);\n+    = model->get_or_create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model->set_value (model->get_lvalue (p, NULL),\n \t\t    ptr_sval, NULL);\n@@ -1790,7 +1790,7 @@ test_program_state_merging ()\n   const svalue *size_in_bytes\n     = mgr->get_or_create_unknown_svalue (size_type_node);\n   const region *new_reg\n-    = model0->create_region_for_heap_alloc (size_in_bytes, NULL);\n+    = model0->get_or_create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model0->set_value (model0->get_lvalue (p, &ctxt),\n \t\t     ptr_sval, &ctxt);"}, {"sha": "37cb09f9195e10e437bc4362d9f883b03dacbeb4", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -634,7 +634,7 @@ kf_calloc::impl_call_pre (const call_details &cd) const\n     = mgr->get_or_create_binop (size_type_node, MULT_EXPR,\n \t\t\t\tnmemb_sval, size_sval);\n   const region *new_reg\n-    = model->create_region_for_heap_alloc (prod_sval, cd.get_ctxt ());\n+    = model->get_or_create_region_for_heap_alloc (prod_sval, cd.get_ctxt ());\n   const region *sized_reg\n     = mgr->get_sized_region (new_reg, NULL_TREE, prod_sval);\n   model->zero_fill_region (sized_reg);\n@@ -837,7 +837,7 @@ kf_malloc::impl_call_pre (const call_details &cd) const\n   region_model_manager *mgr = cd.get_manager ();\n   const svalue *size_sval = cd.get_arg_svalue (0);\n   const region *new_reg\n-    = model->create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n+    = model->get_or_create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n   if (cd.get_lhs_type ())\n     {\n       const svalue *ptr_sval\n@@ -1067,7 +1067,7 @@ class kf_operator_new : public known_function\n     region_model_manager *mgr = cd.get_manager ();\n     const svalue *size_sval = cd.get_arg_svalue (0);\n     const region *new_reg\n-      = model->create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n+      = model->get_or_create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n     if (cd.get_lhs_type ())\n       {\n \tconst svalue *ptr_sval\n@@ -1255,7 +1255,7 @@ kf_realloc::impl_call_post (const call_details &cd) const\n \n       /* Create the new region.  */\n       const region *new_reg\n-\t= model->create_region_for_heap_alloc (new_size_sval, ctxt);\n+\t= model->get_or_create_region_for_heap_alloc (new_size_sval, ctxt);\n       const svalue *new_ptr_sval\n \t= mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n       if (!model->add_constraint (new_ptr_sval, NE_EXPR, old_ptr_sval,"}, {"sha": "d9a7ae91a355756ced751083eedb36eec759ff45", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -1678,11 +1678,22 @@ get_region_for_unexpected_tree_code (region_model_context *ctxt,\n   return new_reg;\n }\n \n-/* Return a new region describing a heap-allocated block of memory.  */\n+/* Return a region describing a heap-allocated block of memory.\n+   Reuse an existing heap_allocated_region is its id is not within\n+   BASE_REGS_IN_USE.  */\n \n const region *\n-region_model_manager::create_region_for_heap_alloc ()\n+region_model_manager::\n+get_or_create_region_for_heap_alloc (const sbitmap &base_regs_in_use)\n {\n+  /* Try to reuse an existing region, if it's unreferenced in the\n+     client state.  */\n+  for (auto existing_reg : m_managed_dynamic_regions)\n+    if (!bitmap_bit_p (base_regs_in_use, existing_reg->get_id ()))\n+      if (existing_reg->get_kind () == RK_HEAP_ALLOCATED)\n+\treturn existing_reg;\n+\n+  /* All existing ones (if any) are in use; create a new one.  */\n   region *reg\n     = new heap_allocated_region (alloc_region_id (), &m_heap_region);\n   m_managed_dynamic_regions.safe_push (reg);"}, {"sha": "22f980056fad951eb4e201cc6d295234e83035b7", "filename": "gcc/analyzer/region-model-manager.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.h?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -100,6 +100,7 @@ class region_model_manager\n   const svalue *create_unique_svalue (tree type);\n \n   /* region consolidation.  */\n+  unsigned get_num_regions () const { return m_next_region_id; }\n   const stack_region * get_stack_region () const { return &m_stack_region; }\n   const heap_region *get_heap_region () const { return &m_heap_region; }\n   const code_region *get_code_region () const { return &m_code_region; }\n@@ -152,7 +153,8 @@ class region_model_manager\n   /* Dynamically-allocated region instances.\n      The number of these within the analysis can grow arbitrarily.\n      They are still owned by the manager.  */\n-  const region *create_region_for_heap_alloc ();\n+  const region *\n+  get_or_create_region_for_heap_alloc (const sbitmap &base_regs_in_use);\n   const region *create_region_for_alloca (const frame_region *frame);\n \n   void log_stats (logger *logger, bool show_objs) const;"}, {"sha": "7f2c0b6bd1aa3cbefb35aada597e8a4b5ed745d0", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -209,8 +209,9 @@ region_to_value_map::dump (bool simple) const\n    to OUT.\n \n    For now, write (region, value) mappings that are in common between THIS\n-   and OTHER to OUT, effectively taking the intersection, rather than\n-   rejecting differences.  */\n+   and OTHER to OUT, effectively taking the intersection.\n+\n+   Reject merger of different values.  */\n \n bool\n region_to_value_map::can_merge_with_p (const region_to_value_map &other,\n@@ -222,8 +223,12 @@ region_to_value_map::can_merge_with_p (const region_to_value_map &other,\n       const svalue *iter_sval = iter.second;\n       const svalue * const * other_slot = other.get (iter_reg);\n       if (other_slot)\n-\tif (iter_sval == *other_slot)\n-\t  out->put (iter_reg, iter_sval);\n+\t{\n+\t  if (iter_sval == *other_slot)\n+\t    out->put (iter_reg, iter_sval);\n+\t  else\n+\t    return false;\n+\t}\n     }\n   return true;\n }\n@@ -5498,19 +5503,52 @@ region_model::check_dynamic_size_for_floats (const svalue *size_in_bytes,\n \t}\n }\n \n-/* Return a new region describing a heap-allocated block of memory.\n-   Use CTXT to complain about tainted sizes.  */\n+/* Return a region describing a heap-allocated block of memory.\n+   Use CTXT to complain about tainted sizes.\n+\n+   Reuse an existing heap_allocated_region if it's not being referenced by\n+   this region_model; otherwise create a new one.  */\n \n const region *\n-region_model::create_region_for_heap_alloc (const svalue *size_in_bytes,\n-\t\t\t\t\t    region_model_context *ctxt)\n-{\n-  const region *reg = m_mgr->create_region_for_heap_alloc ();\n+region_model::get_or_create_region_for_heap_alloc (const svalue *size_in_bytes,\n+\t\t\t\t\t\t   region_model_context *ctxt)\n+{\n+  /* Determine which regions are referenced in this region_model, so that\n+     we can reuse an existing heap_allocated_region if it's not in use on\n+     this path.  */\n+  auto_sbitmap base_regs_in_use (m_mgr->get_num_regions ());\n+  get_referenced_base_regions (base_regs_in_use);\n+  const region *reg\n+    = m_mgr->get_or_create_region_for_heap_alloc (base_regs_in_use);\n   if (compat_types_p (size_in_bytes->get_type (), size_type_node))\n     set_dynamic_extents (reg, size_in_bytes, ctxt);\n   return reg;\n }\n \n+/* Populate OUT_IDS with the set of IDs of those base regions which are\n+   reachable in this region_model.  */\n+\n+void\n+region_model::get_referenced_base_regions (auto_sbitmap &out_ids) const\n+{\n+  reachable_regions reachable_regs (const_cast<region_model *> (this));\n+  m_store.for_each_cluster (reachable_regions::init_cluster_cb,\n+\t\t\t    &reachable_regs);\n+  /* Get regions for locals that have explicitly bound values.  */\n+  for (store::cluster_map_t::iterator iter = m_store.begin ();\n+       iter != m_store.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      if (const region *parent = base_reg->get_parent_region ())\n+\tif (parent->get_kind () == RK_FRAME)\n+\t  reachable_regs.add (base_reg, false);\n+    }\n+\n+  bitmap_clear (out_ids);\n+  for (auto iter_reg : reachable_regs)\n+    bitmap_set_bit (out_ids, iter_reg->get_id ());\n+}\n+\n /* Return a new region describing a block of memory allocated within the\n    current frame.\n    Use CTXT to complain about tainted sizes.  */\n@@ -7608,7 +7646,7 @@ test_state_merging ()\n     tree size = build_int_cst (size_type_node, 1024);\n     const svalue *size_sval = mgr.get_or_create_constant_svalue (size);\n     const region *new_reg\n-      = model0.create_region_for_heap_alloc (size_sval, &ctxt);\n+      = model0.get_or_create_region_for_heap_alloc (size_sval, &ctxt);\n     const svalue *ptr_sval = mgr.get_ptr_svalue (ptr_type_node, new_reg);\n     model0.set_value (model0.get_lvalue (p, &ctxt),\n \t\t      ptr_sval, &ctxt);\n@@ -7996,7 +8034,8 @@ test_malloc_constraints ()\n \n   const svalue *size_in_bytes\n     = mgr.get_or_create_unknown_svalue (size_type_node);\n-  const region *reg = model.create_region_for_heap_alloc (size_in_bytes, NULL);\n+  const region *reg\n+    = model.get_or_create_region_for_heap_alloc (size_in_bytes, NULL);\n   const svalue *sval = mgr.get_ptr_svalue (ptr_type_node, reg);\n   model.set_value (model.get_lvalue (p, NULL), sval, NULL);\n   model.set_value (q, p, NULL);\n@@ -8225,7 +8264,8 @@ test_malloc ()\n \n   /* \"p = malloc (n * 4);\".  */\n   const svalue *size_sval = model.get_rvalue (n_times_4, &ctxt);\n-  const region *reg = model.create_region_for_heap_alloc (size_sval, &ctxt);\n+  const region *reg\n+    = model.get_or_create_region_for_heap_alloc (size_sval, &ctxt);\n   const svalue *ptr = mgr.get_ptr_svalue (int_star, reg);\n   model.set_value (model.get_lvalue (p, &ctxt), ptr, &ctxt);\n   ASSERT_EQ (model.get_capacity (reg), size_sval);"}, {"sha": "86c42a24ff2c9bff05c6bb6d5c957c2bcabb19ec", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n       (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n      http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf  */\n \n+#include \"sbitmap.h\"\n #include \"selftest.h\"\n #include \"analyzer/svalue.h\"\n #include \"analyzer/region.h\"\n@@ -434,10 +435,12 @@ class region_model\n \t\t       region_model_context *ctxt,\n \t\t       rejected_constraint **out);\n \n-  const region *create_region_for_heap_alloc (const svalue *size_in_bytes,\n-\t\t\t\t\t      region_model_context *ctxt);\n+  const region *\n+  get_or_create_region_for_heap_alloc (const svalue *size_in_bytes,\n+\t\t\t\t       region_model_context *ctxt);\n   const region *create_region_for_alloca (const svalue *size_in_bytes,\n \t\t\t\t\t  region_model_context *ctxt);\n+  void get_referenced_base_regions (auto_sbitmap &out_ids) const;\n \n   tree get_representative_tree (const svalue *sval) const;\n   tree get_representative_tree (const region *reg) const;"}, {"sha": "99939b7ea7082553adcc01d98ef9ecabddd9187b", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -3069,6 +3069,15 @@ store::canonicalize (store_manager *mgr)\n       binding_cluster *cluster = (*iter).second;\n       if (base_reg->get_kind () == RK_HEAP_ALLOCATED)\n \t{\n+\t  /* Don't purge a heap-allocated region that's been marked as\n+\t     escaping, since this could be recording that a ptr to it\n+\t     was written to an unknown symbolic region along this\n+\t     path, and so we don't know whether it's referenced or\n+\t     not, and hence should report it as leaking\n+\t     (PR analyzer/106473).  */\n+\t  if (cluster->escaped_p ())\n+\t    continue;\n+\n \t  if (cluster->empty_p ())\n \t    if (!s.m_regs.contains (base_reg))\n \t      purgeable_regions.add (base_reg);"}, {"sha": "afd1492252e0aff12efefd51fb75eb1433070ca6", "filename": "gcc/testsuite/gcc.dg/analyzer/aliasing-pr106473.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-pr106473.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-pr106473.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-pr106473.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -0,0 +1,5 @@\n+void foo(char **args[], int *argc)\n+{\n+  *argc = 1;\n+  (*args)[0] = __builtin_malloc(42);\n+}"}, {"sha": "2cf64e97b412078823c686b2ee4c3db1870cbe89", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-2.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-additional-options \"-fanalyzer-fine-grained\" }\n+   -fanalyzer-fine-grained is currently required; see PR analyzer/107851.  */\n+\n #include <stdlib.h>\n #include <stdio.h>\n #include <stdint.h>"}, {"sha": "6751441dd18f7ee764ef8fe09df5bb6a454d206e", "filename": "gcc/testsuite/gcc.dg/analyzer/allocation-size-3.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fallocation-size-3.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -1,3 +1,6 @@\n+/* { dg-additional-options \"-fanalyzer-fine-grained\" }\n+   -fanalyzer-fine-grained is currently required; see PR analyzer/107851.  */\n+\n /* { dg-additional-options -Wno-analyzer-out-of-bounds } */\n \n #include <stdlib.h>"}, {"sha": "7d05f40a544b04c196f4de7fe4332e21bdd258b6", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -47,7 +47,8 @@ void test (void)\n \t{\n \tdefault:\n \tcase 0:\n-\t  *pp = malloc (16); /* { dg-warning \"leak\" } */\n+\t  *pp = malloc (16);  /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n+\t  // TODO: xfail\n \t  break;\n \tcase 1:\n \t  free (*pp);"}, {"sha": "1657836df9890b39922ac2cb006950b59bae68a0", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-3.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include <stdlib.h>\n+\n+extern int get (void);\n+\n+/* In theory each of p0...p1 can be in various malloc states,\n+   independently, so the total combined number of states\n+   at any program point within the loop is NUM_VARS * NUM_STATES.  */\n+\n+void test (void)\n+{\n+  void *p0, *p1;\n+  void **pp;\n+  while (get ())\n+    {\n+      switch (get ())\n+\t{\n+\tdefault:\n+\tcase 0:\n+\t  pp = &p0;\n+\t  break;\n+\tcase 1:\n+\t  pp = &p1;\n+\t  break;\n+\t}\n+\n+      switch (get ())\n+\t{\n+\tdefault:\n+\tcase 0:\n+\t  *pp = malloc (16); /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n+\t  // TODO: xfail\n+\t  break;\n+\tcase 1:\n+\t  free (*pp);\n+\t  break;\n+\tcase 2:\n+\t  /* no-op.  */\n+\t  break;\n+\t}\n+    }\n+}"}, {"sha": "4575ff5563d79e29c3c4b480bd08f787326f17a3", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-reuse.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-reuse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce917b0422c145779b83e005afd8433c0c86fb06/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-reuse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-reuse.c?ref=ce917b0422c145779b83e005afd8433c0c86fb06", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target alloca } */\n+\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+/* Multiple calls to malloc (without a free) should return non-equal pointers.  */\n+\n+void test_1 (void)\n+{\n+  void *p, *q;\n+  p = malloc (1024);\n+  if (!p)\n+    return;\n+  q = malloc (1024);\n+  __analyzer_eval (p == q); /* { dg-warning \"FALSE\" } */\n+  free (p);\n+  free (q);\n+}\n+\n+/* Multiple calls to malloc with a free might or might not\n+   return the same pointer.  */\n+\n+void test_2 (void)\n+{\n+  void *p, *q;\n+  p = malloc (1024);\n+  if (!p)\n+    return;\n+  free (p);\n+  \n+  q = malloc (1024);\n+  __analyzer_eval (p == q); /* { dg-warning \"UNKNOWN\" \"ideal\" { xfail *-*-* } } */\n+  /* { dg-bogus \"FALSE\" \"status quo\" { xfail *-*-* } .-1 } */\n+  // TODO: ideally this should be UNKNOWN\n+  free (q);\n+}\n+\n+void test_two_malloc_sites_same_size (int flag)\n+{\n+  void *p;\n+  if (flag)\n+    p = malloc (1024);\n+  else\n+    p = malloc (1024);\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+  free (p);\n+}\n+\n+void test_two_malloc_sites_different_sizes (int flag)\n+{\n+  void *p;\n+  if (flag)\n+    p = malloc (4096);\n+  else\n+    p = malloc (1024);\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  free (p);\n+}"}]}