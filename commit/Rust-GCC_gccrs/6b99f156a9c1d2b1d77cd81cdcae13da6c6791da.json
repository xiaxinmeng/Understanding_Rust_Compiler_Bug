{"sha": "6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5OWYxNTZhOWMxZDJiMWQ3N2NkODFjZGNhZTEzZGE2YzY3OTFkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-09-04T10:34:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-09-04T10:34:35Z"}, "message": "tree-vrp.c (vrp_evaluate_conditional_warnv_with_ops_using_ranges): Break out from ...\n\n\t* tree-vrp.c (vrp_evaluate_conditional_warnv_with_ops_using_ranges):\n\tBreak out from ...\n\t(vrp_evaluate_conditional_warnv_with_ops): ... this one.  Add\n\tusing_ranges argument.\n\t(vrp_evaluate_conditional): Avoid bogus warning for type range.\n\t(vrp_visit_cond_stmt): Update call of\n\tvrp_evaluate_conditional_warnv_with_ops\n\nFrom-SVN: r139981", "tree": {"sha": "dce5c124c42879e1ded5e37490c29e649142d3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dce5c124c42879e1ded5e37490c29e649142d3f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da/comments", "author": null, "committer": null, "parents": [{"sha": "4db15d75ec50a9eb20ebd8fa95a1fda5c7a635e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db15d75ec50a9eb20ebd8fa95a1fda5c7a635e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4db15d75ec50a9eb20ebd8fa95a1fda5c7a635e3"}], "stats": {"total": 73, "additions": 53, "deletions": 20}, "files": [{"sha": "02d59e08915a0c5c70496f9a49f44f0744fd6fed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "patch": "@@ -1,3 +1,13 @@\n+2008-09-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-vrp.c (vrp_evaluate_conditional_warnv_with_ops_using_ranges):\n+\tBreak out from ...\n+\t(vrp_evaluate_conditional_warnv_with_ops): ... this one.  Add\n+\tusing_ranges argument.\n+\t(vrp_evaluate_conditional): Avoid bogus warning for type range.\n+\t(vrp_visit_cond_stmt): Update call of\n+\tvrp_evaluate_conditional_warnv_with_ops\n+\n 2008-09-04  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/37345"}, {"sha": "46aa69d59ae04e297d88313d5706af79bd84cb17", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b99f156a9c1d2b1d77cd81cdcae13da6c6791da/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6b99f156a9c1d2b1d77cd81cdcae13da6c6791da", "patch": "@@ -57,7 +57,8 @@ static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n-\t\t\t\t\t\t     tree, tree, bool, bool *);\n+\t\t\t\t\t\t     tree, tree, bool, bool *,\n+\t\t\t\t\t\t     bool *);\n \n /* Location information for ASSERT_EXPRs.  Each instance of this\n    structure describes an ASSERT_EXPR for an SSA name.  Since a single\n@@ -2905,7 +2906,8 @@ extract_range_from_comparison (value_range_t *vr, enum tree_code code,\n   bool sop = false;\n   tree val;\n   \n-  val = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, false, &sop);\n+  val = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, false, &sop,\n+  \t\t\t\t\t\t NULL);\n \n   /* A disadvantage of using a special infinity as an overflow\n      representation is that we lose the ability to record overflow\n@@ -5447,20 +5449,51 @@ compare_names (enum tree_code comp, tree n1, tree n2,\n   return NULL_TREE;\n }\n \n+/* Helper function for vrp_evaluate_conditional_warnv.  */\n+\n+static tree\n+vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code code,\n+\t\t\t\t\t\t      tree op0, tree op1,\n+\t\t\t\t\t\t      bool * strict_overflow_p)\n+{\n+  value_range_t *vr0, *vr1;\n+\n+  vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n+  vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n+\n+  if (vr0 && vr1)\n+    return compare_ranges (code, vr0, vr1, strict_overflow_p);\n+  else if (vr0 && vr1 == NULL)\n+    return compare_range_with_value (code, vr0, op1, strict_overflow_p);\n+  else if (vr0 == NULL && vr1)\n+    return (compare_range_with_value\n+\t    (swap_tree_comparison (code), vr1, op0, strict_overflow_p));\n+  return NULL;\n+}\n+\n /* Helper function for vrp_evaluate_conditional_warnv. */\n \n static tree\n vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n \t\t\t\t\t tree op1, bool use_equiv_p,\n-\t\t\t\t\t bool *strict_overflow_p)\n+\t\t\t\t\t bool *strict_overflow_p, bool *only_ranges)\n {\n+  tree ret;\n+  if (only_ranges)\n+    *only_ranges = true;\n+\n   /* We only deal with integral and pointer types.  */\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n       && !POINTER_TYPE_P (TREE_TYPE (op0)))\n     return NULL_TREE;\n \n   if (use_equiv_p)\n     {\n+      if (only_ranges\n+          && (ret = vrp_evaluate_conditional_warnv_with_ops_using_ranges\n+\t              (code, op0, op1, strict_overflow_p)))\n+\treturn ret;\n+      *only_ranges = false;\n       if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME)\n \treturn compare_names (code, op0, op1, strict_overflow_p);\n       else if (TREE_CODE (op0) == SSA_NAME)\n@@ -5470,20 +5503,8 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n \t\t(swap_tree_comparison (code), op1, op0, strict_overflow_p));\n     }\n   else\n-    {\n-      value_range_t *vr0, *vr1;\n-\n-      vr0 = (TREE_CODE (op0) == SSA_NAME) ? get_value_range (op0) : NULL;\n-      vr1 = (TREE_CODE (op1) == SSA_NAME) ? get_value_range (op1) : NULL;\n-\n-      if (vr0 && vr1)\n-\treturn compare_ranges (code, vr0, vr1, strict_overflow_p);\n-      else if (vr0 && vr1 == NULL)\n-\treturn compare_range_with_value (code, vr0, op1, strict_overflow_p);\n-      else if (vr0 == NULL && vr1)\n-\treturn (compare_range_with_value\n-\t\t(swap_tree_comparison (code), vr1, op0, strict_overflow_p));\n-    }\n+    return vrp_evaluate_conditional_warnv_with_ops_using_ranges (code, op0, op1,\n+\t\t\t\t\t\t\t\t strict_overflow_p);\n   return NULL_TREE;\n }\n \n@@ -5499,9 +5520,11 @@ vrp_evaluate_conditional (enum tree_code code, tree op0, tree op1, gimple stmt)\n {\n   bool sop;\n   tree ret;\n+  bool only_ranges;\n \n   sop = false;\n-  ret = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, true, &sop);\n+  ret = vrp_evaluate_conditional_warnv_with_ops (code, op0, op1, true, &sop,\n+  \t\t\t\t\t\t &only_ranges);\n \n   if (ret && sop)\n     {\n@@ -5534,7 +5557,7 @@ vrp_evaluate_conditional (enum tree_code code, tree op0, tree op1, gimple stmt)\n     }\n \n   if (warn_type_limits\n-      && ret\n+      && ret && only_ranges\n       && TREE_CODE_CLASS (code) == tcc_comparison\n       && TREE_CODE (op0) == SSA_NAME)\n     {\n@@ -5658,7 +5681,7 @@ vrp_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n   val = vrp_evaluate_conditional_warnv_with_ops (gimple_cond_code (stmt),\n \t\t\t\t\t\t gimple_cond_lhs (stmt),\n \t\t\t\t\t\t gimple_cond_rhs (stmt),\n-\t\t\t\t\t\t false, &sop);\n+\t\t\t\t\t\t false, &sop, NULL);\n   if (val)\n     {\n       if (!sop)"}]}