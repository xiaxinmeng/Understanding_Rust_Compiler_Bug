{"sha": "a0e39c36e20828b30b2f68a25292ecd7963fafce", "node_id": "C_kwDOANBUbNoAKGEwZTM5YzM2ZTIwODI4YjMwYjJmNjhhMjUyOTJlY2Q3OTYzZmFmY2U", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-05-25T12:18:47Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-06-01T08:45:11Z"}, "message": "ast: Add AstBuilder class.\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-ast-builder.cc: New file.\n\t* ast/rust-ast-builder.h: New file.", "tree": {"sha": "df77dd22e77271fbe3cbeaa8c4b0ea63ba22fa00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df77dd22e77271fbe3cbeaa8c4b0ea63ba22fa00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0e39c36e20828b30b2f68a25292ecd7963fafce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e39c36e20828b30b2f68a25292ecd7963fafce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e39c36e20828b30b2f68a25292ecd7963fafce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e39c36e20828b30b2f68a25292ecd7963fafce/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4359c47260614f123a6d186ccbf2a2522a30125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4359c47260614f123a6d186ccbf2a2522a30125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4359c47260614f123a6d186ccbf2a2522a30125"}], "stats": {"total": 220, "additions": 220, "deletions": 0}, "files": [{"sha": "06116540c194122fedb4127d40218a647da019ba", "filename": "gcc/rust/ast/rust-ast-builder.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0e39c36e20828b30b2f68a25292ecd7963fafce/gcc%2Frust%2Fast%2Frust-ast-builder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0e39c36e20828b30b2f68a25292ecd7963fafce/gcc%2Frust%2Fast%2Frust-ast-builder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-builder.cc?ref=a0e39c36e20828b30b2f68a25292ecd7963fafce", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-builder.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::unique_ptr<Expr>\n+AstBuilder::call (std::unique_ptr<Expr> &&path,\n+\t\t  std::vector<std::unique_ptr<Expr>> &&args)\n+{\n+  return std::unique_ptr<Expr> (\n+    new CallExpr (std::move (path), std::move (args), {}, loc));\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::identifier (std::string name)\n+{\n+  return std::unique_ptr<Expr> (new IdentifierExpr (name, {}, loc));\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::tuple_idx (std::string receiver, int idx)\n+{\n+  return std::unique_ptr<Expr> (\n+    new TupleIndexExpr (identifier (receiver), idx, {}, loc));\n+}\n+\n+FunctionQualifiers\n+AstBuilder::fn_qualifiers ()\n+{\n+  return FunctionQualifiers (loc, AsyncConstStatus::NONE, false);\n+}\n+\n+PathExprSegment\n+AstBuilder::path_segment (std::string seg)\n+{\n+  return PathExprSegment (PathIdentSegment (seg, loc), loc);\n+}\n+\n+std::unique_ptr<TypePathSegment>\n+AstBuilder::type_path_segment (std::string seg)\n+{\n+  return std::unique_ptr<TypePathSegment> (\n+    new TypePathSegment (seg, false, loc));\n+}\n+\n+std::unique_ptr<Type>\n+AstBuilder::single_type_path (std::string type)\n+{\n+  auto segments = std::vector<std::unique_ptr<TypePathSegment>> ();\n+  segments.emplace_back (type_path_segment (type));\n+\n+  return std::unique_ptr<Type> (new TypePath (std::move (segments), loc));\n+}\n+\n+PathInExpression\n+AstBuilder::path_in_expression (std::vector<std::string> &&segments)\n+{\n+  auto path_segments = std::vector<PathExprSegment> ();\n+  for (auto &seg : segments)\n+    path_segments.emplace_back (path_segment (seg));\n+\n+  return PathInExpression (std::move (path_segments), {}, loc);\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::struct_expr_struct (std::string struct_name)\n+{\n+  return std::unique_ptr<Expr> (\n+    new StructExprStruct (path_in_expression ({struct_name}), {}, {}, loc));\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::block (std::vector<std::unique_ptr<Stmt>> &&stmts,\n+\t\t   std::unique_ptr<Expr> &&tail_expr)\n+{\n+  return std::unique_ptr<Expr> (\n+    new BlockExpr (std::move (stmts), std::move (tail_expr), {}, {}, loc, loc));\n+}\n+\n+std::unique_ptr<Stmt>\n+AstBuilder::let (std::unique_ptr<Pattern> pattern, std::unique_ptr<Type> type,\n+\t\t std::unique_ptr<Expr> init)\n+{\n+  return std::unique_ptr<Stmt> (\n+    new LetStmt (/* needs a pattern here, not just a name */ nullptr,\n+\t\t std::move (init), std::move (type), {}, loc));\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::ref (std::unique_ptr<Expr> &&of, bool mut)\n+{\n+  return std::unique_ptr<Expr> (\n+    new BorrowExpr (std::move (of), mut, /* is double */ false, {}, loc));\n+}\n+\n+std::unique_ptr<Expr>\n+AstBuilder::deref (std::unique_ptr<Expr> &&of)\n+{\n+  return std::unique_ptr<Expr> (new DereferenceExpr (std::move (of), {}, loc));\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "4bbd931a7f97d41612943b363a4147a2ace7a3a5", "filename": "gcc/rust/ast/rust-ast-builder.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0e39c36e20828b30b2f68a25292ecd7963fafce/gcc%2Frust%2Fast%2Frust-ast-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0e39c36e20828b30b2f68a25292ecd7963fafce/gcc%2Frust%2Fast%2Frust-ast-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-builder.h?ref=a0e39c36e20828b30b2f68a25292ecd7963fafce", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef AST_BUILDER_H\n+#define AST_BUILDER_H\n+\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+// TODO: Use this builder when expanding regular macros\n+/* Builder class with helper methods to create AST nodes. This builder is\n+ * tailored towards generating multiple AST nodes from a single location, and\n+ * may not be suitable to other purposes */\n+class AstBuilder\n+{\n+public:\n+  AstBuilder (Location loc) : loc (loc) {}\n+\n+  /* Create an identifier expression (`variable`) */\n+  std::unique_ptr<Expr> identifier (std::string name);\n+\n+  /* Create a tuple index expression (`receiver.0`) */\n+  std::unique_ptr<Expr> tuple_idx (std::string receiver, int idx);\n+\n+  /* Create a reference to an expression (`&of`) */\n+  std::unique_ptr<Expr> ref (std::unique_ptr<Expr> &&of, bool mut = false);\n+\n+  /* Create a dereference of an expression (`*of`) */\n+  std::unique_ptr<Expr> deref (std::unique_ptr<Expr> &&of);\n+\n+  /* Create a block with an optional tail expression */\n+  std::unique_ptr<Expr> block (std::vector<std::unique_ptr<Stmt>> &&stmts,\n+\t\t\t       std::unique_ptr<Expr> &&tail_expr = nullptr);\n+\n+  /* Create a let binding with an optional type and initializer (`let <name> :\n+   * <type> = <init>`) */\n+  std::unique_ptr<Stmt> let (std::unique_ptr<Pattern> pattern,\n+\t\t\t     std::unique_ptr<Type> type = nullptr,\n+\t\t\t     std::unique_ptr<Expr> init = nullptr);\n+\n+  /**\n+   * Create a call expression to a function, struct or enum variant, given its\n+   * arguments (`path(arg0, arg1, arg2)`)\n+   */\n+  std::unique_ptr<Expr> call (std::unique_ptr<Expr> &&path,\n+\t\t\t      std::vector<std::unique_ptr<Expr>> &&args);\n+\n+  /* Empty function qualifiers, with no specific qualifiers */\n+  FunctionQualifiers fn_qualifiers ();\n+\n+  /* Create a single path segment from one string */\n+  PathExprSegment path_segment (std::string seg);\n+\n+  /* And similarly for type path segments */\n+  std::unique_ptr<TypePathSegment> type_path_segment (std::string seg);\n+\n+  /* Create a Type from a single string - the most basic kind of type in our AST\n+   */\n+  std::unique_ptr<Type> single_type_path (std::string type);\n+\n+  /**\n+   * Create a path in expression from multiple segments (`Clone::clone`). You\n+   * do not need to separate the segments using `::`, you can simply provide a\n+   * vector of strings to the functions which will get turned into path segments\n+   */\n+  PathInExpression path_in_expression (std::vector<std::string> &&segments);\n+\n+  /* Create a struct expression for unit structs (`S`) */\n+  std::unique_ptr<Expr> struct_expr_struct (std::string struct_name);\n+\n+private:\n+  /**\n+   * Location of the generated AST nodes\n+   */\n+  Location loc;\n+};\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // AST_BUILDER_H"}]}