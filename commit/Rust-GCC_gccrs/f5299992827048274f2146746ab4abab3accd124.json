{"sha": "f5299992827048274f2146746ab4abab3accd124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUyOTk5OTI4MjcwNDgyNzRmMjE0Njc0NmFiNGFiYWIzYWNjZDEyNA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-09-17T07:34:03Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-01T15:11:17Z"}, "message": "Convert sprintf/strlen passes to value query class.\n\ngcc/ChangeLog:\n\n\t* builtins.c (compute_objsize): Replace vr_values with range_query.\n\t(get_range): Same.\n\t(gimple_call_alloc_size): Same.\n\t* builtins.h (class vr_values):  Remove.\n\t(gimple_call_alloc_size): Replace vr_values with range_query.\n\t* gimple-ssa-sprintf.c (get_int_range): Same.\n\t(struct directive): Pass gimple context to fmtfunc callback.\n\t(directive::set_width): Replace inline with out-of-line version.\n\t(directive::set_precision): Same.\n\t(format_none): New gimple argument.\n\t(format_percent): New gimple argument.\n\t(format_integer): New gimple argument.\n\t(format_floating): New gimple argument.\n\t(get_string_length): Use range_query API.\n\t(format_character): New gimple argument.\n\t(format_string): New gimple argument.\n\t(format_plain): New gimple argument.\n\t(format_directive): New gimple argument.\n\t(parse_directive): Replace vr_values with range_query.\n\t(compute_format_length): Same.\n\t(handle_printf_call): Same.  Adjust for range_query API.\n\t* tree-ssa-strlen.c (get_range): Same.\n\t(compare_nonzero_chars): Same.\n\t(get_addr_stridx) Replace vr_values with range_query.\n\t(get_stridx): Same.\n\t(dump_strlen_info): Same.\n\t(get_range_strlen_dynamic): Adjust for range_query API.\n\t(set_strlen_range): Same\n\t(maybe_warn_overflow): Replace vr_values with range_query.\n\t(handle_builtin_strcpy): Same.\n\t(maybe_diag_stxncpy_trunc): Add FIXME comment.\n\t(handle_builtin_memcpy): Replace vr_values with range_query.\n\t(handle_builtin_memset): Same.\n\t(get_len_or_size): Same.\n\t(strxcmp_eqz_result): Same.\n\t(handle_builtin_string_cmp): Same.\n\t(count_nonzero_bytes_addr): Same, plus adjust for range_query API.\n\t(count_nonzero_bytes): Replace vr_values with range_query.\n\t(handle_store): Same.\n\t(strlen_check_and_optimize_call): Same.\n\t(handle_integral_assign): Same.\n\t(check_and_optimize_stmt): Same.\n\t* tree-ssa-strlen.h (class vr_values): Remove.\n\t(get_range): Replace vr_values with range_query.\n\t(get_range_strlen_dynamic): Same.\n\t(handle_printf_call): Same.", "tree": {"sha": "b0830471dbe0c82c925a6c75a709c558645bc7c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0830471dbe0c82c925a6c75a709c558645bc7c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5299992827048274f2146746ab4abab3accd124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5299992827048274f2146746ab4abab3accd124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5299992827048274f2146746ab4abab3accd124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5299992827048274f2146746ab4abab3accd124/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a889e06ac680e0aafa62cd5dec99e75d3f1ca1b6"}], "stats": {"total": 364, "additions": 186, "deletions": 178}, "files": [{"sha": "f91266e42405f4799ec66bc4bc9b39072075c37f", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5299992827048274f2146746ab4abab3accd124/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5299992827048274f2146746ab4abab3accd124/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f5299992827048274f2146746ab4abab3accd124", "patch": "@@ -183,7 +183,8 @@ static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n-static bool get_range (tree, signop, offset_int[2], const vr_values * = NULL);\n+static bool get_range (tree, gimple *, signop, offset_int[2],\n+\t\t       range_query * = NULL);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n \n unsigned HOST_WIDE_INT target_newline;\n@@ -4152,7 +4153,7 @@ check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n \n tree\n gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n-\t\t\tconst vr_values *rvals /* = NULL */)\n+\t\t\trange_query *rvals /* = NULL */)\n {\n   if (!stmt)\n     return NULL_TREE;\n@@ -4206,7 +4207,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n \n   const int prec = ADDR_MAX_PRECISION;\n   const tree size_max = TYPE_MAX_VALUE (sizetype);\n-  if (!get_range (size, rng1, rvals))\n+  if (!get_range (size, stmt, rng1, rvals))\n     {\n       /* Use the full non-negative range on failure.  */\n       rng1[0] = wi::zero (prec);\n@@ -4220,7 +4221,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n      of the upper bounds as a constant.  Ignore anti-ranges.  */\n   tree n = argidx2 < nargs ? gimple_call_arg (stmt, argidx2) : integer_one_node;\n   wide_int rng2[2];\n-  if (!get_range (n, rng2, rvals))\n+\t  if (!get_range (n, stmt, rng2, rvals))\n     {\n       /* As above, use the full non-negative range on failure.  */\n       rng2[0] = wi::zero (prec);\n@@ -4252,8 +4253,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n    Return the function parameter on success and null otherwise.  */\n \n tree\n-gimple_parm_array_size (tree ptr, wide_int rng[2],\n-\t\t\tconst vr_values * /* = NULL */)\n+gimple_parm_array_size (tree ptr, wide_int rng[2], range_query * /* = NULL */)\n {\n   /* For a function argument try to determine the byte size of the array\n      from the current function declaratation (e.g., attribute access or\n@@ -4305,11 +4305,11 @@ gimple_parm_array_size (tree ptr, wide_int rng[2],\n    result but accepts offset_int instead.  */\n \n static bool\n-get_range (tree x, signop sgn, offset_int r[2],\n-\t   const vr_values *rvals /* = NULL */)\n+get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n+\t   range_query *rvals /* = NULL */)\n {\n   wide_int wr[2];\n-  if (!get_range (x, wr, rvals))\n+  if (!get_range (x, stmt, wr, rvals))\n     return false;\n \n   r[0] = offset_int::from (wr[0], sgn);\n@@ -4333,7 +4333,7 @@ get_range (tree x, signop sgn, offset_int r[2],\n \n static bool\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t bitmap *visited, const vr_values *rvals /* = NULL */)\n+\t\t bitmap *visited, range_query *rvals /* = NULL */)\n {\n   const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n   if (addr)\n@@ -4431,7 +4431,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n       offset_int orng[2];\n       tree off = TREE_OPERAND (ptr, 1);\n-      if (!get_range (off, SIGNED, orng, rvals))\n+      if (!get_range (off, NULL, SIGNED, orng, rvals))\n \t/* Fail unless the size of the object is zero.  */\n \treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n \n@@ -4527,7 +4527,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t     offset to the maximum.  */\n \t  offset_int orng[2];\n \t  tree off = gimple_assign_rhs2 (stmt);\n-\t  if (!get_range (off, SIGNED, orng, rvals))\n+\t  if (!get_range (off, stmt, SIGNED, orng, rvals))\n \t    {\n \t      orng[0] = wi::to_offset (TYPE_MIN_VALUE (ptrdiff_type_node));\n \t      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n@@ -4551,7 +4551,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n       && !array_at_struct_end_p (ptr))\n     {\n       if (tree size = TYPE_SIZE_UNIT (type))\n-\treturn get_range (size, UNSIGNED, pref->sizrng, rvals);\n+\treturn get_range (size, NULL, UNSIGNED, pref->sizrng, rvals);\n     }\n \n   return false;\n@@ -4562,7 +4562,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t const vr_values *rvals /* = NULL */)\n+\t\t range_query *rvals /* = NULL */)\n {\n   bitmap visited = NULL;\n \n@@ -4603,7 +4603,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n tree\n compute_objsize (tree ptr, int ostype, tree *pdecl /* = NULL */,\n-\t\t tree *poff /* = NULL */, const vr_values *rvals /* = NULL */)\n+\t\t tree *poff /* = NULL */, class range_query *rvals /* = NULL */)\n {\n   /* Set the initial offsets to zero and size to negative to indicate\n      none has been computed yet.  */"}, {"sha": "504c618b851ff23df3f7b693a93fef40d17e1fb1", "filename": "gcc/builtins.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5299992827048274f2146746ab4abab3accd124/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5299992827048274f2146746ab4abab3accd124/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=f5299992827048274f2146746ab4abab3accd124", "patch": "@@ -195,13 +195,13 @@ struct access_data\n   access_mode mode;\n };\n \n-class vr_values;\n+class range_query;\n extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n-\t\t\t\t    const vr_values * = NULL);\n-extern tree gimple_parm_array_size (tree, wide_int[2], const vr_values * = NULL);\n+\t\t\t\t    range_query * = NULL);\n+extern tree gimple_parm_array_size (tree, wide_int[2], range_query * = NULL);\n extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n-\t\t\t     const vr_values * = NULL);\n-extern tree compute_objsize (tree, int, access_ref *, const vr_values * = NULL);\n+\t\t\t     range_query * = NULL);\n+extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n \n extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n \t\t\t  const access_data * = NULL);"}, {"sha": "fff034fac4ddeb87f8cdf64f30994f876878e0d8", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 67, "deletions": 59, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5299992827048274f2146746ab4abab3accd124/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5299992827048274f2146746ab4abab3accd124/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=f5299992827048274f2146746ab4abab3accd124", "patch": "@@ -546,8 +546,8 @@ fmtresult::type_max_digits (tree type, int base)\n }\n \n static bool\n-get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT,\n-\t       const vr_values *);\n+get_int_range (tree, gimple *, HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t       bool, HOST_WIDE_INT, range_query *);\n \n struct call_info;\n \n@@ -597,7 +597,7 @@ struct directive\n \n   /* Format conversion function that given a directive and an argument\n      returns the formatting result.  */\n-  fmtresult (*fmtfunc) (const directive &, tree, const vr_values *);\n+  fmtresult (*fmtfunc) (const directive &, tree, range_query *);\n \n   /* Return True when the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n@@ -634,10 +634,7 @@ struct directive\n      or 0, whichever is greater.  For a non-constant ARG in some range\n      set width to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set width to [0, INT_MAX].  */\n-  void set_width (tree arg, const vr_values *vr)\n-  {\n-    get_int_range (arg, width, width + 1, true, 0, vr);\n-  }\n+  void set_width (tree arg, range_query *);\n \n   /* Set both bounds of the precision range to VAL.  */\n   void set_precision (HOST_WIDE_INT val)\n@@ -650,10 +647,7 @@ struct directive\n      or -1 whichever is greater.  For a non-constant ARG in some range\n      set precision to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set precision to [-1, INT_MAX].  */\n-  void set_precision (tree arg, const vr_values *vr)\n-  {\n-    get_int_range (arg, prec, prec + 1, false, -1, vr);\n-  }\n+  void set_precision (tree arg, range_query *query);\n \n   /* Return true if both width and precision are known to be\n      either constant or in some range, false otherwise.  */\n@@ -956,10 +950,22 @@ struct call_info\n   }\n };\n \n+void\n+directive::set_width (tree arg, range_query *query)\n+{\n+  get_int_range (arg, info->callstmt, width, width + 1, true, 0, query);\n+}\n+\n+void\n+directive::set_precision (tree arg, range_query *query)\n+{\n+  get_int_range (arg, info->callstmt, prec, prec + 1, false, -1, query);\n+}\n+\n /* Return the result of formatting a no-op directive (such as '%n').  */\n \n static fmtresult\n-format_none (const directive &, tree, const vr_values *)\n+format_none (const directive &, tree, range_query *)\n {\n   fmtresult res (0);\n   return res;\n@@ -968,7 +974,7 @@ format_none (const directive &, tree, const vr_values *)\n /* Return the result of formatting the '%%' directive.  */\n \n static fmtresult\n-format_percent (const directive &, tree, const vr_values *)\n+format_percent (const directive &, tree, range_query *)\n {\n   fmtresult res (1);\n   return res;\n@@ -1026,9 +1032,10 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n    the determined range are replaced with NEGBOUND.  */\n \n static bool\n-get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n+get_int_range (tree arg, gimple *stmt,\n+\t       HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t       bool absolute, HOST_WIDE_INT negbound,\n-\t       const class vr_values *vr_values)\n+\t       range_query *query)\n {\n   /* The type of the result.  */\n   const_tree type = integer_type_node;\n@@ -1067,10 +1074,10 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t  && TYPE_PRECISION (argtype) <= TYPE_PRECISION (type))\n \t{\n \t  /* Try to determine the range of values of the integer argument.  */\n-\t  const value_range_equiv *vr\n-\t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n+\t  value_range vr;\n+\t  query->range_of_expr (vr, arg, stmt);\n \n-\t  if (!vr->undefined_p () && !vr->varying_p () && !vr->symbolic_p ())\n+\t  if (!vr.undefined_p () && !vr.varying_p ())\n \t    {\n \t      HOST_WIDE_INT type_min\n \t\t= (TYPE_UNSIGNED (argtype)\n@@ -1080,8 +1087,8 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n \t      HOST_WIDE_INT type_max = tree_to_uhwi (TYPE_MAX_VALUE (argtype));\n \n \t      tree type = TREE_TYPE (arg);\n-\t      tree tmin = wide_int_to_tree (type, vr->lower_bound ());\n-\t      tree tmax = wide_int_to_tree (type, vr->upper_bound ());\n+\t      tree tmin = wide_int_to_tree (type, vr.lower_bound ());\n+\t      tree tmax = wide_int_to_tree (type, vr.upper_bound ());\n \t      *pmin = TREE_INT_CST_LOW (tmin);\n \t      *pmax = TREE_INT_CST_LOW (tmax);\n \n@@ -1103,8 +1110,8 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n       /* Handle an argument with an unknown range as if none had been\n \t provided.  */\n       if (unknown)\n-\treturn get_int_range (NULL_TREE, pmin, pmax, absolute,\n-\t\t\t      negbound, vr_values);\n+\treturn get_int_range (NULL_TREE, NULL, pmin, pmax, absolute,\n+\t\t\t      negbound, query);\n     }\n \n   /* Adjust each bound as specified by ABSOLUTE and NEGBOUND.  */\n@@ -1189,7 +1196,7 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n    used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n+format_integer (const directive &dir, tree arg, range_query *query)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n@@ -1372,13 +1379,13 @@ format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n     {\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n-      const value_range_equiv *vr\n-\t= CONST_CAST (class vr_values *, vr_values)->get_value_range (arg);\n+      value_range vr;\n+      query->range_of_expr (vr, arg, dir.info->callstmt);\n \n-      if (!vr->varying_p () && !vr->undefined_p () && !vr->symbolic_p ())\n+      if (!vr.varying_p () && !vr.undefined_p ())\n \t{\n-\t  argmin = wide_int_to_tree (TREE_TYPE (arg), vr->lower_bound ());\n-\t  argmax = wide_int_to_tree (TREE_TYPE (arg), vr->upper_bound ());\n+\t  argmin = wide_int_to_tree (TREE_TYPE (arg), vr.lower_bound ());\n+\t  argmax = wide_int_to_tree (TREE_TYPE (arg), vr.upper_bound ());\n \n \t  /* Set KNOWNRANGE if the argument is in a known subrange\n \t     of the directive's type and neither width nor precision\n@@ -1404,7 +1411,7 @@ format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n \t      if (code == INTEGER_CST)\n \t\t{\n \t\t  arg = gimple_assign_rhs1 (def);\n-\t\t  return format_integer (dir, arg, vr_values);\n+\t\t  return format_integer (dir, arg, query);\n \t\t}\n \n \t      if (code == NOP_EXPR)\n@@ -1449,16 +1456,16 @@ format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n       /* For unsigned conversions/directives or signed when\n \t the minimum is positive, use the minimum and maximum to compute\n \t the shortest and longest output, respectively.  */\n-      res.range.min = format_integer (dir, argmin, vr_values).range.min;\n-      res.range.max = format_integer (dir, argmax, vr_values).range.max;\n+      res.range.min = format_integer (dir, argmin, query).range.min;\n+      res.range.max = format_integer (dir, argmax, query).range.max;\n     }\n   else if (tree_int_cst_sgn (argmax) < 0)\n     {\n       /* For signed conversions/directives if maximum is negative,\n \t use the minimum as the longest output and maximum as the\n \t shortest output.  */\n-      res.range.min = format_integer (dir, argmax, vr_values).range.min;\n-      res.range.max = format_integer (dir, argmin, vr_values).range.max;\n+      res.range.min = format_integer (dir, argmax, query).range.min;\n+      res.range.max = format_integer (dir, argmin, query).range.max;\n     }\n   else\n     {\n@@ -1467,11 +1474,11 @@ format_integer (const directive &dir, tree arg, const vr_values *vr_values)\n \t length of the output of both minimum and maximum and pick the\n \t longer.  */\n       unsigned HOST_WIDE_INT max1\n-\t= format_integer (dir, argmin, vr_values).range.max;\n+\t= format_integer (dir, argmin, query).range.max;\n       unsigned HOST_WIDE_INT max2\n-\t= format_integer (dir, argmax, vr_values).range.max;\n+\t= format_integer (dir, argmax, query).range.max;\n       res.range.min\n-\t= format_integer (dir, integer_zero_node, vr_values).range.min;\n+\t= format_integer (dir, integer_zero_node, query).range.min;\n       res.range.max = MAX (max1, max2);\n     }\n \n@@ -1820,7 +1827,7 @@ format_floating (const directive &dir, const HOST_WIDE_INT prec[2])\n    ARG.  */\n \n static fmtresult\n-format_floating (const directive &dir, tree arg, const vr_values *)\n+format_floating (const directive &dir, tree arg, range_query *)\n {\n   HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n   tree type = (dir.modifier == FMT_LEN_L || dir.modifier == FMT_LEN_ll\n@@ -2014,7 +2021,8 @@ format_floating (const directive &dir, tree arg, const vr_values *)\n    Used by the format_string function below.  */\n \n static fmtresult\n-get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n+get_string_length (tree str, gimple *stmt, unsigned eltsize,\n+\t\t   range_query *query)\n {\n   if (!str)\n     return fmtresult ();\n@@ -2025,7 +2033,7 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n   c_strlen_data lendata = { };\n   lendata.maxbound = str;\n   if (eltsize == 1)\n-    get_range_strlen_dynamic (str, &lendata, vr);\n+    get_range_strlen_dynamic (str, stmt, &lendata, query);\n   else\n     {\n       /* Determine the length of the shortest and longest string referenced\n@@ -2122,7 +2130,7 @@ get_string_length (tree str, unsigned eltsize, const vr_values *vr)\n    vsprinf).  */\n \n static fmtresult\n-format_character (const directive &dir, tree arg, const vr_values *vr_values)\n+format_character (const directive &dir, tree arg, range_query *query)\n {\n   fmtresult res;\n \n@@ -2135,7 +2143,7 @@ format_character (const directive &dir, tree arg, const vr_values *vr_values)\n       res.range.min = 0;\n \n       HOST_WIDE_INT min, max;\n-      if (get_int_range (arg, &min, &max, false, 0, vr_values))\n+      if (get_int_range (arg, dir.info->callstmt, &min, &max, false, 0, query))\n \t{\n \t  if (min == 0 && max == 0)\n \t    {\n@@ -2433,7 +2441,7 @@ alias_offset (tree arg, tree dst, HOST_WIDE_INT dst_fld)\n    vsprinf).  */\n \n static fmtresult\n-format_string (const directive &dir, tree arg, const vr_values *vr_values)\n+format_string (const directive &dir, tree arg, range_query *query)\n {\n   fmtresult res;\n \n@@ -2462,7 +2470,7 @@ format_string (const directive &dir, tree arg, const vr_values *vr_values)\n       gcc_checking_assert (count_by == 2 || count_by == 4);\n     }\n \n-  fmtresult slen = get_string_length (arg, count_by, vr_values);\n+  fmtresult slen = get_string_length (arg, dir.info->callstmt, count_by, query);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {\n@@ -2634,7 +2642,7 @@ format_string (const directive &dir, tree arg, const vr_values *vr_values)\n /* Format plain string (part of the format string itself).  */\n \n static fmtresult\n-format_plain (const directive &dir, tree, const vr_values *)\n+format_plain (const directive &dir, tree, range_query *)\n {\n   fmtresult res (dir.len);\n   return res;\n@@ -3030,7 +3038,7 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n static bool\n format_directive (const call_info &info,\n \t\t  format_result *res, const directive &dir,\n-\t\t  const class vr_values *vr_values)\n+\t\t  range_query *query)\n {\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n@@ -3055,7 +3063,7 @@ format_directive (const call_info &info,\n     return false;\n \n   /* Compute the range of lengths of the formatted output.  */\n-  fmtresult fmtres = dir.fmtfunc (dir, dir.arg, vr_values);\n+  fmtresult fmtres = dir.fmtfunc (dir, dir.arg, query);\n \n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n@@ -3386,7 +3394,7 @@ static size_t\n parse_directive (call_info &info,\n \t\t directive &dir, format_result *res,\n \t\t const char *str, unsigned *argno,\n-\t\t const vr_values *vr_values)\n+\t\t range_query *query)\n {\n   const char *pcnt = strchr (str, target_percent);\n   dir.beg = str;\n@@ -3711,7 +3719,7 @@ parse_directive (call_info &info,\n   if (star_width)\n     {\n       if (INTEGRAL_TYPE_P (TREE_TYPE (star_width)))\n-\tdir.set_width (star_width, vr_values);\n+\tdir.set_width (star_width, query);\n       else\n \t{\n \t  /* Width specified by a va_list takes on the range [0, -INT_MIN]\n@@ -3744,7 +3752,7 @@ parse_directive (call_info &info,\n   if (star_precision)\n     {\n       if (INTEGRAL_TYPE_P (TREE_TYPE (star_precision)))\n-\tdir.set_precision (star_precision, vr_values);\n+\tdir.set_precision (star_precision, query);\n       else\n \t{\n \t  /* Precision specified by a va_list takes on the range [-1, INT_MAX]\n@@ -3958,7 +3966,7 @@ maybe_warn_overlap (call_info &info, format_result *res)\n    that caused the processing to be terminated early).  */\n \n static bool\n-compute_format_length (call_info &info, format_result *res, const vr_values *vr)\n+compute_format_length (call_info &info, format_result *res, range_query *query)\n {\n   if (dump_file)\n     {\n@@ -3995,10 +4003,10 @@ compute_format_length (call_info &info, format_result *res, const vr_values *vr)\n     {\n       directive dir (&info, dirno);\n \n-      size_t n = parse_directive (info, dir, res, pf, &argno, vr);\n+      size_t n = parse_directive (info, dir, res, pf, &argno, query);\n \n       /* Return failure if the format function fails.  */\n-      if (!format_directive (info, res, dir, vr))\n+      if (!format_directive (info, res, dir, query))\n \treturn false;\n \n       /* Return success when the directive is zero bytes long and it's\n@@ -4288,7 +4296,7 @@ get_user_idx_format (tree fndecl, unsigned *idx_args)\n    gsi_next should not be performed in the caller.  */\n \n bool\n-handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n+handle_printf_call (gimple_stmt_iterator *gsi, range_query *query)\n {\n   init_target_to_host_charmap ();\n \n@@ -4557,14 +4565,14 @@ handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n \t  /* Try to determine the range of values of the argument\n \t     and use the greater of the two at level 1 and the smaller\n \t     of them at level 2.  */\n-\t  const value_range_equiv *vr\n-\t    = CONST_CAST (class vr_values *, vr_values)->get_value_range (size);\n+\t  value_range vr;\n+\t  query->range_of_expr (vr, size, info.callstmt);\n \n-\t  if (!vr->undefined_p () && !vr->symbolic_p ())\n+\t  if (!vr.undefined_p ())\n \t    {\n \t      tree type = TREE_TYPE (size);\n-\t      tree tmin = wide_int_to_tree (type, vr->lower_bound ());\n-\t      tree tmax = wide_int_to_tree (type, vr->upper_bound ());\n+\t      tree tmin = wide_int_to_tree (type, vr.lower_bound ());\n+\t      tree tmax = wide_int_to_tree (type, vr.upper_bound ());\n \t      unsigned HOST_WIDE_INT minsize = TREE_INT_CST_LOW (tmin);\n \t      unsigned HOST_WIDE_INT maxsize = TREE_INT_CST_LOW (tmax);\n \t      dstsize = warn_level < 2 ? maxsize : minsize;\n@@ -4675,7 +4683,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n      never set to true again).  */\n   res.posunder4k = posunder4k && dstptr;\n \n-  bool success = compute_format_length (info, &res, vr_values);\n+  bool success = compute_format_length (info, &res, query);\n   if (res.warned)\n     gimple_set_no_warning (info.callstmt, true);\n "}, {"sha": "f4d1c5ca25625713651ba1f44faf64030f28b7f9", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 94, "deletions": 95, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5299992827048274f2146746ab4abab3accd124/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5299992827048274f2146746ab4abab3accd124/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=f5299992827048274f2146746ab4abab3accd124", "patch": "@@ -200,7 +200,8 @@ static void handle_builtin_stxncpy_strncat (bool, gimple_stmt_iterator *);\n    to determine the range, otherwise get_range_info.  */\n \n tree\n-get_range (tree val, wide_int minmax[2], const vr_values *rvals /* = NULL */)\n+get_range (tree val, gimple *stmt, wide_int minmax[2],\n+\t   range_query *rvals /* = NULL */)\n {\n   if (TREE_CODE (val) == INTEGER_CST)\n     {\n@@ -211,21 +212,17 @@ get_range (tree val, wide_int minmax[2], const vr_values *rvals /* = NULL */)\n   if (TREE_CODE (val) != SSA_NAME)\n     return NULL_TREE;\n \n-  if (rvals)\n-    {\n-      /* The range below may be \"inaccurate\" if a constant has been\n-\t substituted earlier for VAL by this pass that hasn't been\n-\t propagated through the CFG.  This shoud be fixed by the new\n-\t on-demand VRP if/when it becomes available (hopefully in\n-\t GCC 11).  */\n-      const value_range *vr\n-\t= (CONST_CAST (class vr_values *, rvals)->get_value_range (val));\n-      value_range_kind rng = vr->kind ();\n-      if (rng != VR_RANGE || !range_int_cst_p (vr))\n+  if (rvals && stmt)\n+    {\n+      value_range vr;\n+      if (!rvals->range_of_expr (vr, val, stmt))\n+\treturn NULL_TREE;\n+      value_range_kind rng = vr.kind ();\n+      if (rng != VR_RANGE)\n \treturn NULL_TREE;\n \n-      minmax[0] = wi::to_wide (vr->min ());\n-      minmax[1] = wi::to_wide (vr->max ());\n+      minmax[0] = wi::to_wide (vr.min ());\n+      minmax[1] = wi::to_wide (vr.max ());\n       return val;\n     }\n \n@@ -263,7 +260,7 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off)\n \n static int\n compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n-\t\t       const vr_values *rvals)\n+\t\t       range_query *rvals)\n {\n   if (!si->nonzero_chars)\n     return -1;\n@@ -274,20 +271,19 @@ compare_nonzero_chars (strinfo *si, unsigned HOST_WIDE_INT off,\n   if (!rvals || TREE_CODE (si->nonzero_chars) != SSA_NAME)\n     return -1;\n \n-  const value_range_equiv *vr\n-    = (CONST_CAST (class vr_values *, rvals)\n-       ->get_value_range (si->nonzero_chars));\n-\n-  value_range_kind rng = vr->kind ();\n-  if (rng != VR_RANGE || !range_int_cst_p (vr))\n+  value_range vr;\n+  if (!rvals->range_of_expr (vr, si->nonzero_chars, si->stmt))\n+    return -1;\n+  value_range_kind rng = vr.kind ();\n+  if (rng != VR_RANGE)\n     return -1;\n \n   /* If the offset is less than the minimum length or if the bounds\n      of the length range are equal return the result of the comparison\n      same as in the constant case.  Otherwise return a conservative\n      result.  */\n-  int cmpmin = compare_tree_int (vr->min (), off);\n-  if (cmpmin > 0 || tree_int_cst_equal (vr->min (), vr->max ()))\n+  int cmpmin = compare_tree_int (vr.min (), off);\n+  if (cmpmin > 0 || tree_int_cst_equal (vr.min (), vr.max ()))\n     return cmpmin;\n \n   return -1;\n@@ -332,7 +328,7 @@ get_next_strinfo (strinfo *si)\n \n static int\n get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n-\t\t const vr_values *rvals = NULL)\n+\t\t range_query *rvals = NULL)\n {\n   HOST_WIDE_INT off;\n   struct stridxlist *list, *last = NULL;\n@@ -392,7 +388,7 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out,\n    When nonnull, uses RVALS to determine range information.  */\n \n static int\n-get_stridx (tree exp, wide_int offrng[2] = NULL, const vr_values *rvals = NULL)\n+get_stridx (tree exp, wide_int offrng[2] = NULL, range_query *rvals = NULL)\n {\n   if (offrng)\n     offrng[0] = offrng[1] = wi::zero (TYPE_PRECISION (ptrdiff_type_node));\n@@ -474,7 +470,7 @@ get_stridx (tree exp, wide_int offrng[2] = NULL, const vr_values *rvals = NULL)\n \t\t       return the index corresponding to the SSA_NAME.\n \t\t       Do this irrespective of the whether the offset\n \t\t       is known.  */\n-\t\t    if (get_range (off, offrng, rvals))\n+\t\t    if (get_range (off, def_stmt, offrng, rvals))\n \t\t      {\n \t\t\t/* When the offset range is known, increment it\n \t\t\t   it by the constant offset computed in prior\n@@ -864,11 +860,11 @@ get_string_length (strinfo *si)\n }\n \n /* Dump strlen data to FP for statement STMT.  When non-null, RVALS\n-   points to EVRP info and is used to dump strlen range for non-constant\n-   results.  */\n+   points to the valuation engine used to calculate ranges, and is\n+   used to dump strlen range for non-constant results.  */\n \n DEBUG_FUNCTION void\n-dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n+dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n {\n   if (stmt)\n     {\n@@ -909,14 +905,14 @@ dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n \t\t      wide_int min, max;\n \t\t      if (rvals)\n \t\t\t{\n-\t\t\t  const value_range *vr\n-\t\t\t    = CONST_CAST (class vr_values *, rvals)\n-\t\t\t    ->get_value_range (si->nonzero_chars);\n-\t\t\t  rng = vr->kind ();\n-\t\t\t  if (range_int_cst_p (vr))\n+\t\t\t  value_range vr;\n+\t\t\t  rvals->range_of_expr (vr, si->nonzero_chars,\n+\t\t\t\t\t\tsi->stmt);\n+\t\t\t  rng = vr.kind ();\n+\t\t\t  if (range_int_cst_p (&vr))\n \t\t\t    {\n-\t\t\t      min = wi::to_wide (vr->min ());\n-\t\t\t      max = wi::to_wide (vr->max ());\n+\t\t\t      min = wi::to_wide (vr.min ());\n+\t\t\t      max = wi::to_wide (vr.max ());\n \t\t\t    }\n \t\t\t  else\n \t\t\t    rng = VR_UNDEFINED;\n@@ -1004,13 +1000,14 @@ dump_strlen_info (FILE *fp, gimple *stmt, const vr_values *rvals)\n \n /* Attempt to determine the length of the string SRC.  On success, store\n    the length in *PDATA and return true.  Otherwise, return false.\n-   VISITED is a bitmap of visited PHI nodes.  RVALS points to EVRP info\n-   and PSSA_DEF_MAX to an SSA_NAME assignment limit used to prevent runaway\n-   recursion.  */\n+   VISITED is a bitmap of visited PHI nodes.  RVALS points to the valuation\n+   engine used to calculate ranges.  PSSA_DEF_MAX to an SSA_NAME\n+   assignment limit used to prevent runaway recursion.  */\n \n static bool\n-get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n-\t\t\t  const vr_values *rvals, unsigned *pssa_def_max)\n+get_range_strlen_dynamic (tree src, gimple *stmt,\n+\t\t\t  c_strlen_data *pdata, bitmap *visited,\n+\t\t\t  range_query *rvals, unsigned *pssa_def_max)\n {\n   int idx = get_stridx (src);\n   if (!idx)\n@@ -1042,8 +1039,8 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t\t    continue;\n \n \t\t  c_strlen_data argdata = { };\n-\t\t  if (get_range_strlen_dynamic (arg, &argdata, visited, rvals,\n-\t\t\t\t\t\tpssa_def_max))\n+\t\t  if (get_range_strlen_dynamic (arg, phi, &argdata, visited,\n+\t\t\t\t\t\trvals, pssa_def_max))\n \t\t    {\n \t\t      /* Set the DECL of an unterminated array this argument\n \t\t\t refers to if one hasn't been found yet.  */\n@@ -1110,14 +1107,12 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t    pdata->minlen = si->nonzero_chars;\n \t  else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t    {\n-\t      const value_range_equiv *vr\n-\t\t= CONST_CAST (class vr_values *, rvals)\n-\t\t->get_value_range (si->nonzero_chars);\n-\t      if (vr->kind () == VR_RANGE\n-\t\t  && range_int_cst_p (vr))\n+\t      value_range vr;\n+\t      rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n+\t      if (range_int_cst_p (&vr))\n \t\t{\n-\t\t  pdata->minlen = vr->min ();\n-\t\t  pdata->maxlen = vr->max ();\n+\t\t  pdata->minlen = vr.min ();\n+\t\t  pdata->maxlen = vr.max ();\n \t\t}\n \t      else\n \t\tpdata->minlen = build_zero_cst (size_type_node);\n@@ -1156,14 +1151,12 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n \t}\n       else if (pdata->minlen && TREE_CODE (pdata->minlen) == SSA_NAME)\n \t{\n-\t  const value_range_equiv *vr\n-\t    = CONST_CAST (class vr_values *, rvals)\n-\t    ->get_value_range (si->nonzero_chars);\n-\t  if (vr->kind () == VR_RANGE\n-\t      && range_int_cst_p (vr))\n+\t  value_range vr;\n+\t  rvals->range_of_expr (vr, si->nonzero_chars, stmt);\n+\t  if (range_int_cst_p (&vr))\n \t    {\n-\t      pdata->minlen = vr->min ();\n-\t      pdata->maxlen = vr->max ();\n+\t      pdata->minlen = vr.min ();\n+\t      pdata->maxlen = vr.max ();\n \t      pdata->maxbound = pdata->maxlen;\n \t    }\n \t  else\n@@ -1198,17 +1191,17 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata, bitmap *visited,\n    Try to obtain the range of the lengths of the string(s) referenced\n    by SRC, or the size of the largest array SRC refers to if the range\n    of lengths cannot be determined, and store all in *PDATA.  RVALS\n-   points to EVRP info.  */\n+   points to the valuation engine used to calculate ranges.  */\n \n void\n-get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n-\t\t\t  const vr_values *rvals)\n+get_range_strlen_dynamic (tree src, gimple *stmt, c_strlen_data *pdata,\n+\t\t\t  range_query *rvals)\n {\n   bitmap visited = NULL;\n   tree maxbound = pdata->maxbound;\n \n   unsigned limit = param_ssa_name_def_chain_limit;\n-  if (!get_range_strlen_dynamic (src, pdata, &visited, rvals, &limit))\n+  if (!get_range_strlen_dynamic (src, stmt, pdata, &visited, rvals, &limit))\n     {\n       /* On failure extend the length range to an impossible maximum\n \t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n@@ -1803,6 +1796,7 @@ set_strlen_range (tree lhs, wide_int min, wide_int max,\n       else if (TREE_CODE (bound) == SSA_NAME)\n \t{\n \t  wide_int minbound, maxbound;\n+\t  // FIXME: Use range_query instead of global ranges.\n \t  value_range_kind rng = get_range_info (bound, &minbound, &maxbound);\n \t  if (rng == VR_RANGE)\n \t    {\n@@ -1907,7 +1901,7 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n \n static void\n maybe_warn_overflow (gimple *stmt, tree len,\n-\t\t     const vr_values *rvals = NULL,\n+\t\t     range_query *rvals = NULL,\n \t\t     strinfo *si = NULL, bool plus_one = false,\n \t\t     bool rawmem = false)\n {\n@@ -1959,7 +1953,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t  tree off = TREE_OPERAND (ref, 1);\n \t  ref = TREE_OPERAND (ref, 0);\n \t  wide_int rng[2];\n-\t  if (get_range (off, rng, rvals))\n+\t  if (get_range (off, stmt, rng, rvals))\n \t    {\n \t      /* Convert offsets to the maximum precision.  */\n \t      offrng[0] = widest_int::from (rng[0], SIGNED);\n@@ -1977,7 +1971,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t  tree mem_off = TREE_OPERAND (ref, 1);\n \t  ref = TREE_OPERAND (ref, 0);\n \t  wide_int rng[2];\n-\t  if (get_range (mem_off, rng, rvals))\n+\t  if (get_range (mem_off, stmt, rng, rvals))\n \t    {\n \t      offrng[0] += widest_int::from (rng[0], SIGNED);\n \t      offrng[1] += widest_int::from (rng[1], SIGNED);\n@@ -2049,7 +2043,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \t    }\n \n \t  wide_int rng[2];\n-\t  if (get_range (destsize, rng, rvals))\n+\t  if (get_range (destsize, stmt, rng, rvals))\n \t    {\n \t      sizrng[0] = widest_int::from (rng[0], UNSIGNED);\n \t      sizrng[1] = widest_int::from (rng[1], UNSIGNED);\n@@ -2080,7 +2074,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n     return;\n \n   wide_int rng[2];\n-  if (!get_range (len, rng, rvals))\n+  if (!get_range (len, stmt, rng, rvals))\n     return;\n \n   widest_int lenrng[2] =\n@@ -2231,7 +2225,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n   if (destoff)\n     {\n       wide_int rng[2];\n-      if (get_range (destoff, rng))\n+      if (get_range (destoff, stmt, rng))\n \t{\n \t  offrng[0] = widest_int::from (rng[0], SIGNED);\n \t  offrng[1] = widest_int::from (rng[1], SIGNED);\n@@ -2339,7 +2333,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n static inline void\n maybe_warn_overflow (gimple *stmt, unsigned HOST_WIDE_INT len,\n-\t\t     const vr_values *rvals = NULL, strinfo *si = NULL,\n+\t\t     range_query *rvals = NULL, strinfo *si = NULL,\n \t\t     bool plus_one = false, bool rawmem = false)\n {\n   maybe_warn_overflow (stmt, build_int_cst (size_type_node, len), rvals,\n@@ -2642,7 +2636,7 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n \n static void\n handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       const vr_values *rvals)\n+\t\t       range_query *rvals)\n {\n   int idx, didx;\n   tree src, dst, srclen, len, lhs, type, fn, oldlen;\n@@ -3036,6 +3030,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n     cntrange[0] = cntrange[1] = wi::to_wide (cnt);\n   else if (TREE_CODE (cnt) == SSA_NAME)\n     {\n+      // FIXME: Use range_query instead of global ranges.\n       enum value_range_kind rng = get_range_info (cnt, cntrange, cntrange + 1);\n       if (rng == VR_RANGE)\n \t;\n@@ -3444,7 +3439,7 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n \n static void\n handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n-\t\t       const vr_values *rvals)\n+\t\t       range_query *rvals)\n {\n   tree lhs, oldlen, newlen;\n   gimple *stmt = gsi_stmt (*gsi);\n@@ -3909,7 +3904,7 @@ handle_alloc_call (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n static bool\n handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t       const vr_values *rvals)\n+\t\t       range_query *rvals)\n {\n   gimple *memset_stmt = gsi_stmt (*gsi);\n   tree ptr = gimple_call_arg (memset_stmt, 0);\n@@ -4103,9 +4098,10 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n    determine range information. Returns true on success.  */\n \n static bool\n-get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n+get_len_or_size (gimple *stmt, tree arg, int idx,\n+\t\t unsigned HOST_WIDE_INT lenrng[2],\n \t\t unsigned HOST_WIDE_INT *size, bool *nulterm,\n-\t\t const vr_values *rvals)\n+\t\t range_query *rvals)\n {\n   /* Invalidate.  */\n   *size = HOST_WIDE_INT_M1U;\n@@ -4140,6 +4136,7 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n       else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n \t  wide_int min, max;\n+\t  // FIXME: Use range_query instead of global ranges.\n \t  value_range_kind rng = get_range_info (si->nonzero_chars, &min, &max);\n \t  if (rng == VR_RANGE)\n \t    {\n@@ -4158,7 +4155,7 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n   /* Set MAXBOUND to an arbitrary non-null non-integer node as a request\n      to have it set to the length of the longest string in a PHI.  */\n   lendata.maxbound = arg;\n-  get_range_strlen_dynamic (arg, &lendata, rvals);\n+  get_range_strlen_dynamic (arg, stmt, &lendata, rvals);\n \n   unsigned HOST_WIDE_INT maxbound = HOST_WIDE_INT_M1U;\n   if (tree_fits_uhwi_p (lendata.maxbound)\n@@ -4216,17 +4213,17 @@ get_len_or_size (tree arg, int idx, unsigned HOST_WIDE_INT lenrng[2],\n    Otherwise return null.  */\n \n static tree\n-strxcmp_eqz_result (tree arg1, int idx1, tree arg2, int idx2,\n+strxcmp_eqz_result (gimple *stmt, tree arg1, int idx1, tree arg2, int idx2,\n \t\t    unsigned HOST_WIDE_INT bound, unsigned HOST_WIDE_INT len[2],\n-\t\t    unsigned HOST_WIDE_INT *psize, const vr_values *rvals)\n+\t\t    unsigned HOST_WIDE_INT *psize, range_query *rvals)\n {\n   /* Determine the range the length of each string is in and whether it's\n      known to be nul-terminated, or the size of the array it's stored in.  */\n   bool nul1, nul2;\n   unsigned HOST_WIDE_INT siz1, siz2;\n   unsigned HOST_WIDE_INT len1rng[2], len2rng[2];\n-  if (!get_len_or_size (arg1, idx1, len1rng, &siz1, &nul1, rvals)\n-      || !get_len_or_size (arg2, idx2, len2rng, &siz2, &nul2, rvals))\n+  if (!get_len_or_size (stmt, arg1, idx1, len1rng, &siz1, &nul1, rvals)\n+      || !get_len_or_size (stmt, arg2, idx2, len2rng, &siz2, &nul2, rvals))\n     return NULL_TREE;\n \n   /* BOUND is set to HWI_M1U for strcmp and less to strncmp, and LENiRNG\n@@ -4375,7 +4372,7 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n    another and false otherwise.  */\n \n static bool\n-handle_builtin_string_cmp (gimple_stmt_iterator *gsi, const vr_values *rvals)\n+handle_builtin_string_cmp (gimple_stmt_iterator *gsi, range_query *rvals)\n {\n   gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n   tree lhs = gimple_call_lhs (stmt);\n@@ -4420,7 +4417,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, const vr_values *rvals)\n     /* Try to determine if the two strings are either definitely equal\n        or definitely unequal and if so, either fold the result to zero\n        (when equal) or set the range of the result to ~[0, 0] otherwise.  */\n-    if (tree eqz = strxcmp_eqz_result (arg1, idx1, arg2, idx2, bound,\n+    if (tree eqz = strxcmp_eqz_result (stmt, arg1, idx1, arg2, idx2, bound,\n \t\t\t\t       len, &siz, rvals))\n       {\n \tif (integer_zerop (eqz))\n@@ -4457,8 +4454,9 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi, const vr_values *rvals)\n     unsigned HOST_WIDE_INT arsz1, arsz2;\n     bool nulterm[2];\n \n-    if (!get_len_or_size (arg1, idx1, len1rng, &arsz1, nulterm, rvals)\n-\t|| !get_len_or_size (arg2, idx2, len2rng, &arsz2, nulterm + 1, rvals))\n+    if (!get_len_or_size (stmt, arg1, idx1, len1rng, &arsz1, nulterm, rvals)\n+\t|| !get_len_or_size (stmt, arg2, idx2, len2rng, &arsz2, nulterm + 1,\n+\t\t\t     rvals))\n       return false;\n \n     if (len1rng[0] == len1rng[1] && len1rng[0] < HOST_WIDE_INT_MAX)\n@@ -4623,7 +4621,7 @@ int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n static bool\n count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t  unsigned [3], bool *, bool *, bool *,\n-\t\t\t  const vr_values *, ssa_name_limit_t &);\n+\t\t\t  range_query *, ssa_name_limit_t &);\n \n /* Determines the minimum and maximum number of leading non-zero bytes\n    in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n@@ -4644,7 +4642,7 @@ static bool\n count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t\t     unsigned HOST_WIDE_INT nbytes,\n \t\t     unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul, const vr_values *rvals,\n+\t\t     bool *allnul, bool *allnonnul, range_query *rvals,\n \t\t     ssa_name_limit_t &snlim)\n {\n   if (TREE_CODE (exp) == SSA_NAME)\n@@ -4836,7 +4834,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \t\t\t  unsigned HOST_WIDE_INT nbytes,\n \t\t\t  unsigned lenrange[3], bool *nulterm,\n \t\t\t  bool *allnul, bool *allnonnul,\n-\t\t\t  const vr_values *rvals, ssa_name_limit_t &snlim)\n+\t\t\t  range_query *rvals, ssa_name_limit_t &snlim)\n {\n   int idx = get_stridx (exp);\n   if (idx > 0)\n@@ -4853,13 +4851,13 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n       else if (si->nonzero_chars\n \t       && TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n-\t  vr_values *v = CONST_CAST (vr_values *, rvals);\n-\t  const value_range_equiv *vr = v->get_value_range (si->nonzero_chars);\n-\t  if (vr->kind () != VR_RANGE || !range_int_cst_p (vr))\n+\t  value_range vr;\n+\t  rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n+\t  if (vr.kind () != VR_RANGE)\n \t    return false;\n \n-\t  minlen = tree_to_uhwi (vr->min ());\n-\t  maxlen = tree_to_uhwi (vr->max ());\n+\t  minlen = tree_to_uhwi (vr.min ());\n+\t  maxlen = tree_to_uhwi (vr.max ());\n \t}\n       else\n \treturn false;\n@@ -4948,7 +4946,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \n static bool\n count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n-\t\t     bool *allnul, bool *allnonnul, const vr_values *rvals)\n+\t\t     bool *allnul, bool *allnonnul, range_query *rvals)\n {\n   /* Set to optimistic values so the caller doesn't have to worry about\n      initializing these and to what.  On success, the function will clear\n@@ -4972,7 +4970,7 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n \n static bool\n handle_store (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t      const vr_values *rvals)\n+\t      range_query *rvals)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n@@ -5382,7 +5380,7 @@ is_char_type (tree type)\n \n static bool\n strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n-\t\t\t\tconst vr_values *rvals)\n+\t\t\t\trange_query *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -5473,7 +5471,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi, bool *zero_write,\n \n static void\n handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n-\t\t\tconst vr_values *rvals)\n+\t\t\trange_query *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_assign_lhs (stmt);\n@@ -5565,6 +5563,7 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t\t  wide_int min, max;\n \t\t  signop sign = TYPE_SIGN (lhs_type);\n \t\t  int prec = TYPE_PRECISION (lhs_type);\n+\t\t  // FIXME: Use range_query instead of global ranges.\n \t\t  value_range_kind vr = get_range_info (lhs, &min, &max);\n \t\t  if (vr == VR_VARYING\n \t\t      || (vr == VR_RANGE\n@@ -5617,7 +5616,7 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \n static bool\n check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n-\t\t\t const vr_values *rvals)\n+\t\t\t range_query *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n "}, {"sha": "225f64b1630ba0c6b8349cd2a3c6d5da14bf4be3", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5299992827048274f2146746ab4abab3accd124/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5299992827048274f2146746ab4abab3accd124/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=f5299992827048274f2146746ab4abab3accd124", "patch": "@@ -25,13 +25,14 @@ extern bool is_strlen_related_p (tree, tree);\n extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n extern tree set_strlen_range (tree, wide_int, wide_int, tree = NULL_TREE);\n \n-class vr_values;\n-extern tree get_range (tree, wide_int[2], const vr_values * = NULL);\n+extern tree get_range (tree, gimple *, wide_int[2],\n+\t\t       class range_query * = NULL);\n \n struct c_strlen_data;\n-extern void get_range_strlen_dynamic (tree , c_strlen_data *, const vr_values *);\n+extern void get_range_strlen_dynamic (tree, gimple *, c_strlen_data *,\n+\t\t\t\t      class range_query *);\n \n /* APIs internal to strlen pass.  Defined in gimple-ssa-sprintf.c.  */\n-extern bool handle_printf_call (gimple_stmt_iterator *,  const vr_values *);\n+extern bool handle_printf_call (gimple_stmt_iterator *,  class range_query *);\n \n #endif   // GCC_TREE_SSA_STRLEN_H"}]}