{"sha": "8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM3ZGJlYTlmMTkzYWUyMWQxOTM0NTNkN2E5ZWI2ZDIwODk2MThkNg==", "commit": {"author": {"name": "Boris Kolpackov", "email": "boris@codesynthesis.com", "date": "2017-11-26T13:00:48Z"}, "committer": {"name": "Jonathan Yong", "email": "jyong@gcc.gnu.org", "date": "2017-11-26T13:00:48Z"}, "message": "Plugin support on Windows/MinGW\n\nconfig/ChangeLog:\n2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n\n\t* gcc-plugin.m4: Add support for MinGW.\n\ngcc/ChangeLog:\n2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n\n\t* plugin.c (add_new_plugin): Use platform-specific library extensions.\n\t(try_init_one_plugin): Alternative implementation for MinGW.\n\t* Makefile.in (plugin_implib): New.\n\t(gengtype-lex.c): Fix broken AIX workaround.\n\t* configure: Regenerate.\n\t* doc/plugins.texi: Document support for MinGW.\n\ngcc/c/ChangeLog:\n2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n\n\t* Make-lang.in (c.install-plugin): Install backend import library.\n\ngcc/cp/ChangeLog:\n2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n\n\t* Make-lang.in (c++.install-plugin): Install backend import library.\n\nlibcc1/ChangeLog:\n2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n\n\t* configure: Regenerate.\n\nFrom-SVN: r255154", "tree": {"sha": "c02088e446e880dcebb2359db9e0c6d8c5681dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c02088e446e880dcebb2359db9e0c6d8c5681dd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/comments", "author": {"login": "boris-kolpackov", "id": 31799599, "node_id": "MDQ6VXNlcjMxNzk5NTk5", "avatar_url": "https://avatars.githubusercontent.com/u/31799599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boris-kolpackov", "html_url": "https://github.com/boris-kolpackov", "followers_url": "https://api.github.com/users/boris-kolpackov/followers", "following_url": "https://api.github.com/users/boris-kolpackov/following{/other_user}", "gists_url": "https://api.github.com/users/boris-kolpackov/gists{/gist_id}", "starred_url": "https://api.github.com/users/boris-kolpackov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boris-kolpackov/subscriptions", "organizations_url": "https://api.github.com/users/boris-kolpackov/orgs", "repos_url": "https://api.github.com/users/boris-kolpackov/repos", "events_url": "https://api.github.com/users/boris-kolpackov/events{/privacy}", "received_events_url": "https://api.github.com/users/boris-kolpackov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44dfb822801cb19dd842c5eaa2bbfa3b64b375f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44dfb822801cb19dd842c5eaa2bbfa3b64b375f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44dfb822801cb19dd842c5eaa2bbfa3b64b375f7"}], "stats": {"total": 273, "additions": 253, "deletions": 20}, "files": [{"sha": "a44722ed528a49a2657d066808ef0d6bc700f4a9", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n+\n+\t* gcc-plugin.m4: Add support for MinGW.\n+\n 2017-11-17  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n \n \t* cet.m4: New file."}, {"sha": "38b2ae6e12e6b5d0d3b9cdfd88eebeaec6841596", "filename": "config/gcc-plugin.m4", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/config%2Fgcc-plugin.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/config%2Fgcc-plugin.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fgcc-plugin.m4?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -19,8 +19,21 @@ AC_DEFUN([GCC_ENABLE_PLUGINS],\n    enable_plugin=yes; default_plugin=yes)\n \n    pluginlibs=\n+   plugin_check=yes\n \n    case \"${host}\" in\n+     *-*-mingw*)\n+       # Since plugin support under MinGW is not as straightforward as on\n+       # other platforms (e.g., we have to link import library, etc), we\n+       # only enable it if explicitly requested.\n+       if test x\"$default_plugin\" = x\"yes\"; then\n+         enable_plugin=no\n+       elif test x\"$enable_plugin\" = x\"yes\"; then\n+         # Use make's target variable to derive import library name.\n+         pluginlibs='-Wl,--export-all-symbols -Wl,--out-implib=[$]@.a'\n+\t plugin_check=no\n+       fi\n+     ;;\n      *-*-darwin*)\n        if test x$build = x$host; then\n \t export_sym_check=\"nm${exeext} -g\"\n@@ -41,7 +54,7 @@ AC_DEFUN([GCC_ENABLE_PLUGINS],\n      ;;\n    esac\n \n-   if test x\"$enable_plugin\" = x\"yes\"; then\n+   if test x\"$enable_plugin\" = x\"yes\" -a x\"$plugin_check\" = x\"yes\"; then\n \n      AC_MSG_CHECKING([for exported symbols])\n      if test \"x$export_sym_check\" != x; then"}, {"sha": "e52effababaa81ca2219a3d48681d1fc1a70ac9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -1,3 +1,12 @@\n+2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n+\n+\t* plugin.c (add_new_plugin): Use platform-specific library extensions.\n+\t(try_init_one_plugin): Alternative implementation for MinGW.\n+\t* Makefile.in (plugin_implib): New.\n+\t(gengtype-lex.c): Fix broken AIX workaround.\n+\t* configure: Regenerate.\n+\t* doc/plugins.texi: Document support for MinGW.\n+\n 2017-11-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/81553"}, {"sha": "c428eaab023c35faa58e8c944324ddc26f058ca0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -57,6 +57,7 @@ MAKEOVERRIDES =\n build=@build@\n host=@host@\n host_noncanonical=@host_noncanonical@\n+host_os=@host_os@\n target=@target@\n target_noncanonical:=@target_noncanonical@\n \n@@ -393,6 +394,11 @@ PLUGINLIBS = @pluginlibs@\n \n enable_plugin = @enable_plugin@\n \n+# On MinGW plugin installation involves installing import libraries.\n+ifeq ($(enable_plugin),yes)\n+  plugin_implib := $(if $(strip $(filter mingw%,$(host_os))),yes,no)\n+endif\n+\n enable_host_shared = @enable_host_shared@\n \n enable_as_accelerator = @enable_as_accelerator@\n@@ -2828,11 +2834,15 @@ $(genprog:%=build/gen%$(build_exeext)): build/gen%$(build_exeext): build/gen%.o\n \t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n \n # Generated source files for gengtype.  Prepend inclusion of\n-# bconfig.h because AIX requires _LARGE_FILES to be defined before\n+# config.h/bconfig.h because AIX requires _LARGE_FILES to be defined before\n # any system header is included.\n gengtype-lex.c : gengtype-lex.l\n \t-$(FLEX) $(FLEXFLAGS) -o$@ $< && { \\\n-\t  echo '#include \"bconfig.h\"' > $@.tmp; \\\n+\t  echo '#ifdef HOST_GENERATOR_FILE' > $@.tmp; \\\n+\t  echo '#include \"config.h\"'       >> $@.tmp; \\\n+\t  echo '#else'                     >> $@.tmp; \\\n+\t  echo '#include \"bconfig.h\"'      >> $@.tmp; \\\n+\t  echo '#endif'                    >> $@.tmp; \\\n \t  cat $@ >> $@.tmp; \\\n \t  mv $@.tmp $@; \\\n \t}"}, {"sha": "087a1e7cfaf484875cb72e02fb0743586fd6b5a0", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n+\n+\t* Make-lang.in (c.install-plugin): Install backend import library.\n+\n 2017-11-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-parser.c (c_parser_omp_declare_simd): Reject declare simd in"}, {"sha": "b194f2276468be942535439c33e8eb9caff18d0d", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -125,7 +125,14 @@ check-c : check-gcc\n \n c.install-common:\n c.install-man:\n-c.install-plugin:\n+\n+c.install-plugin: installdirs\n+# Install import library.\n+ifeq ($(plugin_implib),yes)\n+\t$(mkinstalldirs) $(DESTDIR)$(plugin_resourcesdir)\n+\t$(INSTALL_DATA) cc1$(exeext).a $(DESTDIR)/$(plugin_resourcesdir)/cc1$(exeext).a\n+endif\n+\n c.uninstall:\n \n #\f"}, {"sha": "39eb3c829307f4f38b434262f4cbc723d18a1d34", "filename": "gcc/configure", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -29619,8 +29619,21 @@ fi\n \n \n    pluginlibs=\n+   plugin_check=yes\n \n    case \"${host}\" in\n+     *-*-mingw*)\n+       # Since plugin support under MinGW is not as straightforward as on\n+       # other platforms (e.g., we have to link import library, etc), we\n+       # only enable it if explicitly requested.\n+       if test x\"$default_plugin\" = x\"yes\"; then\n+         enable_plugin=no\n+       elif test x\"$enable_plugin\" = x\"yes\"; then\n+         # Use make's target variable to derive import library name.\n+         pluginlibs='-Wl,--export-all-symbols -Wl,--out-implib=$@.a'\n+\t plugin_check=no\n+       fi\n+     ;;\n      *-*-darwin*)\n        if test x$build = x$host; then\n \t export_sym_check=\"nm${exeext} -g\"\n@@ -29641,7 +29654,7 @@ fi\n      ;;\n    esac\n \n-   if test x\"$enable_plugin\" = x\"yes\"; then\n+   if test x\"$enable_plugin\" = x\"yes\" -a x\"$plugin_check\" = x\"yes\"; then\n \n      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for exported symbols\" >&5\n $as_echo_n \"checking for exported symbols... \" >&6; }"}, {"sha": "854df5afe9174ba3d161e1c1203c6e5eff2850c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n+\n+\t* Make-lang.in (c++.install-plugin): Install backend import library.\n+\n 2017-11-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* parser.c (cp_parser_omp_declare): Change return type to bool from"}, {"sha": "7af4a4cb0b8640c8ace9e0ebc5613d61b3cae333", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -238,6 +238,11 @@ c++.install-plugin: installdirs\n \t  $(mkinstalldirs) $(DESTDIR)$$dir; \\\n \t  $(INSTALL_DATA) $$path $(DESTDIR)$$dest; \\\n \tdone\n+# Install import library.\n+ifeq ($(plugin_implib),yes)\n+\t$(mkinstalldirs) $(DESTDIR)$(plugin_resourcesdir)\n+\t$(INSTALL_DATA) cc1plus$(exeext).a $(DESTDIR)/$(plugin_resourcesdir)/cc1plus$(exeext).a\n+endif\n \n c++.uninstall:\n \t-rm -rf $(DESTDIR)$(bindir)/$(CXX_INSTALL_NAME)$(exeext)"}, {"sha": "dc3fa2128814e619476892f3e6678f48dcd64e9c", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -34,22 +34,25 @@ can be quite useful.\n @section Loading Plugins\n \n Plugins are supported on platforms that support @option{-ldl\n--rdynamic}.  They are loaded by the compiler using @code{dlopen}\n-and invoked at pre-determined locations in the compilation\n-process.\n+-rdynamic} as well as Windows/MinGW. They are loaded by the compiler\n+using @code{dlopen} or equivalent and invoked at pre-determined\n+locations in the compilation process.\n \n Plugins are loaded with\n \n-@option{-fplugin=/path/to/@var{name}.so} @option{-fplugin-arg-@var{name}-@var{key1}[=@var{value1}]}\n+@option{-fplugin=/path/to/@var{name}.@var{ext}} @option{-fplugin-arg-@var{name}-@var{key1}[=@var{value1}]}\n \n+Where @var{name} is the plugin name and @var{ext} is the platform-specific\n+dynamic library extension. It should be @code{dll} on Windows/MinGW,\n+@code{dylib} on Darwin/Mac OS X, and @code{so} on all other platforms.\n The plugin arguments are parsed by GCC and passed to respective\n plugins as key-value pairs. Multiple plugins can be invoked by\n specifying multiple @option{-fplugin} arguments.\n \n A plugin can be simply given by its short name (no dots or\n slashes). When simply passing @option{-fplugin=@var{name}}, the plugin is\n loaded from the @file{plugin} directory, so @option{-fplugin=@var{name}} is\n-the same as @option{-fplugin=`gcc -print-file-name=plugin`/@var{name}.so},\n+the same as @option{-fplugin=`gcc -print-file-name=plugin`/@var{name}.@var{ext}},\n using backquote shell syntax to query the @file{plugin} directory.\n \n @node Plugin API\n@@ -508,6 +511,48 @@ A single source file plugin may be built with @code{g++ -I`gcc\n plugin.so}, using backquote shell syntax to query the @file{plugin}\n directory.\n \n+Plugin support on Windows/MinGW has a number of limitations and\n+additional requirements. When building a plugin on Windows we have to\n+link an import library for the corresponding backend executable, for\n+example, @file{cc1.exe}, @file{cc1plus.exe}, etc., in order to gain\n+access to the symbols provided by GCC. This means that on Windows a\n+plugin is language-specific, for example, for C, C++, etc. If you wish\n+to use your plugin with multiple languages, then you will need to\n+build multiple plugin libraries and either instruct your users on how\n+to load the correct version or provide a compiler wrapper that does\n+this automatically.\n+\n+Additionally, on Windows the plugin library has to export the\n+@code{plugin_is_GPL_compatible} and @code{plugin_init} symbols. If you\n+do not wish to modify the source code of your plugin, then you can use\n+the @option{-Wl,--export-all-symbols} option or provide a suitable DEF\n+file. Alternatively, you can export just these two symbols by decorating\n+them with @code{__declspec(dllexport)}, for example:\n+\n+@smallexample\n+#ifdef _WIN32\n+__declspec(dllexport)\n+#endif\n+int plugin_is_GPL_compatible;\n+\n+#ifdef _WIN32\n+__declspec(dllexport)\n+#endif\n+int plugin_init (plugin_name_args *, plugin_gcc_version *)\n+@end smallexample\n+\n+The import libraries are installed into the @code{plugin} directory\n+and their names are derived by appending the @code{.a} extension to\n+the backend executable names, for example, @file{cc1.exe.a},\n+@file{cc1plus.exe.a}, etc. The following command line shows how to\n+build the single source file plugin on Windows to be used with the C++\n+compiler:\n+\n+@smallexample\n+g++ -I`gcc -print-file-name=plugin`/include -shared -Wl,--export-all-symbols \\\n+-o plugin.dll plugin.c `gcc -print-file-name=plugin`/cc1plus.exe.a\n+@end smallexample\n+\n When a plugin needs to use @command{gengtype}, be sure that both\n @file{gengtype} and @file{gtype.state} have the same version as the\n GCC for which the plugin is built."}, {"sha": "db18e642680e9a13c09dbb61b98034bc301f9636", "filename": "gcc/plugin.c", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -34,6 +34,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin-version.h\"\n #endif\n \n+#ifdef __MINGW32__\n+#ifndef WIN32_LEAN_AND_MEAN\n+#define WIN32_LEAN_AND_MEAN\n+#endif\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#endif\n+\n #define GCC_PLUGIN_STRINGIFY0(X) #X\n #define GCC_PLUGIN_STRINGIFY1(X) GCC_PLUGIN_STRINGIFY0 (X)\n \n@@ -144,7 +154,7 @@ get_plugin_base_name (const char *full_name)\n   /* First get the base name part of the full-path name, i.e. NAME.so.  */\n   char *base_name = xstrdup (lbasename (full_name));\n \n-  /* Then get rid of '.so' part of the name.  */\n+  /* Then get rid of the extension in the name, e.g., .so.  */\n   strip_off_ending (base_name, strlen (base_name));\n \n   return base_name;\n@@ -175,12 +185,27 @@ add_new_plugin (const char* plugin_name)\n   if (name_is_short)\n     {\n       base_name = CONST_CAST (char*, plugin_name);\n-      /* FIXME: the \".so\" suffix is currently builtin, since plugins\n-\t only work on ELF host systems like e.g. Linux or Solaris.\n-\t When plugins shall be available on non ELF systems such as\n-\t Windows or MacOS, this code has to be greatly improved.  */\n+\n+#if defined(__MINGW32__)\n+      static const char plugin_ext[] = \".dll\";\n+#elif defined(__APPLE__)\n+      /* Mac OS has two types of libraries: dynamic libraries (.dylib) and\n+         plugins (.bundle). Both can be used with dlopen()/dlsym() but the\n+         former cannot be linked at build time (i.e., with the -lfoo linker\n+         option). A GCC plugin is therefore probably a Mac OS plugin but their\n+         use seems to be quite rare and the .bundle extension is more of a\n+         recommendation rather than the rule. This raises the questions of how\n+         well they are supported by tools (e.g., libtool). So to avoid\n+         complications let's use the .dylib extension for now. In the future,\n+         if this proves to be an issue, we can always check for both\n+         extensions.  */\n+      static const char plugin_ext[] = \".dylib\";\n+#else\n+      static const char plugin_ext[] = \".so\";\n+#endif\n+\n       plugin_name = concat (default_plugin_dir_name (), \"/\",\n-\t\t\t    plugin_name, \".so\", NULL);\n+\t\t\t    plugin_name, plugin_ext, NULL);\n       if (access (plugin_name, R_OK))\n \tfatal_error\n \t  (input_location,\n@@ -573,6 +598,85 @@ invoke_plugin_callbacks_full (int event, void *gcc_data)\n }\n \n #ifdef ENABLE_PLUGIN\n+\n+/* Try to initialize PLUGIN. Return true if successful. */\n+\n+#ifdef __MINGW32__\n+\n+// Return a message string for last error or NULL if unknown. Must be freed\n+// with LocalFree().\n+static inline char *\n+win32_error_msg ()\n+{\n+  char *msg;\n+  return FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+\t\t\t FORMAT_MESSAGE_FROM_SYSTEM |\n+\t\t\t FORMAT_MESSAGE_IGNORE_INSERTS |\n+\t\t\t FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+\t\t\t 0,\n+\t\t\t GetLastError (),\n+\t\t\t MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),\n+\t\t\t (char*)&msg,\n+\t\t\t 0,\n+\t\t\t 0)\n+    ? msg\n+    : NULL;\n+}\n+\n+static bool\n+try_init_one_plugin (struct plugin_name_args *plugin)\n+{\n+  HMODULE dl_handle;\n+  plugin_init_func plugin_init;\n+\n+  dl_handle = LoadLibrary (plugin->full_name);\n+  if (!dl_handle)\n+    {\n+      char *err = win32_error_msg ();\n+      error (\"cannot load plugin %s\\n%s\", plugin->full_name, err);\n+      LocalFree (err);\n+      return false;\n+    }\n+\n+  /* Check the plugin license. Unlike the name suggests, GetProcAddress()\n+     can be used for both functions and variables.  */\n+  if (GetProcAddress (dl_handle, str_license) == NULL)\n+    {\n+      char *err = win32_error_msg ();\n+      fatal_error (input_location,\n+\t\t   \"plugin %s is not licensed under a GPL-compatible license\\n\"\n+\t\t   \"%s\", plugin->full_name, err);\n+    }\n+\n+  /* Unlike dlsym(), GetProcAddress() returns a pointer to a function so we\n+     can cast directly without union tricks.  */\n+  plugin_init = (plugin_init_func)\n+    GetProcAddress (dl_handle, str_plugin_init_func_name);\n+\n+  if (plugin_init == NULL)\n+    {\n+      char *err = win32_error_msg ();\n+      FreeLibrary (dl_handle);\n+      error (\"cannot find %s in plugin %s\\n%s\", str_plugin_init_func_name,\n+             plugin->full_name, err);\n+      LocalFree (err);\n+      return false;\n+    }\n+\n+  /* Call the plugin-provided initialization routine with the arguments.  */\n+  if ((*plugin_init) (plugin, &gcc_version))\n+    {\n+      FreeLibrary (dl_handle);\n+      error (\"fail to initialize plugin %s\", plugin->full_name);\n+      return false;\n+    }\n+  /* Leak dl_handle on purpose to ensure the plugin is loaded for the\n+     entire run of the compiler. */\n+  return true;\n+}\n+\n+#else // POSIX-like with dlopen()/dlsym().\n+\n /* We need a union to cast dlsym return value to a function pointer\n    as ISO C forbids assignment between function pointer and 'void *'.\n    Use explicit union instead of __extension__(<union_cast>) for\n@@ -581,8 +685,6 @@ invoke_plugin_callbacks_full (int event, void *gcc_data)\n #define PTR_UNION_AS_VOID_PTR(NAME) (NAME._q)\n #define PTR_UNION_AS_CAST_PTR(NAME) (NAME._nq)\n \n-/* Try to initialize PLUGIN. Return true if successful. */\n-\n static bool\n try_init_one_plugin (struct plugin_name_args *plugin)\n {\n@@ -634,7 +736,7 @@ try_init_one_plugin (struct plugin_name_args *plugin)\n      entire run of the compiler. */\n   return true;\n }\n-\n+#endif\n \n /* Routine to dlopen and initialize one plugin. This function is passed to\n    (and called by) the hash table traverse routine. Return 1 for the"}, {"sha": "c248bf8dd203231c7509aec979f9b9836fa4b42d", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14 Boris Kolpackov  <boris@codesynthesis.com>\n+\n+\t* configure: Regenerate.\n+\n 2017-11-16  Sergio Durigan Junior  <sergiodj@redhat.com>\n \t    Pedro Alves  <palves@redhat.com>\n "}, {"sha": "23d1a7645ff3a85059d650380fc14a8f8cb46be1", "filename": "libcc1/configure", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/libcc1%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7dbea9f193ae21d193453d7a9eb6d2089618d6/libcc1%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fconfigure?ref=8c7dbea9f193ae21d193453d7a9eb6d2089618d6", "patch": "@@ -14552,8 +14552,21 @@ fi\n \n \n    pluginlibs=\n+   plugin_check=yes\n \n    case \"${host}\" in\n+     *-*-mingw*)\n+       # Since plugin support under MinGW is not as straightforward as on\n+       # other platforms (e.g., we have to link import library, etc), we\n+       # only enable it if explicitly requested.\n+       if test x\"$default_plugin\" = x\"yes\"; then\n+         enable_plugin=no\n+       elif test x\"$enable_plugin\" = x\"yes\"; then\n+         # Use make's target variable to derive import library name.\n+         pluginlibs='-Wl,--export-all-symbols -Wl,--out-implib=$@.a'\n+\t plugin_check=no\n+       fi\n+     ;;\n      *-*-darwin*)\n        if test x$build = x$host; then\n \t export_sym_check=\"nm${exeext} -g\"\n@@ -14574,7 +14587,7 @@ fi\n      ;;\n    esac\n \n-   if test x\"$enable_plugin\" = x\"yes\"; then\n+   if test x\"$enable_plugin\" = x\"yes\" -a x\"$plugin_check\" = x\"yes\"; then\n \n      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for exported symbols\" >&5\n $as_echo_n \"checking for exported symbols... \" >&6; }"}]}