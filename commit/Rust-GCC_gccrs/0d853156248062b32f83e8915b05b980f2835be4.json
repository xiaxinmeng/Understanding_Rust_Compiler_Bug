{"sha": "0d853156248062b32f83e8915b05b980f2835be4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4NTMxNTYyNDgwNjJiMzJmODNlODkxNWIwNWI5ODBmMjgzNWJlNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-03-23T09:49:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-03-23T09:49:46Z"}, "message": "decl.c (validate_size): Improve comments and tweak error message.\n\n\t* gcc-interface/decl.c (validate_size): Improve comments and tweak\n\terror message.\n\t(set_rm_size): Likewise.\n\nFrom-SVN: r171343", "tree": {"sha": "25a6d76cb0e4147e0bf3a129e08790d926ff93d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25a6d76cb0e4147e0bf3a129e08790d926ff93d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d853156248062b32f83e8915b05b980f2835be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d853156248062b32f83e8915b05b980f2835be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d853156248062b32f83e8915b05b980f2835be4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d853156248062b32f83e8915b05b980f2835be4/comments", "author": null, "committer": null, "parents": [{"sha": "4184ef1b53a953f11d32569788d2ec3261dde565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4184ef1b53a953f11d32569788d2ec3261dde565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4184ef1b53a953f11d32569788d2ec3261dde565"}], "stats": {"total": 63, "additions": 34, "deletions": 29}, "files": [{"sha": "d8d9df0fb3864b0ac427a85066a956620e4d7fdd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d853156248062b32f83e8915b05b980f2835be4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d853156248062b32f83e8915b05b980f2835be4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d853156248062b32f83e8915b05b980f2835be4", "patch": "@@ -1,3 +1,9 @@\n+2011-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (validate_size): Improve comments and tweak\n+\terror message.\n+\t(set_rm_size): Likewise.\n+\n 2011-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Create TYPE_DECL"}, {"sha": "a3bb2e70937501fa04b28406622258ef0792ce77", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d853156248062b32f83e8915b05b980f2835be4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d853156248062b32f83e8915b05b980f2835be4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0d853156248062b32f83e8915b05b980f2835be4", "patch": "@@ -7799,14 +7799,14 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n }\n \f\n /* UINT_SIZE is a Uint giving the specified size for an object of GNU_TYPE\n-   corresponding to GNAT_OBJECT.  If size is valid, return a tree corresponding\n-   to its value.  Otherwise return 0.  KIND is VAR_DECL is we are specifying\n-   the size for an object, TYPE_DECL for the size of a type, and FIELD_DECL\n-   for the size of a field.  COMPONENT_P is true if we are being called\n-   to process the Component_Size of GNAT_OBJECT.  This is used for error\n-   message handling and to indicate to use the object size of GNU_TYPE.\n-   ZERO_OK is true if a size of zero is permitted; if ZERO_OK is false,\n-   it means that a size of zero should be treated as an unspecified size.  */\n+   corresponding to GNAT_OBJECT.  If the size is valid, return an INTEGER_CST\n+   corresponding to its value.  Otherwise, return NULL_TREE.  KIND is set to\n+   VAR_DECL if we are specifying the size of an object, TYPE_DECL for the\n+   size of a type, and FIELD_DECL for the size of a field.  COMPONENT_P is\n+   true if we are being called to process the Component_Size of GNAT_OBJECT;\n+   this is used only for error messages.  ZERO_OK is true if a size of zero\n+   is permitted; if ZERO_OK is false, it means that a size of zero should be\n+   treated as an unspecified size.  */\n \n static tree\n validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n@@ -7823,7 +7823,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   if (UI_Lt (uint_size, Uint_0))\n     return NULL_TREE;\n \n-  /* Find the node to use for errors.  */\n+  /* Find the node to use for error messages.  */\n   if ((Ekind (gnat_object) == E_Component\n        || Ekind (gnat_object) == E_Discriminant)\n       && Present (Component_Clause (gnat_object)))\n@@ -7833,16 +7833,16 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   else\n     gnat_error_node = gnat_object;\n \n-  /* Get the size as a tree.  Issue an error if a size was specified but\n-     cannot be represented in sizetype.  */\n+  /* Get the size as an INTEGER_CST.  Issue an error if a size was specified\n+     but cannot be represented in bitsizetype.  */\n   size = UI_To_gnu (uint_size, bitsizetype);\n   if (TREE_OVERFLOW (size))\n     {\n       if (component_p)\n-\tpost_error_ne (\"component size of & is too large\", gnat_error_node,\n+\tpost_error_ne (\"component size for& is too large\", gnat_error_node,\n \t\t       gnat_object);\n       else\n-\tpost_error_ne (\"size of & is too large\", gnat_error_node,\n+\tpost_error_ne (\"size for& is too large\", gnat_error_node,\n \t\t       gnat_object);\n       return NULL_TREE;\n     }\n@@ -7865,15 +7865,15 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n     }\n \n   /* If this is an integral type or a packed array type, the front-end has\n-     verified the size, so we need not do it here (which would entail\n+     already verified the size, so we need not do it here (which would mean\n      checking against the bounds).  However, if this is an aliased object,\n      it may not be smaller than the type of the object.  */\n   if ((INTEGRAL_TYPE_P (gnu_type) || TYPE_IS_PACKED_ARRAY_TYPE_P (gnu_type))\n       && !(kind == VAR_DECL && Is_Aliased (gnat_object)))\n     return size;\n \n-  /* If the object is a record that contains a template, add the size of\n-     the template to the specified size.  */\n+  /* If the object is a record that contains a template, add the size of the\n+     template to the specified size.  */\n   if (TREE_CODE (gnu_type) == RECORD_TYPE\n       && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n     size = size_binop (PLUS_EXPR, DECL_SIZE (TYPE_FIELDS (gnu_type)), size);\n@@ -7886,8 +7886,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   else\n     type_size = rm_size (gnu_type);\n \n-  /* Modify the size of the type to be that of the maximum size if it has a\n-     discriminant.  */\n+  /* Modify the size of a discriminated type to be the maximum size.  */\n   if (type_size && CONTAINS_PLACEHOLDER_P (type_size))\n     type_size = max_size (type_size, true);\n \n@@ -7901,8 +7900,8 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       type_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n     }\n \n-  /* If the size of the object is a constant, the new size must not be\n-     smaller.  */\n+  /* Issue an error either if the default size of the object isn't a constant\n+     or if the new size is smaller than it.  */\n   if (TREE_CODE (type_size) != INTEGER_CST\n       || TREE_OVERFLOW (type_size)\n       || tree_int_cst_lt (size, type_size))\n@@ -7915,15 +7914,14 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \tpost_error_ne_tree\n \t  (\"size for& too small{, minimum allowed is ^}\",\n \t   gnat_error_node, gnat_object, type_size);\n-\n-      size = NULL_TREE;\n+      return NULL_TREE;\n     }\n \n   return size;\n }\n \f\n-/* Similarly, but both validate and process a value of RM size.  This\n-   routine is only called for types.  */\n+/* Similarly, but both validate and process a value of RM size.  This routine\n+   is only called for types.  */\n \n static void\n set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n@@ -7944,13 +7942,13 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   gnat_attr_node\n     = Get_Attribute_Definition_Clause (gnat_entity, Attr_Value_Size);\n \n-  /* Get the size as a tree.  Issue an error if a size was specified but\n-     cannot be represented in sizetype.  */\n+  /* Get the size as an INTEGER_CST.  Issue an error if a size was specified\n+     but cannot be represented in bitsizetype.  */\n   size = UI_To_gnu (uint_size, bitsizetype);\n   if (TREE_OVERFLOW (size))\n     {\n       if (Present (gnat_attr_node))\n-\tpost_error_ne (\"Value_Size of & is too large\", gnat_attr_node,\n+\tpost_error_ne (\"Value_Size for& is too large\", gnat_attr_node,\n \t\t       gnat_entity);\n       return;\n     }\n@@ -7970,8 +7968,9 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   if (CONTAINS_PLACEHOLDER_P (old_size))\n     old_size = max_size (old_size, true);\n \n-  /* If the size of the object is a constant, the new size must not be smaller\n-     (the front-end has verified this for scalar and packed array types).  */\n+  /* Issue an error either if the old size of the object isn't a constant or\n+     if the new size is smaller than it.  The front-end has already verified\n+     this for scalar and packed array types.  */\n   if (TREE_CODE (old_size) != INTEGER_CST\n       || TREE_OVERFLOW (old_size)\n       || (AGGREGATE_TYPE_P (gnu_type)"}]}