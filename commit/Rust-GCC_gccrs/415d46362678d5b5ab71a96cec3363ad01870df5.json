{"sha": "415d46362678d5b5ab71a96cec3363ad01870df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE1ZDQ2MzYyNjc4ZDViNWFiNzFhOTZjZWMzMzYzYWQwMTg3MGRmNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-29T01:57:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-29T01:57:47Z"}, "message": "re PR c++/11530 ([unit-at-a-time] inline static function not emitted with -O3)\n\n\tPR c++/11530\n\t* parser.c (cp_parser_postfix_expression): Do not call mark_used.\n\t* semantics.c (finish_id_expression): Call mark_used for all\n\tdeclarations.\n\n\tPR c++/11530\n\t* g++.dg/opt/call1.C: New test.\n\nFrom-SVN: r69911", "tree": {"sha": "d294364dbe757f8114ce5fb8aa4219d5820584d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d294364dbe757f8114ce5fb8aa4219d5820584d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/415d46362678d5b5ab71a96cec3363ad01870df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415d46362678d5b5ab71a96cec3363ad01870df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415d46362678d5b5ab71a96cec3363ad01870df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415d46362678d5b5ab71a96cec3363ad01870df5/comments", "author": null, "committer": null, "parents": [{"sha": "7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6d72fcfbd0aa2bb05d81afcdcf5e4c6027b2e8"}], "stats": {"total": 81, "additions": 58, "deletions": 23}, "files": [{"sha": "583d13ff584cc684f0c6e726a0eea1e6c0f29669", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=415d46362678d5b5ab71a96cec3363ad01870df5", "patch": "@@ -1,3 +1,10 @@\n+2003-07-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11530\n+\t* parser.c (cp_parser_postfix_expression): Do not call mark_used.\n+\t* semantics.c (finish_id_expression): Call mark_used for all\n+\tdeclarations.\n+\n 2003-07-28  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11667"}, {"sha": "00f1c6eda4fe3a2d7ff14aa6a56cfd46b968dfa6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=415d46362678d5b5ab71a96cec3363ad01870df5", "patch": "@@ -3428,10 +3428,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \treturn postfix_expression;\n     }\n \n-  /* Remember that there was a reference to this entity.  */\n-  if (DECL_P (postfix_expression))\n-    mark_used (postfix_expression);\n-\n   /* Keep looping until the postfix-expression is complete.  */\n   while (true)\n     {"}, {"sha": "bf30ca08b8f1045e91ef9751eaed9e0f8e009fa8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=415d46362678d5b5ab71a96cec3363ad01870df5", "patch": "@@ -2486,19 +2486,8 @@ finish_id_expression (tree id_expression,\n \t      *non_constant_expression_p = true;\n \t    }\n \t}\n-\n-      if (scope)\n-\t{\n-\t  decl = (adjust_result_of_qualified_name_lookup \n-\t\t  (decl, scope, current_class_type));\n-\t  if (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n-\t    *qualifying_class = scope;\n-\t  else if (!processing_template_decl)\n-\t    decl = convert_from_reference (decl);\n-\t  else if (TYPE_P (scope))\n-\t    decl = build (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n-\t}\n-      else if (TREE_CODE (decl) == NAMESPACE_DECL)\n+      \n+      if (TREE_CODE (decl) == NAMESPACE_DECL)\n \t{\n \t  error (\"use of namespace `%D' as expression\", decl);\n \t  return error_mark_node;\n@@ -2516,6 +2505,25 @@ finish_id_expression (tree id_expression,\n \t  print_candidates (decl);\n \t  return error_mark_node;\n \t}\n+\n+      /* Mark variable-like entities as used.  Functions are similarly\n+\t marked either below or after overload resolution.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == RESULT_DECL)\n+\tmark_used (decl);\n+\n+      if (scope)\n+\t{\n+\t  decl = (adjust_result_of_qualified_name_lookup \n+\t\t  (decl, scope, current_class_type));\n+\t  if (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n+\t    *qualifying_class = scope;\n+\t  else if (!processing_template_decl)\n+\t    decl = convert_from_reference (decl);\n+\t  else if (TYPE_P (scope))\n+\t    decl = build (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n+\t}\n       else if (TREE_CODE (decl) == FIELD_DECL)\n \tdecl = finish_non_static_data_member (decl, current_class_ref,\n \t\t\t\t\t      /*qualifying_scope=*/NULL_TREE);\n@@ -2525,17 +2533,17 @@ finish_id_expression (tree id_expression,\n \n \t  if (TREE_CODE (first_fn) == TEMPLATE_DECL)\n \t    first_fn = DECL_TEMPLATE_RESULT (first_fn);\n-\t  \n+\n+\t  if (!really_overloaded_fn (decl))\n+\t    mark_used (first_fn);\n+\n \t  if (TREE_CODE (first_fn) == FUNCTION_DECL\n \t      && DECL_FUNCTION_MEMBER_P (first_fn))\n \t    {\n \t      /* A set of member functions.  */\n \t      decl = maybe_dummy_object (DECL_CONTEXT (first_fn), 0);\n \t      return finish_class_member_access_expr (decl, id_expression);\n \t    }\n-\t  else if (!really_overloaded_fn (decl))\n-\t    /* not really overloaded function */\n-\t    mark_used (first_fn);\n \t}\n       else\n \t{\n@@ -2566,8 +2574,6 @@ finish_id_expression (tree id_expression,\n \t      perform_or_defer_access_check (TYPE_BINFO (path), decl);\n \t    }\n \t  \n-\t  mark_used (decl);\n-\t  \n \t  if (! processing_template_decl)\n \t    decl = convert_from_reference (decl);\n \t}"}, {"sha": "6b59e6a9b0c4c478b6cdc01996803722319efe79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=415d46362678d5b5ab71a96cec3363ad01870df5", "patch": "@@ -1,3 +1,8 @@\n+2003-07-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR c++/11530\n+\t* g++.dg/opt/call1.C: New test.\n+\n 2003-07-28  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR c++/11667"}, {"sha": "642e024084927a7dd7ac4cfbbf969bbd2cccb33a", "filename": "gcc/testsuite/g++.dg/opt/call1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcall1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/415d46362678d5b5ab71a96cec3363ad01870df5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcall1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcall1.C?ref=415d46362678d5b5ab71a96cec3363ad01870df5", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-O2\" }\n+\n+void a (void (*f)())\n+{\n+  f();\n+}\n+\n+struct RunState\n+{\n+  static void runcallback() { }\n+  static void wait()\n+  {\n+    a (runcallback);\n+  }\n+};\n+\n+int main()\n+{\n+  RunState::wait();\n+  return 0;\n+}"}]}