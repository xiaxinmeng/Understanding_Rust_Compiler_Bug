{"sha": "d75199f782348bfc401f925b60f33ffc9822b7cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc1MTk5Zjc4MjM0OGJmYzQwMWY5MjViNjBmMzNmZmM5ODIyYjdjYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-13T18:27:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-15T18:57:01Z"}, "message": "c++: Avoid redundant copy in {} init [PR98642]\n\nHere, initializing from { } implies a call to the default constructor for\nbase.  We were then seeing that we're initializing a base subobject, so we\ntried to copy the result of that call.  This is clearly wrong; we should\ninitialize the base directly from its default constructor.\n\nThis patch does a lot of refactoring of unsafe_copy_elision_p and adds\nmake_safe_copy_elision that will also try to do the base constructor\nrewriting from the last patch.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98642\n\t* call.c (unsafe_return_slot_p): Return int.\n\t(init_by_return_slot_p): Split out from...\n\t(unsafe_copy_elision_p): ...here.\n\t(unsafe_copy_elision_p_opt): New name for old meaning.\n\t(build_over_call): Adjust.\n\t(make_safe_copy_elision): New.\n\t* typeck2.c (split_nonconstant_init_1): Elide copy from safe\n\tlist-initialization.\n\t* cp-tree.h: Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98642\n\t* g++.dg/cpp1z/elide5.C: New test.", "tree": {"sha": "a1f67748fa7024d5816a2133f7e9310101d70f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1f67748fa7024d5816a2133f7e9310101d70f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d75199f782348bfc401f925b60f33ffc9822b7cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75199f782348bfc401f925b60f33ffc9822b7cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75199f782348bfc401f925b60f33ffc9822b7cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75199f782348bfc401f925b60f33ffc9822b7cc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "424deca72b63e644cbc975cbc2fdda5248449bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/424deca72b63e644cbc975cbc2fdda5248449bcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/424deca72b63e644cbc975cbc2fdda5248449bcb"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "b6e9f125aeb93f0bc22b308f3d7b8fa60e946ee3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d75199f782348bfc401f925b60f33ffc9822b7cc", "patch": "@@ -8439,7 +8439,7 @@ base_ctor_for (tree complete_ctor)\n \n /* Try to make EXP suitable to be used as the initializer for a base subobject,\n    and return whether we were successful.  EXP must have already been cleared\n-   by unsafe_copy_elision_p.  */\n+   by unsafe_copy_elision_p{,_opt}.  */\n \n static bool\n make_base_init_ok (tree exp)\n@@ -8463,7 +8463,7 @@ make_base_init_ok (tree exp)\n     /* A trivial copy is OK.  */\n     return true;\n   if (!AGGR_INIT_VIA_CTOR_P (exp))\n-    /* unsafe_copy_elision_p must have said this is OK.  */\n+    /* unsafe_copy_elision_p_opt must have said this is OK.  */\n     return true;\n   tree fn = cp_get_callee_fndecl_nofold (exp);\n   if (DECL_BASE_CONSTRUCTOR_P (fn))\n@@ -8479,20 +8479,20 @@ make_base_init_ok (tree exp)\n   return true;\n }\n \n-/* Return true iff T refers to a base or potentially-overlapping field, which\n-   cannot be used for return by invisible reference.  We avoid doing C++17\n-   mandatory copy elision when this is true.\n+/* Return 2 if T refers to a base, 1 if a potentially-overlapping field,\n+   neither of which can be used for return by invisible reference.  We avoid\n+   doing C++17 mandatory copy elision for either of these cases.\n \n-   This returns true even if the type of T has no tail padding that other data\n-   could be allocated into, because that depends on the particular ABI.\n-   unsafe_copy_elision_p, below, does consider whether there is padding.  */\n+   This returns non-zero even if the type of T has no tail padding that other\n+   data could be allocated into, because that depends on the particular ABI.\n+   unsafe_copy_elision_p_opt does consider whether there is padding.  */\n \n-bool\n+int\n unsafe_return_slot_p (tree t)\n {\n   /* Check empty bases separately, they don't have fields.  */\n   if (is_empty_base_ref (t))\n-    return true;\n+    return 2;\n \n   STRIP_NOPS (t);\n   if (TREE_CODE (t) == ADDR_EXPR)\n@@ -8504,45 +8504,80 @@ unsafe_return_slot_p (tree t)\n   if (!CLASS_TYPE_P (TREE_TYPE (t)))\n     /* The middle-end will do the right thing for scalar types.  */\n     return false;\n-  return (DECL_FIELD_IS_BASE (t)\n-\t  || lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (t)));\n+  if (DECL_FIELD_IS_BASE (t))\n+    return 2;\n+  if (lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (t)))\n+    return 1;\n+  return 0;\n }\n \n-/* We can't elide a copy from a function returning by value to a\n-   potentially-overlapping subobject, as the callee might clobber tail padding.\n-   Return true iff this could be that case.  */\n+/* True IFF EXP is a prvalue that represents return by invisible reference.  */\n \n static bool\n-unsafe_copy_elision_p (tree target, tree exp)\n+init_by_return_slot_p (tree exp)\n {\n   /* Copy elision only happens with a TARGET_EXPR.  */\n   if (TREE_CODE (exp) != TARGET_EXPR)\n     return false;\n-  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n-  /* It's safe to elide the copy for a class with no tail padding.  */\n-  if (!is_empty_class (type)\n-      && tree_int_cst_equal (TYPE_SIZE (type), CLASSTYPE_SIZE (type)))\n-    return false;\n-  /* It's safe to elide the copy if we aren't initializing a base object.  */\n-  if (!unsafe_return_slot_p (target))\n-    return false;\n   tree init = TARGET_EXPR_INITIAL (exp);\n   /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */\n   while (TREE_CODE (init) == COMPOUND_EXPR)\n     init = TREE_OPERAND (init, 1);\n   if (TREE_CODE (init) == COND_EXPR)\n     {\n       /* We'll end up copying from each of the arms of the COND_EXPR directly\n-\t into the target, so look at them. */\n+\t into the target, so look at them.  */\n       if (tree op = TREE_OPERAND (init, 1))\n-\tif (unsafe_copy_elision_p (target, op))\n+\tif (init_by_return_slot_p (op))\n \t  return true;\n-      return unsafe_copy_elision_p (target, TREE_OPERAND (init, 2));\n+      return init_by_return_slot_p (TREE_OPERAND (init, 2));\n     }\n   return (TREE_CODE (init) == AGGR_INIT_EXPR\n \t  && !AGGR_INIT_VIA_CTOR_P (init));\n }\n \n+/* We can't elide a copy from a function returning by value to a\n+   potentially-overlapping subobject, as the callee might clobber tail padding.\n+   Return true iff this could be that case.\n+\n+   Places that use this function (or _opt) to decide to elide a copy should\n+   probably use make_safe_copy_elision instead.  */\n+\n+static bool\n+unsafe_copy_elision_p (tree target, tree exp)\n+{\n+  return unsafe_return_slot_p (target) && init_by_return_slot_p (exp);\n+}\n+\n+/* As above, but for optimization allow more cases that are actually safe.  */\n+\n+static bool\n+unsafe_copy_elision_p_opt (tree target, tree exp)\n+{\n+  tree type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n+  /* It's safe to elide the copy for a class with no tail padding.  */\n+  if (!is_empty_class (type)\n+      && tree_int_cst_equal (TYPE_SIZE (type), CLASSTYPE_SIZE (type)))\n+    return false;\n+  return unsafe_copy_elision_p (target, exp);\n+}\n+\n+/* Try to make EXP suitable to be used as the initializer for TARGET,\n+   and return whether we were successful.  */\n+\n+bool\n+make_safe_copy_elision (tree target, tree exp)\n+{\n+  int uns = unsafe_return_slot_p (target);\n+  if (!uns)\n+    return true;\n+  if (init_by_return_slot_p (exp))\n+    return false;\n+  if (uns == 1)\n+    return true;\n+  return make_base_init_ok (exp);\n+}\n+\n /* True IFF the result of the conversion C is a prvalue.  */\n \n static bool\n@@ -9188,7 +9223,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t    /* See unsafe_copy_elision_p.  */\n \t\t    || unsafe_return_slot_p (fa));\n \n-      bool unsafe = unsafe_copy_elision_p (fa, arg);\n+      bool unsafe = unsafe_copy_elision_p_opt (fa, arg);\n       bool eliding_temp = (TREE_CODE (arg) == TARGET_EXPR && !unsafe);\n \n       /* [class.copy]: the copy constructor is implicitly defined even if the"}, {"sha": "51139f4a4be8c11fa4d6f3883e34c05b74480098", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d75199f782348bfc401f925b60f33ffc9822b7cc", "patch": "@@ -6471,7 +6471,8 @@ extern bool is_std_init_list\t\t\t(tree);\n extern bool is_list_ctor\t\t\t(tree);\n extern void validate_conversion_obstack\t\t(void);\n extern void mark_versions_used\t\t\t(tree);\n-extern bool unsafe_return_slot_p\t\t(tree);\n+extern int unsafe_return_slot_p\t\t\t(tree);\n+extern bool make_safe_copy_elision\t\t(tree, tree);\n extern bool cp_warn_deprecated_use\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern void cp_warn_deprecated_use_scopes\t(tree);\n extern tree get_function_version_dispatcher\t(tree);"}, {"sha": "d9362500f06ab01afcc18ed3fa627e4a80b81028", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d75199f782348bfc401f925b60f33ffc9822b7cc", "patch": "@@ -569,17 +569,30 @@ split_nonconstant_init_1 (tree dest, tree init, bool nested)\n \t\t    sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n \t\t\t\t  NULL_TREE);\n \n+\t\t  /* We may need to add a copy constructor call if\n+\t\t     the field has [[no_unique_address]].  */\n \t\t  if (unsafe_return_slot_p (sub))\n \t\t    {\n-\t\t      /* We may need to add a copy constructor call if\n-\t\t\t the field has [[no_unique_address]].  */\n+\t\t      /* But not if the initializer is an implicit ctor call\n+\t\t\t we just built in digest_init.  */\n+\t\t      if (TREE_CODE (value) == TARGET_EXPR\n+\t\t\t  && TARGET_EXPR_LIST_INIT_P (value)\n+\t\t\t  && make_safe_copy_elision (sub, value))\n+\t\t\tgoto build_init;\n+\n+\t\t      tree name = (DECL_FIELD_IS_BASE (field_index)\n+\t\t\t\t   ? base_ctor_identifier\n+\t\t\t\t   : complete_ctor_identifier);\n \t\t      releasing_vec args = make_tree_vector_single (value);\n \t\t      code = build_special_member_call\n-\t\t\t(sub, complete_ctor_identifier, &args, inner_type,\n+\t\t\t(sub, name, &args, inner_type,\n \t\t\t LOOKUP_NORMAL, tf_warning_or_error);\n \t\t    }\n \t\t  else\n-\t\t    code = build2 (INIT_EXPR, inner_type, sub, value);\n+\t\t    {\n+\t\t    build_init:\n+\t\t      code = build2 (INIT_EXPR, inner_type, sub, value);\n+\t\t    }\n \t\t  code = build_stmt (input_location, EXPR_STMT, code);\n \t\t  code = maybe_cleanup_point_expr_void (code);\n \t\t  add_stmt (code);"}, {"sha": "abe80ec0bc43582fe142c919e15d7734456b1b71", "filename": "gcc/testsuite/g++.dg/cpp1z/elide5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75199f782348bfc401f925b60f33ffc9822b7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide5.C?ref=d75199f782348bfc401f925b60f33ffc9822b7cc", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/98642\n+// { dg-do compile { target c++11 } }\n+\n+struct base {\n+  base(void) {}\n+  base(base &&) = delete;\n+};\n+\n+struct foo : public base { };\n+\n+static foo c1 { };\n+\n+#if __cpp_aggregate_bases\n+static foo c2 { {} };\n+#endif"}]}