{"sha": "fd0611850d548ec973dfff208a064eb561621481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQwNjExODUwZDU0OGVjOTczZGZmZjIwOGEwNjRlYjU2MTYyMTQ4MQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-18T17:09:13Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-18T17:09:13Z"}, "message": "re PR fortran/54884 (Externally used PRIVATE module procedure wrongly marked as TREE_PUBLIC()=0)\n\n2012-10-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54884\n        * resolve.c (specification_expr): Change to bool.\n        (resolve_formal_arglist, resolve_symbol): Set\n        specification_expr to true before resolving the array spec.\n        (resolve_variable, resolve_charlen, resolve_fl_variable):\n        Properly reset specification_expr.\n        (resolve_function): Set public_use when used in\n        a specification expr.\n\n2012-10-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54884\n        * gfortran.dg/public_private_module_7.f90: New.\n\nFrom-SVN: r192571", "tree": {"sha": "1184fe6275641dc585ad6282f7144996f451f07c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1184fe6275641dc585ad6282f7144996f451f07c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd0611850d548ec973dfff208a064eb561621481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0611850d548ec973dfff208a064eb561621481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd0611850d548ec973dfff208a064eb561621481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0611850d548ec973dfff208a064eb561621481/comments", "author": null, "committer": null, "parents": [{"sha": "0fb2e99454910a5071743ccb924223ca3df33d36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2e99454910a5071743ccb924223ca3df33d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb2e99454910a5071743ccb924223ca3df33d36"}], "stats": {"total": 140, "additions": 113, "deletions": 27}, "files": [{"sha": "37afedeaebacc2a10d47fb27669fb69f809fdce0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fd0611850d548ec973dfff208a064eb561621481", "patch": "@@ -1,3 +1,14 @@\n+2012-10-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54884\n+\t* resolve.c (specification_expr): Change to bool.\n+\t(resolve_formal_arglist, resolve_symbol): Set\n+\tspecification_expr to true before resolving the array spec.\n+\t(resolve_variable, resolve_charlen, resolve_fl_variable):\n+\tProperly reset specification_expr.\n+\t(resolve_function): Set public_use when used in\n+\ta specification expr.\n+\n 2012-10-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/50981"}, {"sha": "ac3021ea72c205883450fc814ad2e74107dff19c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=fd0611850d548ec973dfff208a064eb561621481", "patch": "@@ -81,7 +81,7 @@ static int omp_workshare_flag;\n static int formal_arg_flag = 0;\n \n /* True if we are resolving a specification expression.  */\n-static int specification_expr = 0;\n+static bool specification_expr = false;\n \n /* The id of the last entry seen.  */\n static int current_entry_id;\n@@ -278,6 +278,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n {\n   gfc_formal_arglist *f;\n   gfc_symbol *sym;\n+  bool saved_specification_expr;\n   int i;\n \n   if (proc->result != NULL)\n@@ -336,7 +337,10 @@ resolve_formal_arglist (gfc_symbol *proc)\n       as = sym->ts.type == BT_CLASS && sym->attr.class_ok\n \t   ? CLASS_DATA (sym)->as : sym->as;\n \n+      saved_specification_expr = specification_expr;\n+      specification_expr = true;\n       gfc_resolve_array_spec (as, 0);\n+      specification_expr = saved_specification_expr;\n \n       /* We can't tell if an array with dimension (:) is assumed or deferred\n \t shape until we know if it has the pointer or allocatable attributes.\n@@ -3119,6 +3123,12 @@ resolve_function (gfc_expr *expr)\n       return FAILURE;\n     }\n \n+  if (sym && specification_expr && sym->attr.function\n+      && gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->attr.flavor == FL_MODULE)\n+    sym->attr.public_used = 1;\n+\n+\n   /* Switch off assumed size checking and do this again for certain kinds\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n@@ -5368,7 +5378,7 @@ resolve_variable (gfc_expr *e)\n       gfc_entry_list *entry;\n       gfc_formal_arglist *formal;\n       int n;\n-      bool seen;\n+      bool seen, saved_specification_expr;\n \n       /* If the symbol is a dummy...  */\n       if (sym->attr.dummy && sym->ns == gfc_current_ns)\n@@ -5401,22 +5411,21 @@ resolve_variable (gfc_expr *e)\n \t}\n \n       /* Now do the same check on the specification expressions.  */\n-      specification_expr = 1;\n+      saved_specification_expr = specification_expr;\n+      specification_expr = true;\n       if (sym->ts.type == BT_CHARACTER\n \t  && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n \tt = FAILURE;\n \n       if (sym->as)\n \tfor (n = 0; n < sym->as->rank; n++)\n \t  {\n-\t     specification_expr = 1;\n \t     if (gfc_resolve_expr (sym->as->lower[n]) == FAILURE)\n \t       t = FAILURE;\n-\t     specification_expr = 1;\n \t     if (gfc_resolve_expr (sym->as->upper[n]) == FAILURE)\n \t       t = FAILURE;\n \t  }\n-      specification_expr = 0;\n+      specification_expr = saved_specification_expr;\n \n       if (t == SUCCESS)\n \t/* Update the symbol's entry level.  */\n@@ -10175,28 +10184,35 @@ static gfc_try\n resolve_charlen (gfc_charlen *cl)\n {\n   int i, k;\n+  bool saved_specification_expr;\n \n   if (cl->resolved)\n     return SUCCESS;\n \n   cl->resolved = 1;\n-\n+  saved_specification_expr = specification_expr;\n+  specification_expr = true;\n \n   if (cl->length_from_typespec)\n     {\n       if (gfc_resolve_expr (cl->length) == FAILURE)\n-\treturn FAILURE;\n+\t{\n+\t  specification_expr = saved_specification_expr;\n+\t  return FAILURE;\n+\t}\n \n       if (gfc_simplify_expr (cl->length, 0) == FAILURE)\n-\treturn FAILURE;\n+\t{\n+\t  specification_expr = saved_specification_expr;\n+\t  return FAILURE;\n+\t}\n     }\n   else\n     {\n-      specification_expr = 1;\n \n       if (resolve_index_expr (cl->length) == FAILURE)\n \t{\n-\t  specification_expr = 0;\n+\t  specification_expr = saved_specification_expr;\n \t  return FAILURE;\n \t}\n     }\n@@ -10220,9 +10236,11 @@ resolve_charlen (gfc_charlen *cl)\n       && mpz_cmp (cl->length->value.integer, gfc_integer_kinds[k].huge) > 0)\n     {\n       gfc_error (\"String length at %L is too large\", &cl->length->where);\n+      specification_expr = saved_specification_expr;\n       return FAILURE;\n     }\n \n+  specification_expr = saved_specification_expr;\n   return SUCCESS;\n }\n \n@@ -10682,6 +10700,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   int no_init_flag, automatic_flag;\n   gfc_expr *e;\n   const char *auto_save_msg;\n+  bool saved_specification_expr;\n \n   auto_save_msg = \"Automatic object '%s' at %L cannot have the \"\n \t\t  \"SAVE attribute\";\n@@ -10692,7 +10711,8 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   /* Set this flag to check that variables are parameters of all entries.\n      This check is effected by the call to gfc_resolve_expr through\n      is_non_constant_shape_array.  */\n-  specification_expr = 1;\n+  saved_specification_expr = specification_expr;\n+  specification_expr = true;\n \n   if (sym->ns->proc_name\n       && (sym->ns->proc_name->attr.flavor == FL_MODULE\n@@ -10706,7 +10726,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t constant.  */\n       gfc_error (\"The module or main program array '%s' at %L must \"\n \t\t \"have constant shape\", sym->name, &sym->declared_at);\n-      specification_expr = 0;\n+      specification_expr = saved_specification_expr;\n       return FAILURE;\n     }\n \n@@ -10716,6 +10736,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n       gfc_error (\"Entity '%s' at %L has a deferred type parameter and \"\n \t\t \"requires either the pointer or allocatable attribute\",\n \t\t     sym->name, &sym->declared_at);\n+      specification_expr = saved_specification_expr;\n       return FAILURE;\n     }\n \n@@ -10729,12 +10750,14 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t{\n \t  gfc_error (\"Entity with assumed character length at %L must be a \"\n \t\t     \"dummy argument or a PARAMETER\", &sym->declared_at);\n+\t  specification_expr = saved_specification_expr;\n \t  return FAILURE;\n \t}\n \n       if (e && sym->attr.save == SAVE_EXPLICIT && !gfc_is_constant_expr (e))\n \t{\n \t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n+\t  specification_expr = saved_specification_expr;\n \t  return FAILURE;\n \t}\n \n@@ -10748,12 +10771,14 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t    {\n \t      gfc_error (\"'%s' at %L must have constant character length \"\n \t\t\t\"in this context\", sym->name, &sym->declared_at);\n+\t      specification_expr = saved_specification_expr;\n \t      return FAILURE;\n \t    }\n \t  if (sym->attr.in_common)\n \t    {\n \t      gfc_error (\"COMMON variable '%s' at %L must have constant \"\n \t\t\t \"character length\", sym->name, &sym->declared_at);\n+\t      specification_expr = saved_specification_expr;\n \t      return FAILURE;\n \t    }\n \t}\n@@ -10784,6 +10809,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n       if (automatic_flag && sym->attr.save == SAVE_EXPLICIT)\n \t{\n \t  gfc_error (auto_save_msg, sym->name, &sym->declared_at);\n+\t  specification_expr = saved_specification_expr;\n \t  return FAILURE;\n \t}\n     }\n@@ -10817,13 +10843,19 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t\t   sym->name, &sym->declared_at);\n       else\n \tgoto no_init_error;\n+      specification_expr = saved_specification_expr;\n       return FAILURE;\n     }\n \n no_init_error:\n   if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n-    return resolve_fl_variable_derived (sym, no_init_flag);\n+    {\n+      gfc_try res = resolve_fl_variable_derived (sym, no_init_flag);\n+      specification_expr = saved_specification_expr;\n+      return res;\n+    }\n \n+  specification_expr = saved_specification_expr;\n   return SUCCESS;\n }\n \n@@ -12569,6 +12601,7 @@ resolve_symbol (gfc_symbol *sym)\n   gfc_component *c;\n   symbol_attribute class_attr;\n   gfc_array_spec *as;\n+  bool saved_specification_expr;\n \n   if (sym->attr.artificial)\n     return;\n@@ -12689,7 +12722,12 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n   else if (mp_flag && sym->attr.flavor == FL_PROCEDURE && sym->attr.function)\n-    gfc_resolve_array_spec (sym->result->as, false);\n+    {\n+      bool saved_specification_expr = specification_expr;\n+      specification_expr = true;\n+      gfc_resolve_array_spec (sym->result->as, false);\n+      specification_expr = saved_specification_expr;\n+    }\n \n   if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n     {\n@@ -13105,7 +13143,10 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->attr.function && sym->as)\n     formal_arg_flag = 1;\n \n+  saved_specification_expr = specification_expr;\n+  specification_expr = true;\n   gfc_resolve_array_spec (sym->as, check_constant);\n+  specification_expr = saved_specification_expr;\n \n   formal_arg_flag = 0;\n "}, {"sha": "b3e39701e428dd850e0a57e9e8673aec509e2f66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd0611850d548ec973dfff208a064eb561621481", "patch": "@@ -1,3 +1,8 @@\n+2012-10-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54884\n+\t* gfortran.dg/public_private_module_7.f90: New.\n+\n 2012-10-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/29633\n@@ -10,21 +15,21 @@\n \n 2012-10-18  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n-        * gcc.target/arm/neon/vfmaQf32.c: New testcase.\n-        * gcc.target/arm/neon/vfmaf32.c: Likewise.\n-        * gcc.target/arm/neon/vfmsQf32.c: Likewise.\n-        * gcc.target/arm/neon/vfmsf32.c: Likewise.\n+\t* gcc.target/arm/neon/vfmaQf32.c: New testcase.\n+\t* gcc.target/arm/neon/vfmaf32.c: Likewise.\n+\t* gcc.target/arm/neon/vfmsQf32.c: Likewise.\n+\t* gcc.target/arm/neon/vfmsf32.c: Likewise.\n \n 2012-10-18  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n-        * gcc.target/arm/ftest-armv8a-arm.c: New testcase.\n-        * gcc.target/arm/ftest-armv8a-thumb.c: Likewise.\n-        * gcc.target/arm/ftest-support-arm.h (feature_matrix): Add\n-        ARMv8-A row.\n-        * gcc.target/arm/ftest-support-thumb.h (feature_matrix):\n-        Likewise.\n-        * gcc.target/arm/ftest-support.h (architecture): Add ARMv8-A.\n-        * lib/target-supports.exp: Add ARMv8-A architecture expectation.\n+\t* gcc.target/arm/ftest-armv8a-arm.c: New testcase.\n+\t* gcc.target/arm/ftest-armv8a-thumb.c: Likewise.\n+\t* gcc.target/arm/ftest-support-arm.h (feature_matrix): Add\n+\tARMv8-A row.\n+\t* gcc.target/arm/ftest-support-thumb.h (feature_matrix):\n+\tLikewise.\n+\t* gcc.target/arm/ftest-support.h (architecture): Add ARMv8-A.\n+\t* lib/target-supports.exp: Add ARMv8-A architecture expectation.\n \n 2012-10-16  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "d03b7047a126aed151eeae0a5abe7a658df967ba", "filename": "gcc/testsuite/gfortran.dg/public_private_module_7.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0611850d548ec973dfff208a064eb561621481/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_7.f90?ref=fd0611850d548ec973dfff208a064eb561621481", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! { dg-options \"-O2\" }\n+!\n+! PR fortran/54884\n+!\n+! Check that get_key_len is not optimized away as it\n+! is used in a publicly visible specification expression.\n+!\n+module m_common_attrs\n+  private\n+  !...\n+  public :: get_key\n+contains\n+  pure function get_key_len() result(n)\n+    n = 5\n+  end function get_key_len\n+  pure function other() result(n)\n+    n = 5\n+  end function other\n+  ! ...\n+  function get_key() result(key)\n+    ! ...\n+    character(len=get_key_len()) :: key\n+    key = ''\n+  end function get_key\n+end module m_common_attrs\n+\n+! { dg-final { scan-assembler-not \"__m_common_attrs_MOD_other\" } }\n+! { dg-final { scan-assembler \"__m_common_attrs_MOD_get_key_len\" } }"}]}