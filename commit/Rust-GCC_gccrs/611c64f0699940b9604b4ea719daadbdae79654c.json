{"sha": "611c64f0699940b9604b4ea719daadbdae79654c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExYzY0ZjA2OTk5NDBiOTYwNGI0ZWE3MTlkYWFkYmRhZTc5NjU0Yw==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-11-05T18:14:52Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-11-05T18:14:52Z"}, "message": "re PR fortran/45451 ([OOP] Inconsistent status of ALLOCATABLE components inside CLASS variables.)\n\n2010-11-05  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45451\n\tPR fortran/46174\n\t* class.c (gfc_find_derived_vtab): Improved search for existing vtab.\n\tAdd component '$copy' to vtype symbol for polymorphic deep copying.\n\t* expr.c (gfc_check_pointer_assign): Make sure the vtab is generated\n\tduring resolution stage.\n\t* resolve.c (resolve_codes): Don't resolve code if namespace is already\n\tresolved.\n\t* trans-stmt.c (gfc_trans_allocate): Call '$copy' procedure for\n\tpolymorphic ALLOCATE statements with SOURCE.\n\n2010-11-05  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45451\n\tPR fortran/46174\n\t* gfortran.dg/class_19.f03: Modified.\n\t* gfortran.dg/class_allocate_6.f03: New.\n\nFrom-SVN: r166368", "tree": {"sha": "db3c9509cd58e015bc566f15340f5dd30d33b1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3c9509cd58e015bc566f15340f5dd30d33b1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/611c64f0699940b9604b4ea719daadbdae79654c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611c64f0699940b9604b4ea719daadbdae79654c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611c64f0699940b9604b4ea719daadbdae79654c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611c64f0699940b9604b4ea719daadbdae79654c/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458ebeba0f4edf877b36a9b61d56ee4ff8e97af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458ebeba0f4edf877b36a9b61d56ee4ff8e97af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/458ebeba0f4edf877b36a9b61d56ee4ff8e97af3"}], "stats": {"total": 206, "additions": 179, "deletions": 27}, "files": [{"sha": "cace0a310f1a5dcfb0767c4c1b8edb5a564a5900", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -1,3 +1,16 @@\n+2010-11-05  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45451\n+\tPR fortran/46174\n+\t* class.c (gfc_find_derived_vtab): Improved search for existing vtab.\n+\tAdd component '$copy' to vtype symbol for polymorphic deep copying.\n+\t* expr.c (gfc_check_pointer_assign): Make sure the vtab is generated\n+\tduring resolution stage.\n+\t* resolve.c (resolve_codes): Don't resolve code if namespace is already\n+\tresolved.\n+\t* trans-stmt.c (gfc_trans_allocate): Call '$copy' procedure for\n+\tpolymorphic ALLOCATE statements with SOURCE.\n+\n 2010-11-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \t    Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "43907dc43a7da4d59a185251f38a87a24e295705", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 80, "deletions": 13, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -39,9 +39,10 @@ along with GCC; see the file COPYING3.  If not see\n     * $hash: A hash value serving as a unique identifier for this type.\n     * $size: The size in bytes of the derived type.\n     * $extends: A pointer to the vtable entry of the parent derived type.\n-   In addition to these fields, each vtable entry contains additional procedure\n-   pointer components, which contain pointers to the procedures which are bound\n-   to the type's \"methods\" (type-bound procedures).  */\n+    * $def_init: A pointer to a default initialized variable of this type.\n+    * $copy: A procedure pointer to a copying procedure.\n+   After these follow procedure pointer components for the specific\n+   type-bound procedures.  */\n \n \n #include \"config.h\"\n@@ -307,19 +308,14 @@ add_procs_to_declared_vtab (gfc_symbol *derived, gfc_symbol *vtype)\n }\n \n \n-/* Find the symbol for a derived type's vtab.\n-   A vtab has the following fields:\n-    * $hash\ta hash value used to identify the derived type\n-    * $size\tthe size in bytes of the derived type\n-    * $extends\ta pointer to the vtable of the parent derived type\n-   After these follow procedure pointer components for the\n-   specific type-bound procedures.  */\n+/* Find (or generate) the symbol for a derived type's vtab.  */\n \n gfc_symbol *\n gfc_find_derived_vtab (gfc_symbol *derived)\n {\n   gfc_namespace *ns;\n   gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n+  gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n   char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n   \n   /* Find the top-level namespace (MODULE or PROGRAM).  */\n@@ -334,7 +330,13 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   if (ns)\n     {\n       sprintf (name, \"vtab$%s\", derived->name);\n-      gfc_find_symbol (name, ns, 0, &vtab);\n+\n+      /* Look for the vtab symbol in various namespaces.  */\n+      gfc_find_symbol (name, gfc_current_ns, 0, &vtab);\n+      if (vtab == NULL)\n+\tgfc_find_symbol (name, ns, 0, &vtab);\n+      if (vtab == NULL)\n+\tgfc_find_symbol (name, derived->ns, 0, &vtab);\n \n       if (vtab == NULL)\n \t{\n@@ -361,6 +363,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n \t\tgoto cleanup;\n \t      vtype->attr.access = ACCESS_PUBLIC;\n+\t      vtype->attr.vtype = 1;\n \t      gfc_set_sym_referenced (vtype);\n \n \t      /* Add component '$hash'.  */\n@@ -408,6 +411,14 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  c->initializer = gfc_get_null_expr (NULL);\n \t\t}\n \n+\t      if (derived->components == NULL && !derived->attr.zero_comp)\n+\t\t{\n+\t\t  /* At this point an error must have occurred.\n+\t\t     Prevent further errors on the vtype components.  */\n+\t\t  found_sym = vtab;\n+\t\t  goto have_vtype;\n+\t\t}\n+\n \t      /* Add component $def_init.  */\n \t      if (gfc_add_component (vtype, \"$def_init\", &c) == FAILURE)\n \t\tgoto cleanup;\n@@ -416,7 +427,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      c->ts.type = BT_DERIVED;\n \t      c->ts.u.derived = derived;\n \t      if (derived->attr.abstract)\n-\t\tc->initializer = NULL;\n+\t\tc->initializer = gfc_get_null_expr (NULL);\n \t      else\n \t\t{\n \t\t  /* Construct default initialization variable.  */\n@@ -434,11 +445,61 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  c->initializer = gfc_lval_expr_from_sym (def_init);\n \t\t}\n \n+\t      /* Add component $copy.  */\n+\t      if (gfc_add_component (vtype, \"$copy\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->attr.proc_pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->tb = XCNEW (gfc_typebound_proc);\n+\t      c->tb->ppc = 1;\n+\t      if (derived->attr.abstract)\n+\t\tc->initializer = gfc_get_null_expr (NULL);\n+\t      else\n+\t\t{\n+\t\t  /* Set up namespace.  */\n+\t\t  gfc_namespace *sub_ns = gfc_get_namespace (ns, 0);\n+\t\t  sub_ns->sibling = ns->contained;\n+\t\t  ns->contained = sub_ns;\n+\t\t  sub_ns->resolved = 1;\n+\t\t  /* Set up procedure symbol.  */\n+\t\t  sprintf (name, \"copy$%s\", derived->name);\n+\t\t  gfc_get_symbol (name, sub_ns, &copy);\n+\t\t  sub_ns->proc_name = copy;\n+\t\t  copy->attr.flavor = FL_PROCEDURE;\n+\t\t  copy->attr.if_source = IFSRC_DECL;\n+\t\t  gfc_set_sym_referenced (copy);\n+\t\t  /* Set up formal arguments.  */\n+\t\t  gfc_get_symbol (\"src\", sub_ns, &src);\n+\t\t  src->ts.type = BT_DERIVED;\n+\t\t  src->ts.u.derived = derived;\n+\t\t  src->attr.flavor = FL_VARIABLE;\n+\t\t  src->attr.dummy = 1;\n+\t\t  gfc_set_sym_referenced (src);\n+\t\t  copy->formal = gfc_get_formal_arglist ();\n+\t\t  copy->formal->sym = src;\n+\t\t  gfc_get_symbol (\"dst\", sub_ns, &dst);\n+\t\t  dst->ts.type = BT_DERIVED;\n+\t\t  dst->ts.u.derived = derived;\n+\t\t  dst->attr.flavor = FL_VARIABLE;\n+\t\t  dst->attr.dummy = 1;\n+\t\t  gfc_set_sym_referenced (dst);\n+\t\t  copy->formal->next = gfc_get_formal_arglist ();\n+\t\t  copy->formal->next->sym = dst;\n+\t\t  /* Set up code.  */\n+\t\t  sub_ns->code = gfc_get_code ();\n+\t\t  sub_ns->code->op = EXEC_ASSIGN;\n+\t\t  sub_ns->code->expr1 = gfc_lval_expr_from_sym (dst);\n+\t\t  sub_ns->code->expr2 = gfc_lval_expr_from_sym (src);\n+\t\t  /* Set initializer.  */\n+\t\t  c->initializer = gfc_lval_expr_from_sym (copy);\n+\t\t  c->ts.interface = copy;\n+\t\t}\n+\n \t      /* Add procedure pointers for type-bound procedures.  */\n \t      add_procs_to_declared_vtab (derived, vtype);\n-\t      vtype->attr.vtype = 1;\n \t    }\n \n+have_vtype:\n \t  vtab->ts.u.derived = vtype;\n \t  vtab->value = gfc_default_initializer (&vtab->ts);\n \t}\n@@ -456,6 +517,12 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \tgfc_commit_symbol (vtype);\n       if (def_init)\n \tgfc_commit_symbol (def_init);\n+      if (copy)\n+\tgfc_commit_symbol (copy);\n+      if (src)\n+\tgfc_commit_symbol (src);\n+      if (dst)\n+\tgfc_commit_symbol (dst);\n     }\n   else\n     gfc_undo_symbols ();"}, {"sha": "2b98b35ee211a42d9d8b3f9fbb9569651bbdea77", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -3457,6 +3457,10 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n+  if (lvalue->ts.type == BT_CLASS && rvalue->ts.type == BT_DERIVED)\n+    /* Make sure the vtab is present.  */\n+    gfc_find_derived_vtab (rvalue->ts.u.derived);\n+\n   /* Check rank remapping.  */\n   if (rank_remap)\n     {"}, {"sha": "7429ff2a246f1bfb45269ec1c688e033fcd01717", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -13331,6 +13331,9 @@ resolve_codes (gfc_namespace *ns)\n   gfc_namespace *n;\n   bitmap_obstack old_obstack;\n \n+  if (ns->resolved == 1)\n+    return;\n+\n   for (n = ns->contained; n; n = n->sibling)\n     resolve_codes (n);\n "}, {"sha": "d075ac8b82bc24ebc1c69de959fc7be06fe46873", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -4487,21 +4487,33 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Initialization via SOURCE block\n \t     (or static default initializer).  */\n \t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n-\t  if (al->expr->ts.type == BT_CLASS && rhs->expr_type == EXPR_VARIABLE\n-\t      && rhs->ts.type != BT_CLASS)\n-\t    tmp = gfc_trans_assignment (expr, rhs, false, false);\n-\t  else if (al->expr->ts.type == BT_CLASS)\n+\t  if (al->expr->ts.type == BT_CLASS)\n \t    {\n-\t      /* TODO: One needs to do a deep-copy for BT_CLASS; cf. PR 46174.  */\n-\t      gfc_se dst,src;\n+\t      gfc_se call;\n+\t      gfc_actual_arglist *actual;\n+\t      gfc_expr *ppc;\n+\t      gfc_init_se (&call, NULL);\n+\t      /* Do a polymorphic deep copy.  */\n+\t      actual = gfc_get_actual_arglist ();\n+\t      actual->expr = gfc_copy_expr (rhs);\n \t      if (rhs->ts.type == BT_CLASS)\n-\t\tgfc_add_component_ref (rhs, \"$data\");\n-\t      gfc_init_se (&dst, NULL);\n-\t      gfc_init_se (&src, NULL);\n-\t      gfc_conv_expr (&dst, expr);\n-\t      gfc_conv_expr (&src, rhs);\n-\t      gfc_add_block_to_block (&block, &src.pre);\n-\t      tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz);\n+\t\tgfc_add_component_ref (actual->expr, \"$data\");\n+\t      actual->next = gfc_get_actual_arglist ();\n+\t      actual->next->expr = gfc_copy_expr (al->expr);\n+\t      gfc_add_component_ref (actual->next->expr, \"$data\");\n+\t      if (rhs->ts.type == BT_CLASS)\n+\t\t{\n+\t\t  ppc = gfc_copy_expr (rhs);\n+\t\t  gfc_add_component_ref (ppc, \"$vptr\");\n+\t\t}\n+\t      else\n+\t\tppc = gfc_lval_expr_from_sym (gfc_find_derived_vtab (rhs->ts.u.derived));\n+\t      gfc_add_component_ref (ppc, \"$copy\");\n+\t      gfc_conv_procedure_call (&call, ppc->symtree->n.sym, actual,\n+\t\t\t\t\tppc, NULL);\n+\t      gfc_add_expr_to_block (&call.pre, call.expr);\n+\t      gfc_add_block_to_block (&call.pre, &call.post);\n+\t      tmp = gfc_finish_block (&call.pre);\n \t    }\n \t  else\n \t    tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),"}, {"sha": "359bc49b3c29f7cde65542d476e1e7e1f33b4b0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -1,3 +1,10 @@\n+2010-11-05  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45451\n+\tPR fortran/46174\n+\t* gfortran.dg/class_19.f03: Modified.\n+\t* gfortran.dg/class_allocate_6.f03: New.\n+\n 2010-11-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/avx-vzeroupper-19.c: New."}, {"sha": "27ee7b4e2cb44829665a1f354e13de8e9310d113", "filename": "gcc/testsuite/gfortran.dg/class_19.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_19.f03?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -39,7 +39,7 @@ program main\n \n end program main\n \n-! { dg-final { scan-tree-dump-times \"__builtin_free\" 8 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 11 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n \n ! { dg-final { cleanup-modules \"foo_mod\" } }"}, {"sha": "8b96d1db24607c8b257a48cabce95e193e562990", "filename": "gcc/testsuite/gfortran.dg/class_allocate_6.f03", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611c64f0699940b9604b4ea719daadbdae79654c/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_6.f03?ref=611c64f0699940b9604b4ea719daadbdae79654c", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+!\n+! PR 46174: [OOP] ALLOCATE with SOURCE: Deep copy missing\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+implicit none\n+type t\n+end type t\n+\n+type, extends(t) :: t2\n+  integer, allocatable :: a(:)\n+end type t2\n+\n+class(t), allocatable :: x, y\n+integer :: i\n+\n+allocate(t2 :: x)\n+select type(x)\n+ type is (t2)\n+   allocate(x%a(10))\n+   x%a = [ (i, i = 1,10) ]\n+   print '(*(i3))', x%a\n+ class default\n+   call abort()\n+end select\n+\n+allocate(y, source=x)\n+\n+select type(x)\n+ type is (t2)\n+   x%a = [ (i, i = 11,20) ]\n+   print '(*(i3))', x%a\n+ class default\n+   call abort()\n+end select\n+\n+select type(y)\n+ type is (t2)\n+   print '(*(i3))', y%a\n+   if (any (y%a /= [ (i, i = 1,10) ])) call abort()\n+ class default\n+   call abort()\n+end select\n+\n+end"}]}