{"sha": "fe2ef088e065f9e15311b221db3fcbf864dfb250", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyZWYwODhlMDY1ZjllMTUzMTFiMjIxZGIzZmNiZjg2NGRmYjI1MA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2010-06-28T15:14:31Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-06-28T15:14:31Z"}, "message": "re PR middle-end/44592 (wrong code at -O3)\n\n\tPR middle-end/44592\n\t* gimple-fold.c (gimplify_and_update_call_from_tree): Maintain\n\tproper VDEF chain for intermediate stores in the sequence.\n\ntestsuite/\n\tPR middle-end/44592\n\t* gfortran.dg/pr44592.f90: New test.\n\nFrom-SVN: r161496", "tree": {"sha": "9de962d5f754d58a1f456143f4c86710db0e4087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9de962d5f754d58a1f456143f4c86710db0e4087"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe2ef088e065f9e15311b221db3fcbf864dfb250", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2ef088e065f9e15311b221db3fcbf864dfb250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe2ef088e065f9e15311b221db3fcbf864dfb250", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe2ef088e065f9e15311b221db3fcbf864dfb250/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0cc75e07893d05abcfe0287dc2c1071680e0c6f"}], "stats": {"total": 85, "additions": 81, "deletions": 4}, "files": [{"sha": "fd8b6d951ab8b237614c31624932330e72a9f0d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe2ef088e065f9e15311b221db3fcbf864dfb250", "patch": "@@ -1,3 +1,9 @@\n+2010-06-28  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/44592\n+\t* gimple-fold.c (gimplify_and_update_call_from_tree): Maintain\n+\tproper VDEF chain for intermediate stores in the sequence.\n+\n 2010-06-28  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/44357"}, {"sha": "8fb604da437aa6131513a907d10a9b95d2b7f2ed", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=fe2ef088e065f9e15311b221db3fcbf864dfb250", "patch": "@@ -1053,7 +1053,9 @@ fold_gimple_cond (gimple stmt)\n    is replaced.  If the call is expected to produces a result, then it\n    is replaced by an assignment of the new RHS to the result variable.\n    If the result is to be ignored, then the call is replaced by a\n-   GIMPLE_NOP.  */\n+   GIMPLE_NOP.  A proper VDEF chain is retained by making the first\n+   VUSE and the last VDEF of the whole sequence be the same as the replaced\n+   statement and using new SSA names for stores in between.  */\n \n void\n gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n@@ -1065,12 +1067,15 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n   gimple_seq stmts = gimple_seq_alloc();\n   struct gimplify_ctx gctx;\n   gimple last = NULL;\n+  gimple laststore = NULL;\n+  tree reaching_vuse;\n \n   stmt = gsi_stmt (*si_p);\n \n   gcc_assert (is_gimple_call (stmt));\n \n   lhs = gimple_call_lhs (stmt);\n+  reaching_vuse = gimple_vuse (stmt);\n \n   push_gimplify_context (&gctx);\n \n@@ -1095,13 +1100,47 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n       new_stmt = gsi_stmt (i);\n       find_new_referenced_vars (new_stmt);\n       mark_symbols_for_renaming (new_stmt);\n+      /* If the new statement has a VUSE, update it with exact SSA name we\n+         know will reach this one.  */\n+      if (gimple_vuse (new_stmt))\n+\t{\n+\t  /* If we've also seen a previous store create a new VDEF for\n+\t     the latter one, and make that the new reaching VUSE.  */\n+\t  if (laststore)\n+\t    {\n+\t      reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);\n+\t      gimple_set_vdef (laststore, reaching_vuse);\n+\t      update_stmt (laststore);\n+\t      laststore = NULL;\n+\t    }\n+\t  gimple_set_vuse (new_stmt, reaching_vuse);\n+\t  gimple_set_modified (new_stmt, true);\n+\t}\n+      if (gimple_assign_single_p (new_stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (new_stmt)))\n+\t{\n+\t  laststore = new_stmt;\n+\t}\n       last = new_stmt;\n     }\n \n   if (lhs == NULL_TREE)\n     {\n-      unlink_stmt_vdef (stmt);\n-      release_defs (stmt);\n+      /* If we replace a call without LHS that has a VDEF and our new\n+         sequence ends with a store we must make that store have the same\n+\t vdef in order not to break the sequencing.  This can happen\n+\t for instance when folding memcpy calls into assignments.  */\n+      if (gimple_vdef (stmt) && laststore)\n+\t{\n+\t  gimple_set_vdef (laststore, gimple_vdef (stmt));\n+\t  move_ssa_defining_stmt_for_defs (laststore, stmt);\n+\t  update_stmt (laststore);\n+\t}\n+      else\n+\t{\n+\t  unlink_stmt_vdef (stmt);\n+\t  release_defs (stmt);\n+\t}\n       new_stmt = last;\n     }\n   else\n@@ -1111,8 +1150,15 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \t  gsi_insert_before (si_p, last, GSI_NEW_STMT);\n \t  gsi_next (si_p);\n \t}\n+      if (laststore)\n+\t{\n+\t  reaching_vuse = make_ssa_name (gimple_vop (cfun), laststore);\n+\t  gimple_set_vdef (laststore, reaching_vuse);\n+\t  update_stmt (laststore);\n+\t  laststore = NULL;\n+\t}\n       new_stmt = gimple_build_assign (lhs, tmp);\n-      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+      gimple_set_vuse (new_stmt, reaching_vuse);\n       gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n       move_ssa_defining_stmt_for_defs (new_stmt, stmt);\n     }"}, {"sha": "7bdfc3480023f018fda00ee34a670fdbe1e756b5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe2ef088e065f9e15311b221db3fcbf864dfb250", "patch": "@@ -1,3 +1,8 @@\n+2010-06-28  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/44592\n+\t* gfortran.dg/pr44592.f90: New test.\n+\n 2010-06-28  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/44357"}, {"sha": "8b043ba33ed3cbc7575a942ea0ba6451673bd5ce", "filename": "gcc/testsuite/gfortran.dg/pr44592.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44592.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe2ef088e065f9e15311b221db3fcbf864dfb250/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44592.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr44592.f90?ref=fe2ef088e065f9e15311b221db3fcbf864dfb250", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! { dg-options \"-O3\" }\n+! From forall_12.f90\n+! Fails with loop reversal at -O3\n+!\n+  character(len=1) :: b(4) = (/\"1\",\"2\",\"3\",\"4\"/), c(4)\n+  c = b\n+  i = 1\n+  ! This statement must be here for the abort below\n+  b(1:3)(i:i) = b(2:4)(i:i)\n+\n+  b = c\n+  b(4:2:-1)(i:i) = b(3:1:-1)(i:i)\n+\n+  ! This fails.  If the condition is printed, the result is F F F F\n+  if (any (b .ne. (/\"1\",\"1\",\"2\",\"3\"/))) i = 2\n+  print *, b\n+  print *, b .ne. (/\"1\",\"1\",\"2\",\"3\"/)\n+  if (i == 2) call abort\n+end"}]}