{"sha": "e01a4a17e5574417cf8fd32c2698ab1870204c73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxYTRhMTdlNTU3NDQxN2NmOGZkMzJjMjY5OGFiMTg3MDIwNGM3Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-04-03T01:23:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-04-03T01:23:24Z"}, "message": "class.c (maybe_fixup_vptrs, [...]): Lose.\n\n\t* class.c (maybe_fixup_vptrs, build_class_init_list): Lose.\n\t(finish_struct_1): Don't call build_class_init_list.\n\nFrom-SVN: r26147", "tree": {"sha": "8a9f222f96109e6e1b15e466b6fcd5267986a599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a9f222f96109e6e1b15e466b6fcd5267986a599"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01a4a17e5574417cf8fd32c2698ab1870204c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01a4a17e5574417cf8fd32c2698ab1870204c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01a4a17e5574417cf8fd32c2698ab1870204c73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01a4a17e5574417cf8fd32c2698ab1870204c73/comments", "author": null, "committer": null, "parents": [{"sha": "54d4c16730b76ba6f2a109083ace3d938dc80d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d4c16730b76ba6f2a109083ace3d938dc80d8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54d4c16730b76ba6f2a109083ace3d938dc80d8e"}], "stats": {"total": 153, "additions": 5, "deletions": 148}, "files": [{"sha": "813cc218e614b968e052793a40b7b4cf2049fb33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01a4a17e5574417cf8fd32c2698ab1870204c73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01a4a17e5574417cf8fd32c2698ab1870204c73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e01a4a17e5574417cf8fd32c2698ab1870204c73", "patch": "@@ -1,3 +1,8 @@\n+1999-04-03  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (maybe_fixup_vptrs, build_class_init_list): Lose.\n+\t(finish_struct_1): Don't call build_class_init_list.\n+\n 1999-04-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tinfo.h (__class_type_info): Fix illegal declaration."}, {"sha": "6997d013f853231ba5cf1ba112c6bda6f047e882", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01a4a17e5574417cf8fd32c2698ab1870204c73/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01a4a17e5574417cf8fd32c2698ab1870204c73/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e01a4a17e5574417cf8fd32c2698ab1870204c73", "patch": "@@ -1540,150 +1540,6 @@ handle_using_decl (using_decl, t, method_vec, fields)\n   else\n     alter_access (t, binfo, fdecl, access);\n }\n-\n-/* If FOR_TYPE needs to reinitialize virtual function table pointers\n-   for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.\n-   Returns BASE_INIT_LIST appropriately modified.  */\n-\n-static tree\n-maybe_fixup_vptrs (for_type, binfo, base_init_list)\n-     tree for_type, binfo, base_init_list;\n-{\n-  /* Now reinitialize any slots that don't fall under our virtual\n-     function table pointer.  */\n-  tree vfields = CLASSTYPE_VFIELDS (BINFO_TYPE (binfo));\n-  while (vfields)\n-    {\n-      tree basetype = VF_NORMAL_VALUE (vfields)\n-\t? TYPE_MAIN_VARIANT (VF_NORMAL_VALUE (vfields))\n-\t  : VF_BASETYPE_VALUE (vfields);\n-\n-      tree base_binfo = get_binfo (basetype, for_type, 0);\n-      /* Punt until this is implemented.  */\n-      if (1 /* BINFO_MODIFIED (base_binfo) */)\n-\t{\n-\t  tree base_offset = get_vfield_offset (base_binfo);\n-\t  if (! tree_int_cst_equal (base_offset, get_vfield_offset (TYPE_BINFO (for_type)))\n-\t      && ! tree_int_cst_equal (base_offset, get_vfield_offset (binfo)))\n-\t    base_init_list = tree_cons (error_mark_node, base_binfo,\n-\t\t\t\t\tbase_init_list);\n-\t}\n-      vfields = TREE_CHAIN (vfields);\n-    }\n-  return base_init_list;\n-}\n-\n-/* If TYPE does not have a constructor, then the compiler must\n-   manually deal with all of the initialization this type requires.\n-\n-   If a base initializer exists only to fill in the virtual function\n-   table pointer, then we mark that fact with the TREE_VIRTUAL bit.\n-   This way, we avoid multiple initializations of the same field by\n-   each virtual function table up the class hierarchy.\n-\n-   Virtual base class pointers are not initialized here.  They are\n-   initialized only at the \"top level\" of object creation.  If we\n-   initialized them here, we would have to skip a lot of work.  */\n-\n-static void\n-build_class_init_list (type)\n-     tree type;\n-{\n-  tree base_init_list = NULL_TREE;\n-  tree member_init_list = NULL_TREE;\n-\n-  /* Since we build member_init_list and base_init_list using\n-     tree_cons, backwards fields the all through work.  */\n-  tree x;\n-  tree binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n-  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  for (x = TYPE_FIELDS (type); x; x = TREE_CHAIN (x))\n-    {\n-      if (TREE_CODE (x) != FIELD_DECL)\n-\tcontinue;\n-\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (x))\n-\t  || DECL_INITIAL (x) != NULL_TREE)\n-\tmember_init_list = tree_cons (x, type, member_init_list);\n-    }\n-  member_init_list = nreverse (member_init_list);\n-\n-  /* We will end up doing this last.  Need special marker\n-     to avoid infinite regress.  */\n-  if (TYPE_VIRTUAL_P (type))\n-    {\n-      base_init_list = build_tree_list (error_mark_node, TYPE_BINFO (type));\n-      if (CLASSTYPE_NEEDS_VIRTUAL_REINIT (type) == 0)\n-\tTREE_VALUE (base_init_list) = NULL_TREE;\n-      TREE_ADDRESSABLE (base_init_list) = 1;\n-    }\n-\n-  /* Each base class which needs to have initialization\n-     of some kind gets to make such requests known here.  */\n-  for (i = n_baseclasses-1; i >= 0; i--)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree blist;\n-\n-      /* Don't initialize virtual baseclasses this way.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-\n-      if (TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  /* ...and the last shall come first...  */\n-\t  base_init_list = maybe_fixup_vptrs (type, base_binfo, base_init_list);\n-\t  base_init_list = tree_cons (NULL_TREE, base_binfo, base_init_list);\n-\t  continue;\n-\t}\n-\n-      /* ...ditto...  */\n-      base_init_list = maybe_fixup_vptrs (type, base_binfo, base_init_list);\n-\n-      /* This is normally true for single inheritance.\n-\t The win is we can shrink the chain of initializations\n-\t to be done by only converting to the actual type\n-\t we are interested in.  */\n-      if (TREE_VALUE (blist)\n-\t  && TREE_CODE (TREE_VALUE (blist)) == TREE_VEC\n-\t  && tree_int_cst_equal (BINFO_OFFSET (base_binfo),\n-\t\t\t\t BINFO_OFFSET (TREE_VALUE (blist))))\n-\t{\n-\t  if (base_init_list)\n-\t    {\n-\t      /* Does it do more than just fill in a\n-\t\t virtual function table pointer?  */\n-\t      if (! TREE_ADDRESSABLE (blist))\n-\t\tbase_init_list = build_tree_list (blist, base_init_list);\n-\t      /* Can we get by just with the virtual function table\n-\t\t pointer that it fills in?  */\n-\t      else if (TREE_ADDRESSABLE (base_init_list)\n-\t\t       && TREE_VALUE (base_init_list) == 0)\n-\t\tbase_init_list = blist;\n-\t      /* Maybe, but it is not obvious as the previous case.  */\n-\t      else if (! CLASSTYPE_NEEDS_VIRTUAL_REINIT (type))\n-\t\t{\n-\t\t  tree last = tree_last (base_init_list);\n-\t\t  while (TREE_VALUE (last)\n-\t\t\t && TREE_CODE (TREE_VALUE (last)) == TREE_LIST)\n-\t\t    last = tree_last (TREE_VALUE (last));\n-\t\t  if (TREE_VALUE (last) == 0)\n-\t\t    base_init_list = build_tree_list (blist, base_init_list);\n-\t\t}\n-\t    }\n-\t  else\n-\t    base_init_list = blist;\n-\t}\n-      else\n-\t{\n-\t  /* The function expand_aggr_init knows how to do the\n-\t     initialization of `basetype' without getting\n-\t     an explicit `blist'.  */\n-\t  base_init_list = tree_cons (NULL_TREE, base_binfo, base_init_list);\n-\t}\n-    }\n-}\n \f\n struct base_info\n {\n@@ -4136,11 +3992,7 @@ finish_struct_1 (t, warn_anon)\n \t    TREE_ADDRESSABLE (vfields) = 1;\n \t  vfields = TREE_CHAIN (vfields);\n \t}\n-      if (any_default_members != 0)\n-\tbuild_class_init_list (t);\n     }\n-  else if (TYPE_NEEDS_CONSTRUCTING (t))\n-    build_class_init_list (t);\n \n   /* Write out inline function definitions.  */\n   do_inline_function_hair (t, CLASSTYPE_INLINE_FRIENDS (t));"}]}