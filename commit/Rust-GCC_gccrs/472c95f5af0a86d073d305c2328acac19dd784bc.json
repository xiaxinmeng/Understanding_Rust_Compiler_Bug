{"sha": "472c95f5af0a86d073d305c2328acac19dd784bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcyYzk1ZjVhZjBhODZkMDczZDMwNWMyMzI4YWNhYzE5ZGQ3ODRiYw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-04-07T08:10:34Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-04-07T08:10:34Z"}, "message": "re PR target/43920 (Choosing conditional execution over conditional branches for code size in some cases.)\n\n2011-04-07  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/43920\n\t* cfgcleanup.c (equal_different_set_p, can_replace_by, merge_dir): New\n\tfunction.\n\t(old_insns_match_p): Change return type.  Replace return false/true with\n\treturn dir_none/dir_both.  Use can_replace_by.\n\t(flow_find_cross_jump): Add dir_p parameter.  Init replacement direction\n\tfrom dir_p.  Register replacement direction in dir, last_dir and\n\tafterlast_dir.\tHandle new return type of old_insns_match_p using\n\tmerge_dir.  Return replacement direction in dir_p.\n\t(flow_find_head_matching_sequence, outgoing_edges_match): Handle new\n\treturn type of old_insns_match_p.\n\t(try_crossjump_to_edge): Add argument to call to flow_find_cross_jump.\n\t* ifcvt.c ( cond_exec_process_if_block): Add argument to call to\n\tflow_find_cross_jump.\n\t* basic-block.h (enum replace_direction): New type.\n\t(flow_find_cross_jump): Add parameter to declaration.\n\nFrom-SVN: r172090", "tree": {"sha": "16eccafa75bb37f7b9b96e7f23c0feeb6c8d439b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16eccafa75bb37f7b9b96e7f23c0feeb6c8d439b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/472c95f5af0a86d073d305c2328acac19dd784bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c95f5af0a86d073d305c2328acac19dd784bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472c95f5af0a86d073d305c2328acac19dd784bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c95f5af0a86d073d305c2328acac19dd784bc/comments", "author": null, "committer": null, "parents": [{"sha": "7c16382a3ac63d118295dd2c039e4032738d2a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c16382a3ac63d118295dd2c039e4032738d2a60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c16382a3ac63d118295dd2c039e4032738d2a60"}], "stats": {"total": 205, "additions": 183, "deletions": 22}, "files": [{"sha": "00917fe827f25d852473210b702cad2ba25bd688", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=472c95f5af0a86d073d305c2328acac19dd784bc", "patch": "@@ -1,3 +1,22 @@\n+2011-04-07  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/43920\n+\t* cfgcleanup.c (equal_different_set_p, can_replace_by, merge_dir): New\n+\tfunction.\n+\t(old_insns_match_p): Change return type.  Replace return false/true with\n+\treturn dir_none/dir_both.  Use can_replace_by.\n+\t(flow_find_cross_jump): Add dir_p parameter.  Init replacement direction\n+\tfrom dir_p.  Register replacement direction in dir, last_dir and\n+\tafterlast_dir.\tHandle new return type of old_insns_match_p using\n+\tmerge_dir.  Return replacement direction in dir_p.\n+\t(flow_find_head_matching_sequence, outgoing_edges_match): Handle new\n+\treturn type of old_insns_match_p.\n+\t(try_crossjump_to_edge): Add argument to call to flow_find_cross_jump.\n+\t* ifcvt.c ( cond_exec_process_if_block): Add argument to call to\n+\tflow_find_cross_jump.\n+\t* basic-block.h (enum replace_direction): New type.\n+\t(flow_find_cross_jump): Add parameter to declaration.\n+\n 2011-04-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (AVXMODEDCVTDQ2PS): Remove."}, {"sha": "2791fbc4184628cbb1ec7848faeff152652c3a8f", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=472c95f5af0a86d073d305c2328acac19dd784bc", "patch": "@@ -804,9 +804,12 @@ extern bool fixup_abnormal_edges (void);\n extern void find_many_sub_basic_blocks (sbitmap);\n extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n \n+enum replace_direction { dir_none, dir_forward, dir_backward, dir_both };\n+\n /* In cfgcleanup.c.  */\n extern bool cleanup_cfg (int);\n-extern int flow_find_cross_jump (basic_block, basic_block, rtx *, rtx *);\n+extern int flow_find_cross_jump (basic_block, basic_block, rtx *, rtx *,\n+                                 enum replace_direction*);\n extern int flow_find_head_matching_sequence (basic_block, basic_block,\n \t\t\t\t\t     rtx *, rtx *, int);\n "}, {"sha": "8b9bb45cad79a7bdbf16b875e41d2226658a2126", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 158, "deletions": 20, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=472c95f5af0a86d073d305c2328acac19dd784bc", "patch": "@@ -72,7 +72,7 @@ static bool block_was_dirty;\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n-static bool old_insns_match_p (int, rtx, rtx);\n+static enum replace_direction old_insns_match_p (int, rtx, rtx);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -946,27 +946,143 @@ merge_memattrs (rtx x, rtx y)\n }\n \n \n-/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n+ /* Checks if patterns P1 and P2 are equivalent, apart from the possibly\n+    different single sets S1 and S2.  */\n \n static bool\n+equal_different_set_p (rtx p1, rtx s1, rtx p2, rtx s2)\n+{\n+  int i;\n+  rtx e1, e2;\n+\n+  if (p1 == s1 && p2 == s2)\n+    return true;\n+\n+  if (GET_CODE (p1) != PARALLEL || GET_CODE (p2) != PARALLEL)\n+    return false;\n+\n+  if (XVECLEN (p1, 0) != XVECLEN (p2, 0))\n+    return false;\n+\n+  for (i = 0; i < XVECLEN (p1, 0); i++)\n+    {\n+      e1 = XVECEXP (p1, 0, i);\n+      e2 = XVECEXP (p2, 0, i);\n+      if (e1 == s1 && e2 == s2)\n+        continue;\n+      if (reload_completed\n+          ? rtx_renumbered_equal_p (e1, e2) : rtx_equal_p (e1, e2))\n+        continue;\n+\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Examine register notes on I1 and I2 and return:\n+   - dir_forward if I1 can be replaced by I2, or\n+   - dir_backward if I2 can be replaced by I1, or\n+   - dir_both if both are the case.  */\n+\n+static enum replace_direction\n+can_replace_by (rtx i1, rtx i2)\n+{\n+  rtx s1, s2, d1, d2, src1, src2, note1, note2;\n+  bool c1, c2;\n+\n+  /* Check for 2 sets.  */\n+  s1 = single_set (i1);\n+  s2 = single_set (i2);\n+  if (s1 == NULL_RTX || s2 == NULL_RTX)\n+    return dir_none;\n+\n+  /* Check that the 2 sets set the same dest.  */\n+  d1 = SET_DEST (s1);\n+  d2 = SET_DEST (s2);\n+  if (!(reload_completed\n+        ? rtx_renumbered_equal_p (d1, d2) : rtx_equal_p (d1, d2)))\n+    return dir_none;\n+\n+  /* Find identical req_equiv or reg_equal note, which implies that the 2 sets\n+     set dest to the same value.  */\n+  note1 = find_reg_equal_equiv_note (i1);\n+  note2 = find_reg_equal_equiv_note (i2);\n+  if (!note1 || !note2 || !rtx_equal_p (XEXP (note1, 0), XEXP (note2, 0))\n+      || !CONST_INT_P (XEXP (note1, 0)))\n+    return dir_none;\n+\n+  if (!equal_different_set_p (PATTERN (i1), s1, PATTERN (i2), s2))\n+    return dir_none;\n+\n+  /* Although the 2 sets set dest to the same value, we cannot replace\n+       (set (dest) (const_int))\n+     by\n+       (set (dest) (reg))\n+     because we don't know if the reg is live and has the same value at the\n+     location of replacement.  */\n+  src1 = SET_SRC (s1);\n+  src2 = SET_SRC (s2);\n+  c1 = CONST_INT_P (src1);\n+  c2 = CONST_INT_P (src2);\n+  if (c1 && c2)\n+    return dir_both;\n+  else if (c2)\n+    return dir_forward;\n+  else if (c1)\n+    return dir_backward;\n+\n+  return dir_none;\n+}\n+\n+/* Merges directions A and B.  */\n+\n+static enum replace_direction\n+merge_dir (enum replace_direction a, enum replace_direction b)\n+{\n+  /* Implements the following table:\n+        |bo fw bw no\n+     ---+-----------\n+     bo |bo fw bw no\n+     fw |-- fw no no\n+     bw |-- -- bw no\n+     no |-- -- -- no.  */\n+\n+  if (a == b)\n+    return a;\n+\n+  if (a == dir_both)\n+    return b;\n+  if (b == dir_both)\n+    return a;\n+\n+  return dir_none;\n+}\n+\n+/* Examine I1 and I2 and return:\n+   - dir_forward if I1 can be replaced by I2, or\n+   - dir_backward if I2 can be replaced by I1, or\n+   - dir_both if both are the case.  */\n+\n+static enum replace_direction\n old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n {\n   rtx p1, p2;\n \n   /* Verify that I1 and I2 are equivalent.  */\n   if (GET_CODE (i1) != GET_CODE (i2))\n-    return false;\n+    return dir_none;\n \n   /* __builtin_unreachable() may lead to empty blocks (ending with\n      NOTE_INSN_BASIC_BLOCK).  They may be crossjumped. */\n   if (NOTE_INSN_BASIC_BLOCK_P (i1) && NOTE_INSN_BASIC_BLOCK_P (i2))\n-    return true;\n+    return dir_both;\n \n   p1 = PATTERN (i1);\n   p2 = PATTERN (i2);\n \n   if (GET_CODE (p1) != GET_CODE (p2))\n-    return false;\n+    return dir_none;\n \n   /* If this is a CALL_INSN, compare register usage information.\n      If we don't check this on stack register machines, the two\n@@ -987,15 +1103,15 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n       rtx n2 = find_reg_note (i2, REG_EH_REGION, 0);\n \n       if (!n1 && n2)\n-\treturn false;\n+\treturn dir_none;\n \n       if (n1 && (!n2 || XEXP (n1, 0) != XEXP (n2, 0)))\n-\treturn false;\n+\treturn dir_none;\n \n       if (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n \t\t\tCALL_INSN_FUNCTION_USAGE (i2))\n \t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2))\n-\treturn false;\n+\treturn dir_none;\n     }\n \n #ifdef STACK_REGS\n@@ -1024,15 +1140,15 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n \t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n \n       if (!hard_reg_set_equal_p (i1_regset, i2_regset))\n-\treturn false;\n+\treturn dir_none;\n     }\n #endif\n \n   if (reload_completed\n       ? rtx_renumbered_equal_p (p1, p2) : rtx_equal_p (p1, p2))\n-    return true;\n+    return dir_both;\n \n-  return false;\n+  return can_replace_by (i1, i2);\n }\n \f\n /* When comparing insns I1 and I2 in flow_find_cross_jump or\n@@ -1059,18 +1175,32 @@ merge_notes (rtx i1, rtx i2)\n }\n \n /* Look through the insns at the end of BB1 and BB2 and find the longest\n-   sequence that are equivalent.  Store the first insns for that sequence\n-   in *F1 and *F2 and return the sequence length.\n+   sequence that are either equivalent, or allow forward or backward\n+   replacement.  Store the first insns for that sequence in *F1 and *F2 and\n+   return the sequence length.\n+\n+   DIR_P indicates the allowed replacement direction on function entry, and\n+   the actual replacement direction on function exit.  If NULL, only equivalent\n+   sequences are allowed.\n \n    To simplify callers of this function, if the blocks match exactly,\n    store the head of the blocks in *F1 and *F2.  */\n \n int\n-flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n+flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n+                      enum replace_direction *dir_p)\n {\n   rtx i1, i2, last1, last2, afterlast1, afterlast2;\n   int ninsns = 0;\n   rtx p1;\n+  enum replace_direction dir, last_dir, afterlast_dir;\n+\n+  if (dir_p)\n+    dir = *dir_p;\n+  else\n+    dir = dir_both;\n+  afterlast_dir = dir;\n+  last_dir = afterlast_dir;\n \n   /* Skip simple jumps at the end of the blocks.  Complex jumps still\n      need to be compared for equivalence, which we'll do below.  */\n@@ -1107,7 +1237,8 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n       if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n \tbreak;\n \n-      if (!old_insns_match_p (0, i1, i2))\n+      dir = merge_dir (dir, old_insns_match_p (0, i1, i2));\n+      if (dir == dir_none || (!dir_p && dir != dir_both))\n \tbreak;\n \n       merge_memattrs (i1, i2);\n@@ -1119,6 +1250,8 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n \n \t  afterlast1 = last1, afterlast2 = last2;\n \t  last1 = i1, last2 = i2;\n+\t  afterlast_dir = last_dir;\n+\t  last_dir = dir;\n \t  p1 = PATTERN (i1);\n \t  if (!(GET_CODE (p1) == USE || GET_CODE (p1) == CLOBBER))\n \t    ninsns++;\n@@ -1132,7 +1265,7 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n   /* Don't allow the insn after a compare to be shared by\n      cross-jumping unless the compare is also shared.  */\n   if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n-    last1 = afterlast1, last2 = afterlast2, ninsns--;\n+    last1 = afterlast1, last2 = afterlast2, last_dir = afterlast_dir, ninsns--;\n #endif\n \n   /* Include preceding notes and labels in the cross-jump.  One,\n@@ -1156,6 +1289,8 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2)\n       *f2 = last2;\n     }\n \n+  if (dir_p)\n+    *dir_p = last_dir;\n   return ninsns;\n }\n \n@@ -1222,7 +1357,7 @@ flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx *f1,\n \t      && nehedges1 != nehedges2))\n \tbreak;\n \n-      if (!old_insns_match_p (0, i1, i2))\n+      if (old_insns_match_p (0, i1, i2) != dir_both)\n \tbreak;\n \n       merge_memattrs (i1, i2);\n@@ -1451,7 +1586,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t  rr.update_label_nuses = false;\n \t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n \n-\t\t  match = old_insns_match_p (mode, BB_END (bb1), BB_END (bb2));\n+\t\t  match = (old_insns_match_p (mode, BB_END (bb1), BB_END (bb2))\n+\t\t\t   == dir_both);\n \t\t  if (dump_file && match)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n@@ -1473,7 +1609,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* First ensure that the instructions match.  There may be many outgoing\n      edges so this test is generally cheaper.  */\n-  if (!old_insns_match_p (mode, BB_END (bb1), BB_END (bb2)))\n+  if (old_insns_match_p (mode, BB_END (bb1), BB_END (bb2)) != dir_both)\n     return false;\n \n   /* Search the outgoing edges, ensure that the counts do match, find possible\n@@ -1574,6 +1710,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   int nmatch;\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n+  enum replace_direction dir;\n   rtx newpos1, newpos2;\n   edge s;\n   edge_iterator ei;\n@@ -1629,7 +1766,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     return false;\n \n   /* ... and part the second.  */\n-  nmatch = flow_find_cross_jump (src1, src2, &newpos1, &newpos2);\n+  dir = dir_forward;\n+  nmatch = flow_find_cross_jump (src1, src2, &newpos1, &newpos2, &dir);\n \n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched"}, {"sha": "b34aee27379598be259f81c981d8eaaf388a8eb8", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c95f5af0a86d073d305c2328acac19dd784bc/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=472c95f5af0a86d073d305c2328acac19dd784bc", "patch": "@@ -481,7 +481,8 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n       /* Look for matching sequences at the head and tail of the two blocks,\n \t and limit the range of insns to be converted if possible.  */\n       n_matching = flow_find_cross_jump (then_bb, else_bb,\n-\t\t\t\t\t &then_first_tail, &else_first_tail);\n+\t\t\t\t\t &then_first_tail, &else_first_tail,\n+\t\t\t\t\t NULL);\n       if (then_first_tail == BB_HEAD (then_bb))\n \tthen_start = then_end = NULL_RTX;\n       if (else_first_tail == BB_HEAD (else_bb))"}]}