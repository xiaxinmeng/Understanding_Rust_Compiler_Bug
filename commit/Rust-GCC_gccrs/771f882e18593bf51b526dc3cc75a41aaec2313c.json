{"sha": "771f882e18593bf51b526dc3cc75a41aaec2313c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcxZjg4MmUxODU5M2JmNTFiNTI2ZGMzY2M3NWE0MWFhZWMyMzEzYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2008-12-12T20:32:47Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2008-12-12T20:32:47Z"}, "message": "re PR tree-optimization/32044 (final value replacement too aggressive for e.g. targets with no native div/mod insns)\n\n\tPR tree-optimization/32044\n\t* tree-scalar-evolution.h (expression_expensive_p): Declare.\n\t* tree-scalar-evolution.c (expression_expensive_p): New function.\n\t(scev_const_prop): Avoid introducing expensive expressions.\n\t* tree-ssa-loop-ivopts.c (may_eliminate_iv): Ditto.\n\n\t* gcc.dg/pr34027-1.c: Change outcome.\n\t* gcc.dg/tree-ssa/pr32044.c: New test.\n\nFrom-SVN: r142719", "tree": {"sha": "d2bf855f278b353dce85dfa95de900d9e0e0ca37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2bf855f278b353dce85dfa95de900d9e0e0ca37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/771f882e18593bf51b526dc3cc75a41aaec2313c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771f882e18593bf51b526dc3cc75a41aaec2313c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771f882e18593bf51b526dc3cc75a41aaec2313c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771f882e18593bf51b526dc3cc75a41aaec2313c/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c877fcc00d1510fd4a6e0d109609522f6e108e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c877fcc00d1510fd4a6e0d109609522f6e108e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c877fcc00d1510fd4a6e0d109609522f6e108e1"}], "stats": {"total": 141, "additions": 133, "deletions": 8}, "files": [{"sha": "8fdd16275826601b3c4c4f81550ba36f57cf3513", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -1,3 +1,11 @@\n+2008-12-12  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/32044\n+\t* tree-scalar-evolution.h (expression_expensive_p): Declare.\n+\t* tree-scalar-evolution.c (expression_expensive_p): New function.\n+\t(scev_const_prop): Avoid introducing expensive expressions.\n+\t* tree-ssa-loop-ivopts.c (may_eliminate_iv): Ditto.\n+\n 2008-12-12  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/38409"}, {"sha": "895c3561a27dc205abc6286107a8f83910f23532", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -1,3 +1,9 @@\n+2008-12-12  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/32044\n+\t* gcc.dg/pr34027-1.c: Change outcome.\n+\t* gcc.dg/tree-ssa/pr32044.c: New test.\n+\n 2008-12-12  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR target/11594"}, {"sha": "8e8872a51332c0dcd076ba4f142ec881f7ce8a70", "filename": "gcc/testsuite/gcc.dg/pr34027-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34027-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34027-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr34027-1.c?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -8,5 +8,9 @@ unsigned long foobar(unsigned long ns)\n   return ns;\n }\n \n-/* { dg-final { scan-tree-dump \"ns % 10000\" \"optimized\" } } */\n+/* This test was originally introduced to test that we transform\n+   to ns % 10000.  See the discussion of PR 32044 why we do not do\n+   that anymore.  */\n+/* { dg-final { scan-tree-dump-times \"%\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"/\" 0 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "0c1a58206f443e6f704acdf8d0971ad14013f642", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr32044.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr32044.c?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-empty -fdump-tree-final_cleanup\" } */\n+\n+int foo (int n)\n+{\n+  while (n >= 45)\n+    n -= 45;\n+\n+  return n;\n+}\n+\n+int bar (int n)\n+{\n+  while (n >= 64)\n+    n -= 64;\n+\n+  return n;\n+}\n+\n+int bla (int n)\n+{\n+  int i = 0;\n+\n+  while (n >= 45)\n+    {\n+      i++;\n+      n -= 45;\n+    }\n+\n+  return i;\n+}\n+\n+int baz (int n)\n+{\n+  int i = 0;\n+\n+  while (n >= 64)\n+    {\n+      i++;\n+      n -= 64;\n+    }\n+\n+  return i;\n+}\n+\n+/* The loops computing division/modulo by 64 should be eliminated.  */\n+/* { dg-final { scan-tree-dump-times \"Removing empty loop\" 2 \"empty\" } } */\n+\n+/* There should be no division/modulo in the final dump (division and modulo\n+   by 64 are done using bit operations).  */\n+/* { dg-final { scan-tree-dump-times \"/\" 0 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"%\" 0 \"final_cleanup\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"empty\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "f306ab8277c08561eae3c9d0f3b72afcdd7adeaf", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -2805,6 +2805,50 @@ scev_finalize (void)\n   scalar_evolution_info = NULL;\n }\n \n+/* Returns true if the expression EXPR is considered to be too expensive\n+   for scev_const_prop.  */\n+\n+bool\n+expression_expensive_p (tree expr)\n+{\n+  enum tree_code code;\n+\n+  if (is_gimple_val (expr))\n+    return false;\n+\n+  code = TREE_CODE (expr);\n+  if (code == TRUNC_DIV_EXPR\n+      || code == CEIL_DIV_EXPR\n+      || code == FLOOR_DIV_EXPR\n+      || code == ROUND_DIV_EXPR\n+      || code == TRUNC_MOD_EXPR\n+      || code == CEIL_MOD_EXPR\n+      || code == FLOOR_MOD_EXPR\n+      || code == ROUND_MOD_EXPR\n+      || code == EXACT_DIV_EXPR)\n+    {\n+      /* Division by power of two is usually cheap, so we allow it.\n+\t Forbid anything else.  */\n+      if (!integer_pow2p (TREE_OPERAND (expr, 1)))\n+\treturn true;\n+    }\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_binary:\n+    case tcc_comparison:\n+      if (expression_expensive_p (TREE_OPERAND (expr, 1)))\n+\treturn true;\n+\n+      /* Fallthru.  */\n+    case tcc_unary:\n+      return expression_expensive_p (TREE_OPERAND (expr, 0));\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Replace ssa names for that scev can prove they are constant by the\n    appropriate constants.  Also perform final value replacement in loops,\n    in case the replacement expressions are cheap.\n@@ -2896,12 +2940,6 @@ scev_const_prop (void)\n \tcontinue;\n \n       niter = number_of_latch_executions (loop);\n-      /* We used to check here whether the computation of NITER is expensive,\n-\t and avoided final value elimination if that is the case.  The problem\n-\t is that it is hard to evaluate whether the expression is too\n-\t expensive, as we do not know what optimization opportunities the\n-\t elimination of the final value may reveal.  Therefore, we now\n-\t eliminate the final values of induction variables unconditionally.  */\n       if (niter == chrec_dont_know)\n \tcontinue;\n \n@@ -2938,7 +2976,15 @@ scev_const_prop (void)\n \t      /* Moving the computation from the loop may prolong life range\n \t\t of some ssa names, which may cause problems if they appear\n \t\t on abnormal edges.  */\n-\t      || contains_abnormal_ssa_name_p (def))\n+\t      || contains_abnormal_ssa_name_p (def)\n+\t      /* Do not emit expensive expressions.  The rationale is that\n+\t\t when someone writes a code like\n+\n+\t\t while (n > 45) n -= 45;\n+\n+\t\t he probably knows that n is not large, and does not want it\n+\t\t to be turned into n %= 45.  */\n+\t      || expression_expensive_p (def))\n \t    {\n \t      gsi_next (&psi);\n \t      continue;"}, {"sha": "0aa8837cbbc2c82b102d9ec418c335e91ee78a43", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -35,6 +35,7 @@ extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n unsigned int scev_const_prop (void);\n \n+bool expression_expensive_p (tree);\n extern bool simple_iv (struct loop *, gimple, tree, affine_iv *, bool);\n \n /* Returns the basic block preceding LOOP or ENTRY_BLOCK_PTR when the"}, {"sha": "2d36becf5ecd9dc5f4a5a704285eed98c92337c8", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771f882e18593bf51b526dc3cc75a41aaec2313c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=771f882e18593bf51b526dc3cc75a41aaec2313c", "patch": "@@ -3844,7 +3844,12 @@ may_eliminate_iv (struct ivopts_data *data,\n     return false;\n \n   cand_value_at (loop, cand, use->stmt, nit, &bnd);\n+\n   *bound = aff_combination_to_tree (&bnd);\n+  /* It is unlikely that computing the number of iterations using division\n+     would be more profitable than keeping the original induction variable.  */\n+  if (expression_expensive_p (*bound))\n+    return false;\n   return true;\n }\n "}]}