{"sha": "b069302cd278cf9eeb6861b3edc105baad575452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2OTMwMmNkMjc4Y2Y5ZWViNjg2MWIzZWRjMTA1YmFhZDU3NTQ1Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-25T17:10:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-25T17:10:03Z"}, "message": "avr.c (TARGET_STRUCT_VALUE_RTX): New.\n\n\t* config/avr/avr.c (TARGET_STRUCT_VALUE_RTX): New.\n\t(TARGET_RETURN_IN_MEMORY): Likewise.\n\t(TARGET_STRICT_ARGUMENT_NAMING): Likewise.\n\t(avr_return_in_memory): Remove.\n\t* config/avr/avr.h (RETURN_IN_MEMORY): Remove.\n\t(STRUCT_VALUE): Likewise.\n\t(STRUCT_VALUE_INCOMING): Likewise.\n\t(STRICT_ARGUMENT_NAMING): Likewise.\n\nFrom-SVN: r76565", "tree": {"sha": "f673e5d334cd5fbaf8a5cee153aaffa0dc88f378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f673e5d334cd5fbaf8a5cee153aaffa0dc88f378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b069302cd278cf9eeb6861b3edc105baad575452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b069302cd278cf9eeb6861b3edc105baad575452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b069302cd278cf9eeb6861b3edc105baad575452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b069302cd278cf9eeb6861b3edc105baad575452/comments", "author": null, "committer": null, "parents": [{"sha": "c2c71fe2a83826c3cf8f9f0babb41b08d5c66c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2c71fe2a83826c3cf8f9f0babb41b08d5c66c75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2c71fe2a83826c3cf8f9f0babb41b08d5c66c75"}], "stats": {"total": 80, "additions": 31, "deletions": 49}, "files": [{"sha": "827ee7a72f1c8509e50932ebcfd9acfee1b4cf38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b069302cd278cf9eeb6861b3edc105baad575452", "patch": "@@ -1,3 +1,14 @@\n+2004-01-25  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/avr/avr.c (TARGET_STRUCT_VALUE_RTX): New.\n+\t(TARGET_RETURN_IN_MEMORY): Likewise.\n+\t(TARGET_STRICT_ARGUMENT_NAMING): Likewise.\n+\t(avr_return_in_memory): Remove.\n+\t* config/avr/avr.h (RETURN_IN_MEMORY): Remove.\n+\t(STRUCT_VALUE): Likewise.\n+\t(STRUCT_VALUE_INCOMING): Likewise.\n+\t(STRICT_ARGUMENT_NAMING): Likewise.\n+\n 2004-01-25  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (recog_for_combine): Avoid allocating unnecesary RTX."}, {"sha": "dc60d18fcb8ec7c8f62a4ba4bedb330118cbbec2", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=b069302cd278cf9eeb6861b3edc105baad575452", "patch": "@@ -77,6 +77,7 @@ static void avr_asm_out_dtor (rtx, int);\n static int default_rtx_costs (rtx, enum rtx_code, enum rtx_code);\n static bool avr_rtx_costs (rtx, int, int, int *);\n static int avr_address_cost (rtx);\n+static bool avr_return_in_memory (tree, tree);\n \n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n@@ -242,6 +243,14 @@ int avr_case_values_threshold = 30000;\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG avr_reorg\n \n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX hook_rtx_tree_int_null\n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY avr_return_in_memory\n+\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -5366,4 +5375,12 @@ avr_asm_out_dtor (rtx symbol, int priority)\n   default_dtor_section_asm_out_destructor (symbol, priority);\n }\n \n+static bool\n+avr_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n+{\n+  return ((TYPE_MODE (type) == BLKmode)\n+\t  ? int_size_in_bytes (type) > 8\n+\t  : 0);\n+}\n+\n #include \"gt-avr.h\""}, {"sha": "f94cc5784249f1054d89bdd429c66b848ead94a7", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b069302cd278cf9eeb6861b3edc105baad575452/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=b069302cd278cf9eeb6861b3edc105baad575452", "patch": "@@ -1188,9 +1188,9 @@ extern int avr_reg_order[];\n    `parallel' RTX, if the return value is in multiple places.  See\n    `FUNCTION_ARG' for an explanation of the `parallel' form.\n \n-   If `PROMOTE_FUNCTION_RETURN' is defined, you must apply the same\n-   promotion rules specified in `PROMOTE_MODE' if VALTYPE is a scalar\n-   type.\n+   If `TARGET_PROMOTE_FUNCTION_RETURN' is defined to return true, you\n+   must apply the same promotion rules specified in `PROMOTE_MODE' if\n+   VALTYPE is a scalar type.\n \n    If the precise function being called is known, FUNC is a tree node\n    (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This\n@@ -1233,26 +1233,6 @@ extern int avr_reg_order[];\n    called function use different registers for the return value, this\n    macro should recognize only the caller's register numbers.  */\n \n-#define RETURN_IN_MEMORY(TYPE) ((TYPE_MODE (TYPE) == BLKmode)\t\\\n-\t\t\t\t? int_size_in_bytes (TYPE) > 8\t\\\n-\t\t\t\t: 0)\n-/* A C expression which can inhibit the returning of certain function\n-   values in registers, based on the type of value.  A nonzero value\n-   says to return the function value in memory, just as large\n-   structures are always returned.  Here TYPE will be a C expression\n-   of type `tree', representing the data type of the value.\n-\n-   Note that values of mode `BLKmode' must be explicitly handled by\n-   this macro.  Also, the option `-fpcc-struct-return' takes effect\n-   regardless of this macro.  On most systems, it is possible to\n-   leave the macro undefined; this causes a default definition to be\n-   used, whose value is the constant 1 for `BLKmode' values, and 0\n-   otherwise.\n-\n-   Do not use this macro to indicate that structures and unions\n-   should always be returned in memory.  You should instead use\n-   `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n /* Define this macro to be 1 if all structure and union return values\n    must be in memory.  Since this results in slower code, this should\n@@ -1263,38 +1243,12 @@ extern int avr_reg_order[];\n \n    If not defined, this defaults to the value 1.  */\n \n-#define STRUCT_VALUE 0\n-/* If the structure value address is not passed in a register, define\n-   `STRUCT_VALUE' as an expression returning an RTX for the place\n-   where the address is passed.  If it returns 0, the address is\n-   passed as an \"invisible\" first argument.  */\n-\n-#define STRUCT_VALUE_INCOMING 0\n-/* If the incoming location is not a register, then you should define\n-   `STRUCT_VALUE_INCOMING' as an expression for an RTX for where the\n-   called function should find the value.  If it should find the\n-   value on the stack, define this to create a `mem' which refers to\n-   the frame pointer.  A definition of 0 means that the address is\n-   passed as an \"invisible\" first argument.  */\n-\n #define EPILOGUE_USES(REGNO) 0\n /* Define this macro as a C expression that is nonzero for registers\n    are used by the epilogue or the `return' pattern.  The stack and\n    frame pointer registers are already be assumed to be used as\n    needed.  */\n \n-#define STRICT_ARGUMENT_NAMING 1\n-/* Define this macro if the location where a function argument is\n-   passed depends on whether or not it is a named argument.\n-\n-   This macro controls how the NAMED argument to `FUNCTION_ARG' is\n-   set for varargs and stdarg functions.  With this macro defined,\n-   the NAMED argument is always true for named arguments, and false\n-   for unnamed arguments.  If this is not defined, but\n-   `SETUP_INCOMING_VARARGS' is defined, then all arguments are\n-   treated as named.  Otherwise, all named arguments except the last\n-   are treated as named.  */\n-\n \n #define HAVE_POST_INCREMENT 1\n /* Define this macro if the machine supports post-increment"}]}