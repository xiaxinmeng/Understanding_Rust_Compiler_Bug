{"sha": "c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViMjFjM2Y0YzE3YjA2NDkxNTUwMzVkMmY5YWE5N2IyZGE4YTgxMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-07-30T21:28:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-13T03:23:07Z"}, "message": "libgo: update to Go1.17rc2\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/341629", "tree": {"sha": "c6d3a68b503ba5b16182acbb958e3e5dbc95a43b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6d3a68b503ba5b16182acbb958e3e5dbc95a43b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc"}], "stats": {"total": 97467, "additions": 74653, "deletions": 22814}, "files": [{"sha": "bcbe1d93018cd3f148cddcd14033ee1c94c6a75f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1,4 +1,4 @@\n-5edbb624b2595d644eb6842c952a292c41f7d6fa\n+33f65dce43bd01c1fa38cd90a78c9aea6ca6dd59\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4286d5c5433db0f482c6eacd6267c824f5c3302a", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1,4 +1,4 @@\n-7677616a263e8ded606cc8297cb67ddc667a876e\n+72ab3ff68b1ec894fe5599ec82b8849f3baa9d94\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "92fedcf6eb8dc3bf81ab25c6a4e1fc1c3228e69c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -366,6 +366,7 @@ toolexeclibgoregexp_DATA = \\\n toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n \n toolexeclibgoruntime_DATA = \\\n+\truntime/cgo.gox \\\n \truntime/debug.gox \\\n \truntime/metrics.gox \\\n \truntime/pprof.gox \\\n@@ -428,7 +429,9 @@ noinst_DATA = \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\\n-\tos/signal/internal/pty.gox\n+\tos/signal/internal/pty.gox \\\n+\treflect/internal/example1.gox \\\n+\treflect/internal/example2.gox\n \n if LIBGO_IS_RTEMS\n rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -480,14 +483,10 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'func init() { DefaultGoroot = \"$(prefix)\" }' >> version.go.tmp\n-\techo 'const TheVersion = \"'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n-\techo 'const Goexperiment = ``' >> version.go.tmp\n \techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n \techo 'const GOOS = \"'$(GOOS)'\"' >> version.go.tmp\n \techo 'const GccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n-\techo >> version.go.tmp\n-\techo \"type ArchFamilyType int\" >> version.go.tmp\n+\techo 'const StackGuardMultiplierDefault = 1' >> version.go.tmp\n \techo >> version.go.tmp\n \techo \"const (\" >> version.go.tmp\n \techo \"\tUNKNOWN ArchFamilyType = iota\" >> version.go.tmp\n@@ -507,13 +506,13 @@ s-version: Makefile\n \tdone\n \techo >> version.go.tmp\n \techo \"const (\" >> version.go.tmp\n-\techo \"  ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n-\techo \"  BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n-\techo \"  CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> version.go.tmp\n-\techo \"  DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n-\techo \"  MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n-\techo \"  PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n+\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n+\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n+\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n+\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n+\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n+\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n+\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> version.go.tmp\n \techo \")\" >> version.go.tmp\n \techo >> version.go.tmp\n \tfor a in $(ALLGOOS); do \\\n@@ -526,7 +525,6 @@ s-version: Makefile\n \t  fi; \\\n \tdone\n \techo >> version.go.tmp\n-\techo \"type Uintreg uintptr\" >> version.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n \n@@ -547,24 +545,31 @@ s-gcpu: Makefile\n \t$(SHELL) $(srcdir)/mvifdiff.sh gcpugen.go.tmp gcpugen.go\n \t$(STAMP) $@\n \n+buildcfg.go: s-buildcfg; @true\n+s-buildcfg: Makefile\n+\trm -f buildcfg.go.tmp\n+\techo \"package buildcfg\" > buildcfg.go.tmp\n+\techo \"import \\\"runtime\\\"\" >> buildcfg.go.tmp\n+\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> buildcfg.go.tmp\n+\techo 'const defaultGO386 = `sse2`' >> buildcfg.go.tmp\n+\techo 'const defaultGOARM = `5`' >> buildcfg.go.tmp\n+\techo 'const defaultGOMIPS = `hardfloat`' >> buildcfg.go.tmp\n+\techo 'const defaultGOMIPS64 = `hardfloat`' >> buildcfg.go.tmp\n+\techo 'const defaultGOPPC64 = `power8`' >> buildcfg.go.tmp\n+\techo 'const defaultGOEXPERIMENT = `fieldtrack`' >> buildcfg.go.tmp\n+\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> buildcfg.go.tmp\n+\techo 'const defaultGO_LDSO = ``' >> buildcfg.go.tmp\n+\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> buildcfg.go.tmp\n+\techo 'const defaultGOOS = runtime.GOOS' >> buildcfg.go.tmp\n+\techo 'const defaultGOARCH = runtime.GOARCH' >> buildcfg.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh buildcfg.go.tmp buildcfg.go\n+\t$(STAMP) $@\n+\n objabi.go: s-objabi; @true\n s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n-\techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> objabi.go.tmp\n-\techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n-\techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n-\techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n-\techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n-\techo 'const defaultGOPPC64 = `power8`' >> objabi.go.tmp\n-\techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n-\techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n-\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n-\techo 'const defaultGO_LDSO = ``' >> objabi.go.tmp\n-\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n \techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n-\techo 'const goexperiment = ``' >> objabi.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n \t$(STAMP) $@\n \n@@ -671,7 +676,7 @@ s-zstdpkglist: Makefile libgo-packages.txt\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n-\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|golang\\.org/[a-z0-9_./]*\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n+\techo $(libgo_go_objs) 'unsafe.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|golang\\.org/[a-z0-9_./]*\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n \techo '}' >> zstdpkglist.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh zstdpkglist.go.tmp zstdpkglist.go\n \t$(STAMP) $@\n@@ -1054,6 +1059,9 @@ internal/cpu.lo.dep: $(extra_go_files_internal_cpu)\n extra_go_files_golang_org_x_sys_cpu = gcpugen.go\n golang.org/x/sys/cpu.lo.dep: $(extra_go_files_golang_org_x_sys_cpu)\n \n+extra_go_files_internal_buildcfg = buildcfg.go\n+cmd/internal/buildcfg.lo.dep: $(extra_go_files_internal_buildcfg)\n+\n extra_go_files_internal_goroot = zstdpkglist.go\n internal/goroot.lo.dep: $(extra_go_files_internal_goroot)\n "}, {"sha": "3b2bdf99027c2e5e21d04cb501c0847fae1c30d9", "filename": "libgo/Makefile.in", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -839,6 +839,7 @@ toolexeclibgoregexp_DATA = \\\n \n toolexeclibgoruntimedir = $(toolexeclibgodir)/runtime\n toolexeclibgoruntime_DATA = \\\n+\truntime/cgo.gox \\\n \truntime/debug.gox \\\n \truntime/metrics.gox \\\n \truntime/pprof.gox \\\n@@ -892,6 +893,7 @@ noinst_DATA = golang.org/x/net/nettest.gox internal/cfg.gox \\\n \tinternal/obscuretestdata.gox internal/profile.gox \\\n \tinternal/testenv.gox internal/trace.gox \\\n \tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n+\treflect/internal/example1.gox reflect/internal/example2.gox \\\n \tzdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -1135,6 +1137,7 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n extra_go_files_internal_cpu = cpugen.go\n extra_go_files_golang_org_x_sys_cpu = gcpugen.go\n+extra_go_files_internal_buildcfg = buildcfg.go\n extra_go_files_internal_goroot = zstdpkglist.go\n extra_go_files_go_types = gccgosizes.go\n extra_go_files_cmd_internal_objabi = objabi.go\n@@ -2687,14 +2690,10 @@ version.go: s-version; @true\n s-version: Makefile\n \trm -f version.go.tmp\n \techo \"package sys\" > version.go.tmp\n-\techo 'func init() { DefaultGoroot = \"$(prefix)\" }' >> version.go.tmp\n-\techo 'const TheVersion = \"'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'\"' >> version.go.tmp\n-\techo 'const Goexperiment = ``' >> version.go.tmp\n \techo 'const GOARCH = \"'$(GOARCH)'\"' >> version.go.tmp\n \techo 'const GOOS = \"'$(GOOS)'\"' >> version.go.tmp\n \techo 'const GccgoToolDir = \"$(libexecsubdir)\"' >> version.go.tmp\n-\techo >> version.go.tmp\n-\techo \"type ArchFamilyType int\" >> version.go.tmp\n+\techo 'const StackGuardMultiplierDefault = 1' >> version.go.tmp\n \techo >> version.go.tmp\n \techo \"const (\" >> version.go.tmp\n \techo \"\tUNKNOWN ArchFamilyType = iota\" >> version.go.tmp\n@@ -2714,13 +2713,13 @@ s-version: Makefile\n \tdone\n \techo >> version.go.tmp\n \techo \"const (\" >> version.go.tmp\n-\techo \"  ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n-\techo \"  BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n-\techo \"  CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> version.go.tmp\n-\techo \"  DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n-\techo \"  MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n-\techo \"  PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n+\techo \"  _ArchFamily = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) family`\" >> version.go.tmp\n+\techo \"  _BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n+\techo \"  _DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n+\techo \"  _Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n+\techo \"  _MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n+\techo \"  _PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n+\techo \"  _StackAlign = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) stackalign`\" >> version.go.tmp\n \techo \")\" >> version.go.tmp\n \techo >> version.go.tmp\n \tfor a in $(ALLGOOS); do \\\n@@ -2733,7 +2732,6 @@ s-version: Makefile\n \t  fi; \\\n \tdone\n \techo >> version.go.tmp\n-\techo \"type Uintreg uintptr\" >> version.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n \n@@ -2754,24 +2752,31 @@ s-gcpu: Makefile\n \t$(SHELL) $(srcdir)/mvifdiff.sh gcpugen.go.tmp gcpugen.go\n \t$(STAMP) $@\n \n+buildcfg.go: s-buildcfg; @true\n+s-buildcfg: Makefile\n+\trm -f buildcfg.go.tmp\n+\techo \"package buildcfg\" > buildcfg.go.tmp\n+\techo \"import \\\"runtime\\\"\" >> buildcfg.go.tmp\n+\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> buildcfg.go.tmp\n+\techo 'const defaultGO386 = `sse2`' >> buildcfg.go.tmp\n+\techo 'const defaultGOARM = `5`' >> buildcfg.go.tmp\n+\techo 'const defaultGOMIPS = `hardfloat`' >> buildcfg.go.tmp\n+\techo 'const defaultGOMIPS64 = `hardfloat`' >> buildcfg.go.tmp\n+\techo 'const defaultGOPPC64 = `power8`' >> buildcfg.go.tmp\n+\techo 'const defaultGOEXPERIMENT = `fieldtrack`' >> buildcfg.go.tmp\n+\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> buildcfg.go.tmp\n+\techo 'const defaultGO_LDSO = ``' >> buildcfg.go.tmp\n+\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> buildcfg.go.tmp\n+\techo 'const defaultGOOS = runtime.GOOS' >> buildcfg.go.tmp\n+\techo 'const defaultGOARCH = runtime.GOARCH' >> buildcfg.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh buildcfg.go.tmp buildcfg.go\n+\t$(STAMP) $@\n+\n objabi.go: s-objabi; @true\n s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n-\techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> objabi.go.tmp\n-\techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n-\techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n-\techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n-\techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n-\techo 'const defaultGOPPC64 = `power8`' >> objabi.go.tmp\n-\techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n-\techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n-\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n-\techo 'const defaultGO_LDSO = ``' >> objabi.go.tmp\n-\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n \techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n-\techo 'const goexperiment = ``' >> objabi.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n \t$(STAMP) $@\n \n@@ -2872,7 +2877,7 @@ s-zstdpkglist: Makefile libgo-packages.txt\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n-\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|golang\\.org/[a-z0-9_./]*\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n+\techo $(libgo_go_objs) 'unsafe.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|golang\\.org/[a-z0-9_./]*\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n \techo '}' >> zstdpkglist.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh zstdpkglist.go.tmp zstdpkglist.go\n \t$(STAMP) $@\n@@ -3005,6 +3010,7 @@ syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n internal/cpu.lo.dep: $(extra_go_files_internal_cpu)\n golang.org/x/sys/cpu.lo.dep: $(extra_go_files_golang_org_x_sys_cpu)\n+cmd/internal/buildcfg.lo.dep: $(extra_go_files_internal_buildcfg)\n internal/goroot.lo.dep: $(extra_go_files_internal_goroot)\n go/types.lo.dep: $(extra_go_files_go_types)\n cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)"}, {"sha": "904eb73bd5cf6e17793ac92874e56c656c282d18", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1 +1 @@\n-go1.16.5\n+go1.17rc2"}, {"sha": "dd8990f10e2c7b5a0ded85b3c75d9b0d8fa85009", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -43,7 +43,10 @@ crypto/des\n crypto/dsa\n crypto/ecdsa\n crypto/ed25519\n+crypto/ed25519/internal/edwards25519\n+crypto/ed25519/internal/edwards25519/field\n crypto/elliptic\n+crypto/elliptic/internal/fiat\n crypto/hmac\n crypto/internal/subtle\n crypto/md5\n@@ -110,6 +113,7 @@ index/suffixarray\n internal/cpu\n internal/execabs\n internal/fmtsort\n+internal/itoa\n internal/poll\n internal/profile\n internal/reflectlite\n@@ -139,6 +143,7 @@ net/http/httptest\n net/http/httptrace\n net/http/httputil\n net/http/internal\n+net/http/internal/ascii\n net/http/pprof\n net/internal/socktest\n net/mail\n@@ -157,6 +162,7 @@ reflect\n regexp\n regexp/syntax\n runtime\n+runtime/cgo\n runtime/debug\n runtime/internal/atomic\n runtime/internal/math"}, {"sha": "57ceeb2baa7ba7ccc5b3864fb956542f480c704c", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2608,7 +2608,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=19:0:0\n+libtool_VERSION=20:0:0\n \n \n # Default to --enable-multilib"}, {"sha": "1f4f32dae2b4c9e633f21ac15a6afbe435b1c614", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=19:0:0\n+libtool_VERSION=20:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "71cece5793a4c4d3fb3392451beaced08db150dc", "filename": "libgo/go/archive/tar/stat_actime1.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || hurd || linux || dragonfly || openbsd || solaris\n // +build aix hurd linux dragonfly openbsd solaris\n \n package tar"}, {"sha": "5a9a35cbb4e22d9df42f307843730032d7e0b392", "filename": "libgo/go/archive/tar/stat_actime2.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build darwin || freebsd || netbsd\n // +build darwin freebsd netbsd\n \n package tar"}, {"sha": "f27df67eedc1af73d29aee80c54e5d320925581f", "filename": "libgo/go/archive/tar/stat_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || hurd || linux || darwin || dragonfly || freebsd || openbsd || netbsd || solaris\n // +build aix hurd linux darwin dragonfly freebsd openbsd netbsd solaris\n \n package tar"}, {"sha": "e9fafc7cc70df5cd5f6308f42c87c6d577f6dabf", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -262,16 +262,11 @@ func TestFileInfoHeaderDir(t *testing.T) {\n func TestFileInfoHeaderSymlink(t *testing.T) {\n \ttestenv.MustHaveSymlink(t)\n \n-\ttmpdir, err := os.MkdirTemp(\"\", \"TestFileInfoHeaderSymlink\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(tmpdir)\n+\ttmpdir := t.TempDir()\n \n \tlink := filepath.Join(tmpdir, \"link\")\n \ttarget := tmpdir\n-\terr = os.Symlink(target, link)\n-\tif err != nil {\n+\tif err := os.Symlink(target, link); err != nil {\n \t\tt.Fatal(err)\n \t}\n \tfi, err := os.Lstat(link)"}, {"sha": "2d53f4c7231653d651b4f3b5bb1a15325b4a33ac", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 82, "deletions": 33, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -52,12 +52,9 @@ type File struct {\n \tFileHeader\n \tzip          *Reader\n \tzipr         io.ReaderAt\n-\tzipsize      int64\n \theaderOffset int64\n-}\n-\n-func (f *File) hasDataDescriptor() bool {\n-\treturn f.Flags&0x8 != 0\n+\tzip64        bool  // zip64 extended information extra field presence\n+\tdescErr      error // error reading the data descriptor during init\n }\n \n // OpenReader will open the Zip file specified by name and return a ReadCloser.\n@@ -120,14 +117,15 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \t// a bad one, and then only report an ErrFormat or UnexpectedEOF if\n \t// the file count modulo 65536 is incorrect.\n \tfor {\n-\t\tf := &File{zip: z, zipr: r, zipsize: size}\n+\t\tf := &File{zip: z, zipr: r}\n \t\terr = readDirectoryHeader(f, buf)\n \t\tif err == ErrFormat || err == io.ErrUnexpectedEOF {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tf.readDataDescriptor()\n \t\tz.File = append(z.File, f)\n \t}\n \tif uint16(len(z.File)) != uint16(end.directoryRecords) { // only compare 16 bits here\n@@ -188,26 +186,68 @@ func (f *File) Open() (io.ReadCloser, error) {\n \t\treturn nil, ErrAlgorithm\n \t}\n \tvar rc io.ReadCloser = dcomp(r)\n-\tvar desr io.Reader\n-\tif f.hasDataDescriptor() {\n-\t\tdesr = io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, dataDescriptorLen)\n-\t}\n \trc = &checksumReader{\n \t\trc:   rc,\n \t\thash: crc32.NewIEEE(),\n \t\tf:    f,\n-\t\tdesr: desr,\n \t}\n \treturn rc, nil\n }\n \n+// OpenRaw returns a Reader that provides access to the File's contents without\n+// decompression.\n+func (f *File) OpenRaw() (io.Reader, error) {\n+\tbodyOffset, err := f.findBodyOffset()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset, int64(f.CompressedSize64))\n+\treturn r, nil\n+}\n+\n+func (f *File) readDataDescriptor() {\n+\tif !f.hasDataDescriptor() {\n+\t\treturn\n+\t}\n+\n+\tbodyOffset, err := f.findBodyOffset()\n+\tif err != nil {\n+\t\tf.descErr = err\n+\t\treturn\n+\t}\n+\n+\t// In section 4.3.9.2 of the spec: \"However ZIP64 format MAY be used\n+\t// regardless of the size of a file.  When extracting, if the zip64\n+\t// extended information extra field is present for the file the\n+\t// compressed and uncompressed sizes will be 8 byte values.\"\n+\t//\n+\t// Historically, this package has used the compressed and uncompressed\n+\t// sizes from the central directory to determine if the package is\n+\t// zip64.\n+\t//\n+\t// For this case we allow either the extra field or sizes to determine\n+\t// the data descriptor length.\n+\tzip64 := f.zip64 || f.isZip64()\n+\tn := int64(dataDescriptorLen)\n+\tif zip64 {\n+\t\tn = dataDescriptor64Len\n+\t}\n+\tsize := int64(f.CompressedSize64)\n+\tr := io.NewSectionReader(f.zipr, f.headerOffset+bodyOffset+size, n)\n+\tdd, err := readDataDescriptor(r, zip64)\n+\tif err != nil {\n+\t\tf.descErr = err\n+\t\treturn\n+\t}\n+\tf.CRC32 = dd.crc32\n+}\n+\n type checksumReader struct {\n \trc    io.ReadCloser\n \thash  hash.Hash32\n \tnread uint64 // number of bytes read so far\n \tf     *File\n-\tdesr  io.Reader // if non-nil, where to read the data descriptor\n-\terr   error     // sticky error\n+\terr   error // sticky error\n }\n \n func (r *checksumReader) Stat() (fs.FileInfo, error) {\n@@ -228,12 +268,12 @@ func (r *checksumReader) Read(b []byte) (n int, err error) {\n \t\tif r.nread != r.f.UncompressedSize64 {\n \t\t\treturn 0, io.ErrUnexpectedEOF\n \t\t}\n-\t\tif r.desr != nil {\n-\t\t\tif err1 := readDataDescriptor(r.desr, r.f); err1 != nil {\n-\t\t\t\tif err1 == io.EOF {\n+\t\tif r.f.hasDataDescriptor() {\n+\t\t\tif r.f.descErr != nil {\n+\t\t\t\tif r.f.descErr == io.EOF {\n \t\t\t\t\terr = io.ErrUnexpectedEOF\n \t\t\t\t} else {\n-\t\t\t\t\terr = err1\n+\t\t\t\t\terr = r.f.descErr\n \t\t\t\t}\n \t\t\t} else if r.hash.Sum32() != r.f.CRC32 {\n \t\t\t\terr = ErrChecksum\n@@ -344,6 +384,8 @@ parseExtras:\n \n \t\tswitch fieldTag {\n \t\tcase zip64ExtraID:\n+\t\t\tf.zip64 = true\n+\n \t\t\t// update directory values from the zip64 extra block.\n \t\t\t// They should only be consulted if the sizes read earlier\n \t\t\t// are maxed out.\n@@ -443,8 +485,9 @@ parseExtras:\n \treturn nil\n }\n \n-func readDataDescriptor(r io.Reader, f *File) error {\n-\tvar buf [dataDescriptorLen]byte\n+func readDataDescriptor(r io.Reader, zip64 bool) (*dataDescriptor, error) {\n+\t// Create enough space for the largest possible size\n+\tvar buf [dataDescriptor64Len]byte\n \n \t// The spec says: \"Although not originally assigned a\n \t// signature, the value 0x08074b50 has commonly been adopted\n@@ -454,10 +497,9 @@ func readDataDescriptor(r io.Reader, f *File) error {\n \t// descriptors and should account for either case when reading\n \t// ZIP files to ensure compatibility.\"\n \t//\n-\t// dataDescriptorLen includes the size of the signature but\n-\t// first read just those 4 bytes to see if it exists.\n+\t// First read just those 4 bytes to see if the signature exists.\n \tif _, err := io.ReadFull(r, buf[:4]); err != nil {\n-\t\treturn err\n+\t\treturn nil, err\n \t}\n \toff := 0\n \tmaybeSig := readBuf(buf[:4])\n@@ -466,21 +508,28 @@ func readDataDescriptor(r io.Reader, f *File) error {\n \t\t// bytes.\n \t\toff += 4\n \t}\n-\tif _, err := io.ReadFull(r, buf[off:12]); err != nil {\n-\t\treturn err\n+\n+\tend := dataDescriptorLen - 4\n+\tif zip64 {\n+\t\tend = dataDescriptor64Len - 4\n \t}\n-\tb := readBuf(buf[:12])\n-\tif b.uint32() != f.CRC32 {\n-\t\treturn ErrChecksum\n+\tif _, err := io.ReadFull(r, buf[off:end]); err != nil {\n+\t\treturn nil, err\n \t}\n+\tb := readBuf(buf[:end])\n \n-\t// The two sizes that follow here can be either 32 bits or 64 bits\n-\t// but the spec is not very clear on this and different\n-\t// interpretations has been made causing incompatibilities. We\n-\t// already have the sizes from the central directory so we can\n-\t// just ignore these.\n+\tout := &dataDescriptor{\n+\t\tcrc32: b.uint32(),\n+\t}\n \n-\treturn nil\n+\tif zip64 {\n+\t\tout.compressedSize = b.uint64()\n+\t\tout.uncompressedSize = b.uint64()\n+\t} else {\n+\t\tout.compressedSize = uint64(b.uint32())\n+\t\tout.uncompressedSize = uint64(b.uint32())\n+\t}\n+\treturn out, nil\n }\n \n func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error) {"}, {"sha": "37dafe6c8e7c448c8fa28359e07fc2cdbb73560f", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 163, "deletions": 4, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -499,9 +499,15 @@ func TestReader(t *testing.T) {\n func readTestZip(t *testing.T, zt ZipTest) {\n \tvar z *Reader\n \tvar err error\n+\tvar raw []byte\n \tif zt.Source != nil {\n \t\trat, size := zt.Source()\n \t\tz, err = NewReader(rat, size)\n+\t\traw = make([]byte, size)\n+\t\tif _, err := rat.ReadAt(raw, 0); err != nil {\n+\t\t\tt.Errorf(\"ReadAt error=%v\", err)\n+\t\t\treturn\n+\t\t}\n \t} else {\n \t\tpath := filepath.Join(\"testdata\", zt.Name)\n \t\tif zt.Obscured {\n@@ -519,6 +525,12 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\t\tdefer rc.Close()\n \t\t\tz = &rc.Reader\n \t\t}\n+\t\tvar err2 error\n+\t\traw, err2 = os.ReadFile(path)\n+\t\tif err2 != nil {\n+\t\t\tt.Errorf(\"ReadFile(%s) error=%v\", path, err2)\n+\t\t\treturn\n+\t\t}\n \t}\n \tif err != zt.Error {\n \t\tt.Errorf(\"error=%v, want %v\", err, zt.Error)\n@@ -545,7 +557,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \n \t// test read of each file\n \tfor i, ft := range zt.File {\n-\t\treadTestFile(t, zt, ft, z.File[i])\n+\t\treadTestFile(t, zt, ft, z.File[i], raw)\n \t}\n \tif t.Failed() {\n \t\treturn\n@@ -557,7 +569,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \tfor i := 0; i < 5; i++ {\n \t\tfor j, ft := range zt.File {\n \t\t\tgo func(j int, ft ZipTestFile) {\n-\t\t\t\treadTestFile(t, zt, ft, z.File[j])\n+\t\t\t\treadTestFile(t, zt, ft, z.File[j], raw)\n \t\t\t\tdone <- true\n \t\t\t}(j, ft)\n \t\t\tn++\n@@ -574,7 +586,7 @@ func equalTimeAndZone(t1, t2 time.Time) bool {\n \treturn t1.Equal(t2) && name1 == name2 && offset1 == offset2\n }\n \n-func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n+func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File, raw []byte) {\n \tif f.Name != ft.Name {\n \t\tt.Errorf(\"name=%q, want %q\", f.Name, ft.Name)\n \t}\n@@ -594,6 +606,31 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \t\tt.Errorf(\"%v: UncompressedSize=%#x does not match UncompressedSize64=%#x\", f.Name, size, f.UncompressedSize64)\n \t}\n \n+\t// Check that OpenRaw returns the correct byte segment\n+\trw, err := f.OpenRaw()\n+\tif err != nil {\n+\t\tt.Errorf(\"%v: OpenRaw error=%v\", f.Name, err)\n+\t\treturn\n+\t}\n+\tstart, err := f.DataOffset()\n+\tif err != nil {\n+\t\tt.Errorf(\"%v: DataOffset error=%v\", f.Name, err)\n+\t\treturn\n+\t}\n+\tgot, err := io.ReadAll(rw)\n+\tif err != nil {\n+\t\tt.Errorf(\"%v: OpenRaw ReadAll error=%v\", f.Name, err)\n+\t\treturn\n+\t}\n+\tend := uint64(start) + f.CompressedSize64\n+\twant := raw[start:end]\n+\tif !bytes.Equal(got, want) {\n+\t\tt.Logf(\"got %q\", got)\n+\t\tt.Logf(\"want %q\", want)\n+\t\tt.Errorf(\"%v: OpenRaw returned unexpected bytes\", f.Name)\n+\t\treturn\n+\t}\n+\n \tr, err := f.Open()\n \tif err != nil {\n \t\tt.Errorf(\"%v\", err)\n@@ -776,8 +813,8 @@ func returnRecursiveZip() (r io.ReaderAt, size int64) {\n //\t\t\"archive/zip\"\n //\t\t\"bytes\"\n //\t\t\"io\"\n-//\t\t\"io/ioutil\"\n //\t\t\"log\"\n+//\t\t\"os\"\n //\t)\n //\n //\ttype zeros struct{}\n@@ -1167,6 +1204,128 @@ func TestCVE202127919(t *testing.T) {\n \t}\n }\n \n+func TestReadDataDescriptor(t *testing.T) {\n+\ttests := []struct {\n+\t\tdesc    string\n+\t\tin      []byte\n+\t\tzip64   bool\n+\t\twant    *dataDescriptor\n+\t\twantErr error\n+\t}{{\n+\t\tdesc: \"valid 32 bit with signature\",\n+\t\tin: []byte{\n+\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, // compressed size\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, // uncompressed size\n+\t\t},\n+\t\twant: &dataDescriptor{\n+\t\t\tcrc32:            0x03020100,\n+\t\t\tcompressedSize:   0x07060504,\n+\t\t\tuncompressedSize: 0x0b0a0908,\n+\t\t},\n+\t}, {\n+\t\tdesc: \"valid 32 bit without signature\",\n+\t\tin: []byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, // compressed size\n+\t\t\t0x08, 0x09, 0x0a, 0x0b, // uncompressed size\n+\t\t},\n+\t\twant: &dataDescriptor{\n+\t\t\tcrc32:            0x03020100,\n+\t\t\tcompressedSize:   0x07060504,\n+\t\t\tuncompressedSize: 0x0b0a0908,\n+\t\t},\n+\t}, {\n+\t\tdesc: \"valid 64 bit with signature\",\n+\t\tin: []byte{\n+\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n+\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, // uncompressed size\n+\t\t},\n+\t\tzip64: true,\n+\t\twant: &dataDescriptor{\n+\t\t\tcrc32:            0x03020100,\n+\t\t\tcompressedSize:   0x0b0a090807060504,\n+\t\t\tuncompressedSize: 0x131211100f0e0d0c,\n+\t\t},\n+\t}, {\n+\t\tdesc: \"valid 64 bit without signature\",\n+\t\tin: []byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n+\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, // uncompressed size\n+\t\t},\n+\t\tzip64: true,\n+\t\twant: &dataDescriptor{\n+\t\t\tcrc32:            0x03020100,\n+\t\t\tcompressedSize:   0x0b0a090807060504,\n+\t\t\tuncompressedSize: 0x131211100f0e0d0c,\n+\t\t},\n+\t}, {\n+\t\tdesc: \"invalid 32 bit with signature\",\n+\t\tin: []byte{\n+\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, // unexpected end\n+\t\t},\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tdesc: \"invalid 32 bit without signature\",\n+\t\tin: []byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, // unexpected end\n+\t\t},\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tdesc: \"invalid 64 bit with signature\",\n+\t\tin: []byte{\n+\t\t\t0x50, 0x4b, 0x07, 0x08, // signature\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n+\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, // unexpected end\n+\t\t},\n+\t\tzip64:   true,\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tdesc: \"invalid 64 bit without signature\",\n+\t\tin: []byte{\n+\t\t\t0x00, 0x01, 0x02, 0x03, // crc32\n+\t\t\t0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, // compressed size\n+\t\t\t0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, // unexpected end\n+\t\t},\n+\t\tzip64:   true,\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}}\n+\n+\tfor _, test := range tests {\n+\t\tt.Run(test.desc, func(t *testing.T) {\n+\t\t\tr := bytes.NewReader(test.in)\n+\n+\t\t\tdesc, err := readDataDescriptor(r, test.zip64)\n+\t\t\tif err != test.wantErr {\n+\t\t\t\tt.Fatalf(\"got err %v; want nil\", err)\n+\t\t\t}\n+\t\t\tif test.want == nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif desc == nil {\n+\t\t\t\tt.Fatalf(\"got nil DataDescriptor; want non-nil\")\n+\t\t\t}\n+\t\t\tif desc.crc32 != test.want.crc32 {\n+\t\t\t\tt.Errorf(\"got CRC32 %#x; want %#x\", desc.crc32, test.want.crc32)\n+\t\t\t}\n+\t\t\tif desc.compressedSize != test.want.compressedSize {\n+\t\t\t\tt.Errorf(\"got CompressedSize %#x; want %#x\", desc.compressedSize, test.want.compressedSize)\n+\t\t\t}\n+\t\t\tif desc.uncompressedSize != test.want.uncompressedSize {\n+\t\t\t\tt.Errorf(\"got UncompressedSize %#x; want %#x\", desc.uncompressedSize, test.want.uncompressedSize)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n func TestCVE202133196(t *testing.T) {\n \t// Archive that indicates it has 1 << 128 -1 files,\n \t// this would previously cause a panic due to attempting"}, {"sha": "ff9f605eb697eec319602d455917953b70b906e6", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -42,7 +42,7 @@ const (\n \tdirectoryHeaderLen       = 46         // + filename + extra + comment\n \tdirectoryEndLen          = 22         // + comment\n \tdataDescriptorLen        = 16         // four uint32: descriptor signature, crc32, compressed size, size\n-\tdataDescriptor64Len      = 24         // descriptor with 8 byte sizes\n+\tdataDescriptor64Len      = 24         // two uint32: signature, crc32 | two uint64: compressed size, size\n \tdirectory64LocLen        = 20         //\n \tdirectory64EndLen        = 56         // + extra\n \n@@ -315,6 +315,10 @@ func (h *FileHeader) isZip64() bool {\n \treturn h.CompressedSize64 >= uint32max || h.UncompressedSize64 >= uint32max\n }\n \n+func (f *FileHeader) hasDataDescriptor() bool {\n+\treturn f.Flags&0x8 != 0\n+}\n+\n func msdosModeToFileMode(m uint32) (mode fs.FileMode) {\n \tif m&msdosDir != 0 {\n \t\tmode = fs.ModeDir | 0777\n@@ -341,11 +345,9 @@ func fileModeToUnixMode(mode fs.FileMode) uint32 {\n \tcase fs.ModeSocket:\n \t\tm = s_IFSOCK\n \tcase fs.ModeDevice:\n-\t\tif mode&fs.ModeCharDevice != 0 {\n-\t\t\tm = s_IFCHR\n-\t\t} else {\n-\t\t\tm = s_IFBLK\n-\t\t}\n+\t\tm = s_IFBLK\n+\tcase fs.ModeDevice | fs.ModeCharDevice:\n+\t\tm = s_IFCHR\n \t}\n \tif mode&fs.ModeSetuid != 0 {\n \t\tm |= s_ISUID\n@@ -388,3 +390,11 @@ func unixModeToFileMode(m uint32) fs.FileMode {\n \t}\n \treturn mode\n }\n+\n+// dataDescriptor holds the data descriptor that optionally follows the file\n+// contents in the zip file.\n+type dataDescriptor struct {\n+\tcrc32            uint32\n+\tcompressedSize   uint64\n+\tuncompressedSize uint64\n+}"}, {"sha": "3b23cc3391d9e676a6735266fa8bb76a73ace755", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 114, "deletions": 21, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -37,6 +37,7 @@ type Writer struct {\n type header struct {\n \t*FileHeader\n \toffset uint64\n+\traw    bool\n }\n \n // NewWriter returns a new Writer writing a zip file to w.\n@@ -245,22 +246,31 @@ func detectUTF8(s string) (valid, require bool) {\n \treturn true, require\n }\n \n+// prepare performs the bookkeeping operations required at the start of\n+// CreateHeader and CreateRaw.\n+func (w *Writer) prepare(fh *FileHeader) error {\n+\tif w.last != nil && !w.last.closed {\n+\t\tif err := w.last.close(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tif len(w.dir) > 0 && w.dir[len(w.dir)-1].FileHeader == fh {\n+\t\t// See https://golang.org/issue/11144 confusion.\n+\t\treturn errors.New(\"archive/zip: invalid duplicate FileHeader\")\n+\t}\n+\treturn nil\n+}\n+\n // CreateHeader adds a file to the zip archive using the provided FileHeader\n // for the file metadata. Writer takes ownership of fh and may mutate\n // its fields. The caller must not modify fh after calling CreateHeader.\n //\n // This returns a Writer to which the file contents should be written.\n // The file's contents must be written to the io.Writer before the next\n-// call to Create, CreateHeader, or Close.\n+// call to Create, CreateHeader, CreateRaw, or Close.\n func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n-\tif w.last != nil && !w.last.closed {\n-\t\tif err := w.last.close(); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\tif len(w.dir) > 0 && w.dir[len(w.dir)-1].FileHeader == fh {\n-\t\t// See https://golang.org/issue/11144 confusion.\n-\t\treturn nil, errors.New(\"archive/zip: invalid duplicate FileHeader\")\n+\tif err := w.prepare(fh); err != nil {\n+\t\treturn nil, err\n \t}\n \n \t// The ZIP format has a sad state of affairs regarding character encoding.\n@@ -365,15 +375,15 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \t\tow = fw\n \t}\n \tw.dir = append(w.dir, h)\n-\tif err := writeHeader(w.cw, fh); err != nil {\n+\tif err := writeHeader(w.cw, h); err != nil {\n \t\treturn nil, err\n \t}\n \t// If we're creating a directory, fw is nil.\n \tw.last = fw\n \treturn ow, nil\n }\n \n-func writeHeader(w io.Writer, h *FileHeader) error {\n+func writeHeader(w io.Writer, h *header) error {\n \tconst maxUint16 = 1<<16 - 1\n \tif len(h.Name) > maxUint16 {\n \t\treturn errLongName\n@@ -390,9 +400,20 @@ func writeHeader(w io.Writer, h *FileHeader) error {\n \tb.uint16(h.Method)\n \tb.uint16(h.ModifiedTime)\n \tb.uint16(h.ModifiedDate)\n-\tb.uint32(0) // since we are writing a data descriptor crc32,\n-\tb.uint32(0) // compressed size,\n-\tb.uint32(0) // and uncompressed size should be zero\n+\t// In raw mode (caller does the compression), the values are either\n+\t// written here or in the trailing data descriptor based on the header\n+\t// flags.\n+\tif h.raw && !h.hasDataDescriptor() {\n+\t\tb.uint32(h.CRC32)\n+\t\tb.uint32(uint32(min64(h.CompressedSize64, uint32max)))\n+\t\tb.uint32(uint32(min64(h.UncompressedSize64, uint32max)))\n+\t} else {\n+\t\t// When this package handle the compression, these values are\n+\t\t// always written to the trailing data descriptor.\n+\t\tb.uint32(0) // crc32\n+\t\tb.uint32(0) // compressed size\n+\t\tb.uint32(0) // uncompressed size\n+\t}\n \tb.uint16(uint16(len(h.Name)))\n \tb.uint16(uint16(len(h.Extra)))\n \tif _, err := w.Write(buf[:]); err != nil {\n@@ -405,6 +426,65 @@ func writeHeader(w io.Writer, h *FileHeader) error {\n \treturn err\n }\n \n+func min64(x, y uint64) uint64 {\n+\tif x < y {\n+\t\treturn x\n+\t}\n+\treturn y\n+}\n+\n+// CreateRaw adds a file to the zip archive using the provided FileHeader and\n+// returns a Writer to which the file contents should be written. The file's\n+// contents must be written to the io.Writer before the next call to Create,\n+// CreateHeader, CreateRaw, or Close.\n+//\n+// In contrast to CreateHeader, the bytes passed to Writer are not compressed.\n+func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error) {\n+\tif err := w.prepare(fh); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfh.CompressedSize = uint32(min64(fh.CompressedSize64, uint32max))\n+\tfh.UncompressedSize = uint32(min64(fh.UncompressedSize64, uint32max))\n+\n+\th := &header{\n+\t\tFileHeader: fh,\n+\t\toffset:     uint64(w.cw.count),\n+\t\traw:        true,\n+\t}\n+\tw.dir = append(w.dir, h)\n+\tif err := writeHeader(w.cw, h); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif strings.HasSuffix(fh.Name, \"/\") {\n+\t\tw.last = nil\n+\t\treturn dirWriter{}, nil\n+\t}\n+\n+\tfw := &fileWriter{\n+\t\theader: h,\n+\t\tzipw:   w.cw,\n+\t}\n+\tw.last = fw\n+\treturn fw, nil\n+}\n+\n+// Copy copies the file f (obtained from a Reader) into w. It copies the raw\n+// form directly bypassing decompression, compression, and validation.\n+func (w *Writer) Copy(f *File) error {\n+\tr, err := f.OpenRaw()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfw, err := w.CreateRaw(&f.FileHeader)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = io.Copy(fw, r)\n+\treturn err\n+}\n+\n // RegisterCompressor registers or overrides a custom compressor for a specific\n // method ID. If a compressor for a given method is not found, Writer will\n // default to looking up the compressor at the package level.\n@@ -446,6 +526,9 @@ func (w *fileWriter) Write(p []byte) (int, error) {\n \tif w.closed {\n \t\treturn 0, errors.New(\"zip: write to closed file\")\n \t}\n+\tif w.raw {\n+\t\treturn w.zipw.Write(p)\n+\t}\n \tw.crc32.Write(p)\n \treturn w.rawCount.Write(p)\n }\n@@ -455,6 +538,9 @@ func (w *fileWriter) close() error {\n \t\treturn errors.New(\"zip: file closed twice\")\n \t}\n \tw.closed = true\n+\tif w.raw {\n+\t\treturn w.writeDataDescriptor()\n+\t}\n \tif err := w.comp.Close(); err != nil {\n \t\treturn err\n \t}\n@@ -474,26 +560,33 @@ func (w *fileWriter) close() error {\n \t\tfh.UncompressedSize = uint32(fh.UncompressedSize64)\n \t}\n \n+\treturn w.writeDataDescriptor()\n+}\n+\n+func (w *fileWriter) writeDataDescriptor() error {\n+\tif !w.hasDataDescriptor() {\n+\t\treturn nil\n+\t}\n \t// Write data descriptor. This is more complicated than one would\n \t// think, see e.g. comments in zipfile.c:putextended() and\n \t// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7073588.\n \t// The approach here is to write 8 byte sizes if needed without\n \t// adding a zip64 extra in the local header (too late anyway).\n \tvar buf []byte\n-\tif fh.isZip64() {\n+\tif w.isZip64() {\n \t\tbuf = make([]byte, dataDescriptor64Len)\n \t} else {\n \t\tbuf = make([]byte, dataDescriptorLen)\n \t}\n \tb := writeBuf(buf)\n \tb.uint32(dataDescriptorSignature) // de-facto standard, required by OS X\n-\tb.uint32(fh.CRC32)\n-\tif fh.isZip64() {\n-\t\tb.uint64(fh.CompressedSize64)\n-\t\tb.uint64(fh.UncompressedSize64)\n+\tb.uint32(w.CRC32)\n+\tif w.isZip64() {\n+\t\tb.uint64(w.CompressedSize64)\n+\t\tb.uint64(w.UncompressedSize64)\n \t} else {\n-\t\tb.uint32(fh.CompressedSize)\n-\t\tb.uint32(fh.UncompressedSize)\n+\t\tb.uint32(w.CompressedSize)\n+\t\tb.uint32(w.UncompressedSize)\n \t}\n \t_, err := w.zipw.Write(buf)\n \treturn err"}, {"sha": "97c6c5297994684ca7fcfc5ccc492025709d795c", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 182, "deletions": 3, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -6,8 +6,10 @@ package zip\n \n import (\n \t\"bytes\"\n+\t\"compress/flate\"\n \t\"encoding/binary\"\n \t\"fmt\"\n+\t\"hash/crc32\"\n \t\"io\"\n \t\"io/fs\"\n \t\"math/rand\"\n@@ -57,6 +59,18 @@ var writeTests = []WriteTest{\n \t\tMethod: Deflate,\n \t\tMode:   0755 | fs.ModeSymlink,\n \t},\n+\t{\n+\t\tName:   \"device\",\n+\t\tData:   []byte(\"device file\"),\n+\t\tMethod: Deflate,\n+\t\tMode:   0755 | fs.ModeDevice,\n+\t},\n+\t{\n+\t\tName:   \"chardevice\",\n+\t\tData:   []byte(\"char device file\"),\n+\t\tMethod: Deflate,\n+\t\tMode:   0755 | fs.ModeDevice | fs.ModeCharDevice,\n+\t},\n }\n \n func TestWriter(t *testing.T) {\n@@ -353,6 +367,171 @@ func TestWriterDirAttributes(t *testing.T) {\n \t}\n }\n \n+func TestWriterCopy(t *testing.T) {\n+\t// make a zip file\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\tfor _, wt := range writeTests {\n+\t\ttestCreate(t, w, &wt)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read it back\n+\tsrc, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, wt := range writeTests {\n+\t\ttestReadFile(t, src.File[i], &wt)\n+\t}\n+\n+\t// make a new zip file copying the old compressed data.\n+\tbuf2 := new(bytes.Buffer)\n+\tdst := NewWriter(buf2)\n+\tfor _, f := range src.File {\n+\t\tif err := dst.Copy(f); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\tif err := dst.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read the new one back\n+\tr, err := NewReader(bytes.NewReader(buf2.Bytes()), int64(buf2.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, wt := range writeTests {\n+\t\ttestReadFile(t, r.File[i], &wt)\n+\t}\n+}\n+\n+func TestWriterCreateRaw(t *testing.T) {\n+\tfiles := []struct {\n+\t\tname             string\n+\t\tcontent          []byte\n+\t\tmethod           uint16\n+\t\tflags            uint16\n+\t\tcrc32            uint32\n+\t\tuncompressedSize uint64\n+\t\tcompressedSize   uint64\n+\t}{\n+\t\t{\n+\t\t\tname:    \"small store w desc\",\n+\t\t\tcontent: []byte(\"gophers\"),\n+\t\t\tmethod:  Store,\n+\t\t\tflags:   0x8,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"small deflate wo desc\",\n+\t\t\tcontent: bytes.Repeat([]byte(\"abcdefg\"), 2048),\n+\t\t\tmethod:  Deflate,\n+\t\t},\n+\t}\n+\n+\t// write a zip file\n+\tarchive := new(bytes.Buffer)\n+\tw := NewWriter(archive)\n+\n+\tfor i := range files {\n+\t\tf := &files[i]\n+\t\tf.crc32 = crc32.ChecksumIEEE(f.content)\n+\t\tsize := uint64(len(f.content))\n+\t\tf.uncompressedSize = size\n+\t\tf.compressedSize = size\n+\n+\t\tvar compressedContent []byte\n+\t\tif f.method == Deflate {\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tw, err := flate.NewWriter(&buf, flate.BestSpeed)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"flate.NewWriter err = %v\", err)\n+\t\t\t}\n+\t\t\t_, err = w.Write(f.content)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"flate Write err = %v\", err)\n+\t\t\t}\n+\t\t\terr = w.Close()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"flate Writer.Close err = %v\", err)\n+\t\t\t}\n+\t\t\tcompressedContent = buf.Bytes()\n+\t\t\tf.compressedSize = uint64(len(compressedContent))\n+\t\t}\n+\n+\t\th := &FileHeader{\n+\t\t\tName:               f.name,\n+\t\t\tMethod:             f.method,\n+\t\t\tFlags:              f.flags,\n+\t\t\tCRC32:              f.crc32,\n+\t\t\tCompressedSize64:   f.compressedSize,\n+\t\t\tUncompressedSize64: f.uncompressedSize,\n+\t\t}\n+\t\tw, err := w.CreateRaw(h)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif compressedContent != nil {\n+\t\t\t_, err = w.Write(compressedContent)\n+\t\t} else {\n+\t\t\t_, err = w.Write(f.content)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%s Write got %v; want nil\", f.name, err)\n+\t\t}\n+\t}\n+\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read it back\n+\tr, err := NewReader(bytes.NewReader(archive.Bytes()), int64(archive.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, want := range files {\n+\t\tgot := r.File[i]\n+\t\tif got.Name != want.name {\n+\t\t\tt.Errorf(\"got Name %s; want %s\", got.Name, want.name)\n+\t\t}\n+\t\tif got.Method != want.method {\n+\t\t\tt.Errorf(\"%s: got Method %#x; want %#x\", want.name, got.Method, want.method)\n+\t\t}\n+\t\tif got.Flags != want.flags {\n+\t\t\tt.Errorf(\"%s: got Flags %#x; want %#x\", want.name, got.Flags, want.flags)\n+\t\t}\n+\t\tif got.CRC32 != want.crc32 {\n+\t\t\tt.Errorf(\"%s: got CRC32 %#x; want %#x\", want.name, got.CRC32, want.crc32)\n+\t\t}\n+\t\tif got.CompressedSize64 != want.compressedSize {\n+\t\t\tt.Errorf(\"%s: got CompressedSize64 %d; want %d\", want.name, got.CompressedSize64, want.compressedSize)\n+\t\t}\n+\t\tif got.UncompressedSize64 != want.uncompressedSize {\n+\t\t\tt.Errorf(\"%s: got UncompressedSize64 %d; want %d\", want.name, got.UncompressedSize64, want.uncompressedSize)\n+\t\t}\n+\n+\t\tr, err := got.Open()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: Open err = %v\", got.Name, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tbuf, err := io.ReadAll(r)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: ReadAll err = %v\", got.Name, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif !bytes.Equal(buf, want.content) {\n+\t\t\tt.Errorf(\"%v: ReadAll returned unexpected bytes\", got.Name)\n+\t\t}\n+\t}\n+}\n+\n func testCreate(t *testing.T, w *Writer, wt *WriteTest) {\n \theader := &FileHeader{\n \t\tName:   wt.Name,\n@@ -378,15 +557,15 @@ func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n \ttestFileMode(t, f, wt.Mode)\n \trc, err := f.Open()\n \tif err != nil {\n-\t\tt.Fatal(\"opening:\", err)\n+\t\tt.Fatalf(\"opening %s: %v\", f.Name, err)\n \t}\n \tb, err := io.ReadAll(rc)\n \tif err != nil {\n-\t\tt.Fatal(\"reading:\", err)\n+\t\tt.Fatalf(\"reading %s: %v\", f.Name, err)\n \t}\n \terr = rc.Close()\n \tif err != nil {\n-\t\tt.Fatal(\"closing:\", err)\n+\t\tt.Fatalf(\"closing %s: %v\", f.Name, err)\n \t}\n \tif !bytes.Equal(b, wt.Data) {\n \t\tt.Errorf(\"File contents %q, want %q\", b, wt.Data)"}, {"sha": "ec928e7ad69ed54d213d3a38d9efb011ff32eb82", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -670,7 +670,8 @@ func (b *Writer) WriteByte(c byte) error {\n // WriteRune writes a single Unicode code point, returning\n // the number of bytes written and any error.\n func (b *Writer) WriteRune(r rune) (size int, err error) {\n-\tif r < utf8.RuneSelf {\n+\t// Compare as uint32 to correctly handle negative runes.\n+\tif uint32(r) < utf8.RuneSelf {\n \t\terr = b.WriteByte(byte(r))\n \t\tif err != nil {\n \t\t\treturn 0, err"}, {"sha": "ebcc711db9d48cdefa44d6ec9bddd2406c13b59d", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -534,6 +534,20 @@ func TestReadWriteRune(t *testing.T) {\n \t}\n }\n \n+func TestWriteInvalidRune(t *testing.T) {\n+\t// Invalid runes, including negative ones, should be written as the\n+\t// replacement character.\n+\tfor _, r := range []rune{-1, utf8.MaxRune + 1} {\n+\t\tvar buf bytes.Buffer\n+\t\tw := NewWriter(&buf)\n+\t\tw.WriteRune(r)\n+\t\tw.Flush()\n+\t\tif s := buf.String(); s != \"\\uFFFD\" {\n+\t\t\tt.Errorf(\"WriteRune(%d) wrote %q, not replacement character\", r, s)\n+\t\t}\n+\t}\n+}\n+\n func TestReadStringAllocs(t *testing.T) {\n \tr := strings.NewReader(\"       foo       foo        42        42        42        42        42        42        42        42       4.2       4.2       4.2       4.2\\n\")\n \tbuf := NewReader(r)"}, {"sha": "4846d4f733677777a50e24d971cdf643954d4f23", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -48,7 +48,8 @@ type Scanner struct {\n // and the next token to return to the user, if any, plus an error, if any.\n //\n // Scanning stops if the function returns an error, in which case some of\n-// the input may be discarded.\n+// the input may be discarded. If that error is ErrFinalToken, scanning\n+// stops with no error.\n //\n // Otherwise, the Scanner advances the input. If the token is not nil,\n // the Scanner returns it to the user. If the token is nil, the"}, {"sha": "5a47526593b093678b85e0c45c2dfbd5a42d16ed", "filename": "libgo/go/bytes/boundary_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fboundary_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n //\n+//go:build linux\n // +build linux\n \n package bytes_test"}, {"sha": "549b077708f80e3742e79b0e93e29d3432d3c6c7", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -275,7 +275,8 @@ func (b *Buffer) WriteByte(c byte) error {\n // included to match bufio.Writer's WriteRune. The buffer is grown as needed;\n // if it becomes too large, WriteRune will panic with ErrTooLarge.\n func (b *Buffer) WriteRune(r rune) (n int, err error) {\n-\tif r < utf8.RuneSelf {\n+\t// Compare as uint32 to correctly handle negative runes.\n+\tif uint32(r) < utf8.RuneSelf {\n \t\tb.WriteByte(byte(r))\n \t\treturn 1, nil\n \t}"}, {"sha": "9c9b7440ffaa753625a365534a2c7ec30baf4ff2", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"math/rand\"\n \t\"testing\"\n@@ -387,6 +388,16 @@ func TestRuneIO(t *testing.T) {\n \t}\n }\n \n+func TestWriteInvalidRune(t *testing.T) {\n+\t// Invalid runes, including negative ones, should be written as\n+\t// utf8.RuneError.\n+\tfor _, r := range []rune{-1, utf8.MaxRune + 1} {\n+\t\tvar buf Buffer\n+\t\tbuf.WriteRune(r)\n+\t\tcheck(t, fmt.Sprintf(\"TestWriteInvalidRune (%d)\", r), &buf, \"\\uFFFD\")\n+\t}\n+}\n+\n func TestNext(t *testing.T) {\n \tb := []byte{0, 1, 2, 3, 4}\n \ttmp := make([]byte, 5)"}, {"sha": "a6787f640501133173e82804d1a2c1fc289504a5", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -387,6 +387,9 @@ and of course there is nothing stopping the C code from doing anything\n it likes. However, programs that break these rules are likely to fail\n in unexpected and unpredictable ways.\n \n+The runtime/cgo.Handle type can be used to safely pass Go values\n+between Go and C. See the runtime/cgo package documentation for details.\n+\n Note: the current implementation has a bug. While Go code is permitted\n to write nil or a C pointer (but not a Go pointer) to C memory, the\n current implementation may sometimes cause a runtime error if the"}, {"sha": "de64a75f710485894d543ba761277eb963b12ebe", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -927,7 +927,7 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \tvar sbCheck bytes.Buffer\n \tfor i, param := range params {\n \t\torigArg := args[i]\n-\t\targ, nu := p.mangle(f, &args[i])\n+\t\targ, nu := p.mangle(f, &args[i], true)\n \t\tif nu {\n \t\t\tneedsUnsafe = true\n \t\t}\n@@ -970,7 +970,7 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \t\tsb.WriteString(\"return \")\n \t}\n \n-\tm, nu := p.mangle(f, &call.Call.Fun)\n+\tm, nu := p.mangle(f, &call.Call.Fun, false)\n \tif nu {\n \t\tneedsUnsafe = true\n \t}\n@@ -1104,7 +1104,8 @@ func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {\n // rewriting calls when it finds them.\n // It removes the corresponding references in f.Ref and f.Calls, so that we\n // don't try to do the replacement again in rewriteRef or rewriteCall.\n-func (p *Package) mangle(f *File, arg *ast.Expr) (ast.Expr, bool) {\n+// If addPosition is true, add position info to the idents of C names in arg.\n+func (p *Package) mangle(f *File, arg *ast.Expr, addPosition bool) (ast.Expr, bool) {\n \tneedsUnsafe := false\n \tf.walk(arg, ctxExpr, func(f *File, arg interface{}, context astContext) {\n \t\tpx, ok := arg.(*ast.Expr)\n@@ -1119,7 +1120,7 @@ func (p *Package) mangle(f *File, arg *ast.Expr) (ast.Expr, bool) {\n \n \t\t\tfor _, r := range f.Ref {\n \t\t\t\tif r.Expr == px {\n-\t\t\t\t\t*px = p.rewriteName(f, r)\n+\t\t\t\t\t*px = p.rewriteName(f, r, addPosition)\n \t\t\t\t\tr.Done = true\n \t\t\t\t\tbreak\n \t\t\t\t}\n@@ -1379,7 +1380,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t}\n \t\t}\n \n-\t\texpr := p.rewriteName(f, r)\n+\t\texpr := p.rewriteName(f, r, false)\n \n \t\tif *godefs {\n \t\t\t// Substitute definition for mangled type name.\n@@ -1442,8 +1443,23 @@ func (p *Package) rewriteRef(f *File) {\n }\n \n // rewriteName returns the expression used to rewrite a reference.\n-func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n-\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n+// If addPosition is true, add position info in the ident name.\n+func (p *Package) rewriteName(f *File, r *Ref, addPosition bool) ast.Expr {\n+\tgetNewIdent := ast.NewIdent\n+\tif addPosition {\n+\t\tgetNewIdent = func(newName string) *ast.Ident {\n+\t\t\tmangledIdent := ast.NewIdent(newName)\n+\t\t\tif len(newName) == len(r.Name.Go) {\n+\t\t\t\treturn mangledIdent\n+\t\t\t}\n+\t\t\tp := fset.Position((*r.Expr).End())\n+\t\t\tif p.Column == 0 {\n+\t\t\t\treturn mangledIdent\n+\t\t\t}\n+\t\t\treturn ast.NewIdent(fmt.Sprintf(\"%s /*line :%d:%d*/\", newName, p.Line, p.Column))\n+\t\t}\n+\t}\n+\tvar expr ast.Expr = getNewIdent(r.Name.Mangle) // default\n \tswitch r.Context {\n \tcase ctxCall, ctxCall2:\n \t\tif r.Name.Kind != \"func\" {\n@@ -1471,7 +1487,7 @@ func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n \t\t\t\tn.Mangle = \"_C2func_\" + n.Go\n \t\t\t\tf.Name[\"2\"+r.Name.Go] = n\n \t\t\t}\n-\t\t\texpr = ast.NewIdent(n.Mangle)\n+\t\t\texpr = getNewIdent(n.Mangle)\n \t\t\tr.Name = n\n \t\t\tbreak\n \t\t}\n@@ -1502,7 +1518,7 @@ func (p *Package) rewriteName(f *File, r *Ref) ast.Expr {\n \t\t\t// issue 7757.\n \t\t\texpr = &ast.CallExpr{\n \t\t\t\tFun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: \"_Cgo_ptr\"},\n-\t\t\t\tArgs: []ast.Expr{ast.NewIdent(name.Mangle)},\n+\t\t\t\tArgs: []ast.Expr{getNewIdent(name.Mangle)},\n \t\t\t}\n \t\tcase \"type\":\n \t\t\t// Okay - might be new(T)\n@@ -1584,9 +1600,17 @@ func (p *Package) gccMachine() []string {\n \tcase \"s390x\":\n \t\treturn []string{\"-m64\"}\n \tcase \"mips64\", \"mips64le\":\n-\t\treturn []string{\"-mabi=64\"}\n+\t\tif gomips64 == \"hardfloat\" {\n+\t\t\treturn []string{\"-mabi=64\", \"-mhard-float\"}\n+\t\t} else if gomips64 == \"softfloat\" {\n+\t\t\treturn []string{\"-mabi=64\", \"-msoft-float\"}\n+\t\t}\n \tcase \"mips\", \"mipsle\":\n-\t\treturn []string{\"-mabi=32\"}\n+\t\tif gomips == \"hardfloat\" {\n+\t\t\treturn []string{\"-mabi=32\", \"-mfp32\", \"-mhard-float\", \"-mno-odd-spreg\"}\n+\t\t} else if gomips == \"softfloat\" {\n+\t\t\treturn []string{\"-mabi=32\", \"-msoft-float\"}\n+\t\t}\n \tcase \"ppc64\":\n \t\tif goos == \"aix\" {\n \t\t\treturn []string{\"-maix64\"}\n@@ -1639,6 +1663,8 @@ func (p *Package) gccCmd() []string {\n \tif goos == \"aix\" {\n \t\tc = append(c, \"-mcmodel=large\")\n \t}\n+\t// disable LTO so we get an object whose symbols we can read\n+\tc = append(c, \"-fno-lto\")\n \tc = append(c, \"-\") //read input from standard input\n \treturn c\n }"}, {"sha": "40dc6d2562d0e36707894e29c72f644eba688938", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Cgo; see gmp.go for an overview.\n+// Cgo; see doc.go for an overview.\n \n // TODO(rsc):\n //\tEmit correct line number annotations.\n@@ -17,9 +17,11 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n+\t\"internal/buildcfg\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"runtime\"\n@@ -249,7 +251,7 @@ var importRuntimeCgo = flag.Bool(\"import_runtime_cgo\", true, \"import runtime/cgo\n var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generated code\")\n var trimpath = flag.String(\"trimpath\", \"\", \"applies supplied rewrites or trims prefixes to recorded source file paths\")\n \n-var goarch, goos string\n+var goarch, goos, gomips, gomips64 string\n \n func main() {\n \tobjabi.AddVersionFlag() // -V\n@@ -306,6 +308,14 @@ func main() {\n \n \tp := newPackage(args[:i])\n \n+\t// We need a C compiler to be available. Check this.\n+\tgccName := p.gccBaseCmd()[0]\n+\t_, err := exec.LookPath(gccName)\n+\tif err != nil {\n+\t\tfatalf(\"C compiler %q not found: %v\", gccName, err)\n+\t\tos.Exit(2)\n+\t}\n+\n \t// Record CGO_LDFLAGS from the environment for external linking.\n \tif ldflags := os.Getenv(\"CGO_LDFLAGS\"); ldflags != \"\" {\n \t\targs, err := splitQuoted(ldflags)\n@@ -409,6 +419,9 @@ func newPackage(args []string) *Package {\n \tif s := os.Getenv(\"GOOS\"); s != \"\" {\n \t\tgoos = s\n \t}\n+\tbuildcfg.Check()\n+\tgomips = buildcfg.GOMIPS\n+\tgomips64 = buildcfg.GOMIPS64\n \tptrSize := ptrSizeMap[goarch]\n \tif ptrSize == 0 {\n \t\tfatalf(\"unknown ptrSize for $GOARCH %q\", goarch)"}, {"sha": "3cf16f90f98099cfe44c7592ac6e9f12db307a89", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -173,8 +173,18 @@ func (p *Package) writeDefs() {\n \t\t\tif *gccgo {\n \t\t\t\tfmt.Fprintf(fc, \"extern byte *%s;\\n\", n.C)\n \t\t\t} else {\n-\t\t\t\tfmt.Fprintf(fm, \"extern char %s[];\\n\", n.C)\n-\t\t\t\tfmt.Fprintf(fm, \"void *_cgohack_%s = %s;\\n\\n\", n.C, n.C)\n+\t\t\t\t// Force a reference to all symbols so that\n+\t\t\t\t// the external linker will add DT_NEEDED\n+\t\t\t\t// entries as needed on ELF systems.\n+\t\t\t\t// Treat function variables differently\n+\t\t\t\t// to avoid type confict errors from LTO\n+\t\t\t\t// (Link Time Optimization).\n+\t\t\t\tif n.Kind == \"fpvar\" {\n+\t\t\t\t\tfmt.Fprintf(fm, \"extern void %s();\\n\", n.C)\n+\t\t\t\t} else {\n+\t\t\t\t\tfmt.Fprintf(fm, \"extern char %s[];\\n\", n.C)\n+\t\t\t\t\tfmt.Fprintf(fm, \"void *_cgohack_%s = %s;\\n\\n\", n.C, n.C)\n+\t\t\t\t}\n \t\t\t\tfmt.Fprintf(fgo2, \"//go:linkname __cgo_%s %s\\n\", n.C, n.C)\n \t\t\t\tfmt.Fprintf(fgo2, \"//go:cgo_import_static %s\\n\", n.C)\n \t\t\t\tfmt.Fprintf(fgo2, \"var __cgo_%s byte\\n\", n.C)\n@@ -1026,14 +1036,28 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t}\n \t\tfmt.Fprintf(fgcc, \"}\\n\")\n \n-\t\t// Build the wrapper function compiled by cmd/compile.\n-\t\t// This unpacks the argument struct above and calls the Go function.\n+\t\t// In internal linking mode, the Go linker sees both\n+\t\t// the C wrapper written above and the Go wrapper it\n+\t\t// references. Hence, export the C wrapper (e.g., for\n+\t\t// if we're building a shared object). The Go linker\n+\t\t// will resolve the C wrapper's reference to the Go\n+\t\t// wrapper without a separate export.\n \t\tfmt.Fprintf(fgo2, \"//go:cgo_export_dynamic %s\\n\", exp.ExpName)\n+\t\t// cgo_export_static refers to a symbol by its linker\n+\t\t// name, so set the linker name of the Go wrapper.\n \t\tfmt.Fprintf(fgo2, \"//go:linkname _cgoexp%s_%s _cgoexp%s_%s\\n\", cPrefix, exp.ExpName, cPrefix, exp.ExpName)\n+\t\t// In external linking mode, the Go linker sees the Go\n+\t\t// wrapper, but not the C wrapper. For this case,\n+\t\t// export the Go wrapper so the host linker can\n+\t\t// resolve the reference from the C wrapper to the Go\n+\t\t// wrapper.\n \t\tfmt.Fprintf(fgo2, \"//go:cgo_export_static _cgoexp%s_%s\\n\", cPrefix, exp.ExpName)\n+\n+\t\t// Build the wrapper function compiled by cmd/compile.\n+\t\t// This unpacks the argument struct above and calls the Go function.\n \t\tfmt.Fprintf(fgo2, \"func _cgoexp%s_%s(a *%s) {\\n\", cPrefix, exp.ExpName, gotype)\n \n-\t\tfmt.Fprintf(fm, \"int _cgoexp%s_%s;\\n\", cPrefix, exp.ExpName)\n+\t\tfmt.Fprintf(fm, \"void _cgoexp%s_%s(void* p){}\\n\", cPrefix, exp.ExpName)\n \n \t\tif gccResult != \"void\" {\n \t\t\t// Write results back to frame.\n@@ -1722,15 +1746,21 @@ typedef struct __go_open_array {\n struct __go_string __go_byte_array_to_string(const void* p, intgo len);\n struct __go_open_array __go_string_to_byte_array (struct __go_string str);\n \n+extern void runtime_throw(const char *);\n+\n const char *_cgoPREFIX_Cfunc_CString(struct __go_string s) {\n \tchar *p = malloc(s.__length+1);\n+\tif(p == NULL)\n+\t\truntime_throw(\"runtime: C malloc failed\");\n \tmemmove(p, s.__data, s.__length);\n \tp[s.__length] = 0;\n \treturn p;\n }\n \n void *_cgoPREFIX_Cfunc_CBytes(struct __go_open_array b) {\n \tchar *p = malloc(b.__count);\n+\tif(p == NULL)\n+\t\truntime_throw(\"runtime: C malloc failed\");\n \tmemmove(p, b.__values, b.__count);\n \treturn p;\n }\n@@ -1749,14 +1779,13 @@ Slice _cgoPREFIX_Cfunc_GoBytes(char *p, int32_t n) {\n \treturn __go_string_to_byte_array(s);\n }\n \n-extern void runtime_throw(const char *);\n void *_cgoPREFIX_Cfunc__CMalloc(size_t n) {\n-        void *p = malloc(n);\n-        if(p == NULL && n == 0)\n-                p = malloc(1);\n-        if(p == NULL)\n-                runtime_throw(\"runtime: C malloc failed\");\n-        return p;\n+\tvoid *p = malloc(n);\n+\tif(p == NULL && n == 0)\n+\t\tp = malloc(1);\n+\tif(p == NULL)\n+\t\truntime_throw(\"runtime: C malloc failed\");\n+\treturn p;\n }\n \n struct __go_type_descriptor;"}, {"sha": "cd03968eedcf618d0ecef8da89ce790646dba399", "filename": "libgo/go/cmd/go.mod", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo.mod?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1,12 +1,15 @@\n module cmd\n \n-go 1.16\n+go 1.17\n \n require (\n-\tgithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2\n-\tgolang.org/x/arch v0.0.0-20201008161808-52c3e6f60cff\n-\tgolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897\n-\tgolang.org/x/mod v0.4.2-0.20210325185522-dbbbf8a3c6ea\n-\tgolang.org/x/sys v0.0.0-20201204225414-ed752295db88 // indirect\n-\tgolang.org/x/tools v0.0.0-20210107193943-4ed967dd8eff\n+\tgithub.com/google/pprof v0.0.0-20210506205249-923b5ab0fc1a\n+\tgithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639 // indirect\n+\tgolang.org/x/arch v0.0.0-20210502124803-cbf565b21d1e\n+\tgolang.org/x/crypto v0.0.0-20210503195802-e9a32991a82e // indirect\n+\tgolang.org/x/mod v0.4.3-0.20210608190319-0f08993efd8a\n+\tgolang.org/x/sys v0.0.0-20210511113859-b0526f3d8744 // indirect\n+\tgolang.org/x/term v0.0.0-20210503060354-a79de5458b56\n+\tgolang.org/x/tools v0.1.2-0.20210519160823-49064d2332f9\n+\tgolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect\n )"}, {"sha": "7f88d3216cf080a9573026997231cc608a801589", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 91, "deletions": 60, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -111,7 +111,7 @@\n // \t-p n\n // \t\tthe number of programs, such as build commands or\n // \t\ttest binaries, that can be run in parallel.\n-// \t\tThe default is the number of CPUs available.\n+// \t\tThe default is GOMAXPROCS, normally the number of CPUs available.\n // \t-race\n // \t\tenable data race detection.\n // \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n@@ -174,8 +174,8 @@\n // \t\ta build will run as if the disk file path exists with the contents\n // \t\tgiven by the backing file paths, or as if the disk file path does not\n // \t\texist if its backing file path is empty. Support for the -overlay flag\n-// \t\thas some limitations:importantly, cgo files included from outside the\n-// \t\tinclude path must be  in the same directory as the Go package they are\n+// \t\thas some limitations: importantly, cgo files included from outside the\n+// \t\tinclude path must be in the same directory as the Go package they are\n // \t\tincluded from, and overlays will not appear when binaries and tests are\n // \t\trun through go run and go test respectively.\n // \t-pkgdir dir\n@@ -198,6 +198,8 @@\n // \t\ta program to use to invoke toolchain programs like vet and asm.\n // \t\tFor example, instead of running asm, the go command will run\n // \t\t'cmd args /path/to/asm <arguments for asm>'.\n+// \t\tThe TOOLEXEC_IMPORTPATH environment variable will be set,\n+// \t\tmatching 'go list -f {{.ImportPath}}' for the package being built.\n //\n // The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a\n // space-separated list of arguments to pass to an underlying tool\n@@ -291,7 +293,7 @@\n //\n // Usage:\n //\n-// \tgo doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\n+// \tgo doc [doc flags] [package|[package.]symbol[.methodOrField]]\n //\n // Doc prints the documentation comments associated with the item identified by its\n // arguments (a package, const, func, type, var, method, or struct field)\n@@ -596,7 +598,7 @@\n //\n // Usage:\n //\n-// \tgo get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\n+// \tgo get [-d] [-t] [-u] [-v] [build flags] [packages]\n //\n // Get resolves its command-line arguments to packages at specific module versions,\n // updates go.mod to require those versions, downloads source code into the\n@@ -641,14 +643,6 @@\n // When the -t and -u flags are used together, get will update\n // test dependencies as well.\n //\n-// The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP, and also bypassess\n-// module sum validation using the checksum database. Use with caution.\n-// This flag is deprecated and will be removed in a future version of go.\n-// To permit the use of insecure schemes, use the GOINSECURE environment\n-// variable instead. To bypass module sum validation, use GOPRIVATE or\n-// GONOSUMDB. See 'go help environment' for details.\n-//\n // The -d flag instructs get not to build or install packages. get will only\n // update go.mod and download source code needed to build packages.\n //\n@@ -849,6 +843,7 @@\n //         UseAllFiles   bool     // use files regardless of +build lines, file names\n //         Compiler      string   // compiler to assume when computing target paths\n //         BuildTags     []string // build constraints to match in +build lines\n+//         ToolTags      []string // toolchain-specific build constraints\n //         ReleaseTags   []string // releases the current release is compatible with\n //         InstallSuffix string   // suffix to use in the name of the install dir\n //     }\n@@ -1083,7 +1078,7 @@\n //\n // Usage:\n //\n-// \tgo mod edit [editing flags] [go.mod]\n+// \tgo mod edit [editing flags] [-fmt|-print|-json] [go.mod]\n //\n // Edit provides a command-line interface for editing go.mod,\n // for use primarily by tools or scripts. It reads only go.mod;\n@@ -1142,19 +1137,24 @@\n // writing it back to go.mod. The JSON output corresponds to these Go types:\n //\n // \ttype Module struct {\n-// \t\tPath string\n+// \t\tPath    string\n // \t\tVersion string\n // \t}\n //\n // \ttype GoMod struct {\n-// \t\tModule  Module\n+// \t\tModule  ModPath\n // \t\tGo      string\n // \t\tRequire []Require\n // \t\tExclude []Module\n // \t\tReplace []Replace\n // \t\tRetract []Retract\n // \t}\n //\n+// \ttype ModPath struct {\n+// \t\tPath       string\n+// \t\tDeprecated string\n+// \t}\n+//\n // \ttype Require struct {\n // \t\tPath string\n // \t\tVersion string\n@@ -1186,21 +1186,25 @@\n //\n // Usage:\n //\n-// \tgo mod graph\n+// \tgo mod graph [-go=version]\n //\n // Graph prints the module requirement graph (with replacements applied)\n // in text form. Each line in the output has two space-separated fields: a module\n // and one of its requirements. Each module is identified as a string of the form\n // path@version, except for the main module, which has no @version suffix.\n //\n+// The -go flag causes graph to report the module graph as loaded by the\n+// given Go version, instead of the version indicated by the 'go' directive\n+// in the go.mod file.\n+//\n // See https://golang.org/ref/mod#go-mod-graph for more about 'go mod graph'.\n //\n //\n // Initialize new module in current directory\n //\n // Usage:\n //\n-// \tgo mod init [module]\n+// \tgo mod init [module-path]\n //\n // Init initializes and writes a new go.mod file in the current directory, in\n // effect creating a new module rooted at the current directory. The go.mod file\n@@ -1221,7 +1225,7 @@\n //\n // Usage:\n //\n-// \tgo mod tidy [-e] [-v]\n+// \tgo mod tidy [-e] [-v] [-go=version] [-compat=version]\n //\n // Tidy makes sure go.mod matches the source code in the module.\n // It adds any missing modules necessary to build the current module's\n@@ -1235,6 +1239,20 @@\n // The -e flag causes tidy to attempt to proceed despite errors\n // encountered while loading packages.\n //\n+// The -go flag causes tidy to update the 'go' directive in the go.mod\n+// file to the given version, which may change which module dependencies\n+// are retained as explicit requirements in the go.mod file.\n+// (Go versions 1.17 and higher retain more requirements in order to\n+// support lazy module loading.)\n+//\n+// The -compat flag preserves any additional checksums needed for the\n+// 'go' command from the indicated major Go release to successfully load\n+// the module graph, and causes tidy to error out if that version of the\n+// 'go' command would load any imported package from a different module\n+// version. By default, tidy acts as if the -compat flag were set to the\n+// version prior to the one indicated by the 'go' directive in the go.mod\n+// file.\n+//\n // See https://golang.org/ref/mod#go-mod-tidy for more about 'go mod tidy'.\n //\n //\n@@ -1318,10 +1336,21 @@\n // \tgo run [build flags] [-exec xprog] package [arguments...]\n //\n // Run compiles and runs the named main Go package.\n-// Typically the package is specified as a list of .go source files from a single directory,\n-// but it may also be an import path, file system path, or pattern\n+// Typically the package is specified as a list of .go source files from a single\n+// directory, but it may also be an import path, file system path, or pattern\n // matching a single known package, as in 'go run .' or 'go run my/cmd'.\n //\n+// If the package argument has a version suffix (like @latest or @v1.0.0),\n+// \"go run\" builds the program in module-aware mode, ignoring the go.mod file in\n+// the current directory or any parent directory, if there is one. This is useful\n+// for running programs without affecting the dependencies of the main module.\n+//\n+// If the package argument doesn't have a version suffix, \"go run\" may run in\n+// module-aware mode or GOPATH mode, depending on the GO111MODULE environment\n+// variable and the presence of a go.mod file. See 'go help modules' for details.\n+// If module-aware mode is enabled, \"go run\" runs in the context of the main\n+// module.\n+//\n // By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n // If the -exec flag is given, 'go run' invokes the binary using xprog:\n // \t'xprog a.out arguments...'.\n@@ -1416,8 +1445,8 @@\n //\n // The rule for a match in the cache is that the run involves the same\n // test binary and the flags on the command line come entirely from a\n-// restricted set of 'cacheable' test flags, defined as -cpu, -list,\n-// -parallel, -run, -short, and -v. If a run of go test has any test\n+// restricted set of 'cacheable' test flags, defined as -benchtime, -cpu,\n+// -list, -parallel, -run, -short, and -v. If a run of go test has any test\n // or non-test flags outside this set, the result is not cached. To\n // disable test caching, use any test flag or argument other than the\n // cacheable flags. The idiomatic way to disable test caching explicitly\n@@ -1543,38 +1572,28 @@\n //\n // A build constraint, also known as a build tag, is a line comment that begins\n //\n-// \t// +build\n+// \t//go:build\n //\n // that lists the conditions under which a file should be included in the package.\n // Constraints may appear in any kind of source file (not just Go), but\n // they must appear near the top of the file, preceded\n // only by blank lines and other line comments. These rules mean that in Go\n // files a build constraint must appear before the package clause.\n //\n-// To distinguish build constraints from package documentation, a series of\n-// build constraints must be followed by a blank line.\n-//\n-// A build constraint is evaluated as the OR of space-separated options.\n-// Each option evaluates as the AND of its comma-separated terms.\n-// Each term consists of letters, digits, underscores, and dots.\n-// A term may be negated with a preceding !.\n-// For example, the build constraint:\n-//\n-// \t// +build linux,386 darwin,!cgo\n-//\n-// corresponds to the boolean formula:\n+// To distinguish build constraints from package documentation,\n+// a build constraint should be followed by a blank line.\n //\n-// \t(linux AND 386) OR (darwin AND (NOT cgo))\n+// A build constraint is evaluated as an expression containing options\n+// combined by ||, &&, and ! operators and parentheses. Operators have\n+// the same meaning as in Go.\n //\n-// A file may have multiple build constraints. The overall constraint is the AND\n-// of the individual constraints. That is, the build constraints:\n+// For example, the following build constraint constrains a file to\n+// build when the \"linux\" and \"386\" constraints are satisfied, or when\n+// \"darwin\" is satisfied and \"cgo\" is not:\n //\n-// \t// +build linux darwin\n-// \t// +build amd64\n+// \t//go:build (linux && 386) || (darwin && !cgo)\n //\n-// corresponds to the boolean formula:\n-//\n-// \t(linux OR darwin) AND amd64\n+// It is an error for a file to have more than one //go:build line.\n //\n // During a particular build, the following words are satisfied:\n //\n@@ -1612,24 +1631,28 @@\n //\n // To keep a file from being considered for the build:\n //\n-// \t// +build ignore\n+// \t//go:build ignore\n //\n // (any other unsatisfied word will work as well, but \"ignore\" is conventional.)\n //\n // To build a file only when using cgo, and only on Linux and OS X:\n //\n-// \t// +build linux,cgo darwin,cgo\n+// \t//go:build cgo && (linux || darwin)\n //\n // Such a file is usually paired with another file implementing the\n // default functionality for other systems, which in this case would\n // carry the constraint:\n //\n-// \t// +build !linux,!darwin !cgo\n+// \t//go:build !(cgo && (linux || darwin))\n //\n // Naming a file dns_windows.go will cause it to be included only when\n // building the package for Windows; similarly, math_386.s will be included\n // only when building the package for 32-bit x86.\n //\n+// Go versions 1.16 and earlier used a different syntax for build constraints,\n+// with a \"// +build\" prefix. The gofmt command will add an equivalent //go:build\n+// constraint when encountering the older syntax.\n+//\n //\n // Build modes\n //\n@@ -1787,9 +1810,8 @@\n // \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n // \t\tof module path prefixes that should always be fetched in an insecure\n // \t\tmanner. Only applies to dependencies that are being fetched directly.\n-// \t\tUnlike the -insecure flag on 'go get', GOINSECURE does not disable\n-// \t\tchecksum database validation. GOPRIVATE or GONOSUMDB may be used\n-// \t\tto achieve that.\n+// \t\tGOINSECURE does not disable checksum database validation. GOPRIVATE or\n+// \t\tGONOSUMDB may be used to achieve that.\n // \tGOOS\n // \t\tThe operating system for which to compile code.\n // \t\tExamples are linux, darwin, windows, netbsd.\n@@ -1869,6 +1891,9 @@\n // \tGOMIPS64\n // \t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n // \t\tValid values are hardfloat (default), softfloat.\n+// \tGOPPC64\n+// \t\tFor GOARCH=ppc64{,le}, the target ISA (Instruction Set Architecture).\n+// \t\tValid values are power8 (default), power9.\n // \tGOWASM\n // \t\tFor GOARCH=wasm, comma-separated list of experimental WebAssembly features to use.\n // \t\tValid values are satconv, signext.\n@@ -1878,6 +1903,12 @@\n // \tGCCGOTOOLDIR\n // \t\tIf set, where to find gccgo tools, such as cgo.\n // \t\tThe default is based on how gccgo was configured.\n+// \tGOEXPERIMENT\n+// \t\tComma-separated list of toolchain experiments to enable or disable.\n+// \t\tThe list of available experiments may change arbitrarily over time.\n+// \t\tSee src/internal/goexperiment/flags.go for currently valid values.\n+// \t\tWarning: This variable is provided for the development and testing\n+// \t\tof the Go toolchain itself. Use beyond that purpose is unsupported.\n // \tGOROOT_FINAL\n // \t\tThe root of the installed Go tree, when it is\n // \t\tinstalled in a location other than where it is built.\n@@ -1961,7 +1992,7 @@\n // The go.mod file format is described in detail at\n // https://golang.org/ref/mod#go-mod-file.\n //\n-// To create a new go.mod file, use 'go help init'. For details see\n+// To create a new go.mod file, use 'go mod init'. For details see\n // 'go help mod init' or https://golang.org/ref/mod#go-mod-init.\n //\n // To add missing module requirements or remove unneeded requirements,\n@@ -2139,7 +2170,7 @@\n // This help text, accessible as 'go help gopath-get' even in module-aware mode,\n // describes 'go get' as it operates in legacy GOPATH mode.\n //\n-// Usage: go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\n+// Usage: go get [-d] [-f] [-t] [-u] [-v] [-fix] [build flags] [packages]\n //\n // Get downloads the packages named by the import paths, along with their\n // dependencies. It then installs the named packages, like 'go install'.\n@@ -2155,13 +2186,6 @@\n // The -fix flag instructs get to run the fix tool on the downloaded packages\n // before resolving dependencies or building the code.\n //\n-// The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP. Use with caution.\n-// This flag is deprecated and will be removed in a future version of go.\n-// The GOINSECURE environment variable should be used instead, since it\n-// provides control over which packages may be retrieved using an insecure\n-// scheme. See 'go help environment' for details.\n-//\n // The -t flag instructs get to also download the packages required to build\n // the tests for the specified packages.\n //\n@@ -2346,7 +2370,7 @@\n // will result in the following requests:\n //\n // \thttps://example.org/pkg/foo?go-get=1 (preferred)\n-// \thttp://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)\n+// \thttp://example.org/pkg/foo?go-get=1  (fallback, only with use of correctly set GOINSECURE)\n //\n // If that page contains the meta tag\n //\n@@ -2664,6 +2688,13 @@\n // \t    the Go tree can run a sanity check but not spend time running\n // \t    exhaustive tests.\n //\n+// \t-shuffle off,on,N\n+// \t\tRandomize the execution order of tests and benchmarks.\n+// \t\tIt is off by default. If -shuffle is set to on, then it will seed\n+// \t\tthe randomizer using the system clock. If -shuffle is set to an\n+// \t\tinteger N, then N will be used as the seed value. In both cases,\n+// \t\tthe seed will be reported for reproducibility.\n+//\n // \t-timeout d\n // \t    If a test binary runs longer than duration d, panic.\n // \t    If d is 0, the timeout is disabled."}, {"sha": "a1f2727825ede1f1ead32d3e240311206a186ed5", "filename": "libgo/go/cmd/go/go11.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo11.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build go1.1\n // +build go1.1\n \n package main"}, {"sha": "6ce276537babd88765937e1f7ec0f3c98cc5ac68", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -72,7 +72,6 @@ func tooSlow(t *testing.T) {\n // (temp) directory.\n var testGOROOT string\n \n-var testCC string\n var testGOCACHE string\n \n var testGo string\n@@ -179,13 +178,6 @@ func TestMain(m *testing.M) {\n \t\t\tos.Exit(2)\n \t\t}\n \n-\t\tout, err = exec.Command(gotool, \"env\", \"CC\").CombinedOutput()\n-\t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"could not find testing CC: %v\\n%s\", err, out)\n-\t\t\tos.Exit(2)\n-\t\t}\n-\t\ttestCC = strings.TrimSpace(string(out))\n-\n \t\tcmd := exec.Command(testGo, \"env\", \"CGO_ENABLED\")\n \t\tcmd.Stderr = new(strings.Builder)\n \t\tif out, err := cmd.Output(); err != nil {\n@@ -811,8 +803,10 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t// so that we can change files.\n \tfor _, copydir := range []string{\n \t\t\"src/runtime\",\n+\t\t\"src/internal/abi\",\n \t\t\"src/internal/bytealg\",\n \t\t\"src/internal/cpu\",\n+\t\t\"src/internal/goexperiment\",\n \t\t\"src/math/bits\",\n \t\t\"src/unsafe\",\n \t\tfilepath.Join(\"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH),\n@@ -2183,7 +2177,7 @@ func testBuildmodePIE(t *testing.T, useCgo, setBuildmodeToPIE bool) {\n \t\t\t// See https://sourceware.org/bugzilla/show_bug.cgi?id=19011\n \t\t\tsection := f.Section(\".edata\")\n \t\t\tif section == nil {\n-\t\t\t\tt.Fatalf(\".edata section is not present\")\n+\t\t\t\tt.Skip(\".edata section is not present\")\n \t\t\t}\n \t\t\t// TODO: deduplicate this struct from cmd/link/internal/ld/pe.go\n \t\t\ttype IMAGE_EXPORT_DIRECTORY struct {\n@@ -2830,3 +2824,59 @@ func TestCoverpkgTestOnly(t *testing.T) {\n \ttg.grepStderrNot(\"no packages being tested depend on matches\", \"bad match message\")\n \ttg.grepStdout(\"coverage: 100\", \"no coverage\")\n }\n+\n+// Regression test for golang.org/issue/34499: version command should not crash\n+// when executed in a deleted directory on Linux.\n+func TestExecInDeletedDir(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"windows\", \"plan9\",\n+\t\t\"aix\",                // Fails with \"device busy\".\n+\t\t\"solaris\", \"illumos\": // Fails with \"invalid argument\".\n+\t\tt.Skipf(\"%v does not support removing the current working directory\", runtime.GOOS)\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\twd, err := os.Getwd()\n+\ttg.check(err)\n+\ttg.makeTempdir()\n+\ttg.check(os.Chdir(tg.tempdir))\n+\tdefer func() { tg.check(os.Chdir(wd)) }()\n+\n+\ttg.check(os.Remove(tg.tempdir))\n+\n+\t// `go version` should not fail\n+\ttg.run(\"version\")\n+}\n+\n+// A missing C compiler should not force the net package to be stale.\n+// Issue 47215.\n+func TestMissingCC(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"test is only meaningful on systems with cgo\")\n+\t}\n+\tcc := os.Getenv(\"CC\")\n+\tif cc == \"\" {\n+\t\tcc = \"gcc\"\n+\t}\n+\tif filepath.IsAbs(cc) {\n+\t\tt.Skipf(`\"CC\" (%s) is an absolute path`, cc)\n+\t}\n+\t_, err := exec.LookPath(cc)\n+\tif err != nil {\n+\t\tt.Skipf(`\"CC\" (%s) not on PATH`, cc)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tnetStale, _ := tg.isStale(\"net\")\n+\tif netStale {\n+\t\tt.Skip(`skipping test because \"net\" package is currently stale`)\n+\t}\n+\n+\ttg.setenv(\"PATH\", \"\") // No C compiler on PATH.\n+\tnetStale, _ = tg.isStale(\"net\")\n+\tif netStale {\n+\t\tt.Error(`clearing \"PATH\" causes \"net\" to be stale`)\n+\t}\n+}"}, {"sha": "db992b78914923fba18e6aeacacaa09e1364aa29", "filename": "libgo/go/cmd/go/go_unix_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n // +build darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n \n package main_test"}, {"sha": "4d8715ef5fe002a349d83e956eb4493e9c698fe0", "filename": "libgo/go/cmd/go/internal/base/path.go", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,21 +8,27 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"sync\"\n )\n \n-func getwd() string {\n-\twd, err := os.Getwd()\n-\tif err != nil {\n-\t\tFatalf(\"cannot determine current directory: %v\", err)\n-\t}\n-\treturn wd\n-}\n+var cwd string\n+var cwdOnce sync.Once\n \n-var Cwd = getwd()\n+// Cwd returns the current working directory at the time of the first call.\n+func Cwd() string {\n+\tcwdOnce.Do(func() {\n+\t\tvar err error\n+\t\tcwd, err = os.Getwd()\n+\t\tif err != nil {\n+\t\t\tFatalf(\"cannot determine current directory: %v\", err)\n+\t\t}\n+\t})\n+\treturn cwd\n+}\n \n // ShortPath returns an absolute or relative name for path, whatever is shorter.\n func ShortPath(path string) string {\n-\tif rel, err := filepath.Rel(Cwd, path); err == nil && len(rel) < len(path) {\n+\tif rel, err := filepath.Rel(Cwd(), path); err == nil && len(rel) < len(path) {\n \t\treturn rel\n \t}\n \treturn path\n@@ -32,10 +38,8 @@ func ShortPath(path string) string {\n // made relative to the current directory if they would be shorter.\n func RelPaths(paths []string) []string {\n \tvar out []string\n-\t// TODO(rsc): Can this use Cwd from above?\n-\tpwd, _ := os.Getwd()\n \tfor _, p := range paths {\n-\t\trel, err := filepath.Rel(pwd, p)\n+\t\trel, err := filepath.Rel(Cwd(), p)\n \t\tif err == nil && len(rel) < len(p) {\n \t\t\tp = rel\n \t\t}"}, {"sha": "5cc0b0f1011e5a1a0c2ff3a0eb256960d90deb7c", "filename": "libgo/go/cmd/go/internal/base/signal_notunix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build plan9 || windows\n // +build plan9 windows\n \n package base"}, {"sha": "cdb25934c2de2c8389b356ca2b78fe8689b82bc8", "filename": "libgo/go/cmd/go/internal/base/signal_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || darwin || dragonfly || freebsd || hurd || js || linux || netbsd || openbsd || solaris\n // +build aix darwin dragonfly freebsd hurd js linux netbsd openbsd solaris\n \n package base"}, {"sha": "307527c695cbededab0ae1dfa4447e2fc3161c4b", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -20,6 +20,7 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/envcmd\"\n \t\"cmd/go/internal/web\"\n )\n \n@@ -81,7 +82,7 @@ func printGoVersion(w io.Writer) {\n \tfmt.Fprintf(w, \"### What version of Go are you using (`go version`)?\\n\\n\")\n \tfmt.Fprintf(w, \"<pre>\\n\")\n \tfmt.Fprintf(w, \"$ go version\\n\")\n-\tprintCmdOut(w, \"\", \"go\", \"version\")\n+\tfmt.Fprintf(w, \"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n \tfmt.Fprintf(w, \"</pre>\\n\")\n \tfmt.Fprintf(w, \"\\n\")\n }\n@@ -90,13 +91,20 @@ func printEnvDetails(w io.Writer) {\n \tfmt.Fprintf(w, \"### What operating system and processor architecture are you using (`go env`)?\\n\\n\")\n \tfmt.Fprintf(w, \"<details><summary><code>go env</code> Output</summary><br><pre>\\n\")\n \tfmt.Fprintf(w, \"$ go env\\n\")\n-\tprintCmdOut(w, \"\", \"go\", \"env\")\n+\tprintGoEnv(w)\n \tprintGoDetails(w)\n \tprintOSDetails(w)\n \tprintCDetails(w)\n \tfmt.Fprintf(w, \"</pre></details>\\n\\n\")\n }\n \n+func printGoEnv(w io.Writer) {\n+\tenv := envcmd.MkEnv()\n+\tenv = append(env, envcmd.ExtraEnvVars()...)\n+\tenv = append(env, envcmd.ExtraEnvVarsCostly()...)\n+\tenvcmd.PrintEnv(w, env)\n+}\n+\n func printGoDetails(w io.Writer) {\n \tprintCmdOut(w, \"GOROOT/bin/go version: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"version\")\n \tprintCmdOut(w, \"GOROOT/bin/go tool compile -V: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"tool\", \"compile\", \"-V\")"}, {"sha": "d592d7049786ce9d3fd5d15a67f2884327f149a0", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -19,7 +19,7 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"cmd/go/internal/renameio\"\n+\t\"cmd/go/internal/lockedfile\"\n )\n \n // An ActionID is a cache action key, the hash of a complete description of a\n@@ -294,10 +294,17 @@ func (c *Cache) Trim() {\n \t// We maintain in dir/trim.txt the time of the last completed cache trim.\n \t// If the cache has been trimmed recently enough, do nothing.\n \t// This is the common case.\n-\tdata, _ := renameio.ReadFile(filepath.Join(c.dir, \"trim.txt\"))\n-\tt, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64)\n-\tif err == nil && now.Sub(time.Unix(t, 0)) < trimInterval {\n-\t\treturn\n+\t// If the trim file is corrupt, detected if the file can't be parsed, or the\n+\t// trim time is too far in the future, attempt the trim anyway. It's possible that\n+\t// the cache was full when the corruption happened. Attempting a trim on\n+\t// an empty cache is cheap, so there wouldn't be a big performance hit in that case.\n+\tif data, err := lockedfile.Read(filepath.Join(c.dir, \"trim.txt\")); err == nil {\n+\t\tif t, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64); err == nil {\n+\t\t\tlastTrim := time.Unix(t, 0)\n+\t\t\tif d := now.Sub(lastTrim); d < trimInterval && d > -mtimeInterval {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n \t}\n \n \t// Trim each of the 256 subdirectories.\n@@ -311,7 +318,11 @@ func (c *Cache) Trim() {\n \n \t// Ignore errors from here: if we don't write the complete timestamp, the\n \t// cache will appear older than it is, and we'll trim it again next time.\n-\trenameio.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())), 0666)\n+\tvar b bytes.Buffer\n+\tfmt.Fprintf(&b, \"%d\", now.Unix())\n+\tif err := lockedfile.Write(filepath.Join(c.dir, \"trim.txt\"), &b, 0666); err != nil {\n+\t\treturn\n+\t}\n }\n \n // trimSubdir trims a single cache subdirectory."}, {"sha": "4f79c3150024492db1572271c08ffb1a3eeca082", "filename": "libgo/go/cmd/go/internal/cache/hash.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"sync\"\n )\n \n@@ -36,7 +37,22 @@ type Hash struct {\n // of other versions. This salt will result in additional ActionID files\n // in the cache, but not additional copies of the large output files,\n // which are still addressed by unsalted SHA256.\n-var hashSalt = []byte(runtime.Version())\n+//\n+// We strip any GOEXPERIMENTs the go tool was built with from this\n+// version string on the assumption that they shouldn't affect go tool\n+// execution. This allows bootstrapping to converge faster: dist builds\n+// go_bootstrap without any experiments, so by stripping experiments\n+// go_bootstrap and the final go binary will use the same salt.\n+var hashSalt = []byte(stripExperiment(runtime.Version()))\n+\n+// stripExperiment strips any GOEXPERIMENT configuration from the Go\n+// version string.\n+func stripExperiment(version string) string {\n+\tif i := strings.Index(version, \" X:\"); i >= 0 {\n+\t\treturn version[:i]\n+\t}\n+\treturn version\n+}\n \n // Subkey returns an action ID corresponding to mixing a parent\n // action ID with a string description of the subkey."}, {"sha": "57a3c1ff6fbdc1f9f29a10a4580e8d40e4f8c908", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"internal/buildcfg\"\n \t\"internal/cfg\"\n \t\"io\"\n \t\"os\"\n@@ -19,27 +20,25 @@ import (\n \t\"sync\"\n \n \t\"cmd/go/internal/fsys\"\n-\n-\t\"cmd/internal/objabi\"\n )\n \n // These are general \"build flags\" used by build and other commands.\n var (\n \tBuildA                 bool   // -a flag\n \tBuildBuildmode         string // -buildmode flag\n \tBuildContext           = defaultContext()\n-\tBuildMod               string             // -mod flag\n-\tBuildModExplicit       bool               // whether -mod was set explicitly\n-\tBuildModReason         string             // reason -mod was set, if set by default\n-\tBuildI                 bool               // -i flag\n-\tBuildLinkshared        bool               // -linkshared flag\n-\tBuildMSan              bool               // -msan flag\n-\tBuildN                 bool               // -n flag\n-\tBuildO                 string             // -o flag\n-\tBuildP                 = runtime.NumCPU() // -p flag\n-\tBuildPkgdir            string             // -pkgdir flag\n-\tBuildRace              bool               // -race flag\n-\tBuildToolexec          []string           // -toolexec flag\n+\tBuildMod               string                  // -mod flag\n+\tBuildModExplicit       bool                    // whether -mod was set explicitly\n+\tBuildModReason         string                  // reason -mod was set, if set by default\n+\tBuildI                 bool                    // -i flag\n+\tBuildLinkshared        bool                    // -linkshared flag\n+\tBuildMSan              bool                    // -msan flag\n+\tBuildN                 bool                    // -n flag\n+\tBuildO                 string                  // -o flag\n+\tBuildP                 = runtime.GOMAXPROCS(0) // -p flag\n+\tBuildPkgdir            string                  // -pkgdir flag\n+\tBuildRace              bool                    // -race flag\n+\tBuildToolexec          []string                // -toolexec flag\n \tBuildToolchainName     string\n \tBuildToolchainCompiler func() string\n \tBuildToolchainLinker   func() string\n@@ -51,8 +50,6 @@ var (\n \tModCacheRW bool   // -modcacherw flag\n \tModFile    string // -modfile flag\n \n-\tInsecure bool // -insecure flag\n-\n \tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n \n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n@@ -80,6 +77,14 @@ func defaultContext() build.Context {\n \tctxt.GOOS = envOr(\"GOOS\", ctxt.GOOS)\n \tctxt.GOARCH = envOr(\"GOARCH\", ctxt.GOARCH)\n \n+\t// The experiments flags are based on GOARCH, so they may\n+\t// need to change.  TODO: This should be cleaned up.\n+\tbuildcfg.UpdateExperiments(ctxt.GOOS, ctxt.GOARCH, envOr(\"GOEXPERIMENT\", buildcfg.DefaultGOEXPERIMENT))\n+\tctxt.ToolTags = nil\n+\tfor _, exp := range buildcfg.EnabledExperiments() {\n+\t\tctxt.ToolTags = append(ctxt.ToolTags, \"goexperiment.\"+exp)\n+\t}\n+\n \t// The go/build rule for whether cgo is enabled is:\n \t//\t1. If $CGO_ENABLED is set, respect it.\n \t//\t2. Otherwise, if this is a cross-compile, disable cgo.\n@@ -254,12 +259,12 @@ var (\n \tGOMODCACHE   = envOr(\"GOMODCACHE\", gopathDir(\"pkg/mod\"))\n \n \t// Used in envcmd.MkEnv and build ID computations.\n-\tGOARM    = envOr(\"GOARM\", fmt.Sprint(objabi.GOARM))\n-\tGO386    = envOr(\"GO386\", objabi.GO386)\n-\tGOMIPS   = envOr(\"GOMIPS\", objabi.GOMIPS)\n-\tGOMIPS64 = envOr(\"GOMIPS64\", objabi.GOMIPS64)\n-\tGOPPC64  = envOr(\"GOPPC64\", fmt.Sprintf(\"%s%d\", \"power\", objabi.GOPPC64))\n-\tGOWASM   = envOr(\"GOWASM\", fmt.Sprint(objabi.GOWASM))\n+\tGOARM    = envOr(\"GOARM\", fmt.Sprint(buildcfg.GOARM))\n+\tGO386    = envOr(\"GO386\", buildcfg.GO386)\n+\tGOMIPS   = envOr(\"GOMIPS\", buildcfg.GOMIPS)\n+\tGOMIPS64 = envOr(\"GOMIPS64\", buildcfg.GOMIPS64)\n+\tGOPPC64  = envOr(\"GOPPC64\", fmt.Sprintf(\"%s%d\", \"power\", buildcfg.GOPPC64))\n+\tGOWASM   = envOr(\"GOWASM\", fmt.Sprint(buildcfg.GOWASM))\n \n \tGOPROXY    = envOr(\"GOPROXY\", \"https://proxy.golang.org,direct\")\n \tGOSUMDB    = envOr(\"GOSUMDB\", \"sum.golang.org\")"}, {"sha": "fd4cb205591105d0ad527e25e811cd62dfadf5a8", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -117,7 +117,7 @@ func runClean(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tif cleanPkg {\n-\t\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n+\t\tfor _, pkg := range load.PackagesAndErrors(ctx, load.PackageOpts{}, args) {\n \t\t\tclean(pkg)\n \t\t}\n \t}"}, {"sha": "8580a5dc4d2482a7e2f88640abe9a76a245adb18", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -13,7 +13,7 @@ import (\n \n var CmdDoc = &base.Command{\n \tRun:         runDoc,\n-\tUsageLine:   \"go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\",\n+\tUsageLine:   \"go doc [doc flags] [package|[package.]symbol[.methodOrField]]\",\n \tCustomFlags: true,\n \tShort:       \"show documentation for package or symbol\",\n \tLong: `"}, {"sha": "1553d263914541f05a639e03b8041969ba244301", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 136, "deletions": 106, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,6 +10,8 @@ import (\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"internal/buildcfg\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n@@ -71,6 +73,7 @@ func MkEnv() []cfg.EnvVar {\n \t\t{Name: \"GOCACHE\", Value: cache.DefaultDir()},\n \t\t{Name: \"GOENV\", Value: envFile},\n \t\t{Name: \"GOEXE\", Value: cfg.ExeSuffix},\n+\t\t{Name: \"GOEXPERIMENT\", Value: buildcfg.GOEXPERIMENT()},\n \t\t{Name: \"GOFLAGS\", Value: cfg.Getenv(\"GOFLAGS\")},\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n@@ -196,23 +199,31 @@ func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n \tif *envU && *envW {\n \t\tbase.Fatalf(\"go env: cannot use -u with -w\")\n \t}\n+\n+\t// Handle 'go env -w' and 'go env -u' before calling buildcfg.Check,\n+\t// so they can be used to recover from an invalid configuration.\n+\tif *envW {\n+\t\trunEnvW(args)\n+\t\treturn\n+\t}\n+\n+\tif *envU {\n+\t\trunEnvU(args)\n+\t\treturn\n+\t}\n+\n+\tbuildcfg.Check()\n+\n \tenv := cfg.CmdEnv\n \tenv = append(env, ExtraEnvVars()...)\n \n-\tif err := fsys.Init(base.Cwd); err != nil {\n+\tif err := fsys.Init(base.Cwd()); err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \t// Do we need to call ExtraEnvVarsCostly, which is a bit expensive?\n \tneedCostly := false\n-\tif *envU || *envW {\n-\t\t// We're overwriting or removing default settings,\n-\t\t// so it doesn't really matter what the existing settings are.\n-\t\t//\n-\t\t// Moreover, we haven't validated the new settings yet, so it is\n-\t\t// important that we NOT perform any actions based on them,\n-\t\t// such as initializing the builder to compute other variables.\n-\t} else if len(args) == 0 {\n+\tif len(args) == 0 {\n \t\t// We're listing all environment variables (\"go env\"),\n \t\t// including the expensive ones.\n \t\tneedCostly = true\n@@ -237,95 +248,6 @@ func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n \t\tenv = append(env, ExtraEnvVarsCostly()...)\n \t}\n \n-\tif *envW {\n-\t\t// Process and sanity-check command line.\n-\t\tif len(args) == 0 {\n-\t\t\tbase.Fatalf(\"go env -w: no KEY=VALUE arguments given\")\n-\t\t}\n-\t\tosEnv := make(map[string]string)\n-\t\tfor _, e := range cfg.OrigEnv {\n-\t\t\tif i := strings.Index(e, \"=\"); i >= 0 {\n-\t\t\t\tosEnv[e[:i]] = e[i+1:]\n-\t\t\t}\n-\t\t}\n-\t\tadd := make(map[string]string)\n-\t\tfor _, arg := range args {\n-\t\t\ti := strings.Index(arg, \"=\")\n-\t\t\tif i < 0 {\n-\t\t\t\tbase.Fatalf(\"go env -w: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n-\t\t\t}\n-\t\t\tkey, val := arg[:i], arg[i+1:]\n-\t\t\tif err := checkEnvWrite(key, val); err != nil {\n-\t\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n-\t\t\t}\n-\t\t\tif _, ok := add[key]; ok {\n-\t\t\t\tbase.Fatalf(\"go env -w: multiple values for key: %s\", key)\n-\t\t\t}\n-\t\t\tadd[key] = val\n-\t\t\tif osVal := osEnv[key]; osVal != \"\" && osVal != val {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: go env -w %s=... does not override conflicting OS environment variable\\n\", key)\n-\t\t\t}\n-\t\t}\n-\n-\t\tgoos, okGOOS := add[\"GOOS\"]\n-\t\tgoarch, okGOARCH := add[\"GOARCH\"]\n-\t\tif okGOOS || okGOARCH {\n-\t\t\tif !okGOOS {\n-\t\t\t\tgoos = cfg.Goos\n-\t\t\t}\n-\t\t\tif !okGOARCH {\n-\t\t\t\tgoarch = cfg.Goarch\n-\t\t\t}\n-\t\t\tif err := work.CheckGOOSARCHPair(goos, goarch); err != nil {\n-\t\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n-\t\t\t}\n-\t\t}\n-\n-\t\tgotmp, okGOTMP := add[\"GOTMPDIR\"]\n-\t\tif okGOTMP {\n-\t\t\tif !filepath.IsAbs(gotmp) && gotmp != \"\" {\n-\t\t\t\tbase.Fatalf(\"go env -w: GOTMPDIR must be an absolute path\")\n-\t\t\t}\n-\t\t}\n-\n-\t\tupdateEnvFile(add, nil)\n-\t\treturn\n-\t}\n-\n-\tif *envU {\n-\t\t// Process and sanity-check command line.\n-\t\tif len(args) == 0 {\n-\t\t\tbase.Fatalf(\"go env -u: no arguments given\")\n-\t\t}\n-\t\tdel := make(map[string]bool)\n-\t\tfor _, arg := range args {\n-\t\t\tif err := checkEnvWrite(arg, \"\"); err != nil {\n-\t\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n-\t\t\t}\n-\t\t\tdel[arg] = true\n-\t\t}\n-\t\tif del[\"GOOS\"] || del[\"GOARCH\"] {\n-\t\t\tgoos, goarch := cfg.Goos, cfg.Goarch\n-\t\t\tif del[\"GOOS\"] {\n-\t\t\t\tgoos = getOrigEnv(\"GOOS\")\n-\t\t\t\tif goos == \"\" {\n-\t\t\t\t\tgoos = build.Default.GOOS\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif del[\"GOARCH\"] {\n-\t\t\t\tgoarch = getOrigEnv(\"GOARCH\")\n-\t\t\t\tif goarch == \"\" {\n-\t\t\t\t\tgoarch = build.Default.GOARCH\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif err := work.CheckGOOSARCHPair(goos, goarch); err != nil {\n-\t\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n-\t\t\t}\n-\t\t}\n-\t\tupdateEnvFile(nil, del)\n-\t\treturn\n-\t}\n-\n \tif len(args) > 0 {\n \t\tif *envJson {\n \t\t\tvar es []cfg.EnvVar\n@@ -347,27 +269,135 @@ func runEnv(ctx context.Context, cmd *base.Command, args []string) {\n \t\treturn\n \t}\n \n+\tPrintEnv(os.Stdout, env)\n+}\n+\n+func runEnvW(args []string) {\n+\t// Process and sanity-check command line.\n+\tif len(args) == 0 {\n+\t\tbase.Fatalf(\"go env -w: no KEY=VALUE arguments given\")\n+\t}\n+\tosEnv := make(map[string]string)\n+\tfor _, e := range cfg.OrigEnv {\n+\t\tif i := strings.Index(e, \"=\"); i >= 0 {\n+\t\t\tosEnv[e[:i]] = e[i+1:]\n+\t\t}\n+\t}\n+\tadd := make(map[string]string)\n+\tfor _, arg := range args {\n+\t\ti := strings.Index(arg, \"=\")\n+\t\tif i < 0 {\n+\t\t\tbase.Fatalf(\"go env -w: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n+\t\t}\n+\t\tkey, val := arg[:i], arg[i+1:]\n+\t\tif err := checkEnvWrite(key, val); err != nil {\n+\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t\t}\n+\t\tif _, ok := add[key]; ok {\n+\t\t\tbase.Fatalf(\"go env -w: multiple values for key: %s\", key)\n+\t\t}\n+\t\tadd[key] = val\n+\t\tif osVal := osEnv[key]; osVal != \"\" && osVal != val {\n+\t\t\tfmt.Fprintf(os.Stderr, \"warning: go env -w %s=... does not override conflicting OS environment variable\\n\", key)\n+\t\t}\n+\t}\n+\n+\tif err := checkBuildConfig(add, nil); err != nil {\n+\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t}\n+\n+\tgotmp, okGOTMP := add[\"GOTMPDIR\"]\n+\tif okGOTMP {\n+\t\tif !filepath.IsAbs(gotmp) && gotmp != \"\" {\n+\t\t\tbase.Fatalf(\"go env -w: GOTMPDIR must be an absolute path\")\n+\t\t}\n+\t}\n+\n+\tupdateEnvFile(add, nil)\n+}\n+\n+func runEnvU(args []string) {\n+\t// Process and sanity-check command line.\n+\tif len(args) == 0 {\n+\t\tbase.Fatalf(\"go env -u: no arguments given\")\n+\t}\n+\tdel := make(map[string]bool)\n+\tfor _, arg := range args {\n+\t\tif err := checkEnvWrite(arg, \"\"); err != nil {\n+\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t\t}\n+\t\tdel[arg] = true\n+\t}\n+\n+\tif err := checkBuildConfig(nil, del); err != nil {\n+\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t}\n+\n+\tupdateEnvFile(nil, del)\n+}\n+\n+// checkBuildConfig checks whether the build configuration is valid\n+// after the specified configuration environment changes are applied.\n+func checkBuildConfig(add map[string]string, del map[string]bool) error {\n+\t// get returns the value for key after applying add and del and\n+\t// reports whether it changed. cur should be the current value\n+\t// (i.e., before applying changes) and def should be the default\n+\t// value (i.e., when no environment variables are provided at all).\n+\tget := func(key, cur, def string) (string, bool) {\n+\t\tif val, ok := add[key]; ok {\n+\t\t\treturn val, true\n+\t\t}\n+\t\tif del[key] {\n+\t\t\tval := getOrigEnv(key)\n+\t\t\tif val == \"\" {\n+\t\t\t\tval = def\n+\t\t\t}\n+\t\t\treturn val, true\n+\t\t}\n+\t\treturn cur, false\n+\t}\n+\n+\tgoos, okGOOS := get(\"GOOS\", cfg.Goos, build.Default.GOOS)\n+\tgoarch, okGOARCH := get(\"GOARCH\", cfg.Goarch, build.Default.GOARCH)\n+\tif okGOOS || okGOARCH {\n+\t\tif err := work.CheckGOOSARCHPair(goos, goarch); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tgoexperiment, okGOEXPERIMENT := get(\"GOEXPERIMENT\", buildcfg.GOEXPERIMENT(), \"\")\n+\tif okGOEXPERIMENT {\n+\t\tif _, _, err := buildcfg.ParseGOEXPERIMENT(goos, goarch, goexperiment); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// PrintEnv prints the environment variables to w.\n+func PrintEnv(w io.Writer, env []cfg.EnvVar) {\n \tfor _, e := range env {\n \t\tif e.Name != \"TERM\" {\n \t\t\tswitch runtime.GOOS {\n \t\t\tdefault:\n-\t\t\t\tfmt.Printf(\"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n+\t\t\t\tfmt.Fprintf(w, \"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n \t\t\tcase \"plan9\":\n \t\t\t\tif strings.IndexByte(e.Value, '\\x00') < 0 {\n-\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.Name, strings.ReplaceAll(e.Value, \"'\", \"''\"))\n+\t\t\t\t\tfmt.Fprintf(w, \"%s='%s'\\n\", e.Name, strings.ReplaceAll(e.Value, \"'\", \"''\"))\n \t\t\t\t} else {\n \t\t\t\t\tv := strings.Split(e.Value, \"\\x00\")\n-\t\t\t\t\tfmt.Printf(\"%s=(\", e.Name)\n+\t\t\t\t\tfmt.Fprintf(w, \"%s=(\", e.Name)\n \t\t\t\t\tfor x, s := range v {\n \t\t\t\t\t\tif x > 0 {\n-\t\t\t\t\t\t\tfmt.Printf(\" \")\n+\t\t\t\t\t\t\tfmt.Fprintf(w, \" \")\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tfmt.Printf(\"%s\", s)\n+\t\t\t\t\t\tfmt.Fprintf(w, \"%s\", s)\n \t\t\t\t\t}\n-\t\t\t\t\tfmt.Printf(\")\\n\")\n+\t\t\t\t\tfmt.Fprintf(w, \")\\n\")\n \t\t\t\t}\n \t\t\tcase \"windows\":\n-\t\t\t\tfmt.Printf(\"set %s=%s\\n\", e.Name, e.Value)\n+\t\t\t\tfmt.Fprintf(w, \"set %s=%s\\n\", e.Name, e.Value)\n \t\t\t}\n \t\t}\n \t}\n@@ -428,7 +458,7 @@ func checkEnvWrite(key, val string) error {\n \t\t\treturn fmt.Errorf(\"GOPATH entry is relative; must be absolute path: %q\", val)\n \t\t}\n \t// Make sure CC and CXX are absolute paths\n-\tcase \"CC\", \"CXX\":\n+\tcase \"CC\", \"CXX\", \"GOMODCACHE\":\n \t\tif !filepath.IsAbs(val) && val != \"\" && val != filepath.Base(val) {\n \t\t\treturn fmt.Errorf(\"%s entry is relative; must be absolute path: %q\", key, val)\n \t\t}"}, {"sha": "988d45e71ccfe2ccf571e409962bdd3ade4e3430", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -33,7 +33,7 @@ See also: go fmt, go vet.\n }\n \n func runFix(ctx context.Context, cmd *base.Command, args []string) {\n-\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tw := 0\n \tfor _, pkg := range pkgs {\n \t\tif pkg.Error != nil {"}, {"sha": "8a040087539e8f9195c61a88d89883a379a963b2", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -65,7 +65,7 @@ func runFmt(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}()\n \t}\n-\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n+\tfor _, pkg := range load.PackagesAndErrors(ctx, load.PackageOpts{}, args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not formatting packages in dependency modules\\n\")"}, {"sha": "0b806027e6469a3cac3b19e2e5e162b7ead8e92d", "filename": "libgo/go/cmd/go/internal/fsys/fsys.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffsys%2Ffsys.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -44,7 +44,7 @@ func (n *node) isDeleted() bool {\n \n // TODO(matloob): encapsulate these in an io/fs-like interface\n var overlay map[string]*node // path -> file or directory node\n-var cwd string               // copy of base.Cwd to avoid dependency\n+var cwd string               // copy of base.Cwd() to avoid dependency\n \n // Canonicalize a path for looking it up in the overlay.\n // Important: filepath.Join(cwd, path) doesn't always produce\n@@ -100,7 +100,7 @@ func Init(wd string) error {\n }\n \n func initFromJSON(overlayJSON OverlayJSON) error {\n-\t// Canonicalize the paths in in the overlay map.\n+\t// Canonicalize the paths in the overlay map.\n \t// Use reverseCanonicalized to check for collisions:\n \t// no two 'from' paths should canonicalize to the same path.\n \toverlay = make(map[string]*node)"}, {"sha": "80ea32b4284011712eb82b2bd671e4f5f9a35b2e", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -161,8 +161,6 @@ func init() {\n }\n \n func runGenerate(ctx context.Context, cmd *base.Command, args []string) {\n-\tload.IgnoreImports = true\n-\n \tif generateRunFlag != \"\" {\n \t\tvar err error\n \t\tgenerateRunRE, err = regexp.Compile(generateRunFlag)\n@@ -175,7 +173,8 @@ func runGenerate(ctx context.Context, cmd *base.Command, args []string) {\n \n \t// Even if the arguments are .go files, this loop suffices.\n \tprinted := false\n-\tfor _, pkg := range load.PackagesAndErrors(ctx, args) {\n+\tpkgOpts := load.PackageOpts{IgnoreImports: true}\n+\tfor _, pkg := range load.PackagesAndErrors(ctx, pkgOpts, args) {\n \t\tif modload.Enabled() && pkg.Module != nil && !pkg.Module.Main {\n \t\t\tif !printed {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: not generating in packages in dependency modules\\n\")\n@@ -334,6 +333,7 @@ func (g *Generator) setEnv() {\n \t\t\"GOPACKAGE=\" + g.pkg,\n \t\t\"DOLLAR=\" + \"$\",\n \t}\n+\tg.env = base.AppendPWD(g.env, g.dir)\n }\n \n // split breaks the line into words, evaluating quoted"}, {"sha": "3c16dc3040facba13a7a59416268ae7944250599", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -26,7 +26,7 @@ import (\n )\n \n var CmdGet = &base.Command{\n-\tUsageLine: \"go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\",\n+\tUsageLine: \"go get [-d] [-f] [-t] [-u] [-v] [-fix] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n Get downloads the packages named by the import paths, along with their\n@@ -43,13 +43,6 @@ of the original.\n The -fix flag instructs get to run the fix tool on the downloaded packages\n before resolving dependencies or building the code.\n \n-The -insecure flag permits fetching from repositories and resolving\n-custom domains using insecure schemes such as HTTP. Use with caution.\n-This flag is deprecated and will be removed in a future version of go.\n-The GOINSECURE environment variable should be used instead, since it\n-provides control over which packages may be retrieved using an insecure\n-scheme. See 'go help environment' for details.\n-\n The -t flag instructs get to also download the packages required to build\n the tests for the specified packages.\n \n@@ -105,17 +98,17 @@ Usage: ` + CmdGet.UsageLine + `\n }\n \n var (\n-\tgetD   = CmdGet.Flag.Bool(\"d\", false, \"\")\n-\tgetF   = CmdGet.Flag.Bool(\"f\", false, \"\")\n-\tgetT   = CmdGet.Flag.Bool(\"t\", false, \"\")\n-\tgetU   = CmdGet.Flag.Bool(\"u\", false, \"\")\n-\tgetFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n+\tgetD        = CmdGet.Flag.Bool(\"d\", false, \"\")\n+\tgetF        = CmdGet.Flag.Bool(\"f\", false, \"\")\n+\tgetT        = CmdGet.Flag.Bool(\"t\", false, \"\")\n+\tgetU        = CmdGet.Flag.Bool(\"u\", false, \"\")\n+\tgetFix      = CmdGet.Flag.Bool(\"fix\", false, \"\")\n+\tgetInsecure = CmdGet.Flag.Bool(\"insecure\", false, \"\")\n )\n \n func init() {\n \twork.AddBuildFlags(CmdGet, work.OmitModFlag|work.OmitModCommonFlags)\n \tCmdGet.Run = runGet // break init loop\n-\tCmdGet.Flag.BoolVar(&cfg.Insecure, \"insecure\", cfg.Insecure, \"\")\n }\n \n func runGet(ctx context.Context, cmd *base.Command, args []string) {\n@@ -129,11 +122,11 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \tif *getF && !*getU {\n \t\tbase.Fatalf(\"go get: cannot use -f flag without -u\")\n \t}\n-\tif cfg.Insecure {\n-\t\tfmt.Fprintf(os.Stderr, \"go get: -insecure flag is deprecated; see 'go help get' for details\\n\")\n+\tif *getInsecure {\n+\t\tbase.Fatalf(\"go get: -insecure flag is no longer supported; use GOINSECURE instead\")\n \t}\n \n-\t// Disable any prompting for passwords by Git.\n+\t// Disable any prompting for passwords by Git itself.\n \t// Only has an effect for 2.3.0 or later, but avoiding\n \t// the prompt in earlier versions is just too hard.\n \t// If user has explicitly set GIT_TERMINAL_PROMPT=1, keep\n@@ -143,7 +136,10 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t\tos.Setenv(\"GIT_TERMINAL_PROMPT\", \"0\")\n \t}\n \n-\t// Disable any ssh connection pooling by Git.\n+\t// Also disable prompting for passwords by the 'ssh' subprocess spawned by\n+\t// Git, because apparently GIT_TERMINAL_PROMPT isn't sufficient to do that.\n+\t// Adding '-o BatchMode=yes' should do the trick.\n+\t//\n \t// If a Git subprocess forks a child into the background to cache a new connection,\n \t// that child keeps stdout/stderr open. After the Git subprocess exits,\n \t// os /exec expects to be able to read from the stdout/stderr pipe\n@@ -157,7 +153,14 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t// assume they know what they are doing and don't step on it.\n \t// But default to turning off ControlMaster.\n \tif os.Getenv(\"GIT_SSH\") == \"\" && os.Getenv(\"GIT_SSH_COMMAND\") == \"\" {\n-\t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n+\t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no -o BatchMode=yes\")\n+\t}\n+\n+\t// And one more source of Git prompts: the Git Credential Manager Core for Windows.\n+\t//\n+\t// See https://github.com/microsoft/Git-Credential-Manager-Core/blob/master/docs/environment.md#gcm_interactive.\n+\tif os.Getenv(\"GCM_INTERACTIVE\") == \"\" {\n+\t\tos.Setenv(\"GCM_INTERACTIVE\", \"never\")\n \t}\n \n \t// Phase 1. Download/update.\n@@ -180,7 +183,7 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t// everything.\n \tload.ClearPackageCache()\n \n-\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tload.CheckPackageErrors(pkgs)\n \n \t// Phase 3. Install.\n@@ -255,9 +258,9 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n \t\t\tmode := 0 // don't do module or vendor resolution\n-\t\t\treturn load.LoadImport(context.TODO(), path, base.Cwd, nil, stk, nil, mode)\n+\t\t\treturn load.LoadImport(context.TODO(), load.PackageOpts{}, path, base.Cwd(), nil, stk, nil, mode)\n \t\t}\n-\t\treturn load.LoadImport(context.TODO(), path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n+\t\treturn load.LoadImport(context.TODO(), load.PackageOpts{}, path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n \t}\n \n \tp := load1(arg, mode)\n@@ -435,7 +438,7 @@ func downloadPackage(p *load.Package) error {\n \t\treturn fmt.Errorf(\"%s: invalid import path: %v\", p.ImportPath, err)\n \t}\n \tsecurity := web.SecureOnly\n-\tif cfg.Insecure || module.MatchPrefixPatterns(cfg.GOINSECURE, importPrefix) {\n+\tif module.MatchPrefixPatterns(cfg.GOINSECURE, importPrefix) {\n \t\tsecurity = web.Insecure\n \t}\n "}, {"sha": "490ff1fb7cf05bd5a7e107c1ea40bb44174cc0db", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -251,7 +251,7 @@ For example,\n will result in the following requests:\n \n \thttps://example.org/pkg/foo?go-get=1 (preferred)\n-\thttp://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)\n+\thttp://example.org/pkg/foo?go-get=1  (fallback, only with use of correctly set GOINSECURE)\n \n If that page contains the meta tag\n \n@@ -517,9 +517,8 @@ General-purpose environment variables:\n \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n \t\tof module path prefixes that should always be fetched in an insecure\n \t\tmanner. Only applies to dependencies that are being fetched directly.\n-\t\tUnlike the -insecure flag on 'go get', GOINSECURE does not disable\n-\t\tchecksum database validation. GOPRIVATE or GONOSUMDB may be used\n-\t\tto achieve that.\n+\t\tGOINSECURE does not disable checksum database validation. GOPRIVATE or\n+\t\tGONOSUMDB may be used to achieve that.\n \tGOOS\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n@@ -599,6 +598,9 @@ Architecture-specific environment variables:\n \tGOMIPS64\n \t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n \t\tValid values are hardfloat (default), softfloat.\n+\tGOPPC64\n+\t\tFor GOARCH=ppc64{,le}, the target ISA (Instruction Set Architecture).\n+\t\tValid values are power8 (default), power9.\n \tGOWASM\n \t\tFor GOARCH=wasm, comma-separated list of experimental WebAssembly features to use.\n \t\tValid values are satconv, signext.\n@@ -608,6 +610,12 @@ Special-purpose environment variables:\n \tGCCGOTOOLDIR\n \t\tIf set, where to find gccgo tools, such as cgo.\n \t\tThe default is based on how gccgo was configured.\n+\tGOEXPERIMENT\n+\t\tComma-separated list of toolchain experiments to enable or disable.\n+\t\tThe list of available experiments may change arbitrarily over time.\n+\t\tSee src/internal/goexperiment/flags.go for currently valid values.\n+\t\tWarning: This variable is provided for the development and testing\n+\t\tof the Go toolchain itself. Use beyond that purpose is unsupported.\n \tGOROOT_FINAL\n \t\tThe root of the installed Go tree, when it is\n \t\tinstalled in a location other than where it is built.\n@@ -785,38 +793,28 @@ var HelpBuildConstraint = &base.Command{\n \tLong: `\n A build constraint, also known as a build tag, is a line comment that begins\n \n-\t// +build\n+\t//go:build\n \n that lists the conditions under which a file should be included in the package.\n Constraints may appear in any kind of source file (not just Go), but\n they must appear near the top of the file, preceded\n only by blank lines and other line comments. These rules mean that in Go\n files a build constraint must appear before the package clause.\n \n-To distinguish build constraints from package documentation, a series of\n-build constraints must be followed by a blank line.\n+To distinguish build constraints from package documentation,\n+a build constraint should be followed by a blank line.\n \n-A build constraint is evaluated as the OR of space-separated options.\n-Each option evaluates as the AND of its comma-separated terms.\n-Each term consists of letters, digits, underscores, and dots.\n-A term may be negated with a preceding !.\n-For example, the build constraint:\n+A build constraint is evaluated as an expression containing options\n+combined by ||, &&, and ! operators and parentheses. Operators have\n+the same meaning as in Go.\n \n-\t// +build linux,386 darwin,!cgo\n+For example, the following build constraint constrains a file to\n+build when the \"linux\" and \"386\" constraints are satisfied, or when\n+\"darwin\" is satisfied and \"cgo\" is not:\n \n-corresponds to the boolean formula:\n+\t//go:build (linux && 386) || (darwin && !cgo)\n \n-\t(linux AND 386) OR (darwin AND (NOT cgo))\n-\n-A file may have multiple build constraints. The overall constraint is the AND\n-of the individual constraints. That is, the build constraints:\n-\n-\t// +build linux darwin\n-\t// +build amd64\n-\n-corresponds to the boolean formula:\n-\n-\t(linux OR darwin) AND amd64\n+It is an error for a file to have more than one //go:build line.\n \n During a particular build, the following words are satisfied:\n \n@@ -854,22 +852,26 @@ in addition to ios tags and files.\n \n To keep a file from being considered for the build:\n \n-\t// +build ignore\n+\t//go:build ignore\n \n (any other unsatisfied word will work as well, but \"ignore\" is conventional.)\n \n To build a file only when using cgo, and only on Linux and OS X:\n \n-\t// +build linux,cgo darwin,cgo\n+\t//go:build cgo && (linux || darwin)\n \n Such a file is usually paired with another file implementing the\n default functionality for other systems, which in this case would\n carry the constraint:\n \n-\t// +build !linux,!darwin !cgo\n+\t//go:build !(cgo && (linux || darwin))\n \n Naming a file dns_windows.go will cause it to be included only when\n building the package for Windows; similarly, math_386.s will be included\n only when building the package for 32-bit x86.\n+\n+Go versions 1.16 and earlier used a different syntax for build constraints,\n+with a \"// +build\" prefix. The gofmt command will add an equivalent //go:build\n+constraint when encountering the older syntax.\n `,\n }"}, {"sha": "70d5190450502d042c2a2d0ed3d17105d50e6dbc", "filename": "libgo/go/cmd/go/internal/imports/read.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,6 +8,7 @@ package imports\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n \t\"errors\"\n \t\"io\"\n \t\"unicode/utf8\"\n@@ -22,6 +23,19 @@ type importReader struct {\n \tnerr int\n }\n \n+var bom = []byte{0xef, 0xbb, 0xbf}\n+\n+func newImportReader(b *bufio.Reader) *importReader {\n+\t// Remove leading UTF-8 BOM.\n+\t// Per https://golang.org/ref/spec#Source_code_representation:\n+\t// a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF)\n+\t// if it is the first Unicode code point in the source text.\n+\tif leadingBytes, err := b.Peek(3); err == nil && bytes.Equal(leadingBytes, bom) {\n+\t\tb.Discard(3)\n+\t}\n+\treturn &importReader{b: b}\n+}\n+\n func isIdent(c byte) bool {\n \treturn 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '_' || c >= utf8.RuneSelf\n }\n@@ -201,7 +215,7 @@ func (r *importReader) readImport(imports *[]string) {\n // ReadComments is like io.ReadAll, except that it only reads the leading\n // block of comments in the file.\n func ReadComments(f io.Reader) ([]byte, error) {\n-\tr := &importReader{b: bufio.NewReader(f)}\n+\tr := newImportReader(bufio.NewReader(f))\n \tr.peekByte(true)\n \tif r.err == nil && !r.eof {\n \t\t// Didn't reach EOF, so must have found a non-space byte. Remove it.\n@@ -213,7 +227,7 @@ func ReadComments(f io.Reader) ([]byte, error) {\n // ReadImports is like io.ReadAll, except that it expects a Go file as input\n // and stops reading the input once the imports have completed.\n func ReadImports(f io.Reader, reportSyntaxError bool, imports *[]string) ([]byte, error) {\n-\tr := &importReader{b: bufio.NewReader(f)}\n+\tr := newImportReader(bufio.NewReader(f))\n \n \tr.readKeyword(\"package\")\n \tr.readIdent()"}, {"sha": "6a1a6524a116d50c8036baa0b0ff3d60e08ccf1a", "filename": "libgo/go/cmd/go/internal/imports/read_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fread_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -66,6 +66,10 @@ var readImportsTests = []readTest{\n \t\t`,\n \t\t\"\",\n \t},\n+\t{\n+\t\t\"\\ufeff\ud835\udd3b\" + `package p; import \"x\";\u2119var x = 1`,\n+\t\t\"\",\n+\t},\n }\n \n var readCommentsTests = []readTest{\n@@ -81,6 +85,10 @@ var readCommentsTests = []readTest{\n \t\t`\u2119package p; import . \"x\"`,\n \t\t\"\",\n \t},\n+\t{\n+\t\t\"\\ufeff\ud835\udd3b\" + `\u2119package p; import . \"x\"`,\n+\t\t\"\",\n+\t},\n \t{\n \t\t`// foo\n \n@@ -90,6 +98,19 @@ var readCommentsTests = []readTest{\n \t\t\n \t\t/*/ zot */\n \n+\t\t// asdf\n+\t\t\u2119Hello, world`,\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t\"\\ufeff\ud835\udd3b\" + `// foo\n+\n+\t\t/* bar */\n+\n+\t\t/* quux */ // baz\n+\n+\t\t/*/ zot */\n+\n \t\t// asdf\n \t\t\u2119Hello, world`,\n \t\t\"\",\n@@ -107,6 +128,11 @@ func testRead(t *testing.T, tests []readTest, read func(io.Reader) ([]byte, erro\n \t\t\tin = tt.in[:j] + tt.in[j+len(\"\u2119\"):]\n \t\t\ttestOut = tt.in[:j]\n \t\t}\n+\t\td := strings.Index(tt.in, \"\ud835\udd3b\")\n+\t\tif d >= 0 {\n+\t\t\tin = in[:d] + in[d+len(\"\ud835\udd3b\"):]\n+\t\t\ttestOut = testOut[d+len(\"\ud835\udd3b\"):]\n+\t\t}\n \t\tr := strings.NewReader(in)\n \t\tbuf, err := read(r)\n \t\tif err != nil {"}, {"sha": "aaf5a6b91d7fa9bc3fd3b0be1dc163f000abbe1f", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/tags.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ftags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ftags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ftags.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1 @@\n+android arm64\n\\ No newline at end of file"}, {"sha": "0fdf397db08b5cecda1b6394d4fef7395c1933ba", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/want.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fwant.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fwant.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fwant.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+a\n+b\n+c\n+d\n+e\n+f"}, {"sha": "b6386a32605da28470daea37889bc67ac633db2f", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/tags.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ftags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ftags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ftags.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1 @@\n+illumos amd64"}, {"sha": "0fdf397db08b5cecda1b6394d4fef7395c1933ba", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/want.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fwant.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fwant.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fwant.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+a\n+b\n+c\n+d\n+e\n+f"}, {"sha": "f59ec20aabf5842d237244ece8c81ab184faeac1", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/tags.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Ftags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Ftags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Ftags.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1 @@\n+*\n\\ No newline at end of file"}, {"sha": "139f5f49755c40f251f28e427f1a112c8eae12f9", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/want.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fwant.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fwant.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fwant.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,4 @@\n+import1\n+import2\n+import3\n+import4"}, {"sha": "2dc63766b70654576156bebd007d6b35c0def832", "filename": "libgo/go/cmd/go/internal/list/context.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -17,6 +17,7 @@ type Context struct {\n \tUseAllFiles   bool     `json:\",omitempty\"` // use files regardless of +build lines, file names\n \tCompiler      string   `json:\",omitempty\"` // compiler to assume when computing target paths\n \tBuildTags     []string `json:\",omitempty\"` // build constraints to match in +build lines\n+\tToolTags      []string `json:\",omitempty\"` // toolchain-specific build constraints\n \tReleaseTags   []string `json:\",omitempty\"` // releases the current release is compatible with\n \tInstallSuffix string   `json:\",omitempty\"` // suffix to use in the name of the install dir\n }\n@@ -31,6 +32,7 @@ func newContext(c *build.Context) *Context {\n \t\tUseAllFiles:   c.UseAllFiles,\n \t\tCompiler:      c.Compiler,\n \t\tBuildTags:     c.BuildTags,\n+\t\tToolTags:      c.ToolTags,\n \t\tReleaseTags:   c.ReleaseTags,\n \t\tInstallSuffix: c.InstallSuffix,\n \t}"}, {"sha": "7cb9ec6d9492428aa0c9afe111fde89bf35fa536", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -148,6 +148,7 @@ The template function \"context\" returns the build context, defined as:\n         UseAllFiles   bool     // use files regardless of +build lines, file names\n         Compiler      string   // compiler to assume when computing target paths\n         BuildTags     []string // build constraints to match in +build lines\n+        ToolTags      []string // toolchain-specific build constraints\n         ReleaseTags   []string // releases the current release is compatible with\n         InstallSuffix string   // suffix to use in the name of the install dir\n     }\n@@ -335,7 +336,10 @@ var (\n var nl = []byte{'\\n'}\n \n func runList(ctx context.Context, cmd *base.Command, args []string) {\n-\tload.ModResolveTests = *listTest\n+\tif *listFmt != \"\" && *listJson == true {\n+\t\tbase.Fatalf(\"go list -f cannot be used with -json\")\n+\t}\n+\n \twork.BuildInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n@@ -344,7 +348,7 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\tif *listM {\n \t\t\t*listFmt = \"{{.String}}\"\n \t\t\tif *listVersions {\n-\t\t\t\t*listFmt = `{{.Path}}{{range .Versions}} {{.}}{{end}}`\n+\t\t\t\t*listFmt = `{{.Path}}{{range .Versions}} {{.}}{{end}}{{if .Deprecated}} (deprecated){{end}}`\n \t\t\t}\n \t\t} else {\n \t\t\t*listFmt = \"{{.ImportPath}}\"\n@@ -423,7 +427,7 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tbase.Fatalf(\"go list -m: not using modules\")\n \t\t}\n \n-\t\tmodload.LoadModFile(ctx) // Parses go.mod and sets cfg.BuildMod.\n+\t\tmodload.LoadModFile(ctx) // Sets cfg.BuildMod as a side-effect.\n \t\tif cfg.BuildMod == \"vendor\" {\n \t\t\tconst actionDisabledFormat = \"go list -m: can't %s using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\"\n \n@@ -447,13 +451,29 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \n-\t\tmods := modload.ListModules(ctx, args, *listU, *listVersions, *listRetracted)\n+\t\tvar mode modload.ListMode\n+\t\tif *listU {\n+\t\t\tmode |= modload.ListU | modload.ListRetracted | modload.ListDeprecated\n+\t\t}\n+\t\tif *listRetracted {\n+\t\t\tmode |= modload.ListRetracted\n+\t\t}\n+\t\tif *listVersions {\n+\t\t\tmode |= modload.ListVersions\n+\t\t\tif *listRetracted {\n+\t\t\t\tmode |= modload.ListRetractedVersions\n+\t\t\t}\n+\t\t}\n+\t\tmods, err := modload.ListModules(ctx, args, mode)\n \t\tif !*listE {\n \t\t\tfor _, m := range mods {\n \t\t\t\tif m.Error != nil {\n \t\t\t\t\tbase.Errorf(\"go list -m: %v\", m.Error.Err)\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Errorf(\"go list -m: %v\", err)\n+\t\t\t}\n \t\t\tbase.ExitIfErrors()\n \t\t}\n \t\tfor _, m := range mods {\n@@ -478,8 +498,11 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\tbase.Fatalf(\"go list -test cannot be used with -find\")\n \t}\n \n-\tload.IgnoreImports = *listFind\n-\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tpkgOpts := load.PackageOpts{\n+\t\tIgnoreImports:   *listFind,\n+\t\tModResolveTests: *listTest,\n+\t}\n+\tpkgs := load.PackagesAndErrors(ctx, pkgOpts, args)\n \tif !*listE {\n \t\tw := 0\n \t\tfor _, pkg := range pkgs {\n@@ -516,9 +539,9 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\tvar pmain, ptest, pxtest *load.Package\n \t\t\t\tvar err error\n \t\t\t\tif *listE {\n-\t\t\t\t\tpmain, ptest, pxtest = load.TestPackagesAndErrors(ctx, p, nil)\n+\t\t\t\t\tpmain, ptest, pxtest = load.TestPackagesAndErrors(ctx, pkgOpts, p, nil)\n \t\t\t\t} else {\n-\t\t\t\t\tpmain, ptest, pxtest, err = load.TestPackagesFor(ctx, p, nil)\n+\t\t\t\t\tpmain, ptest, pxtest, err = load.TestPackagesFor(ctx, pkgOpts, p, nil)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tbase.Errorf(\"can't load test package: %s\", err)\n \t\t\t\t\t}\n@@ -605,7 +628,7 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\told := make(map[string]string)\n \t\tfor _, p := range all {\n \t\t\tif p.ForTest != \"\" {\n-\t\t\t\tnew := p.ImportPath + \" [\" + p.ForTest + \".test]\"\n+\t\t\t\tnew := p.Desc()\n \t\t\t\told[new] = p.ImportPath\n \t\t\t\tp.ImportPath = new\n \t\t\t}\n@@ -679,9 +702,14 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \n \t\tif len(args) > 0 {\n-\t\t\tlistU := false\n-\t\t\tlistVersions := false\n-\t\t\trmods := modload.ListModules(ctx, args, listU, listVersions, *listRetracted)\n+\t\t\tvar mode modload.ListMode\n+\t\t\tif *listRetracted {\n+\t\t\t\tmode |= modload.ListRetracted\n+\t\t\t}\n+\t\t\trmods, err := modload.ListModules(ctx, args, mode)\n+\t\t\tif err != nil && !*listE {\n+\t\t\t\tbase.Errorf(\"go list -retracted: %v\", err)\n+\t\t\t}\n \t\t\tfor i, arg := range args {\n \t\t\t\trmod := rmods[i]\n \t\t\t\tfor _, mod := range argToMods[arg] {\n@@ -696,8 +724,18 @@ func runList(ctx context.Context, cmd *base.Command, args []string) {\n \n \t// Record non-identity import mappings in p.ImportMap.\n \tfor _, p := range pkgs {\n-\t\tfor i, srcPath := range p.Internal.RawImports {\n-\t\t\tpath := p.Imports[i]\n+\t\tnRaw := len(p.Internal.RawImports)\n+\t\tfor i, path := range p.Imports {\n+\t\t\tvar srcPath string\n+\t\t\tif i < nRaw {\n+\t\t\t\tsrcPath = p.Internal.RawImports[i]\n+\t\t\t} else {\n+\t\t\t\t// This path is not within the raw imports, so it must be an import\n+\t\t\t\t// found only within CompiledGoFiles. Those paths are found in\n+\t\t\t\t// CompiledImports.\n+\t\t\t\tsrcPath = p.Internal.CompiledImports[i-nRaw]\n+\t\t\t}\n+\n \t\t\tif path != srcPath {\n \t\t\t\tif p.ImportMap == nil {\n \t\t\t\t\tp.ImportMap = make(map[string]string)"}, {"sha": "440cb86134489a7e023ce516629fe9bccc00fe0c", "filename": "libgo/go/cmd/go/internal/load/flag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -34,7 +34,7 @@ type ppfValue struct {\n \n // Set is called each time the flag is encountered on the command line.\n func (f *PerPackageFlag) Set(v string) error {\n-\treturn f.set(v, base.Cwd)\n+\treturn f.set(v, base.Cwd())\n }\n \n // set is the implementation of Set, taking a cwd (current working directory) for easier testing."}, {"sha": "c085fcbbf80faaa32677f605dea702182ddabf19", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 369, "deletions": 102, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"go/build\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"internal/goroot\"\n \t\"io/fs\"\n \t\"os\"\n \t\"path\"\n@@ -29,6 +30,8 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modinfo\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/par\"\n@@ -37,11 +40,10 @@ import (\n \t\"cmd/go/internal/trace\"\n \t\"cmd/internal/sys\"\n \n+\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n )\n \n-var IgnoreImports bool // control whether we ignore imports in packages\n-\n // A Package describes a single package found in a directory.\n type Package struct {\n \tPackagePublic                 // visible in 'go list'\n@@ -85,6 +87,7 @@ type PackagePublic struct {\n \tCgoFiles          []string `json:\",omitempty\"` // .go source files that import \"C\"\n \tCompiledGoFiles   []string `json:\",omitempty\"` // .go output from running cgo on CgoFiles\n \tIgnoredGoFiles    []string `json:\",omitempty\"` // .go source files ignored due to build constraints\n+\tInvalidGoFiles    []string `json:\",omitempty\"` // .go source files with detected problems (parse error, wrong package name, and so on)\n \tIgnoredOtherFiles []string `json:\",omitempty\"` // non-.go source files ignored due to build constraints\n \tCFiles            []string `json:\",omitempty\"` // .c source files\n \tCXXFiles          []string `json:\",omitempty\"` // .cc, .cpp and .cxx source files\n@@ -142,6 +145,7 @@ func (p *Package) AllFiles() []string {\n \t\tp.CgoFiles,\n \t\t// no p.CompiledGoFiles, because they are from GoFiles or generated by us\n \t\tp.IgnoredGoFiles,\n+\t\t// no p.InvalidGoFiles, because they are from GoFiles\n \t\tp.IgnoredOtherFiles,\n \t\tp.CFiles,\n \t\tp.CXXFiles,\n@@ -190,8 +194,8 @@ type PackageInternal struct {\n \t// Unexported fields are not part of the public API.\n \tBuild             *build.Package\n \tImports           []*Package           // this package's direct imports\n-\tCompiledImports   []string             // additional Imports necessary when using CompiledGoFiles (all from standard library)\n-\tRawImports        []string             // this package's original imports as they appear in the text of the program\n+\tCompiledImports   []string             // additional Imports necessary when using CompiledGoFiles (all from standard library); 1:1 with the end of PackagePublic.Imports\n+\tRawImports        []string             // this package's original imports as they appear in the text of the program; 1:1 with the end of PackagePublic.Imports\n \tForceLibrary      bool                 // this package is a library (even if named \"main\")\n \tCmdlineFiles      bool                 // package built from files listed on command line\n \tCmdlinePkg        bool                 // package listed on command line\n@@ -206,6 +210,7 @@ type PackageInternal struct {\n \tBuildInfo         string               // add this info to package main\n \tTestmainGo        *[]byte              // content for _testmain.go\n \tEmbed             map[string][]string  // //go:embed comment mapping\n+\tOrigImportPath    string               // original import path before adding '_test' suffix\n \n \tAsmflags   []string // -asmflags for this package\n \tGcflags    []string // -gcflags for this package\n@@ -343,7 +348,7 @@ type CoverVar struct {\n \tVar  string // name of count struct\n }\n \n-func (p *Package) copyBuild(pp *build.Package) {\n+func (p *Package) copyBuild(opts PackageOpts, pp *build.Package) {\n \tp.Internal.Build = pp\n \n \tif pp.PkgTargetRoot != \"\" && cfg.BuildPkgdir != \"\" {\n@@ -368,6 +373,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.GoFiles = pp.GoFiles\n \tp.CgoFiles = pp.CgoFiles\n \tp.IgnoredGoFiles = pp.IgnoredGoFiles\n+\tp.InvalidGoFiles = pp.InvalidGoFiles\n \tp.IgnoredOtherFiles = pp.IgnoredOtherFiles\n \tp.CFiles = pp.CFiles\n \tp.CXXFiles = pp.CXXFiles\n@@ -392,7 +398,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.TestImports = pp.TestImports\n \tp.XTestGoFiles = pp.XTestGoFiles\n \tp.XTestImports = pp.XTestImports\n-\tif IgnoreImports {\n+\tif opts.IgnoreImports {\n \t\tp.Imports = nil\n \t\tp.Internal.RawImports = nil\n \t\tp.TestImports = nil\n@@ -401,6 +407,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.EmbedPatterns = pp.EmbedPatterns\n \tp.TestEmbedPatterns = pp.TestEmbedPatterns\n \tp.XTestEmbedPatterns = pp.XTestEmbedPatterns\n+\tp.Internal.OrigImportPath = pp.ImportPath\n }\n \n // A PackageError describes an error loading information about a package.\n@@ -476,8 +483,10 @@ type ImportPathError interface {\n \n var (\n \t_ ImportPathError = (*importError)(nil)\n+\t_ ImportPathError = (*mainPackageError)(nil)\n \t_ ImportPathError = (*modload.ImportMissingError)(nil)\n \t_ ImportPathError = (*modload.ImportMissingSumError)(nil)\n+\t_ ImportPathError = (*modload.DirectImportFromImplicitDependencyError)(nil)\n )\n \n type importError struct {\n@@ -597,7 +606,7 @@ func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {\n \t\t})\n \t\tpackageDataCache.Delete(p.ImportPath)\n \t}\n-\treturn LoadImport(context.TODO(), arg, base.Cwd, nil, stk, nil, 0)\n+\treturn LoadImport(context.TODO(), PackageOpts{}, arg, base.Cwd(), nil, stk, nil, 0)\n }\n \n // dirToImportPath returns the pseudo-import path we use for a package\n@@ -649,11 +658,11 @@ const (\n // LoadImport does not set tool flags and should only be used by\n // this package, as part of a bigger load operation, and by GOPATH-based \"go get\".\n // TODO(rsc): When GOPATH-based \"go get\" is removed, unexport this function.\n-func LoadImport(ctx context.Context, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n-\treturn loadImport(ctx, nil, path, srcDir, parent, stk, importPos, mode)\n+func LoadImport(ctx context.Context, opts PackageOpts, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\treturn loadImport(ctx, opts, nil, path, srcDir, parent, stk, importPos, mode)\n }\n \n-func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+func loadImport(ctx context.Context, opts PackageOpts, pre *preload, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n \tif path == \"\" {\n \t\tpanic(\"LoadImport called with empty package path\")\n \t}\n@@ -665,25 +674,30 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t\tparentRoot = parent.Root\n \t\tparentIsStd = parent.Standard\n \t}\n-\tbp, loaded, err := loadPackageData(path, parentPath, srcDir, parentRoot, parentIsStd, mode)\n-\tif loaded && pre != nil && !IgnoreImports {\n-\t\tpre.preloadImports(bp.Imports, bp)\n+\tbp, loaded, err := loadPackageData(ctx, path, parentPath, srcDir, parentRoot, parentIsStd, mode)\n+\tif loaded && pre != nil && !opts.IgnoreImports {\n+\t\tpre.preloadImports(ctx, opts, bp.Imports, bp)\n \t}\n \tif bp == nil {\n-\t\tif importErr, ok := err.(ImportPathError); !ok || importErr.ImportPath() != path {\n-\t\t\t// Only add path to the error's import stack if it's not already present on the error.\n-\t\t\tstk.Push(path)\n-\t\t\tdefer stk.Pop()\n-\t\t}\n-\t\treturn &Package{\n+\t\tp := &Package{\n \t\t\tPackagePublic: PackagePublic{\n \t\t\t\tImportPath: path,\n-\t\t\t\tError: &PackageError{\n-\t\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\t\tErr:         err,\n-\t\t\t\t},\n+\t\t\t\tIncomplete: true,\n \t\t\t},\n \t\t}\n+\t\tif importErr, ok := err.(ImportPathError); !ok || importErr.ImportPath() != path {\n+\t\t\t// Only add path to the error's import stack if it's not already present\n+\t\t\t// in the error.\n+\t\t\t//\n+\t\t\t// TODO(bcmills): setLoadPackageDataError itself has a similar Push / Pop\n+\t\t\t// sequence that empirically doesn't trigger for these errors, guarded by\n+\t\t\t// a somewhat complex condition. Figure out how to generalize that\n+\t\t\t// condition and eliminate the explicit calls here.\n+\t\t\tstk.Push(path)\n+\t\t\tdefer stk.Pop()\n+\t\t}\n+\t\tp.setLoadPackageDataError(err, path, stk, nil)\n+\t\treturn p\n \t}\n \n \timportPath := bp.ImportPath\n@@ -701,7 +715,7 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t\t// Load package.\n \t\t// loadPackageData may return bp != nil even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tp.load(ctx, path, stk, importPos, bp, err)\n+\t\tp.load(ctx, opts, path, stk, importPos, bp, err)\n \n \t\tif !cfg.ModulesEnabled && path != cleanImport(path) {\n \t\t\tp.Error = &PackageError{\n@@ -714,7 +728,7 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n \t}\n \n \t// Checked on every import because the rules depend on the code doing the importing.\n-\tif perr := disallowInternal(srcDir, parent, parentPath, p, stk); perr != p {\n+\tif perr := disallowInternal(ctx, srcDir, parent, parentPath, p, stk); perr != p {\n \t\tperr.Error.setPos(importPos)\n \t\treturn perr\n \t}\n@@ -763,7 +777,7 @@ func loadImport(ctx context.Context, pre *preload, path, srcDir string, parent *\n //\n // loadPackageData returns a boolean, loaded, which is true if this is the\n // first time the package was loaded. Callers may preload imports in this case.\n-func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd bool, mode int) (bp *build.Package, loaded bool, err error) {\n+func loadPackageData(ctx context.Context, path, parentPath, parentDir, parentRoot string, parentIsStd bool, mode int) (bp *build.Package, loaded bool, err error) {\n \tif path == \"\" {\n \t\tpanic(\"loadPackageData called with empty package path\")\n \t}\n@@ -835,11 +849,34 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t\t\t\tbuildMode = build.ImportComment\n \t\t\t}\n \t\t\tdata.p, data.err = cfg.BuildContext.ImportDir(r.dir, buildMode)\n-\t\t\tif data.p.Root == \"\" && cfg.ModulesEnabled {\n-\t\t\t\tif info := modload.PackageModuleInfo(path); info != nil {\n+\t\t\tif cfg.ModulesEnabled {\n+\t\t\t\t// Override data.p.Root, since ImportDir sets it to $GOPATH, if\n+\t\t\t\t// the module is inside $GOPATH/src.\n+\t\t\t\tif info := modload.PackageModuleInfo(ctx, path); info != nil {\n \t\t\t\t\tdata.p.Root = info.Dir\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif r.err != nil {\n+\t\t\t\tif data.err != nil {\n+\t\t\t\t\t// ImportDir gave us one error, and the module loader gave us another.\n+\t\t\t\t\t// We arbitrarily choose to keep the error from ImportDir because\n+\t\t\t\t\t// that's what our tests already expect, and it seems to provide a bit\n+\t\t\t\t\t// more detail in most cases.\n+\t\t\t\t} else if errors.Is(r.err, imports.ErrNoGo) {\n+\t\t\t\t\t// ImportDir said there were files in the package, but the module\n+\t\t\t\t\t// loader said there weren't. Which one is right?\n+\t\t\t\t\t// Without this special-case hack, the TestScript/test_vet case fails\n+\t\t\t\t\t// on the vetfail/p1 package (added in CL 83955).\n+\t\t\t\t\t// Apparently, imports.ShouldBuild biases toward rejecting files\n+\t\t\t\t\t// with invalid build constraints, whereas ImportDir biases toward\n+\t\t\t\t\t// accepting them.\n+\t\t\t\t\t//\n+\t\t\t\t\t// TODO(#41410: Figure out how this actually ought to work and fix\n+\t\t\t\t\t// this mess.\n+\t\t\t\t} else {\n+\t\t\t\t\tdata.err = r.err\n+\t\t\t\t}\n+\t\t\t}\n \t\t} else if r.err != nil {\n \t\t\tdata.p = new(build.Package)\n \t\t\tdata.err = r.err\n@@ -950,7 +987,7 @@ func newPreload() *preload {\n // preloadMatches loads data for package paths matched by patterns.\n // When preloadMatches returns, some packages may not be loaded yet, but\n // loadPackageData and loadImport are always safe to call.\n-func (pre *preload) preloadMatches(matches []*search.Match) {\n+func (pre *preload) preloadMatches(ctx context.Context, opts PackageOpts, matches []*search.Match) {\n \tfor _, m := range matches {\n \t\tfor _, pkg := range m.Pkgs {\n \t\t\tselect {\n@@ -959,10 +996,10 @@ func (pre *preload) preloadMatches(matches []*search.Match) {\n \t\t\tcase pre.sema <- struct{}{}:\n \t\t\t\tgo func(pkg string) {\n \t\t\t\t\tmode := 0 // don't use vendoring or module import resolution\n-\t\t\t\t\tbp, loaded, err := loadPackageData(pkg, \"\", base.Cwd, \"\", false, mode)\n+\t\t\t\t\tbp, loaded, err := loadPackageData(ctx, pkg, \"\", base.Cwd(), \"\", false, mode)\n \t\t\t\t\t<-pre.sema\n-\t\t\t\t\tif bp != nil && loaded && err == nil && !IgnoreImports {\n-\t\t\t\t\t\tpre.preloadImports(bp.Imports, bp)\n+\t\t\t\t\tif bp != nil && loaded && err == nil && !opts.IgnoreImports {\n+\t\t\t\t\t\tpre.preloadImports(ctx, opts, bp.Imports, bp)\n \t\t\t\t\t}\n \t\t\t\t}(pkg)\n \t\t\t}\n@@ -973,7 +1010,7 @@ func (pre *preload) preloadMatches(matches []*search.Match) {\n // preloadImports queues a list of imports for preloading.\n // When preloadImports returns, some packages may not be loaded yet,\n // but loadPackageData and loadImport are always safe to call.\n-func (pre *preload) preloadImports(imports []string, parent *build.Package) {\n+func (pre *preload) preloadImports(ctx context.Context, opts PackageOpts, imports []string, parent *build.Package) {\n \tparentIsStd := parent.Goroot && parent.ImportPath != \"\" && search.IsStandardImportPath(parent.ImportPath)\n \tfor _, path := range imports {\n \t\tif path == \"C\" || path == \"unsafe\" {\n@@ -984,10 +1021,10 @@ func (pre *preload) preloadImports(imports []string, parent *build.Package) {\n \t\t\treturn\n \t\tcase pre.sema <- struct{}{}:\n \t\t\tgo func(path string) {\n-\t\t\t\tbp, loaded, err := loadPackageData(path, parent.ImportPath, parent.Dir, parent.Root, parentIsStd, ResolveImport)\n+\t\t\t\tbp, loaded, err := loadPackageData(ctx, path, parent.ImportPath, parent.Dir, parent.Root, parentIsStd, ResolveImport)\n \t\t\t\t<-pre.sema\n-\t\t\t\tif bp != nil && loaded && err == nil && !IgnoreImports {\n-\t\t\t\t\tpre.preloadImports(bp.Imports, bp)\n+\t\t\t\tif bp != nil && loaded && err == nil && !opts.IgnoreImports {\n+\t\t\t\t\tpre.preloadImports(ctx, opts, bp.Imports, bp)\n \t\t\t\t}\n \t\t\t}(path)\n \t\t}\n@@ -1323,6 +1360,11 @@ func reusePackage(p *Package, stk *ImportStack) *Package {\n \t\t\t\tErr:           errors.New(\"import cycle not allowed\"),\n \t\t\t\tIsImportCycle: true,\n \t\t\t}\n+\t\t} else if !p.Error.IsImportCycle {\n+\t\t\t// If the error is already set, but it does not indicate that\n+\t\t\t// we are in an import cycle, set IsImportCycle so that we don't\n+\t\t\t// end up stuck in a loop down the road.\n+\t\t\tp.Error.IsImportCycle = true\n \t\t}\n \t\tp.Incomplete = true\n \t}\n@@ -1338,7 +1380,7 @@ func reusePackage(p *Package, stk *ImportStack) *Package {\n // is allowed to import p.\n // If the import is allowed, disallowInternal returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowInternal(srcDir string, importer *Package, importerPath string, p *Package, stk *ImportStack) *Package {\n+func disallowInternal(ctx context.Context, srcDir string, importer *Package, importerPath string, p *Package, stk *ImportStack) *Package {\n \t// golang.org/s/go14internal:\n \t// An import of a path containing the element \u201cinternal\u201d\n \t// is disallowed if the importing code is outside the tree\n@@ -1416,7 +1458,7 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t\t\t// directory containing them.\n \t\t\t// If the directory is outside the main module, this will resolve to \".\",\n \t\t\t// which is not a prefix of any valid module.\n-\t\t\timporterPath = modload.DirImportPath(importer.Dir)\n+\t\t\timporterPath = modload.DirImportPath(ctx, importer.Dir)\n \t\t}\n \t\tparentOfInternal := p.ImportPath[:i]\n \t\tif str.HasPathPrefix(importerPath, parentOfInternal) {\n@@ -1638,8 +1680,8 @@ func (p *Package) DefaultExecName() string {\n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n // stk contains the import stack, not including path itself.\n-func (p *Package) load(ctx context.Context, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n-\tp.copyBuild(bp)\n+func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error) {\n+\tp.copyBuild(opts, bp)\n \n \t// The localPrefix is the path we interpret ./ imports relative to.\n \t// Synthesized main packages sometimes override this.\n@@ -1763,35 +1805,37 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\t}\n \t}\n \n-\t// Cgo translation adds imports of \"unsafe\", \"runtime/cgo\" and \"syscall\",\n-\t// except for certain packages, to avoid circular dependencies.\n-\tif p.UsesCgo() {\n-\t\taddImport(\"unsafe\", true)\n-\t}\n-\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) && cfg.BuildContext.Compiler != \"gccgo\" {\n-\t\taddImport(\"runtime/cgo\", true)\n-\t}\n-\tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n-\t\taddImport(\"syscall\", true)\n-\t}\n-\n-\t// SWIG adds imports of some standard packages.\n-\tif p.UsesSwig() {\n-\t\taddImport(\"unsafe\", true)\n-\t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n+\tif !opts.IgnoreImports {\n+\t\t// Cgo translation adds imports of \"unsafe\", \"runtime/cgo\" and \"syscall\",\n+\t\t// except for certain packages, to avoid circular dependencies.\n+\t\tif p.UsesCgo() {\n+\t\t\taddImport(\"unsafe\", true)\n+\t\t}\n+\t\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) && cfg.BuildContext.Compiler != \"gccgo\" {\n \t\t\taddImport(\"runtime/cgo\", true)\n \t\t}\n-\t\taddImport(\"syscall\", true)\n-\t\taddImport(\"sync\", true)\n+\t\tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n+\t\t\taddImport(\"syscall\", true)\n+\t\t}\n \n-\t\t// TODO: The .swig and .swigcxx files can use\n-\t\t// %go_import directives to import other packages.\n-\t}\n+\t\t// SWIG adds imports of some standard packages.\n+\t\tif p.UsesSwig() {\n+\t\t\taddImport(\"unsafe\", true)\n+\t\t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n+\t\t\t\taddImport(\"runtime/cgo\", true)\n+\t\t\t}\n+\t\t\taddImport(\"syscall\", true)\n+\t\t\taddImport(\"sync\", true)\n \n-\t// The linker loads implicit dependencies.\n-\tif p.Name == \"main\" && !p.Internal.ForceLibrary {\n-\t\tfor _, dep := range LinkerDeps(p) {\n-\t\t\taddImport(dep, false)\n+\t\t\t// TODO: The .swig and .swigcxx files can use\n+\t\t\t// %go_import directives to import other packages.\n+\t\t}\n+\n+\t\t// The linker loads implicit dependencies.\n+\t\tif p.Name == \"main\" && !p.Internal.ForceLibrary {\n+\t\t\tfor _, dep := range LinkerDeps(p) {\n+\t\t\t\taddImport(dep, false)\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -1815,6 +1859,14 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \tstk.Push(path)\n \tdefer stk.Pop()\n \n+\tpkgPath := p.ImportPath\n+\tif p.Internal.CmdlineFiles {\n+\t\tpkgPath = \"command-line-arguments\"\n+\t}\n+\tif cfg.ModulesEnabled {\n+\t\tp.Module = modload.PackageModuleInfo(ctx, pkgPath)\n+\t}\n+\n \tp.EmbedFiles, p.Internal.Embed, err = resolveEmbed(p.Dir, p.EmbedPatterns)\n \tif err != nil {\n \t\tp.Incomplete = true\n@@ -1858,7 +1910,7 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n-\t\tp1 := LoadImport(ctx, path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n+\t\tp1 := LoadImport(ctx, opts, path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n \n \t\tpath = p1.ImportPath\n \t\timportPaths[i] = path\n@@ -1874,6 +1926,10 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \tp.Internal.Imports = imports\n \tp.collectDeps()\n \n+\tif cfg.ModulesEnabled && p.Error == nil && p.Name == \"main\" && len(p.DepsErrors) == 0 {\n+\t\tp.Internal.BuildInfo = modload.PackageBuildInfo(pkgPath, p.Deps)\n+\t}\n+\n \t// unsafe is a fake package.\n \tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n \t\tp.Target = \"\"\n@@ -1913,17 +1969,6 @@ func (p *Package) load(ctx context.Context, path string, stk *ImportStack, impor\n \t\tsetError(fmt.Errorf(\"Fortran source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.FFiles, \" \")))\n \t\treturn\n \t}\n-\n-\tif cfg.ModulesEnabled && p.Error == nil {\n-\t\tmainPath := p.ImportPath\n-\t\tif p.Internal.CmdlineFiles {\n-\t\t\tmainPath = \"command-line-arguments\"\n-\t\t}\n-\t\tp.Module = modload.PackageModuleInfo(mainPath)\n-\t\tif p.Name == \"main\" && len(p.DepsErrors) == 0 {\n-\t\t\tp.Internal.BuildInfo = modload.PackageBuildInfo(mainPath, p.Deps)\n-\t\t}\n-\t}\n }\n \n // An EmbedError indicates a problem with a go:embed directive.\n@@ -2305,7 +2350,7 @@ func PackageList(roots []*Package) []*Package {\n // TestPackageList returns the list of packages in the dag rooted at roots\n // as visited in a depth-first post-order traversal, including the test\n // imports of the roots. This ignores errors in test packages.\n-func TestPackageList(ctx context.Context, roots []*Package) []*Package {\n+func TestPackageList(ctx context.Context, opts PackageOpts, roots []*Package) []*Package {\n \tseen := map[*Package]bool{}\n \tall := []*Package{}\n \tvar walk func(*Package)\n@@ -2321,7 +2366,7 @@ func TestPackageList(ctx context.Context, roots []*Package) []*Package {\n \t}\n \twalkTest := func(root *Package, path string) {\n \t\tvar stk ImportStack\n-\t\tp1 := LoadImport(ctx, path, root.Dir, root, &stk, root.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tp1 := LoadImport(ctx, opts, path, root.Dir, root, &stk, root.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif p1.Error == nil {\n \t\t\twalk(p1)\n \t\t}\n@@ -2344,22 +2389,35 @@ func TestPackageList(ctx context.Context, roots []*Package) []*Package {\n // TODO(jayconrod): delete this function and set flags automatically\n // in LoadImport instead.\n func LoadImportWithFlags(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n-\tp := LoadImport(context.TODO(), path, srcDir, parent, stk, importPos, mode)\n+\tp := LoadImport(context.TODO(), PackageOpts{}, path, srcDir, parent, stk, importPos, mode)\n \tsetToolFlags(p)\n \treturn p\n }\n \n-// ModResolveTests indicates whether calls to the module loader should also\n-// resolve test dependencies of the requested packages.\n-//\n-// If ModResolveTests is true, then the module loader needs to resolve test\n-// dependencies at the same time as packages; otherwise, the test dependencies\n-// of those packages could be missing, and resolving those missing dependencies\n-// could change the selected versions of modules that provide other packages.\n-//\n-// TODO(#40775): Change this from a global variable to an explicit function\n-// argument where needed.\n-var ModResolveTests bool\n+// PackageOpts control the behavior of PackagesAndErrors and other package\n+// loading functions.\n+type PackageOpts struct {\n+\t// IgnoreImports controls whether we ignore explicit and implicit imports\n+\t// when loading packages.  Implicit imports are added when supporting Cgo\n+\t// or SWIG and when linking main packages.\n+\tIgnoreImports bool\n+\n+\t// ModResolveTests indicates whether calls to the module loader should also\n+\t// resolve test dependencies of the requested packages.\n+\t//\n+\t// If ModResolveTests is true, then the module loader needs to resolve test\n+\t// dependencies at the same time as packages; otherwise, the test dependencies\n+\t// of those packages could be missing, and resolving those missing dependencies\n+\t// could change the selected versions of modules that provide other packages.\n+\tModResolveTests bool\n+\n+\t// MainOnly is true if the caller only wants to load main packages.\n+\t// For a literal argument matching a non-main package, a stub may be returned\n+\t// with an error. For a non-literal argument (with \"...\"), non-main packages\n+\t// are not be matched, and their dependencies may not be loaded. A warning\n+\t// may be printed for non-literal arguments that match no main packages.\n+\tMainOnly bool\n+}\n \n // PackagesAndErrors returns the packages named by the command line arguments\n // 'patterns'. If a named package cannot be loaded, PackagesAndErrors returns\n@@ -2369,7 +2427,7 @@ var ModResolveTests bool\n //\n // To obtain a flat list of packages, use PackageList.\n // To report errors loading packages, use ReportPackageErrors.\n-func PackagesAndErrors(ctx context.Context, patterns []string) []*Package {\n+func PackagesAndErrors(ctx context.Context, opts PackageOpts, patterns []string) []*Package {\n \tctx, span := trace.StartSpan(ctx, \"load.PackagesAndErrors\")\n \tdefer span.Done()\n \n@@ -2381,19 +2439,19 @@ func PackagesAndErrors(ctx context.Context, patterns []string) []*Package {\n \t\t\t// We need to test whether the path is an actual Go file and not a\n \t\t\t// package path or pattern ending in '.go' (see golang.org/issue/34653).\n \t\t\tif fi, err := fsys.Stat(p); err == nil && !fi.IsDir() {\n-\t\t\t\treturn []*Package{GoFilesPackage(ctx, patterns)}\n+\t\t\t\treturn []*Package{GoFilesPackage(ctx, opts, patterns)}\n \t\t\t}\n \t\t}\n \t}\n \n \tvar matches []*search.Match\n \tif modload.Init(); cfg.ModulesEnabled {\n-\t\tloadOpts := modload.PackageOpts{\n+\t\tmodOpts := modload.PackageOpts{\n \t\t\tResolveMissingImports: true,\n-\t\t\tLoadTests:             ModResolveTests,\n-\t\t\tSilenceErrors:         true,\n+\t\t\tLoadTests:             opts.ModResolveTests,\n+\t\t\tSilencePackageErrors:  true,\n \t\t}\n-\t\tmatches, _ = modload.LoadPackages(ctx, loadOpts, patterns...)\n+\t\tmatches, _ = modload.LoadPackages(ctx, modOpts, patterns...)\n \t} else {\n \t\tmatches = search.ImportPaths(patterns)\n \t}\n@@ -2406,14 +2464,14 @@ func PackagesAndErrors(ctx context.Context, patterns []string) []*Package {\n \n \tpre := newPreload()\n \tdefer pre.flush()\n-\tpre.preloadMatches(matches)\n+\tpre.preloadMatches(ctx, opts, matches)\n \n \tfor _, m := range matches {\n \t\tfor _, pkg := range m.Pkgs {\n \t\t\tif pkg == \"\" {\n \t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern()))\n \t\t\t}\n-\t\t\tp := loadImport(ctx, pre, pkg, base.Cwd, nil, &stk, nil, 0)\n+\t\t\tp := loadImport(ctx, opts, pre, pkg, base.Cwd(), nil, &stk, nil, 0)\n \t\t\tp.Match = append(p.Match, m.Pattern())\n \t\t\tp.Internal.CmdlinePkg = true\n \t\t\tif m.IsLiteral() {\n@@ -2449,6 +2507,10 @@ func PackagesAndErrors(ctx context.Context, patterns []string) []*Package {\n \t\t}\n \t}\n \n+\tif opts.MainOnly {\n+\t\tpkgs = mainPackagesOnly(pkgs, matches)\n+\t}\n+\n \t// Now that CmdlinePkg is set correctly,\n \t// compute the effective flags for all loaded packages\n \t// (not just the ones matching the patterns but also\n@@ -2497,6 +2559,80 @@ func CheckPackageErrors(pkgs []*Package) {\n \tbase.ExitIfErrors()\n }\n \n+// mainPackagesOnly filters out non-main packages matched only by arguments\n+// containing \"...\" and returns the remaining main packages.\n+//\n+// Packages with missing, invalid, or ambiguous names may be treated as\n+// possibly-main packages.\n+//\n+// mainPackagesOnly sets a non-main package's Error field and returns it if it\n+// is named by a literal argument.\n+//\n+// mainPackagesOnly prints warnings for non-literal arguments that only match\n+// non-main packages.\n+func mainPackagesOnly(pkgs []*Package, matches []*search.Match) []*Package {\n+\ttreatAsMain := map[string]bool{}\n+\tfor _, m := range matches {\n+\t\tif m.IsLiteral() {\n+\t\t\tfor _, path := range m.Pkgs {\n+\t\t\t\ttreatAsMain[path] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvar mains []*Package\n+\tfor _, pkg := range pkgs {\n+\t\tif pkg.Name == \"main\" {\n+\t\t\ttreatAsMain[pkg.ImportPath] = true\n+\t\t\tmains = append(mains, pkg)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif len(pkg.InvalidGoFiles) > 0 { // TODO(#45999): && pkg.Name == \"\", but currently go/build sets pkg.Name arbitrarily if it is ambiguous.\n+\t\t\t// The package has (or may have) conflicting names, and we can't easily\n+\t\t\t// tell whether one of them is \"main\". So assume that it could be, and\n+\t\t\t// report an error for the package.\n+\t\t\ttreatAsMain[pkg.ImportPath] = true\n+\t\t}\n+\t\tif treatAsMain[pkg.ImportPath] {\n+\t\t\tif pkg.Error == nil {\n+\t\t\t\tpkg.Error = &PackageError{Err: &mainPackageError{importPath: pkg.ImportPath}}\n+\t\t\t}\n+\t\t\tmains = append(mains, pkg)\n+\t\t}\n+\t}\n+\n+\tfor _, m := range matches {\n+\t\tif m.IsLiteral() || len(m.Pkgs) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfoundMain := false\n+\t\tfor _, path := range m.Pkgs {\n+\t\t\tif treatAsMain[path] {\n+\t\t\t\tfoundMain = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !foundMain {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %q matched only non-main packages\\n\", m.Pattern())\n+\t\t}\n+\t}\n+\n+\treturn mains\n+}\n+\n+type mainPackageError struct {\n+\timportPath string\n+}\n+\n+func (e *mainPackageError) Error() string {\n+\treturn fmt.Sprintf(\"package %s is not a main package\", e.importPath)\n+}\n+\n+func (e *mainPackageError) ImportPath() string {\n+\treturn e.importPath\n+}\n+\n func setToolFlags(pkgs ...*Package) {\n \tfor _, p := range PackageList(pkgs) {\n \t\tp.Internal.Asmflags = BuildAsmflags.For(p)\n@@ -2509,7 +2645,7 @@ func setToolFlags(pkgs ...*Package) {\n // GoFilesPackage creates a package for building a collection of Go files\n // (typically named on the command line). The target is named p.a for\n // package p or named after the first Go file for package main.\n-func GoFilesPackage(ctx context.Context, gofiles []string) *Package {\n+func GoFilesPackage(ctx context.Context, opts PackageOpts, gofiles []string) *Package {\n \tmodload.Init()\n \n \tfor _, f := range gofiles {\n@@ -2562,7 +2698,7 @@ func GoFilesPackage(ctx context.Context, gofiles []string) *Package {\n \n \tvar err error\n \tif dir == \"\" {\n-\t\tdir = base.Cwd\n+\t\tdir = base.Cwd()\n \t}\n \tdir, err = filepath.Abs(dir)\n \tif err != nil {\n@@ -2573,7 +2709,7 @@ func GoFilesPackage(ctx context.Context, gofiles []string) *Package {\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n \tpkg.Internal.CmdlineFiles = true\n-\tpkg.load(ctx, \"command-line-arguments\", &stk, nil, bp, err)\n+\tpkg.load(ctx, opts, \"command-line-arguments\", &stk, nil, bp, err)\n \tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n \tpkg.ImportPath = \"command-line-arguments\"\n \tpkg.Target = \"\"\n@@ -2589,7 +2725,138 @@ func GoFilesPackage(ctx context.Context, gofiles []string) *Package {\n \t\t}\n \t}\n \n+\tif opts.MainOnly && pkg.Name != \"main\" && pkg.Error == nil {\n+\t\tpkg.Error = &PackageError{Err: &mainPackageError{importPath: pkg.ImportPath}}\n+\t}\n \tsetToolFlags(pkg)\n \n \treturn pkg\n }\n+\n+// PackagesAndErrorsOutsideModule is like PackagesAndErrors but runs in\n+// module-aware mode and ignores the go.mod file in the current directory or any\n+// parent directory, if there is one. This is used in the implementation of 'go\n+// install pkg@version' and other commands that support similar forms.\n+//\n+// modload.ForceUseModules must be true, and modload.RootMode must be NoRoot\n+// before calling this function.\n+//\n+// PackagesAndErrorsOutsideModule imposes several constraints to avoid\n+// ambiguity. All arguments must have the same version suffix (not just a suffix\n+// that resolves to the same version). They must refer to packages in the same\n+// module, which must not be std or cmd. That module is not considered the main\n+// module, but its go.mod file (if it has one) must not contain directives that\n+// would cause it to be interpreted differently if it were the main module\n+// (replace, exclude).\n+func PackagesAndErrorsOutsideModule(ctx context.Context, opts PackageOpts, args []string) ([]*Package, error) {\n+\tif !modload.ForceUseModules {\n+\t\tpanic(\"modload.ForceUseModules must be true\")\n+\t}\n+\tif modload.RootMode != modload.NoRoot {\n+\t\tpanic(\"modload.RootMode must be NoRoot\")\n+\t}\n+\n+\t// Check that the arguments satisfy syntactic constraints.\n+\tvar version string\n+\tfor _, arg := range args {\n+\t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n+\t\t\tversion = arg[i+1:]\n+\t\t\tif version == \"\" {\n+\t\t\t\treturn nil, fmt.Errorf(\"%s: version must not be empty\", arg)\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tpatterns := make([]string, len(args))\n+\tfor i, arg := range args {\n+\t\tif !strings.HasSuffix(arg, \"@\"+version) {\n+\t\t\treturn nil, fmt.Errorf(\"%s: all arguments must have the same version (@%s)\", arg, version)\n+\t\t}\n+\t\tp := arg[:len(arg)-len(version)-1]\n+\t\tswitch {\n+\t\tcase build.IsLocalImport(p):\n+\t\t\treturn nil, fmt.Errorf(\"%s: argument must be a package path, not a relative path\", arg)\n+\t\tcase filepath.IsAbs(p):\n+\t\t\treturn nil, fmt.Errorf(\"%s: argument must be a package path, not an absolute path\", arg)\n+\t\tcase search.IsMetaPackage(p):\n+\t\t\treturn nil, fmt.Errorf(\"%s: argument must be a package path, not a meta-package\", arg)\n+\t\tcase path.Clean(p) != p:\n+\t\t\treturn nil, fmt.Errorf(\"%s: argument must be a clean package path\", arg)\n+\t\tcase !strings.Contains(p, \"...\") && search.IsStandardImportPath(p) && goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, p):\n+\t\t\treturn nil, fmt.Errorf(\"%s: argument must not be a package in the standard library\", arg)\n+\t\tdefault:\n+\t\t\tpatterns[i] = p\n+\t\t}\n+\t}\n+\n+\t// Query the module providing the first argument, load its go.mod file, and\n+\t// check that it doesn't contain directives that would cause it to be\n+\t// interpreted differently if it were the main module.\n+\t//\n+\t// If multiple modules match the first argument, accept the longest match\n+\t// (first result). It's possible this module won't provide packages named by\n+\t// later arguments, and other modules would. Let's not try to be too\n+\t// magical though.\n+\tallowed := modload.CheckAllowed\n+\tif modload.IsRevisionQuery(version) {\n+\t\t// Don't check for retractions if a specific revision is requested.\n+\t\tallowed = nil\n+\t}\n+\tnoneSelected := func(path string) (version string) { return \"none\" }\n+\tqrs, err := modload.QueryPackages(ctx, patterns[0], version, noneSelected, allowed)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: %w\", args[0], err)\n+\t}\n+\trootMod := qrs[0].Mod\n+\tdata, err := modfetch.GoMod(rootMod.Path, rootMod.Version)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: %w\", args[0], err)\n+\t}\n+\tf, err := modfile.Parse(\"go.mod\", data, nil)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s (in %s): %w\", args[0], rootMod, err)\n+\t}\n+\tdirectiveFmt := \"%s (in %s):\\n\" +\n+\t\t\"\\tThe go.mod file for the module providing named packages contains one or\\n\" +\n+\t\t\"\\tmore %s directives. It must not contain directives that would cause\\n\" +\n+\t\t\"\\tit to be interpreted differently than if it were the main module.\"\n+\tif len(f.Replace) > 0 {\n+\t\treturn nil, fmt.Errorf(directiveFmt, args[0], rootMod, \"replace\")\n+\t}\n+\tif len(f.Exclude) > 0 {\n+\t\treturn nil, fmt.Errorf(directiveFmt, args[0], rootMod, \"exclude\")\n+\t}\n+\n+\t// Since we are in NoRoot mode, the build list initially contains only\n+\t// the dummy command-line-arguments module. Add a requirement on the\n+\t// module that provides the packages named on the command line.\n+\tif _, err := modload.EditBuildList(ctx, nil, []module.Version{rootMod}); err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: %w\", args[0], err)\n+\t}\n+\n+\t// Load packages for all arguments.\n+\tpkgs := PackagesAndErrors(ctx, opts, patterns)\n+\n+\t// Check that named packages are all provided by the same module.\n+\tfor _, pkg := range pkgs {\n+\t\tvar pkgErr error\n+\t\tif pkg.Module == nil {\n+\t\t\t// Packages in std, cmd, and their vendored dependencies\n+\t\t\t// don't have this field set.\n+\t\t\tpkgErr = fmt.Errorf(\"package %s not provided by module %s\", pkg.ImportPath, rootMod)\n+\t\t} else if pkg.Module.Path != rootMod.Path || pkg.Module.Version != rootMod.Version {\n+\t\t\tpkgErr = fmt.Errorf(\"package %s provided by module %s@%s\\n\\tAll packages must be provided by the same module (%s).\", pkg.ImportPath, pkg.Module.Path, pkg.Module.Version, rootMod)\n+\t\t}\n+\t\tif pkgErr != nil && pkg.Error == nil {\n+\t\t\tpkg.Error = &PackageError{Err: pkgErr}\n+\t\t}\n+\t}\n+\n+\tmatchers := make([]func(string) bool, len(patterns))\n+\tfor i, p := range patterns {\n+\t\tif strings.Contains(p, \"...\") {\n+\t\t\tmatchers[i] = search.MatchPattern(p)\n+\t\t}\n+\t}\n+\treturn pkgs, nil\n+}"}, {"sha": "c8282965669c56d330c68a2390ba51d8c39452b8", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -21,6 +21,7 @@ import (\n \t\"unicode\"\n \t\"unicode/utf8\"\n \n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n )\n@@ -45,8 +46,8 @@ type TestCover struct {\n // TestPackagesFor is like TestPackagesAndErrors but it returns\n // an error if the test packages or their dependencies have errors.\n // Only test packages without errors are returned.\n-func TestPackagesFor(ctx context.Context, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n-\tpmain, ptest, pxtest = TestPackagesAndErrors(ctx, p, cover)\n+func TestPackagesFor(ctx context.Context, opts PackageOpts, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n+\tpmain, ptest, pxtest = TestPackagesAndErrors(ctx, opts, p, cover)\n \tfor _, p1 := range []*Package{ptest, pxtest, pmain} {\n \t\tif p1 == nil {\n \t\t\t// pxtest may be nil\n@@ -92,15 +93,15 @@ func TestPackagesFor(ctx context.Context, p *Package, cover *TestCover) (pmain,\n //\n // The caller is expected to have checked that len(p.TestGoFiles)+len(p.XTestGoFiles) > 0,\n // or else there's no point in any of this.\n-func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package) {\n+func TestPackagesAndErrors(ctx context.Context, opts PackageOpts, p *Package, cover *TestCover) (pmain, ptest, pxtest *Package) {\n \tctx, span := trace.StartSpan(ctx, \"load.TestPackagesAndErrors\")\n \tdefer span.Done()\n \n \tpre := newPreload()\n \tdefer pre.flush()\n \tallImports := append([]string{}, p.TestImports...)\n \tallImports = append(allImports, p.XTestImports...)\n-\tpre.preloadImports(allImports, p.Internal.Build)\n+\tpre.preloadImports(ctx, opts, allImports, p.Internal.Build)\n \n \tvar ptestErr, pxtestErr *PackageError\n \tvar imports, ximports []*Package\n@@ -109,13 +110,13 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \tstk.Push(p.ImportPath + \" (test)\")\n \trawTestImports := str.StringList(p.TestImports)\n \tfor i, path := range p.TestImports {\n-\t\tp1 := loadImport(ctx, pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n+\t\tp1 := loadImport(ctx, opts, pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n \t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n \t\t\t// Can't change that code, because that code is only for loading the\n \t\t\t// non-test copy of a package.\n \t\t\tptestErr = &PackageError{\n-\t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n+\t\t\t\tImportStack:   importCycleStack(p1, p.ImportPath),\n \t\t\t\tErr:           errors.New(\"import cycle not allowed in test\"),\n \t\t\t\tIsImportCycle: true,\n \t\t\t}\n@@ -139,7 +140,7 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \tpxtestNeedsPtest := false\n \trawXTestImports := str.StringList(p.XTestImports)\n \tfor i, path := range p.XTestImports {\n-\t\tp1 := loadImport(ctx, pre, path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n+\t\tp1 := loadImport(ctx, opts, pre, path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n \t\tif p1.ImportPath == p.ImportPath {\n \t\t\tpxtestNeedsPtest = true\n \t\t} else {\n@@ -203,6 +204,7 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\t}\n \t\tptest.Internal.Embed = testEmbed\n \t\tptest.EmbedFiles = str.StringList(p.EmbedFiles, p.TestEmbedFiles)\n+\t\tptest.Internal.OrigImportPath = p.Internal.OrigImportPath\n \t\tptest.collectDeps()\n \t} else {\n \t\tptest = p\n@@ -232,11 +234,12 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\t\t\tImports:    ximports,\n \t\t\t\tRawImports: rawXTestImports,\n \n-\t\t\t\tAsmflags:   p.Internal.Asmflags,\n-\t\t\t\tGcflags:    p.Internal.Gcflags,\n-\t\t\t\tLdflags:    p.Internal.Ldflags,\n-\t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n-\t\t\t\tEmbed:      xtestEmbed,\n+\t\t\t\tAsmflags:       p.Internal.Asmflags,\n+\t\t\t\tGcflags:        p.Internal.Gcflags,\n+\t\t\t\tLdflags:        p.Internal.Ldflags,\n+\t\t\t\tGccgoflags:     p.Internal.Gccgoflags,\n+\t\t\t\tEmbed:          xtestEmbed,\n+\t\t\t\tOrigImportPath: p.Internal.OrigImportPath,\n \t\t\t},\n \t\t}\n \t\tif pxtestNeedsPtest {\n@@ -257,12 +260,13 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\t\tModule:     p.Module,\n \t\t},\n \t\tInternal: PackageInternal{\n-\t\t\tBuild:      &build.Package{Name: \"main\"},\n-\t\t\tBuildInfo:  p.Internal.BuildInfo,\n-\t\t\tAsmflags:   p.Internal.Asmflags,\n-\t\t\tGcflags:    p.Internal.Gcflags,\n-\t\t\tLdflags:    p.Internal.Ldflags,\n-\t\t\tGccgoflags: p.Internal.Gccgoflags,\n+\t\t\tBuild:          &build.Package{Name: \"main\"},\n+\t\t\tBuildInfo:      p.Internal.BuildInfo,\n+\t\t\tAsmflags:       p.Internal.Asmflags,\n+\t\t\tGcflags:        p.Internal.Gcflags,\n+\t\t\tLdflags:        p.Internal.Ldflags,\n+\t\t\tGccgoflags:     p.Internal.Gccgoflags,\n+\t\t\tOrigImportPath: p.Internal.OrigImportPath,\n \t\t},\n \t}\n \n@@ -277,7 +281,7 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\tif dep == ptest.ImportPath {\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\t} else {\n-\t\t\tp1 := loadImport(ctx, pre, dep, \"\", nil, &stk, nil, 0)\n+\t\t\tp1 := loadImport(ctx, opts, pre, dep, \"\", nil, &stk, nil, 0)\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t}\n \t}\n@@ -290,10 +294,12 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \t\t\tseen[p1] = true\n \t\t}\n \t\tfor _, p1 := range cover.Pkgs {\n-\t\t\tif !seen[p1] {\n-\t\t\t\tseen[p1] = true\n-\t\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n+\t\t\tif seen[p1] {\n+\t\t\t\t// Don't add duplicate imports.\n+\t\t\t\tcontinue\n \t\t\t}\n+\t\t\tseen[p1] = true\n+\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t}\n \t}\n \n@@ -369,22 +375,44 @@ func TestPackagesAndErrors(ctx context.Context, p *Package, cover *TestCover) (p\n \treturn pmain, ptest, pxtest\n }\n \n-func testImportStack(top string, p *Package, target string) []string {\n-\tstk := []string{top, p.ImportPath}\n-Search:\n-\tfor p.ImportPath != target {\n-\t\tfor _, p1 := range p.Internal.Imports {\n-\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n-\t\t\t\tstk = append(stk, p1.ImportPath)\n-\t\t\t\tp = p1\n-\t\t\t\tcontinue Search\n+// importCycleStack returns an import stack from p to the package whose import\n+// path is target.\n+func importCycleStack(p *Package, target string) []string {\n+\t// importerOf maps each import path to its importer nearest to p.\n+\timporterOf := map[string]string{p.ImportPath: \"\"}\n+\n+\t// q is a breadth-first queue of packages to search for target.\n+\t// Every package added to q has a corresponding entry in pathTo.\n+\t//\n+\t// We search breadth-first for two reasons:\n+\t//\n+\t// \t1. We want to report the shortest cycle.\n+\t//\n+\t// \t2. If p contains multiple cycles, the first cycle we encounter might not\n+\t// \t   contain target. To ensure termination, we have to break all cycles\n+\t// \t   other than the first.\n+\tq := []*Package{p}\n+\n+\tfor len(q) > 0 {\n+\t\tp := q[0]\n+\t\tq = q[1:]\n+\t\tif path := p.ImportPath; path == target {\n+\t\t\tvar stk []string\n+\t\t\tfor path != \"\" {\n+\t\t\t\tstk = append(stk, path)\n+\t\t\t\tpath = importerOf[path]\n+\t\t\t}\n+\t\t\treturn stk\n+\t\t}\n+\t\tfor _, dep := range p.Internal.Imports {\n+\t\t\tif _, ok := importerOf[dep.ImportPath]; !ok {\n+\t\t\t\timporterOf[dep.ImportPath] = p.ImportPath\n+\t\t\t\tq = append(q, dep)\n \t\t\t}\n \t\t}\n-\t\t// Can't happen, but in case it does...\n-\t\tstk = append(stk, \"<lost path to cycle>\")\n-\t\tbreak\n \t}\n-\treturn stk\n+\n+\tpanic(\"lost path to cycle\")\n }\n \n // recompileForTest copies and replaces certain packages in pmain's dependency\n@@ -576,7 +604,13 @@ type testFunc struct {\n var testFileSet = token.NewFileSet()\n \n func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n-\tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n+\t// Pass in the overlaid source if we have an overlay for this file.\n+\tsrc, err := fsys.Open(filename)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer src.Close()\n+\tf, err := parser.ParseFile(testFileSet, filename, src, parser.ParseComments)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "e302fe7fccf56bf761ddcf27d8c4478ff23e6778", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_fcntl.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_fcntl.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || (solaris && !illumos)\n // +build aix solaris,!illumos\n \n // This code implements the filelock API using POSIX 'fcntl' locks, which attach"}, {"sha": "c6eac302c573f325316c5073d16a064fd095815b", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_other.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_other.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !aix && !darwin && !dragonfly && !freebsd && !hurd && !linux && !netbsd && !openbsd && !plan9 && !solaris && !windows\n // +build !aix,!darwin,!dragonfly,!freebsd,!hurd,!linux,!netbsd,!openbsd,!plan9,!solaris,!windows\n \n package filelock"}, {"sha": "908afb6c8cb7687d4d34545038b831e27434c2d8", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_plan9.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_plan9.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build plan9\n // +build plan9\n \n package filelock"}, {"sha": "640d4406f4200cd1e44c426421955678feb66f91", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !js && !plan9\n // +build !js,!plan9\n \n package filelock_test"}, {"sha": "b22c0bb9918cad7e946e2da36f7a2f35133319bc", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_unix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build darwin || dragonfly || freebsd || hurd || illumos || linux || netbsd || openbsd\n // +build darwin dragonfly freebsd hurd illumos linux netbsd openbsd\n \n package filelock"}, {"sha": "dd27ce92bd8d617449952f0c792f7966d10d2b84", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_windows.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_windows.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build windows\n // +build windows\n \n package filelock"}, {"sha": "e4923f68764dad89a06539bbffccbe112e645996", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_filelock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_filelock.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !plan9\n // +build !plan9\n \n package lockedfile\n@@ -10,7 +11,6 @@ import (\n \t\"io/fs\"\n \t\"os\"\n \n-\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile/internal/filelock\"\n )\n \n@@ -20,7 +20,7 @@ func openFile(name string, flag int, perm fs.FileMode) (*os.File, error) {\n \t// calls for Linux and Windows anyway, so it's simpler to use that approach\n \t// consistently.\n \n-\tf, err := fsys.OpenFile(name, flag&^os.O_TRUNC, perm)\n+\tf, err := os.OpenFile(name, flag&^os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "979118b10ae83d13d01064ca3eb896f5b6a38d48", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_plan9.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_plan9.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build plan9\n // +build plan9\n \n package lockedfile\n@@ -12,8 +13,6 @@ import (\n \t\"os\"\n \t\"strings\"\n \t\"time\"\n-\n-\t\"cmd/go/internal/fsys\"\n )\n \n // Opening an exclusive-use file returns an error.\n@@ -58,7 +57,7 @@ func openFile(name string, flag int, perm fs.FileMode) (*os.File, error) {\n \t// If the file was unpacked or created by some other program, it might not\n \t// have the ModeExclusive bit set. Set it before we call OpenFile, so that we\n \t// can be confident that a successful OpenFile implies exclusive use.\n-\tif fi, err := fsys.Stat(name); err == nil {\n+\tif fi, err := os.Stat(name); err == nil {\n \t\tif fi.Mode()&fs.ModeExclusive == 0 {\n \t\t\tif err := os.Chmod(name, fi.Mode()|fs.ModeExclusive); err != nil {\n \t\t\t\treturn nil, err\n@@ -71,7 +70,7 @@ func openFile(name string, flag int, perm fs.FileMode) (*os.File, error) {\n \tnextSleep := 1 * time.Millisecond\n \tconst maxSleep = 500 * time.Millisecond\n \tfor {\n-\t\tf, err := fsys.OpenFile(name, flag, perm|fs.ModeExclusive)\n+\t\tf, err := os.OpenFile(name, flag, perm|fs.ModeExclusive)\n \t\tif err == nil {\n \t\t\treturn f, nil\n \t\t}"}, {"sha": "3acc6695a748003e6f0fc7107bc49ffcf5995162", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -3,6 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // js does not support inter-process file locking.\n+//go:build !js\n // +build !js\n \n package lockedfile_test"}, {"sha": "b753346e7da50bccbb6d904a3f59c30648093153", "filename": "libgo/go/cmd/go/internal/lockedfile/transform_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -3,6 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // js does not support inter-process file locking.\n+//go:build !js\n // +build !js\n \n package lockedfile_test"}, {"sha": "0e5af852376e76c5363d595d15c55f18d4acd8f6", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -134,21 +134,18 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tvar mods []*moduleJSON\n-\tlistU := false\n-\tlistVersions := false\n-\tlistRetractions := false\n \ttype token struct{}\n \tsem := make(chan token, runtime.GOMAXPROCS(0))\n-\tinfos := modload.ListModules(ctx, args, listU, listVersions, listRetractions)\n+\tinfos, infosErr := modload.ListModules(ctx, args, 0)\n \tif !haveExplicitArgs {\n-\t\t// 'go mod download' is sometimes run without arguments to pre-populate\n-\t\t// the module cache. It may fetch modules that aren't needed to build\n-\t\t// packages in the main mdoule. This is usually not intended, so don't save\n-\t\t// sums for downloaded modules (golang.org/issue/45332).\n-\t\t// TODO(golang.org/issue/45551): For now, save sums needed to load the\n-\t\t// build list (same as 1.15 behavior). In the future, report an error if\n-\t\t// go.mod or go.sum need to be updated after loading the build list.\n-\t\tmodload.WriteGoMod()\n+\t\t// 'go mod download' is sometimes run without arguments to pre-populate the\n+\t\t// module cache. It may fetch modules that aren't needed to build packages\n+\t\t// in the main mdoule. This is usually not intended, so don't save sums for\n+\t\t// downloaded modules (golang.org/issue/45332).\n+\t\t// TODO(golang.org/issue/45551): For now, in ListModules, save sums needed\n+\t\t// to load the build list (same as 1.15 behavior). In the future, report an\n+\t\t// error if go.mod or go.sum need to be updated after loading the build\n+\t\t// list.\n \t\tmodload.DisallowWriteGoMod()\n \t}\n \n@@ -209,6 +206,13 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t//\n \t// Don't save sums for 'go mod download' without arguments; see comment above.\n \tif haveExplicitArgs {\n-\t\tmodload.WriteGoMod()\n+\t\tmodload.WriteGoMod(ctx)\n+\t}\n+\n+\t// If there was an error matching some of the requested packages, emit it now\n+\t// (after we've written the checksums for the modules that were downloaded\n+\t// successfully).\n+\tif infosErr != nil {\n+\t\tbase.Errorf(\"go mod download: %v\", infosErr)\n \t}\n }"}, {"sha": "bb3d5210926aef7993e93a8beb0fbd189859e399", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -25,7 +25,7 @@ import (\n )\n \n var cmdEdit = &base.Command{\n-\tUsageLine: \"go mod edit [editing flags] [go.mod]\",\n+\tUsageLine: \"go mod edit [editing flags] [-fmt|-print|-json] [go.mod]\",\n \tShort:     \"edit go.mod from tools or scripts\",\n \tLong: `\n Edit provides a command-line interface for editing go.mod,\n@@ -85,19 +85,24 @@ The -json flag prints the final go.mod file in JSON format instead of\n writing it back to go.mod. The JSON output corresponds to these Go types:\n \n \ttype Module struct {\n-\t\tPath string\n+\t\tPath    string\n \t\tVersion string\n \t}\n \n \ttype GoMod struct {\n-\t\tModule  Module\n+\t\tModule  ModPath\n \t\tGo      string\n \t\tRequire []Require\n \t\tExclude []Module\n \t\tReplace []Replace\n \t\tRetract []Retract\n \t}\n \n+\ttype ModPath struct {\n+\t\tPath       string\n+\t\tDeprecated string\n+\t}\n+\n \ttype Require struct {\n \t\tPath string\n \t\tVersion string\n@@ -191,7 +196,7 @@ func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n \n \tif *editGo != \"\" {\n \t\tif !modfile.GoVersionRE.MatchString(*editGo) {\n-\t\t\tbase.Fatalf(`go mod: invalid -go option; expecting something like \"-go 1.12\"`)\n+\t\t\tbase.Fatalf(`go mod: invalid -go option; expecting something like \"-go %s\"`, modload.LatestGoVersion())\n \t\t}\n \t}\n \n@@ -450,14 +455,19 @@ func flagDropRetract(arg string) {\n \n // fileJSON is the -json output data structure.\n type fileJSON struct {\n-\tModule  module.Version\n+\tModule  editModuleJSON\n \tGo      string `json:\",omitempty\"`\n \tRequire []requireJSON\n \tExclude []module.Version\n \tReplace []replaceJSON\n \tRetract []retractJSON\n }\n \n+type editModuleJSON struct {\n+\tPath       string\n+\tDeprecated string `json:\",omitempty\"`\n+}\n+\n type requireJSON struct {\n \tPath     string\n \tVersion  string `json:\",omitempty\"`\n@@ -479,7 +489,10 @@ type retractJSON struct {\n func editPrintJSON(modFile *modfile.File) {\n \tvar f fileJSON\n \tif modFile.Module != nil {\n-\t\tf.Module = modFile.Module.Mod\n+\t\tf.Module = editModuleJSON{\n+\t\t\tPath:       modFile.Module.Mod.Path,\n+\t\t\tDeprecated: modFile.Module.Deprecated,\n+\t\t}\n \t}\n \tif modFile.Go != nil {\n \t\tf.Go = modFile.Go.Version"}, {"sha": "ac81f26dadea69dd3f58d7491caaa39aba7cfcad", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"bufio\"\n \t\"context\"\n \t\"os\"\n-\t\"sort\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modload\"\n@@ -19,20 +18,29 @@ import (\n )\n \n var cmdGraph = &base.Command{\n-\tUsageLine: \"go mod graph\",\n+\tUsageLine: \"go mod graph [-go=version]\",\n \tShort:     \"print module requirement graph\",\n \tLong: `\n Graph prints the module requirement graph (with replacements applied)\n in text form. Each line in the output has two space-separated fields: a module\n and one of its requirements. Each module is identified as a string of the form\n path@version, except for the main module, which has no @version suffix.\n \n+The -go flag causes graph to report the module graph as loaded by the\n+given Go version, instead of the version indicated by the 'go' directive\n+in the go.mod file.\n+\n See https://golang.org/ref/mod#go-mod-graph for more about 'go mod graph'.\n \t`,\n \tRun: runGraph,\n }\n \n+var (\n+\tgraphGo goVersionFlag\n+)\n+\n func init() {\n+\tcmdGraph.Flag.Var(&graphGo, \"go\", \"\")\n \tbase.AddModCommonFlags(&cmdGraph.Flag)\n }\n \n@@ -42,43 +50,26 @@ func runGraph(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot\n-\tmodload.LoadAllModules(ctx)\n+\tmg := modload.LoadModGraph(ctx, graphGo.String())\n \n-\treqs := modload.MinReqs()\n-\tformat := func(m module.Version) string {\n-\t\tif m.Version == \"\" {\n-\t\t\treturn m.Path\n-\t\t}\n-\t\treturn m.Path + \"@\" + m.Version\n-\t}\n+\tw := bufio.NewWriter(os.Stdout)\n+\tdefer w.Flush()\n \n-\tvar out []string\n-\tvar deps int // index in out where deps start\n-\tseen := map[module.Version]bool{modload.Target: true}\n-\tqueue := []module.Version{modload.Target}\n-\tfor len(queue) > 0 {\n-\t\tvar m module.Version\n-\t\tm, queue = queue[0], queue[1:]\n-\t\tlist, _ := reqs.Required(m)\n-\t\tfor _, r := range list {\n-\t\t\tif !seen[r] {\n-\t\t\t\tqueue = append(queue, r)\n-\t\t\t\tseen[r] = true\n-\t\t\t}\n-\t\t\tout = append(out, format(m)+\" \"+format(r)+\"\\n\")\n-\t\t}\n-\t\tif m == modload.Target {\n-\t\t\tdeps = len(out)\n+\tformat := func(m module.Version) {\n+\t\tw.WriteString(m.Path)\n+\t\tif m.Version != \"\" {\n+\t\t\tw.WriteString(\"@\")\n+\t\t\tw.WriteString(m.Version)\n \t\t}\n \t}\n \n-\tsort.Slice(out[deps:], func(i, j int) bool {\n-\t\treturn out[deps+i][0] < out[deps+j][0]\n+\tmg.WalkBreadthFirst(func(m module.Version) {\n+\t\treqs, _ := mg.RequiredBy(m)\n+\t\tfor _, r := range reqs {\n+\t\t\tformat(m)\n+\t\t\tw.WriteByte(' ')\n+\t\t\tformat(r)\n+\t\t\tw.WriteByte('\\n')\n+\t\t}\n \t})\n-\n-\tw := bufio.NewWriter(os.Stdout)\n-\tfor _, line := range out {\n-\t\tw.WriteString(line)\n-\t}\n-\tw.Flush()\n }"}, {"sha": "958c3066ac11082dee31fe8b0cc4f3f049124e5e", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -13,7 +13,7 @@ import (\n )\n \n var cmdInit = &base.Command{\n-\tUsageLine: \"go mod init [module]\",\n+\tUsageLine: \"go mod init [module-path]\",\n \tShort:     \"initialize new module in current directory\",\n \tLong: `\n Init initializes and writes a new go.mod file in the current directory, in"}, {"sha": "fe25507e94f4fe365ec17d48b09e91be1109d702", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -12,10 +12,14 @@ import (\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n \t\"context\"\n+\t\"fmt\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var cmdTidy = &base.Command{\n-\tUsageLine: \"go mod tidy [-e] [-v]\",\n+\tUsageLine: \"go mod tidy [-e] [-v] [-go=version] [-compat=version]\",\n \tShort:     \"add missing and remove unused modules\",\n \tLong: `\n Tidy makes sure go.mod matches the source code in the module.\n@@ -30,19 +34,65 @@ to standard error.\n The -e flag causes tidy to attempt to proceed despite errors\n encountered while loading packages.\n \n+The -go flag causes tidy to update the 'go' directive in the go.mod\n+file to the given version, which may change which module dependencies\n+are retained as explicit requirements in the go.mod file.\n+(Go versions 1.17 and higher retain more requirements in order to\n+support lazy module loading.)\n+\n+The -compat flag preserves any additional checksums needed for the\n+'go' command from the indicated major Go release to successfully load\n+the module graph, and causes tidy to error out if that version of the\n+'go' command would load any imported package from a different module\n+version. By default, tidy acts as if the -compat flag were set to the\n+version prior to the one indicated by the 'go' directive in the go.mod\n+file.\n+\n See https://golang.org/ref/mod#go-mod-tidy for more about 'go mod tidy'.\n \t`,\n \tRun: runTidy,\n }\n \n-var tidyE bool // if true, report errors but proceed anyway.\n+var (\n+\ttidyE      bool          // if true, report errors but proceed anyway.\n+\ttidyGo     goVersionFlag // go version to write to the tidied go.mod file (toggles lazy loading)\n+\ttidyCompat goVersionFlag // go version for which the tidied go.mod and go.sum files should be \u201ccompatible\u201d\n+)\n \n func init() {\n \tcmdTidy.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n \tcmdTidy.Flag.BoolVar(&tidyE, \"e\", false, \"\")\n+\tcmdTidy.Flag.Var(&tidyGo, \"go\", \"\")\n+\tcmdTidy.Flag.Var(&tidyCompat, \"compat\", \"\")\n \tbase.AddModCommonFlags(&cmdTidy.Flag)\n }\n \n+// A goVersionFlag is a flag.Value representing a supported Go version.\n+//\n+// (Note that the -go argument to 'go mod edit' is *not* a goVersionFlag.\n+// It intentionally allows newer-than-supported versions as arguments.)\n+type goVersionFlag struct {\n+\tv string\n+}\n+\n+func (f *goVersionFlag) String() string   { return f.v }\n+func (f *goVersionFlag) Get() interface{} { return f.v }\n+\n+func (f *goVersionFlag) Set(s string) error {\n+\tif s != \"\" {\n+\t\tlatest := modload.LatestGoVersion()\n+\t\tif !modfile.GoVersionRE.MatchString(s) {\n+\t\t\treturn fmt.Errorf(\"expecting a Go version like %q\", latest)\n+\t\t}\n+\t\tif semver.Compare(\"v\"+s, \"v\"+latest) > 0 {\n+\t\t\treturn fmt.Errorf(\"maximum supported Go version is %s\", latest)\n+\t\t}\n+\t}\n+\n+\tf.v = s\n+\treturn nil\n+}\n+\n func runTidy(ctx context.Context, cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod tidy: no arguments allowed\")\n@@ -61,17 +111,15 @@ func runTidy(ctx context.Context, cmd *base.Command, args []string) {\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot\n \n-\tmodload.CheckTidyVersion(ctx, tidyE)\n-\n \tmodload.LoadPackages(ctx, modload.PackageOpts{\n+\t\tGoVersion:                tidyGo.String(),\n \t\tTags:                     imports.AnyTags(),\n+\t\tTidy:                     true,\n+\t\tTidyCompatibleVersion:    tidyCompat.String(),\n+\t\tVendorModulesInGOROOTSrc: true,\n \t\tResolveMissingImports:    true,\n \t\tLoadTests:                true,\n \t\tAllowErrors:              tidyE,\n \t\tSilenceMissingStdImports: true,\n \t}, \"all\")\n-\n-\tmodload.TidyBuildList()\n-\tmodload.TrimGoSum()\n-\tmodload.WriteGoMod()\n }"}, {"sha": "713d5f9f3faa6ac9fb58dffc561c96d2dd5b1b70", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n@@ -65,6 +66,7 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \n \tloadOpts := modload.PackageOpts{\n \t\tTags:                     imports.AnyTags(),\n+\t\tVendorModulesInGOROOTSrc: true,\n \t\tResolveMissingImports:    true,\n \t\tUseVendorAll:             true,\n \t\tAllowErrors:              vendorE,\n@@ -87,15 +89,23 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tincludeAllReplacements := false\n+\tincludeGoVersions := false\n \tisExplicit := map[module.Version]bool{}\n-\tif gv := modload.ModFile().Go; gv != nil && semver.Compare(\"v\"+gv.Version, \"v1.14\") >= 0 {\n-\t\t// If the Go version is at least 1.14, annotate all explicit 'require' and\n-\t\t// 'replace' targets found in the go.mod file so that we can perform a\n-\t\t// stronger consistency check when -mod=vendor is set.\n-\t\tfor _, r := range modload.ModFile().Require {\n-\t\t\tisExplicit[r.Mod] = true\n+\tif gv := modload.ModFile().Go; gv != nil {\n+\t\tif semver.Compare(\"v\"+gv.Version, \"v1.14\") >= 0 {\n+\t\t\t// If the Go version is at least 1.14, annotate all explicit 'require' and\n+\t\t\t// 'replace' targets found in the go.mod file so that we can perform a\n+\t\t\t// stronger consistency check when -mod=vendor is set.\n+\t\t\tfor _, r := range modload.ModFile().Require {\n+\t\t\t\tisExplicit[r.Mod] = true\n+\t\t\t}\n+\t\t\tincludeAllReplacements = true\n+\t\t}\n+\t\tif semver.Compare(\"v\"+gv.Version, \"v1.17\") >= 0 {\n+\t\t\t// If the Go version is at least 1.17, annotate all modules with their\n+\t\t\t// 'go' version directives.\n+\t\t\tincludeGoVersions = true\n \t\t}\n-\t\tincludeAllReplacements = true\n \t}\n \n \tvar vendorMods []module.Version\n@@ -109,26 +119,35 @@ func runVendor(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \tmodule.Sort(vendorMods)\n \n-\tvar buf bytes.Buffer\n+\tvar (\n+\t\tbuf bytes.Buffer\n+\t\tw   io.Writer = &buf\n+\t)\n+\tif cfg.BuildV {\n+\t\tw = io.MultiWriter(&buf, os.Stderr)\n+\t}\n+\n \tfor _, m := range vendorMods {\n \t\tline := moduleLine(m, modload.Replacement(m))\n-\t\tbuf.WriteString(line)\n-\t\tif cfg.BuildV {\n-\t\t\tos.Stderr.WriteString(line)\n+\t\tio.WriteString(w, line)\n+\n+\t\tgoVersion := \"\"\n+\t\tif includeGoVersions {\n+\t\t\tgoVersion = modload.ModuleInfo(ctx, m.Path).GoVersion\n \t\t}\n-\t\tif isExplicit[m] {\n-\t\t\tbuf.WriteString(\"## explicit\\n\")\n-\t\t\tif cfg.BuildV {\n-\t\t\t\tos.Stderr.WriteString(\"## explicit\\n\")\n-\t\t\t}\n+\t\tswitch {\n+\t\tcase isExplicit[m] && goVersion != \"\":\n+\t\t\tfmt.Fprintf(w, \"## explicit; go %s\\n\", goVersion)\n+\t\tcase isExplicit[m]:\n+\t\t\tio.WriteString(w, \"## explicit\\n\")\n+\t\tcase goVersion != \"\":\n+\t\t\tfmt.Fprintf(w, \"## go %s\\n\", goVersion)\n \t\t}\n+\n \t\tpkgs := modpkgs[m]\n \t\tsort.Strings(pkgs)\n \t\tfor _, pkg := range pkgs {\n-\t\t\tfmt.Fprintf(&buf, \"%s\\n\", pkg)\n-\t\t\tif cfg.BuildV {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", pkg)\n-\t\t\t}\n+\t\t\tfmt.Fprintf(w, \"%s\\n\", pkg)\n \t\t\tvendorPkg(vdir, pkg)\n \t\t}\n \t}\n@@ -281,7 +300,7 @@ func copyMetadata(modPath, pkg, dst, src string, copiedFiles map[string]bool) {\n \t\tif modPath == pkg {\n \t\t\tbreak\n \t\t}\n-\t\tpkg = filepath.Dir(pkg)\n+\t\tpkg = path.Dir(pkg)\n \t\tdst = filepath.Dir(dst)\n \t\tsrc = filepath.Dir(src)\n \t}\n@@ -322,6 +341,15 @@ func matchPotentialSourceFile(dir string, info fs.DirEntry) bool {\n \tif strings.HasSuffix(info.Name(), \"_test.go\") {\n \t\treturn false\n \t}\n+\tif info.Name() == \"go.mod\" || info.Name() == \"go.sum\" {\n+\t\tif gv := modload.ModFile().Go; gv != nil && semver.Compare(\"v\"+gv.Version, \"v1.17\") >= 0 {\n+\t\t\t// As of Go 1.17, we strip go.mod and go.sum files from dependency modules.\n+\t\t\t// Otherwise, 'go' commands invoked within the vendor subtree may misidentify\n+\t\t\t// an arbitrary directory within the vendor tree as a module root.\n+\t\t\t// (See https://golang.org/issue/42970.)\n+\t\t\treturn false\n+\t\t}\n+\t}\n \tif strings.HasSuffix(info.Name(), \".go\") {\n \t\tf, err := fsys.Open(filepath.Join(dir, info.Name()))\n \t\tif err != nil {"}, {"sha": "5a6eca32cfb706bfcd50906937d9eec70e4fc4c4", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -54,7 +54,8 @@ func runVerify(ctx context.Context, cmd *base.Command, args []string) {\n \tsem := make(chan token, runtime.GOMAXPROCS(0))\n \n \t// Use a slice of result channels, so that the output is deterministic.\n-\tmods := modload.LoadAllModules(ctx)[1:]\n+\tconst defaultGoVersion = \"\"\n+\tmods := modload.LoadModGraph(ctx, defaultGoVersion).BuildList()[1:]\n \terrsChans := make([]<-chan []error, len(mods))\n \n \tfor i, mod := range mods {"}, {"sha": "3b14b27c8c780d954a133cd46dc4bee2f875e442", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -68,22 +68,25 @@ func runWhy(ctx context.Context, cmd *base.Command, args []string) {\n \tmodload.RootMode = modload.NeedRoot\n \n \tloadOpts := modload.PackageOpts{\n-\t\tTags:          imports.AnyTags(),\n-\t\tLoadTests:     !*whyVendor,\n-\t\tSilenceErrors: true,\n-\t\tUseVendorAll:  *whyVendor,\n+\t\tTags:                     imports.AnyTags(),\n+\t\tVendorModulesInGOROOTSrc: true,\n+\t\tLoadTests:                !*whyVendor,\n+\t\tSilencePackageErrors:     true,\n+\t\tUseVendorAll:             *whyVendor,\n \t}\n \n \tif *whyM {\n-\t\tlistU := false\n-\t\tlistVersions := false\n-\t\tlistRetractions := false\n \t\tfor _, arg := range args {\n \t\t\tif strings.Contains(arg, \"@\") {\n \t\t\t\tbase.Fatalf(\"go mod why: module query not allowed\")\n \t\t\t}\n \t\t}\n-\t\tmods := modload.ListModules(ctx, args, listU, listVersions, listRetractions)\n+\n+\t\tmods, err := modload.ListModules(ctx, args, 0)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go mod why: %v\", err)\n+\t\t}\n+\n \t\tbyModule := make(map[module.Version][]string)\n \t\t_, pkgs := modload.LoadPackages(ctx, loadOpts, \"all\")\n \t\tfor _, path := range pkgs {"}, {"sha": "9c861f8e99e1537fd05d83f975ea5f85359fb797", "filename": "libgo/go/cmd/go/internal/modconv/convert.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -12,7 +12,6 @@ import (\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/modfetch\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n@@ -21,7 +20,7 @@ import (\n \n // ConvertLegacyConfig converts legacy config to modfile.\n // The file argument is slash-delimited.\n-func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n+func ConvertLegacyConfig(f *modfile.File, file string, data []byte, queryPackage func(path, rev string) (module.Version, error)) error {\n \ti := strings.LastIndex(file, \"/\")\n \tj := -2\n \tif i >= 0 {\n@@ -62,15 +61,13 @@ func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n \t\tsem <- token{}\n \t\tgo func(i int, m module.Version) {\n \t\t\tdefer func() { <-sem }()\n-\t\t\trepo, info, err := modfetch.ImportRepoRev(m.Path, m.Version)\n+\t\t\tversion, err := queryPackage(m.Path, m.Version)\n \t\t\tif err != nil {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: converting %s: stat %s@%s: %v\\n\", base.ShortPath(file), m.Path, m.Version, err)\n \t\t\t\treturn\n \t\t\t}\n \n-\t\t\tpath := repo.ModulePath()\n-\t\t\tversions[i].Path = path\n-\t\t\tversions[i].Version = info.Version\n+\t\t\tversions[i] = version\n \t\t}(i, m)\n \t}\n \t// Fill semaphore channel to wait for all tasks to finish."}, {"sha": "66b9ff4f382f2678cf39a8869321b50c16c3307a", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modconv\n-\n-import (\n-\t\"bytes\"\n-\t\"context\"\n-\t\"fmt\"\n-\t\"internal/testenv\"\n-\t\"log\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"path/filepath\"\n-\t\"strings\"\n-\t\"testing\"\n-\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/modfetch\"\n-\n-\t\"golang.org/x/mod/modfile\"\n-\t\"golang.org/x/mod/module\"\n-)\n-\n-func TestMain(m *testing.M) {\n-\tos.Exit(testMain(m))\n-}\n-\n-func testMain(m *testing.M) int {\n-\tcfg.GOPROXY = \"direct\"\n-\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tfmt.Fprintln(os.Stderr, \"skipping because git binary not found\")\n-\t\tfmt.Println(\"PASS\")\n-\t\treturn 0\n-\t}\n-\n-\tdir, err := os.MkdirTemp(\"\", \"modconv-test-\")\n-\tif err != nil {\n-\t\tlog.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\tcfg.GOMODCACHE = filepath.Join(dir, \"pkg/mod\")\n-\n-\treturn m.Run()\n-}\n-\n-func TestConvertLegacyConfig(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\tif testing.Verbose() {\n-\t\told := cfg.BuildX\n-\t\tdefer func() {\n-\t\t\tcfg.BuildX = old\n-\t\t}()\n-\t\tcfg.BuildX = true\n-\t}\n-\n-\tvar tests = []struct {\n-\t\tpath  string\n-\t\tvers  string\n-\t\tgomod string\n-\t}{\n-\t\t/*\n-\t\t\tDifferent versions of git seem to find or not find\n-\t\t\tgithub.com/Masterminds/semver's a93e51b5a57e,\n-\t\t\twhich is an unmerged pull request.\n-\t\t\tWe'd rather not provide access to unmerged pull requests,\n-\t\t\tso the line is removed from the golden file here,\n-\t\t\tbut some git commands still find it somehow.\n-\n-\t\t\t{\n-\t\t\t\t// Gopkg.lock parsing.\n-\t\t\t\t\"github.com/golang/dep\", \"v0.4.0\",\n-\t\t\t\t`module github.com/golang/dep\n-\n-\t\t\t\trequire (\n-\t\t\t\t\tgithub.com/Masterminds/vcs v1.11.1\n-\t\t\t\t\tgithub.com/armon/go-radix v0.0.0-20160115234725-4239b77079c7\n-\t\t\t\t\tgithub.com/boltdb/bolt v1.3.1\n-\t\t\t\t\tgithub.com/go-yaml/yaml v0.0.0-20170407172122-cd8b52f8269e\n-\t\t\t\t\tgithub.com/golang/protobuf v0.0.0-20170901042739-5afd06f9d81a\n-\t\t\t\t\tgithub.com/jmank88/nuts v0.3.0\n-\t\t\t\t\tgithub.com/nightlyone/lockfile v0.0.0-20170707060451-e83dc5e7bba0\n-\t\t\t\t\tgithub.com/pelletier/go-toml v0.0.0-20171218135716-b8b5e7696574\n-\t\t\t\t\tgithub.com/pkg/errors v0.8.0\n-\t\t\t\t\tgithub.com/sdboyer/constext v0.0.0-20170321163424-836a14457353\n-\t\t\t\t\tgolang.org/x/net v0.0.0-20170828231752-66aacef3dd8a\n-\t\t\t\t\tgolang.org/x/sync v0.0.0-20170517211232-f52d1811a629\n-\t\t\t\t\tgolang.org/x/sys v0.0.0-20170830134202-bb24a47a89ea\n-\t\t\t\t)`,\n-\t\t\t},\n-\t\t*/\n-\n-\t\t// TODO: https://github.com/docker/distribution uses vendor.conf\n-\n-\t\t{\n-\t\t\t// Godeps.json parsing.\n-\t\t\t// TODO: Should v2.0.0 work here too?\n-\t\t\t\"github.com/docker/distribution\", \"v0.0.0-20150410205453-85de3967aa93\",\n-\t\t\t`module github.com/docker/distribution\n-\n-\t\t\trequire (\n-\t\t\t\tgithub.com/AdRoll/goamz v0.0.0-20150130162828-d3664b76d905\n-\t\t\t\tgithub.com/MSOpenTech/azure-sdk-for-go v0.0.0-20150323223030-d90753bcad2e\n-\t\t\t\tgithub.com/Sirupsen/logrus v0.7.3\n-\t\t\t\tgithub.com/bugsnag/bugsnag-go v1.0.3-0.20141110184014-b1d153021fcd\n-\t\t\t\tgithub.com/bugsnag/osext v0.0.0-20130617224835-0dd3f918b21b\n-\t\t\t\tgithub.com/bugsnag/panicwrap v0.0.0-20141110184334-e5f9854865b9\n-\t\t\t\tgithub.com/codegangsta/cli v1.4.2-0.20150131031259-6086d7927ec3\n-\t\t\t\tgithub.com/docker/docker v1.4.2-0.20150204013315-165ea5c158cf\n-\t\t\t\tgithub.com/docker/libtrust v0.0.0-20150114040149-fa567046d9b1\n-\t\t\t\tgithub.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7\n-\t\t\t\tgithub.com/gorilla/context v0.0.0-20140604161150-14f550f51af5\n-\t\t\t\tgithub.com/gorilla/handlers v0.0.0-20140825150757-0e84b7d810c1\n-\t\t\t\tgithub.com/gorilla/mux v0.0.0-20140926153814-e444e69cbd2e\n-\t\t\t\tgithub.com/jlhawn/go-crypto v0.0.0-20150401213827-cd738dde20f0\n-\t\t\t\tgithub.com/yvasiyarov/go-metrics v0.0.0-20140926110328-57bccd1ccd43\n-\t\t\t\tgithub.com/yvasiyarov/gorelic v0.0.7-0.20141212073537-a9bba5b9ab50\n-\t\t\t\tgithub.com/yvasiyarov/newrelic_platform_go v0.0.0-20140908184405-b21fdbd4370f\n-\t\t\t\tgolang.org/x/net v0.0.0-20150202051010-1dfe7915deaf\n-\t\t\t\tgopkg.in/check.v1 v1.0.0-20141024133853-64131543e789\n-\t\t\t\tgopkg.in/yaml.v2 v2.0.0-20150116202057-bef53efd0c76\n-\t\t\t)`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// golang.org/issue/24585 - confusion about v2.0.0 tag in legacy non-v2 module\n-\t\t\t\"github.com/fishy/gcsbucket\", \"v0.0.0-20180217031846-618d60fe84e0\",\n-\t\t\t`module github.com/fishy/gcsbucket\n-\n-\t\t\trequire (\n-\t\t\t\tcloud.google.com/go v0.18.0\n-\t\t\t\tgithub.com/fishy/fsdb v0.0.0-20180217030800-5527ded01371\n-\t\t\t\tgithub.com/golang/protobuf v1.0.0\n-\t\t\t\tgithub.com/googleapis/gax-go v2.0.0+incompatible\n-\t\t\t\tgolang.org/x/net v0.0.0-20180216171745-136a25c244d3\n-\t\t\t\tgolang.org/x/oauth2 v0.0.0-20180207181906-543e37812f10\n-\t\t\t\tgolang.org/x/text v0.3.1-0.20180208041248-4e4a3210bb54\n-\t\t\t\tgoogle.golang.org/api v0.0.0-20180217000815-c7a403bb5fe1\n-\t\t\t\tgoogle.golang.org/appengine v1.0.0\n-\t\t\t\tgoogle.golang.org/genproto v0.0.0-20180206005123-2b5a72b8730b\n-\t\t\t\tgoogle.golang.org/grpc v1.10.0\n-\t\t\t)`,\n-\t\t},\n-\t}\n-\n-\tctx := context.Background()\n-\n-\tfor _, tt := range tests {\n-\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"_\"+tt.vers, func(t *testing.T) {\n-\t\t\tf, err := modfile.Parse(\"golden\", []byte(tt.gomod), nil)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\twant, err := f.Format()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\n-\t\t\tdir, err := modfetch.Download(ctx, module.Version{Path: tt.path, Version: tt.vers})\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\n-\t\t\tfor name := range Converters {\n-\t\t\t\tfile := filepath.Join(dir, name)\n-\t\t\t\tdata, err := os.ReadFile(file)\n-\t\t\t\tif err == nil {\n-\t\t\t\t\tf := new(modfile.File)\n-\t\t\t\t\tf.AddModuleStmt(tt.path)\n-\t\t\t\t\tif err := ConvertLegacyConfig(f, filepath.ToSlash(file), data); err != nil {\n-\t\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t\t}\n-\t\t\t\t\tout, err := f.Format()\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Fatalf(\"format after conversion: %v\", err)\n-\t\t\t\t\t}\n-\t\t\t\t\tif !bytes.Equal(out, want) {\n-\t\t\t\t\t\tt.Fatalf(\"final go.mod:\\n%s\\n\\nwant:\\n%s\", out, want)\n-\t\t\t\t\t}\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tt.Fatalf(\"no converter found for %s@%s\", tt.path, tt.vers)\n-\t\t})\n-\t}\n-}"}, {"sha": "8510f0f849342ec2ea463c61af35e0cf59d8061a", "filename": "libgo/go/cmd/go/internal/modconv/testdata/traefik.dep", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.dep", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.dep", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.dep?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,79 @@\n+# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n+\n+[[projects]]\n+  name = \"github.com/Nvveen/Gotty\"\n+  packages = [\".\"]\n+  revision = \"a8b993ba6abdb0e0c12b0125c603323a71c7790c\"\n+  source = \"github.com/ijc25/Gotty\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/OpenDNS/vegadns2client\"\n+  packages = [\".\"]\n+  revision = \"a3fa4a771d87bda2514a90a157e1fed1b6897d2e\"\n+\n+[[projects]]\n+  name = \"github.com/PuerkitoBio/purell\"\n+  packages = [\".\"]\n+  revision = \"8a290539e2e8629dbc4e6bad948158f790ec31f4\"\n+  version = \"v1.0.0\"\n+\n+[[projects]]\n+  name = \"github.com/PuerkitoBio/urlesc\"\n+  packages = [\".\"]\n+  revision = \"5bd2802263f21d8788851d5305584c82a5c75d7e\"\n+\n+[[projects]]\n+  name = \"github.com/Shopify/sarama\"\n+  packages = [\".\"]\n+  revision = \"70f6a705d4a17af059acbc6946fb2bd30762acd7\"\n+\n+[[projects]]\n+  name = \"github.com/VividCortex/gohistogram\"\n+  packages = [\".\"]\n+  revision = \"51564d9861991fb0ad0f531c99ef602d0f9866e6\"\n+  version = \"v1.0.0\"\n+\n+[[projects]]\n+  branch = \"containous-fork\"\n+  name = \"github.com/abbot/go-http-auth\"\n+  packages = [\".\"]\n+  revision = \"65b0cdae8d7fe5c05c7430e055938ef6d24a66c9\"\n+  source = \"github.com/containous/go-http-auth\"\n+\n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/abronan/valkeyrie\"\n+  packages = [\n+    \".\",\n+    \"store\",\n+    \"store/boltdb\",\n+    \"store/consul\",\n+    \"store/etcd/v2\",\n+    \"store/etcd/v3\",\n+    \"store/zookeeper\"\n+  ]\n+  revision = \"063d875e3c5fd734fa2aa12fac83829f62acfc70\"\n+  \n+[[projects]]\n+  branch = \"master\"\n+  name = \"github.com/mesosphere/mesos-dns\"\n+  packages = [\n+    \"detect\",\n+    \"errorutil\",\n+    \"logging\",\n+    \"models\",\n+    \"records\",\n+    \"records/labels\",\n+    \"records/state\",\n+    \"util\"\n+  ]\n+  revision = \"b47dc4c19f215e98da687b15b4c64e70f629bea5\"\n+  source = \"git@github.com:containous/mesos-dns.git\"\n+\n+  [[projects]]\n+  name = \"gopkg.in/fsnotify.v1\"\n+  packages = [\".\"]\n+  revision = \"629574ca2a5df945712d3079857300b5e4da0236\"\n+  source = \"github.com/fsnotify/fsnotify\"\n+  version = \"v1.4.2\"\n\\ No newline at end of file"}, {"sha": "5054295383f4c3bba0301df477d7ac2c02499b12", "filename": "libgo/go/cmd/go/internal/modconv/testdata/traefik.out", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftestdata%2Ftraefik.out?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+github.com/Nvveen/Gotty a8b993ba6abdb0e0c12b0125c603323a71c7790c\n+github.com/OpenDNS/vegadns2client a3fa4a771d87bda2514a90a157e1fed1b6897d2e\n+github.com/PuerkitoBio/purell v1.0.0\n+github.com/PuerkitoBio/urlesc 5bd2802263f21d8788851d5305584c82a5c75d7e\n+github.com/Shopify/sarama 70f6a705d4a17af059acbc6946fb2bd30762acd7\n+github.com/VividCortex/gohistogram v1.0.0\n+github.com/abbot/go-http-auth 65b0cdae8d7fe5c05c7430e055938ef6d24a66c9\n+github.com/abronan/valkeyrie 063d875e3c5fd734fa2aa12fac83829f62acfc70\n+github.com/mesosphere/mesos-dns b47dc4c19f215e98da687b15b4c64e70f629bea5\n+gopkg.in/fsnotify.v1 v1.4.2\n+replace: github.com/Nvveen/Gotty a8b993ba6abdb0e0c12b0125c603323a71c7790c github.com/ijc25/Gotty a8b993ba6abdb0e0c12b0125c603323a71c7790c\n+replace: github.com/abbot/go-http-auth 65b0cdae8d7fe5c05c7430e055938ef6d24a66c9 github.com/containous/go-http-auth 65b0cdae8d7fe5c05c7430e055938ef6d24a66c9\n+replace: github.com/mesosphere/mesos-dns b47dc4c19f215e98da687b15b4c64e70f629bea5 github.com/containous/mesos-dns b47dc4c19f215e98da687b15b4c64e70f629bea5\n+replace: gopkg.in/fsnotify.v1 v1.4.2 github.com/fsnotify/fsnotify v1.4.2"}, {"sha": "ed694581a7c6af47ba12c789ece904fb15c1099c", "filename": "libgo/go/cmd/go/internal/modfetch/bootstrap.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build cmd_go_bootstrap\n // +build cmd_go_bootstrap\n \n package modfetch"}, {"sha": "b01b4674131e7af76436c5b5513b6dbc1c155cbe", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 135, "deletions": 37, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -11,8 +11,10 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/fs\"\n+\t\"math/rand\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n \n@@ -21,17 +23,15 @@ import (\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/renameio\"\n+\t\"cmd/go/internal/robustio\"\n \n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n \n func cacheDir(path string) (string, error) {\n-\tif cfg.GOMODCACHE == \"\" {\n-\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n-\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n-\t\treturn \"\", fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n+\tif err := checkCacheDir(); err != nil {\n+\t\treturn \"\", err\n \t}\n \tenc, err := module.EscapePath(path)\n \tif err != nil {\n@@ -64,10 +64,8 @@ func CachePath(m module.Version, suffix string) (string, error) {\n // along with the directory if the directory does not exist or if the directory\n // is not completely populated.\n func DownloadDir(m module.Version) (string, error) {\n-\tif cfg.GOMODCACHE == \"\" {\n-\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n-\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n-\t\treturn \"\", fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n+\tif err := checkCacheDir(); err != nil {\n+\t\treturn \"\", err\n \t}\n \tenc, err := module.EscapePath(m.Path)\n \tif err != nil {\n@@ -108,7 +106,9 @@ func DownloadDir(m module.Version) (string, error) {\n \n \t// Check if a .ziphash file exists. It should be created before the\n \t// zip is extracted, but if it was deleted (by another program?), we need\n-\t// to re-calculate it.\n+\t// to re-calculate it. Note that checkMod will repopulate the ziphash\n+\t// file if it doesn't exist, but if the module is excluded by checks\n+\t// through GONOSUMDB or GOPRIVATE, that check and repopulation won't happen.\n \tziphashPath, err := CachePath(m, \"ziphash\")\n \tif err != nil {\n \t\treturn dir, err\n@@ -146,15 +146,13 @@ func lockVersion(mod module.Version) (unlock func(), err error) {\n \treturn lockedfile.MutexAt(path).Lock()\n }\n \n-// SideLock locks a file within the module cache that that previously guarded\n+// SideLock locks a file within the module cache that previously guarded\n // edits to files outside the cache, such as go.sum and go.mod files in the\n // user's working directory.\n // If err is nil, the caller MUST eventually call the unlock function.\n func SideLock() (unlock func(), err error) {\n-\tif cfg.GOMODCACHE == \"\" {\n-\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n-\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n-\t\tbase.Fatalf(\"go: internal error: cfg.GOMODCACHE not set\")\n+\tif err := checkCacheDir(); err != nil {\n+\t\treturn nil, err\n \t}\n \n \tpath := filepath.Join(cfg.GOMODCACHE, \"cache\", \"lock\")\n@@ -332,7 +330,7 @@ func InfoFile(path, version string) (string, error) {\n \t}\n \n \t// Stat should have populated the disk cache for us.\n-\tfile, _, err := readDiskStat(path, version)\n+\tfile, err := CachePath(module.Version{Path: path, Version: version}, \"info\")\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -349,6 +347,9 @@ func GoMod(path, rev string) ([]byte, error) {\n \t\tif _, info, err := readDiskStat(path, rev); err == nil {\n \t\t\trev = info.Version\n \t\t} else {\n+\t\t\tif errors.Is(err, statCacheErr) {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t\terr := TryProxies(func(proxy string) error {\n \t\t\t\tinfo, err := Lookup(proxy, path).Stat(rev)\n \t\t\t\tif err == nil {\n@@ -384,7 +385,7 @@ func GoModFile(path, version string) (string, error) {\n \t\treturn \"\", err\n \t}\n \t// GoMod should have populated the disk cache for us.\n-\tfile, _, err := readDiskGoMod(path, version)\n+\tfile, err := CachePath(module.Version{Path: path, Version: version}, \"mod\")\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -499,7 +500,7 @@ func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error\n \tfor _, name := range names {\n \t\tif strings.HasSuffix(name, suffix) {\n \t\t\tv := strings.TrimSuffix(name, \".info\")\n-\t\t\tif IsPseudoVersion(v) && semver.Compare(v, maxVersion) > 0 {\n+\t\t\tif module.IsPseudoVersion(v) && semver.Compare(v, maxVersion) > 0 {\n \t\t\t\tmaxVersion = v\n \t\t\t\tfile, info, err = readDiskStat(path, strings.TrimSuffix(name, \".info\"))\n \t\t\t}\n@@ -547,7 +548,7 @@ func readDiskCache(path, rev, suffix string) (file string, data []byte, err erro\n \tif err != nil {\n \t\treturn \"\", nil, errNotCached\n \t}\n-\tdata, err = renameio.ReadFile(file)\n+\tdata, err = robustio.ReadFile(file)\n \tif err != nil {\n \t\treturn file, nil, errNotCached\n \t}\n@@ -584,7 +585,29 @@ func writeDiskCache(file string, data []byte) error {\n \t\treturn err\n \t}\n \n-\tif err := renameio.WriteFile(file, data, 0666); err != nil {\n+\t// Write the file to a temporary location, and then rename it to its final\n+\t// path to reduce the likelihood of a corrupt file existing at that final path.\n+\tf, err := tempFile(filepath.Dir(file), filepath.Base(file), 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\t// Only call os.Remove on f.Name() if we failed to rename it: otherwise,\n+\t\t// some other process may have created a new file with the same name after\n+\t\t// the rename completed.\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\tos.Remove(f.Name())\n+\t\t}\n+\t}()\n+\n+\tif _, err := f.Write(data); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := robustio.Rename(f.Name(), file); err != nil {\n \t\treturn err\n \t}\n \n@@ -594,29 +617,49 @@ func writeDiskCache(file string, data []byte) error {\n \treturn nil\n }\n \n+// tempFile creates a new temporary file with given permission bits.\n+func tempFile(dir, prefix string, perm fs.FileMode) (f *os.File, err error) {\n+\tfor i := 0; i < 10000; i++ {\n+\t\tname := filepath.Join(dir, prefix+strconv.Itoa(rand.Intn(1000000000))+\".tmp\")\n+\t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, perm)\n+\t\tif os.IsExist(err) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn\n+}\n+\n // rewriteVersionList rewrites the version list in dir\n // after a new *.mod file has been written.\n-func rewriteVersionList(dir string) {\n+func rewriteVersionList(dir string) (err error) {\n \tif filepath.Base(dir) != \"@v\" {\n \t\tbase.Fatalf(\"go: internal error: misuse of rewriteVersionList\")\n \t}\n \n \tlistFile := filepath.Join(dir, \"list\")\n \n-\t// We use a separate lockfile here instead of locking listFile itself because\n-\t// we want to use Rename to write the file atomically. The list may be read by\n-\t// a GOPROXY HTTP server, and if we crash midway through a rewrite (or if the\n-\t// HTTP server ignores our locking and serves the file midway through a\n-\t// rewrite) it's better to serve a stale list than a truncated one.\n-\tunlock, err := lockedfile.MutexAt(listFile + \".lock\").Lock()\n+\t// Lock listfile when writing to it to try to avoid corruption to the file.\n+\t// Under rare circumstances, for instance, if the system loses power in the\n+\t// middle of a write it is possible for corrupt data to be written. This is\n+\t// not a problem for the go command itself, but may be an issue if the the\n+\t// cache is being served by a GOPROXY HTTP server. This will be corrected\n+\t// the next time a new version of the module is fetched and the file is rewritten.\n+\t// TODO(matloob): golang.org/issue/43313 covers adding a go mod verify\n+\t// command that removes module versions that fail checksums. It should also\n+\t// remove list files that are detected to be corrupt.\n+\tf, err := lockedfile.Edit(listFile)\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: can't lock version list lockfile: %v\", err)\n+\t\treturn err\n \t}\n-\tdefer unlock()\n-\n+\tdefer func() {\n+\t\tif cerr := f.Close(); cerr != nil && err == nil {\n+\t\t\terr = cerr\n+\t\t}\n+\t}()\n \tinfos, err := os.ReadDir(dir)\n \tif err != nil {\n-\t\treturn\n+\t\treturn err\n \t}\n \tvar list []string\n \tfor _, info := range infos {\n@@ -634,19 +677,74 @@ func rewriteVersionList(dir string) {\n \t\t\t}\n \t\t}\n \t}\n-\tSortVersions(list)\n+\tsemver.Sort(list)\n \n \tvar buf bytes.Buffer\n \tfor _, v := range list {\n \t\tbuf.WriteString(v)\n \t\tbuf.WriteString(\"\\n\")\n \t}\n-\told, _ := renameio.ReadFile(listFile)\n-\tif bytes.Equal(buf.Bytes(), old) {\n-\t\treturn\n+\tif fi, err := f.Stat(); err == nil && int(fi.Size()) == buf.Len() {\n+\t\told := make([]byte, buf.Len()+1)\n+\t\tif n, err := f.ReadAt(old, 0); err == io.EOF && n == buf.Len() && bytes.Equal(buf.Bytes(), old) {\n+\t\t\treturn nil // No edit needed.\n+\t\t}\n+\t}\n+\t// Remove existing contents, so that when we truncate to the actual size it will zero-fill,\n+\t// and we will be able to detect (some) incomplete writes as files containing trailing NUL bytes.\n+\tif err := f.Truncate(0); err != nil {\n+\t\treturn err\n+\t}\n+\t// Reserve the final size and zero-fill.\n+\tif err := f.Truncate(int64(buf.Len())); err != nil {\n+\t\treturn err\n+\t}\n+\t// Write the actual contents. If this fails partway through,\n+\t// the remainder of the file should remain as zeroes.\n+\tif _, err := f.Write(buf.Bytes()); err != nil {\n+\t\tf.Truncate(0)\n+\t\treturn err\n \t}\n \n-\tif err := renameio.WriteFile(listFile, buf.Bytes(), 0666); err != nil {\n-\t\tbase.Fatalf(\"go: failed to write version list: %v\", err)\n+\treturn nil\n+}\n+\n+var (\n+\tstatCacheOnce sync.Once\n+\tstatCacheErr  error\n+)\n+\n+// checkCacheDir checks if the directory specified by GOMODCACHE exists. An\n+// error is returned if it does not.\n+func checkCacheDir() error {\n+\tif cfg.GOMODCACHE == \"\" {\n+\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n+\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n+\t\treturn fmt.Errorf(\"internal error: cfg.GOMODCACHE not set\")\n+\t}\n+\tif !filepath.IsAbs(cfg.GOMODCACHE) {\n+\t\treturn fmt.Errorf(\"GOMODCACHE entry is relative; must be absolute path: %q.\\n\", cfg.GOMODCACHE)\n \t}\n+\n+\t// os.Stat is slow on Windows, so we only call it once to prevent unnecessary\n+\t// I/O every time this function is called.\n+\tstatCacheOnce.Do(func() {\n+\t\tfi, err := os.Stat(cfg.GOMODCACHE)\n+\t\tif err != nil {\n+\t\t\tif !os.IsNotExist(err) {\n+\t\t\t\tstatCacheErr = fmt.Errorf(\"could not create module cache: %w\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err := os.MkdirAll(cfg.GOMODCACHE, 0777); err != nil {\n+\t\t\t\tstatCacheErr = fmt.Errorf(\"could not create module cache: %w\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t\tif !fi.IsDir() {\n+\t\t\tstatCacheErr = fmt.Errorf(\"could not create module cache: %q is not a directory\", cfg.GOMODCACHE)\n+\t\t\treturn\n+\t\t}\n+\t})\n+\treturn statCacheErr\n }"}, {"sha": "4d4964edf447ebb7e963acd2c0defb74bb5957f6", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -296,6 +296,9 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t// Or maybe it's the prefix of a hash of a named ref.\n \t// Try to resolve to both a ref (git name) and full (40-hex-digit) commit hash.\n \tr.refsOnce.Do(r.loadRefs)\n+\t// loadRefs may return an error if git fails, for example segfaults, or\n+\t// could not load a private repo, but defer checking to the else block\n+\t// below, in case we already have the rev in question in the local cache.\n \tvar ref, hash string\n \tif r.refs[\"refs/tags/\"+rev] != \"\" {\n \t\tref = \"refs/tags/\" + rev\n@@ -332,6 +335,9 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t\t\thash = rev\n \t\t}\n \t} else {\n+\t\tif r.refsErr != nil {\n+\t\t\treturn nil, r.refsErr\n+\t\t}\n \t\treturn nil, &UnknownRevisionError{Rev: rev}\n \t}\n "}, {"sha": "a684fa1a9bba9e4a253b19018840adf3b34c32ce", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git_test.go", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"archive/zip\"\n \t\"bytes\"\n \t\"flag\"\n-\t\"fmt\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/fs\"\n@@ -47,36 +46,32 @@ var altRepos = []string{\n var localGitRepo string\n \n func testMain(m *testing.M) int {\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tfmt.Fprintln(os.Stderr, \"skipping because git binary not found\")\n-\t\tfmt.Println(\"PASS\")\n-\t\treturn 0\n-\t}\n-\n \tdir, err := os.MkdirTemp(\"\", \"gitrepo-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n \tdefer os.RemoveAll(dir)\n \n \tif testenv.HasExternalNetwork() && testenv.HasExec() {\n-\t\t// Clone gitrepo1 into a local directory.\n-\t\t// If we use a file:// URL to access the local directory,\n-\t\t// then git starts up all the usual protocol machinery,\n-\t\t// which will let us test remote git archive invocations.\n-\t\tlocalGitRepo = filepath.Join(dir, \"gitrepo2\")\n-\t\tif _, err := Run(\"\", \"git\", \"clone\", \"--mirror\", gitrepo1, localGitRepo); err != nil {\n-\t\t\tlog.Fatal(err)\n-\t\t}\n-\t\tif _, err := Run(localGitRepo, \"git\", \"config\", \"daemon.uploadarch\", \"true\"); err != nil {\n-\t\t\tlog.Fatal(err)\n+\t\tif _, err := exec.LookPath(\"git\"); err == nil {\n+\t\t\t// Clone gitrepo1 into a local directory.\n+\t\t\t// If we use a file:// URL to access the local directory,\n+\t\t\t// then git starts up all the usual protocol machinery,\n+\t\t\t// which will let us test remote git archive invocations.\n+\t\t\tlocalGitRepo = filepath.Join(dir, \"gitrepo2\")\n+\t\t\tif _, err := Run(\"\", \"git\", \"clone\", \"--mirror\", gitrepo1, localGitRepo); err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n+\t\t\tif _, err := Run(localGitRepo, \"git\", \"config\", \"daemon.uploadarch\", \"true\"); err != nil {\n+\t\t\t\tlog.Fatal(err)\n+\t\t\t}\n \t\t}\n \t}\n \n \treturn m.Run()\n }\n \n-func testRepo(remote string) (Repo, error) {\n+func testRepo(t *testing.T, remote string) (Repo, error) {\n \tif remote == \"localGitRepo\" {\n \t\t// Convert absolute path to file URL. LocalGitRepo will not accept\n \t\t// Windows absolute paths because they look like a host:path remote.\n@@ -87,15 +82,17 @@ func testRepo(remote string) (Repo, error) {\n \t\t} else {\n \t\t\turl = \"file:///\" + filepath.ToSlash(localGitRepo)\n \t\t}\n+\t\ttestenv.MustHaveExecPath(t, \"git\")\n \t\treturn LocalGitRepo(url)\n \t}\n-\tkind := \"git\"\n+\tvcs := \"git\"\n \tfor _, k := range []string{\"hg\"} {\n \t\tif strings.Contains(remote, \"/\"+k+\"/\") {\n-\t\t\tkind = k\n+\t\t\tvcs = k\n \t\t}\n \t}\n-\treturn NewRepo(kind, remote)\n+\ttestenv.MustHaveExecPath(t, vcs)\n+\treturn NewRepo(vcs, remote)\n }\n \n var tagsTests = []struct {\n@@ -116,7 +113,7 @@ func TestTags(t *testing.T) {\n \n \tfor _, tt := range tagsTests {\n \t\tf := func(t *testing.T) {\n-\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tr, err := testRepo(t, tt.repo)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -168,7 +165,7 @@ func TestLatest(t *testing.T) {\n \n \tfor _, tt := range latestTests {\n \t\tf := func(t *testing.T) {\n-\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tr, err := testRepo(t, tt.repo)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -221,7 +218,7 @@ func TestReadFile(t *testing.T) {\n \n \tfor _, tt := range readFileTests {\n \t\tf := func(t *testing.T) {\n-\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tr, err := testRepo(t, tt.repo)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -412,7 +409,7 @@ func TestReadZip(t *testing.T) {\n \n \tfor _, tt := range readZipTests {\n \t\tf := func(t *testing.T) {\n-\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tr, err := testRepo(t, tt.repo)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -581,7 +578,7 @@ func TestStat(t *testing.T) {\n \n \tfor _, tt := range statTests {\n \t\tf := func(t *testing.T) {\n-\t\t\tr, err := testRepo(tt.repo)\n+\t\t\tr, err := testRepo(t, tt.repo)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}"}, {"sha": "0e9f38196676b108a28c77e9c2d5b591ecb0ae02", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build ignore\n // +build ignore\n \n // Interactive debugging shell for codehost.Repo implementations."}, {"sha": "dfef9f73c27aefa1bd3073706280a62f5cd8173e", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -159,7 +159,7 @@ func (r *codeRepo) Versions(prefix string) ([]string, error) {\n \t\tif r.codeDir != \"\" {\n \t\t\tv = v[len(r.codeDir)+1:]\n \t\t}\n-\t\tif v == \"\" || v != module.CanonicalVersion(v) || IsPseudoVersion(v) {\n+\t\tif v == \"\" || v != module.CanonicalVersion(v) || module.IsPseudoVersion(v) {\n \t\t\tcontinue\n \t\t}\n \n@@ -172,8 +172,8 @@ func (r *codeRepo) Versions(prefix string) ([]string, error) {\n \n \t\tlist = append(list, v)\n \t}\n-\tSortVersions(list)\n-\tSortVersions(incompatible)\n+\tsemver.Sort(list)\n+\tsemver.Sort(incompatible)\n \n \treturn r.appendIncompatibleVersions(list, incompatible)\n }\n@@ -385,7 +385,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \tif statVers != \"\" && statVers == module.CanonicalVersion(statVers) {\n \t\tinfo2.Version = statVers\n \n-\t\tif IsPseudoVersion(info2.Version) {\n+\t\tif module.IsPseudoVersion(info2.Version) {\n \t\t\tif err := r.validatePseudoVersion(info, info2.Version); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n@@ -433,7 +433,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t}\n \t\ttrimmed := tag[len(tagPrefix):]\n \t\t// Tags that look like pseudo-versions would be confusing. Ignore them.\n-\t\tif IsPseudoVersion(tag) {\n+\t\tif module.IsPseudoVersion(tag) {\n \t\t\treturn \"\", false\n \t\t}\n \n@@ -531,7 +531,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\tpseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid\n \t}\n \n-\tinfo2.Version = PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)\n+\tinfo2.Version = module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)\n \treturn checkGoMod()\n }\n \n@@ -560,7 +560,7 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\treturn err\n \t}\n \n-\trev, err := PseudoVersionRev(version)\n+\trev, err := module.PseudoVersionRev(version)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -575,12 +575,12 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\t}\n \t}\n \n-\tt, err := PseudoVersionTime(version)\n+\tt, err := module.PseudoVersionTime(version)\n \tif err != nil {\n \t\treturn err\n \t}\n \tif !t.Equal(info.Time.Truncate(time.Second)) {\n-\t\treturn fmt.Errorf(\"does not match version-control timestamp (expected %s)\", info.Time.UTC().Format(pseudoVersionTimestampFormat))\n+\t\treturn fmt.Errorf(\"does not match version-control timestamp (expected %s)\", info.Time.UTC().Format(module.PseudoVersionTimestampFormat))\n \t}\n \n \ttagPrefix := \"\"\n@@ -604,7 +604,7 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t// not enforce that property when resolving existing pseudo-versions: we don't\n \t// know when the parent tags were added, and the highest-tagged parent may not\n \t// have existed when the pseudo-version was first resolved.\n-\tbase, err := PseudoVersionBase(strings.TrimSuffix(version, \"+incompatible\"))\n+\tbase, err := module.PseudoVersionBase(strings.TrimSuffix(version, \"+incompatible\"))\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -661,7 +661,7 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\trev, err := PseudoVersionRev(version)\n+\t\trev, err := module.PseudoVersionRev(version)\n \t\tif err != nil {\n \t\t\treturn fmt.Errorf(\"not a descendent of preceding tag (%s)\", lastTag)\n \t\t}\n@@ -672,8 +672,8 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \n func (r *codeRepo) revToRev(rev string) string {\n \tif semver.IsValid(rev) {\n-\t\tif IsPseudoVersion(rev) {\n-\t\t\tr, _ := PseudoVersionRev(rev)\n+\t\tif module.IsPseudoVersion(rev) {\n+\t\t\tr, _ := module.PseudoVersionRev(rev)\n \t\t\treturn r\n \t\t}\n \t\tif semver.Build(rev) == \"+incompatible\" {\n@@ -843,7 +843,7 @@ func (r *codeRepo) GoMod(version string) (data []byte, err error) {\n \t\treturn nil, fmt.Errorf(\"version %s is not canonical\", version)\n \t}\n \n-\tif IsPseudoVersion(version) {\n+\tif module.IsPseudoVersion(version) {\n \t\t// findDir ignores the metadata encoded in a pseudo-version,\n \t\t// only using the revision at the end.\n \t\t// Invoke Stat to verify the metadata explicitly so we don't return\n@@ -864,22 +864,25 @@ func (r *codeRepo) GoMod(version string) (data []byte, err error) {\n \tdata, err = r.code.ReadFile(rev, path.Join(dir, \"go.mod\"), codehost.MaxGoMod)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n-\t\t\treturn r.legacyGoMod(rev, dir), nil\n+\t\t\treturn LegacyGoMod(r.modPath), nil\n \t\t}\n \t\treturn nil, err\n \t}\n \treturn data, nil\n }\n \n-func (r *codeRepo) legacyGoMod(rev, dir string) []byte {\n-\t// We used to try to build a go.mod reflecting pre-existing\n-\t// package management metadata files, but the conversion\n-\t// was inherently imperfect (because those files don't have\n-\t// exactly the same semantics as go.mod) and, when done\n-\t// for dependencies in the middle of a build, impossible to\n-\t// correct. So we stopped.\n-\t// Return a fake go.mod that simply declares the module path.\n-\treturn []byte(fmt.Sprintf(\"module %s\\n\", modfile.AutoQuote(r.modPath)))\n+// LegacyGoMod generates a fake go.mod file for a module that doesn't have one.\n+// The go.mod file contains a module directive and nothing else: no go version,\n+// no requirements.\n+//\n+// We used to try to build a go.mod reflecting pre-existing\n+// package management metadata files, but the conversion\n+// was inherently imperfect (because those files don't have\n+// exactly the same semantics as go.mod) and, when done\n+// for dependencies in the middle of a build, impossible to\n+// correct. So we stopped.\n+func LegacyGoMod(modPath string) []byte {\n+\treturn []byte(fmt.Sprintf(\"module %s\\n\", modfile.AutoQuote(modPath)))\n }\n \n func (r *codeRepo) modPrefix(rev string) string {\n@@ -942,7 +945,7 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t\treturn fmt.Errorf(\"version %s is not canonical\", version)\n \t}\n \n-\tif IsPseudoVersion(version) {\n+\tif module.IsPseudoVersion(version) {\n \t\t// findDir ignores the metadata encoded in a pseudo-version,\n \t\t// only using the revision at the end.\n \t\t// Invoke Stat to verify the metadata explicitly so we don't return"}, {"sha": "d3d30d970b3b979b14741ce2a2da38c8812a422c", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,6 +8,8 @@ import (\n \t\"archive/zip\"\n \t\"bytes\"\n \t\"context\"\n+\t\"crypto/sha256\"\n+\t\"encoding/base64\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -20,9 +22,9 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/robustio\"\n \t\"cmd/go/internal/trace\"\n \n@@ -37,10 +39,8 @@ var downloadCache par.Cache\n // local download cache and returns the name of the directory\n // corresponding to the root of the module's file tree.\n func Download(ctx context.Context, mod module.Version) (dir string, err error) {\n-\tif cfg.GOMODCACHE == \"\" {\n-\t\t// modload.Init exits if GOPATH[0] is empty, and cfg.GOMODCACHE\n-\t\t// is set to GOPATH[0]/pkg/mod if GOMODCACHE is empty, so this should never happen.\n-\t\tbase.Fatalf(\"go: internal error: cfg.GOMODCACHE not set\")\n+\tif err := checkCacheDir(); err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \t// The par.Cache here avoids duplicate work.\n@@ -223,11 +223,10 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \t// Clean up any remaining tempfiles from previous runs.\n \t// This is only safe to do because the lock file ensures that their\n \t// writers are no longer active.\n-\tfor _, base := range []string{zipfile, zipfile + \"hash\"} {\n-\t\tif old, err := filepath.Glob(renameio.Pattern(base)); err == nil {\n-\t\t\tfor _, path := range old {\n-\t\t\t\tos.Remove(path) // best effort\n-\t\t\t}\n+\ttmpPattern := filepath.Base(zipfile) + \"*.tmp\"\n+\tif old, err := filepath.Glob(filepath.Join(filepath.Dir(zipfile), tmpPattern)); err == nil {\n+\t\tfor _, path := range old {\n+\t\t\tos.Remove(path) // best effort\n \t\t}\n \t}\n \n@@ -242,7 +241,7 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \t// contents of the file (by hashing it) before we commit it. Because the file\n \t// is zip-compressed, we need an actual file \u2014 or at least an io.ReaderAt \u2014 to\n \t// validate it: we can't just tee the stream as we write it.\n-\tf, err := os.CreateTemp(filepath.Dir(zipfile), filepath.Base(renameio.Pattern(zipfile)))\n+\tf, err := os.CreateTemp(filepath.Dir(zipfile), tmpPattern)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -298,12 +297,6 @@ func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err e\n \t\t}\n \t}\n \n-\t// Sync the file before renaming it: otherwise, after a crash the reader may\n-\t// observe a 0-length file instead of the actual contents.\n-\t// See https://golang.org/issue/22397#issuecomment-380831736.\n-\tif err := f.Sync(); err != nil {\n-\t\treturn err\n-\t}\n \tif err := f.Close(); err != nil {\n \t\treturn err\n \t}\n@@ -334,7 +327,21 @@ func hashZip(mod module.Version, zipfile, ziphashfile string) error {\n \tif err := checkModSum(mod, hash); err != nil {\n \t\treturn err\n \t}\n-\treturn renameio.WriteFile(ziphashfile, []byte(hash), 0666)\n+\thf, err := lockedfile.Create(ziphashfile)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif err := hf.Truncate(int64(len(hash))); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := hf.WriteAt([]byte(hash), 0); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := hf.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n }\n \n // makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir\n@@ -410,7 +417,18 @@ func initGoSum() (bool, error) {\n \n \tgoSum.m = make(map[module.Version][]string)\n \tgoSum.status = make(map[modSum]modSumStatus)\n-\tdata, err := lockedfile.Read(GoSumFile)\n+\tvar (\n+\t\tdata []byte\n+\t\terr  error\n+\t)\n+\tif actualSumFile, ok := fsys.OverlayPath(GoSumFile); ok {\n+\t\t// Don't lock go.sum if it's part of the overlay.\n+\t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n+\t\t// in the overlay. See #44700.\n+\t\tdata, err = os.ReadFile(actualSumFile)\n+\t} else {\n+\t\tdata, err = lockedfile.Read(GoSumFile)\n+\t}\n \tif err != nil && !os.IsNotExist(err) {\n \t\treturn false, err\n \t}\n@@ -485,11 +503,24 @@ func checkMod(mod module.Version) {\n \tif err != nil {\n \t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n-\tdata, err := renameio.ReadFile(ziphash)\n+\tdata, err := lockedfile.Read(ziphash)\n \tif err != nil {\n \t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n-\th := strings.TrimSpace(string(data))\n+\tdata = bytes.TrimSpace(data)\n+\tif !isValidSum(data) {\n+\t\t// Recreate ziphash file from zip file and use that to check the mod sum.\n+\t\tzip, err := CachePath(mod, \"zip\")\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n+\t\t}\n+\t\terr = hashZip(mod, zip, ziphash)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n+\t\t}\n+\t\treturn\n+\t}\n+\th := string(data)\n \tif !strings.HasPrefix(h, \"h1:\") {\n \t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, fmt.Errorf(\"unexpected ziphash: %q\", h)))\n \t}\n@@ -634,11 +665,32 @@ func Sum(mod module.Version) string {\n \tif err != nil {\n \t\treturn \"\"\n \t}\n-\tdata, err := renameio.ReadFile(ziphash)\n+\tdata, err := lockedfile.Read(ziphash)\n \tif err != nil {\n \t\treturn \"\"\n \t}\n-\treturn strings.TrimSpace(string(data))\n+\tdata = bytes.TrimSpace(data)\n+\tif !isValidSum(data) {\n+\t\treturn \"\"\n+\t}\n+\treturn string(data)\n+}\n+\n+// isValidSum returns true if data is the valid contents of a zip hash file.\n+// Certain critical files are written to disk by first truncating\n+// then writing the actual bytes, so that if the write fails\n+// the corrupt file should contain at least one of the null\n+// bytes written by the truncate operation.\n+func isValidSum(data []byte) bool {\n+\tif bytes.IndexByte(data, '\\000') >= 0 {\n+\t\treturn false\n+\t}\n+\n+\tif len(data) != len(\"h1:\")+base64.StdEncoding.EncodedLen(sha256.Size) {\n+\t\treturn false\n+\t}\n+\n+\treturn true\n }\n \n // WriteGoSum writes the go.sum file if it needs to be updated.\n@@ -676,6 +728,9 @@ Outer:\n \tif cfg.BuildMod == \"readonly\" {\n \t\tbase.Fatalf(\"go: updates to go.sum needed, disabled by -mod=readonly\")\n \t}\n+\tif _, ok := fsys.OverlayPath(GoSumFile); ok {\n+\t\tbase.Fatalf(\"go: updates to go.sum needed, but go.sum is part of the overlay specified with -overlay\")\n+\t}\n \n \t// Make a best-effort attempt to acquire the side lock, only to exclude\n \t// previous versions of the 'go' command from making simultaneous edits."}, {"sha": "012d05f29db55cd36060296eea832c58d7b149fc", "filename": "libgo/go/cmd/go/internal/modfetch/insecure.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modfetch\n-\n-import (\n-\t\"cmd/go/internal/cfg\"\n-\n-\t\"golang.org/x/mod/module\"\n-)\n-\n-// allowInsecure reports whether we are allowed to fetch this path in an insecure manner.\n-func allowInsecure(path string) bool {\n-\treturn cfg.Insecure || module.MatchPrefixPatterns(cfg.GOINSECURE, path)\n-}"}, {"sha": "31d453c8074e6a52b4b9fe7009ef9ef79aba70e3", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -228,7 +228,7 @@ func (p *proxyRepo) versionError(version string, err error) error {\n \t\t\tPath: p.path,\n \t\t\tErr: &module.InvalidVersionError{\n \t\t\t\tVersion: version,\n-\t\t\t\tPseudo:  IsPseudoVersion(version),\n+\t\t\t\tPseudo:  module.IsPseudoVersion(version),\n \t\t\t\tErr:     err,\n \t\t\t},\n \t\t}\n@@ -276,11 +276,11 @@ func (p *proxyRepo) Versions(prefix string) ([]string, error) {\n \tvar list []string\n \tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tf := strings.Fields(line)\n-\t\tif len(f) >= 1 && semver.IsValid(f[0]) && strings.HasPrefix(f[0], prefix) && !IsPseudoVersion(f[0]) {\n+\t\tif len(f) >= 1 && semver.IsValid(f[0]) && strings.HasPrefix(f[0], prefix) && !module.IsPseudoVersion(f[0]) {\n \t\t\tlist = append(list, f[0])\n \t\t}\n \t}\n-\tSortVersions(list)\n+\tsemver.Sort(list)\n \treturn list, nil\n }\n \n@@ -307,8 +307,8 @@ func (p *proxyRepo) latest() (*RevInfo, error) {\n \t\t\t)\n \t\t\tif len(f) >= 2 {\n \t\t\t\tft, _ = time.Parse(time.RFC3339, f[1])\n-\t\t\t} else if IsPseudoVersion(f[0]) {\n-\t\t\t\tft, _ = PseudoVersionTime(f[0])\n+\t\t\t} else if module.IsPseudoVersion(f[0]) {\n+\t\t\t\tft, _ = module.PseudoVersionTime(f[0])\n \t\t\t\tftIsFromPseudo = true\n \t\t\t} else {\n \t\t\t\t// Repo.Latest promises that this method is only called where there are"}, {"sha": "4483f8e962fa5212ea2ae65e1eac66e5117a15ed", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo_test.go", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modfetch\n-\n-import (\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-var pseudoTests = []struct {\n-\tmajor   string\n-\tolder   string\n-\tversion string\n-}{\n-\t{\"\", \"\", \"v0.0.0-20060102150405-hash\"},\n-\t{\"v0\", \"\", \"v0.0.0-20060102150405-hash\"},\n-\t{\"v1\", \"\", \"v1.0.0-20060102150405-hash\"},\n-\t{\"v2\", \"\", \"v2.0.0-20060102150405-hash\"},\n-\t{\"unused\", \"v0.0.0\", \"v0.0.1-0.20060102150405-hash\"},\n-\t{\"unused\", \"v1.2.3\", \"v1.2.4-0.20060102150405-hash\"},\n-\t{\"unused\", \"v1.2.99999999999999999\", \"v1.2.100000000000000000-0.20060102150405-hash\"},\n-\t{\"unused\", \"v1.2.3-pre\", \"v1.2.3-pre.0.20060102150405-hash\"},\n-\t{\"unused\", \"v1.3.0-pre\", \"v1.3.0-pre.0.20060102150405-hash\"},\n-\t{\"unused\", \"v0.0.0--\", \"v0.0.0--.0.20060102150405-hash\"},\n-\t{\"unused\", \"v1.0.0+metadata\", \"v1.0.1-0.20060102150405-hash+metadata\"},\n-\t{\"unused\", \"v2.0.0+incompatible\", \"v2.0.1-0.20060102150405-hash+incompatible\"},\n-\t{\"unused\", \"v2.3.0-pre+incompatible\", \"v2.3.0-pre.0.20060102150405-hash+incompatible\"},\n-}\n-\n-var pseudoTime = time.Date(2006, 1, 2, 15, 4, 5, 0, time.UTC)\n-\n-func TestPseudoVersion(t *testing.T) {\n-\tfor _, tt := range pseudoTests {\n-\t\tv := PseudoVersion(tt.major, tt.older, pseudoTime, \"hash\")\n-\t\tif v != tt.version {\n-\t\t\tt.Errorf(\"PseudoVersion(%q, %q, ...) = %v, want %v\", tt.major, tt.older, v, tt.version)\n-\t\t}\n-\t}\n-}\n-\n-func TestIsPseudoVersion(t *testing.T) {\n-\tfor _, tt := range pseudoTests {\n-\t\tif !IsPseudoVersion(tt.version) {\n-\t\t\tt.Errorf(\"IsPseudoVersion(%q) = false, want true\", tt.version)\n-\t\t}\n-\t\tif IsPseudoVersion(tt.older) {\n-\t\t\tt.Errorf(\"IsPseudoVersion(%q) = true, want false\", tt.older)\n-\t\t}\n-\t}\n-}\n-\n-func TestPseudoVersionTime(t *testing.T) {\n-\tfor _, tt := range pseudoTests {\n-\t\ttm, err := PseudoVersionTime(tt.version)\n-\t\tif tm != pseudoTime || err != nil {\n-\t\t\tt.Errorf(\"PseudoVersionTime(%q) = %v, %v, want %v, nil\", tt.version, tm.Format(time.RFC3339), err, pseudoTime.Format(time.RFC3339))\n-\t\t}\n-\t\ttm, err = PseudoVersionTime(tt.older)\n-\t\tif tm != (time.Time{}) || err == nil {\n-\t\t\tt.Errorf(\"PseudoVersionTime(%q) = %v, %v, want %v, error\", tt.older, tm.Format(time.RFC3339), err, time.Time{}.Format(time.RFC3339))\n-\t\t}\n-\t}\n-}\n-\n-func TestInvalidPseudoVersionTime(t *testing.T) {\n-\tconst v = \"---\"\n-\tif _, err := PseudoVersionTime(v); err == nil {\n-\t\tt.Error(\"expected error, got nil instead\")\n-\t}\n-}\n-\n-func TestPseudoVersionRev(t *testing.T) {\n-\tfor _, tt := range pseudoTests {\n-\t\trev, err := PseudoVersionRev(tt.version)\n-\t\tif rev != \"hash\" || err != nil {\n-\t\t\tt.Errorf(\"PseudoVersionRev(%q) = %q, %v, want %q, nil\", tt.older, rev, err, \"hash\")\n-\t\t}\n-\t\trev, err = PseudoVersionRev(tt.older)\n-\t\tif rev != \"\" || err == nil {\n-\t\t\tt.Errorf(\"PseudoVersionRev(%q) = %q, %v, want %q, error\", tt.older, rev, err, \"\")\n-\t\t}\n-\t}\n-}\n-\n-func TestPseudoVersionBase(t *testing.T) {\n-\tfor _, tt := range pseudoTests {\n-\t\tbase, err := PseudoVersionBase(tt.version)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"PseudoVersionBase(%q): %v\", tt.version, err)\n-\t\t} else if base != tt.older {\n-\t\t\tt.Errorf(\"PseudoVersionBase(%q) = %q; want %q\", tt.version, base, tt.older)\n-\t\t}\n-\t}\n-}\n-\n-func TestInvalidPseudoVersionBase(t *testing.T) {\n-\tfor _, in := range []string{\n-\t\t\"v0.0.0\",\n-\t\t\"v0.0.0-\",                                 // malformed: empty prerelease\n-\t\t\"v0.0.0-0.20060102150405-hash\",            // Z+1 == 0\n-\t\t\"v0.1.0-0.20060102150405-hash\",            // Z+1 == 0\n-\t\t\"v1.0.0-0.20060102150405-hash\",            // Z+1 == 0\n-\t\t\"v0.0.0-20060102150405-hash+incompatible\", // \"+incompatible without base version\n-\t\t\"v0.0.0-20060102150405-hash+metadata\",     // other metadata without base version\n-\t} {\n-\t\tbase, err := PseudoVersionBase(in)\n-\t\tif err == nil || base != \"\" {\n-\t\t\tt.Errorf(`PseudoVersionBase(%q) = %q, %v; want \"\", error`, in, base, err)\n-\t\t}\n-\t}\n-}\n-\n-func TestIncDecimal(t *testing.T) {\n-\tcases := []struct {\n-\t\tin, want string\n-\t}{\n-\t\t{\"0\", \"1\"},\n-\t\t{\"1\", \"2\"},\n-\t\t{\"99\", \"100\"},\n-\t\t{\"100\", \"101\"},\n-\t\t{\"101\", \"102\"},\n-\t}\n-\n-\tfor _, tc := range cases {\n-\t\tgot := incDecimal(tc.in)\n-\t\tif got != tc.want {\n-\t\t\tt.Fatalf(\"incDecimal(%q) = %q; want %q\", tc.in, tc.want, got)\n-\t\t}\n-\t}\n-}\n-\n-func TestDecDecimal(t *testing.T) {\n-\tcases := []struct {\n-\t\tin, want string\n-\t}{\n-\t\t{\"\", \"\"},\n-\t\t{\"0\", \"\"},\n-\t\t{\"00\", \"\"},\n-\t\t{\"1\", \"0\"},\n-\t\t{\"2\", \"1\"},\n-\t\t{\"99\", \"98\"},\n-\t\t{\"100\", \"99\"},\n-\t\t{\"101\", \"100\"},\n-\t}\n-\n-\tfor _, tc := range cases {\n-\t\tgot := decDecimal(tc.in)\n-\t\tif got != tc.want {\n-\t\t\tt.Fatalf(\"decDecimal(%q) = %q; want %q\", tc.in, tc.want, got)\n-\t\t}\n-\t}\n-}"}, {"sha": "0bffa55af6f2ed6c4b12ec8363a8bb4f7f434bc6", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 4, "deletions": 71, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"io\"\n \t\"io/fs\"\n \t\"os\"\n-\t\"sort\"\n \t\"strconv\"\n \t\"time\"\n \n@@ -20,7 +19,6 @@ import (\n \tweb \"cmd/go/internal/web\"\n \n \t\"golang.org/x/mod/module\"\n-\t\"golang.org/x/mod/semver\"\n )\n \n const traceRepo = false // trace all repo actions, for debugging\n@@ -35,7 +33,7 @@ type Repo interface {\n \t// Pseudo-versions are not included.\n \t//\n \t// Versions should be returned sorted in semver order\n-\t// (implementations can use SortVersions).\n+\t// (implementations can use semver.Sort).\n \t//\n \t// Versions returns a non-nil error only if there was a problem\n \t// fetching the list of versions: it may return an empty list\n@@ -171,15 +169,6 @@ type RevInfo struct {\n // and it can check that the path can be resolved to a target repository.\n // To avoid version control access except when absolutely necessary,\n // Lookup does not attempt to connect to the repository itself.\n-//\n-// The ImportRepoRev function is a variant of Import which is limited\n-// to code in a source code repository at a particular revision identifier\n-// (usually a commit hash or source code repository tag, not necessarily\n-// a module version).\n-// ImportRepoRev is used when converting legacy dependency requirements\n-// from older systems into go.mod files. Those older systems worked\n-// at either package or repository granularity, and most of the time they\n-// recorded commit hashes, not tagged versions.\n \n var lookupCache par.Cache\n \n@@ -194,7 +183,8 @@ type lookupCacheKey struct {\n // from its origin, and \"noproxy\" indicates that the patch should be fetched\n // directly only if GONOPROXY matches the given path.\n //\n-// For the distinguished proxy \"off\", Lookup always returns a non-nil error.\n+// For the distinguished proxy \"off\", Lookup always returns a Repo that returns\n+// a non-nil error for every method call.\n //\n // A successful return does not guarantee that the module\n // has any defined versions.\n@@ -267,7 +257,7 @@ var (\n func lookupDirect(path string) (Repo, error) {\n \tsecurity := web.SecureOnly\n \n-\tif allowInsecure(path) {\n+\tif module.MatchPrefixPatterns(cfg.GOINSECURE, path) {\n \t\tsecurity = web.Insecure\n \t}\n \trr, err := vcs.RepoRootForImportPath(path, vcs.PreferMod, security)\n@@ -299,63 +289,6 @@ func lookupCodeRepo(rr *vcs.RepoRoot) (codehost.Repo, error) {\n \treturn code, nil\n }\n \n-// ImportRepoRev returns the module and version to use to access\n-// the given import path loaded from the source code repository that\n-// the original \"go get\" would have used, at the specific repository revision\n-// (typically a commit hash, but possibly also a source control tag).\n-func ImportRepoRev(path, rev string) (Repo, *RevInfo, error) {\n-\tif cfg.BuildMod == \"vendor\" || cfg.BuildMod == \"readonly\" {\n-\t\treturn nil, nil, fmt.Errorf(\"repo version lookup disabled by -mod=%s\", cfg.BuildMod)\n-\t}\n-\n-\t// Note: Because we are converting a code reference from a legacy\n-\t// version control system, we ignore meta tags about modules\n-\t// and use only direct source control entries (get.IgnoreMod).\n-\tsecurity := web.SecureOnly\n-\tif allowInsecure(path) {\n-\t\tsecurity = web.Insecure\n-\t}\n-\trr, err := vcs.RepoRootForImportPath(path, vcs.IgnoreMod, security)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tcode, err := lookupCodeRepo(rr)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\trevInfo, err := code.Stat(rev)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\t// TODO: Look in repo to find path, check for go.mod files.\n-\t// For now we're just assuming rr.Root is the module path,\n-\t// which is true in the absence of go.mod files.\n-\n-\trepo, err := newCodeRepo(code, rr.Root, rr.Root)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\n-\tinfo, err := repo.(*codeRepo).convert(revInfo, rev)\n-\tif err != nil {\n-\t\treturn nil, nil, err\n-\t}\n-\treturn repo, info, nil\n-}\n-\n-func SortVersions(list []string) {\n-\tsort.Slice(list, func(i, j int) bool {\n-\t\tcmp := semver.Compare(list[i], list[j])\n-\t\tif cmp != 0 {\n-\t\t\treturn cmp < 0\n-\t\t}\n-\t\treturn list[i] < list[j]\n-\t})\n-}\n-\n // A loggingRepo is a wrapper around an underlying Repo\n // that prints a log message at the start and end of each call.\n // It can be inserted when debugging."}, {"sha": "f233cba6df1bb7e996735147834e9c40960158f4", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -4,6 +4,7 @@\n \n // Go checksum database lookup\n \n+//go:build !cmd_go_bootstrap\n // +build !cmd_go_bootstrap\n \n package modfetch\n@@ -33,7 +34,7 @@ import (\n \n // useSumDB reports whether to use the Go checksum database for the given module.\n func useSumDB(mod module.Version) bool {\n-\treturn cfg.GOSUMDB != \"off\" && !cfg.Insecure && !module.MatchPrefixPatterns(cfg.GONOSUMDB, mod.Path)\n+\treturn cfg.GOSUMDB != \"off\" && !module.MatchPrefixPatterns(cfg.GONOSUMDB, mod.Path)\n }\n \n // lookupSumDB returns the Go checksum database's go.sum lines for the given module,\n@@ -184,7 +185,7 @@ func (c *dbClient) initBase() {\n \t\t}\n \t})\n \tif errors.Is(err, fs.ErrNotExist) {\n-\t\t// No proxies, or all proxies failed (with 404, 410, or were were allowed\n+\t\t// No proxies, or all proxies failed (with 404, 410, or were allowed\n \t\t// to fall back), or we reached an explicit \"direct\" or \"off\".\n \t\tc.base = c.direct\n \t} else if err != nil {"}, {"sha": "9672e5598e0d3a980570899a4770925effaee087", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 274, "deletions": 122, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -30,16 +30,15 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"reflect\"\n \t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n@@ -53,7 +52,7 @@ import (\n var CmdGet = &base.Command{\n \t// Note: -d -u are listed explicitly because they are the most common get flags.\n \t// Do not send CLs removing them because they're covered by [get flags].\n-\tUsageLine: \"go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\",\n+\tUsageLine: \"go get [-d] [-t] [-u] [-v] [build flags] [packages]\",\n \tShort:     \"add dependencies to current module and install them\",\n \tLong: `\n Get resolves its command-line arguments to packages at specific module versions,\n@@ -99,14 +98,6 @@ but changes the default to select patch releases.\n When the -t and -u flags are used together, get will update\n test dependencies as well.\n \n-The -insecure flag permits fetching from repositories and resolving\n-custom domains using insecure schemes such as HTTP, and also bypassess\n-module sum validation using the checksum database. Use with caution.\n-This flag is deprecated and will be removed in a future version of go.\n-To permit the use of insecure schemes, use the GOINSECURE environment\n-variable instead. To bypass module sum validation, use GOPRIVATE or\n-GONOSUMDB. See 'go help environment' for details.\n-\n The -d flag instructs get not to build or install packages. get will only\n update go.mod and download source code needed to build packages.\n \n@@ -227,13 +218,13 @@ variable for future go command invocations.\n }\n \n var (\n-\tgetD   = CmdGet.Flag.Bool(\"d\", false, \"\")\n-\tgetF   = CmdGet.Flag.Bool(\"f\", false, \"\")\n-\tgetFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n-\tgetM   = CmdGet.Flag.Bool(\"m\", false, \"\")\n-\tgetT   = CmdGet.Flag.Bool(\"t\", false, \"\")\n-\tgetU   upgradeFlag\n-\t// -insecure is cfg.Insecure\n+\tgetD        = CmdGet.Flag.Bool(\"d\", false, \"\")\n+\tgetF        = CmdGet.Flag.Bool(\"f\", false, \"\")\n+\tgetFix      = CmdGet.Flag.Bool(\"fix\", false, \"\")\n+\tgetM        = CmdGet.Flag.Bool(\"m\", false, \"\")\n+\tgetT        = CmdGet.Flag.Bool(\"t\", false, \"\")\n+\tgetU        upgradeFlag\n+\tgetInsecure = CmdGet.Flag.Bool(\"insecure\", false, \"\")\n \t// -v is cfg.BuildV\n )\n \n@@ -264,7 +255,6 @@ func (v *upgradeFlag) String() string { return \"\" }\n func init() {\n \twork.AddBuildFlags(CmdGet, work.OmitModFlag)\n \tCmdGet.Run = runGet // break init loop\n-\tCmdGet.Flag.BoolVar(&cfg.Insecure, \"insecure\", cfg.Insecure, \"\")\n \tCmdGet.Flag.Var(&getU, \"u\", \"\")\n }\n \n@@ -284,10 +274,9 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \tif *getM {\n \t\tbase.Fatalf(\"go get: -m flag is no longer supported; consider -d to skip building packages\")\n \t}\n-\tif cfg.Insecure {\n-\t\tfmt.Fprintf(os.Stderr, \"go get: -insecure flag is deprecated; see 'go help get' for details\\n\")\n+\tif *getInsecure {\n+\t\tbase.Fatalf(\"go get: -insecure flag is no longer supported; use GOINSECURE instead\")\n \t}\n-\tload.ModResolveTests = *getT\n \n \t// Do not allow any updating of go.mod until we've applied\n \t// all the requested changes and checked that the result matches\n@@ -298,8 +287,6 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t// 'go get' is expected to do this, unlike other commands.\n \tmodload.AllowMissingModuleImports()\n \n-\tmodload.LoadModFile(ctx) // Initializes modload.Target.\n-\n \tqueries := parseArgs(ctx, args)\n \n \tr := newResolver(ctx, queries)\n@@ -310,7 +297,7 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t\tr.performWildcardQueries(ctx)\n \t\tr.performPatternAllQueries(ctx)\n \n-\t\tif changed := r.resolveCandidates(ctx, queries, nil); changed {\n+\t\tif changed := r.resolveQueries(ctx, queries); changed {\n \t\t\t// 'go get' arguments can be (and often are) package patterns rather than\n \t\t\t// (just) modules. A package can be provided by any module with a prefix\n \t\t\t// of its import path, and a wildcard can even match packages in modules\n@@ -347,12 +334,12 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t\t// - ambiguous import errors.\n \t\t//   TODO(#27899): Try to resolve ambiguous import errors automatically.\n \t\tupgrades := r.findAndUpgradeImports(ctx, queries)\n-\t\tif changed := r.resolveCandidates(ctx, nil, upgrades); changed {\n+\t\tif changed := r.applyUpgrades(ctx, upgrades); changed {\n \t\t\tcontinue\n \t\t}\n \n \t\tr.findMissingWildcards(ctx)\n-\t\tif changed := r.resolveCandidates(ctx, r.wildcardQueries, nil); changed {\n+\t\tif changed := r.resolveQueries(ctx, r.wildcardQueries); changed {\n \t\t\tcontinue\n \t\t}\n \n@@ -367,7 +354,7 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tpkgPatterns = append(pkgPatterns, q.pattern)\n \t\t}\n \t}\n-\tr.checkPackagesAndRetractions(ctx, pkgPatterns)\n+\tr.checkPackageProblems(ctx, pkgPatterns)\n \n \t// We've already downloaded modules (and identified direct and indirect\n \t// dependencies) by loading packages in findAndUpgradeImports.\n@@ -380,12 +367,51 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \t// directory.\n \tif !*getD && len(pkgPatterns) > 0 {\n \t\twork.BuildInit()\n-\t\tpkgs := load.PackagesAndErrors(ctx, pkgPatterns)\n+\n+\t\tpkgOpts := load.PackageOpts{ModResolveTests: *getT}\n+\t\tvar pkgs []*load.Package\n+\t\tfor _, pkg := range load.PackagesAndErrors(ctx, pkgOpts, pkgPatterns) {\n+\t\t\tif pkg.Error != nil {\n+\t\t\t\tvar noGo *load.NoGoError\n+\t\t\t\tif errors.As(pkg.Error.Err, &noGo) {\n+\t\t\t\t\tif m := modload.PackageModule(pkg.ImportPath); m.Path == pkg.ImportPath {\n+\t\t\t\t\t\t// pkg is at the root of a module, and doesn't exist with the current\n+\t\t\t\t\t\t// build tags. Probably the user just wanted to change the version of\n+\t\t\t\t\t\t// that module \u2014 not also build the package \u2014 so suppress the error.\n+\t\t\t\t\t\t// (See https://golang.org/issue/33526.)\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tpkgs = append(pkgs, pkg)\n+\t\t}\n \t\tload.CheckPackageErrors(pkgs)\n+\n+\t\thaveExternalExe := false\n+\t\tfor _, pkg := range pkgs {\n+\t\t\tif pkg.Name == \"main\" && pkg.Module != nil && pkg.Module.Path != modload.Target.Path {\n+\t\t\t\thaveExternalExe = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif haveExternalExe {\n+\t\t\tfmt.Fprint(os.Stderr, \"go get: installing executables with 'go get' in module mode is deprecated.\")\n+\t\t\tvar altMsg string\n+\t\t\tif modload.HasModRoot() {\n+\t\t\t\taltMsg = `\n+\tTo adjust and download dependencies of the current module, use 'go get -d'.\n+\tTo install using requirements of the current module, use 'go install'.\n+\tTo install ignoring the current module, use 'go install' with a version,\n+\tlike 'go install example.com/cmd@latest'.\n+`\n+\t\t\t} else {\n+\t\t\t\taltMsg = \"\\n\\tUse 'go install pkg@version' instead.\\n\"\n+\t\t\t}\n+\t\t\tfmt.Fprint(os.Stderr, altMsg)\n+\t\t\tfmt.Fprintf(os.Stderr, \"\\tFor more information, see https://golang.org/doc/go-get-install-deprecation\\n\\tor run 'go help get' or 'go help install'.\\n\")\n+\t\t}\n+\n \t\twork.InstallPackages(ctx, pkgPatterns, pkgs)\n-\t\t// TODO(#40276): After Go 1.16, print a deprecation notice when building and\n-\t\t// installing main packages. 'go install pkg' or 'go install pkg@version'\n-\t\t// should be used instead. Give the specific argument to use if possible.\n \t}\n \n \tif !modload.HasModRoot() {\n@@ -396,7 +422,7 @@ func runGet(ctx context.Context, cmd *base.Command, args []string) {\n \toldReqs := reqsFromGoMod(modload.ModFile())\n \n \tmodload.AllowWriteGoMod()\n-\tmodload.WriteGoMod()\n+\tmodload.WriteGoMod(ctx)\n \tmodload.DisallowWriteGoMod()\n \n \tnewReqs := reqsFromGoMod(modload.ModFile())\n@@ -460,9 +486,8 @@ type resolver struct {\n \t// that resolved the module to that version (the \u201creason\u201d).\n \tresolvedVersion map[string]versionReason\n \n-\tbuildList                 []module.Version\n-\tbuildListResolvedVersions int               // len(resolvedVersion) when buildList was computed\n-\tbuildListVersion          map[string]string // index of buildList (module path \u2192 version)\n+\tbuildList        []module.Version\n+\tbuildListVersion map[string]string // index of buildList (module path \u2192 version)\n \n \tinitialVersion map[string]string // index of the initial build list at the start of 'go get'\n \n@@ -479,7 +504,12 @@ type versionReason struct {\n }\n \n func newResolver(ctx context.Context, queries []*query) *resolver {\n-\tbuildList := modload.LoadAllModules(ctx)\n+\t// LoadModGraph also sets modload.Target, which is needed by various resolver\n+\t// methods.\n+\tconst defaultGoVersion = \"\"\n+\tmg := modload.LoadModGraph(ctx, defaultGoVersion)\n+\n+\tbuildList := mg.BuildList()\n \tinitialVersion := make(map[string]string, len(buildList))\n \tfor _, m := range buildList {\n \t\tinitialVersion[m.Path] = m.Version\n@@ -688,7 +718,7 @@ func (r *resolver) performLocalQueries(ctx context.Context) {\n \n \t\t\t// Absolute paths like C:\\foo and relative paths like ../foo... are\n \t\t\t// restricted to matching packages in the main module.\n-\t\t\tpkgPattern := modload.DirImportPath(q.pattern)\n+\t\t\tpkgPattern := modload.DirImportPath(ctx, q.pattern)\n \t\t\tif pkgPattern == \".\" {\n \t\t\t\treturn errSet(fmt.Errorf(\"%s%s is not within module rooted at %s\", q.pattern, absDetail, modload.ModRoot()))\n \t\t\t}\n@@ -1121,9 +1151,11 @@ func (r *resolver) findAndUpgradeImports(ctx context.Context, queries []*query)\n // build list.\n func (r *resolver) loadPackages(ctx context.Context, patterns []string, findPackage func(ctx context.Context, path string, m module.Version) (versionOk bool)) {\n \topts := modload.PackageOpts{\n-\t\tTags:          imports.AnyTags(),\n-\t\tLoadTests:     *getT,\n-\t\tSilenceErrors: true, // May be fixed by subsequent upgrades or downgrades.\n+\t\tTags:                     imports.AnyTags(),\n+\t\tVendorModulesInGOROOTSrc: true,\n+\t\tLoadTests:                *getT,\n+\t\tAssumeRootsImported:      true, // After 'go get foo', imports of foo should build.\n+\t\tSilencePackageErrors:     true, // May be fixed by subsequent upgrades or downgrades.\n \t}\n \n \topts.AllowPackage = func(ctx context.Context, path string, m module.Version) error {\n@@ -1176,24 +1208,19 @@ func (r *resolver) loadPackages(ctx context.Context, patterns []string, findPack\n // to be updated before its dependencies can be loaded.\n var errVersionChange = errors.New(\"version change needed\")\n \n-// resolveCandidates resolves candidates sets that are attached to the given\n+// resolveQueries resolves candidate sets that are attached to the given\n // queries and/or needed to provide the given missing-package dependencies.\n //\n-// resolveCandidates starts by resolving one module version from each\n+// resolveQueries starts by resolving one module version from each\n // unambiguous pathSet attached to the given queries.\n //\n // If no unambiguous query results in a change to the build list,\n-// resolveCandidates modifies the build list by adding one module version from\n-// each pathSet in missing, but does not mark those versions as resolved\n-// (so they can still be modified by other queries).\n-//\n-// If that still does not result in any changes to the build list,\n-// resolveCandidates revisits the ambiguous query candidates and resolves them\n+// resolveQueries revisits the ambiguous query candidates and resolves them\n // arbitrarily in order to guarantee forward progress.\n //\n // If all pathSets are resolved without any changes to the build list,\n-// resolveCandidates returns with changed=false.\n-func (r *resolver) resolveCandidates(ctx context.Context, queries []*query, upgrades []pathSet) (changed bool) {\n+// resolveQueries returns with changed=false.\n+func (r *resolver) resolveQueries(ctx context.Context, queries []*query) (changed bool) {\n \tdefer base.ExitIfErrors()\n \n \t// Note: this is O(N\u00b2) with the number of pathSets in the worst case.\n@@ -1247,12 +1274,52 @@ func (r *resolver) resolveCandidates(ctx context.Context, queries []*query, upgr\n \t\t}\n \t}\n \n-\tif changed := r.updateBuildList(ctx, nil); changed {\n-\t\t// The build list has changed, so disregard any missing packages: they might\n-\t\t// now be determined by requirements in the build list, which we would\n-\t\t// prefer to use instead of arbitrary \"latest\" versions.\n-\t\treturn true\n+\tif resolved > 0 {\n+\t\tif changed = r.updateBuildList(ctx, nil); changed {\n+\t\t\t// The build list has changed, so disregard any remaining ambiguous queries:\n+\t\t\t// they might now be determined by requirements in the build list, which we\n+\t\t\t// would prefer to use instead of arbitrary versions.\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\t// The build list will be the same on the next iteration as it was on this\n+\t// iteration, so any ambiguous queries will remain so. In order to make\n+\t// progress, resolve them arbitrarily but deterministically.\n+\t//\n+\t// If that results in conflicting versions, the user can re-run 'go get'\n+\t// with additional explicit versions for the conflicting packages or\n+\t// modules.\n+\tresolvedArbitrarily := 0\n+\tfor _, q := range queries {\n+\t\tfor _, cs := range q.candidates {\n+\t\t\tisPackage, m := r.chooseArbitrarily(cs)\n+\t\t\tif isPackage {\n+\t\t\t\tq.matchesPackages = true\n+\t\t\t}\n+\t\t\tr.resolve(q, m)\n+\t\t\tresolvedArbitrarily++\n+\t\t}\n \t}\n+\tif resolvedArbitrarily > 0 {\n+\t\tchanged = r.updateBuildList(ctx, nil)\n+\t}\n+\treturn changed\n+}\n+\n+// applyUpgrades disambiguates candidate sets that are needed to upgrade (or\n+// provide) transitive dependencies imported by previously-resolved packages.\n+//\n+// applyUpgrades modifies the build list by adding one module version from each\n+// pathSet in upgrades, then downgrading (or further upgrading) those modules as\n+// needed to maintain any already-resolved versions of other modules.\n+// applyUpgrades does not mark the new versions as resolved, so they can still\n+// be further modified by other queries (such as wildcards).\n+//\n+// If all pathSets are resolved without any changes to the build list,\n+// applyUpgrades returns with changed=false.\n+func (r *resolver) applyUpgrades(ctx context.Context, upgrades []pathSet) (changed bool) {\n+\tdefer base.ExitIfErrors()\n \n \t// Arbitrarily add a \"latest\" version that provides each missing package, but\n \t// do not mark the version as resolved: we still want to allow the explicit\n@@ -1276,27 +1343,9 @@ func (r *resolver) resolveCandidates(ctx context.Context, queries []*query, upgr\n \t\ttentative = append(tentative, m)\n \t}\n \tbase.ExitIfErrors()\n-\tif changed := r.updateBuildList(ctx, tentative); changed {\n-\t\treturn true\n-\t}\n \n-\t// The build list will be the same on the next iteration as it was on this\n-\t// iteration, so any ambiguous queries will remain so. In order to make\n-\t// progress, resolve them arbitrarily but deterministically.\n-\t//\n-\t// If that results in conflicting versions, the user can re-run 'go get'\n-\t// with additional explicit versions for the conflicting packages or\n-\t// modules.\n-\tfor _, q := range queries {\n-\t\tfor _, cs := range q.candidates {\n-\t\t\tisPackage, m := r.chooseArbitrarily(cs)\n-\t\t\tif isPackage {\n-\t\t\t\tq.matchesPackages = true\n-\t\t\t}\n-\t\t\tr.resolve(q, m)\n-\t\t}\n-\t}\n-\treturn r.updateBuildList(ctx, nil)\n+\tchanged = r.updateBuildList(ctx, tentative)\n+\treturn changed\n }\n \n // disambiguate eliminates candidates from cs that conflict with other module\n@@ -1417,35 +1466,45 @@ func (r *resolver) chooseArbitrarily(cs pathSet) (isPackage bool, m module.Versi\n \treturn false, cs.mod\n }\n \n-// checkPackagesAndRetractions reloads packages for the given patterns and\n-// reports missing and ambiguous package errors. It also reports loads and\n-// reports retractions for resolved modules and modules needed to build\n-// named packages.\n+// checkPackageProblems reloads packages for the given patterns and reports\n+// missing and ambiguous package errors. It also reports retractions and\n+// deprecations for resolved modules and modules needed to build named packages.\n+// It also adds a sum for each updated module in the build list if we had one\n+// before and didn't get one while loading packages.\n //\n // We skip missing-package errors earlier in the process, since we want to\n // resolve pathSets ourselves, but at that point, we don't have enough context\n // to log the package-import chains leading to each error.\n-func (r *resolver) checkPackagesAndRetractions(ctx context.Context, pkgPatterns []string) {\n+func (r *resolver) checkPackageProblems(ctx context.Context, pkgPatterns []string) {\n \tdefer base.ExitIfErrors()\n \n-\t// Build a list of modules to load retractions for. Start with versions\n-\t// selected based on command line queries.\n-\t//\n-\t// This is a subset of the build list. If the main module has a lot of\n-\t// dependencies, loading retractions for the entire build list would be slow.\n-\trelevantMods := make(map[module.Version]struct{})\n+\t// Gather information about modules we might want to load retractions and\n+\t// deprecations for. Loading this metadata requires at least one version\n+\t// lookup per module, and we don't want to load information that's neither\n+\t// relevant nor actionable.\n+\ttype modFlags int\n+\tconst (\n+\t\tresolved modFlags = 1 << iota // version resolved by 'go get'\n+\t\tnamed                         // explicitly named on command line or provides a named package\n+\t\thasPkg                        // needed to build named packages\n+\t\tdirect                        // provides a direct dependency of the main module\n+\t)\n+\trelevantMods := make(map[module.Version]modFlags)\n \tfor path, reason := range r.resolvedVersion {\n-\t\trelevantMods[module.Version{Path: path, Version: reason.version}] = struct{}{}\n+\t\tm := module.Version{Path: path, Version: reason.version}\n+\t\trelevantMods[m] |= resolved\n \t}\n \n \t// Reload packages, reporting errors for missing and ambiguous imports.\n \tif len(pkgPatterns) > 0 {\n \t\t// LoadPackages will print errors (since it has more context) but will not\n \t\t// exit, since we need to load retractions later.\n \t\tpkgOpts := modload.PackageOpts{\n-\t\t\tLoadTests:             *getT,\n-\t\t\tResolveMissingImports: false,\n-\t\t\tAllowErrors:           true,\n+\t\t\tVendorModulesInGOROOTSrc: true,\n+\t\t\tLoadTests:                *getT,\n+\t\t\tResolveMissingImports:    false,\n+\t\t\tAllowErrors:              true,\n+\t\t\tSilenceNoGoErrors:        true,\n \t\t}\n \t\tmatches, pkgs := modload.LoadPackages(ctx, pkgOpts, pkgPatterns...)\n \t\tfor _, m := range matches {\n@@ -1461,53 +1520,141 @@ func (r *resolver) checkPackagesAndRetractions(ctx context.Context, pkgPatterns\n \t\t\t\t\t// associated with either the package or its test \u2014 ErrNoGo must\n \t\t\t\t\t// indicate that none of those source files happen to apply in this\n \t\t\t\t\t// configuration. If we are actually building the package (no -d\n-\t\t\t\t\t// flag), the compiler will report the problem; otherwise, assume that\n-\t\t\t\t\t// the user is going to build or test it in some other configuration\n-\t\t\t\t\t// and suppress the error.\n+\t\t\t\t\t// flag), we will report the problem then; otherwise, assume that the\n+\t\t\t\t\t// user is going to build or test this package in some other\n+\t\t\t\t\t// configuration and suppress the error.\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \n \t\t\t\tbase.SetExitStatus(1)\n \t\t\t\tif ambiguousErr := (*modload.AmbiguousImportError)(nil); errors.As(err, &ambiguousErr) {\n \t\t\t\t\tfor _, m := range ambiguousErr.Modules {\n-\t\t\t\t\t\trelevantMods[m] = struct{}{}\n+\t\t\t\t\t\trelevantMods[m] |= hasPkg\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif m := modload.PackageModule(pkg); m.Path != \"\" {\n-\t\t\t\trelevantMods[m] = struct{}{}\n+\t\t\t\trelevantMods[m] |= hasPkg\n+\t\t\t}\n+\t\t}\n+\t\tfor _, match := range matches {\n+\t\t\tfor _, pkg := range match.Pkgs {\n+\t\t\t\tm := modload.PackageModule(pkg)\n+\t\t\t\trelevantMods[m] |= named\n \t\t\t}\n \t\t}\n \t}\n \n-\t// Load and report retractions.\n-\ttype retraction struct {\n-\t\tm   module.Version\n-\t\terr error\n-\t}\n-\tretractions := make([]retraction, 0, len(relevantMods))\n+\treqs := modload.LoadModFile(ctx)\n \tfor m := range relevantMods {\n-\t\tretractions = append(retractions, retraction{m: m})\n+\t\tif reqs.IsDirect(m.Path) {\n+\t\t\trelevantMods[m] |= direct\n+\t\t}\n \t}\n-\tsort.Slice(retractions, func(i, j int) bool {\n-\t\treturn retractions[i].m.Path < retractions[j].m.Path\n-\t})\n-\tfor i := 0; i < len(retractions); i++ {\n+\n+\t// Load retractions for modules mentioned on the command line and modules\n+\t// needed to build named packages. We care about retractions of indirect\n+\t// dependencies, since we might be able to upgrade away from them.\n+\ttype modMessage struct {\n+\t\tm       module.Version\n+\t\tmessage string\n+\t}\n+\tretractions := make([]modMessage, 0, len(relevantMods))\n+\tfor m, flags := range relevantMods {\n+\t\tif flags&(resolved|named|hasPkg) != 0 {\n+\t\t\tretractions = append(retractions, modMessage{m: m})\n+\t\t}\n+\t}\n+\tsort.Slice(retractions, func(i, j int) bool { return retractions[i].m.Path < retractions[j].m.Path })\n+\tfor i := range retractions {\n \t\ti := i\n \t\tr.work.Add(func() {\n \t\t\terr := modload.CheckRetractions(ctx, retractions[i].m)\n \t\t\tif retractErr := (*modload.ModuleRetractedError)(nil); errors.As(err, &retractErr) {\n-\t\t\t\tretractions[i].err = err\n+\t\t\t\tretractions[i].message = err.Error()\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\t// Load deprecations for modules mentioned on the command line. Only load\n+\t// deprecations for indirect dependencies if they're also direct dependencies\n+\t// of the main module. Deprecations of purely indirect dependencies are\n+\t// not actionable.\n+\tdeprecations := make([]modMessage, 0, len(relevantMods))\n+\tfor m, flags := range relevantMods {\n+\t\tif flags&(resolved|named) != 0 || flags&(hasPkg|direct) == hasPkg|direct {\n+\t\t\tdeprecations = append(deprecations, modMessage{m: m})\n+\t\t}\n+\t}\n+\tsort.Slice(deprecations, func(i, j int) bool { return deprecations[i].m.Path < deprecations[j].m.Path })\n+\tfor i := range deprecations {\n+\t\ti := i\n+\t\tr.work.Add(func() {\n+\t\t\tdeprecation, err := modload.CheckDeprecation(ctx, deprecations[i].m)\n+\t\t\tif err != nil || deprecation == \"\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdeprecations[i].message = modload.ShortMessage(deprecation, \"\")\n+\t\t})\n+\t}\n+\n+\t// Load sums for updated modules that had sums before. When we update a\n+\t// module, we may update another module in the build list that provides a\n+\t// package in 'all' that wasn't loaded as part of this 'go get' command.\n+\t// If we don't add a sum for that module, builds may fail later.\n+\t// Note that an incidentally updated package could still import packages\n+\t// from unknown modules or from modules in the build list that we didn't\n+\t// need previously. We can't handle that case without loading 'all'.\n+\tsumErrs := make([]error, len(r.buildList))\n+\tfor i := range r.buildList {\n+\t\ti := i\n+\t\tm := r.buildList[i]\n+\t\tmActual := m\n+\t\tif mRepl := modload.Replacement(m); mRepl.Path != \"\" {\n+\t\t\tmActual = mRepl\n+\t\t}\n+\t\told := module.Version{Path: m.Path, Version: r.initialVersion[m.Path]}\n+\t\tif old.Version == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\toldActual := old\n+\t\tif oldRepl := modload.Replacement(old); oldRepl.Path != \"\" {\n+\t\t\toldActual = oldRepl\n+\t\t}\n+\t\tif mActual == oldActual || mActual.Version == \"\" || !modfetch.HaveSum(oldActual) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr.work.Add(func() {\n+\t\t\tif _, err := modfetch.DownloadZip(ctx, mActual); err != nil {\n+\t\t\t\tverb := \"upgraded\"\n+\t\t\t\tif semver.Compare(m.Version, old.Version) < 0 {\n+\t\t\t\t\tverb = \"downgraded\"\n+\t\t\t\t}\n+\t\t\t\treplaced := \"\"\n+\t\t\t\tif mActual != m {\n+\t\t\t\t\treplaced = fmt.Sprintf(\" (replaced by %s)\", mActual)\n+\t\t\t\t}\n+\t\t\t\terr = fmt.Errorf(\"%s %s %s => %s%s: error finding sum for %s: %v\", verb, m.Path, old.Version, m.Version, replaced, mActual, err)\n+\t\t\t\tsumErrs[i] = err\n \t\t\t}\n \t\t})\n \t}\n+\n \t<-r.work.Idle()\n+\n+\t// Report deprecations, then retractions, then errors fetching sums.\n+\t// Only errors fetching sums are hard errors.\n+\tfor _, mm := range deprecations {\n+\t\tif mm.message != \"\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: module %s is deprecated: %s\\n\", mm.m.Path, mm.message)\n+\t\t}\n+\t}\n \tvar retractPath string\n-\tfor _, r := range retractions {\n-\t\tif r.err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %v\\n\", r.err)\n+\tfor _, mm := range retractions {\n+\t\tif mm.message != \"\" {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %v\\n\", mm.message)\n \t\t\tif retractPath == \"\" {\n-\t\t\t\tretractPath = r.m.Path\n+\t\t\t\tretractPath = mm.m.Path\n \t\t\t} else {\n \t\t\t\tretractPath = \"<module>\"\n \t\t\t}\n@@ -1516,6 +1663,12 @@ func (r *resolver) checkPackagesAndRetractions(ctx context.Context, pkgPatterns\n \tif retractPath != \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"go: to switch to the latest unretracted version, run:\\n\\tgo get %s@latest\\n\", retractPath)\n \t}\n+\tfor _, err := range sumErrs {\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"go: %v\", err)\n+\t\t}\n+\t}\n+\tbase.ExitIfErrors()\n }\n \n // reportChanges logs version changes to os.Stderr.\n@@ -1614,11 +1767,10 @@ func (r *resolver) resolve(q *query, m module.Version) {\n //\n // If the additional modules conflict with the resolved versions, they will be\n // downgraded to a non-conflicting version (possibly \"none\").\n+//\n+// If the resulting build list is the same as the one resulting from the last\n+// call to updateBuildList, updateBuildList returns with changed=false.\n func (r *resolver) updateBuildList(ctx context.Context, additions []module.Version) (changed bool) {\n-\tif len(additions) == 0 && len(r.resolvedVersion) == r.buildListResolvedVersions {\n-\t\treturn false\n-\t}\n-\n \tdefer base.ExitIfErrors()\n \n \tresolved := make([]module.Version, 0, len(r.resolvedVersion))\n@@ -1628,7 +1780,8 @@ func (r *resolver) updateBuildList(ctx context.Context, additions []module.Versi\n \t\t}\n \t}\n \n-\tif err := modload.EditBuildList(ctx, additions, resolved); err != nil {\n+\tchanged, err := modload.EditBuildList(ctx, additions, resolved)\n+\tif err != nil {\n \t\tvar constraint *modload.ConstraintError\n \t\tif !errors.As(err, &constraint) {\n \t\t\tbase.Errorf(\"go get: %v\", err)\n@@ -1647,13 +1800,12 @@ func (r *resolver) updateBuildList(ctx context.Context, additions []module.Versi\n \t\t}\n \t\treturn false\n \t}\n-\n-\tbuildList := modload.LoadAllModules(ctx)\n-\tr.buildListResolvedVersions = len(r.resolvedVersion)\n-\tif reflect.DeepEqual(r.buildList, buildList) {\n+\tif !changed {\n \t\treturn false\n \t}\n-\tr.buildList = buildList\n+\n+\tconst defaultGoVersion = \"\"\n+\tr.buildList = modload.LoadModGraph(ctx, defaultGoVersion).BuildList()\n \tr.buildListVersion = make(map[string]string, len(r.buildList))\n \tfor _, m := range r.buildList {\n \t\tr.buildListVersion[m.Path] = m.Version"}, {"sha": "19088352f058baa93bce316dd462b6b37dd9089d", "filename": "libgo/go/cmd/go/internal/modinfo/info.go", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,19 +10,20 @@ import \"time\"\n // and the fields are documented in the help text in ../list/list.go\n \n type ModulePublic struct {\n-\tPath      string        `json:\",omitempty\"` // module path\n-\tVersion   string        `json:\",omitempty\"` // module version\n-\tVersions  []string      `json:\",omitempty\"` // available module versions\n-\tReplace   *ModulePublic `json:\",omitempty\"` // replaced by this module\n-\tTime      *time.Time    `json:\",omitempty\"` // time version was created\n-\tUpdate    *ModulePublic `json:\",omitempty\"` // available update (with -u)\n-\tMain      bool          `json:\",omitempty\"` // is this the main module?\n-\tIndirect  bool          `json:\",omitempty\"` // module is only indirectly needed by main module\n-\tDir       string        `json:\",omitempty\"` // directory holding local copy of files, if any\n-\tGoMod     string        `json:\",omitempty\"` // path to go.mod file describing module, if any\n-\tGoVersion string        `json:\",omitempty\"` // go version used in module\n-\tRetracted []string      `json:\",omitempty\"` // retraction information, if any (with -retracted or -u)\n-\tError     *ModuleError  `json:\",omitempty\"` // error loading module\n+\tPath       string        `json:\",omitempty\"` // module path\n+\tVersion    string        `json:\",omitempty\"` // module version\n+\tVersions   []string      `json:\",omitempty\"` // available module versions\n+\tReplace    *ModulePublic `json:\",omitempty\"` // replaced by this module\n+\tTime       *time.Time    `json:\",omitempty\"` // time version was created\n+\tUpdate     *ModulePublic `json:\",omitempty\"` // available update (with -u)\n+\tMain       bool          `json:\",omitempty\"` // is this the main module?\n+\tIndirect   bool          `json:\",omitempty\"` // module is only indirectly needed by main module\n+\tDir        string        `json:\",omitempty\"` // directory holding local copy of files, if any\n+\tGoMod      string        `json:\",omitempty\"` // path to go.mod file describing module, if any\n+\tGoVersion  string        `json:\",omitempty\"` // go version used in module\n+\tRetracted  []string      `json:\",omitempty\"` // retraction information, if any (with -retracted or -u)\n+\tDeprecated string        `json:\",omitempty\"` // deprecation message, if any (with -u)\n+\tError      *ModuleError  `json:\",omitempty\"` // error loading module\n }\n \n type ModuleError struct {\n@@ -45,6 +46,9 @@ func (m *ModulePublic) String() string {\n \t\t\ts += \" [\" + versionString(m.Update) + \"]\"\n \t\t}\n \t}\n+\tif m.Deprecated != \"\" {\n+\t\ts += \" (deprecated)\"\n+\t}\n \tif m.Replace != nil {\n \t\ts += \" => \" + m.Replace.Path\n \t\tif m.Replace.Version != \"\" {\n@@ -53,6 +57,9 @@ func (m *ModulePublic) String() string {\n \t\t\t\ts += \" [\" + versionString(m.Replace.Update) + \"]\"\n \t\t\t}\n \t\t}\n+\t\tif m.Replace.Deprecated != \"\" {\n+\t\t\ts += \" (deprecated)\"\n+\t\t}\n \t}\n \treturn s\n }"}, {"sha": "becf6b87f800543bf36ddaba4717af3b00c26334", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 140, "deletions": 51, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"internal/goroot\"\n+\t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n@@ -50,44 +51,56 @@ func findStandardImportPath(path string) string {\n // a given package. If modules are not enabled or if the package is in the\n // standard library or if the package was not successfully loaded with\n // LoadPackages or ImportFromFiles, nil is returned.\n-func PackageModuleInfo(pkgpath string) *modinfo.ModulePublic {\n+func PackageModuleInfo(ctx context.Context, pkgpath string) *modinfo.ModulePublic {\n \tif isStandardImportPath(pkgpath) || !Enabled() {\n \t\treturn nil\n \t}\n-\tm, ok := findModule(pkgpath)\n+\tm, ok := findModule(loaded, pkgpath)\n \tif !ok {\n \t\treturn nil\n \t}\n-\tfromBuildList := true\n-\tlistRetracted := false\n-\treturn moduleInfo(context.TODO(), m, fromBuildList, listRetracted)\n+\n+\trs := LoadModFile(ctx)\n+\treturn moduleInfo(ctx, rs, m, 0)\n }\n \n func ModuleInfo(ctx context.Context, path string) *modinfo.ModulePublic {\n \tif !Enabled() {\n \t\treturn nil\n \t}\n \n-\tlistRetracted := false\n \tif i := strings.Index(path, \"@\"); i >= 0 {\n \t\tm := module.Version{Path: path[:i], Version: path[i+1:]}\n-\t\tfromBuildList := false\n-\t\treturn moduleInfo(ctx, m, fromBuildList, listRetracted)\n+\t\treturn moduleInfo(ctx, nil, m, 0)\n \t}\n \n-\tfor _, m := range buildList {\n-\t\tif m.Path == path {\n-\t\t\tfromBuildList := true\n-\t\t\treturn moduleInfo(ctx, m, fromBuildList, listRetracted)\n+\trs := LoadModFile(ctx)\n+\n+\tvar (\n+\t\tv  string\n+\t\tok bool\n+\t)\n+\tif rs.depth == lazy {\n+\t\tv, ok = rs.rootSelected(path)\n+\t}\n+\tif !ok {\n+\t\tmg, err := rs.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n+\t\tv = mg.Selected(path)\n \t}\n \n-\treturn &modinfo.ModulePublic{\n-\t\tPath: path,\n-\t\tError: &modinfo.ModuleError{\n-\t\t\tErr: \"module not in current build\",\n-\t\t},\n+\tif v == \"none\" {\n+\t\treturn &modinfo.ModulePublic{\n+\t\t\tPath: path,\n+\t\t\tError: &modinfo.ModuleError{\n+\t\t\t\tErr: \"module not in current build\",\n+\t\t\t},\n+\t\t}\n \t}\n+\n+\treturn moduleInfo(ctx, rs, module.Version{Path: path, Version: v}, 0)\n }\n \n // addUpdate fills in m.Update if an updated version is available.\n@@ -96,7 +109,26 @@ func addUpdate(ctx context.Context, m *modinfo.ModulePublic) {\n \t\treturn\n \t}\n \n-\tif info, err := Query(ctx, m.Path, \"upgrade\", m.Version, CheckAllowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n+\tinfo, err := Query(ctx, m.Path, \"upgrade\", m.Version, CheckAllowed)\n+\tvar noVersionErr *NoMatchingVersionError\n+\tif errors.Is(err, fs.ErrNotExist) || errors.As(err, &noVersionErr) {\n+\t\t// Ignore \"not found\" and \"no matching version\" errors.\n+\t\t// This means the proxy has no matching version or no versions at all.\n+\t\t//\n+\t\t// We should report other errors though. An attacker that controls the\n+\t\t// network shouldn't be able to hide versions by interfering with\n+\t\t// the HTTPS connection. An attacker that controls the proxy may still\n+\t\t// hide versions, since the \"list\" and \"latest\" endpoints are not\n+\t\t// authenticated.\n+\t\treturn\n+\t} else if err != nil {\n+\t\tif m.Error == nil {\n+\t\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif semver.Compare(info.Version, m.Version) > 0 {\n \t\tm.Update = &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n \t\t\tVersion: info.Version,\n@@ -113,7 +145,11 @@ func addVersions(ctx context.Context, m *modinfo.ModulePublic, listRetracted boo\n \tif listRetracted {\n \t\tallowed = CheckExclusions\n \t}\n-\tm.Versions, _ = versions(ctx, m.Path, allowed)\n+\tvar err error\n+\tm.Versions, err = versions(ctx, m.Path, allowed)\n+\tif err != nil && m.Error == nil {\n+\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n+\t}\n }\n \n // addRetraction fills in m.Retracted if the module was retracted by its author.\n@@ -124,47 +160,91 @@ func addRetraction(ctx context.Context, m *modinfo.ModulePublic) {\n \t}\n \n \terr := CheckRetractions(ctx, module.Version{Path: m.Path, Version: m.Version})\n-\tvar rerr *ModuleRetractedError\n-\tif errors.As(err, &rerr) {\n-\t\tif len(rerr.Rationale) == 0 {\n+\tvar noVersionErr *NoMatchingVersionError\n+\tvar retractErr *ModuleRetractedError\n+\tif err == nil || errors.Is(err, fs.ErrNotExist) || errors.As(err, &noVersionErr) {\n+\t\t// Ignore \"not found\" and \"no matching version\" errors.\n+\t\t// This means the proxy has no matching version or no versions at all.\n+\t\t//\n+\t\t// We should report other errors though. An attacker that controls the\n+\t\t// network shouldn't be able to hide versions by interfering with\n+\t\t// the HTTPS connection. An attacker that controls the proxy may still\n+\t\t// hide versions, since the \"list\" and \"latest\" endpoints are not\n+\t\t// authenticated.\n+\t\treturn\n+\t} else if errors.As(err, &retractErr) {\n+\t\tif len(retractErr.Rationale) == 0 {\n \t\t\tm.Retracted = []string{\"retracted by module author\"}\n \t\t} else {\n-\t\t\tm.Retracted = rerr.Rationale\n+\t\t\tm.Retracted = retractErr.Rationale\n \t\t}\n-\t} else if err != nil && m.Error == nil {\n+\t} else if m.Error == nil {\n \t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n \t}\n }\n \n-func moduleInfo(ctx context.Context, m module.Version, fromBuildList, listRetracted bool) *modinfo.ModulePublic {\n+// addDeprecation fills in m.Deprecated if the module was deprecated by its\n+// author. m.Error is set if there's an error loading deprecation information.\n+func addDeprecation(ctx context.Context, m *modinfo.ModulePublic) {\n+\tdeprecation, err := CheckDeprecation(ctx, module.Version{Path: m.Path, Version: m.Version})\n+\tvar noVersionErr *NoMatchingVersionError\n+\tif errors.Is(err, fs.ErrNotExist) || errors.As(err, &noVersionErr) {\n+\t\t// Ignore \"not found\" and \"no matching version\" errors.\n+\t\t// This means the proxy has no matching version or no versions at all.\n+\t\t//\n+\t\t// We should report other errors though. An attacker that controls the\n+\t\t// network shouldn't be able to hide versions by interfering with\n+\t\t// the HTTPS connection. An attacker that controls the proxy may still\n+\t\t// hide versions, since the \"list\" and \"latest\" endpoints are not\n+\t\t// authenticated.\n+\t\treturn\n+\t}\n+\tif err != nil {\n+\t\tif m.Error == nil {\n+\t\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n+\t\t}\n+\t\treturn\n+\t}\n+\tm.Deprecated = deprecation\n+}\n+\n+// moduleInfo returns information about module m, loaded from the requirements\n+// in rs (which may be nil to indicate that m was not loaded from a requirement\n+// graph).\n+func moduleInfo(ctx context.Context, rs *Requirements, m module.Version, mode ListMode) *modinfo.ModulePublic {\n \tif m == Target {\n \t\tinfo := &modinfo.ModulePublic{\n \t\t\tPath:    m.Path,\n \t\t\tVersion: m.Version,\n \t\t\tMain:    true,\n \t\t}\n+\t\tif v, ok := rawGoVersion.Load(Target); ok {\n+\t\t\tinfo.GoVersion = v.(string)\n+\t\t} else {\n+\t\t\tpanic(\"internal error: GoVersion not set for main module\")\n+\t\t}\n \t\tif HasModRoot() {\n \t\t\tinfo.Dir = ModRoot()\n \t\t\tinfo.GoMod = ModFilePath()\n-\t\t\tif modFile.Go != nil {\n-\t\t\t\tinfo.GoVersion = modFile.Go.Version\n-\t\t\t}\n \t\t}\n \t\treturn info\n \t}\n \n \tinfo := &modinfo.ModulePublic{\n \t\tPath:     m.Path,\n \t\tVersion:  m.Version,\n-\t\tIndirect: fromBuildList && loaded != nil && !loaded.direct[m.Path],\n+\t\tIndirect: rs != nil && !rs.direct[m.Path],\n \t}\n \tif v, ok := rawGoVersion.Load(m); ok {\n \t\tinfo.GoVersion = v.(string)\n \t}\n \n \t// completeFromModCache fills in the extra fields in m using the module cache.\n \tcompleteFromModCache := func(m *modinfo.ModulePublic) {\n-\t\tmod := module.Version{Path: m.Path, Version: m.Version}\n+\t\tchecksumOk := func(suffix string) bool {\n+\t\t\treturn rs == nil || m.Version == \"\" || cfg.BuildMod == \"mod\" ||\n+\t\t\t\tmodfetch.HaveSum(module.Version{Path: m.Path, Version: m.Version + suffix})\n+\t\t}\n \n \t\tif m.Version != \"\" {\n \t\t\tif q, err := Query(ctx, m.Path, m.Version, \"\", nil); err != nil {\n@@ -173,31 +253,40 @@ func moduleInfo(ctx context.Context, m module.Version, fromBuildList, listRetrac\n \t\t\t\tm.Version = q.Version\n \t\t\t\tm.Time = &q.Time\n \t\t\t}\n+\t\t}\n+\t\tmod := module.Version{Path: m.Path, Version: m.Version}\n+\n+\t\tif m.GoVersion == \"\" && checksumOk(\"/go.mod\") {\n+\t\t\t// Load the go.mod file to determine the Go version, since it hasn't\n+\t\t\t// already been populated from rawGoVersion.\n+\t\t\tif summary, err := rawGoModSummary(mod); err == nil && summary.goVersion != \"\" {\n+\t\t\t\tm.GoVersion = summary.goVersion\n+\t\t\t}\n+\t\t}\n \n-\t\t\tgomod, err := modfetch.CachePath(mod, \"mod\")\n-\t\t\tif err == nil {\n-\t\t\t\tif info, err := os.Stat(gomod); err == nil && info.Mode().IsRegular() {\n-\t\t\t\t\tm.GoMod = gomod\n+\t\tif m.Version != \"\" {\n+\t\t\tif checksumOk(\"/go.mod\") {\n+\t\t\t\tgomod, err := modfetch.CachePath(mod, \"mod\")\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tif info, err := os.Stat(gomod); err == nil && info.Mode().IsRegular() {\n+\t\t\t\t\t\tm.GoMod = gomod\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tdir, err := modfetch.DownloadDir(mod)\n-\t\t\tif err == nil {\n-\t\t\t\tm.Dir = dir\n+\t\t\tif checksumOk(\"\") {\n+\t\t\t\tdir, err := modfetch.DownloadDir(mod)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tm.Dir = dir\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif listRetracted {\n+\t\t\tif mode&ListRetracted != 0 {\n \t\t\t\taddRetraction(ctx, m)\n \t\t\t}\n \t\t}\n-\n-\t\tif m.GoVersion == \"\" {\n-\t\t\tif summary, err := rawGoModSummary(mod); err == nil && summary.goVersionV != \"\" {\n-\t\t\t\tm.GoVersion = summary.goVersionV[1:]\n-\t\t\t}\n-\t\t}\n \t}\n \n-\tif !fromBuildList {\n+\tif rs == nil {\n \t\t// If this was an explicitly-versioned argument to 'go mod download' or\n \t\t// 'go list -m', report the actual requested version, not its replacement.\n \t\tcompleteFromModCache(info) // Will set m.Error in vendor mode.\n@@ -255,11 +344,11 @@ func PackageBuildInfo(path string, deps []string) string {\n \t\treturn \"\"\n \t}\n \n-\ttarget := mustFindModule(path, path)\n+\ttarget := mustFindModule(loaded, path, path)\n \tmdeps := make(map[module.Version]bool)\n \tfor _, dep := range deps {\n \t\tif !isStandardImportPath(dep) {\n-\t\t\tmdeps[mustFindModule(path, dep)] = true\n+\t\t\tmdeps[mustFindModule(loaded, path, dep)] = true\n \t\t}\n \t}\n \tvar mods []module.Version\n@@ -298,8 +387,8 @@ func PackageBuildInfo(path string, deps []string) string {\n //\n // TODO(jayconrod): remove this. Callers should use findModule and return\n // errors instead of relying on base.Fatalf.\n-func mustFindModule(target, path string) module.Version {\n-\tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n+func mustFindModule(ld *loader, target, path string) module.Version {\n+\tpkg, ok := ld.pkgCache.Get(path).(*loadPkg)\n \tif ok {\n \t\tif pkg.err != nil {\n \t\t\tbase.Fatalf(\"build %v: cannot load %v: %v\", target, path, pkg.err)\n@@ -318,8 +407,8 @@ func mustFindModule(target, path string) module.Version {\n // findModule searches for the module that contains the package at path.\n // If the package was loaded, its containing module and true are returned.\n // Otherwise, module.Version{} and false are returend.\n-func findModule(path string) (module.Version, bool) {\n-\tif pkg, ok := loaded.pkgCache.Get(path).(*loadPkg); ok {\n+func findModule(ld *loader, path string) (module.Version, bool) {\n+\tif pkg, ok := ld.pkgCache.Get(path).(*loadPkg); ok {\n \t\treturn pkg.mod, pkg.mod != module.Version{}\n \t}\n \tif path == \"command-line-arguments\" {"}, {"sha": "604a57b4373b28051b0fdf0235b1e52f9051d9c3", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "modified", "additions": 990, "deletions": 196, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -7,188 +7,501 @@ package modload\n import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/mvs\"\n+\t\"cmd/go/internal/par\"\n \t\"context\"\n \t\"fmt\"\n-\t\"go/build\"\n \t\"os\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"runtime/debug\"\n \t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n \n-\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n \n-// buildList is the list of modules to use for building packages.\n-// It is initialized by calling LoadPackages or ImportFromFiles,\n-// each of which uses loaded.load.\n-//\n-// Ideally, exactly ONE of those functions would be called,\n-// and exactly once. Most of the time, that's true.\n-// During \"go get\" it may not be. TODO(rsc): Figure out if\n-// that restriction can be established, or else document why not.\n-//\n-var buildList []module.Version\n-\n-// additionalExplicitRequirements is a list of modules paths for which\n-// WriteGoMod should record explicit requirements, even if they would be\n-// selected without those requirements. Each path must also appear in buildList.\n-var additionalExplicitRequirements []string\n-\n // capVersionSlice returns s with its cap reduced to its length.\n func capVersionSlice(s []module.Version) []module.Version {\n \treturn s[:len(s):len(s)]\n }\n \n-// LoadAllModules loads and returns the list of modules matching the \"all\"\n-// module pattern, starting with the Target module and in a deterministic\n-// (stable) order, without loading any packages.\n+// A Requirements represents a logically-immutable set of root module requirements.\n+type Requirements struct {\n+\t// depth is the depth at which the requirement graph is computed.\n+\t//\n+\t// If eager, the graph includes all transitive requirements regardless of depth.\n+\t//\n+\t// If lazy, the graph includes only the root modules, the explicit\n+\t// requirements of those root modules, and the transitive requirements of only\n+\t// the *non-lazy* root modules.\n+\tdepth modDepth\n+\n+\t// rootModules is the set of module versions explicitly required by the main\n+\t// module, sorted and capped to length. It may contain duplicates, and may\n+\t// contain multiple versions for a given module path.\n+\trootModules    []module.Version\n+\tmaxRootVersion map[string]string\n+\n+\t// direct is the set of module paths for which we believe the module provides\n+\t// a package directly imported by a package or test in the main module.\n+\t//\n+\t// The \"direct\" map controls which modules are annotated with \"// indirect\"\n+\t// comments in the go.mod file, and may impact which modules are listed as\n+\t// explicit roots (vs. indirect-only dependencies). However, it should not\n+\t// have a semantic effect on the build list overall.\n+\t//\n+\t// The initial direct map is populated from the existing \"// indirect\"\n+\t// comments (or lack thereof) in the go.mod file. It is updated by the\n+\t// package loader: dependencies may be promoted to direct if new\n+\t// direct imports are observed, and may be demoted to indirect during\n+\t// 'go mod tidy' or 'go mod vendor'.\n+\t//\n+\t// The direct map is keyed by module paths, not module versions. When a\n+\t// module's selected version changes, we assume that it remains direct if the\n+\t// previous version was a direct dependency. That assumption might not hold in\n+\t// rare cases (such as if a dependency splits out a nested module, or merges a\n+\t// nested module back into a parent module).\n+\tdirect map[string]bool\n+\n+\tgraphOnce sync.Once    // guards writes to (but not reads from) graph\n+\tgraph     atomic.Value // cachedGraph\n+}\n+\n+// A cachedGraph is a non-nil *ModuleGraph, together with any error discovered\n+// while loading that graph.\n+type cachedGraph struct {\n+\tmg  *ModuleGraph\n+\terr error // If err is non-nil, mg may be incomplete (but must still be non-nil).\n+}\n+\n+// requirements is the requirement graph for the main module.\n //\n-// Modules are loaded automatically (and lazily) in LoadPackages:\n-// LoadAllModules need only be called if LoadPackages is not,\n-// typically in commands that care about modules but no particular package.\n+// It is always non-nil if the main module's go.mod file has been loaded.\n+//\n+// This variable should only be read from the loadModFile function, and should\n+// only be written in the loadModFile and commitRequirements functions.\n+// All other functions that need or produce a *Requirements should\n+// accept and/or return an explicit parameter.\n+var requirements *Requirements\n+\n+// newRequirements returns a new requirement set with the given root modules.\n+// The dependencies of the roots will be loaded lazily at the first call to the\n+// Graph method.\n //\n-// The caller must not modify the returned list, but may append to it.\n-func LoadAllModules(ctx context.Context) []module.Version {\n-\tLoadModFile(ctx)\n-\tReloadBuildList()\n-\tWriteGoMod()\n-\treturn capVersionSlice(buildList)\n+// The rootModules slice must be sorted according to module.Sort.\n+// The caller must not modify the rootModules slice or direct map after passing\n+// them to newRequirements.\n+//\n+// If vendoring is in effect, the caller must invoke initVendor on the returned\n+// *Requirements before any other method.\n+func newRequirements(depth modDepth, rootModules []module.Version, direct map[string]bool) *Requirements {\n+\tfor i, m := range rootModules {\n+\t\tif m == Target {\n+\t\t\tpanic(fmt.Sprintf(\"newRequirements called with untrimmed build list: rootModules[%v] is Target\", i))\n+\t\t}\n+\t\tif m.Path == \"\" || m.Version == \"\" {\n+\t\t\tpanic(fmt.Sprintf(\"bad requirement: rootModules[%v] = %v\", i, m))\n+\t\t}\n+\t\tif i > 0 {\n+\t\t\tprev := rootModules[i-1]\n+\t\t\tif prev.Path > m.Path || (prev.Path == m.Path && semver.Compare(prev.Version, m.Version) > 0) {\n+\t\t\t\tpanic(fmt.Sprintf(\"newRequirements called with unsorted roots: %v\", rootModules))\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\trs := &Requirements{\n+\t\tdepth:          depth,\n+\t\trootModules:    capVersionSlice(rootModules),\n+\t\tmaxRootVersion: make(map[string]string, len(rootModules)),\n+\t\tdirect:         direct,\n+\t}\n+\n+\tfor _, m := range rootModules {\n+\t\tif v, ok := rs.maxRootVersion[m.Path]; ok && cmpVersion(v, m.Version) >= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\trs.maxRootVersion[m.Path] = m.Version\n+\t}\n+\treturn rs\n }\n \n-// Selected returns the selected version of the module with the given path, or\n-// the empty string if the given module has no selected version\n-// (either because it is not required or because it is the Target module).\n-func Selected(path string) (version string) {\n+// initVendor initializes rs.graph from the given list of vendored module\n+// dependencies, overriding the graph that would normally be loaded from module\n+// requirements.\n+func (rs *Requirements) initVendor(vendorList []module.Version) {\n+\trs.graphOnce.Do(func() {\n+\t\tmg := &ModuleGraph{\n+\t\t\tg: mvs.NewGraph(cmpVersion, []module.Version{Target}),\n+\t\t}\n+\n+\t\tif rs.depth == lazy {\n+\t\t\t// The roots of a lazy module should already include every module in the\n+\t\t\t// vendor list, because the vendored modules are the same as those\n+\t\t\t// maintained as roots by the lazy loading \u201cimport invariant\u201d.\n+\t\t\t//\n+\t\t\t// Just to be sure, we'll double-check that here.\n+\t\t\tinconsistent := false\n+\t\t\tfor _, m := range vendorList {\n+\t\t\t\tif v, ok := rs.rootSelected(m.Path); !ok || v != m.Version {\n+\t\t\t\t\tbase.Errorf(\"go: vendored module %v should be required explicitly in go.mod\", m)\n+\t\t\t\t\tinconsistent = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif inconsistent {\n+\t\t\t\tbase.Fatalf(\"go: %v\", errGoModDirty)\n+\t\t\t}\n+\n+\t\t\t// Now we can treat the rest of the module graph as effectively \u201cpruned\n+\t\t\t// out\u201d, like a more aggressive version of lazy loading: in vendor mode,\n+\t\t\t// the root requirements *are* the complete module graph.\n+\t\t\tmg.g.Require(Target, rs.rootModules)\n+\t\t} else {\n+\t\t\t// The transitive requirements of the main module are not in general available\n+\t\t\t// from the vendor directory, and we don't actually know how we got from\n+\t\t\t// the roots to the final build list.\n+\t\t\t//\n+\t\t\t// Instead, we'll inject a fake \"vendor/modules.txt\" module that provides\n+\t\t\t// those transitive dependencies, and mark it as a dependency of the main\n+\t\t\t// module. That allows us to elide the actual structure of the module\n+\t\t\t// graph, but still distinguishes between direct and indirect\n+\t\t\t// dependencies.\n+\t\t\tvendorMod := module.Version{Path: \"vendor/modules.txt\", Version: \"\"}\n+\t\t\tmg.g.Require(Target, append(rs.rootModules, vendorMod))\n+\t\t\tmg.g.Require(vendorMod, vendorList)\n+\t\t}\n+\n+\t\trs.graph.Store(cachedGraph{mg, nil})\n+\t})\n+}\n+\n+// rootSelected returns the version of the root dependency with the given module\n+// path, or the zero module.Version and ok=false if the module is not a root\n+// dependency.\n+func (rs *Requirements) rootSelected(path string) (version string, ok bool) {\n \tif path == Target.Path {\n-\t\treturn \"\"\n+\t\treturn Target.Version, true\n \t}\n-\tfor _, m := range buildList {\n-\t\tif m.Path == path {\n-\t\t\treturn m.Version\n-\t\t}\n+\tif v, ok := rs.maxRootVersion[path]; ok {\n+\t\treturn v, true\n \t}\n-\treturn \"\"\n+\treturn \"\", false\n }\n \n-// EditBuildList edits the global build list by first adding every module in add\n-// to the existing build list, then adjusting versions (and adding or removing\n-// requirements as needed) until every module in mustSelect is selected at the\n-// given version.\n+// Graph returns the graph of module requirements loaded from the current\n+// root modules (as reported by RootModules).\n //\n-// (Note that the newly-added modules might not be selected in the resulting\n-// build list: they could be lower than existing requirements or conflict with\n-// versions in mustSelect.)\n+// Graph always makes a best effort to load the requirement graph despite any\n+// errors, and always returns a non-nil *ModuleGraph.\n //\n-// If the versions listed in mustSelect are mutually incompatible (due to one of\n-// the listed modules requiring a higher version of another), EditBuildList\n-// returns a *ConstraintError and leaves the build list in its previous state.\n-func EditBuildList(ctx context.Context, add, mustSelect []module.Version) error {\n-\tvar upgraded = capVersionSlice(buildList)\n-\tif len(add) > 0 {\n-\t\t// First, upgrade the build list with any additions.\n-\t\t// In theory we could just append the additions to the build list and let\n-\t\t// mvs.Downgrade take care of resolving the upgrades too, but the\n-\t\t// diagnostics from Upgrade are currently much better in case of errors.\n-\t\tvar err error\n-\t\tupgraded, err = mvs.Upgrade(Target, &mvsReqs{buildList: upgraded}, add...)\n-\t\tif err != nil {\n-\t\t\treturn err\n+// If the requirements of any relevant module fail to load, Graph also\n+// returns a non-nil error of type *mvs.BuildListError.\n+func (rs *Requirements) Graph(ctx context.Context) (*ModuleGraph, error) {\n+\trs.graphOnce.Do(func() {\n+\t\tmg, mgErr := readModGraph(ctx, rs.depth, rs.rootModules)\n+\t\trs.graph.Store(cachedGraph{mg, mgErr})\n+\t})\n+\tcached := rs.graph.Load().(cachedGraph)\n+\treturn cached.mg, cached.err\n+}\n+\n+// IsDirect returns whether the given module provides a package directly\n+// imported by a package or test in the main module.\n+func (rs *Requirements) IsDirect(path string) bool {\n+\treturn rs.direct[path]\n+}\n+\n+// A ModuleGraph represents the complete graph of module dependencies\n+// of a main module.\n+//\n+// If the main module is lazily loaded, the graph does not include\n+// transitive dependencies of non-root (implicit) dependencies.\n+type ModuleGraph struct {\n+\tg         *mvs.Graph\n+\tloadCache par.Cache // module.Version \u2192 summaryError\n+\n+\tbuildListOnce sync.Once\n+\tbuildList     []module.Version\n+}\n+\n+// A summaryError is either a non-nil modFileSummary or a non-nil error\n+// encountered while reading or parsing that summary.\n+type summaryError struct {\n+\tsummary *modFileSummary\n+\terr     error\n+}\n+\n+var readModGraphDebugOnce sync.Once\n+\n+// readModGraph reads and returns the module dependency graph starting at the\n+// given roots.\n+//\n+// Unlike LoadModGraph, readModGraph does not attempt to diagnose or update\n+// inconsistent roots.\n+func readModGraph(ctx context.Context, depth modDepth, roots []module.Version) (*ModuleGraph, error) {\n+\tif depth == lazy {\n+\t\treadModGraphDebugOnce.Do(func() {\n+\t\t\tfor _, f := range strings.Split(os.Getenv(\"GODEBUG\"), \",\") {\n+\t\t\t\tswitch f {\n+\t\t\t\tcase \"lazymod=log\":\n+\t\t\t\t\tdebug.PrintStack()\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"go: read full module graph.\\n\")\n+\t\t\t\tcase \"lazymod=strict\":\n+\t\t\t\t\tdebug.PrintStack()\n+\t\t\t\t\tbase.Fatalf(\"go: read full module graph (forbidden by GODEBUG=lazymod=strict).\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\tvar (\n+\t\tmu       sync.Mutex // guards mg.g and hasError during loading\n+\t\thasError bool\n+\t\tmg       = &ModuleGraph{\n+\t\t\tg: mvs.NewGraph(cmpVersion, []module.Version{Target}),\n \t\t}\n+\t)\n+\tmg.g.Require(Target, roots)\n+\n+\tvar (\n+\t\tloadQueue    = par.NewQueue(runtime.GOMAXPROCS(0))\n+\t\tloadingEager sync.Map // module.Version \u2192 nil; the set of modules that have been or are being loaded via eager roots\n+\t)\n+\n+\t// loadOne synchronously loads the explicit requirements for module m.\n+\t// It does not load the transitive requirements of m even if the go version in\n+\t// m's go.mod file indicates eager loading.\n+\tloadOne := func(m module.Version) (*modFileSummary, error) {\n+\t\tcached := mg.loadCache.Do(m, func() interface{} {\n+\t\t\tsummary, err := goModSummary(m)\n+\n+\t\t\tmu.Lock()\n+\t\t\tif err == nil {\n+\t\t\t\tmg.g.Require(m, summary.require)\n+\t\t\t} else {\n+\t\t\t\thasError = true\n+\t\t\t}\n+\t\t\tmu.Unlock()\n+\n+\t\t\treturn summaryError{summary, err}\n+\t\t}).(summaryError)\n+\n+\t\treturn cached.summary, cached.err\n \t}\n \n-\tdowngraded, err := mvs.Downgrade(Target, &mvsReqs{buildList: append(upgraded, mustSelect...)}, mustSelect...)\n-\tif err != nil {\n-\t\treturn err\n+\tvar enqueue func(m module.Version, depth modDepth)\n+\tenqueue = func(m module.Version, depth modDepth) {\n+\t\tif m.Version == \"none\" {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif depth == eager {\n+\t\t\tif _, dup := loadingEager.LoadOrStore(m, nil); dup {\n+\t\t\t\t// m has already been enqueued for loading. Since eager loading may\n+\t\t\t\t// follow cycles in the the requirement graph, we need to return early\n+\t\t\t\t// to avoid making the load queue infinitely long.\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\n+\t\tloadQueue.Add(func() {\n+\t\t\tsummary, err := loadOne(m)\n+\t\t\tif err != nil {\n+\t\t\t\treturn // findError will report the error later.\n+\t\t\t}\n+\n+\t\t\t// If the version in m's go.mod file implies eager loading, then we cannot\n+\t\t\t// assume that the explicit requirements of m (added by loadOne) are\n+\t\t\t// sufficient to build the packages it contains. We must load its full\n+\t\t\t// transitive dependency graph to be sure that we see all relevant\n+\t\t\t// dependencies.\n+\t\t\tif depth == eager || summary.depth == eager {\n+\t\t\t\tfor _, r := range summary.require {\n+\t\t\t\t\tenqueue(r, eager)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n \t}\n \n-\tfinal, err := mvs.Upgrade(Target, &mvsReqs{buildList: downgraded}, mustSelect...)\n-\tif err != nil {\n-\t\treturn err\n+\tfor _, m := range roots {\n+\t\tenqueue(m, depth)\n \t}\n+\t<-loadQueue.Idle()\n \n-\tselected := make(map[string]module.Version, len(final))\n-\tfor _, m := range final {\n-\t\tselected[m.Path] = m\n+\tif hasError {\n+\t\treturn mg, mg.findError()\n \t}\n-\tinconsistent := false\n-\tfor _, m := range mustSelect {\n-\t\ts, ok := selected[m.Path]\n-\t\tif !ok {\n-\t\t\tif m.Version != \"none\" {\n-\t\t\t\tpanic(fmt.Sprintf(\"internal error: mvs.BuildList lost %v\", m))\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif s.Version != m.Version {\n-\t\t\tinconsistent = true\n-\t\t\tbreak\n-\t\t}\n+\treturn mg, nil\n+}\n+\n+// RequiredBy returns the dependencies required by module m in the graph,\n+// or ok=false if module m's dependencies are not relevant (such as if they\n+// are pruned out by lazy loading).\n+//\n+// The caller must not modify the returned slice, but may safely append to it\n+// and may rely on it not to be modified.\n+func (mg *ModuleGraph) RequiredBy(m module.Version) (reqs []module.Version, ok bool) {\n+\treturn mg.g.RequiredBy(m)\n+}\n+\n+// Selected returns the selected version of the module with the given path.\n+//\n+// If no version is selected, Selected returns version \"none\".\n+func (mg *ModuleGraph) Selected(path string) (version string) {\n+\treturn mg.g.Selected(path)\n+}\n+\n+// WalkBreadthFirst invokes f once, in breadth-first order, for each module\n+// version other than \"none\" that appears in the graph, regardless of whether\n+// that version is selected.\n+func (mg *ModuleGraph) WalkBreadthFirst(f func(m module.Version)) {\n+\tmg.g.WalkBreadthFirst(f)\n+}\n+\n+// BuildList returns the selected versions of all modules present in the graph,\n+// beginning with Target.\n+//\n+// The order of the remaining elements in the list is deterministic\n+// but arbitrary.\n+//\n+// The caller must not modify the returned list, but may safely append to it\n+// and may rely on it not to be modified.\n+func (mg *ModuleGraph) BuildList() []module.Version {\n+\tmg.buildListOnce.Do(func() {\n+\t\tmg.buildList = capVersionSlice(mg.g.BuildList())\n+\t})\n+\treturn mg.buildList\n+}\n+\n+func (mg *ModuleGraph) findError() error {\n+\terrStack := mg.g.FindPath(func(m module.Version) bool {\n+\t\tcached := mg.loadCache.Get(m)\n+\t\treturn cached != nil && cached.(summaryError).err != nil\n+\t})\n+\tif len(errStack) > 0 {\n+\t\terr := mg.loadCache.Get(errStack[len(errStack)-1]).(summaryError).err\n+\t\tvar noUpgrade func(from, to module.Version) bool\n+\t\treturn mvs.NewBuildListError(err, errStack, noUpgrade)\n \t}\n \n-\tif !inconsistent {\n-\t\tbuildList = final\n-\t\tadditionalExplicitRequirements = make([]string, 0, len(mustSelect))\n-\t\tfor _, m := range mustSelect {\n-\t\t\tif m.Version != \"none\" {\n-\t\t\t\tadditionalExplicitRequirements = append(additionalExplicitRequirements, m.Path)\n-\t\t\t}\n+\treturn nil\n+}\n+\n+func (mg *ModuleGraph) allRootsSelected() bool {\n+\troots, _ := mg.g.RequiredBy(Target)\n+\tfor _, m := range roots {\n+\t\tif mg.Selected(m.Path) != m.Version {\n+\t\t\treturn false\n \t\t}\n-\t\treturn nil\n \t}\n+\treturn true\n+}\n \n-\t// We overshot one or more of the modules in mustSelected, which means that\n-\t// Downgrade removed something in mustSelect because it conflicted with\n-\t// something else in mustSelect.\n-\t//\n-\t// Walk the requirement graph to find the conflict.\n-\t//\n-\t// TODO(bcmills): Ideally, mvs.Downgrade (or a replacement for it) would do\n-\t// this directly.\n+// LoadModGraph loads and returns the graph of module dependencies of the main module,\n+// without loading any packages.\n+//\n+// If the goVersion string is non-empty, the returned graph is the graph\n+// as interpreted by the given Go version (instead of the version indicated\n+// in the go.mod file).\n+//\n+// Modules are loaded automatically (and lazily) in LoadPackages:\n+// LoadModGraph need only be called if LoadPackages is not,\n+// typically in commands that care about modules but no particular package.\n+func LoadModGraph(ctx context.Context, goVersion string) *ModuleGraph {\n+\trs := LoadModFile(ctx)\n \n-\treqs := &mvsReqs{buildList: final}\n-\treason := map[module.Version]module.Version{}\n-\tfor _, m := range mustSelect {\n-\t\treason[m] = m\n-\t}\n-\tqueue := mustSelect[:len(mustSelect):len(mustSelect)]\n-\tfor len(queue) > 0 {\n-\t\tvar m module.Version\n-\t\tm, queue = queue[0], queue[1:]\n-\t\trequired, err := reqs.Required(m)\n-\t\tif err != nil {\n-\t\t\treturn err\n+\tif goVersion != \"\" {\n+\t\tdepth := modDepthFromGoVersion(goVersion)\n+\t\tif depth == eager && rs.depth != eager {\n+\t\t\t// Use newRequirements instead of convertDepth because convertDepth\n+\t\t\t// also updates roots; here, we want to report the unmodified roots\n+\t\t\t// even though they may seem inconsistent.\n+\t\t\trs = newRequirements(eager, rs.rootModules, rs.direct)\n \t\t}\n-\t\tfor _, r := range required {\n-\t\t\tif _, ok := reason[r]; !ok {\n-\t\t\t\treason[r] = reason[m]\n-\t\t\t\tqueue = append(queue, r)\n-\t\t\t}\n+\n+\t\tmg, err := rs.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n+\t\treturn mg\n \t}\n \n-\tvar conflicts []Conflict\n-\tfor _, m := range mustSelect {\n-\t\ts, ok := selected[m.Path]\n-\t\tif !ok {\n-\t\t\tif m.Version != \"none\" {\n-\t\t\t\tpanic(fmt.Sprintf(\"internal error: mvs.BuildList lost %v\", m))\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif s.Version != m.Version {\n-\t\t\tconflicts = append(conflicts, Conflict{\n-\t\t\t\tSource:     reason[s],\n-\t\t\t\tDep:        s,\n-\t\t\t\tConstraint: m,\n-\t\t\t})\n+\trs, mg, err := expandGraph(ctx, rs)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\n+\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\treturn mg\n+}\n+\n+// expandGraph loads the complete module graph from rs.\n+//\n+// If the complete graph reveals that some root of rs is not actually the\n+// selected version of its path, expandGraph computes a new set of roots that\n+// are consistent. (When lazy loading is implemented, this may result in\n+// upgrades to other modules due to requirements that were previously pruned\n+// out.)\n+//\n+// expandGraph returns the updated roots, along with the module graph loaded\n+// from those roots and any error encountered while loading that graph.\n+// expandGraph returns non-nil requirements and a non-nil graph regardless of\n+// errors. On error, the roots might not be updated to be consistent.\n+func expandGraph(ctx context.Context, rs *Requirements) (*Requirements, *ModuleGraph, error) {\n+\tmg, mgErr := rs.Graph(ctx)\n+\tif mgErr != nil {\n+\t\t// Without the graph, we can't update the roots: we don't know which\n+\t\t// versions of transitive dependencies would be selected.\n+\t\treturn rs, mg, mgErr\n+\t}\n+\n+\tif !mg.allRootsSelected() {\n+\t\t// The roots of rs are not consistent with the rest of the graph. Update\n+\t\t// them. In an eager module this is a no-op for the build list as a whole \u2014\n+\t\t// it just promotes what were previously transitive requirements to be\n+\t\t// roots \u2014 but in a lazy module it may pull in previously-irrelevant\n+\t\t// transitive dependencies.\n+\n+\t\tnewRS, rsErr := updateRoots(ctx, rs.direct, rs, nil, nil, false)\n+\t\tif rsErr != nil {\n+\t\t\t// Failed to update roots, perhaps because of an error in a transitive\n+\t\t\t// dependency needed for the update. Return the original Requirements\n+\t\t\t// instead.\n+\t\t\treturn rs, mg, rsErr\n \t\t}\n+\t\trs = newRS\n+\t\tmg, mgErr = rs.Graph(ctx)\n \t}\n \n-\treturn &ConstraintError{\n-\t\tConflicts: conflicts,\n+\treturn rs, mg, mgErr\n+}\n+\n+// EditBuildList edits the global build list by first adding every module in add\n+// to the existing build list, then adjusting versions (and adding or removing\n+// requirements as needed) until every module in mustSelect is selected at the\n+// given version.\n+//\n+// (Note that the newly-added modules might not be selected in the resulting\n+// build list: they could be lower than existing requirements or conflict with\n+// versions in mustSelect.)\n+//\n+// If the versions listed in mustSelect are mutually incompatible (due to one of\n+// the listed modules requiring a higher version of another), EditBuildList\n+// returns a *ConstraintError and leaves the build list in its previous state.\n+//\n+// On success, EditBuildList reports whether the selected version of any module\n+// in the build list may have been changed (possibly to or from \"none\") as a\n+// result.\n+func EditBuildList(ctx context.Context, add, mustSelect []module.Version) (changed bool, err error) {\n+\trs, changed, err := editRequirements(ctx, LoadModFile(ctx), add, mustSelect)\n+\tif err != nil {\n+\t\treturn false, err\n \t}\n+\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\treturn changed, err\n }\n \n // A ConstraintError describes inconsistent constraints in EditBuildList\n@@ -216,93 +529,574 @@ type Conflict struct {\n \tConstraint module.Version\n }\n \n-// ReloadBuildList resets the state of loaded packages, then loads and returns\n-// the build list set by EditBuildList.\n-func ReloadBuildList() []module.Version {\n-\tloaded = loadFromRoots(loaderParams{\n-\t\tPackageOpts: PackageOpts{\n-\t\t\tTags: imports.Tags(),\n-\t\t},\n-\t\tlistRoots:          func() []string { return nil },\n-\t\tallClosesOverTests: index.allPatternClosesOverTests(), // but doesn't matter because the root list is empty.\n-\t})\n-\treturn capVersionSlice(buildList)\n+// tidyRoots trims the root dependencies to the minimal requirements needed to\n+// both retain the same versions of all packages in pkgs and satisfy the\n+// lazy loading invariants (if applicable).\n+func tidyRoots(ctx context.Context, rs *Requirements, pkgs []*loadPkg) (*Requirements, error) {\n+\tif rs.depth == eager {\n+\t\treturn tidyEagerRoots(ctx, rs.direct, pkgs)\n+\t}\n+\treturn tidyLazyRoots(ctx, rs.direct, pkgs)\n+}\n+\n+func updateRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error) {\n+\tif rs.depth == eager {\n+\t\treturn updateEagerRoots(ctx, direct, rs, add)\n+\t}\n+\treturn updateLazyRoots(ctx, direct, rs, pkgs, add, rootsImported)\n+}\n+\n+// tidyLazyRoots returns a minimal set of root requirements that maintains the\n+// \"lazy loading\" invariants of the go.mod file for the given packages:\n+//\n+// \t1. For each package marked with pkgInAll, the module path that provided that\n+// \t   package is included as a root.\n+// \t2. For all packages, the module that provided that package either remains\n+// \t   selected at the same version or is upgraded by the dependencies of a\n+// \t   root.\n+//\n+// If any module that provided a package has been upgraded above its previous,\n+// version, the caller may need to reload and recompute the package graph.\n+//\n+// To ensure that the loading process eventually converges, the caller should\n+// add any needed roots from the tidy root set (without removing existing untidy\n+// roots) until the set of roots has converged.\n+func tidyLazyRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n+\tvar (\n+\t\troots        []module.Version\n+\t\tpathIncluded = map[string]bool{Target.Path: true}\n+\t)\n+\t// We start by adding roots for every package in \"all\".\n+\t//\n+\t// Once that is done, we may still need to add more roots to cover upgraded or\n+\t// otherwise-missing test dependencies for packages in \"all\". For those test\n+\t// dependencies, we prefer to add roots for packages with shorter import\n+\t// stacks first, on the theory that the module requirements for those will\n+\t// tend to fill in the requirements for their transitive imports (which have\n+\t// deeper import stacks). So we add the missing dependencies for one depth at\n+\t// a time, starting with the packages actually in \"all\" and expanding outwards\n+\t// until we have scanned every package that was loaded.\n+\tvar (\n+\t\tqueue  []*loadPkg\n+\t\tqueued = map[*loadPkg]bool{}\n+\t)\n+\tfor _, pkg := range pkgs {\n+\t\tif !pkg.flags.has(pkgInAll) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif pkg.fromExternalModule() && !pathIncluded[pkg.mod.Path] {\n+\t\t\troots = append(roots, pkg.mod)\n+\t\t\tpathIncluded[pkg.mod.Path] = true\n+\t\t}\n+\t\tqueue = append(queue, pkg)\n+\t\tqueued[pkg] = true\n+\t}\n+\tmodule.Sort(roots)\n+\ttidy := newRequirements(lazy, roots, direct)\n+\n+\tfor len(queue) > 0 {\n+\t\troots = tidy.rootModules\n+\t\tmg, err := tidy.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tprevQueue := queue\n+\t\tqueue = nil\n+\t\tfor _, pkg := range prevQueue {\n+\t\t\tm := pkg.mod\n+\t\t\tif m.Path == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, dep := range pkg.imports {\n+\t\t\t\tif !queued[dep] {\n+\t\t\t\t\tqueue = append(queue, dep)\n+\t\t\t\t\tqueued[dep] = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif pkg.test != nil && !queued[pkg.test] {\n+\t\t\t\tqueue = append(queue, pkg.test)\n+\t\t\t\tqueued[pkg.test] = true\n+\t\t\t}\n+\t\t\tif !pathIncluded[m.Path] {\n+\t\t\t\tif s := mg.Selected(m.Path); cmpVersion(s, m.Version) < 0 {\n+\t\t\t\t\troots = append(roots, m)\n+\t\t\t\t}\n+\t\t\t\tpathIncluded[m.Path] = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(roots) > len(tidy.rootModules) {\n+\t\t\tmodule.Sort(roots)\n+\t\t\ttidy = newRequirements(lazy, roots, tidy.direct)\n+\t\t}\n+\t}\n+\n+\t_, err := tidy.Graph(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn tidy, nil\n }\n \n-// CheckTidyVersion reports an error to stderr if the Go version indicated by\n-// the go.mod file is not supported by this version of the 'go' command.\n+// updateLazyRoots returns a set of root requirements that maintains the \u201clazy\n+// loading\u201d invariants of the go.mod file:\n+//\n+// \t1. The selected version of the module providing each package marked with\n+// \t   either pkgInAll or pkgIsRoot is included as a root.\n+// \t   Note that certain root patterns (such as '...') may explode the root set\n+// \t   to contain every module that provides any package imported (or merely\n+// \t   required) by any other module.\n+// \t2. Each root appears only once, at the selected version of its path\n+// \t   (if rs.graph is non-nil) or at the highest version otherwise present as a\n+// \t   root (otherwise).\n+// \t3. Every module path that appears as a root in rs remains a root.\n+// \t4. Every version in add is selected at its given version unless upgraded by\n+// \t   (the dependencies of) an existing root or another module in add.\n+//\n+// The packages in pkgs are assumed to have been loaded from either the roots of\n+// rs or the modules selected in the graph of rs.\n+//\n+// The above invariants together imply the \u201clazy loading\u201d invariants for the\n+// go.mod file:\n+//\n+// \t1. (The import invariant.) Every module that provides a package transitively\n+// \t   imported by any package or test in the main module is included as a root.\n+// \t   This follows by induction from (1) and (3) above. Transitively-imported\n+// \t   packages loaded during this invocation are marked with pkgInAll (1),\n+// \t   and by hypothesis any transitively-imported packages loaded in previous\n+// \t   invocations were already roots in rs (3).\n+//\n+// \t2. (The argument invariant.) Every module that provides a package matching\n+// \t   an explicit package pattern is included as a root. This follows directly\n+// \t   from (1): packages matching explicit package patterns are marked with\n+// \t   pkgIsRoot.\n+//\n+// \t3. (The completeness invariant.) Every module that contributed any package\n+// \t   to the build is required by either the main module or one of the modules\n+// \t   it requires explicitly. This invariant is left up to the caller, who must\n+// \t   not load packages from outside the module graph but may add roots to the\n+// \t   graph, but is facilited by (3). If the caller adds roots to the graph in\n+// \t   order to resolve missing packages, then updateLazyRoots will retain them,\n+// \t   the selected versions of those roots cannot regress, and they will\n+// \t   eventually be written back to the main module's go.mod file.\n //\n-// If allowError is false, such an error terminates the program.\n-func CheckTidyVersion(ctx context.Context, allowError bool) {\n-\tLoadModFile(ctx)\n-\tif index.goVersionV == \"\" {\n-\t\treturn\n+// (See https://golang.org/design/36460-lazy-module-loading#invariants for more\n+// detail.)\n+func updateLazyRoots(ctx context.Context, direct map[string]bool, rs *Requirements, pkgs []*loadPkg, add []module.Version, rootsImported bool) (*Requirements, error) {\n+\troots := rs.rootModules\n+\trootsUpgraded := false\n+\n+\tspotCheckRoot := map[module.Version]bool{}\n+\n+\t// \u201cThe selected version of the module providing each package marked with\n+\t// either pkgInAll or pkgIsRoot is included as a root.\u201d\n+\tneedSort := false\n+\tfor _, pkg := range pkgs {\n+\t\tif !pkg.fromExternalModule() {\n+\t\t\t// pkg was not loaded from a module dependency, so we don't need\n+\t\t\t// to do anything special to maintain that dependency.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch {\n+\t\tcase pkg.flags.has(pkgInAll):\n+\t\t\t// pkg is transitively imported by a package or test in the main module.\n+\t\t\t// We need to promote the module that maintains it to a root: if some\n+\t\t\t// other module depends on the main module, and that other module also\n+\t\t\t// uses lazy loading, it will expect to find all of our transitive\n+\t\t\t// dependencies by reading just our go.mod file, not the go.mod files of\n+\t\t\t// everything we depend on.\n+\t\t\t//\n+\t\t\t// (This is the \u201cimport invariant\u201d that makes lazy loading possible.)\n+\n+\t\tcase rootsImported && pkg.flags.has(pkgFromRoot):\n+\t\t\t// pkg is a transitive dependency of some root, and we are treating the\n+\t\t\t// roots as if they are imported by the main module (as in 'go get').\n+\n+\t\tcase pkg.flags.has(pkgIsRoot):\n+\t\t\t// pkg is a root of the package-import graph. (Generally this means that\n+\t\t\t// it matches a command-line argument.) We want future invocations of the\n+\t\t\t// 'go' command \u2014 such as 'go test' on the same package \u2014 to continue to\n+\t\t\t// use the same versions of its dependencies that we are using right now.\n+\t\t\t// So we need to bring this package's dependencies inside the lazy-loading\n+\t\t\t// horizon.\n+\t\t\t//\n+\t\t\t// Making the module containing this package a root of the module graph\n+\t\t\t// does exactly that: if the module containing the package is lazy it\n+\t\t\t// should satisfy the import invariant itself, so all of its dependencies\n+\t\t\t// should be in its go.mod file, and if the module containing the package\n+\t\t\t// is eager then if we make it a root we will load all of its transitive\n+\t\t\t// dependencies into the module graph.\n+\t\t\t//\n+\t\t\t// (This is the \u201cargument invariant\u201d of lazy loading, and is important for\n+\t\t\t// reproducibility.)\n+\n+\t\tdefault:\n+\t\t\t// pkg is a dependency of some other package outside of the main module.\n+\t\t\t// As far as we know it's not relevant to the main module (and thus not\n+\t\t\t// relevant to consumers of the main module either), and its dependencies\n+\t\t\t// should already be in the module graph \u2014 included in the dependencies of\n+\t\t\t// the package that imported it.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif _, ok := rs.rootSelected(pkg.mod.Path); ok {\n+\t\t\t// It is possible that the main module's go.mod file is incomplete or\n+\t\t\t// otherwise erroneous \u2014 for example, perhaps the author forgot to 'git\n+\t\t\t// add' their updated go.mod file after adding a new package import, or\n+\t\t\t// perhaps they made an edit to the go.mod file using a third-party tool\n+\t\t\t// ('git merge'?) that doesn't maintain consistency for module\n+\t\t\t// dependencies. If that happens, ideally we want to detect the missing\n+\t\t\t// requirements and fix them up here.\n+\t\t\t//\n+\t\t\t// However, we also need to be careful not to be too aggressive. For\n+\t\t\t// transitive dependencies of external tests, the go.mod file for the\n+\t\t\t// module containing the test itself is expected to provide all of the\n+\t\t\t// relevant dependencies, and we explicitly don't want to pull in\n+\t\t\t// requirements on *irrelevant* requirements that happen to occur in the\n+\t\t\t// go.mod files for these transitive-test-only dependencies. (See the test\n+\t\t\t// in mod_lazy_test_horizon.txt for a concrete example.\n+\t\t\t//\n+\t\t\t// The \u201cgoldilocks zone\u201d seems to be to spot-check exactly the same\n+\t\t\t// modules that we promote to explicit roots: namely, those that provide\n+\t\t\t// packages transitively imported by the main module, and those that\n+\t\t\t// provide roots of the package-import graph. That will catch erroneous\n+\t\t\t// edits to the main module's go.mod file and inconsistent requirements in\n+\t\t\t// dependencies that provide imported packages, but will ignore erroneous\n+\t\t\t// or misleading requirements in dependencies that aren't obviously\n+\t\t\t// relevant to the packages in the main module.\n+\t\t\tspotCheckRoot[pkg.mod] = true\n+\t\t} else {\n+\t\t\troots = append(roots, pkg.mod)\n+\t\t\trootsUpgraded = true\n+\t\t\t// The roots slice was initially sorted because rs.rootModules was sorted,\n+\t\t\t// but the root we just added could be out of order.\n+\t\t\tneedSort = true\n+\t\t}\n \t}\n \n-\ttags := build.Default.ReleaseTags\n-\tmaxGo := tags[len(tags)-1]\n-\tif !strings.HasPrefix(maxGo, \"go\") || !modfile.GoVersionRE.MatchString(maxGo[2:]) {\n-\t\tbase.Fatalf(\"go: unrecognized go version %q\", maxGo)\n+\tfor _, m := range add {\n+\t\tif v, ok := rs.rootSelected(m.Path); !ok || cmpVersion(v, m.Version) < 0 {\n+\t\t\troots = append(roots, m)\n+\t\t\trootsUpgraded = true\n+\t\t\tneedSort = true\n+\t\t}\n+\t}\n+\tif needSort {\n+\t\tmodule.Sort(roots)\n \t}\n-\tmax := maxGo[2:]\n \n-\tif semver.Compare(index.goVersionV, \"v\"+max) > 0 {\n-\t\thave := index.goVersionV[1:]\n-\t\tif allowError {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", have, max)\n+\t// \"Each root appears only once, at the selected version of its path \u2026.\u201d\n+\tfor {\n+\t\tvar mg *ModuleGraph\n+\t\tif rootsUpgraded {\n+\t\t\t// We've added or upgraded one or more roots, so load the full module\n+\t\t\t// graph so that we can update those roots to be consistent with other\n+\t\t\t// requirements.\n+\t\t\tif cfg.BuildMod != \"mod\" {\n+\t\t\t\t// Our changes to the roots may have moved dependencies into or out of\n+\t\t\t\t// the lazy-loading horizon, which could in turn change the selected\n+\t\t\t\t// versions of other modules. (Unlike for eager modules, for lazy\n+\t\t\t\t// modules adding or removing an explicit root is a semantic change, not\n+\t\t\t\t// just a cosmetic one.)\n+\t\t\t\treturn rs, errGoModDirty\n+\t\t\t}\n+\n+\t\t\trs = newRequirements(lazy, roots, direct)\n+\t\t\tvar err error\n+\t\t\tmg, err = rs.Graph(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn rs, err\n+\t\t\t}\n \t\t} else {\n-\t\t\tbase.Fatalf(\"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", have, max)\n+\t\t\t// Since none of the roots have been upgraded, we have no reason to\n+\t\t\t// suspect that they are inconsistent with the requirements of any other\n+\t\t\t// roots. Only look at the full module graph if we've already loaded it;\n+\t\t\t// otherwise, just spot-check the explicit requirements of the roots from\n+\t\t\t// which we loaded packages.\n+\t\t\tif rs.graph.Load() != nil {\n+\t\t\t\t// We've already loaded the full module graph, which includes the\n+\t\t\t\t// requirements of all of the root modules \u2014 even the transitive\n+\t\t\t\t// requirements, if they are eager!\n+\t\t\t\tmg, _ = rs.Graph(ctx)\n+\t\t\t} else if cfg.BuildMod == \"vendor\" {\n+\t\t\t\t// We can't spot-check the requirements of other modules because we\n+\t\t\t\t// don't in general have their go.mod files available in the vendor\n+\t\t\t\t// directory. (Fortunately this case is impossible, because mg.graph is\n+\t\t\t\t// always non-nil in vendor mode!)\n+\t\t\t\tpanic(\"internal error: rs.graph is unexpectedly nil with -mod=vendor\")\n+\t\t\t} else if !spotCheckRoots(ctx, rs, spotCheckRoot) {\n+\t\t\t\t// We spot-checked the explicit requirements of the roots that are\n+\t\t\t\t// relevant to the packages we've loaded. Unfortunately, they're\n+\t\t\t\t// inconsistent in some way; we need to load the full module graph\n+\t\t\t\t// so that we can fix the roots properly.\n+\t\t\t\tvar err error\n+\t\t\t\tmg, err = rs.Graph(ctx)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn rs, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\troots = make([]module.Version, 0, len(rs.rootModules))\n+\t\trootsUpgraded = false\n+\t\tinRootPaths := make(map[string]bool, len(rs.rootModules)+1)\n+\t\tinRootPaths[Target.Path] = true\n+\t\tfor _, m := range rs.rootModules {\n+\t\t\tif inRootPaths[m.Path] {\n+\t\t\t\t// This root specifies a redundant path. We already retained the\n+\t\t\t\t// selected version of this path when we saw it before, so omit the\n+\t\t\t\t// redundant copy regardless of its version.\n+\t\t\t\t//\n+\t\t\t\t// When we read the full module graph, we include the dependencies of\n+\t\t\t\t// every root even if that root is redundant. That better preserves\n+\t\t\t\t// reproducibility if, say, some automated tool adds a redundant\n+\t\t\t\t// 'require' line and then runs 'go mod tidy' to try to make everything\n+\t\t\t\t// consistent, since the requirements of the older version are carried\n+\t\t\t\t// over.\n+\t\t\t\t//\n+\t\t\t\t// So omitting a root that was previously present may *reduce* the\n+\t\t\t\t// selected versions of non-roots, but merely removing a requirement\n+\t\t\t\t// cannot *increase* the selected versions of other roots as a result \u2014\n+\t\t\t\t// we don't need to mark this change as an upgrade. (This particular\n+\t\t\t\t// change cannot invalidate any other roots.)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tvar v string\n+\t\t\tif mg == nil {\n+\t\t\t\tv, _ = rs.rootSelected(m.Path)\n+\t\t\t} else {\n+\t\t\t\tv = mg.Selected(m.Path)\n+\t\t\t}\n+\t\t\troots = append(roots, module.Version{Path: m.Path, Version: v})\n+\t\t\tinRootPaths[m.Path] = true\n+\t\t\tif v != m.Version {\n+\t\t\t\trootsUpgraded = true\n+\t\t\t}\n \t\t}\n+\t\t// Note that rs.rootModules was already sorted by module path and version,\n+\t\t// and we appended to the roots slice in the same order and guaranteed that\n+\t\t// each path has only one version, so roots is also sorted by module path\n+\t\t// and (trivially) version.\n+\n+\t\tif !rootsUpgraded {\n+\t\t\t// The root set has converged: every root going into this iteration was\n+\t\t\t// already at its selected version, although we have have removed other\n+\t\t\t// (redundant) roots for the same path.\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif rs.depth == lazy && reflect.DeepEqual(roots, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n+\t\t// The root set is unchanged and rs was already lazy, so keep rs to\n+\t\t// preserve its cached ModuleGraph (if any).\n+\t\treturn rs, nil\n \t}\n+\treturn newRequirements(lazy, roots, direct), nil\n }\n \n-// TidyBuildList trims the build list to the minimal requirements needed to\n-// retain the same versions of all packages from the preceding call to\n-// LoadPackages.\n-func TidyBuildList() {\n-\tused := map[module.Version]bool{Target: true}\n-\tfor _, pkg := range loaded.pkgs {\n-\t\tused[pkg.mod] = true\n+// spotCheckRoots reports whether the versions of the roots in rs satisfy the\n+// explicit requirements of the modules in mods.\n+func spotCheckRoots(ctx context.Context, rs *Requirements, mods map[module.Version]bool) bool {\n+\tctx, cancel := context.WithCancel(ctx)\n+\tdefer cancel()\n+\n+\twork := par.NewQueue(runtime.GOMAXPROCS(0))\n+\tfor m := range mods {\n+\t\tm := m\n+\t\twork.Add(func() {\n+\t\t\tif ctx.Err() != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tsummary, err := goModSummary(m)\n+\t\t\tif err != nil {\n+\t\t\t\tcancel()\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tfor _, r := range summary.require {\n+\t\t\t\tif v, ok := rs.rootSelected(r.Path); ok && cmpVersion(v, r.Version) < 0 {\n+\t\t\t\t\tcancel()\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+\t<-work.Idle()\n+\n+\tif ctx.Err() != nil {\n+\t\t// Either we failed a spot-check, or the caller no longer cares about our\n+\t\t// answer anyway.\n+\t\treturn false\n \t}\n \n-\tkeep := []module.Version{Target}\n-\tvar direct []string\n-\tfor _, m := range buildList[1:] {\n-\t\tif used[m] {\n+\treturn true\n+}\n+\n+// tidyEagerRoots returns a minimal set of root requirements that maintains the\n+// selected version of every module that provided a package in pkgs, and\n+// includes the selected version of every such module in direct as a root.\n+func tidyEagerRoots(ctx context.Context, direct map[string]bool, pkgs []*loadPkg) (*Requirements, error) {\n+\tvar (\n+\t\tkeep     []module.Version\n+\t\tkeptPath = map[string]bool{}\n+\t)\n+\tvar (\n+\t\trootPaths   []string // module paths that should be included as roots\n+\t\tinRootPaths = map[string]bool{}\n+\t)\n+\tfor _, pkg := range pkgs {\n+\t\tif !pkg.fromExternalModule() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif m := pkg.mod; !keptPath[m.Path] {\n \t\t\tkeep = append(keep, m)\n-\t\t\tif loaded.direct[m.Path] {\n-\t\t\t\tdirect = append(direct, m.Path)\n-\t\t\t}\n-\t\t} else if cfg.BuildV {\n-\t\t\tif _, ok := index.require[m]; ok {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n+\t\t\tkeptPath[m.Path] = true\n+\t\t\tif direct[m.Path] && !inRootPaths[m.Path] {\n+\t\t\t\trootPaths = append(rootPaths, m.Path)\n+\t\t\t\tinRootPaths[m.Path] = true\n \t\t\t}\n \t\t}\n \t}\n \n-\tmin, err := mvs.Req(Target, direct, &mvsReqs{buildList: keep})\n+\tmin, err := mvs.Req(Target, rootPaths, &mvsReqs{roots: keep})\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+\t\treturn nil, err\n \t}\n-\tbuildList = append([]module.Version{Target}, min...)\n+\treturn newRequirements(eager, min, direct), nil\n }\n \n-// checkMultiplePaths verifies that a given module path is used as itself\n-// or as a replacement for another module, but not both at the same time.\n+// updateEagerRoots returns a set of root requirements that includes the selected\n+// version of every module path in direct as a root, and maintains the selected\n+// version of every module selected in the graph of rs.\n //\n-// (See https://golang.org/issue/26607 and https://golang.org/issue/34650.)\n-func checkMultiplePaths() {\n-\tfirstPath := make(map[module.Version]string, len(buildList))\n-\tfor _, mod := range buildList {\n-\t\tsrc := mod\n-\t\tif rep := Replacement(mod); rep.Path != \"\" {\n-\t\t\tsrc = rep\n+// The roots are updated such that:\n+//\n+// \t1. The selected version of every module path in direct is included as a root\n+// \t   (if it is not \"none\").\n+// \t2. Each root is the selected version of its path. (We say that such a root\n+// \t   set is \u201cconsistent\u201d.)\n+// \t3. Every version selected in the graph of rs remains selected unless upgraded\n+// \t   by a dependency in add.\n+// \t4. Every version in add is selected at its given version unless upgraded by\n+// \t   (the dependencies of) an existing root or another module in add.\n+func updateEagerRoots(ctx context.Context, direct map[string]bool, rs *Requirements, add []module.Version) (*Requirements, error) {\n+\tmg, err := rs.Graph(ctx)\n+\tif err != nil {\n+\t\t// We can't ignore errors in the module graph even if the user passed the -e\n+\t\t// flag to try to push past them. If we can't load the complete module\n+\t\t// dependencies, then we can't reliably compute a minimal subset of them.\n+\t\treturn rs, err\n+\t}\n+\n+\tif cfg.BuildMod != \"mod\" {\n+\t\t// Instead of actually updating the requirements, just check that no updates\n+\t\t// are needed.\n+\t\tif rs == nil {\n+\t\t\t// We're being asked to reconstruct the requirements from scratch,\n+\t\t\t// but we aren't even allowed to modify them.\n+\t\t\treturn rs, errGoModDirty\n \t\t}\n-\t\tif prev, ok := firstPath[src]; !ok {\n-\t\t\tfirstPath[src] = mod.Path\n-\t\t} else if prev != mod.Path {\n-\t\t\tbase.Errorf(\"go: %s@%s used for two different module paths (%s and %s)\", src.Path, src.Version, prev, mod.Path)\n+\t\tfor _, m := range rs.rootModules {\n+\t\t\tif m.Version != mg.Selected(m.Path) {\n+\t\t\t\t// The root version v is misleading: the actual selected version is higher.\n+\t\t\t\treturn rs, errGoModDirty\n+\t\t\t}\n \t\t}\n+\t\tfor _, m := range add {\n+\t\t\tif m.Version != mg.Selected(m.Path) {\n+\t\t\t\treturn rs, errGoModDirty\n+\t\t\t}\n+\t\t}\n+\t\tfor mPath := range direct {\n+\t\t\tif _, ok := rs.rootSelected(mPath); !ok {\n+\t\t\t\t// Module m is supposed to be listed explicitly, but isn't.\n+\t\t\t\t//\n+\t\t\t\t// Note that this condition is also detected (and logged with more\n+\t\t\t\t// detail) earlier during package loading, so it shouldn't actually be\n+\t\t\t\t// possible at this point \u2014 this is just a defense in depth.\n+\t\t\t\treturn rs, errGoModDirty\n+\t\t\t}\n+\t\t}\n+\n+\t\t// No explicit roots are missing and all roots are already at the versions\n+\t\t// we want to keep. Any other changes we would make are purely cosmetic,\n+\t\t// such as pruning redundant indirect dependencies. Per issue #34822, we\n+\t\t// ignore cosmetic changes when we cannot update the go.mod file.\n+\t\treturn rs, nil\n+\t}\n+\n+\tvar (\n+\t\trootPaths   []string // module paths that should be included as roots\n+\t\tinRootPaths = map[string]bool{}\n+\t)\n+\tfor _, root := range rs.rootModules {\n+\t\t// If the selected version of the root is the same as what was already\n+\t\t// listed in the go.mod file, retain it as a root (even if redundant) to\n+\t\t// avoid unnecessary churn. (See https://golang.org/issue/34822.)\n+\t\t//\n+\t\t// We do this even for indirect requirements, since we don't know why they\n+\t\t// were added and they could become direct at any time.\n+\t\tif !inRootPaths[root.Path] && mg.Selected(root.Path) == root.Version {\n+\t\t\trootPaths = append(rootPaths, root.Path)\n+\t\t\tinRootPaths[root.Path] = true\n+\t\t}\n+\t}\n+\n+\t// \u201cThe selected version of every module path in direct is included as a root.\u201d\n+\t//\n+\t// This is only for convenience and clarity for end users: in an eager module,\n+\t// the choice of explicit vs. implicit dependency has no impact on MVS\n+\t// selection (for itself or any other module).\n+\tkeep := append(mg.BuildList()[1:], add...)\n+\tfor _, m := range keep {\n+\t\tif direct[m.Path] && !inRootPaths[m.Path] {\n+\t\t\trootPaths = append(rootPaths, m.Path)\n+\t\t\tinRootPaths[m.Path] = true\n+\t\t}\n+\t}\n+\n+\tmin, err := mvs.Req(Target, rootPaths, &mvsReqs{roots: keep})\n+\tif err != nil {\n+\t\treturn rs, err\n+\t}\n+\tif rs.depth == eager && reflect.DeepEqual(min, rs.rootModules) && reflect.DeepEqual(direct, rs.direct) {\n+\t\t// The root set is unchanged and rs was already eager, so keep rs to\n+\t\t// preserve its cached ModuleGraph (if any).\n+\t\treturn rs, nil\n+\t}\n+\treturn newRequirements(eager, min, direct), nil\n+}\n+\n+// convertDepth returns a version of rs with the given depth.\n+// If rs already has the given depth, convertDepth returns rs unmodified.\n+func convertDepth(ctx context.Context, rs *Requirements, depth modDepth) (*Requirements, error) {\n+\tif rs.depth == depth {\n+\t\treturn rs, nil\n+\t}\n+\n+\tif depth == eager {\n+\t\t// We are converting a lazy module to an eager one. The roots of an eager\n+\t\t// module graph are a superset of the roots of a lazy graph, so we don't\n+\t\t// need to add any new roots \u2014 we just need to prune away the ones that are\n+\t\t// redundant given eager loading, which is exactly what updateEagerRoots\n+\t\t// does.\n+\t\treturn updateEagerRoots(ctx, rs.direct, rs, nil)\n+\t}\n+\n+\t// We are converting an eager module to a lazy one. The module graph of an\n+\t// eager module includes the transitive dependencies of every module in the\n+\t// build list.\n+\t//\n+\t// Hey, we can express that as a lazy root set! \u201cInclude the transitive\n+\t// dependencies of every module in the build list\u201d is exactly what happens in\n+\t// a lazy module if we promote every module in the build list to a root!\n+\tmg, err := rs.Graph(ctx)\n+\tif err != nil {\n+\t\treturn rs, err\n \t}\n-\tbase.ExitIfErrors()\n+\treturn newRequirements(lazy, mg.BuildList()[1:], rs.direct), nil\n }"}, {"sha": "c350b9d1b5c571ed0e0754a07ad58fa3c9b26fe9", "filename": "libgo/go/cmd/go/internal/modload/edit.go", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fedit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,569 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modload\n+\n+import (\n+\t\"cmd/go/internal/mvs\"\n+\t\"context\"\n+\t\"reflect\"\n+\t\"sort\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+)\n+\n+// editRequirements returns an edited version of rs such that:\n+//\n+// \t1. Each module version in mustSelect is selected.\n+//\n+// \t2. Each module version in tryUpgrade is upgraded toward the indicated\n+// \t   version as far as can be done without violating (1).\n+//\n+// \t3. Each module version in rs.rootModules (or rs.graph, if rs.depth is eager)\n+// \t   is downgraded from its original version only to the extent needed to\n+// \t   satisfy (1), or upgraded only to the extent needed to satisfy (1) and\n+// \t   (2).\n+//\n+// \t4. No module is upgraded above the maximum version of its path found in the\n+// \t   dependency graph of rs, the combined dependency graph of the versions in\n+// \t   mustSelect, or the dependencies of each individual module version in\n+// \t   tryUpgrade.\n+//\n+// Generally, the module versions in mustSelect are due to the module or a\n+// package within the module matching an explicit command line argument to 'go\n+// get', and the versions in tryUpgrade are transitive dependencies that are\n+// either being upgraded by 'go get -u' or being added to satisfy some\n+// otherwise-missing package import.\n+func editRequirements(ctx context.Context, rs *Requirements, tryUpgrade, mustSelect []module.Version) (edited *Requirements, changed bool, err error) {\n+\tlimiter, err := limiterForEdit(ctx, rs, tryUpgrade, mustSelect)\n+\tif err != nil {\n+\t\treturn rs, false, err\n+\t}\n+\n+\tvar conflicts []Conflict\n+\tfor _, m := range mustSelect {\n+\t\tconflict, err := limiter.Select(m)\n+\t\tif err != nil {\n+\t\t\treturn rs, false, err\n+\t\t}\n+\t\tif conflict.Path != \"\" {\n+\t\t\tconflicts = append(conflicts, Conflict{\n+\t\t\t\tSource: m,\n+\t\t\t\tDep:    conflict,\n+\t\t\t\tConstraint: module.Version{\n+\t\t\t\t\tPath:    conflict.Path,\n+\t\t\t\t\tVersion: limiter.max[conflict.Path],\n+\t\t\t\t},\n+\t\t\t})\n+\t\t}\n+\t}\n+\tif len(conflicts) > 0 {\n+\t\treturn rs, false, &ConstraintError{Conflicts: conflicts}\n+\t}\n+\n+\tmods, changed, err := selectPotentiallyImportedModules(ctx, limiter, rs, tryUpgrade)\n+\tif err != nil {\n+\t\treturn rs, false, err\n+\t}\n+\n+\tvar roots []module.Version\n+\tif rs.depth == eager {\n+\t\t// In an eager module, modules that provide packages imported by the main\n+\t\t// module may either be explicit roots or implicit transitive dependencies.\n+\t\t// We promote the modules in mustSelect to be explicit requirements.\n+\t\tvar rootPaths []string\n+\t\tfor _, m := range mustSelect {\n+\t\t\tif m.Version != \"none\" && m.Path != Target.Path {\n+\t\t\t\trootPaths = append(rootPaths, m.Path)\n+\t\t\t}\n+\t\t}\n+\t\tif !changed && len(rootPaths) == 0 {\n+\t\t\t// The build list hasn't changed and we have no new roots to add.\n+\t\t\t// We don't need to recompute the minimal roots for the module.\n+\t\t\treturn rs, false, nil\n+\t\t}\n+\n+\t\tfor _, m := range mods {\n+\t\t\tif v, ok := rs.rootSelected(m.Path); ok && (v == m.Version || rs.direct[m.Path]) {\n+\t\t\t\t// m.Path was formerly a root, and either its version hasn't changed or\n+\t\t\t\t// we believe that it provides a package directly imported by a package\n+\t\t\t\t// or test in the main module. For now we'll assume that it is still\n+\t\t\t\t// relevant enough to remain a root. If we actually load all of the\n+\t\t\t\t// packages and tests in the main module (which we are not doing here),\n+\t\t\t\t// we can revise the explicit roots at that point.\n+\t\t\t\trootPaths = append(rootPaths, m.Path)\n+\t\t\t}\n+\t\t}\n+\n+\t\troots, err = mvs.Req(Target, rootPaths, &mvsReqs{roots: mods})\n+\t\tif err != nil {\n+\t\t\treturn nil, false, err\n+\t\t}\n+\t} else {\n+\t\t// In a lazy module, every module that provides a package imported by the\n+\t\t// main module must be retained as a root.\n+\t\troots = mods\n+\t\tif !changed {\n+\t\t\t// Because the roots we just computed are unchanged, the entire graph must\n+\t\t\t// be the same as it was before. Save the original rs, since we have\n+\t\t\t// probably already loaded its requirement graph.\n+\t\t\treturn rs, false, nil\n+\t\t}\n+\t}\n+\n+\t// A module that is not even in the build list necessarily cannot provide\n+\t// any imported packages. Mark as direct only the direct modules that are\n+\t// still in the build list.\n+\t//\n+\t// TODO(bcmills): Would it make more sense to leave the direct map as-is\n+\t// but allow it to refer to modules that are no longer in the build list?\n+\t// That might complicate updateRoots, but it may be cleaner in other ways.\n+\tdirect := make(map[string]bool, len(rs.direct))\n+\tfor _, m := range roots {\n+\t\tif rs.direct[m.Path] {\n+\t\t\tdirect[m.Path] = true\n+\t\t}\n+\t}\n+\treturn newRequirements(rs.depth, roots, direct), changed, nil\n+}\n+\n+// limiterForEdit returns a versionLimiter with its max versions set such that\n+// the max version for every module path in mustSelect is the version listed\n+// there, and the max version for every other module path is the maximum version\n+// of its path found in the dependency graph of rs, the combined dependency\n+// graph of the versions in mustSelect, or the dependencies of each individual\n+// module version in tryUpgrade.\n+func limiterForEdit(ctx context.Context, rs *Requirements, tryUpgrade, mustSelect []module.Version) (*versionLimiter, error) {\n+\tmg, err := rs.Graph(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tmaxVersion := map[string]string{} // module path \u2192 version\n+\trestrictTo := func(m module.Version) {\n+\t\tv, ok := maxVersion[m.Path]\n+\t\tif !ok || cmpVersion(v, m.Version) > 0 {\n+\t\t\tmaxVersion[m.Path] = m.Version\n+\t\t}\n+\t}\n+\n+\tif rs.depth == eager {\n+\t\t// Eager go.mod files don't indicate which transitive dependencies are\n+\t\t// actually relevant to the main module, so we have to assume that any module\n+\t\t// that could have provided any package \u2014 that is, any module whose selected\n+\t\t// version was not \"none\" \u2014 may be relevant.\n+\t\tfor _, m := range mg.BuildList() {\n+\t\t\trestrictTo(m)\n+\t\t}\n+\t} else {\n+\t\t// The go.mod file explicitly records every module that provides a package\n+\t\t// imported by the main module.\n+\t\t//\n+\t\t// If we need to downgrade an existing root or a new root found in\n+\t\t// tryUpgrade, we don't want to allow that downgrade to incidentally upgrade\n+\t\t// a module imported by the main module to some arbitrary version.\n+\t\t// However, we don't particularly care about arbitrary upgrades to modules\n+\t\t// that are (at best) only providing packages imported by tests of\n+\t\t// dependencies outside the main module.\n+\t\tfor _, m := range rs.rootModules {\n+\t\t\trestrictTo(module.Version{\n+\t\t\t\tPath:    m.Path,\n+\t\t\t\tVersion: mg.Selected(m.Path),\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\tif err := raiseLimitsForUpgrades(ctx, maxVersion, rs.depth, tryUpgrade, mustSelect); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// The versions in mustSelect override whatever we would naively select \u2014\n+\t// we will downgrade other modules as needed in order to meet them.\n+\tfor _, m := range mustSelect {\n+\t\trestrictTo(m)\n+\t}\n+\n+\treturn newVersionLimiter(rs.depth, maxVersion), nil\n+}\n+\n+// raiseLimitsForUpgrades increases the module versions in maxVersions to the\n+// versions that would be needed to allow each of the modules in tryUpgrade\n+// (individually) and all of the modules in mustSelect (simultaneously) to be\n+// added as roots.\n+//\n+// Versions not present in maxVersion are unrestricted, and it is assumed that\n+// they will not be promoted to root requirements (and thus will not contribute\n+// their own dependencies if the main module is lazy).\n+//\n+// These limits provide an upper bound on how far a module may be upgraded as\n+// part of an incidental downgrade, if downgrades are needed in order to select\n+// the versions in mustSelect.\n+func raiseLimitsForUpgrades(ctx context.Context, maxVersion map[string]string, depth modDepth, tryUpgrade []module.Version, mustSelect []module.Version) error {\n+\t// allow raises the limit for m.Path to at least m.Version.\n+\t// If m.Path was already unrestricted, it remains unrestricted.\n+\tallow := func(m module.Version) {\n+\t\tv, ok := maxVersion[m.Path]\n+\t\tif !ok {\n+\t\t\treturn // m.Path is unrestricted.\n+\t\t}\n+\t\tif cmpVersion(v, m.Version) < 0 {\n+\t\t\tmaxVersion[m.Path] = m.Version\n+\t\t}\n+\t}\n+\n+\tvar eagerUpgrades []module.Version\n+\tif depth == eager {\n+\t\teagerUpgrades = tryUpgrade\n+\t} else {\n+\t\tfor _, m := range tryUpgrade {\n+\t\t\tif m.Path == Target.Path {\n+\t\t\t\t// Target is already considered to be higher than any possible m, so we\n+\t\t\t\t// won't be upgrading to it anyway and there is no point scanning its\n+\t\t\t\t// dependencies.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tsummary, err := goModSummary(m)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif summary.depth == eager {\n+\t\t\t\t// For efficiency, we'll load all of the eager upgrades as one big\n+\t\t\t\t// graph, rather than loading the (potentially-overlapping) subgraph for\n+\t\t\t\t// each upgrade individually.\n+\t\t\t\teagerUpgrades = append(eagerUpgrades, m)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfor _, r := range summary.require {\n+\t\t\t\tallow(r)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif len(eagerUpgrades) > 0 {\n+\t\t// Compute the max versions for eager upgrades all together.\n+\t\t// Since these modules are eager, we'll end up scanning all of their\n+\t\t// transitive dependencies no matter which versions end up selected,\n+\t\t// and since we have a large dependency graph to scan we might get\n+\t\t// a significant benefit from not revisiting dependencies that are at\n+\t\t// common versions among multiple upgrades.\n+\t\tupgradeGraph, err := readModGraph(ctx, eager, eagerUpgrades)\n+\t\tif err != nil {\n+\t\t\tif go117LazyTODO {\n+\t\t\t\t// Compute the requirement path from a module path in tryUpgrade to the\n+\t\t\t\t// error, and the requirement path (if any) from rs.rootModules to the\n+\t\t\t\t// tryUpgrade module path. Return a *mvs.BuildListError showing the\n+\t\t\t\t// concatenation of the paths (with an upgrade in the middle).\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tfor _, r := range upgradeGraph.BuildList() {\n+\t\t\t// Upgrading to m would upgrade to r, and the caller requested that we\n+\t\t\t// try to upgrade to m, so it's ok to upgrade to r.\n+\t\t\tallow(r)\n+\t\t}\n+\t}\n+\n+\tif len(mustSelect) > 0 {\n+\t\tmustGraph, err := readModGraph(ctx, depth, mustSelect)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tfor _, r := range mustGraph.BuildList() {\n+\t\t\t// Some module in mustSelect requires r, so we must allow at least r.Version\n+\t\t\t// unless it conflicts with an entry in mustSelect.\n+\t\t\tallow(r)\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// selectPotentiallyImportedModules increases the limiter-selected version of\n+// every module in rs that potentially provides a package imported (directly or\n+// indirectly) by the main module, and every module in tryUpgrade, toward the\n+// highest version seen in rs or tryUpgrade, but not above the maximums enforced\n+// by the limiter.\n+//\n+// It returns the list of module versions selected by the limiter, sorted by\n+// path, along with a boolean indicating whether that list is different from the\n+// list of modules read from rs.\n+func selectPotentiallyImportedModules(ctx context.Context, limiter *versionLimiter, rs *Requirements, tryUpgrade []module.Version) (mods []module.Version, changed bool, err error) {\n+\tfor _, m := range tryUpgrade {\n+\t\tif err := limiter.UpgradeToward(ctx, m); err != nil {\n+\t\t\treturn nil, false, err\n+\t\t}\n+\t}\n+\n+\tvar initial []module.Version\n+\tif rs.depth == eager {\n+\t\tmg, err := rs.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, false, err\n+\t\t}\n+\t\tinitial = mg.BuildList()[1:]\n+\t} else {\n+\t\tinitial = rs.rootModules\n+\t}\n+\tfor _, m := range initial {\n+\t\tif err := limiter.UpgradeToward(ctx, m); err != nil {\n+\t\t\treturn nil, false, err\n+\t\t}\n+\t}\n+\n+\tmods = make([]module.Version, 0, len(limiter.selected))\n+\tfor path, v := range limiter.selected {\n+\t\tif v != \"none\" && path != Target.Path {\n+\t\t\tmods = append(mods, module.Version{Path: path, Version: v})\n+\t\t}\n+\t}\n+\n+\t// We've identified acceptable versions for each of the modules, but those\n+\t// versions are not necessarily consistent with each other: one upgraded or\n+\t// downgraded module may require a higher (but still allowed) version of\n+\t// another. The lower version may require extraneous dependencies that aren't\n+\t// actually relevant, so we need to compute the actual selected versions.\n+\tmg, err := readModGraph(ctx, rs.depth, mods)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\tmods = make([]module.Version, 0, len(limiter.selected))\n+\tfor path, _ := range limiter.selected {\n+\t\tif path != Target.Path {\n+\t\t\tif v := mg.Selected(path); v != \"none\" {\n+\t\t\t\tmods = append(mods, module.Version{Path: path, Version: v})\n+\t\t\t}\n+\t\t}\n+\t}\n+\tmodule.Sort(mods)\n+\n+\tchanged = !reflect.DeepEqual(mods, initial)\n+\n+\treturn mods, changed, err\n+}\n+\n+// A versionLimiter tracks the versions that may be selected for each module\n+// subject to constraints on the maximum versions of transitive dependencies.\n+type versionLimiter struct {\n+\t// depth is the depth at which the dependencies of the modules passed to\n+\t// Select and UpgradeToward are loaded.\n+\tdepth modDepth\n+\n+\t// max maps each module path to the maximum version that may be selected for\n+\t// that path.\n+\t//\n+\t// Paths with no entry are unrestricted, and we assume that they will not be\n+\t// promoted to root dependencies (so will not contribute dependencies if the\n+\t// main module is lazy).\n+\tmax map[string]string\n+\n+\t// selected maps each module path to a version of that path (if known) whose\n+\t// transitive dependencies do not violate any max version. The version kept\n+\t// is the highest one found during any call to UpgradeToward for the given\n+\t// module path.\n+\t//\n+\t// If a higher acceptable version is found during a call to UpgradeToward for\n+\t// some *other* module path, that does not update the selected version.\n+\t// Ignoring those versions keeps the downgrades computed for two modules\n+\t// together close to the individual downgrades that would be computed for each\n+\t// module in isolation. (The only way one module can affect another is if the\n+\t// final downgraded version of the one module explicitly requires a higher\n+\t// version of the other.)\n+\t//\n+\t// Version \"none\" of every module is always known not to violate any max\n+\t// version, so paths at version \"none\" are omitted.\n+\tselected map[string]string\n+\n+\t// dqReason records whether and why each each encountered version is\n+\t// disqualified.\n+\tdqReason map[module.Version]dqState\n+\n+\t// requiring maps each not-yet-disqualified module version to the versions\n+\t// that directly require it. If that version becomes disqualified, the\n+\t// disqualification will be propagated to all of the versions in the list.\n+\trequiring map[module.Version][]module.Version\n+}\n+\n+// A dqState indicates whether and why a module version is \u201cdisqualified\u201d from\n+// being used in a way that would incorporate its requirements.\n+//\n+// The zero dqState indicates that the module version is not known to be\n+// disqualified, either because it is ok or because we are currently traversing\n+// a cycle that includes it.\n+type dqState struct {\n+\terr      error          // if non-nil, disqualified because the requirements of the module could not be read\n+\tconflict module.Version // disqualified because the module (transitively) requires dep, which exceeds the maximum version constraint for its path\n+}\n+\n+func (dq dqState) isDisqualified() bool {\n+\treturn dq != dqState{}\n+}\n+\n+// newVersionLimiter returns a versionLimiter that restricts the module paths\n+// that appear as keys in max.\n+//\n+// max maps each module path to its maximum version; paths that are not present\n+// in the map are unrestricted. The limiter assumes that unrestricted paths will\n+// not be promoted to root dependencies.\n+//\n+// If depth is lazy, then if a module passed to UpgradeToward or Select is\n+// itself lazy, its unrestricted dependencies are skipped when scanning\n+// requirements.\n+func newVersionLimiter(depth modDepth, max map[string]string) *versionLimiter {\n+\treturn &versionLimiter{\n+\t\tdepth:     depth,\n+\t\tmax:       max,\n+\t\tselected:  map[string]string{Target.Path: Target.Version},\n+\t\tdqReason:  map[module.Version]dqState{},\n+\t\trequiring: map[module.Version][]module.Version{},\n+\t}\n+}\n+\n+// UpgradeToward attempts to upgrade the selected version of m.Path as close as\n+// possible to m.Version without violating l's maximum version limits.\n+//\n+// If depth is lazy and m itself is lazy, the the dependencies of unrestricted\n+// dependencies of m will not be followed.\n+func (l *versionLimiter) UpgradeToward(ctx context.Context, m module.Version) error {\n+\tselected, ok := l.selected[m.Path]\n+\tif ok {\n+\t\tif cmpVersion(selected, m.Version) >= 0 {\n+\t\t\t// The selected version is already at least m, so no upgrade is needed.\n+\t\t\treturn nil\n+\t\t}\n+\t} else {\n+\t\tselected = \"none\"\n+\t}\n+\n+\tif l.check(m, l.depth).isDisqualified() {\n+\t\tcandidates, err := versions(ctx, m.Path, CheckAllowed)\n+\t\tif err != nil {\n+\t\t\t// This is likely a transient error reaching the repository,\n+\t\t\t// rather than a permanent error with the retrieved version.\n+\t\t\t//\n+\t\t\t// TODO(golang.org/issue/31730, golang.org/issue/30134):\n+\t\t\t// decode what to do based on the actual error.\n+\t\t\treturn err\n+\t\t}\n+\n+\t\t// Skip to candidates < m.Version.\n+\t\ti := sort.Search(len(candidates), func(i int) bool {\n+\t\t\treturn semver.Compare(candidates[i], m.Version) >= 0\n+\t\t})\n+\t\tcandidates = candidates[:i]\n+\n+\t\tfor l.check(m, l.depth).isDisqualified() {\n+\t\t\tn := len(candidates)\n+\t\t\tif n == 0 || cmpVersion(selected, candidates[n-1]) >= 0 {\n+\t\t\t\t// We couldn't find a suitable candidate above the already-selected version.\n+\t\t\t\t// Retain that version unmodified.\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tm.Version, candidates = candidates[n-1], candidates[:n-1]\n+\t\t}\n+\t}\n+\n+\tl.selected[m.Path] = m.Version\n+\treturn nil\n+}\n+\n+// Select attempts to set the selected version of m.Path to exactly m.Version.\n+func (l *versionLimiter) Select(m module.Version) (conflict module.Version, err error) {\n+\tdq := l.check(m, l.depth)\n+\tif !dq.isDisqualified() {\n+\t\tl.selected[m.Path] = m.Version\n+\t}\n+\treturn dq.conflict, dq.err\n+}\n+\n+// check determines whether m (or its transitive dependencies) would violate l's\n+// maximum version limits if added to the module requirement graph.\n+//\n+// If depth is lazy and m itself is lazy, then the dependencies of unrestricted\n+// dependencies of m will not be followed. If the lazy loading invariants hold\n+// for the main module up to this point, the packages in those modules are at\n+// best only imported by tests of dependencies that are themselves loaded from\n+// outside modules. Although we would like to keep 'go test all' as reproducible\n+// as is feasible, we don't want to retain test dependencies that are only\n+// marginally relevant at best.\n+func (l *versionLimiter) check(m module.Version, depth modDepth) dqState {\n+\tif m.Version == \"none\" || m == Target {\n+\t\t// version \"none\" has no requirements, and the dependencies of Target are\n+\t\t// tautological.\n+\t\treturn dqState{}\n+\t}\n+\n+\tif dq, seen := l.dqReason[m]; seen {\n+\t\treturn dq\n+\t}\n+\tl.dqReason[m] = dqState{}\n+\n+\tif max, ok := l.max[m.Path]; ok && cmpVersion(m.Version, max) > 0 {\n+\t\treturn l.disqualify(m, dqState{conflict: m})\n+\t}\n+\n+\tsummary, err := goModSummary(m)\n+\tif err != nil {\n+\t\t// If we can't load the requirements, we couldn't load the go.mod file.\n+\t\t// There are a number of reasons this can happen, but this usually\n+\t\t// means an older version of the module had a missing or invalid\n+\t\t// go.mod file. For example, if example.com/mod released v2.0.0 before\n+\t\t// migrating to modules (v2.0.0+incompatible), then added a valid go.mod\n+\t\t// in v2.0.1, downgrading from v2.0.1 would cause this error.\n+\t\t//\n+\t\t// TODO(golang.org/issue/31730, golang.org/issue/30134): if the error\n+\t\t// is transient (we couldn't download go.mod), return the error from\n+\t\t// Downgrade. Currently, we can't tell what kind of error it is.\n+\t\treturn l.disqualify(m, dqState{err: err})\n+\t}\n+\n+\tif summary.depth == eager {\n+\t\tdepth = eager\n+\t}\n+\tfor _, r := range summary.require {\n+\t\tif depth == lazy {\n+\t\t\tif _, restricted := l.max[r.Path]; !restricted {\n+\t\t\t\t// r.Path is unrestricted, so we don't care at what version it is\n+\t\t\t\t// selected. We assume that r.Path will not become a root dependency, so\n+\t\t\t\t// since m is lazy, r's dependencies won't be followed.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tif dq := l.check(r, depth); dq.isDisqualified() {\n+\t\t\treturn l.disqualify(m, dq)\n+\t\t}\n+\n+\t\t// r and its dependencies are (perhaps provisionally) ok.\n+\t\t//\n+\t\t// However, if there are cycles in the requirement graph, we may have only\n+\t\t// checked a portion of the requirement graph so far, and r (and thus m) may\n+\t\t// yet be disqualified by some path we have not yet visited. Remember this edge\n+\t\t// so that we can disqualify m and its dependents if that occurs.\n+\t\tl.requiring[r] = append(l.requiring[r], m)\n+\t}\n+\n+\treturn dqState{}\n+}\n+\n+// disqualify records that m (or one of its transitive dependencies)\n+// violates l's maximum version limits.\n+func (l *versionLimiter) disqualify(m module.Version, dq dqState) dqState {\n+\tif dq := l.dqReason[m]; dq.isDisqualified() {\n+\t\treturn dq\n+\t}\n+\tl.dqReason[m] = dq\n+\n+\tfor _, p := range l.requiring[m] {\n+\t\tl.disqualify(p, dqState{conflict: m})\n+\t}\n+\t// Now that we have disqualified the modules that depend on m, we can forget\n+\t// about them \u2014 we won't need to disqualify them again.\n+\tdelete(l.requiring, m)\n+\treturn dq\n+}"}, {"sha": "886ad62bd90cb6a64113732336d9affe117a98ef", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -46,7 +46,7 @@ marking the root of the main (current) module.\n The go.mod file format is described in detail at\n https://golang.org/ref/mod#go-mod-file.\n \n-To create a new go.mod file, use 'go help init'. For details see\n+To create a new go.mod file, use 'go mod init'. For details see\n 'go help mod init' or https://golang.org/ref/mod#go-mod-init.\n \n To add missing module requirements or remove unneeded requirements,"}, {"sha": "d2bbe5cbe0b1eae58ac5a041792d0b4d0e8a3c85", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 171, "deletions": 85, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"internal/goroot\"\n \t\"io/fs\"\n \t\"os\"\n+\tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n@@ -60,7 +61,7 @@ func (e *ImportMissingError) Error() string {\n \n \t\tif e.replaced.Path != \"\" {\n \t\t\tsuggestArg := e.replaced.Path\n-\t\t\tif !modfetch.IsZeroPseudoVersion(e.replaced.Version) {\n+\t\t\tif !module.IsZeroPseudoVersion(e.replaced.Version) {\n \t\t\t\tsuggestArg = e.replaced.String()\n \t\t\t}\n \t\t\treturn fmt.Sprintf(\"module %s provides package %s and is replaced but not required; to add it:\\n\\tgo get %s\", e.replaced.Path, e.Path, suggestArg)\n@@ -127,6 +128,23 @@ func (e *AmbiguousImportError) Error() string {\n \treturn buf.String()\n }\n \n+// A DirectImportFromImplicitDependencyError indicates a package directly\n+// imported by a package or test in the main module that is satisfied by a\n+// dependency that is not explicit in the main module's go.mod file.\n+type DirectImportFromImplicitDependencyError struct {\n+\tImporterPath string\n+\tImportedPath string\n+\tModule       module.Version\n+}\n+\n+func (e *DirectImportFromImplicitDependencyError) Error() string {\n+\treturn fmt.Sprintf(\"package %s imports %s from implicitly required module; to add missing requirements, run:\\n\\tgo get %s@%s\", e.ImporterPath, e.ImportedPath, e.Module.Path, e.Module.Version)\n+}\n+\n+func (e *DirectImportFromImplicitDependencyError) ImportPath() string {\n+\treturn e.ImporterPath\n+}\n+\n // ImportMissingSumError is reported in readonly mode when we need to check\n // if a module contains a package, but we don't have a sum for its .zip file.\n // We might need sums for multiple modules to verify the package is unique.\n@@ -160,11 +178,13 @@ func (e *ImportMissingSumError) Error() string {\n \t\t// Importing package is unknown, or the missing package was named on the\n \t\t// command line. Recommend 'go mod download' for the modules that could\n \t\t// provide the package, since that shouldn't change go.mod.\n-\t\targs := make([]string, len(e.mods))\n-\t\tfor i, mod := range e.mods {\n-\t\t\targs[i] = mod.Path\n+\t\tif len(e.mods) > 0 {\n+\t\t\targs := make([]string, len(e.mods))\n+\t\t\tfor i, mod := range e.mods {\n+\t\t\t\targs[i] = mod.Path\n+\t\t\t}\n+\t\t\thint = fmt.Sprintf(\"; to add:\\n\\tgo mod download %s\", strings.Join(args, \" \"))\n \t\t}\n-\t\thint = fmt.Sprintf(\"; to add:\\n\\tgo mod download %s\", strings.Join(args, \" \"))\n \t} else {\n \t\t// Importing package is known (common case). Recommend 'go get' on the\n \t\t// current version of the importing package.\n@@ -202,28 +222,31 @@ func (e *invalidImportError) Unwrap() error {\n \treturn e.err\n }\n \n-// importFromBuildList finds the module and directory in the build list\n-// containing the package with the given import path. The answer must be unique:\n-// importFromBuildList returns an error if multiple modules attempt to provide\n-// the same package.\n+// importFromModules finds the module and directory in the dependency graph of\n+// rs containing the package with the given import path. If mg is nil,\n+// importFromModules attempts to locate the module using only the main module\n+// and the roots of rs before it loads the full graph.\n //\n-// importFromBuildList can return a module with an empty m.Path, for packages in\n+// The answer must be unique: importFromModules returns an error if multiple\n+// modules are observed to provide the same package.\n+//\n+// importFromModules can return a module with an empty m.Path, for packages in\n // the standard library.\n //\n-// importFromBuildList can return an empty directory string, for fake packages\n+// importFromModules can return an empty directory string, for fake packages\n // like \"C\" and \"unsafe\".\n //\n-// If the package cannot be found in buildList,\n-// importFromBuildList returns an *ImportMissingError.\n-func importFromBuildList(ctx context.Context, path string, buildList []module.Version) (m module.Version, dir string, err error) {\n+// If the package is not present in any module selected from the requirement\n+// graph, importFromModules returns an *ImportMissingError.\n+func importFromModules(ctx context.Context, path string, rs *Requirements, mg *ModuleGraph) (m module.Version, dir string, err error) {\n \tif strings.Contains(path, \"@\") {\n \t\treturn module.Version{}, \"\", fmt.Errorf(\"import path should not have @version\")\n \t}\n \tif build.IsLocalImport(path) {\n \t\treturn module.Version{}, \"\", fmt.Errorf(\"relative import not supported\")\n \t}\n-\tif path == \"C\" || path == \"unsafe\" {\n-\t\t// There's no directory for import \"C\" or import \"unsafe\".\n+\tif path == \"C\" {\n+\t\t// There's no directory for import \"C\".\n \t\treturn module.Version{}, \"\", nil\n \t}\n \t// Before any further lookup, check that the path is valid.\n@@ -269,66 +292,122 @@ func importFromBuildList(ctx context.Context, path string, buildList []module.Ve\n \t// Check each module on the build list.\n \tvar dirs []string\n \tvar mods []module.Version\n-\tvar sumErrMods []module.Version\n-\tfor _, m := range buildList {\n-\t\tif !maybeInModule(path, m.Path) {\n-\t\t\t// Avoid possibly downloading irrelevant modules.\n-\t\t\tcontinue\n-\t\t}\n-\t\tneedSum := true\n-\t\troot, isLocal, err := fetch(ctx, m, needSum)\n-\t\tif err != nil {\n-\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n-\t\t\t\t// We are missing a sum needed to fetch a module in the build list.\n-\t\t\t\t// We can't verify that the package is unique, and we may not find\n-\t\t\t\t// the package at all. Keep checking other modules to decide which\n-\t\t\t\t// error to report. Multiple sums may be missing if we need to look in\n-\t\t\t\t// multiple nested modules to resolve the import.\n-\t\t\t\tsumErrMods = append(sumErrMods, m)\n+\n+\t// Iterate over possible modules for the path, not all selected modules.\n+\t// Iterating over selected modules would make the overall loading time\n+\t// O(M \u00d7 P) for M modules providing P imported packages, whereas iterating\n+\t// over path prefixes is only O(P \u00d7 k) with maximum path depth k. For\n+\t// large projects both M and P may be very large (note that M \u2264 P), but k\n+\t// will tend to remain smallish (if for no other reason than filesystem\n+\t// path limitations).\n+\t//\n+\t// We perform this iteration either one or two times. If mg is initially nil,\n+\t// then we first attempt to load the package using only the main module and\n+\t// its root requirements. If that does not identify the package, or if mg is\n+\t// already non-nil, then we attempt to load the package using the full\n+\t// requirements in mg.\n+\tfor {\n+\t\tvar sumErrMods []module.Version\n+\t\tfor prefix := path; prefix != \".\"; prefix = pathpkg.Dir(prefix) {\n+\t\t\tvar (\n+\t\t\t\tv  string\n+\t\t\t\tok bool\n+\t\t\t)\n+\t\t\tif mg == nil {\n+\t\t\t\tv, ok = rs.rootSelected(prefix)\n+\t\t\t} else {\n+\t\t\t\tv, ok = mg.Selected(prefix), true\n+\t\t\t}\n+\t\t\tif !ok || v == \"none\" {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\t// Report fetch error.\n-\t\t\t// Note that we don't know for sure this module is necessary,\n-\t\t\t// but it certainly _could_ provide the package, and even if we\n-\t\t\t// continue the loop and find the package in some other module,\n-\t\t\t// we need to look at this module to make sure the import is\n-\t\t\t// not ambiguous.\n-\t\t\treturn module.Version{}, \"\", err\n+\t\t\tm := module.Version{Path: prefix, Version: v}\n+\n+\t\t\tneedSum := true\n+\t\t\troot, isLocal, err := fetch(ctx, m, needSum)\n+\t\t\tif err != nil {\n+\t\t\t\tif sumErr := (*sumMissingError)(nil); errors.As(err, &sumErr) {\n+\t\t\t\t\t// We are missing a sum needed to fetch a module in the build list.\n+\t\t\t\t\t// We can't verify that the package is unique, and we may not find\n+\t\t\t\t\t// the package at all. Keep checking other modules to decide which\n+\t\t\t\t\t// error to report. Multiple sums may be missing if we need to look in\n+\t\t\t\t\t// multiple nested modules to resolve the import; we'll report them all.\n+\t\t\t\t\tsumErrMods = append(sumErrMods, m)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Report fetch error.\n+\t\t\t\t// Note that we don't know for sure this module is necessary,\n+\t\t\t\t// but it certainly _could_ provide the package, and even if we\n+\t\t\t\t// continue the loop and find the package in some other module,\n+\t\t\t\t// we need to look at this module to make sure the import is\n+\t\t\t\t// not ambiguous.\n+\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t}\n+\t\t\tif dir, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n+\t\t\t\treturn module.Version{}, \"\", err\n+\t\t\t} else if ok {\n+\t\t\t\tmods = append(mods, m)\n+\t\t\t\tdirs = append(dirs, dir)\n+\t\t\t}\n \t\t}\n-\t\tif dir, ok, err := dirInModule(path, m.Path, root, isLocal); err != nil {\n-\t\t\treturn module.Version{}, \"\", err\n-\t\t} else if ok {\n-\t\t\tmods = append(mods, m)\n-\t\t\tdirs = append(dirs, dir)\n+\n+\t\tif len(mods) > 1 {\n+\t\t\t// We produce the list of directories from longest to shortest candidate\n+\t\t\t// module path, but the AmbiguousImportError should report them from\n+\t\t\t// shortest to longest. Reverse them now.\n+\t\t\tfor i := 0; i < len(mods)/2; i++ {\n+\t\t\t\tj := len(mods) - 1 - i\n+\t\t\t\tmods[i], mods[j] = mods[j], mods[i]\n+\t\t\t\tdirs[i], dirs[j] = dirs[j], dirs[i]\n+\t\t\t}\n+\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n \t\t}\n-\t}\n-\tif len(mods) > 1 {\n-\t\treturn module.Version{}, \"\", &AmbiguousImportError{importPath: path, Dirs: dirs, Modules: mods}\n-\t}\n-\tif len(sumErrMods) > 0 {\n-\t\treturn module.Version{}, \"\", &ImportMissingSumError{\n-\t\t\timportPath: path,\n-\t\t\tmods:       sumErrMods,\n-\t\t\tfound:      len(mods) > 0,\n+\n+\t\tif len(sumErrMods) > 0 {\n+\t\t\tfor i := 0; i < len(sumErrMods)/2; i++ {\n+\t\t\t\tj := len(sumErrMods) - 1 - i\n+\t\t\t\tsumErrMods[i], sumErrMods[j] = sumErrMods[j], sumErrMods[i]\n+\t\t\t}\n+\t\t\treturn module.Version{}, \"\", &ImportMissingSumError{\n+\t\t\t\timportPath: path,\n+\t\t\t\tmods:       sumErrMods,\n+\t\t\t\tfound:      len(mods) > 0,\n+\t\t\t}\n \t\t}\n-\t}\n-\tif len(mods) == 1 {\n-\t\treturn mods[0], dirs[0], nil\n-\t}\n \n-\tvar queryErr error\n-\tif !HasModRoot() {\n-\t\tqueryErr = ErrNoModRoot\n+\t\tif len(mods) == 1 {\n+\t\t\treturn mods[0], dirs[0], nil\n+\t\t}\n+\n+\t\tif mg != nil {\n+\t\t\t// We checked the full module graph and still didn't find the\n+\t\t\t// requested package.\n+\t\t\tvar queryErr error\n+\t\t\tif !HasModRoot() {\n+\t\t\t\tqueryErr = ErrNoModRoot\n+\t\t\t}\n+\t\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr, isStd: pathIsStd}\n+\t\t}\n+\n+\t\t// So far we've checked the root dependencies.\n+\t\t// Load the full module graph and try again.\n+\t\tmg, err = rs.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\t// We might be missing one or more transitive (implicit) dependencies from\n+\t\t\t// the module graph, so we can't return an ImportMissingError here \u2014 one\n+\t\t\t// of the missing modules might actually contain the package in question,\n+\t\t\t// in which case we shouldn't go looking for it in some new dependency.\n+\t\t\treturn module.Version{}, \"\", err\n+\t\t}\n \t}\n-\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr, isStd: pathIsStd}\n }\n \n // queryImport attempts to locate a module that can be added to the current\n // build list to provide the package with the given import path.\n //\n // Unlike QueryPattern, queryImport prefers to add a replaced version of a\n // module *before* checking the proxies for a version to add.\n-func queryImport(ctx context.Context, path string) (module.Version, error) {\n+func queryImport(ctx context.Context, path string, rs *Requirements) (module.Version, error) {\n \t// To avoid spurious remote fetches, try the latest replacement for each\n \t// module (golang.org/issue/26241).\n \tif index != nil {\n@@ -344,11 +423,20 @@ func queryImport(ctx context.Context, path string) (module.Version, error) {\n \t\t\t\t// used from within some other module, the user will be able to upgrade\n \t\t\t\t// the requirement to any real version they choose.\n \t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(mp); ok && len(pathMajor) > 0 {\n-\t\t\t\t\tmv = modfetch.ZeroPseudoVersion(pathMajor[1:])\n+\t\t\t\t\tmv = module.ZeroPseudoVersion(pathMajor[1:])\n \t\t\t\t} else {\n-\t\t\t\t\tmv = modfetch.ZeroPseudoVersion(\"v0\")\n+\t\t\t\t\tmv = module.ZeroPseudoVersion(\"v0\")\n \t\t\t\t}\n \t\t\t}\n+\t\t\tmg, err := rs.Graph(ctx)\n+\t\t\tif err != nil {\n+\t\t\t\treturn module.Version{}, err\n+\t\t\t}\n+\t\t\tif cmpVersion(mg.Selected(mp), mv) >= 0 {\n+\t\t\t\t// We can't resolve the import by adding mp@mv to the module graph,\n+\t\t\t\t// because the selected version of mp is already at least mv.\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tmods = append(mods, module.Version{Path: mp, Version: mv})\n \t\t}\n \n@@ -417,7 +505,12 @@ func queryImport(ctx context.Context, path string) (module.Version, error) {\n \t// and return m, dir, ImpportMissingError.\n \tfmt.Fprintf(os.Stderr, \"go: finding module for package %s\\n\", path)\n \n-\tcandidates, err := QueryPackages(ctx, path, \"latest\", Selected, CheckAllowed)\n+\tmg, err := rs.Graph(ctx)\n+\tif err != nil {\n+\t\treturn module.Version{}, err\n+\t}\n+\n+\tcandidates, err := QueryPackages(ctx, path, \"latest\", mg.Selected, CheckAllowed)\n \tif err != nil {\n \t\tif errors.Is(err, fs.ErrNotExist) {\n \t\t\t// Return \"cannot find module providing package [\u2026]\" instead of whatever\n@@ -430,28 +523,21 @@ func queryImport(ctx context.Context, path string) (module.Version, error) {\n \n \tcandidate0MissingVersion := \"\"\n \tfor i, c := range candidates {\n-\t\tcm := c.Mod\n-\t\tcanAdd := true\n-\t\tfor _, bm := range buildList {\n-\t\t\tif bm.Path == cm.Path && semver.Compare(bm.Version, cm.Version) > 0 {\n-\t\t\t\t// QueryPattern proposed that we add module cm to provide the package,\n-\t\t\t\t// but we already depend on a newer version of that module (and we don't\n-\t\t\t\t// have the package).\n-\t\t\t\t//\n-\t\t\t\t// This typically happens when a package is present at the \"@latest\"\n-\t\t\t\t// version (e.g., v1.0.0) of a module, but we have a newer version\n-\t\t\t\t// of the same module in the build list (e.g., v1.0.1-beta), and\n-\t\t\t\t// the package is not present there.\n-\t\t\t\tcanAdd = false\n-\t\t\t\tif i == 0 {\n-\t\t\t\t\tcandidate0MissingVersion = bm.Version\n-\t\t\t\t}\n-\t\t\t\tbreak\n+\t\tif v := mg.Selected(c.Mod.Path); semver.Compare(v, c.Mod.Version) > 0 {\n+\t\t\t// QueryPattern proposed that we add module c.Mod to provide the package,\n+\t\t\t// but we already depend on a newer version of that module (and that\n+\t\t\t// version doesn't have the package).\n+\t\t\t//\n+\t\t\t// This typically happens when a package is present at the \"@latest\"\n+\t\t\t// version (e.g., v1.0.0) of a module, but we have a newer version\n+\t\t\t// of the same module in the build list (e.g., v1.0.1-beta), and\n+\t\t\t// the package is not present there.\n+\t\t\tif i == 0 {\n+\t\t\t\tcandidate0MissingVersion = v\n \t\t\t}\n+\t\t\tcontinue\n \t\t}\n-\t\tif canAdd {\n-\t\t\treturn cm, nil\n-\t\t}\n+\t\treturn c.Mod, nil\n \t}\n \treturn module.Version{}, &ImportMissingError{\n \t\tPath:              path,"}, {"sha": "98145887e9dcc5c6b18aa071f08c27ce7c4681ca", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -69,11 +69,12 @@ func TestQueryImport(t *testing.T) {\n \tRootMode = NoRoot\n \n \tctx := context.Background()\n+\trs := newRequirements(eager, nil, nil)\n \n \tfor _, tt := range importTests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n \t\t\t// Note that there is no build list, so Import should always fail.\n-\t\t\tm, err := queryImport(ctx, tt.path)\n+\t\t\tm, err := queryImport(ctx, tt.path, rs)\n \n \t\t\tif tt.err == \"\" {\n \t\t\t\tif err != nil {"}, {"sha": "a8cbd9fe16d1862d673de85f4f9e301461ab07d3", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 355, "deletions": 238, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -15,31 +15,46 @@ import (\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n-\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modconv\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/str\"\n \n \t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n \t\"golang.org/x/mod/semver\"\n )\n \n+// Variables set by other packages.\n+//\n+// TODO(#40775): See if these can be plumbed as explicit parameters.\n+var (\n+\t// RootMode determines whether a module root is needed.\n+\tRootMode Root\n+\n+\t// ForceUseModules may be set to force modules to be enabled when\n+\t// GO111MODULE=auto or to report an error when GO111MODULE=off.\n+\tForceUseModules bool\n+\n+\tallowMissingModuleImports bool\n+)\n+\n+// Variables set in Init.\n var (\n \tinitialized bool\n+\tmodRoot     string\n+\tgopath      string\n+)\n \n-\tmodRoot string\n-\tTarget  module.Version\n+// Variables set in initTarget (during {Load,Create}ModFile).\n+var (\n+\tTarget module.Version\n \n \t// targetPrefix is the path prefix for packages in Target, without a trailing\n \t// slash. For most modules, targetPrefix is just Target.Path, but the\n@@ -49,25 +64,14 @@ var (\n \t// targetInGorootSrc caches whether modRoot is within GOROOT/src.\n \t// The \"std\" module is special within GOROOT/src, but not otherwise.\n \ttargetInGorootSrc bool\n-\n-\tgopath string\n-\n-\t// RootMode determines whether a module root is needed.\n-\tRootMode Root\n-\n-\t// ForceUseModules may be set to force modules to be enabled when\n-\t// GO111MODULE=auto or to report an error when GO111MODULE=off.\n-\tForceUseModules bool\n-\n-\tallowMissingModuleImports bool\n )\n \n type Root int\n \n const (\n \t// AutoRoot is the default for most commands. modload.Init will look for\n \t// a go.mod file in the current directory or any parent. If none is found,\n-\t// modules may be disabled (GO111MODULE=on) or commands may run in a\n+\t// modules may be disabled (GO111MODULE=auto) or commands may run in a\n \t// limited module mode.\n \tAutoRoot Root = iota\n \n@@ -82,7 +86,7 @@ const (\n \n // ModFile returns the parsed go.mod file.\n //\n-// Note that after calling LoadPackages or LoadAllModules,\n+// Note that after calling LoadPackages or LoadModGraph,\n // the require statements in the modfile.File are no longer\n // the source of truth and will be ignored: edits made directly\n // will be lost at the next call to WriteGoMod.\n@@ -131,7 +135,7 @@ func Init() {\n \t\treturn\n \t}\n \n-\tif err := fsys.Init(base.Cwd); err != nil {\n+\tif err := fsys.Init(base.Cwd()); err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n@@ -159,7 +163,11 @@ func Init() {\n \t// assume they know what they are doing and don't step on it.\n \t// But default to turning off ControlMaster.\n \tif os.Getenv(\"GIT_SSH\") == \"\" && os.Getenv(\"GIT_SSH_COMMAND\") == \"\" {\n-\t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n+\t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no -o BatchMode=yes\")\n+\t}\n+\n+\tif os.Getenv(\"GCM_INTERACTIVE\") == \"\" {\n+\t\tos.Setenv(\"GCM_INTERACTIVE\", \"never\")\n \t}\n \n \tif modRoot != \"\" {\n@@ -171,7 +179,7 @@ func Init() {\n \t\t}\n \t\tmodRoot = \"\"\n \t} else {\n-\t\tmodRoot = findModuleRoot(base.Cwd)\n+\t\tmodRoot = findModuleRoot(base.Cwd())\n \t\tif modRoot == \"\" {\n \t\t\tif cfg.ModFile != \"\" {\n \t\t\t\tbase.Fatalf(\"go: cannot find main module, but -modfile was set.\\n\\t-modfile cannot be used to set the module root directory.\")\n@@ -268,7 +276,7 @@ func WillBeEnabled() bool {\n \t\treturn false\n \t}\n \n-\tif modRoot := findModuleRoot(base.Cwd); modRoot == \"\" {\n+\tif modRoot := findModuleRoot(base.Cwd()); modRoot == \"\" {\n \t\t// GO111MODULE is 'auto', and we can't find a module root.\n \t\t// Stay in GOPATH mode.\n \t\treturn false\n@@ -327,8 +335,8 @@ func die() {\n \tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n-\tif dir, name := findAltConfig(base.Cwd); dir != \"\" {\n-\t\trel, err := filepath.Rel(base.Cwd, dir)\n+\tif dir, name := findAltConfig(base.Cwd()); dir != \"\" {\n+\t\trel, err := filepath.Rel(base.Cwd(), dir)\n \t\tif err != nil {\n \t\t\trel = dir\n \t\t}\n@@ -343,30 +351,77 @@ func die() {\n \n var ErrNoModRoot = errors.New(\"go.mod file not found in current directory or any parent directory; see 'go help modules'\")\n \n+type goModDirtyError struct{}\n+\n+func (goModDirtyError) Error() string {\n+\tif cfg.BuildModExplicit {\n+\t\treturn fmt.Sprintf(\"updates to go.mod needed, disabled by -mod=%v; to update it:\\n\\tgo mod tidy\", cfg.BuildMod)\n+\t}\n+\tif cfg.BuildModReason != \"\" {\n+\t\treturn fmt.Sprintf(\"updates to go.mod needed, disabled by -mod=%s\\n\\t(%s)\\n\\tto update it:\\n\\tgo mod tidy\", cfg.BuildMod, cfg.BuildModReason)\n+\t}\n+\treturn \"updates to go.mod needed; to update it:\\n\\tgo mod tidy\"\n+}\n+\n+var errGoModDirty error = goModDirtyError{}\n+\n // LoadModFile sets Target and, if there is a main module, parses the initial\n // build list from its go.mod file.\n //\n // LoadModFile may make changes in memory, like adding a go directive and\n-// ensuring requirements are consistent. WriteGoMod should be called later to\n-// write changes out to disk or report errors in readonly mode.\n+// ensuring requirements are consistent, and will write those changes back to\n+// disk unless DisallowWriteGoMod is in effect.\n //\n // As a side-effect, LoadModFile may change cfg.BuildMod to \"vendor\" if\n // -mod wasn't set explicitly and automatic vendoring should be enabled.\n-func LoadModFile(ctx context.Context) {\n-\tif len(buildList) > 0 {\n-\t\treturn\n+//\n+// If LoadModFile or CreateModFile has already been called, LoadModFile returns\n+// the existing in-memory requirements (rather than re-reading them from disk).\n+//\n+// LoadModFile checks the roots of the module graph for consistency with each\n+// other, but unlike LoadModGraph does not load the full module graph or check\n+// it for global consistency. Most callers outside of the modload package should\n+// use LoadModGraph instead.\n+func LoadModFile(ctx context.Context) *Requirements {\n+\trs, needCommit := loadModFile(ctx)\n+\tif needCommit {\n+\t\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\t}\n+\treturn rs\n+}\n+\n+// loadModFile is like LoadModFile, but does not implicitly commit the\n+// requirements back to disk after fixing inconsistencies.\n+//\n+// If needCommit is true, after the caller makes any other needed changes to the\n+// returned requirements they should invoke commitRequirements to fix any\n+// inconsistencies that may be present in the on-disk go.mod file.\n+func loadModFile(ctx context.Context) (rs *Requirements, needCommit bool) {\n+\tif requirements != nil {\n+\t\treturn requirements, false\n \t}\n \n \tInit()\n \tif modRoot == \"\" {\n \t\tTarget = module.Version{Path: \"command-line-arguments\"}\n \t\ttargetPrefix = \"command-line-arguments\"\n-\t\tbuildList = []module.Version{Target}\n-\t\treturn\n+\t\tgoVersion := LatestGoVersion()\n+\t\trawGoVersion.Store(Target, goVersion)\n+\t\trequirements = newRequirements(modDepthFromGoVersion(goVersion), nil, nil)\n+\t\treturn requirements, false\n \t}\n \n \tgomod := ModFilePath()\n-\tdata, err := lockedfile.Read(gomod)\n+\tvar data []byte\n+\tvar err error\n+\tif gomodActual, ok := fsys.OverlayPath(gomod); ok {\n+\t\t// Don't lock go.mod if it's part of the overlay.\n+\t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n+\t\t// in the overlay. See #44700.\n+\t\tdata, err = os.ReadFile(gomodActual)\n+\t} else {\n+\t\tdata, err = lockedfile.Read(gomodActual)\n+\t}\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n@@ -377,24 +432,53 @@ func LoadModFile(ctx context.Context) {\n \t\t// Errors returned by modfile.Parse begin with file:line.\n \t\tbase.Fatalf(\"go: errors parsing go.mod:\\n%s\\n\", err)\n \t}\n-\tmodFile = f\n-\tindex = indexModFile(data, f, fixed)\n-\n \tif f.Module == nil {\n \t\t// No module declaration. Must add module path.\n \t\tbase.Fatalf(\"go: no module declaration in go.mod. To specify the module path:\\n\\tgo mod edit -module=example.com/mod\")\n \t}\n \n-\tif err := checkModulePathLax(f.Module.Mod.Path); err != nil {\n+\tmodFile = f\n+\tinitTarget(f.Module.Mod)\n+\tindex = indexModFile(data, f, fixed)\n+\n+\tif err := module.CheckImportPath(f.Module.Mod.Path); err != nil {\n+\t\tif pathErr, ok := err.(*module.InvalidPathError); ok {\n+\t\t\tpathErr.Kind = \"module\"\n+\t\t}\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tsetDefaultBuildMod() // possibly enable automatic vendoring\n-\tmodFileToBuildList()\n+\trs = requirementsFromModFile(ctx)\n+\n \tif cfg.BuildMod == \"vendor\" {\n \t\treadVendorList()\n \t\tcheckVendorConsistency()\n+\t\trs.initVendor(vendorList)\n+\t}\n+\tif index.goVersionV == \"\" {\n+\t\t// TODO(#45551): Do something more principled instead of checking\n+\t\t// cfg.CmdName directly here.\n+\t\tif cfg.BuildMod == \"mod\" && cfg.CmdName != \"mod graph\" && cfg.CmdName != \"mod why\" {\n+\t\t\taddGoStmt(LatestGoVersion())\n+\t\t\tif go117EnableLazyLoading {\n+\t\t\t\t// We need to add a 'go' version to the go.mod file, but we must assume\n+\t\t\t\t// that its existing contents match something between Go 1.11 and 1.16.\n+\t\t\t\t// Go 1.11 through 1.16 have eager requirements, but the latest Go\n+\t\t\t\t// version uses lazy requirements instead \u2014 so we need to cnvert the\n+\t\t\t\t// requirements to be lazy.\n+\t\t\t\trs, err = convertDepth(ctx, rs, lazy)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\trawGoVersion.Store(Target, modFileGoVersion())\n+\t\t}\n \t}\n+\n+\trequirements = rs\n+\treturn requirements, true\n }\n \n // CreateModFile initializes a new module by creating a go.mod file.\n@@ -407,7 +491,7 @@ func LoadModFile(ctx context.Context) {\n // exactly the same as in the legacy configuration (for example, we can't get\n // packages at multiple versions from the same module).\n func CreateModFile(ctx context.Context, modPath string) {\n-\tmodRoot = base.Cwd\n+\tmodRoot = base.Cwd()\n \tInit()\n \tmodFilePath := ModFilePath()\n \tif _, err := fsys.Stat(modFilePath); err == nil {\n@@ -420,14 +504,23 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n-\t} else if err := checkModulePathLax(modPath); err != nil {\n+\t} else if err := module.CheckImportPath(modPath); err != nil {\n+\t\tif pathErr, ok := err.(*module.InvalidPathError); ok {\n+\t\t\tpathErr.Kind = \"module\"\n+\t\t\t// Same as build.IsLocalPath()\n+\t\t\tif pathErr.Path == \".\" || pathErr.Path == \"..\" ||\n+\t\t\t\tstrings.HasPrefix(pathErr.Path, \"./\") || strings.HasPrefix(pathErr.Path, \"../\") {\n+\t\t\t\tpathErr.Err = errors.New(\"is a local import path\")\n+\t\t\t}\n+\t\t}\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n \tfmt.Fprintf(os.Stderr, \"go: creating new go.mod: module %s\\n\", modPath)\n \tmodFile = new(modfile.File)\n \tmodFile.AddModuleStmt(modPath)\n-\taddGoStmt() // Add the go directive before converted module requirements.\n+\tinitTarget(modFile.Module.Mod)\n+\taddGoStmt(LatestGoVersion()) // Add the go directive before converted module requirements.\n \n \tconvertedFrom, err := convertLegacyConfig(modPath)\n \tif convertedFrom != \"\" {\n@@ -437,8 +530,7 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tmodFileToBuildList()\n-\tWriteGoMod()\n+\tcommitRequirements(ctx, modFileGoVersion(), requirementsFromModFile(ctx))\n \n \t// Suggest running 'go mod tidy' unless the project is empty. Even if we\n \t// imported all the correct requirements above, we're probably missing\n@@ -464,49 +556,6 @@ func CreateModFile(ctx context.Context, modPath string) {\n \t}\n }\n \n-// checkModulePathLax checks that the path meets some minimum requirements\n-// to avoid confusing users or the module cache. The requirements are weaker\n-// than those of module.CheckPath to allow room for weakening module path\n-// requirements in the future, but strong enough to help users avoid significant\n-// problems.\n-func checkModulePathLax(p string) error {\n-\t// TODO(matloob): Replace calls of this function in this CL with calls\n-\t// to module.CheckImportPath once it's been laxened, if it becomes laxened.\n-\t// See golang.org/issue/29101 for a discussion about whether to make CheckImportPath\n-\t// more lax or more strict.\n-\n-\terrorf := func(format string, args ...interface{}) error {\n-\t\treturn fmt.Errorf(\"invalid module path %q: %s\", p, fmt.Sprintf(format, args...))\n-\t}\n-\n-\t// Disallow shell characters \" ' * < > ? ` | to avoid triggering bugs\n-\t// with file systems and subcommands. Disallow file path separators : and \\\n-\t// because path separators other than / will confuse the module cache.\n-\t// See fileNameOK in golang.org/x/mod/module/module.go.\n-\tshellChars := \"`\" + `\\\"'*<>?|`\n-\tfsChars := `\\:`\n-\tif i := strings.IndexAny(p, shellChars); i >= 0 {\n-\t\treturn errorf(\"contains disallowed shell character %q\", p[i])\n-\t}\n-\tif i := strings.IndexAny(p, fsChars); i >= 0 {\n-\t\treturn errorf(\"contains disallowed path separator character %q\", p[i])\n-\t}\n-\n-\t// Ensure path.IsAbs and build.IsLocalImport are false, and that the path is\n-\t// invariant under path.Clean, also to avoid confusing the module cache.\n-\tif path.IsAbs(p) {\n-\t\treturn errorf(\"is an absolute path\")\n-\t}\n-\tif build.IsLocalImport(p) {\n-\t\treturn errorf(\"is a local import path\")\n-\t}\n-\tif path.Clean(p) != p {\n-\t\treturn errorf(\"is not clean\")\n-\t}\n-\n-\treturn nil\n-}\n-\n // fixVersion returns a modfile.VersionFixer implemented using the Query function.\n //\n // It resolves commit hashes and branch names to versions,\n@@ -559,34 +608,77 @@ func fixVersion(ctx context.Context, fixed *bool) modfile.VersionFixer {\n // when there is no module root. Normally, this is forbidden because it's slow\n // and there's no way to make the result reproducible, but some commands\n // like 'go get' are expected to do this.\n+//\n+// This function affects the default cfg.BuildMod when outside of a module,\n+// so it can only be called prior to Init.\n func AllowMissingModuleImports() {\n+\tif initialized {\n+\t\tpanic(\"AllowMissingModuleImports after Init\")\n+\t}\n \tallowMissingModuleImports = true\n }\n \n-// modFileToBuildList initializes buildList from the modFile.\n-func modFileToBuildList() {\n-\tTarget = modFile.Module.Mod\n-\ttargetPrefix = Target.Path\n-\tif rel := search.InDir(base.Cwd, cfg.GOROOTsrc); rel != \"\" {\n+// initTarget sets Target and associated variables according to modFile,\n+func initTarget(m module.Version) {\n+\tTarget = m\n+\ttargetPrefix = m.Path\n+\n+\tif rel := search.InDir(base.Cwd(), cfg.GOROOTsrc); rel != \"\" {\n \t\ttargetInGorootSrc = true\n-\t\tif Target.Path == \"std\" {\n+\t\tif m.Path == \"std\" {\n+\t\t\t// The \"std\" module in GOROOT/src is the Go standard library. Unlike other\n+\t\t\t// modules, the packages in the \"std\" module have no import-path prefix.\n+\t\t\t//\n+\t\t\t// Modules named \"std\" outside of GOROOT/src do not receive this special\n+\t\t\t// treatment, so it is possible to run 'go test .' in other GOROOTs to\n+\t\t\t// test individual packages using a combination of the modified package\n+\t\t\t// and the ordinary standard library.\n+\t\t\t// (See https://golang.org/issue/30756.)\n \t\t\ttargetPrefix = \"\"\n \t\t}\n \t}\n+}\n \n-\tlist := []module.Version{Target}\n+// requirementsFromModFile returns the set of non-excluded requirements from\n+// the global modFile.\n+func requirementsFromModFile(ctx context.Context) *Requirements {\n+\troots := make([]module.Version, 0, len(modFile.Require))\n+\tmPathCount := map[string]int{Target.Path: 1}\n+\tdirect := map[string]bool{}\n \tfor _, r := range modFile.Require {\n \t\tif index != nil && index.exclude[r.Mod] {\n \t\t\tif cfg.BuildMod == \"mod\" {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: dropping requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n \t\t\t} else {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: ignoring requirement on excluded version %s %s\\n\", r.Mod.Path, r.Mod.Version)\n \t\t\t}\n-\t\t} else {\n-\t\t\tlist = append(list, r.Mod)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\troots = append(roots, r.Mod)\n+\t\tmPathCount[r.Mod.Path]++\n+\t\tif !r.Indirect {\n+\t\t\tdirect[r.Mod.Path] = true\n+\t\t}\n+\t}\n+\tmodule.Sort(roots)\n+\trs := newRequirements(modDepthFromGoVersion(modFileGoVersion()), roots, direct)\n+\n+\t// If any module path appears more than once in the roots, we know that the\n+\t// go.mod file needs to be updated even though we have not yet loaded any\n+\t// transitive dependencies.\n+\tfor _, n := range mPathCount {\n+\t\tif n > 1 {\n+\t\t\tvar err error\n+\t\t\trs, err = updateRoots(ctx, rs.direct, rs, nil, nil, false)\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\t}\n+\t\t\tbreak\n \t\t}\n \t}\n-\tbuildList = list\n+\n+\treturn rs\n }\n \n // setDefaultBuildMod sets a default value for cfg.BuildMod if the -mod flag\n@@ -605,7 +697,11 @@ func setDefaultBuildMod() {\n \t\treturn\n \t}\n \tif modRoot == \"\" {\n-\t\tcfg.BuildMod = \"readonly\"\n+\t\tif allowMissingModuleImports {\n+\t\t\tcfg.BuildMod = \"mod\"\n+\t\t} else {\n+\t\t\tcfg.BuildMod = \"readonly\"\n+\t\t}\n \t\treturn\n \t}\n \n@@ -634,6 +730,17 @@ func setDefaultBuildMod() {\n // convertLegacyConfig imports module requirements from a legacy vendoring\n // configuration file, if one is present.\n func convertLegacyConfig(modPath string) (from string, err error) {\n+\tnoneSelected := func(path string) (version string) { return \"none\" }\n+\tqueryPackage := func(path, rev string) (module.Version, error) {\n+\t\tpkgMods, modOnly, err := QueryPattern(context.Background(), path, rev, noneSelected, nil)\n+\t\tif err != nil {\n+\t\t\treturn module.Version{}, err\n+\t\t}\n+\t\tif len(pkgMods) > 0 {\n+\t\t\treturn pkgMods[0].Mod, nil\n+\t\t}\n+\t\treturn modOnly.Mod, nil\n+\t}\n \tfor _, name := range altConfigs {\n \t\tcfg := filepath.Join(modRoot, name)\n \t\tdata, err := os.ReadFile(cfg)\n@@ -643,27 +750,57 @@ func convertLegacyConfig(modPath string) (from string, err error) {\n \t\t\t\treturn \"\", nil\n \t\t\t}\n \t\t\tcfg = filepath.ToSlash(cfg)\n-\t\t\terr := modconv.ConvertLegacyConfig(modFile, cfg, data)\n+\t\t\terr := modconv.ConvertLegacyConfig(modFile, cfg, data, queryPackage)\n \t\t\treturn name, err\n \t\t}\n \t}\n \treturn \"\", nil\n }\n \n-// addGoStmt adds a go directive to the go.mod file if it does not already include one.\n-// The 'go' version added, if any, is the latest version supported by this toolchain.\n-func addGoStmt() {\n+// addGoStmt adds a go directive to the go.mod file if it does not already\n+// include one. The 'go' version added, if any, is the latest version supported\n+// by this toolchain.\n+func addGoStmt(v string) {\n \tif modFile.Go != nil && modFile.Go.Version != \"\" {\n \t\treturn\n \t}\n+\tif err := modFile.AddGoStmt(v); err != nil {\n+\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\t}\n+\trawGoVersion.Store(Target, v)\n+}\n+\n+// LatestGoVersion returns the latest version of the Go language supported by\n+// this toolchain, like \"1.17\".\n+func LatestGoVersion() string {\n \ttags := build.Default.ReleaseTags\n \tversion := tags[len(tags)-1]\n \tif !strings.HasPrefix(version, \"go\") || !modfile.GoVersionRE.MatchString(version[2:]) {\n-\t\tbase.Fatalf(\"go: unrecognized default version %q\", version)\n+\t\tbase.Fatalf(\"go: internal error: unrecognized default version %q\", version)\n \t}\n-\tif err := modFile.AddGoStmt(version[2:]); err != nil {\n-\t\tbase.Fatalf(\"go: internal error: %v\", err)\n+\treturn version[2:]\n+}\n+\n+// priorGoVersion returns the Go major release immediately preceding v,\n+// or v itself if v is the first Go major release (1.0) or not a supported\n+// Go version.\n+func priorGoVersion(v string) string {\n+\tvTag := \"go\" + v\n+\ttags := build.Default.ReleaseTags\n+\tfor i, tag := range tags {\n+\t\tif tag == vTag {\n+\t\t\tif i == 0 {\n+\t\t\t\treturn v\n+\t\t\t}\n+\n+\t\t\tversion := tags[i-1]\n+\t\t\tif !strings.HasPrefix(version, \"go\") || !modfile.GoVersionRE.MatchString(version[2:]) {\n+\t\t\t\tbase.Fatalf(\"go: internal error: unrecognized version %q\", version)\n+\t\t\t}\n+\t\t\treturn version[2:]\n+\t\t}\n \t}\n+\treturn v\n }\n \n var altConfigs = []string{\n@@ -780,14 +917,8 @@ func findModulePath(dir string) (string, error) {\n \t\t}\n \t\tif rel := search.InDir(dir, filepath.Join(gpdir, \"src\")); rel != \"\" && rel != \".\" {\n \t\t\tpath := filepath.ToSlash(rel)\n-\t\t\t// TODO(matloob): replace this with module.CheckImportPath\n-\t\t\t// once it's been laxened.\n-\t\t\t// Only checkModulePathLax here. There are some unpublishable\n-\t\t\t// module names that are compatible with checkModulePathLax\n-\t\t\t// but they already work in GOPATH so don't break users\n-\t\t\t// trying to do a build with modules. gorelease will alert users\n-\t\t\t// publishing their modules to fix their paths.\n-\t\t\tif err := checkModulePathLax(path); err != nil {\n+\t\t\t// gorelease will alert users publishing their modules to fix their paths.\n+\t\t\tif err := module.CheckImportPath(path); err != nil {\n \t\t\t\tbadPathErr = err\n \t\t\t\tbreak\n \t\t\t}\n@@ -847,71 +978,51 @@ func AllowWriteGoMod() {\n \tallowWriteGoMod = true\n }\n \n-// MinReqs returns a Reqs with minimal additional dependencies of Target,\n-// as will be written to go.mod.\n-func MinReqs() mvs.Reqs {\n-\tretain := append([]string{}, additionalExplicitRequirements...)\n-\tfor _, m := range buildList[1:] {\n-\t\t_, explicit := index.require[m]\n-\t\tif explicit || loaded.direct[m.Path] {\n-\t\t\tretain = append(retain, m.Path)\n-\t\t}\n-\t}\n-\tsort.Strings(retain)\n-\tstr.Uniq(&retain)\n-\tmin, err := mvs.Req(Target, retain, &mvsReqs{buildList: buildList})\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+// WriteGoMod writes the current build list back to go.mod.\n+func WriteGoMod(ctx context.Context) {\n+\tif !allowWriteGoMod {\n+\t\tpanic(\"WriteGoMod called while disallowed\")\n \t}\n-\treturn &mvsReqs{buildList: append([]module.Version{Target}, min...)}\n+\tcommitRequirements(ctx, modFileGoVersion(), LoadModFile(ctx))\n }\n \n-// WriteGoMod writes the current build list back to go.mod.\n-func WriteGoMod() {\n-\t// If we're using -mod=vendor we basically ignored\n-\t// go.mod, so definitely don't try to write back our\n-\t// incomplete view of the world.\n-\tif !allowWriteGoMod || cfg.BuildMod == \"vendor\" {\n+// commitRequirements writes sets the global requirements variable to rs and\n+// writes its contents back to the go.mod file on disk.\n+func commitRequirements(ctx context.Context, goVersion string, rs *Requirements) {\n+\trequirements = rs\n+\n+\tif !allowWriteGoMod {\n+\t\t// Some package outside of modload promised to update the go.mod file later.\n \t\treturn\n \t}\n \n-\t// If we aren't in a module, we don't have anywhere to write a go.mod file.\n \tif modRoot == \"\" {\n+\t\t// We aren't in a module, so we don't have anywhere to write a go.mod file.\n \t\treturn\n \t}\n \n-\tif cfg.BuildMod != \"readonly\" {\n-\t\taddGoStmt()\n+\tvar list []*modfile.Require\n+\tfor _, m := range rs.rootModules {\n+\t\tlist = append(list, &modfile.Require{\n+\t\t\tMod:      m,\n+\t\t\tIndirect: !rs.direct[m.Path],\n+\t\t})\n \t}\n-\n-\tif loaded != nil {\n-\t\treqs := MinReqs()\n-\t\tmin, err := reqs.Required(Target)\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n-\t\t}\n-\t\tvar list []*modfile.Require\n-\t\tfor _, m := range min {\n-\t\t\tlist = append(list, &modfile.Require{\n-\t\t\t\tMod:      m,\n-\t\t\t\tIndirect: !loaded.direct[m.Path],\n-\t\t\t})\n-\t\t}\n+\tif goVersion != \"\" {\n+\t\tmodFile.AddGoStmt(goVersion)\n+\t}\n+\tif semver.Compare(\"v\"+modFileGoVersion(), separateIndirectVersionV) < 0 {\n \t\tmodFile.SetRequire(list)\n+\t} else {\n+\t\tmodFile.SetRequireSeparateIndirect(list)\n \t}\n \tmodFile.Cleanup()\n \n \tdirty := index.modFileIsDirty(modFile)\n-\tif dirty && cfg.BuildMod == \"readonly\" {\n+\tif dirty && cfg.BuildMod != \"mod\" {\n \t\t// If we're about to fail due to -mod=readonly,\n \t\t// prefer to report a dirty go.mod over a dirty go.sum\n-\t\tif cfg.BuildModExplicit {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n-\t\t} else if cfg.BuildModReason != \"\" {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\\n\\t(%s)\", cfg.BuildModReason)\n-\t\t} else {\n-\t\t\tbase.Fatalf(\"go: updates to go.mod needed; to update it:\\n\\tgo mod tidy\")\n-\t\t}\n+\t\tbase.Fatalf(\"go: %v\", errGoModDirty)\n \t}\n \n \tif !dirty && cfg.CmdName != \"mod tidy\" {\n@@ -920,7 +1031,14 @@ func WriteGoMod() {\n \t\t// Don't write go.mod, but write go.sum in case we added or trimmed sums.\n \t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n \t\tif cfg.CmdName != \"mod init\" {\n-\t\t\tmodfetch.WriteGoSum(keepSums(true))\n+\t\t\tmodfetch.WriteGoSum(keepSums(ctx, loaded, rs, addBuildListZipSums))\n+\t\t}\n+\t\treturn\n+\t}\n+\tgomod := ModFilePath()\n+\tif _, ok := fsys.OverlayPath(gomod); ok {\n+\t\tif dirty {\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed, but go.mod is part of the overlay specified with -overlay\")\n \t\t}\n \t\treturn\n \t}\n@@ -936,7 +1054,7 @@ func WriteGoMod() {\n \t\t// Update go.sum after releasing the side lock and refreshing the index.\n \t\t// 'go mod init' shouldn't write go.sum, since it will be incomplete.\n \t\tif cfg.CmdName != \"mod init\" {\n-\t\t\tmodfetch.WriteGoSum(keepSums(true))\n+\t\t\tmodfetch.WriteGoSum(keepSums(ctx, loaded, rs, addBuildListZipSums))\n \t\t}\n \t}()\n \n@@ -973,100 +1091,99 @@ func WriteGoMod() {\n \t}\n }\n \n-// keepSums returns a set of module sums to preserve in go.sum. The set\n-// includes entries for all modules used to load packages (according to\n-// the last load function such as LoadPackages or ImportFromFiles).\n-// It also contains entries for go.mod files needed for MVS (the version\n-// of these entries ends with \"/go.mod\").\n-//\n-// If keepBuildListZips is true, the set also includes sums for zip files for\n-// all modules in the build list with replacements applied. 'go get' and\n-// 'go mod download' may add sums to this set when adding a requirement on a\n-// module without a root package or when downloading a direct or indirect\n-// dependency.\n-func keepSums(keepBuildListZips bool) map[module.Version]bool {\n-\t// Re-derive the build list using the current list of direct requirements.\n-\t// Keep the sum for the go.mod of each visited module version (or its\n-\t// replacement).\n-\tmodkey := func(m module.Version) module.Version {\n-\t\treturn module.Version{Path: m.Path, Version: m.Version + \"/go.mod\"}\n-\t}\n+// keepSums returns the set of modules (and go.mod file entries) for which\n+// checksums would be needed in order to reload the same set of packages\n+// loaded by the most recent call to LoadPackages or ImportFromFiles,\n+// including any go.mod files needed to reconstruct the MVS result,\n+// in addition to the checksums for every module in keepMods.\n+func keepSums(ctx context.Context, ld *loader, rs *Requirements, which whichSums) map[module.Version]bool {\n+\t// Every module in the full module graph contributes its requirements,\n+\t// so in order to ensure that the build list itself is reproducible,\n+\t// we need sums for every go.mod in the graph (regardless of whether\n+\t// that version is selected).\n \tkeep := make(map[module.Version]bool)\n-\tvar mu sync.Mutex\n-\treqs := &keepSumReqs{\n-\t\tReqs: &mvsReqs{buildList: buildList},\n-\t\tvisit: func(m module.Version) {\n-\t\t\t// If we build using a replacement module, keep the sum for the replacement,\n-\t\t\t// since that's the code we'll actually use during a build.\n-\t\t\tmu.Lock()\n-\t\t\tr := Replacement(m)\n-\t\t\tif r.Path == \"\" {\n-\t\t\t\tkeep[modkey(m)] = true\n-\t\t\t} else {\n-\t\t\t\tkeep[modkey(r)] = true\n-\t\t\t}\n-\t\t\tmu.Unlock()\n-\t\t},\n-\t}\n-\tbuildList, err := mvs.BuildList(Target, reqs)\n-\tif err != nil {\n-\t\tpanic(fmt.Sprintf(\"unexpected error reloading build list: %v\", err))\n-\t}\n-\n-\tactualMods := make(map[string]module.Version)\n-\tfor _, m := range buildList[1:] {\n-\t\tif r := Replacement(m); r.Path != \"\" {\n-\t\t\tactualMods[m.Path] = r\n-\t\t} else {\n-\t\t\tactualMods[m.Path] = m\n-\t\t}\n-\t}\n \n \t// Add entries for modules in the build list with paths that are prefixes of\n-\t// paths of loaded packages. We need to retain sums for modules needed to\n-\t// report ambiguous import errors. We use our re-derived build list,\n-\t// since the global build list may have been tidied.\n-\tif loaded != nil {\n-\t\tfor _, pkg := range loaded.pkgs {\n-\t\t\tif pkg.testOf != nil || pkg.inStd || module.CheckImportPath(pkg.path) != nil {\n+\t// paths of loaded packages. We need to retain sums for all of these modules \u2014\n+\t// not just the modules containing the actual packages \u2014 in order to rule out\n+\t// ambiguous import errors the next time we load the package.\n+\tif ld != nil {\n+\t\tfor _, pkg := range ld.pkgs {\n+\t\t\t// We check pkg.mod.Path here instead of pkg.inStd because the\n+\t\t\t// pseudo-package \"C\" is not in std, but not provided by any module (and\n+\t\t\t// shouldn't force loading the whole module graph).\n+\t\t\tif pkg.testOf != nil || (pkg.mod.Path == \"\" && pkg.err == nil) || module.CheckImportPath(pkg.path) != nil {\n \t\t\t\tcontinue\n \t\t\t}\n+\n+\t\t\tif rs.depth == lazy && pkg.mod.Path != \"\" {\n+\t\t\t\tif v, ok := rs.rootSelected(pkg.mod.Path); ok && v == pkg.mod.Version {\n+\t\t\t\t\t// pkg was loaded from a root module, and because the main module is\n+\t\t\t\t\t// lazy we do not check non-root modules for conflicts for packages\n+\t\t\t\t\t// that can be found in roots. So we only need the checksums for the\n+\t\t\t\t\t// root modules that may contain pkg, not all possible modules.\n+\t\t\t\t\tfor prefix := pkg.path; prefix != \".\"; prefix = path.Dir(prefix) {\n+\t\t\t\t\t\tif v, ok := rs.rootSelected(prefix); ok && v != \"none\" {\n+\t\t\t\t\t\t\tm := module.Version{Path: prefix, Version: v}\n+\t\t\t\t\t\t\tkeep[resolveReplacement(m)] = true\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tmg, _ := rs.Graph(ctx)\n \t\t\tfor prefix := pkg.path; prefix != \".\"; prefix = path.Dir(prefix) {\n-\t\t\t\tif m, ok := actualMods[prefix]; ok {\n-\t\t\t\t\tkeep[m] = true\n+\t\t\t\tif v := mg.Selected(prefix); v != \"none\" {\n+\t\t\t\t\tm := module.Version{Path: prefix, Version: v}\n+\t\t\t\t\tkeep[resolveReplacement(m)] = true\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\t// Add entries for the zip of each module in the build list.\n-\t// We might not need all of these (tidy does not add them), but they may be\n-\t// added by a specific 'go get' or 'go mod download' command to resolve\n-\t// missing import sum errors.\n-\tif keepBuildListZips {\n-\t\tfor _, m := range actualMods {\n-\t\t\tkeep[m] = true\n+\tif rs.graph.Load() == nil {\n+\t\t// The module graph was not loaded, possibly because the main module is lazy\n+\t\t// or possibly because we haven't needed to load the graph yet.\n+\t\t// Save sums for the root modules (or their replacements), but don't\n+\t\t// incur the cost of loading the graph just to find and retain the sums.\n+\t\tfor _, m := range rs.rootModules {\n+\t\t\tr := resolveReplacement(m)\n+\t\t\tkeep[modkey(r)] = true\n+\t\t\tif which == addBuildListZipSums {\n+\t\t\t\tkeep[r] = true\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tmg, _ := rs.Graph(ctx)\n+\t\tmg.WalkBreadthFirst(func(m module.Version) {\n+\t\t\tif _, ok := mg.RequiredBy(m); ok {\n+\t\t\t\t// The requirements from m's go.mod file are present in the module graph,\n+\t\t\t\t// so they are relevant to the MVS result regardless of whether m was\n+\t\t\t\t// actually selected.\n+\t\t\t\tkeep[modkey(resolveReplacement(m))] = true\n+\t\t\t}\n+\t\t})\n+\n+\t\tif which == addBuildListZipSums {\n+\t\t\tfor _, m := range mg.BuildList() {\n+\t\t\t\tkeep[resolveReplacement(m)] = true\n+\t\t\t}\n \t\t}\n \t}\n \n \treturn keep\n }\n \n-// keepSumReqs embeds another Reqs implementation. The Required method\n-// calls visit for each version in the module graph.\n-type keepSumReqs struct {\n-\tmvs.Reqs\n-\tvisit func(module.Version)\n-}\n+type whichSums int8\n \n-func (r *keepSumReqs) Required(m module.Version) ([]module.Version, error) {\n-\tr.visit(m)\n-\treturn r.Reqs.Required(m)\n-}\n+const (\n+\tloadedZipSumsOnly = whichSums(iota)\n+\taddBuildListZipSums\n+)\n \n-func TrimGoSum() {\n-\t// Don't retain sums for the zip file of every module in the build list.\n-\t// We may not need them all to build the main module's packages.\n-\tkeepBuildListZips := false\n-\tmodfetch.TrimGoSum(keepSums(keepBuildListZips))\n+// modKey returns the module.Version under which the checksum for m's go.mod\n+// file is stored in the go.sum file.\n+func modkey(m module.Version) module.Version {\n+\treturn module.Version{Path: m.Path, Version: m.Version + \"/go.mod\"}\n }"}, {"sha": "ccdeb9b1d11e8650ec420169723ba7d1aae4c2ba", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 129, "deletions": 67, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -20,25 +20,42 @@ import (\n \t\"golang.org/x/mod/module\"\n )\n \n-func ListModules(ctx context.Context, args []string, listU, listVersions, listRetracted bool) []*modinfo.ModulePublic {\n-\tmods := listModules(ctx, args, listVersions, listRetracted)\n+type ListMode int\n+\n+const (\n+\tListU ListMode = 1 << iota\n+\tListRetracted\n+\tListDeprecated\n+\tListVersions\n+\tListRetractedVersions\n+)\n+\n+// ListModules returns a description of the modules matching args, if known,\n+// along with any error preventing additional matches from being identified.\n+//\n+// The returned slice can be nonempty even if the error is non-nil.\n+func ListModules(ctx context.Context, args []string, mode ListMode) ([]*modinfo.ModulePublic, error) {\n+\trs, mods, err := listModules(ctx, LoadModFile(ctx), args, mode)\n \n \ttype token struct{}\n \tsem := make(chan token, runtime.GOMAXPROCS(0))\n-\tif listU || listVersions || listRetracted {\n+\tif mode != 0 {\n \t\tfor _, m := range mods {\n \t\t\tadd := func(m *modinfo.ModulePublic) {\n \t\t\t\tsem <- token{}\n \t\t\t\tgo func() {\n-\t\t\t\t\tif listU {\n+\t\t\t\t\tif mode&ListU != 0 {\n \t\t\t\t\t\taddUpdate(ctx, m)\n \t\t\t\t\t}\n-\t\t\t\t\tif listVersions {\n-\t\t\t\t\t\taddVersions(ctx, m, listRetracted)\n+\t\t\t\t\tif mode&ListVersions != 0 {\n+\t\t\t\t\t\taddVersions(ctx, m, mode&ListRetractedVersions != 0)\n \t\t\t\t\t}\n-\t\t\t\t\tif listRetracted || listU {\n+\t\t\t\t\tif mode&ListRetracted != 0 {\n \t\t\t\t\t\taddRetraction(ctx, m)\n \t\t\t\t\t}\n+\t\t\t\t\tif mode&ListDeprecated != 0 {\n+\t\t\t\t\t\taddDeprecation(ctx, m)\n+\t\t\t\t\t}\n \t\t\t\t\t<-sem\n \t\t\t\t}()\n \t\t\t}\n@@ -54,40 +71,81 @@ func ListModules(ctx context.Context, args []string, listU, listVersions, listRe\n \t\tsem <- token{}\n \t}\n \n-\treturn mods\n+\tif err == nil {\n+\t\tcommitRequirements(ctx, modFileGoVersion(), rs)\n+\t}\n+\treturn mods, err\n }\n \n-func listModules(ctx context.Context, args []string, listVersions, listRetracted bool) []*modinfo.ModulePublic {\n-\tLoadAllModules(ctx)\n+func listModules(ctx context.Context, rs *Requirements, args []string, mode ListMode) (_ *Requirements, mods []*modinfo.ModulePublic, mgErr error) {\n \tif len(args) == 0 {\n-\t\treturn []*modinfo.ModulePublic{moduleInfo(ctx, buildList[0], true, listRetracted)}\n+\t\treturn rs, []*modinfo.ModulePublic{moduleInfo(ctx, rs, Target, mode)}, nil\n \t}\n \n-\tvar mods []*modinfo.ModulePublic\n-\tmatchedBuildList := make([]bool, len(buildList))\n+\tneedFullGraph := false\n \tfor _, arg := range args {\n \t\tif strings.Contains(arg, `\\`) {\n \t\t\tbase.Fatalf(\"go: module paths never use backslash\")\n \t\t}\n \t\tif search.IsRelativePath(arg) {\n \t\t\tbase.Fatalf(\"go: cannot use relative path %s to specify module\", arg)\n \t\t}\n-\t\tif !HasModRoot() && (arg == \"all\" || strings.Contains(arg, \"...\")) {\n-\t\t\tbase.Fatalf(\"go: cannot match %q: %v\", arg, ErrNoModRoot)\n+\t\tif arg == \"all\" || strings.Contains(arg, \"...\") {\n+\t\t\tneedFullGraph = true\n+\t\t\tif !HasModRoot() {\n+\t\t\t\tbase.Fatalf(\"go: cannot match %q: %v\", arg, ErrNoModRoot)\n+\t\t\t}\n+\t\t\tcontinue\n \t\t}\n \t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n \t\t\tpath := arg[:i]\n \t\t\tvers := arg[i+1:]\n+\t\t\tif vers == \"upgrade\" || vers == \"patch\" {\n+\t\t\t\tif _, ok := rs.rootSelected(path); !ok || rs.depth == eager {\n+\t\t\t\t\tneedFullGraph = true\n+\t\t\t\t\tif !HasModRoot() {\n+\t\t\t\t\t\tbase.Fatalf(\"go: cannot match %q: %v\", arg, ErrNoModRoot)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif _, ok := rs.rootSelected(arg); !ok || rs.depth == eager {\n+\t\t\tneedFullGraph = true\n+\t\t\tif mode&ListVersions == 0 && !HasModRoot() {\n+\t\t\t\tbase.Fatalf(\"go: cannot match %q without -versions or an explicit version: %v\", arg, ErrNoModRoot)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvar mg *ModuleGraph\n+\tif needFullGraph {\n+\t\trs, mg, mgErr = expandGraph(ctx, rs)\n+\t}\n+\n+\tmatchedModule := map[module.Version]bool{}\n+\tfor _, arg := range args {\n+\t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n+\t\t\tpath := arg[:i]\n+\t\t\tvers := arg[i+1:]\n+\n \t\t\tvar current string\n-\t\t\tfor _, m := range buildList {\n-\t\t\t\tif m.Path == path {\n-\t\t\t\t\tcurrent = m.Version\n-\t\t\t\t\tbreak\n+\t\t\tif mg == nil {\n+\t\t\t\tcurrent, _ = rs.rootSelected(path)\n+\t\t\t} else {\n+\t\t\t\tcurrent = mg.Selected(path)\n+\t\t\t}\n+\t\t\tif current == \"none\" && mgErr != nil {\n+\t\t\t\tif vers == \"upgrade\" || vers == \"patch\" {\n+\t\t\t\t\t// The module graph is incomplete, so we don't know what version we're\n+\t\t\t\t\t// actually upgrading from.\n+\t\t\t\t\t// mgErr is already set, so just skip this module.\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tallowed := CheckAllowed\n-\t\t\tif IsRevisionQuery(vers) || listRetracted {\n+\t\t\tif IsRevisionQuery(vers) || mode&ListRetracted != 0 {\n \t\t\t\t// Allow excluded and retracted versions if the user asked for a\n \t\t\t\t// specific revision or used 'go list -retracted'.\n \t\t\t\tallowed = nil\n@@ -101,75 +159,79 @@ func listModules(ctx context.Context, args []string, listVersions, listRetracted\n \t\t\t\t})\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tmod := moduleInfo(ctx, module.Version{Path: path, Version: info.Version}, false, listRetracted)\n+\n+\t\t\t// Indicate that m was resolved from outside of rs by passing a nil\n+\t\t\t// *Requirements instead.\n+\t\t\tvar noRS *Requirements\n+\n+\t\t\tmod := moduleInfo(ctx, noRS, module.Version{Path: path, Version: info.Version}, mode)\n \t\t\tmods = append(mods, mod)\n \t\t\tcontinue\n \t\t}\n \n \t\t// Module path or pattern.\n \t\tvar match func(string) bool\n-\t\tvar literal bool\n \t\tif arg == \"all\" {\n \t\t\tmatch = func(string) bool { return true }\n \t\t} else if strings.Contains(arg, \"...\") {\n \t\t\tmatch = search.MatchPattern(arg)\n \t\t} else {\n-\t\t\tmatch = func(p string) bool { return arg == p }\n-\t\t\tliteral = true\n-\t\t}\n-\t\tmatched := false\n-\t\tfor i, m := range buildList {\n-\t\t\tif i == 0 && !HasModRoot() {\n-\t\t\t\t// The root module doesn't actually exist: omit it.\n+\t\t\tvar v string\n+\t\t\tif mg == nil {\n+\t\t\t\tvar ok bool\n+\t\t\t\tv, ok = rs.rootSelected(arg)\n+\t\t\t\tif !ok {\n+\t\t\t\t\t// We checked rootSelected(arg) in the earlier args loop, so if there\n+\t\t\t\t\t// is no such root we should have loaded a non-nil mg.\n+\t\t\t\t\tpanic(fmt.Sprintf(\"internal error: root requirement expected but not found for %v\", arg))\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tv = mg.Selected(arg)\n+\t\t\t}\n+\t\t\tif v == \"none\" && mgErr != nil {\n+\t\t\t\t// mgErr is already set, so just skip this module.\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tif v != \"none\" {\n+\t\t\t\tmods = append(mods, moduleInfo(ctx, rs, module.Version{Path: arg, Version: v}, mode))\n+\t\t\t} else if cfg.BuildMod == \"vendor\" {\n+\t\t\t\t// In vendor mode, we can't determine whether a missing module is \u201ca\n+\t\t\t\t// known dependency\u201d because the module graph is incomplete.\n+\t\t\t\t// Give a more explicit error message.\n+\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n+\t\t\t\t\tPath:  arg,\n+\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"can't resolve module using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")),\n+\t\t\t\t})\n+\t\t\t} else if mode&ListVersions != 0 {\n+\t\t\t\t// Don't make the user provide an explicit '@latest' when they're\n+\t\t\t\t// explicitly asking what the available versions are. Instead, return a\n+\t\t\t\t// module with version \"none\", to which we can add the requested list.\n+\t\t\t\tmods = append(mods, &modinfo.ModulePublic{Path: arg})\n+\t\t\t} else {\n+\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n+\t\t\t\t\tPath:  arg,\n+\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"not a known dependency\")),\n+\t\t\t\t})\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tmatched := false\n+\t\tfor _, m := range mg.BuildList() {\n \t\t\tif match(m.Path) {\n \t\t\t\tmatched = true\n-\t\t\t\tif !matchedBuildList[i] {\n-\t\t\t\t\tmatchedBuildList[i] = true\n-\t\t\t\t\tmods = append(mods, moduleInfo(ctx, m, true, listRetracted))\n+\t\t\t\tif !matchedModule[m] {\n+\t\t\t\t\tmatchedModule[m] = true\n+\t\t\t\t\tmods = append(mods, moduleInfo(ctx, rs, m, mode))\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif !matched {\n-\t\t\tif literal {\n-\t\t\t\tif listVersions {\n-\t\t\t\t\t// Don't make the user provide an explicit '@latest' when they're\n-\t\t\t\t\t// explicitly asking what the available versions are.\n-\t\t\t\t\t// Instead, resolve the module, even if it isn't an existing dependency.\n-\t\t\t\t\tinfo, err := Query(ctx, arg, \"latest\", \"\", nil)\n-\t\t\t\t\tif err == nil {\n-\t\t\t\t\t\tmod := moduleInfo(ctx, module.Version{Path: arg, Version: info.Version}, false, listRetracted)\n-\t\t\t\t\t\tmods = append(mods, mod)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\t\t\tPath:  arg,\n-\t\t\t\t\t\t\tError: modinfoError(arg, \"\", err),\n-\t\t\t\t\t\t})\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif cfg.BuildMod == \"vendor\" {\n-\t\t\t\t\t// In vendor mode, we can't determine whether a missing module is \u201ca\n-\t\t\t\t\t// known dependency\u201d because the module graph is incomplete.\n-\t\t\t\t\t// Give a more explicit error message.\n-\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\t\tPath:  arg,\n-\t\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"can't resolve module using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")),\n-\t\t\t\t\t})\n-\t\t\t\t} else {\n-\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\t\tPath:  arg,\n-\t\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"not a known dependency\")),\n-\t\t\t\t\t})\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: pattern %q matched no module dependencies\\n\", arg)\n-\t\t\t}\n+\t\t\tfmt.Fprintf(os.Stderr, \"warning: pattern %q matched no module dependencies\\n\", arg)\n \t\t}\n \t}\n \n-\treturn mods\n+\treturn rs, mods, mgErr\n }\n \n // modinfoError wraps an error to create an error message in"}, {"sha": "bce9ad85f42e6c593724c6e05bbfb31db6b57521", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 950, "deletions": 197, "changes": 1147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -49,7 +49,7 @@ package modload\n // Because \"go mod vendor\" prunes out the tests of vendored packages, the\n // behavior of the \"all\" pattern with -mod=vendor in Go 1.11\u20131.15 is the same\n // as the \"all\" pattern (regardless of the -mod flag) in 1.16+.\n-// The allClosesOverTests parameter to the loader indicates whether the \"all\"\n+// The loader uses the GoVersion parameter to determine whether the \"all\"\n // pattern should close over tests (as in Go 1.11\u20131.15) or stop at only those\n // packages transitively imported by the packages and tests in the main module\n // (\"all\" in Go 1.16+ and \"go mod vendor\" in Go 1.11+).\n@@ -121,26 +121,61 @@ import (\n \t\"cmd/go/internal/str\"\n \n \t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n // loaded is the most recently-used package loader.\n // It holds details about individual packages.\n+//\n+// This variable should only be accessed directly in top-level exported\n+// functions. All other functions that require or produce a *loader should pass\n+// or return it as an explicit parameter.\n var loaded *loader\n \n // PackageOpts control the behavior of the LoadPackages function.\n type PackageOpts struct {\n+\t// GoVersion is the Go version to which the go.mod file should be updated\n+\t// after packages have been loaded.\n+\t//\n+\t// An empty GoVersion means to use the Go version already specified in the\n+\t// main module's go.mod file, or the latest Go version if there is no main\n+\t// module.\n+\tGoVersion string\n+\n \t// Tags are the build tags in effect (as interpreted by the\n \t// cmd/go/internal/imports package).\n \t// If nil, treated as equivalent to imports.Tags().\n \tTags map[string]bool\n \n+\t// Tidy, if true, requests that the build list and go.sum file be reduced to\n+\t// the minimial dependencies needed to reproducibly reload the requested\n+\t// packages.\n+\tTidy bool\n+\n+\t// TidyCompatibleVersion is the oldest Go version that must be able to\n+\t// reproducibly reload the requested packages.\n+\t//\n+\t// If empty, the compatible version is the Go version immediately prior to the\n+\t// 'go' version listed in the go.mod file.\n+\tTidyCompatibleVersion string\n+\n+\t// VendorModulesInGOROOTSrc indicates that if we are within a module in\n+\t// GOROOT/src, packages in the module's vendor directory should be resolved as\n+\t// actual module dependencies (instead of standard-library packages).\n+\tVendorModulesInGOROOTSrc bool\n+\n \t// ResolveMissingImports indicates that we should attempt to add module\n \t// dependencies as needed to resolve imports of packages that are not found.\n \t//\n \t// For commands that support the -mod flag, resolving imports may still fail\n \t// if the flag is set to \"readonly\" (the default) or \"vendor\".\n \tResolveMissingImports bool\n \n+\t// AssumeRootsImported indicates that the transitive dependencies of the root\n+\t// packages should be treated as if those roots will be imported by the main\n+\t// module.\n+\tAssumeRootsImported bool\n+\n \t// AllowPackage, if non-nil, is called after identifying the module providing\n \t// each package. If AllowPackage returns a non-nil error, that error is set\n \t// for the package, and the imports and test of that package will not be\n@@ -166,16 +201,32 @@ type PackageOpts struct {\n \t// an error occurs.\n \tAllowErrors bool\n \n-\t// SilenceErrors indicates that LoadPackages should not print errors\n-\t// that occur while loading packages. SilenceErrors implies AllowErrors.\n-\tSilenceErrors bool\n+\t// SilencePackageErrors indicates that LoadPackages should not print errors\n+\t// that occur while matching or loading packages, and should not terminate the\n+\t// process if such an error occurs.\n+\t//\n+\t// Errors encountered in the module graph will still be reported.\n+\t//\n+\t// The caller may retrieve the silenced package errors using the Lookup\n+\t// function, and matching errors are still populated in the Errs field of the\n+\t// associated search.Match.)\n+\tSilencePackageErrors bool\n \n \t// SilenceMissingStdImports indicates that LoadPackages should not print\n \t// errors or terminate the process if an imported package is missing, and the\n \t// import path looks like it might be in the standard library (perhaps in a\n \t// future version).\n \tSilenceMissingStdImports bool\n \n+\t// SilenceNoGoErrors indicates that LoadPackages should not print\n+\t// imports.ErrNoGo errors.\n+\t// This allows the caller to invoke LoadPackages (and report other errors)\n+\t// without knowing whether the requested packages exist for the given tags.\n+\t//\n+\t// Note that if a requested package does not exist *at all*, it will fail\n+\t// during module resolution and the error will not be suppressed.\n+\tSilenceNoGoErrors bool\n+\n \t// SilenceUnmatchedWarnings suppresses the warnings normally emitted for\n \t// patterns that did not match any packages.\n \tSilenceUnmatchedWarnings bool\n@@ -184,7 +235,6 @@ type PackageOpts struct {\n // LoadPackages identifies the set of packages matching the given patterns and\n // loads the packages in the import graph rooted at that set.\n func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (matches []*search.Match, loadedPackages []string) {\n-\tLoadModFile(ctx)\n \tif opts.Tags == nil {\n \t\topts.Tags = imports.Tags()\n \t}\n@@ -199,13 +249,13 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t}\n \t}\n \n-\tupdateMatches := func(ld *loader) {\n+\tupdateMatches := func(rs *Requirements, ld *loader) {\n \t\tfor _, m := range matches {\n \t\t\tswitch {\n \t\t\tcase m.IsLocal():\n \t\t\t\t// Evaluate list of file system directories on first iteration.\n \t\t\t\tif m.Dirs == nil {\n-\t\t\t\t\tmatchLocalDirs(m)\n+\t\t\t\t\tmatchLocalDirs(ctx, m, rs)\n \t\t\t\t}\n \n \t\t\t\t// Make a copy of the directory list and translate to import paths.\n@@ -216,7 +266,7 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t\t\t// the loader iterations.\n \t\t\t\tm.Pkgs = m.Pkgs[:0]\n \t\t\t\tfor _, dir := range m.Dirs {\n-\t\t\t\t\tpkg, err := resolveLocalPackage(dir)\n+\t\t\t\t\tpkg, err := resolveLocalPackage(ctx, dir, rs)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tif !m.IsLiteral() && (err == errPkgIsBuiltin || err == errPkgIsGorootSrc) {\n \t\t\t\t\t\t\tcontinue // Don't include \"builtin\" or GOROOT/src in wildcard patterns.\n@@ -239,7 +289,17 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \n \t\t\tcase strings.Contains(m.Pattern(), \"...\"):\n \t\t\t\tm.Errs = m.Errs[:0]\n-\t\t\t\tmatchPackages(ctx, m, opts.Tags, includeStd, buildList)\n+\t\t\t\tmg, err := rs.Graph(ctx)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\t// The module graph is (or may be) incomplete \u2014 perhaps we failed to\n+\t\t\t\t\t// load the requirements of some module. This is an error in matching\n+\t\t\t\t\t// the patterns to packages, because we may be missing some packages\n+\t\t\t\t\t// or we may erroneously match packages in the wrong versions of\n+\t\t\t\t\t// modules. However, for cases like 'go list -e', the error should not\n+\t\t\t\t\t// necessarily prevent us from loading the packages we could find.\n+\t\t\t\t\tm.Errs = append(m.Errs, err)\n+\t\t\t\t}\n+\t\t\t\tmatchPackages(ctx, m, opts.Tags, includeStd, mg.BuildList())\n \n \t\t\tcase m.Pattern() == \"all\":\n \t\t\t\tif ld == nil {\n@@ -264,14 +324,16 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\t}\n \t}\n \n-\tloaded = loadFromRoots(loaderParams{\n-\t\tPackageOpts: opts,\n+\tinitialRS, _ := loadModFile(ctx) // Ignore needCommit \u2014 we're going to commit at the end regardless.\n \n-\t\tallClosesOverTests: index.allPatternClosesOverTests() && !opts.UseVendorAll,\n-\t\tallPatternIsRoot:   allPatternIsRoot,\n+\tld := loadFromRoots(ctx, loaderParams{\n+\t\tPackageOpts:  opts,\n+\t\trequirements: initialRS,\n \n-\t\tlistRoots: func() (roots []string) {\n-\t\t\tupdateMatches(nil)\n+\t\tallPatternIsRoot: allPatternIsRoot,\n+\n+\t\tlistRoots: func(rs *Requirements) (roots []string) {\n+\t\t\tupdateMatches(rs, nil)\n \t\t\tfor _, m := range matches {\n \t\t\t\troots = append(roots, m.Pkgs...)\n \t\t\t}\n@@ -280,47 +342,14 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t})\n \n \t// One last pass to finalize wildcards.\n-\tupdateMatches(loaded)\n-\n-\t// Report errors, if any.\n-\tcheckMultiplePaths()\n-\tfor _, pkg := range loaded.pkgs {\n-\t\tif pkg.err != nil {\n-\t\t\tif sumErr := (*ImportMissingSumError)(nil); errors.As(pkg.err, &sumErr) {\n-\t\t\t\tif importer := pkg.stack; importer != nil {\n-\t\t\t\t\tsumErr.importer = importer.path\n-\t\t\t\t\tsumErr.importerVersion = importer.mod.Version\n-\t\t\t\t\tsumErr.importerIsTest = importer.testOf != nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsilence := opts.SilenceErrors\n-\t\t\tif stdErr := (*ImportMissingError)(nil); errors.As(pkg.err, &stdErr) &&\n-\t\t\t\tstdErr.isStd && opts.SilenceMissingStdImports {\n-\t\t\t\tsilence = true\n-\t\t\t}\n+\tupdateMatches(ld.requirements, ld)\n \n-\t\t\tif !silence {\n-\t\t\t\tif opts.AllowErrors {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", pkg.stackText(), pkg.err)\n-\t\t\t\t} else {\n-\t\t\t\t\tbase.Errorf(\"%s: %v\", pkg.stackText(), pkg.err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif !pkg.isTest() {\n-\t\t\tloadedPackages = append(loadedPackages, pkg.path)\n-\t\t}\n-\t}\n-\tif !opts.SilenceErrors {\n-\t\t// Also list errors in matching patterns (such as directory permission\n-\t\t// errors for wildcard patterns).\n+\t// List errors in matching patterns (such as directory permission\n+\t// errors for wildcard patterns).\n+\tif !ld.SilencePackageErrors {\n \t\tfor _, match := range matches {\n \t\t\tfor _, err := range match.Errs {\n-\t\t\t\tif opts.AllowErrors {\n-\t\t\t\t\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n-\t\t\t\t} else {\n-\t\t\t\t\tbase.Errorf(\"%v\", err)\n-\t\t\t\t}\n+\t\t\t\tld.errorf(\"%v\\n\", err)\n \t\t\t}\n \t\t}\n \t}\n@@ -330,15 +359,68 @@ func LoadPackages(ctx context.Context, opts PackageOpts, patterns ...string) (ma\n \t\tsearch.WarnUnmatched(matches)\n \t}\n \n-\t// Success! Update go.mod (if needed) and return the results.\n-\tWriteGoMod()\n+\tif opts.Tidy {\n+\t\tif cfg.BuildV {\n+\t\t\tmg, _ := ld.requirements.Graph(ctx)\n+\n+\t\t\tfor _, m := range initialRS.rootModules {\n+\t\t\t\tvar unused bool\n+\t\t\t\tif ld.requirements.depth == eager {\n+\t\t\t\t\t// m is unused if it was dropped from the module graph entirely. If it\n+\t\t\t\t\t// was only demoted from direct to indirect, it may still be in use via\n+\t\t\t\t\t// a transitive import.\n+\t\t\t\t\tunused = mg.Selected(m.Path) == \"none\"\n+\t\t\t\t} else {\n+\t\t\t\t\t// m is unused if it was dropped from the roots. If it is still present\n+\t\t\t\t\t// as a transitive dependency, that transitive dependency is not needed\n+\t\t\t\t\t// by any package or test in the main module.\n+\t\t\t\t\t_, ok := ld.requirements.rootSelected(m.Path)\n+\t\t\t\t\tunused = !ok\n+\t\t\t\t}\n+\t\t\t\tif unused {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tkeep := keepSums(ctx, ld, ld.requirements, loadedZipSumsOnly)\n+\t\tif compatDepth := modDepthFromGoVersion(ld.TidyCompatibleVersion); compatDepth != ld.requirements.depth {\n+\t\t\tcompatRS := newRequirements(compatDepth, ld.requirements.rootModules, ld.requirements.direct)\n+\t\t\tld.checkTidyCompatibility(ctx, compatRS)\n+\n+\t\t\tfor m := range keepSums(ctx, ld, compatRS, loadedZipSumsOnly) {\n+\t\t\t\tkeep[m] = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif allowWriteGoMod {\n+\t\t\tmodfetch.TrimGoSum(keep)\n+\n+\t\t\t// commitRequirements below will also call WriteGoSum, but the \"keep\" map\n+\t\t\t// we have here could be strictly larger: commitRequirements only commits\n+\t\t\t// loaded.requirements, but here we may have also loaded (and want to\n+\t\t\t// preserve checksums for) additional entities from compatRS, which are\n+\t\t\t// only needed for compatibility with ld.TidyCompatibleVersion.\n+\t\t\tmodfetch.WriteGoSum(keep)\n+\t\t}\n+\t}\n+\n+\t// Success! Update go.mod and go.sum (if needed) and return the results.\n+\tloaded = ld\n+\tcommitRequirements(ctx, loaded.GoVersion, loaded.requirements)\n+\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif !pkg.isTest() {\n+\t\t\tloadedPackages = append(loadedPackages, pkg.path)\n+\t\t}\n+\t}\n \tsort.Strings(loadedPackages)\n \treturn matches, loadedPackages\n }\n \n // matchLocalDirs is like m.MatchDirs, but tries to avoid scanning directories\n // outside of the standard library and active modules.\n-func matchLocalDirs(m *search.Match) {\n+func matchLocalDirs(ctx context.Context, m *search.Match, rs *Requirements) {\n \tif !m.IsLocal() {\n \t\tpanic(fmt.Sprintf(\"internal error: resolveLocalDirs on non-local pattern %s\", m.Pattern()))\n \t}\n@@ -352,9 +434,9 @@ func matchLocalDirs(m *search.Match) {\n \t\tdir := filepath.Dir(filepath.Clean(m.Pattern()[:i+3]))\n \t\tabsDir := dir\n \t\tif !filepath.IsAbs(dir) {\n-\t\t\tabsDir = filepath.Join(base.Cwd, dir)\n+\t\t\tabsDir = filepath.Join(base.Cwd(), dir)\n \t\t}\n-\t\tif search.InDir(absDir, cfg.GOROOTsrc) == \"\" && search.InDir(absDir, ModRoot()) == \"\" && pathInModuleCache(absDir) == \"\" {\n+\t\tif search.InDir(absDir, cfg.GOROOTsrc) == \"\" && search.InDir(absDir, ModRoot()) == \"\" && pathInModuleCache(ctx, absDir, rs) == \"\" {\n \t\t\tm.Dirs = []string{}\n \t\t\tm.AddError(fmt.Errorf(\"directory prefix %s outside available modules\", base.ShortPath(absDir)))\n \t\t\treturn\n@@ -365,12 +447,12 @@ func matchLocalDirs(m *search.Match) {\n }\n \n // resolveLocalPackage resolves a filesystem path to a package path.\n-func resolveLocalPackage(dir string) (string, error) {\n+func resolveLocalPackage(ctx context.Context, dir string, rs *Requirements) (string, error) {\n \tvar absDir string\n \tif filepath.IsAbs(dir) {\n \t\tabsDir = filepath.Clean(dir)\n \t} else {\n-\t\tabsDir = filepath.Join(base.Cwd, dir)\n+\t\tabsDir = filepath.Join(base.Cwd(), dir)\n \t}\n \n \tbp, err := cfg.BuildContext.ImportDir(absDir, 0)\n@@ -456,7 +538,7 @@ func resolveLocalPackage(dir string) (string, error) {\n \t\treturn pkg, nil\n \t}\n \n-\tpkg := pathInModuleCache(absDir)\n+\tpkg := pathInModuleCache(ctx, absDir, rs)\n \tif pkg == \"\" {\n \t\treturn \"\", fmt.Errorf(\"directory %s outside available modules\", base.ShortPath(absDir))\n \t}\n@@ -471,7 +553,7 @@ var (\n \n // pathInModuleCache returns the import path of the directory dir,\n // if dir is in the module cache copy of a module in our build list.\n-func pathInModuleCache(dir string) string {\n+func pathInModuleCache(ctx context.Context, dir string, rs *Requirements) string {\n \ttryMod := func(m module.Version) (string, bool) {\n \t\tvar root string\n \t\tvar err error\n@@ -501,52 +583,81 @@ func pathInModuleCache(dir string) string {\n \t\treturn path.Join(m.Path, filepath.ToSlash(sub)), true\n \t}\n \n-\tfor _, m := range buildList[1:] {\n-\t\tif importPath, ok := tryMod(m); ok {\n-\t\t\t// checkMultiplePaths ensures that a module can be used for at most one\n-\t\t\t// requirement, so this must be it.\n-\t\t\treturn importPath\n+\tif rs.depth == lazy {\n+\t\tfor _, m := range rs.rootModules {\n+\t\t\tif v, _ := rs.rootSelected(m.Path); v != m.Version {\n+\t\t\t\tcontinue // m is a root, but we have a higher root for the same path.\n+\t\t\t}\n+\t\t\tif importPath, ok := tryMod(m); ok {\n+\t\t\t\t// checkMultiplePaths ensures that a module can be used for at most one\n+\t\t\t\t// requirement, so this must be it.\n+\t\t\t\treturn importPath\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// None of the roots contained dir, or we're in eager mode and want to load\n+\t// the full module graph more aggressively. Either way, check the full graph\n+\t// to see if the directory is a non-root dependency.\n+\t//\n+\t// If the roots are not consistent with the full module graph, the selected\n+\t// versions of root modules may differ from what we already checked above.\n+\t// Re-check those paths too.\n+\n+\tmg, _ := rs.Graph(ctx)\n+\tvar importPath string\n+\tfor _, m := range mg.BuildList() {\n+\t\tvar found bool\n+\t\timportPath, found = tryMod(m)\n+\t\tif found {\n+\t\t\tbreak\n \t\t}\n \t}\n-\treturn \"\"\n+\treturn importPath\n }\n \n // ImportFromFiles adds modules to the build list as needed\n // to satisfy the imports in the named Go source files.\n+//\n+// Errors in missing dependencies are silenced.\n+//\n+// TODO(bcmills): Silencing errors seems off. Take a closer look at this and\n+// figure out what the error-reporting actually ought to be.\n func ImportFromFiles(ctx context.Context, gofiles []string) {\n-\tLoadModFile(ctx)\n+\trs := LoadModFile(ctx)\n \n \ttags := imports.Tags()\n \timports, testImports, err := imports.ScanFiles(gofiles, tags)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tloaded = loadFromRoots(loaderParams{\n+\tloaded = loadFromRoots(ctx, loaderParams{\n \t\tPackageOpts: PackageOpts{\n \t\t\tTags:                  tags,\n \t\t\tResolveMissingImports: true,\n+\t\t\tSilencePackageErrors:  true,\n \t\t},\n-\t\tallClosesOverTests: index.allPatternClosesOverTests(),\n-\t\tlistRoots: func() (roots []string) {\n+\t\trequirements: rs,\n+\t\tlistRoots: func(*Requirements) (roots []string) {\n \t\t\troots = append(roots, imports...)\n \t\t\troots = append(roots, testImports...)\n \t\t\treturn roots\n \t\t},\n \t})\n-\tWriteGoMod()\n+\tcommitRequirements(ctx, loaded.GoVersion, loaded.requirements)\n }\n \n // DirImportPath returns the effective import path for dir,\n // provided it is within the main module, or else returns \".\".\n-func DirImportPath(dir string) string {\n+func DirImportPath(ctx context.Context, dir string) string {\n \tif !HasModRoot() {\n \t\treturn \".\"\n \t}\n-\tLoadModFile(context.TODO())\n+\tLoadModFile(ctx) // Sets targetPrefix.\n \n \tif !filepath.IsAbs(dir) {\n-\t\tdir = filepath.Join(base.Cwd, dir)\n+\t\tdir = filepath.Join(base.Cwd(), dir)\n \t} else {\n \t\tdir = filepath.Clean(dir)\n \t}\n@@ -564,20 +675,6 @@ func DirImportPath(dir string) string {\n \treturn \".\"\n }\n \n-// TargetPackages returns the list of packages in the target (top-level) module\n-// matching pattern, which may be relative to the working directory, under all\n-// build tag settings.\n-func TargetPackages(ctx context.Context, pattern string) *search.Match {\n-\t// TargetPackages is relative to the main module, so ensure that the main\n-\t// module is a thing that can contain packages.\n-\tLoadModFile(ctx)\n-\tModRoot()\n-\n-\tm := search.NewMatch(pattern)\n-\tmatchPackages(ctx, m, imports.AnyTags(), omitStd, []module.Version{Target})\n-\treturn m\n-}\n-\n // ImportMap returns the actual package import path\n // for an import path found in source code.\n // If the given import path does not appear in the source code\n@@ -609,29 +706,6 @@ func PackageModule(path string) module.Version {\n \treturn pkg.mod\n }\n \n-// PackageImports returns the imports for the package named by the import path.\n-// Test imports will be returned as well if tests were loaded for the package\n-// (i.e., if \"all\" was loaded or if LoadTests was set and the path was matched\n-// by a command line argument). PackageImports will return nil for\n-// unknown package paths.\n-func PackageImports(path string) (imports, testImports []string) {\n-\tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n-\tif !ok {\n-\t\treturn nil, nil\n-\t}\n-\timports = make([]string, len(pkg.imports))\n-\tfor i, p := range pkg.imports {\n-\t\timports[i] = p.path\n-\t}\n-\tif pkg.test != nil {\n-\t\ttestImports = make([]string, len(pkg.test.imports))\n-\t\tfor i, p := range pkg.test.imports {\n-\t\t\ttestImports[i] = p.path\n-\t\t}\n-\t}\n-\treturn imports, testImports\n-}\n-\n // Lookup returns the source directory, import path, and any loading error for\n // the package at path as imported from the package in parentDir.\n // Lookup requires that one of the Load functions in this package has already\n@@ -670,26 +744,29 @@ func Lookup(parentPath string, parentIsStd bool, path string) (dir, realPath str\n type loader struct {\n \tloaderParams\n \n+\t// allClosesOverTests indicates whether the \"all\" pattern includes\n+\t// dependencies of tests outside the main module (as in Go 1.11\u20131.15).\n+\t// (Otherwise \u2014 as in Go 1.16+ \u2014 the \"all\" pattern includes only the packages\n+\t// transitively *imported by* the packages and tests in the main module.)\n+\tallClosesOverTests bool\n+\n \twork *par.Queue\n \n \t// reset on each iteration\n \troots    []*loadPkg\n \tpkgCache *par.Cache // package path (string) \u2192 *loadPkg\n \tpkgs     []*loadPkg // transitive closure of loaded packages and tests; populated in buildStacks\n-\n-\t// computed at end of iterations\n-\tdirect map[string]bool // imported directly by main module\n }\n \n // loaderParams configure the packages loaded by, and the properties reported\n // by, a loader instance.\n type loaderParams struct {\n \tPackageOpts\n+\trequirements *Requirements\n \n-\tallClosesOverTests bool // Does the \"all\" pattern include the transitive closure of tests of packages in \"all\"?\n-\tallPatternIsRoot   bool // Is the \"all\" pattern an additional root?\n+\tallPatternIsRoot bool // Is the \"all\" pattern an additional root?\n \n-\tlistRoots func() []string\n+\tlistRoots func(rs *Requirements) []string\n }\n \n func (ld *loader) reset() {\n@@ -704,6 +781,16 @@ func (ld *loader) reset() {\n \tld.pkgs = nil\n }\n \n+// errorf reports an error via either os.Stderr or base.Errorf,\n+// according to whether ld.AllowErrors is set.\n+func (ld *loader) errorf(format string, args ...interface{}) {\n+\tif ld.AllowErrors {\n+\t\tfmt.Fprintf(os.Stderr, format, args...)\n+\t} else {\n+\t\tbase.Errorf(format, args...)\n+\t}\n+}\n+\n // A loadPkg records information about a single loaded package.\n type loadPkg struct {\n \t// Populated at construction time:\n@@ -756,6 +843,11 @@ const (\n \t// are also roots (and must be marked pkgIsRoot).\n \tpkgIsRoot\n \n+\t// pkgFromRoot indicates that the package is in the transitive closure of\n+\t// imports starting at the roots. (Note that every package marked as pkgIsRoot\n+\t// is also trivially marked pkgFromRoot.)\n+\tpkgFromRoot\n+\n \t// pkgImportsLoaded indicates that the imports and testImports fields of a\n \t// loadPkg have been populated.\n \tpkgImportsLoaded\n@@ -796,6 +888,18 @@ func (pkg *loadPkg) isTest() bool {\n \treturn pkg.testOf != nil\n }\n \n+// fromExternalModule reports whether pkg was loaded from a module other than\n+// the main module.\n+func (pkg *loadPkg) fromExternalModule() bool {\n+\tif pkg.mod.Path == \"\" {\n+\t\treturn false // loaded from the standard library, not a module\n+\t}\n+\tif pkg.mod.Path == Target.Path {\n+\t\treturn false // loaded from the main module.\n+\t}\n+\treturn true\n+}\n+\n var errMissing = errors.New(\"cannot find package\")\n \n // loadFromRoots attempts to load the build graph needed to process a set of\n@@ -804,30 +908,82 @@ var errMissing = errors.New(\"cannot find package\")\n // The set of root packages is returned by the params.listRoots function, and\n // expanded to the full set of packages by tracing imports (and possibly tests)\n // as needed.\n-func loadFromRoots(params loaderParams) *loader {\n+func loadFromRoots(ctx context.Context, params loaderParams) *loader {\n \tld := &loader{\n \t\tloaderParams: params,\n \t\twork:         par.NewQueue(runtime.GOMAXPROCS(0)),\n \t}\n \n+\tif ld.GoVersion == \"\" {\n+\t\tld.GoVersion = modFileGoVersion()\n+\n+\t\tif ld.Tidy && semver.Compare(\"v\"+ld.GoVersion, \"v\"+LatestGoVersion()) > 0 {\n+\t\t\tld.errorf(\"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", ld.GoVersion, LatestGoVersion())\n+\t\t\tbase.ExitIfErrors()\n+\t\t}\n+\t}\n+\n+\tif ld.Tidy {\n+\t\tif ld.TidyCompatibleVersion == \"\" {\n+\t\t\tld.TidyCompatibleVersion = priorGoVersion(ld.GoVersion)\n+\t\t} else if semver.Compare(\"v\"+ld.TidyCompatibleVersion, \"v\"+ld.GoVersion) > 0 {\n+\t\t\t// Each version of the Go toolchain knows how to interpret go.mod and\n+\t\t\t// go.sum files produced by all previous versions, so a compatibility\n+\t\t\t// version higher than the go.mod version adds nothing.\n+\t\t\tld.TidyCompatibleVersion = ld.GoVersion\n+\t\t}\n+\t}\n+\n+\tif semver.Compare(\"v\"+ld.GoVersion, narrowAllVersionV) < 0 && !ld.UseVendorAll {\n+\t\t// The module's go version explicitly predates the change in \"all\" for lazy\n+\t\t// loading, so continue to use the older interpretation.\n+\t\tld.allClosesOverTests = true\n+\t}\n+\n \tvar err error\n-\treqs := &mvsReqs{buildList: buildList}\n-\tbuildList, err = mvs.BuildList(Target, reqs)\n+\tld.requirements, err = convertDepth(ctx, ld.requirements, modDepthFromGoVersion(ld.GoVersion))\n \tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+\t\tld.errorf(\"go: %v\\n\", err)\n+\t}\n+\n+\tif ld.requirements.depth == eager {\n+\t\tvar err error\n+\t\tld.requirements, _, err = expandGraph(ctx, ld.requirements)\n+\t\tif err != nil {\n+\t\t\tld.errorf(\"go: %v\\n\", err)\n+\t\t}\n \t}\n \n-\taddedModuleFor := make(map[string]bool)\n \tfor {\n \t\tld.reset()\n \n \t\t// Load the root packages and their imports.\n \t\t// Note: the returned roots can change on each iteration,\n \t\t// since the expansion of package patterns depends on the\n \t\t// build list we're using.\n+\t\trootPkgs := ld.listRoots(ld.requirements)\n+\n+\t\tif ld.requirements.depth == lazy && cfg.BuildMod == \"mod\" {\n+\t\t\t// Before we start loading transitive imports of packages, locate all of\n+\t\t\t// the root packages and promote their containing modules to root modules\n+\t\t\t// dependencies. If their go.mod files are tidy (the common case) and the\n+\t\t\t// set of root packages does not change then we can select the correct\n+\t\t\t// versions of all transitive imports on the first try and complete\n+\t\t\t// loading in a single iteration.\n+\t\t\tchangedBuildList := ld.preloadRootModules(ctx, rootPkgs)\n+\t\t\tif changedBuildList {\n+\t\t\t\t// The build list has changed, so the set of root packages may have also\n+\t\t\t\t// changed. Start over to pick up the changes. (Preloading roots is much\n+\t\t\t\t// cheaper than loading the full import graph, so we would rather pay\n+\t\t\t\t// for an extra iteration of preloading than potentially end up\n+\t\t\t\t// discarding the result of a full iteration of loading.)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n \t\tinRoots := map[*loadPkg]bool{}\n-\t\tfor _, path := range ld.listRoots() {\n-\t\t\troot := ld.pkg(path, pkgIsRoot)\n+\t\tfor _, path := range rootPkgs {\n+\t\t\troot := ld.pkg(ctx, path, pkgIsRoot)\n \t\t\tif !inRoots[root] {\n \t\t\t\tld.roots = append(ld.roots, root)\n \t\t\t\tinRoots[root] = true\n@@ -843,77 +999,314 @@ func loadFromRoots(params loaderParams) *loader {\n \n \t\tld.buildStacks()\n \n+\t\tchanged, err := ld.updateRequirements(ctx)\n+\t\tif err != nil {\n+\t\t\tld.errorf(\"go: %v\\n\", err)\n+\t\t\tbreak\n+\t\t}\n+\t\tif changed {\n+\t\t\t// Don't resolve missing imports until the module graph have stabilized.\n+\t\t\t// If the roots are still changing, they may turn out to specify a\n+\t\t\t// requirement on the missing package(s), and we would rather use a\n+\t\t\t// version specified by a new root than add a new dependency on an\n+\t\t\t// unrelated version.\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif !ld.ResolveMissingImports || (!HasModRoot() && !allowMissingModuleImports) {\n \t\t\t// We've loaded as much as we can without resolving missing imports.\n \t\t\tbreak\n \t\t}\n-\t\tmodAddedBy := ld.resolveMissingImports(addedModuleFor)\n+\n+\t\tmodAddedBy := ld.resolveMissingImports(ctx)\n \t\tif len(modAddedBy) == 0 {\n+\t\t\t// The roots are stable, and we've resolved all of the missing packages\n+\t\t\t// that we can.\n \t\t\tbreak\n \t\t}\n \n-\t\t// Recompute buildList with all our additions.\n-\t\treqs = &mvsReqs{buildList: buildList}\n-\t\tbuildList, err = mvs.BuildList(Target, reqs)\n+\t\ttoAdd := make([]module.Version, 0, len(modAddedBy))\n+\t\tfor m, _ := range modAddedBy {\n+\t\t\ttoAdd = append(toAdd, m)\n+\t\t}\n+\t\tmodule.Sort(toAdd) // to make errors deterministic\n+\n+\t\t// We ran updateRequirements before resolving missing imports and it didn't\n+\t\t// make any changes, so we know that the requirement graph is already\n+\t\t// consistent with ld.pkgs: we don't need to pass ld.pkgs to updateRoots\n+\t\t// again. (That would waste time looking for changes that we have already\n+\t\t// applied.)\n+\t\tvar noPkgs []*loadPkg\n+\t\t// We also know that we're going to call updateRequirements again next\n+\t\t// iteration so we don't need to also update it here. (That would waste time\n+\t\t// computing a \"direct\" map that we'll have to recompute later anyway.)\n+\t\tdirect := ld.requirements.direct\n+\t\trs, err := updateRoots(ctx, direct, ld.requirements, noPkgs, toAdd, ld.AssumeRootsImported)\n \t\tif err != nil {\n \t\t\t// If an error was found in a newly added module, report the package\n \t\t\t// import stack instead of the module requirement stack. Packages\n \t\t\t// are more descriptive.\n \t\t\tif err, ok := err.(*mvs.BuildListError); ok {\n \t\t\t\tif pkg := modAddedBy[err.Module()]; pkg != nil {\n-\t\t\t\t\tbase.Fatalf(\"go: %s: %v\", pkg.stackText(), err.Err)\n+\t\t\t\t\tld.errorf(\"go: %s: %v\\n\", pkg.stackText(), err.Err)\n+\t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n-\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t\tld.errorf(\"go: %v\\n\", err)\n+\t\t\tbreak\n \t\t}\n+\t\tif reflect.DeepEqual(rs.rootModules, ld.requirements.rootModules) {\n+\t\t\t// Something is deeply wrong. resolveMissingImports gave us a non-empty\n+\t\t\t// set of modules to add to the graph, but adding those modules had no\n+\t\t\t// effect \u2014 either they were already in the graph, or updateRoots did not\n+\t\t\t// add them as requested.\n+\t\t\tpanic(fmt.Sprintf(\"internal error: adding %v to module graph had no effect on root requirements (%v)\", toAdd, rs.rootModules))\n+\t\t}\n+\t\tld.requirements = rs\n \t}\n-\tbase.ExitIfErrors()\n+\tbase.ExitIfErrors() // TODO(bcmills): Is this actually needed?\n \n-\t// Compute directly referenced dependency modules.\n-\tld.direct = make(map[string]bool)\n-\tfor _, pkg := range ld.pkgs {\n-\t\tif pkg.mod == Target {\n-\t\t\tfor _, dep := range pkg.imports {\n-\t\t\t\tif dep.mod.Path != \"\" && dep.mod.Path != Target.Path && index != nil {\n-\t\t\t\t\t_, explicit := index.require[dep.mod]\n-\t\t\t\t\tif allowWriteGoMod && cfg.BuildMod == \"readonly\" && !explicit {\n-\t\t\t\t\t\t// TODO(#40775): attach error to package instead of using\n-\t\t\t\t\t\t// base.Errorf. Ideally, 'go list' should not fail because of this,\n-\t\t\t\t\t\t// but today, LoadPackages calls WriteGoMod unconditionally, which\n-\t\t\t\t\t\t// would fail with a less clear message.\n-\t\t\t\t\t\tbase.Errorf(\"go: %[1]s: package %[2]s imported from implicitly required module; to add missing requirements, run:\\n\\tgo get %[2]s@%[3]s\", pkg.path, dep.path, dep.mod.Version)\n-\t\t\t\t\t}\n-\t\t\t\t\tld.direct[dep.mod.Path] = true\n+\t// Tidy the build list, if applicable, before we report errors.\n+\t// (The process of tidying may remove errors from irrelevant dependencies.)\n+\tif ld.Tidy {\n+\t\trs, err := tidyRoots(ctx, ld.requirements, ld.pkgs)\n+\t\tif err != nil {\n+\t\t\tld.errorf(\"go: %v\\n\", err)\n+\t\t}\n+\n+\t\tif ld.requirements.depth == lazy {\n+\t\t\t// We continuously add tidy roots to ld.requirements during loading, so at\n+\t\t\t// this point the tidy roots should be a subset of the roots of\n+\t\t\t// ld.requirements, ensuring that no new dependencies are brought inside\n+\t\t\t// the lazy-loading horizon.\n+\t\t\t// If that is not the case, there is a bug in the loading loop above.\n+\t\t\tfor _, m := range rs.rootModules {\n+\t\t\t\tif v, ok := ld.requirements.rootSelected(m.Path); !ok || v != m.Version {\n+\t\t\t\t\tld.errorf(\"go mod tidy: internal error: a requirement on %v is needed but was not added during package loading\\n\", m)\n+\t\t\t\t\tbase.ExitIfErrors()\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tld.requirements = rs\n \t}\n-\tbase.ExitIfErrors()\n+\n+\t// Report errors, if any.\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif pkg.err == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Add importer information to checksum errors.\n+\t\tif sumErr := (*ImportMissingSumError)(nil); errors.As(pkg.err, &sumErr) {\n+\t\t\tif importer := pkg.stack; importer != nil {\n+\t\t\t\tsumErr.importer = importer.path\n+\t\t\t\tsumErr.importerVersion = importer.mod.Version\n+\t\t\t\tsumErr.importerIsTest = importer.testOf != nil\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ld.SilencePackageErrors {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif stdErr := (*ImportMissingError)(nil); errors.As(pkg.err, &stdErr) &&\n+\t\t\tstdErr.isStd && ld.SilenceMissingStdImports {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif ld.SilenceNoGoErrors && errors.Is(pkg.err, imports.ErrNoGo) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tld.errorf(\"%s: %v\\n\", pkg.stackText(), pkg.err)\n+\t}\n+\n+\tld.checkMultiplePaths()\n+\treturn ld\n+}\n+\n+// updateRequirements ensures that ld.requirements is consistent with the\n+// information gained from ld.pkgs and includes the modules in add as roots at\n+// at least the given versions.\n+//\n+// In particular:\n+//\n+// \t- Modules that provide packages directly imported from the main module are\n+// \t  marked as direct, and are promoted to explicit roots. If a needed root\n+// \t  cannot be promoted due to -mod=readonly or -mod=vendor, the importing\n+// \t  package is marked with an error.\n+//\n+// \t- If ld scanned the \"all\" pattern independent of build constraints, it is\n+// \t  guaranteed to have seen every direct import. Module dependencies that did\n+// \t  not provide any directly-imported package are then marked as indirect.\n+//\n+// \t- Root dependencies are updated to their selected versions.\n+//\n+// The \"changed\" return value reports whether the update changed the selected\n+// version of any module that either provided a loaded package or may now\n+// provide a package that was previously unresolved.\n+func (ld *loader) updateRequirements(ctx context.Context) (changed bool, err error) {\n+\trs := ld.requirements\n+\n+\t// direct contains the set of modules believed to provide packages directly\n+\t// imported by the main module.\n+\tvar direct map[string]bool\n \n \t// If we didn't scan all of the imports from the main module, or didn't use\n \t// imports.AnyTags, then we didn't necessarily load every package that\n-\t// contributes \u201cdirect\u201d imports \u2014 so we can't safely mark existing\n-\t// dependencies as indirect-only.\n-\t// Conservatively mark those dependencies as direct.\n-\tif modFile != nil && (!ld.allPatternIsRoot || !reflect.DeepEqual(ld.Tags, imports.AnyTags())) {\n-\t\tfor _, r := range modFile.Require {\n-\t\t\tif !r.Indirect {\n-\t\t\t\tld.direct[r.Mod.Path] = true\n+\t// contributes \u201cdirect\u201d imports \u2014 so we can't safely mark existing direct\n+\t// dependencies in ld.requirements as indirect-only. Propagate them as direct.\n+\tloadedDirect := ld.allPatternIsRoot && reflect.DeepEqual(ld.Tags, imports.AnyTags())\n+\tif loadedDirect {\n+\t\tdirect = make(map[string]bool)\n+\t} else {\n+\t\t// TODO(bcmills): It seems like a shame to allocate and copy a map here when\n+\t\t// it will only rarely actually vary from rs.direct. Measure this cost and\n+\t\t// maybe avoid the copy.\n+\t\tdirect = make(map[string]bool, len(rs.direct))\n+\t\tfor mPath := range rs.direct {\n+\t\t\tdirect[mPath] = true\n+\t\t}\n+\t}\n+\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif pkg.mod != Target {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, dep := range pkg.imports {\n+\t\t\tif !dep.fromExternalModule() {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif pkg.err == nil && cfg.BuildMod != \"mod\" {\n+\t\t\t\tif v, ok := rs.rootSelected(dep.mod.Path); !ok || v != dep.mod.Version {\n+\t\t\t\t\t// dep.mod is not an explicit dependency, but needs to be.\n+\t\t\t\t\t// Because we are not in \"mod\" mode, we will not be able to update it.\n+\t\t\t\t\t// Instead, mark the importing package with an error.\n+\t\t\t\t\t//\n+\t\t\t\t\t// TODO(#41688): The resulting error message fails to include the file\n+\t\t\t\t\t// position of the import statement (because that information is not\n+\t\t\t\t\t// tracked by the module loader). Figure out how to plumb the import\n+\t\t\t\t\t// position through.\n+\t\t\t\t\tpkg.err = &DirectImportFromImplicitDependencyError{\n+\t\t\t\t\t\tImporterPath: pkg.path,\n+\t\t\t\t\t\tImportedPath: dep.path,\n+\t\t\t\t\t\tModule:       dep.mod,\n+\t\t\t\t\t}\n+\t\t\t\t\t// cfg.BuildMod does not allow us to change dep.mod to be a direct\n+\t\t\t\t\t// dependency, so don't mark it as such.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// dep is a package directly imported by a package or test in the main\n+\t\t\t// module and loaded from some other module (not the standard library).\n+\t\t\t// Mark its module as a direct dependency.\n+\t\t\tdirect[dep.mod.Path] = true\n \t\t}\n \t}\n \n-\treturn ld\n+\tvar addRoots []module.Version\n+\tif ld.Tidy {\n+\t\t// When we are tidying a lazy module, we may need to add roots to preserve\n+\t\t// the versions of indirect, test-only dependencies that are upgraded\n+\t\t// above or otherwise missing from the go.mod files of direct\n+\t\t// dependencies. (For example, the direct dependency might be a very\n+\t\t// stable codebase that predates modules and thus lacks a go.mod file, or\n+\t\t// the author of the direct dependency may have forgotten to commit a\n+\t\t// change to the go.mod file, or may have made an erroneous hand-edit that\n+\t\t// causes it to be untidy.)\n+\t\t//\n+\t\t// Promoting an indirect dependency to a root adds the next layer of its\n+\t\t// dependencies to the module graph, which may increase the selected\n+\t\t// versions of other modules from which we have already loaded packages.\n+\t\t// So after we promote an indirect dependency to a root, we need to reload\n+\t\t// packages, which means another iteration of loading.\n+\t\t//\n+\t\t// As an extra wrinkle, the upgrades due to promoting a root can cause\n+\t\t// previously-resolved packages to become unresolved. For example, the\n+\t\t// module providing an unstable package might be upgraded to a version\n+\t\t// that no longer contains that package. If we then resolve the missing\n+\t\t// package, we might add yet another root that upgrades away some other\n+\t\t// dependency. (The tests in mod_tidy_convergence*.txt illustrate some\n+\t\t// particularly worrisome cases.)\n+\t\t//\n+\t\t// To ensure that this process of promoting, adding, and upgrading roots\n+\t\t// eventually terminates, during iteration we only ever add modules to the\n+\t\t// root set \u2014 we only remove irrelevant roots at the very end of\n+\t\t// iteration, after we have already added every root that we plan to need\n+\t\t// in the (eventual) tidy root set.\n+\t\t//\n+\t\t// Since we do not remove any roots during iteration, even if they no\n+\t\t// longer provide any imported packages, the selected versions of the\n+\t\t// roots can only increase and the set of roots can only expand. The set\n+\t\t// of extant root paths is finite and the set of versions of each path is\n+\t\t// finite, so the iteration *must* reach a stable fixed-point.\n+\t\ttidy, err := tidyRoots(ctx, rs, ld.pkgs)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\taddRoots = tidy.rootModules\n+\t}\n+\n+\trs, err = updateRoots(ctx, direct, rs, ld.pkgs, addRoots, ld.AssumeRootsImported)\n+\tif err != nil {\n+\t\t// We don't actually know what even the root requirements are supposed to be,\n+\t\t// so we can't proceed with loading. Return the error to the caller\n+\t\treturn false, err\n+\t}\n+\n+\tif rs != ld.requirements && !reflect.DeepEqual(rs.rootModules, ld.requirements.rootModules) {\n+\t\t// The roots of the module graph have changed in some way (not just the\n+\t\t// \"direct\" markings). Check whether the changes affected any of the loaded\n+\t\t// packages.\n+\t\tmg, err := rs.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\tfor _, pkg := range ld.pkgs {\n+\t\t\tif pkg.fromExternalModule() && mg.Selected(pkg.mod.Path) != pkg.mod.Version {\n+\t\t\t\tchanged = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif pkg.err != nil {\n+\t\t\t\t// Promoting a module to a root may resolve an import that was\n+\t\t\t\t// previously missing (by pulling in a previously-prune dependency that\n+\t\t\t\t// provides it) or ambiguous (by promoting exactly one of the\n+\t\t\t\t// alternatives to a root and ignoring the second-level alternatives) or\n+\t\t\t\t// otherwise errored out (by upgrading from a version that cannot be\n+\t\t\t\t// fetched to one that can be).\n+\t\t\t\t//\n+\t\t\t\t// Instead of enumerating all of the possible errors, we'll just check\n+\t\t\t\t// whether importFromModules returns nil for the package.\n+\t\t\t\t// False-positives are ok: if we have a false-positive here, we'll do an\n+\t\t\t\t// extra iteration of package loading this time, but we'll still\n+\t\t\t\t// converge when the root set stops changing.\n+\t\t\t\t//\n+\t\t\t\t// In some sense, we can think of this as \u2018upgraded the module providing\n+\t\t\t\t// pkg.path from \"none\" to a version higher than \"none\"\u2019.\n+\t\t\t\tif _, _, err = importFromModules(ctx, pkg.path, rs, nil); err == nil {\n+\t\t\t\t\tchanged = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tld.requirements = rs\n+\treturn changed, nil\n }\n \n-// resolveMissingImports adds module dependencies to the global build list\n-// in order to resolve missing packages from pkgs.\n+// resolveMissingImports returns a set of modules that could be added as\n+// dependencies in order to resolve missing packages from pkgs.\n //\n // The newly-resolved packages are added to the addedModuleFor map, and\n-// resolveMissingImports returns a map from each newly-added module version to\n-// the first package for which that module was added.\n-func (ld *loader) resolveMissingImports(addedModuleFor map[string]bool) (modAddedBy map[module.Version]*loadPkg) {\n-\tvar needPkgs []*loadPkg\n+// resolveMissingImports returns a map from each new module version to\n+// the first missing package that module would resolve.\n+func (ld *loader) resolveMissingImports(ctx context.Context) (modAddedBy map[module.Version]*loadPkg) {\n+\ttype pkgMod struct {\n+\t\tpkg *loadPkg\n+\t\tmod *module.Version\n+\t}\n+\tvar pkgMods []pkgMod\n \tfor _, pkg := range ld.pkgs {\n \t\tif pkg.err == nil {\n \t\t\tcontinue\n@@ -928,30 +1321,47 @@ func (ld *loader) resolveMissingImports(addedModuleFor map[string]bool) (modAdde\n \t\t\tcontinue\n \t\t}\n \n-\t\tneedPkgs = append(needPkgs, pkg)\n-\n \t\tpkg := pkg\n+\t\tvar mod module.Version\n \t\tld.work.Add(func() {\n-\t\t\tpkg.mod, pkg.err = queryImport(context.TODO(), pkg.path)\n+\t\t\tvar err error\n+\t\t\tmod, err = queryImport(ctx, pkg.path, ld.requirements)\n+\t\t\tif err != nil {\n+\t\t\t\t// pkg.err was already non-nil, so we can reasonably attribute the error\n+\t\t\t\t// for pkg to either the original error or the one returned by\n+\t\t\t\t// queryImport. The existing error indicates only that we couldn't find\n+\t\t\t\t// the package, whereas the query error also explains why we didn't fix\n+\t\t\t\t// the problem \u2014 so we prefer the latter.\n+\t\t\t\tpkg.err = err\n+\t\t\t}\n+\n+\t\t\t// err is nil, but we intentionally leave pkg.err non-nil and pkg.mod\n+\t\t\t// unset: we still haven't satisfied other invariants of a\n+\t\t\t// successfully-loaded package, such as scanning and loading the imports\n+\t\t\t// of that package. If we succeed in resolving the new dependency graph,\n+\t\t\t// the caller can reload pkg and update the error at that point.\n+\t\t\t//\n+\t\t\t// Even then, the package might not be loaded from the version we've\n+\t\t\t// identified here. The module may be upgraded by some other dependency,\n+\t\t\t// or by a transitive dependency of mod itself, or \u2014 less likely \u2014 the\n+\t\t\t// package may be rejected by an AllowPackage hook or rendered ambiguous\n+\t\t\t// by some other newly-added or newly-upgraded dependency.\n \t\t})\n+\n+\t\tpkgMods = append(pkgMods, pkgMod{pkg: pkg, mod: &mod})\n \t}\n \t<-ld.work.Idle()\n \n \tmodAddedBy = map[module.Version]*loadPkg{}\n-\tfor _, pkg := range needPkgs {\n-\t\tif pkg.err != nil {\n+\tfor _, pm := range pkgMods {\n+\t\tpkg, mod := pm.pkg, *pm.mod\n+\t\tif mod.Path == \"\" {\n \t\t\tcontinue\n \t\t}\n \n-\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, pkg.mod.Path, pkg.mod.Version)\n-\t\tif addedModuleFor[pkg.path] {\n-\t\t\t// TODO(bcmills): This should only be an error if pkg.mod is the same\n-\t\t\t// version we already tried to add previously.\n-\t\t\tbase.Fatalf(\"go: %s: looping trying to add package\", pkg.stackText())\n-\t\t}\n-\t\tif modAddedBy[pkg.mod] == nil {\n-\t\t\tmodAddedBy[pkg.mod] = pkg\n-\t\t\tbuildList = append(buildList, pkg.mod)\n+\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, mod.Path, mod.Version)\n+\t\tif modAddedBy[mod] == nil {\n+\t\t\tmodAddedBy[mod] = pkg\n \t\t}\n \t}\n \n@@ -965,7 +1375,7 @@ func (ld *loader) resolveMissingImports(addedModuleFor map[string]bool) (modAdde\n // ld.work queue, and its test (if requested) will also be populated once\n // imports have been resolved. When ld.work goes idle, all transitive imports of\n // the requested package (and its test, if requested) will have been loaded.\n-func (ld *loader) pkg(path string, flags loadPkgFlags) *loadPkg {\n+func (ld *loader) pkg(ctx context.Context, path string, flags loadPkgFlags) *loadPkg {\n \tif flags.has(pkgImportsLoaded) {\n \t\tpanic(\"internal error: (*loader).pkg called with pkgImportsLoaded flag set\")\n \t}\n@@ -974,20 +1384,20 @@ func (ld *loader) pkg(path string, flags loadPkgFlags) *loadPkg {\n \t\tpkg := &loadPkg{\n \t\t\tpath: path,\n \t\t}\n-\t\tld.applyPkgFlags(pkg, flags)\n+\t\tld.applyPkgFlags(ctx, pkg, flags)\n \n-\t\tld.work.Add(func() { ld.load(pkg) })\n+\t\tld.work.Add(func() { ld.load(ctx, pkg) })\n \t\treturn pkg\n \t}).(*loadPkg)\n \n-\tld.applyPkgFlags(pkg, flags)\n+\tld.applyPkgFlags(ctx, pkg, flags)\n \treturn pkg\n }\n \n // applyPkgFlags updates pkg.flags to set the given flags and propagate the\n // (transitive) effects of those flags, possibly loading or enqueueing further\n // packages as a result.\n-func (ld *loader) applyPkgFlags(pkg *loadPkg, flags loadPkgFlags) {\n+func (ld *loader) applyPkgFlags(ctx context.Context, pkg *loadPkg, flags loadPkgFlags) {\n \tif flags == 0 {\n \t\treturn\n \t}\n@@ -996,6 +1406,9 @@ func (ld *loader) applyPkgFlags(pkg *loadPkg, flags loadPkgFlags) {\n \t\t// This package matches a root pattern by virtue of being in \"all\".\n \t\tflags |= pkgIsRoot\n \t}\n+\tif flags.has(pkgIsRoot) {\n+\t\tflags |= pkgFromRoot\n+\t}\n \n \told := pkg.flags.update(flags)\n \tnew := old | flags\n@@ -1039,21 +1452,108 @@ func (ld *loader) applyPkgFlags(pkg *loadPkg, flags loadPkgFlags) {\n \t\t\t\t// of packages in \"all\" if \"all\" closes over test dependencies.\n \t\t\t\ttestFlags |= pkgInAll\n \t\t\t}\n-\t\t\tld.pkgTest(pkg, testFlags)\n+\t\t\tld.pkgTest(ctx, pkg, testFlags)\n \t\t}\n \t}\n \n \tif new.has(pkgInAll) && !old.has(pkgInAll|pkgImportsLoaded) {\n \t\t// We have just marked pkg with pkgInAll, or we have just loaded its\n \t\t// imports, or both. Now is the time to propagate pkgInAll to the imports.\n \t\tfor _, dep := range pkg.imports {\n-\t\t\tld.applyPkgFlags(dep, pkgInAll)\n+\t\t\tld.applyPkgFlags(ctx, dep, pkgInAll)\n \t\t}\n \t}\n+\n+\tif new.has(pkgFromRoot) && !old.has(pkgFromRoot|pkgImportsLoaded) {\n+\t\tfor _, dep := range pkg.imports {\n+\t\t\tld.applyPkgFlags(ctx, dep, pkgFromRoot)\n+\t\t}\n+\t}\n+}\n+\n+// preloadRootModules loads the module requirements needed to identify the\n+// selected version of each module providing a package in rootPkgs,\n+// adding new root modules to the module graph if needed.\n+func (ld *loader) preloadRootModules(ctx context.Context, rootPkgs []string) (changedBuildList bool) {\n+\tneedc := make(chan map[module.Version]bool, 1)\n+\tneedc <- map[module.Version]bool{}\n+\tfor _, path := range rootPkgs {\n+\t\tpath := path\n+\t\tld.work.Add(func() {\n+\t\t\t// First, try to identify the module containing the package using only roots.\n+\t\t\t//\n+\t\t\t// If the main module is tidy and the package is in \"all\" \u2014 or if we're\n+\t\t\t// lucky \u2014 we can identify all of its imports without actually loading the\n+\t\t\t// full module graph.\n+\t\t\tm, _, err := importFromModules(ctx, path, ld.requirements, nil)\n+\t\t\tif err != nil {\n+\t\t\t\tvar missing *ImportMissingError\n+\t\t\t\tif errors.As(err, &missing) && ld.ResolveMissingImports {\n+\t\t\t\t\t// This package isn't provided by any selected module.\n+\t\t\t\t\t// If we can find it, it will be a new root dependency.\n+\t\t\t\t\tm, err = queryImport(ctx, path, ld.requirements)\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\t// We couldn't identify the root module containing this package.\n+\t\t\t\t\t// Leave it unresolved; we will report it during loading.\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif m.Path == \"\" {\n+\t\t\t\t// The package is in std or cmd. We don't need to change the root set.\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tv, ok := ld.requirements.rootSelected(m.Path)\n+\t\t\tif !ok || v != m.Version {\n+\t\t\t\t// We found the requested package in m, but m is not a root, so\n+\t\t\t\t// loadModGraph will not load its requirements. We need to promote the\n+\t\t\t\t// module to a root to ensure that any other packages this package\n+\t\t\t\t// imports are resolved from correct dependency versions.\n+\t\t\t\t//\n+\t\t\t\t// (This is the \u201cargument invariant\u201d from the lazy loading design.)\n+\t\t\t\tneed := <-needc\n+\t\t\t\tneed[m] = true\n+\t\t\t\tneedc <- need\n+\t\t\t}\n+\t\t})\n+\t}\n+\t<-ld.work.Idle()\n+\n+\tneed := <-needc\n+\tif len(need) == 0 {\n+\t\treturn false // No roots to add.\n+\t}\n+\n+\ttoAdd := make([]module.Version, 0, len(need))\n+\tfor m := range need {\n+\t\ttoAdd = append(toAdd, m)\n+\t}\n+\tmodule.Sort(toAdd)\n+\n+\trs, err := updateRoots(ctx, ld.requirements.direct, ld.requirements, nil, toAdd, ld.AssumeRootsImported)\n+\tif err != nil {\n+\t\t// We are missing some root dependency, and for some reason we can't load\n+\t\t// enough of the module dependency graph to add the missing root. Package\n+\t\t// loading is doomed to fail, so fail quickly.\n+\t\tld.errorf(\"go: %v\\n\", err)\n+\t\tbase.ExitIfErrors()\n+\t\treturn false\n+\t}\n+\tif reflect.DeepEqual(rs.rootModules, ld.requirements.rootModules) {\n+\t\t// Something is deeply wrong. resolveMissingImports gave us a non-empty\n+\t\t// set of modules to add to the graph, but adding those modules had no\n+\t\t// effect \u2014 either they were already in the graph, or updateRoots did not\n+\t\t// add them as requested.\n+\t\tpanic(fmt.Sprintf(\"internal error: adding %v to module graph had no effect on root requirements (%v)\", toAdd, rs.rootModules))\n+\t}\n+\n+\tld.requirements = rs\n+\treturn true\n }\n \n // load loads an individual package.\n-func (ld *loader) load(pkg *loadPkg) {\n+func (ld *loader) load(ctx context.Context, pkg *loadPkg) {\n \tif strings.Contains(pkg.path, \"@\") {\n \t\t// Leave for error during load.\n \t\treturn\n@@ -1072,7 +1572,24 @@ func (ld *loader) load(pkg *loadPkg) {\n \t\treturn\n \t}\n \n-\tpkg.mod, pkg.dir, pkg.err = importFromBuildList(context.TODO(), pkg.path, buildList)\n+\tvar mg *ModuleGraph\n+\tif ld.requirements.depth == eager {\n+\t\tvar err error\n+\t\tmg, err = ld.requirements.Graph(ctx)\n+\t\tif err != nil {\n+\t\t\t// We already checked the error from Graph in loadFromRoots and/or\n+\t\t\t// updateRequirements, so we ignored the error on purpose and we should\n+\t\t\t// keep trying to push past it.\n+\t\t\t//\n+\t\t\t// However, because mg may be incomplete (and thus may select inaccurate\n+\t\t\t// versions), we shouldn't use it to load packages. Instead, we pass a nil\n+\t\t\t// *ModuleGraph, which will cause mg to first try loading from only the\n+\t\t\t// main module and root dependencies.\n+\t\t\tmg = nil\n+\t\t}\n+\t}\n+\n+\tpkg.mod, pkg.dir, pkg.err = importFromModules(ctx, pkg.path, ld.requirements, mg)\n \tif pkg.dir == \"\" {\n \t\treturn\n \t}\n@@ -1086,10 +1603,10 @@ func (ld *loader) load(pkg *loadPkg) {\n \t\t// about (by reducing churn on the flag bits of dependencies), and costs\n \t\t// essentially nothing (these atomic flag ops are essentially free compared\n \t\t// to scanning source code for imports).\n-\t\tld.applyPkgFlags(pkg, pkgInAll)\n+\t\tld.applyPkgFlags(ctx, pkg, pkgInAll)\n \t}\n \tif ld.AllowPackage != nil {\n-\t\tif err := ld.AllowPackage(context.TODO(), pkg.path, pkg.mod); err != nil {\n+\t\tif err := ld.AllowPackage(ctx, pkg.path, pkg.mod); err != nil {\n \t\t\tpkg.err = err\n \t\t}\n \t}\n@@ -1120,19 +1637,19 @@ func (ld *loader) load(pkg *loadPkg) {\n \t\t\t// GOROOT/src/vendor even when \"std\" is not the main module.\n \t\t\tpath = ld.stdVendor(pkg.path, path)\n \t\t}\n-\t\tpkg.imports = append(pkg.imports, ld.pkg(path, importFlags))\n+\t\tpkg.imports = append(pkg.imports, ld.pkg(ctx, path, importFlags))\n \t}\n \tpkg.testImports = testImports\n \n-\tld.applyPkgFlags(pkg, pkgImportsLoaded)\n+\tld.applyPkgFlags(ctx, pkg, pkgImportsLoaded)\n }\n \n // pkgTest locates the test of pkg, creating it if needed, and updates its state\n // to reflect the given flags.\n //\n // pkgTest requires that the imports of pkg have already been loaded (flagged\n // with pkgImportsLoaded).\n-func (ld *loader) pkgTest(pkg *loadPkg, testFlags loadPkgFlags) *loadPkg {\n+func (ld *loader) pkgTest(ctx context.Context, pkg *loadPkg, testFlags loadPkgFlags) *loadPkg {\n \tif pkg.isTest() {\n \t\tpanic(\"pkgTest called on a test package\")\n \t}\n@@ -1147,7 +1664,7 @@ func (ld *loader) pkgTest(pkg *loadPkg, testFlags loadPkgFlags) *loadPkg {\n \t\t\terr:    pkg.err,\n \t\t\tinStd:  pkg.inStd,\n \t\t}\n-\t\tld.applyPkgFlags(pkg.test, testFlags)\n+\t\tld.applyPkgFlags(ctx, pkg.test, testFlags)\n \t\tcreatedTest = true\n \t})\n \n@@ -1162,12 +1679,12 @@ func (ld *loader) pkgTest(pkg *loadPkg, testFlags loadPkgFlags) *loadPkg {\n \t\t\tif pkg.inStd {\n \t\t\t\tpath = ld.stdVendor(test.path, path)\n \t\t\t}\n-\t\t\ttest.imports = append(test.imports, ld.pkg(path, importFlags))\n+\t\t\ttest.imports = append(test.imports, ld.pkg(ctx, path, importFlags))\n \t\t}\n \t\tpkg.testImports = nil\n-\t\tld.applyPkgFlags(test, pkgImportsLoaded)\n+\t\tld.applyPkgFlags(ctx, test, pkgImportsLoaded)\n \t} else {\n-\t\tld.applyPkgFlags(test, testFlags)\n+\t\tld.applyPkgFlags(ctx, test, testFlags)\n \t}\n \n \treturn test\n@@ -1181,13 +1698,13 @@ func (ld *loader) stdVendor(parentPath, path string) string {\n \t}\n \n \tif str.HasPathPrefix(parentPath, \"cmd\") {\n-\t\tif Target.Path != \"cmd\" {\n+\t\tif !ld.VendorModulesInGOROOTSrc || Target.Path != \"cmd\" {\n \t\t\tvendorPath := pathpkg.Join(\"cmd\", \"vendor\", path)\n \t\t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n \t\t\t\treturn vendorPath\n \t\t\t}\n \t\t}\n-\t} else if Target.Path != \"std\" || str.HasPathPrefix(parentPath, \"vendor\") {\n+\t} else if !ld.VendorModulesInGOROOTSrc || Target.Path != \"std\" || str.HasPathPrefix(parentPath, \"vendor\") {\n \t\t// If we are outside of the 'std' module, resolve imports from within 'std'\n \t\t// to the vendor directory.\n \t\t//\n@@ -1222,6 +1739,242 @@ func (ld *loader) computePatternAll() (all []string) {\n \treturn all\n }\n \n+// checkMultiplePaths verifies that a given module path is used as itself\n+// or as a replacement for another module, but not both at the same time.\n+//\n+// (See https://golang.org/issue/26607 and https://golang.org/issue/34650.)\n+func (ld *loader) checkMultiplePaths() {\n+\tmods := ld.requirements.rootModules\n+\tif cached := ld.requirements.graph.Load(); cached != nil {\n+\t\tif mg := cached.(cachedGraph).mg; mg != nil {\n+\t\t\tmods = mg.BuildList()\n+\t\t}\n+\t}\n+\n+\tfirstPath := map[module.Version]string{}\n+\tfor _, mod := range mods {\n+\t\tsrc := resolveReplacement(mod)\n+\t\tif prev, ok := firstPath[src]; !ok {\n+\t\t\tfirstPath[src] = mod.Path\n+\t\t} else if prev != mod.Path {\n+\t\t\tld.errorf(\"go: %s@%s used for two different module paths (%s and %s)\\n\", src.Path, src.Version, prev, mod.Path)\n+\t\t}\n+\t}\n+}\n+\n+// checkTidyCompatibility emits an error if any package would be loaded from a\n+// different module under rs than under ld.requirements.\n+func (ld *loader) checkTidyCompatibility(ctx context.Context, rs *Requirements) {\n+\tsuggestUpgrade := false\n+\tsuggestEFlag := false\n+\tsuggestFixes := func() {\n+\t\tif ld.AllowErrors {\n+\t\t\t// The user is explicitly ignoring these errors, so don't bother them with\n+\t\t\t// other options.\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// We print directly to os.Stderr because this information is advice about\n+\t\t// how to fix errors, not actually an error itself.\n+\t\t// (The actual errors should have been logged already.)\n+\n+\t\tfmt.Fprintln(os.Stderr)\n+\n+\t\tgoFlag := \"\"\n+\t\tif ld.GoVersion != modFileGoVersion() {\n+\t\t\tgoFlag = \" -go=\" + ld.GoVersion\n+\t\t}\n+\n+\t\tcompatFlag := \"\"\n+\t\tif ld.TidyCompatibleVersion != priorGoVersion(ld.GoVersion) {\n+\t\t\tcompatFlag = \" -compat=\" + ld.TidyCompatibleVersion\n+\t\t}\n+\t\tif suggestUpgrade {\n+\t\t\teDesc := \"\"\n+\t\t\teFlag := \"\"\n+\t\t\tif suggestEFlag {\n+\t\t\t\teDesc = \", leaving some packages unresolved\"\n+\t\t\t\teFlag = \" -e\"\n+\t\t\t}\n+\t\t\tfmt.Fprintf(os.Stderr, \"To upgrade to the versions selected by go %s%s:\\n\\tgo mod tidy%s -go=%s && go mod tidy%s -go=%s%s\\n\", ld.TidyCompatibleVersion, eDesc, eFlag, ld.TidyCompatibleVersion, eFlag, ld.GoVersion, compatFlag)\n+\t\t} else if suggestEFlag {\n+\t\t\t// If some packages are missing but no package is upgraded, then we\n+\t\t\t// shouldn't suggest upgrading to the Go 1.16 versions explicitly \u2014 that\n+\t\t\t// wouldn't actually fix anything for Go 1.16 users, and *would* break\n+\t\t\t// something for Go 1.17 users.\n+\t\t\tfmt.Fprintf(os.Stderr, \"To proceed despite packages unresolved in go %s:\\n\\tgo mod tidy -e%s%s\\n\", ld.TidyCompatibleVersion, goFlag, compatFlag)\n+\t\t}\n+\n+\t\tfmt.Fprintf(os.Stderr, \"If reproducibility with go %s is not needed:\\n\\tgo mod tidy%s -compat=%s\\n\", ld.TidyCompatibleVersion, goFlag, ld.GoVersion)\n+\n+\t\t// TODO(#46141): Populate the linked wiki page.\n+\t\tfmt.Fprintf(os.Stderr, \"For other options, see:\\n\\thttps://golang.org/doc/modules/pruning\\n\")\n+\t}\n+\n+\tmg, err := rs.Graph(ctx)\n+\tif err != nil {\n+\t\tld.errorf(\"go mod tidy: error loading go %s module graph: %v\\n\", ld.TidyCompatibleVersion, err)\n+\t\tsuggestFixes()\n+\t\treturn\n+\t}\n+\n+\t// Re-resolve packages in parallel.\n+\t//\n+\t// We re-resolve each package \u2014 rather than just checking versions \u2014 to ensure\n+\t// that we have fetched module source code (and, importantly, checksums for\n+\t// that source code) for all modules that are necessary to ensure that imports\n+\t// are unambiguous. That also produces clearer diagnostics, since we can say\n+\t// exactly what happened to the package if it became ambiguous or disappeared\n+\t// entirely.\n+\t//\n+\t// We re-resolve the packages in parallel because this process involves disk\n+\t// I/O to check for package sources, and because the process of checking for\n+\t// ambiguous imports may require us to download additional modules that are\n+\t// otherwise pruned out in Go 1.17 \u2014 we don't want to block progress on other\n+\t// packages while we wait for a single new download.\n+\ttype mismatch struct {\n+\t\tmod module.Version\n+\t\terr error\n+\t}\n+\tmismatchMu := make(chan map[*loadPkg]mismatch, 1)\n+\tmismatchMu <- map[*loadPkg]mismatch{}\n+\tfor _, pkg := range ld.pkgs {\n+\t\tif pkg.mod.Path == \"\" && pkg.err == nil {\n+\t\t\t// This package is from the standard library (which does not vary based on\n+\t\t\t// the module graph).\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpkg := pkg\n+\t\tld.work.Add(func() {\n+\t\t\tmod, _, err := importFromModules(ctx, pkg.path, rs, mg)\n+\t\t\tif mod != pkg.mod {\n+\t\t\t\tmismatches := <-mismatchMu\n+\t\t\t\tmismatches[pkg] = mismatch{mod: mod, err: err}\n+\t\t\t\tmismatchMu <- mismatches\n+\t\t\t}\n+\t\t})\n+\t}\n+\t<-ld.work.Idle()\n+\n+\tmismatches := <-mismatchMu\n+\tif len(mismatches) == 0 {\n+\t\t// Since we're running as part of 'go mod tidy', the roots of the module\n+\t\t// graph should contain only modules that are relevant to some package in\n+\t\t// the package graph. We checked every package in the package graph and\n+\t\t// didn't find any mismatches, so that must mean that all of the roots of\n+\t\t// the module graph are also consistent.\n+\t\t//\n+\t\t// If we're wrong, Go 1.16 in -mod=readonly mode will error out with\n+\t\t// \"updates to go.mod needed\", which would be very confusing. So instead,\n+\t\t// we'll double-check that our reasoning above actually holds \u2014 if it\n+\t\t// doesn't, we'll emit an internal error and hopefully the user will report\n+\t\t// it as a bug.\n+\t\tfor _, m := range ld.requirements.rootModules {\n+\t\t\tif v := mg.Selected(m.Path); v != m.Version {\n+\t\t\t\tfmt.Fprintln(os.Stderr)\n+\t\t\t\tbase.Fatalf(\"go: internal error: failed to diagnose selected-version mismatch for module %s: go %s selects %s, but go %s selects %s\\n\\tPlease report this at https://golang.org/issue.\", m.Path, ld.GoVersion, m.Version, ld.TidyCompatibleVersion, v)\n+\t\t\t}\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\t// Iterate over the packages (instead of the mismatches map) to emit errors in\n+\t// deterministic order.\n+\tfor _, pkg := range ld.pkgs {\n+\t\tmismatch, ok := mismatches[pkg]\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif pkg.isTest() {\n+\t\t\t// We already did (or will) report an error for the package itself,\n+\t\t\t// so don't report a duplicate (and more vebose) error for its test.\n+\t\t\tif _, ok := mismatches[pkg.testOf]; !ok {\n+\t\t\t\tbase.Fatalf(\"go: internal error: mismatch recorded for test %s, but not its non-test package\", pkg.path)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tswitch {\n+\t\tcase mismatch.err != nil:\n+\t\t\t// pkg resolved successfully, but errors out using the requirements in rs.\n+\t\t\t//\n+\t\t\t// This could occur because the import is provided by a single lazy root\n+\t\t\t// (and is thus unambiguous in lazy mode) and also one or more\n+\t\t\t// transitive dependencies (and is ambiguous in eager mode).\n+\t\t\t//\n+\t\t\t// It could also occur because some transitive dependency upgrades the\n+\t\t\t// module that previously provided the package to a version that no\n+\t\t\t// longer does, or to a version for which the module source code (but\n+\t\t\t// not the go.mod file in isolation) has a checksum error.\n+\t\t\tif missing := (*ImportMissingError)(nil); errors.As(mismatch.err, &missing) {\n+\t\t\t\tselected := module.Version{\n+\t\t\t\t\tPath:    pkg.mod.Path,\n+\t\t\t\t\tVersion: mg.Selected(pkg.mod.Path),\n+\t\t\t\t}\n+\t\t\t\tld.errorf(\"%s loaded from %v,\\n\\tbut go %s would fail to locate it in %s\\n\", pkg.stackText(), pkg.mod, ld.TidyCompatibleVersion, selected)\n+\t\t\t} else {\n+\t\t\t\tif ambiguous := (*AmbiguousImportError)(nil); errors.As(mismatch.err, &ambiguous) {\n+\t\t\t\t\t// TODO: Is this check needed?\n+\t\t\t\t}\n+\t\t\t\tld.errorf(\"%s loaded from %v,\\n\\tbut go %s would fail to locate it:\\n\\t%v\\n\", pkg.stackText(), pkg.mod, ld.TidyCompatibleVersion, mismatch.err)\n+\t\t\t}\n+\n+\t\t\tsuggestEFlag = true\n+\n+\t\t\t// Even if we press ahead with the '-e' flag, the older version will\n+\t\t\t// error out in readonly mode if it thinks the go.mod file contains\n+\t\t\t// any *explicit* dependency that is not at its selected version,\n+\t\t\t// even if that dependency is not relevant to any package being loaded.\n+\t\t\t//\n+\t\t\t// We check for that condition here. If all of the roots are consistent\n+\t\t\t// the '-e' flag suffices, but otherwise we need to suggest an upgrade.\n+\t\t\tif !suggestUpgrade {\n+\t\t\t\tfor _, m := range ld.requirements.rootModules {\n+\t\t\t\t\tif v := mg.Selected(m.Path); v != m.Version {\n+\t\t\t\t\t\tsuggestUpgrade = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tcase pkg.err != nil:\n+\t\t\t// pkg had an error in lazy mode (presumably suppressed with the -e flag),\n+\t\t\t// but not in eager mode.\n+\t\t\t//\n+\t\t\t// This is possible, if, say, the import is unresolved in lazy mode\n+\t\t\t// (because the \"latest\" version of each candidate module either is\n+\t\t\t// unavailable or does not contain the package), but is resolved in\n+\t\t\t// eager mode due to a newer-than-latest dependency that is normally\n+\t\t\t// runed out of the module graph.\n+\t\t\t//\n+\t\t\t// This could also occur if the source code for the module providing the\n+\t\t\t// package in lazy mode has a checksum error, but eager mode upgrades\n+\t\t\t// that module to a version with a correct checksum.\n+\t\t\t//\n+\t\t\t// pkg.err should have already been logged elsewhere \u2014 along with a\n+\t\t\t// stack trace \u2014 so log only the import path and non-error info here.\n+\t\t\tsuggestUpgrade = true\n+\t\t\tld.errorf(\"%s failed to load from any module,\\n\\tbut go %s would load it from %v\\n\", pkg.path, ld.TidyCompatibleVersion, mismatch.mod)\n+\n+\t\tcase pkg.mod != mismatch.mod:\n+\t\t\t// The package is loaded successfully by both Go versions, but from a\n+\t\t\t// different module in each. This could lead to subtle (and perhaps even\n+\t\t\t// unnoticed!) variations in behavior between builds with different\n+\t\t\t// toolchains.\n+\t\t\tsuggestUpgrade = true\n+\t\t\tld.errorf(\"%s loaded from %v,\\n\\tbut go %s would select %v\\n\", pkg.stackText(), pkg.mod, ld.TidyCompatibleVersion, mismatch.mod.Version)\n+\n+\t\tdefault:\n+\t\t\tbase.Fatalf(\"go: internal error: mismatch recorded for package %s, but no differences found\", pkg.path)\n+\t\t}\n+\t}\n+\n+\tsuggestFixes()\n+\tbase.ExitIfErrors()\n+}\n+\n // scanDir is like imports.ScanDir but elides known magic imports from the list,\n // so that we do not go looking for packages that don't really exist.\n //"}, {"sha": "03e02e73b63f659f0ec6e3eff89299f691763c6d", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "modified", "additions": 274, "deletions": 145, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,13 +8,15 @@ import (\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\"\n \t\"unicode\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/par\"\n@@ -25,14 +27,58 @@ import (\n \t\"golang.org/x/mod/semver\"\n )\n \n-// narrowAllVersionV is the Go version (plus leading \"v\") at which the\n-// module-module \"all\" pattern no longer closes over the dependencies of\n-// tests outside of the main module.\n-const narrowAllVersionV = \"v1.16\"\n-const go116EnableNarrowAll = true\n+const (\n+\t// narrowAllVersionV is the Go version (plus leading \"v\") at which the\n+\t// module-module \"all\" pattern no longer closes over the dependencies of\n+\t// tests outside of the main module.\n+\tnarrowAllVersionV = \"v1.16\"\n+\n+\t// lazyLoadingVersionV is the Go version (plus leading \"v\") at which a\n+\t// module's go.mod file is expected to list explicit requirements on every\n+\t// module that provides any package transitively imported by that module.\n+\tlazyLoadingVersionV = \"v1.17\"\n+\n+\t// separateIndirectVersionV is the Go version (plus leading \"v\") at which\n+\t// \"// indirect\" dependencies are added in a block separate from the direct\n+\t// ones. See https://golang.org/issue/45965.\n+\tseparateIndirectVersionV = \"v1.17\"\n+)\n+\n+const (\n+\t// go117EnableLazyLoading toggles whether lazy-loading code paths should be\n+\t// active. It will be removed once the lazy loading implementation is stable\n+\t// and well-tested.\n+\tgo117EnableLazyLoading = true\n+\n+\t// go1117LazyTODO is a constant that exists only until lazy loading is\n+\t// implemented. Its use indicates a condition that will need to change if the\n+\t// main module is lazy.\n+\tgo117LazyTODO = false\n+)\n \n var modFile *modfile.File\n \n+// modFileGoVersion returns the (non-empty) Go version at which the requirements\n+// in modFile are intepreted, or the latest Go version if modFile is nil.\n+func modFileGoVersion() string {\n+\tif modFile == nil {\n+\t\treturn LatestGoVersion()\n+\t}\n+\tif modFile.Go == nil || modFile.Go.Version == \"\" {\n+\t\t// The main module necessarily has a go.mod file, and that file lacks a\n+\t\t// 'go' directive. The 'go' command has been adding that directive\n+\t\t// automatically since Go 1.12, so this module either dates to Go 1.11 or\n+\t\t// has been erroneously hand-edited.\n+\t\t//\n+\t\t// The semantics of the go.mod file are more-or-less the same from Go 1.11\n+\t\t// through Go 1.16, changing at 1.17 for lazy loading. So even though a\n+\t\t// go.mod file without a 'go' directive is theoretically a Go 1.11 file,\n+\t\t// scripts may assume that it ends up as a Go 1.16 module.\n+\t\treturn \"1.16\"\n+\t}\n+\treturn modFile.Go.Version\n+}\n+\n // A modFileIndex is an index of data corresponding to a modFile\n // at a specific point in time.\n type modFileIndex struct {\n@@ -53,6 +99,24 @@ type requireMeta struct {\n \tindirect bool\n }\n \n+// A modDepth indicates which dependencies should be loaded for a go.mod file.\n+type modDepth uint8\n+\n+const (\n+\tlazy  modDepth = iota // load dependencies only as needed\n+\teager                 // load all transitive dependencies eagerly\n+)\n+\n+func modDepthFromGoVersion(goVersion string) modDepth {\n+\tif !go117EnableLazyLoading {\n+\t\treturn eager\n+\t}\n+\tif semver.Compare(\"v\"+goVersion, lazyLoadingVersionV) < 0 {\n+\t\treturn eager\n+\t}\n+\treturn lazy\n+}\n+\n // CheckAllowed returns an error equivalent to ErrDisallowed if m is excluded by\n // the main module's go.mod or retracted by its author. Most version queries use\n // this to filter out versions that should not be used.\n@@ -88,76 +152,53 @@ func (e *excludedError) Is(err error) bool { return err == ErrDisallowed }\n \n // CheckRetractions returns an error if module m has been retracted by\n // its author.\n-func CheckRetractions(ctx context.Context, m module.Version) error {\n+func CheckRetractions(ctx context.Context, m module.Version) (err error) {\n+\tdefer func() {\n+\t\tif retractErr := (*ModuleRetractedError)(nil); err == nil || errors.As(err, &retractErr) {\n+\t\t\treturn\n+\t\t}\n+\t\t// Attribute the error to the version being checked, not the version from\n+\t\t// which the retractions were to be loaded.\n+\t\tif mErr := (*module.ModuleError)(nil); errors.As(err, &mErr) {\n+\t\t\terr = mErr.Err\n+\t\t}\n+\t\terr = &retractionLoadingError{m: m, err: err}\n+\t}()\n+\n \tif m.Version == \"\" {\n \t\t// Main module, standard library, or file replacement module.\n \t\t// Cannot be retracted.\n \t\treturn nil\n \t}\n-\n-\t// Look up retraction information from the latest available version of\n-\t// the module. Cache retraction information so we don't parse the go.mod\n-\t// file repeatedly.\n-\ttype entry struct {\n-\t\tretract []retraction\n-\t\terr     error\n+\tif repl := Replacement(module.Version{Path: m.Path}); repl.Path != \"\" {\n+\t\t// All versions of the module were replaced.\n+\t\t// Don't load retractions, since we'd just load the replacement.\n+\t\treturn nil\n \t}\n-\tpath := m.Path\n-\te := retractCache.Do(path, func() (v interface{}) {\n-\t\tctx, span := trace.StartSpan(ctx, \"checkRetractions \"+path)\n-\t\tdefer span.Done()\n-\n-\t\tif repl := Replacement(module.Version{Path: m.Path}); repl.Path != \"\" {\n-\t\t\t// All versions of the module were replaced with a local directory.\n-\t\t\t// Don't load retractions.\n-\t\t\treturn &entry{nil, nil}\n-\t\t}\n-\n-\t\t// Find the latest version of the module.\n-\t\t// Ignore exclusions from the main module's go.mod.\n-\t\tconst ignoreSelected = \"\"\n-\t\tvar allowAll AllowedFunc\n-\t\trev, err := Query(ctx, path, \"latest\", ignoreSelected, allowAll)\n-\t\tif err != nil {\n-\t\t\treturn &entry{nil, err}\n-\t\t}\n-\n-\t\t// Load go.mod for that version.\n-\t\t// If the version is replaced, we'll load retractions from the replacement.\n-\t\t//\n-\t\t// If there's an error loading the go.mod, we'll return it here.\n-\t\t// These errors should generally be ignored by callers of checkRetractions,\n-\t\t// since they happen frequently when we're offline. These errors are not\n-\t\t// equivalent to ErrDisallowed, so they may be distinguished from\n-\t\t// retraction errors.\n-\t\t//\n-\t\t// We load the raw file here: the go.mod file may have a different module\n-\t\t// path that we expect if the module or its repository was renamed.\n-\t\t// We still want to apply retractions to other aliases of the module.\n-\t\trm := module.Version{Path: path, Version: rev.Version}\n-\t\tif repl := Replacement(rm); repl.Path != \"\" {\n-\t\t\trm = repl\n-\t\t}\n-\t\tsummary, err := rawGoModSummary(rm)\n-\t\tif err != nil {\n-\t\t\treturn &entry{nil, err}\n-\t\t}\n-\t\treturn &entry{summary.retract, nil}\n-\t}).(*entry)\n \n-\tif err := e.err; err != nil {\n-\t\t// Attribute the error to the version being checked, not the version from\n-\t\t// which the retractions were to be loaded.\n-\t\tvar mErr *module.ModuleError\n-\t\tif errors.As(err, &mErr) {\n-\t\t\terr = mErr.Err\n-\t\t}\n-\t\treturn &retractionLoadingError{m: m, err: err}\n+\t// Find the latest available version of the module, and load its go.mod. If\n+\t// the latest version is replaced, we'll load the replacement.\n+\t//\n+\t// If there's an error loading the go.mod, we'll return it here. These errors\n+\t// should generally be ignored by callers since they happen frequently when\n+\t// we're offline. These errors are not equivalent to ErrDisallowed, so they\n+\t// may be distinguished from retraction errors.\n+\t//\n+\t// We load the raw file here: the go.mod file may have a different module\n+\t// path that we expect if the module or its repository was renamed.\n+\t// We still want to apply retractions to other aliases of the module.\n+\trm, err := queryLatestVersionIgnoringRetractions(ctx, m.Path)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tsummary, err := rawGoModSummary(rm)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \n \tvar rationale []string\n \tisRetracted := false\n-\tfor _, r := range e.retract {\n+\tfor _, r := range summary.retract {\n \t\tif semver.Compare(r.Low, m.Version) <= 0 && semver.Compare(m.Version, r.High) <= 0 {\n \t\t\tisRetracted = true\n \t\t\tif r.Rationale != \"\" {\n@@ -171,8 +212,6 @@ func CheckRetractions(ctx context.Context, m module.Version) error {\n \treturn nil\n }\n \n-var retractCache par.Cache\n-\n type ModuleRetractedError struct {\n \tRationale []string\n }\n@@ -182,7 +221,7 @@ func (e *ModuleRetractedError) Error() string {\n \tif len(e.Rationale) > 0 {\n \t\t// This is meant to be a short error printed on a terminal, so just\n \t\t// print the first rationale.\n-\t\tmsg += \": \" + ShortRetractionRationale(e.Rationale[0])\n+\t\tmsg += \": \" + ShortMessage(e.Rationale[0], \"retracted by module author\")\n \t}\n \treturn msg\n }\n@@ -204,28 +243,67 @@ func (e *retractionLoadingError) Unwrap() error {\n \treturn e.err\n }\n \n-// ShortRetractionRationale returns a retraction rationale string that is safe\n-// to print in a terminal. It returns hard-coded strings if the rationale\n-// is empty, too long, or contains non-printable characters.\n-func ShortRetractionRationale(rationale string) string {\n-\tconst maxRationaleBytes = 500\n-\tif i := strings.Index(rationale, \"\\n\"); i >= 0 {\n-\t\trationale = rationale[:i]\n-\t}\n-\trationale = strings.TrimSpace(rationale)\n-\tif rationale == \"\" {\n-\t\treturn \"retracted by module author\"\n-\t}\n-\tif len(rationale) > maxRationaleBytes {\n-\t\treturn \"(rationale omitted: too long)\"\n-\t}\n-\tfor _, r := range rationale {\n+// ShortMessage returns a string from go.mod (for example, a retraction\n+// rationale or deprecation message) that is safe to print in a terminal.\n+//\n+// If the given string is empty, ShortMessage returns the given default. If the\n+// given string is too long or contains non-printable characters, ShortMessage\n+// returns a hard-coded string.\n+func ShortMessage(message, emptyDefault string) string {\n+\tconst maxLen = 500\n+\tif i := strings.Index(message, \"\\n\"); i >= 0 {\n+\t\tmessage = message[:i]\n+\t}\n+\tmessage = strings.TrimSpace(message)\n+\tif message == \"\" {\n+\t\treturn emptyDefault\n+\t}\n+\tif len(message) > maxLen {\n+\t\treturn \"(message omitted: too long)\"\n+\t}\n+\tfor _, r := range message {\n \t\tif !unicode.IsGraphic(r) && !unicode.IsSpace(r) {\n-\t\t\treturn \"(rationale omitted: contains non-printable characters)\"\n+\t\t\treturn \"(message omitted: contains non-printable characters)\"\n \t\t}\n \t}\n \t// NOTE: the go.mod parser rejects invalid UTF-8, so we don't check that here.\n-\treturn rationale\n+\treturn message\n+}\n+\n+// CheckDeprecation returns a deprecation message from the go.mod file of the\n+// latest version of the given module. Deprecation messages are comments\n+// before or on the same line as the module directives that start with\n+// \"Deprecated:\" and run until the end of the paragraph.\n+//\n+// CheckDeprecation returns an error if the message can't be loaded.\n+// CheckDeprecation returns \"\", nil if there is no deprecation message.\n+func CheckDeprecation(ctx context.Context, m module.Version) (deprecation string, err error) {\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\terr = fmt.Errorf(\"loading deprecation for %s: %w\", m.Path, err)\n+\t\t}\n+\t}()\n+\n+\tif m.Version == \"\" {\n+\t\t// Main module, standard library, or file replacement module.\n+\t\t// Don't look up deprecation.\n+\t\treturn \"\", nil\n+\t}\n+\tif repl := Replacement(module.Version{Path: m.Path}); repl.Path != \"\" {\n+\t\t// All versions of the module were replaced.\n+\t\t// We'll look up deprecation separately for the replacement.\n+\t\treturn \"\", nil\n+\t}\n+\n+\tlatest, err := queryLatestVersionIgnoringRetractions(ctx, m.Path)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tsummary, err := rawGoModSummary(latest)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn summary.deprecated, nil\n }\n \n // Replacement returns the replacement for mod, if any, from go.mod.\n@@ -243,6 +321,15 @@ func Replacement(mod module.Version) module.Version {\n \treturn module.Version{}\n }\n \n+// resolveReplacement returns the module actually used to load the source code\n+// for m: either m itself, or the replacement for m (iff m is replaced).\n+func resolveReplacement(m module.Version) module.Version {\n+\tif r := Replacement(m); r.Path != \"\" {\n+\t\treturn r\n+\t}\n+\treturn m\n+}\n+\n // indexModFile rebuilds the index of modFile.\n // If modFile has been changed since it was first read,\n // modFile.Cleanup must be called before indexModFile.\n@@ -257,10 +344,13 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \t}\n \n \ti.goVersionV = \"\"\n-\tif modFile.Go != nil {\n+\tif modFile.Go == nil {\n+\t\trawGoVersion.Store(Target, \"\")\n+\t} else {\n \t\t// We're going to use the semver package to compare Go versions, so go ahead\n \t\t// and add the \"v\" prefix it expects once instead of every time.\n \t\ti.goVersionV = \"v\" + modFile.Go.Version\n+\t\trawGoVersion.Store(Target, modFile.Go.Version)\n \t}\n \n \ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n@@ -292,23 +382,6 @@ func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileInd\n \treturn i\n }\n \n-// allPatternClosesOverTests reports whether the \"all\" pattern includes\n-// dependencies of tests outside the main module (as in Go 1.11\u20131.15).\n-// (Otherwise \u2014 as in Go 1.16+ \u2014 the \"all\" pattern includes only the packages\n-// transitively *imported by* the packages and tests in the main module.)\n-func (i *modFileIndex) allPatternClosesOverTests() bool {\n-\tif !go116EnableNarrowAll {\n-\t\treturn true\n-\t}\n-\tif i != nil && semver.Compare(i.goVersionV, narrowAllVersionV) < 0 {\n-\t\t// The module explicitly predates the change in \"all\" for lazy loading, so\n-\t\t// continue to use the older interpretation. (If i == nil, we not in any\n-\t\t// module at all and should use the latest semantics.)\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n // modFileIsDirty reports whether the go.mod file differs meaningfully\n // from what was indexed.\n // If modFile has been changed (even cosmetically) since it was first read,\n@@ -335,7 +408,7 @@ func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n \t\t\treturn true\n \t\t}\n \t} else if \"v\"+modFile.Go.Version != i.goVersionV {\n-\t\tif i.goVersionV == \"\" && cfg.BuildMod == \"readonly\" {\n+\t\tif i.goVersionV == \"\" && cfg.BuildMod != \"mod\" {\n \t\t\t// go.mod files did not always require a 'go' version, so do not error out\n \t\t\t// if one is missing \u2014 we may be inside an older module in the module\n \t\t\t// cache, and should bias toward providing useful behavior.\n@@ -391,9 +464,11 @@ var rawGoVersion sync.Map // map[module.Version]string\n // module.\n type modFileSummary struct {\n \tmodule     module.Version\n-\tgoVersionV string // GoVersion with \"v\" prefix\n+\tgoVersion  string\n+\tdepth      modDepth\n \trequire    []module.Version\n \tretract    []retraction\n+\tdeprecated string\n }\n \n // A retraction consists of a retracted version interval and rationale.\n@@ -433,19 +508,13 @@ func goModSummary(m module.Version) (*modFileSummary, error) {\n \t\t// return the full list of modules from modules.txt.\n \t\treadVendorList()\n \n-\t\t// TODO(#36876): Load the \"go\" version from vendor/modules.txt and store it\n-\t\t// in rawGoVersion with the appropriate key.\n-\n \t\t// We don't know what versions the vendored module actually relies on,\n \t\t// so assume that it requires everything.\n \t\tsummary.require = vendorList\n \t\treturn summary, nil\n \t}\n \n-\tactual := Replacement(m)\n-\tif actual.Path == \"\" {\n-\t\tactual = m\n-\t}\n+\tactual := resolveReplacement(m)\n \tif HasModRoot() && cfg.BuildMod == \"readonly\" && actual.Version != \"\" {\n \t\tkey := module.Version{Path: actual.Path, Version: actual.Version + \"/go.mod\"}\n \t\tif !modfetch.HaveSum(key) {\n@@ -526,45 +595,24 @@ func rawGoModSummary(m module.Version) (*modFileSummary, error) {\n \t}\n \tc := rawGoModSummaryCache.Do(m, func() interface{} {\n \t\tsummary := new(modFileSummary)\n-\t\tvar f *modfile.File\n-\t\tif m.Version == \"\" {\n-\t\t\t// m is a replacement module with only a file path.\n-\t\t\tdir := m.Path\n-\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\tdir = filepath.Join(ModRoot(), dir)\n-\t\t\t}\n-\t\t\tgomod := filepath.Join(dir, \"go.mod\")\n-\n-\t\t\tdata, err := lockedfile.Read(gomod)\n-\t\t\tif err != nil {\n-\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"reading %s: %v\", base.ShortPath(gomod), err))}\n-\t\t\t}\n-\t\t\tf, err = modfile.ParseLax(gomod, data, nil)\n-\t\t\tif err != nil {\n-\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err))}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif !semver.IsValid(m.Version) {\n-\t\t\t\t// Disallow the broader queries supported by fetch.Lookup.\n-\t\t\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", m.Path, m.Version)\n-\t\t\t}\n-\n-\t\t\tdata, err := modfetch.GoMod(m.Path, m.Version)\n-\t\t\tif err != nil {\n-\t\t\t\treturn cached{nil, err}\n-\t\t\t}\n-\t\t\tf, err = modfile.ParseLax(\"go.mod\", data, nil)\n-\t\t\tif err != nil {\n-\t\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"parsing go.mod: %v\", err))}\n-\t\t\t}\n+\t\tname, data, err := rawGoModData(m)\n+\t\tif err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\t\tf, err := modfile.ParseLax(name, data, nil)\n+\t\tif err != nil {\n+\t\t\treturn cached{nil, module.VersionError(m, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(name), err))}\n \t\t}\n-\n \t\tif f.Module != nil {\n \t\t\tsummary.module = f.Module.Mod\n+\t\t\tsummary.deprecated = f.Module.Deprecated\n \t\t}\n \t\tif f.Go != nil && f.Go.Version != \"\" {\n \t\t\trawGoVersion.LoadOrStore(m, f.Go.Version)\n-\t\t\tsummary.goVersionV = \"v\" + f.Go.Version\n+\t\t\tsummary.goVersion = f.Go.Version\n+\t\t\tsummary.depth = modDepthFromGoVersion(f.Go.Version)\n+\t\t} else {\n+\t\t\tsummary.depth = eager\n \t\t}\n \t\tif len(f.Require) > 0 {\n \t\t\tsummary.require = make([]module.Version, 0, len(f.Require))\n@@ -589,3 +637,84 @@ func rawGoModSummary(m module.Version) (*modFileSummary, error) {\n }\n \n var rawGoModSummaryCache par.Cache // module.Version \u2192 rawGoModSummary result\n+\n+// rawGoModData returns the content of the go.mod file for module m, ignoring\n+// all replacements that may apply to m.\n+//\n+// rawGoModData cannot be used on the Target module.\n+//\n+// Unlike rawGoModSummary, rawGoModData does not cache its results in memory.\n+// Use rawGoModSummary instead unless you specifically need these bytes.\n+func rawGoModData(m module.Version) (name string, data []byte, err error) {\n+\tif m.Version == \"\" {\n+\t\t// m is a replacement module with only a file path.\n+\t\tdir := m.Path\n+\t\tif !filepath.IsAbs(dir) {\n+\t\t\tdir = filepath.Join(ModRoot(), dir)\n+\t\t}\n+\t\tname = filepath.Join(dir, \"go.mod\")\n+\t\tif gomodActual, ok := fsys.OverlayPath(name); ok {\n+\t\t\t// Don't lock go.mod if it's part of the overlay.\n+\t\t\t// On Plan 9, locking requires chmod, and we don't want to modify any file\n+\t\t\t// in the overlay. See #44700.\n+\t\t\tdata, err = os.ReadFile(gomodActual)\n+\t\t} else {\n+\t\t\tdata, err = lockedfile.Read(gomodActual)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn \"\", nil, module.VersionError(m, fmt.Errorf(\"reading %s: %v\", base.ShortPath(name), err))\n+\t\t}\n+\t} else {\n+\t\tif !semver.IsValid(m.Version) {\n+\t\t\t// Disallow the broader queries supported by fetch.Lookup.\n+\t\t\tbase.Fatalf(\"go: internal error: %s@%s: unexpected invalid semantic version\", m.Path, m.Version)\n+\t\t}\n+\t\tname = \"go.mod\"\n+\t\tdata, err = modfetch.GoMod(m.Path, m.Version)\n+\t}\n+\treturn name, data, err\n+}\n+\n+// queryLatestVersionIgnoringRetractions looks up the latest version of the\n+// module with the given path without considering retracted or excluded\n+// versions.\n+//\n+// If all versions of the module are replaced,\n+// queryLatestVersionIgnoringRetractions returns the replacement without making\n+// a query.\n+//\n+// If the queried latest version is replaced,\n+// queryLatestVersionIgnoringRetractions returns the replacement.\n+func queryLatestVersionIgnoringRetractions(ctx context.Context, path string) (latest module.Version, err error) {\n+\ttype entry struct {\n+\t\tlatest module.Version\n+\t\terr    error\n+\t}\n+\te := latestVersionIgnoringRetractionsCache.Do(path, func() interface{} {\n+\t\tctx, span := trace.StartSpan(ctx, \"queryLatestVersionIgnoringRetractions \"+path)\n+\t\tdefer span.Done()\n+\n+\t\tif repl := Replacement(module.Version{Path: path}); repl.Path != \"\" {\n+\t\t\t// All versions of the module were replaced.\n+\t\t\t// No need to query.\n+\t\t\treturn &entry{latest: repl}\n+\t\t}\n+\n+\t\t// Find the latest version of the module.\n+\t\t// Ignore exclusions from the main module's go.mod.\n+\t\tconst ignoreSelected = \"\"\n+\t\tvar allowAll AllowedFunc\n+\t\trev, err := Query(ctx, path, \"latest\", ignoreSelected, allowAll)\n+\t\tif err != nil {\n+\t\t\treturn &entry{err: err}\n+\t\t}\n+\t\tlatest := module.Version{Path: path, Version: rev.Version}\n+\t\tif repl := resolveReplacement(latest); repl.Path != \"\" {\n+\t\t\tlatest = repl\n+\t\t}\n+\t\treturn &entry{latest: latest}\n+\t}).(*entry)\n+\treturn e.latest, e.err\n+}\n+\n+var latestVersionIgnoringRetractionsCache par.Cache // path \u2192 queryLatestVersionIgnoringRetractions result"}, {"sha": "87619b4ace68e28d40621054ab4d437a4b97cf83", "filename": "libgo/go/cmd/go/internal/modload/mvs.go", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmvs.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -16,17 +16,36 @@ import (\n \t\"golang.org/x/mod/semver\"\n )\n \n+// cmpVersion implements the comparison for versions in the module loader.\n+//\n+// It is consistent with semver.Compare except that as a special case,\n+// the version \"\" is considered higher than all other versions.\n+// The main module (also known as the target) has no version and must be chosen\n+// over other versions of the same module in the module dependency graph.\n+func cmpVersion(v1, v2 string) int {\n+\tif v2 == \"\" {\n+\t\tif v1 == \"\" {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\t}\n+\tif v1 == \"\" {\n+\t\treturn 1\n+\t}\n+\treturn semver.Compare(v1, v2)\n+}\n+\n // mvsReqs implements mvs.Reqs for module semantic versions,\n // with any exclusions or replacements applied internally.\n type mvsReqs struct {\n-\tbuildList []module.Version\n+\troots []module.Version\n }\n \n func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n \tif mod == Target {\n \t\t// Use the build list as it existed when r was constructed, not the current\n \t\t// global build list.\n-\t\treturn r.buildList[1:], nil\n+\t\treturn r.roots, nil\n \t}\n \n \tif mod.Version == \"none\" {\n@@ -47,7 +66,7 @@ func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n // be chosen over other versions of the same module in the module dependency\n // graph.\n func (*mvsReqs) Max(v1, v2 string) string {\n-\tif v1 != \"\" && (v2 == \"\" || semver.Compare(v1, v2) == -1) {\n+\tif cmpVersion(v1, v2) < 0 {\n \t\treturn v2\n \t}\n \treturn v1\n@@ -86,12 +105,12 @@ func versions(ctx context.Context, path string, allowed AllowedFunc) ([]string,\n \treturn versions, err\n }\n \n-// Previous returns the tagged version of m.Path immediately prior to\n+// previousVersion returns the tagged version of m.Path immediately prior to\n // m.Version, or version \"none\" if no prior version is tagged.\n //\n // Since the version of Target is not found in the version list,\n // it has no previous version.\n-func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n+func previousVersion(m module.Version) (module.Version, error) {\n \t// TODO(golang.org/issue/38714): thread tracing context through MVS.\n \n \tif m == Target {\n@@ -111,3 +130,7 @@ func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n \t}\n \treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n }\n+\n+func (*mvsReqs) Previous(m module.Version) (module.Version, error) {\n+\treturn previousVersion(m)\n+}"}, {"sha": "e737ca90fcd79d911f741b7fc43e1aa663b97d4b", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -5,13 +5,13 @@\n package modload\n \n import (\n+\t\"bytes\"\n \t\"context\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io/fs\"\n \t\"os\"\n \tpathpkg \"path\"\n-\t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n \t\"sync\"\n@@ -177,7 +177,7 @@ func queryProxy(ctx context.Context, proxy, path, query, current string, allowed\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tif (query == \"upgrade\" || query == \"patch\") && modfetch.IsPseudoVersion(current) && !rev.Time.IsZero() {\n+\t\tif (query == \"upgrade\" || query == \"patch\") && module.IsPseudoVersion(current) && !rev.Time.IsZero() {\n \t\t\t// Don't allow \"upgrade\" or \"patch\" to move from a pseudo-version\n \t\t\t// to a chronologically older version or pseudo-version.\n \t\t\t//\n@@ -196,7 +196,7 @@ func queryProxy(ctx context.Context, proxy, path, query, current string, allowed\n \t\t\t// newer but v1.1.0 is still an \u201cupgrade\u201d; or v1.0.2 might be a revert of\n \t\t\t// an unsuccessful fix in v1.0.1, in which case the v1.0.2 commit may be\n \t\t\t// older than the v1.0.1 commit despite the tag itself being newer.)\n-\t\t\tcurrentTime, err := modfetch.PseudoVersionTime(current)\n+\t\t\tcurrentTime, err := module.PseudoVersionTime(current)\n \t\t\tif err == nil && rev.Time.Before(currentTime) {\n \t\t\t\tif err := allowed(ctx, module.Version{Path: path, Version: current}); errors.Is(err, ErrDisallowed) {\n \t\t\t\t\treturn nil, err\n@@ -325,18 +325,18 @@ func newQueryMatcher(path string, query, current string, allowed AllowedFunc) (*\n \t\tif current == \"\" || current == \"none\" {\n \t\t\tqm.mayUseLatest = true\n \t\t} else {\n-\t\t\tqm.mayUseLatest = modfetch.IsPseudoVersion(current)\n+\t\t\tqm.mayUseLatest = module.IsPseudoVersion(current)\n \t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, current) >= 0 }\n \t\t}\n \n \tcase query == \"patch\":\n-\t\tif current == \"none\" {\n+\t\tif current == \"\" || current == \"none\" {\n \t\t\treturn nil, &NoPatchBaseError{path}\n \t\t}\n \t\tif current == \"\" {\n \t\t\tqm.mayUseLatest = true\n \t\t} else {\n-\t\t\tqm.mayUseLatest = modfetch.IsPseudoVersion(current)\n+\t\t\tqm.mayUseLatest = module.IsPseudoVersion(current)\n \t\t\tqm.prefix = semver.MajorMinor(current) + \".\"\n \t\t\tqm.filter = func(mv string) bool { return semver.Compare(mv, current) >= 0 }\n \t\t}\n@@ -695,7 +695,9 @@ func QueryPattern(ctx context.Context, pattern, query string, current func(strin\n \n // modulePrefixesExcludingTarget returns all prefixes of path that may plausibly\n // exist as a module, excluding targetPrefix but otherwise including path\n-// itself, sorted by descending length.\n+// itself, sorted by descending length. Prefixes that are not valid module paths\n+// but are valid package paths (like \"m\" or \"example.com/.gen\") are included,\n+// since they might be replaced.\n func modulePrefixesExcludingTarget(path string) []string {\n \tprefixes := make([]string, 0, strings.Count(path, \"/\")+1)\n \n@@ -747,6 +749,7 @@ func queryPrefixModules(ctx context.Context, candidateModules []string, queryMod\n \t\tnoPackage   *PackageNotInModuleError\n \t\tnoVersion   *NoMatchingVersionError\n \t\tnoPatchBase *NoPatchBaseError\n+\t\tinvalidPath *module.InvalidPathError // see comment in case below\n \t\tnotExistErr error\n \t)\n \tfor _, r := range results {\n@@ -767,6 +770,17 @@ func queryPrefixModules(ctx context.Context, candidateModules []string, queryMod\n \t\t\tif noPatchBase == nil {\n \t\t\t\tnoPatchBase = rErr\n \t\t\t}\n+\t\tcase *module.InvalidPathError:\n+\t\t\t// The prefix was not a valid module path, and there was no replacement.\n+\t\t\t// Prefixes like this may appear in candidateModules, since we handle\n+\t\t\t// replaced modules that weren't required in the repo lookup process\n+\t\t\t// (see lookupRepo).\n+\t\t\t//\n+\t\t\t// A shorter prefix may be a valid module path and may contain a valid\n+\t\t\t// import path, so this is a low-priority error.\n+\t\t\tif invalidPath == nil {\n+\t\t\t\tinvalidPath = rErr\n+\t\t\t}\n \t\tdefault:\n \t\t\tif errors.Is(rErr, fs.ErrNotExist) {\n \t\t\t\tif notExistErr == nil {\n@@ -800,6 +814,8 @@ func queryPrefixModules(ctx context.Context, candidateModules []string, queryMod\n \t\t\terr = noVersion\n \t\tcase noPatchBase != nil:\n \t\t\terr = noPatchBase\n+\t\tcase invalidPath != nil:\n+\t\t\terr = invalidPath\n \t\tcase notExistErr != nil:\n \t\t\terr = notExistErr\n \t\tdefault:\n@@ -904,8 +920,8 @@ func (e *PackageNotInModuleError) ImportPath() string {\n \treturn \"\"\n }\n \n-// ModuleHasRootPackage returns whether module m contains a package m.Path.\n-func ModuleHasRootPackage(ctx context.Context, m module.Version) (bool, error) {\n+// moduleHasRootPackage returns whether module m contains a package m.Path.\n+func moduleHasRootPackage(ctx context.Context, m module.Version) (bool, error) {\n \tneedSum := false\n \troot, isLocal, err := fetch(ctx, m, needSum)\n \tif err != nil {\n@@ -915,14 +931,32 @@ func ModuleHasRootPackage(ctx context.Context, m module.Version) (bool, error) {\n \treturn ok, err\n }\n \n-func versionHasGoMod(ctx context.Context, m module.Version) (bool, error) {\n-\tneedSum := false\n-\troot, _, err := fetch(ctx, m, needSum)\n+// versionHasGoMod returns whether a version has a go.mod file.\n+//\n+// versionHasGoMod fetches the go.mod file (possibly a fake) and true if it\n+// contains anything other than a module directive with the same path. When a\n+// module does not have a real go.mod file, the go command acts as if it had one\n+// that only contained a module directive. Normal go.mod files created after\n+// 1.12 at least have a go directive.\n+//\n+// This function is a heuristic, since it's possible to commit a file that would\n+// pass this test. However, we only need a heurstic for determining whether\n+// +incompatible versions may be \"latest\", which is what this function is used\n+// for.\n+//\n+// This heuristic is useful for two reasons: first, when using a proxy,\n+// this lets us fetch from the .mod endpoint which is much faster than the .zip\n+// endpoint. The .mod file is used anyway, even if the .zip file contains a\n+// go.mod with different content. Second, if we don't fetch the .zip, then\n+// we don't need to verify it in go.sum. This makes 'go list -m -u' faster\n+// and simpler.\n+func versionHasGoMod(_ context.Context, m module.Version) (bool, error) {\n+\t_, data, err := rawGoModData(m)\n \tif err != nil {\n \t\treturn false, err\n \t}\n-\tfi, err := os.Stat(filepath.Join(root, \"go.mod\"))\n-\treturn err == nil && !fi.IsDir(), nil\n+\tisFake := bytes.Equal(data, modfetch.LegacyGoMod(m.Path))\n+\treturn !isFake, nil\n }\n \n // A versionRepo is a subset of modfetch.Repo that can report information about\n@@ -993,7 +1027,7 @@ func (rr *replacementRepo) Versions(prefix string) ([]string, error) {\n \tif index != nil && len(index.replace) > 0 {\n \t\tpath := rr.ModulePath()\n \t\tfor m, _ := range index.replace {\n-\t\t\tif m.Path == path && strings.HasPrefix(m.Version, prefix) && m.Version != \"\" && !modfetch.IsPseudoVersion(m.Version) {\n+\t\t\tif m.Path == path && strings.HasPrefix(m.Version, prefix) && m.Version != \"\" && !module.IsPseudoVersion(m.Version) {\n \t\t\t\tversions = append(versions, m.Version)\n \t\t\t}\n \t\t}\n@@ -1050,9 +1084,9 @@ func (rr *replacementRepo) Latest() (*modfetch.RevInfo, error) {\n \t\t\t\t// used from within some other module, the user will be able to upgrade\n \t\t\t\t// the requirement to any real version they choose.\n \t\t\t\tif _, pathMajor, ok := module.SplitPathVersion(path); ok && len(pathMajor) > 0 {\n-\t\t\t\t\tv = modfetch.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t\tv = module.PseudoVersion(pathMajor[1:], \"\", time.Time{}, \"000000000000\")\n \t\t\t\t} else {\n-\t\t\t\t\tv = modfetch.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n+\t\t\t\t\tv = module.PseudoVersion(\"v0\", \"\", time.Time{}, \"000000000000\")\n \t\t\t\t}\n \t\t\t}\n \n@@ -1067,9 +1101,9 @@ func (rr *replacementRepo) Latest() (*modfetch.RevInfo, error) {\n \n func (rr *replacementRepo) replacementStat(v string) (*modfetch.RevInfo, error) {\n \trev := &modfetch.RevInfo{Version: v}\n-\tif modfetch.IsPseudoVersion(v) {\n-\t\trev.Time, _ = modfetch.PseudoVersionTime(v)\n-\t\trev.Short, _ = modfetch.PseudoVersionRev(v)\n+\tif module.IsPseudoVersion(v) {\n+\t\trev.Time, _ = module.PseudoVersionTime(v)\n+\t\trev.Short, _ = module.PseudoVersionRev(v)\n \t}\n \treturn rev, nil\n }"}, {"sha": "a3f2f84505a0f996d48aa6bb91937e63c33ff097", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -106,7 +106,7 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n \t{path: queryRepo, query: \"ed5ffdaa\", vers: \"v1.9.10-pre2.0.20191220134614-ed5ffdaa1f5e\"},\n \n-\t// golang.org/issue/29262: The major version for for a module without a suffix\n+\t// golang.org/issue/29262: The major version for a module without a suffix\n \t// should be based on the most recent tag (v1 as appropriate, not v0\n \t// unconditionally).\n \t{path: queryRepo, query: \"42abcb6df8ee\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n@@ -122,7 +122,7 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \"upgrade\", allow: \"NOMATCH\", err: `no matching versions for query \"upgrade\"`},\n \t{path: queryRepo, query: \"upgrade\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `vcs-test.golang.org/git/querytest.git@v1.9.9: disallowed module version`},\n \t{path: queryRepo, query: \"upgrade\", current: \"v1.99.99\", err: `vcs-test.golang.org/git/querytest.git@v1.99.99: invalid version: unknown revision v1.99.99`},\n-\t{path: queryRepo, query: \"patch\", current: \"\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"patch\", current: \"\", err: `can't query version \"patch\" of module vcs-test.golang.org/git/querytest.git: no existing version is required`},\n \t{path: queryRepo, query: \"patch\", current: \"v0.1.0\", vers: \"v0.1.2\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.0\", vers: \"v1.9.9\"},\n \t{path: queryRepo, query: \"patch\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},"}, {"sha": "0c2e2660e9fc1c0a4e34f20f9274216f3f723236", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -87,7 +87,7 @@ func matchPackages(ctx context.Context, m *search.Match, tags map[string]bool, f\n \t\t\t}\n \n \t\t\tif !fi.IsDir() {\n-\t\t\t\tif fi.Mode()&fs.ModeSymlink != 0 && want {\n+\t\t\t\tif fi.Mode()&fs.ModeSymlink != 0 && want && strings.Contains(m.Pattern(), \"...\") {\n \t\t\t\t\tif target, err := fsys.Stat(path); err == nil && target.IsDir() {\n \t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: ignoring symlink %s\\n\", path)\n \t\t\t\t\t}\n@@ -188,7 +188,7 @@ func MatchInModule(ctx context.Context, pattern string, m module.Version, tags m\n \t\tmatchPackages(ctx, match, tags, includeStd, nil)\n \t}\n \n-\tLoadModFile(ctx)\n+\tLoadModFile(ctx) // Sets Target, needed by fetch and matchPackages.\n \n \tif !match.IsLiteral() {\n \t\tmatchPackages(ctx, match, tags, omitStd, []module.Version{m})"}, {"sha": "368f893198492984b0cc1efaffe988d5f172c5d5", "filename": "libgo/go/cmd/go/internal/modload/stat_openfile.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build (js && wasm) || plan9\n // +build js,wasm plan9\n \n // On plan9, per http://9p.io/magic/man2html/2/access: \u201cSince file permissions"}, {"sha": "f5f7ce3e03df4627f34fc4fc0d69d75994bdd4d7", "filename": "libgo/go/cmd/go/internal/modload/stat_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build aix || darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n // +build aix darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n \n package modload"}, {"sha": "825e60b27af89406122aa400b92df706aba508d5", "filename": "libgo/go/cmd/go/internal/modload/stat_windows.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build windows\n // +build windows\n \n package modload"}, {"sha": "80713b0812eacce928f0a39b26eba024e655a56b", "filename": "libgo/go/cmd/go/internal/modload/vendor.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fvendor.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -31,6 +31,7 @@ var (\n type vendorMetadata struct {\n \tExplicit    bool\n \tReplacement module.Version\n+\tGoVersion   string\n }\n \n // readVendorList reads the list of vendored modules from vendor/modules.txt.\n@@ -104,6 +105,10 @@ func readVendorList() {\n \t\t\t\t\tif entry == \"explicit\" {\n \t\t\t\t\t\tmeta.Explicit = true\n \t\t\t\t\t}\n+\t\t\t\t\tif strings.HasPrefix(entry, \"go \") {\n+\t\t\t\t\t\tmeta.GoVersion = strings.TrimPrefix(entry, \"go \")\n+\t\t\t\t\t\trawGoVersion.Store(mod, meta.GoVersion)\n+\t\t\t\t\t}\n \t\t\t\t\t// All other tokens are reserved for future use.\n \t\t\t\t}\n \t\t\t\tvendorMeta[mod] = meta"}, {"sha": "bf183cea9e88af62b0b8d773297f432bae740b84", "filename": "libgo/go/cmd/go/internal/mvs/errors.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Ferrors.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -31,13 +31,15 @@ type buildListErrorElem struct {\n // occurred at a module found along the given path of requirements and/or\n // upgrades, which must be non-empty.\n //\n-// The isUpgrade function reports whether a path step is due to an upgrade.\n-// A nil isUpgrade function indicates that none of the path steps are due to upgrades.\n-func NewBuildListError(err error, path []module.Version, isUpgrade func(from, to module.Version) bool) *BuildListError {\n+// The isVersionChange function reports whether a path step is due to an\n+// explicit upgrade or downgrade (as opposed to an existing requirement in a\n+// go.mod file). A nil isVersionChange function indicates that none of the path\n+// steps are due to explicit version changes.\n+func NewBuildListError(err error, path []module.Version, isVersionChange func(from, to module.Version) bool) *BuildListError {\n \tstack := make([]buildListErrorElem, 0, len(path))\n \tfor len(path) > 1 {\n \t\treason := \"requires\"\n-\t\tif isUpgrade != nil && isUpgrade(path[0], path[1]) {\n+\t\tif isVersionChange != nil && isVersionChange(path[0], path[1]) {\n \t\t\treason = \"updating to\"\n \t\t}\n \t\tstack = append(stack, buildListErrorElem{"}, {"sha": "c5de4866bf467907bafe5d1370b5f2ed39c8c173", "filename": "libgo/go/cmd/go/internal/mvs/graph.go", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fgraph.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package mvs\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+// Graph implements an incremental version of the MVS algorithm, with the\n+// requirements pushed by the caller instead of pulled by the MVS traversal.\n+type Graph struct {\n+\tcmp   func(v1, v2 string) int\n+\troots []module.Version\n+\n+\trequired map[module.Version][]module.Version\n+\n+\tisRoot   map[module.Version]bool // contains true for roots and false for reachable non-roots\n+\tselected map[string]string       // path \u2192 version\n+}\n+\n+// NewGraph returns an incremental MVS graph containing only a set of root\n+// dependencies and using the given max function for version strings.\n+//\n+// The caller must ensure that the root slice is not modified while the Graph\n+// may be in use.\n+func NewGraph(cmp func(v1, v2 string) int, roots []module.Version) *Graph {\n+\tg := &Graph{\n+\t\tcmp:      cmp,\n+\t\troots:    roots[:len(roots):len(roots)],\n+\t\trequired: make(map[module.Version][]module.Version),\n+\t\tisRoot:   make(map[module.Version]bool),\n+\t\tselected: make(map[string]string),\n+\t}\n+\n+\tfor _, m := range roots {\n+\t\tg.isRoot[m] = true\n+\t\tif g.cmp(g.Selected(m.Path), m.Version) < 0 {\n+\t\t\tg.selected[m.Path] = m.Version\n+\t\t}\n+\t}\n+\n+\treturn g\n+}\n+\n+// Require adds the information that module m requires all modules in reqs.\n+// The reqs slice must not be modified after it is passed to Require.\n+//\n+// m must be reachable by some existing chain of requirements from g's target,\n+// and Require must not have been called for it already.\n+//\n+// If any of the modules in reqs has the same path as g's target,\n+// the target must have higher precedence than the version in req.\n+func (g *Graph) Require(m module.Version, reqs []module.Version) {\n+\t// To help catch disconnected-graph bugs, enforce that all required versions\n+\t// are actually reachable from the roots (and therefore should affect the\n+\t// selected versions of the modules they name).\n+\tif _, reachable := g.isRoot[m]; !reachable {\n+\t\tpanic(fmt.Sprintf(\"%v is not reachable from any root\", m))\n+\t}\n+\n+\t// Truncate reqs to its capacity to avoid aliasing bugs if it is later\n+\t// returned from RequiredBy and appended to.\n+\treqs = reqs[:len(reqs):len(reqs)]\n+\n+\tif _, dup := g.required[m]; dup {\n+\t\tpanic(fmt.Sprintf(\"requirements of %v have already been set\", m))\n+\t}\n+\tg.required[m] = reqs\n+\n+\tfor _, dep := range reqs {\n+\t\t// Mark dep reachable, regardless of whether it is selected.\n+\t\tif _, ok := g.isRoot[dep]; !ok {\n+\t\t\tg.isRoot[dep] = false\n+\t\t}\n+\n+\t\tif g.cmp(g.Selected(dep.Path), dep.Version) < 0 {\n+\t\t\tg.selected[dep.Path] = dep.Version\n+\t\t}\n+\t}\n+}\n+\n+// RequiredBy returns the slice of requirements passed to Require for m, if any,\n+// with its capacity reduced to its length.\n+// If Require has not been called for m, RequiredBy(m) returns ok=false.\n+//\n+// The caller must not modify the returned slice, but may safely append to it\n+// and may rely on it not to be modified.\n+func (g *Graph) RequiredBy(m module.Version) (reqs []module.Version, ok bool) {\n+\treqs, ok = g.required[m]\n+\treturn reqs, ok\n+}\n+\n+// Selected returns the selected version of the given module path.\n+//\n+// If no version is selected, Selected returns version \"none\".\n+func (g *Graph) Selected(path string) (version string) {\n+\tv, ok := g.selected[path]\n+\tif !ok {\n+\t\treturn \"none\"\n+\t}\n+\treturn v\n+}\n+\n+// BuildList returns the selected versions of all modules present in the Graph,\n+// beginning with the selected versions of each module path in the roots of g.\n+//\n+// The order of the remaining elements in the list is deterministic\n+// but arbitrary.\n+func (g *Graph) BuildList() []module.Version {\n+\tseenRoot := make(map[string]bool, len(g.roots))\n+\n+\tvar list []module.Version\n+\tfor _, r := range g.roots {\n+\t\tif seenRoot[r.Path] {\n+\t\t\t// Multiple copies of the same root, with the same or different versions,\n+\t\t\t// are a bit of a degenerate case: we will take the transitive\n+\t\t\t// requirements of both roots into account, but only the higher one can\n+\t\t\t// possibly be selected. However \u2014 especially given that we need the\n+\t\t\t// seenRoot map for later anyway \u2014 it is simpler to support this\n+\t\t\t// degenerate case than to forbid it.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif v := g.Selected(r.Path); v != \"none\" {\n+\t\t\tlist = append(list, module.Version{Path: r.Path, Version: v})\n+\t\t}\n+\t\tseenRoot[r.Path] = true\n+\t}\n+\tuniqueRoots := list\n+\n+\tfor path, version := range g.selected {\n+\t\tif !seenRoot[path] {\n+\t\t\tlist = append(list, module.Version{Path: path, Version: version})\n+\t\t}\n+\t}\n+\tmodule.Sort(list[len(uniqueRoots):])\n+\n+\treturn list\n+}\n+\n+// WalkBreadthFirst invokes f once, in breadth-first order, for each module\n+// version other than \"none\" that appears in the graph, regardless of whether\n+// that version is selected.\n+func (g *Graph) WalkBreadthFirst(f func(m module.Version)) {\n+\tvar queue []module.Version\n+\tenqueued := make(map[module.Version]bool)\n+\tfor _, m := range g.roots {\n+\t\tif m.Version != \"none\" {\n+\t\t\tqueue = append(queue, m)\n+\t\t\tenqueued[m] = true\n+\t\t}\n+\t}\n+\n+\tfor len(queue) > 0 {\n+\t\tm := queue[0]\n+\t\tqueue = queue[1:]\n+\n+\t\tf(m)\n+\n+\t\treqs, _ := g.RequiredBy(m)\n+\t\tfor _, r := range reqs {\n+\t\t\tif !enqueued[r] && r.Version != \"none\" {\n+\t\t\t\tqueue = append(queue, r)\n+\t\t\t\tenqueued[r] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// FindPath reports a shortest requirement path starting at one of the roots of\n+// the graph and ending at a module version m for which f(m) returns true, or\n+// nil if no such path exists.\n+func (g *Graph) FindPath(f func(module.Version) bool) []module.Version {\n+\t// firstRequires[a] = b means that in a breadth-first traversal of the\n+\t// requirement graph, the module version a was first required by b.\n+\tfirstRequires := make(map[module.Version]module.Version)\n+\n+\tqueue := g.roots\n+\tfor _, m := range g.roots {\n+\t\tfirstRequires[m] = module.Version{}\n+\t}\n+\n+\tfor len(queue) > 0 {\n+\t\tm := queue[0]\n+\t\tqueue = queue[1:]\n+\n+\t\tif f(m) {\n+\t\t\t// Construct the path reversed (because we're starting from the far\n+\t\t\t// endpoint), then reverse it.\n+\t\t\tpath := []module.Version{m}\n+\t\t\tfor {\n+\t\t\t\tm = firstRequires[m]\n+\t\t\t\tif m.Path == \"\" {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tpath = append(path, m)\n+\t\t\t}\n+\n+\t\t\ti, j := 0, len(path)-1\n+\t\t\tfor i < j {\n+\t\t\t\tpath[i], path[j] = path[j], path[i]\n+\t\t\t\ti++\n+\t\t\t\tj--\n+\t\t\t}\n+\n+\t\t\treturn path\n+\t\t}\n+\n+\t\treqs, _ := g.RequiredBy(m)\n+\t\tfor _, r := range reqs {\n+\t\t\tif _, seen := firstRequires[r]; !seen {\n+\t\t\t\tqueue = append(queue, r)\n+\t\t\t\tfirstRequires[r] = m\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "6969f90f2e681abf23495ab7aab8ba4432453d17", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 128, "deletions": 122, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"fmt\"\n \t\"sort\"\n \t\"sync\"\n-\t\"sync/atomic\"\n \n \t\"cmd/go/internal/par\"\n \n@@ -41,6 +40,11 @@ type Reqs interface {\n \t// Note that v1 < v2 can be written Max(v1, v2) != v1\n \t// and similarly v1 <= v2 can be written Max(v1, v2) == v2.\n \tMax(v1, v2 string) string\n+}\n+\n+// An UpgradeReqs is a Reqs that can also identify available upgrades.\n+type UpgradeReqs interface {\n+\tReqs\n \n \t// Upgrade returns the upgraded version of m,\n \t// for use during an UpgradeAll operation.\n@@ -54,6 +58,11 @@ type Reqs interface {\n \t// TODO(rsc): Upgrade must be able to return errors,\n \t// but should \"no latest version\" just return m instead?\n \tUpgrade(m module.Version) (module.Version, error)\n+}\n+\n+// A DowngradeReqs is a Reqs that can also identify available downgrades.\n+type DowngradeReqs interface {\n+\tReqs\n \n \t// Previous returns the version of m.Path immediately prior to m.Version,\n \t// or \"none\" if no such version is known.\n@@ -81,151 +90,91 @@ func BuildList(target module.Version, reqs Reqs) ([]module.Version, error) {\n }\n \n func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (module.Version, error)) ([]module.Version, error) {\n-\t// Explore work graph in parallel in case reqs.Required\n-\t// does high-latency network operations.\n-\ttype modGraphNode struct {\n-\t\tm        module.Version\n-\t\trequired []module.Version\n-\t\tupgrade  module.Version\n-\t\terr      error\n+\tcmp := func(v1, v2 string) int {\n+\t\tif reqs.Max(v1, v2) != v1 {\n+\t\t\treturn -1\n+\t\t}\n+\t\tif reqs.Max(v2, v1) != v2 {\n+\t\t\treturn 1\n+\t\t}\n+\t\treturn 0\n \t}\n+\n \tvar (\n \t\tmu       sync.Mutex\n-\t\tmodGraph = map[module.Version]*modGraphNode{}\n-\t\tmin      = map[string]string{} // maps module path to minimum required version\n-\t\thaveErr  int32\n+\t\tg        = NewGraph(cmp, []module.Version{target})\n+\t\tupgrades = map[module.Version]module.Version{}\n+\t\terrs     = map[module.Version]error{} // (non-nil errors only)\n \t)\n-\tsetErr := func(n *modGraphNode, err error) {\n-\t\tn.err = err\n-\t\tatomic.StoreInt32(&haveErr, 1)\n-\t}\n \n+\t// Explore work graph in parallel in case reqs.Required\n+\t// does high-latency network operations.\n \tvar work par.Work\n \twork.Add(target)\n \twork.Do(10, func(item interface{}) {\n \t\tm := item.(module.Version)\n \n-\t\tnode := &modGraphNode{m: m}\n-\t\tmu.Lock()\n-\t\tmodGraph[m] = node\n+\t\tvar required []module.Version\n+\t\tvar err error\n \t\tif m.Version != \"none\" {\n-\t\t\tif v, ok := min[m.Path]; !ok || reqs.Max(v, m.Version) != v {\n-\t\t\t\tmin[m.Path] = m.Version\n-\t\t\t}\n+\t\t\trequired, err = reqs.Required(m)\n \t\t}\n-\t\tmu.Unlock()\n \n-\t\tif m.Version != \"none\" {\n-\t\t\trequired, err := reqs.Required(m)\n-\t\t\tif err != nil {\n-\t\t\t\tsetErr(node, err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tnode.required = required\n-\t\t\tfor _, r := range node.required {\n-\t\t\t\twork.Add(r)\n+\t\tu := m\n+\t\tif upgrade != nil {\n+\t\t\tupgradeTo, upErr := upgrade(m)\n+\t\t\tif upErr == nil {\n+\t\t\t\tu = upgradeTo\n+\t\t\t} else if err == nil {\n+\t\t\t\terr = upErr\n \t\t\t}\n \t\t}\n \n-\t\tif upgrade != nil {\n-\t\t\tu, err := upgrade(m)\n-\t\t\tif err != nil {\n-\t\t\t\tsetErr(node, err)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif u != m {\n-\t\t\t\tnode.upgrade = u\n-\t\t\t\twork.Add(u)\n-\t\t\t}\n+\t\tmu.Lock()\n+\t\tif err != nil {\n+\t\t\terrs[m] = err\n+\t\t}\n+\t\tif u != m {\n+\t\t\tupgrades[m] = u\n+\t\t\trequired = append([]module.Version{u}, required...)\n+\t\t}\n+\t\tg.Require(m, required)\n+\t\tmu.Unlock()\n+\n+\t\tfor _, r := range required {\n+\t\t\twork.Add(r)\n \t\t}\n \t})\n \n \t// If there was an error, find the shortest path from the target to the\n \t// node where the error occurred so we can report a useful error message.\n-\tif haveErr != 0 {\n-\t\t// neededBy[a] = b means a was added to the module graph by b.\n-\t\tneededBy := make(map[*modGraphNode]*modGraphNode)\n-\t\tq := make([]*modGraphNode, 0, len(modGraph))\n-\t\tq = append(q, modGraph[target])\n-\t\tfor len(q) > 0 {\n-\t\t\tnode := q[0]\n-\t\t\tq = q[1:]\n-\n-\t\t\tif node.err != nil {\n-\t\t\t\tpathUpgrade := map[module.Version]module.Version{}\n-\n-\t\t\t\t// Construct the error path reversed (from the error to the main module),\n-\t\t\t\t// then reverse it to obtain the usual order (from the main module to\n-\t\t\t\t// the error).\n-\t\t\t\terrPath := []module.Version{node.m}\n-\t\t\t\tfor n, prev := neededBy[node], node; n != nil; n, prev = neededBy[n], n {\n-\t\t\t\t\tif n.upgrade == prev.m {\n-\t\t\t\t\t\tpathUpgrade[n.m] = prev.m\n-\t\t\t\t\t}\n-\t\t\t\t\terrPath = append(errPath, n.m)\n-\t\t\t\t}\n-\t\t\t\ti, j := 0, len(errPath)-1\n-\t\t\t\tfor i < j {\n-\t\t\t\t\terrPath[i], errPath[j] = errPath[j], errPath[i]\n-\t\t\t\t\ti++\n-\t\t\t\t\tj--\n-\t\t\t\t}\n-\n-\t\t\t\tisUpgrade := func(from, to module.Version) bool {\n-\t\t\t\t\treturn pathUpgrade[from] == to\n-\t\t\t\t}\n-\n-\t\t\t\treturn nil, NewBuildListError(node.err, errPath, isUpgrade)\n-\t\t\t}\n+\tif len(errs) > 0 {\n+\t\terrPath := g.FindPath(func(m module.Version) bool {\n+\t\t\treturn errs[m] != nil\n+\t\t})\n+\t\tif len(errPath) == 0 {\n+\t\t\tpanic(\"internal error: could not reconstruct path to module with error\")\n+\t\t}\n \n-\t\t\tneighbors := node.required\n-\t\t\tif node.upgrade.Path != \"\" {\n-\t\t\t\tneighbors = append(neighbors, node.upgrade)\n-\t\t\t}\n-\t\t\tfor _, neighbor := range neighbors {\n-\t\t\t\tnn := modGraph[neighbor]\n-\t\t\t\tif neededBy[nn] != nil {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tneededBy[nn] = node\n-\t\t\t\tq = append(q, nn)\n+\t\terr := errs[errPath[len(errPath)-1]]\n+\t\tisUpgrade := func(from, to module.Version) bool {\n+\t\t\tif u, ok := upgrades[from]; ok {\n+\t\t\t\treturn u == to\n \t\t\t}\n+\t\t\treturn false\n \t\t}\n+\t\treturn nil, NewBuildListError(err.(error), errPath, isUpgrade)\n \t}\n \n \t// The final list is the minimum version of each module found in the graph.\n-\n-\tif v := min[target.Path]; v != target.Version {\n+\tlist := g.BuildList()\n+\tif v := list[0]; v != target {\n \t\t// target.Version will be \"\" for modload, the main client of MVS.\n \t\t// \"\" denotes the main module, which has no version. However, MVS treats\n \t\t// version strings as opaque, so \"\" is not a special value here.\n \t\t// See golang.org/issue/31491, golang.org/issue/29773.\n-\t\tpanic(fmt.Sprintf(\"mistake: chose version %q instead of target %+v\", v, target)) // TODO: Don't panic.\n+\t\tpanic(fmt.Sprintf(\"mistake: chose version %q instead of target %+v\", v, target))\n \t}\n-\n-\tlist := []module.Version{target}\n-\tfor path, vers := range min {\n-\t\tif path != target.Path {\n-\t\t\tlist = append(list, module.Version{Path: path, Version: vers})\n-\t\t}\n-\n-\t\tn := modGraph[module.Version{Path: path, Version: vers}]\n-\t\trequired := n.required\n-\t\tfor _, r := range required {\n-\t\t\tif r.Version == \"none\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tv := min[r.Path]\n-\t\t\tif r.Path != target.Path && reqs.Max(v, r.Version) != v {\n-\t\t\t\tpanic(fmt.Sprintf(\"mistake: version %q does not satisfy requirement %+v\", v, r)) // TODO: Don't panic.\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\ttail := list[1:]\n-\tsort.Slice(tail, func(i, j int) bool {\n-\t\treturn tail[i].Path < tail[j].Path\n-\t})\n \treturn list, nil\n }\n \n@@ -293,10 +242,15 @@ func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, err\n \t}\n \t// First walk the base modules that must be listed.\n \tvar min []module.Version\n+\thaveBase := map[string]bool{}\n \tfor _, path := range base {\n+\t\tif haveBase[path] {\n+\t\t\tcontinue\n+\t\t}\n \t\tm := module.Version{Path: path, Version: max[path]}\n \t\tmin = append(min, m)\n \t\twalk(m)\n+\t\thaveBase[path] = true\n \t}\n \t// Now the reverse postorder to bring in anything else.\n \tfor i := len(postorder) - 1; i >= 0; i-- {\n@@ -318,7 +272,7 @@ func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, err\n \n // UpgradeAll returns a build list for the target module\n // in which every module is upgraded to its latest version.\n-func UpgradeAll(target module.Version, reqs Reqs) ([]module.Version, error) {\n+func UpgradeAll(target module.Version, reqs UpgradeReqs) ([]module.Version, error) {\n \treturn buildList(target, reqs, func(m module.Version) (module.Version, error) {\n \t\tif m.Path == target.Path {\n \t\t\treturn target, nil\n@@ -330,7 +284,7 @@ func UpgradeAll(target module.Version, reqs Reqs) ([]module.Version, error) {\n \n // Upgrade returns a build list for the target module\n // in which the given additional modules are upgraded.\n-func Upgrade(target module.Version, reqs Reqs, upgrade ...module.Version) ([]module.Version, error) {\n+func Upgrade(target module.Version, reqs UpgradeReqs, upgrade ...module.Version) ([]module.Version, error) {\n \tlist, err := reqs.Required(target)\n \tif err != nil {\n \t\treturn nil, err\n@@ -369,11 +323,20 @@ func Upgrade(target module.Version, reqs Reqs, upgrade ...module.Version) ([]mod\n // The versions to be downgraded may be unreachable from reqs.Latest and\n // reqs.Previous, but the methods of reqs must otherwise handle such versions\n // correctly.\n-func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([]module.Version, error) {\n-\tlist, err := reqs.Required(target)\n+func Downgrade(target module.Version, reqs DowngradeReqs, downgrade ...module.Version) ([]module.Version, error) {\n+\t// Per https://research.swtch.com/vgo-mvs#algorithm_4:\n+\t// \u201cTo avoid an unnecessary downgrade to E 1.1, we must also add a new\n+\t// requirement on E 1.2. We can apply Algorithm R to find the minimal set of\n+\t// new requirements to write to go.mod.\u201d\n+\t//\n+\t// In order to generate those new requirements, we need to identify versions\n+\t// for every module in the build list \u2014 not just reqs.Required(target).\n+\tlist, err := BuildList(target, reqs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tlist = list[1:] // remove target\n+\n \tmax := make(map[string]string)\n \tfor _, r := range list {\n \t\tmax[r.Path] = r.Version\n@@ -406,6 +369,9 @@ func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([\n \t\t}\n \t\tadded[m] = true\n \t\tif v, ok := max[m.Path]; ok && reqs.Max(m.Version, v) != v {\n+\t\t\t// m would upgrade an existing dependency \u2014 it is not a strict downgrade,\n+\t\t\t// and because it was already present as a dependency, it could affect the\n+\t\t\t// behavior of other relevant packages.\n \t\t\texclude(m)\n \t\t\treturn\n \t\t}\n@@ -422,6 +388,7 @@ func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([\n \t\t\t// is transient (we couldn't download go.mod), return the error from\n \t\t\t// Downgrade. Currently, we can't tell what kind of error it is.\n \t\t\texclude(m)\n+\t\t\treturn\n \t\t}\n \t\tfor _, r := range list {\n \t\t\tadd(r)\n@@ -433,8 +400,8 @@ func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([\n \t\t}\n \t}\n \n-\tvar out []module.Version\n-\tout = append(out, target)\n+\tdowngraded := make([]module.Version, 0, len(list)+1)\n+\tdowngraded = append(downgraded, target)\n List:\n \tfor _, r := range list {\n \t\tadd(r)\n@@ -461,10 +428,49 @@ List:\n \t\t\tadd(p)\n \t\t\tr = p\n \t\t}\n-\t\tout = append(out, r)\n+\t\tdowngraded = append(downgraded, r)\n \t}\n \n-\treturn out, nil\n+\t// The downgrades we computed above only downgrade to versions enumerated by\n+\t// reqs.Previous. However, reqs.Previous omits some versions \u2014 such as\n+\t// pseudo-versions and retracted versions \u2014 that may be selected as transitive\n+\t// requirements of other modules.\n+\t//\n+\t// If one of those requirements pulls the version back up above the version\n+\t// identified by reqs.Previous, then the transitive dependencies of that that\n+\t// initially-downgraded version should no longer matter \u2014 in particular, we\n+\t// should not add new dependencies on module paths that nothing else in the\n+\t// updated module graph even requires.\n+\t//\n+\t// In order to eliminate those spurious dependencies, we recompute the build\n+\t// list with the actual versions of the downgraded modules as selected by MVS,\n+\t// instead of our initial downgrades.\n+\t// (See the downhiddenartifact and downhiddencross test cases).\n+\tactual, err := BuildList(target, &override{\n+\t\ttarget: target,\n+\t\tlist:   downgraded,\n+\t\tReqs:   reqs,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tactualVersion := make(map[string]string, len(actual))\n+\tfor _, m := range actual {\n+\t\tactualVersion[m.Path] = m.Version\n+\t}\n+\n+\tdowngraded = downgraded[:0]\n+\tfor _, m := range list {\n+\t\tif v, ok := actualVersion[m.Path]; ok {\n+\t\t\tdowngraded = append(downgraded, module.Version{Path: m.Path, Version: v})\n+\t\t}\n+\t}\n+\n+\treturn BuildList(target, &override{\n+\t\ttarget: target,\n+\t\tlist:   downgraded,\n+\t\tReqs:   reqs,\n+\t})\n }\n \n type override struct {"}, {"sha": "598ed666889517a112c01e78d5b6fcb95101fcd2", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 135, "deletions": 25, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -28,10 +28,11 @@ D4: E2 F1\n D5: E2\n G1: C4\n A2: B1 C4 D4\n-build A: A B1 C2 D4 E2 F1\n-upgrade* A: A B1 C4 D5 E2 F1 G1\n-upgrade A C4: A B1 C4 D4 E2 F1 G1\n-downgrade A2 D2: A2 C4 D2\n+build A:       A B1 C2 D4 E2 F1\n+upgrade* A:    A B1 C4 D5 E2 F1 G1\n+upgrade A C4:  A B1 C4 D4 E2 F1 G1\n+build A2:     A2 B1 C4 D4 E2 F1 G1\n+downgrade A2 D2: A2 C4 D2 E2 F1 G1\n \n name: trim\n A: B1 C2\n@@ -68,7 +69,7 @@ B2: D1\n C: D2\n D1: E2\n D2: E1\n-build A: A B1 C D2 E1\n+build A:      A B1 C D2 E1\n upgrade A B2: A B2 C D2 E2\n \n name: cross1R\n@@ -136,17 +137,17 @@ name: cross5\n A: D1\n D1: E2\n D2: E1\n-build A: A D1 E2\n-upgrade* A: A D2 E2\n-upgrade A D2: A D2 E2\n+build A:       A D1 E2\n+upgrade* A:    A D2 E2\n+upgrade A D2:  A D2 E2\n upgradereq A D2: D2 E2\n \n name: cross6\n A: D2\n D1: E2\n D2: E1\n-build A: A D2 E1\n-upgrade* A: A D2 E2\n+build A:      A D2 E1\n+upgrade* A:   A D2 E2\n upgrade A E2: A D2 E2\n \n name: cross7\n@@ -175,7 +176,7 @@ B1: D1\n B2:\n C2:\n D2:\n-build A: A B1 C1 D1\n+build A:    A B1 C1 D1\n upgrade* A: A B2 C2 D2\n \n name: simplify\n@@ -194,7 +195,7 @@ B4:\n B5.hidden:\n C2:\n C3:\n-build A: A B1 C1\n+build A:    A B1 C1\n upgrade* A: A B4 C3\n \n name: up2\n@@ -206,15 +207,15 @@ B4:\n B5.hidden:\n C2:\n C3:\n-build A: A B5.hidden C1\n+build A:    A B5.hidden C1\n upgrade* A: A B5.hidden C3\n \n name: down1\n A: B2\n B1: C1\n B2: C2\n-build A: A B2 C2\n-downgrade A C1: A B1\n+build A:        A B2 C2\n+downgrade A C1: A B1 C1\n \n name: down2\n A: B2 E2\n@@ -227,33 +228,129 @@ D2: B2\n E2: D2\n E1:\n F1:\n-downgrade A F1: A B1 E1\n+build A:        A B2 C2 D2 E2 F2\n+downgrade A F1: A B1 C1 D1 E1 F1\n+\n+# https://research.swtch.com/vgo-mvs#algorithm_4:\n+# \u201c[D]owngrades are constrained to only downgrade packages, not also upgrade\n+# them; if an upgrade before downgrade is needed, the user must ask for it\n+# explicitly.\u201d\n+#\n+# Here, downgrading B2 to B1 upgrades C1 to C2, and C2 does not depend on D2.\n+# However, C2 would be an upgrade \u2014 not a downgrade \u2014 so B1 must also be\n+# rejected.\n+name: downcross1\n+A: B2 C1\n+B1: C2\n+B2: C1\n+C1: D2\n+C2:\n+D1:\n+D2:\n+build A:        A B2 C1 D2\n+downgrade A D1: A       D1\n+\n+# https://research.swtch.com/vgo-mvs#algorithm_4:\n+# \u201cUnlike upgrades, downgrades must work by removing requirements, not adding\n+# them.\u201d\n+#\n+# However, downgrading a requirement may introduce a new requirement on a\n+# previously-unrequired module. If each dependency's requirements are complete\n+# (\u201ctidy\u201d), that can't change the behavior of any other package whose version is\n+# not also being downgraded, so we should allow it.\n+name: downcross2\n+A: B2\n+B1: C1\n+B2: D2\n+C1:\n+D1:\n+D2:\n+build A:        A B2    D2\n+downgrade A D1: A B1 C1 D1\n \n name: downcycle\n A: A B2\n B2: A\n B1:\n+build A:        A B2\n downgrade A B1: A B1\n \n+# Both B3 and C2 require D2.\n+# If we downgrade D to D1, then in isolation B3 would downgrade to B1,\n+# because B2 is hidden \u2014 B1 is the next-highest version that is not hidden.\n+# However, if we downgrade D, we will also downgrade C to C1.\n+# And C1 requires B2.hidden, and B2.hidden also meets our requirements:\n+# it is compatible with D1 and a strict downgrade from B3.\n+#\n+# Since neither the initial nor the final build list includes B1,\n+# and the nothing in the final downgraded build list requires E at all,\n+# no dependency on E1 (required by only B1) should be introduced.\n+#\n+name: downhiddenartifact\n+A: B3 C2\n+A1: B3\n+B1: E1\n+B2.hidden:\n+B3: D2\n+C1: B2.hidden\n+C2: D2\n+D1:\n+D2:\n+build A1: A1 B3 D2\n+downgrade A1 D1: A1 B1 D1 E1\n+build A: A B3 C2 D2\n+downgrade A D1: A B2.hidden C1 D1\n+\n+# Both B3 and C3 require D2.\n+# If we downgrade D to D1, then in isolation B3 would downgrade to B1,\n+# and C3 would downgrade to C1.\n+# But C1 requires B2.hidden, and B1 requires C2.hidden, so we can't\n+# downgrade to either of those without pulling the other back up a little.\n+#\n+# B2.hidden and C2.hidden are both compatible with D1, so that still\n+# meets our requirements \u2014 but then we're in an odd state in which\n+# B and C have both been downgraded to hidden versions, without any\n+# remaining requirements to explain how those hidden versions got there.\n+#\n+# TODO(bcmills): Would it be better to force downgrades to land on non-hidden\n+# versions?\n+# In this case, that would remove the dependencies on B and C entirely.\n+#\n+name: downhiddencross\n+A: B3 C3\n+B1: C2.hidden\n+B2.hidden:\n+B3: D2\n+C1: B2.hidden\n+C2.hidden:\n+C3: D2\n+D1:\n+D2:\n+build A: A B3 C3 D2\n+downgrade A D1: A B2.hidden C2.hidden D1\n+\n # golang.org/issue/25542.\n name: noprev1\n A: B4 C2\n B2.hidden:\n C2:\n+build A:               A B4        C2\n downgrade A B2.hidden: A B2.hidden C2\n \n name: noprev2\n A: B4 C2\n B2.hidden:\n B1:\n C2:\n+build A:               A B4        C2\n downgrade A B2.hidden: A B2.hidden C2\n \n name: noprev3\n A: B4 C2\n B3:\n B2.hidden:\n C2:\n+build A:               A B4        C2\n downgrade A B2.hidden: A B2.hidden C2\n \n # Cycles involving the target.\n@@ -264,9 +361,9 @@ A: B1\n B1: A1\n B2: A2\n B3: A3\n-build A: A B1\n+build A:      A B1\n upgrade A B2: A B2\n-upgrade* A: A B3\n+upgrade* A:   A B3\n \n # golang.org/issue/29773:\n # Requirements of older versions of the target\n@@ -280,7 +377,7 @@ B2: A2\n C1: A2\n C2:\n D2:\n-build A: A B1 C1 D1\n+build A:    A B1 C1 D1\n upgrade* A: A B2 C2 D2\n \n # Cycles with multiple possible solutions.\n@@ -293,23 +390,23 @@ B2: C2\n C1:\n C2: B2\n build M: M A1 B2 C2\n-req M: A1 B2\n-req M A: A1 B2\n-req M C: A1 C2\n+req M:     A1 B2\n+req M A:   A1 B2\n+req M C:   A1 C2\n \n # Requirement minimization.\n \n name: req1\n A: B1 C1 D1 E1 F1\n B1: C1 E1 F1\n-req A: B1 D1\n+req A:   B1    D1\n req A C: B1 C1 D1\n \n name: req2\n A: G1 H1\n G1: H1\n H1: G1\n-req A: G1\n+req A:   G1\n req A G: G1\n req A H: H1\n \n@@ -326,7 +423,20 @@ M: Anone B1 D1 E1\n B1: Cnone D1\n E1: Fnone\n build M: M B1 D1 E1\n-req M: B1 E1\n+req M:     B1    E1\n+\n+name: reqdup\n+M: A1 B1\n+A1: B1\n+B1:\n+req M A A: A1\n+\n+name: reqcross\n+M: A1 B1 C1\n+A1: B1 C1\n+B1: C1\n+C1:\n+req M A B: A1 B1\n `\n \n func Test(t *testing.T) {"}, {"sha": "9788171d6e200d6c5648772cf3729a54ae606d66", "filename": "libgo/go/cmd/go/internal/renameio/renameio.go", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package renameio writes files atomically by renaming temporary files.\n-package renameio\n-\n-import (\n-\t\"bytes\"\n-\t\"io\"\n-\t\"io/fs\"\n-\t\"math/rand\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"strconv\"\n-\n-\t\"cmd/go/internal/robustio\"\n-)\n-\n-const patternSuffix = \".tmp\"\n-\n-// Pattern returns a glob pattern that matches the unrenamed temporary files\n-// created when writing to filename.\n-func Pattern(filename string) string {\n-\treturn filepath.Join(filepath.Dir(filename), filepath.Base(filename)+patternSuffix)\n-}\n-\n-// WriteFile is like os.WriteFile, but first writes data to an arbitrary\n-// file in the same directory as filename, then renames it atomically to the\n-// final name.\n-//\n-// That ensures that the final location, if it exists, is always a complete file.\n-func WriteFile(filename string, data []byte, perm fs.FileMode) (err error) {\n-\treturn WriteToFile(filename, bytes.NewReader(data), perm)\n-}\n-\n-// WriteToFile is a variant of WriteFile that accepts the data as an io.Reader\n-// instead of a slice.\n-func WriteToFile(filename string, data io.Reader, perm fs.FileMode) (err error) {\n-\tf, err := tempFile(filepath.Dir(filename), filepath.Base(filename), perm)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer func() {\n-\t\t// Only call os.Remove on f.Name() if we failed to rename it: otherwise,\n-\t\t// some other process may have created a new file with the same name after\n-\t\t// that.\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\tos.Remove(f.Name())\n-\t\t}\n-\t}()\n-\n-\tif _, err := io.Copy(f, data); err != nil {\n-\t\treturn err\n-\t}\n-\t// Sync the file before renaming it: otherwise, after a crash the reader may\n-\t// observe a 0-length file instead of the actual contents.\n-\t// See https://golang.org/issue/22397#issuecomment-380831736.\n-\tif err := f.Sync(); err != nil {\n-\t\treturn err\n-\t}\n-\tif err := f.Close(); err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn robustio.Rename(f.Name(), filename)\n-}\n-\n-// ReadFile is like os.ReadFile, but on Windows retries spurious errors that\n-// may occur if the file is concurrently replaced.\n-//\n-// Errors are classified heuristically and retries are bounded, so even this\n-// function may occasionally return a spurious error on Windows.\n-// If so, the error will likely wrap one of:\n-// \t- syscall.ERROR_ACCESS_DENIED\n-// \t- syscall.ERROR_FILE_NOT_FOUND\n-// \t- internal/syscall/windows.ERROR_SHARING_VIOLATION\n-func ReadFile(filename string) ([]byte, error) {\n-\treturn robustio.ReadFile(filename)\n-}\n-\n-// tempFile creates a new temporary file with given permission bits.\n-func tempFile(dir, prefix string, perm fs.FileMode) (f *os.File, err error) {\n-\tfor i := 0; i < 10000; i++ {\n-\t\tname := filepath.Join(dir, prefix+strconv.Itoa(rand.Intn(1000000000))+patternSuffix)\n-\t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, perm)\n-\t\tif os.IsExist(err) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tbreak\n-\t}\n-\treturn\n-}"}, {"sha": "5b2ed836242a4a8399566514d1c13a716dbd29dc", "filename": "libgo/go/cmd/go/internal/renameio/renameio_test.go", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,160 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !plan9\n-\n-package renameio\n-\n-import (\n-\t\"encoding/binary\"\n-\t\"errors\"\n-\t\"internal/testenv\"\n-\t\"math/rand\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"runtime\"\n-\t\"strings\"\n-\t\"sync\"\n-\t\"sync/atomic\"\n-\t\"syscall\"\n-\t\"testing\"\n-\t\"time\"\n-\n-\t\"cmd/go/internal/robustio\"\n-)\n-\n-func TestConcurrentReadsAndWrites(t *testing.T) {\n-\tif runtime.GOOS == \"darwin\" && strings.HasSuffix(testenv.Builder(), \"-10_14\") {\n-\t\ttestenv.SkipFlaky(t, 33041)\n-\t}\n-\n-\tdir, err := os.MkdirTemp(\"\", \"renameio\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\tpath := filepath.Join(dir, \"blob.bin\")\n-\n-\tconst chunkWords = 8 << 10\n-\tbuf := make([]byte, 2*chunkWords*8)\n-\tfor i := uint64(0); i < 2*chunkWords; i++ {\n-\t\tbinary.LittleEndian.PutUint64(buf[i*8:], i)\n-\t}\n-\n-\tvar attempts int64 = 128\n-\tif !testing.Short() {\n-\t\tattempts *= 16\n-\t}\n-\tconst parallel = 32\n-\n-\tvar sem = make(chan bool, parallel)\n-\n-\tvar (\n-\t\twriteSuccesses, readSuccesses int64 // atomic\n-\t\twriteErrnoSeen, readErrnoSeen sync.Map\n-\t)\n-\n-\tfor n := attempts; n > 0; n-- {\n-\t\tsem <- true\n-\t\tgo func() {\n-\t\t\tdefer func() { <-sem }()\n-\n-\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Microsecond)\n-\t\t\toffset := rand.Intn(chunkWords)\n-\t\t\tchunk := buf[offset*8 : (offset+chunkWords)*8]\n-\t\t\tif err := WriteFile(path, chunk, 0666); err == nil {\n-\t\t\t\tatomic.AddInt64(&writeSuccesses, 1)\n-\t\t\t} else if robustio.IsEphemeralError(err) {\n-\t\t\t\tvar (\n-\t\t\t\t\terrno syscall.Errno\n-\t\t\t\t\tdup   bool\n-\t\t\t\t)\n-\t\t\t\tif errors.As(err, &errno) {\n-\t\t\t\t\t_, dup = writeErrnoSeen.LoadOrStore(errno, true)\n-\t\t\t\t}\n-\t\t\t\tif !dup {\n-\t\t\t\t\tt.Logf(\"ephemeral error: %v\", err)\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n-\t\t\t}\n-\n-\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Microsecond)\n-\t\t\tdata, err := ReadFile(path)\n-\t\t\tif err == nil {\n-\t\t\t\tatomic.AddInt64(&readSuccesses, 1)\n-\t\t\t} else if robustio.IsEphemeralError(err) {\n-\t\t\t\tvar (\n-\t\t\t\t\terrno syscall.Errno\n-\t\t\t\t\tdup   bool\n-\t\t\t\t)\n-\t\t\t\tif errors.As(err, &errno) {\n-\t\t\t\t\t_, dup = readErrnoSeen.LoadOrStore(errno, true)\n-\t\t\t\t}\n-\t\t\t\tif !dup {\n-\t\t\t\t\tt.Logf(\"ephemeral error: %v\", err)\n-\t\t\t\t}\n-\t\t\t\treturn\n-\t\t\t} else {\n-\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tif len(data) != 8*chunkWords {\n-\t\t\t\tt.Errorf(\"read %d bytes, but each write is a %d-byte file\", len(data), 8*chunkWords)\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tu := binary.LittleEndian.Uint64(data)\n-\t\t\tfor i := 1; i < chunkWords; i++ {\n-\t\t\t\tnext := binary.LittleEndian.Uint64(data[i*8:])\n-\t\t\t\tif next != u+1 {\n-\t\t\t\t\tt.Errorf(\"wrote sequential integers, but read integer out of sequence at offset %d\", i)\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tu = next\n-\t\t\t}\n-\t\t}()\n-\t}\n-\n-\tfor n := parallel; n > 0; n-- {\n-\t\tsem <- true\n-\t}\n-\n-\tvar minWriteSuccesses int64 = attempts\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// Windows produces frequent \"Access is denied\" errors under heavy rename load.\n-\t\t// As long as those are the only errors and *some* of the writes succeed, we're happy.\n-\t\tminWriteSuccesses = attempts / 4\n-\t}\n-\n-\tif writeSuccesses < minWriteSuccesses {\n-\t\tt.Errorf(\"%d (of %d) writes succeeded; want \u2265 %d\", writeSuccesses, attempts, minWriteSuccesses)\n-\t} else {\n-\t\tt.Logf(\"%d (of %d) writes succeeded (ok: \u2265 %d)\", writeSuccesses, attempts, minWriteSuccesses)\n-\t}\n-\n-\tvar minReadSuccesses int64 = attempts\n-\n-\tswitch runtime.GOOS {\n-\tcase \"windows\":\n-\t\t// Windows produces frequent \"Access is denied\" errors under heavy rename load.\n-\t\t// As long as those are the only errors and *some* of the reads succeed, we're happy.\n-\t\tminReadSuccesses = attempts / 4\n-\n-\tcase \"darwin\", \"ios\":\n-\t\t// The filesystem on certain versions of macOS (10.14) and iOS (affected\n-\t\t// versions TBD) occasionally fail with \"no such file or directory\" errors.\n-\t\t// See https://golang.org/issue/33041 and https://golang.org/issue/42066.\n-\t\t// The flake rate is fairly low, so ensure that at least 75% of attempts\n-\t\t// succeed.\n-\t\tminReadSuccesses = attempts - (attempts / 4)\n-\t}\n-\n-\tif readSuccesses < minReadSuccesses {\n-\t\tt.Errorf(\"%d (of %d) reads succeeded; want \u2265 %d\", readSuccesses, attempts, minReadSuccesses)\n-\t} else {\n-\t\tt.Logf(\"%d (of %d) reads succeeded (ok: \u2265 %d)\", readSuccesses, attempts, minReadSuccesses)\n-\t}\n-}"}, {"sha": "65e4fa587b7943d740ee024df4eca4c611163993", "filename": "libgo/go/cmd/go/internal/renameio/umask_test.go", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go?ref=72be20e20299ec57b4bc9ba03d5b7d6bf10e97cc", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !plan9,!windows,!js\n-\n-package renameio\n-\n-import (\n-\t\"io/fs\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"syscall\"\n-\t\"testing\"\n-)\n-\n-func TestWriteFileModeAppliesUmask(t *testing.T) {\n-\tdir, err := os.MkdirTemp(\"\", \"renameio\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\n-\tconst mode = 0644\n-\tconst umask = 0007\n-\tdefer syscall.Umask(syscall.Umask(umask))\n-\n-\tfile := filepath.Join(dir, \"testWrite\")\n-\terr = WriteFile(file, []byte(\"go-build\"), mode)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Failed to write file: %v\", err)\n-\t}\n-\n-\tfi, err := os.Stat(file)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Stat %q (looking for mode %#o): %s\", file, mode, err)\n-\t}\n-\n-\tif fi.Mode()&fs.ModePerm != 0640 {\n-\t\tt.Errorf(\"Stat %q: mode %#o want %#o\", file, fi.Mode()&fs.ModePerm, 0640)\n-\t}\n-}"}, {"sha": "d5c241857b476c47cfed2c9bb1c5b1f739426ee3", "filename": "libgo/go/cmd/go/internal/robustio/robustio_flaky.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build windows || darwin\n // +build windows darwin\n \n package robustio"}, {"sha": "3a20cac6cf88aef9882a484439c2298489a80e2f", "filename": "libgo/go/cmd/go/internal/robustio/robustio_other.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !windows && !darwin\n // +build !windows,!darwin\n \n package robustio"}, {"sha": "784f7162dfd3f5b01bbd7c60a89975a9e3e5f1aa", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,13 +8,16 @@ package run\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"os\"\n \t\"path\"\n+\t\"path/filepath\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n )\n@@ -24,10 +27,21 @@ var CmdRun = &base.Command{\n \tShort:     \"compile and run Go program\",\n \tLong: `\n Run compiles and runs the named main Go package.\n-Typically the package is specified as a list of .go source files from a single directory,\n-but it may also be an import path, file system path, or pattern\n+Typically the package is specified as a list of .go source files from a single\n+directory, but it may also be an import path, file system path, or pattern\n matching a single known package, as in 'go run .' or 'go run my/cmd'.\n \n+If the package argument has a version suffix (like @latest or @v1.0.0),\n+\"go run\" builds the program in module-aware mode, ignoring the go.mod file in\n+the current directory or any parent directory, if there is one. This is useful\n+for running programs without affecting the dependencies of the main module.\n+\n+If the package argument doesn't have a version suffix, \"go run\" may run in\n+module-aware mode or GOPATH mode, depending on the GO111MODULE environment\n+variable and the presence of a go.mod file. See 'go help modules' for details.\n+If module-aware mode is enabled, \"go run\" runs in the context of the main\n+module.\n+\n By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.\n If the -exec flag is given, 'go run' invokes the binary using xprog:\n \t'xprog a.out arguments...'.\n@@ -59,14 +73,26 @@ func printStderr(args ...interface{}) (int, error) {\n }\n \n func runRun(ctx context.Context, cmd *base.Command, args []string) {\n+\tif shouldUseOutsideModuleMode(args) {\n+\t\t// Set global module flags for 'go run cmd@version'.\n+\t\t// This must be done before modload.Init, but we need to call work.BuildInit\n+\t\t// before loading packages, since it affects package locations, e.g.,\n+\t\t// for -race and -msan.\n+\t\tmodload.ForceUseModules = true\n+\t\tmodload.RootMode = modload.NoRoot\n+\t\tmodload.AllowMissingModuleImports()\n+\t\tmodload.Init()\n+\t}\n \twork.BuildInit()\n \tvar b work.Builder\n \tb.Init()\n \tb.Print = printStderr\n+\n \ti := 0\n \tfor i < len(args) && strings.HasSuffix(args[i], \".go\") {\n \t\ti++\n \t}\n+\tpkgOpts := load.PackageOpts{MainOnly: true}\n \tvar p *load.Package\n \tif i > 0 {\n \t\tfiles := args[:i]\n@@ -77,18 +103,29 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\tbase.Fatalf(\"go run: cannot run *_test.go files (%s)\", file)\n \t\t\t}\n \t\t}\n-\t\tp = load.GoFilesPackage(ctx, files)\n+\t\tp = load.GoFilesPackage(ctx, pkgOpts, files)\n \t} else if len(args) > 0 && !strings.HasPrefix(args[0], \"-\") {\n-\t\tpkgs := load.PackagesAndErrors(ctx, args[:1])\n+\t\targ := args[0]\n+\t\tvar pkgs []*load.Package\n+\t\tif strings.Contains(arg, \"@\") && !build.IsLocalImport(arg) && !filepath.IsAbs(arg) {\n+\t\t\tvar err error\n+\t\t\tpkgs, err = load.PackagesAndErrorsOutsideModule(ctx, pkgOpts, args[:1])\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Fatalf(\"go run: %v\", err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tpkgs = load.PackagesAndErrors(ctx, pkgOpts, args[:1])\n+\t\t}\n+\n \t\tif len(pkgs) == 0 {\n-\t\t\tbase.Fatalf(\"go run: no packages loaded from %s\", args[0])\n+\t\t\tbase.Fatalf(\"go run: no packages loaded from %s\", arg)\n \t\t}\n \t\tif len(pkgs) > 1 {\n \t\t\tvar names []string\n \t\t\tfor _, p := range pkgs {\n \t\t\t\tnames = append(names, p.ImportPath)\n \t\t\t}\n-\t\t\tbase.Fatalf(\"go run: pattern %s matches multiple packages:\\n\\t%s\", args[0], strings.Join(names, \"\\n\\t\"))\n+\t\t\tbase.Fatalf(\"go run: pattern %s matches multiple packages:\\n\\t%s\", arg, strings.Join(names, \"\\n\\t\"))\n \t\t}\n \t\tp = pkgs[0]\n \t\ti++\n@@ -98,9 +135,6 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \tcmdArgs := args[i:]\n \tload.CheckPackageErrors([]*load.Package{p})\n \n-\tif p.Name != \"main\" {\n-\t\tbase.Fatalf(\"go run: cannot run non-main package\")\n-\t}\n \tp.Internal.OmitDebug = true\n \tp.Target = \"\" // must build - not up to date\n \tif p.Internal.CmdlineFiles {\n@@ -123,11 +157,34 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t} else {\n \t\tp.Internal.ExeName = path.Base(p.ImportPath)\n \t}\n+\n \ta1 := b.LinkAction(work.ModeBuild, work.ModeBuild, p)\n \ta := &work.Action{Mode: \"go run\", Func: buildRunProgram, Args: cmdArgs, Deps: []*work.Action{a1}}\n \tb.Do(ctx, a)\n }\n \n+// shouldUseOutsideModuleMode returns whether 'go run' will load packages in\n+// module-aware mode, ignoring the go.mod file in the current directory. It\n+// returns true if the first argument contains \"@\", does not begin with \"-\"\n+// (resembling a flag) or end with \".go\" (a file). The argument must not be a\n+// local or absolute file path.\n+//\n+// These rules are slightly different than other commands. Whether or not\n+// 'go run' uses this mode, it interprets arguments ending with \".go\" as files\n+// and uses arguments up to the last \".go\" argument to comprise the package.\n+// If there are no \".go\" arguments, only the first argument is interpreted\n+// as a package path, since there can be only one package.\n+func shouldUseOutsideModuleMode(args []string) bool {\n+\t// NOTE: \"@\" not allowed in import paths, but it is allowed in non-canonical\n+\t// versions.\n+\treturn len(args) > 0 &&\n+\t\t!strings.HasSuffix(args[0], \".go\") &&\n+\t\t!strings.HasPrefix(args[0], \"-\") &&\n+\t\tstrings.Contains(args[0], \"@\") &&\n+\t\t!build.IsLocalImport(args[0]) &&\n+\t\t!filepath.IsAbs(args[0])\n+}\n+\n // buildRunProgram is the action for running a binary that has already\n // been compiled. We ignore exit status.\n func buildRunProgram(b *work.Builder, ctx context.Context, a *work.Action) error {"}, {"sha": "a0c806a259329c27c2f45739e1250550bec04f06", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -155,7 +155,7 @@ func (m *Match) MatchPackages() {\n \t\t\t}\n \n \t\t\tif !fi.IsDir() {\n-\t\t\t\tif fi.Mode()&fs.ModeSymlink != 0 && want {\n+\t\t\t\tif fi.Mode()&fs.ModeSymlink != 0 && want && strings.Contains(m.pattern, \"...\") {\n \t\t\t\t\tif target, err := fsys.Stat(path); err == nil && target.IsDir() {\n \t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: ignoring symlink %s\\n\", path)\n \t\t\t\t\t}\n@@ -445,7 +445,7 @@ func ImportPathsQuiet(patterns []string) []*Match {\n \t\t\tfor i, dir := range m.Dirs {\n \t\t\t\tabsDir := dir\n \t\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\t\tabsDir = filepath.Join(base.Cwd, dir)\n+\t\t\t\t\tabsDir = filepath.Join(base.Cwd(), dir)\n \t\t\t\t}\n \t\t\t\tif bp, _ := cfg.BuildContext.ImportDir(absDir, build.FindOnly); bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n \t\t\t\t\tm.Pkgs[i] = bp.ImportPath\n@@ -571,7 +571,6 @@ func IsRelativePath(pattern string) bool {\n // If so, InDir returns an equivalent path relative to dir.\n // If not, InDir returns an empty string.\n // InDir makes some effort to succeed even in the presence of symbolic links.\n-// TODO(rsc): Replace internal/test.inDir with a call to this function for Go 1.12.\n func InDir(path, dir string) string {\n \tif rel := inDirLex(path, dir); rel != \"\" {\n \t\treturn rel"}, {"sha": "657d22a6b4d2ff8a7a1d69c6e2ed76e6c869c3e6", "filename": "libgo/go/cmd/go/internal/test/cover.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -26,8 +26,8 @@ func initCoverProfile() {\n \tif testCoverProfile == \"\" || testC {\n \t\treturn\n \t}\n-\tif !filepath.IsAbs(testCoverProfile) && testOutputDir != \"\" {\n-\t\ttestCoverProfile = filepath.Join(testOutputDir, testCoverProfile)\n+\tif !filepath.IsAbs(testCoverProfile) {\n+\t\ttestCoverProfile = filepath.Join(testOutputDir.getAbs(), testCoverProfile)\n \t}\n \n \t// No mutex - caller's responsibility to call with no racing goroutines."}, {"sha": "37ac81c26782ae226be515bc2f65a42700de978d", "filename": "libgo/go/cmd/go/internal/test/flagdefs.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fflagdefs.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -28,6 +28,7 @@ var passFlagToTest = map[string]bool{\n \t\"parallel\":             true,\n \t\"run\":                  true,\n \t\"short\":                true,\n+\t\"shuffle\":              true,\n \t\"timeout\":              true,\n \t\"trace\":                true,\n \t\"v\":                    true,"}, {"sha": "9277de7fee839e216f8c70b31b8720d839f16c5e", "filename": "libgo/go/cmd/go/internal/test/genflags.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fgenflags.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build ignore\n // +build ignore\n \n package main"}, {"sha": "59ea1ef5445178f052006dd37af2d8b0b209b9ef", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -29,6 +29,7 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/lockedfile\"\n+\t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/trace\"\n \t\"cmd/go/internal/work\"\n@@ -117,8 +118,8 @@ elapsed time in the summary line.\n \n The rule for a match in the cache is that the run involves the same\n test binary and the flags on the command line come entirely from a\n-restricted set of 'cacheable' test flags, defined as -cpu, -list,\n--parallel, -run, -short, and -v. If a run of go test has any test\n+restricted set of 'cacheable' test flags, defined as -benchtime, -cpu,\n+-list, -parallel, -run, -short, and -v. If a run of go test has any test\n or non-test flags outside this set, the result is not cached. To\n disable test caching, use any test flag or argument other than the\n cacheable flags. The idiomatic way to disable test caching explicitly\n@@ -271,6 +272,13 @@ control the execution of any test:\n \t    the Go tree can run a sanity check but not spend time running\n \t    exhaustive tests.\n \n+\t-shuffle off,on,N\n+\t\tRandomize the execution order of tests and benchmarks.\n+\t\tIt is off by default. If -shuffle is set to on, then it will seed\n+\t\tthe randomizer using the system clock. If -shuffle is set to an\n+\t\tinteger N, then N will be used as the seed value. In both cases,\n+\t\tthe seed will be reported for reproducibility.\n+\n \t-timeout d\n \t    If a test binary runs longer than duration d, panic.\n \t    If d is 0, the timeout is disabled.\n@@ -478,7 +486,8 @@ var (\n \ttestJSON         bool                              // -json flag\n \ttestList         string                            // -list flag\n \ttestO            string                            // -o flag\n-\ttestOutputDir    = base.Cwd                        // -outputdir flag\n+\ttestOutputDir    outputdirFlag                     // -outputdir flag\n+\ttestShuffle      shuffleFlag                       // -shuffle flag\n \ttestTimeout      time.Duration                     // -timeout flag\n \ttestV            bool                              // -v flag\n \ttestVet          = vetFlag{flags: defaultVetFlags} // -vet flag\n@@ -568,8 +577,6 @@ var defaultVetFlags = []string{\n }\n \n func runTest(ctx context.Context, cmd *base.Command, args []string) {\n-\tload.ModResolveTests = true\n-\n \tpkgArgs, testArgs = testFlags(args)\n \n \tif cfg.DebugTrace != \"\" {\n@@ -595,7 +602,8 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \twork.VetFlags = testVet.flags\n \twork.VetExplicit = testVet.explicit\n \n-\tpkgs = load.PackagesAndErrors(ctx, pkgArgs)\n+\tpkgOpts := load.PackageOpts{ModResolveTests: true}\n+\tpkgs = load.PackagesAndErrors(ctx, pkgOpts, pkgArgs)\n \tload.CheckPackageErrors(pkgs)\n \tif len(pkgs) == 0 {\n \t\tbase.Fatalf(\"no packages to test\")\n@@ -679,7 +687,7 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t\tsort.Strings(all)\n \n \t\ta := &work.Action{Mode: \"go test -i\"}\n-\t\tpkgs := load.PackagesAndErrors(ctx, all)\n+\t\tpkgs := load.PackagesAndErrors(ctx, pkgOpts, all)\n \t\tload.CheckPackageErrors(pkgs)\n \t\tfor _, p := range pkgs {\n \t\t\tif cfg.BuildToolchainName == \"gccgo\" && p.Standard {\n@@ -702,11 +710,11 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t\tmatch := make([]func(*load.Package) bool, len(testCoverPaths))\n \t\tmatched := make([]bool, len(testCoverPaths))\n \t\tfor i := range testCoverPaths {\n-\t\t\tmatch[i] = load.MatchPackage(testCoverPaths[i], base.Cwd)\n+\t\t\tmatch[i] = load.MatchPackage(testCoverPaths[i], base.Cwd())\n \t\t}\n \n \t\t// Select for coverage all dependencies matching the testCoverPaths patterns.\n-\t\tfor _, p := range load.TestPackageList(ctx, pkgs) {\n+\t\tfor _, p := range load.TestPackageList(ctx, pkgOpts, pkgs) {\n \t\t\thaveMatch := false\n \t\t\tfor i := range testCoverPaths {\n \t\t\t\tif match[i](p) {\n@@ -715,6 +723,12 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\t// A package which only has test files can't be imported\n+\t\t\t// as a dependency, nor can it be instrumented for coverage.\n+\t\t\tif len(p.GoFiles)+len(p.CgoFiles) == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n \t\t\t// Silently ignore attempts to run coverage on\n \t\t\t// sync/atomic when using atomic coverage mode.\n \t\t\t// Atomic coverage mode uses sync/atomic, so\n@@ -768,7 +782,7 @@ func runTest(ctx context.Context, cmd *base.Command, args []string) {\n \t\t\tensureImport(p, \"sync/atomic\")\n \t\t}\n \n-\t\tbuildTest, runTest, printTest, err := builderTest(&b, ctx, p)\n+\t\tbuildTest, runTest, printTest, err := builderTest(&b, ctx, pkgOpts, p)\n \t\tif err != nil {\n \t\t\tstr := err.Error()\n \t\t\tstr = strings.TrimPrefix(str, \"\\n\")\n@@ -835,7 +849,7 @@ var windowsBadWords = []string{\n \t\"update\",\n }\n \n-func builderTest(b *work.Builder, ctx context.Context, p *load.Package) (buildAction, runAction, printAction *work.Action, err error) {\n+func builderTest(b *work.Builder, ctx context.Context, pkgOpts load.PackageOpts, p *load.Package) (buildAction, runAction, printAction *work.Action, err error) {\n \tif len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {\n \t\tbuild := b.CompileAction(work.ModeBuild, work.ModeBuild, p)\n \t\trun := &work.Action{Mode: \"test run\", Package: p, Deps: []*work.Action{build}}\n@@ -858,7 +872,7 @@ func builderTest(b *work.Builder, ctx context.Context, p *load.Package) (buildAc\n \t\t\tDeclVars: declareCoverVars,\n \t\t}\n \t}\n-\tpmain, ptest, pxtest, err := load.TestPackagesFor(ctx, p, cover)\n+\tpmain, ptest, pxtest, err := load.TestPackagesFor(ctx, pkgOpts, p, cover)\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n@@ -931,11 +945,11 @@ func builderTest(b *work.Builder, ctx context.Context, p *load.Package) (buildAc\n \tvar installAction, cleanAction *work.Action\n \tif testC || testNeedBinary() {\n \t\t// -c or profiling flag: create action to copy binary to ./test.out.\n-\t\ttarget := filepath.Join(base.Cwd, testBinary+cfg.ExeSuffix)\n+\t\ttarget := filepath.Join(base.Cwd(), testBinary+cfg.ExeSuffix)\n \t\tif testO != \"\" {\n \t\t\ttarget = testO\n \t\t\tif !filepath.IsAbs(target) {\n-\t\t\t\ttarget = filepath.Join(base.Cwd, target)\n+\t\t\t\ttarget = filepath.Join(base.Cwd(), target)\n \t\t\t}\n \t\t}\n \t\tif target == os.DevNull {\n@@ -1326,7 +1340,8 @@ func (c *runCache) tryCacheWithID(b *work.Builder, a *work.Action, id string) bo\n \t\t\treturn false\n \t\t}\n \t\tswitch arg[:i] {\n-\t\tcase \"-test.cpu\",\n+\t\tcase \"-test.benchtime\",\n+\t\t\t\"-test.cpu\",\n \t\t\t\"-test.list\",\n \t\t\t\"-test.parallel\",\n \t\t\t\"-test.run\",\n@@ -1499,7 +1514,7 @@ func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error)\n \t\t\tif !filepath.IsAbs(name) {\n \t\t\t\tname = filepath.Join(pwd, name)\n \t\t\t}\n-\t\t\tif a.Package.Root == \"\" || !inDir(name, a.Package.Root) {\n+\t\t\tif a.Package.Root == \"\" || search.InDir(name, a.Package.Root) == \"\" {\n \t\t\t\t// Do not recheck files outside the module, GOPATH, or GOROOT root.\n \t\t\t\tbreak\n \t\t\t}\n@@ -1508,7 +1523,7 @@ func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error)\n \t\t\tif !filepath.IsAbs(name) {\n \t\t\t\tname = filepath.Join(pwd, name)\n \t\t\t}\n-\t\t\tif a.Package.Root == \"\" || !inDir(name, a.Package.Root) {\n+\t\t\tif a.Package.Root == \"\" || search.InDir(name, a.Package.Root) == \"\" {\n \t\t\t\t// Do not recheck files outside the module, GOPATH, or GOROOT root.\n \t\t\t\tbreak\n \t\t\t}\n@@ -1526,18 +1541,6 @@ func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error)\n \treturn sum, nil\n }\n \n-func inDir(path, dir string) bool {\n-\tif str.HasFilePathPrefix(path, dir) {\n-\t\treturn true\n-\t}\n-\txpath, err1 := filepath.EvalSymlinks(path)\n-\txdir, err2 := filepath.EvalSymlinks(dir)\n-\tif err1 == nil && err2 == nil && str.HasFilePathPrefix(xpath, xdir) {\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func hashGetenv(name string) cache.ActionID {\n \th := cache.NewHash(\"getenv\")\n \tv, ok := os.LookupEnv(name)"}, {"sha": "08f1efa2c0d26a0cf398f2b778c0adde90fc97ae", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"time\"\n \n@@ -61,15 +62,16 @@ func init() {\n \tcf.String(\"memprofilerate\", \"\", \"\")\n \tcf.StringVar(&testMutexProfile, \"mutexprofile\", \"\", \"\")\n \tcf.String(\"mutexprofilefraction\", \"\", \"\")\n-\tcf.Var(outputdirFlag{&testOutputDir}, \"outputdir\", \"\")\n+\tcf.Var(&testOutputDir, \"outputdir\", \"\")\n \tcf.Int(\"parallel\", 0, \"\")\n \tcf.String(\"run\", \"\", \"\")\n \tcf.Bool(\"short\", false, \"\")\n \tcf.DurationVar(&testTimeout, \"timeout\", 10*time.Minute, \"\")\n \tcf.StringVar(&testTrace, \"trace\", \"\", \"\")\n \tcf.BoolVar(&testV, \"v\", false, \"\")\n+\tcf.Var(&testShuffle, \"shuffle\", \"\")\n \n-\tfor name, _ := range passFlagToTest {\n+\tfor name := range passFlagToTest {\n \t\tcf.Var(cf.Lookup(name).Value, \"test.\"+name, \"\")\n \t}\n }\n@@ -126,19 +128,26 @@ func (f stringFlag) Set(value string) error {\n // outputdirFlag implements the -outputdir flag.\n // It interprets an empty value as the working directory of the 'go' command.\n type outputdirFlag struct {\n-\tresolved *string\n+\tabs string\n }\n \n-func (f outputdirFlag) String() string { return *f.resolved }\n-func (f outputdirFlag) Set(value string) (err error) {\n+func (f *outputdirFlag) String() string {\n+\treturn f.abs\n+}\n+func (f *outputdirFlag) Set(value string) (err error) {\n \tif value == \"\" {\n-\t\t// The empty string implies the working directory of the 'go' command.\n-\t\t*f.resolved = base.Cwd\n+\t\tf.abs = \"\"\n \t} else {\n-\t\t*f.resolved, err = filepath.Abs(value)\n+\t\tf.abs, err = filepath.Abs(value)\n \t}\n \treturn err\n }\n+func (f *outputdirFlag) getAbs() string {\n+\tif f.abs == \"\" {\n+\t\treturn base.Cwd()\n+\t}\n+\treturn f.abs\n+}\n \n // vetFlag implements the special parsing logic for the -vet flag:\n // a comma-separated list, with a distinguished value \"off\" and\n@@ -194,6 +203,41 @@ func (f *vetFlag) Set(value string) error {\n \treturn nil\n }\n \n+type shuffleFlag struct {\n+\ton   bool\n+\tseed *int64\n+}\n+\n+func (f *shuffleFlag) String() string {\n+\tif !f.on {\n+\t\treturn \"off\"\n+\t}\n+\tif f.seed == nil {\n+\t\treturn \"on\"\n+\t}\n+\treturn fmt.Sprintf(\"%d\", *f.seed)\n+}\n+\n+func (f *shuffleFlag) Set(value string) error {\n+\tif value == \"off\" {\n+\t\t*f = shuffleFlag{on: false}\n+\t\treturn nil\n+\t}\n+\n+\tif value == \"on\" {\n+\t\t*f = shuffleFlag{on: true}\n+\t\treturn nil\n+\t}\n+\n+\tseed, err := strconv.ParseInt(value, 10, 64)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(`-shuffle argument must be \"on\", \"off\", or an int64: %v`, err)\n+\t}\n+\n+\t*f = shuffleFlag{on: true, seed: &seed}\n+\treturn nil\n+}\n+\n // testFlags processes the command line, grabbing -x and -c, rewriting known flags\n // to have \"test\" before them, and reading the command line for the test binary.\n // Unfortunately for us, we need to do our own flag processing because go test\n@@ -367,7 +411,7 @@ func testFlags(args []string) (packageNames, passToTest []string) {\n \t// command. Set it explicitly if it is needed due to some other flag that\n \t// requests output.\n \tif testProfile() != \"\" && !outputDirSet {\n-\t\tinjectedFlags = append(injectedFlags, \"-test.outputdir=\"+testOutputDir)\n+\t\tinjectedFlags = append(injectedFlags, \"-test.outputdir=\"+testOutputDir.getAbs())\n \t}\n \n \t// If the user is explicitly passing -help or -h, show output"}, {"sha": "91485f6f745b1ffcc64fcbd95f3449cbcb2b7cb6", "filename": "libgo/go/cmd/go/internal/vcs/vcs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1176,7 +1176,7 @@ func expand(match map[string]string, s string) string {\n // and import paths referring to a fully-qualified importPath\n // containing a VCS type (foo.com/repo.git/dir)\n var vcsPaths = []*vcsPath{\n-\t// Github\n+\t// GitHub\n \t{\n \t\tpathPrefix: \"github.com\",\n \t\tregexp:     lazyregexp.New(`^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`),"}, {"sha": "1d419dddb98d6cdcc53ef5e3e6eb67b477531988", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -53,8 +53,6 @@ See also: go fmt, go fix.\n }\n \n func runVet(ctx context.Context, cmd *base.Command, args []string) {\n-\tload.ModResolveTests = true\n-\n \tvetFlags, pkgArgs := vetFlags(args)\n \n \tif cfg.DebugTrace != \"\" {\n@@ -87,7 +85,8 @@ func runVet(ctx context.Context, cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n-\tpkgs := load.PackagesAndErrors(ctx, pkgArgs)\n+\tpkgOpts := load.PackageOpts{ModResolveTests: true}\n+\tpkgs := load.PackagesAndErrors(ctx, pkgOpts, pkgArgs)\n \tload.CheckPackageErrors(pkgs)\n \tif len(pkgs) == 0 {\n \t\tbase.Fatalf(\"no packages to vet\")\n@@ -98,7 +97,7 @@ func runVet(ctx context.Context, cmd *base.Command, args []string) {\n \n \troot := &work.Action{Mode: \"go vet\"}\n \tfor _, p := range pkgs {\n-\t\t_, ptest, pxtest, err := load.TestPackagesFor(ctx, p, nil)\n+\t\t_, ptest, pxtest, err := load.TestPackagesFor(ctx, pkgOpts, p, nil)\n \t\tif err != nil {\n \t\t\tbase.Errorf(\"%v\", err)\n \t\t\tcontinue"}, {"sha": "08686cdfcf9f4c11e96587a99738a09aa62b4324", "filename": "libgo/go/cmd/go/internal/web/bootstrap.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build cmd_go_bootstrap\n // +build cmd_go_bootstrap\n \n // This code is compiled only into the bootstrap 'go' binary."}, {"sha": "f177278eba1e7d9088014ee0ae246e2efb0dca39", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !cmd_go_bootstrap\n // +build !cmd_go_bootstrap\n \n // This code is compiled into the real 'go' binary, but it is not\n@@ -27,7 +28,7 @@ import (\n \t\"cmd/internal/browser\"\n )\n \n-// impatientInsecureHTTPClient is used in -insecure mode,\n+// impatientInsecureHTTPClient is used with GOINSECURE,\n // when we're connecting to https servers that might not be there\n // or might be using self-signed certificates.\n var impatientInsecureHTTPClient = &http.Client{"}, {"sha": "453af402b43dd9eb9208af234701127cfa887f25", "filename": "libgo/go/cmd/go/internal/web/url_other.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !windows\n // +build !windows\n \n package web"}, {"sha": "4d6ed2ec7f8c1dd0d9ab90f83f4478057c36b46d", "filename": "libgo/go/cmd/go/internal/web/url_other_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:build !windows\n // +build !windows\n \n package web"}, {"sha": "2e00c0cb126c1b5face3adb872058e67ddbb8241", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -349,7 +349,7 @@ func readpkglist(shlibpath string) (pkgs []*load.Package) {\n \t\t\tif strings.HasPrefix(t, \"pkgpath \") {\n \t\t\t\tt = strings.TrimPrefix(t, \"pkgpath \")\n \t\t\t\tt = strings.TrimSuffix(t, \";\")\n-\t\t\t\tpkgs = append(pkgs, load.LoadImportWithFlags(t, base.Cwd, nil, &stk, nil, 0))\n+\t\t\t\tpkgs = append(pkgs, load.LoadImportWithFlags(t, base.Cwd(), nil, &stk, nil, 0))\n \t\t\t}\n \t\t}\n \t} else {\n@@ -360,7 +360,7 @@ func readpkglist(shlibpath string) (pkgs []*load.Package) {\n \t\tscanner := bufio.NewScanner(bytes.NewBuffer(pkglistbytes))\n \t\tfor scanner.Scan() {\n \t\t\tt := scanner.Text()\n-\t\t\tpkgs = append(pkgs, load.LoadImportWithFlags(t, base.Cwd, nil, &stk, nil, 0))\n+\t\t\tpkgs = append(pkgs, load.LoadImportWithFlags(t, base.Cwd(), nil, &stk, nil, 0))\n \t\t}\n \t}\n \treturn\n@@ -781,7 +781,7 @@ func (b *Builder) linkSharedAction(mode, depMode BuildMode, shlib string, a1 *Ac\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tvar stk load.ImportStack\n-\t\t\t\tp := load.LoadImportWithFlags(pkg, base.Cwd, nil, &stk, nil, 0)\n+\t\t\t\tp := load.LoadImportWithFlags(pkg, base.Cwd(), nil, &stk, nil, 0)\n \t\t\t\tif p.Error != nil {\n \t\t\t\t\tbase.Fatalf(\"load %s: %v\", pkg, p.Error)\n \t\t\t\t}"}, {"sha": "0ed2389cd5a81af6f3ff862dd275b9fb9ba0109e", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 17, "deletions": 139, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,9 +10,7 @@ import (\n \t\"fmt\"\n \t\"go/build\"\n \texec \"internal/execabs\"\n-\t\"internal/goroot\"\n \t\"os\"\n-\t\"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"strings\"\n@@ -21,13 +19,9 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/load\"\n-\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/trace\"\n-\n-\t\"golang.org/x/mod/modfile\"\n-\t\"golang.org/x/mod/module\"\n )\n \n var CmdBuild = &base.Command{\n@@ -71,7 +65,7 @@ and test commands:\n \t-p n\n \t\tthe number of programs, such as build commands or\n \t\ttest binaries, that can be run in parallel.\n-\t\tThe default is the number of CPUs available.\n+\t\tThe default is GOMAXPROCS, normally the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n@@ -134,8 +128,8 @@ and test commands:\n \t\ta build will run as if the disk file path exists with the contents\n \t\tgiven by the backing file paths, or as if the disk file path does not\n \t\texist if its backing file path is empty. Support for the -overlay flag\n-\t\thas some limitations:importantly, cgo files included from outside the\n-\t\tinclude path must be  in the same directory as the Go package they are\n+\t\thas some limitations: importantly, cgo files included from outside the\n+\t\tinclude path must be in the same directory as the Go package they are\n \t\tincluded from, and overlays will not appear when binaries and tests are\n \t\trun through go run and go test respectively.\n \t-pkgdir dir\n@@ -158,6 +152,8 @@ and test commands:\n \t\ta program to use to invoke toolchain programs like vet and asm.\n \t\tFor example, instead of running asm, the go command will run\n \t\t'cmd args /path/to/asm <arguments for asm>'.\n+\t\tThe TOOLEXEC_IMPORTPATH environment variable will be set,\n+\t\tmatching 'go list -f {{.ImportPath}}' for the package being built.\n \n The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a\n space-separated list of arguments to pass to an underlying tool\n@@ -372,7 +368,7 @@ func runBuild(ctx context.Context, cmd *base.Command, args []string) {\n \tvar b Builder\n \tb.Init()\n \n-\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tload.CheckPackageErrors(pkgs)\n \n \texplicitO := len(cfg.BuildO) > 0\n@@ -592,7 +588,7 @@ func runInstall(ctx context.Context, cmd *base.Command, args []string) {\n \t}\n \n \tBuildInit()\n-\tpkgs := load.PackagesAndErrors(ctx, args)\n+\tpkgs := load.PackagesAndErrors(ctx, load.PackageOpts{}, args)\n \tif cfg.ModulesEnabled && !modload.HasModRoot() {\n \t\thaveErrors := false\n \t\tallMissingErrors := true\n@@ -762,145 +758,27 @@ func installOutsideModule(ctx context.Context, args []string) {\n \tmodload.RootMode = modload.NoRoot\n \tmodload.AllowMissingModuleImports()\n \tmodload.Init()\n-\n-\t// Check that the arguments satisfy syntactic constraints.\n-\tvar version string\n-\tfor _, arg := range args {\n-\t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n-\t\t\tversion = arg[i+1:]\n-\t\t\tif version == \"\" {\n-\t\t\t\tbase.Fatalf(\"go install %s: version must not be empty\", arg)\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tpatterns := make([]string, len(args))\n-\tfor i, arg := range args {\n-\t\tif !strings.HasSuffix(arg, \"@\"+version) {\n-\t\t\tbase.Errorf(\"go install %s: all arguments must have the same version (@%s)\", arg, version)\n-\t\t\tcontinue\n-\t\t}\n-\t\tp := arg[:len(arg)-len(version)-1]\n-\t\tswitch {\n-\t\tcase build.IsLocalImport(p):\n-\t\t\tbase.Errorf(\"go install %s: argument must be a package path, not a relative path\", arg)\n-\t\tcase filepath.IsAbs(p):\n-\t\t\tbase.Errorf(\"go install %s: argument must be a package path, not an absolute path\", arg)\n-\t\tcase search.IsMetaPackage(p):\n-\t\t\tbase.Errorf(\"go install %s: argument must be a package path, not a meta-package\", arg)\n-\t\tcase path.Clean(p) != p:\n-\t\t\tbase.Errorf(\"go install %s: argument must be a clean package path\", arg)\n-\t\tcase !strings.Contains(p, \"...\") && search.IsStandardImportPath(p) && goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, p):\n-\t\t\tbase.Errorf(\"go install %s: argument must not be a package in the standard library\", arg)\n-\t\tdefault:\n-\t\t\tpatterns[i] = p\n-\t\t}\n-\t}\n-\tbase.ExitIfErrors()\n \tBuildInit()\n \n-\t// Query the module providing the first argument, load its go.mod file, and\n-\t// check that it doesn't contain directives that would cause it to be\n-\t// interpreted differently if it were the main module.\n-\t//\n-\t// If multiple modules match the first argument, accept the longest match\n-\t// (first result). It's possible this module won't provide packages named by\n-\t// later arguments, and other modules would. Let's not try to be too\n-\t// magical though.\n-\tallowed := modload.CheckAllowed\n-\tif modload.IsRevisionQuery(version) {\n-\t\t// Don't check for retractions if a specific revision is requested.\n-\t\tallowed = nil\n-\t}\n-\tnoneSelected := func(path string) (version string) { return \"none\" }\n-\tqrs, err := modload.QueryPackages(ctx, patterns[0], version, noneSelected, allowed)\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go install %s: %v\", args[0], err)\n-\t}\n-\tinstallMod := qrs[0].Mod\n-\tdata, err := modfetch.GoMod(installMod.Path, installMod.Version)\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go install %s: %v\", args[0], err)\n-\t}\n-\tf, err := modfile.Parse(\"go.mod\", data, nil)\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go install %s: %s: %v\", args[0], installMod, err)\n-\t}\n-\tdirectiveFmt := \"go install %s: %s\\n\" +\n-\t\t\"\\tThe go.mod file for the module providing named packages contains one or\\n\" +\n-\t\t\"\\tmore %s directives. It must not contain directives that would cause\\n\" +\n-\t\t\"\\tit to be interpreted differently than if it were the main module.\"\n-\tif len(f.Replace) > 0 {\n-\t\tbase.Fatalf(directiveFmt, args[0], installMod, \"replace\")\n-\t}\n-\tif len(f.Exclude) > 0 {\n-\t\tbase.Fatalf(directiveFmt, args[0], installMod, \"exclude\")\n-\t}\n-\n-\t// Since we are in NoRoot mode, the build list initially contains only\n-\t// the dummy command-line-arguments module. Add a requirement on the\n-\t// module that provides the packages named on the command line.\n-\tif err := modload.EditBuildList(ctx, nil, []module.Version{installMod}); err != nil {\n-\t\tbase.Fatalf(\"go install %s: %v\", args[0], err)\n-\t}\n-\n-\t// Load packages for all arguments. Ignore non-main packages.\n+\t// Load packages. Ignore non-main packages.\n \t// Print a warning if an argument contains \"...\" and matches no main packages.\n \t// PackagesAndErrors already prints warnings for patterns that don't match any\n \t// packages, so be careful not to double print.\n-\tmatchers := make([]func(string) bool, len(patterns))\n-\tfor i, p := range patterns {\n-\t\tif strings.Contains(p, \"...\") {\n-\t\t\tmatchers[i] = search.MatchPattern(p)\n-\t\t}\n-\t}\n-\n \t// TODO(golang.org/issue/40276): don't report errors loading non-main packages\n \t// matched by a pattern.\n-\tpkgs := load.PackagesAndErrors(ctx, patterns)\n-\tload.CheckPackageErrors(pkgs)\n-\tmainPkgs := make([]*load.Package, 0, len(pkgs))\n-\tmainCount := make([]int, len(patterns))\n-\tnonMainCount := make([]int, len(patterns))\n-\tfor _, pkg := range pkgs {\n-\t\tif pkg.Name == \"main\" {\n-\t\t\tmainPkgs = append(mainPkgs, pkg)\n-\t\t\tfor i := range patterns {\n-\t\t\t\tif matchers[i] != nil && matchers[i](pkg.ImportPath) {\n-\t\t\t\t\tmainCount[i]++\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfor i := range patterns {\n-\t\t\t\tif matchers[i] == nil && patterns[i] == pkg.ImportPath {\n-\t\t\t\t\tbase.Errorf(\"go install: package %s is not a main package\", pkg.ImportPath)\n-\t\t\t\t} else if matchers[i] != nil && matchers[i](pkg.ImportPath) {\n-\t\t\t\t\tnonMainCount[i]++\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\tbase.ExitIfErrors()\n-\tfor i, p := range patterns {\n-\t\tif matchers[i] != nil && mainCount[i] == 0 && nonMainCount[i] > 0 {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: warning: %q matched no main packages\\n\", p)\n-\t\t}\n+\tpkgOpts := load.PackageOpts{MainOnly: true}\n+\tpkgs, err := load.PackagesAndErrorsOutsideModule(ctx, pkgOpts, args)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go install: %v\", err)\n \t}\n-\n-\t// Check that named packages are all provided by the same module.\n-\tfor _, pkg := range mainPkgs {\n-\t\tif pkg.Module == nil {\n-\t\t\t// Packages in std, cmd, and their vendored dependencies\n-\t\t\t// don't have this field set.\n-\t\t\tbase.Errorf(\"go install: package %s not provided by module %s\", pkg.ImportPath, installMod)\n-\t\t} else if pkg.Module.Path != installMod.Path || pkg.Module.Version != installMod.Version {\n-\t\t\tbase.Errorf(\"go install: package %s provided by module %s@%s\\n\\tAll packages must be provided by the same module (%s).\", pkg.ImportPath, pkg.Module.Path, pkg.Module.Version, installMod)\n-\t\t}\n+\tload.CheckPackageErrors(pkgs)\n+\tpatterns := make([]string, len(args))\n+\tfor i, arg := range args {\n+\t\tpatterns[i] = arg[:strings.Index(arg, \"@\")]\n \t}\n-\tbase.ExitIfErrors()\n \n \t// Build and install the packages.\n-\tInstallPackages(ctx, patterns, mainPkgs)\n+\tInstallPackages(ctx, patterns, pkgs)\n }\n \n // ExecCmd is the command to use to run user binaries."}, {"sha": "600fc3083f0d506228fe1e26797013f94e11607b", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -173,10 +173,11 @@ func TestSharedLibName(t *testing.T) {\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Fatal(err)\n \t\t\t\t}\n+\t\t\t\tcwd := base.Cwd()\n \t\t\t\toldGopath := cfg.BuildContext.GOPATH\n \t\t\t\tdefer func() {\n \t\t\t\t\tcfg.BuildContext.GOPATH = oldGopath\n-\t\t\t\t\tos.Chdir(base.Cwd)\n+\t\t\t\t\tos.Chdir(cwd)\n \t\t\t\t\terr := os.RemoveAll(tmpGopath)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tt.Error(err)"}, {"sha": "4e9189a36320ace016890c567fd241ffb92a7a87", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -204,7 +204,7 @@ func (b *Builder) toolID(name string) string {\n // In order to get reproducible builds for released compilers, we\n // detect a released compiler by the absence of \"experimental\" in the\n // --version output, and in that case we just use the version string.\n-func (b *Builder) gccgoToolID(name, language string) (string, error) {\n+func (b *Builder) gccToolID(name, language string) (string, error) {\n \tkey := name + \".\" + language\n \tb.id.Lock()\n \tid := b.toolIDCache[key]"}, {"sha": "b0281041c9821b365198436bf4a6ea6b2854f140", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,11 +8,11 @@ package work\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/fsys\"\n \t\"context\"\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"internal/buildcfg\"\n \texec \"internal/execabs\"\n \t\"internal/lazyregexp\"\n \t\"io\"\n@@ -31,6 +31,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/str\"\n@@ -245,17 +246,37 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \tif p.Internal.ForceLibrary {\n \t\tfmt.Fprintf(h, \"forcelibrary\\n\")\n \t}\n-\tif len(p.CgoFiles)+len(p.SwigFiles) > 0 {\n+\tif len(p.CgoFiles)+len(p.SwigFiles)+len(p.SwigCXXFiles) > 0 {\n \t\tfmt.Fprintf(h, \"cgo %q\\n\", b.toolID(\"cgo\"))\n \t\tcppflags, cflags, cxxflags, fflags, ldflags, _ := b.CFlags(p)\n-\t\tfmt.Fprintf(h, \"CC=%q %q %q %q\\n\", b.ccExe(), cppflags, cflags, ldflags)\n-\t\tif len(p.CXXFiles)+len(p.SwigFiles) > 0 {\n-\t\t\tfmt.Fprintf(h, \"CXX=%q %q\\n\", b.cxxExe(), cxxflags)\n+\n+\t\tccExe := b.ccExe()\n+\t\tfmt.Fprintf(h, \"CC=%q %q %q %q\\n\", ccExe, cppflags, cflags, ldflags)\n+\t\t// Include the C compiler tool ID so that if the C\n+\t\t// compiler changes we rebuild the package.\n+\t\t// But don't do that for standard library packages like net,\n+\t\t// so that the prebuilt .a files from a Go binary install\n+\t\t// don't need to be rebuilt with the local compiler.\n+\t\tif !p.Standard {\n+\t\t\tif ccID, err := b.gccToolID(ccExe[0], \"c\"); err == nil {\n+\t\t\t\tfmt.Fprintf(h, \"CC ID=%q\\n\", ccID)\n+\t\t\t}\n+\t\t}\n+\t\tif len(p.CXXFiles)+len(p.SwigCXXFiles) > 0 {\n+\t\t\tcxxExe := b.cxxExe()\n+\t\t\tfmt.Fprintf(h, \"CXX=%q %q\\n\", cxxExe, cxxflags)\n+\t\t\tif cxxID, err := b.gccToolID(cxxExe[0], \"c++\"); err == nil {\n+\t\t\t\tfmt.Fprintf(h, \"CXX ID=%q\\n\", cxxID)\n+\t\t\t}\n \t\t}\n \t\tif len(p.FFiles) > 0 {\n-\t\t\tfmt.Fprintf(h, \"FC=%q %q\\n\", b.fcExe(), fflags)\n+\t\t\tfcExe := b.fcExe()\n+\t\t\tfmt.Fprintf(h, \"FC=%q %q\\n\", fcExe, fflags)\n+\t\t\tif fcID, err := b.gccToolID(fcExe[0], \"f95\"); err == nil {\n+\t\t\t\tfmt.Fprintf(h, \"FC ID=%q\\n\", fcID)\n+\t\t\t}\n \t\t}\n-\t\t// TODO(rsc): Should we include the SWIG version or Fortran/GCC/G++/Objective-C compiler versions?\n+\t\t// TODO(rsc): Should we include the SWIG version?\n \t}\n \tif p.Internal.CoverMode != \"\" {\n \t\tfmt.Fprintf(h, \"cover %q %q\\n\", p.Internal.CoverMode, b.toolID(\"cover\"))\n@@ -276,6 +297,10 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t\tkey, val := cfg.GetArchEnv()\n \t\tfmt.Fprintf(h, \"%s=%s\\n\", key, val)\n \n+\t\tif goexperiment := buildcfg.GOEXPERIMENT(); goexperiment != \"\" {\n+\t\t\tfmt.Fprintf(h, \"GOEXPERIMENT=%q\\n\", goexperiment)\n+\t\t}\n+\n \t\t// TODO(rsc): Convince compiler team not to add more magic environment variables,\n \t\t// or perhaps restrict the environment variables passed to subprocesses.\n \t\t// Because these are clumsy, undocumented special-case hacks\n@@ -284,7 +309,7 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t\tmagic := []string{\n \t\t\t\"GOCLOBBERDEADHASH\",\n \t\t\t\"GOSSAFUNC\",\n-\t\t\t\"GO_SSA_PHI_LOC_CUTOFF\",\n+\t\t\t\"GOSSADIR\",\n \t\t\t\"GOSSAHASH\",\n \t\t}\n \t\tfor _, env := range magic {\n@@ -311,15 +336,15 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t\t}\n \n \tcase \"gccgo\":\n-\t\tid, err := b.gccgoToolID(BuildToolchain.compiler(), \"go\")\n+\t\tid, err := b.gccToolID(BuildToolchain.compiler(), \"go\")\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"%v\", err)\n \t\t}\n \t\tfmt.Fprintf(h, \"compile %s %q %q\\n\", id, forcedGccgoflags, p.Internal.Gccgoflags)\n \t\tfmt.Fprintf(h, \"pkgpath %s\\n\", gccgoPkgpath(p))\n \t\tfmt.Fprintf(h, \"ar %q\\n\", BuildToolchain.(gccgoToolchain).ar())\n \t\tif len(p.SFiles) > 0 {\n-\t\t\tid, _ = b.gccgoToolID(BuildToolchain.compiler(), \"assembler-with-cpp\")\n+\t\t\tid, _ = b.gccToolID(BuildToolchain.compiler(), \"assembler-with-cpp\")\n \t\t\t// Ignore error; different assembler versions\n \t\t\t// are unlikely to make any difference anyhow.\n \t\t\tfmt.Fprintf(h, \"asm %q\\n\", id)\n@@ -649,6 +674,10 @@ OverlayLoop:\n \t\t}\n \n \t\toutGo, outObj, err := b.cgo(a, base.Tool(\"cgo\"), objdir, pcCFLAGS, pcLDFLAGS, mkAbsFiles(a.Package.Dir, cgofiles), gccfiles, cxxfiles, a.Package.MFiles, a.Package.FFiles)\n+\n+\t\t// The files in cxxfiles have now been handled by b.cgo.\n+\t\tcxxfiles = nil\n+\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -1248,6 +1277,10 @@ func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package) {\n \t\tkey, val := cfg.GetArchEnv()\n \t\tfmt.Fprintf(h, \"%s=%s\\n\", key, val)\n \n+\t\tif goexperiment := buildcfg.GOEXPERIMENT(); goexperiment != \"\" {\n+\t\t\tfmt.Fprintf(h, \"GOEXPERIMENT=%q\\n\", goexperiment)\n+\t\t}\n+\n \t\t// The linker writes source file paths that say GOROOT_FINAL, but\n \t\t// only if -trimpath is not specified (see ld() in gc.go).\n \t\tgorootFinal := cfg.GOROOT_FINAL\n@@ -1263,7 +1296,7 @@ func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package) {\n \t\t// Or external linker settings and flags?\n \n \tcase \"gccgo\":\n-\t\tid, err := b.gccgoToolID(BuildToolchain.linker(), \"go\")\n+\t\tid, err := b.gccToolID(BuildToolchain.linker(), \"go\")\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"%v\", err)\n \t\t}\n@@ -1843,6 +1876,7 @@ var objectMagic = [][]byte{\n \t{0xCE, 0xFA, 0xED, 0xFE},                  // Mach-O little-endian 32-bit\n \t{0xCF, 0xFA, 0xED, 0xFE},                  // Mach-O little-endian 64-bit\n \t{0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00},      // PE (Windows) as generated by 6l/8l and gcc\n+\t{0x4d, 0x5a, 0x78, 0x00, 0x01, 0x00},      // PE (Windows) as generated by llvm for dll\n \t{0x00, 0x00, 0x01, 0xEB},                  // Plan 9 i386\n \t{0x00, 0x00, 0x8a, 0x97},                  // Plan 9 amd64\n \t{0x00, 0x00, 0x06, 0x47},                  // Plan 9 arm\n@@ -2059,8 +2093,11 @@ func (b *Builder) runOut(a *Action, dir string, env []string, cmdargs ...interfa\n \n \t// Add the TOOLEXEC_IMPORTPATH environment variable for -toolexec tools.\n \t// It doesn't really matter if -toolexec isn't being used.\n+\t// Note that a.Package.Desc is not really an import path,\n+\t// but this is consistent with 'go list -f {{.ImportPath}}'.\n+\t// Plus, it is useful to uniquely identify packages in 'go list -json'.\n \tif a != nil && a.Package != nil {\n-\t\tcmd.Env = append(cmd.Env, \"TOOLEXEC_IMPORTPATH=\"+a.Package.ImportPath)\n+\t\tcmd.Env = append(cmd.Env, \"TOOLEXEC_IMPORTPATH=\"+a.Package.Desc())\n \t}\n \n \tcmd.Env = append(cmd.Env, env...)\n@@ -2349,7 +2386,7 @@ func (b *Builder) gccld(a *Action, p *load.Package, objdir, outfile string, flag\n \n \tcmdargs := []interface{}{cmd, \"-o\", outfile, objs, flags}\n \tdir := p.Dir\n-\tout, err := b.runOut(a, base.Cwd, b.cCompilerEnv(), cmdargs...)\n+\tout, err := b.runOut(a, base.Cwd(), b.cCompilerEnv(), cmdargs...)\n \n \tif len(out) > 0 {\n \t\t// Filter out useless linker warnings caused by bugs outside Go.\n@@ -2606,9 +2643,19 @@ func (b *Builder) gccArchArgs() []string {\n \tcase \"s390x\":\n \t\treturn []string{\"-m64\", \"-march=z196\"}\n \tcase \"mips64\", \"mips64le\":\n-\t\treturn []string{\"-mabi=64\"}\n+\t\targs := []string{\"-mabi=64\"}\n+\t\tif cfg.GOMIPS64 == \"hardfloat\" {\n+\t\t\treturn append(args, \"-mhard-float\")\n+\t\t} else if cfg.GOMIPS64 == \"softfloat\" {\n+\t\t\treturn append(args, \"-msoft-float\")\n+\t\t}\n \tcase \"mips\", \"mipsle\":\n-\t\treturn []string{\"-mabi=32\", \"-march=mips32\"}\n+\t\targs := []string{\"-mabi=32\", \"-march=mips32\"}\n+\t\tif cfg.GOMIPS == \"hardfloat\" {\n+\t\t\treturn append(args, \"-mhard-float\", \"-mfp32\", \"-mno-odd-spreg\")\n+\t\t} else if cfg.GOMIPS == \"softfloat\" {\n+\t\t\treturn append(args, \"-msoft-float\")\n+\t\t}\n \tcase \"ppc64\":\n \t\tif cfg.Goos == \"aix\" {\n \t\t\treturn []string{\"-maix64\"}\n@@ -2963,7 +3010,7 @@ func (b *Builder) dynimport(a *Action, p *load.Package, objdir, importGo, cgoExe\n \tif p.Standard && p.ImportPath == \"runtime/cgo\" {\n \t\tcgoflags = []string{\"-dynlinker\"} // record path to dynamic linker\n \t}\n-\treturn b.run(a, base.Cwd, p.ImportPath, b.cCompilerEnv(), cfg.BuildToolexec, cgoExe, \"-dynpackage\", p.Name, \"-dynimport\", dynobj, \"-dynout\", importGo, cgoflags)\n+\treturn b.run(a, base.Cwd(), p.ImportPath, b.cCompilerEnv(), cfg.BuildToolexec, cgoExe, \"-dynpackage\", p.Name, \"-dynimport\", dynobj, \"-dynout\", importGo, cgoflags)\n }\n \n // Run SWIG on all SWIG input files.\n@@ -3097,7 +3144,7 @@ func (b *Builder) swigDoIntSize(objdir string) (intsize string, err error) {\n \t}\n \tsrcs := []string{src}\n \n-\tp := load.GoFilesPackage(context.TODO(), srcs)\n+\tp := load.GoFilesPackage(context.TODO(), load.PackageOpts{}, srcs)\n \n \tif _, _, e := BuildToolchain.gc(b, &Action{Mode: \"swigDoIntSize\", Package: p, Objdir: objdir}, \"\", nil, nil, \"\", false, srcs); e != nil {\n \t\treturn \"32\", nil"}, {"sha": "85da4f89f991f48e4ad9a3aad4b145f622363cb1", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n+\t\"internal/buildcfg\"\n \t\"io\"\n \t\"log\"\n \t\"os\"\n@@ -63,15 +64,33 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \n \tpkgpath := pkgPath(a)\n \tgcargs := []string{\"-p\", pkgpath}\n-\tif p.Module != nil && p.Module.GoVersion != \"\" && allowedVersion(p.Module.GoVersion) {\n-\t\tgcargs = append(gcargs, \"-lang=go\"+p.Module.GoVersion)\n+\tif p.Module != nil {\n+\t\tv := p.Module.GoVersion\n+\t\tif v == \"\" {\n+\t\t\t// We started adding a 'go' directive to the go.mod file unconditionally\n+\t\t\t// as of Go 1.12, so any module that still lacks such a directive must\n+\t\t\t// either have been authored before then, or have a hand-edited go.mod\n+\t\t\t// file that hasn't been updated by cmd/go since that edit.\n+\t\t\t//\n+\t\t\t// Unfortunately, through at least Go 1.16 we didn't add versions to\n+\t\t\t// vendor/modules.txt. So this could also be a vendored 1.16 dependency.\n+\t\t\t//\n+\t\t\t// Fortunately, there were no breaking changes to the language between Go\n+\t\t\t// 1.11 and 1.16, so if we assume Go 1.16 semantics we will not introduce\n+\t\t\t// any spurious errors \u2014 we will only mask errors, and not particularly\n+\t\t\t// important ones at that.\n+\t\t\tv = \"1.16\"\n+\t\t}\n+\t\tif allowedVersion(v) {\n+\t\t\tgcargs = append(gcargs, \"-lang=go\"+v)\n+\t\t}\n \t}\n \tif p.Standard {\n \t\tgcargs = append(gcargs, \"-std\")\n \t}\n \tcompilingRuntime := p.Standard && (p.ImportPath == \"runtime\" || strings.HasPrefix(p.ImportPath, \"runtime/internal\"))\n \t// The runtime package imports a couple of general internal packages.\n-\tif p.Standard && (p.ImportPath == \"internal/cpu\" || p.ImportPath == \"internal/bytealg\") {\n+\tif p.Standard && (p.ImportPath == \"internal/cpu\" || p.ImportPath == \"internal/bytealg\" || p.ImportPath == \"internal/abi\") {\n \t\tcompilingRuntime = true\n \t}\n \tif compilingRuntime {\n@@ -129,7 +148,11 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\t}\n \t}\n \n-\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"compile\"), \"-o\", ofile, \"-trimpath\", a.trimpath(), gcflags, gcargs, \"-D\", p.Internal.LocalPrefix}\n+\targs := []interface{}{cfg.BuildToolexec, base.Tool(\"compile\"), \"-o\", ofile, \"-trimpath\", a.trimpath(), gcflags, gcargs}\n+\tif p.Internal.LocalPrefix != \"\" {\n+\t\t// Workaround #43883.\n+\t\targs = append(args, \"-D\", p.Internal.LocalPrefix)\n+\t}\n \tif importcfg != nil {\n \t\tif err := b.writeFile(objdir+\"importcfg\", importcfg); err != nil {\n \t\t\treturn \"\", nil, err\n@@ -174,7 +197,7 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg, embedcfg\n \t\targs = append(args, f)\n \t}\n \n-\toutput, err = b.runOut(a, base.Cwd, nil, args...)\n+\toutput, err = b.runOut(a, base.Cwd(), nil, args...)\n \treturn ofile, output, err\n }\n \n@@ -209,7 +232,7 @@ CheckFlags:\n \t}\n \n \t// TODO: Test and delete these conditions.\n-\tif objabi.Fieldtrack_enabled != 0 || objabi.Preemptibleloops_enabled != 0 {\n+\tif buildcfg.Experiment.FieldTrack || buildcfg.Experiment.PreemptibleLoops {\n \t\tcanDashC = false\n \t}\n \n@@ -235,16 +258,19 @@ CheckFlags:\n \t//   - it has no successor packages to compile (usually package main)\n \t//   - all paths through the build graph pass through it\n \t//   - critical path scheduling says it is high priority\n-\t// and in such a case, set c to runtime.NumCPU.\n+\t// and in such a case, set c to runtime.GOMAXPROCS(0).\n+\t// By default this is the same as runtime.NumCPU.\n \t// We do this now when p==1.\n+\t// To limit parallelism, set GOMAXPROCS below numCPU; this may be useful\n+\t// on a low-memory builder, or if a deterministic build order is required.\n+\tc := runtime.GOMAXPROCS(0)\n \tif cfg.BuildP == 1 {\n-\t\t// No process parallelism. Max out c.\n-\t\treturn runtime.NumCPU()\n+\t\t// No process parallelism, do not cap compiler parallelism.\n+\t\treturn c\n \t}\n-\t// Some process parallelism. Set c to min(4, numcpu).\n-\tc := 4\n-\tif ncpu := runtime.NumCPU(); ncpu < c {\n-\t\tc = ncpu\n+\t// Some process parallelism. Set c to min(4, maxprocs).\n+\tif c > 4 {\n+\t\tc = 4\n \t}\n \treturn c\n }\n@@ -265,10 +291,11 @@ func (a *Action) trimpath() string {\n \n \trewriteDir := a.Package.Dir\n \tif cfg.BuildTrimpath {\n+\t\timportPath := a.Package.Internal.OrigImportPath\n \t\tif m := a.Package.Module; m != nil && m.Version != \"\" {\n-\t\t\trewriteDir = m.Path + \"@\" + m.Version + strings.TrimPrefix(a.Package.ImportPath, m.Path)\n+\t\t\trewriteDir = m.Path + \"@\" + m.Version + strings.TrimPrefix(importPath, m.Path)\n \t\t} else {\n-\t\t\trewriteDir = a.Package.ImportPath\n+\t\t\trewriteDir = importPath\n \t\t}\n \t\trewrite += a.Package.Dir + \"=>\" + rewriteDir + \";\"\n \t}\n@@ -336,18 +363,6 @@ func asmArgs(a *Action, p *load.Package) []interface{} {\n \t}\n \tif objabi.IsRuntimePackagePath(pkgpath) {\n \t\targs = append(args, \"-compiling-runtime\")\n-\t\tif objabi.Regabi_enabled != 0 {\n-\t\t\t// In order to make it easier to port runtime assembly\n-\t\t\t// to the register ABI, we introduce a macro\n-\t\t\t// indicating the experiment is enabled.\n-\t\t\t//\n-\t\t\t// Note: a similar change also appears in\n-\t\t\t// cmd/dist/build.go.\n-\t\t\t//\n-\t\t\t// TODO(austin): Remove this once we commit to the\n-\t\t\t// register ABI (#40724).\n-\t\t\targs = append(args, \"-D=GOEXPERIMENT_REGABI=1\")\n-\t\t}\n \t}\n \n \tif cfg.Goarch == \"mips\" || cfg.Goarch == \"mipsle\" {"}, {"sha": "1e8250002eec1261f91350929bbab7351fd24988", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -102,7 +102,7 @@ func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg,\n \n \tif b.gccSupportsFlag(args[:1], \"-ffile-prefix-map=a=b\") {\n \t\tif cfg.BuildTrimpath {\n-\t\t\targs = append(args, \"-ffile-prefix-map=\"+base.Cwd+\"=.\")\n+\t\t\targs = append(args, \"-ffile-prefix-map=\"+base.Cwd()+\"=.\")\n \t\t\targs = append(args, \"-ffile-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")\n \t\t}\n \t\tif fsys.OverlayFile != \"\" {\n@@ -114,9 +114,9 @@ func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg,\n \t\t\t\t}\n \t\t\t\ttoPath := absPath\n \t\t\t\t// gccgo only applies the last matching rule, so also handle the case where\n-\t\t\t\t// BuildTrimpath is true and the path is relative to base.Cwd.\n-\t\t\t\tif cfg.BuildTrimpath && str.HasFilePathPrefix(toPath, base.Cwd) {\n-\t\t\t\t\ttoPath = \".\" + toPath[len(base.Cwd):]\n+\t\t\t\t// BuildTrimpath is true and the path is relative to base.Cwd().\n+\t\t\t\tif cfg.BuildTrimpath && str.HasFilePathPrefix(toPath, base.Cwd()) {\n+\t\t\t\t\ttoPath = \".\" + toPath[len(base.Cwd()):]\n \t\t\t\t}\n \t\t\t\targs = append(args, \"-ffile-prefix-map=\"+overlayPath+\"=\"+toPath)\n \t\t\t}\n@@ -597,7 +597,7 @@ func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile, cfile string) error\n \t}\n \tdefs = tools.maybePIC(defs)\n \tif b.gccSupportsFlag(compiler, \"-ffile-prefix-map=a=b\") {\n-\t\tdefs = append(defs, \"-ffile-prefix-map=\"+base.Cwd+\"=.\")\n+\t\tdefs = append(defs, \"-ffile-prefix-map=\"+base.Cwd()+\"=.\")\n \t\tdefs = append(defs, \"-ffile-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")\n \t} else if b.gccSupportsFlag(compiler, \"-fdebug-prefix-map=a=b\") {\n \t\tdefs = append(defs, \"-fdebug-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")"}, {"sha": "37a3e2d0ffd1232368863992603432fbd783e828", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -11,21 +11,19 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/fsys\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/internal/objabi\"\n \t\"cmd/internal/sys\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"strings\"\n )\n \n func BuildInit() {\n \tmodload.Init()\n \tinstrumentInit()\n \tbuildModeInit()\n-\tif err := fsys.Init(base.Cwd); err != nil {\n+\tif err := fsys.Init(base.Cwd()); err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n@@ -47,20 +45,6 @@ func BuildInit() {\n \t\t\tbase.Fatalf(\"go %s: %s environment variable is relative; must be absolute path: %s\\n\", flag.Args()[0], key, path)\n \t\t}\n \t}\n-\n-\t// For each experiment that has been enabled in the toolchain, define a\n-\t// build tag with the same name but prefixed by \"goexperiment.\" which can be\n-\t// used for compiling alternative files for the experiment. This allows\n-\t// changes for the experiment, like extra struct fields in the runtime,\n-\t// without affecting the base non-experiment code at all. [2:] strips the\n-\t// leading \"X:\" from objabi.Expstring().\n-\texp := objabi.Expstring()[2:]\n-\tif exp != \"none\" {\n-\t\texperiments := strings.Split(exp, \",\")\n-\t\tfor _, expt := range experiments {\n-\t\t\tcfg.BuildContext.BuildTags = append(cfg.BuildContext.BuildTags, \"goexperiment.\"+expt)\n-\t\t}\n-\t}\n }\n \n func instrumentInit() {"}, {"sha": "e9b9f6c6c0f24417652309b4d2b13b098677db73", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -208,8 +208,8 @@ var validLinkerFlags = []*lazyregexp.Regexp{\n \tre(`-Wl,-z,(no)?execstack`),\n \tre(`-Wl,-z,relro`),\n \n-\tre(`[a-zA-Z0-9_/].*\\.(a|o|obj|dll|dylib|so)`), // direct linker inputs: x.o or libfoo.so (but not -foo.o or @foo.o)\n-\tre(`\\./.*\\.(a|o|obj|dll|dylib|so)`),\n+\tre(`[a-zA-Z0-9_/].*\\.(a|o|obj|dll|dylib|so|tbd)`), // direct linker inputs: x.o or libfoo.so (but not -foo.o or @foo.o)\n+\tre(`\\./.*\\.(a|o|obj|dll|dylib|so|tbd)`),\n }\n \n var validLinkerFlagsWithNextArg = []string{"}, {"sha": "8d4be0abfc09e6c21c9a51ea6a32696c4fa6e259", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -164,6 +164,8 @@ var goodLinkerFlags = [][]string{\n \t{\"-Wl,-framework\", \"-Wl,Chocolate\"},\n \t{\"-Wl,-framework,Chocolate\"},\n \t{\"-Wl,-unresolved-symbols=ignore-all\"},\n+\t{\"libcgotbdtest.tbd\"},\n+\t{\"./libcgotbdtest.tbd\"},\n }\n \n var badLinkerFlags = [][]string{"}, {"sha": "8b77871b23f26922b4612c9017522710f1511af5", "filename": "libgo/go/cmd/go/internal/work/testgo.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -4,6 +4,7 @@\n \n // This file contains extra hooks for testing the go command.\n \n+//go:build testgo\n // +build testgo\n \n package work"}, {"sha": "a3251723c55d635e8060c2d399020ad3a15a027d", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"context\"\n \t\"flag\"\n \t\"fmt\"\n+\t\"internal/buildcfg\"\n \t\"log\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -147,19 +148,6 @@ func main() {\n \t\tos.Exit(2)\n \t}\n \n-\t// Set environment (GOOS, GOARCH, etc) explicitly.\n-\t// In theory all the commands we invoke should have\n-\t// the same default computation of these as we do,\n-\t// but in practice there might be skew\n-\t// This makes sure we all agree.\n-\tcfg.OrigEnv = os.Environ()\n-\tcfg.CmdEnv = envcmd.MkEnv()\n-\tfor _, env := range cfg.CmdEnv {\n-\t\tif os.Getenv(env.Name) != env.Value {\n-\t\t\tos.Setenv(env.Name, env.Value)\n-\t\t}\n-\t}\n-\n BigCmdLoop:\n \tfor bigCmd := base.Go; ; {\n \t\tfor _, cmd := range bigCmd.Commands {\n@@ -185,18 +173,7 @@ BigCmdLoop:\n \t\t\tif !cmd.Runnable() {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tcmd.Flag.Usage = func() { cmd.Usage() }\n-\t\t\tif cmd.CustomFlags {\n-\t\t\t\targs = args[1:]\n-\t\t\t} else {\n-\t\t\t\tbase.SetFromGOFLAGS(&cmd.Flag)\n-\t\t\t\tcmd.Flag.Parse(args[1:])\n-\t\t\t\targs = cmd.Flag.Args()\n-\t\t\t}\n-\t\t\tctx := maybeStartTrace(context.Background())\n-\t\t\tctx, span := trace.StartSpan(ctx, fmt.Sprint(\"Running \", cmd.Name(), \" command\"))\n-\t\t\tcmd.Run(ctx, cmd, args)\n-\t\t\tspan.Done()\n+\t\t\tinvoke(cmd, args)\n \t\t\tbase.Exit()\n \t\t\treturn\n \t\t}\n@@ -210,6 +187,39 @@ BigCmdLoop:\n \t}\n }\n \n+func invoke(cmd *base.Command, args []string) {\n+\t// 'go env' handles checking the build config\n+\tif cmd != envcmd.CmdEnv {\n+\t\tbuildcfg.Check()\n+\t}\n+\n+\t// Set environment (GOOS, GOARCH, etc) explicitly.\n+\t// In theory all the commands we invoke should have\n+\t// the same default computation of these as we do,\n+\t// but in practice there might be skew\n+\t// This makes sure we all agree.\n+\tcfg.OrigEnv = os.Environ()\n+\tcfg.CmdEnv = envcmd.MkEnv()\n+\tfor _, env := range cfg.CmdEnv {\n+\t\tif os.Getenv(env.Name) != env.Value {\n+\t\t\tos.Setenv(env.Name, env.Value)\n+\t\t}\n+\t}\n+\n+\tcmd.Flag.Usage = func() { cmd.Usage() }\n+\tif cmd.CustomFlags {\n+\t\targs = args[1:]\n+\t} else {\n+\t\tbase.SetFromGOFLAGS(&cmd.Flag)\n+\t\tcmd.Flag.Parse(args[1:])\n+\t\targs = cmd.Flag.Args()\n+\t}\n+\tctx := maybeStartTrace(context.Background())\n+\tctx, span := trace.StartSpan(ctx, fmt.Sprint(\"Running \", cmd.Name(), \" command\"))\n+\tcmd.Run(ctx, cmd, args)\n+\tspan.Done()\n+}\n+\n func init() {\n \tbase.Usage = mainUsage\n }"}, {"sha": "a2b0aca3c9da65b1c588b5e875bf61e799e289f6", "filename": "libgo/go/cmd/go/mkalldocs.sh", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fmkalldocs.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fmkalldocs.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmkalldocs.sh?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -1,11 +1,13 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n # Copyright 2012 The Go Authors. All rights reserved.\n # Use of this source code is governed by a BSD-style\n # license that can be found in the LICENSE file.\n \n set -e\n \n go build -o go.latest\n-./go.latest help documentation >alldocs.go\n+# If the command used to generate alldocs.go changes, update TestDocsUpToDate in\n+# help_test.go.\n+GO111MODULE='' ./go.latest help documentation >alldocs.go\n gofmt -w alldocs.go\n rm go.latest"}, {"sha": "74bfecc08dbc6de1ca9768c536113eb878d7f3da", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -23,7 +23,6 @@ import (\n \t\"sync\"\n \t\"testing\"\n \n-\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/txtar\"\n@@ -229,7 +228,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tif m.Path != modPath {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif modfetch.IsPseudoVersion(m.Version) && (latestPseudo == \"\" || semver.Compare(latestPseudo, m.Version) > 0) {\n+\t\t\tif module.IsPseudoVersion(m.Version) && (latestPseudo == \"\" || semver.Compare(latestPseudo, m.Version) > 0) {\n \t\t\t\tlatestPseudo = m.Version\n \t\t\t} else if semver.Prerelease(m.Version) != \"\" && (latestPrerelease == \"\" || semver.Compare(latestPrerelease, m.Version) > 0) {\n \t\t\t\tlatestPrerelease = m.Version\n@@ -282,7 +281,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tfound = true\n-\t\t\tif !modfetch.IsPseudoVersion(m.Version) {\n+\t\t\tif !module.IsPseudoVersion(m.Version) {\n \t\t\t\tif err := module.Check(m.Path, m.Version); err == nil {\n \t\t\t\t\tfmt.Fprintf(w, \"%s\\n\", m.Version)\n \t\t\t\t}\n@@ -315,7 +314,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\tfor _, m := range modList {\n \t\t\tif m.Path == path && semver.Compare(best, m.Version) < 0 {\n \t\t\t\tvar hash string\n-\t\t\t\tif modfetch.IsPseudoVersion(m.Version) {\n+\t\t\t\tif module.IsPseudoVersion(m.Version) {\n \t\t\t\t\thash = m.Version[strings.LastIndex(m.Version, \"-\")+1:]\n \t\t\t\t} else {\n \t\t\t\t\thash = findHash(m)\n@@ -362,7 +361,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\tvar buf bytes.Buffer\n \t\t\tz := zip.NewWriter(&buf)\n \t\t\tfor _, f := range a.Files {\n-\t\t\t\tif strings.HasPrefix(f.Name, \".\") {\n+\t\t\t\tif f.Name == \".info\" || f.Name == \".mod\" || f.Name == \".zip\" {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tvar zipName string"}, {"sha": "639e907db075159dd5aba227d38e7ec9261127bf", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -32,7 +32,6 @@ import (\n \t\"cmd/go/internal/robustio\"\n \t\"cmd/go/internal/txtar\"\n \t\"cmd/go/internal/work\"\n-\t\"cmd/internal/objabi\"\n \t\"cmd/internal/sys\"\n )\n \n@@ -41,6 +40,33 @@ func TestScript(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \ttestenv.SkipIfShortAndSlow(t)\n \n+\tvar (\n+\t\tctx         = context.Background()\n+\t\tgracePeriod = 100 * time.Millisecond\n+\t)\n+\tif deadline, ok := t.Deadline(); ok {\n+\t\ttimeout := time.Until(deadline)\n+\n+\t\t// If time allows, increase the termination grace period to 5% of the\n+\t\t// remaining time.\n+\t\tif gp := timeout / 20; gp > gracePeriod {\n+\t\t\tgracePeriod = gp\n+\t\t}\n+\n+\t\t// When we run commands that execute subprocesses, we want to reserve two\n+\t\t// grace periods to clean up. We will send the first termination signal when\n+\t\t// the context expires, then wait one grace period for the process to\n+\t\t// produce whatever useful output it can (such as a stack trace). After the\n+\t\t// first grace period expires, we'll escalate to os.Kill, leaving the second\n+\t\t// grace period for the test function to record its output before the test\n+\t\t// process itself terminates.\n+\t\ttimeout -= 2 * gracePeriod\n+\n+\t\tvar cancel context.CancelFunc\n+\t\tctx, cancel = context.WithTimeout(ctx, timeout)\n+\t\tt.Cleanup(cancel)\n+\t}\n+\n \tfiles, err := filepath.Glob(\"testdata/script/*.txt\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -50,40 +76,51 @@ func TestScript(t *testing.T) {\n \t\tname := strings.TrimSuffix(filepath.Base(file), \".txt\")\n \t\tt.Run(name, func(t *testing.T) {\n \t\t\tt.Parallel()\n-\t\t\tts := &testScript{t: t, name: name, file: file}\n+\t\t\tctx, cancel := context.WithCancel(ctx)\n+\t\t\tts := &testScript{\n+\t\t\t\tt:           t,\n+\t\t\t\tctx:         ctx,\n+\t\t\t\tcancel:      cancel,\n+\t\t\t\tgracePeriod: gracePeriod,\n+\t\t\t\tname:        name,\n+\t\t\t\tfile:        file,\n+\t\t\t}\n \t\t\tts.setup()\n \t\t\tif !*testWork {\n \t\t\t\tdefer removeAll(ts.workdir)\n \t\t\t}\n \t\t\tts.run()\n+\t\t\tcancel()\n \t\t})\n \t}\n }\n \n // A testScript holds execution state for a single test script.\n type testScript struct {\n-\tt          *testing.T\n-\tworkdir    string            // temporary work dir ($WORK)\n-\tlog        bytes.Buffer      // test execution log (printed at end of test)\n-\tmark       int               // offset of next log truncation\n-\tcd         string            // current directory during test execution; initially $WORK/gopath/src\n-\tname       string            // short name of test (\"foo\")\n-\tfile       string            // full file name (\"testdata/script/foo.txt\")\n-\tlineno     int               // line number currently executing\n-\tline       string            // line currently executing\n-\tenv        []string          // environment list (for os/exec)\n-\tenvMap     map[string]string // environment mapping (matches env)\n-\tstdout     string            // standard output from last 'go' command; for 'stdout' command\n-\tstderr     string            // standard error from last 'go' command; for 'stderr' command\n-\tstopped    bool              // test wants to stop early\n-\tstart      time.Time         // time phase started\n-\tbackground []*backgroundCmd  // backgrounded 'exec' and 'go' commands\n+\tt           *testing.T\n+\tctx         context.Context\n+\tcancel      context.CancelFunc\n+\tgracePeriod time.Duration\n+\tworkdir     string            // temporary work dir ($WORK)\n+\tlog         bytes.Buffer      // test execution log (printed at end of test)\n+\tmark        int               // offset of next log truncation\n+\tcd          string            // current directory during test execution; initially $WORK/gopath/src\n+\tname        string            // short name of test (\"foo\")\n+\tfile        string            // full file name (\"testdata/script/foo.txt\")\n+\tlineno      int               // line number currently executing\n+\tline        string            // line currently executing\n+\tenv         []string          // environment list (for os/exec)\n+\tenvMap      map[string]string // environment mapping (matches env)\n+\tstdout      string            // standard output from last 'go' command; for 'stdout' command\n+\tstderr      string            // standard error from last 'go' command; for 'stderr' command\n+\tstopped     bool              // test wants to stop early\n+\tstart       time.Time         // time phase started\n+\tbackground  []*backgroundCmd  // backgrounded 'exec' and 'go' commands\n }\n \n type backgroundCmd struct {\n \twant           simpleStatus\n \targs           []string\n-\tcancel         context.CancelFunc\n \tdone           <-chan struct{}\n \terr            error\n \tstdout, stderr strings.Builder\n@@ -109,6 +146,10 @@ var extraEnvKeys = []string{\n \n // setup sets up the test execution temporary directory and environment.\n func (ts *testScript) setup() {\n+\tif err := ts.ctx.Err(); err != nil {\n+\t\tts.t.Fatalf(\"test interrupted during setup: %v\", err)\n+\t}\n+\n \tStartProxy()\n \tts.workdir = filepath.Join(testTmpDir, \"script-\"+ts.name)\n \tts.check(os.MkdirAll(filepath.Join(ts.workdir, \"tmp\"), 0777))\n@@ -123,13 +164,13 @@ func (ts *testScript) setup() {\n \t\t\"GOCACHE=\" + testGOCACHE,\n \t\t\"GODEBUG=\" + os.Getenv(\"GODEBUG\"),\n \t\t\"GOEXE=\" + cfg.ExeSuffix,\n-\t\t\"GOEXPSTRING=\" + objabi.Expstring()[2:],\n \t\t\"GOOS=\" + runtime.GOOS,\n \t\t\"GOPATH=\" + filepath.Join(ts.workdir, \"gopath\"),\n \t\t\"GOPROXY=\" + proxyURL,\n \t\t\"GOPRIVATE=\",\n \t\t\"GOROOT=\" + testGOROOT,\n \t\t\"GOROOT_FINAL=\" + os.Getenv(\"GOROOT_FINAL\"), // causes spurious rebuilds and breaks the \"stale\" built-in if not propagated\n+\t\t\"GOTRACEBACK=system\",\n \t\t\"TESTGO_GOROOT=\" + testGOROOT,\n \t\t\"GOSUMDB=\" + testSumDBVerifierKey,\n \t\t\"GONOPROXY=\",\n@@ -200,9 +241,7 @@ func (ts *testScript) run() {\n \t\t// On a normal exit from the test loop, background processes are cleaned up\n \t\t// before we print PASS. If we return early (e.g., due to a test failure),\n \t\t// don't print anything about the processes that were still running.\n-\t\tfor _, bg := range ts.background {\n-\t\t\tbg.cancel()\n-\t\t}\n+\t\tts.cancel()\n \t\tfor _, bg := range ts.background {\n \t\t\t<-bg.done\n \t\t}\n@@ -275,6 +314,10 @@ Script:\n \t\tfmt.Fprintf(&ts.log, \"> %s\\n\", line)\n \n \t\tfor _, cond := range parsed.conds {\n+\t\t\tif err := ts.ctx.Err(); err != nil {\n+\t\t\t\tts.fatalf(\"test interrupted: %v\", err)\n+\t\t\t}\n+\n \t\t\t// Known conds are: $GOOS, $GOARCH, runtime.Compiler, and 'short' (for testing.Short).\n \t\t\t//\n \t\t\t// NOTE: If you make changes here, update testdata/script/README too!\n@@ -356,9 +399,7 @@ Script:\n \t\t}\n \t}\n \n-\tfor _, bg := range ts.background {\n-\t\tbg.cancel()\n-\t}\n+\tts.cancel()\n \tts.cmdWait(success, nil)\n \n \t// Final phase ended.\n@@ -476,7 +517,7 @@ func (ts *testScript) cmdCd(want simpleStatus, args []string) {\n \t\tts.fatalf(\"usage: cd dir\")\n \t}\n \n-\tdir := args[0]\n+\tdir := filepath.FromSlash(args[0])\n \tif !filepath.IsAbs(dir) {\n \t\tdir = filepath.Join(ts.cd, dir)\n \t}\n@@ -798,9 +839,7 @@ func (ts *testScript) cmdSkip(want simpleStatus, args []string) {\n \n \t// Before we mark the test as skipped, shut down any background processes and\n \t// make sure they have returned the correct status.\n-\tfor _, bg := range ts.background {\n-\t\tbg.cancel()\n-\t}\n+\tts.cancel()\n \tts.cmdWait(success, nil)\n \n \tif len(args) == 1 {\n@@ -1065,38 +1104,9 @@ func (ts *testScript) exec(command string, args ...string) (stdout, stderr strin\n func (ts *testScript) startBackground(want simpleStatus, command string, args ...string) (*backgroundCmd, error) {\n \tdone := make(chan struct{})\n \tbg := &backgroundCmd{\n-\t\twant:   want,\n-\t\targs:   append([]string{command}, args...),\n-\t\tdone:   done,\n-\t\tcancel: func() {},\n-\t}\n-\n-\tctx := context.Background()\n-\tgracePeriod := 100 * time.Millisecond\n-\tif deadline, ok := ts.t.Deadline(); ok {\n-\t\ttimeout := time.Until(deadline)\n-\t\t// If time allows, increase the termination grace period to 5% of the\n-\t\t// remaining time.\n-\t\tif gp := timeout / 20; gp > gracePeriod {\n-\t\t\tgracePeriod = gp\n-\t\t}\n-\n-\t\t// Send the first termination signal with two grace periods remaining.\n-\t\t// If it still hasn't finished after the first period has elapsed,\n-\t\t// we'll escalate to os.Kill with a second period remaining until the\n-\t\t// test deadline..\n-\t\ttimeout -= 2 * gracePeriod\n-\n-\t\tif timeout <= 0 {\n-\t\t\t// The test has less than the grace period remaining. There is no point in\n-\t\t\t// even starting the command, because it will be terminated immediately.\n-\t\t\t// Save the expense of starting it in the first place.\n-\t\t\tbg.err = context.DeadlineExceeded\n-\t\t\tclose(done)\n-\t\t\treturn bg, nil\n-\t\t}\n-\n-\t\tctx, bg.cancel = context.WithTimeout(ctx, timeout)\n+\t\twant: want,\n+\t\targs: append([]string{command}, args...),\n+\t\tdone: done,\n \t}\n \n \tcmd := exec.Command(command, args...)\n@@ -1105,29 +1115,16 @@ func (ts *testScript) startBackground(want simpleStatus, command string, args ..\n \tcmd.Stdout = &bg.stdout\n \tcmd.Stderr = &bg.stderr\n \tif err := cmd.Start(); err != nil {\n-\t\tbg.cancel()\n \t\treturn nil, err\n \t}\n \n \tgo func() {\n-\t\tbg.err = waitOrStop(ctx, cmd, stopSignal(), gracePeriod)\n+\t\tbg.err = waitOrStop(ts.ctx, cmd, quitSignal(), ts.gracePeriod)\n \t\tclose(done)\n \t}()\n \treturn bg, nil\n }\n \n-// stopSignal returns the appropriate signal to use to request that a process\n-// stop execution.\n-func stopSignal() os.Signal {\n-\tif runtime.GOOS == \"windows\" {\n-\t\t// Per https://golang.org/pkg/os/#Signal, \u201cInterrupt is not implemented on\n-\t\t// Windows; using it with os.Process.Signal will return an error.\u201d\n-\t\t// Fall back to Kill instead.\n-\t\treturn os.Kill\n-\t}\n-\treturn os.Interrupt\n-}\n-\n // waitOrStop waits for the already-started command cmd by calling its Wait method.\n //\n // If cmd does not return before ctx is done, waitOrStop sends it the given interrupt signal."}, {"sha": "e1cc6cf8ba755fffd719f14a2e0455b2ae7874e5", "filename": "libgo/go/cmd/go/stop_other_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_other_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build !(aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris)\n+// +build !aix\n+// +build !darwin\n+// +build !dragonfly\n+// +build !freebsd\n+// +build !js !wasm\n+// +build !linux\n+// +build !netbsd\n+// +build !openbsd\n+// +build !solaris\n+\n+package main_test\n+\n+import (\n+\t\"os\"\n+\t\"runtime\"\n+)\n+\n+// quitSignal returns the appropriate signal to use to request that a process\n+// quit execution.\n+func quitSignal() os.Signal {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Per https://golang.org/pkg/os/#Signal, \u201cInterrupt is not implemented on\n+\t\t// Windows; using it with os.Process.Signal will return an error.\u201d\n+\t\t// Fall back to Kill instead.\n+\t\treturn os.Kill\n+\t}\n+\treturn os.Interrupt\n+}"}, {"sha": "ac35b240f0ad9727845fed622a5112f704b95909", "filename": "libgo/go/cmd/go/stop_unix_test.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fstop_unix_test.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris\n+// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris\n+\n+package main_test\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func quitSignal() os.Signal {\n+\treturn syscall.SIGQUIT\n+}"}, {"sha": "03869e68defe0845c5cbdef60fa08f2fd3fdf42d", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -22,10 +22,10 @@ import (\n \t\"bytes\"\n \t\"flag\"\n \t\"fmt\"\n+\texec \"internal/execabs\"\n \t\"io/fs\"\n \t\"log\"\n \t\"os\"\n-\texec \"internal/execabs\"\n \t\"path/filepath\"\n \t\"strings\"\n "}, {"sha": "a86951981e2596a9a088018d0936e2d6f08ee7a1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_ambiguous_a_b_v0.0.0-empty.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_b_v0.0.0-empty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_b_v0.0.0-empty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_b_v0.0.0-empty.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,12 @@\n+Module example.com/ambiguous/a/b is a suffix of example.com/a.\n+This version contains no package.\n+-- .mod --\n+module example.com/ambiguous/a/b\n+\n+go 1.16\n+-- .info --\n+{\"Version\":\"v0.0.0-empty\"}\n+-- go.mod --\n+module example.com/ambiguous/a/b\n+\n+go 1.16"}, {"sha": "bb438262e134bf3d34b3d0af92193fc8966ac2a5", "filename": "libgo/go/cmd/go/testdata/mod/example.com_ambiguous_a_v1.0.0.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_ambiguous_a_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,18 @@\n+Module example.com/ambiguous/a is a prefix of example.com/a/b.\n+It contains package example.com/a/b.\n+-- .mod --\n+module example.com/ambiguous/a\n+\n+go 1.16\n+\n+require example.com/ambiguous/a/b v0.0.0-empty\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- go.mod --\n+module example.com/ambiguous/a\n+\n+go 1.16\n+\n+require example.com/ambiguous/a/b v0.0.0-empty\n+-- b/b.go --\n+package b"}, {"sha": "c883d8a7744a15626377305cfca13ccfd7fa5d98", "filename": "libgo/go/cmd/go/testdata/mod/example.com_cmd_v1.0.0-exclude.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-exclude.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-exclude.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-exclude.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,28 @@\n+example.com/cmd contains main packages.\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-exclude\"}\n+-- .mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+exclude rsc.io/quote v1.5.2\n+-- go.mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+exclude rsc.io/quote v1.5.2\n+-- a/a.go --\n+package main\n+\n+func main() {}\n+-- b/b.go --\n+package main\n+\n+func main() {}\n+-- err/err.go --\n+package err\n+\n+var X = DoesNotCompile"}, {"sha": "7670f29ffd0024ea106a0de4269ee32ee11a71c7", "filename": "libgo/go/cmd/go/testdata/mod/example.com_cmd_v1.0.0-newerself.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-newerself.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-newerself.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-newerself.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,28 @@\n+example.com/cmd contains main packages.\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-newerself\"}\n+-- .mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+require example.com/cmd v1.0.0\n+-- go.mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+require example.com/cmd v1.0.0\n+-- a/a.go --\n+package main\n+\n+func main() {}\n+-- b/b.go --\n+package main\n+\n+func main() {}\n+-- err/err.go --\n+package err\n+\n+var X = DoesNotCompile"}, {"sha": "581a496035ec9ee072ca49c929cbd0ca420c893b", "filename": "libgo/go/cmd/go/testdata/mod/example.com_cmd_v1.0.0-replace.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0-replace.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,28 @@\n+example.com/cmd contains main packages.\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-replace\"}\n+-- .mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+replace rsc.io/quote => rsc.io/quote v1.5.2\n+-- go.mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+replace rsc.io/quote => rsc.io/quote v1.5.2\n+-- a/a.go --\n+package main\n+\n+func main() {}\n+-- b/b.go --\n+package main\n+\n+func main() {}\n+-- err/err.go --\n+package err\n+\n+var X = DoesNotCompile"}, {"sha": "c1981391a13c74a57b1a326f4cd915b236594208", "filename": "libgo/go/cmd/go/testdata/mod/example.com_cmd_v1.0.0.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,31 @@\n+example.com/cmd contains main packages.\n+\n+v1.0.0 is the latest non-retracted version. Other versions contain errors or\n+detectable problems.\n+\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+module example.com/cmd\n+\n+go 1.16\n+-- go.mod --\n+module example.com/cmd\n+\n+go 1.16\n+-- a/a.go --\n+package main\n+\n+import \"fmt\"\n+\n+func main() { fmt.Println(\"a@v1.0.0\") }\n+-- b/b.go --\n+package main\n+\n+import \"fmt\"\n+\n+func main() { fmt.Println(\"b@v1.0.0\") }\n+-- err/err.go --\n+package err\n+\n+var X = DoesNotCompile"}, {"sha": "9298afb1fb39175e7c936a96785c04f0ebe78c93", "filename": "libgo/go/cmd/go/testdata/mod/example.com_cmd_v1.9.0.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_cmd_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,30 @@\n+example.com/cmd contains main packages.\n+\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+-- .mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+// this is a bad version\n+retract v1.9.0\n+-- go.mod --\n+module example.com/cmd\n+\n+go 1.16\n+\n+// this is a bad version\n+retract v1.9.0\n+-- a/a.go --\n+package main\n+\n+func main() {}\n+-- b/b.go --\n+package main\n+\n+func main() {}\n+-- err/err.go --\n+package err\n+\n+var X = DoesNotCompile"}, {"sha": "7c29621e83db969f78eb860c4fd5457a2f1b2223", "filename": "libgo/go/cmd/go/testdata/mod/example.com_deprecated_a_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,12 @@\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+module example.com/deprecated/a\n+\n+go 1.17\n+-- go.mod --\n+module example.com/deprecated/a\n+\n+go 1.17\n+-- a.go --\n+package a"}, {"sha": "0613389d1f3874ffe6a1bbd981f41d679ee8748a", "filename": "libgo/go/cmd/go/testdata/mod/example.com_deprecated_a_v1.9.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_a_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+-- .mod --\n+// Deprecated: in example.com/deprecated/a@v1.9.0\n+module example.com/deprecated/a\n+\n+go 1.17\n+-- go.mod --\n+// Deprecated: in example.com/deprecated/a@v1.9.0\n+module example.com/deprecated/a\n+\n+go 1.17\n+-- a.go --\n+package a"}, {"sha": "50006aefb5f3aabeddc1763a1f39f7c74b276252", "filename": "libgo/go/cmd/go/testdata/mod/example.com_deprecated_b_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,12 @@\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+module example.com/deprecated/b\n+\n+go 1.17\n+-- go.mod --\n+module example.com/deprecated/b\n+\n+go 1.17\n+-- b.go --\n+package b"}, {"sha": "163d6b543eb7a8ff08f4ad19debf24c4aea21024", "filename": "libgo/go/cmd/go/testdata/mod/example.com_deprecated_b_v1.9.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_deprecated_b_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+-- .mod --\n+// Deprecated: in example.com/deprecated/b@v1.9.0\n+module example.com/deprecated/b\n+\n+go 1.17\n+-- go.mod --\n+// Deprecated: in example.com/deprecated/b@v1.9.0\n+module example.com/deprecated/b\n+\n+go 1.17\n+-- b.go --\n+package b"}, {"sha": "2ada3a3f812af60861577b2383c619fde64c4126", "filename": "libgo/go/cmd/go/testdata/mod/example.com_dotname_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotname_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotname_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotname_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,12 @@\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+module example.com/dotname\n+\n+go 1.16\n+-- go.mod --\n+module example.com/dotname\n+\n+go 1.16\n+-- .dot/dot.go --\n+package dot"}, {"sha": "435578da8d8a5d7da42a1ad0446749e76e399ded", "filename": "libgo/go/cmd/go/testdata/mod/example.com_incompatiblewithsub_v1.0.0.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+Module example.com/incompatiblewithsub has an incompatible version\n+and a package in a subdirectory.\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+module example.com/incompatiblewithsub\n+-- sub/sub.go --\n+package sub"}, {"sha": "198ec1702bdebbcffd3b96ad34328dc40bb9e933", "filename": "libgo/go/cmd/go/testdata/mod/example.com_incompatiblewithsub_v2.0.0+incompatible.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v2.0.0%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v2.0.0%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_incompatiblewithsub_v2.0.0%2Bincompatible.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+Module example.com/incompatiblewithsub has an incompatible version\n+and a package in a subdirectory.\n+-- .info --\n+{\"Version\":\"v2.0.0+incompatible\"}\n+-- .mod --\n+module example.com/incompatiblewithsub\n+-- sub/sub.go --\n+package sub"}, {"sha": "05f7ae28a396a1174b27cb1922908f19f09ea68f", "filename": "libgo/go/cmd/go/testdata/mod/example.com_quote_v1.5.2.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_quote_v1.5.2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_quote_v1.5.2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_quote_v1.5.2.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,9 @@\n+This module is a replacement for rsc.io/quote, but its go.mod file declares\n+a module path different from its location and the original module.\n+\n+-- .mod --\n+module rsc.io/Quote\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.5.2\"}"}, {"sha": "f8e623d56f7818f68f6c65dfed6e199f1da2314e", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_ambiguous_nested_v1.9.0-bad.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_nested_v1.9.0-bad.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_nested_v1.9.0-bad.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_nested_v1.9.0-bad.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+-- .mod --\n+module example.com/retract/ambiguous/nested\n+\n+go 1.16\n+\n+retract v1.9.0-bad // nested modules are bad\n+-- .info --\n+{\"Version\":\"v1.9.0-bad\"}\n+-- nested.go --\n+package nested"}, {"sha": "5ee01391a2423eff055d8aae097cb5d03c93f115", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_ambiguous_other_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_other_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_other_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_other_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,12 @@\n+-- .mod --\n+module example.com/retract/ambiguous/other\n+\n+go 1.16\n+\n+require example.com/retract/ambiguous v1.0.0\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- other.go --\n+package other\n+\n+import _ \"example.com/retract/ambiguous/nested\""}, {"sha": "c8eeb1654f355f6d974806299ea10f47fc2e275a", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_ambiguous_v1.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_ambiguous_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,9 @@\n+-- .mod --\n+module example.com/retract/ambiguous\n+\n+go 1.16\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- nested/nested.go --\n+package nested\n+"}, {"sha": "a987685e248b7a45130289660f20e759653b7266", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_incompatible_v1.0.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+The v1.0.0 release of example.com/retract/incompatible retracts\n+v2.0.0+incompatible.\n+\n+-- .mod --\n+module example.com/retract/incompatible\n+\n+go 1.16\n+\n+retract v2.0.0+incompatible\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- go.mod --\n+module example.com/retract/incompatible\n+\n+go 1.16\n+\n+retract v2.0.0+incompatible\n+-- incompatible.go --\n+package incompatible"}, {"sha": "c668dbb7a9411c44d41a481a010601ae3ffe35b2", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_incompatible_v2.0.0+incompatible.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v2.0.0%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v2.0.0%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_incompatible_v2.0.0%2Bincompatible.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,9 @@\n+The v1.0.0 release of example.com/retract/incompatible retracts\n+v2.0.0+incompatible.\n+\n+-- .mod --\n+module example.com/retract/incompatible\n+-- .info --\n+{\"Version\":\"v2.0.0+incompatible\"}\n+-- incompatible.go --\n+package incompatible"}, {"sha": "1d8d81071ee0e2ea33867938b9663d9e7cc7978d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_missingmod_v1.0.0.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+This version should be retracted, but the go.mod file for the version that would\n+contain the retraction is not available.\n+-- .mod --\n+module example.com/retract/missingmod\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- missingmod.go --\n+package missingmod"}, {"sha": "bba919ec213e211114b8798f48968bbe7b276374", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_missingmod_v1.9.0.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_missingmod_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,4 @@\n+The go.mod file at this version will be loaded to check for retractions\n+of earlier versions. However, the .mod file is not available.\n+-- .info --\n+{\"Version\":\"v1.9.0\"}"}, {"sha": "c4a53e1d80eac4d7c505b836acdaa0c79997aa96", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-block.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-block.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-block.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-block.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-block\"}"}, {"sha": "92573b62e3679ab6d4207406d09bf58e4e195b30", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-blockwithcomment.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-blockwithcomment.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-blockwithcomment.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-blockwithcomment.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-blockwithcomment\"}"}, {"sha": "1f0894aa8bea1323ce3c4336355f0f93e0746cb0", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-empty.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-empty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-empty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-empty.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-empty\"}\n+-- empty.go --\n+package empty"}, {"sha": "1b5e7534285de0b511458f33a923acf4e408e267", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-long.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-long.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-long.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-long.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-long\"}\n+-- empty.go --\n+package empty"}, {"sha": "b1ffe27225066d9160687ab7939991b9f6970fb6", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-multiline1.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline1.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-multiline1\"}\n+-- empty.go --\n+package empty"}, {"sha": "72f80b3254106bf084ef6bbd1a0397661abcae8a", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-multiline2.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-multiline2.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-multiline2\"}\n+-- empty.go --\n+package empty"}, {"sha": "1b0450462b0c0962f048d44d5d86857b07c43336", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-order.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-order.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-order.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-order.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-order\"}"}, {"sha": "949612431e5d17b6071f3cc63afefa430792cb82", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.0-unprintable.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-unprintable.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-unprintable.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.0-unprintable.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,8 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0-unprintable\"}\n+-- empty.go --\n+package empty"}, {"sha": "3be7d5b56e4b22198954564bff39c7ef499b3a77", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.0.1-order.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.1-order.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.1-order.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.0.1-order.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.1-order\"}"}, {"sha": "6975d4ebd4dd93b13159bce97d4e539c851285fc", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rationale_v1.9.0.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rationale_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,48 @@\n+Module example.com/retract/description retracts all versions of itself.\n+The rationale comments have various problems.\n+\n+-- .mod --\n+module example.com/retract/rationale\n+\n+go 1.14\n+\n+retract (\n+\tv1.0.0-empty\n+\n+\t// short description\n+\t// more\n+\t//\n+\t// detail\n+\tv1.0.0-multiline1 // suffix\n+\t// after not included\n+)\n+\n+// short description\n+// more\n+//\n+// detail\n+retract v1.0.0-multiline2 // suffix\n+\n+// loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong\n+retract v1.0.0-long\n+\n+// Ends with a BEL character. Beep!\u0007\n+retract v1.0.0-unprintable\n+\n+// block comment\n+retract (\n+\tv1.0.0-block\n+\n+\t// inner comment\n+\tv1.0.0-blockwithcomment\n+)\n+\n+retract (\n+\t[v1.0.0-order, v1.0.0-order] // degenerate range\n+\tv1.0.0-order // single version\n+\n+\tv1.0.1-order // single version\n+\t[v1.0.1-order, v1.0.1-order] // degenerate range\n+)\n+-- .info --\n+{\"Version\":\"v1.9.0\"}"}, {"sha": "25c4ff1b1f9e2dfa4fd5f28fb2655d76899bf5d1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rename_v1.0.0-bad.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.0.0-bad.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.0.0-bad.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.0.0-bad.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,16 @@\n+Module example.com/retract/rename is renamed in a later version.\n+\n+This happens frequently when a repository is renamed or when a go.mod file\n+is added for the first time with a custom module path.\n+-- .info --\n+{\"Version\":\"v1.0.0-bad\"}\n+-- .mod --\n+module example.com/retract/rename\n+\n+go 1.16\n+-- go.mod --\n+module example.com/retract/rename\n+\n+go 1.16\n+-- rename.go --\n+package rename"}, {"sha": "9c08f713c40a6fbf88606de596248aaef57cd837", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_rename_v1.9.0-new.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.9.0-new.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.9.0-new.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_rename_v1.9.0-new.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,22 @@\n+Module example.com/retract/rename is renamed in this version.\n+\n+This happens frequently when a repository is renamed or when a go.mod file\n+is added for the first time with a custom module path.\n+-- .info --\n+{\"Version\":\"v1.9.0-new\"}\n+-- .mod --\n+module example.com/retract/newname\n+\n+go 1.16\n+\n+// bad\n+retract v1.0.0-bad\n+-- go.mod --\n+module example.com/retract/newname\n+\n+go 1.16\n+\n+// bad\n+retract v1.0.0-bad\n+-- newname.go --\n+package newname"}, {"sha": "4dc486b599801e3ef470df119c3f136ccf1d6659", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_all_v1.9.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_all_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_all_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_all_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+Module example.com/retract/self/prev is a module that retracts its own\n+latest version.\n+\n+No unretracted versions are available.\n+\n+-- .mod --\n+module example.com/retract/self/all\n+\n+go 1.15\n+\n+retract v1.9.0 // bad\n+\n+-- .info --\n+{\"Version\":\"v1.9.0\"}"}, {"sha": "04c28455d76d903fea3cf65e2bea8e9f9acfe900", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prerelease_v1.0.0.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,16 @@\n+Module example.com/retract/self/prerelease is a module that retracts its own\n+latest version and all other release version.\n+\n+A pre-release version higher than the highest release version is still\n+available, and that should be matched by @latest.\n+\n+-- .mod --\n+module example.com/retract/self/prerelease\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+\n+-- p.go --\n+package p"}, {"sha": "7c1c047e69e8b97d955c48521f1a44d7b093af9d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prerelease_v1.9.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+Module example.com/retract/self/prerelease is a module that retracts its own\n+latest version and all other release version.\n+\n+A pre-release version higher than the highest release version is still\n+available, and that should be matched by @latest.\n+\n+-- .mod --\n+module example.com/retract/self/prerelease\n+\n+go 1.15\n+\n+retract v1.0.0 // bad\n+retract v1.9.0 // self\n+\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+\n+-- p.go --\n+package p"}, {"sha": "abf44fdae14fcb41ae10bbe9e36d7ea4e8c23645", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prerelease_v1.9.1-pre.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.1-pre.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.1-pre.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prerelease_v1.9.1-pre.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,16 @@\n+Module example.com/retract/self/prerelease is a module that retracts its own\n+latest version and all other release version.\n+\n+A pre-release version higher than the highest release version is still\n+available, and that should be matched by @latest.\n+\n+-- .mod --\n+module example.com/retract/self/prerelease\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.9.1-pre\"}\n+\n+-- p.go --\n+package p"}, {"sha": "095063d69b2d6b23786f2b887a86ff8f3205d2c9", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prev_v1.0.0-bad.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.0.0-bad.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.0.0-bad.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.0.0-bad.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+See example.com_retract_self_prev_v1.9.0.txt.\n+\n+This version is retracted.\n+\n+-- .mod --\n+module example.com/retract/self/prev\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-bad\"}\n+\n+-- p.go --\n+package p"}, {"sha": "27c3a390655a213a619cb727c71470c687e5fcf7", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prev_v1.1.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+See example.com_retract_self_pref_v1.9.0.txt.\n+\n+This version is the latest (only) non-retracted version.\n+\n+-- .mod --\n+module example.com/retract/self/prev\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.1.0\"}\n+\n+-- p.go --\n+package p"}, {"sha": "03d6168f0d19d0b552c370681d742361a3b5baee", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_prev_v1.9.0.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_prev_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,18 @@\n+Module example.com/retract/self/prev is a module that retracts its own\n+latest version, as well as an earlier version.\n+\n+A previous unretracted release version, v1.1.0, is still available.\n+\n+-- .mod --\n+module example.com/retract/self/prev\n+\n+go 1.15\n+\n+retract v1.0.0-bad // bad\n+retract v1.9.0 // self\n+\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+\n+-- p.go --\n+package p"}, {"sha": "f9ab41e88f9ea342f8c02aae72a3c9ce350dc0d9", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_pseudo_v0.0.0-20200325131415-0123456789ab", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v0.0.0-20200325131415-0123456789ab", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v0.0.0-20200325131415-0123456789ab", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v0.0.0-20200325131415-0123456789ab?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,20 @@\n+See example.com_retract_self_pseudo_v1.9.0.txt.\n+\n+This version is not retracted. It should be returned by the proxy's\n+@latest endpoint. It should match the @latest version query.\n+\n+TODO(golang.org/issue/24031): the proxy and proxy.golang.org both return\n+the highest release version from the @latest endpoint, even if that\n+version is retracted, so there is no way for the go command to\n+discover an unretracted pseudo-version.\n+\n+-- .mod --\n+module example.com/retract/self/pseudo\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v0.0.0-20200325131415-01234567890ab\"}\n+\n+-- p.go --\n+package p"}, {"sha": "d47eda05977544b762e592e296df8b49b6718d9e", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_pseudo_v1.0.0-bad.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.0.0-bad.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.0.0-bad.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.0.0-bad.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+See example.com_retract_self_pseudo_v1.9.0.txt.\n+\n+This version is retracted.\n+\n+-- .mod --\n+module example.com/retract/self/pseudo\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-bad\"}\n+\n+-- p.go --\n+package p"}, {"sha": "db09cc6a5f405d16f2e544aa25ec199f3a0fc98e", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_self_pseudo_v1.9.0.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.9.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.9.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_self_pseudo_v1.9.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,16 @@\n+Module example.com/retract/self/pseudo is a module that retracts its own\n+latest version, as well as an earlier version.\n+\n+An unretracted pseudo-version is available.\n+\n+-- .mod --\n+module example.com/retract/self/pseudo\n+\n+go 1.15\n+\n+retract v1.0.0-bad // bad\n+retract v1.9.0 // self\n+\n+-- .info --\n+{\"Version\":\"v1.9.0\"}\n+"}, {"sha": "2f996cfc366cf2df450b1efe89c6a0add3c2543f", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_v1.0.0-bad.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-bad.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-bad.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-bad.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+-- .mod --\n+module example.com/retract\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-bad\"}\n+\n+-- retract.go --\n+package retract"}, {"sha": "78152bba4fad7231e5c7af93869bf31423566a7d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_v1.0.0-good.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-good.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-good.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-good.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+-- .mod --\n+module example.com/retract\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-good\"}\n+\n+-- retract.go --\n+package retract"}, {"sha": "3bc9e35b7c5f702a2f33021d644fe4030ac3fbf0", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_v1.0.0-unused.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-unused.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-unused.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.0.0-unused.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+-- .mod --\n+module example.com/retract\n+\n+go 1.15\n+\n+-- .info --\n+{\"Version\":\"v1.0.0-unused\"}\n+\n+-- retract.go --\n+package retract"}, {"sha": "18d6d832e2ba22505f6655da5d4ac71311ce4fcd", "filename": "libgo/go/cmd/go/testdata/mod/example.com_retract_v1.1.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_retract_v1.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+-- .mod --\n+module example.com/retract\n+\n+go 1.15\n+\n+retract v1.0.0-bad // bad\n+retract v1.0.0-unused // bad\n+\n+-- .info --\n+{\"Version\":\"v1.1.0\"}\n+\n+-- retract.go --\n+package retract"}, {"sha": "edf5d487885d4293a7178464953ebfa3a9dcd3a5", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split-incompatible_subpkg_v0.1.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_subpkg_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_subpkg_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_subpkg_v0.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+Written by hand.\n+Test case for getting a package that has been moved to a nested module,\n+with a +incompatible version (and thus no go.mod file) at the root module.\n+\n+-- .mod --\n+module example.com/split-incompatible/subpkg\n+-- .info --\n+{\"Version\": \"v0.1.0\"}\n+-- go.mod --\n+module example.com/split-incompatible/subpkg\n+\n+go 1.16\n+-- subpkg.go --\n+package subpkg"}, {"sha": "35c3f277103df132a0588eb4fe5ef6ca4689e18f", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split-incompatible_v2.0.0+incompatible.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.0.0%2Bincompatible.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+Written by hand.\n+Test case for getting a package that has been moved to a nested module,\n+with a +incompatible verison (and thus no go.mod file) at the root module.\n+\n+-- .mod --\n+module example.com/split-incompatible\n+-- .info --\n+{\"Version\": \"v2.0.0+incompatible\"}\n+-- subpkg/subpkg.go --\n+package subpkg"}, {"sha": "917fc0f55992efa69f6767a486fd2a2908bded95", "filename": "libgo/go/cmd/go/testdata/mod/example.com_split-incompatible_v2.1.0-pre+incompatible.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_split-incompatible_v2.1.0-pre%2Bincompatible.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,10 @@\n+Written by hand.\n+Test case for getting a package that has been moved to a nested module,\n+with a +incompatible verison (and thus no go.mod file) at the root module.\n+\n+-- .mod --\n+module example.com/split-incompatible\n+-- .info --\n+{\"Version\": \"v2.1.0-pre+incompatible\"}\n+-- README.txt --\n+subpkg has moved to module example.com/split-incompatible/subpkg"}, {"sha": "a68588eedb4ae267a1990f95f93c0e2833dc9df3", "filename": "libgo/go/cmd/go/testdata/mod/example.com_undeprecated_v1.0.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- .mod --\n+// Deprecated: in v1.0.0\n+module example.com/undeprecated\n+\n+go 1.17\n+-- go.mod --\n+// Deprecated: in v1.0.0\n+module example.com/undeprecated\n+\n+go 1.17\n+-- undeprecated.go --\n+package undeprecated"}, {"sha": "ecabf322ec486fa99f1455f04241d559a5bfb6a4", "filename": "libgo/go/cmd/go/testdata/mod/example.com_undeprecated_v1.0.1.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_undeprecated_v1.0.1.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,14 @@\n+-- .info --\n+{\"Version\":\"v1.0.1\"}\n+-- .mod --\n+// no longer deprecated\n+module example.com/undeprecated\n+\n+go 1.17\n+-- go.mod --\n+// no longer deprecated\n+module example.com/undeprecated\n+\n+go 1.17\n+-- undeprecated.go --\n+package undeprecated"}, {"sha": "8c9de7a5f4764ff9bd25cb22fee721f842c51001", "filename": "libgo/go/cmd/go/testdata/mod/example.net_ambiguous_nested_v0.1.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_nested_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_nested_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_nested_v0.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+Written by hand.\n+\n+Test module containing a package that is also provided by a nested module tagged\n+with the same version.\n+\n+-- .mod --\n+module example.net/ambiguous/nested\n+\n+go 1.16\n+-- .info --\n+{\"Version\": \"v0.1.0\"}\n+-- go.mod --\n+module example.net/ambiguous/nested\n+\n+go 1.16\n+-- pkg/pkg.go --\n+// Package pkg exists in both example.net/ambiguous v0.1.0\n+// and example.net/ambiguous/nested v0.1.0\n+package pkg"}, {"sha": "8fa6d83346d0f901d812d81f2208c44fc93955f0", "filename": "libgo/go/cmd/go/testdata/mod/example.net_ambiguous_v0.1.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+Written by hand.\n+\n+Test module containing a package that is also provided by a nested module tagged\n+with the same version.\n+\n+-- .mod --\n+module example.net/ambiguous\n+\n+go 1.16\n+-- .info --\n+{\"Version\": \"v0.1.0\"}\n+-- go.mod --\n+module example.net/ambiguous\n+\n+go 1.16\n+-- nested/pkg/pkg.go --\n+// Package pkg exists in both example.net/ambiguous v0.1.0\n+// and example.net/ambiguous/nested v0.1.0\n+package pkg"}, {"sha": "7589ad76a311a2a054944b71dafb9dc2e4bf7b61", "filename": "libgo/go/cmd/go/testdata/mod/example.net_ambiguous_v0.2.0.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.2.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.2.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_ambiguous_v0.2.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,18 @@\n+Written by hand.\n+\n+Test module containing a package that is also provided by a nested module tagged\n+with the same version.\n+\n+-- .mod --\n+module example.net/ambiguous\n+\n+go 1.16\n+-- .info --\n+{\"Version\": \"v0.2.0\"}\n+-- go.mod --\n+module example.net/ambiguous\n+\n+go 1.16\n+-- nested/pkg/README.txt --\n+// Package pkg no longer exists in this module at v0.2.0.\n+// Find it in module example.net/ambiguous/nested instead."}, {"sha": "207e86a73cf4d224bede65f143add33156e904b7", "filename": "libgo/go/cmd/go/testdata/mod/example.net_pkgadded_v1.0.0.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.0.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,17 @@\n+Written by hand.\n+Test module with a root package added in v1.1.0\n+and a subpackage added in v1.2.0.\n+\n+-- .mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- go.mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- README.txt --\n+We will add the package example.net/pkgadded in v1.1.0,\n+and example.net/pkgadded/subpkg in v1.2.0."}, {"sha": "1c88de2dd6ffa773926302c18f756b5940ea90bd", "filename": "libgo/go/cmd/go/testdata/mod/example.net_pkgadded_v1.1.0.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.1.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+Written by hand.\n+Test module with a root package added in v1.1.0\n+and a subpackage added in v1.2.0.\n+\n+-- .mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- .info --\n+{\"Version\":\"v1.1.0\"}\n+-- go.mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- README.txt --\n+We will add the package example.net/pkgadded/subpkg in v1.2.0.\n+-- pkgadded.go --\n+// Package pkgadded was added in v1.1.0.\n+package pkgadded"}, {"sha": "922951ac37ea88b107f85f77d08ea4d0c16a4356", "filename": "libgo/go/cmd/go/testdata/mod/example.net_pkgadded_v1.2.0.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.2.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.2.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.net_pkgadded_v1.2.0.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,20 @@\n+Written by hand.\n+Test module with a root package added in v1.1.0\n+and a subpackage added in v1.2.0.\n+\n+-- .mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- .info --\n+{\"Version\":\"v1.2.0\"}\n+-- go.mod --\n+module example.net/pkgadded\n+\n+go 1.16\n+-- pkgadded.go --\n+// Package pkgadded was added in v1.1.0.\n+package pkgadded\n+-- subpkg/subpkg.go --\n+// Package subpkg was added in v1.2.0.\n+package subpkg"}, {"sha": "48e4055b0bdb971397be7dd2b0b909205a46a588", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -29,7 +29,6 @@ Scripts also have access to these other environment variables:\n \tGOARCH=<target GOARCH>\n \tGOCACHE=<actual GOCACHE being used outside the test>\n \tGOEXE=<executable file suffix: .exe on Windows, empty on other systems>\n-\tGOEXPSTRING=<value of objabi.Expstring(), from GOEXPERIMENT when toolchain built>\n \tGOOS=<target GOOS>\n \tGOPATH=$WORK/gopath\n \tGOPROXY=<local module proxy serving from cmd/go/testdata/mod>\n@@ -103,6 +102,7 @@ The commands are:\n \n - cd dir\n   Change to the given directory for future commands.\n+  The directory must use slashes as path separator.\n \n - chmod perm path...\n   Change the permissions of the files or directories named by the path arguments"}, {"sha": "cf4e2584d656508ef0505e568b1d6b0866371160", "filename": "libgo/go/cmd/go/testdata/script/badgo.txt", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbadgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbadgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbadgo.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,50 @@\n+go get example.net/badgo@v1.0.0\n+go get example.net/badgo@v1.1.0\n+go get example.net/badgo@v1.2.0\n+go get example.net/badgo@v1.3.0\n+go get example.net/badgo@v1.4.0\n+go get example.net/badgo@v1.5.0\n+! go get example.net/badgo@v1.6.0\n+stderr 'invalid go version .X.Y.: must match format 1.23'\n+\n+-- go.mod --\n+module m\n+\n+replace (\n+\texample.net/badgo v1.0.0 => ./v1.0.0\n+\texample.net/badgo v1.1.0 => ./v1.1.0\n+\texample.net/badgo v1.2.0 => ./v1.2.0\n+\texample.net/badgo v1.3.0 => ./v1.3.0\n+\texample.net/badgo v1.4.0 => ./v1.4.0\n+\texample.net/badgo v1.5.0 => ./v1.5.0\n+\texample.net/badgo v1.6.0 => ./v1.6.0\n+)\n+\n+-- v1.0.0/go.mod --\n+module example.net/badgo\n+go 1.17.0\n+\n+-- v1.1.0/go.mod --\n+module example.net/badgo\n+go 1.17rc2\n+\n+-- v1.2.0/go.mod --\n+module example.net/badgo\n+go 1.17.1\n+\n+-- v1.3.0/go.mod --\n+module example.net/badgo\n+go v1.17.0\n+\n+-- v1.4.0/go.mod --\n+module example.net/badgo\n+go v1.17.0-rc.2\n+\n+-- v1.5.0/go.mod --\n+module example.net/badgo\n+go v1.17.1\n+\n+-- v1.6.0/go.mod --\n+module example.net/badgo\n+go X.Y\n+"}, {"sha": "fc38f18ca5186f4183ce52b2f3a89bb05387ca98", "filename": "libgo/go/cmd/go/testdata/script/bug.txt", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -2,9 +2,11 @@\n \n [!linux] skip\n [gccgo] skip\n+[short] skip\n \n go install\n-env BROWSER=$GOPATH/bin/browser\n+go build -o $TMPDIR/go ./go\n+env BROWSER=$GOPATH/bin/browser PATH=$TMPDIR:$PATH\n go bug\n exists $TMPDIR/browser\n grep '^go version' $TMPDIR/browser\n@@ -45,3 +47,13 @@ func main() {\n \t}\n }\n \n+-- go/main.go --\n+package main\n+\n+import (\n+    \"os\"\n+)\n+\n+func main() {\n+    os.Exit(1)\n+}"}, {"sha": "ff2a36456e406d4444ee82bd14bc14ce20806bfd", "filename": "libgo/go/cmd/go/testdata/script/build_arm.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_arm.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+[short] skip 'skipping cross-compile in short mode'\n+\n+env GOARCH=arm\n+env GOOS=linux\n+env GOARM=5\n+\n+go build hello.go\n+! stderr 'unable to find math.a'\n+\n+-- hello.go --\n+package main\n+\n+func main() {}\n\\ No newline at end of file"}, {"sha": "931827fbde62334cb8da3aa5c4bf95204eb80e1e", "filename": "libgo/go/cmd/go/testdata/script/build_cache_arch_mode.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_arch_mode.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_arch_mode.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_arch_mode.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,21 @@\n+# Issue 9737: verify that GOARM affects the computed build ID\n+\n+[short] skip\n+\n+# arm\n+env GOOS=linux\n+env GOARCH=arm\n+env GOARM=5\n+go install mycmd\n+env GOARM=7\n+stale mycmd\n+\n+\n+-- go.mod --\n+module mycmd\n+\n+go 1.16\n+-- x.go --\n+package main\n+\n+func main() {}"}, {"sha": "68e2773a724570b554d054ecd01c7e96796fafc6", "filename": "libgo/go/cmd/go/testdata/script/build_cache_disabled.txt", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_disabled.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,50 @@\n+# The build cache is required to build anything. It also may be needed to\n+# initialize the build system, which is needed for commands like 'go env'.\n+# However, there are lots of commands the cache is not needed for, and we\n+# shouldn't require it when it won't be used.\n+#\n+# TODO(golang.org/issue/39882): commands below should work, too.\n+# * go clean -modcache\n+# * go env\n+# * go fix\n+# * go fmt\n+# * go generate\n+# * go get -d\n+# * go list (without -export or -compiled)\n+\n+env GOCACHE=off\n+\n+# Commands that don't completely load packages should work.\n+[!gccgo] go doc fmt\n+[!gccgo] stdout Printf\n+\n+[!gccgo] ! go tool compile -h\n+[!gccgo] stderr usage:\n+\n+go version\n+stdout '^go version'\n+\n+\n+# Module commands that don't load packages should work.\n+go mod init m\n+exists go.mod\n+\n+go mod edit -require rsc.io/quote@v1.5.2\n+\n+go mod download rsc.io/quote\n+\n+go mod graph\n+stdout rsc.io/quote\n+\n+go mod verify\n+\n+\n+# Commands that load but don't build packages should work.\n+go fmt .\n+\n+[!gccgo] go doc .\n+\n+-- main.go --\n+package main\n+\n+func main() {}"}, {"sha": "a7a4bf412d0c11399ead394381707138111bce61", "filename": "libgo/go/cmd/go/testdata/script/build_cd_gopath_different.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cd_gopath_different.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cd_gopath_different.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cd_gopath_different.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,73 @@\n+[gccgo] skip 'gccgo does not support -ldflags -X'\n+env GO111MODULE=off\n+go build run_go.go\n+\n+# Apply identity function to GOPATH\n+exec ./run_go$GOEXE $GOPATH/src/my.pkg/main $GOPATH IDENTITY build -o $WORK/tmp/a.exe -ldflags -X=my.pkg.Text=linkXworked\n+exec $WORK/tmp/a.exe\n+stderr 'linkXworked'\n+rm $WORK/tmp/a.exe\n+\n+[!windows] stop 'rest of the tests only apply to Windows'\n+\n+# Replace '\\' with '/' in GOPATH\n+exec ./run_go$GOEXE $GOPATH/src/my.pkg/main $GOPATH REPLACE_SLASH build -o $WORK/tmp/a.exe -ldflags -X=my.pkg.Text=linkXworked\n+exec $WORK/tmp/a.exe\n+stderr 'linkXworked'\n+rm $WORK/tmp/a.exe\n+\n+# Apply identity function to GOPATH\n+exec ./run_go$GOEXE $GOPATH/src/my.pkg/main $GOPATH UPPER build -o $WORK/tmp/a.exe -ldflags -X=my.pkg.Text=linkXworked\n+exec $WORK/tmp/a.exe\n+stderr 'linkXworked'\n+rm $WORK/tmp/a.exe\n+\n+# Apply identity function to GOPATH\n+exec ./run_go$GOEXE $GOPATH/src/my.pkg/main $GOPATH LOWER build -o $WORK/tmp/a.exe -ldflags -X=my.pkg.Text=linkXworked\n+exec $WORK/tmp/a.exe\n+stderr 'linkXworked'\n+rm $WORK/tmp/a.exe\n+\n+-- run_go.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"strings\"\n+)\n+\n+func main() {\n+\tdir := os.Args[1]\n+\tgopath := os.Args[2]\n+\tswitch os.Args[3] {\n+\t\tcase \"IDENTITY\":\n+\t\tcase \"REPLACE_SLASH\": gopath = strings.ReplaceAll(gopath, `\\`, `/`)\n+\t\tcase \"UPPER\": gopath = strings.ToUpper(gopath)\n+\t\tcase \"LOWER\": gopath = strings.ToLower(gopath)\n+\t\tdefault: fmt.Fprintln(os.Stderr, \"bad op\"); os.Exit(1)\n+\t}\n+\tcmd := exec.Command(\"go\", os.Args[4:]...)\n+\tcmd.Dir = dir\n+\tcmd.Env = append(os.Environ(), \"GOPATH=\"+gopath)\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+}\n+\n+-- my.pkg/main/main.go --\n+package main\n+\n+import \"my.pkg\"\n+\n+func main() {\n+\tprintln(pkg.Text)\n+}\n+-- my.pkg/pkg.go --\n+package pkg\n+\n+var Text = \"unset\""}, {"sha": "88a24de81478408ea807b1f1846680dc06627602", "filename": "libgo/go/cmd/go/testdata/script/build_cgo_consistent_results.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cgo_consistent_results.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cgo_consistent_results.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cgo_consistent_results.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,23 @@\n+[short] skip\n+[!cgo] skip\n+\n+[solaris] skip \"skipping on Solaris; see golang.org/issue/13247\"\n+[illumos] skip \"skipping on Solaris; see golang.org/issue/13247\"\n+\n+go build -o $WORK/exe1$GOEXE cgotest\n+go build -x -o $WORK/exe2$GOEXE cgotest\n+\n+# TODO(matloob): skip if stderr does not contain '-fdebug-prefix-map=\\$WORK'\n+\n+cmp $WORK/exe1$GOEXE $WORK/exe2$GOEXE\n+\n+-- go.mod --\n+module cgotest\n+\n+go 1.16\n+-- m.go --\n+package cgotest\n+\n+import \"C\"\n+\n+var _ C.int"}, {"sha": "2b81b4cf80b6968a022dcbf526680690714b840d", "filename": "libgo/go/cmd/go/testdata/script/build_darwin_cc_arch.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_darwin_cc_arch.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_darwin_cc_arch.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_darwin_cc_arch.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,24 @@\n+# Test that we pass -arch flag to C compiler on Darwin (issue 43692).\n+\n+[!darwin] skip\n+[!cgo] skip\n+\n+# clear CC, in case user sets it\n+env CC=\n+\n+env CGO_ENABLED=1\n+\n+env GOARCH=amd64\n+go build -n -x c.go\n+stderr 'clang.*-arch x86_64'\n+\n+env GOARCH=arm64\n+go build -n -x c.go\n+stderr 'clang.*-arch arm64'\n+\n+-- c.go --\n+package main\n+\n+import \"C\"\n+\n+func main() {}"}, {"sha": "3f49ef6f9ea80cba4e87b6c90e9e5541b1ddc88c", "filename": "libgo/go/cmd/go/testdata/script/build_dash_n_cgo.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_n_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_n_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_n_cgo.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,18 @@\n+# Tests golang.org/issue/14944\n+\n+[!cgo] skip\n+\n+go build -n foo.go\n+! stderr 'os.Stat .* no such file or directory' # there shouldn't be a stat of the archive file\n+\n+-- foo.go --\n+package main\n+\n+/*\n+#include <limits.h>\n+*/\n+import \"C\"\n+\n+func main() {\n+        println(C.INT_MAX)\n+}\n\\ No newline at end of file"}, {"sha": "e415fc224dc1261f2ab5aa5450c08e01cb4a1862", "filename": "libgo/go/cmd/go/testdata/script/build_dash_o_dev_null.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_o_dev_null.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_o_dev_null.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_o_dev_null.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+# Issue #25579\n+\n+[short] skip\n+\n+go build -o $devnull hello.go\n+! exists 'hello'$GOEXE\n+\n+-- hello.go --\n+package main\n+\n+func main() {\n+\tprintln(\"hello, world\")\n+}"}, {"sha": "6fd5bbe182bfd45d7b42c299d65e1cde11c1e95a", "filename": "libgo/go/cmd/go/testdata/script/build_dash_x.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_x.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_x.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_dash_x.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,49 @@\n+[short] skip\n+[!cgo] skip\n+\n+[!exec:/usr/bin/env] skip\n+[!exec:bash] skip\n+[!exec:cat] skip\n+\n+mkdir $WORK/tmp/cache\n+env GOCACHE=$WORK/tmp/cache\n+\n+# Before building our test main.go, ensure that an up-to-date copy of\n+# runtime/cgo is present in the cache. If it isn't, the 'go build' step below\n+# will fail with \"can't open import\". See golang.org/issue/29004.\n+#\n+# (The fix in golang.org/issue/29004 didn't completely fix the underlying issue:\n+# cmd/go/internal/load adds a bunch of implicit dependencies\n+# based on various heuristics, and, due to a bug described in\n+# https://golang.org/issue/31544#issuecomment-490607180,\n+# those implicit dependencies are not added early enough during\n+# loading to properly affect the import graph.)\n+go build runtime/cgo\n+\n+go build -x -o main main.go\n+cp stderr commands.txt\n+exec cat header.txt commands.txt\n+cp stdout test.sh\n+\n+exec ./main\n+cmp stderr hello.txt\n+rm ./main\n+\n+exec /usr/bin/env bash -x test.sh\n+exec ./main\n+cmp stderr hello.txt\n+\n+grep '^WORK=(.*)\\n' commands.txt\n+\n+-- main.go --\n+package main\n+\n+import \"C\"\n+\n+func main() {\n+\tprint(\"hello\\n\")\n+}\n+-- header.txt --\n+set -e\n+-- hello.txt --\n+hello"}, {"sha": "a994d170884d64a5d0badecbb9d3e4031236b219", "filename": "libgo/go/cmd/go/testdata/script/build_exe.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_exe.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_exe.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_exe.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,25 @@\n+# go build with -o and -buildmode=exe should report an error on a non-main package.\n+\n+! go build -buildmode=exe -o out$GOEXE ./not_main\n+stderr '-buildmode=exe requires exactly one main package'\n+! exists out$GOEXE\n+! go build -buildmode=exe -o out$GOEXE ./main_one ./main_two\n+stderr '-buildmode=exe requires exactly one main package'\n+! exists out$GOEXE\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- not_main/not_main.go --\n+package not_main\n+\n+func F() {}\n+-- main_one/main_one.go --\n+package main\n+\n+func main() {}\n+-- main_two/main_two.go --\n+package main\n+\n+func main() {}"}, {"sha": "caf25022e4cdd94ab9f9f83a47261d5bd56886c6", "filename": "libgo/go/cmd/go/testdata/script/build_gopath_order.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gopath_order.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gopath_order.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gopath_order.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,36 @@\n+# golang.org/issue/14176#issuecomment-179895769\n+# golang.org/issue/14192\n+# -I arguments to compiler could end up not in GOPATH order,\n+# leading to unexpected import resolution in the compiler.\n+\n+env GO111MODULE=off\n+env GOPATH=$WORK/p1${:}$WORK/p2\n+mkdir $WORK/p1/src/foo $WORK/p2/src/baz\n+mkdir $WORK/p2/pkg/${GOOS}_${GOARCH} $WORK/p1/src/bar\n+cp foo.go $WORK/p1/src/foo/foo.go\n+cp baz.go $WORK/p2/src/baz/baz.go\n+cp foo.a $WORK/p2/pkg/${GOOS}_${GOARCH}/foo.a\n+cp bar.go $WORK/p1/src/bar/bar.go\n+\n+go install -x bar\n+\n+# add in baz.a to the mix\n+mkdir $WORK/p1/pkg/${GOOS}_${GOARCH}\n+cp baz.a $WORK/p1/pkg/${GOOS}_${GOARCH}/baz.a\n+env GOPATH=$WORK/p1${:}$WORK/p2\n+go install -x bar\n+env GOPATH=$WORK/p2${:}$WORK/p1\n+go install -x bar\n+\n+-- foo.go --\n+package foo\n+-- baz.go --\n+package baz\n+-- foo.a --\n+bad\n+-- baz.a --\n+bad\n+-- bar.go --\n+package bar\n+import _ \"baz\"\n+import _ \"foo\""}, {"sha": "71356e5321eb1ca3ab2b9227c55ceba8eb4710d1", "filename": "libgo/go/cmd/go/testdata/script/build_i_deprecate.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i_deprecate.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,24 @@\n+# Check that deprecation warnings are printed when the -i flag is used.\n+# TODO(golang.org/issue/41696): remove the -i flag after Go 1.16, and this test.\n+\n+go build -n -i\n+stderr '^go build: -i flag is deprecated$'\n+\n+go install -n -i\n+stderr '^go install: -i flag is deprecated$'\n+\n+go test -n -i\n+stderr '^go test: -i flag is deprecated$'\n+\n+\n+# 'go clean -i' should not print a deprecation warning.\n+# It will continue working.\n+go clean -i .\n+! stderr .\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- m.go --\n+package m"}, {"sha": "37141f3466b3e7d7ac785d6e5cd909157bb2febe", "filename": "libgo/go/cmd/go/testdata/script/build_ignore_leading_bom.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_ignore_leading_bom.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_ignore_leading_bom.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_ignore_leading_bom.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,27 @@\n+# Per https://golang.org/ref/spec#Source_code_representation:\n+# a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF)\n+# if it is the first Unicode code point in the source text.\n+\n+go list -f 'Imports: {{.Imports}} EmbedFiles: {{.EmbedFiles}}' .\n+stdout '^Imports: \\[embed m/hello\\] EmbedFiles: \\[.*file\\]$'\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- m.go --\n+\ufeffpackage main\n+\n+import (\n+\t_ \"embed\"\n+\n+\t\"m/hello\"\n+)\n+\n+//go:embed file\n+var s string\n+\n+-- hello/hello.go --\n+package hello\n+\n+-- file --"}, {"sha": "b500340bfb48b6e0405702caa67d7cb267d8bec3", "filename": "libgo/go/cmd/go/testdata/script/build_import_comment.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_comment.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_comment.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_comment.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,68 @@\n+# Test in GOPATH mode first.\n+env GO111MODULE=off\n+cd m\n+\n+# Import comment matches\n+go build -n works.go\n+\n+# Import comment mismatch\n+! go build -n wrongplace.go\n+stderr 'wrongplace expects import \"my/x\"'\n+\n+# Import comment syntax error\n+! go build -n bad.go\n+stderr 'cannot parse import comment'\n+\n+# Import comment conflict\n+! go build -n conflict.go\n+stderr 'found import comments'\n+\n+\n+# Test in module mode.\n+# We ignore import comments, so these commands should succeed.\n+env GO111MODULE=on\n+\n+# Import comment matches\n+go build -n works.go\n+\n+# Import comment mismatch\n+go build -n wrongplace.go\n+\n+# Import comment syntax error\n+go build -n bad.go\n+\n+# Import comment conflict\n+go build -n conflict.go\n+\n+-- m/go.mod --\n+module m\n+\n+go 1.16\n+-- m/bad.go --\n+package p\n+\n+import \"m/bad\"\n+-- m/conflict.go --\n+package p\n+\n+import \"m/conflict\"\n+-- m/works.go --\n+package p\n+\n+import _ \"m/works/x\"\n+-- m/wrongplace.go --\n+package p\n+\n+import \"m/wrongplace\"\n+-- m/bad/bad.go --\n+package bad // import\n+-- m/conflict/a.go --\n+package conflict // import \"a\"\n+-- m/conflict/b.go --\n+package conflict /* import \"b\" */\n+-- m/works/x/x.go --\n+package x // import \"m/works/x\"\n+-- m/works/x/x1.go --\n+package x // important! not an import comment\n+-- m/wrongplace/x.go --\n+package x // import \"my/x\""}, {"sha": "16e4e87daeeeae113061b4c62bb28dd389bd273e", "filename": "libgo/go/cmd/go/testdata/script/build_import_cycle.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_cycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_cycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_import_cycle.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+# mod_import_cycle covers this error in module mode.\n+env GO111MODULE=off\n+\n+! go build selfimport\n+stderr -count=1 'import cycle not allowed'\n+\n+go list -e -f '{{.Error}}' selfimport # Don't hang forever\n+stdout -count=1 'import cycle not allowed'\n+\n+-- selfimport/selfimport.go --\n+package selfimport\n+\n+import \"selfimport\""}, {"sha": "25aa18cfcb33c0bb5dd8d2874b5777a733d2275d", "filename": "libgo/go/cmd/go/testdata/script/build_internal.txt", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_internal.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,63 @@\n+# Test internal package errors are handled\n+cd testinternal3\n+go list .\n+stdout 'testinternal3'\n+\n+# Test internal cache\n+cd ../testinternal4\n+! go build testinternal4/p\n+stderr 'internal'\n+\n+# Test internal packages outside GOROOT are respected\n+cd ../testinternal2\n+! go build -v .\n+stderr 'p\\.go:3:8: use of internal package .*internal/w not allowed'\n+\n+[gccgo] skip # gccgo does not have GOROOT\n+cd ../testinternal\n+! go build -v .\n+stderr 'p\\.go:3:8: use of internal package net/http/internal not allowed'\n+\n+-- testinternal/go.mod --\n+module testinternal\n+\n+go 1.16\n+-- testinternal/p.go --\n+package p\n+\n+import _ \"net/http/internal\"\n+-- testinternal2/go.mod --\n+module testinternal2\n+\n+go 1.16\n+-- testinternal2/p.go --\n+package p\n+\n+import _ \"./x/y/z/internal/w\"\n+-- testinternal2/x/y/z/internal/w/w.go --\n+package w\n+-- testinternal3/go.mod --\n+module testinternal3\n+\n+go 1.16\n+-- testinternal3/t.go --\n+package t\n+\n+import _ \"internal/does-not-exist\"\n+-- testinternal4/go.mod --\n+module testinternal4\n+\n+go 1.16\n+-- testinternal4/p/p.go --\n+package p\n+\n+import (\n+\t_ \"testinternal4/q/internal/x\"\n+\t_ \"testinternal4/q/j\"\n+)\n+-- testinternal4/q/internal/x/x.go --\n+package x\n+-- testinternal4/q/j/j.go --\n+package j\n+\n+import _ \"testinternal4/q/internal/x\""}, {"sha": "cf1e9ea6c24dff535e9372c8dd334a7eba478a14", "filename": "libgo/go/cmd/go/testdata/script/build_issue6480.txt", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue6480.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue6480.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_issue6480.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,128 @@\n+# \"go test -c -test.bench=XXX errors\" should not hang.\n+# \"go test -c\" should also produce reproducible binaries.\n+# \"go test -c\" should also appear to write a new binary every time,\n+# even if it's really just updating the mtime on an existing up-to-date binary.\n+\n+[gccgo] skip\n+[short] skip\n+\n+# Install some commands to compare mtimes\n+env GOBIN=$WORK/tmp/bin\n+go install m/now m/mtime m/before\n+\n+# Initial builds\n+go test -c -test.bench=XXX errors\n+go test -c -o errors2.test errors\n+cmp errors.test$GOEXE errors2.test # // errors2.test has no exeSuffix because -o above doesn't have it\n+\n+# Check errors.test mtime is updated\n+exec $GOBIN/now\n+cp stdout start_time.txt\n+go test -x -c -test.bench=XXX errors\n+! stderr '[\\\\/]link|gccgo' # make sure up-to-date test binary is not relinked\n+exec $GOBIN/mtime errors.test$GOEXE\n+cp stdout errors1_mod_time.txt\n+exec $GOBIN/before start_time.txt errors1_mod_time.txt\n+rm start_time.txt errors1_mod_time.txt\n+\n+# Check errors2.test mtime is updated\n+exec $GOBIN/now\n+cp stdout start_time.txt\n+go test -x -c -o errors2.test errors\n+! stderr '[\\\\/]link|gccgo' # make sure up-to-date test binary is not relinked\n+exec $GOBIN/mtime errors2.test\n+cp stdout errors2_mod_time.txt\n+exec $GOBIN/before start_time.txt errors2_mod_time.txt\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- now/now.go --\n+// Writes time.Now() to a file\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+func main() {\n+\tif err := json.NewEncoder(os.Stdout).Encode(time.Now()); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+}\n+-- mtime/mtime.go --\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tinfo, err := os.Stat(os.Args[1])\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tif err := json.NewEncoder(os.Stdout).Encode(info.ModTime()); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+}\n+-- before/before.go --\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+func truncateLike(t, p time.Time) time.Time {\n+\tnano := p.UnixNano()\n+\td := 1 * time.Nanosecond\n+\tfor nano%int64(d) == 0 && d < 1*time.Second {\n+\t\td *= 10\n+\t}\n+\tfor nano%int64(d) == 0 && d < 2*time.Second {\n+\t\td *= 2\n+\t}\n+\treturn t.Truncate(d)\n+}\n+\n+func main() {\n+\tvar t1 time.Time\n+\tb1, err := os.ReadFile(os.Args[1])\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tif err := json.Unmarshal(b1, &t1); err != nil  {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\n+\tvar t2 time.Time\n+\tb2, err := os.ReadFile(os.Args[2])\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tif err := json.Unmarshal(b2, &t2); err != nil  {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\n+\tt1 = truncateLike(t1, t2)\n+\tif !t1.Before(t2) {\n+\t\tfmt.Fprintf(os.Stderr, \"time in %v (%v) is not before time in %v (%v)\", os.Args[1], t1, os.Args[2], t2)\n+\t\tos.Exit(1)\n+\t}\n+}"}, {"sha": "f1de1e4c7129af961d25c5c8190b186354cef612", "filename": "libgo/go/cmd/go/testdata/script/build_link_x_import_path_escape.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_link_x_import_path_escape.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_link_x_import_path_escape.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_link_x_import_path_escape.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,22 @@\n+[gccgo] skip 'gccgo does not support -ldflags -X'\n+\n+go build -o linkx$GOEXE -ldflags -X=my.pkg.Text=linkXworked my.pkg/main\n+exec ./linkx$GOEXE\n+stderr '^linkXworked$'\n+\n+-- go.mod --\n+module my.pkg\n+\n+go 1.16\n+-- main/main.go --\n+package main\n+\n+import \"my.pkg\"\n+\n+func main() {\n+\tprintln(pkg.Text)\n+}\n+-- pkg.go --\n+package pkg\n+\n+var Text = \"unset\""}, {"sha": "7aa77aea42ad3b8bbcd3046845ffcd37a021163e", "filename": "libgo/go/cmd/go/testdata/script/build_n_cgo.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_n_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_n_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_n_cgo.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,17 @@\n+[!cgo] skip\n+\n+# Test that nothing is prepended to $WORK path prefix.\n+# See issue golang.org/issue/37012.\n+go build -n\n+! stderr '[/\\\\]\\$WORK'\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- main.go --\n+package main\n+\n+import \"C\"\n+\n+var _ C.int"}, {"sha": "b61d7522740d34447f64f75056a8cd15f9bffbbf", "filename": "libgo/go/cmd/go/testdata/script/build_no_go.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_no_go.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_no_go.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_no_go.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,41 @@\n+! go build ./empty/test\n+stderr 'no non-test Go files in '\n+\n+! go build ./empty/xtest\n+stderr 'no non-test Go files in '\n+\n+! go build ./empty/testxtest\n+stderr 'no non-test Go files in '\n+\n+! go build ./exclude\n+stderr 'build constraints exclude all Go files in '\n+\n+! go build ./exclude/ignore\n+stderr 'no Go files in '\n+\n+! go build ./exclude/empty\n+stderr 'no Go files in '\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- empty/test/test_test.go --\n+package p\n+-- empty/testxtest/test_test.go --\n+package p\n+-- empty/testxtest/xtest_test.go --\n+package p_test\n+-- empty/xtest/xtest_test.go --\n+package p_test\n+-- exclude/empty/x.txt --\n+-- exclude/ignore/_x.go --\n+package x\n+-- exclude/x.go --\n+// +build linux,!linux\n+\n+package x\n+-- exclude/x_linux.go --\n+// +build windows\n+\n+package x"}, {"sha": "1e82950dbc1f1a9de1c9b9da768e2ad886bd4233", "filename": "libgo/go/cmd/go/testdata/script/build_output.txt", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_output.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_output.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_output.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,117 @@\n+[gccgo] skip 'gccgo has no standard packages'\n+[short] skip\n+\n+[!windows] env NONEXE='.exe'\n+[windows] env NONEXE=''\n+\n+env GOBIN=$WORK/tmp/bin\n+go install m/isarchive &\n+\n+go build x.go\n+exists -exec x$GOEXE\n+rm x$GOEXE\n+! exists x$NONEXE\n+\n+go build -o myprog x.go\n+! exists x\n+! exists x.exe\n+exists -exec myprog\n+! exists myprogr.exe\n+\n+! exists bin\n+go build -o bin/x x.go\n+exists -exec bin/x\n+rm bin\n+\n+! exists bin\n+go build -o bin/ x.go\n+exists -exec bin/x$GOEXE\n+rm bin\n+\n+[windows] ! exists bin\n+[windows] go build -o bin\\x x.go\n+[windows] exists -exec bin\\x\n+[windows] rm bin\n+\n+[windows] ! exists bin\n+[windows] go build -o bin\\ x.go\n+[windows] exists -exec bin\\x.exe\n+[windows] rm bin\n+\n+! exists bin\n+mkdir bin\n+go build -o bin x.go\n+exists -exec bin/x$GOEXE\n+rm bin\n+\n+go build p.go\n+! exists p\n+! exists p.a\n+! exists p.o\n+! exists p.exe\n+\n+wait # for isarchive\n+\n+go build -o p.a p.go\n+exists p.a\n+exec $GOBIN/isarchive p.a\n+\n+go build cmd/gofmt\n+exists -exec gofmt$GOEXE\n+rm gofmt$GOEXE\n+! exists gofmt$NONEXE\n+\n+go build -o mygofmt cmd/gofmt\n+exists -exec mygofmt\n+! exists mygofmt.exe\n+! exists gofmt\n+! exists gofmt.exe\n+\n+go build sync/atomic\n+! exists atomic\n+! exists atomic.exe\n+\n+go build -o myatomic.a sync/atomic\n+exists myatomic.a\n+exec $GOBIN/isarchive myatomic.a\n+! exists atomic\n+! exists atomic.a\n+! exists atomic.exe\n+\n+! go build -o whatever cmd/gofmt sync/atomic\n+stderr 'multiple packages'\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- x.go --\n+package main\n+\n+func main() {}\n+-- p.go --\n+package p\n+-- isarchive/isarchive.go --\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tf, err := os.Open(os.Args[1])\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tbuf := make([]byte, 100)\n+\tio.ReadFull(f, buf)\n+\tf.Close()\n+\tif !bytes.HasPrefix(buf, []byte(\"!<arch>\\n\")) {\n+\t\tfmt.Fprintf(os.Stderr, \"file %s exists but is not an archive\\n\", os.Args[1])\n+\t\tos.Exit(1)\n+\t}\n+}"}, {"sha": "2932b94e6c42c70cdec8884c1e36dc281e063369", "filename": "libgo/go/cmd/go/testdata/script/build_overlay.txt", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_overlay.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,308 @@\n+[short] skip\n+\n+# Test building in overlays.\n+# TODO(#39958): add a test case where the destination file in the replace map\n+#   isn't a go file. Either completely exclude that case in fs.IsDirWithGoFiles\n+#   if the compiler doesn't allow it, or test that it works all the way.\n+# TODO(#39958): add a test that both gc and gccgo assembly files can include .h\n+#   files.\n+\n+# The main package (m) is contained in an overlay. It imports m/dir2 which has one\n+# file in an overlay and one file outside the overlay, which in turn imports m/dir,\n+# which only has source files in the overlay.\n+\n+cd m\n+\n+! go build .\n+go build -overlay overlay.json -o main$GOEXE .\n+exec ./main$goexe\n+stdout '^hello$'\n+\n+go build -overlay overlay.json -o print_abspath$GOEXE ./printpath\n+exec ./print_abspath$GOEXE\n+stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]main.go\n+\n+go build -overlay overlay.json -o print_trimpath$GOEXE -trimpath ./printpath\n+exec ./print_trimpath$GOEXE\n+stdout ^m[/\\\\]printpath[/\\\\]main.go\n+\n+go build -overlay overlay.json -o print_trimpath_two_files$GOEXE printpath/main.go printpath/other.go\n+exec ./print_trimpath_two_files$GOEXE\n+stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]main.go\n+stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]other.go\n+\n+go build -overlay overlay.json -o main_cgo_replace$GOEXE ./cgo_hello_replace\n+exec ./main_cgo_replace$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -overlay overlay.json -o main_cgo_quote$GOEXE ./cgo_hello_quote\n+exec ./main_cgo_quote$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -overlay overlay.json -o main_cgo_angle$GOEXE ./cgo_hello_angle\n+exec ./main_cgo_angle$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -overlay overlay.json -o main_call_asm$GOEXE ./call_asm\n+exec ./main_call_asm$GOEXE\n+! stdout .\n+\n+# Change the contents of a file in the overlay and ensure that makes the target stale\n+go install -overlay overlay.json ./test_cache\n+go list -overlay overlay.json -f '{{.Stale}}' ./test_cache\n+stdout '^false$'\n+cp overlay/test_cache_different.go overlay/test_cache.go\n+go list -overlay overlay.json -f '{{.Stale}}' ./test_cache\n+stdout '^true$'\n+\n+go list -compiled -overlay overlay.json -f '{{range .CompiledGoFiles}}{{. | printf \"%s\\n\"}}{{end}}' ./cgo_hello_replace\n+cp stdout compiled_cgo_sources.txt\n+go run ../print_line_comments.go compiled_cgo_sources.txt\n+stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]cgo_hello_replace[/\\\\]cgo_hello_replace.go\n+! stdout $GOPATH[/\\\\]src[/\\\\]m[/\\\\]overlay[/\\\\]hello.c\n+\n+# Run same tests but with gccgo.\n+env GO111MODULE=off\n+[!exec:gccgo] stop\n+\n+! go build -compiler=gccgo .\n+go build -compiler=gccgo -overlay overlay.json -o main_gccgo$GOEXE .\n+exec ./main_gccgo$goexe\n+stdout '^hello$'\n+\n+go build -compiler=gccgo -overlay overlay.json -o print_abspath_gccgo$GOEXE ./printpath\n+exec ./print_abspath_gccgo$GOEXE\n+stdout $WORK[/\\\\]gopath[/\\\\]src[/\\\\]m[/\\\\]printpath[/\\\\]main.go\n+\n+go build -compiler=gccgo -overlay overlay.json -o print_trimpath_gccgo$GOEXE -trimpath ./printpath\n+exec ./print_trimpath_gccgo$GOEXE\n+stdout ^\\.[/\\\\]printpath[/\\\\]main.go\n+\n+\n+go build -compiler=gccgo  -overlay overlay.json -o main_cgo_replace_gccgo$GOEXE ./cgo_hello_replace\n+exec ./main_cgo_replace_gccgo$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -compiler=gccgo  -overlay overlay.json -o main_cgo_quote_gccgo$GOEXE ./cgo_hello_quote\n+exec ./main_cgo_quote_gccgo$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -compiler=gccgo  -overlay overlay.json -o main_cgo_angle_gccgo$GOEXE ./cgo_hello_angle\n+exec ./main_cgo_angle_gccgo$GOEXE\n+stdout '^hello cgo\\r?\\n'\n+\n+go build -compiler=gccgo -overlay overlay.json -o main_call_asm_gccgo$GOEXE ./call_asm\n+exec ./main_call_asm_gccgo$GOEXE\n+! stdout .\n+\n+\n+-- m/go.mod --\n+// TODO(matloob): how do overlays work with go.mod (especially if mod=readonly)\n+module m\n+\n+go 1.16\n+\n+-- m/dir2/h.go --\n+package dir2\n+\n+func PrintMessage() {\n+\tprintMessage()\n+}\n+-- m/dir/foo.txt --\n+The build action code currently expects the package directory\n+to exist, so it can run the compiler in that directory.\n+TODO(matloob): Remove this requirement.\n+-- m/printpath/about.txt --\n+the actual code is in the overlay\n+-- m/overlay.json --\n+{\n+\t\"Replace\": {\n+\t\t\"f.go\": \"overlay/f.go\",\n+\t\t\"dir/g.go\": \"overlay/dir_g.go\",\n+\t\t\"dir2/i.go\": \"overlay/dir2_i.go\",\n+\t\t\"printpath/main.go\": \"overlay/printpath.go\",\n+\t\t\"printpath/other.go\": \"overlay2/printpath2.go\",\n+\t\t\"call_asm/asm_gc.s\": \"overlay/asm_gc.s\",\n+\t\t\"call_asm/asm_gccgo.s\": \"overlay/asm_gccgo.s\",\n+\t\t\"test_cache/main.go\": \"overlay/test_cache.go\",\n+\t\t\"cgo_hello_replace/cgo_header.h\": \"overlay/cgo_head.h\",\n+\t\t\"cgo_hello_replace/hello.c\": \"overlay/hello.c\",\n+\t\t\"cgo_hello_quote/cgo_hello.go\": \"overlay/cgo_hello_quote.go\",\n+\t\t\"cgo_hello_quote/cgo_header.h\": \"overlay/cgo_head.h\",\n+\t\t\"cgo_hello_angle/cgo_hello.go\": \"overlay/cgo_hello_angle.go\",\n+\t\t\"cgo_hello_angle/cgo_header.h\": \"overlay/cgo_head.h\"\n+\t}\n+}\n+-- m/cgo_hello_replace/cgo_hello_replace.go --\n+package main\n+\n+// #include \"cgo_header.h\"\n+import \"C\"\n+\n+func main() {\n+\tC.say_hello()\n+}\n+-- m/cgo_hello_replace/cgo_header.h --\n+ // Test that this header is replaced with one that has the proper declaration.\n+void say_goodbye();\n+\n+-- m/cgo_hello_replace/hello.c --\n+#include <stdio.h>\n+\n+void say_goodbye() { puts(\"goodbye cgo\\n\"); fflush(stdout); }\n+\n+-- m/overlay/f.go --\n+package main\n+\n+import \"m/dir2\"\n+\n+func main() {\n+\tdir2.PrintMessage()\n+}\n+-- m/call_asm/main.go --\n+package main\n+\n+func foo() // There will be a \"missing function body\" error if the assembly file isn't found.\n+\n+func main() {\n+\tfoo()\n+}\n+-- m/overlay/dir_g.go --\n+package dir\n+\n+import \"fmt\"\n+\n+func PrintMessage() {\n+\tfmt.Println(\"hello\")\n+}\n+-- m/overlay/printpath.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+)\n+\n+func main() {\n+\t_, file, _, _ := runtime.Caller(0)\n+\n+\t// Since https://golang.org/cl/214286, the runtime's debug paths are\n+\t// slash-separated regardless of platform, so normalize them to system file\n+\t// paths.\n+\tfmt.Println(filepath.FromSlash(file))\n+}\n+-- m/overlay2/printpath2.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+)\n+\n+func init() {\n+\t_, file, _, _ := runtime.Caller(0)\n+\tfmt.Println(filepath.FromSlash(file))\n+}\n+-- m/overlay/dir2_i.go --\n+package dir2\n+\n+import \"m/dir\"\n+\n+func printMessage() {\n+\tdir.PrintMessage()\n+}\n+-- m/overlay/cgo_hello_quote.go --\n+package main\n+\n+// #include \"cgo_header.h\"\n+import \"C\"\n+\n+func main() {\n+\tC.say_hello()\n+}\n+-- m/overlay/cgo_hello_angle.go --\n+package main\n+\n+// #include <cgo_header.h>\n+import \"C\"\n+\n+func main() {\n+\tC.say_hello()\n+}\n+-- m/overlay/cgo_head.h --\n+void say_hello();\n+-- m/overlay/hello.c --\n+#include <stdio.h>\n+\n+void say_hello() { puts(\"hello cgo\\n\"); fflush(stdout); }\n+-- m/overlay/asm_gc.s --\n+// +build gc\n+\n+TEXT \u00b7foo(SB),0,$0\n+\tRET\n+\n+-- m/overlay/asm_gccgo.s --\n+// +build gccgo\n+\n+.globl main.foo\n+.text\n+main.foo:\n+\tret\n+\n+-- m/overlay/test_cache.go --\n+package foo\n+\n+import \"fmt\"\n+\n+func bar() {\n+\tfmt.Println(\"something\")\n+}\n+-- m/overlay/test_cache_different.go --\n+package foo\n+\n+import \"fmt\"\n+\n+func bar() {\n+\tfmt.Println(\"different\")\n+}\n+-- m/cgo_hello_quote/hello.c --\n+#include <stdio.h>\n+\n+void say_hello() { puts(\"hello cgo\\n\"); fflush(stdout); }\n+-- m/cgo_hello_angle/hello.c --\n+#include <stdio.h>\n+\n+void say_hello() { puts(\"hello cgo\\n\"); fflush(stdout); }\n+\n+-- print_line_comments.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+func main() {\n+\tcompiledGoFilesArg := os.Args[1]\n+\tb, err := ioutil.ReadFile(compiledGoFilesArg)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tcompiledGoFiles := strings.Split(strings.TrimSpace(string(b)), \"\\n\")\n+\tfor _, f := range compiledGoFiles {\n+\t\tb, err := ioutil.ReadFile(f)\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tfor _, line := range strings.Split(string(b), \"\\n\") {\n+\t\t\tif strings.HasPrefix(line, \"#line\") || strings.HasPrefix(line, \"//line\") {\n+\t\t\t\tfmt.Println(line)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6a600cfb0a8c5761f59d73141b79b731bffdeef3", "filename": "libgo/go/cmd/go/testdata/script/build_patterns_outside_gopath.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_patterns_outside_gopath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_patterns_outside_gopath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_patterns_outside_gopath.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,36 @@\n+# Tests issue #18778\n+[short] skip\n+\n+cd pkgs\n+\n+env GO111MODULE=off\n+go build ./...\n+! stdout .\n+go test ./...\n+stdout '^ok'\n+go list ./...\n+stdout 'pkgs$'\n+stdout 'pkgs/a'\n+\n+-- pkgs/go.mod --\n+module pkgs\n+\n+go 1.16\n+-- pkgs/a.go --\n+package x\n+-- pkgs/a_test.go --\n+package x_test\n+\n+import \"testing\"\n+\n+func TestX(t *testing.T) {\n+}\n+-- pkgs/a/a.go --\n+package a\n+-- pkgs/a/a_test.go --\n+package a_test\n+\n+import \"testing\"\n+\n+func TestA(t *testing.T) {\n+}"}, {"sha": "e0bbbefb19418ba922be4c877b2d398d3da89dd4", "filename": "libgo/go/cmd/go/testdata/script/build_plugin_non_main.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_plugin_non_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_plugin_non_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_plugin_non_main.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+# Plugins are not supported on all platforms.\n+[!buildmode:plugin] skip\n+\n+go build -n testdep\n+! go build -buildmode=plugin testdep\n+stderr '-buildmode=plugin requires exactly one main package'\n+\n+-- go.mod --\n+module testdep\n+\n+go 1.16\n+-- testdep.go --\n+package p"}, {"sha": "bee218f4c1fff290b993cf68930a4753ecbce708", "filename": "libgo/go/cmd/go/testdata/script/build_tag_goexperiment.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tag_goexperiment.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tag_goexperiment.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tag_goexperiment.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,31 @@\n+[short] skip\n+# Reset all experiments so fieldtrack is definitely off.\n+env GOEXPERIMENT=none\n+go run m\n+stderr 'fieldtrack off'\n+# Turn fieldtrack on.\n+env GOEXPERIMENT=none,fieldtrack\n+go run m\n+stderr 'fieldtrack on'\n+\n+-- ft_off.go --\n+// +build !goexperiment.fieldtrack\n+\n+package main\n+\n+func main() {\n+\tprintln(\"fieldtrack off\")\n+}\n+\n+-- ft_on.go --\n+// +build goexperiment.fieldtrack\n+\n+package main\n+\n+func main() {\n+\tprintln(\"fieldtrack on\")\n+}\n+\n+-- go.mod --\n+module m\n+go 1.14"}, {"sha": "f3eb28202ac96259be5e8182036a3a7116928b43", "filename": "libgo/go/cmd/go/testdata/script/build_tags_no_comma.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tags_no_comma.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tags_no_comma.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_tags_no_comma.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,4 @@\n+[gccgo] skip 'gccgo has no standard packages'\n+go build -tags 'tag1 tag2' math\n+! go build -tags 'tag1,tag2 tag3' math\n+stderr 'space-separated list contains comma'\n\\ No newline at end of file"}, {"sha": "8693a80a08e67539a7e331870cd846cb045d57a8", "filename": "libgo/go/cmd/go/testdata/script/build_test_only.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_test_only.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_test_only.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_test_only.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,19 @@\n+# Named explicitly, test-only packages should be reported as\n+# unbuildable/uninstallable, even if there is a wildcard also matching.\n+! go build m/testonly m/testonly...\n+stderr 'no non-test Go files in'\n+! go install ./testonly\n+stderr 'no non-test Go files in'\n+\n+# Named through a wildcard, the test-only packages should be silently ignored.\n+go build m/testonly...\n+go install ./testonly...\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- testonly/t_test.go --\n+package testonly\n+-- testonly2/t.go --\n+package testonly2"}, {"sha": "3187b4d6439995e7a81aea198ae4d0a4d3f2a8d7", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath_cgo.txt", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath_cgo.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,184 @@\n+# This test builds a cgo binary and verifies the source directory path\n+# does not appear in the binary, either literally or in compressed DWARF.\n+# TODO(golang.org/issue/36072): ideally we should build a binary from identical\n+# sources in different directories and verify the binary and all intermediate\n+# files are identical.\n+\n+[short] skip\n+[!cgo] skip\n+\n+# Check that the source path appears when -trimpath is not used.\n+go build -o hello.exe .\n+grep -q gopath[/\\\\]src hello.exe\n+go run ./list-dwarf hello.exe\n+stdout gopath[/\\\\]src\n+\n+# Check that the source path does not appear when -trimpath is used.\n+[aix] stop # can't inspect XCOFF binaries\n+go build -trimpath -o hello.exe .\n+! grep -q gopath[/\\\\]src hello.exe\n+go run ./list-dwarf hello.exe\n+! stdout gopath/src\n+\n+\n+# Do the above, with the cgo (but not .c) sources in an overlay\n+# Check that the source path appears when -trimpath is not used.\n+mkdir $WORK/overlay\n+cp hello.go $WORK/overlay/hello.go\n+mkdir hello_overlay\n+cp hello.c hello_overlay/hello.c\n+go build -overlay overlay.json -o hello_overlay.exe ./hello_overlay\n+grep -q gopath[/\\\\]src hello_overlay.exe\n+! grep -q $WORK[/\\\\]overlay hello_overlay.exe\n+go run ./list-dwarf hello_overlay.exe\n+stdout gopath[/\\\\]src\n+! stdout $WORK[/\\\\]overlay\n+\n+# Check that the source path does not appear when -trimpath is used.\n+go build -overlay overlay.json -trimpath -o hello_overlay.exe ./hello_overlay\n+! grep -q gopath[/\\\\]src hello_overlay.exe\n+! grep -q $WORK[/\\\\]overlay hello_overlay.exe\n+go run ./list-dwarf hello_overlay.exe\n+! stdout gopath/src\n+! stdout $WORK[/\\\\]overlay\n+\n+-- go.mod --\n+module m\n+\n+go 1.14\n+-- overlay.json --\n+{\n+\t\"Replace\": {\n+\t\t\"hello_overlay/hello.go\": \"../../overlay/hello.go\"\n+\t}\n+}\n+-- hello.c --\n+#include <stdio.h>\n+\n+void say_hello() { puts(\"Hello, world!\\n\"); }\n+\n+-- hello.go --\n+package main\n+\n+// void say_hello();\n+import \"C\"\n+\n+func main() {\n+\tC.say_hello()\n+}\n+\n+-- list-dwarf/list-dwarf.go --\n+package main\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"sort\"\n+)\n+\n+func main() {\n+\tfiles, err := run(os.Args[1])\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tfor _, file := range files {\n+\t\tfmt.Println(file)\n+\t}\n+}\n+\n+func run(exePath string) ([]string, error) {\n+\tdwarfData, err := readDWARF(exePath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdwarfReader := dwarfData.Reader()\n+\tfiles := make(map[string]bool)\n+\tfor {\n+\t\te, err := dwarfReader.Next()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif e == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tlr, err := dwarfData.LineReader(e)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif lr == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tvar le dwarf.LineEntry\n+\t\tfor {\n+\t\t\tif err := lr.Next(&le); err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tfiles[le.File.Name] = true\n+\t\t}\n+\t}\n+\n+\tsortedFiles := make([]string, 0, len(files))\n+\tfor file := range files {\n+\t\tsortedFiles = append(sortedFiles, file)\n+\t}\n+\tsort.Strings(sortedFiles)\n+\treturn sortedFiles, nil\n+}\n+-- list-dwarf/read_darwin.go --\n+package main\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"debug/macho\"\n+)\n+\n+func readDWARF(exePath string) (*dwarf.Data, error) {\n+\tmachoFile, err := macho.Open(exePath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer machoFile.Close()\n+\treturn machoFile.DWARF()\n+}\n+-- list-dwarf/read_elf.go --\n+// +build android dragonfly freebsd illumos linux netbsd openbsd solaris\n+\n+package main\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"debug/elf\"\n+)\n+\n+func readDWARF(exePath string) (*dwarf.Data, error) {\n+\telfFile, err := elf.Open(exePath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer elfFile.Close()\n+\treturn elfFile.DWARF()\n+}\n+-- list-dwarf/read_windows.go --\n+package main\n+\n+import (\n+\t\"debug/dwarf\"\n+\t\"debug/pe\"\n+)\n+\n+func readDWARF(exePath string) (*dwarf.Data, error) {\n+\tpeFile, err := pe.Open(exePath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer peFile.Close()\n+\treturn peFile.DWARF()\n+}"}, {"sha": "d61e420279b7b61650161c1ff429cd68ffaf8e7c", "filename": "libgo/go/cmd/go/testdata/script/build_unsupported_goos.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_unsupported_goos.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_unsupported_goos.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_unsupported_goos.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,6 @@\n+[gccgo] skip # gccgo assumes cross-compilation is always possible\n+\n+env GOOS=windwos\n+\n+! go build -n exclude\n+stderr 'unsupported GOOS/GOARCH pair'\n\\ No newline at end of file"}, {"sha": "f430ff2c3eb888d596b848f5f95ee06d50fe446d", "filename": "libgo/go/cmd/go/testdata/script/build_vendor.txt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_vendor.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,42 @@\n+# Build\n+env GO111MODULE=off\n+go build vend/x\n+! stdout .\n+! stderr .\n+\n+-- vend/dir1/dir1.go --\n+package dir1\n+-- vend/subdir/bad.go --\n+package subdir\n+\n+import _ \"r\"\n+-- vend/subdir/good.go --\n+package subdir\n+\n+import _ \"p\"\n+-- vend/vendor/p/p.go --\n+package p\n+-- vend/vendor/q/q.go --\n+package q\n+-- vend/vendor/vend/dir1/dir2/dir2.go --\n+package dir2\n+-- vend/x/invalid/invalid.go --\n+package invalid\n+\n+import \"vend/x/invalid/vendor/foo\"\n+-- vend/x/vendor/p/p/p.go --\n+package p\n+\n+import _ \"notfound\"\n+-- vend/x/vendor/p/p.go --\n+package p\n+-- vend/x/vendor/r/r.go --\n+package r\n+-- vend/x/x.go --\n+package x\n+\n+import _ \"p\"\n+import _ \"q\"\n+import _ \"r\"\n+import _ \"vend/dir1\"      // not vendored\n+import _ \"vend/dir1/dir2\" // vendored"}, {"sha": "7aaa713e24412c1966b003e3f774888cd9df7dcb", "filename": "libgo/go/cmd/go/testdata/script/cgo_asm_error.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_asm_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_asm_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_asm_error.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,25 @@\n+[!cgo] skip\n+\n+# Test that cgo package can't contain a go assembly file.\n+\n+# Ensure the build fails and reports that the package has a Go assembly file.\n+! go build cgoasm\n+stderr 'package using cgo has Go assembly file'\n+\n+-- go.mod --\n+module cgoasm\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+/*\n+// hi\n+*/\n+import \"C\"\n+\n+func F() {}\n+-- p.s --\n+TEXT asm(SB),$0\n+\tRET\n+"}, {"sha": "6bf3beb8e4f79e704364bc25406a3c4f929f84ce", "filename": "libgo/go/cmd/go/testdata/script/cgo_bad_directives.txt", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_bad_directives.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_bad_directives.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_bad_directives.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,129 @@\n+[!cgo] skip\n+[short] skip\n+\n+cp x.go.txt x.go\n+\n+# Only allow //go:cgo_ldflag .* in cgo-generated code\n+[gc] cp x_gc.go.txt x.go\n+[gc] ! go build x\n+[gc] stderr '//go:cgo_ldflag .* only allowed in cgo-generated code'\n+\n+# Ignore _* files\n+rm x.go\n+! go build .\n+stderr 'no Go files'\n+cp cgo_yy.go.txt _cgo_yy.go\n+! go build .\n+stderr 'no Go files' #_* files are ignored...\n+\n+[gc] ! go build _cgo_yy.go # ... but if forced, the comment is rejected\n+# Actually, today there is a separate issue that _ files named\n+# on the command line are ignored. Once that is fixed,\n+# we want to see the cgo_ldflag error.\n+[gc] stderr '//go:cgo_ldflag only allowed in cgo-generated code|no Go files'\n+\n+rm _cgo_yy.go\n+\n+# Reject #cgo CFLAGS: -fplugin=foo.so\n+cp x.go.txt x.go\n+cp y_fplugin.go.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: -fplugin=foo.so'\n+\n+# Reject #cgo CFLAGS: -lbar -fplugin=foo.so\n+cp y_lbar_fplugin.go.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: -fplugin=foo.so'\n+\n+# Reject #cgo pkg-config: -foo\n+cp y_pkgconfig_dash_foo.txt y.go\n+! go build x\n+stderr 'invalid pkg-config package name: -foo'\n+\n+# Reject #cgo pkg-config: @foo\n+cp y_pkgconfig_at_foo.txt y.go\n+! go build x\n+stderr 'invalid pkg-config package name: @foo'\n+\n+# Reject #cgo CFLAGS: @foo\n+cp y_cflags_at_foo.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: @foo'\n+\n+# Reject #cgo CFLAGS: -D\n+cp y_cflags_dash_d.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: -D without argument'\n+\n+# Note that -I @foo is allowed because we rewrite it into -I /path/to/src/@foo\n+# before the check is applied. There's no such rewrite for -D.\n+\n+# Reject #cgo CFLAGS: -D @foo\n+cp y_cflags_dash_d_space_at_foo.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: -D @foo'\n+\n+# Reject #cgo CFLAGS -D@foo\n+cp y_cflags_dash_d_at_foo.txt y.go\n+! go build x\n+stderr 'invalid flag in #cgo CFLAGS: -D@foo'\n+\n+# Check for CFLAGS in commands\n+env CGO_CFLAGS=-D@foo\n+cp y_no_cflags.txt y.go\n+go build -n x\n+stderr '-D@foo'\n+\n+-- go.mod --\n+module x\n+\n+go 1.16\n+-- x_gc.go.txt --\n+package x\n+\n+//go:cgo_ldflag \"-fplugin=foo.so\"\n+\n+import \"C\"\n+-- cgo_yy.go.txt --\n+package x\n+\n+//go:cgo_ldflag \"-fplugin=foo.so\"\n+\n+import \"C\"\n+-- x.go.txt --\n+package x\n+-- y_fplugin.go.txt --\n+package x\n+// #cgo CFLAGS: -fplugin=foo.so\n+import \"C\"\n+-- y_lbar_fplugin.go.txt --\n+package x\n+// #cgo CFLAGS: -Ibar -fplugin=foo.so\n+import \"C\"\n+-- y_pkgconfig_dash_foo.txt --\n+package x\n+// #cgo pkg-config: -foo\n+import \"C\"\n+-- y_pkgconfig_at_foo.txt --\n+package x\n+// #cgo pkg-config: @foo\n+import \"C\"\n+-- y_cflags_at_foo.txt --\n+package x\n+// #cgo CFLAGS: @foo\n+import \"C\"\n+-- y_cflags_dash_d.txt --\n+package x\n+// #cgo CFLAGS: -D\n+import \"C\"\n+-- y_cflags_dash_d_space_at_foo.txt --\n+package x\n+// #cgo CFLAGS: -D @foo\n+import \"C\"\n+-- y_cflags_dash_d_at_foo.txt --\n+package x\n+// #cgo CFLAGS: -D@foo\n+import \"C\"\n+-- y_no_cflags.txt --\n+package x\n+import \"C\""}, {"sha": "bd4777c821cd4a3bdc25177b7e5d3fab0348b2b7", "filename": "libgo/go/cmd/go/testdata/script/cgo_depends_on_syscall.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_depends_on_syscall.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_depends_on_syscall.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_depends_on_syscall.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,15 @@\n+[!cgo] skip\n+[!race] skip\n+\n+go list -race -deps foo\n+stdout syscall\n+\n+-- go.mod --\n+module foo\n+\n+go 1.16\n+-- foo.go --\n+package foo\n+\n+// #include <stdio.h>\n+import \"C\""}, {"sha": "a3372bbbc7672622704d58252d0751c0b30cf554", "filename": "libgo/go/cmd/go/testdata/script/cgo_flag_contains_space.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_flag_contains_space.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_flag_contains_space.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_flag_contains_space.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,16 @@\n+[short] skip\n+[!cgo] skip\n+\n+env GOCACHE=$WORK/gocache  # Looking for compile flags, so need a clean cache.\n+go build -x -n main.go\n+stderr '\"-I[^\"]+c flags\"' # find quoted c flags\n+! stderr '\"-I[^\"]+c flags\".*\"-I[^\"]+c flags\"' # don't find too many quoted c flags per line\n+stderr '\"-L[^\"]+ld flags\"' # find quoted ld flags\n+! stderr '\"-L[^\"]+c flags\".*\"-L[^\"]+c flags\"' # don't find too many quoted ld flags per line\n+\n+-- main.go --\n+package main\n+// #cgo CFLAGS: -I\"c flags\"\n+// #cgo LDFLAGS: -L\"ld flags\"\n+import \"C\"\n+func main() {}"}, {"sha": "be9609e86f0ddb364737d96408c997a4896bc7c9", "filename": "libgo/go/cmd/go/testdata/script/cgo_path.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,43 @@\n+[!cgo] skip\n+\n+# Set CC explicitly to something that requires a PATH lookup.\n+# Normally, the default is gcc or clang, but if CC was set during make.bash,\n+# that becomes the default.\n+[exec:clang] env CC=clang\n+[exec:gcc] env CC=gcc\n+[!exec:clang] [!exec:gcc] skip 'Unknown C compiler'\n+\n+env GOCACHE=$WORK/gocache  # Looking for compile flags, so need a clean cache.\n+[!windows] env PATH=.:$PATH\n+[!windows] chmod 0755 p/gcc p/clang\n+[!windows] exists -exec p/gcc p/clang\n+[windows] exists -exec p/gcc.bat p/clang.bat\n+! exists p/bug.txt\n+! go build -x\n+stderr '^cgo: exec (clang|gcc): (clang|gcc) resolves to executable relative to current directory \\(.[/\\\\](clang|gcc)(.bat)?\\)$'\n+! exists p/bug.txt\n+\n+-- go.mod --\n+module m\n+\n+-- m.go --\n+package m\n+\n+import _ \"m/p\"\n+\n+-- p/p.go --\n+package p\n+\n+// #define X 1\n+import \"C\"\n+\n+-- p/gcc --\n+#!/bin/sh\n+echo ran gcc >bug.txt\n+-- p/clang --\n+#!/bin/sh\n+echo ran clang >bug.txt\n+-- p/gcc.bat --\n+echo ran gcc >bug.txt\n+-- p/clang.bat --\n+echo ran clang >bug.txt"}, {"sha": "654295dc692d95d7a979be6cc5e815cbc7ec3dbe", "filename": "libgo/go/cmd/go/testdata/script/cgo_path_space.txt", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_path_space.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,56 @@\n+# Check that if the PATH directory containing the C compiler has a space,\n+# we can still use that compiler with cgo.\n+# Verifies #43808.\n+[!cgo] skip\n+\n+# Set CC explicitly to something that requires a PATH lookup.\n+# Normally, the default is gcc or clang, but if CC was set during make.bash,\n+# that becomes the default.\n+[exec:clang] env CC=clang\n+[exec:gcc] env CC=gcc\n+[!exec:clang] [!exec:gcc] skip 'Unknown C compiler'\n+\n+[!windows] chmod 0755 $WORK/'program files'/clang\n+[!windows] chmod 0755 $WORK/'program files'/gcc\n+[!windows] exists -exec $WORK/'program files'/clang\n+[!windows] exists -exec $WORK/'program files'/gcc\n+[!windows] env PATH=$WORK/'program files':$PATH\n+[windows] exists -exec $WORK/'program files'/gcc.bat\n+[windows] exists -exec $WORK/'program files'/clang.bat\n+[windows] env PATH=$WORK\\'program files';%PATH%\n+\n+! exists $WORK/log.txt\n+? go build -x\n+exists $WORK/log.txt\n+rm $WORK/log.txt\n+\n+# TODO(#41400, #43078): when CC is set explicitly, it should be allowed to\n+# contain spaces separating arguments, and it should be possible to quote\n+# arguments with spaces (including the path), as in CGO_CFLAGS and other\n+# variables. For now, this doesn't work.\n+[!windows] env CC=$WORK/'program files'/gcc\n+[windows] env CC=$WORK\\'program files'\\gcc.bat\n+! go build -x\n+! exists $WORK/log.txt\n+\n+-- go.mod --\n+module m\n+\n+-- m.go --\n+package m\n+\n+// #define X 1\n+import \"C\"\n+\n+-- $WORK/program files/gcc --\n+#!/bin/sh\n+\n+echo ok >$WORK/log.txt\n+-- $WORK/program files/clang --\n+#!/bin/sh\n+\n+echo ok >$WORK/log.txt\n+-- $WORK/program files/gcc.bat --\n+echo ok >%WORK%\\log.txt\n+-- $WORK/program files/clang.bat --\n+echo ok >%WORK%\\log.txt"}, {"sha": "9e46855eadb1e687458cbb035705a76324185a86", "filename": "libgo/go/cmd/go/testdata/script/cgo_stale.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_stale.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,39 @@\n+# golang.org/issue/46347: a stale runtime/cgo should only force a single rebuild\n+\n+[!cgo] skip\n+[short] skip\n+\n+\n+# If we set a unique CGO_CFLAGS, the installed copy of runtime/cgo\n+# should be reported as stale.\n+\n+env CGO_CFLAGS=-DTestScript_cgo_stale=true\n+stale runtime/cgo\n+\n+\n+# If we then build a package that uses cgo, runtime/cgo should be rebuilt and\n+# cached with the new flag, but not installed to GOROOT (and thus still stale).\n+\n+env GOCACHE=$WORK/cache  # Use a fresh cache to avoid interference between runs.\n+\n+go build -x .\n+stderr '[/\\\\]cgo'$GOEXE'[\"]? .* -importpath runtime/cgo'\n+stale runtime/cgo\n+\n+\n+# After runtime/cgo has been rebuilt and cached, it should not be rebuilt again\n+# even though it is still reported as stale.\n+\n+go build -x .\n+! stderr '[/\\\\]cgo'$GOEXE'[\"]? .* -importpath runtime/cgo'\n+stale runtime/cgo\n+\n+\n+-- go.mod --\n+module example.com/m\n+\n+go 1.17\n+-- m.go --\n+package m\n+\n+import \"C\""}, {"sha": "7335f8a4c78aa9fe6960a1fe99615cceb875f109", "filename": "libgo/go/cmd/go/testdata/script/clean_binary.txt", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_binary.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_binary.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_binary.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,78 @@\n+# Build something to create the executable, including several cases\n+[short] skip\n+\n+# --------------------- clean executables -------------------------\n+\n+# case1: test file-named executable 'main'\n+env GO111MODULE=on\n+\n+! exists main$GOEXE\n+go build main.go\n+exists -exec main$GOEXE\n+go clean\n+! exists main$GOEXE\n+\n+# case2: test module-named executable 'a.b.c'\n+! exists a.b.c$GOEXE\n+go build\n+exists -exec a.b.c$GOEXE\n+go clean\n+! exists a.b.c$GOEXE\n+\n+# case3: directory-named executable 'src'\n+env GO111MODULE=off\n+\n+! exists src$GOEXE\n+go build\n+exists -exec src$GOEXE\n+go clean\n+! exists src$GOEXE\n+\n+# --------------------- clean test files -------------------------\n+\n+# case1: test file-named test file\n+env GO111MODULE=on\n+\n+! exists main.test$GOEXE\n+go test -c main_test.go\n+exists -exec main.test$GOEXE\n+go clean\n+! exists main.test$GOEXE\n+\n+# case2: test module-named test file\n+! exists a.b.c.test$GOEXE\n+go test -c\n+exists -exec a.b.c.test$GOEXE\n+go clean\n+! exists a.b.c.test$GOEXE\n+\n+# case3: test directory-based test file\n+env GO111MODULE=off\n+\n+! exists src.test$GOEXE\n+go test -c\n+exists -exec src.test$GOEXE\n+go clean\n+! exists src.test$GOEXE\n+\n+-- main.go --\n+package main\n+\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(\"hello!\")\n+}\n+\n+-- main_test.go --\n+package main\n+\n+import \"testing\"\n+\n+func TestSomething(t *testing.T) {\n+}\n+\n+-- go.mod --\n+module example.com/a.b.c/v2\n+\n+go 1.12\n\\ No newline at end of file"}, {"sha": "4497b36bc3d83e698174b884deb3aed33431af32", "filename": "libgo/go/cmd/go/testdata/script/clean_cache_n.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_cache_n.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_cache_n.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_cache_n.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,25 @@\n+# We're testing cache behavior, so start with a clean GOCACHE.\n+env GOCACHE=$WORK/cache\n+\n+# Build something so that the cache gets populates\n+go build main.go\n+\n+# Check that cache contains directories before running\n+exists $GOCACHE/00\n+\n+# Run go clean -cache -n and ensure that directories weren't deleted\n+go clean -cache -n\n+exists $GOCACHE/00\n+\n+# Re-run go clean cache without the -n flag go ensure that directories were properly removed\n+go clean -cache\n+! exists $GOCACHE/00\n+\n+-- main.go --\n+package main\n+\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(\"hello!\")\n+}"}, {"sha": "57f76d6c02890ebfba0202e2c8a08a690c20bdd8", "filename": "libgo/go/cmd/go/testdata/script/cover_asm.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_asm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_asm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_asm.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,33 @@\n+[short] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+# Test cover for a package that has an assembly function.\n+\n+go test -outputdir=$WORK -coverprofile=cover.out coverasm\n+go tool cover -func=$WORK/cover.out\n+stdout '\\tg\\t*100.0%' # Check g is 100% covered.\n+! stdout '\\tf\\t*[0-9]' # Check for no coverage on the assembly function\n+\n+-- go.mod --\n+module coverasm\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+func f()\n+\n+func g() {\n+\tprintln(\"g\")\n+}\n+-- p.s --\n+// empty asm file,\n+// so go test doesn't complain about declaration of f in p.go.\n+-- p_test.go --\n+package p\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+\tg()\n+}"}, {"sha": "e7d5250468cd01e8444338f7add92ea39825f100", "filename": "libgo/go/cmd/go/testdata/script/cover_blank_func_decl.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_blank_func_decl.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_blank_func_decl.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_blank_func_decl.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,35 @@\n+[short] skip\n+go test -cover coverblank\n+stdout 'coverage: 100.0% of statements'\n+\n+\n+-- go.mod --\n+module coverblank\n+\n+go 1.16\n+-- a.go --\n+package coverblank\n+\n+func _() {\n+\tprintln(\"unreachable\")\n+}\n+\n+type X int\n+\n+func (x X) Print() {\n+\tprintln(x)\n+}\n+\n+func (x X) _() {\n+\tprintln(\"unreachable\")\n+}\n+\n+-- a_test.go --\n+package coverblank\n+\n+import \"testing\"\n+\n+func TestX(t *testing.T) {\n+\tvar x X\n+\tx.Print()\n+}"}, {"sha": "9cf78f71e9fac21484fc1bb1ef68e40fc99c4c45", "filename": "libgo/go/cmd/go/testdata/script/cover_cgo.txt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,42 @@\n+[short] skip\n+[!cgo] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+# Test coverage on cgo code.\n+\n+go test -short -cover cgocover\n+stdout  'coverage:.*[1-9][0-9.]+%'\n+! stderr '[^0-9]0\\.0%'\n+\n+-- go.mod --\n+module cgocover\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}\n+-- p_test.go --\n+package p\n+\n+import \"testing\"\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "c53b979f9fcfaee7ec85d67b53ce5647be994eb9", "filename": "libgo/go/cmd/go/testdata/script/cover_cgo_extra_file.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_file.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_file.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_file.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,48 @@\n+[short] skip\n+[!cgo] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+# Test coverage on cgo code. This test case includes an\n+# extra empty non-cgo file in the package being checked.\n+\n+go test -short -cover cgocover4\n+stdout  'coverage:.*[1-9][0-9.]+%'\n+! stderr '[^0-9]0\\.0%'\n+\n+-- go.mod --\n+module cgocover4\n+\n+go 1.16\n+-- notcgo.go --\n+package p\n+-- p.go --\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}\n+-- x_test.go --\n+package p_test\n+\n+import (\n+\t. \"cgocover4\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "b501ab02a557ffed85919d43d73c42192a3b2162", "filename": "libgo/go/cmd/go/testdata/script/cover_cgo_extra_test.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_extra_test.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,49 @@\n+[short] skip\n+[!cgo] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+# Test coverage on cgo code. This test case has an external\n+# test that tests the code and an in-package test file with\n+# no test cases.\n+\n+go test -short -cover cgocover3\n+stdout  'coverage:.*[1-9][0-9.]+%'\n+! stderr '[^0-9]0\\.0%'\n+\n+-- go.mod --\n+module cgocover3\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}\n+-- p_test.go --\n+package p\n+-- x_test.go --\n+package p_test\n+\n+import (\n+\t. \"cgocover3\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "79cc08c4811a65a8699eb5949d5bf422b2ef81b4", "filename": "libgo/go/cmd/go/testdata/script/cover_cgo_xtest.txt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_xtest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_xtest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_cgo_xtest.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,45 @@\n+[short] skip\n+[!cgo] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+# Test cgo coverage with an external test.\n+\n+go test -short -cover cgocover2\n+stdout  'coverage:.*[1-9][0-9.]+%'\n+! stderr '[^0-9]0\\.0%'\n+\n+-- go.mod --\n+module cgocover2\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+/*\n+void\n+f(void)\n+{\n+}\n+*/\n+import \"C\"\n+\n+var b bool\n+\n+func F() {\n+\tif b {\n+\t\tfor {\n+\t\t}\n+\t}\n+\tC.f()\n+}\n+-- x_test.go --\n+package p_test\n+\n+import (\n+\t. \"cgocover2\"\n+\t\"testing\"\n+)\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}"}, {"sha": "8950f8d088e747e13de82f0dce86a630217eab48", "filename": "libgo/go/cmd/go/testdata/script/cover_dash_c.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dash_c.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dash_c.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dash_c.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,31 @@\n+[short] skip\n+[gccgo] skip\n+\n+# Test for issue 24588\n+\n+go test -c -o $WORK/coverdep -coverprofile=$WORK/no/such/dir/cover.out coverdep\n+exists -exec $WORK/coverdep\n+\n+-- go.mod --\n+module coverdep\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+import _ \"coverdep/p1\"\n+\n+func F() {\n+}\n+-- p1/p1.go --\n+package p1\n+\n+import _ \"errors\"\n+-- p_test.go --\n+package p\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+\tF()\n+}"}, {"sha": "36ea6e00b3ef92654667ba19a1d08d1ab160a24a", "filename": "libgo/go/cmd/go/testdata/script/cover_dep_loop.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dep_loop.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dep_loop.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dep_loop.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,36 @@\n+[short] skip\n+[gccgo] skip\n+\n+# coverdep2/p1's xtest imports coverdep2/p2 which imports coverdep2/p1.\n+# Make sure that coverage on coverdep2/p2 recompiles coverdep2/p2.\n+\n+go test -short -cover coverdep2/p1\n+stdout 'coverage: 100.0% of statements' # expect 100.0% coverage\n+\n+-- go.mod --\n+module coverdep2\n+\n+go 1.16\n+-- p1/p.go --\n+package p1\n+\n+func F() int { return 1 }\n+-- p1/p_test.go --\n+package p1_test\n+\n+import (\n+\t\"coverdep2/p2\"\n+\t\"testing\"\n+)\n+\n+func Test(t *testing.T) {\n+\tp2.F()\n+}\n+-- p2/p2.go --\n+package p2\n+\n+import \"coverdep2/p1\"\n+\n+func F() {\n+\tp1.F()\n+}"}, {"sha": "d492e42e2a9265f66a6a96a4698b231d39032760", "filename": "libgo/go/cmd/go/testdata/script/cover_dot_import.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dot_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dot_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_dot_import.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,29 @@\n+[short] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+go test -coverpkg=coverdot/a,coverdot/b coverdot/b\n+! stderr '[^0-9]0\\.0%'\n+! stdout '[^0-9]0\\.0%'\n+\n+-- go.mod --\n+module coverdot\n+\n+go 1.16\n+-- a/a.go --\n+package a\n+\n+func F() {}\n+-- b/b.go --\n+package b\n+\n+import . \"coverdot/a\"\n+\n+func G() { F() }\n+-- b/b_test.go --\n+package b\n+\n+import \"testing\"\n+\n+func TestG(t *testing.T) {\n+\tG()\n+}"}, {"sha": "583a664237b007df5bf52c26a8af0e2186b5fff2", "filename": "libgo/go/cmd/go/testdata/script/cover_error.txt", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_error.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,74 @@\n+[short] skip\n+[gccgo] skip\n+\n+# Test line numbers in cover errors.\n+\n+# Get errors from a go test into stderr.txt\n+! go test coverbad\n+stderr 'p\\.go:4' # look for error at coverbad/p.go:4\n+[cgo] stderr 'p1\\.go:6' # look for error at coverbad/p.go:6\n+! stderr $WORK # make sure temporary directory isn't in error\n+\n+cp stderr $WORK/stderr.txt\n+\n+# Clean out character positions from stderr.txt\n+# It's OK that stderr2 drops the character position in the error,\n+# because of the //line directive (see golang.org/issue/22662).\n+go run clean_charpos.go $WORK/stderr.txt &\n+\n+# Get errors from coverage into stderr2.txt\n+! go test -cover coverbad\n+cp stderr $WORK/stderr2.txt\n+\n+wait # for go run above\n+\n+cmp $WORK/stderr.txt $WORK/stderr2.txt\n+\n+-- go.mod --\n+module coverbad\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+func f() {\n+\tg()\n+}\n+-- p1.go --\n+package p\n+\n+import \"C\"\n+\n+func h() {\n+\tj()\n+}\n+-- p_test.go --\n+package p\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {}\n+-- clean_charpos.go --\n+// +build ignore\n+\n+package main\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+func main() {\n+\tlog.SetFlags(0)\n+\tb, err := os.ReadFile(os.Args[1])\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\ts := strings.ReplaceAll(string(b), \"p.go:4:2:\", \"p.go:4:\")\n+\ts = strings.ReplaceAll(s, \"p1.go:6:2:\", \"p1.go:6:\")\n+\tos.WriteFile(os.Args[1], []byte(s), 0644)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "eb6de6778a9bf35e98ba7be6320270644b04610c", "filename": "libgo/go/cmd/go/testdata/script/cover_import_main_loop.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_import_main_loop.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_import_main_loop.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_import_main_loop.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,26 @@\n+[gccgo] skip # gccgo has no cover tool\n+\n+! go test -n importmain/test\n+stderr 'not an importable package' # check that import main was detected\n+! go test -n -cover importmain/test\n+stderr 'not an importable package' # check that import main was detected\n+\n+-- go.mod --\n+module importmain\n+\n+go 1.16\n+-- ismain/main.go --\n+package main\n+\n+import _ \"importmain/test\"\n+\n+func main() {}\n+-- test/test.go --\n+package test\n+-- test/test_test.go --\n+package test_test\n+\n+import \"testing\"\n+import _ \"importmain/ismain\"\n+\n+func TestCase(t *testing.T) {}"}, {"sha": "ec0850c00374529a3babf7a018395a6f56ab5a53", "filename": "libgo/go/cmd/go/testdata/script/cover_pattern.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pattern.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pattern.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pattern.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,41 @@\n+[gccgo] skip\n+\n+# If coverpkg=m/sleepy... expands by package loading\n+# (as opposed to pattern matching on deps)\n+# then it will try to load sleepybad, which does not compile,\n+# and the test command will fail.\n+! go list m/sleepy...\n+go test -c -n -coverprofile=$TMPDIR/cover.out -coverpkg=m/sleepy... -run=^$ m/sleepy1\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- sleepy1/p_test.go --\n+package p\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func Test1(t *testing.T) {\n+\ttime.Sleep(200 * time.Millisecond)\n+}\n+-- sleepy2/p_test.go --\n+package p\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func Test1(t *testing.T) {\n+\ttime.Sleep(200 * time.Millisecond)\n+}\n+-- sleepybad/p.go --\n+package p\n+\n+import ^\n+\n+var _ = io.DoesNotExist"}, {"sha": "4e51726b29c4db2ea7c740ba2a5176e94eedaeb5", "filename": "libgo/go/cmd/go/testdata/script/cover_pkgall_imports.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_imports.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,48 @@\n+# This test checks that -coverpkg=all can be used\n+# when the package pattern includes packages\n+# which only have tests.\n+# Verifies golang.org/issue/27333, golang.org/issue/43242.\n+\n+[short] skip\n+cd $GOPATH/src/example.com/cov\n+\n+env GO111MODULE=on\n+go test -coverpkg=all ./...\n+\n+env GO111MODULE=off\n+go test -coverpkg=all ./...\n+\n+-- $GOPATH/src/example.com/cov/go.mod --\n+module example.com/cov\n+\n+-- $GOPATH/src/example.com/cov/notest/notest.go --\n+package notest\n+\n+func Foo() {}\n+\n+-- $GOPATH/src/example.com/cov/onlytest/onlytest_test.go --\n+package onlytest_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"example.com/cov/notest\"\n+)\n+\n+func TestFoo(t *testing.T) {\n+\tnotest.Foo()\n+}\n+\n+-- $GOPATH/src/example.com/cov/withtest/withtest.go --\n+package withtest\n+\n+func Bar() {}\n+\n+-- $GOPATH/src/example.com/cov/withtest/withtest_test.go --\n+package withtest\n+\n+import \"testing\"\n+\n+func TestBar(t *testing.T) {\n+\tBar()\n+}"}, {"sha": "38a7bb77a56059517b32cbbd1c163242841c9bc4", "filename": "libgo/go/cmd/go/testdata/script/cover_runs.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_runs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_runs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_runs.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,13 @@\n+[gccgo] skip 'gccgo has no cover tool'\n+[short] skip\n+\n+go test -short -coverpkg=strings strings regexp\n+! stdout '[^0-9]0\\.0%'\n+stdout  'strings.*coverage:.*[1-9][0-9.]+%'\n+stdout  'regexp.*coverage:.*[1-9][0-9.]+%'\n+\n+go test -short -cover strings math regexp\n+! stdout '[^0-9]0\\.0%'\n+stdout  'strings.*coverage:.*[1-9][0-9.]+%'\n+stdout  'math.*coverage:.*[1-9][0-9.]+%'\n+stdout  'regexp.*coverage:.*[1-9][0-9.]+%'\n\\ No newline at end of file"}, {"sha": "4f3c9ca2f270143dfd40fea5760921793a859766", "filename": "libgo/go/cmd/go/testdata/script/cover_statements.txt", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_statements.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_statements.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_statements.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,61 @@\n+[short] skip\n+go test -cover ./pkg1 ./pkg2 ./pkg3 ./pkg4\n+stdout 'pkg1\t\\[no test files\\]'\n+stdout 'pkg2\t\\S+\tcoverage: 0.0% of statements \\[no tests to run\\]'\n+stdout 'pkg3\t\\S+\tcoverage: 100.0% of statements'\n+stdout 'pkg4\t\\S+\tcoverage: \\[no statements\\]'\n+\n+-- go.mod --\n+module m\n+\n+go 1.16\n+-- pkg1/a.go --\n+package pkg1\n+\n+import \"fmt\"\n+\n+func F() {\n+\tfmt.Println(\"pkg1\")\n+}\n+-- pkg2/a.go --\n+package pkg2\n+\n+import \"fmt\"\n+\n+func F() {\n+\tfmt.Println(\"pkg2\")\n+}\n+-- pkg2/a_test.go --\n+package pkg2\n+-- pkg3/a.go --\n+package pkg3\n+\n+import \"fmt\"\n+\n+func F() {\n+\tfmt.Println(\"pkg3\")\n+}\n+-- pkg3/a_test.go --\n+package pkg3\n+\n+import \"testing\"\n+\n+func TestF(t *testing.T) {\n+\tF()\n+}\n+-- pkg4/a.go --\n+package pkg4\n+\n+type T struct {\n+\tX bool\n+}\n+-- pkg4/a_test.go --\n+package pkg4\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestT(t *testing.T) {\n+\t_ = T{}\n+}"}, {"sha": "433af9ab738177aa8967f5ed8561c1bc00836e15", "filename": "libgo/go/cmd/go/testdata/script/cover_sync_atomic_import.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_sync_atomic_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_sync_atomic_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_sync_atomic_import.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813", "patch": "@@ -0,0 +1,28 @@\n+[short] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+go test -short -cover -covermode=atomic -coverpkg=coverdep/p1 coverdep\n+\n+-- go.mod --\n+module coverdep\n+\n+go 1.16\n+-- p.go --\n+package p\n+\n+import _ \"coverdep/p1\"\n+\n+func F() {\n+}\n+-- p1/p1.go --\n+package p1\n+\n+import _ \"errors\"\n+-- p_test.go --\n+package p\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {\n+\tF()\n+}"}, {"sha": "670308c6df2ee0b9407e104520d10251d7db7a96", "filename": "libgo/go/cmd/go/testdata/script/doc.txt", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdoc.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdoc.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdoc.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "04b17cd62b385999188cfa7e6795496bbddd0c50", "filename": "libgo/go/cmd/go/testdata/script/embed.txt", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "8a16afea8a0946cadc92290a66c4a354fdbb38c8", "filename": "libgo/go/cmd/go/testdata/script/embed_fmt.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed_fmt.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed_fmt.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fembed_fmt.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "06432826fe746ccf5f6c91014924d466fcbfbc3a", "filename": "libgo/go/cmd/go/testdata/script/env_cross_build.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_cross_build.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_cross_build.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_cross_build.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "681512d87c612181a81d2f7f152e98b39115112c", "filename": "libgo/go/cmd/go/testdata/script/env_exp.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_exp.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_exp.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_exp.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "647f26525ddcd0fe2dff1fe2369f05d415153953", "filename": "libgo/go/cmd/go/testdata/script/env_unset.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_unset.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "7920fbaceff90ddb2964f06398919d494f1933f2", "filename": "libgo/go/cmd/go/testdata/script/env_write.txt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "84bf41cfbafacd175597b77c26b9525e8f4c6e03", "filename": "libgo/go/cmd/go/testdata/script/fmt_load_errors.txt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "db2a29128b2dd1d1923373c67fb4ebb60c046158", "filename": "libgo/go/cmd/go/testdata/script/gccgo_link_c.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_link_c.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_link_c.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_link_c.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "73f5bbd57a91d35177b5ccaed75e0d1496cebffe", "filename": "libgo/go/cmd/go/testdata/script/generate.txt", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "4d31573d5643a0ea48f9488dbf8c1c4aa4a9c759", "filename": "libgo/go/cmd/go/testdata/script/generate_bad_imports.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_bad_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_bad_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_bad_imports.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "2df16633765fa92d3543d581c9094488bbcd8491", "filename": "libgo/go/cmd/go/testdata/script/generate_env.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_env.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_env.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_env.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "e18e62ccf34fa8877beac479f1998b0916438637", "filename": "libgo/go/cmd/go/testdata/script/generate_invalid.txt", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_invalid.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_invalid.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgenerate_invalid.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "ec4f8d32432179bc97c5fe9fccb56d1527c664e3", "filename": "libgo/go/cmd/go/testdata/script/get_404_meta.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "cda25e12b0e6ea0a2f3ef7a0165fcfca5e8b7df0", "filename": "libgo/go/cmd/go/testdata/script/get_custom_domain_wildcard.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_custom_domain_wildcard.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_custom_domain_wildcard.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_custom_domain_wildcard.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "baac91686868a66a83d51d206993a7df8ca728cb", "filename": "libgo/go/cmd/go/testdata/script/get_dash_t.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dash_t.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dash_t.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dash_t.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "918784869b312a10b2f0535f2eff8b12a3c7fcb0", "filename": "libgo/go/cmd/go/testdata/script/get_domain_root.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_domain_root.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_domain_root.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_domain_root.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "dbaf46ced363df24a3771014225cd42948878a54", "filename": "libgo/go/cmd/go/testdata/script/get_dot_slash_download.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dot_slash_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dot_slash_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dot_slash_download.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "bed872098769249e851a30ac13a4957c83aed913", "filename": "libgo/go/cmd/go/testdata/script/get_go_file.txt", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_go_file.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "929435ad70c1036d6a2ab2137a2b529589d20bd2", "filename": "libgo/go/cmd/go/testdata/script/get_goroot.txt", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_goroot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_goroot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_goroot.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "69930f7107a58b9ddeb4729b313ccb8cc999969e", "filename": "libgo/go/cmd/go/testdata/script/get_insecure.txt", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "7eba42e873e011a8c7d479e53a2e04e360bbf20e", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_custom_domain.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_custom_domain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_custom_domain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_custom_domain.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "8d88427c319d22d7990e8664279e39b9f9b178ca", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_env.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_env.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_env.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_env.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "2517664dd02308901fe338e5daac43a73c16b306", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_no_longer_supported.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_no_longer_supported.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "fb5f26951cdad9dfdd72f67775db707149f7e9a4", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_redirect.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "e1a1a23d47e475a34927e55bd570389a0b27dc09", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_update.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_update.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_update.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_update.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "ff20d4ba04e64c804c5e707eea85a6e6a5836d69", "filename": "libgo/go/cmd/go/testdata/script/get_internal_wildcard.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_internal_wildcard.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_internal_wildcard.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_internal_wildcard.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}, {"sha": "9d6b7dde0196653caa333d7dcd48162a7bca32d9", "filename": "libgo/go/cmd/go/testdata/script/get_issue11307.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_issue11307.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5b21c3f4c17b0649155035d2f9aa97b2da8a813/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_issue11307.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_issue11307.txt?ref=c5b21c3f4c17b0649155035d2f9aa97b2da8a813"}]}