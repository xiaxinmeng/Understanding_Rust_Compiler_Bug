{"sha": "4001cd8939ccd018fe0952dc98cdd8fc08607842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwMWNkODkzOWNjZDAxOGZlMDk1MmRjOThjZGQ4ZmMwODYwNzg0Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-06-14T22:29:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-06-14T22:29:03Z"}, "message": "mips.c (machine_function): Add varargs_size field.\n\n\t* config/mips/mips.c (machine_function): Add varargs_size field.\n\t(mips_setup_incoming_varargs): Store the amount of extra stack space\n\tthere rather than in *pretend_size.  When saving registers, always\n\texpect virtual_incoming_args_rtx to point to the start of the\n\tpretend arguments.\n\t(mips_va_start): Remove alignment hack.  Handle all\n\t!EABI_FLOAT_VARARGS_P cases in the same way.\n\t(compute_frame_size): Handle varargs_size.  Remove the redundant\n\t!TARGET_OLDABI condition in the handling of pretend_args_size.\n\t(mips_initial_elimination_offset): Remove the now-redundant check\n\tof TARGET_NEWABI.\n\nFrom-SVN: r100956", "tree": {"sha": "9e0bc0056bdb4e048917dda0db981d984de6fb9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e0bc0056bdb4e048917dda0db981d984de6fb9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4001cd8939ccd018fe0952dc98cdd8fc08607842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4001cd8939ccd018fe0952dc98cdd8fc08607842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4001cd8939ccd018fe0952dc98cdd8fc08607842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4001cd8939ccd018fe0952dc98cdd8fc08607842/comments", "author": null, "committer": null, "parents": [{"sha": "727f302ea131fbea681450550198717753e09ccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727f302ea131fbea681450550198717753e09ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/727f302ea131fbea681450550198717753e09ccf"}], "stats": {"total": 216, "additions": 101, "deletions": 115}, "files": [{"sha": "ae7f2af3beb349dac9b419f44cb971c2c2e772e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001cd8939ccd018fe0952dc98cdd8fc08607842/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001cd8939ccd018fe0952dc98cdd8fc08607842/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4001cd8939ccd018fe0952dc98cdd8fc08607842", "patch": "@@ -1,3 +1,17 @@\n+2005-06-14  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips.c (machine_function): Add varargs_size field.\n+\t(mips_setup_incoming_varargs): Store the amount of extra stack space\n+\tthere rather than in *pretend_size.  When saving registers, always\n+\texpect virtual_incoming_args_rtx to point to the start of the\n+\tpretend arguments.\n+\t(mips_va_start): Remove alignment hack.  Handle all\n+\t!EABI_FLOAT_VARARGS_P cases in the same way.\n+\t(compute_frame_size): Handle varargs_size.  Remove the redundant\n+\t!TARGET_OLDABI condition in the handling of pretend_args_size.\n+\t(mips_initial_elimination_offset): Remove the now-redundant check\n+\tof TARGET_NEWABI.\n+\n 2005-06-14  Jeff Law  <law@redhat.com>\n \n \t* tree-vrp.c (local_fold): Remove."}, {"sha": "8680fa7eb33a8125c8175f8725f4509fe0a1d367", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 87, "deletions": 115, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4001cd8939ccd018fe0952dc98cdd8fc08607842/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4001cd8939ccd018fe0952dc98cdd8fc08607842/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4001cd8939ccd018fe0952dc98cdd8fc08607842", "patch": "@@ -397,6 +397,10 @@ struct machine_function GTY(()) {\n      refers to GP relative global variables.  */\n   rtx mips16_gp_pseudo_rtx;\n \n+  /* The number of extra stack bytes taken up by register varargs.\n+     This area is allocated by the callee at the very top of the frame.  */\n+  int varargs_size;\n+\n   /* Current frame information, calculated by compute_frame_size.  */\n   struct mips_frame_info frame;\n \n@@ -3753,7 +3757,8 @@ mips_pad_reg_upward (enum machine_mode mode, tree type)\n \f\n static void\n mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t     tree type, int *pretend_size, int no_rtl)\n+\t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n+\t\t\t     int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum;\n   int gp_saved, fp_saved;\n@@ -3777,18 +3782,9 @@ mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t{\n \t  rtx ptr, mem;\n \n-\t  ptr = virtual_incoming_args_rtx;\n-\t  switch (mips_abi)\n-\t    {\n-\t    case ABI_32:\n-\t    case ABI_O64:\n-\t      ptr = plus_constant (ptr, local_cum.num_gprs * UNITS_PER_WORD);\n-\t      break;\n-\n-\t    case ABI_EABI:\n-\t      ptr = plus_constant (ptr, -gp_saved * UNITS_PER_WORD);\n-\t      break;\n-\t    }\n+\t  ptr = plus_constant (virtual_incoming_args_rtx,\n+\t\t\t       REG_PARM_STACK_SPACE (cfun->decl)\n+\t\t\t       - gp_saved * UNITS_PER_WORD);\n \t  mem = gen_rtx_MEM (BLKmode, ptr);\n \t  set_mem_alias_set (mem, get_varargs_alias_set ());\n \n@@ -3823,14 +3819,9 @@ mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    }\n \t}\n     }\n-  if (TARGET_OLDABI)\n-    {\n-      /* No need for pretend arguments: the register parameter area was\n-\t allocated by the caller.  */\n-      *pretend_size = 0;\n-      return;\n-    }\n-  *pretend_size = (gp_saved * UNITS_PER_WORD) + (fp_saved * UNITS_PER_FPREG);\n+  if (REG_PARM_STACK_SPACE (cfun->decl) == 0)\n+    cfun->machine->varargs_size = (gp_saved * UNITS_PER_WORD\n+\t\t\t\t   + fp_saved * UNITS_PER_FPREG);\n }\n \n /* Create the va_list data type.\n@@ -3910,101 +3901,84 @@ mips_build_builtin_va_list (void)\n void\n mips_va_start (tree valist, rtx nextarg)\n {\n-  const CUMULATIVE_ARGS *cum = &current_function_args_info;\n-\n-  /* ARG_POINTER_REGNUM is initialized to STACK_POINTER_BOUNDARY, but\n-     since the stack is aligned for a pair of argument-passing slots,\n-     and the beginning of a variable argument list may be an odd slot,\n-     we have to decrease its alignment.  */\n-  if (cfun && cfun->emit->regno_pointer_align)\n-    while (((current_function_pretend_args_size * BITS_PER_UNIT)\n-\t    & (REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) - 1)) != 0)\n-      REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) /= 2;\n-\n-  if (mips_abi == ABI_EABI)\n+  if (EABI_FLOAT_VARARGS_P)\n     {\n+      const CUMULATIVE_ARGS *cum;\n+      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n+      tree ovfl, gtop, ftop, goff, foff;\n+      tree t;\n       int gpr_save_area_size;\n+      int fpr_save_area_size;\n+      int fpr_offset;\n \n+      cum = &current_function_args_info;\n       gpr_save_area_size\n \t= (MAX_ARGS_IN_REGISTERS - cum->num_gprs) * UNITS_PER_WORD;\n+      fpr_save_area_size\n+\t= (MAX_ARGS_IN_REGISTERS - cum->num_fprs) * UNITS_PER_FPREG;\n \n-      if (EABI_FLOAT_VARARGS_P)\n-\t{\n-\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n-\t  tree ovfl, gtop, ftop, goff, foff;\n-\t  tree t;\n-\t  int fpr_offset;\n-\t  int fpr_save_area_size;\n-\n-\t  f_ovfl = TYPE_FIELDS (va_list_type_node);\n-\t  f_gtop = TREE_CHAIN (f_ovfl);\n-\t  f_ftop = TREE_CHAIN (f_gtop);\n-\t  f_goff = TREE_CHAIN (f_ftop);\n-\t  f_foff = TREE_CHAIN (f_goff);\n-\n-\t  ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n-\t\t\tNULL_TREE);\n-\t  gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n-\t\t\tNULL_TREE);\n-\t  ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n-\t\t\tNULL_TREE);\n-\t  goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n-\t\t\tNULL_TREE);\n-\t  foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n-\t\t\tNULL_TREE);\n-\n-\t  /* Emit code to initialize OVFL, which points to the next varargs\n-\t     stack argument.  CUM->STACK_WORDS gives the number of stack\n-\t     words used by named arguments.  */\n-\t  t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n-\t  if (cum->stack_words > 0)\n-\t    t = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n-\t\t       build_int_cst (NULL_TREE,\n-\t\t\t\t      cum->stack_words * UNITS_PER_WORD));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n- \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* Emit code to initialize GTOP, the top of the GPR save area.  */\n-\t  t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n- \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* Emit code to initialize FTOP, the top of the FPR save area.\n-\t     This address is gpr_save_area_bytes below GTOP, rounded\n-\t     down to the next fp-aligned boundary.  */\n-\t  t = make_tree (TREE_TYPE (ftop), virtual_incoming_args_rtx);\n-\t  fpr_offset = gpr_save_area_size + UNITS_PER_FPVALUE - 1;\n-\t  fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n-\t  if (fpr_offset)\n-\t    t = build (PLUS_EXPR, TREE_TYPE (ftop), t,\n-\t\t       build_int_cst (NULL_TREE, -fpr_offset));\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* Emit code to initialize GOFF, the offset from GTOP of the\n-\t     next GPR argument.  */\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n-\t\t     build_int_cst (NULL_TREE, gpr_save_area_size));\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-\t  /* Likewise emit code to initialize FOFF, the offset from FTOP\n-\t     of the next FPR argument.  */\n-\t  fpr_save_area_size\n-\t    = (MAX_ARGS_IN_REGISTERS - cum->num_fprs) * UNITS_PER_FPREG;\n-\t  t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n-\t\t     build_int_cst (NULL_TREE, fpr_save_area_size));\n-\t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t}\n-      else\n-\t{\n-\t  /* Everything is in the GPR save area, or in the overflow\n-\t     area which is contiguous with it.  */\n-\t  nextarg = plus_constant (nextarg, -gpr_save_area_size);\n-\t  std_expand_builtin_va_start (valist, nextarg);\n-\t}\n+      f_ovfl = TYPE_FIELDS (va_list_type_node);\n+      f_gtop = TREE_CHAIN (f_ovfl);\n+      f_ftop = TREE_CHAIN (f_gtop);\n+      f_goff = TREE_CHAIN (f_ftop);\n+      f_foff = TREE_CHAIN (f_goff);\n+\n+      ovfl = build (COMPONENT_REF, TREE_TYPE (f_ovfl), valist, f_ovfl,\n+\t\t    NULL_TREE);\n+      gtop = build (COMPONENT_REF, TREE_TYPE (f_gtop), valist, f_gtop,\n+\t\t    NULL_TREE);\n+      ftop = build (COMPONENT_REF, TREE_TYPE (f_ftop), valist, f_ftop,\n+\t\t    NULL_TREE);\n+      goff = build (COMPONENT_REF, TREE_TYPE (f_goff), valist, f_goff,\n+\t\t    NULL_TREE);\n+      foff = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff,\n+\t\t    NULL_TREE);\n+\n+      /* Emit code to initialize OVFL, which points to the next varargs\n+\t stack argument.  CUM->STACK_WORDS gives the number of stack\n+\t words used by named arguments.  */\n+      t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n+      if (cum->stack_words > 0)\n+\tt = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n+\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t  cum->stack_words * UNITS_PER_WORD));\n+      t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* Emit code to initialize GTOP, the top of the GPR save area.  */\n+      t = make_tree (TREE_TYPE (gtop), virtual_incoming_args_rtx);\n+      t = build (MODIFY_EXPR, TREE_TYPE (gtop), gtop, t);\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* Emit code to initialize FTOP, the top of the FPR save area.\n+\t This address is gpr_save_area_bytes below GTOP, rounded\n+\t down to the next fp-aligned boundary.  */\n+      t = make_tree (TREE_TYPE (ftop), virtual_incoming_args_rtx);\n+      fpr_offset = gpr_save_area_size + UNITS_PER_FPVALUE - 1;\n+      fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n+      if (fpr_offset)\n+\tt = build (PLUS_EXPR, TREE_TYPE (ftop), t,\n+\t\t   build_int_cst (NULL_TREE, -fpr_offset));\n+      t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* Emit code to initialize GOFF, the offset from GTOP of the\n+\t next GPR argument.  */\n+      t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n+\t\t build_int_cst (NULL_TREE, gpr_save_area_size));\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* Likewise emit code to initialize FOFF, the offset from FTOP\n+\t of the next FPR argument.  */\n+      t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n+\t\t build_int_cst (NULL_TREE, fpr_save_area_size));\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n   else\n-    std_expand_builtin_va_start (valist, nextarg);\n+    {\n+      nextarg = plus_constant (nextarg, -cfun->machine->varargs_size);\n+      std_expand_builtin_va_start (valist, nextarg);\n+    }\n }\n \f\n /* Implement va_arg.  */\n@@ -6140,10 +6114,9 @@ compute_frame_size (HOST_WIDE_INT size)\n   gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n   total_size += gp_reg_rounded + MIPS_STACK_ALIGN (fp_reg_size);\n \n-  /* Add in space reserved on the stack by the callee for storing arguments\n-     passed in registers.  */\n-  if (!TARGET_OLDABI)\n-    total_size += MIPS_STACK_ALIGN (current_function_pretend_args_size);\n+  /* Add in the space required for saving incoming register arguments.  */\n+  total_size += current_function_pretend_args_size;\n+  total_size += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n \n   /* Save other computed information.  */\n   cfun->machine->frame.total_size = total_size;\n@@ -6212,9 +6185,8 @@ mips_initial_elimination_offset (int from, int to)\n       break;\n \n     case ARG_POINTER_REGNUM:\n-      offset = cfun->machine->frame.total_size;\n-      if (TARGET_NEWABI)\n-\toffset -= current_function_pretend_args_size;\n+      offset = (cfun->machine->frame.total_size\n+\t\t- current_function_pretend_args_size);\n       break;\n \n     default:"}]}