{"sha": "ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxN2NkOGY3ZDVlYzQ5YjQ3ZWQxN2ZmZGY1YWQxYWViODAyNGNkYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2002-06-10T22:20:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-06-10T22:20:47Z"}, "message": "m32r.h: Don't define SELECT_CC_MODE.\n\n\t* config/m32r/m32r.h: Don't define SELECT_CC_MODE.\n\t* config/m32r/m32r-protos.h: Don't prototype m32r_select_cc_mode.\n\t* config/m32r/m32r.c: Don't define m32r_select_cc_mode.\n\t(gen_compare): Use CCmode unconditionally.\n\nFrom-SVN: r54473", "tree": {"sha": "565bffafe6d510175f439ac35ae2fafa63dbcaa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/565bffafe6d510175f439ac35ae2fafa63dbcaa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/comments", "author": null, "committer": null, "parents": [{"sha": "7b668f9ed038456ca0c0cc048978bd4241f4c311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b668f9ed038456ca0c0cc048978bd4241f4c311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b668f9ed038456ca0c0cc048978bd4241f4c311"}], "stats": {"total": 44, "additions": 16, "deletions": 28}, "files": [{"sha": "13dbbfa7233519ec9c862a0e6172f98df7e12d0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "patch": "@@ -1,3 +1,10 @@\n+2002-06-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* config/m32r/m32r.h: Don't define SELECT_CC_MODE.\n+\t* config/m32r/m32r-protos.h: Don't prototype m32r_select_cc_mode.\n+\t* config/m32r/m32r.c: Don't define m32r_select_cc_mode.\n+\t(gen_compare): Use CCmode unconditionally.\n+\n 2002-06-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/6759"}, {"sha": "1a73aa014b4bfbb2314cd5523efc8ea1c70bb0dc", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "patch": "@@ -44,7 +44,6 @@ extern int    function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS *, Mmode, tree\n #ifdef RTX_CODE\n extern int    easy_di_const\t\t\tPARAMS ((rtx));\n extern int    easy_df_const\t\t\tPARAMS ((rtx));\n-extern int    m32r_select_cc_mode\t\tPARAMS ((int, rtx, rtx));\n extern rtx    gen_compare\t\t\tPARAMS ((enum rtx_code, rtx, rtx, int));\n extern rtx    gen_split_move_double\t\tPARAMS ((rtx *));\n extern int    m32r_address_code\t\t\tPARAMS ((rtx));"}, {"sha": "2df9aea7838bcbda0e227967429068fe0a4770b3", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "patch": "@@ -1061,18 +1061,6 @@ large_insn_p (op, mode)\n \f\n /* Comparisons.  */\n \n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  */\n-\n-int\n-m32r_select_cc_mode (op, x, y)\n-     int op ATTRIBUTE_UNUSED;\n-     rtx x ATTRIBUTE_UNUSED;\n-     rtx y ATTRIBUTE_UNUSED;\n-{\n-  return (int) CCmode;\n-}\n-\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for compare [arg0 of the if_then_else].\n    If need_compare is true then the comparison insn must be generated, rather\n@@ -1084,9 +1072,8 @@ gen_compare (code, x, y, need_compare)\n      rtx x, y;\n      int need_compare;\n {\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n   enum rtx_code compare_code, branch_code;\n-  rtx cc_reg = gen_rtx_REG (mode, CARRY_REGNUM);\n+  rtx cc_reg = gen_rtx_REG (CCmode, CARRY_REGNUM);\n   int must_swap = 0;\n \n   switch (code)\n@@ -1132,7 +1119,7 @@ gen_compare (code, x, y, need_compare)\n \t    {\n \t      emit_insn (gen_cmp_eqsi_insn (x, y));\n \t\t\n-\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t      return gen_rtx (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n       \n@@ -1172,7 +1159,7 @@ gen_compare (code, x, y, need_compare)\n \t\t  abort ();\n \t\t}\n \t      \n-\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t      return gen_rtx (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n \t  \n@@ -1212,7 +1199,7 @@ gen_compare (code, x, y, need_compare)\n \t\t  abort();\n \t\t}\n \t      \n-\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t      return gen_rtx (code, CCmode, cc_reg, const0_rtx);\n \t    }\n \t  break;\n \n@@ -1225,12 +1212,12 @@ gen_compare (code, x, y, need_compare)\n       /* reg/reg equal comparison */\n       if (compare_code == EQ\n \t  && register_operand (y, SImode))\n-\treturn gen_rtx (code, mode, x, y);\n+\treturn gen_rtx (code, CCmode, x, y);\n       \n       /* reg/zero signed comparison */\n       if ((compare_code == EQ || compare_code == LT)\n \t  && y == const0_rtx)\n-\treturn gen_rtx (code, mode, x, y);\n+\treturn gen_rtx (code, CCmode, x, y);\n       \n       /* reg/smallconst equal comparison */\n       if (compare_code == EQ\n@@ -1239,15 +1226,15 @@ gen_compare (code, x, y, need_compare)\n \t{\n \t  rtx tmp = gen_reg_rtx (SImode);\n \t  emit_insn (gen_cmp_ne_small_const_insn (tmp, x, y));\n-\t  return gen_rtx (code, mode, tmp, const0_rtx);\n+\t  return gen_rtx (code, CCmode, tmp, const0_rtx);\n \t}\n       \n       /* reg/const equal comparison */\n       if (compare_code == EQ\n \t  && CONSTANT_P (y))\n \t{\n \t  rtx tmp = force_reg (GET_MODE (x), y);\n-\t  return gen_rtx (code, mode, x, tmp);\n+\t  return gen_rtx (code, CCmode, x, tmp);\n \t}\n     }\n \n@@ -1283,7 +1270,7 @@ gen_compare (code, x, y, need_compare)\n       abort ();\n     }\n \n-  return gen_rtx (branch_code, VOIDmode, cc_reg, CONST0_RTX (mode));\n+  return gen_rtx (branch_code, VOIDmode, cc_reg, CONST0_RTX (CCmode));\n }\n \f\n /* Split a 2 word move (DI or DF) into component parts.  */"}, {"sha": "12f330d9cc19321d151f64ce5335e34714b95cc0", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=ac17cd8f7d5ec49b47ed17ffdf5ad1aeb8024cdb", "patch": "@@ -1421,11 +1421,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Condition code usage.  */\n \n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  */\n-#define SELECT_CC_MODE(OP, X, Y) \\\n-((enum machine_mode)m32r_select_cc_mode ((int)OP, X, Y))\n-\n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n #define REVERSIBLE_CC_MODE(MODE) 1 /*???*/"}]}