{"sha": "eabd32629b158fb3253e5b0a7f973f5294980273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFiZDMyNjI5YjE1OGZiMzI1M2U1YjBhN2Y5NzNmNTI5NDk4MDI3Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-19T14:53:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-19T14:53:17Z"}, "message": "Initial revision\n\nFrom-SVN: r792", "tree": {"sha": "ad337178bcda1a848adb3cfa7e2372d4f8082bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad337178bcda1a848adb3cfa7e2372d4f8082bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eabd32629b158fb3253e5b0a7f973f5294980273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabd32629b158fb3253e5b0a7f973f5294980273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eabd32629b158fb3253e5b0a7f973f5294980273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabd32629b158fb3253e5b0a7f973f5294980273/comments", "author": null, "committer": null, "parents": [{"sha": "a7a975e119735ca9f01ddf3fa1189ea599b888b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a975e119735ca9f01ddf3fa1189ea599b888b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a975e119735ca9f01ddf3fa1189ea599b888b0"}], "stats": {"total": 1656, "additions": 1656, "deletions": 0}, "files": [{"sha": "6ff2ebfc1e19ad1b0e31542f44cce89a9a116aac", "filename": "gcc/config/pa/pa.h", "status": "added", "additions": 1656, "deletions": 0, "changes": 1656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eabd32629b158fb3253e5b0a7f973f5294980273/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eabd32629b158fb3253e5b0a7f973f5294980273/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=eabd32629b158fb3253e5b0a7f973f5294980273", "patch": "@@ -0,0 +1,1656 @@\n+/* Definitions of target machine for GNU compiler, for the HP Spectrum.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@mcc.com)\n+   and Tim Moore (moore@defmacro.cs.utah.edu) of the Center for\n+   Software Science at the University of Utah.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+enum cmp_type\t\t\t\t/* comparison type */\n+{\n+  CMP_SI,\t\t\t\t/* compare integers */\n+  CMP_SF,\t\t\t\t/* compare single precision floats */\n+  CMP_DF,\t\t\t\t/* compare double precision floats */\n+  CMP_MAX\t\t\t\t/* max comparison type */\n+};\n+\n+#define DBX_DEBUGGING_INFO\n+#define DEFAULT_GDB_EXTENSIONS 0\n+\n+/* Defines for a K&R CC */\n+\n+#ifdef OLD_CC\n+#define CPP_SPEC \"%{!gnu:-nostdinc %{!nostinc:-I/usr/include}} \\\n+  %{gnu:%{nostdinc}} %{!gnu:-traditional} -Dvolatile=__volatile\"\n+#define CC1_SPEC \"%{!gnu:-traditional -fwritable-strings -fno-defer-pop} \\\n+  %{pg:} %{p:}\"\n+#else\n+#define CC1_SPEC \"%{pg:} %{p:}\"\n+#endif\n+  \n+/* Brain-dead loader */\n+#ifdef hpux8\n+#define LINK_SPEC \"-u main -a archive\"\n+#else\n+#define LINK_SPEC \"-u main\"\n+#endif\n+\n+/* Omit frame pointer at high optimization levels.  */\n+  \n+#define OPTIMIZATION_OPTIONS(OPTIMIZE) \\\n+{  \t\t\t\t\t\t\t\t\\\n+  if (OPTIMIZE >= 2) \t\t\t\t\t\t\\\n+    flag_omit_frame_pointer = 1;\t\t\t\t\\\n+}\n+\n+/* These compiler options take an argument.  We ignore -target for now.  */\n+\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n+ (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\\\n+  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"target\")\\\n+  || !strcmp (STR, \"aux-info\"))\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#ifdef hpux\n+#define CPP_PREDEFINES \"-Dhp9000s800 -D__hp9000s800 -Dhp9k8 -DPWB -Dhpux -Dunix -D_HPUX_SOURCE\"\n+#else\n+#define CPP_PREDEFINES \"-Dhp9000s800 -D__hp9000s800 -Dhp9k8 -Dunix -D_HPUX_SOURCE -Dhp9000 -Dhp800 -Dspectrum -DREVARGV\"\n+#endif\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (hp9000s800)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets.\n+\n+   On the the hp9k800, we don't yet need any. But ... */\n+\n+extern int target_flags;\n+\n+/* compile code for PA-RISC 1.1 (\"Snake\") */\n+\n+#define TARGET_SNAKE (target_flags & 1)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES \\\n+  {{\"snake\", 1},\t\\\n+   { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 0\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the hp9k8.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.  */\n+/* For the hp9k800 we can decide arbitrarily\n+   since there are no machine instructions for them.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Largest alignment required for any stack parameter, in bits.\n+   Don't define this if it is equal to PARM_BOUNDARY */\n+#define MAX_PARM_BOUNDARY 64\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY (TARGET_SNAKE ? 512 : 64)\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* Get around hp-ux assembler bug, and make strcpy of constants fast. */\n+#define CONSTANT_ALIGNMENT(CODE, TYPEALIGN) \\\n+  ((TYPEALIGN) < 32 ? 32 : (TYPEALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   The hp9k800 has 32 fullword registers and 16 floating point\n+   registers. The floating point registers hold either word or double\n+   word values.\n+   \n+   16 additional registers are reserved.\n+   \n+   PA-RISC 1.1 has 32 fullword registers and 32 floating point\n+   registers. However, the floating point registers behave\n+   differently: the left and right halves of registers are addressable\n+   as 32 bit registers. So, we will set things up like the 68k which\n+   has different fp units: define separate register sets for the 1.0\n+   and 1.1 fp units. */\n+\n+#define FIRST_PSEUDO_REGISTER 113  /* 32 + 16 1.0 regs + 64 1.1 regs + */\n+\t\t\t\t   /* 1 shift reg */\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On the hp9k800, these are:\n+   Reg 0\t= 0 (hardware). However, 0 is used for condition code,\n+                  so is not fixed.\n+   Reg 1\t= ADDIL target/Temporary (hardware).\n+   Reg 2\t= Return Pointer\n+   Reg 3\t= Unused\n+   Reg 4\t= Frame Pointer (Gnu)\n+   Reg 5-18\t= Preserved Registers\n+   Reg 19-22\t= Temporary Registers\n+   Reg 23-26\t= Temporary/Parameter Registers\n+   Reg 27\t= Global Data Pointer (hp)\n+   Reg 28\t= Temporary/???/Return Value register\n+   Reg 29\t= Temporary/Static Chain/Return Value register\n+   Reg 30\t= stack pointer\n+   Reg 31\t= Temporary/Millicode Return Pointer (hp)\n+\n+   Freg 0-3\t= Status Registers\n+   Freg 4-7\t= Arguments/Return Value\n+   Freg 8-11\t= Temporary Registers\n+   Freg 12-15\t= Preserved Registers\n+\n+   Freg 16-31\t= Reserved\n+\n+   On the Snake, fp regs are\n+\n+   Freg 0-3\t= Status Registers\n+   Freg 4L-7R\t= Arguments/Return Value\n+   Freg 8L-11R\t= Temporary Registers\n+   Freg 12L-15R\t= Preserved Registers\n+\n+   Freg 16L-31R\t= ?? Some partition of temporary and preserved; assume\n+   preserved for now.\n+   \n+\n+*/\n+\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 1, 1, 1, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 0, 0, 1, 1, \\\n+  /* 1.0 fp registers */ \\\n+  1, 1, 1, 1, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  /* 1.1 fp registers */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  /* 1.0 fp registers */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 0, 0, 0, 0, \\\n+  /* 1.1 fp registers */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1}    \n+\n+/* Make sure everything's fine if we *don't* have a given processor.\n+   This assumes that putting a register in fixed_regs will keep the\n+   compiler's mitts completely off it.  We don't bother to zero it out\n+   of register classes. \n+\n+   Make register 27 global for now.  We'll undo this kludge after 2.1.  */\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\\\n+  HARD_REG_SET x;\t\t\t\t\\\n+  global_regs[27] = 1;\t\t\t\t\\\n+  if (!TARGET_SNAKE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)SNAKE_FP_REGS]);\\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    } \t\t\t\t\t\t\\\n+}\n+\n+/* Allocated the call used registers first.  This should minimize\n+   the number of registers that need to be saved (as call used\n+   registers will generally not be allocated across a call).\n+\n+   It is possible that it would be wise to allocate the floating point\n+   registers before the regular ones, but I doubt it matters.  Same\n+   comment for parameters versus normal.  */\n+\n+#define REG_ALLOC_ORDER \\\n+ {19, 20, 21, 22, 23, 24, 25, 26,\t\\\n+  27, 28, 29, 30, 31, 40, 41, 42,\t\\\n+  43, 36, 37, 38, 39,\t\t\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63, \t\\\n+  64, 65, 66, 67, 68, 69, 70, 71, \t\\\n+  72, 73, 74, 75, 76, 77, 78, 79, \t\\\n+  80, 81, 82, 83, 84, 85, 86, 87, \t\\\n+  88, 89, 90, 91, 92, 93, 94, 95, \t\\\n+  96, 97, 98, 99, 100, 101, 102, 103, \t\\\n+  104, 105, 106, 107, 108, 109, 110, 111,\\\n+   5,  6,  7,\t\t\t\t\\\n+   8,  9, 10, 11, 12, 13, 14, 15,\t\\\n+  16, 17, 18, 44, 45, 46, 47,\t\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n+     1,\t\\\n+   2,  3,  4, 32, 33, 34, 35,  0,\t\\\n+   112}\n+\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the hp9k800, ordinary registers hold 32 bits worth;\n+   The floating point registers are 64 bits wide. Snake fp regs are 32\n+   bits wide */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (((REGNO) < 32 || (REGNO) >= 48)\t\\\n+   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the hp9k800, the cpu registers can hold any mode.  We\n+   force this to be an even register is it cannot hold the full mode.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n+   : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n+   : (REGNO) < 48 ? (GET_MODE_SIZE (MODE) >= 4)\t\t\t\t\\\n+   : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n+      : GET_MODE_SIZE (MODE) == 4))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* the hp9k800 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 30\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 4\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+extern int leaf_function;\n+\n+#define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n+  \n+\n+/* C statement to store the difference between the frame pointer\n+   and the stack pointer values immediately after the function prologue.\n+\n+   Note, we always pretend that this is a leaf function because if\n+   it's not, there's no point in trying to eliminate the\n+   frame pointer.  If it is a leaf function, we guessed right!  */\n+#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n+  do { int __fsize = compute_frame_size (get_frame_size (), 1) + 32;\t\\\n+       (VAR) = -(TARGET_SNAKE ? (__fsize + 63) & ~63 : __fsize); } while (0)\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 4\n+\n+/* Register in which static-chain is passed to a function.  */\n+/* ??? */\n+#define STATIC_CHAIN_REGNUM 29\n+\n+/* Register which holds offset table for position-independent\n+   data references.  */\n+\n+#define PIC_OFFSET_TABLE_REGNUM 18\n+\n+#define INITIALIZE_PIC initialize_pic ()\n+#define FINALIZE_PIC finalize_pic ()\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 28\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+  /* The hp9k800 has four kinds of registers: general regs, 1.0 fp regs,\n+     1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n+     fmpyadd and fmpysub are restricted. */\n+\n+enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, HI_SNAKE_FP_REGS,\n+ SNAKE_FP_REGS, FP_OR_SNAKE_FP_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+  { \"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"HI_SNAKE_FP_REGS\",\\\n+    \"SNAKE_FP_REGS\", \"FP_OR_SNAKE_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n+   is in no class. */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+{ {0, 0, 0, 0},\t\t\t/* NO_REGS */\t\t\\\n+  {0x2, 0, 0, 0},\t\t/* R1_REGS */\t\t\\\n+  {-2, 0, 0, 0},\t\t/* GENERAL_REGS */\t\\\n+  {0, 0xffff, 0, 0},\t\t/* FP_REGS */\t\t\\\n+  {0, 0, 0xffff0000, 0xffff},\t/* HI_SNAKE_FP_REGS */\t\\\n+  {0, 0xffff0000, ~0, 0xffff},\t/* SNAKE_FP_REGS */\t\\\n+  {0, ~0, ~0, 0xffff},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n+  {0, 0, 0, 0x10000},\t\t/* SHIFT_REGS */\t\\\n+  {-2, ~0, ~0, 0x1ffff}}\t/* ALL_REGS */\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\\\n+  ((REGNO) == 0 ? NO_REGS \t\t\\\n+   : (REGNO) == 1 ? R1_REGS\t\t\\\n+   : (REGNO) < 32 ? GENERAL_REGS\t\\\n+   : (REGNO) < 48 ? FP_REGS\t\t\\\n+   : (REGNO) < 80 ? SNAKE_FP_REGS\t\\\n+   : (REGNO) < 112 ? HI_SNAKE_FP_REGS\t\\\n+   : SHIFT_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'r' ? GENERAL_REGS :\t\t\t\t\t\\\n+   ((C) == 'f' ? (!TARGET_SNAKE ? FP_REGS : NO_REGS) :\t\t\\\n+    ((C) == 'x' ? (TARGET_SNAKE ? SNAKE_FP_REGS : NO_REGS) :\t\\\n+     ((C) == 'y' ? (TARGET_SNAKE ? HI_SNAKE_FP_REGS : NO_REGS) :\\\n+      ((C) == 'q' ? SHIFT_REGS :\t\t\t\t\\\n+       ((C) == 'a' ? R1_REGS : NO_REGS))))))\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+HP9000/800 immediate field sizes:\n+  5 bits: scalar/floating short loads + stores; deposit; conditional branch\n+  11 bits: arithmetic immediate, compare immediate\n+  14 bits: loads and stores; load offset\n+  21 bits: load and add immediate long (but this isn't really used)\n+  (there are also 13-bit and 26-bit immediates but only in system instructions)\n+\n+   `I' is used for the 11 bit constants.\n+   `J' is used for the 14 bit constants.\n+   `K' is used for unsigned 5 bit constants (extract/deposit operands).\n+   `L' is used for the 5 bit constants.\n+   `M' is used for 0.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? (unsigned) ((VALUE) + 0x400) < 0x800\t\t\\\n+   : (C) == 'J' ? (unsigned) ((VALUE) + 0x2000) < 0x4000\t\\\n+   : (C) == 'K' ? (unsigned) (VALUE) < 0x20\t\t\t\\\n+   : (C) == 'L' ? (unsigned) ((VALUE) + 0x10) < 0x20\t\t\\\n+   : (C) == 'M' ? (VALUE) == 0\t\t\t\t\t\\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' && XINT (VALUE, 0) == 0 && XINT (VALUE, 1) == 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class (CLASS, MODE, IN)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((CLASS) == FP_REGS ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+/* #define STACK_GROWS_DOWNWARD */\n+\n+/* Believe it or not.  */\n+#define ARGS_GROW_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 8\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the hp9k800, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   This value will be negated because the arguments grow down.\n+   Also note that on STACK_GROWS_UPWARD machines (such as this one)\n+   this is the distance from the frame pointer to the end of the first\n+   argument, not it's beginning.  To get the real offset of the first\n+   argument, the size of the argument must be added.\n+\n+   ??? Have to check on this.*/\n+\n+/* #define FIRST_PARM_OFFSET(FNDECL) 36  */\n+#define FIRST_PARM_OFFSET(FNDECL) -32 \n+\n+/* Absolute value of offset from top-of-stack address to location to store the\n+   function parameter if it can't go in a register.\n+   Addresses for following parameters are computed relative to this one.  */\n+/* #define FIRST_PARM_CALLER_OFFSET(FNDECL) 36 */\n+#define FIRST_PARM_CALLER_OFFSET(FNDECL) -32 \n+\n+\n+/* When a parameter is passed in a register, stack space is still\n+   allocated for it.  */\n+#define REG_PARM_STACK_SPACE(DECL) 16\n+\n+/* Define this if the above stack space is to be considered part of the\n+   space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+/* Keep the stack pointer constant throughout the function.\n+   This is both an optimization and a necessity: longjmp\n+   doesn't behave itself when the stack pointer moves within\n+   the function!  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+  \n+/* The weird HPPA calling conventions require a minimum of 48 bytes on \n+   the stack: 16 bytes for register saves, and 32 bytes for magic.\n+   This is the difference between the logical top of stack and the\n+   actual sp. */ \n+#define STACK_POINTER_OFFSET -32\n+\n+#define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n+  ((STACK_POINTER_OFFSET) - current_function_outgoing_args_size)\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the hp9k800 the value is found in register(s) 28(-29), unless\n+   the mode is SF or DF. Then the value is returned in fr4 (36, ) */\n+\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n+\t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n+\t\t\t\t      (TARGET_SNAKE ? 56 : 36) : 28))\n+\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n+  FUNCTION_VALUE(VALTYPE, FUNC)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) \\\n+  gen_rtx (REG, MODE, (MODE == SFmode || MODE == DFmode ?\\\n+\t\t       (TARGET_SNAKE ? 56 : 36) : 28))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 28 || (N) == 36 || (N) == 56)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) (((N) >= 23 && (N) <= 26) || \\\n+\t\t\t\t ((N) >= 36 && (N) <= 39) || \\\n+\t\t\t\t ((N) >= 56 && (N) <= 63))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the hp9k800, this is a single integer, which is a number of words\n+   of arguments scanned so far (including the invisible argument,\n+   if any, which holds the structure-value-address).\n+   Thus 4 or more means all following args should go on the stack.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+*/\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) ((CUM) = 0)\n+\n+/* Figure out the size in words of the function argument. */\n+\n+#define FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n+  ((((MODE) != BLKmode ? GET_MODE_SIZE (MODE) : int_size_in_bytes (TYPE))+3)/4)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+    (((((CUM) & 01) && (TYPE) != 0 && TYPE_ALIGN (TYPE) > BITS_PER_WORD)\\\n+      && (CUM)++), (CUM) += FUNCTION_ARG_SIZE(MODE, TYPE))\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the hp9k800 the first four words of args are normally in registers\n+   and the rest are pushed.  But any arg that won't entirely fit in regs\n+   is pushed.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding ((MODE), (TYPE))\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t      \t\t\\\n+  (4 >= ((CUM) + FUNCTION_ARG_SIZE ((MODE), (TYPE)))\t\t\t\\\n+   ? gen_rtx (REG,\t\t\t\t\t\t\t\\\n+\t      (MODE),\t\t\t\t\t\t\t\\\n+\t      ((MODE) == SFmode ?\t\t\t\t\t\\\n+\t       (TARGET_SNAKE ? 56 + 2 * (CUM) : 36  + (CUM)) :\t\t\\\n+\t       ((MODE) == DFmode ? ((CUM) ?\t\t\t\t\\\n+\t\t\t\t    (TARGET_SNAKE ? 62 : 39) :\t\t\\\n+\t\t\t\t    (TARGET_SNAKE ? 58 : 37)) :        \t\\\n+\t\t(27 - (CUM) - FUNCTION_ARG_SIZE ((MODE), (TYPE))))))\t\\\n+   : 0)\n+\n+/* Define where a function finds its arguments.\n+   This would be different from FUNCTION_ARG if we had register windows.  */\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+  FUNCTION_ARG (CUM, MODE, TYPE, NAMED)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* If defined, a C expression that gives the alignment boundary, in\n+   bits, of an argument with the specified mode and type.  If it is\n+   not defined,  `PARM_BOUNDARY' is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+  (((TYPE) != 0)\t\t\t\t\t\t\t\\\n+\t? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n+\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t\t: TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n+\t: ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\t\\\n+\t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n+\t\t: GET_MODE_ALIGNMENT(MODE)))\n+\n+/* Arguments larger than eight bytes are passed by invisible reference */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  ((TYPE) ? int_size_in_bytes (TYPE) > 8 : GET_MODE_SIZE (MODE) > 8)\n+\f\n+extern struct rtx_def *hppa_compare_op0, *hppa_compare_op1;\n+extern enum cmp_type hppa_branch_type;\n+\n+/* Output the label for a function definition.  */\n+#ifdef HP_FP_ARG_DESCRIPTOR_REVERSED\n+#define ASM_DOUBLE_ARG_DESCRIPTORS(FILE, ARG0, ARG1)\t\\\n+  do { fprintf (FILE, \",ARGW%d=FR\", (ARG0));\t\t\\\n+       fprintf (FILE, \",ARGW%d=FU\", (ARG1));} while (0)\n+#else\n+#define ASM_DOUBLE_ARG_DESCRIPTORS(FILE, ARG0, ARG1)\t\\\n+  do { fprintf (FILE, \",ARGW%d=FU\", (ARG0));\t\t\\\n+       fprintf (FILE, \",ARGW%d=FR\", (ARG1));} while (0)\n+#endif\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+    do { tree fntype = DECL_RESULT (DECL);\t \t\t\t\\\n+\t tree tree_type = TREE_TYPE (DECL);\t\t\t\t\\\n+\t tree parm;\t\t\t\t\t\t\t\\\n+\t int i;\t\t\t\t\t\t\t\t\\\n+\t if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n+\t   {\t\t\t\t\t\t\t\t\\\n+\t     fputs (\"\\t.EXPORT \", FILE); assemble_name (FILE, NAME);\t\\\n+\t     fputs (\",PRIV_LEV=3\", FILE);\t\t\t\t\\\n+\t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n+\t\t  parm = TREE_CHAIN (parm), i++)\t\t\t\\\n+\t       {\t\t\t\t\t\t\t\\\n+\t\t if (TYPE_MODE (DECL_ARG_TYPE (parm)) == SFmode)\t\\\n+\t\t   fprintf (FILE, \",ARGW%d=FR\", i);\t\t\t\\\n+\t\t else if (TYPE_MODE (DECL_ARG_TYPE (parm)) == DFmode)\t\\\n+\t\t   {\t\t\t\t\t\t\t\\\n+\t\t     if (i == 0 || i == 2)\t\t\t\t\\\n+\t\t       {\t\t\t\t\t\t\\\n+\t\t\t ASM_DOUBLE_ARG_DESCRIPTORS (FILE, i++, i);\t\\\n+\t\t       }\t\t\t\t\t\t\\\n+\t\t     else if (i == 1)\t\t\t\t\t\\\n+\t\t       {\t\t\t\t\t\t\\\n+\t\t\t ASM_DOUBLE_ARG_DESCRIPTORS (FILE, ++i, ++i);\t\\\n+\t\t       }\t\t\t\t\t\t\\\n+\t\t   }\t\t\t\t\t\t\t\\\n+\t\t else\t\t\t\t\t\t\t\\\n+\t\t   fprintf (FILE, \",ARGW%d=GR\", i);\t\t\t\\\n+\t       }\t\t\t\t\t\t\t\\\n+\t     /* anonymous args */\t\t\t\t\t\\\n+\t     if (TYPE_ARG_TYPES (tree_type) != 0\t\t\t\\\n+\t\t && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (tree_type)))\\\n+\t\t     != void_type_node))\t\t\t\t\\\n+\t       {\t\t\t\t\t\t\t\\\n+\t\t for (; i < 4; i++)\t\t\t\t\t\\\n+\t\t   fprintf (FILE, \",ARGW%d=GR\", i);\t\t\t\\\n+\t       }\t\t\t\t\t\t\t\\\n+\t     if (TYPE_MODE (fntype) == DFmode)\t\t\t\t\\\n+\t       fprintf (FILE, \",RTNVAL=FR\");\t\t\t\t\\\n+\t     else if (TYPE_MODE (fntype) == SFmode)\t\t\t\\\n+\t       fprintf (FILE, \",RTNVAL=FU\");\t\t\t\t\\\n+\t     else if (fntype != void_type_node)\t\t\t\t\\\n+\t       fprintf (FILE, \",RTNVAL=GR\");\t\t\t\t\\\n+\t     fputs (\"\\n\", FILE);\t\t\t\t\t\\\n+\t   }\t\t\t\t\t\t\t\t\\\n+\t ASM_OUTPUT_LABEL (FILE, NAME);} while (0)\n+\n+/* Two views of the size of the current frame.  */\n+extern int actual_fsize;\n+extern int apparent_fsize;\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+/* On HP-PA, move-double insns between fpu and cpu need an 8-byte block\n+   of memory.  If any fpu reg is used in the function, we allocate\n+   such a block here, at the bottom of the frame, just in case it's needed.\n+\n+   If this function is a leaf procedure, then we may choose not\n+   to do a \"save\" insn.  The decision about whether or not\n+   to do this is made in regclass.c.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+  output_function_prologue (FILE, SIZE, leaf_function)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.\n+\n+   Because HPUX _mcount is so different, we actually emit the\n+   profiling code in function_prologue. This just stores LABELNO for\n+   that. */\n+\n+#ifdef hp800\t\t\t/* Don't have the proper libraries yet */\n+#define FUNCTION_PROFILER(FILE, LABELNO) {}\n+#else\n+#define PROFILE_BEFORE_PROLOGUE\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+{ extern int hp_profile_labelno; hp_profile_labelno = (LABELNO);}\n+#endif\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+extern int may_call_alloca;\n+extern int current_function_pretend_args_size;\n+\n+#define EXIT_IGNORE_STACK\t\\\n+ (get_frame_size () != 0\t\\\n+  || current_function_calls_alloca || current_function_outgoing_args_size)\n+\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+/* This declaration is needed due to traditional/ANSI\n+   incompatibilities which cannot be #ifdefed away\n+   because they occur inside of macros.  Sigh.  */\n+extern union tree_node *current_function_decl;\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\\\n+  output_function_epilogue (FILE, SIZE, leaf_function)\n+#define DELAY_SLOTS_FOR_EPILOGUE 1\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n+  eligible_for_epilogue_delay (trial, slots_filled)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) {}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 0\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   This takes 16 insns: 2 shifts & 2 ands (to split up addresses), 4 sethi\n+   (to load in opcodes), 4 iors (to merge address and opcodes), and 4 writes\n+   (to store insns).  This is a bit excessive.  Perhaps a different\n+   mechanism would be better here.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) {}\n+\n+/* Emit code for a call to builtin_saveregs.  We must emit USE insns which\n+   reference the 4 integer arg registers and 4 fp arg registers.\n+   Ordinarily they are not call used registers, but they are for\n+   _builtin_saveregs, so we must make this explicit.  */\n+\n+\n+#if 0\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST)\t\t\t\t\\\n+  (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, TImode, 23))),\t\\\n+   (TARGET_SNAKE ?\t\t\t\t\t\t\t\\\n+    (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 56))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 58))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 60))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 62)))) :\t\\\n+    (emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 36))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 37))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 38))),\t\\\n+     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, DFmode, 39))))))\n+#endif\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) (rtx)hppa_builtin_saveregs (ARGLIST)\n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT\n+#define HAVE_POST_DECREMENT\n+\n+#define HAVE_PRE_DECREMENT\n+#define HAVE_PRE_INCREMENT\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+  ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+  (((REGNO) >= 32 || reg_renumber[REGNO] >= 32)\\\n+   && ((REGNO) <= 111 || reg_renumber[REGNO] <= 111))\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the the hp9k800, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+/*#define LEGITIMATE_CONSTANT_P(X) (1)*/\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\\\n+ (GET_CODE (X) != CONST_DOUBLE)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+/* Optional extra constraints for this machine. Borrowed from sparc.h.\n+\n+   For the HPPA, `Q' means that this is a memory operand but not a\n+   symbolic memory operand.  Note that an unassigned pseudo register\n+   is such a memory operand.  Needed because reload will generate\n+   these things in insns and then not re-recognize the insns, causing\n+   constrain_operands to fail.\n+\n+   `R' handles the LO_SUM which can be an address for `Q'.\n+\n+   `S' handles constraints for calls.\n+\n+   `T' is for fp load and store addresses.*/\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+(REGNO (X) && (REGNO (X) < 32 || REGNO (X) > FIRST_PSEUDO_REGISTER))\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+(REGNO (X) && (REGNO (X) < 32 || REGNO (X) > FIRST_PSEUDO_REGISTER))\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\\\n+   ((GET_CODE (OP) == MEM\t\t\t\t\\\n+     && memory_address_p (GET_MODE (OP), XEXP (OP, 0))\t\\\n+     && ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n+   : ((C) == 'R' ?\t\t\t\t\t\\\n+      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n+       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n+      : ((C) == 'S'\t\t\t\t\t\\\n+\t ? CONSTANT_P (OP) || memory_address_p (Pmode, OP)\\\n+\t : ((C) == 'T' ? short_memory_operand (OP, VOIDmode) : 0))))\\\n+\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  (((C) == 'Q' || (C) == 'T') ?\t\t\t\t\\\n+   (GET_CODE (OP) == REG ?\t\t\t\t\\\n+    (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n+     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n+    : GET_CODE (OP) == MEM)\t\t\t\t\\\n+   : ((C) == 'R' ?\t\t\t\t\t\\\n+      (GET_CODE (OP) == LO_SUM\t\t\t\t\\\n+       && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\\\n+      : (CONSTANT_P (OP)\t\t\t\t\\\n+\t    || (GET_CODE (OP) == REG && reg_renumber[REGNO (OP)] > 0)\\\n+\t    || strict_memory_address_p (Pmode, OP))))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the hp9k800, the actual legitimate addresses must be\n+   REG+REG, REG+(REG*SCALE) or REG+SMALLINT.\n+   But we can treat a SYMBOL_REF as legitimate if it is part of this\n+   function's constant-pool, because such addresses can actually\n+   be output as REG+SMALLINT.  */\n+\n+#define VAL_5_BITS_P(X) ((unsigned)(X) + 0x10 < 0x20)\n+#define INT_5_BITS(X) VAL_5_BITS_P (INTVAL (X))\n+\n+#define VAL_U5_BITS_P(X) ((unsigned)(X) < 0x20)\n+#define INT_U5_BITS(X) VAL_U5_BITS_P (INTVAL (X))\n+\n+#define VAL_11_BITS_P(X) ((unsigned)(X) + 0x400 < 0x800)\n+#define INT_11_BITS(X) VAL_11_BITS_P (INTVAL (X))\n+\n+#define VAL_14_BITS_P(X) ((unsigned)(X) + 0x2000 < 0x4000)\n+#define INT_14_BITS(X) VAL_14_BITS_P (INTVAL (X))\n+\n+#define FITS_14_BITS(X)\t\\\n+   (GET_CODE (X) == CONST_INT && INT_14_BITS (X))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{\t\t\t\t\t\t\t\\\n+  if ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\\\n+      || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_DEC\t\t\\\n+\t   || GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_INC)\t\\\n+\t  && REG_P (XEXP (X, 0))\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      rtx base = 0, index;\t\t\t\t\\\n+      if (flag_pic && XEXP (X, 0) == pic_offset_table_rtx)\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  else if (flag_pic == 1\t\t\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != REG\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != LO_SUM\t\\\n+\t\t   && GET_CODE (XEXP (X, 1)) != MEM)\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (REG_P (XEXP (X, 0))\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\\\n+      else if (REG_P (XEXP (X, 1))\t\t\t\\\n+\t       && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\\\n+\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n+      if (base != 0)\t\t\t\t\t\\\n+\tif (GET_CODE (index) == CONST_INT\t\t\\\n+\t    && ((INT_14_BITS (index) && (MODE) != SFmode && (MODE) != DFmode) \\\n+\t\t|| INT_5_BITS (index)))\t\t\t\\\n+\t  goto ADDR;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n+\t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n+\t   && (MODE) != SFmode\t\t\t\t\\\n+\t   && (MODE) != DFmode)\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LO_SUM\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == SUBREG\t\t\\\n+\t   && GET_CODE (SUBREG_REG (XEXP (X, 0))) == REG\\\n+\t   && REG_OK_FOR_BASE_P (SUBREG_REG (XEXP (X, 0)))\\\n+\t   && CONSTANT_P (XEXP (X, 1))\t\t\t\\\n+\t   && (MODE) != SFmode\t\t\t\t\\\n+\t   && (MODE) != DFmode)\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == LABEL_REF\t\t\t\\\n+\t   || (GET_CODE (X) == CONST_INT\t\t\\\n+\t       && INT_14_BITS (X)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On the hp9k800, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n+{ if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   copy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 1),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 0), 0));\t\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n+    (X) = gen_rtx (PLUS, SImode, XEXP (X, 0),\t\t\t\\\n+\t\t   force_operand (XEXP (X, 1), 0));\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\\\n+  if (flag_pic) (X) = legitimize_pic_address (X, MODE, gen_reg_rtx (Pmode));\\\n+  else if ((GET_CODE (X) == SYMBOL_REF & read_only_operand (X))\t\\\n+\t    || GET_CODE (X) == LABEL_REF)\t\t\t\\\n+    (X) = gen_rtx (LO_SUM, Pmode,\t\t\t\t\\\n+\t\t   copy_to_mode_reg (Pmode, gen_rtx (HIGH, Pmode, X)), X); \\\n+  else if (GET_CODE (X) == SYMBOL_REF)\t\t\t\t\\\n+    (X) = gen_rtx (LO_SUM, Pmode,\t\t\t\t\\\n+\t\t   copy_to_mode_reg (Pmode,\t\t\t\\\n+\t\t\t\t     gen_rtx (PLUS, Pmode,\t\\\n+\t\t\t\t\t      copy_to_mode_reg (Pmode,\\\n+\t\t\t\t\t\t\t\tgen_rtx (HIGH, Pmode, X)),\\\n+\t\t\t\t\t      gen_rtx (REG, Pmode, 27))),\\\n+\t\t   X);\t\t\t\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN;}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC\t\\\n+      || GET_CODE (ADDR) == POST_DEC\t\\\n+      || GET_CODE (ADDR) == PRE_INC\t\\\n+      || GET_CODE (ADDR) == POST_INC)\t\\\n+    goto LABEL\n+\f\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the\n+   rtl for DECL or other node is created.\n+   The value of the rtl will be a `mem' whose address is a\n+   `symbol_ref'.\n+\n+   The usual thing for this macro to do is to a flag in the\n+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n+   name string in the `symbol_ref' (if one bit is not enough\n+   information).\n+\n+   On the PA-RISC we use this to indicate if a symbol is in text or\n+   data space.  */\n+\n+#define ENCODE_SECTION_INFO(DECL)\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\t\\\n+      SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n+\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\tif (RTX_UNCHANGING_P (rtl) && !MEM_VOLATILE_P (rtl)\t\t\\\n+\t    && !flag_pic)\t\t\t\t\t\t\\\n+\t  SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+  \n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   HPPA floating comparisons produce condition codes. */\n+#define EXTRA_CC_MODES CCFPmode\n+\n+/* Define the names for the modes specified above.  */\n+#define EXTRA_CC_NAMES \"CCFP\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point, CCFPmode\n+   should be used.  CC_NOOVmode should be used when the first operand is a\n+   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n+   needed.  */\n+#define SELECT_CC_MODE(OP,X) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode : CCmode)    \\\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE SImode\n+  \n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0) return 0;\t\t\t\t\\\n+    if (INT_14_BITS (RTX)) return 1;\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 2;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 4;\n+\n+#define ADDRESS_COST(RTX) \\\n+  (GET_CODE (RTX) == REG ? 1 : hppa_address_cost (RTX))\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n+  (((CLASS1 == FP_REGS && CLASS2 == GENERAL_REGS) \\\n+    || (CLASS1 == GENERAL_REGS && CLASS2 == FP_REGS)) ? 6 : 2)\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  The purpose for the cost of MULT is to encourage\n+   `synth_mult' to find a synthetic multiply when reasonable.  */\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (20);\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (60);\t\t\t\t\\\n+   case PLUS: /* this includes shNadd insns */\t\t\\\n+    return COSTS_N_INSNS (1) + 2;\n+\n+/* Conditional branches with empty delay slots have a length of two.  */\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\\n+  if (GET_CODE (INSN) == CALL_INSN\t\t\t\t\t\\\n+      || (GET_CODE (INSN) == JUMP_INSN && ! simplejump_p (insn)))\t\\\n+    LENGTH += 1;\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) \\\n+do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n+\\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\\n\\\n+\\t.SPACE $TEXT$\\n\\\n+\\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\\n\\\n+\\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\\n\\\n+\\t.IMPORT $global$,DATA\\n\\\n+\\t.IMPORT $$dyncall,MILLICODE\\n\");\\\n+     if (profile_flag)\\\n+       fprintf (FILE, \"\\t.IMPORT __gcc_mcount, CODE\\n\");\\\n+   } while (0)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* We don't yet know how to identify GCC to HP series 800.  */\n+#define ASM_IDENTIFY_GCC(FILE) fprintf (FILE, \"; gcc_compiled.:\\n\")\n+\n+/* Output before code.  */\n+\n+/* Supposedly the assembler rejects the command if there is no tab!  */\n+#define TEXT_SECTION_ASM_OP \"\\t.SPACE $TEXT$\\n\\t.SUBSPA $CODE$\\n\"\n+\n+/* Output before writable data.  */\n+\n+/* Supposedly the assembler rejects the command if there is no tab!  */\n+#define DATA_SECTION_ASM_OP \"\\t.SPACE $PRIVATE$\\n\\t.SUBSPA $DATA$\\n\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"0\", \"%r1\", \"%r2\", \"%r3\", \"%r4\", \"%r5\", \"%r6\", \"%r7\",\t\t\t\\\n+ \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\t\\\n+ \"%r16\", \"%r17\", \"%r18\", \"%r19\", \"%r20\", \"%r21\", \"%r22\", \"%r23\",\t\\\n+ \"%r24\", \"%r25\", \"%r26\", \"%r27\", \"%r28\", \"%r29\", \"%r30\", \"%r31\",\t\\\n+ \"%fr0\", \"%fr1\", \"%fr2\", \"%fr3\", \"%fr4\", \"%fr5\", \"%fr6\", \"%fr7\",\t\\\n+ \"%fr8\", \"%fr9\", \"%fr10\", \"%fr11\", \"%fr12\", \"%fr13\", \"%fr14\", \"%fr15\",\t\\\n+ \"%fr0\", \"%fr0R\", \"%fr1\", \"%fr1R\", \"%fr2\", \"%fr2R\", \"%fr3\", \"%fr3R\",\t\\\n+ \"%fr4\", \"%fr4R\", \"%fr5\", \"%fr5R\", \"%fr6\", \"%fr6R\", \"%fr7\", \"%fr7R\",\t\\\n+ \"%fr8\", \"%fr8R\", \"%fr9\", \"%fr9R\", \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\",\\\n+ \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\",\\\n+ \"%fr16\", \"%fr16R\", \"%fr17\", \"%fr17R\", \"%fr18\", \"%fr18R\", \"%fr19\", \"%fr19R\",\\\n+ \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\",\\\n+ \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\",\\\n+ \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\",\\\n+ \"SAR\"}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputc ('\\n', FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+  do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\\\n+\t assemble_name (FILE, NAME);\t\t\t\t\\\n+       if (TREE_CODE (DECL) == VAR_DECL && ! TREE_READONLY (DECL))     \t\\\n+\t fputs (\",DATA\\n\", FILE);\t\t\t\t\\\n+       else\t\t\t\t\t\t\t\\\n+\t fputs (\",CODE\\n\", FILE);\t\t\t\t\\\n+     } while (0)\n+\n+/* hpux ld doesn't output the object file name, or anything useful at\n+   all, to indicate the start of an object file's symbols. This screws\n+   up gdb, so we'll output this magic cookie at the end of an object\n+   file with debugging symbols */\n+\n+#define ASM_FILE_END(FILE) \\\n+  do { if (write_symbols == DBX_DEBUG)\\\n+\t { fputs (TEXT_SECTION_ASM_OP, FILE);\\\n+\t   fputs (\".stabs \\\"end_file.\\\",4,0,0,Ltext_end\\nLtext_end:\\n\",\\\n+\t\t  (FILE));\\\n+\t }\\\n+     } while (0)\n+\n+/* The bogus HP assembler requires ALL external references to be \n+   \"imported\", even library calls. They look a bit different, so\n+   here's this macro. */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, RTL) \\\n+  do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n+       assemble_name (FILE, XSTR ((RTL), 0));\t\t       \t\t\\\n+       fputs (\",CODE\\n\", FILE);\t\t\t\t\t\t\\\n+     } while (0)\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n+  do { fputs (\"\\t.EXPORT \", FILE); assemble_name (FILE, NAME);\t\t\\\n+       fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s$%04d\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s$%04d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  do { union { double d; int i[2];} __u;\t\\\n+    __u.d = (VALUE);\t\t\t\t\\\n+    fprintf (FILE, \"\\t; .double %.20e\\n\\t.word %d ; = 0x%x\\n\\t.word %d ; = 0x%x\\n\",\t\\\n+\t     __u.d, __u.i[0], __u.i[0], __u.i[1], __u.i[1]);\t\\\n+  } while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  do { union { float f; int i;} __u;\t\t\\\n+    __u.f = (VALUE);\t\t\t\t\\\n+    fprintf (FILE, \"\\t; .float %.12e\\n\\t.word %d ; = 0x%x\\n\", __u.f, __u.i, __u.i); \\\n+  } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `short' and `char' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n+  output_ascii ((FILE), (P), (SIZE))\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tstws,mb %s,4(0,30)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tldws,ma -4(0,30),%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   Note that this method makes filling these branch delay slots\n+   virtually impossible.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (the hp9k800 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tword L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (1<<(LOG)))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.blockz %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( data_section (),\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fputs (\"\\t.comm \", (FILE)),\t\t\t\t\\\n+  fprintf ((FILE), \"%d\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( data_section (),\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t.align %d\\n\", (SIZE) <= 4 ? 4 : 8),\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\\t.blockz %d\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  ((CHAR) == '@' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^')\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   On the hp9k800, the CODE can be `r', meaning this is a register-only operand\n+   and an immediate zero should be represented as `r0'.\n+\n+   Several % codes are defined:\n+   O an operation\n+   C compare conditions\n+   N extract conditions\n+   M modifier to handle preincrement addressing for memory refs.\n+   F modifier to handle preincrement addressing for fp memory refs */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  register rtx base;\t\t\t\t\t\t\t\\\n+  int offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"0(0,%s)\", reg_names [REGNO (addr)]);\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\t\\\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\t\\\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%d(0,%s)\", offset, reg_names [REGNO (base)]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case LO_SUM:\t\t\t\t\t\t\t\\\n+      fputs (\"R'\", FILE);\t\t\t\t\t\t\\\n+      output_global_address (FILE, XEXP (addr, 1));\t\t\t\\\n+      fputs (\"(\", FILE);\t\t\t\t\t\t\\\n+      output_operand (XEXP (addr, 0), 0);\t\t\t\t\\\n+      fputs (\")\", FILE);\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+\f\n+#define SMALL_INT(OP) INT_14_BITS (OP)\n+/* Define functions in hppa.c and used in insn-output.c.  */\n+\n+extern char *output_move_double ();\n+extern char *output_fp_move_double ();\n+extern char *output_block_move ();\n+extern char *output_scc_insn ();\n+extern char *output_cbranch ();\n+extern char *output_return ();\n+extern char *output_floatsisf2 ();\n+extern char *output_floatsidf2 ();\n+extern char *output_mul_insn ();\n+extern char *output_div_insn ();\n+extern char *output_mod_insn ();\n+extern void output_arg_descriptor ();\n+extern void output_global_address ();\n+extern struct rtx_def *legitimize_pic_address ();"}]}