{"sha": "ebee1eb978f5168267f8ee9dc530f620d5639943", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlZTFlYjk3OGY1MTY4MjY3ZjhlZTlkYzUzMGY2MjBkNTYzOTk0Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-02-03T02:18:59Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-02-03T02:18:59Z"}, "message": "PR middle-end/79275 -  -Wformat-overflow false positive exceeding INT_MAX in glibc sysdeps/posix/tempname.c\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/79275\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-11.c: New test.\n\t* gcc.dg/tree-ssa/pr79275.c: New test.\n\ngcc/ChangeLog:\n\n\tPR middle-end/79275\n\t* gimple-ssa-sprintf.c (get_string_length): Set lower bound to zero.\n\t(format_string): Tighten up the range of output for non-constant\n\tstrings and correct the expected range for wide non-constant strings.\n\nFrom-SVN: r245142", "tree": {"sha": "8d6cf5d91b0b93aaba4c736c8852ac2813fa9fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d6cf5d91b0b93aaba4c736c8852ac2813fa9fe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebee1eb978f5168267f8ee9dc530f620d5639943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebee1eb978f5168267f8ee9dc530f620d5639943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebee1eb978f5168267f8ee9dc530f620d5639943", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebee1eb978f5168267f8ee9dc530f620d5639943/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92d8bb06dc66c41c1b27906e680b79b12b2f51df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d8bb06dc66c41c1b27906e680b79b12b2f51df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d8bb06dc66c41c1b27906e680b79b12b2f51df"}], "stats": {"total": 441, "additions": 419, "deletions": 22}, "files": [{"sha": "fe36a9e0f7b7009bc965ff7c0afb3e1775014f7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebee1eb978f5168267f8ee9dc530f620d5639943", "patch": "@@ -1,3 +1,10 @@\n+2017-02-02  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79275\n+\t* gimple-ssa-sprintf.c (get_string_length): Set lower bound to zero.\n+\t(format_string): Tighten up the range of output for non-constant\n+\tstrings and correct the expected range for wide non-constant strings.\n+\n 2017-02-02  Martin Sebor  <msebor@redhat.com>\n \n \t* doc/invoke.texi (-maccumulate-args): Fix bad grammar."}, {"sha": "9e099f0a1330de9e8db1c195374cb48e691310bc", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=ebee1eb978f5168267f8ee9dc530f620d5639943", "patch": "@@ -1832,10 +1832,11 @@ get_string_length (tree str)\n \t}\n       else\n \t{\n-\t  /* When the upper bound is unknown (as assumed to be excessive)\n+\t  /* When the upper bound is unknown (it can be zero or excessive)\n \t     set the likely length to the greater of 1 and the length of\n-\t     the shortest string.  */\n+\t     the shortest string and reset the lower bound to zero.  */\n \t  res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n+\t  res.range.min = 0;\n \t}\n \n       res.range.unlikely = res.range.max;\n@@ -1986,43 +1987,89 @@ format_string (const directive &dir, tree arg)\n     }\n   else\n     {\n-      /* For a '%s' and '%ls' directive with a non-constant string,\n-\t the minimum number of characters is the greater of WIDTH\n-\t and either 0 in mode 1 or the smaller of PRECISION and 1\n-\t in mode 2, and the maximum is PRECISION or -1 to disable\n-\t tracking.  */\n+      /* For a '%s' and '%ls' directive with a non-constant string (either\n+\t one of a number of strings of known length or an unknown string)\n+\t the minimum number of characters is lesser of PRECISION[0] and\n+\t the length of the shortest known string or zero, and the maximum\n+\t is the lessser of the length of the longest known string or\n+\t PTRDIFF_MAX and PRECISION[1].  The likely length is either\n+\t the minimum at level 1 and the greater of the minimum and 1\n+\t at level 2.  This result is adjust upward for width (if it's\n+\t specified).  */\n+\n+      if (dir.modifier == FMT_LEN_l)\n+\t{\n+\t  /* A wide character converts to as few as zero bytes.  */\n+\t  slen.range.min = 0;\n+\t  if (slen.range.max < target_int_max ())\n+\t    slen.range.max *= target_mb_len_max ();\n+\n+\t  if (slen.range.likely < target_int_max ())\n+\t    slen.range.likely *= 2;\n+\n+\t  if (slen.range.likely < target_int_max ())\n+\t    slen.range.unlikely *= target_mb_len_max ();\n+\t}\n+\n+      res.range = slen.range;\n \n       if (dir.prec[0] >= 0)\n \t{\n+\t  /* Adjust the minimum to zero if the string length is unknown,\n+\t     or at most the lower bound of the precision otherwise.  */\n \t  if (slen.range.min >= target_int_max ())\n-\t    slen.range.min = 0;\n+\t    res.range.min = 0;\n \t  else if ((unsigned HOST_WIDE_INT)dir.prec[0] < slen.range.min)\n-\t    {\n-\t      slen.range.min = dir.prec[0];\n-\t      slen.range.likely = slen.range.min;\n-\t    }\n+\t    res.range.min = dir.prec[0];\n \n+\t  /* Make both maxima no greater than the upper bound of precision.  */\n \t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < slen.range.max\n \t      || slen.range.max >= target_int_max ())\n \t    {\n-\t      slen.range.max = dir.prec[1];\n-\t      slen.range.likely = slen.range.max;\n+\t      res.range.max = dir.prec[1];\n+\t      res.range.unlikely = dir.prec[1];\n \t    }\n+\n+\t  /* If precision is constant, set the likely counter to the lesser\n+\t     of it and the maximum string length.  Otherwise, if the lower\n+\t     bound of precision is greater than zero, set the likely counter\n+\t     to the minimum.  Otherwise set it to zero or one based on\n+\t     the warning level.  */\n+\t  if (dir.prec[0] == dir.prec[1])\n+\t    res.range.likely\n+\t      = ((unsigned HOST_WIDE_INT)dir.prec[0] < slen.range.max\n+\t\t ? dir.prec[0] : slen.range.max);\n+\t  else if (dir.prec[0] > 0)\n+\t    res.range.likely = res.range.min;\n+\t  else\n+\t    res.range.likely = warn_level > 1;\n+\t}\n+      else if (dir.prec[1] >= 0)\n+\t{\n+\t  res.range.min = 0;\n+\t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < slen.range.max)\n+\t    res.range.max = dir.prec[1];\n+\t  res.range.likely = dir.prec[1] ? warn_level > 1 : 0;\n \t}\n       else if (slen.range.min >= target_int_max ())\n \t{\n-\t  slen.range.min = 0;\n-\t  slen.range.max = HOST_WIDE_INT_MAX;\n-\t  /* At level one strings of unknown length are assumed to be\n+\t  res.range.min = 0;\n+\t  res.range.max = HOST_WIDE_INT_MAX;\n+\t  /* At level 1 strings of unknown length are assumed to be\n \t     empty, while at level 1 they are assumed to be one byte\n \t     long.  */\n-\t  slen.range.likely = warn_level > 1;\n+\t  res.range.likely = warn_level > 1;\n+\t}\n+      else\n+\t{\n+\t  /* A string of unknown length unconstrained by precision is\n+\t     assumed to be empty at level 1 and just one character long\n+\t     at higher levels.  */\n+\t  if (res.range.likely >= target_int_max ())\n+\t    res.range.likely = warn_level > 1;\n \t}\n \n-      slen.range.unlikely = slen.range.max;\n-\n-      res.range = slen.range;\n-      res.knownrange = slen.knownrange;\n+      res.range.unlikely = res.range.max;\n     }\n \n   /* Bump up the byte counters if WIDTH is greater.  */"}, {"sha": "1289892dadaf4da122ab9b9811c02877b9ce6d79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebee1eb978f5168267f8ee9dc530f620d5639943", "patch": "@@ -1,3 +1,9 @@\n+2017-02-02  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79275\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-11.c: New test.\n+\t* gcc.dg/tree-ssa/pr79275.c: New test.\n+\n 2017-02-02  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n         * gcc.dg/sms-8.c: Update options for powerpc*-*-*."}, {"sha": "b714c952a73e1f447fa241afa590d98067617676", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-11.c", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-11.c?ref=ebee1eb978f5168267f8ee9dc530f620d5639943", "patch": "@@ -0,0 +1,323 @@\n+/* PR middle-end/79275 - -Wformat-overflow false positive exceeding INT_MAX\n+   in glibc sysdeps/posix/tempname.c\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-INT_MAX - 1)\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+extern int int_value (void);\n+extern size_t size_value (void);\n+\n+int int_range (int min, int max)\n+{\n+  int n = int_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+size_t size_range (size_t min, size_t max)\n+{\n+  size_t n = size_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+void sink (char*, char*);\n+\n+int dummy_sprintf (char*, const char*, ...);\n+\n+char buffer [256];\n+extern char *ptr;\n+\n+const char s0[] = \"\";\n+const char s1[] = \"1\";\n+const char s2[] = \"12\";\n+const char s3[] = \"123\";\n+const char s4[] = \"1234\";\n+const char s5[] = \"12345\";\n+const char s6[] = \"123456\";\n+const char s7[] = \"1234567\";\n+const char s8[] = \"12345678\";\n+const char s9[] = \"123456789\";\n+extern const char sx[];\n+extern const char sy[];\n+\n+/* Wide string literals outside the ASCII range to avoid assumptions\n+   about the number of narrow characters they might convert to beyond\n+   up to 6 bytes each (the maximum for UTF-8 not exceeded by any known\n+   encoding).  */\n+const wchar_t ws0[] = L\"\";\n+const wchar_t ws1[] = L\"\\u1111\";\n+const wchar_t ws2[] = L\"\\u1111\\u2222\";\n+const wchar_t ws3[] = L\"\\u1111\\u2222\\u3333\";\n+const wchar_t ws4[] = L\"\\u1111\\u2222\\u3333\\u4444\";\n+const wchar_t ws5[] = L\"\\u1111\\u2222\\u3333\\u4444\\u5555\";\n+const wchar_t ws6[] = L\"\\u1111\\u2222\\u3333\\u4444\\u5555\\u6666\";\n+const wchar_t ws7[] = L\"\\u1111\\u2222\\u3333\\u4444\\u5555\\u6666\\u7777\";\n+const wchar_t ws8[] =\n+  L\"\\u1111\\u2222\\u3333\\u4444\\u5555\\u6666\\u7777\\u8888\";\n+const wchar_t ws9[] =\n+  L\"\\u1111\\u2222\\u3333\\u4444\\u5555\\u6666\\u7777\\u8888\\u9999\";\n+extern const wchar_t wsx[];\n+extern const wchar_t wsy[];\n+\n+static const int imin = INT_MIN;\n+static const int imax = INT_MAX;\n+\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n+\n+/* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#define T(size, ...)\t\t\t\t\t\t\\\n+  (FUNC (sprintf) (buffer (size),  __VA_ARGS__),\t\t\\\n+   sink (buffer, ptr))\n+\n+/* Return a value in the range [MIN, MAX].  */\n+#define IR(min, max)  int_range (min, max)\n+\n+/* Return a string whose length is in the range [MIN, MAX] where\n+   both MIN and MAX must be digits in the range [0, 9].  */\n+#define SR(min, max)  (int_value () < 0 ? s##min : s##max)\n+\n+/* Return a wide string whose length is in the range [MIN, MAX] where\n+   both MIN and MAX must be digits in the range [0, 9].  */\n+#define WR(min, max)  (int_value () < 0 ? ws##min : ws##max)\n+\n+void test_narrow_string_with_precision (void)\n+{\n+  T (-1, \"%.*s\", IR ( 0,  1), SR (0, 1));\n+  T (-1, \"%.*s\", IR ( 0,  1), SR (0, 2));\n+  T (-1, \"%.*s\", IR ( 0,  1), SR (0, 3));\n+  T (-1, \"%.*s\", IR ( 0,  1), SR (0, 4));\n+  T (-1, \"%.*s\", IR ( 0,  1), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0,  2), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0,  3), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0,  4), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0,  9), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0, 99), SR (0, 9));\n+  T (-1, \"%.*s\", IR ( 0, 99), SR (0, x));\n+  T (-1, \"%.*s\", IR ( 0, 99), SR (1, x));\n+  T (-1, \"%.*s\", IR ( 0, 99), SR (x, 1));\n+  T (-1, \"%.*s\", IR ( 0, 99), SR (x, 9));\n+\n+  T (-1, \"%.*s\", IR (imax / 3, imax / 2), SR (x, y));\n+\n+  /* Non-constant zero length string.  */\n+  T ( 0, \"%.*s\", IR (imin, -1), SR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (imin,  0), SR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-1,    0), SR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-1,    1), SR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-1,   99), SR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+\n+  /* String with length between 0 and 1 character.  */\n+  T ( 0, \"%.*s\", IR (imin, -1), SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR (imin, 0),  SR (0, 1));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-2, -1),   SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR (-2,  0),   SR (0, 1));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  1),   SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  2),   SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0, 99),   SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0, imax), SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 1, imax), SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 9, imax), SR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+\n+  /* String with length between 2 and 3 characters.  */\n+  T ( 0, \"%.*s\", IR (imin, -1), SR (2, 3));   /* { dg-warning \"writing between 2 and 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR (imin, 0),  SR (2, 3));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-2, -1),   SR (2, 3));   /* { dg-warning \"writing between 2 and 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR (-2,  0),   SR (2, 3));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (-2,  1),   SR (2, 3));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  1),   SR (2, 3));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  2),   SR (2, 3));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 0, 99),   SR (2, 3));   /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 0, imax), SR (2, 3));   /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 1, 99),   SR (2, 3));   /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 9, 99),   SR (2, 3));   /* { dg-warning \"writing between 2 and 3 bytes\" } */\n+\n+  T ( 0, \"%.*s\", IR ( 0,  1),   SR (0, 9));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  2),   SR (0, 9));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 0,  9),   SR (0, 9));   /* { dg-warning \"writing up to 9 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 0, 79),   SR (0, 9));   /* { dg-warning \"writing up to 9 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 1,  2),   SR (0, 9));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 2,  3),   SR (0, 9));   /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%.*s\", IR ( 7, 13),   SR (0, 9));   /* { dg-warning \"writing up to 9 bytes\" } */\n+\n+  /* String between N and unknown number of characters long.  */\n+  T ( 0, \"%.*s\", IR (imin, -1), SR (0, x));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*s\", IR (imin, -1), SR (1, x));   /* { dg-warning \"writing likely 1 or more bytes\" } */\n+  T ( 1, \"%.*s\", IR (imin, -1), SR (1, x));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (imin, -1), SR (8, x));   /* { dg-warning \"writing likely 8 or more bytes\" } */\n+  T ( 1, \"%.*s\", IR (imin, -1), SR (x, 9));   /* { dg-warning \"writing likely 9 or more bytes\" } */\n+\n+  /* Unknown strings.  */\n+  T ( 1, \"%.*s\", IR (imin, -1), SR (x, y));\n+  T ( 1, \"%.*s\", IR (imin,  0), SR (x, y));\n+  T ( 1, \"%.*s\", IR ( -99,  1), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (  -2,  2), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (  -1, 99), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (   0, 99), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (   1, 99), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", IR (   9, 99), SR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+}\n+\n+void test_narrow_string_with_width_and_precision (void)\n+{\n+  T (-1, \"%*.*s\", IR ( 0,  1), IR ( 0,  1), SR (0, 1));\n+  T (-1, \"%*.*s\", IR ( 0,  1), IR ( 0,  1), SR (0, 2));\n+  T (-1, \"%*.*s\", IR ( 0,  1), IR ( 0,  1), SR (0, 3));\n+  T (-1, \"%*.*s\", IR ( 0,  1), IR ( 0,  1), SR (0, 4));\n+  T (-1, \"%*.*s\", IR ( 0,  1), IR ( 0,  1), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0,  2), IR ( 0,  2), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0,  3), IR ( 0,  3), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0,  4), IR ( 0,  4), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0,  9), IR ( 0,  9), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0, 99), IR ( 0, 99), SR (0, 9));\n+  T (-1, \"%*.*s\", IR ( 0, 99), IR ( 0, 99), SR (0, x));\n+  T (-1, \"%*.*s\", IR ( 0, 99), IR ( 0, 99), SR (1, x));\n+  T (-1, \"%*.*s\", IR ( 0, 99), IR ( 0, 99), SR (x, 1));\n+  T (-1, \"%*.*s\", IR ( 0, 99), IR ( 0, 99), SR (x, 9));\n+  T (-1, \"%*.*s\", IR (12, 34), IR (45, 67), SR (x, 9));\n+  T (-1, \"%*.*s\", IR (12, 34), IR (45, 67), SR (x, y));\n+\n+  T (-1, \"%*.*s\", IR (imax / 5, imax / 4), IR (imax / 3, imax / 2), SR (x, y));\n+\n+  T (-1, \"%*.*s %*.*s\",\n+     IR (imax / 9, imax / 8), IR (imax / 7, imax / 6), SR (x, y),\n+     IR (imax / 5, imax / 4), IR (imax / 3, imax / 2), SR (x, y));\n+\n+  /* The two directives below combined convert to [INT_MAX, INT_MAX + 1].\n+     Since the lower end of the range doesn't exceed INT_MAX no warning\n+     is expected.  */\n+  T (-1, \"%*.*s%*.*s\",\n+     IR (imax - 5, imax - 3), IR (1, 2), SR (x, y),\n+     IR (       5,        6), IR (3, 4), SR (x, y));\n+\n+  /* The three directives below (the two %s plus the space in between)\n+     combined convert to [INT_MAX + 1, INT_MAX + 2].  Since the lower\n+     end of the range exceeds INT_MAX a warning is expected.  */\n+  T (-1, \"%*.*s %*.*s\",                                     /* { dg-warning \"INT_MAX\" } */\n+     IR (imax - 5, imax - 3), IR (1, 2), SR (x, y),\n+     IR (       5,        6), IR (3, 4), SR (x, y));\n+\n+   /* Non-constant zero length string.  */\n+  T ( 0, \"%*.*s\", IR ( 0, 1), IR (imin, -1), SR (0, 0));    /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 2), IR (imin, -1), SR (0, 0));    /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (imin, -1), SR (0, 0));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  1), SR (0, 0));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  1), SR (0, 1));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  2), SR (0, 1));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  3), SR (0, 1));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  1), SR (3, 5));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  2), SR (3, 5));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  3), SR (3, 5));    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  4), SR (3, 5));    /* { dg-warning \"writing up to 4 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  5), SR (3, 5));    /* { dg-warning \"writing up to 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 0, 3), IR (   0,  6), SR (3, 5));    /* { dg-warning \"writing up to 5 bytes\" } */\n+\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  1), SR (3, 5));    /* { dg-warning \"writing between 1 and 2 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  2), SR (3, 5));    /* { dg-warning \"writing between 1 and 2 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  3), SR (3, 5));    /* { dg-warning \"writing between 1 and 3 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  4), SR (3, 5));    /* { dg-warning \"writing between 1 and 4 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  5), SR (3, 5));    /* { dg-warning \"writing between 1 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 1, 2), IR (   0,  6), SR (3, 5));    /* { dg-warning \"writing between 1 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   0,  6), SR (3, 5));    /* { dg-warning \"writing between 2 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   1,  6), SR (3, 5));    /* { dg-warning \"writing between 2 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   2,  6), SR (3, 5));    /* { dg-warning \"writing between 2 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   3,  6), SR (3, 5));    /* { dg-warning \"writing between 3 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   4,  6), SR (3, 5));    /* { dg-warning \"writing between 3 and 5 bytes\" } */\n+  T ( 0, \"%*.*s\", IR ( 2, 3), IR (   5,  6), SR (3, 5));    /* { dg-warning \"writing between 3 and 5 bytes\" } */\n+}\n+\n+void test_wide_string (void)\n+{\n+  T (-1, \"%.*ls\", IR ( 0,  1), WR (0, 1));\n+  T (-1, \"%.*ls\", IR ( 0,  1), WR (0, 2));\n+  T (-1, \"%.*ls\", IR ( 0,  1), WR (0, 3));\n+  T (-1, \"%.*ls\", IR ( 0,  1), WR (0, 4));\n+  T (-1, \"%.*ls\", IR ( 0,  1), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0,  2), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0,  3), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0,  4), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0,  9), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0, 99), WR (0, 9));\n+  T (-1, \"%.*ls\", IR ( 0, 99), WR (0, x));\n+  T (-1, \"%.*ls\", IR ( 0, 99), WR (1, x));\n+  T (-1, \"%.*ls\", IR ( 0, 99), WR (x, 1));\n+  T (-1, \"%.*ls\", IR ( 0, 99), WR (x, 9));\n+\n+   /* Non-constant zero length string.  */\n+  T ( 0, \"%.*ls\", IR (imin, -1), WR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (imin,  0), WR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-1,    0), WR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-1,    1), WR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-1,   99), WR (0, 0));   /* { dg-warning \"writing a terminating nul\" } */\n+\n+  /* String with length between 0 and 1 character.  */\n+  T ( 0, \"%.*ls\", IR (imin, -1), WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+  T ( 0, \"%.*ls\", IR (imin, 0),  WR (0, 1));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-2, -1),   WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+  T ( 0, \"%.*ls\", IR (-2,  0),   WR (0, 1));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  1),   WR (0, 1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  2),   WR (0, 1));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, 99),   WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, imax), WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 1, imax), WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 9, imax), WR (0, 1));   /* { dg-warning \"writing up to 6 bytes\" } */\n+\n+  /* String with length between 2 and 3 characters.  */\n+  T ( 0, \"%.*ls\", IR (imin, -1), WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+  T ( 0, \"%.*ls\", IR (imin, 0),  WR (2, 3));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-2, -1),   WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+  T ( 0, \"%.*ls\", IR (-2,  0),   WR (2, 3));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (-2,  1),   WR (2, 3));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  1),   WR (2, 3));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  2),   WR (2, 3));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, 99),   WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, imax), WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 1, 99),   WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 9, 99),   WR (2, 3));   /* { dg-warning \"writing up to 18 bytes\" } */\n+\n+  T ( 0, \"%.*ls\", IR ( 0,  1),   WR (0, 9));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  2),   WR (0, 9));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0,  9),   WR (0, 9));   /* { dg-warning \"writing up to 9 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, 53),   WR (0, 9));   /* { dg-warning \"writing up to 53 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 0, 55),   WR (0, 9));   /* { dg-warning \"writing up to 54 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 1,  2),   WR (0, 9));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 2,  3),   WR (0, 9));   /* { dg-warning \"writing up to 3 bytes\" } */\n+  T ( 0, \"%.*ls\", IR ( 7, 13),   WR (0, 9));   /* { dg-warning \"writing up to 13 bytes\" } */\n+\n+  /* String between N and unknown number of characters long.  */\n+  T ( 0, \"%.*ls\", IR (imin, -1), WR (0, x));   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 0, \"%.*ls\", IR (imin, -1), WR (1, x));   /* { dg-warning \"writing likely 2 or more bytes\" } */\n+  T ( 1, \"%.*ls\", IR (imin, -1), WR (1, x));   /* { dg-warning \"writing likely 2 or more bytes\" } */\n+  T ( 1, \"%.*ls\", IR (imin, -1), WR (8, x));   /* { dg-warning \"writing likely 16 or more bytes\" } */\n+  T ( 1, \"%.*ls\", IR (imin, -1), WR (x, 9));   /* { dg-warning \"writing likely 18 or more bytes\" } */\n+\n+  /* Unknown strings.  */\n+  T ( 1, \"%.*ls\", IR (imin, -1), WR (x, y));\n+  T ( 1, \"%.*ls\", IR (imin,  0), WR (x, y));\n+  T ( 1, \"%.*ls\", IR ( -99,  1), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*ls\", IR (  -2,  2), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*ls\", IR (  -1, 99), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*ls\", IR (   0, 99), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*ls\", IR (   1, 99), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*ls\", IR (   9, 99), WR (x, y));   /* { dg-warning \"may write a terminating nul\" } */\n+}"}, {"sha": "d3145245bfbd53d2e16af760e02715a27822952d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79275.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79275.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebee1eb978f5168267f8ee9dc530f620d5639943/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79275.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79275.c?ref=ebee1eb978f5168267f8ee9dc530f620d5639943", "patch": "@@ -0,0 +1,14 @@\n+/* PR middle-end/79275 - -Wformat-overflow false positive exceeding INT_MAX\n+   in glibc sysdeps/posix/tempname.c\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void f (char *dst, size_t n, const char *s)\n+{\n+  if (n < 2 || __INT_MAX__ - 2 < n)\n+    n = 2;\n+\n+  __builtin_sprintf (dst, \"%.*s %.*s\", (int)n, s, (int)n, s);   /* { dg-bogus \"INT_MAX\" } */\n+}"}]}