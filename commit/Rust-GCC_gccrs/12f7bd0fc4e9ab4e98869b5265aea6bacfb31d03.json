{"sha": "12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJmN2JkMGZjNGU5YWI0ZTk4ODY5YjUyNjVhZWE2YmFjZmIzMWQwMw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-18T17:57:22Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-20T09:59:22Z"}, "message": "Support struct initializers using Identifiers\n\nThis resolves each identifier for its respective field. It includes fixes\nfor the TypeResolver to print errors instead of asserts where we loose\ndecent debug info.", "tree": {"sha": "aaff0986f81394b83e8536b68a18bcd48ecb9484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaff0986f81394b83e8536b68a18bcd48ecb9484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2acd529fcfa43368f7ea8209cc5e6b88d2bd79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2acd529fcfa43368f7ea8209cc5e6b88d2bd79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2acd529fcfa43368f7ea8209cc5e6b88d2bd79"}], "stats": {"total": 197, "additions": 173, "deletions": 24}, "files": [{"sha": "34122bb231ffce85f45b5fac798a078224f36c68", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -882,6 +882,8 @@ class Expr\n \n   virtual NodeId get_node_id () const { return node_id; }\n \n+  virtual void set_node_id (NodeId id) { node_id = id; }\n+\n protected:\n   // Constructor\n   Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())"}, {"sha": "6dba7fdf8316bcb3f65dc81b57ad186d3eb81ce0", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -1604,6 +1604,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Identifier get_field_name () const { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "0a16f6a25e542f56f821ea7619ae8123cd59427f", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -40,6 +40,8 @@ class CompileStructExprField : public HIRCompileBase\n \n   void visit (HIR::StructExprFieldIndexValue &field);\n \n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n private:\n   CompileStructExprField (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr)"}, {"sha": "ce6d8277063de3afb065e081955b856df2983c1d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -234,5 +234,15 @@ CompileStructExprField::visit (HIR::StructExprFieldIndexValue &field)\n   translated = CompileExpr::Compile (field.get_value (), ctx);\n }\n \n+void\n+CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  translated = CompileExpr::Compile (&expr, ctx);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "c44c9f972e02531c1d11381c0e68c735de2d3765", "filename": "gcc/rust/hir/rust-ast-lower-struct-field-expr.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -34,10 +34,13 @@ class ASTLowerStructExprField : public ASTLoweringBase\n     field->accept_vis (compiler);\n     rust_assert (compiler.translated != nullptr);\n \n-    // compiler.mappings->insert_hir_expr (\n-    //   compiler.translated->get_mappings ().get_crate_num (),\n-    //   compiler.translated->get_mappings ().get_hirid (),\n-    //   compiler.translated);\n+    compiler.mappings->insert_hir_struct_field (\n+      compiler.translated->get_mappings ().get_crate_num (),\n+      compiler.translated->get_mappings ().get_hirid (), compiler.translated);\n+    compiler.mappings->insert_location (\n+      compiler.translated->get_mappings ().get_crate_num (),\n+      compiler.translated->get_mappings ().get_hirid (),\n+      field->get_locus_slow ());\n \n     return compiler.translated;\n   }\n@@ -48,6 +51,8 @@ class ASTLowerStructExprField : public ASTLoweringBase\n \n   void visit (AST::StructExprFieldIndexValue &field);\n \n+  void visit (AST::StructExprFieldIdentifier &field);\n+\n private:\n   ASTLowerStructExprField () : translated (nullptr) {}\n "}, {"sha": "dac2320d84abe17362cec2bfe26030f7f139056b", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -228,5 +228,18 @@ ASTLowerStructExprField::visit (AST::StructExprFieldIndexValue &field)\n \t\t\t\t\t  field.get_locus ());\n }\n \n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprFieldIdentifier (mapping, field.get_field_name (),\n+\t\t\t\t\t  field.get_locus ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "ff3fbab1dc251da695a73add7cba33ce575b759b", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -1496,6 +1496,8 @@ class StructExprFieldIdentifier : public StructExprField\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_field_name () const { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "391647327697c99e2aef7f169c5f6e6ffb74fae1", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -26,8 +26,7 @@ namespace Rust {\n namespace Resolver {\n \n // this resolves values being assigned not that the field actually exists yet.\n-// We cant resolve the field to struct until type resolution since the HIR\n-// Mappings don't exist yet.\n+\n class ResolveStructExprField : public ResolverBase\n {\n public:\n@@ -43,6 +42,8 @@ class ResolveStructExprField : public ResolverBase\n \n   void visit (AST::StructExprFieldIndexValue &field);\n \n+  void visit (AST::StructExprFieldIdentifier &field);\n+\n private:\n   ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "ec53ae04b295bc2cee8e63747b7b78c07d510d2a", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -324,5 +324,14 @@ ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n   ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n }\n \n+void\n+ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  AST::IdentifierExpr expr (field.get_field_name (), field.get_locus ());\n+  expr.set_node_id (field.get_node_id ());\n+\n+  ResolveExpr::go (&expr, field.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "48ab40ffd17d29c9d8874fe46f7f8fcd3d98e485", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -46,6 +46,8 @@ class TypeCheckStructExpr : public TypeCheckBase\n \n   void visit (HIR::StructExprFieldIndexValue &field);\n \n+  void visit (HIR::StructExprFieldIdentifier &field);\n+\n private:\n   TypeCheckStructExpr ()\n     : TypeCheckBase (), resolved (nullptr), struct_path_resolved (nullptr)"}, {"sha": "6f8c3a1313a1a48c9ed9aaa4a9866bdd4b3ecc7e", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -222,5 +222,34 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n     fields_assigned.insert (field_name);\n }\n \n+void\n+TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n+{\n+  auto it = fields_assigned.find (field.get_field_name ());\n+  if (it != fields_assigned.end ())\n+    {\n+      rust_fatal_error (field.get_locus (), \"used more than once\");\n+      return;\n+    }\n+\n+  TyTy::StructFieldType *field_type\n+    = struct_path_resolved->get_field (field.get_field_name ());\n+  if (field_type == nullptr)\n+    {\n+      rust_error_at (field.get_locus (), \"unknown field\");\n+      return;\n+    }\n+\n+  // we can make the field look like an identifier expr to take advantage of\n+  // existing code to figure out the type\n+  HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n+\t\t\t    field.get_locus ());\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (&expr);\n+\n+  resolved_field = field_type->get_field_type ()->combine (value);\n+  if (resolved_field != nullptr)\n+    fields_assigned.insert (field.field_name);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "eb03ff9b7501e43f4f9469f94552903e014ab1f5", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -44,41 +44,62 @@ class TyTyResolver\n \n   void go (Rib *rib)\n   {\n-    rib->iterate_decls ([&] (NodeId decl_node_id, Location) mutable -> bool {\n+    rib->iterate_decls ([&] (NodeId decl_node_id,\n+\t\t\t     Location locus) mutable -> bool {\n       // type inference in rust means we need to gather and examine all\n       // references of this decl and combine each to make sure the type is\n       // correctly inferred. Consider the example:\n       // let mut x; x = 1;\n       // we can only say x is an infer variable then at the assignment\n       // we think x must be an integer\n \n+      bool ok = true;\n       std::vector<TyTy::TyBase *> gathered_types;\n       rib->iterate_references_for_def (\n \tdecl_node_id, [&] (NodeId ref_node) mutable -> bool {\n \t  HirId hir_node_ref;\n-\t  bool ok\n-\t    = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t    ref_node, &hir_node_ref);\n-\t  rust_assert (ok);\n+\t  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t     ref_node, &hir_node_ref))\n+\t    {\n+\t      rust_error_at (locus,\n+\t\t\t     \"failed to reserve lookup HIR node for reference\");\n+\t      ok = false;\n+\t      return false;\n+\t    }\n \n \t  TyTy::TyBase *resolved = nullptr;\n \t  if (!context->lookup_type (hir_node_ref, &resolved))\n \t    {\n \t      // this could be an array/adt type\n \t      Definition d;\n-\t      bool ok = resolver->lookup_definition (ref_node, &d);\n-\t      rust_assert (ok);\n+\t      if (!resolver->lookup_definition (ref_node, &d))\n+\t\t{\n+\t\t  rust_error_at (\n+\t\t    locus,\n+\t\t    \"failed to lookup definition for referenced hir node\");\n+\n+\t\t  ok = false;\n+\t\t  return false;\n+\t\t}\n+\n+\t      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n+\t\t\t\t\t\t d.parent, &hir_node_ref))\n+\t\t{\n+\t\t  rust_error_at (locus,\n+\t\t\t\t \"failed to lookup HIR node for parent NodeId\");\n \n-\t      ok = mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t\t d.parent, &hir_node_ref);\n-\t      rust_assert (ok);\n+\t\t  ok = false;\n+\t\t  return false;\n+\t\t}\n \n \t      if (!context->lookup_type (hir_node_ref, &resolved))\n \t\t{\n-\t\t  rust_fatal_error (\n+\t\t  rust_error_at (\n \t\t    mappings->lookup_location (hir_node_ref),\n \t\t    \"failed to lookup type for reference at node [%u]\",\n \t\t    hir_node_ref);\n+\n+\t\t  ok = false;\n \t\t  return false;\n \t\t}\n \t    }\n@@ -88,18 +109,29 @@ class TyTyResolver\n \t});\n \n       Definition d;\n-      bool ok = resolver->lookup_definition (decl_node_id, &d);\n-      rust_assert (ok);\n+      if (!resolver->lookup_definition (decl_node_id, &d))\n+\t{\n+\t  rust_error_at (locus, \"Failed to lookup definition within rib\");\n+\t  return false;\n+\t}\n \n       HIR::Stmt *decl = nullptr;\n-      ok = mappings->resolve_nodeid_to_stmt (d.parent, &decl);\n-      rust_assert (ok);\n+      if (!mappings->resolve_nodeid_to_stmt (d.parent, &decl))\n+\t{\n+\t  rust_error_at (locus, \"Failed to resolve decl to HIR::Stmt\");\n+\t  return false;\n+\t}\n \n       TyTy::TyBase *resolved_type = nullptr;\n-      ok = context->lookup_type (decl->get_mappings ().get_hirid (),\n-\t\t\t\t &resolved_type);\n-      rust_assert (ok);\n+      if (!context->lookup_type (decl->get_mappings ().get_hirid (),\n+\t\t\t\t &resolved_type))\n+\t{\n+\t  rust_error_at (locus, \"Unknown base type for decl in Rib\");\n+\t  return false;\n+\t}\n \n+      // if it is not infer then it must have been figured out already\n+      // we might need changes for generics later on\n       if (resolved_type->get_kind () != TyTy::TypeKind::INFER)\n \treturn true;\n "}, {"sha": "c6e177b8b8d35c7ed8691ace6244cb302a10c00a", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -349,6 +349,30 @@ Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_struct_field (CrateNum crateNum, HirId id,\n+\t\t\t\t   HIR::StructExprField *field)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirStructFieldMappings[crateNum][id] = field;\n+  nodeIdToHirMappings[crateNum][field->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::StructExprField *\n+Mappings::lookup_hir_struct_field (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirStructFieldMappings.find (crateNum);\n+  if (it == hirStructFieldMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n \t\t\t\t      HIR::Item *item)"}, {"sha": "3818be9f2fecd7a65c14d3e3f1c98405c3740b51", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -121,6 +121,10 @@ class Mappings\n   void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n   HIR::FunctionParam *lookup_hir_param (CrateNum crateNum, HirId id);\n \n+  void insert_hir_struct_field (CrateNum crateNum, HirId id,\n+\t\t\t\tHIR::StructExprField *type);\n+  HIR::StructExprField *lookup_hir_struct_field (CrateNum crateNum, HirId id);\n+\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n@@ -159,6 +163,8 @@ class Mappings\n   std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Stmt *> > hirStmtMappings;\n   std::map<CrateNum, std::map<HirId, HIR::FunctionParam *> > hirParamMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::StructExprField *> >\n+    hirStructFieldMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "fb1e58efcbae7e22ea998ea86f3fe720275dafbd", "filename": "gcc/testsuite/rust.test/compilable/struct_init_3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fstruct_init_3.rs?ref=12f7bd0fc4e9ab4e98869b5265aea6bacfb31d03", "patch": "@@ -0,0 +1,10 @@\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {\n+    let a = 1;\n+    let b = 2;\n+    let c = Foo { a, b };\n+}"}]}