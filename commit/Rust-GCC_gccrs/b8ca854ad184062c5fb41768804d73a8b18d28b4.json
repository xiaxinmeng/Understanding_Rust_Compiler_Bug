{"sha": "b8ca854ad184062c5fb41768804d73a8b18d28b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjYTg1NGFkMTg0MDYyYzVmYjQxNzY4ODA0ZDczYThiMThkMjhiNA==", "commit": {"author": {"name": "Jeff Sturm", "email": "jsturm@one-point.com", "date": "2003-11-18T03:57:08Z"}, "committer": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2003-11-18T03:57:08Z"}, "message": "re PR java/12857 (Illegal method modifier when loading a generated .class)\n\nFix PR java/12857.\n\ndecl.c (java_init_decl_processing): Don't initialize\nclass_not_found_type_node, no_class_def_found_type_node.\n\njava-tree.h (JTI_CLASS_NOT_FOUND_TYPE_NODE,\nJTI_NO_CLASS_DEF_FOUND_TYPE_NODE): Remove from java_tree_index.\n(class_not_found_type_node, no_class_def_found_type_node):\nDon't define.\n\nparse.y (build_dot_class_method_invocation): Add this_class\nargument.  Qualify method invocations to a different class.\n(create_new_parser_context): Initialize saved_data_ctx to 0.\n(java_parser_context_save_global): Initialize saved_data_ctx to 1.\n(build_dot_class_method): Don't load classes.  Register\nincomplete types.\n(build_incomplete_class_ref): Special cases for interfaces\nand inner classes.  Move build_dot_class_method call to here...\n(patch_incomplete_class_ref): ...from here.  Pass current_class\nto build_dot_class_method_invocation.\n(build_assertion): Pass class_type to\nbuild_dot_class_method_invocation.\n(encapsulate_with_try_catch): Handle EXPR_WITH_FILE_LOCATION node.\n\nFrom-SVN: r73691", "tree": {"sha": "f2c4076691ff089f645cb3ea0584d76a88894787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2c4076691ff089f645cb3ea0584d76a88894787"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8ca854ad184062c5fb41768804d73a8b18d28b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ca854ad184062c5fb41768804d73a8b18d28b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ca854ad184062c5fb41768804d73a8b18d28b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ca854ad184062c5fb41768804d73a8b18d28b4/comments", "author": null, "committer": null, "parents": [{"sha": "a78e4fa7643f1264968e86476a2f39a2a241f202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78e4fa7643f1264968e86476a2f39a2a241f202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78e4fa7643f1264968e86476a2f39a2a241f202"}], "stats": {"total": 145, "additions": 110, "deletions": 35}, "files": [{"sha": "ea30c778e8ae1c79c9320461ee064a384437b12a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=b8ca854ad184062c5fb41768804d73a8b18d28b4", "patch": "@@ -1,3 +1,29 @@\n+2003-11-17  Jeff Sturm  <jsturm@one-point.com>\n+\n+\tFix PR java/12857.\n+\n+\tdecl.c (java_init_decl_processing): Don't initialize\n+\tclass_not_found_type_node, no_class_def_found_type_node.\n+\n+\tjava-tree.h (JTI_CLASS_NOT_FOUND_TYPE_NODE,\n+\tJTI_NO_CLASS_DEF_FOUND_TYPE_NODE): Remove from java_tree_index.\n+\t(class_not_found_type_node, no_class_def_found_type_node):\n+\tDon't define.\n+\n+\tparse.y (build_dot_class_method_invocation): Add this_class\n+\targument.  Qualify method invocations to a different class.\n+\t(create_new_parser_context): Initialize saved_data_ctx to 0.\n+\t(java_parser_context_save_global): Initialize saved_data_ctx to 1.\n+\t(build_dot_class_method): Don't load classes.  Register\n+\tincomplete types.\n+\t(build_incomplete_class_ref): Special cases for interfaces\n+\tand inner classes.  Move build_dot_class_method call to here...\n+\t(patch_incomplete_class_ref): ...from here.  Pass current_class\n+\tto build_dot_class_method_invocation.\n+\t(build_assertion): Pass class_type to\n+\tbuild_dot_class_method_invocation.\n+\t(encapsulate_with_try_catch): Handle EXPR_WITH_FILE_LOCATION node.\n+\n 2003-11-17  Jeff Sturm  <jsturm@one-point.com>\n \n \tFix PR java/12739."}, {"sha": "b8f09e1dfaa101b0fb9d80d2f21d534b3c03b4a0", "filename": "gcc/java/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=b8ca854ad184062c5fb41768804d73a8b18d28b4", "patch": "@@ -553,10 +553,6 @@ java_init_decl_processing (void)\n     lookup_class (get_identifier (\"java.lang.RuntimeException\"));\n   error_exception_type_node = \n     lookup_class (get_identifier (\"java.lang.Error\"));\n-  class_not_found_type_node = \n-    lookup_class (get_identifier (\"java.lang.ClassNotFoundException\"));\n-  no_class_def_found_type_node = \n-    lookup_class (get_identifier (\"java.lang.NoClassDefFoundError\"));\n \n   rawdata_ptr_type_node\n     = promote_type (lookup_class (get_identifier (\"gnu.gcj.RawData\")));"}, {"sha": "2c706c9fe44b03f6ca22dd70f5175fa7e145d3f3", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=b8ca854ad184062c5fb41768804d73a8b18d28b4", "patch": "@@ -308,8 +308,6 @@ enum java_tree_index\n   JTI_RUNTIME_EXCEPTION_TYPE_NODE,\n   JTI_ERROR_EXCEPTION_TYPE_NODE,\n   JTI_RAWDATA_PTR_TYPE_NODE,\n-  JTI_CLASS_NOT_FOUND_TYPE_NODE,\n-  JTI_NO_CLASS_DEF_FOUND_TYPE_NODE,\n \n   JTI_BYTE_ARRAY_TYPE_NODE,\n   JTI_SHORT_ARRAY_TYPE_NODE,\n@@ -492,10 +490,6 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_ERROR_EXCEPTION_TYPE_NODE]\n #define rawdata_ptr_type_node \\\n   java_global_trees[JTI_RAWDATA_PTR_TYPE_NODE]\n-#define class_not_found_type_node \\\n-  java_global_trees[JTI_CLASS_NOT_FOUND_TYPE_NODE]\n-#define no_class_def_found_type_node \\\n-  java_global_trees[JTI_NO_CLASS_DEF_FOUND_TYPE_NODE]\n \n #define byte_array_type_node \\\n   java_global_trees[JTI_BYTE_ARRAY_TYPE_NODE]"}, {"sha": "5613c8767987a7239e11abe40c46b06278029d38", "filename": "gcc/java/parse.y", "status": "modified", "additions": 84, "deletions": 25, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8ca854ad184062c5fb41768804d73a8b18d28b4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=b8ca854ad184062c5fb41768804d73a8b18d28b4", "patch": "@@ -326,7 +326,7 @@ static void patch_anonymous_class (tree, tree, tree);\n static void add_inner_class_fields (tree, tree);\n \n static tree build_dot_class_method (tree);\n-static tree build_dot_class_method_invocation (tree);\n+static tree build_dot_class_method_invocation (tree, tree);\n static void create_new_parser_context (int);\n static tree maybe_build_class_init_for_field (tree, tree);\n \n@@ -2660,7 +2660,9 @@ create_new_parser_context (int copy_from_previous)\n   if (copy_from_previous)\n     {\n       memcpy (new, ctxp, sizeof (struct parser_ctxt));\n-      new->saved_data_ctx = 1;\n+      /* This flag, indicating the context saves global values,\n+\t should only be set by java_parser_context_save_global.  */\n+      new->saved_data_ctx = 0;\n     }\n   else\n     memset (new, 0, sizeof (struct parser_ctxt));\n@@ -2733,7 +2735,10 @@ java_parser_context_save_global (void)\n   /* If this context already stores data, create a new one suitable\n      for data storage. */\n   else if (ctxp->saved_data)\n-    create_new_parser_context (1);\n+    {\n+      create_new_parser_context (1);\n+      ctxp->saved_data_ctx = 1;\n+    }\n \n   ctxp->lineno = input_line;\n   ctxp->class_type = current_class;\n@@ -8724,7 +8729,7 @@ build_dot_class_method (tree class)\n {\n #define BWF(S) build_wfl_node (get_identifier ((S)))\n #define MQN(X,Y) make_qualified_name ((X), (Y), 0)\n-  tree args, tmp, saved_current_function_decl, mdecl;\n+  tree args, tmp, saved_current_function_decl, mdecl, qual_name;\n   tree stmt, throw_stmt;\n \n   if (!get_message_wfl)\n@@ -8741,15 +8746,17 @@ build_dot_class_method (tree class)\n   /* Build the qualified name java.lang.Class.forName */\n   tmp = MQN (MQN (MQN (BWF (\"java\"),\n \t\t       BWF (\"lang\")), BWF (\"Class\")), BWF (\"forName\"));\n-  load_class (class_not_found_type_node, 1);\n-  load_class (no_class_def_found_type_node, 1);\n \n   /* Create the \"class$\" function */\n   mdecl = create_artificial_method (class, ACC_STATIC,\n \t\t\t\t    build_pointer_type (class_type_node),\n \t\t\t\t    classdollar_identifier_node, args);\n-  DECL_FUNCTION_THROWS (mdecl) =\n-    build_tree_list (NULL_TREE, no_class_def_found_type_node);\n+  qual_name = MQN (MQN (BWF (\"java\"), BWF (\"lang\")),\n+\t\t   BWF (\"NoClassDefFoundError\"));\n+  DECL_FUNCTION_THROWS (mdecl) = build_tree_list (NULL_TREE, qual_name);\n+  register_incomplete_type (JDEP_EXCEPTION, qual_name, NULL_TREE, NULL_TREE);\n+  JDEP_GET_PATCH (CLASSD_LAST (ctxp->classd_list)) =\n+    &TREE_VALUE (DECL_FUNCTION_THROWS (mdecl));\n \n   /* We start by building the try block. We need to build:\n        return (java.lang.Class.forName (type)); */\n@@ -8772,8 +8779,9 @@ build_dot_class_method (tree class)\n   throw_stmt = build1 (THROW_EXPR, NULL_TREE, throw_stmt);\n \n   /* Encapsulate STMT in a try block. The catch clause executes THROW_STMT */\n-  stmt = encapsulate_with_try_catch (0, class_not_found_type_node,\n-\t\t\t\t     stmt, throw_stmt);\n+  qual_name = MQN (MQN (BWF (\"java\"), BWF (\"lang\")),\n+\t\t   BWF (\"ClassNotFoundException\"));\n+  stmt = encapsulate_with_try_catch (0, qual_name, stmt, throw_stmt);\n \n   fix_method_argument_names (args, mdecl);\n   layout_class_method (class, NULL_TREE, mdecl, NULL_TREE);\n@@ -8788,9 +8796,10 @@ build_dot_class_method (tree class)\n }\n \n static tree\n-build_dot_class_method_invocation (tree type)\n+build_dot_class_method_invocation (tree this_class, tree type)\n {\n-  tree sig_id, s;\n+  tree dot_class_method = TYPE_DOT_CLASS (this_class);\n+  tree sig_id, s, t;\n \n   if (TYPE_ARRAY_P (type))\n     sig_id = build_java_signature (type);\n@@ -8803,8 +8812,14 @@ build_dot_class_method_invocation (tree type)\n \n   s = build_string (IDENTIFIER_LENGTH (sig_id),\n \t\t    IDENTIFIER_POINTER (sig_id));\n-  return build_method_invocation (build_wfl_node (classdollar_identifier_node),\n-\t\t\t\t  build_tree_list (NULL_TREE, s));\n+  t = build_method_invocation (build_wfl_node (DECL_NAME (dot_class_method)),\n+\t\t\t       build_tree_list (NULL_TREE, s));\n+  if (DECL_CONTEXT (dot_class_method) != this_class)\n+    {\n+      tree class_name = DECL_NAME (TYPE_NAME (DECL_CONTEXT (dot_class_method)));\n+      t = make_qualified_primary (build_wfl_node (class_name), t, 0);\n+    }\n+  return t;\n }\n \n /* This section of the code deals with constructor.  */\n@@ -14099,6 +14114,44 @@ static tree\n build_incomplete_class_ref (int location, tree class_name)\n {\n   tree node = build1 (CLASS_LITERAL, NULL_TREE, class_name);\n+  tree class_decl = GET_CPC ();\n+  tree this_class = TREE_TYPE (class_decl);\n+\n+  /* Generate the synthetic static method `class$'.  (Previously we\n+     deferred this, causing different method tables to be emitted\n+     for native code and bytecode.)  */\n+  if (!TYPE_DOT_CLASS (this_class)\n+      && !JPRIMITIVE_TYPE_P (class_name)\n+      && !(TREE_CODE (class_name) == VOID_TYPE))\n+    {\n+      tree target_class;\n+\n+      if (CLASS_INTERFACE (TYPE_NAME (this_class)))\n+\t{\n+\t  /* For interfaces, adding a static 'class$' method directly \n+\t     is illegal.  So create an inner class to contain the new\n+\t     method.  Empirically this matches the behavior of javac.  */\n+\t  tree t = build_wfl_node (DECL_NAME (TYPE_NAME (object_type_node)));\n+\t  tree inner = create_anonymous_class (0, t);\n+\t  target_class = TREE_TYPE (inner);\n+\t  end_class_declaration (1);\n+\t}\n+      else\n+\t{\n+\t  /* For inner classes, add a 'class$' method to their outermost\n+\t     context, creating it if necessary.  */\n+\t  while (INNER_CLASS_DECL_P (class_decl))\n+\t    class_decl = DECL_CONTEXT (class_decl);\n+\t  target_class = TREE_TYPE (class_decl);\n+\t}\n+\n+      if (TYPE_DOT_CLASS (target_class) == NULL_TREE)\n+\tbuild_dot_class_method (target_class);\n+\n+      if (this_class != target_class)\n+      \tTYPE_DOT_CLASS (this_class) = TYPE_DOT_CLASS (target_class);\n+    }\n+\n   EXPR_WFL_LINECOL (node) = location;\n   return node;\n }\n@@ -14113,12 +14166,6 @@ patch_incomplete_class_ref (tree node)\n   if (!(ref_type = resolve_type_during_patch (type)))\n     return error_mark_node;\n \n-  /* Generate the synthetic static method `class$'.  (Previously we\n-     deferred this, causing different method tables to be emitted\n-     for native code and bytecode.)  */\n-  if (!TYPE_DOT_CLASS (current_class))\n-      build_dot_class_method (current_class);\n-\n   /* If we're not emitting class files and we know ref_type is a\n      compiled class, build a direct reference.  */\n   if ((! flag_emit_class_files && is_compiled_class (ref_type))\n@@ -14134,7 +14181,7 @@ patch_incomplete_class_ref (tree node)\n \n   /* If we're emitting class files and we have to deal with non\n      primitive types, we invoke the synthetic static method `class$'.  */\n-  ref_type = build_dot_class_method_invocation (ref_type);\n+  ref_type = build_dot_class_method_invocation (current_class, ref_type);\n   return java_complete_tree (ref_type);\n }\n \n@@ -15398,7 +15445,7 @@ build_assertion (int location, tree condition, tree value)\n \n       if (!TYPE_DOT_CLASS (class_type))\n \tbuild_dot_class_method (class_type);\n-      classdollar = build_dot_class_method_invocation (class_type);\n+      classdollar = build_dot_class_method_invocation (class_type, class_type);\n \n       /* Call CLASS.desiredAssertionStatus().  */\n       id = build_wfl_node (get_identifier (\"desiredAssertionStatus\"));\n@@ -15456,7 +15503,7 @@ build_assertion (int location, tree condition, tree value)\n    catches TYPE and executes CATCH_STMTS.  */\n \n static tree\n-encapsulate_with_try_catch (int location, tree type, tree try_stmts,\n+encapsulate_with_try_catch (int location, tree type_or_name, tree try_stmts,\n \t\t\t    tree catch_stmts)\n {\n   tree try_block, catch_clause_param, catch_block, catch;\n@@ -15465,8 +15512,20 @@ encapsulate_with_try_catch (int location, tree type, tree try_stmts,\n   try_block = build_expr_block (try_stmts, NULL_TREE);\n \n   /* Build a catch block: we need a catch clause parameter */\n-  catch_clause_param = build_decl (VAR_DECL,\n-\t\t\t\t   wpv_id, build_pointer_type (type));\n+  if (TREE_CODE (type_or_name) == EXPR_WITH_FILE_LOCATION)\n+    {\n+      tree catch_type = obtain_incomplete_type (type_or_name);\n+      jdep *dep;\n+      catch_clause_param = build_decl (VAR_DECL, wpv_id, catch_type);\n+      register_incomplete_type (JDEP_VARIABLE, type_or_name,\n+\t\t\t\tcatch_clause_param, catch_type);\n+      dep = CLASSD_LAST (ctxp->classd_list);\n+      JDEP_GET_PATCH (dep) = &TREE_TYPE (catch_clause_param);\n+    }\n+  else\n+    catch_clause_param = build_decl (VAR_DECL, wpv_id,\n+\t\t\t\t     build_pointer_type (type_or_name));\n+\n   /* And a block */\n   catch_block = build_expr_block (NULL_TREE, catch_clause_param);\n "}]}