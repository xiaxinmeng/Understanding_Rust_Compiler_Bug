{"sha": "1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwMGM2NmYwZDlkNThlYzU4NjY2YmJjZTE2MDFjY2YzZmQ4YjNlYw==", "commit": {"author": {"name": "Felix Yang", "email": "felix.yang@huawei.com", "date": "2015-01-18T02:25:42Z"}, "committer": {"name": "Fei Yang", "email": "fyang@gcc.gnu.org", "date": "2015-01-18T02:25:42Z"}, "message": "auto-profile.c (afdo_find_equiv_class): Remove unnecessary test.\n\n        * auto-profile.c (afdo_find_equiv_class): Remove unnecessary test.\n        (autofdo_source_profile::get_callsite_total_count,\n        function_instance::get_function_instance_by_decl,\n        string_table::get_index, string_table::get_index_by_decl,\n        afdo_vpt_for_early_inline, afdo_callsite_hot_enough_for_early_inline):\n        Fix comment typos. Reformatting and minor code rearrangement.\n\nFrom-SVN: r219812", "tree": {"sha": "56d8559a557f3483284f2db70c5b7fc0c57a62fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56d8559a557f3483284f2db70c5b7fc0c57a62fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec/comments", "author": null, "committer": null, "parents": [{"sha": "a07c25b5cb2f0cd85a2c0d02bf7d6d54c224e310", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07c25b5cb2f0cd85a2c0d02bf7d6d54c224e310", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a07c25b5cb2f0cd85a2c0d02bf7d6d54c224e310"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "ca035f97c747d6c5041815bef4d7ff20acbe976b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "patch": "@@ -1,3 +1,12 @@\n+2015-01-18  Felix Yang  <felix.yang@huawei.com>\n+\n+\t* auto-profile.c (afdo_find_equiv_class): Remove unnecessary test.\n+\t(autofdo_source_profile::get_callsite_total_count,\n+\tfunction_instance::get_function_instance_by_decl,\n+\tstring_table::get_index, string_table::get_index_by_decl,\n+\tafdo_vpt_for_early_inline, afdo_callsite_hot_enough_for_early_inline):\n+\tFix comment typos. Reformatting and minor code rearrangement.\n+\n 2015-01-17  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (probe_stack): Delete."}, {"sha": "ba2d5ab654e633ac63f88d565d19c6c29851df3a", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=1500c66f0d9d58ec58666bbce1601ccf3fd8b3ec", "patch": "@@ -107,7 +107,7 @@ along with GCC; see the file COPYING3.  If not see\n      standalone symbol, or a clone of a function that is inlined into another\n      function.\n \n-   Phase 2: Early inline + valur profile transformation.\n+   Phase 2: Early inline + value profile transformation.\n      Early inline uses autofdo_source_profile to find if a callsite is:\n         * inlined in the profiled binary.\n         * callee body is hot in the profiling run.\n@@ -372,7 +372,7 @@ get_original_name (const char *name)\n \n /* Return the combined location, which is a 32bit integer in which\n    higher 16 bits stores the line offset of LOC to the start lineno\n-   of DECL, The lower 16 bits stores the discrimnator.  */\n+   of DECL, The lower 16 bits stores the discriminator.  */\n \n static unsigned\n get_combined_location (location_t loc, tree decl)\n@@ -435,7 +435,7 @@ get_inline_stack (location_t locus, inline_stack *stack)\n \n /* Return STMT's combined location, which is a 32bit integer in which\n    higher 16 bits stores the line offset of LOC to the start lineno\n-   of DECL, The lower 16 bits stores the discrimnator.  */\n+   of DECL, The lower 16 bits stores the discriminator.  */\n \n static unsigned\n get_relative_location_for_stmt (gimple stmt)\n@@ -492,8 +492,8 @@ string_table::get_index (const char *name) const\n   string_index_map::const_iterator iter = map_.find (name);\n   if (iter == map_.end ())\n     return -1;\n-  else\n-    return iter->second;\n+\n+  return iter->second;\n }\n \n /* Return the index of a given function DECL. Return -1 if DECL is not \n@@ -513,8 +513,8 @@ string_table::get_index_by_decl (tree decl) const\n     return ret;\n   if (DECL_ABSTRACT_ORIGIN (decl))\n     return get_index_by_decl (DECL_ABSTRACT_ORIGIN (decl));\n-  else\n-    return -1;\n+\n+  return -1;\n }\n \n /* Return the function name of a given INDEX.  */\n@@ -580,8 +580,8 @@ function_instance::get_function_instance_by_decl (unsigned lineno,\n     }\n   if (DECL_ABSTRACT_ORIGIN (decl))\n     return get_function_instance_by_decl (lineno, DECL_ABSTRACT_ORIGIN (decl));\n-  else\n-    return NULL;\n+\n+  return NULL;\n }\n \n /* Store the profile info for LOC in INFO. Return TRUE if profile info\n@@ -608,7 +608,7 @@ function_instance::mark_annotated (location_t loc)\n   iter->second.annotated = true;\n }\n \n-/* Read the inlinied indirect call target profile for STMT and store it in\n+/* Read the inlined indirect call target profile for STMT and store it in\n    MAP, return the total count for all inlined indirect calls.  */\n \n gcov_type\n@@ -835,8 +835,8 @@ autofdo_source_profile::get_callsite_total_count (\n       || afdo_string_table->get_index (IDENTIFIER_POINTER (\n              DECL_ASSEMBLER_NAME (edge->callee->decl))) != s->name ())\n     return 0;\n-  else\n-    return s->total_count ();\n+\n+  return s->total_count ();\n }\n \n /* Read AutoFDO profile and returns TRUE on success.  */\n@@ -967,9 +967,9 @@ read_profile (void)\n    histograms for indirect-call optimization.\n \n    This function is actually served for 2 purposes:\n- \u00a0 \u00a0 * before annotation, we need to mark histogram, promote and inline\n- \u00a0 \u00a0 * after annotation, we just need to mark, and let follow-up logic to\n- \u00a0 \u00a0 \u00a0 decide if it needs to promote and inline.  */\n+     * before annotation, we need to mark histogram, promote and inline\n+     * after annotation, we just need to mark, and let follow-up logic to\n+       decide if it needs to promote and inline.  */\n \n static void\n afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n@@ -1065,7 +1065,7 @@ set_edge_annotated (edge e, edge_set *annotated)\n }\n \n /* For a given BB, set its execution count. Attach value profile if a stmt\n-   is not in PROMOTED, because we only want to promot an indirect call once.\n+   is not in PROMOTED, because we only want to promote an indirect call once.\n    Return TRUE if BB is annotated.  */\n \n static bool\n@@ -1149,7 +1149,7 @@ afdo_find_equiv_class (bb_set *annotated_bb)\n         bb1->aux = bb;\n         if (bb1->count > bb->count && is_bb_annotated (bb1, *annotated_bb))\n           {\n-            bb->count = MAX (bb->count, bb1->count);\n+            bb->count = bb1->count;\n             set_bb_annotated (bb, annotated_bb);\n           }\n       }\n@@ -1161,7 +1161,7 @@ afdo_find_equiv_class (bb_set *annotated_bb)\n         bb1->aux = bb;\n         if (bb1->count > bb->count && is_bb_annotated (bb1, *annotated_bb))\n           {\n-            bb->count = MAX (bb->count, bb1->count);\n+            bb->count = bb1->count;\n             set_bb_annotated (bb, annotated_bb);\n           }\n       }\n@@ -1466,13 +1466,14 @@ afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n           }\n       }\n   }\n+\n   if (has_vpt)\n     {\n       optimize_inline_calls (current_function_decl);\n       return true;\n     }\n-  else\n-    return false;\n+\n+  return false;\n }\n \n /* Annotate auto profile to the control flow graph. Do not annotate value\n@@ -1667,19 +1668,20 @@ afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)\n {\n   gcov_type count\n       = autofdo::afdo_source_profile->get_callsite_total_count (edge);\n+\n   if (count > 0)\n     {\n       bool is_hot;\n       const struct gcov_ctr_summary *saved_profile_info = profile_info;\n-      /* At earling inline stage, profile_info is not set yet. We need to\n+      /* At early inline stage, profile_info is not set yet. We need to\n          temporarily set it to afdo_profile_info to calculate hotness.  */\n       profile_info = autofdo::afdo_profile_info;\n       is_hot = maybe_hot_count_p (NULL, count);\n       profile_info = saved_profile_info;\n       return is_hot;\n     }\n-  else\n-    return false;\n+\n+  return false;\n }\n \n namespace"}]}