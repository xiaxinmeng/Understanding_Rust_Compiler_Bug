{"sha": "c127c1274ff15e01fa10b3221a68522a644e0bfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEyN2MxMjc0ZmYxNWUwMWZhMTBiMzIyMWE2ODUyMmE2NDRlMGJmYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-01T03:05:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-01T03:05:52Z"}, "message": "* h8300.md: Fix formatting.\n\nFrom-SVN: r35397", "tree": {"sha": "96b4002f5fef6f8cb90e260f39ab0f4ba09db17e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96b4002f5fef6f8cb90e260f39ab0f4ba09db17e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c127c1274ff15e01fa10b3221a68522a644e0bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c127c1274ff15e01fa10b3221a68522a644e0bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c127c1274ff15e01fa10b3221a68522a644e0bfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c127c1274ff15e01fa10b3221a68522a644e0bfa/comments", "author": null, "committer": null, "parents": [{"sha": "1868b439596f4fab73f606bcb00c453a53f30a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1868b439596f4fab73f606bcb00c453a53f30a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1868b439596f4fab73f606bcb00c453a53f30a91"}], "stats": {"total": 186, "additions": 91, "deletions": 95}, "files": [{"sha": "8adb9712bb67d8e68dcac0b4ca1da991eead3f72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c127c1274ff15e01fa10b3221a68522a644e0bfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c127c1274ff15e01fa10b3221a68522a644e0bfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c127c1274ff15e01fa10b3221a68522a644e0bfa", "patch": "@@ -130,6 +130,8 @@\n \n 2000-07-31  Kazu Hirata  <kazu@hxi.com>\n \n+\t* h8300.md: Fix formatting.\n+\n \t* local-alloc.c: Fix formatting.\n \n \t* h8300.c (get_shift_alg): Remove the variable alg."}, {"sha": "1f9f17f2bd7916f90df0b45120d73bfb1f2b6a08", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 89, "deletions": 95, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c127c1274ff15e01fa10b3221a68522a644e0bfa/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c127c1274ff15e01fa10b3221a68522a644e0bfa/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=c127c1274ff15e01fa10b3221a68522a644e0bfa", "patch": "@@ -66,7 +66,7 @@\n \n ;; The size of instructions in bytes.\n \n-(define_attr \"length\" \"\" \n+(define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"branch\")\n \t (if_then_else (and (ge (minus (pc) (match_dup 0))\n \t\t\t\t(const_int -120))\n@@ -165,7 +165,7 @@\n      [(const_int 2) (const_int 2) (const_int 2)\n       (if_then_else (eq_attr \"cpu\" \"h8300\") (const_int 4) (const_int 8))])\n    (set_attr \"cc\" \"set_zn,set_znv,set_znv,set_znv\")])\n-   \n+\n ;; movhi\n \n ;; ??? We use push.l on the h8300h to push a 16bit value?!?  We have\n@@ -290,48 +290,47 @@\n     case 0:\n       return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n     case 1:\n-      if (REGNO(operands[0]) < REGNO(operands[1]))\n+      if (REGNO (operands[0]) < REGNO (operands[1]))\n \treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-      else \n+      else\n \treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n     case 2:\n       /* Make sure we don't trample the register we index with.  */\n-    \n-      if (GET_CODE(operands[1]) == MEM) \n+      if (GET_CODE (operands[1]) == MEM)\n \t{\n \t  rtx inside = XEXP (operands[1],0);\n-\t  if  (REG_P (inside)) \n+\t  if (REG_P (inside))\n \t    {\n-\t      rn = REGNO(inside);\n+\t      rn = REGNO (inside);\n \t    }\n-\t  else if (GET_CODE (inside) == PLUS) \n+\t  else if (GET_CODE (inside) == PLUS)\n \t    {\n \t      rtx lhs = XEXP (inside,0);\n \t      rtx rhs = XEXP (inside,1);\n \t      if (REG_P (lhs)) rn = REGNO (lhs);\n \t      if (REG_P (rhs)) rn = REGNO (rhs);\n \t    }\n \t}\n-      if (rn == REGNO (operands[0])) \t\n+      if (rn == REGNO (operands[0]))\n \t{\n \t  /* Move the second word first.  */\n \t  return \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n \t}\n-      else \n+      else\n \t{\n \t  /* See if either half is zero.  If so, use sub.w to clear\n \t     that half.  */\n-\tif (GET_CODE (operands[1]) == CONST_INT)\n-\t  {\n-\t    if ((INTVAL (operands[1]) & 0xffff) == 0)\n-\t      return \\\"mov.w\t%e1,%e0\\;sub.w\t%f0,%f0\\\";\n-\t    if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)\n-\t      return \\\"sub.w\t%e0,%e0\\;mov.w\t%f1,%f0\\\";\n-\t  }\n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    {\n+\t      if ((INTVAL (operands[1]) & 0xffff) == 0)\n+\t\treturn \\\"mov.w\t%e1,%e0\\;sub.w\t%f0,%f0\\\";\n+\t      if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)\n+\t\treturn \\\"sub.w\t%e0,%e0\\;mov.w\t%f1,%f0\\\";\n+\t    }\n+\t  return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n \t}\n     case 3:\n-\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n     case 4:\n       return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n     case 5:\n@@ -351,28 +350,27 @@\n        || register_operand (operands[1], SFmode))\"\n   \"*\n {\n-  /* Copy of the movsi stuff */\n+  /* Copy of the movsi stuff.  */\n   int rn = -1;\n   switch (which_alternative)\n     {\n     case 0:\n       return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n     case 1:\n-      if (REGNO(operands[0]) < REGNO(operands[1]))\n+      if (REGNO (operands[0]) < REGNO (operands[1]))\n \treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-      else \n+      else\n \treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n     case 2:\n       /* Make sure we don't trample the register we index with.  */\n-    \n-      if (GET_CODE (operands[1]) == MEM) \n+      if (GET_CODE (operands[1]) == MEM)\n \t{\n \t  rtx inside = XEXP (operands[1],0);\n \t  if (REG_P (inside))\n \t    {\n \t      rn = REGNO (inside);\n \t    }\n-\t  else if (GET_CODE (inside) == PLUS) \n+\t  else if (GET_CODE (inside) == PLUS)\n \t    {\n \t      rtx lhs = XEXP (inside,0);\n \t      rtx rhs = XEXP (inside,1);\n@@ -381,15 +379,12 @@\n \t    }\n \t}\n       if (rn == REGNO (operands[0]))\n-\t{\n-\t  /* move the second word first */\n-\t  return \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n-\t}\n-      else \n-\t{\n-\t  return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n-\t}\n-    \n+\t/* Move the second word first.  */\n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+      else\n+\t/* Move the first word first.  */\n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+\n     case 3:\n       return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n     case 4:\n@@ -430,13 +425,13 @@\n \t     number to zero in one of the two low bytes.  */\n \t  if (val == (val & 0xff))\n \t    {\n-\t      operands[1] = GEN_INT ((char)val & 0xff);\n+\t      operands[1] = GEN_INT ((char) val & 0xff);\n \t      return \\\"sub.l %S0,%S0\\;add.b %1,%w0\\\";\n \t    }\n-     \n+\n \t  if (val == (val & 0xff00))\n \t    {\n-\t      operands[1] = GEN_INT ((char)(val >> 8) & 0xff);\n+\t      operands[1] = GEN_INT ((char) (val >> 8) & 0xff);\n \t      return \\\"sub.l %S0,%S0\\;add.b %1,%x0\\\";\n \t    }\n \n@@ -509,7 +504,7 @@\n   \"btst\t%Z1,%R0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_zn\")])\n-  \n+\n (define_insn \"\"\n   [(set (cc0) (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"r\")\n \t\t\t       (const_int 1)\n@@ -626,7 +621,7 @@\n   \"@\n    adds\t%2,%A0\n    subs\t%G2,%A0\n-   add.b\t%s2,%s0\\;addx\t%t2,%t0 \n+   add.b\t%s2,%s0\\;addx\t%t2,%t0\n    add.w\t%T2,%T0\n    mov.w        %T1,%T0\\;add.w  %T2,%T0\"\n   [(set_attr \"length\" \"2,2,4,2,6\")\n@@ -978,9 +973,9 @@\n     {\n       int i = INTVAL (operands[2]);\n \n-      if ((i & 0x00ff) != 0x00ff) \n+      if ((i & 0x00ff) != 0x00ff)\n \toutput_asm_insn (\\\"and\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0xff00) \n+      if ((i & 0xff00) != 0xff00)\n \toutput_asm_insn (\\\"and\t%t2,%t0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1031,9 +1026,9 @@\n \toutput_asm_insn (\\\"and\t%w2,%w0\\\", operands);\n       if ((i & 0x0000ff00) != 0x0000ff00 && !lower_cleared)\n \toutput_asm_insn (\\\"and\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared) \n+      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared)\n \toutput_asm_insn (\\\"and\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0xff000000 && !upper_cleared) \n+      if ((i & 0xff000000) != 0xff000000 && !upper_cleared)\n \toutput_asm_insn (\\\"and\t%z2,%z0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1083,9 +1078,9 @@\n     {\n       int i = INTVAL (operands[2]);\n \n-      if ((i & 0x00ff) != 0) \n+      if ((i & 0x00ff) != 0)\n \toutput_asm_insn (\\\"or\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0) \n+      if ((i & 0xff00) != 0)\n \toutput_asm_insn (\\\"or\t%t2,%t0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1114,14 +1109,14 @@\n       if ((TARGET_H8300H || TARGET_H8300S)\n \t  && (i & 0xffff0000) != 0x00000000)\n         return \\\"or.l\t%S2,%S0\\\";\n-\t\n-      if ((i & 0x000000ff) != 0) \n+\n+      if ((i & 0x000000ff) != 0)\n \toutput_asm_insn (\\\"or\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0) \n+      if ((i & 0x0000ff00) != 0)\n \toutput_asm_insn (\\\"or\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0) \n+      if ((i & 0x00ff0000) != 0)\n \toutput_asm_insn (\\\"or\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0) \n+      if ((i & 0xff000000) != 0)\n \toutput_asm_insn (\\\"or\t%z2,%z0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1170,9 +1165,9 @@\n     {\n       int i = INTVAL (operands[2]);\n \n-      if ((i & 0x00ff) != 0) \n+      if ((i & 0x00ff) != 0)\n \toutput_asm_insn (\\\"xor\t%s2,%s0\\\", operands);\n-      if ((i & 0xff00) != 0) \n+      if ((i & 0xff00) != 0)\n \toutput_asm_insn (\\\"xor\t%t2,%t0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1202,13 +1197,13 @@\n \t  && (i & 0xffff0000) != 0x00000000)\n         return \\\"xor.l\t%S2,%S0\\\";\n \n-      if ((i & 0x000000ff) != 0) \n+      if ((i & 0x000000ff) != 0)\n \toutput_asm_insn (\\\"xor\t%w2,%w0\\\", operands);\n-      if ((i & 0x0000ff00) != 0) \n+      if ((i & 0x0000ff00) != 0)\n \toutput_asm_insn (\\\"xor\t%x2,%x0\\\", operands);\n-      if ((i & 0x00ff0000) != 0) \n+      if ((i & 0x00ff0000) != 0)\n \toutput_asm_insn (\\\"xor\t%y2,%y0\\\", operands);\n-      if ((i & 0xff000000) != 0) \n+      if ((i & 0xff000000) != 0)\n \toutput_asm_insn (\\\"xor\t%z2,%z0\\\", operands);\n       return \\\"\\\";\n     }\n@@ -1338,7 +1333,6 @@\n \t\t\t  (const_int 0))\n \t\t      (const_int 8)\n \t\t      (const_int 2)))])\n-\t\t\t\n \f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n@@ -1455,13 +1449,13 @@\n       return 0;\n     }\n \n-  if (get_attr_length (insn) == 2) \n+  if (get_attr_length (insn) == 2)\n     return \\\"b%j1\t%l0\\\";\n-  else if (get_attr_length (insn) == 4) \n+  else if (get_attr_length (insn) == 4)\n     return \\\"b%j1\t%l0:16\\\";\n   else\n     return \\\"b%k1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\\\";\n-}\" \n+}\"\n  [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"none\")])\n \n@@ -1484,9 +1478,9 @@\n       return 0;\n     }\n \n-  if (get_attr_length (insn) == 2) \n+  if (get_attr_length (insn) == 2)\n     return \\\"b%k1\t%l0\\\";\n-  else if (get_attr_length (insn) == 4) \n+  else if (get_attr_length (insn) == 4)\n     return \\\"b%k1\t%l0:16\\\";\n   else\n     return \\\"b%j1\t.Lh8BR%=\\;jmp\t@%l0\\\\n.Lh8BR%=:\\\";\n@@ -1656,7 +1650,7 @@\n (define_expand \"zero_extendhisi2_h8300\"\n   [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n    (set (reg:SI 0) (zero_extend:SI (reg:HI 1)))\n-   (set (match_operand:SI 0 \"general_operand\" \"\" ) (reg:SI 0))]\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 0))]\n   \"TARGET_H8300\"\n   \"\")\n \n@@ -1740,7 +1734,7 @@\n (define_expand \"extendhisi2_h8300\"\n   [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n    (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))\n-   (set (match_operand:SI 0 \"general_operand\" \"\" ) (reg:SI 0))]\n+   (set (match_operand:SI 0 \"general_operand\" \"\") (reg:SI 0))]\n   \"TARGET_H8300\"\n   \"\")\n \n@@ -1808,7 +1802,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:QI 3 \"nshift_operator\" \n+\t(match_operator:QI 3 \"nshift_operator\"\n \t\t\t[ (match_operand:QI 1 \"register_operand\" \"0,0\")\n \t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"KM,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n@@ -1842,7 +1836,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:HI 3 \"nshift_operator\" \n+\t(match_operator:HI 3 \"nshift_operator\"\n \t\t\t[ (match_operand:HI 1 \"register_operand\" \"0,0\")\n \t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"KM,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n@@ -1879,7 +1873,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operator:SI 3 \"nshift_operator\" \n+\t(match_operator:SI 3 \"nshift_operator\"\n \t\t\t[ (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"K,rn\")]))\n    (clobber (match_scratch:QI 4 \"=X,&r\"))]\n@@ -1896,14 +1890,14 @@\n \n ;; You'll never believe all these patterns perform one basic action --\n ;; load a bit from the source, optionally invert the bit, then store it\n-;; in the destination (which is known to be zero)..  \n+;; in the destination (which is known to be zero).\n ;;\n ;; Combine obviously need some work to better identify this situation and\n ;; canonicalize the form better.\n \n-;; \n+;;\n ;; Normal loads with a 16bit destination.\n-;; \n+;;\n ;; Yes, both cases are needed.\n ;;\n (define_insn \"\"\n@@ -1927,9 +1921,9 @@\n   [(set_attr \"cc\" \"clobber\")\n    (set_attr \"length\" \"6\")])\n \n-;; \n+;;\n ;; Inverted loads with a 16bit destination.\n-;; \n+;;\n ;; Yes, all four cases are needed.\n ;;\n \n@@ -1946,7 +1940,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(and:HI (not:HI \n+\t(and:HI (not:HI\n \t\t  (lshiftrt:HI\n \t\t    (match_operand:HI 1 \"bit_operand\" \"Ur\")\n \t\t    (match_operand:HI 2 \"const_int_operand\" \"n\")))\n@@ -1958,8 +1952,8 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(and:HI (not:HI \n-\t\t  (subreg:HI \n+\t(and:HI (not:HI\n+\t\t  (subreg:HI\n \t\t    (lshiftrt:SI\n \t\t      (match_operand:SI 1 \"register_operand\" \"Ur\")\n \t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 1))\n@@ -1971,8 +1965,8 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n-\t(and:HI (not:HI \n-\t\t  (subreg:HI \n+\t(and:HI (not:HI\n+\t\t  (subreg:HI\n \t\t    (lshiftrt:SI\n \t\t      (match_operand:SI 1 \"bit_operand\" \"Ur\")\n \t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 0))\n@@ -1983,9 +1977,9 @@\n   [(set_attr \"cc\" \"clobber\")\n    (set_attr \"length\" \"8\")])\n \n-;; \n+;;\n ;; Normal loads with a 32bit destination.\n-;; \n+;;\n ;; Yes, all three cases are needed.\n ;;\n (define_insn \"\"\n@@ -2004,7 +1998,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(and:SI (zero_extend:SI \n+\t(and:SI (zero_extend:SI\n \t\t   (lshiftrt:QI\n \t\t     (match_operand:QI 1 \"bit_operand\" \"Ur\")\n \t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))\n@@ -2020,7 +2014,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(and:SI (zero_extend:SI \n+\t(and:SI (zero_extend:SI\n \t\t   (lshiftrt:HI\n \t\t      (match_operand:HI 1 \"bit_operand\" \"Ur\")\n \t\t      (match_operand:HI 2 \"const_int_operand\" \"n\")))\n@@ -2034,9 +2028,9 @@\n \t\t      (const_int 10)\n \t\t      (const_int 8)))])\n \n-;; \n+;;\n ;; Inverted loads with a 32bit destination.\n-;; \n+;;\n ;; Yes, all seven cases are needed.\n ;;\n (define_insn \"\"\n@@ -2100,7 +2094,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n \t(and:SI (not:SI\n-\t\t  (subreg:SI \n+\t\t  (subreg:SI\n \t\t     (lshiftrt:HI\n \t\t\t(match_operand:HI 1 \"bit_operand\" \"Ur\")\n \t\t\t(match_operand:HI 2 \"const_int_operand\" \"n\")) 0))\n@@ -2117,7 +2111,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n \t(and:SI (not:SI\n-\t\t  (subreg:SI \n+\t\t  (subreg:SI\n \t\t     (lshiftrt:QI\n \t\t\t(match_operand:QI 1 \"bit_operand\" \"Ur\")\n \t\t\t(match_operand:QI 2 \"const_int_operand\" \"n\")) 0))\n@@ -2171,7 +2165,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_expand \"extzv\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\") \n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(zero_extract:HI (match_operand:HI 1 \"bit_operand\" \"\")\n \t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n \t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n@@ -2224,42 +2218,42 @@\n \n ;; Notice a move which could be post incremented.\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(mem:QI (match_operand:HI 1 \"register_operand\" \"\")))\n    (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.b\t@%T1+,%X0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(mem:HI (match_operand:HI 1 \"register_operand\" \"\")))\n    (set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.w\t@%T1+,%T0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n ;; Notice a move which could be predecremented.\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand:HI 1 \"register_operand\" \"\")\n \t(plus:HI (match_dup 1) (const_int -1)))\n    (set (mem:QI (match_dup 1))\n \t\t(match_operand:QI 0 \"register_operand\" \"\"))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.b\t%X0,@-%T1\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n \n-(define_peephole \n+(define_peephole\n   [(set (match_operand:HI 1 \"register_operand\" \"\")\n \t(plus:HI (match_dup 1) (const_int -2)))\n    (set (mem:HI (match_dup 1))\n \t\t(match_operand:HI 0 \"register_operand\" \"\"))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.w\t%T0,@-%T1\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])"}]}