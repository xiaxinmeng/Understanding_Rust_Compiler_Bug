{"sha": "1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2ZmM0ZGU2OWQ3ZWNlNmZmNWY5ODhmM2M2MDBkMGYwNDkzY2JjNw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-08-07T02:02:19Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-08-07T02:02:19Z"}, "message": "(true_dependence): An unchanging read is guaranteed independent of a store only if the store is not unchanging.\n\n(true_dependence): An unchanging read is guaranteed\nindependent of a store only if the store is not unchanging.\n(anti_dependence): Added comment about unchanging reads.\n(sched_analyze_2): Don't ignore unchanging reads, they may be\ndependent on unchanging writes.\n\nFrom-SVN: r1777", "tree": {"sha": "bd8cfd2fb100d801fb085ad04eb2060d568c9db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd8cfd2fb100d801fb085ad04eb2060d568c9db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7/comments", "author": null, "committer": null, "parents": [{"sha": "5584677eb43bc65eab09f7ea0057acb5f7bc4658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5584677eb43bc65eab09f7ea0057acb5f7bc4658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5584677eb43bc65eab09f7ea0057acb5f7bc4658"}], "stats": {"total": 75, "additions": 40, "deletions": 35}, "files": [{"sha": "525d9eb3d166387974148ca3d265dde60bf9ba6c", "filename": "gcc/sched.c", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=1f6fc4de69d7ece6ff5f988f3c600d0f0493cbc7", "patch": "@@ -653,7 +653,14 @@ true_dependence (mem, x)\n      rtx mem;\n      rtx x;\n {\n-  if (RTX_UNCHANGING_P (x))\n+  /* If X is an unchanging read, then it can't possibly conflict with any\n+     non-unchanging store.  It may conflict with an unchanging write though,\n+     because there may be a single store to this address to initialize it.\n+     Just fall through to the code below to resolve the case where we have\n+     both an unchanging read and an unchanging write.  This won't handle all\n+     cases optimally, but the possible performance loss should be\n+     negligible.  */\n+  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n   return ((MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n@@ -672,6 +679,9 @@ anti_dependence (mem, x)\n      rtx mem;\n      rtx x;\n {\n+  /* If MEM is an unchanging read, then it can't possibly conflict with\n+     the store to X, because there is at most one store to MEM, and it must\n+     have occured somewhere before MEM.  */\n   if (RTX_UNCHANGING_P (mem))\n     return 0;\n \n@@ -1389,46 +1399,41 @@ sched_analyze_2 (x, insn)\n       {\n \t/* Reading memory.  */\n \n-\t/* Don't create a dependence for memory references which are known to\n-\t   be unchanging, such as constant pool accesses.  These will never\n-\t   conflict with any other memory access.  */\n-\tif (RTX_UNCHANGING_P (x) == 0)\n+\trtx pending, pending_mem;\n+\n+\tpending = pending_read_insns;\n+\tpending_mem = pending_read_mems;\n+\twhile (pending)\n \t  {\n-\t    rtx pending, pending_mem;\n+\t    /* If a dependency already exists, don't create a new one.  */\n+\t    if (! find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n+\t      if (read_dependence (XEXP (pending_mem, 0), x))\n+\t\tadd_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n \n-\t    pending = pending_read_insns;\n-\t    pending_mem = pending_read_mems;\n-\t    while (pending)\n-\t      {\n-\t\t/* If a dependency already exists, don't create a new one.  */\n-\t\tif (! find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t\t  if (read_dependence (XEXP (pending_mem, 0), x))\n-\t\t    add_dependence (insn, XEXP (pending, 0), REG_DEP_ANTI);\n+\t    pending = XEXP (pending, 1);\n+\t    pending_mem = XEXP (pending_mem, 1);\n+\t  }\n \n-\t\tpending = XEXP (pending, 1);\n-\t\tpending_mem = XEXP (pending_mem, 1);\n-\t      }\n+\tpending = pending_write_insns;\n+\tpending_mem = pending_write_mems;\n+\twhile (pending)\n+\t  {\n+\t    /* If a dependency already exists, don't create a new one.  */\n+\t    if (! find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n+\t      if (true_dependence (XEXP (pending_mem, 0), x))\n+\t\tadd_dependence (insn, XEXP (pending, 0), 0);\n \n-\t    pending = pending_write_insns;\n-\t    pending_mem = pending_write_mems;\n-\t    while (pending)\n-\t      {\n-\t\t/* If a dependency already exists, don't create a new one.  */\n-\t\tif (! find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t\t  if (true_dependence (XEXP (pending_mem, 0), x))\n-\t\t    add_dependence (insn, XEXP (pending, 0), 0);\n+\t    pending = XEXP (pending, 1);\n+\t    pending_mem = XEXP (pending_mem, 1);\n+\t  }\n+\tif (last_pending_memory_flush)\n+\t  add_dependence (insn, last_pending_memory_flush, REG_DEP_ANTI);\n \n-\t\tpending = XEXP (pending, 1);\n-\t\tpending_mem = XEXP (pending_mem, 1);\n-\t      }\n-\t    if (last_pending_memory_flush)\n-\t      add_dependence (insn, last_pending_memory_flush, REG_DEP_ANTI);\n+\t/* Always add these dependencies to pending_reads, since\n+\t   this insn may be followed by a write.  */\n+\tadd_insn_mem_dependence (&pending_read_insns, &pending_read_mems,\n+\t\t\t\t insn, x);\n \n-\t    /* Always add these dependencies to pending_reads, since\n-\t       this insn may be followed by a write.  */\n-\t    add_insn_mem_dependence (&pending_read_insns, &pending_read_mems,\n-\t\t\t\t     insn, x);\n-\t  }\n \t/* Take advantage of tail recursion here.  */\n \tsched_analyze_2 (XEXP (x, 0), insn);\n \treturn;"}]}