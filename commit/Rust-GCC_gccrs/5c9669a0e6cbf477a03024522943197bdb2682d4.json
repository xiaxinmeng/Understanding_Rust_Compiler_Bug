{"sha": "5c9669a0e6cbf477a03024522943197bdb2682d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM5NjY5YTBlNmNiZjQ3N2EwMzAyNDUyMjk0MzE5N2JkYjI2ODJkNA==", "commit": {"author": {"name": "Fei Yang", "email": "felix.yang@huawei.com", "date": "2020-07-02T09:14:33Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-07-02T09:14:33Z"}, "message": "vect: Fix an ICE in exact_div [PR95961]\n\nIn the test case for PR95961, vectorization factor computed\nby vect_determine_vectorization_factor is [8,8].  But this is\nupdated to [1,1] later by vect_update_vf_for_slp.  When we call\nvect_get_num_vectors in vect_enhance_data_refs_alignment, the number\nof scalars which is based on the vectorization factor is not a multiple\nof the the number of elements in the vector type.  This leads to\nthe ICE.  This isn't a simple stream of contiguous vector accesses.\nIt's hard to predict from the available information how many vector\naccesses we'll actually need per iteration.  As discussed, here we\nshould use the number of scalars instead of the number of vectors as\nan upper bound for the loop saving info about DR in the hash table.\n\n2020-07-02  Felix Yang  <felix.yang@huawei.com>\n\ngcc/\n\tPR tree-optimization/95961\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Use the\n\tnumber of scalars instead of the number of vectors as an upper bound\n\tfor the loop saving info about DR in the hash table.  Remove unused\n\tlocal variables.\n\ngcc/testsuite/\n\tPR tree-optimization/95961\n\t* gcc.target/aarch64/sve/pr95961.c: New test.", "tree": {"sha": "388ec5f43bebd7b754ac9d9df6874cd912a34c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/388ec5f43bebd7b754ac9d9df6874cd912a34c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c9669a0e6cbf477a03024522943197bdb2682d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9669a0e6cbf477a03024522943197bdb2682d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9669a0e6cbf477a03024522943197bdb2682d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9669a0e6cbf477a03024522943197bdb2682d4/comments", "author": null, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d50112acfc01f85fe0fb6d88b329e6122e817b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d50112acfc01f85fe0fb6d88b329e6122e817b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d50112acfc01f85fe0fb6d88b329e6122e817b3"}], "stats": {"total": 39, "additions": 22, "deletions": 17}, "files": [{"sha": "b9802c8d0cdf37a53e7c11c29ac0c10848705752", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr95961.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c9669a0e6cbf477a03024522943197bdb2682d4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95961.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c9669a0e6cbf477a03024522943197bdb2682d4/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95961.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr95961.c?ref=5c9669a0e6cbf477a03024522943197bdb2682d4", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=armv8.2-a+sve -fno-vect-cost-model\" } */\n+\n+typedef struct {\n+    unsigned short mprr_2[5][16][16];\n+} ImageParameters;\n+int s[16][2];\n+void intrapred_luma_16x16(ImageParameters *img, int s0)\n+{\n+  for (int j=0; j < 16; j++)\n+    for (int i=0; i < 16; i++)\n+      {\n+\timg->mprr_2[1 ][j][i]=s[j][1];\n+\timg->mprr_2[2 ][j][i]=s0;\n+      }\n+}"}, {"sha": "2462276e7c2d323224193b043e15a85825e9f233", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c9669a0e6cbf477a03024522943197bdb2682d4/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c9669a0e6cbf477a03024522943197bdb2682d4/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=5c9669a0e6cbf477a03024522943197bdb2682d4", "patch": "@@ -1722,17 +1722,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   dr_vec_info *first_store = NULL;\n   dr_vec_info *dr0_info = NULL;\n   struct data_reference *dr;\n-  unsigned int i, j;\n+  unsigned int i;\n   bool do_peeling = false;\n   bool do_versioning = false;\n   unsigned int npeel = 0;\n   bool one_misalignment_known = false;\n   bool one_misalignment_unknown = false;\n   bool one_dr_unsupportable = false;\n   dr_vec_info *unsupportable_dr_info = NULL;\n-  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  unsigned possible_npeel_number = 1;\n-  tree vectype;\n   unsigned int mis, same_align_drs_max = 0;\n   hash_table<peel_info_hasher> peeling_htab (1);\n \n@@ -1792,7 +1789,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      bool negative = tree_int_cst_compare (DR_STEP (dr),\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n-\t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n \t      /* If known_alignment_for_access_p then we have set\n \t         DR_MISALIGNMENT which is only done if we know it at compiler\n \t         time, so it is safe to assume target alignment is constant.\n@@ -1819,22 +1815,17 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  vectorization factor.\n                  We do this automatically for cost model, since we calculate\n \t\t cost for every peeling option.  */\n+\t      poly_uint64 nscalars = npeel_tmp;\n               if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n \t\t{\n-\t\t  poly_uint64 nscalars = (STMT_SLP_TYPE (stmt_info)\n-\t\t\t\t\t  ? vf * DR_GROUP_SIZE (stmt_info) : vf);\n-\t\t  possible_npeel_number\n-\t\t    = vect_get_num_vectors (nscalars, vectype);\n-\n-\t\t  /* NPEEL_TMP is 0 when there is no misalignment, but also\n-\t\t     allow peeling NELEMENTS.  */\n-\t\t  if (DR_MISALIGNMENT (dr_info) == 0)\n-\t\t    possible_npeel_number++;\n+\t\t  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\t\t  nscalars = (STMT_SLP_TYPE (stmt_info)\n+\t\t\t      ? vf * DR_GROUP_SIZE (stmt_info) : vf);\n \t\t}\n \n \t      /* Save info about DR in the hash table.  Also include peeling\n \t         amounts according to the explanation above.  */\n-              for (j = 0; j < possible_npeel_number; j++)\n+\t      while (known_le (npeel_tmp, nscalars))\n                 {\n                   vect_peeling_hash_insert (&peeling_htab, loop_vinfo,\n \t\t\t\t\t    dr_info, npeel_tmp);\n@@ -2059,8 +2050,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   if (do_peeling)\n     {\n       stmt_vec_info stmt_info = dr0_info->stmt;\n-      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\n       if (known_alignment_for_access_p (dr0_info))\n         {\n \t  bool negative = tree_int_cst_compare (DR_STEP (dr0_info->dr),"}]}