{"sha": "dce1438a65f25cceffec22d53d41ea35ee422673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNlMTQzOGE2NWYyNWNjZWZmZWMyMmQ1M2Q0MWVhMzVlZTQyMjY3Mw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-05-27T08:28:31Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-05-27T08:28:31Z"}, "message": "combine.c (gen_binary): Remove.\n\n2004-05-25  Paolo Bonzini  <bonzini@gnu.org>\n\n        * combine.c (gen_binary): Remove.\n        (known_cond, simplify_shift_const\n        find_split_point, combine_simplify_rtx,\n        simplify_if_then_else, simplify_set,\n        simplify_logical, expand_field_assignment,\n        extract_left_shift, force_to_mode,\n        if_then_else_cond, apply_distributive_law,\n        simplify_and_const_int, simplify_shift_const,\n        gen_lowpart_for_combine, simplify_comparison,\n        reversed_comparison): Replace with\n        simplify_gen_binary, simplify_gen_relational or\n        distribute_and_simplify_rtx.\n        (distribute_and_simplify_rtx): New function.\n        * simplify-rtx.c (simplify_binary_operation):\n        Use nonzero_bits to simplify ANDs where we are\n        turning off bits already known to be off in OP0.\n\nFrom-SVN: r82317", "tree": {"sha": "c7ecfdfb81b14955672d885852ac8aa682ee7655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7ecfdfb81b14955672d885852ac8aa682ee7655"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dce1438a65f25cceffec22d53d41ea35ee422673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce1438a65f25cceffec22d53d41ea35ee422673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dce1438a65f25cceffec22d53d41ea35ee422673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dce1438a65f25cceffec22d53d41ea35ee422673/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42f806e5a0bbc3f5a02394893343e7e6ce1e94f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f806e5a0bbc3f5a02394893343e7e6ce1e94f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f806e5a0bbc3f5a02394893343e7e6ce1e94f2"}], "stats": {"total": 639, "additions": 342, "deletions": 297}, "files": [{"sha": "c6951713dd1b85f3c47782990218dd35d6ca05a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dce1438a65f25cceffec22d53d41ea35ee422673", "patch": "@@ -1,3 +1,22 @@\n+2004-05-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (gen_binary): Remove.\n+\t(known_cond, simplify_shift_const\n+\tfind_split_point, combine_simplify_rtx,\n+\tsimplify_if_then_else, simplify_set,\n+\tsimplify_logical, expand_field_assignment,\n+\textract_left_shift, force_to_mode,\n+\tif_then_else_cond, apply_distributive_law,\n+\tsimplify_and_const_int, simplify_shift_const,\n+\tgen_lowpart_for_combine, simplify_comparison,\n+\treversed_comparison): Replace with\n+\tsimplify_gen_binary, simplify_gen_relational or\n+\tdistribute_and_simplify_rtx.\n+\t(distribute_and_simplify_rtx): New function.\n+\t* simplify-rtx.c (simplify_binary_operation):\n+\tUse nonzero_bits to simplify ANDs where we are\n+\tturning off bits already known to be off in OP0.\n+\n 2004-05-27  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/14478"}, {"sha": "eb07dbb84bccc84794089facd9105780e46293a0", "filename": "gcc/combine.c", "status": "modified", "additions": 319, "deletions": 295, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=dce1438a65f25cceffec22d53d41ea35ee422673", "patch": "@@ -372,6 +372,7 @@ static rtx known_cond (rtx, enum rtx_code, rtx, rtx);\n static int rtx_equal_for_field_assignment_p (rtx, rtx);\n static rtx make_field_assignment (rtx);\n static rtx apply_distributive_law (rtx);\n+static rtx distribute_and_simplify_rtx (rtx);\n static rtx simplify_and_const_int (rtx, enum machine_mode, rtx,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n static int merge_outer_ops (enum rtx_code *, HOST_WIDE_INT *, enum rtx_code,\n@@ -380,7 +381,6 @@ static rtx simplify_shift_const\t(rtx, enum rtx_code, enum machine_mode, rtx,\n \t\t\t\t int);\n static int recog_for_combine (rtx *, rtx, rtx *);\n static rtx gen_lowpart_for_combine (enum machine_mode, rtx);\n-static rtx gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\n static enum rtx_code simplify_comparison (enum rtx_code, rtx *, rtx *);\n static void update_table_tick (rtx);\n static void record_value_for_reg (rtx, rtx, rtx);\n@@ -3017,14 +3017,16 @@ find_split_point (rtx *loc, rtx insn)\n \n \t  if (src == mask)\n \t    SUBST (SET_SRC (x),\n-\t\t   gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n+\t\t   simplify_gen_binary (IOR, mode, dest, GEN_INT (src << pos)));\n \t  else\n-\t    SUBST (SET_SRC (x),\n-\t\t   gen_binary (IOR, mode,\n-\t\t\t       gen_binary (AND, mode, dest,\n-\t\t\t\t\t   gen_int_mode (~(mask << pos),\n-\t\t\t\t\t\t\t mode)),\n-\t\t\t       GEN_INT (src << pos)));\n+\t    {\n+\t      rtx negmask = gen_int_mode (~(mask << pos), mode);\n+\t      SUBST (SET_SRC (x),\n+\t\t     simplify_gen_binary (IOR, mode,\n+\t\t\t\t          simplify_gen_binary (AND, mode,\n+\t\t\t\t\t\t\t       dest, negmask),\n+\t\t\t\t\t  GEN_INT (src << pos)));\n+\t    }\n \n \t  SUBST (SET_DEST (x), dest);\n \n@@ -3599,7 +3601,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       new = simplify_shift_const (NULL_RTX, ASHIFTRT, mode, new,\n \t\t\t\t  INTVAL (XEXP (XEXP (x, 0), 1)));\n \n-      SUBST (XEXP (x, 0), gen_binary (PLUS, mode, new, temp));\n+      SUBST (XEXP (x, 0), simplify_gen_binary (PLUS, mode, new, temp));\n     }\n \n   /* If this is a simple operation applied to an IF_THEN_ELSE, try\n@@ -3656,21 +3658,24 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      /* If the result values are STORE_FLAG_VALUE and zero, we can\n \t\t just make the comparison operation.  */\n \t      if (true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-\t\tx = gen_binary (cond_code, mode, cond, cop1);\n+\t\tx = simplify_gen_relational (cond_code, mode, VOIDmode,\n+\t\t\t\t\t     cond, cop1);\n \t      else if (true_rtx == const0_rtx && false_rtx == const_true_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n-\t\tx = gen_binary (reversed, mode, cond, cop1);\n+\t\tx = simplify_gen_relational (reversed, mode, VOIDmode,\n+\t\t\t\t\t     cond, cop1);\n \n \t      /* Likewise, we can make the negate of a comparison operation\n \t\t if the result values are - STORE_FLAG_VALUE and zero.  */\n \t      else if (GET_CODE (true_rtx) == CONST_INT\n \t\t       && INTVAL (true_rtx) == - STORE_FLAG_VALUE\n \t\t       && false_rtx == const0_rtx)\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tgen_binary (cond_code, mode, cond,\n-\t\t\t\t\t\t    cop1),\n+\t\t\t\t\tsimplify_gen_relational (cond_code,\n+\t\t\t\t\t\t\t\t mode, VOIDmode,\n+\t\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\tmode);\n \t      else if (GET_CODE (false_rtx) == CONST_INT\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n@@ -3679,13 +3684,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n \t\t           != UNKNOWN))\n \t\tx = simplify_gen_unary (NEG, mode,\n-\t\t\t\t\tgen_binary (reversed, mode,\n-\t\t\t\t\t\t    cond, cop1),\n+\t\t\t\t\tsimplify_gen_relational (reversed,\n+\t\t\t\t\t\t\t\t mode, VOIDmode,\n+\t\t\t\t\t\t\t\t cond, cop1),\n \t\t\t\t\tmode);\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n-\t\t\t\t\t     gen_binary (cond_code, VOIDmode,\n-\t\t\t\t\t\t\t cond, cop1),\n+\t\t\t\t\t     simplify_gen_relational (cond_code,\n+\t\t\t\t\t\t\t\t      mode,\n+\t\t\t\t\t\t\t\t      VOIDmode,\n+\t\t\t\t\t\t\t\t      cond,\n+\t\t\t\t\t\t\t\t      cop1),\n \t\t\t\t\t     true_rtx, false_rtx);\n \n \t      code = GET_CODE (x);\n@@ -3788,7 +3797,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t    }\n \n \t  if (inner)\n-\t    return gen_binary (code, mode, other, inner);\n+\t    return simplify_gen_binary (code, mode, other, inner);\n \t}\n     }\n \n@@ -3890,7 +3899,8 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx\n \t  && nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n-\treturn gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n+\treturn simplify_gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t    constm1_rtx);\n \n       temp = expand_compound_operation (XEXP (x, 0));\n \n@@ -4118,8 +4128,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n \t  in2 = XEXP (XEXP (x, 0), 1);\n-\t  return gen_binary (MINUS, mode, XEXP (x, 1),\n-\t\t\t     gen_binary (MULT, mode, in1, in2));\n+\t  return simplify_gen_binary (MINUS, mode, XEXP (x, 1),\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2));\n \t}\n \n       /* If we have (plus (plus (A const) B)), associate it so that CONST is\n@@ -4128,10 +4139,11 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t they are now checked elsewhere.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))\n-\treturn gen_binary (PLUS, mode,\n-\t\t\t   gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       XEXP (x, 1)),\n-\t\t\t   XEXP (XEXP (x, 0), 1));\n+\treturn simplify_gen_binary (PLUS, mode,\n+\t\t\t   \t    simplify_gen_binary (PLUS, mode,\n+\t\t\t\t\t\t\t XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t\t\t XEXP (x, 1)),\n+\t\t\t\t    XEXP (XEXP (x, 0), 1));\n \n       /* (plus (xor (and <foo> (const_int pow2 - 1)) <c>) <-c>)\n \t when c is (const_int (pow2 + 1) / 2) is a sign extension of a\n@@ -4197,7 +4209,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      & nonzero_bits (XEXP (x, 1), mode)) == 0)\n \t{\n \t  /* Try to simplify the expression further.  */\n-\t  rtx tor = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n+\t  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n \t  temp = combine_simplify_rtx (tor, mode, in_dest);\n \n \t  /* If we could, great.  If not, do not go ahead with the IOR\n@@ -4237,8 +4249,10 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = XEXP (XEXP (XEXP (x, 1), 0), 0);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return gen_binary (PLUS, mode, gen_binary (MULT, mode, in1, in2),\n-\t\t\t     XEXP (x, 0));\n+\t  return simplify_gen_binary (PLUS, mode,\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2),\n+\t\t\t\t      XEXP (x, 0));\n \t}\n \n       /* Canonicalize (minus (neg A) (mult B C)) to\n@@ -4250,17 +4264,20 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n \t  in1 = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 1), 0), mode);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n-\t  return gen_binary (MINUS, mode, gen_binary (MULT, mode, in1, in2),\n-\t\t\t     XEXP (XEXP (x, 0), 0));\n+\t  return simplify_gen_binary (MINUS, mode,\n+\t\t\t\t      simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t\t\t   in1, in2),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0));\n \t}\n \n       /* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for\n \t integers.  */\n       if (GET_CODE (XEXP (x, 1)) == PLUS && INTEGRAL_MODE_P (mode))\n-\treturn gen_binary (MINUS, mode,\n-\t\t\t   gen_binary (MINUS, mode, XEXP (x, 0),\n-\t\t\t\t       XEXP (XEXP (x, 1), 0)),\n-\t\t\t   XEXP (XEXP (x, 1), 1));\n+\treturn simplify_gen_binary (MINUS, mode,\n+\t\t\t\t    simplify_gen_binary (MINUS, mode,\n+\t\t\t\t\t\t\t XEXP (x, 0),\n+\t\t\t\t\t\t         XEXP (XEXP (x, 1), 0)),\n+\t\t\t\t    XEXP (XEXP (x, 1), 1));\n       break;\n \n     case MULT:\n@@ -4270,17 +4287,11 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \n       if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (PLUS, mode,\n-\t\t\t gen_binary (MULT, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (x, 1)),\n-\t\t\t gen_binary (MULT, mode,\n-\t\t\t\t     XEXP (XEXP (x, 0), 1),\n-\t\t\t\t     copy_rtx (XEXP (x, 1)))));\n-\n-\t  if (GET_CODE (x) != MULT)\n-\t    return x;\n+\t  rtx result = distribute_and_simplify_rtx (x);\n+\t  if (result)\n+\t    return result;\n \t}\n+\n       /* Try simplify a*(b/c) as (a*b)/c.  */\n       if (FLOAT_MODE_P (mode) && flag_unsafe_math_optimizations\n \t  && GET_CODE (XEXP (x, 0)) == DIV)\n@@ -4289,7 +4300,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t\t\t\t       XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t       XEXP (x, 1));\n \t  if (tem)\n-\t    return gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n+\t    return simplify_gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n \t}\n       break;\n \n@@ -4369,9 +4380,9 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return gen_binary (XOR, mode,\n-\t\t\t\t gen_lowpart (mode, op0),\n-\t\t\t\t const1_rtx);\n+\t      return simplify_gen_binary (XOR, mode,\n+\t\t\t\t\t  gen_lowpart (mode, op0),\n+\t\t\t\t\t  const1_rtx);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n@@ -4614,7 +4625,8 @@ simplify_if_then_else (rtx x)\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true_rtx == const_true_rtx && false_rtx == const0_rtx)\n-    return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n+    return simplify_gen_relational (true_code, mode, VOIDmode,\n+\t\t\t\t    XEXP (cond, 0), XEXP (cond, 1));\n \n   /* Also when the truth value has to be reversed.  */\n   if (comparison_p\n@@ -4764,16 +4776,16 @@ simplify_if_then_else (rtx x)\n       {\n       case GE:\n       case GT:\n-\treturn gen_binary (SMAX, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (SMAX, mode, true_rtx, false_rtx);\n       case LE:\n       case LT:\n-\treturn gen_binary (SMIN, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (SMIN, mode, true_rtx, false_rtx);\n       case GEU:\n       case GTU:\n-\treturn gen_binary (UMAX, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (UMAX, mode, true_rtx, false_rtx);\n       case LEU:\n       case LTU:\n-\treturn gen_binary (UMIN, mode, true_rtx, false_rtx);\n+\treturn simplify_gen_binary (UMIN, mode, true_rtx, false_rtx);\n       default:\n \tbreak;\n       }\n@@ -4886,12 +4898,14 @@ simplify_if_then_else (rtx x)\n \n       if (z)\n \t{\n-\t  temp = subst (gen_binary (true_code, m, cond_op0, cond_op1),\n+\t  temp = subst (simplify_gen_relational (true_code, m, VOIDmode,\n+\t\t\t\t\t\t cond_op0, cond_op1),\n \t\t\tpc_rtx, pc_rtx, 0, 0);\n-\t  temp = gen_binary (MULT, m, temp,\n-\t\t\t     gen_binary (MULT, m, c1, const_true_rtx));\n+\t  temp = simplify_gen_binary (MULT, m, temp,\n+\t\t\t\t      simplify_gen_binary (MULT, m, c1,\n+\t\t\t\t\t\t\t   const_true_rtx));\n \t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n-\t  temp = gen_binary (op, m, gen_lowpart (m, z), temp);\n+\t  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);\n \n \t  if (extend_op != NIL)\n \t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n@@ -5076,7 +5090,8 @@ simplify_set (rtx x)\n \t\t  PUT_CODE (*cc_use, old_code);\n \t\t  other_changed = 0;\n \n-\t\t  op0 = gen_binary (XOR, GET_MODE (op0), op0, GEN_INT (mask));\n+\t\t  op0 = simplify_gen_binary (XOR, GET_MODE (op0),\n+\t\t\t\t\t     op0, GEN_INT (mask));\n \t\t}\n \t    }\n \t}\n@@ -5240,18 +5255,19 @@ simplify_set (rtx x)\n \t       && rtx_equal_p (XEXP (false_rtx, 1), true_rtx))\n \tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 0), true_rtx = const0_rtx;\n \n-      term2 = gen_binary (AND, GET_MODE (src),\n-\t\t\t  XEXP (XEXP (src, 0), 0), true_rtx);\n-      term3 = gen_binary (AND, GET_MODE (src),\n-\t\t\t  simplify_gen_unary (NOT, GET_MODE (src),\n-\t\t\t\t\t      XEXP (XEXP (src, 0), 0),\n-\t\t\t\t\t      GET_MODE (src)),\n-\t\t\t  false_rtx);\n+      term2 = simplify_gen_binary (AND, GET_MODE (src),\n+\t\t\t\t   XEXP (XEXP (src, 0), 0), true_rtx);\n+      term3 = simplify_gen_binary (AND, GET_MODE (src),\n+\t\t\t\t   simplify_gen_unary (NOT, GET_MODE (src),\n+\t\t\t\t\t\t       XEXP (XEXP (src, 0), 0),\n+\t\t\t\t\t\t       GET_MODE (src)),\n+\t\t\t\t   false_rtx);\n \n       SUBST (SET_SRC (x),\n-\t     gen_binary (IOR, GET_MODE (src),\n-\t\t\t gen_binary (IOR, GET_MODE (src), term1, term2),\n-\t\t\t term3));\n+\t     simplify_gen_binary (IOR, GET_MODE (src),\n+\t\t\t\t  simplify_gen_binary (IOR, GET_MODE (src),\n+\t\t\t\t\t\t       term1, term2),\n+\t\t\t\t  term3));\n \n       src = SET_SRC (x);\n     }\n@@ -5286,29 +5302,31 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode,\n-\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n-\t\t\top1);\n+\tx = simplify_gen_binary (AND, mode,\n+\t\t\t\t simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t     XEXP (op0, 1), mode),\n+\t\t\t\t op1);\n \n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode,\n-\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n-\t\t\top1);\n+\tx = simplify_gen_binary (AND, mode,\n+\t\t\t\t simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t     XEXP (op0, 0), mode),\n+\t\t\t\t op1);\n \n       /* Similarly for (~(A ^ B)) & A.  */\n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n+\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 1), op1);\n \n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 1), op1)\n \t  && ! side_effects_p (op1))\n-\tx = gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n+\tx = simplify_gen_binary (AND, mode, XEXP (XEXP (op0, 0), 0), op1);\n \n       /* We can call simplify_and_const_int only if we don't lose\n \t any (sign) bits when converting INTVAL (op1) to\n@@ -5328,8 +5346,9 @@ simplify_logical (rtx x)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && GET_CODE (op1) == CONST_INT\n \t      && (INTVAL (XEXP (op0, 1)) & INTVAL (op1)) != 0)\n-\t    return gen_binary (IOR, mode,\n-\t\t\t       gen_binary (AND, mode, XEXP (op0, 0),\n+\t    return simplify_gen_binary (IOR, mode,\n+\t\t\t\t        simplify_gen_binary\n+\t\t\t\t\t  (AND, mode, XEXP (op0, 0),\n \t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n \t\t\t\t\t\t    & ~INTVAL (op1))), op1);\n \n@@ -5348,54 +5367,16 @@ simplify_logical (rtx x)\n \t  && ! side_effects_p (XEXP (op0, 1)))\n \treturn op1;\n \n-      /* In the following group of tests (and those in case IOR below),\n-\t we start with some combination of logical operations and apply\n-\t the distributive law followed by the inverse distributive law.\n-\t Most of the time, this results in no change.  However, if some of\n-\t the operands are the same or inverses of each other, simplifications\n-\t will result.\n-\n-\t For example, (and (ior A B) (not B)) can occur as the result of\n-\t expanding a bit field assignment.  When we apply the distributive\n-\t law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n-\t which then simplifies to (and (A (not B))).\n-\n-\t If we have (and (ior A B) C), apply the distributive law and then\n-\t the inverse distributive law to see if things simplify.  */\n-\n-      if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR)\n+      /* If we have any of (and (ior A B) C) or (and (xor A B) C),\n+\t apply the distributive law and then the inverse distributive\n+\t law to see if things simplify.  */\n+      if (GET_CODE (op0) == IOR || GET_CODE (op0) == XOR\n+          || GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n \t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (GET_CODE (op0), mode,\n-\t\t\t gen_binary (AND, mode, XEXP (op0, 0), op1),\n-\t\t\t gen_binary (AND, mode, XEXP (op0, 1),\n-\t\t\t\t     copy_rtx (op1))));\n-\t  if (GET_CODE (x) != AND)\n-\t    return x;\n+\t  rtx result = distribute_and_simplify_rtx (x);\n+\t  if (result)\n+\t    return result;\n \t}\n-\n-      if (GET_CODE (op1) == IOR || GET_CODE (op1) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (GET_CODE (op1), mode,\n-\t\t       gen_binary (AND, mode, XEXP (op1, 0), op0),\n-\t\t       gen_binary (AND, mode, XEXP (op1, 1),\n-\t\t\t\t   copy_rtx (op0))));\n-\n-      /* Similarly, taking advantage of the fact that\n-\t (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n-\n-      if (GET_CODE (op0) == NOT && GET_CODE (op1) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (XOR, mode,\n-\t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 0)),\n-\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op0, 0)),\n-\t\t\t\t   XEXP (op1, 1))));\n-\n-      else if (GET_CODE (op1) == NOT && GET_CODE (op0) == XOR)\n-\treturn apply_distributive_law\n-\t  (gen_binary (XOR, mode,\n-\t\t       gen_binary (IOR, mode, XEXP (op1, 0), XEXP (op0, 0)),\n-\t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op1, 0)), XEXP (op0, 1))));\n       break;\n \n     case IOR:\n@@ -5416,28 +5397,11 @@ simplify_logical (rtx x)\n       /* If we have (ior (and A B) C), apply the distributive law and then\n \t the inverse distributive law to see if things simplify.  */\n \n-      if (GET_CODE (op0) == AND)\n+      if (GET_CODE (op0) == AND || GET_CODE (op1) == AND)\n \t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (op0, 0), op1),\n-\t\t\t gen_binary (IOR, mode, XEXP (op0, 1),\n-\t\t\t\t     copy_rtx (op1))));\n-\n-\t  if (GET_CODE (x) != IOR)\n-\t    return x;\n-\t}\n-\n-      if (GET_CODE (op1) == AND)\n-\t{\n-\t  x = apply_distributive_law\n-\t    (gen_binary (AND, mode,\n-\t\t\t gen_binary (IOR, mode, XEXP (op1, 0), op0),\n-\t\t\t gen_binary (IOR, mode, XEXP (op1, 1),\n-\t\t\t\t     copy_rtx (op0))));\n-\n-\t  if (GET_CODE (x) != IOR)\n-\t    return x;\n+\t  rtx result = distribute_and_simplify_rtx (x);\n+\t  if (result)\n+\t    return result;\n \t}\n \n       /* Convert (ior (ashift A CX) (lshiftrt A CY)) where CX+CY equals the\n@@ -5486,7 +5450,7 @@ simplify_logical (rtx x)\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (op0, mode)\n \t      & nonzero_bits (op1, mode)) == 0)\n-\treturn (gen_binary (IOR, mode, op0, op1));\n+\treturn (simplify_gen_binary (IOR, mode, op0, op1));\n \n       /* Convert (XOR (NOT x) (NOT y)) to (XOR x y).\n \t Also convert (XOR (NOT x) y) to (NOT (XOR x y)), similarly for\n@@ -5506,7 +5470,8 @@ simplify_logical (rtx x)\n \t  }\n \telse if (num_negated == 1)\n \t  return\n-\t    simplify_gen_unary (NOT, mode, gen_binary (XOR, mode, op0, op1),\n+\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\tsimplify_gen_binary (XOR, mode, op0, op1),\n \t\t\t\tmode);\n       }\n \n@@ -5517,16 +5482,18 @@ simplify_logical (rtx x)\n       if (GET_CODE (op0) == AND\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n-\treturn gen_binary (AND, mode,\n-\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n-\t\t\t   op1);\n+\treturn simplify_gen_binary (AND, mode,\n+\t\t\t\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t\tXEXP (op0, 0), mode),\n+\t\t\t\t    op1);\n \n       else if (GET_CODE (op0) == AND\n \t       && rtx_equal_p (XEXP (op0, 0), op1)\n \t       && ! side_effects_p (op1))\n-\treturn gen_binary (AND, mode,\n-\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n-\t\t\t   op1);\n+\treturn simplify_gen_binary (AND, mode,\n+\t\t\t\t    simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t\tXEXP (op0, 1), mode),\n+\t\t\t\t    op1);\n \n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n \t comparison if STORE_FLAG_VALUE is 1.  */\n@@ -5795,7 +5762,7 @@ expand_field_assignment (rtx x)\n   rtx inner;\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n   int len;\n-  rtx mask;\n+  rtx mask, cleared, masked;\n   enum machine_mode compute_mode;\n \n   /* Loop until we find something we can't simplify.  */\n@@ -5833,10 +5800,11 @@ expand_field_assignment (rtx x)\n \t\t/* If position is ADJUST - X, new position is X.  */\n \t\tpos = XEXP (pos, 0);\n \t      else\n-\t\tpos = gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (GET_MODE (inner))\n-\t\t\t\t\t   - len),\n-\t\t\t\t  pos);\n+\t\tpos = simplify_gen_binary (MINUS, GET_MODE (pos),\n+\t\t\t\t\t   GEN_INT (GET_MODE_BITSIZE (\n+\t\t\t\t\t\t    GET_MODE (inner))\n+\t\t\t\t\t\t    - len),\n+\t\t\t\t\t   pos);\n \t    }\n \t}\n \n@@ -5883,30 +5851,30 @@ expand_field_assignment (rtx x)\n \t}\n \n       /* Compute a mask of LEN bits, if we can do this on the host machine.  */\n-      if (len < HOST_BITS_PER_WIDE_INT)\n-\tmask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n-      else\n+      if (len >= HOST_BITS_PER_WIDE_INT)\n \tbreak;\n \n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      x = gen_rtx_SET\n-\t(VOIDmode, copy_rtx (inner),\n-\t gen_binary (IOR, compute_mode,\n-\t\t     gen_binary (AND, compute_mode,\n-\t\t\t\t simplify_gen_unary (NOT, compute_mode,\n-\t\t\t\t\t\t     gen_binary (ASHIFT,\n-\t\t\t\t\t\t\t\t compute_mode,\n-\t\t\t\t\t\t\t\t mask, pos),\n-\t\t\t\t\t\t     compute_mode),\n-\t\t\t\t inner),\n-\t\t     gen_binary (ASHIFT, compute_mode,\n-\t\t\t\t gen_binary (AND, compute_mode,\n-\t\t\t\t\t     gen_lowpart\n-\t\t\t\t\t     (compute_mode, SET_SRC (x)),\n-\t\t\t\t\t     mask),\n-\t\t\t\t pos)));\n+      mask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n+      cleared = simplify_gen_binary (AND, compute_mode,\n+\t\t\t\t     simplify_gen_unary (NOT, compute_mode,\n+\t\t\t\t       simplify_gen_binary (ASHIFT,\n+\t\t\t\t\t\t\t    compute_mode,\n+\t\t\t\t\t\t\t    mask, pos),\n+\t\t\t\t       compute_mode),\n+\t\t\t\t     inner);\n+      masked = simplify_gen_binary (ASHIFT, compute_mode,\n+\t\t\t\t    simplify_gen_binary (\n+\t\t\t\t      AND, compute_mode,\n+\t\t\t\t      gen_lowpart (compute_mode, SET_SRC (x)),\n+\t\t\t\t      mask),\n+\t\t\t\t    pos);\n+\n+      x = gen_rtx_SET (VOIDmode, copy_rtx (inner),\n+\t\t       simplify_gen_binary (IOR, compute_mode,\n+\t\t\t\t\t    cleared, masked));\n     }\n \n   return x;\n@@ -6362,8 +6330,8 @@ extract_left_shift (rtx x, int count)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n-\treturn gen_binary (code, mode, tem,\n-\t\t\t   GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n+\treturn simplify_gen_binary (code, mode, tem,\n+\t\t\t\t    GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n \n       break;\n \n@@ -6854,7 +6822,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t  && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n \t\tcval |= (HOST_WIDE_INT) -1 << width;\n \n-\t      y = gen_binary (AND, GET_MODE (x), XEXP (x, 0), GEN_INT (cval));\n+\t      y = simplify_gen_binary (AND, GET_MODE (x),\n+\t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n \t      if (rtx_cost (y, SET) < rtx_cost (x, SET))\n \t\tx = y;\n \t    }\n@@ -6946,10 +6915,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = GEN_INT ((INTVAL (XEXP (x, 1)) & mask)\n \t\t\t  << INTVAL (XEXP (XEXP (x, 0), 1)));\n-\t  temp = gen_binary (GET_CODE (x), GET_MODE (x),\n-\t\t\t     XEXP (XEXP (x, 0), 0), temp);\n-\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp,\n-\t\t\t  XEXP (XEXP (x, 0), 1));\n+\t  temp = simplify_gen_binary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n+\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x), temp,\n+\t\t\t\t   XEXP (XEXP (x, 0), 1));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n@@ -6965,7 +6934,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\treg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = gen_binary (code, op_mode, op0, op1);\n+\tx = simplify_gen_binary (code, op_mode, op0, op1);\n       break;\n \n     case ASHIFT:\n@@ -6999,7 +6968,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t\t\t\t\tmask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n-\tx = gen_binary (code, op_mode, op0, XEXP (x, 1));\n+\tx = simplify_gen_binary (code, op_mode, op0, XEXP (x, 1));\n       break;\n \n     case LSHIFTRT:\n@@ -7027,7 +6996,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  inner = force_to_mode (inner, op_mode, inner_mask, reg, next_select);\n \n \t  if (GET_MODE (x) != op_mode || inner != XEXP (x, 0))\n-\t    x = gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n+\t    x = simplify_gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n \t}\n \n       /* If we have (and (lshiftrt FOO C1) C2) where the combination of the\n@@ -7049,9 +7018,9 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  /* Must be more sign bit copies than the mask needs.  */\n \t  && ((int) num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t      >= exact_log2 (mask + 1)))\n-\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n-\t\t\tGEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n-\t\t\t\t - exact_log2 (mask + 1)));\n+\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t GEN_INT (GET_MODE_BITSIZE (GET_MODE (x))\n+\t\t\t\t\t  - exact_log2 (mask + 1)));\n \n       goto shiftrt;\n \n@@ -7116,7 +7085,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* If MASK is 1, convert this to an LSHIFTRT.  This can be done\n \t even if the shift count isn't a constant.  */\n       if (mask == 1)\n-\tx = gen_binary (LSHIFTRT, GET_MODE (x), XEXP (x, 0), XEXP (x, 1));\n+\tx = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n+\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n \n     shiftrt:\n \n@@ -7181,8 +7151,10 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t{\n \t  temp = gen_int_mode (mask << INTVAL (XEXP (XEXP (x, 0), 1)),\n \t\t\t       GET_MODE (x));\n-\t  temp = gen_binary (XOR, GET_MODE (x), XEXP (XEXP (x, 0), 0), temp);\n-\t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp, XEXP (XEXP (x, 0), 1));\n+\t  temp = simplify_gen_binary (XOR, GET_MODE (x),\n+\t\t\t\t      XEXP (XEXP (x, 0), 0), temp);\n+\t  x = simplify_gen_binary (LSHIFTRT, GET_MODE (x),\n+\t\t\t\t   temp, XEXP (XEXP (x, 0), 1));\n \n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n@@ -7292,8 +7264,19 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t  else if (cond1 == 0)\n \t    true1 = copy_rtx (true1);\n \n-\t  *ptrue = gen_binary (code, mode, true0, true1);\n-\t  *pfalse = gen_binary (code, mode, false0, false1);\n+\t  if (COMPARISON_P (x))\n+\t    {\n+\t      *ptrue = simplify_gen_relational (code, mode, VOIDmode,\n+\t\t\t\t\t\ttrue0, true1);\n+\t      *pfalse = simplify_gen_relational (code, mode, VOIDmode,\n+\t\t\t\t\t         false0, false1);\n+\t     }\n+\t  else\n+\t    {\n+\t      *ptrue = simplify_gen_binary (code, mode, true0, true1);\n+\t      *pfalse = simplify_gen_binary (code, mode, false0, false1);\n+\t    }\n+\n \t  return cond0 ? cond0 : cond1;\n \t}\n \n@@ -7323,13 +7306,13 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n \t      && ! side_effects_p (x))\n \t    {\n-\t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n-\t      *pfalse = gen_binary (MULT, mode,\n-\t\t\t\t    (code == MINUS\n-\t\t\t\t     ? simplify_gen_unary (NEG, mode, op1,\n-\t\t\t\t\t\t\t   mode)\n-\t\t\t\t     : op1),\n-\t\t\t\t    const_true_rtx);\n+\t      *ptrue = simplify_gen_binary (MULT, mode, op0, const_true_rtx);\n+\t      *pfalse = simplify_gen_binary (MULT, mode,\n+\t\t\t\t\t     (code == MINUS\n+\t\t\t\t\t      ? simplify_gen_unary (NEG, mode,\n+\t\t\t\t\t\t\t\t    op1, mode)\n+\t\t\t\t\t      : op1),\n+\t\t\t\t\t      const_true_rtx);\n \t      return cond0;\n \t    }\n \t}\n@@ -7833,8 +7816,8 @@ apply_distributive_law (rtx x)\n \t  || GET_MODE_SIZE (GET_MODE (SUBREG_REG (lhs))) > UNITS_PER_WORD)\n \treturn x;\n \n-      tem = gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n-\t\t\tSUBREG_REG (lhs), SUBREG_REG (rhs));\n+      tem = simplify_gen_binary (code, GET_MODE (SUBREG_REG (lhs)),\n+\t\t\t\t SUBREG_REG (lhs), SUBREG_REG (rhs));\n       return gen_lowpart (GET_MODE (x), tem);\n \n     default:\n@@ -7860,7 +7843,7 @@ apply_distributive_law (rtx x)\n     return x;\n \n   /* Form the new inner operation, seeing if it simplifies first.  */\n-  tem = gen_binary (code, GET_MODE (x), lhs, rhs);\n+  tem = simplify_gen_binary (code, GET_MODE (x), lhs, rhs);\n \n   /* There is one exception to the general way of distributing:\n      (a | c) ^ (b | c) -> (a ^ b) & ~c  */\n@@ -7873,8 +7856,95 @@ apply_distributive_law (rtx x)\n   /* We may be able to continuing distributing the result, so call\n      ourselves recursively on the inner operation before forming the\n      outer operation, which we return.  */\n-  return gen_binary (inner_code, GET_MODE (x),\n-\t\t     apply_distributive_law (tem), other);\n+  return simplify_gen_binary (inner_code, GET_MODE (x),\n+\t\t\t      apply_distributive_law (tem), other);\n+}\n+\n+/* See if X is of the form (* (+ a b) c), and if so convert to\n+   (+ (* a c) (* b c)) and try to simplify.\n+\n+   Most of the time, this results in no change.  However, if some of\n+   the operands are the same or inverses of each other, simplifications\n+   will result.\n+\n+   For example, (and (ior A B) (not B)) can occur as the result of\n+   expanding a bit field assignment.  When we apply the distributive\n+   law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n+   which then simplifies to (and (A (not B))).\n+ \n+   Note that no checks happen on the validity of applying the inverse\n+   distributive law.  This is pointless since we can do it in the\n+   few places where this routine is called.  */\n+static rtx\n+distribute_and_simplify_rtx (rtx x)\n+{\n+  enum machine_mode mode;\n+  enum rtx_code outer, inner;\n+  rtx op0, op1, inner_op0, inner_op1, new_op0, new_op1;\n+\n+  mode = GET_MODE (x);\n+  outer = GET_CODE (x);\n+  op0 = XEXP (x, 0);\n+  op1 = XEXP (x, 1);\n+  if (ARITHMETIC_P (op0))\n+    {\n+      inner = GET_CODE (op0);\n+      inner_op0 = XEXP (op0, 0);\n+      inner_op1 = XEXP (op0, 1);\n+\n+      /* (and (xor B C) (not A)) == (xor (ior A B) (ior A C))  */\n+      if (outer == AND && inner == XOR && GET_CODE (op1) == NOT)\n+        {\n+\t  new_op0 = simplify_gen_binary (IOR, mode, inner_op0, op1);\n+          new_op1 = simplify_gen_binary (IOR, mode, inner_op1, op1);\n+          x = apply_distributive_law (simplify_gen_binary (XOR, mode,\n+\t\t\t\t\t\t\t   new_op0, new_op1));\n+\n+\t  if (GET_CODE (x) != AND)\n+\t    return x;\n+\t}\n+      else\n+\t{\n+          new_op0 = simplify_gen_binary (outer, mode, inner_op0, op1);\n+          new_op1 = simplify_gen_binary (outer, mode, inner_op1, op1);\n+          x = apply_distributive_law (simplify_gen_binary (inner, mode,\n+\t\t\t\t\t\t\t   new_op0, new_op1));\n+\n+\t  if (GET_CODE (x) != outer)\n+\t    return x;\n+\t}\n+    }\n+\n+  if (ARITHMETIC_P (op1))\n+    {\n+      inner = GET_CODE (op1);\n+      inner_op0 = XEXP (op1, 0);\n+      inner_op1 = XEXP (op1, 1);\n+\n+      /* (and (not A) (xor B C)) == (xor (ior A B) (ior A C))  */\n+      if (outer == AND && inner == XOR && GET_CODE (op0) == NOT)\n+        {\n+\t  new_op0 = simplify_gen_binary (IOR, mode, inner_op0, op0);\n+          new_op1 = simplify_gen_binary (IOR, mode, inner_op1, op0);\n+          x = apply_distributive_law (simplify_gen_binary (XOR, mode,\n+\t\t\t\t\t\t\t   new_op0, new_op1));\n+\n+\t  if (GET_CODE (x) != AND)\n+\t    return x;\n+\t}\n+      else\n+\t{\n+          new_op0 = simplify_gen_binary (outer, mode, op0, inner_op0);\n+          new_op1 = simplify_gen_binary (outer, mode, op0, inner_op1);\n+          x = apply_distributive_law (simplify_gen_binary (inner, mode,\n+\t\t\t\t\t\t\t   new_op0, new_op1));\n+\n+\t  if (GET_CODE (x) != outer)\n+\t    return x;\n+\t}\n+    }\n+\n+  return NULL_RTX;\n }\n \f\n /* We have X, a logical `and' of VAROP with the constant CONSTOP, to be done\n@@ -7941,11 +8011,15 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       gen_lowpart\n \t(mode,\n \t apply_distributive_law\n-\t (gen_binary (GET_CODE (varop), GET_MODE (varop),\n-\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n-\t\t\t\t\t      XEXP (varop, 0), constop),\n-\t\t      simplify_and_const_int (NULL_RTX, GET_MODE (varop),\n-\t\t\t\t\t      XEXP (varop, 1), constop))));\n+\t (simplify_gen_binary (GET_CODE (varop), GET_MODE (varop),\n+\t\t\t       simplify_and_const_int (NULL_RTX,\n+\t\t\t\t\t\t       GET_MODE (varop),\n+\t\t\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t\t\t       constop),\n+\t\t\t       simplify_and_const_int (NULL_RTX,\n+\t\t\t\t\t\t       GET_MODE (varop),\n+\t\t\t\t\t\t       XEXP (varop, 1),\n+\t\t\t\t\t\t       constop))));\n \n   /* If VAROP is PLUS, and the constant is a mask of low bite, distribute\n      the AND and see if one of the operands simplifies to zero.  If so, we\n@@ -7986,7 +8060,7 @@ simplify_and_const_int (rtx x, enum machine_mode mode, rtx varop,\n       constop = trunc_int_for_mode (constop, mode);\n       /* See how much, if any, of X we can use.  */\n       if (x == 0 || GET_CODE (x) != AND || GET_MODE (x) != mode)\n-\tx = gen_binary (AND, mode, varop, GEN_INT (constop));\n+\tx = simplify_gen_binary (AND, mode, varop, GEN_INT (constop));\n \n       else\n \t{\n@@ -8505,8 +8579,10 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= gen_binary (ASHIFT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t= simplify_gen_binary (ASHIFT, GET_MODE (varop),\n+\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t       GEN_INT (exact_log2 (\n+\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8517,8 +8593,10 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n-\t\t= gen_binary (LSHIFTRT, GET_MODE (varop), XEXP (varop, 0),\n-\t\t\t      GEN_INT (exact_log2 (INTVAL (XEXP (varop, 1)))));\n+\t\t= simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n+\t\t\t\t       XEXP (varop, 0),\n+\t\t\t\t       GEN_INT (exact_log2 (\n+\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -8763,7 +8841,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t     logical expression, make a new logical expression, and apply\n \t     the inverse distributive law.  This also can't be done\n \t     for some (ashiftrt (xor)).  */\n-\t  if (code != ASHIFTRT || GET_CODE (varop)!= XOR\n+\t  if (code != ASHIFTRT || GET_CODE (varop) != XOR\n \t      || 0 <= trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t  shift_mode))\n \t    {\n@@ -8772,7 +8850,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t      rtx rhs = simplify_shift_const (NULL_RTX, code, shift_mode,\n \t\t\t\t\t      XEXP (varop, 1), count);\n \n-\t      varop = gen_binary (GET_CODE (varop), shift_mode, lhs, rhs);\n+\t      varop = simplify_gen_binary (GET_CODE (varop), shift_mode,\n+\t\t\t\t\t   lhs, rhs);\n \t      varop = apply_distributive_law (varop);\n \n \t      count = 0;\n@@ -9026,7 +9105,8 @@ simplify_shift_const (rtx x, enum rtx_code code,\n       else if (GET_RTX_CLASS (outer_op) == RTX_UNARY)\n \tx = simplify_gen_unary (outer_op, result_mode, x, result_mode);\n       else\n-\tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n+\tx = simplify_gen_binary (outer_op, result_mode, x,\n+\t\t\t\t GEN_INT (outer_const));\n     }\n \n   return x;\n@@ -9259,63 +9339,6 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n     }\n }\n \f\n-/* These routines make binary and unary operations by first seeing if they\n-   fold; if not, a new expression is allocated.  */\n-\n-static rtx\n-gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n-{\n-  rtx result;\n-  rtx tem;\n-\n-  if (GET_CODE (op0) == CLOBBER)\n-    return op0;\n-  else if (GET_CODE (op1) == CLOBBER)\n-    return op1;\n-  \n-  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-      && swap_commutative_operands_p (op0, op1))\n-    tem = op0, op0 = op1, op1 = tem;\n-\n-  if (GET_RTX_CLASS (code) == RTX_COMPARE\n-      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n-    {\n-      enum machine_mode op_mode = GET_MODE (op0);\n-\n-      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get\n-\t just (REL_OP X Y).  */\n-      if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n-\t{\n-\t  op1 = XEXP (op0, 1);\n-\t  op0 = XEXP (op0, 0);\n-\t  op_mode = GET_MODE (op0);\n-\t}\n-\n-      if (op_mode == VOIDmode)\n-\top_mode = GET_MODE (op1);\n-      result = simplify_relational_operation (code, mode, op_mode, op0, op1);\n-    }\n-  else\n-    result = simplify_binary_operation (code, mode, op0, op1);\n-\n-  if (result)\n-    return result;\n-\n-  /* Put complex operands first and constants second.  */\n-  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n-      && swap_commutative_operands_p (op0, op1))\n-    return gen_rtx_fmt_ee (code, mode, op1, op0);\n-\n-  /* If we are turning off bits already known off in OP0, we need not do\n-     an AND.  */\n-  else if (code == AND && GET_CODE (op1) == CONST_INT\n-\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t   && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n-    return op0;\n-\n-  return gen_rtx_fmt_ee (code, mode, op0, op1);\n-}\n-\f\n /* Simplify a comparison between *POP0 and *POP1 where CODE is the\n    comparison code that will be tested.\n \n@@ -10150,9 +10173,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t  && c1 != mask\n \t\t  && c1 != GET_MODE_MASK (tmode))\n \t\t{\n-\t\t  op0 = gen_binary (AND, tmode,\n-\t\t\t\t    SUBREG_REG (XEXP (op0, 0)),\n-\t\t\t\t    gen_int_mode (c1, tmode));\n+\t\t  op0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t     SUBREG_REG (XEXP (op0, 0)),\n+\t\t\t\t\t     gen_int_mode (c1, tmode));\n \t\t  op0 = gen_lowpart (mode, op0);\n \t\t  continue;\n \t\t}\n@@ -10296,12 +10319,12 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n \t      rtx add_const = XEXP (XEXP (op0, 0), 1);\n-\t      rtx new_const = gen_binary (ASHIFTRT, GET_MODE (op0), add_const,\n-\t\t\t\t\t  XEXP (op0, 1));\n+\t      rtx new_const = simplify_gen_binary (ASHIFTRT, GET_MODE (op0),\n+\t\t\t\t\t\t   add_const, XEXP (op0, 1));\n \n-\t      op0 = gen_binary (PLUS, tmode,\n-\t\t\t\tgen_lowpart (tmode, inner),\n-\t\t\t\tnew_const);\n+\t      op0 = simplify_gen_binary (PLUS, tmode,\n+\t\t\t\t\t gen_lowpart (tmode, inner),\n+\t\t\t\t\t new_const);\n \t      continue;\n \t    }\n \n@@ -10454,11 +10477,11 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t make a new AND in the proper mode.  */\n \t      if (GET_CODE (op0) == AND\n \t\t  && !have_insn_for (AND, mode))\n-\t\top0 = gen_binary (AND, tmode,\n-\t\t\t\t  gen_lowpart (tmode,\n-\t\t\t\t\t       XEXP (op0, 0)),\n-\t\t\t\t  gen_lowpart (tmode,\n-\t\t\t\t\t       XEXP (op0, 1)));\n+\t\top0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t   gen_lowpart (tmode,\n+\t\t\t\t\t\t\tXEXP (op0, 0)),\n+\t\t\t\t\t   gen_lowpart (tmode,\n+\t\t\t\t\t\t\tXEXP (op0, 1)));\n \n \t      op0 = gen_lowpart (tmode, op0);\n \t      if (zero_extended && GET_CODE (op1) == CONST_INT)\n@@ -10473,10 +10496,11 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (op1 == const0_rtx && (code == LT || code == GE)\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      op0 = gen_binary (AND, tmode,\n-\t\t\t\tgen_lowpart (tmode, op0),\n-\t\t\t\tGEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t << (GET_MODE_BITSIZE (mode) - 1)));\n+\t      op0 = simplify_gen_binary (AND, tmode,\n+\t\t\t\t\t gen_lowpart (tmode, op0),\n+\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t\t  << (GET_MODE_BITSIZE (mode)\n+\t\t\t\t\t\t      - 1)));\n \t      code = (code == LT) ? NE : EQ;\n \t      break;\n \t    }\n@@ -10523,7 +10547,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n   if (reversed_code == UNKNOWN)\n     return NULL_RTX;\n   else\n-    return gen_binary (reversed_code, mode, op0, op1);\n+    return simplify_gen_relational (reversed_code, mode, VOIDmode, op0, op1);\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value"}, {"sha": "fb80219155c4d56dd603b0445bfbc02986de4dbe", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dce1438a65f25cceffec22d53d41ea35ee422673/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=dce1438a65f25cceffec22d53d41ea35ee422673", "patch": "@@ -1844,9 +1844,11 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \tcase AND:\n \t  if (trueop1 == const0_rtx && ! side_effects_p (op0))\n \t    return const0_rtx;\n+\t  /* If we are turning off bits already known off in OP0, we need\n+\t     not do an AND.  */\n \t  if (GET_CODE (trueop1) == CONST_INT\n-\t      && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n-\t\t  == GET_MODE_MASK (mode)))\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && (nonzero_bits (trueop0, mode) & ~INTVAL (trueop1)) == 0)\n \t    return op0;\n \t  if (trueop0 == trueop1 && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)"}]}