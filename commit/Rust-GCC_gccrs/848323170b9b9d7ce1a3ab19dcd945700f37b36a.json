{"sha": "848323170b9b9d7ce1a3ab19dcd945700f37b36a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4MzIzMTcwYjliOWQ3Y2UxYTNhYjE5ZGNkOTQ1NzAwZjM3YjM2YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-27T19:27:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-27T19:27:41Z"}, "message": "rtl.h (note_stores): Add additional paramter.\n\n\t* rtl.h (note_stores): Add additional paramter.\n\t* rtlanal.c (reg_set_p_1): Take additional paramter.\n\t(reg_set_last_1): Likewise.\n\t(reg_set_p): Adjust call to note_stores.\n\t(reg_set_last): Likewise.\n\t(note_stores): Pass data parameter to worker function.\n\t* alias.c (record_set): Take additional parameter.\n\t(init_alias_analysis): Pass it.\n\t* caller-save.c (mark_set_regs): Take additional parameter.\n\t(save_call_clobbered_regs): Pass NULL to note_stores.\n\t* combine.c (set_nonzero_bits_and_sign_copies): Take additional\n\tparameter.\n\t(record_dead_and_set_regs_1): Likewise.\n\t(reg_dead_at_p_1): Likewise.\n\t(combine_instructions): Adjust calls to note_stores.\n\t(try_combine): Likewise.\n\t(record_dead_insn): Remove.\n\t(record_dead_and_set_regs): Adjust calls to note_stores.\n\t(reg_dead_at_p): Likewise.\n\t* cse.c (invalidate_skipped_set): Take additional parameter.\n\t(cse_check_loop_start): Likewise.\n\t(cse_check_loop_start_value): Remove.\n\t(cse_set_around_loop): Adjust calls to note_stores.\n\t* flow.c (notice_stack_pointer_modification): Take additional\n\tparameter.  Remove duplicate declaration.\n\t(record_volatile_insns): Adjust calls to note_stores.\n\t* gcse.c (record_set_info): Take additional parameter.\n\t(record_last_set_info): Likewise.\n\t(invalidate_nonnull_info): Likewise.\n\t(record_set_insn): Remove.\n\t(compute_sets): Adjust calls to note_stores.\n\t(last_set_insn): Remove.\n\t(compute_hash_table): Adjust calls to note_stores.\n\t(insert_insn_end_bb): Likewise.\n\t(delete_null_pointer_checks): Likewise.\n\t* global.c (mark_reg_store): Take additional parameter.\n\t(mark_reg_clobber): Likewise.\n\t(reg_becomes_live): Likewise.\n\t(global_conflicts): Adjust calls to note_stores.\n\t(build_insn_chain): Likewise.\n\t* integrate.c (note_modified_parmregs): Take additional parameter.\n\t(mark_stores): Likewise.  Make it static.\n\t(save_for_inline_nocopy): Adjust calls to note_stores.\n\t(try_constants): Likewise.\n\t* integrate.h (mark_stores): Remove declaration.\n\t* jump.c (mark_modified_reg): Take additional parameter.\n\t(thread_jumps): Adjust calls to note_stores.\n\t* local-alloc.c (validate_equiv_mem_from_store): Take additional\n\tparameter.\n\t(no_equiv): Likewise.\n\t(reg_is_set): Likewise.\n\t(validate_equiv_mem): Adjust calls to note_stores.\n\t(update_equiv_regs): Likewise.\n\t(block_alloc): Likewise.\n\t* loop.c (note_set_pseudo_multiple_uses_retval): Remove.\n\t(note_addr_stored): Take additional parameter.\n\t(note_set_pseudo_multiple_uses): Likewise.\n\t(record_initial): Likewise.\n\t(prescan_loop): Adjust calls to note_stores.\n\t(strength_reduce): Likewise.\n\t(check_dbra_loop): Likewise.\n\t* regmove.c (flags_set_1): Take additional paramter.\n\t(mark_flags_life_zones): Adjust calls to note_stores.\n\t* reload1.c (mark_not_eliminable): Take additional parameter.\n\t(forget_old_reloads_1): Likewise.\n\t(reload_cse_invalidate_rtx): Likewise.\n\t(reload_cse_check_clobber): Likewise.\n\t(reload_combine_note_store): Likewise.\n\t(move2add_note_store): Likewise.\n\t(reload): Adjust calls to note_stores.\n\t(reload_as_needed): Likewise.\n\t(emit_reload_insns): Likewise.\n\t(reload_cse_regs_1): Likewise.\n\t(reload_cse_record_set): Adjust calls to reload_cse_invalidate_rtx.\n\t(reload_combine): Adjust calls to note_stores.\n\t* resource.c (update_live_status): Take additional paramter.\n\t(mark_target_live_regs): Adjust calls to note_stores.\n\t* stupid.c (find_clobbered_regs): Take additional parameter.\n\t(stupid_life_analysis): Adjust calls to note_stores.\n\nFrom-SVN: r30221", "tree": {"sha": "ea2baf03b5fb6cdb1cb4627f42bbf6bd5341560e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea2baf03b5fb6cdb1cb4627f42bbf6bd5341560e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848323170b9b9d7ce1a3ab19dcd945700f37b36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848323170b9b9d7ce1a3ab19dcd945700f37b36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848323170b9b9d7ce1a3ab19dcd945700f37b36a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848323170b9b9d7ce1a3ab19dcd945700f37b36a/comments", "author": null, "committer": null, "parents": [{"sha": "6ead9ba5a235459ceb3e3d4f6e963d38efd6c6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ead9ba5a235459ceb3e3d4f6e963d38efd6c6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ead9ba5a235459ceb3e3d4f6e963d38efd6c6a8"}], "stats": {"total": 459, "additions": 286, "deletions": 173}, "files": [{"sha": "f3cb9de62a4b596e4f2daa12cf8262daefde60d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -1,3 +1,85 @@\n+Wed Oct 27 12:33:40 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* rtl.h (note_stores): Add additional paramter.\n+\t* rtlanal.c (reg_set_p_1): Take additional paramter.\n+\t(reg_set_last_1): Likewise.\n+\t(reg_set_p): Adjust call to note_stores.\n+\t(reg_set_last): Likewise.\n+\t(note_stores): Pass data parameter to worker function.\n+\t* alias.c (record_set): Take additional parameter.\n+\t(init_alias_analysis): Pass it.\n+\t* caller-save.c (mark_set_regs): Take additional parameter.\n+\t(save_call_clobbered_regs): Pass NULL to note_stores.\n+\t* combine.c (set_nonzero_bits_and_sign_copies): Take additional\n+\tparameter.\n+\t(record_dead_and_set_regs_1): Likewise.\n+\t(reg_dead_at_p_1): Likewise.\n+\t(combine_instructions): Adjust calls to note_stores.\n+\t(try_combine): Likewise.\n+\t(record_dead_insn): Remove.\n+\t(record_dead_and_set_regs): Adjust calls to note_stores.\n+\t(reg_dead_at_p): Likewise.\n+\t* cse.c (invalidate_skipped_set): Take additional parameter.\n+\t(cse_check_loop_start): Likewise.\n+\t(cse_check_loop_start_value): Remove.\n+\t(cse_set_around_loop): Adjust calls to note_stores.\n+\t* flow.c (notice_stack_pointer_modification): Take additional\n+\tparameter.  Remove duplicate declaration.\n+\t(record_volatile_insns): Adjust calls to note_stores.\n+\t* gcse.c (record_set_info): Take additional parameter.\n+\t(record_last_set_info): Likewise.\n+\t(invalidate_nonnull_info): Likewise.\n+\t(record_set_insn): Remove.\n+\t(compute_sets): Adjust calls to note_stores.\n+\t(last_set_insn): Remove.\n+\t(compute_hash_table): Adjust calls to note_stores.\n+\t(insert_insn_end_bb): Likewise.\n+\t(delete_null_pointer_checks): Likewise.\n+\t* global.c (mark_reg_store): Take additional parameter.\n+\t(mark_reg_clobber): Likewise.\n+\t(reg_becomes_live): Likewise.\n+\t(global_conflicts): Adjust calls to note_stores.\n+\t(build_insn_chain): Likewise.\n+\t* integrate.c (note_modified_parmregs): Take additional parameter.\n+\t(mark_stores): Likewise.  Make it static.\n+\t(save_for_inline_nocopy): Adjust calls to note_stores.\n+\t(try_constants): Likewise.\n+\t* integrate.h (mark_stores): Remove declaration.\n+\t* jump.c (mark_modified_reg): Take additional parameter.\n+\t(thread_jumps): Adjust calls to note_stores.\n+\t* local-alloc.c (validate_equiv_mem_from_store): Take additional\n+\tparameter.\n+\t(no_equiv): Likewise.\n+\t(reg_is_set): Likewise.\n+\t(validate_equiv_mem): Adjust calls to note_stores.\n+\t(update_equiv_regs): Likewise.\n+\t(block_alloc): Likewise.\n+\t* loop.c (note_set_pseudo_multiple_uses_retval): Remove.\n+\t(note_addr_stored): Take additional parameter.\n+\t(note_set_pseudo_multiple_uses): Likewise.\n+\t(record_initial): Likewise.\n+\t(prescan_loop): Adjust calls to note_stores.\n+\t(strength_reduce): Likewise.\n+\t(check_dbra_loop): Likewise.\n+\t* regmove.c (flags_set_1): Take additional paramter.\n+\t(mark_flags_life_zones): Adjust calls to note_stores.\n+\t* reload1.c (mark_not_eliminable): Take additional parameter.\n+\t(forget_old_reloads_1): Likewise.\n+\t(reload_cse_invalidate_rtx): Likewise.\n+\t(reload_cse_check_clobber): Likewise.\n+\t(reload_combine_note_store): Likewise.\n+\t(move2add_note_store): Likewise.\n+\t(reload): Adjust calls to note_stores.\n+\t(reload_as_needed): Likewise.\n+\t(emit_reload_insns): Likewise.\n+\t(reload_cse_regs_1): Likewise.\n+\t(reload_cse_record_set): Adjust calls to reload_cse_invalidate_rtx.\n+\t(reload_combine): Adjust calls to note_stores.\n+\t* resource.c (update_live_status): Take additional paramter.\n+\t(mark_target_live_regs): Adjust calls to note_stores.\n+\t* stupid.c (find_clobbered_regs): Take additional parameter.\n+\t(stupid_life_analysis): Adjust calls to note_stores.\n+\t\n Wed Oct 27 19:26:12 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/arm/coff.h (STRUCTURE_SIZE_BOUNDARY): Delete"}, {"sha": "ebb1e7c7efbe6c10d5893902bd9b2d4c93e923a1", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -82,7 +82,7 @@ static int rtx_equal_for_memref_p\tPROTO((rtx, rtx));\n static rtx find_symbolic_term\t\tPROTO((rtx));\n static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n \t\t\t\t\t       HOST_WIDE_INT));\n-static void record_set\t\t\tPROTO((rtx, rtx));\n+static void record_set\t\t\tPROTO((rtx, rtx, void *));\n static rtx find_base_term\t\tPROTO((rtx));\n static int base_alias_check\t\tPROTO((rtx, rtx, enum machine_mode,\n \t\t\t\t\t       enum machine_mode));\n@@ -451,8 +451,9 @@ static char *reg_seen;\n static int unique_id;\n \n static void\n-record_set (dest, set)\n+record_set (dest, set, data)\n      rtx dest, set;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   register unsigned regno;\n   rtx src;\n@@ -1652,9 +1653,9 @@ init_alias_analysis ()\n \n \t      if (GET_CODE (PATTERN (insn)) == SET\n \t\t  && (find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n-\t\trecord_set (SET_DEST (PATTERN (insn)), NULL_RTX);\n+\t\trecord_set (SET_DEST (PATTERN (insn)), NULL_RTX, NULL);\n \t      else\n-\t\tnote_stores (PATTERN (insn), record_set);\n+\t\tnote_stores (PATTERN (insn), record_set, NULL);\n \n \t      set = single_set (insn);\n "}, {"sha": "b58fe871325eec7f96252350a43583c02a026f06", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -84,7 +84,7 @@ static HARD_REG_SET referenced_regs;\n static HARD_REG_SET this_insn_sets;\n \n \n-static void mark_set_regs\t\tPROTO((rtx, rtx));\n+static void mark_set_regs\t\tPROTO((rtx, rtx, void *));\n static void mark_referenced_regs\tPROTO((rtx));\n static int insert_save\t\t\tPROTO((struct insn_chain *, int, int,\n \t\t\t\t\t       HARD_REG_SET *));\n@@ -385,7 +385,7 @@ save_call_clobbered_regs ()\n \t      /* Record all registers set in this call insn.  These don't need\n \t\t to be saved.  */\n \t      CLEAR_HARD_REG_SET (this_insn_sets);\n-\t      note_stores (PATTERN (insn), mark_set_regs);\n+\t      note_stores (PATTERN (insn), mark_set_regs, NULL);\n \n \t      /* Compute which hard regs must be saved before this call.  */\n \t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, call_fixed_reg_set);\n@@ -465,9 +465,10 @@ save_call_clobbered_regs ()\n    been assigned hard regs have had their register number changed already,\n    so we can ignore pseudos.  */\n static void\n-mark_set_regs (reg, setter)\n+mark_set_regs (reg, setter, data)\n      rtx reg;\n      rtx setter ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   register int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);"}, {"sha": "f3dcc96c202ca8b203cfa5671e65c663a526df87", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -354,7 +354,7 @@ static void do_SUBST\t\t\tPROTO((rtx *, rtx));\n static void do_SUBST_INT\t\tPROTO((int *, int));\n static void init_reg_last_arrays\tPROTO((void));\n static void setup_incoming_promotions   PROTO((void));\n-static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx));\n+static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx, void *));\n static int can_combine_p\tPROTO((rtx, rtx, rtx, rtx, rtx *, rtx *));\n static int sets_function_arg_p\tPROTO((rtx));\n static int combinable_i3pat\tPROTO((rtx, rtx *, rtx, rtx, int, rtx *));\n@@ -401,12 +401,12 @@ static enum rtx_code simplify_comparison  PROTO((enum rtx_code, rtx *, rtx *));\n static int reversible_comparison_p  PROTO((rtx));\n static void update_table_tick\tPROTO((rtx));\n static void record_value_for_reg  PROTO((rtx, rtx, rtx));\n-static void record_dead_and_set_regs_1  PROTO((rtx, rtx));\n+static void record_dead_and_set_regs_1  PROTO((rtx, rtx, void *));\n static void record_dead_and_set_regs  PROTO((rtx));\n static int get_last_value_validate  PROTO((rtx *, rtx, int, int));\n static rtx get_last_value\tPROTO((rtx));\n static int use_crosses_set_p\tPROTO((rtx, int));\n-static void reg_dead_at_p_1\tPROTO((rtx, rtx));\n+static void reg_dead_at_p_1\tPROTO((rtx, rtx, void *));\n static int reg_dead_at_p\tPROTO((rtx, rtx));\n static void move_deaths\t\tPROTO((rtx, rtx, int, rtx, rtx *));\n static int reg_bitfield_target_p  PROTO((rtx, rtx));\n@@ -569,13 +569,15 @@ combine_instructions (f, nregs)\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies);\n+\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies, \n+\t\t       NULL);\n \t  record_dead_and_set_regs (insn);\n \n #ifdef AUTO_INC_DEC\n \t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n \t    if (REG_NOTE_KIND (links) == REG_INC)\n-\t      set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX);\n+\t      set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n+\t\t\t\t\t\tNULL);\n #endif\n \t}\n \n@@ -769,9 +771,10 @@ setup_incoming_promotions ()\n    by any set of X.  */\n \n static void\n-set_nonzero_bits_and_sign_copies (x, set)\n+set_nonzero_bits_and_sign_copies (x, set, data)\n      rtx x;\n      rtx set;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int num;\n \n@@ -2557,9 +2560,9 @@ try_combine (i3, i2, i1)\n     /* Update reg_nonzero_bits et al for any changes that may have been made\n        to this insn.  */\n \n-    note_stores (newpat, set_nonzero_bits_and_sign_copies);\n+    note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n     if (newi2pat)\n-      note_stores (newi2pat, set_nonzero_bits_and_sign_copies);\n+      note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n \n     /* If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n@@ -10753,16 +10756,17 @@ record_value_for_reg (reg, insn, value)\n     }\n }\n \n-/* Used for communication between the following two routines.  */\n-static rtx record_dead_insn;\n-\n /* Called via note_stores from record_dead_and_set_regs to handle one\n-   SET or CLOBBER in an insn.  */\n+   SET or CLOBBER in an insn.  DATA is the instruction in which the\n+   set is occurring.  */\n \n static void\n-record_dead_and_set_regs_1 (dest, setter)\n+record_dead_and_set_regs_1 (dest, setter, data)\n      rtx dest, setter;\n+     void *data;\n {\n+  rtx record_dead_insn = (rtx) data;\n+\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n@@ -10840,8 +10844,7 @@ record_dead_and_set_regs (insn)\n       last_call_cuid = mem_last_set = INSN_CUID (insn);\n     }\n \n-  record_dead_insn = insn;\n-  note_stores (PATTERN (insn), record_dead_and_set_regs_1);\n+  note_stores (PATTERN (insn), record_dead_and_set_regs_1, insn);\n }\n \f\n /* Utility routine for the following function.  Verify that all the registers\n@@ -11040,9 +11043,10 @@ static int reg_dead_flag;\n    reg_dead_flag to 1 if X is a CLOBBER and to -1 it is a SET.  */\n \n static void\n-reg_dead_at_p_1 (dest, x)\n+reg_dead_at_p_1 (dest, x, data)\n      rtx dest;\n      rtx x;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno, endregno;\n \n@@ -11094,7 +11098,7 @@ reg_dead_at_p (reg, insn)\n   for (; insn && GET_CODE (insn) != CODE_LABEL && GET_CODE (insn) != BARRIER;\n        insn = prev_nonnote_insn (insn))\n     {\n-      note_stores (PATTERN (insn), reg_dead_at_p_1);\n+      note_stores (PATTERN (insn), reg_dead_at_p_1, NULL);\n       if (reg_dead_flag)\n \treturn reg_dead_flag == 1 ? 1 : 0;\n "}, {"sha": "bc7bd659ba08b6d134108982966dc3be897436a8", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -693,9 +693,9 @@ static int note_mem_written\tPROTO((rtx));\n static void invalidate_from_clobbers PROTO((rtx));\n static rtx cse_process_notes\tPROTO((rtx, rtx));\n static void cse_around_loop\tPROTO((rtx));\n-static void invalidate_skipped_set PROTO((rtx, rtx));\n+static void invalidate_skipped_set PROTO((rtx, rtx, void *));\n static void invalidate_skipped_block PROTO((rtx));\n-static void cse_check_loop_start PROTO((rtx, rtx));\n+static void cse_check_loop_start PROTO((rtx, rtx, void *));\n static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n@@ -8205,9 +8205,10 @@ cse_around_loop (loop_start)\n    since they are done elsewhere.  This function is called via note_stores.  */\n \n static void\n-invalidate_skipped_set (dest, set)\n+invalidate_skipped_set (dest, set, data)\n      rtx set;\n      rtx dest;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (dest);\n \n@@ -8262,30 +8263,29 @@ invalidate_skipped_block (start)\n \t}\n \n       invalidate_from_clobbers (PATTERN (insn));\n-      note_stores (PATTERN (insn), invalidate_skipped_set);\n+      note_stores (PATTERN (insn), invalidate_skipped_set, NULL);\n     }\n }\n \f\n-/* Used for communication between the following two routines; contains a\n-   value to be checked for modification.  */\n-\n-static rtx cse_check_loop_start_value;\n-\n-/* If modifying X will modify the value in CSE_CHECK_LOOP_START_VALUE,\n-   indicate that fact by setting CSE_CHECK_LOOP_START_VALUE to 0.  */\n+/* If modifying X will modify the value in *DATA (which is really an\n+   `rtx *'), indicate that fact by setting the pointed to value to\n+   NULL_RTX.  */\n \n static void\n-cse_check_loop_start (x, set)\n+cse_check_loop_start (x, set, data)\n      rtx x;\n      rtx set ATTRIBUTE_UNUSED;\n+     void *data;\n {\n-  if (cse_check_loop_start_value == 0\n+  rtx *cse_check_loop_start_value = (rtx *) data;\n+\n+  if (*cse_check_loop_start_value == NULL_RTX\n       || GET_CODE (x) == CC0 || GET_CODE (x) == PC)\n     return;\n \n-  if ((GET_CODE (x) == MEM && GET_CODE (cse_check_loop_start_value) == MEM)\n-      || reg_overlap_mentioned_p (x, cse_check_loop_start_value))\n-    cse_check_loop_start_value = 0;\n+  if ((GET_CODE (x) == MEM && GET_CODE (*cse_check_loop_start_value) == MEM)\n+      || reg_overlap_mentioned_p (x, *cse_check_loop_start_value))\n+    *cse_check_loop_start_value = NULL_RTX;\n }\n \n /* X is a SET or CLOBBER contained in INSN that was found near the start of\n@@ -8350,11 +8350,12 @@ cse_set_around_loop (x, insn, loop_start)\n \t\t       can modify it, or we would have invalidated it in\n \t\t       the hash table.  */\n \t\t    rtx q;\n-\n-\t\t    cse_check_loop_start_value = SET_SRC (x);\n+\t\t    rtx cse_check_loop_start_value = SET_SRC (x);\n \t\t    for (q = p; q != loop_start; q = NEXT_INSN (q))\n \t\t      if (GET_RTX_CLASS (GET_CODE (q)) == 'i')\n-\t\t\tnote_stores (PATTERN (q), cse_check_loop_start);\n+\t\t\tnote_stores (PATTERN (q),\n+\t\t\t\t     cse_check_loop_start,\n+\t\t\t\t     &cse_check_loop_start_value);\n \n \t\t    /* If nothing was changed and we can replace our\n \t\t       SET_SRC, add an insn after P to copy its destination"}, {"sha": "9ce099fbc11c2917cb8553873b986d8281b88797", "filename": "gcc/flow.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -328,7 +328,7 @@ static void verify_wide_reg\t\tPROTO((int, rtx, rtx));\n static void verify_local_live_at_start\tPROTO((regset, basic_block));\n static int set_noop_p\t\t\tPROTO((rtx));\n static int noop_move_p\t\t\tPROTO((rtx));\n-static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n+static void notice_stack_pointer_modification PROTO ((rtx, rtx, void *));\n static void record_volatile_insns\tPROTO((rtx));\n static void mark_reg\t\t\tPROTO((regset, rtx));\n static void mark_regs_live_at_end\tPROTO((regset));\n@@ -361,7 +361,6 @@ static void add_pred_succ\t\tPROTO ((int, int, int_list_ptr *,\n static void count_reg_sets_1\t\tPROTO ((rtx));\n static void count_reg_sets\t\tPROTO ((rtx));\n static void count_reg_references\tPROTO ((rtx));\n-static void notice_stack_pointer_modification PROTO ((rtx, rtx));\n static void invalidate_mems_from_autoinc\tPROTO ((rtx));\n static void remove_edge\t\t\tPROTO ((edge));\n static void remove_fake_successors\tPROTO ((basic_block));\n@@ -2694,9 +2693,10 @@ noop_move_p (insn)\n }\n \n static void\n-notice_stack_pointer_modification (x, pat)\n+notice_stack_pointer_modification (x, pat, data)\n      rtx x;\n      rtx pat ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (x == stack_pointer_rtx\n       /* The stack pointer is only modified indirectly as the result\n@@ -2759,7 +2759,9 @@ record_volatile_insns (f)\n       /* Check if insn modifies the stack pointer.  */\n       if ( current_function_sp_is_unchanging\n \t   && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tnote_stores (PATTERN (insn), notice_stack_pointer_modification);\n+\tnote_stores (PATTERN (insn),\n+\t\t     notice_stack_pointer_modification,\n+\t\t     NULL);\n     }\n }\n "}, {"sha": "a40852dc2d86b14c3daa45c94c32b40d47c931cf", "filename": "gcc/gcse.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -521,7 +521,7 @@ static void free_gcse_mem\t     PROTO ((void));\n static void alloc_reg_set_mem\t PROTO ((int));\n static void free_reg_set_mem\t  PROTO ((void));\n static void record_one_set\t    PROTO ((int, rtx));\n-static void record_set_info\t   PROTO ((rtx, rtx));\n+static void record_set_info\t   PROTO ((rtx, rtx, void *));\n static void compute_sets\t      PROTO ((rtx));\n \n static void hash_scan_insn\t    PROTO ((rtx, int, int));\n@@ -542,7 +542,7 @@ static unsigned int hash_set\t  PROTO ((int, int));\n static int expr_equiv_p\t       PROTO ((rtx, rtx));\n static void record_last_reg_set_info  PROTO ((rtx, int));\n static void record_last_mem_set_info  PROTO ((rtx));\n-static void record_last_set_info      PROTO ((rtx, rtx));\n+static void record_last_set_info      PROTO ((rtx, rtx, void *));\n static void compute_hash_table\tPROTO ((int));\n static void alloc_set_hash_table      PROTO ((int));\n static void free_set_hash_table       PROTO ((void));\n@@ -621,7 +621,7 @@ static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n static int handle_avail_expr\t  PROTO ((rtx, struct expr *));\n static int classic_gcse\t       PROTO ((void));\n static int one_classic_gcse_pass      PROTO ((int));\n-static void invalidate_nonnull_info\tPROTO ((rtx, rtx));\n+static void invalidate_nonnull_info\tPROTO ((rtx, rtx, void *));\n static rtx process_insert_insn\tPROTO ((struct expr *));\n static int pre_edge_insert\tPROTO ((struct edge_list *, struct expr **));\n \f\n@@ -1130,16 +1130,17 @@ record_one_set (regno, insn)\n     }\n }\n \n-/* For communication between next two functions (via note_stores).  */\n-static rtx record_set_insn;\n-\n /* Called from compute_sets via note_stores to handle one\n-   SET or CLOBBER in an insn.  */\n+   SET or CLOBBER in an insn.  The DATA is really the instruction\n+   in which the SET is occurring.  */\n \n static void\n-record_set_info (dest, setter)\n+record_set_info (dest, setter, data)\n      rtx dest, setter ATTRIBUTE_UNUSED;\n+     void *data;\n {\n+  rtx record_set_insn = (rtx) data;\n+\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n@@ -1164,10 +1165,7 @@ compute_sets (f)\n   while (insn)\n     {\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t{\n-\t  record_set_insn = insn;\n-\t  note_stores (PATTERN (insn), record_set_info);\n-\t}\n+\tnote_stores (PATTERN (insn), record_set_info, insn);\n       insn = NEXT_INSN (insn);\n     }\n }\n@@ -2069,16 +2067,17 @@ record_last_mem_set_info (insn)\n   mem_set_in_block[BLOCK_NUM (insn)] = 1;\n }\n \n-/* Used for communicating between next two routines.  */\n-static rtx last_set_insn;\n-\n /* Called from compute_hash_table via note_stores to handle one\n-   SET or CLOBBER in an insn.  */\n+   SET or CLOBBER in an insn.  DATA is really the instruction in which\n+   the SET is taking place.  */\n \n static void\n-record_last_set_info (dest, setter)\n+record_last_set_info (dest, setter, data)\n      rtx dest, setter ATTRIBUTE_UNUSED;\n+     void *data;\n {\n+  rtx last_set_insn = (rtx) data;\n+\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n@@ -2183,8 +2182,7 @@ compute_hash_table (set_p)\n \t\trecord_last_mem_set_info (insn);\n \t    }\n \n-\t  last_set_insn = insn;\n-\t  note_stores (PATTERN (insn), record_last_set_info);\n+\t  note_stores (PATTERN (insn), record_last_set_info, insn);\n \t}\n \n       /* The next pass builds the hash table.  */\n@@ -4433,8 +4431,7 @@ insert_insn_end_bb (expr, bb, pre)\n \t  set_block_num (insn, bb);\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t    add_label_notes (PATTERN (insn), new_insn);\n-\t  record_set_insn = insn;\n-\t  note_stores (PATTERN (insn), record_set_info);\n+\t  note_stores (PATTERN (insn), record_set_info, insn);\n \t}\n     }\n   else\n@@ -4930,9 +4927,10 @@ static sbitmap *nonnull_killed;\n \n    We ignore hard registers.  */\n static void\n-invalidate_nonnull_info (x, setter)\n+invalidate_nonnull_info (x, setter, data)\n      rtx x;\n      rtx setter ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int offset, regno;\n \n@@ -5058,7 +5056,7 @@ delete_null_pointer_checks (f)\n \t  set = single_set (insn);\n \t  if (!set)\n \t    {\n-\t      note_stores (PATTERN (insn), invalidate_nonnull_info);\n+\t      note_stores (PATTERN (insn), invalidate_nonnull_info, NULL);\n \t      continue;\n \t    }\n \n@@ -5072,7 +5070,7 @@ delete_null_pointer_checks (f)\n \t\t     REGNO (XEXP (SET_SRC (set), 0)));\n \n \t  /* Now invalidate stuff clobbered by this insn.  */\n-\t  note_stores (PATTERN (insn), invalidate_nonnull_info);\n+\t  note_stores (PATTERN (insn), invalidate_nonnull_info, NULL);\n \n \t  /* And handle stores, we do these last since any sets in INSN can\n \t     not kill the nonnull property if it is derived from a MEM"}, {"sha": "0b8aedd4cf85049a5a66f9f676be42bb763922e6", "filename": "gcc/global.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -264,14 +264,14 @@ static void prune_preferences\tPROTO((void));\n static void find_reg\t\tPROTO((int, HARD_REG_SET, int, int, int));\n static void record_one_conflict PROTO((int));\n static void record_conflicts\tPROTO((int *, int));\n-static void mark_reg_store\tPROTO((rtx, rtx));\n-static void mark_reg_clobber\tPROTO((rtx, rtx));\n+static void mark_reg_store\tPROTO((rtx, rtx, void *));\n+static void mark_reg_clobber\tPROTO((rtx, rtx, void *));\n static void mark_reg_conflicts\tPROTO((rtx));\n static void mark_reg_death\tPROTO((rtx));\n static void mark_reg_live_nc\tPROTO((int, enum machine_mode));\n static void set_preference\tPROTO((rtx, rtx));\n static void dump_conflicts\tPROTO((FILE *));\n-static void reg_becomes_live\tPROTO((rtx, rtx));\n+static void reg_becomes_live\tPROTO((rtx, rtx, void *));\n static void reg_dies\t\tPROTO((int, enum machine_mode));\n static void build_insn_chain\tPROTO((rtx));\n \f\n@@ -722,7 +722,7 @@ global_conflicts ()\n \t      /* Mark any registers clobbered by INSN as live,\n \t\t so they conflict with the inputs.  */\n \n-\t      note_stores (PATTERN (insn), mark_reg_clobber);\n+\t      note_stores (PATTERN (insn), mark_reg_clobber, NULL);\n \n \t      /* Mark any registers dead after INSN as dead now.  */\n \n@@ -735,12 +735,12 @@ global_conflicts ()\n \t\t Clobbers are processed again, so they conflict with\n \t\t the registers that are set.  */\n \n-\t      note_stores (PATTERN (insn), mark_reg_store);\n+\t      note_stores (PATTERN (insn), mark_reg_store, NULL);\n \n #ifdef AUTO_INC_DEC\n \t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_INC)\n-\t\t  mark_reg_store (XEXP (link, 0), NULL_RTX);\n+\t\t  mark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n #endif\n \n \t      /* If INSN has multiple outputs, then any reg that dies here\n@@ -1341,8 +1341,9 @@ record_conflicts (allocno_vec, len)\n    a REG_INC note was found for it).  */\n \n static void\n-mark_reg_store (reg, setter)\n+mark_reg_store (reg, setter, data)\n      rtx reg, setter;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   register int regno;\n \n@@ -1398,11 +1399,12 @@ mark_reg_store (reg, setter)\n /* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */\n \n static void\n-mark_reg_clobber (reg, setter)\n+mark_reg_clobber (reg, setter, data)\n      rtx reg, setter;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (setter) == CLOBBER)\n-    mark_reg_store (reg, setter);\n+    mark_reg_store (reg, setter, data);\n }\n \n /* Record that REG has conflicts with all the regs currently live.\n@@ -1623,9 +1625,10 @@ static regset live_relevant_regs;\n /* Record in live_relevant_regs that register REG became live.  This\n    is called via note_stores.  */\n static void\n-reg_becomes_live (reg, setter)\n+reg_becomes_live (reg, setter, data)\n      rtx reg;\n      rtx setter ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno;\n \n@@ -1718,7 +1721,7 @@ build_insn_chain (first)\n \n \t      /* Mark everything born in this instruction as live.  */\n \n-\t      note_stores (PATTERN (first), reg_becomes_live);\n+\t      note_stores (PATTERN (first), reg_becomes_live, NULL);\n \t    }\n \n \t  /* Remember which registers are live at the end of the insn, before"}, {"sha": "6205e21d6c50bbed7a352b7a61649ed1b4b5f0ab", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -63,7 +63,7 @@ extern struct obstack *function_maybepermanent_obstack;\n #endif\n \f\n static rtvec initialize_for_inline\tPROTO((tree));\n-static void note_modified_parmregs\tPROTO((rtx, rtx));\n+static void note_modified_parmregs\tPROTO((rtx, rtx, void *));\n static void integrate_parm_decls\tPROTO((tree, struct inline_remap *,\n \t\t\t\t\t       rtvec));\n static tree integrate_decl_tree\t\tPROTO((tree,\n@@ -78,6 +78,7 @@ static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n void set_decl_abstract_flags\t\tPROTO((tree, int));\n static tree copy_and_set_decl_abstract_origin PROTO((tree));\n static rtx expand_inline_function_eh_labelmap PROTO((rtx));\n+static void mark_stores                 PROTO((rtx, rtx, void *));\n \n /* The maximum number of instructions accepted for inlining a\n    function.  Increasing values mean more agressive inlining.\n@@ -385,7 +386,7 @@ save_for_inline_nocopy (fndecl)\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t/* Record what interesting things happen to our parameters.  */\n-\tnote_stores (PATTERN (insn), note_modified_parmregs);\n+\tnote_stores (PATTERN (insn), note_modified_parmregs, NULL);\n     }\n \n   /* We have now allocated all that needs to be allocated permanently\n@@ -404,9 +405,10 @@ save_for_inline_nocopy (fndecl)\n /* Note whether a parameter is modified or not.  */\n \n static void\n-note_modified_parmregs (reg, x)\n+note_modified_parmregs (reg, x, data)\n      rtx reg;\n      rtx x ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (reg) == REG && in_nonparm_insns\n       && REGNO (reg) < max_parm_reg\n@@ -1951,7 +1953,7 @@ try_constants (insn, map)\n   apply_change_group ();\n \n   /* Show we don't know the value of anything stored or clobbered.  */\n-  note_stores (PATTERN (insn), mark_stores);\n+  note_stores (PATTERN (insn), mark_stores, NULL);\n   map->last_pc_value = 0;\n #ifdef HAVE_cc0\n   map->last_cc0_value = 0;\n@@ -2268,9 +2270,10 @@ subst_constants (loc, insn, map)\n    called from note_stores with parts of the new insn.  */\n \n void\n-mark_stores (dest, x)\n+mark_stores (dest, x, data)\n      rtx dest;\n      rtx x ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno = -1;\n   enum machine_mode mode = VOIDmode;"}, {"sha": "a80f8829fe911c2b5ad27c53a18393ec1ef9a4ed", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -118,8 +118,6 @@ extern rtx copy_rtx_and_substitute PROTO((rtx, struct inline_remap *));\n \n extern void try_constants PROTO((rtx, struct inline_remap *));\n \n-extern void mark_stores PROTO((rtx, rtx));\n-\n /* Return the label indicated.  */\n extern rtx get_label_from_map PROTO((struct inline_remap *, int));\n "}, {"sha": "72a13589af0893b0251997076c16256254be05e6", "filename": "gcc/jump.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -122,7 +122,7 @@ static void mark_jump_label\t\tPROTO((rtx, rtx, int));\n static void delete_computation\t\tPROTO((rtx));\n static void delete_from_jump_chain\tPROTO((rtx));\n static int delete_labelref_insn\t\tPROTO((rtx, rtx, int));\n-static void mark_modified_reg\t\tPROTO((rtx, rtx));\n+static void mark_modified_reg\t\tPROTO((rtx, rtx, void *));\n static void redirect_tablejump\t\tPROTO((rtx, rtx));\n static void jump_optimize_1\t\tPROTO ((rtx, int, int, int, int));\n #if ! defined(HAVE_cc0) && ! defined(HAVE_conditional_arithmetic)\n@@ -5091,9 +5091,10 @@ static int modified_mem;\n    branch and the second branch.  It marks any changed registers.  */\n \n static void\n-mark_modified_reg (dest, x)\n+mark_modified_reg (dest, x, data)\n      rtx dest;\n      rtx x ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno, i;\n \n@@ -5205,7 +5206,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t\t      modified_regs[i] = 1;\n \t\t}\n \n-\t      note_stores (PATTERN (b2), mark_modified_reg);\n+\t      note_stores (PATTERN (b2), mark_modified_reg, NULL);\n \t    }\n \n \t  /* Check the next candidate branch insn from the label"}, {"sha": "6b0732695d7903cfc97517f35f692e02644ea2a5", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -243,13 +243,13 @@ static rtx *reg_equiv_init_insns;\n static int recorded_label_ref;\n \n static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n-static void validate_equiv_mem_from_store PROTO((rtx, rtx));\n+static void validate_equiv_mem_from_store PROTO((rtx, rtx, void *));\n static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n static int contains_replace_regs PROTO((rtx, char *));\n static int memref_referenced_p\tPROTO((rtx, rtx));\n static int memref_used_between_p PROTO((rtx, rtx, rtx));\n static void update_equiv_regs\tPROTO((void));\n-static void no_equiv\t\tPROTO((rtx, rtx));\n+static void no_equiv\t\tPROTO((rtx, rtx, void *));\n static void block_alloc\t\tPROTO((int));\n static int qty_sugg_compare    \tPROTO((int, int));\n static int qty_sugg_compare_1\tPROTO((const PTR, const PTR));\n@@ -258,7 +258,7 @@ static int qty_compare_1\tPROTO((const PTR, const PTR));\n static int combine_regs\t\tPROTO((rtx, rtx, int, int, rtx, int));\n static int reg_meets_class_p\tPROTO((int, enum reg_class));\n static void update_qty_class\tPROTO((int, int));\n-static void reg_is_set\t\tPROTO((rtx, rtx));\n+static void reg_is_set\t\tPROTO((rtx, rtx, void *));\n static void reg_is_born\t\tPROTO((rtx, int));\n static void wipe_dead_reg\tPROTO((rtx, int));\n static int find_free_reg\tPROTO((enum reg_class, enum machine_mode,\n@@ -436,9 +436,10 @@ static int equiv_mem_modified;\n    Called via note_stores.  */\n \n static void\n-validate_equiv_mem_from_store (dest, set)\n+validate_equiv_mem_from_store (dest, set, data)\n      rtx dest;\n      rtx set ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if ((GET_CODE (dest) == REG\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n@@ -483,7 +484,7 @@ validate_equiv_mem (start, reg, memref)\n \t  && ! CONST_CALL_P (insn))\n \treturn 0;\n \n-      note_stores (PATTERN (insn), validate_equiv_mem_from_store);\n+      note_stores (PATTERN (insn), validate_equiv_mem_from_store, NULL);\n \n       /* If a register mentioned in MEMREF is modified via an\n \t auto-increment, we lose the equivalence.  Do the same if one\n@@ -708,15 +709,15 @@ update_equiv_regs ()\n \n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \tif (REG_NOTE_KIND (note) == REG_INC)\n-\t  no_equiv (XEXP (note, 0), note);\n+\t  no_equiv (XEXP (note, 0), note, NULL);\n \n       set = single_set (insn);\n \n       /* If this insn contains more (or less) than a single SET,\n \t only mark all destinations as having no known equivalence.  */\n       if (set == 0)\n \t{\n-\t  note_stores (PATTERN (insn), no_equiv);\n+\t  note_stores (PATTERN (insn), no_equiv, NULL);\n \t  continue;\n \t}\n       else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n@@ -727,7 +728,7 @@ update_equiv_regs ()\n \t    {\n \t      rtx part = XVECEXP (PATTERN (insn), 0, i);\n \t      if (part != set)\n-\t\tnote_stores (part, no_equiv);\n+\t\tnote_stores (part, no_equiv, NULL);\n \t    }\n \t}\n \n@@ -792,7 +793,7 @@ update_equiv_regs ()\n \t{\n \t  /* This might be seting a SUBREG of a pseudo, a pseudo that is\n \t     also set somewhere else to a constant.  */\n-\t  note_stores (set, no_equiv);\n+\t  note_stores (set, no_equiv, NULL);\n \t  continue;\n \t}\n       /* Don't handle the equivalence if the source is in a register\n@@ -801,7 +802,7 @@ update_equiv_regs ()\n \t  && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t  && CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (src))))\n \t{\n-\t  no_equiv (dest, set);\n+\t  no_equiv (dest, set, NULL);\n \t  continue;\n \t}\n \n@@ -814,7 +815,7 @@ update_equiv_regs ()\n \t\t  && ! rtx_equal_p (XEXP (note, 0),\n \t\t\t\t    reg_equiv_replacement[regno]))))\n \t{\n-\t  no_equiv (dest, set);\n+\t  no_equiv (dest, set, NULL);\n \t  continue;\n \t}\n       /* Record this insn as initializing this register.  */\n@@ -1009,8 +1010,9 @@ update_equiv_regs ()\n    assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n    but needs to be there because this function is called from note_stores.  */\n static void\n-no_equiv (reg, store)\n+no_equiv (reg, store, data)\n      rtx reg, store ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno;\n   rtx list;\n@@ -1259,7 +1261,7 @@ block_alloc (b)\n \t     that are born (set) in this instruction.\n \t     A pseudo that already has a qty is not changed.  */\n \n-\t  note_stores (PATTERN (insn), reg_is_set);\n+\t  note_stores (PATTERN (insn), reg_is_set, NULL);\n \n \t  /* If anything is set in this insn and then unused, mark it as dying\n \t     after this insn, so it will conflict with our outputs.  This\n@@ -1802,9 +1804,10 @@ update_qty_class (qty, reg)\n    carry info from `block_alloc'.  */\n \n static void\n-reg_is_set (reg, setter)\n+reg_is_set (reg, setter, data)\n      rtx reg;\n      rtx setter;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   /* Note that note_stores will only pass us a SUBREG if it is a SUBREG of\n      a hard register.  These may actually not exist any more.  */"}, {"sha": "62df8b04e661ed4fa459a7d7617fb129dde6a89c", "filename": "gcc/loop.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -269,9 +269,6 @@ static struct movable *the_movables;\n \n FILE *loop_dump_stream;\n \n-/* For communicating return values from note_set_pseudo_multiple_uses.  */\n-static int note_set_pseudo_multiple_uses_retval;\n-\n /* Forward declarations.  */\n \n static void verify_dominator PROTO((int));\n@@ -285,8 +282,8 @@ static void count_one_set PROTO((rtx, rtx, varray_type, rtx *));\n \n static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n-static void note_addr_stored PROTO((rtx, rtx));\n-static void note_set_pseudo_multiple_uses PROTO((rtx, rtx));\n+static void note_addr_stored PROTO((rtx, rtx, void *));\n+static void note_set_pseudo_multiple_uses PROTO((rtx, rtx, void *));\n static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n static void scan_loop PROTO((rtx, rtx, rtx, int, int));\n #if 0\n@@ -327,7 +324,7 @@ static int product_cheap_p PROTO((rtx, rtx));\n static int maybe_eliminate_biv PROTO((struct iv_class *, rtx, rtx, int, int, int));\n static int maybe_eliminate_biv_1 PROTO((rtx, rtx, struct iv_class *, int, rtx));\n static int last_use_this_basic_block PROTO((rtx, rtx));\n-static void record_initial PROTO((rtx, rtx));\n+static void record_initial PROTO((rtx, rtx, void *));\n static void update_reg_last_use PROTO((rtx, rtx));\n static rtx next_insn_in_loop PROTO((rtx, rtx, rtx, rtx));\n static void load_mems_and_recount_loop_regs_set PROTO((rtx, rtx, rtx,\n@@ -2476,7 +2473,7 @@ prescan_loop (start, end, loop_info)\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n \t    loop_info->has_tablejump = 1;\n \t  \n-\t  note_stores (PATTERN (insn), note_addr_stored);\n+\t  note_stores (PATTERN (insn), note_addr_stored, NULL);\n \t  if (! first_loop_store_insn && loop_store_mems)\n \t    first_loop_store_insn = insn;\n \n@@ -3156,9 +3153,10 @@ labels_in_range_p (insn, end)\n /* Record that a memory reference X is being set.  */\n \n static void\n-note_addr_stored (x, y)\n+note_addr_stored (x, y, data)\n      rtx x;\n      rtx y ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (x == 0 || GET_CODE (x) != MEM)\n     return;\n@@ -3180,12 +3178,14 @@ note_addr_stored (x, y)\n /* X is a value modified by an INSN that references a biv inside a loop\n    exit test (ie, X is somehow related to the value of the biv).  If X\n    is a pseudo that is used more than once, then the biv is (effectively)\n-   used more than once.  */\n+   used more than once.  DATA is really an `int *', and is set if the\n+   biv is used more than once.  */\n \n static void\n-note_set_pseudo_multiple_uses (x, y)\n+note_set_pseudo_multiple_uses (x, y, data)\n      rtx x;\n      rtx y ATTRIBUTE_UNUSED;\n+     void *data;\n {\n   if (x == 0)\n     return;\n@@ -3204,7 +3204,7 @@ note_set_pseudo_multiple_uses (x, y)\n   if (REGNO (x) >= max_reg_before_loop\n       || ! VARRAY_RTX (reg_single_usage, REGNO (x))\n       || VARRAY_RTX (reg_single_usage, REGNO (x)) == const0_rtx)\n-    note_set_pseudo_multiple_uses_retval = 1;\n+    *((int *) data) = 1;\n }\n \f\n /* Return nonzero if the rtx X is invariant over the current loop.\n@@ -3998,7 +3998,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n       if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n \t  || GET_CODE (p) == CALL_INSN)\n-\tnote_stores (PATTERN (p), record_initial);\n+\tnote_stores (PATTERN (p), record_initial, NULL);\n \n       /* Record any test of a biv that branches around the loop if no store\n \t between it and the start of loop.  We only care about tests with\n@@ -7976,8 +7976,9 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t       that has more than one usage, then the biv has uses\n \t\t       other than counting since it's used to derive a value\n \t\t       that is used more than one time.  */\n-\t\t    note_set_pseudo_multiple_uses_retval = 0;\n-\t\t    note_stores (PATTERN (p), note_set_pseudo_multiple_uses);\n+\t\t    int note_set_pseudo_multiple_uses_retval = 0;\n+\t\t    note_stores (PATTERN (p), note_set_pseudo_multiple_uses,\n+\t\t\t\t &note_set_pseudo_multiple_uses_retval);\n \t\t    if (note_set_pseudo_multiple_uses_retval)\n \t\t      {\n \t\t\tno_use_except_counting = 0;\n@@ -8902,9 +8903,10 @@ last_use_this_basic_block (reg, insn)\n    just record the location of the set and process it later.  */\n \n static void\n-record_initial (dest, set)\n+record_initial (dest, set, data)\n      rtx dest;\n      rtx set;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   struct iv_class *bl;\n "}, {"sha": "7b0b74a9af9dc5738d4604934b21e6486c23a951", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -57,7 +57,7 @@ struct match {\n \n static rtx discover_flags_reg PROTO((void));\n static void mark_flags_life_zones PROTO((rtx));\n-static void flags_set_1 PROTO((rtx, rtx));\n+static void flags_set_1 PROTO((rtx, rtx, void *));\n \n static int try_auto_increment PROTO((rtx, rtx, rtx, rtx, HOST_WIDE_INT, int));\n static int find_matches PROTO((rtx, struct match *));\n@@ -302,7 +302,7 @@ mark_flags_life_zones (flags)\n \t      /* In either case, birth is denoted simply by it's presence\n \t\t as the destination of a set.  */\n \t      flags_set_1_set = 0;\n-\t      note_stores (PATTERN (insn), flags_set_1);\n+\t      note_stores (PATTERN (insn), flags_set_1, NULL);\n \t      if (flags_set_1_set)\n \t\t{\n \t\t  live = 1;\n@@ -322,8 +322,9 @@ mark_flags_life_zones (flags)\n /* A subroutine of mark_flags_life_zones, called through note_stores.  */\n \n static void\n-flags_set_1 (x, pat)\n+flags_set_1 (x, pat, data)\n      rtx x, pat;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (pat) == SET\n       && reg_overlap_mentioned_p (x, flags_set_1_rtx))"}, {"sha": "2909519ef429037a1c8c769f693b6d784446659e", "filename": "gcc/reload1.c", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -398,7 +398,7 @@ static void check_eliminable_occurrences\tPROTO((rtx));\n static void elimination_effects\t\tPROTO((rtx, enum machine_mode));\n static int eliminate_regs_in_insn\tPROTO((rtx, int));\n static void update_eliminable_offsets\tPROTO((void));\n-static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n+static void mark_not_eliminable\t\tPROTO((rtx, rtx, void *));\n static void set_initial_elim_offsets\tPROTO((void));\n static void verify_initial_elim_offsets\tPROTO((void));\n static void set_initial_label_offsets\tPROTO((void));\n@@ -413,7 +413,7 @@ static int hard_reg_use_compare\t\tPROTO((const PTR, const PTR));\n static void count_pseudo\t\tPROTO((struct hard_reg_n_uses *, int));\n static void order_regs_for_reload\tPROTO((struct insn_chain *));\n static void reload_as_needed\t\tPROTO((int));\n-static void forget_old_reloads_1\tPROTO((rtx, rtx));\n+static void forget_old_reloads_1\tPROTO((rtx, rtx, void *));\n static int reload_reg_class_lower\tPROTO((const PTR, const PTR));\n static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n@@ -437,18 +437,18 @@ static void reload_cse_regs_1\t\tPROTO((rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_mem\tPROTO((rtx));\n-static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx));\n+static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx, void *));\n static int reload_cse_regno_equal_p\tPROTO((int, rtx, enum machine_mode));\n static int reload_cse_noop_set_p\tPROTO((rtx, rtx));\n static int reload_cse_simplify_set\tPROTO((rtx, rtx));\n static int reload_cse_simplify_operands\tPROTO((rtx));\n-static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n+static void reload_cse_check_clobber\tPROTO((rtx, rtx, void *));\n static void reload_cse_record_set\tPROTO((rtx, rtx));\n static void reload_combine PROTO((void));\n static void reload_combine_note_use PROTO((rtx *, rtx));\n-static void reload_combine_note_store PROTO((rtx, rtx));\n+static void reload_combine_note_store PROTO((rtx, rtx, void *));\n static void reload_cse_move2add PROTO((rtx));\n-static void move2add_note_store PROTO((rtx, rtx));\n+static void move2add_note_store PROTO((rtx, rtx, void *));\n #ifdef AUTO_INC_DEC\n static void add_auto_inc_notes PROTO((rtx, rtx));\n #endif\n@@ -805,7 +805,7 @@ reload (first, global, dumpfile)\n   for (insn = first; insn && num_eliminable; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t|| GET_CODE (insn) == CALL_INSN)\n-      note_stores (PATTERN (insn), mark_not_eliminable);\n+      note_stores (PATTERN (insn), mark_not_eliminable, NULL);\n \n   maybe_fix_stack_asms ();\n \n@@ -3631,9 +3631,10 @@ update_eliminable_offsets ()\n    the insns of the function.  */\n \n static void\n-mark_not_eliminable (dest, x)\n+mark_not_eliminable (dest, x, data)\n      rtx dest;\n      rtx x;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   register unsigned int i;\n \n@@ -4424,13 +4425,13 @@ reload_as_needed (live_known)\n \t     for this insn in order to be stored in\n \t     (obeying register constraints).  That is correct; such reload\n \t     registers ARE still valid.  */\n-\t  note_stores (oldpat, forget_old_reloads_1);\n+\t  note_stores (oldpat, forget_old_reloads_1, NULL);\n \n \t  /* There may have been CLOBBER insns placed after INSN.  So scan\n \t     between INSN and NEXT and use them to forget old reloads.  */\n \t  for (x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n \t    if (GET_CODE (x) == INSN && GET_CODE (PATTERN (x)) == CLOBBER)\n-\t      note_stores (PATTERN (x), forget_old_reloads_1);\n+\t      note_stores (PATTERN (x), forget_old_reloads_1, NULL);\n \n #ifdef AUTO_INC_DEC\n \t  /* Likewise for regs altered by auto-increment in this insn.\n@@ -4512,7 +4513,8 @@ reload_as_needed (live_known)\n \t\t\t  reg_has_output_reload[REGNO (XEXP (in_reg, 0))] = 1;\n \t\t\t}\n \t\t      else\n-\t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX);\n+\t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX, \n+\t\t\t\t\t      NULL);\n \t\t    }\n \t\t  else if ((code == PRE_INC || code == PRE_DEC)\n \t\t\t   && TEST_HARD_REG_BIT (reg_reloaded_valid,\n@@ -4542,7 +4544,7 @@ reload_as_needed (live_known)\n \t\t    break;\n \n \t\tif (i == n_reloads)\n-\t\t  forget_old_reloads_1 (XEXP (x, 0), NULL_RTX);\n+\t\t  forget_old_reloads_1 (XEXP (x, 0), NULL_RTX, NULL);\n \t      }\n #endif\n \t}\n@@ -4579,9 +4581,10 @@ reload_as_needed (live_known)\n    or it may be a pseudo reg that was reloaded from.  */\n \n static void\n-forget_old_reloads_1 (x, ignored)\n+forget_old_reloads_1 (x, ignored, data)\n      rtx x;\n      rtx ignored ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   register int regno;\n   int nr;\n@@ -7312,7 +7315,7 @@ emit_reload_insns (chain)\n \t\t   clear any memory of reloaded copies of the pseudo reg.\n \t\t   If this output reload comes from a spill reg,\n \t\t   reg_has_output_reload will make this do nothing.  */\n-\t\tnote_stores (pat, forget_old_reloads_1);\n+\t\tnote_stores (pat, forget_old_reloads_1, NULL);\n \n \t\tif (reg_mentioned_p (rld[j].reg_rtx, pat))\n \t\t  {\n@@ -8680,9 +8683,10 @@ reload_cse_invalidate_mem (mem_rtx)\n    note_stores; it is ignored.  */\n \n static void\n-reload_cse_invalidate_rtx (dest, ignore)\n+reload_cse_invalidate_rtx (dest, ignore, data)\n      rtx dest;\n      rtx ignore ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   while (GET_CODE (dest) == STRICT_LOW_PART\n \t || GET_CODE (dest) == SIGN_EXTRACT\n@@ -8895,11 +8899,11 @@ reload_cse_regs_1 (first)\n \t      if (GET_CODE (x) == SET)\n \t\treload_cse_record_set (x, body);\n \t      else\n-\t\tnote_stores (x, reload_cse_invalidate_rtx);\n+\t\tnote_stores (x, reload_cse_invalidate_rtx, NULL);\n \t    }\n \t}\n       else\n-\tnote_stores (body, reload_cse_invalidate_rtx);\n+\tnote_stores (body, reload_cse_invalidate_rtx, NULL);\n \n #ifdef AUTO_INC_DEC\n       /* Clobber any registers which appear in REG_INC notes.  We\n@@ -8910,7 +8914,7 @@ reload_cse_regs_1 (first)\n \n \tfor (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n \t  if (REG_NOTE_KIND (x) == REG_INC)\n-\t    reload_cse_invalidate_rtx (XEXP (x, 0), NULL_RTX);\n+\t    reload_cse_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n       }\n #endif\n \n@@ -8922,7 +8926,8 @@ reload_cse_regs_1 (first)\n \n \t  for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n \t    if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\t      reload_cse_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX);\n+\t      reload_cse_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX,\n+\t\t\t\t\t NULL);\n \t}\n     }\n \n@@ -9367,9 +9372,10 @@ static rtx reload_cse_check_src;\n    second argument, which is passed by note_stores, is ignored.  */\n \n static void\n-reload_cse_check_clobber (dest, ignore)\n+reload_cse_check_clobber (dest, ignore, data)\n      rtx dest;\n      rtx ignore ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   if (reg_overlap_mentioned_p (dest, reload_cse_check_src))\n     reload_cse_check_clobbered = 1;\n@@ -9405,8 +9411,8 @@ reload_cse_record_set (set, body)\n     x = XEXP (x, 0);\n   if (push_operand (x, GET_MODE (x)))\n     {\n-      reload_cse_invalidate_rtx (stack_pointer_rtx, NULL_RTX);\n-      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+      reload_cse_invalidate_rtx (stack_pointer_rtx, NULL_RTX, NULL);\n+      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n       return;\n     }\n \n@@ -9418,7 +9424,7 @@ reload_cse_record_set (set, body)\n       || side_effects_p (src)\n       || side_effects_p (dest))\n     {\n-      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n       return;\n     }\n \n@@ -9428,7 +9434,7 @@ reload_cse_record_set (set, body)\n   if (reg_mentioned_p (cc0_rtx, src)\n       || reg_mentioned_p (cc0_rtx, dest))\n     {\n-      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n       return;\n     }\n #endif\n@@ -9449,10 +9455,10 @@ reload_cse_record_set (set, body)\n \n \t  reload_cse_check_clobbered = 0;\n \t  reload_cse_check_src = src;\n-\t  note_stores (x, reload_cse_check_clobber);\n+\t  note_stores (x, reload_cse_check_clobber, NULL);\n \t  if (reload_cse_check_clobbered)\n \t    {\n-\t      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+\t      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n \t      return;\n \t    }\n \t}\n@@ -9767,7 +9773,7 @@ reload_combine ()\n \t\t}\n \t    }\n \t}\n-      note_stores (PATTERN (insn), reload_combine_note_store);\n+      note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx link;\n@@ -9830,8 +9836,9 @@ reload_combine ()\n    update reg_state[regno].store_ruid and reg_state[regno].use_index\n    accordingly.  Called via note_stores from reload_combine.  */\n static void\n-reload_combine_note_store (dst, set)\n+reload_combine_note_store (dst, set, data)\n      rtx dst, set;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno = 0;\n   int i;\n@@ -10157,7 +10164,7 @@ reload_cse_move2add (first)\n \t\t}\n \t    }\n \t}\n-      note_stores (PATTERN (insn), move2add_note_store);\n+      note_stores (PATTERN (insn), move2add_note_store, NULL);\n       /* If this is a CALL_INSN, all call used registers are stored with\n \t unknown values.  */\n       if (GET_CODE (insn) == CALL_INSN)\n@@ -10178,8 +10185,9 @@ reload_cse_move2add (first)\n    Update reg_set_luid, reg_offset and reg_base_reg accordingly.\n    Called from reload_cse_move2add via note_stores.  */\n static void\n-move2add_note_store (dst, set)\n+move2add_note_store (dst, set, data)\n      rtx dst, set;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno = 0;\n   int i;"}, {"sha": "335b14e42c91a9e7fcecf628c57c37b5f4e0842b", "filename": "gcc/resource.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -73,7 +73,7 @@ static HARD_REG_SET current_live_regs;\n \n static HARD_REG_SET pending_dead_regs;\n \f\n-static void update_live_status\t\tPROTO ((rtx, rtx));\n+static void update_live_status\t\tPROTO ((rtx, rtx, void *));\n static rtx next_insn_no_annul\t\tPROTO ((rtx));\n static rtx find_dead_or_set_registers\tPROTO ((rtx, struct resources*,\n \t\t\t\t\t\trtx*, int, struct resources,\n@@ -83,9 +83,10 @@ static rtx find_dead_or_set_registers\tPROTO ((rtx, struct resources*,\n    It deadens any CLOBBERed registers and livens any SET registers.  */\n \n static void\n-update_live_status (dest, x)\n+update_live_status (dest, x, data)\n      rtx dest;\n      rtx x;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int first_regno, last_regno;\n   int i;\n@@ -973,7 +974,7 @@ mark_target_live_regs (insns, target, res)\n \t\t      SET_HARD_REG_BIT (pending_dead_regs, i);\n \t\t  }\n \n-\t      note_stores (PATTERN (real_insn), update_live_status);\n+\t      note_stores (PATTERN (real_insn), update_live_status, NULL);\n \n \t      /* If any registers were unused after this insn, kill them.\n \t\t These notes will always be accurate.  */"}, {"sha": "e1e1b66f0b27830ab723b9b2d27fbf7c833d2a0b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -1103,7 +1103,7 @@ extern int multiple_sets\t\tPROTO((rtx));\n extern rtx find_last_value\t\tPROTO((rtx, rtx *, rtx, int));\n extern int refers_to_regno_p\t\tPROTO((int, int, rtx, rtx *));\n extern int reg_overlap_mentioned_p\tPROTO((rtx, rtx));\n-extern void note_stores\t\t\tPROTO((rtx, void (*)(rtx, rtx)));\n+extern void note_stores\t\t\tPROTO((rtx, void (*)(rtx, rtx, void *), void *));\n extern rtx reg_set_last\t\t\tPROTO((rtx, rtx));\n extern int rtx_equal_p\t\t\tPROTO((rtx, rtx));\n extern int dead_or_set_p\t\tPROTO((rtx, rtx));"}, {"sha": "573bed01dca2ae3a4ef0935701ad7a49d3625351", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -24,8 +24,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n \n static int rtx_addr_can_trap_p\tPROTO((rtx));\n-static void reg_set_p_1\t\tPROTO((rtx, rtx));\n-static void reg_set_last_1\tPROTO((rtx, rtx));\n+static void reg_set_p_1\t\tPROTO((rtx, rtx, void *));\n+static void reg_set_last_1\tPROTO((rtx, rtx, void *));\n \n \n /* Forward declarations */\n@@ -473,9 +473,10 @@ static rtx reg_set_reg;\n static int reg_set_flag;\n \n static void\n-reg_set_p_1 (x, pat)\n+reg_set_p_1 (x, pat, data)\n      rtx x;\n      rtx pat ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   /* We don't want to return 1 if X is a MEM that contains a register\n      within REG_SET_REG.  */\n@@ -514,7 +515,7 @@ reg_set_p (reg, insn)\n \n   reg_set_reg = reg;\n   reg_set_flag = 0;\n-  note_stores (body, reg_set_p_1);\n+  note_stores (body, reg_set_p_1, NULL);\n   return reg_set_flag;\n }\n \n@@ -980,9 +981,10 @@ static int reg_set_last_first_regno, reg_set_last_last_regno;\n /* Called via note_stores from reg_set_last.  */\n \n static void\n-reg_set_last_1 (x, pat)\n+reg_set_last_1 (x, pat, data)\n      rtx x;\n      rtx pat;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int first, last;\n \n@@ -1047,7 +1049,7 @@ reg_set_last (x, insn)\n        insn = PREV_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n-\tnote_stores (PATTERN (insn), reg_set_last_1);\n+\tnote_stores (PATTERN (insn), reg_set_last_1, NULL);\n \tif (reg_set_last_unknown)\n \t  return 0;\n \telse if (reg_set_last_value)\n@@ -1184,9 +1186,10 @@ rtx_equal_p (x, y)\n   the SUBREG will be passed.  */\n      \n void\n-note_stores (x, fun)\n+note_stores (x, fun, data)\n      register rtx x;\n-     void (*fun) PROTO ((rtx, rtx));\n+     void (*fun) PROTO ((rtx, rtx, void *));\n+     void *data;\n {\n   if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER))\n     {\n@@ -1204,10 +1207,10 @@ note_stores (x, fun)\n \t{\n \t  register int i;\n \t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), x);\n+\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), x, data);\n \t}\n       else\n-\t(*fun) (dest, x);\n+\t(*fun) (dest, x, data);\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n@@ -1231,10 +1234,10 @@ note_stores (x, fun)\n \t\t{\n \t\t  register int i;\n \t\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), y);\n+\t\t    (*fun) (SET_DEST (XVECEXP (dest, 0, i)), y, data);\n \t\t}\n \t      else\n-\t\t(*fun) (dest, y);\n+\t\t(*fun) (dest, y, data);\n \t    }\n \t}\n     }"}, {"sha": "0d5a581e67d4d58bfd1b29b53c8c0666f50a0abd", "filename": "gcc/stupid.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848323170b9b9d7ce1a3ab19dcd945700f37b36a/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=848323170b9b9d7ce1a3ab19dcd945700f37b36a", "patch": "@@ -128,7 +128,7 @@ static int stupid_reg_compare\tPROTO((const PTR,const PTR));\n static int stupid_find_reg\tPROTO((int, enum reg_class, enum machine_mode,\n \t\t\t\t       int, int, int));\n static void stupid_mark_refs\tPROTO((rtx, struct insn_chain *));\n-static void find_clobbered_regs\tPROTO((rtx, rtx));\n+static void find_clobbered_regs\tPROTO((rtx, rtx, void *));\n \f\n /* For communication between stupid_life_analysis and find_clobbered_regs.  */\n static struct insn_chain *current_chain;\n@@ -138,8 +138,9 @@ static struct insn_chain *current_chain;\n    of the appropriate insn_chain structure.  */\n \n static void\n-find_clobbered_regs (reg, setter)\n+find_clobbered_regs (reg, setter, data)\n      rtx reg, setter;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int regno, nregs;\n   if (setter == 0 || GET_CODE (setter) != CLOBBER)\n@@ -344,7 +345,7 @@ stupid_life_analysis (f, nregs, file)\n \t     pattern.  */\n \t  current_chain = chain;\n \t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t    note_stores (PATTERN (insn), find_clobbered_regs);\n+\t    note_stores (PATTERN (insn), find_clobbered_regs, NULL);\n \t}\n \n       if (GET_CODE (insn) == JUMP_INSN && computed_jump_p (insn))"}]}