{"sha": "fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ1ZDViMDdiNzQzMDE0YWYzYjcwZDRiMGY5Y2E5YmRmYWNmMzY1Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-14T01:20:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-14T01:20:34Z"}, "message": "loop.c: Fix formatting.\n\n        * loop.c: Fix formatting.\n        * loop.h: Likewise.\n\nFrom-SVN: r36400", "tree": {"sha": "7122c14d4bd0573fbdd3b81d5d3149e41825583f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7122c14d4bd0573fbdd3b81d5d3149e41825583f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/comments", "author": null, "committer": null, "parents": [{"sha": "f903ebb1d5a56c850f8269b5a143598cc740fc0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f903ebb1d5a56c850f8269b5a143598cc740fc0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f903ebb1d5a56c850f8269b5a143598cc740fc0a"}], "stats": {"total": 244, "additions": 125, "deletions": 119}, "files": [{"sha": "c02cf9736b07242c2aba3b149d4adead4a680f90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "patch": "@@ -1,3 +1,8 @@\n+2000-09-13  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* loop.c: Fix formatting.\n+\t* loop.h: Likewise.\n+\n 2000-09-13  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.md (divsf3): New."}, {"sha": "a48cbec26450b77f8bbfff40290a2b3b1753689c", "filename": "gcc/loop.c", "status": "modified", "additions": 83, "deletions": 87, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "patch": "@@ -78,9 +78,6 @@ static int max_luid;\n \n static int max_loop_num;\n \n-\n-\n-\n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n unsigned int max_reg_before_loop;\n@@ -189,7 +186,7 @@ static void ignore_some_movables PARAMS ((struct movables *));\n static void force_movables PARAMS ((struct movables *));\n static void combine_movables PARAMS ((struct movables *, struct loop_regs *));\n static int regs_match_p PARAMS ((rtx, rtx, struct movables *));\n-static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *, \n+static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *,\n \t\t\t\t\t struct loop_regs *));\n static void add_label_notes PARAMS ((rtx, rtx));\n static void move_movables PARAMS ((struct loop *loop, struct movables *,\n@@ -224,7 +221,7 @@ static rtx express_from_1 PARAMS ((rtx, rtx, rtx));\n static rtx combine_givs_p PARAMS ((struct induction *, struct induction *));\n static void combine_givs PARAMS ((struct loop_regs *, struct iv_class *));\n struct recombine_givs_stats;\n-static int find_life_end PARAMS ((const struct loop *, rtx, \n+static int find_life_end PARAMS ((const struct loop *, rtx,\n \t\t\t\t  struct recombine_givs_stats *,\n \t\t\t\t  rtx, rtx));\n static void recombine_givs PARAMS ((const struct loop *, struct iv_class *,\n@@ -258,7 +255,8 @@ static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n void debug_loop PARAMS ((const struct loop *));\n \n-typedef struct rtx_pair {\n+typedef struct rtx_pair\n+{\n   rtx r1;\n   rtx r2;\n } rtx_pair;\n@@ -283,7 +281,8 @@ static int indirect_jump_in_function_p PARAMS ((rtx));\n static int compute_luids PARAMS ((rtx, rtx, int));\n \n static int biv_elimination_giv_has_0_offset PARAMS ((struct induction *,\n-\t\t\t\t\t\t   struct induction *, rtx));\n+\t\t\t\t\t\t     struct induction *,\n+\t\t\t\t\t\t     rtx));\n \f\n /* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to\n    copy the value of the strength reduced giv to its original register.  */\n@@ -648,7 +647,7 @@ scan_loop (loop, flags)\n \n   regs->num = nregs;\n \n-  count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage, \n+  count_loop_regs_set (loop, regs->may_not_optimize, regs->single_usage,\n \t\t       &insn_count, nregs);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -1526,7 +1525,7 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && VARRAY_INT (regs->set_in_loop, \n+  else if (GET_CODE (y) == REG && VARRAY_INT (regs->set_in_loop,\n \t\t\t\t\t      REGNO (y)) == -2\n \t   && CONSTANT_P (x))\n     {\n@@ -2419,15 +2418,15 @@ prescan_loop (loop)\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n-      loop_info->store_mems \n+      loop_info->store_mems\n \t= gen_rtx_EXPR_LIST (VOIDmode, mem, loop_info->store_mems);\n     }\n   if (loop_info->unknown_constant_address_altered)\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n       RTX_UNCHANGING_P (mem) = 1;\n-      loop_info->store_mems \n+      loop_info->store_mems\n \t= gen_rtx_EXPR_LIST (VOIDmode, mem, loop_info->store_mems);\n     }\n }\n@@ -2587,8 +2586,7 @@ find_and_verify_loops (f, loops)\n \t\t       cont.  */\n \t\t    if ((INSN_LUID (label)\n \t\t\t < INSN_LUID (loop->cont))\n-\t\t\t&& (INSN_LUID (label)\n-\t\t\t    > INSN_LUID (loop->start))\n+\t\t\t&& (INSN_LUID (label) > INSN_LUID (loop->start))\n \t\t\t/* And if there is no later destination already\n \t\t\t   recorded.  */\n \t\t\t&& (! loop->cont_dominator\n@@ -2812,9 +2810,9 @@ find_and_verify_loops (f, loops)\n \t\t\t   off LABEL_OUTSIDE_LOOP_P bit.  */\n \t\t\tif (JUMP_LABEL (insn))\n \t\t\t  {\n-\t\t\t    for (q = 0,\n-\t\t\t\t   r = this_loop->exit_labels;\n-\t\t\t\t r; q = r, r = LABEL_NEXTREF (r))\n+\t\t\t    for (q = 0, r = this_loop->exit_labels;\n+\t\t\t\t r;\n+\t\t\t\t q = r, r = LABEL_NEXTREF (r))\n \t\t\t      if (XEXP (r, 0) == JUMP_LABEL (insn))\n \t\t\t\t{\n \t\t\t\t  LABEL_OUTSIDE_LOOP_P (r) = 0;\n@@ -3050,19 +3048,19 @@ note_addr_stored (x, y, data)\n   /* Count number of memory writes.\n      This affects heuristics in strength_reduce.  */\n   loop_info->num_mem_sets++;\n-  \n+\n   /* BLKmode MEM means all memory is clobbered.  */\n   if (GET_MODE (x) == BLKmode)\n     {\n       if (RTX_UNCHANGING_P (x))\n \tloop_info->unknown_constant_address_altered = 1;\n       else\n \tloop_info->unknown_address_altered = 1;\n-      \n+\n       return;\n     }\n-  \n-  loop_info->store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, \n+\n+  loop_info->store_mems = gen_rtx_EXPR_LIST (VOIDmode, x,\n \t\t\t\t\t     loop_info->store_mems);\n }\n \n@@ -4498,7 +4496,7 @@ strength_reduce (loop, insn_count, flags)\n \t\t  v->maybe_dead = 1;\n \t    }\n \t  else if (v->giv_type == DEST_REG\n-\t      && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n+\t\t   && REGNO_FIRST_UID (REGNO (v->dest_reg)) == INSN_UID (v->insn))\n \t    {\n \t      struct induction *v1;\n \n@@ -5670,7 +5668,7 @@ check_final_value (loop, v)\n \t      if (! biv_increment_seen\n \t\t  && reg_set_p (v->src_reg, PATTERN (p)))\n \t\tbiv_increment_seen = 1;\n-\t\t\n+\n \t      if (reg_mentioned_p (v->dest_reg, PATTERN (p)))\n \t\t{\n \t\t  if (biv_increment_seen)\n@@ -5967,7 +5965,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n \t\t\t\t      inc_val, mult_val, location))\n \t    return 1;\n \t}\n-      /* ... fall through ...  */\n+      /* Fall through.  */\n \n       /* Can accept constant setting of biv only when inside inner most loop.\n   \t Otherwise, a biv of an inner loop may be incorrectly recognized\n@@ -5985,7 +5983,7 @@ basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n       if (loop->level == 1\n \t  && GET_MODE_CLASS (mode) != MODE_CC\n \t  && GET_MODE_CLASS (GET_MODE (dest_reg)) != MODE_CC)\n- \t{\n+\t{\n \t  /* Possible bug here?  Perhaps we don't know the mode of X.  */\n \t  *inc_val = convert_modes (GET_MODE (dest_reg), mode, x, 0);\n \t  *mult_val = const0_rtx;\n@@ -6420,7 +6418,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n     case ZERO_EXTEND:\n     case TRUNCATE:\n       /* Conditionally recognize extensions of simple IVs.  After we've\n-\t computed loop traversal counts and verified the range of the \n+\t computed loop traversal counts and verified the range of the\n \t source IV, we'll reevaluate this as a GIV.  */\n       if (*ext_val == NULL_RTX)\n \t{\n@@ -6433,7 +6431,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t}\n       goto do_default;\n \n-  case REG:\n+    case REG:\n       /* If this is a new register, we can't deal with it.  */\n       if (REGNO (x) >= max_reg_before_loop)\n \treturn 0;\n@@ -6514,7 +6512,11 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t\t      {\n \t\t\tint i = m->consec;\n \t\t\ttem = m->insn;\n-\t\t\tdo { tem = NEXT_INSN (tem); } while (--i > 0);\n+\t\t\tdo\n+\t\t\t  {\n+\t\t\t    tem = NEXT_INSN (tem);\n+\t\t\t  }\n+\t\t\twhile (--i > 0);\n \n \t\t\ttem = find_reg_note (tem, REG_EQUAL, NULL_RTX);\n \t\t\tif (tem)\n@@ -6544,9 +6546,9 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t\t\t      return tem;\n \t\t\t  }\n \t\t\telse if (GET_CODE (tem) == CONST\n-\t\t\t    && GET_CODE (XEXP (tem, 0)) == PLUS\n-\t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 0)) == SYMBOL_REF\n-\t\t\t    && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)\n+\t\t\t\t && GET_CODE (XEXP (tem, 0)) == PLUS\n+\t\t\t\t && GET_CODE (XEXP (XEXP (tem, 0), 0)) == SYMBOL_REF\n+\t\t\t\t && GET_CODE (XEXP (XEXP (tem, 0), 1)) == CONST_INT)\n \t\t\t  {\n \t\t\t    tem = simplify_giv_expr (loop, XEXP (tem, 0),\n \t\t\t\t\t\t     ext_val, benefit);\n@@ -6809,7 +6811,7 @@ express_from_1 (a, b, mult)\n \ta = ra, b = ob;\n       else\n \t{\n-          /* Indicates an extra register in B.  Strip one level from B and\n+\t  /* Indicates an extra register in B.  Strip one level from B and\n \t     recurse, hoping B was the higher order expression.  */\n \t  ob = express_from_1 (a, ob, mult);\n \t  if (ob == NULL_RTX)\n@@ -7029,7 +7031,7 @@ check_ext_dependant_givs (bl, loop_info)\n       info_ok = 1;\n       start_val = INTVAL (bl->initial_value);\n       u_start_val = start_val;\n-\t   \n+\n       neg_incr = 0, abs_incr = INTVAL (incr);\n       if (INTVAL (incr) < 0)\n \tneg_incr = 1, abs_incr = -abs_incr;\n@@ -7045,7 +7047,7 @@ check_ext_dependant_givs (bl, loop_info)\n \t  s_end_val = u_end_val;\n \t  u_max = GET_MODE_MASK (biv_mode);\n \t  s_max = u_max >> 1;\n-\t\t  \n+\n \t  /* Check zero extension of biv ok.  */\n \t  if (start_val >= 0\n \t      /* Check for host arithmatic overflow.  */\n@@ -7059,7 +7061,7 @@ check_ext_dependant_givs (bl, loop_info)\n \t    {\n \t      ze_ok = 1;\n \t    }\n-\t\t  \n+\n \t  /* Check sign extension of biv ok.  */\n \t  /* ??? While it is true that overflow with signed and pointer\n \t     arithmetic is undefined, I fear too many programmers don't\n@@ -7099,7 +7101,7 @@ check_ext_dependant_givs (bl, loop_info)\n \t  case TRUNCATE:\n \t    /* We don't know whether this value is being used as either\n \t       signed or unsigned, so to safely truncate we must satisfy\n-\t       both.  The initial check here verifies the BIV itself; \n+\t       both.  The initial check here verifies the BIV itself;\n \t       once that is successful we may check its range wrt the\n \t       derived GIV.  */\n \t    if (se_ok && ze_ok)\n@@ -7123,9 +7125,9 @@ check_ext_dependant_givs (bl, loop_info)\n \t  {\n \t    if (loop_dump_stream)\n \t      {\n-\t\tfprintf(loop_dump_stream,\n-\t\t\t\"Verified ext dependant giv at %d of reg %d\\n\",\n-\t\t\tINSN_UID (v->insn), bl->regno);\n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"Verified ext dependant giv at %d of reg %d\\n\",\n+\t\t\t INSN_UID (v->insn), bl->regno);\n \t      }\n \t  }\n \telse\n@@ -7146,9 +7148,9 @@ check_ext_dependant_givs (bl, loop_info)\n \t\t      why = \"biv iteration info incomplete\";\n \t\t  }\n \n-\t\tfprintf(loop_dump_stream,\n-\t\t\t\"Failed ext dependant giv at %d, %s\\n\",\n-\t\t\tINSN_UID (v->insn), why);\n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"Failed ext dependant giv at %d, %s\\n\",\n+\t\t\t INSN_UID (v->insn), why);\n \t      }\n \t    v->ignore = 1;\n \t  }\n@@ -7250,7 +7252,7 @@ combine_givs (regs, bl)\n \t DEST_ADDR targets on hosts with reg+reg addressing, though it can\n \t be seen elsewhere as well.  */\n       if (g1->giv_type == DEST_REG\n-\t  && (single_use = VARRAY_RTX (regs->single_usage, \n+\t  && (single_use = VARRAY_RTX (regs->single_usage,\n \t\t\t\t       REGNO (g1->dest_reg)))\n \t  && single_use != const0_rtx)\n \tcontinue;\n@@ -7672,7 +7674,7 @@ recombine_givs (loop, bl, unroll_p)\n \t  p = PREV_INSN (p);\n \t  if (! INSN_P (p))\n \t    continue;\n-\t  ends_need_computing -= find_life_end (loop, PATTERN (p), \n+\t  ends_need_computing -= find_life_end (loop, PATTERN (p),\n \t\t\t\t\t\tstats, p, biv);\n \t}\n       while (ends_need_computing);\n@@ -8031,7 +8033,7 @@ check_dbra_loop (loop, insn_count)\n     rtx jump1;\n     if ((jump1 = prev_nonnote_insn (first_compare)) != loop->cont)\n       if (GET_CODE (jump1) == JUMP_INSN)\n-        return 0;\n+\treturn 0;\n   }\n \n   /* Check all of the bivs to see if the compare uses one of them.\n@@ -8206,7 +8208,7 @@ check_dbra_loop (loop, insn_count)\n \t\t  if (v->giv_type == DEST_REG\n \t\t      && reg_mentioned_p (v->dest_reg,\n \t\t\t\t\t  PATTERN (loop_info->first_loop_store_insn))\n-\t\t      && loop_insn_first_p (loop_info->first_loop_store_insn, \n+\t\t      && loop_insn_first_p (loop_info->first_loop_store_insn,\n \t\t\t\t\t    v->insn))\n \t\t    reversible_mem_store = 0;\n \t\t}\n@@ -8228,7 +8230,7 @@ check_dbra_loop (loop, insn_count)\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n-\t      + the_movables.num + compare_and_branch == insn_count)\n+\t       + the_movables.num + compare_and_branch == insn_count)\n \t   && (bl == ivs->loop_iv_list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{\n@@ -8379,7 +8381,7 @@ check_dbra_loop (loop, insn_count)\n \t      jump_label = XEXP (SET_SRC (PATTERN (PREV_INSN (loop_end))), 1);\n \t      if (jump_label == pc_rtx)\n \t\tjump_label = XEXP (SET_SRC (PATTERN (PREV_INSN (loop_end))), 2);\n-\t      new_add_val = GEN_INT (- INTVAL (bl->biv->add_val));\n+\t      new_add_val = GEN_INT (-INTVAL (bl->biv->add_val));\n \n \t      /* Set start_value; if this is not a CONST_INT, we need\n \t\t to generate a SUB.\n@@ -8463,7 +8465,7 @@ check_dbra_loop (loop, insn_count)\n \n \t      /* Inc LABEL_NUSES so that delete_insn will\n \t\t not delete the label.  */\n-\t      LABEL_NUSES (XEXP (jump_label, 0)) ++;\n+\t      LABEL_NUSES (XEXP (jump_label, 0))++;\n \n \t      /* Emit an insn after the end of the loop to set the biv's\n \t\t proper exit value if it is used anywhere outside the loop.  */\n@@ -9210,7 +9212,7 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n      in cse.c  */\n \n   while (GET_RTX_CLASS (code) == '<'\n-         && op1 == CONST0_RTX (GET_MODE (op0))\n+\t && op1 == CONST0_RTX (GET_MODE (op0))\n \t && op0 != want_reg)\n     {\n       /* Set non-zero when we find something of interest.  */\n@@ -9553,7 +9555,7 @@ insert_loop_mem (mem, data)\n       else\n \tloop_info->mems_allocated = 32;\n \n-      loop_info->mems = (loop_mem_info*)\n+      loop_info->mems = (loop_mem_info *)\n \txrealloc (loop_info->mems,\n \t\t  loop_info->mems_allocated * sizeof (loop_mem_info));\n     }\n@@ -9800,26 +9802,26 @@ load_mems (loop)\n \t\t  && GET_CODE (SET_DEST (set)) == REG\n \t\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n \t\t  && REGNO (SET_DEST (set)) < last_max_reg\n-\t\t  && VARRAY_INT (regs->n_times_set, \n+\t\t  && VARRAY_INT (regs->n_times_set,\n \t\t\t\t REGNO (SET_DEST (set))) == 1\n \t\t  && rtx_equal_p (SET_SRC (set), mem))\n \t\tSET_REGNO_REG_SET (&load_copies, REGNO (SET_DEST (set)));\n \n- \t      /* See if this copies the mem from a register that isn't\n+\t      /* See if this copies the mem from a register that isn't\n \t\t modified afterwards.  We'll try to remove the\n \t\t redundant copy later on by doing a little register\n \t\t renaming and copy propagation.   This will help\n \t\t to untangle things for the BIV detection code.  */\n- \t      if (set\n- \t\t  && ! maybe_never\n- \t\t  && GET_CODE (SET_SRC (set)) == REG\n- \t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n- \t\t  && REGNO (SET_SRC (set)) < last_max_reg\n- \t\t  && VARRAY_INT (regs->n_times_set, REGNO (SET_SRC (set))) == 1\n- \t\t  && rtx_equal_p (SET_DEST (set), mem))\n- \t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n- \t      \n- \t      /* Replace the memory reference with the shadow register.  */\n+\t      if (set\n+\t\t  && ! maybe_never\n+\t\t  && GET_CODE (SET_SRC (set)) == REG\n+\t\t  && REGNO (SET_SRC (set)) >= FIRST_PSEUDO_REGISTER\n+\t\t  && REGNO (SET_SRC (set)) < last_max_reg\n+\t\t  && VARRAY_INT (regs->n_times_set, REGNO (SET_SRC (set))) == 1\n+\t\t  && rtx_equal_p (SET_DEST (set), mem))\n+\t\tSET_REGNO_REG_SET (&store_copies, REGNO (SET_SRC (set)));\n+\n+\t      /* Replace the memory reference with the shadow register.  */\n \t      replace_loop_mems (p, loop_info->mems[i].mem,\n \t\t\t\t loop_info->mems[i].reg);\n \t    }\n@@ -10057,7 +10059,6 @@ try_copy_prop (loop, replacement, regno)\n     }\n }\n \n-\n /* Try to replace occurrences of pseudo REGNO with REPLACEMENT within\n    loop LOOP if the order of the sets of these registers can be\n    swapped.  There must be exactly one insn within the loop that sets\n@@ -10093,13 +10094,13 @@ try_swap_copy_prop (loop, replacement, regno)\n     {\n       rtx prev_insn;\n       rtx prev_set;\n-      \n+\n       /* Some DEF-USE info would come in handy here to make this\n \t function more general.  For now, just check the previous insn\n \t which is the most likely candidate for setting REGNO.  */\n-      \n+\n       prev_insn = PREV_INSN (insn);\n-      \n+\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t  && (prev_set = single_set (prev_insn))\n \t  && GET_CODE (SET_DEST (prev_set)) == REG\n@@ -10108,7 +10109,7 @@ try_swap_copy_prop (loop, replacement, regno)\n \t  /* We have:\n \t     (set (reg regno) (expr))\n \t     (set (reg new_regno) (reg regno))\n-\t     \n+\n \t     so try converting this to:\n \t     (set (reg new_regno) (expr))\n \t     (set (reg regno) (reg new_regno))\n@@ -10128,9 +10129,9 @@ try_swap_copy_prop (loop, replacement, regno)\n \t  if (apply_change_group ())\n \t    {\n \t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream, \n-\t\t\t \"  Swapped set of reg %d at %d with reg %d at %d.\\n\", \n-\t\t\t regno, INSN_UID (insn), \n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"  Swapped set of reg %d at %d with reg %d at %d.\\n\",\n+\t\t\t regno, INSN_UID (insn),\n \t\t\t new_regno, INSN_UID (prev_insn));\n \n \t      /* Update first use of REGNO.  */\n@@ -10145,7 +10146,6 @@ try_swap_copy_prop (loop, replacement, regno)\n     }\n }\n \n-\n /* Replace MEM with its associated pseudo register.  This function is\n    called from load_mems via for_each_rtx.  DATA is actually a pointer\n    to a structure describing the instruction currently being scanned\n@@ -10156,7 +10156,7 @@ replace_loop_mem (mem, data)\n      rtx *mem;\n      void *data;\n {\n-  loop_replace_args *args = (loop_replace_args *)data;\n+  loop_replace_args *args = (loop_replace_args *) data;\n   rtx m = *mem;\n \n   if (m == NULL_RTX)\n@@ -10187,13 +10187,12 @@ replace_loop_mem (mem, data)\n   return 0;\n }\n \n-\n static void\n replace_loop_mems (insn, mem, reg)\n-      rtx insn;\n-      rtx mem;\n-      rtx reg;\n-{\t    \n+     rtx insn;\n+     rtx mem;\n+     rtx reg;\n+{\n   loop_replace_args args;\n \n   args.insn = insn;\n@@ -10203,9 +10202,8 @@ replace_loop_mems (insn, mem, reg)\n   for_each_rtx (&insn, replace_loop_mem, &args);\n }\n \n-\n /* Replace one register with another.  Called through for_each_rtx; PX points\n-   to the rtx being scanned.  DATA is actually a pointer to \n+   to the rtx being scanned.  DATA is actually a pointer to\n    a structure of arguments.  */\n \n static int\n@@ -10214,7 +10212,7 @@ replace_loop_reg (px, data)\n      void *data;\n {\n   rtx x = *px;\n-  loop_replace_args *args = (loop_replace_args *)data;\n+  loop_replace_args *args = (loop_replace_args *) data;\n \n   if (x == NULL_RTX)\n     return 0;\n@@ -10225,7 +10223,6 @@ replace_loop_reg (px, data)\n   return 0;\n }\n \n-\n static void\n replace_loop_regs (insn, reg, replacement)\n      rtx insn;\n@@ -10241,7 +10238,6 @@ replace_loop_regs (insn, reg, replacement)\n   for_each_rtx (&insn, replace_loop_reg, &args);\n }\n \n-\n /* Replace occurrences of the old exit label for the loop with the new\n    one.  DATA is an rtx_pair containing the old and new labels,\n    respectively.  */\n@@ -10283,7 +10279,8 @@ replace_label (x, data)\n \n #define LOOP_INSN_UID(INSN) ((INSN) ? INSN_UID (INSN) : -1)\n \n-static void loop_dump_aux (loop, file, verbose)\n+static void\n+loop_dump_aux (loop, file, verbose)\n      const struct loop *loop;\n      FILE *file;\n      int verbose;\n@@ -10299,7 +10296,7 @@ static void loop_dump_aux (loop, file, verbose)\n       || GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n       || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n       != NOTE_INSN_LOOP_BEG)\n-    fprintf (file, \";;  No NOTE_INSN_LOOP_BEG at %d\\n\", \n+    fprintf (file, \";;  No NOTE_INSN_LOOP_BEG at %d\\n\",\n \t     INSN_UID (PREV_INSN (loop->first->head)));\n   if (! NEXT_INSN (loop->last->end)\n       || GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n@@ -10324,7 +10321,7 @@ static void loop_dump_aux (loop, file, verbose)\n \t       LOOP_INSN_UID (loop->end));\n       fprintf (file, \";;  top %d (%d), scan start %d (%d)\\n\",\n \t       LOOP_BLOCK_NUM (loop->top),\n-\t       LOOP_INSN_UID (loop->top) ,\n+\t       LOOP_INSN_UID (loop->top),\n \t       LOOP_BLOCK_NUM (loop->scan_start),\n \t       LOOP_INSN_UID (loop->scan_start));\n       fprintf (file, \";;  exit_count %d\", loop->exit_count);\n@@ -10338,15 +10335,14 @@ static void loop_dump_aux (loop, file, verbose)\n \t    }\n \t}\n       fputs (\"\\n\", file);\n-      \n+\n       /* This can happen when a marked loop appears as two nested loops,\n \t say from while (a || b) {}.  The inner loop won't match\n \t the loop markers but the outer one will.  */\n       if (LOOP_BLOCK_NUM (loop->cont) != loop->latch->index)\n \tfprintf (file, \";;  NOTE_INSN_LOOP_CONT not in loop latch\\n\");\n     }\n }\n-  \n \n /* Call this function from the debugger to dump LOOP.  */\n "}, {"sha": "15c0c3c9cc0b76c4bfb5d0dc8d509adc915d56b2", "filename": "gcc/loop.h", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=fd5d5b07b743014af3b70d4b0f9ca9bdfacf3656", "patch": "@@ -25,9 +25,8 @@ Boston, MA 02111-1307, USA.  */\n #define LOOP_UNROLL 1\n #define LOOP_BCT 2\n \n-\n /* Get the loop info pointer of a loop.  */\n-#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux) \n+#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n \n /* Get a pointer to the loop registers structure.  */\n #define LOOP_REGS(LOOP) (&LOOP_INFO (loop)->regs)\n@@ -52,7 +51,11 @@ Boston, MA 02111-1307, USA.  */\n \n /* An enum for the two different types of givs, those that are used\n    as memory addresses and those that are calculated into registers.  */\n-enum g_types { DEST_ADDR, DEST_REG };\n+enum g_types\n+{\n+  DEST_ADDR,\n+  DEST_REG\n+};\n \n /* A `struct induction' is created for every instruction that sets\n    an induction variable (either a biv or a giv).  */\n@@ -74,7 +77,7 @@ struct induction\n \t\t\t\t/* For a biv, this is the place where add_val\n \t\t\t\t   was found.  */\n   enum machine_mode mode;\t/* The mode of this biv or giv */\n-  enum machine_mode mem_mode;\t/* For DEST_ADDR, mode of the memory object. */\n+  enum machine_mode mem_mode;\t/* For DEST_ADDR, mode of the memory object.  */\n   rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n   rtx add_val;\t\t\t/* Additive constant for that product.  */\n   int benefit;\t\t\t/* Gain from eliminating this insn.  */\n@@ -102,25 +105,25 @@ struct induction\n   unsigned always_executed : 1; /* 1 if this set occurs each iteration.  */\n   unsigned maybe_multiple : 1;\t/* Only used for a biv and  1 if this biv\n \t\t\t\t   update may be done multiple times per\n-\t\t\t\t   iteration. */\n+\t\t\t\t   iteration.  */\n   unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n \t\t\t\t   another giv.  This occurs in many cases\n \t\t\t\t   where a giv's lifetime spans an update to\n-\t\t\t\t   a biv. */\n+\t\t\t\t   a biv.  */\n   unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n \t\t\t\t   we won't use it to eliminate a biv, it\n-\t\t\t\t   would probably lose. */\n+\t\t\t\t   would probably lose.  */\n   unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n-\t\t\t\t   to it to try to form an auto-inc address. */\n+\t\t\t\t   to it to try to form an auto-inc address.  */\n   unsigned unrolled : 1;\t/* 1 if new register has been allocated and\n \t\t\t\t   initialized in unrolled loop.  */\n   unsigned shared : 1;\n-  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n+  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const.  */\n   int lifetime;\t\t\t/* Length of life of this giv */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv\n \t\t\t\t   derives another.  This occurs when the\n-\t\t\t\t   giv spans a biv update by incrementation. */\n+\t\t\t\t   giv spans a biv update by incrementation.  */\n   rtx ext_dependant;\t\t/* If nonzero, is a sign or zero extension\n \t\t\t\t   if a biv on which this giv is dependant.  */\n   struct induction *next_iv;\t/* For givs, links together all givs that are\n@@ -135,20 +138,21 @@ struct induction\n   HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n-\t\t\t\t   for later use. */\n+\t\t\t\t   for later use.  */\n   int ix;\t\t\t/* Used by recombine_givs, as n index into\n \t\t\t\t   the stats array.  */\n   struct induction *same_insn;\t/* If there are multiple identical givs in\n \t\t\t\t   the same insn, then all but one have this\n \t\t\t\t   field set, and they all point to the giv\n \t\t\t\t   that doesn't have this field set.  */\n   rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n-\t\t\t\t   a substitute for the lifetime information. */\n+\t\t\t\t   a substitute for the lifetime information.  */\n };\n \n /* A `struct iv_class' is created for each biv.  */\n \n-struct iv_class {\n+struct iv_class\n+{\n   unsigned int regno;\t\t/* Pseudo reg which is the biv.  */\n   int biv_count;\t\t/* Number of insns setting this reg.  */\n   struct induction *biv;\t/* List of all insns that set this reg.  */\n@@ -161,30 +165,28 @@ struct iv_class {\n   rtx initial_value;\t\t/* Value of reg at loop start */\n   rtx initial_test;\t\t/* Test performed on BIV before loop */\n   struct iv_class *next;\t/* Links all class structures together */\n-  rtx init_insn;\t\t/* insn which initializes biv, 0 if none. */\n-  rtx init_set;\t\t\t/* SET of INIT_INSN, if any. */\n+  rtx init_insn;\t\t/* insn which initializes biv, 0 if none.  */\n+  rtx init_set;\t\t\t/* SET of INIT_INSN, if any.  */\n   unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n-  unsigned eliminable : 1;\t/* 1 if plausible candidate for elimination. */\n-  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for this. */\n+  unsigned eliminable : 1;\t/* 1 if plausible candidate for elimination.  */\n+  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for this.  */\n   unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n-\t\t\t\t   biv controls. */\n+\t\t\t\t   biv controls.  */\n };\n \n-\n typedef struct loop_mem_info\n {\n   rtx mem;      /* The MEM itself.  */\n   rtx reg;      /* Corresponding pseudo, if any.  */\n   int optimize; /* Nonzero if we can optimize access to this MEM.  */\n } loop_mem_info;\n \n-\n struct loop_ivs\n {\n   /* Indexed by register number, indicates whether or not register is\n      an induction variable, and if so what type.  */\n   varray_type reg_iv_type;\n-  \n+\n   /* Indexed by register number, contains pointer to `struct\n      induction' if register is an induction variable.  This holds\n      general info for all induction variables.  */\n@@ -195,7 +197,7 @@ struct loop_ivs\n      describing the class (a related group) of induction variables\n      that the biv belongs to.  */\n   struct iv_class **reg_biv_class;\n-  \n+\n   /* The head of a list which links together (via the next field)\n      every iv class for the current loop.  */\n   struct iv_class *loop_iv_list;\n@@ -207,7 +209,6 @@ struct loop_ivs\n   unsigned int last_increment_giv;\n };\n \n-\n struct loop_regs\n {\n   int num;\n@@ -220,7 +221,7 @@ struct loop_regs\n      not known equal to a constant.\n      After code motion, regs moved have 0 (which is accurate now)\n      while the failed candidates have the original number of times set.\n-     \n+\n      Therefore, at all times, == 0 indicates an invariant register;\n      < 0 a conditionally invariant one.  */\n   varray_type set_in_loop;\n@@ -229,23 +230,22 @@ struct loop_regs\n      is not set negative for a reg whose sets have been made candidates\n      and not set to 0 for a reg that is moved.  */\n   varray_type n_times_set;\n-  \n+\n   /* Index by register number, 1 indicates that the register\n      cannot be moved or strength reduced.  */\n   varray_type may_not_optimize;\n-  \n+\n   /* Contains the insn in which a register was used if it was used\n      exactly once; contains const0_rtx if it was used more than once.  */\n   varray_type single_usage;\n-  \n+\n   /* Nonzero means reg N has already been moved out of one loop.\n      This reduces the desire to move it out of another.  */\n   char *moved_once;\n \n   int multiple_uses;\n };\n \n-\n /* Information pertaining to a loop.  */\n \n struct loop_info\n@@ -321,8 +321,13 @@ struct loop_info\n };\n \n /* Definitions used by the basic induction variable discovery code.  */\n-enum iv_mode { UNKNOWN_INDUCT, BASIC_INDUCT, NOT_BASIC_INDUCT,\n-\t\t GENERAL_INDUCT };\n+enum iv_mode\n+{\n+  UNKNOWN_INDUCT,\n+  BASIC_INDUCT,\n+  NOT_BASIC_INDUCT,\n+  GENERAL_INDUCT\n+};\n \n /* Variables declared in loop.c, but also needed in unroll.c.  */\n \n@@ -349,8 +354,8 @@ void unroll_loop PARAMS ((struct loop *, int, rtx, int));\n rtx biv_total_increment PARAMS ((struct iv_class *));\n unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n int precondition_loop_p PARAMS ((const struct loop *,\n-\t\t\t       rtx *, rtx *, rtx *, \n-\t\t\t       enum machine_mode *mode));\n+\t\t\t\t rtx *, rtx *, rtx *,\n+\t\t\t\t enum machine_mode *mode));\n rtx final_biv_value PARAMS ((const struct loop *, struct iv_class *));\n rtx final_giv_value PARAMS ((const struct loop *, struct induction *));\n void emit_unrolled_add PARAMS ((rtx, rtx, rtx));"}]}