{"sha": "7edbd87e17d9240077eed1993436365ad6c4365c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VkYmQ4N2UxN2Q5MjQwMDc3ZWVkMTk5MzQzNjM2NWFkNmM0MzY1Yw==", "commit": {"author": {"name": "David Jee", "email": "djee@redhat.com", "date": "2004-01-26T21:55:42Z"}, "committer": {"name": "David Jee", "email": "djee@gcc.gnu.org", "date": "2004-01-26T21:55:42Z"}, "message": "2004-01-26  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(handleEvent): Implemented. Handles PaintEvents.\n\t(paint): Implemented. Use GTK native methods to queue updates\n        for this heavyweight peer.\n\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n\t(handleEvent): Removed.\n\t* java/awt/Component.java\n\t(paint): Implemented. Explictly paint the heavyweight peer.\n\t(update): Clear the background for heavyweight components.\n\t(paintAll): No need to call peer.paint() anymore.\n\t(processEvent): Don't process PaintEvents here. It's now done in\n\tthe peer's handleEvent().\n\t(processPaintEvent): Removed.\n\t* java/awt/Container.java\n\t(paint): No need to call super.paint(). Visit heavyweight\n\tchildren as well.\n\t(update): Don't clear the background here.  It's done in\n\tComponent.update().\n\t(visitChildren): Added check to not recurse into Containers.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(filter_expose_event_handler): New method.  Filter unwanted\n\texpose events while painting heavyweight peers.\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter):\n\tNew method. Connect filter and block pre_event_handler.\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter):\n\tNew method. Disconnect filter and unblock pre_event_handler.\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetQueueDrawArea):\n\tNew method. Invalidate and update given area.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(pre_event_handler): Add checks for unwanted expose events.\n\nFrom-SVN: r76668", "tree": {"sha": "9ab7045766c5842438bf57c60f381f2d8dce8bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ab7045766c5842438bf57c60f381f2d8dce8bb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7edbd87e17d9240077eed1993436365ad6c4365c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edbd87e17d9240077eed1993436365ad6c4365c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7edbd87e17d9240077eed1993436365ad6c4365c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edbd87e17d9240077eed1993436365ad6c4365c/comments", "author": null, "committer": null, "parents": [{"sha": "81a88a6157451550a5753e436021523f93226fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a88a6157451550a5753e436021523f93226fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a88a6157451550a5753e436021523f93226fc9"}], "stats": {"total": 281, "additions": 191, "deletions": 90}, "files": [{"sha": "72c37c2e14e10b9b1e5e06f9d7189fd96d74046b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -1,3 +1,36 @@\n+2004-01-26  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(handleEvent): Implemented. Handles PaintEvents.\n+\t(paint): Implemented. Use GTK native methods to queue updates\n+        for this heavyweight peer.\n+\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n+\t(handleEvent): Removed.\n+\t* java/awt/Component.java\n+\t(paint): Implemented. Explictly paint the heavyweight peer.\n+\t(update): Clear the background for heavyweight components.\n+\t(paintAll): No need to call peer.paint() anymore.\n+\t(processEvent): Don't process PaintEvents here. It's now done in\n+\tthe peer's handleEvent().\n+\t(processPaintEvent): Removed.\n+\t* java/awt/Container.java\n+\t(paint): No need to call super.paint(). Visit heavyweight\n+\tchildren as well.\n+\t(update): Don't clear the background here.  It's done in\n+\tComponent.update().\n+\t(visitChildren): Added check to not recurse into Containers.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(filter_expose_event_handler): New method.  Filter unwanted\n+\texpose events while painting heavyweight peers.\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter):\n+\tNew method. Connect filter and block pre_event_handler.\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter):\n+\tNew method. Disconnect filter and unblock pre_event_handler.\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetQueueDrawArea):\n+\tNew method. Invalidate and update given area.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(pre_event_handler): Add checks for unwanted expose events.\n+\n 2004-01-26  David Jee  <djee@redhat.com>\n \n \t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c"}, {"sha": "4b29bcc9ec59aa5342094d13e11524be6333f50c", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -91,6 +91,9 @@ public class GtkComponentPeer extends GtkGenericPeer\n   native void gtkWidgetSetCursor (int type);\n   native void gtkWidgetSetBackground (int red, int green, int blue);\n   native void gtkWidgetSetForeground (int red, int green, int blue);\n+  native void gtkWidgetQueueDrawArea(int x, int y, int width, int height);\n+  native void addExposeFilter();\n+  native void removeExposeFilter();\n \n   void create ()\n   {\n@@ -217,6 +220,37 @@ public Toolkit getToolkit ()\n   \n   public void handleEvent (AWTEvent event)\n   {\n+    int id = event.getID();\n+\n+    switch (id)\n+      {\n+      case PaintEvent.PAINT:\n+      case PaintEvent.UPDATE:\n+        {\n+          try \n+            {\n+              Graphics g = getGraphics ();\n+          \n+              // Some peers like GtkFileDialogPeer are repainted by Gtk itself\n+              if (g == null)\n+                break;\n+\n+              g.setClip (((PaintEvent)event).getUpdateRect());\n+\n+              if (id == PaintEvent.PAINT)\n+                awtComponent.paint (g);\n+              else\n+                awtComponent.update (g);\n+\n+              g.dispose ();\n+            }\n+          catch (InternalError e)\n+            {\n+              System.err.println (e);\n+            }\n+        }\n+        break;\n+      }\n   }\n   \n   public boolean isFocusTraversable () \n@@ -235,7 +269,21 @@ public Dimension minimumSize ()\n \n   public void paint (Graphics g)\n   {\n-    awtComponent.paint (g);\n+    Component parent = awtComponent.getParent();\n+    GtkComponentPeer parentPeer = null;\n+    if ((parent instanceof Container) && !parent.isLightweight())\n+      parentPeer = (GtkComponentPeer) parent.getPeer();\n+\n+    addExposeFilter();\n+    if (parentPeer != null)\n+      parentPeer.addExposeFilter();\n+\n+    Rectangle clip = g.getClipBounds();\n+    gtkWidgetQueueDrawArea(clip.x, clip.y, clip.width, clip.height);\n+\n+    removeExposeFilter();\n+    if (parentPeer != null)\n+      parentPeer.removeExposeFilter();\n   }\n \n   public Dimension preferredSize ()"}, {"sha": "361dea7562bd83ac187666d5d7ac66d225049b84", "filename": "libjava/gnu/java/awt/peer/gtk/GtkContainerPeer.java", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -100,41 +100,6 @@ public Graphics getGraphics ()\n     return new GdkGraphics (this);\n   }\n \n-  public void handleEvent (AWTEvent event)\n-  {\n-    int id = event.getID();\n-      \n-    switch (id)\n-      {\n-      case PaintEvent.PAINT:\n-      case PaintEvent.UPDATE:\n-\t{\n-\t  try \n-\t    {\n-\t      Graphics g = getGraphics ();\n-\n-\t      // Some peers like GtkFileDialogPeer are repainted by Gtk itself\n-\t      if (g == null)\n-\t        break;\n-\n-\t      g.setClip (((PaintEvent)event).getUpdateRect());\n-\n-\t      if (id == PaintEvent.PAINT)\n-\t\tawtComponent.paint (g);\n-\t      else\n-\t\tawtComponent.update (g);\n-\t      \n-\t      g.dispose ();\n-\t    } \n-\t  catch (InternalError e)\n-\t    { \n-\t      System.err.println (e);\n-\t    }\n-\t}\n-\tbreak;\n-      }\n-  }\n-\n   public void beginLayout () { }\n   public void endLayout () { }\n   public boolean isPaintPending () { return false; }"}, {"sha": "87c73b51e151eb659fc30ab8ee4208f84a181cb6", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 12, "deletions": 40, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -1702,6 +1702,9 @@ public boolean isCursorSet()\n    */\n   public void paint(Graphics g)\n   {\n+    // Paint the heavyweight peer\n+    if (!isLightweight() && peer != null)\n+      peer.paint(g);\n   }\n \n   /**\n@@ -1719,6 +1722,15 @@ public void paint(Graphics g)\n    */\n   public void update(Graphics g)\n   {\n+    if (!isLightweight())\n+      {\n+        Rectangle clip = g.getClipBounds();\n+        if (clip == null)\n+          g.clearRect(0, 0, width, height);\n+        else\n+          g.clearRect(clip.x, clip.y, clip.width, clip.height);\n+      }\n+\n     paint(g);\n   }\n \n@@ -1732,8 +1744,6 @@ public void paintAll(Graphics g)\n   {\n     if (! visible)\n       return;\n-    if (peer != null)\n-      peer.paint(g);\n     paint(g);\n   }\n \n@@ -2787,8 +2797,6 @@ protected void processEvent(AWTEvent e)\n \n     if (e instanceof FocusEvent)\n       processFocusEvent((FocusEvent) e);\n-    else if (e instanceof PaintEvent)\n-      processPaintEvent((PaintEvent) e);\n     else if (e instanceof MouseWheelEvent)\n       processMouseWheelEvent((MouseWheelEvent) e);\n     else if (e instanceof MouseEvent)\n@@ -4224,42 +4232,6 @@ private PaintEvent coalescePaintEvents(PaintEvent queuedEvent,\n     return newEvent;\n   }\n \n-  /**\n-   * Does the work for a paint event.\n-   *\n-   * @param event the event to process\n-   */\n-  private void processPaintEvent(PaintEvent event)\n-  {\n-    // Can't do graphics without peer\n-    if (peer == null)\n-      return;\n-\n-    Graphics gfx = getGraphics();\n-    try\n-      {\n-\tShape clip = event.getUpdateRect();\n-\tgfx.setClip(clip);\n-\n-\tswitch (event.id)\n-\t  {\n-\t  case PaintEvent.PAINT:\n-\t    paint(gfx);\n-\t    break;\n-\t  case PaintEvent.UPDATE:\n-\t    update(gfx);\n-\t    break;\n-\t  default:\n-\t    throw new IllegalArgumentException(\"unknown paint event\");\n-\t  }\n-\tevent.consume ();\n-      }\n-    finally\n-      {\n-\tgfx.dispose();\n-      }\n-  }\n-\n   /**\n    * This method is used to implement transferFocus(). CHILD is the child\n    * making the request. This is overridden by Container; when called for an"}, {"sha": "57cd8338ce98b92945783829d216f8f1a501d0a0", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -663,8 +663,9 @@ public void paint(Graphics g)\n   {\n     if (!isShowing())\n       return;\n-    super.paint(g);\n-    visitChildren(g, GfxPaintVisitor.INSTANCE, true);\n+    // Visit heavyweights as well, in case they were\n+    // erased when we cleared the background for this container.\n+    visitChildren(g, GfxPaintVisitor.INSTANCE, false);\n   }\n \n   /**\n@@ -678,11 +679,6 @@ public void paint(Graphics g)\n    */\n   public void update(Graphics g)\n   {\n-    Rectangle clip = g.getClipBounds();\n-    if (clip == null)\n-      g.clearRect(0, 0, width, height);\n-    else\n-      g.clearRect(clip.x, clip.y, clip.width, clip.height);\n     super.update(g);\n   }\n \n@@ -1204,8 +1200,12 @@ private void visitChildren(Graphics gfx, GfxVisitor visitor,\n         for (int i = ncomponents - 1; i >= 0; --i)\n           {\n             Component comp = component[i];\n+            // If we're visiting heavyweights as well,\n+            // don't recurse into Containers here. This avoids\n+            // painting the same nested child multiple times.\n             boolean applicable = comp.isVisible()\n-              && (comp.isLightweight() || !lightweightOnly);\n+              && (comp.isLightweight()\n+                  || !lightweightOnly && ! (comp instanceof Container));\n \n             if (applicable)\n               visitChild(gfx, visitor, comp);"}, {"sha": "725c89ebd7d55d5331ce48faeaeaf8a81e1394d4", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -575,6 +575,80 @@ Java_gnu_java_awt_peer_gtk_GtkComponentPeer_set__Ljava_lang_String_2Ljava_lang_O\n   (*env)->ReleaseStringUTFChars (env, jname, name);\n }\n \n+gboolean\n+filter_expose_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n+{\n+  // Prevent the default event handler from getting this signal if applicable\n+  // FIXME: I came up with these filters by looking for patterns in the unwanted\n+  //        expose events that are fed back to us from gtk/X. Perhaps there is\n+  //        a way to prevent them from occuring in the first place.\n+  if (event->type == GDK_EXPOSE && (!GTK_IS_LAYOUT(widget)\n+                                    || event->any.window != widget->window))\n+    {\n+      g_signal_stop_emission_by_name(GTK_OBJECT(widget), \"event\");\n+      return FALSE;\n+    }\n+  else\n+    {\n+      // There may be non-expose events that are triggered while we're\n+      // painting a heavyweight peer.\n+      return pre_event_handler(widget, event, peer);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_addExposeFilter\n+  (JNIEnv *env, jobject obj)\n+{\n+  void *ptr = NSA_GET_PTR (env, obj);\n+  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+  g_assert (gref);\n+\n+  gdk_threads_enter ();\n+\n+  g_signal_handlers_block_by_func (GTK_OBJECT(ptr), *pre_event_handler, *gref);\n+  g_signal_connect( GTK_OBJECT(ptr), \"event\",\n+                    G_CALLBACK(filter_expose_event_handler), *gref);\n+\n+  gdk_threads_leave ();\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_removeExposeFilter\n+  (JNIEnv *env, jobject obj)\n+{\n+  void *ptr = NSA_GET_PTR (env, obj);\n+  jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+  g_assert (gref);\n+\n+  gdk_threads_enter ();\n+\n+  g_signal_handlers_disconnect_by_func (GTK_OBJECT(ptr),\n+                                        *filter_expose_event_handler, *gref);\n+  g_signal_handlers_unblock_by_func (GTK_OBJECT(ptr), *pre_event_handler, *gref);\n+\n+  gdk_threads_leave ();\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetQueueDrawArea\n+  (JNIEnv *env, jobject obj, jint x, jint y, jint width, jint height)\n+{\n+  GdkRectangle rect;\n+  void *ptr;\n+\n+  ptr = NSA_GET_PTR (env, obj);\n+\n+  rect.x = x + GTK_WIDGET(ptr)->allocation.x;\n+  rect.y = y + GTK_WIDGET(ptr)->allocation.y;\n+  rect.width = width;\n+  rect.height = height;\n+\n+  gdk_threads_enter ();\n+\n+  gdk_window_invalidate_rect (GTK_WIDGET (ptr)->window, &rect, 0);\n+  gdk_window_process_all_updates();\n+\n+  gdk_threads_leave ();\n+}\n+\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_connectJObject\n   (JNIEnv *env, jobject obj)\n {"}, {"sha": "64b2995ffbce70bfde1c915715a80fd4ed1550b8", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edbd87e17d9240077eed1993436365ad6c4365c/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c?ref=7edbd87e17d9240077eed1993436365ad6c4365c", "patch": "@@ -1012,12 +1012,21 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n       break;\n     case GDK_EXPOSE:\n       {\n-\t(*gdk_env)->CallVoidMethod (gdk_env, peer,\n-\t\t\t\t    postExposeEventID,\n-\t\t\t\t    (jint)event->expose.area.x,\n-\t\t\t\t    (jint)event->expose.area.y,\n-\t\t\t\t    (jint)event->expose.area.width,\n-\t\t\t\t    (jint)event->expose.area.height);\n+        // This filters out unwanted feedback expose events from gtk/X\n+        // when we explictly invalidate and update heavyweight components,\n+        // thus avoiding an infinite loop.\n+        // FIXME: I'm not quite sure why we're getting these expose events. \n+        //        Maybe there is a way to avoid them?\n+        if((event->any.window == widget->window && event->any.send_event)\n+           || GTK_IS_LAYOUT(widget))\n+          {\n+\t    (*gdk_env)->CallVoidMethod (gdk_env, peer,\n+\t\t\t\t        postExposeEventID,\n+\t\t\t\t        (jint)event->expose.area.x,\n+\t\t\t\t        (jint)event->expose.area.y,\n+\t\t\t\t        (jint)event->expose.area.width,\n+\t\t\t\t        (jint)event->expose.area.height);\n+          }\n       }\n       break;\n     case GDK_FOCUS_CHANGE:"}]}