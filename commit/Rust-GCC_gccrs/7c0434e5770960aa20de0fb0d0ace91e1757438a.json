{"sha": "7c0434e5770960aa20de0fb0d0ace91e1757438a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MwNDM0ZTU3NzA5NjBhYTIwZGUwZmIwZDBhY2U5MWUxNzU3NDM4YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-01-20T15:42:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-20T15:42:38Z"}, "message": "compiler: Handle recursive interfaces.\n\n\t* go-gcc.cc (Gcc_backend::placeholder_struct_type): Permit name to\n\tbe empty.\n\t(Gcc_backend::set_placeholder_struct_type): Likewise.\n\nFrom-SVN: r183340", "tree": {"sha": "dbda0920b40eb4619acf931b7375d151ac4f323a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbda0920b40eb4619acf931b7375d151ac4f323a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c0434e5770960aa20de0fb0d0ace91e1757438a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0434e5770960aa20de0fb0d0ace91e1757438a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c0434e5770960aa20de0fb0d0ace91e1757438a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0434e5770960aa20de0fb0d0ace91e1757438a/comments", "author": null, "committer": null, "parents": [{"sha": "0ab6e1eceb167b931222d4d092acaca60f88a7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab6e1eceb167b931222d4d092acaca60f88a7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab6e1eceb167b931222d4d092acaca60f88a7a0"}], "stats": {"total": 628, "additions": 396, "deletions": 232}, "files": [{"sha": "0f7eb27e7040211983df98590f74fd21ad81984a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -1,3 +1,9 @@\n+2012-01-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::placeholder_struct_type): Permit name to\n+\tbe empty.\n+\t(Gcc_backend::set_placeholder_struct_type): Likewise.\n+\n 2012-01-17  Ian Lance Taylor  <iant@google.com>\n \n \t* gospec.c (lang_specific_driver): If we see -S without -o, add -o"}, {"sha": "ca0d626bcc42a03e34a61602bc586c015b6963f4", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -656,10 +656,13 @@ Gcc_backend::placeholder_struct_type(const std::string& name,\n \t\t\t\t     Location location)\n {\n   tree ret = make_node(RECORD_TYPE);\n-  tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n-\t\t\t get_identifier_from_string(name),\n-\t\t\t ret);\n-  TYPE_NAME(ret) = decl;\n+  if (!name.empty())\n+    {\n+      tree decl = build_decl(location.gcc_location(), TYPE_DECL,\n+\t\t\t     get_identifier_from_string(name),\n+\t\t\t     ret);\n+      TYPE_NAME(ret) = decl;\n+    }\n   return this->make_type(ret);\n }\n \n@@ -674,10 +677,13 @@ Gcc_backend::set_placeholder_struct_type(\n   gcc_assert(TREE_CODE(t) == RECORD_TYPE && TYPE_FIELDS(t) == NULL_TREE);\n   Btype* r = this->fill_in_struct(placeholder, fields);\n \n-  // Build the data structure gcc wants to see for a typedef.\n-  tree copy = build_distinct_type_copy(t);\n-  TYPE_NAME(copy) = NULL_TREE;\n-  DECL_ORIGINAL_TYPE(TYPE_NAME(t)) = copy;\n+  if (TYPE_NAME(t) != NULL_TREE)\n+    {\n+      // Build the data structure gcc wants to see for a typedef.\n+      tree copy = build_distinct_type_copy(t);\n+      TYPE_NAME(copy) = NULL_TREE;\n+      DECL_ORIGINAL_TYPE(TYPE_NAME(t)) = copy;\n+    }\n \n   return r->get_tree() != error_mark_node;\n }"}, {"sha": "2605ffef2b1b695594529cae774a6112aca67ce8", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -139,7 +139,8 @@ class Backend\n   set_placeholder_function_type(Btype* placeholder, Btype* ft) = 0;\n \n   // Create a placeholder struct type.  This is used for a named\n-  // struct type, as with placeholder_pointer_type.\n+  // struct type, as with placeholder_pointer_type.  It is also used\n+  // for interface types, in which case NAME will be the empty string.\n   virtual Btype*\n   placeholder_struct_type(const std::string& name, Location) = 0;\n "}, {"sha": "7550a56fc425b72029777c2c8bb3c83791f3865d", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -7566,7 +7566,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t{\n \t  // Calling recover outside of a function always returns the\n \t  // nil empty interface.\n-\t  Type* eface = Type::make_interface_type(NULL, loc);\n+\t  Type* eface = Type::make_empty_interface_type(loc);\n \t  return Expression::make_cast(eface, Expression::make_nil(loc), loc);\n \t}\n       break;\n@@ -8189,7 +8189,7 @@ Builtin_call_expression::do_type()\n       return Type::make_void_type();\n \n     case BUILTIN_RECOVER:\n-      return Type::make_interface_type(NULL, Linemap::predeclared_location());\n+      return Type::make_empty_interface_type(Linemap::predeclared_location());\n \n     case BUILTIN_APPEND:\n       {\n@@ -8883,7 +8883,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (arg_tree == error_mark_node)\n \t  return error_mark_node;\n \tType *empty =\n-\t  Type::make_interface_type(NULL, Linemap::predeclared_location());\n+\t  Type::make_empty_interface_type(Linemap::predeclared_location());\n \targ_tree = Expression::convert_for_assignment(context, empty,\n \t\t\t\t\t\t      arg->type(),\n \t\t\t\t\t\t      arg_tree, location);\n@@ -8916,7 +8916,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t  return error_mark_node;\n \n \tType *empty =\n-\t  Type::make_interface_type(NULL, Linemap::predeclared_location());\n+\t  Type::make_empty_interface_type(Linemap::predeclared_location());\n \ttree empty_tree = type_to_tree(empty->get_backend(context->gogo()));\n \n \tType* nil_type = Type::make_nil_type();"}, {"sha": "59a61bf25d816fc69c84726516001903d09d28a1", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -110,7 +110,8 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n     results->push_back(Typed_identifier(\"\", Type::lookup_string_type(), loc));\n     Type *method_type = Type::make_function_type(NULL, NULL, results, loc);\n     methods->push_back(Typed_identifier(\"Error\", method_type, loc));\n-    Type *error_iface = Type::make_interface_type(methods, loc);\n+    Interface_type *error_iface = Type::make_interface_type(methods, loc);\n+    error_iface->finalize_methods();\n     Named_type *error_type = Named_object::make_type(\"error\", NULL, error_iface, loc)->type_value();\n     this->add_named_type(error_type);\n   }\n@@ -175,7 +176,7 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int int_type_size,\n   print_type->set_is_builtin();\n   this->globals_->add_function_declaration(\"println\", NULL, print_type, loc);\n \n-  Type *empty = Type::make_interface_type(NULL, loc);\n+  Type *empty = Type::make_empty_interface_type(loc);\n   Typed_identifier_list* panic_parms = new Typed_identifier_list();\n   panic_parms->push_back(Typed_identifier(\"e\", empty, loc));\n   Function_type *panic_type = Type::make_function_type(NULL, panic_parms,\n@@ -1564,7 +1565,8 @@ Finalize_methods::type(Type* t)\n \t// finalize the methods of the field types, not of the struct\n \t// type itself.  We don't want to add methods to the struct,\n \t// since it has a name.\n-\tType* rt = t->named_type()->real_type();\n+\tNamed_type* nt = t->named_type();\n+\tType* rt = nt->real_type();\n \tif (rt->classification() != Type::TYPE_STRUCT)\n \t  {\n \t    if (Type::traverse(rt, this) == TRAVERSE_EXIT)\n@@ -1576,7 +1578,21 @@ Finalize_methods::type(Type* t)\n \t      return TRAVERSE_EXIT;\n \t  }\n \n-\tt->named_type()->finalize_methods(this->gogo_);\n+\tnt->finalize_methods(this->gogo_);\n+\n+\t// If this type is defined in a different package, then finalize the\n+\t// types of all the methods, since we won't see them otherwise.\n+\tif (nt->named_object()->package() != NULL && nt->has_any_methods())\n+\t  {\n+\t    const Methods* methods = nt->methods();\n+\t    for (Methods::const_iterator p = methods->begin();\n+\t\t p != methods->end();\n+\t\t ++p)\n+\t      {\n+\t\tif (Type::traverse(p->second->type(), this) == TRAVERSE_EXIT)\n+\t\t  return TRAVERSE_EXIT;\n+\t      }\n+\t  }\n \n \treturn TRAVERSE_SKIP_COMPONENTS;\n       }\n@@ -2622,6 +2638,9 @@ class Build_method_tables : public Traverse\n void\n Gogo::build_interface_method_tables()\n {\n+  if (saw_errors())\n+    return;\n+\n   std::vector<Interface_type*> hidden_interfaces;\n   hidden_interfaces.reserve(this->interface_types_.size());\n   for (std::vector<Interface_type*>::const_iterator pi =\n@@ -4922,10 +4941,7 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \t\t     | Traverse::traverse_statements\n \t\t     | Traverse::traverse_expressions\n \t\t     | Traverse::traverse_types)) != 0)\n-\t    {\n-\t      if (p->func_value()->traverse(traverse) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n+\t    t = p->func_value()->traverse(traverse);\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_PACKAGE:\n@@ -4952,6 +4968,26 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \treturn TRAVERSE_EXIT;\n     }\n \n+  // If we need to traverse types, check the function declarations,\n+  // which have types.  We don't need to check the type declarations,\n+  // as those are just names.\n+  if ((traverse_mask & e_or_t) != 0)\n+    {\n+      for (Bindings::const_declarations_iterator p =\n+\t     this->begin_declarations();\n+\t   p != this->end_declarations();\n+\t   ++p)\n+\t{\n+\t  if (p->second->is_function_declaration())\n+\t    {\n+\t      if (Type::traverse(p->second->func_declaration_value()->type(),\n+\t\t\t\t traverse)\n+\t\t  == TRAVERSE_EXIT)\n+\t\treturn TRAVERSE_EXIT;\n+\t    }\n+\t}\n+    }\n+\n   return TRAVERSE_CONTINUE;\n }\n \n@@ -5090,9 +5126,12 @@ Traverse::remember_type(const Type* type)\n     return true;\n   go_assert((this->traverse_mask() & traverse_types) != 0\n \t     || (this->traverse_mask() & traverse_expressions) != 0);\n-  // We only have to remember named types, as they are the only ones\n-  // we can see multiple times in a traversal.\n-  if (type->classification() != Type::TYPE_NAMED)\n+  // We mostly only have to remember named types.  But it turns out\n+  // that an interface type can refer to itself without using a name\n+  // by relying on interface inheritance, as in\n+  // type I interface { F() interface{I} }\n+  if (type->classification() != Type::TYPE_NAMED\n+      && type->classification() != Type::TYPE_INTERFACE)\n     return false;\n   if (this->types_seen_ == NULL)\n     this->types_seen_ = new Types_seen();"}, {"sha": "1042f03dc2274615f24f7fcf4fcc34478822ba7a", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -2578,8 +2578,13 @@ class Traverse\n   type(Type*);\n \n  private:\n-  typedef Unordered_set_hash(const Type*, Type_hash_identical,\n-\t\t\t     Type_identical) Types_seen;\n+  // A hash table for types we have seen during this traversal.  Note\n+  // that this uses the default hash functions for pointers rather\n+  // than Type_hash_identical and Type_identical.  This is because for\n+  // traversal we care about seeing a specific type structure.  If\n+  // there are two separate instances of identical types, we want to\n+  // traverse both.\n+  typedef Unordered_set(const Type*) Types_seen;\n \n   typedef Unordered_set(const Expression*) Expressions_seen;\n "}, {"sha": "7893d45f1b9641599a807ddfccf233b1731fe0c5", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -151,12 +151,14 @@ runtime_function_type(Runtime_function_type bft)\n \t    Typed_identifier_list* methods = new Typed_identifier_list();\n \t    Type* mtype = Type::make_function_type(NULL, NULL, NULL, bloc);\n \t    methods->push_back(Typed_identifier(\"x\", mtype, bloc));\n-\t    t = Type::make_interface_type(methods, bloc);\n+\t    Interface_type* it = Type::make_interface_type(methods, bloc);\n+\t    it->finalize_methods();\n+\t    t = it;\n \t  }\n \t  break;\n \n \tcase RFT_EFACE:\n-\t  t = Type::make_interface_type(NULL, bloc);\n+\t  t = Type::make_empty_interface_type(bloc);\n \t  break;\n \n \tcase RFT_FUNC_PTR:"}, {"sha": "3572e1d62b6a7c1d10d5c99e041e37d819b1f802", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 249, "deletions": 193, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -6148,140 +6148,110 @@ Type::make_channel_type(bool send, bool receive, Type* element_type)\n int\n Interface_type::do_traverse(Traverse* traverse)\n {\n-  if (this->methods_ == NULL)\n+  Typed_identifier_list* methods = (this->methods_are_finalized_\n+\t\t\t\t    ? this->all_methods_\n+\t\t\t\t    : this->parse_methods_);\n+  if (methods == NULL)\n     return TRAVERSE_CONTINUE;\n-  return this->methods_->traverse(traverse);\n+  return methods->traverse(traverse);\n }\n \n // Finalize the methods.  This handles interface inheritance.\n \n void\n Interface_type::finalize_methods()\n {\n-  if (this->methods_ == NULL)\n+  if (this->methods_are_finalized_)\n+    return;\n+  this->methods_are_finalized_ = true;\n+  if (this->parse_methods_ == NULL)\n     return;\n+\n+  this->all_methods_ = new Typed_identifier_list();\n+  this->all_methods_->reserve(this->parse_methods_->size());\n+  Typed_identifier_list inherit;\n+  for (Typed_identifier_list::const_iterator pm =\n+\t this->parse_methods_->begin();\n+       pm != this->parse_methods_->end();\n+       ++pm)\n+    {\n+      const Typed_identifier* p = &*pm;\n+      if (p->name().empty())\n+\tinherit.push_back(*p);\n+      else if (this->find_method(p->name()) == NULL)\n+\tthis->all_methods_->push_back(*p);\n+      else\n+\terror_at(p->location(), \"duplicate method %qs\",\n+\t\t Gogo::message_name(p->name()).c_str());\n+    }\n+\n   std::vector<Named_type*> seen;\n-  bool is_recursive = false;\n-  size_t from = 0;\n-  size_t to = 0;\n-  while (from < this->methods_->size())\n+  seen.reserve(inherit.size());\n+  bool issued_recursive_error = false;\n+  while (!inherit.empty())\n     {\n-      const Typed_identifier* p = &this->methods_->at(from);\n-      if (!p->name().empty())\n-\t{\n-\t  size_t i;\n-\t  for (i = 0; i < to; ++i)\n-\t    {\n-\t      if (this->methods_->at(i).name() == p->name())\n-\t\t{\n-\t\t  error_at(p->location(), \"duplicate method %qs\",\n-\t\t\t   Gogo::message_name(p->name()).c_str());\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (i == to)\n-\t    {\n-\t      if (from != to)\n-\t\tthis->methods_->set(to, *p);\n-\t      ++to;\n-\t    }\n-\t  ++from;\n-\t  continue;\n-\t}\n+      Type* t = inherit.back().type();\n+      Location tl = inherit.back().location();\n+      inherit.pop_back();\n \n-      Interface_type* it = p->type()->interface_type();\n+      Interface_type* it = t->interface_type();\n       if (it == NULL)\n \t{\n-\t  error_at(p->location(), \"interface contains embedded non-interface\");\n-\t  ++from;\n+\t  if (!t->is_error())\n+\t    error_at(tl, \"interface contains embedded non-interface\");\n \t  continue;\n \t}\n       if (it == this)\n \t{\n-\t  if (!is_recursive)\n+\t  if (!issued_recursive_error)\n \t    {\n-\t      error_at(p->location(), \"invalid recursive interface\");\n-\t      is_recursive = true;\n+\t      error_at(tl, \"invalid recursive interface\");\n+\t      issued_recursive_error = true;\n \t    }\n-\t  ++from;\n \t  continue;\n \t}\n \n-      Named_type* nt = p->type()->named_type();\n+      Named_type* nt = t->named_type();\n       if (nt != NULL)\n \t{\n \t  std::vector<Named_type*>::const_iterator q;\n \t  for (q = seen.begin(); q != seen.end(); ++q)\n \t    {\n \t      if (*q == nt)\n \t\t{\n-\t\t  error_at(p->location(), \"inherited interface loop\");\n+\t\t  error_at(tl, \"inherited interface loop\");\n \t\t  break;\n \t\t}\n \t    }\n \t  if (q != seen.end())\n-\t    {\n-\t      ++from;\n-\t      continue;\n-\t    }\n+\t    continue;\n \t  seen.push_back(nt);\n \t}\n \n-      const Typed_identifier_list* methods = it->methods();\n-      if (methods == NULL)\n-\t{\n-\t  ++from;\n-\t  continue;\n-\t}\n-      for (Typed_identifier_list::const_iterator q = methods->begin();\n-\t   q != methods->end();\n+      const Typed_identifier_list* imethods = it->parse_methods_;\n+      if (imethods == NULL)\n+\tcontinue;\n+      for (Typed_identifier_list::const_iterator q = imethods->begin();\n+\t   q != imethods->end();\n \t   ++q)\n \t{\n \t  if (q->name().empty())\n-\t    {\n-\t      if (q->type()->forwarded() == p->type()->forwarded())\n-\t\terror_at(p->location(), \"interface inheritance loop\");\n-\t      else\n-\t\t{\n-\t\t  size_t i;\n-\t\t  for (i = from + 1; i < this->methods_->size(); ++i)\n-\t\t    {\n-\t\t      const Typed_identifier* r = &this->methods_->at(i);\n-\t\t      if (r->name().empty()\n-\t\t\t  && r->type()->forwarded() == q->type()->forwarded())\n-\t\t\t{\n-\t\t\t  error_at(p->location(),\n-\t\t\t\t   \"inherited interface listed twice\");\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  if (i == this->methods_->size())\n-\t\t    this->methods_->push_back(Typed_identifier(q->name(),\n-\t\t\t\t\t\t\t       q->type(),\n-\t\t\t\t\t\t\t       p->location()));\n-\t\t}\n-\t    }\n+\t    inherit.push_back(*q);\n \t  else if (this->find_method(q->name()) == NULL)\n-\t    this->methods_->push_back(Typed_identifier(q->name(), q->type(),\n-\t\t\t\t\t\t       p->location()));\n+\t    this->all_methods_->push_back(Typed_identifier(q->name(),\n+\t\t\t\t\t\t\t   q->type(), tl));\n \t  else\n-\t    {\n-\t      if (!is_recursive)\n-\t\terror_at(p->location(), \"inherited method %qs is ambiguous\",\n-\t\t\t Gogo::message_name(q->name()).c_str());\n-\t    }\n+\t    error_at(tl, \"inherited method %qs is ambiguous\",\n+\t\t     Gogo::message_name(q->name()).c_str());\n \t}\n-      ++from;\n-    }\n-  if (to == 0)\n-    {\n-      delete this->methods_;\n-      this->methods_ = NULL;\n     }\n+\n+  if (!this->all_methods_->empty())\n+    this->all_methods_->sort_by_name();\n   else\n     {\n-      this->methods_->resize(to);\n-      this->methods_->sort_by_name();\n+      delete this->all_methods_;\n+      this->all_methods_ = NULL;\n     }\n }\n \n@@ -6290,10 +6260,11 @@ Interface_type::finalize_methods()\n const Typed_identifier*\n Interface_type::find_method(const std::string& name) const\n {\n-  if (this->methods_ == NULL)\n+  go_assert(this->methods_are_finalized_);\n+  if (this->all_methods_ == NULL)\n     return NULL;\n-  for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-       p != this->methods_->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p)\n     if (p->name() == name)\n       return &*p;\n@@ -6305,10 +6276,10 @@ Interface_type::find_method(const std::string& name) const\n size_t\n Interface_type::method_index(const std::string& name) const\n {\n-  go_assert(this->methods_ != NULL);\n+  go_assert(this->methods_are_finalized_ && this->all_methods_ != NULL);\n   size_t ret = 0;\n-  for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-       p != this->methods_->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p, ++ret)\n     if (p->name() == name)\n       return ret;\n@@ -6321,10 +6292,11 @@ Interface_type::method_index(const std::string& name) const\n bool\n Interface_type::is_unexported_method(Gogo* gogo, const std::string& name) const\n {\n-  if (this->methods_ == NULL)\n+  go_assert(this->methods_are_finalized_);\n+  if (this->all_methods_ == NULL)\n     return false;\n-  for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-       p != this->methods_->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p)\n     {\n       const std::string& method_name(p->name());\n@@ -6342,26 +6314,53 @@ bool\n Interface_type::is_identical(const Interface_type* t,\n \t\t\t     bool errors_are_identical) const\n {\n+  go_assert(this->methods_are_finalized_ && t->methods_are_finalized_);\n+\n   // We require the same methods with the same types.  The methods\n   // have already been sorted.\n-  if (this->methods() == NULL || t->methods() == NULL)\n-    return this->methods() == t->methods();\n+  if (this->all_methods_ == NULL || t->all_methods_ == NULL)\n+    return this->all_methods_ == t->all_methods_;\n+\n+  if (this->assume_identical(this, t) || t->assume_identical(t, this))\n+    return true;\n \n-  Typed_identifier_list::const_iterator p1 = this->methods()->begin();\n-  for (Typed_identifier_list::const_iterator p2 = t->methods()->begin();\n-       p2 != t->methods()->end();\n-       ++p1, ++p2)\n+  Assume_identical* hold_ai = this->assume_identical_;\n+  Assume_identical ai;\n+  ai.t1 = this;\n+  ai.t2 = t;\n+  ai.next = hold_ai;\n+  this->assume_identical_ = &ai;\n+\n+  Typed_identifier_list::const_iterator p1 = this->all_methods_->begin();\n+  Typed_identifier_list::const_iterator p2;\n+  for (p2 = t->all_methods_->begin(); p2 != t->all_methods_->end(); ++p1, ++p2)\n     {\n-      if (p1 == this->methods()->end())\n-\treturn false;\n+      if (p1 == this->all_methods_->end())\n+\tbreak;\n       if (p1->name() != p2->name()\n \t  || !Type::are_identical(p1->type(), p2->type(),\n \t\t\t\t  errors_are_identical, NULL))\n-\treturn false;\n+\tbreak;\n     }\n-  if (p1 != this->methods()->end())\n-    return false;\n-  return true;\n+\n+  this->assume_identical_ = hold_ai;\n+\n+  return p1 == this->all_methods_->end() && p2 == t->all_methods_->end();\n+}\n+\n+// Return true if T1 and T2 are assumed to be identical during a type\n+// comparison.\n+\n+bool\n+Interface_type::assume_identical(const Interface_type* t1,\n+\t\t\t\t const Interface_type* t2) const\n+{\n+  for (Assume_identical* p = this->assume_identical_;\n+       p != NULL;\n+       p = p->next)\n+    if ((p->t1 == t1 && p->t2 == t2) || (p->t1 == t2 && p->t2 == t1))\n+      return true;\n+  return false;\n }\n \n // Whether we can assign the interface type T to this type.  The types\n@@ -6373,10 +6372,11 @@ bool\n Interface_type::is_compatible_for_assign(const Interface_type* t,\n \t\t\t\t\t std::string* reason) const\n {\n-  if (this->methods() == NULL)\n+  go_assert(this->methods_are_finalized_ && t->methods_are_finalized_);\n+  if (this->all_methods_ == NULL)\n     return true;\n-  for (Typed_identifier_list::const_iterator p = this->methods()->begin();\n-       p != this->methods()->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p)\n     {\n       const Typed_identifier* m = t->find_method(p->name());\n@@ -6423,17 +6423,23 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n // Hash code.\n \n unsigned int\n-Interface_type::do_hash_for_method(Gogo* gogo) const\n+Interface_type::do_hash_for_method(Gogo*) const\n {\n+  go_assert(this->methods_are_finalized_);\n   unsigned int ret = 0;\n-  if (this->methods_ != NULL)\n+  if (this->all_methods_ != NULL)\n     {\n-      for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-\t   p != this->methods_->end();\n+      for (Typed_identifier_list::const_iterator p =\n+\t     this->all_methods_->begin();\n+\t   p != this->all_methods_->end();\n \t   ++p)\n \t{\n \t  ret = Type::hash_string(p->name(), ret);\n-\t  ret += p->type()->hash_for_method(gogo);\n+\t  // We don't use the method type in the hash, to avoid\n+\t  // infinite recursion if an interface method uses a type\n+\t  // which is an interface which inherits from the interface\n+\t  // itself.\n+\t  // type T interface { F() interface {T}}\n \t  ret <<= 1;\n \t}\n     }\n@@ -6446,7 +6452,8 @@ Interface_type::do_hash_for_method(Gogo* gogo) const\n bool\n Interface_type::implements_interface(const Type* t, std::string* reason) const\n {\n-  if (this->methods_ == NULL)\n+  go_assert(this->methods_are_finalized_);\n+  if (this->all_methods_ == NULL)\n     return true;\n \n   bool is_pointer = false;\n@@ -6499,8 +6506,8 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n       return false;\n     }\n \n-  for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-       p != this->methods_->end();\n+  for (Typed_identifier_list::const_iterator p = this->all_methods_->begin();\n+       p != this->all_methods_->end();\n        ++p)\n     {\n       bool is_ambiguous = false;\n@@ -6653,13 +6660,20 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n Btype*\n Interface_type::do_get_backend(Gogo* gogo)\n {\n-  if (this->methods_ == NULL)\n+  if (this->is_empty())\n     return Interface_type::get_backend_empty_interface_type(gogo);\n   else\n     {\n+      if (this->interface_btype_ != NULL)\n+\treturn this->interface_btype_;\n+      this->interface_btype_ =\n+\tgogo->backend()->placeholder_struct_type(\"\", this->location_);\n       std::vector<Backend::Btyped_identifier> bfields;\n       get_backend_interface_fields(gogo, this, &bfields);\n-      return gogo->backend()->struct_type(bfields);\n+      if (!gogo->backend()->set_placeholder_struct_type(this->interface_btype_,\n+\t\t\t\t\t\t\tbfields))\n+\tthis->interface_btype_ = gogo->backend()->error_type();\n+      return this->interface_btype_;\n     }\n }\n \n@@ -6721,13 +6735,14 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   go_assert(pif->is_field_name(\"methods\"));\n \n   Expression_list* methods = new Expression_list();\n-  if (this->methods_ != NULL && !this->methods_->empty())\n+  if (this->all_methods_ != NULL)\n     {\n       Type* elemtype = pif->type()->array_type()->element_type();\n \n-      methods->reserve(this->methods_->size());\n-      for (Typed_identifier_list::const_iterator pm = this->methods_->begin();\n-\t   pm != this->methods_->end();\n+      methods->reserve(this->all_methods_->size());\n+      for (Typed_identifier_list::const_iterator pm =\n+\t     this->all_methods_->begin();\n+\t   pm != this->all_methods_->end();\n \t   ++pm)\n \t{\n \t  const Struct_field_list* mfields = elemtype->struct_type()->fields();\n@@ -6780,29 +6795,35 @@ void\n Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n {\n   ret->append(\"interface {\");\n-  if (this->methods_ != NULL)\n+  const Typed_identifier_list* methods = this->parse_methods_;\n+  if (methods != NULL)\n     {\n       ret->push_back(' ');\n-      for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-\t   p != this->methods_->end();\n+      for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t   p != methods->end();\n \t   ++p)\n \t{\n-\t  if (p != this->methods_->begin())\n+\t  if (p != methods->begin())\n \t    ret->append(\"; \");\n-\t  if (!Gogo::is_hidden_name(p->name()))\n-\t    ret->append(p->name());\n+\t  if (p->name().empty())\n+\t    this->append_reflection(p->type(), gogo, ret);\n \t  else\n \t    {\n-\t      // This matches what the gc compiler does.\n-\t      std::string prefix = Gogo::hidden_name_prefix(p->name());\n-\t      ret->append(prefix.substr(prefix.find('.') + 1));\n-\t      ret->push_back('.');\n-\t      ret->append(Gogo::unpack_hidden_name(p->name()));\n+\t      if (!Gogo::is_hidden_name(p->name()))\n+\t\tret->append(p->name());\n+\t      else\n+\t\t{\n+\t\t  // This matches what the gc compiler does.\n+\t\t  std::string prefix = Gogo::hidden_name_prefix(p->name());\n+\t\t  ret->append(prefix.substr(prefix.find('.') + 1));\n+\t\t  ret->push_back('.');\n+\t\t  ret->append(Gogo::unpack_hidden_name(p->name()));\n+\t\t}\n+\t      std::string sub = p->type()->reflection(gogo);\n+\t      go_assert(sub.compare(0, 4, \"func\") == 0);\n+\t      sub = sub.substr(4);\n+\t      ret->append(sub);\n \t    }\n-\t  std::string sub = p->type()->reflection(gogo);\n-\t  go_assert(sub.compare(0, 4, \"func\") == 0);\n-\t  sub = sub.substr(4);\n-\t  ret->append(sub);\n \t}\n       ret->push_back(' ');\n     }\n@@ -6814,23 +6835,30 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n void\n Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n+  go_assert(this->methods_are_finalized_);\n+\n   ret->push_back('I');\n \n-  const Typed_identifier_list* methods = this->methods_;\n-  if (methods != NULL)\n+  const Typed_identifier_list* methods = this->all_methods_;\n+  if (methods != NULL && !this->seen_)\n     {\n+      this->seen_ = true;\n       for (Typed_identifier_list::const_iterator p = methods->begin();\n \t   p != methods->end();\n \t   ++p)\n \t{\n-\t  std::string n = Gogo::unpack_hidden_name(p->name());\n-\t  char buf[20];\n-\t  snprintf(buf, sizeof buf, \"%u_\",\n-\t\t   static_cast<unsigned int>(n.length()));\n-\t  ret->append(buf);\n-\t  ret->append(n);\n+\t  if (!p->name().empty())\n+\t    {\n+\t      std::string n = Gogo::unpack_hidden_name(p->name());\n+\t      char buf[20];\n+\t      snprintf(buf, sizeof buf, \"%u_\",\n+\t\t       static_cast<unsigned int>(n.length()));\n+\t      ret->append(buf);\n+\t      ret->append(n);\n+\t    }\n \t  this->append_mangled_name(p->type(), gogo, ret);\n \t}\n+      this->seen_ = false;\n     }\n \n   ret->push_back('e');\n@@ -6843,67 +6871,75 @@ Interface_type::do_export(Export* exp) const\n {\n   exp->write_c_string(\"interface { \");\n \n-  const Typed_identifier_list* methods = this->methods_;\n+  const Typed_identifier_list* methods = this->parse_methods_;\n   if (methods != NULL)\n     {\n       for (Typed_identifier_list::const_iterator pm = methods->begin();\n \t   pm != methods->end();\n \t   ++pm)\n \t{\n-\t  exp->write_string(pm->name());\n-\t  exp->write_c_string(\" (\");\n-\n-\t  const Function_type* fntype = pm->type()->function_type();\n-\n-\t  bool first = true;\n-\t  const Typed_identifier_list* parameters = fntype->parameters();\n-\t  if (parameters != NULL)\n+\t  if (pm->name().empty())\n \t    {\n-\t      bool is_varargs = fntype->is_varargs();\n-\t      for (Typed_identifier_list::const_iterator pp =\n-\t\t     parameters->begin();\n-\t\t   pp != parameters->end();\n-\t\t   ++pp)\n-\t\t{\n-\t\t  if (first)\n-\t\t    first = false;\n-\t\t  else\n-\t\t    exp->write_c_string(\", \");\n-\t\t  if (!is_varargs || pp + 1 != parameters->end())\n-\t\t    exp->write_type(pp->type());\n-\t\t  else\n-\t\t    {\n-\t\t      exp->write_c_string(\"...\");\n-\t\t      Type *pptype = pp->type();\n-\t\t      exp->write_type(pptype->array_type()->element_type());\n-\t\t    }\n-\t\t}\n+\t      exp->write_c_string(\"$ \");\n+\t      exp->write_type(pm->type());\n \t    }\n+\t  else\n+\t    {\n+\t      exp->write_string(pm->name());\n+\t      exp->write_c_string(\" (\");\n \n-\t  exp->write_c_string(\")\");\n+\t      const Function_type* fntype = pm->type()->function_type();\n \n-\t  const Typed_identifier_list* results = fntype->results();\n-\t  if (results != NULL)\n-\t    {\n-\t      exp->write_c_string(\" \");\n-\t      if (results->size() == 1)\n-\t\texp->write_type(results->begin()->type());\n-\t      else\n+\t      bool first = true;\n+\t      const Typed_identifier_list* parameters = fntype->parameters();\n+\t      if (parameters != NULL)\n \t\t{\n-\t\t  first = true;\n-\t\t  exp->write_c_string(\"(\");\n-\t\t  for (Typed_identifier_list::const_iterator p =\n-\t\t\t results->begin();\n-\t\t       p != results->end();\n-\t\t       ++p)\n+\t\t  bool is_varargs = fntype->is_varargs();\n+\t\t  for (Typed_identifier_list::const_iterator pp =\n+\t\t\t parameters->begin();\n+\t\t       pp != parameters->end();\n+\t\t       ++pp)\n \t\t    {\n \t\t      if (first)\n \t\t\tfirst = false;\n \t\t      else\n \t\t\texp->write_c_string(\", \");\n-\t\t      exp->write_type(p->type());\n+\t\t      if (!is_varargs || pp + 1 != parameters->end())\n+\t\t\texp->write_type(pp->type());\n+\t\t      else\n+\t\t\t{\n+\t\t\t  exp->write_c_string(\"...\");\n+\t\t\t  Type *pptype = pp->type();\n+\t\t\t  exp->write_type(pptype->array_type()->element_type());\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      exp->write_c_string(\")\");\n+\n+\t      const Typed_identifier_list* results = fntype->results();\n+\t      if (results != NULL)\n+\t\t{\n+\t\t  exp->write_c_string(\" \");\n+\t\t  if (results->size() == 1)\n+\t\t    exp->write_type(results->begin()->type());\n+\t\t  else\n+\t\t    {\n+\t\t      first = true;\n+\t\t      exp->write_c_string(\"(\");\n+\t\t      for (Typed_identifier_list::const_iterator p =\n+\t\t\t     results->begin();\n+\t\t\t   p != results->end();\n+\t\t\t   ++p)\n+\t\t\t{\n+\t\t\t  if (first)\n+\t\t\t    first = false;\n+\t\t\t  else\n+\t\t\t    exp->write_c_string(\", \");\n+\t\t\t  exp->write_type(p->type());\n+\t\t\t}\n+\t\t      exp->write_c_string(\")\");\n \t\t    }\n-\t\t  exp->write_c_string(\")\");\n \t\t}\n \t    }\n \n@@ -6925,6 +6961,16 @@ Interface_type::do_import(Import* imp)\n   while (imp->peek_char() != '}')\n     {\n       std::string name = imp->read_identifier();\n+\n+      if (name == \"$\")\n+\t{\n+\t  imp->require_c_string(\" \");\n+\t  Type* t = imp->read_type();\n+\t  methods->push_back(Typed_identifier(\"\", t, imp->location()));\n+\t  imp->require_c_string(\"; \");\n+\t  continue;\n+\t}\n+\n       imp->require_c_string(\" (\");\n \n       Typed_identifier_list* parameters;\n@@ -7014,6 +7060,16 @@ Type::make_interface_type(Typed_identifier_list* methods,\n   return new Interface_type(methods, location);\n }\n \n+// Make an empty interface type.\n+\n+Interface_type*\n+Type::make_empty_interface_type(Location location)\n+{\n+  Interface_type* ret = new Interface_type(NULL, location);\n+  ret->finalize_methods();\n+  return ret;\n+}\n+\n // Class Method.\n \n // Bind a method to an object."}, {"sha": "b167451191eeb973003fdb9790ca1fab4d169dc2", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -485,6 +485,9 @@ class Type\n   static Interface_type*\n   make_interface_type(Typed_identifier_list* methods, Location);\n \n+  static Interface_type*\n+  make_empty_interface_type(Location);\n+\n   static Type*\n   make_type_descriptor_type();\n \n@@ -1319,6 +1322,10 @@ class Typed_identifier_list\n                                               Linemap::unknown_location()));\n   }\n \n+  void\n+  reserve(size_t c)\n+  { this->entries_.reserve(c); }\n+\n   // Iterators.\n \n   typedef std::vector<Typed_identifier>::iterator iterator;\n@@ -2429,7 +2436,9 @@ class Interface_type : public Type\n  public:\n   Interface_type(Typed_identifier_list* methods, Location location)\n     : Type(TYPE_INTERFACE),\n-      methods_(methods), location_(location)\n+      parse_methods_(methods), all_methods_(NULL), location_(location),\n+      interface_btype_(NULL), assume_identical_(NULL),\n+      methods_are_finalized_(false), seen_(false)\n   { go_assert(methods == NULL || !methods->empty()); }\n \n   // The location where the interface type was defined.\n@@ -2440,18 +2449,27 @@ class Interface_type : public Type\n   // Return whether this is an empty interface.\n   bool\n   is_empty() const\n-  { return this->methods_ == NULL; }\n+  {\n+    go_assert(this->methods_are_finalized_);\n+    return this->all_methods_ == NULL;\n+  }\n \n   // Return the list of methods.  This will return NULL for an empty\n   // interface.\n   const Typed_identifier_list*\n   methods() const\n-  { return this->methods_; }\n+  {\n+    go_assert(this->methods_are_finalized_);\n+    return this->all_methods_;\n+  }\n \n   // Return the number of methods.\n   size_t\n   method_count() const\n-  { return this->methods_ == NULL ? 0 : this->methods_->size(); }\n+  {\n+    go_assert(this->methods_are_finalized_);\n+    return this->all_methods_ == NULL ? 0 : this->all_methods_->size();\n+  }\n \n   // Return the method NAME, or NULL.\n   const Typed_identifier*\n@@ -2461,7 +2479,8 @@ class Interface_type : public Type\n   size_t\n   method_index(const std::string& name) const;\n \n-  // Finalize the methods.  This handles interface inheritance.\n+  // Finalize the methods.  This sets all_methods_.  This handles\n+  // interface inheritance.\n   void\n   finalize_methods();\n \n@@ -2528,11 +2547,41 @@ class Interface_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  // The list of methods associated with the interface.  This will be\n-  // NULL for the empty interface.\n-  Typed_identifier_list* methods_;\n+  // This type guards against infinite recursion when comparing\n+  // interface types.  We keep a list of interface types assumed to be\n+  // identical during comparison.  We just keep the list on the stack.\n+  // This permits us to compare cases like\n+  // type I1 interface { F() interface{I1} }\n+  // type I2 interface { F() interface{I2} }\n+  struct Assume_identical\n+  {\n+    Assume_identical* next;\n+    const Interface_type* t1;\n+    const Interface_type* t2;\n+  };\n+\n+  bool\n+  assume_identical(const Interface_type*, const Interface_type*) const;\n+\n+  // The list of methods associated with the interface from the\n+  // parser.  This will be NULL for the empty interface.  This may\n+  // include unnamed interface types.\n+  Typed_identifier_list* parse_methods_;\n+  // The list of all methods associated with the interface.  This\n+  // expands any interface types listed in methods_.  It is set by\n+  // finalize_methods.  This will be NULL for the empty interface.\n+  Typed_identifier_list* all_methods_;\n   // The location where the interface was defined.\n   Location location_;\n+  // The backend representation of this type during backend conversion.\n+  Btype* interface_btype_;\n+  // A list of interface types assumed to be identical during\n+  // interface comparison.\n+  mutable Assume_identical* assume_identical_;\n+  // Whether the methods have been finalized.\n+  bool methods_are_finalized_;\n+  // Used to avoid endless recursion in do_mangled_name.\n+  mutable bool seen_;\n };\n \n // The value we keep for a named type.  This lets us get the right"}, {"sha": "6e8a4042e72501eecc54d51630d63762f08dc667", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -87,7 +87,7 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n     this->add_named_object(no);\n \n   // Typeof.\n-  Type* empty_interface = Type::make_interface_type(NULL, bloc);\n+  Type* empty_interface = Type::make_empty_interface_type(bloc);\n   Typed_identifier_list* parameters = new Typed_identifier_list;\n   parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n   results = new Typed_identifier_list;"}, {"sha": "d8e112a3a6822dd82c61c95914ca6385ca7ee2fe", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug195.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug195.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug195.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug195.go?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -23,5 +23,5 @@ type I5 interface {\n }\n \n type I6 interface {\n-\tI5\t// GC_ERROR \"interface\"\n+\tI5\t// ERROR \"interface\"\n }"}, {"sha": "fb7b98a016dd2b94a623153f3132cc9e68b7c798", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug251.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug251.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0434e5770960aa20de0fb0d0ace91e1757438a/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug251.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug251.go?ref=7c0434e5770960aa20de0fb0d0ace91e1757438a", "patch": "@@ -12,7 +12,7 @@ type I1 interface {\n }\n \n type I2 interface {\n-\tI1 // GC_ERROR \"loop|interface\"\n+\tI1 // ERROR \"loop|interface\"\n }\n \n "}]}