{"sha": "610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwYzhlZjBhNDIwZTUyNjdjYmNjZDVhNDUwOWYwY2UzMDk1ZTE0Yw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-04-04T14:11:06Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-04-04T14:11:06Z"}, "message": "re PR ipa/60640 (ICE edge points to wrong declaration / verify_cgraph_node failed)\n\n2014-04-04  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/60640\n        * cgraph.h (cgraph_clone_node): New parameter added to declaration.\n        Adjust all callers.\n\t* cgraph.c (clone_of_p): Also return true if thunks match.\n\t(verify_edge_corresponds_to_fndecl): Removed extraneous call to\n\tcgraph_function_or_thunk_node and an obsolete comment.\n        * cgraphclones.c (build_function_type_skip_args): Moved upwards in the\n        file.\n        (build_function_decl_skip_args): Likewise.\n\t(set_new_clone_decl_and_node_flags): New function.\n        (duplicate_thunk_for_node): Likewise.\n        (redirect_edge_duplicating_thunks): Likewise.\n        (cgraph_clone_node): New parameter args_to_skip, pass it to\n        redirect_edge_duplicating_thunks which is called instead of\n        cgraph_redirect_edge_callee.\n        (cgraph_create_virtual_clone): Pass args_to_skip to cgraph_clone_node,\n\tmoved setting of a lot of flags to set_new_clone_decl_and_node_flags.\n\ntestsuite/\n        * g++.dg/ipa/pr60640-1.C: New test.\n        * g++.dg/ipa/pr60640-2.C: Likewise.\n        * g++.dg/ipa/pr60640-3.C: Likewise.\n        * g++.dg/ipa/pr60640-4.C: Likewise.\n\nFrom-SVN: r209097", "tree": {"sha": "a981c037f8ae40dbdb770ab5dcc5d5474cb95903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a981c037f8ae40dbdb770ab5dcc5d5474cb95903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c"}], "stats": {"total": 628, "additions": 498, "deletions": 130}, "files": [{"sha": "851cee76ba28a43e84b401ccf0790cbabc95b29e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -1,3 +1,23 @@\n+2014-04-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/60640\n+        * cgraph.h (cgraph_clone_node): New parameter added to declaration.\n+        Adjust all callers.\n+\t* cgraph.c (clone_of_p): Also return true if thunks match.\n+\t(verify_edge_corresponds_to_fndecl): Removed extraneous call to\n+\tcgraph_function_or_thunk_node and an obsolete comment.\n+        * cgraphclones.c (build_function_type_skip_args): Moved upwards in the\n+        file.\n+        (build_function_decl_skip_args): Likewise.\n+\t(set_new_clone_decl_and_node_flags): New function.\n+        (duplicate_thunk_for_node): Likewise.\n+        (redirect_edge_duplicating_thunks): Likewise.\n+        (cgraph_clone_node): New parameter args_to_skip, pass it to\n+        redirect_edge_duplicating_thunks which is called instead of\n+        cgraph_redirect_edge_callee.\n+        (cgraph_create_virtual_clone): Pass args_to_skip to cgraph_clone_node,\n+\tmoved setting of a lot of flags to set_new_clone_decl_and_node_flags.\n+\n 2014-04-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR fortran/60191"}, {"sha": "be3661af6d34637a2c45db28768f6925de514bbc", "filename": "gcc/cgraph.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -2544,12 +2544,34 @@ collect_callers_of_node (struct cgraph_node *node)\n   return redirect_callers;\n }\n \n-/* Return TRUE if NODE2 is equivalent to NODE or its clone.  */\n+/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  */\n+\n static bool\n clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n {\n+  bool skipped_thunk = false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n   node2 = cgraph_function_or_thunk_node (node2, NULL);\n+\n+  /* There are no virtual clones of thunks so check former_clone_of or if we\n+     might have skipped thunks because this adjustments are no longer\n+     necessary.  */\n+  while (node->thunk.thunk_p)\n+    {\n+      if (node2->former_clone_of == node->decl)\n+\treturn true;\n+      if (!node->thunk.this_adjusting)\n+\treturn false;\n+      node = cgraph_function_or_thunk_node (node->callees->callee, NULL);\n+      skipped_thunk = true;\n+    }\n+\n+  if (skipped_thunk\n+      && (!node2->clone_of\n+\t  || !node2->clone.args_to_skip\n+\t  || !bitmap_bit_p (node2->clone.args_to_skip, 0)))\n+    return false;\n+\n   while (node != node2 && node2)\n     node2 = node2->clone_of;\n   return node2 != NULL;\n@@ -2649,10 +2671,8 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n   if (e->callee->former_clone_of != node->decl\n-      /* IPA-CP sometimes redirect edge to clone and then back to the former\n-\t function.  This ping-pong has to go, eventually.  */\n       && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n-      && !clone_of_p (cgraph_function_or_thunk_node (node, NULL), e->callee))\n+      && !clone_of_p (node, e->callee))\n     return true;\n   else\n     return false;"}, {"sha": "15310d8886100833342c998ccb53fa388fe6b971", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -890,7 +890,7 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tunsigned, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n \t\t\t\t\tint, bool, vec<cgraph_edge_p>,\n-\t\t\t\t\tbool, struct cgraph_node *);\n+\t\t\t\t\tbool, struct cgraph_node *, bitmap);\n tree clone_function_name (tree decl, const char *);\n struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t                          vec<cgraph_edge_p>,"}, {"sha": "257939cb022bece46ea59d34315503234c8c592c", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 211, "deletions": 122, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -168,6 +168,212 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n   return new_edge;\n }\n \n+/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP and the\n+   return value if SKIP_RETURN is true.  */\n+\n+static tree\n+build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n+\t\t\t       bool skip_return)\n+{\n+  tree new_type = NULL;\n+  tree args, new_args = NULL, t;\n+  tree new_reversed;\n+  int i = 0;\n+\n+  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n+       args = TREE_CHAIN (args), i++)\n+    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n+      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n+\n+  new_reversed = nreverse (new_args);\n+  if (args)\n+    {\n+      if (new_reversed)\n+        TREE_CHAIN (new_args) = void_list_node;\n+      else\n+\tnew_reversed = void_list_node;\n+    }\n+\n+  /* Use copy_node to preserve as much as possible from original type\n+     (debug info, attribute lists etc.)\n+     Exception is METHOD_TYPEs must have THIS argument.\n+     When we are asked to remove it, we need to build new FUNCTION_TYPE\n+     instead.  */\n+  if (TREE_CODE (orig_type) != METHOD_TYPE\n+      || !args_to_skip\n+      || !bitmap_bit_p (args_to_skip, 0))\n+    {\n+      new_type = build_distinct_type_copy (orig_type);\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+    }\n+  else\n+    {\n+      new_type\n+        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n+\t\t\t\t\t\t\t new_reversed));\n+      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n+    }\n+\n+  if (skip_return)\n+    TREE_TYPE (new_type) = void_type_node;\n+\n+  /* This is a new type, not a copy of an old type.  Need to reassociate\n+     variants.  We can handle everything except the main variant lazily.  */\n+  t = TYPE_MAIN_VARIANT (orig_type);\n+  if (t != orig_type)\n+    {\n+      t = build_function_type_skip_args (t, args_to_skip, skip_return);\n+      TYPE_MAIN_VARIANT (new_type) = t;\n+      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new_type;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = new_type;\n+      TYPE_NEXT_VARIANT (new_type) = NULL;\n+    }\n+\n+  return new_type;\n+}\n+\n+/* Build variant of function decl ORIG_DECL skipping ARGS_TO_SKIP and the\n+   return value if SKIP_RETURN is true.\n+\n+   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n+   linked by TREE_CHAIN directly.  The caller is responsible for eliminating\n+   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n+\n+static tree\n+build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip,\n+\t\t\t       bool skip_return)\n+{\n+  tree new_decl = copy_node (orig_decl);\n+  tree new_type;\n+\n+  new_type = TREE_TYPE (orig_decl);\n+  if (prototype_p (new_type)\n+      || (skip_return && !VOID_TYPE_P (TREE_TYPE (new_type))))\n+    new_type\n+      = build_function_type_skip_args (new_type, args_to_skip, skip_return);\n+  TREE_TYPE (new_decl) = new_type;\n+\n+  /* For declarations setting DECL_VINDEX (i.e. methods)\n+     we expect first argument to be THIS pointer.   */\n+  if (args_to_skip && bitmap_bit_p (args_to_skip, 0))\n+    DECL_VINDEX (new_decl) = NULL_TREE;\n+\n+  /* When signature changes, we need to clear builtin info.  */\n+  if (DECL_BUILT_IN (new_decl)\n+      && args_to_skip\n+      && !bitmap_empty_p (args_to_skip))\n+    {\n+      DECL_BUILT_IN_CLASS (new_decl) = NOT_BUILT_IN;\n+      DECL_FUNCTION_CODE (new_decl) = (enum built_in_function) 0;\n+    }\n+  /* The FE might have information and assumptions about the other\n+     arguments.  */\n+  DECL_LANG_SPECIFIC (new_decl) = NULL;\n+  return new_decl;\n+}\n+\n+/* Set flags of NEW_NODE and its decl.  NEW_NODE is a newly created private\n+   clone or its thunk.  */\n+\n+static void\n+set_new_clone_decl_and_node_flags (cgraph_node *new_node)\n+{\n+  DECL_EXTERNAL (new_node->decl) = 0;\n+  DECL_COMDAT_GROUP (new_node->decl) = 0;\n+  TREE_PUBLIC (new_node->decl) = 0;\n+  DECL_COMDAT (new_node->decl) = 0;\n+  DECL_WEAK (new_node->decl) = 0;\n+  DECL_VIRTUAL_P (new_node->decl) = 0;\n+  DECL_STATIC_CONSTRUCTOR (new_node->decl) = 0;\n+  DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;\n+\n+  new_node->externally_visible = 0;\n+  new_node->local.local = 1;\n+  new_node->lowered = true;\n+}\n+\n+/* Duplicate thunk THUNK if necessary but make it to refer to NODE.\n+   ARGS_TO_SKIP, if non-NULL, determines which parameters should be omitted.\n+   Function can return NODE if no thunk is necessary, which can happen when\n+   thunk is this_adjusting but we are removing this parameter.  */\n+\n+static cgraph_node *\n+duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node,\n+\t\t\t  bitmap args_to_skip)\n+{\n+  cgraph_node *new_thunk, *thunk_of;\n+  thunk_of = cgraph_function_or_thunk_node (thunk->callees->callee);\n+\n+  if (thunk_of->thunk.thunk_p)\n+    node = duplicate_thunk_for_node (thunk_of, node, args_to_skip);\n+\n+  struct cgraph_edge *cs;\n+  for (cs = node->callers; cs; cs = cs->next_caller)\n+    if (cs->caller->thunk.thunk_p\n+\t&& cs->caller->thunk.this_adjusting == thunk->thunk.this_adjusting\n+\t&& cs->caller->thunk.fixed_offset == thunk->thunk.fixed_offset\n+\t&& cs->caller->thunk.virtual_offset_p == thunk->thunk.virtual_offset_p\n+\t&& cs->caller->thunk.virtual_value == thunk->thunk.virtual_value)\n+      return cs->caller;\n+\n+  tree new_decl;\n+  if (!args_to_skip)\n+    new_decl = copy_node (thunk->decl);\n+  else\n+    {\n+      /* We do not need to duplicate this_adjusting thunks if we have removed\n+\t this.  */\n+      if (thunk->thunk.this_adjusting\n+\t  && bitmap_bit_p (args_to_skip, 0))\n+\treturn node;\n+\n+      new_decl = build_function_decl_skip_args (thunk->decl, args_to_skip,\n+\t\t\t\t\t\tfalse);\n+    }\n+  gcc_checking_assert (!DECL_STRUCT_FUNCTION (new_decl));\n+  gcc_checking_assert (!DECL_INITIAL (new_decl));\n+  gcc_checking_assert (!DECL_RESULT (new_decl));\n+  gcc_checking_assert (!DECL_RTL_SET_P (new_decl));\n+\n+  DECL_NAME (new_decl) = clone_function_name (thunk->decl, \"artificial_thunk\");\n+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+  DECL_SECTION_NAME (new_decl) = NULL;\n+\n+  new_thunk = cgraph_create_node (new_decl);\n+  set_new_clone_decl_and_node_flags (new_thunk);\n+  new_thunk->definition = true;\n+  new_thunk->thunk = thunk->thunk;\n+  new_thunk->unique_name = in_lto_p;\n+  new_thunk->former_clone_of = thunk->decl;\n+\n+  struct cgraph_edge *e = cgraph_create_edge (new_thunk, node, NULL, 0,\n+\t\t\t\t\t      CGRAPH_FREQ_BASE);\n+  e->call_stmt_cannot_inline_p = true;\n+  cgraph_call_edge_duplication_hooks (thunk->callees, e);\n+  if (!expand_thunk (new_thunk, false))\n+    new_thunk->analyzed = true;\n+  cgraph_call_node_duplication_hooks (thunk, new_thunk);\n+  return new_thunk;\n+}\n+\n+/* If E does not lead to a thunk, simply redirect it to N.  Otherwise create\n+   one or more equivalent thunks for N and redirect E to the first in the\n+   chain.  */\n+\n+void\n+redirect_edge_duplicating_thunks (struct cgraph_edge *e, struct cgraph_node *n,\n+\t\t\t\t  bitmap args_to_skip)\n+{\n+  cgraph_node *orig_to = cgraph_function_or_thunk_node (e->callee);\n+  if (orig_to->thunk.thunk_p)\n+    n = duplicate_thunk_for_node (orig_to, n, args_to_skip);\n+\n+  cgraph_redirect_edge_callee (e, n);\n+}\n \n /* Create node representing clone of N executed COUNT times.  Decrease\n    the execution counts from original node too.\n@@ -190,7 +396,8 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \t\t   bool update_original,\n \t\t   vec<cgraph_edge_p> redirect_callers,\n \t\t   bool call_duplication_hook,\n-\t\t   struct cgraph_node *new_inlined_to)\n+\t\t   struct cgraph_node *new_inlined_to,\n+\t\t   bitmap args_to_skip)\n {\n   struct cgraph_node *new_node = cgraph_create_empty_node ();\n   struct cgraph_edge *e;\n@@ -243,7 +450,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n       if (!e->callee\n \t  || DECL_BUILT_IN_CLASS (e->callee->decl) != BUILT_IN_NORMAL\n \t  || DECL_FUNCTION_CODE (e->callee->decl) != BUILT_IN_UNREACHABLE)\n-        cgraph_redirect_edge_callee (e, new_node);\n+        redirect_edge_duplicating_thunks (e, new_node, args_to_skip);\n     }\n \n \n@@ -292,114 +499,6 @@ clone_function_name (tree decl, const char *suffix)\n   return get_identifier (tmp_name);\n }\n \n-/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.  */\n-\n-static tree\n-build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n-\t\t\t       bool skip_return)\n-{\n-  tree new_type = NULL;\n-  tree args, new_args = NULL, t;\n-  tree new_reversed;\n-  int i = 0;\n-\n-  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n-       args = TREE_CHAIN (args), i++)\n-    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n-      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n-\n-  new_reversed = nreverse (new_args);\n-  if (args)\n-    {\n-      if (new_reversed)\n-        TREE_CHAIN (new_args) = void_list_node;\n-      else\n-\tnew_reversed = void_list_node;\n-    }\n-\n-  /* Use copy_node to preserve as much as possible from original type\n-     (debug info, attribute lists etc.)\n-     Exception is METHOD_TYPEs must have THIS argument.\n-     When we are asked to remove it, we need to build new FUNCTION_TYPE\n-     instead.  */\n-  if (TREE_CODE (orig_type) != METHOD_TYPE\n-      || !args_to_skip\n-      || !bitmap_bit_p (args_to_skip, 0))\n-    {\n-      new_type = build_distinct_type_copy (orig_type);\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n-    }\n-  else\n-    {\n-      new_type\n-        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n-\t\t\t\t\t\t\t new_reversed));\n-      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n-    }\n-\n-  if (skip_return)\n-    TREE_TYPE (new_type) = void_type_node;\n-\n-  /* This is a new type, not a copy of an old type.  Need to reassociate\n-     variants.  We can handle everything except the main variant lazily.  */\n-  t = TYPE_MAIN_VARIANT (orig_type);\n-  if (t != orig_type)\n-    {\n-      t = build_function_type_skip_args (t, args_to_skip, skip_return);\n-      TYPE_MAIN_VARIANT (new_type) = t;\n-      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = new_type;\n-    }\n-  else\n-    {\n-      TYPE_MAIN_VARIANT (new_type) = new_type;\n-      TYPE_NEXT_VARIANT (new_type) = NULL;\n-    }\n-\n-  return new_type;\n-}\n-\n-/* Build variant of function decl ORIG_DECL skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.\n-\n-   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n-   linked by TREE_CHAIN directly.  The caller is responsible for eliminating\n-   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n-\n-static tree\n-build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip,\n-\t\t\t       bool skip_return)\n-{\n-  tree new_decl = copy_node (orig_decl);\n-  tree new_type;\n-\n-  new_type = TREE_TYPE (orig_decl);\n-  if (prototype_p (new_type)\n-      || (skip_return && !VOID_TYPE_P (TREE_TYPE (new_type))))\n-    new_type\n-      = build_function_type_skip_args (new_type, args_to_skip, skip_return);\n-  TREE_TYPE (new_decl) = new_type;\n-\n-  /* For declarations setting DECL_VINDEX (i.e. methods)\n-     we expect first argument to be THIS pointer.   */\n-  if (args_to_skip && bitmap_bit_p (args_to_skip, 0))\n-    DECL_VINDEX (new_decl) = NULL_TREE;\n-\n-  /* When signature changes, we need to clear builtin info.  */\n-  if (DECL_BUILT_IN (new_decl)\n-      && args_to_skip\n-      && !bitmap_empty_p (args_to_skip))\n-    {\n-      DECL_BUILT_IN_CLASS (new_decl) = NOT_BUILT_IN;\n-      DECL_FUNCTION_CODE (new_decl) = (enum built_in_function) 0;\n-    }\n-  /* The FE might have information and assumptions about the other\n-     arguments.  */\n-  DECL_LANG_SPECIFIC (new_decl) = NULL;\n-  return new_decl;\n-}\n-\n /* Create callgraph node clone with new declaration.  The actual body will\n    be copied later at compilation stage.\n \n@@ -453,22 +552,15 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \n   new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n \t\t\t\tCGRAPH_FREQ_BASE, false,\n-\t\t\t\tredirect_callers, false, NULL);\n+\t\t\t\tredirect_callers, false, NULL, args_to_skip);\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  DECL_EXTERNAL (new_node->decl) = 0;\n   if (DECL_ONE_ONLY (old_decl))\n     DECL_SECTION_NAME (new_node->decl) = NULL;\n-  DECL_COMDAT_GROUP (new_node->decl) = 0;\n-  TREE_PUBLIC (new_node->decl) = 0;\n-  DECL_COMDAT (new_node->decl) = 0;\n-  DECL_WEAK (new_node->decl) = 0;\n-  DECL_VIRTUAL_P (new_node->decl) = 0;\n-  DECL_STATIC_CONSTRUCTOR (new_node->decl) = 0;\n-  DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;\n+  set_new_clone_decl_and_node_flags (new_node);\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n \n@@ -508,9 +600,6 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n     }\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n-  new_node->externally_visible = 0;\n-  new_node->local.local = 1;\n-  new_node->lowered = true;\n \n   cgraph_call_node_duplication_hooks (old_node, new_node);\n "}, {"sha": "a45aab118fdfdec08684cb38580b8baced8e846c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -184,7 +184,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    freq_scale = e->frequency;\n \t  n = cgraph_clone_node (e->callee, e->callee->decl,\n \t\t\t\t e->count, freq_scale, update_original,\n-\t\t\t\t vNULL, true, inlining_into);\n+\t\t\t\t vNULL, true, inlining_into, NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }"}, {"sha": "4051819404066b561619306173350dec640c12fd", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -1383,7 +1383,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t  /* We need original clone to copy around.  */\n \t  master_clone = cgraph_clone_node (node, node->decl,\n \t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t    false, vNULL, true, NULL);\n+\t\t\t\t\t    false, vNULL, true, NULL, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL, CGRAPH_FREQ_BASE);"}, {"sha": "6206de6d70a455d72f5d868b41bcb1059413e729", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -1042,7 +1042,7 @@ input_node (struct lto_file_decl_data *file_data,\n     {\n       node = cgraph_clone_node (cgraph (nodes[clone_ref]), fn_decl,\n \t\t\t\t0, CGRAPH_FREQ_BASE, false,\n-\t\t\t\tvNULL, false, NULL);\n+\t\t\t\tvNULL, false, NULL, NULL);\n     }\n   else\n     {"}, {"sha": "a8268b939da7dfaa75f14cdbdf5f59e7e2563ef0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -1,3 +1,11 @@\n+2014-04-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/60640\n+        * g++.dg/ipa/pr60640-1.C: New test.\n+        * g++.dg/ipa/pr60640-2.C: Likewise.\n+        * g++.dg/ipa/pr60640-3.C: Likewise.\n+        * g++.dg/ipa/pr60640-4.C: Likewise.\n+\n 2014-04-04  Jeff Law  <law@redhat.com>\n \n \tPR target/60657"}, {"sha": "7a0b91893f8d4cf580eb004b68ea59d52cdae9e5", "filename": "gcc/testsuite/g++.dg/ipa/pr60640-1.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-1.C?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do compile }\n+// { dg-options \"-O3\" }\n+\n+class ASN1Object\n+{\n+public:\n+  virtual ~ASN1Object ();\n+};\n+class A\n+{\n+  virtual unsigned m_fn1 () const;\n+};\n+class B\n+{\n+public:\n+  ASN1Object Element;\n+  virtual unsigned m_fn1 (bool) const;\n+};\n+template <class BASE> class C : public BASE\n+{\n+};\n+\n+class D : ASN1Object, public B\n+{\n+};\n+class G : public D\n+{\n+  unsigned m_fn1 (bool) const {}\n+};\n+class F : A\n+{\n+public:\n+  F (A);\n+  unsigned m_fn1 () const\n+  {\n+    int a;\n+    a = m_fn2 ().m_fn1 (0);\n+    return a;\n+  }\n+  const B &m_fn2 () const { return m_groupParameters; }\n+  C<G> m_groupParameters;\n+};\n+template <class D> void BenchMarkKeyAgreement (int *, int *, int)\n+{\n+  A f;\n+  D d (f);\n+}\n+\n+void BenchmarkAll2 () { BenchMarkKeyAgreement<F>(0, 0, 0); }\n+"}, {"sha": "c6e614cc0047b5bd3f58d3e1e2a3ce56c1cccccc", "filename": "gcc/testsuite/g++.dg/ipa/pr60640-2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-2.C?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-O3\" }\n+\n+struct B { virtual unsigned f () const; };\n+struct C { virtual void f (); };\n+struct F { virtual unsigned f (bool) const; ~F (); };\n+struct J : C, F {};\n+struct G : J { unsigned f (bool) const { return 0; } };\n+struct H : B\n+{\n+  H (int);\n+  unsigned f () const { return ((const F &) h).f (0); }\n+  G h;\n+};\n+H h (0);"}, {"sha": "21b1f58a0407d21b957affac63a233aa4da2307a", "filename": "gcc/testsuite/g++.dg/ipa/pr60640-3.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-3.C?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -0,0 +1,81 @@\n+// { dg-do run }\n+// { dg-options \"-O3\" }\n+\n+struct Distraction\n+{\n+  char fc[8];\n+  virtual Distraction * return_self ()\n+  { return this; }\n+};\n+\n+namespace {\n+\n+struct A;\n+static A * __attribute__ ((noinline, noclone)) get_an_A ();\n+\n+static int go;\n+\n+struct A\n+{\n+  int fi;\n+\n+  A () : fi(777) {}\n+  A (int pi) : fi (pi) {}\n+  virtual A * foo (int p) = 0;\n+};\n+\n+struct B;\n+static B * __attribute__ ((noinline, noclone)) get_a_B ();\n+\n+struct B : public Distraction, A\n+{\n+  B () : Distraction(), A() { }\n+  B (int pi) : Distraction (), A (pi) {}\n+  virtual B * foo (int p)\n+  {\n+    int o = fi;\n+    for (int i = 0; i < p; i++)\n+      o += i + i * i;\n+    go = o;\n+\n+    return get_a_B ();\n+  }\n+};\n+\n+\n+struct B gb1 (1111), gb2 (2);\n+static B * __attribute__ ((noinline, noclone))\n+get_a_B ()\n+{\n+  return &gb1;\n+}\n+\n+static A * __attribute__ ((noinline, noclone))\n+get_an_A ()\n+{\n+  return &gb2;\n+}\n+\n+}\n+\n+static int __attribute__ ((noinline, noclone))\n+get_a_number ()\n+{\n+  return 5;\n+}\n+\n+extern \"C\" void abort (void);\n+\n+int main (int argc, char *argv[])\n+{\n+  for (int i = 0; i < get_a_number (); i++)\n+    {\n+      struct A *p = get_an_A ();\n+      struct A *r = p->foo (4);\n+      if (r->fi != 1111)\n+\tabort ();\n+      if (go != 22)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "eb9eb627f85cab48df16edfe1070d1f4bc1d7303", "filename": "gcc/testsuite/g++.dg/ipa/pr60640-4.C", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610c8ef0a420e5267cbccd5a4509f0ce3095e14c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr60640-4.C?ref=610c8ef0a420e5267cbccd5a4509f0ce3095e14c", "patch": "@@ -0,0 +1,85 @@\n+// { dg-do run }\n+// { dg-options \"-O3 -fdump-ipa-cp\" }\n+\n+struct Distraction\n+{\n+  char fc[8];\n+  virtual Distraction * return_self ()\n+  { return this; }\n+};\n+\n+namespace {\n+\n+struct A;\n+static A * __attribute__ ((noinline, noclone)) get_an_A ();\n+\n+static int go;\n+\n+struct A\n+{\n+  int fi;\n+\n+  A () : fi(777) {}\n+  A (int pi) : fi (pi) {}\n+  virtual void foo (int p) = 0;\n+};\n+\n+struct B : public Distraction, A\n+{\n+  B () : Distraction(), A() { }\n+  B (int pi) : Distraction (), A (pi) {}\n+  virtual void foo (int p)\n+  {\n+    int o = fi;\n+    for (int i = 0; i < p; i++)\n+      o += i + i * i;\n+    go = o;\n+  }\n+};\n+\n+\n+struct B gb (2);\n+static A * __attribute__ ((noinline, noclone))\n+get_an_A ()\n+{\n+  return &gb;\n+}\n+\n+}\n+\n+static int __attribute__ ((noinline, noclone))\n+get_a_number ()\n+{\n+  return 5;\n+}\n+\n+extern \"C\" void abort (void);\n+\n+static void __attribute__ ((noinline, noclone))\n+bar ()\n+{\n+  for (int i = 0; i < get_a_number (); i++)\n+    {\n+      struct A *p = get_an_A ();\n+      p->foo (4);\n+      if (go != 22)\n+\tabort ();\n+    }\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  for (int i = 0; i < get_a_number (); i++)\n+    {\n+      struct A *p = get_an_A ();\n+      p->foo (4);\n+      if (go != 22)\n+\tabort ();\n+    }\n+\n+  bar ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"Thunk fixed offset\" 2 \"cp\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}]}