{"sha": "98ad5807938624cd8ceceec07250147f8783552f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhZDU4MDc5Mzg2MjRjZDhjZWNlZWMwNzI1MDE0N2Y4NzgzNTUyZg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-27T06:34:29Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-27T06:34:29Z"}, "message": "2003-05-27  Michael Koch  <konqueror@gmx.de>\n\n\t* java/util/zip/Deflater.java\n\t(FILTERED): Merged documentation from classpath.\n\t* java/util/zip/DeflaterOutputStream.java\n\t(DeflaterOutputStream): Merged documentation and argument validity\n\tcheck from classpath.\n\t(deflate): Merged documentation from classpath.\n\t(finish): Likewise.\n\t* java/util/zip/Inflater.java\n\t(Inflater): Merged class documentation from classpath.\n\t(zstream): Reordered.\n\t(is_finished): Reordered.\n\t(dict_needed): Reordered.\n\t(Inflater): Reordered, merged documentation from classpath.\n\t(end): Likewise.\n\t(finalize): Merged documentation from classpath.\n\t(finished): Likewise.\n\t(getAdler): Likewise.\n\t(getRemaining): Likewise.\n\t(getTotalIn): Likewise.\n\t(getTotalOut): Likewise.\n\t(inflate): Likewise.\n\t(needsDictionary): Likewise.\n\t(needsInput): Likewise.\n\t(reset): Likewise.\n\t(setDictionary): Likewise.\n\t(setInput): Likewise.\n\nFrom-SVN: r67185", "tree": {"sha": "49e3538d1fb5c0bd4b237abb3fee1421c2b585bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e3538d1fb5c0bd4b237abb3fee1421c2b585bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98ad5807938624cd8ceceec07250147f8783552f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ad5807938624cd8ceceec07250147f8783552f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ad5807938624cd8ceceec07250147f8783552f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ad5807938624cd8ceceec07250147f8783552f/comments", "author": null, "committer": null, "parents": [{"sha": "5191f392bb445f50d7e7fefa50f7125ba9e618ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5191f392bb445f50d7e7fefa50f7125ba9e618ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5191f392bb445f50d7e7fefa50f7125ba9e618ef"}], "stats": {"total": 262, "additions": 235, "deletions": 27}, "files": [{"sha": "005410a6c9eda2eadc833bff7d418359c1652cb5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ad5807938624cd8ceceec07250147f8783552f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ad5807938624cd8ceceec07250147f8783552f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=98ad5807938624cd8ceceec07250147f8783552f", "patch": "@@ -1,3 +1,32 @@\n+2003-05-27  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/util/zip/Deflater.java\n+\t(FILTERED): Merged documentation from classpath.\n+\t* java/util/zip/DeflaterOutputStream.java\n+\t(DeflaterOutputStream): Merged documentation and argument validity\n+\tcheck from classpath.\n+\t(deflate): Merged documentation from classpath.\n+\t(finish): Likewise.\n+\t* java/util/zip/Inflater.java\n+\t(Inflater): Merged class documentation from classpath.\n+\t(zstream): Reordered.\n+\t(is_finished): Reordered.\n+\t(dict_needed): Reordered.\n+\t(Inflater): Reordered, merged documentation from classpath.\n+\t(end): Likewise.\n+\t(finalize): Merged documentation from classpath.\n+\t(finished): Likewise.\n+\t(getAdler): Likewise.\n+\t(getRemaining): Likewise.\n+\t(getTotalIn): Likewise.\n+\t(getTotalOut): Likewise.\n+\t(inflate): Likewise.\n+\t(needsDictionary): Likewise.\n+\t(needsInput): Likewise.\n+\t(reset): Likewise.\n+\t(setDictionary): Likewise.\n+\t(setInput): Likewise.\n+\n 2003-05-27  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/URLConnection.java"}, {"sha": "52c569a412a4eb6553546a68b041b82e1e04f1d5", "filename": "libjava/java/util/zip/Deflater.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java?ref=98ad5807938624cd8ceceec07250147f8783552f", "patch": "@@ -48,7 +48,6 @@\n  * and JCL book.\n  * Believed complete and correct.\n  */\n-\n public class Deflater\n {\n   /**\n@@ -73,6 +72,10 @@\n    * The default strategy.\n    */\n   public static final int DEFAULT_STRATEGY = 0;\n+  /**\n+   * This strategy will only allow longer string repetitions.  It is\n+   * useful for random data with a small character set.\n+   */\n   public static final int FILTERED = 1;\n \n   /** "}, {"sha": "ff66b080f9ef2976d19d463ea6eea1343b7d0145", "filename": "libjava/java/util/zip/DeflaterOutputStream.java", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java?ref=98ad5807938624cd8ceceec07250147f8783552f", "patch": "@@ -56,6 +56,7 @@\n  * finishing the stream.\n  *\n  * @author Tom Tromey, Jochen Hoenicke\n+ * @date Jan 11, 2001 \n  */\n public class DeflaterOutputStream extends FilterOutputStream\n {\n@@ -65,6 +66,11 @@ public void close () throws IOException\n     out.close();\n   }\n \n+  /**\n+   * Deflates everything in the def's input buffers.  This will call\n+   * <code>def.deflate()</code> until all bytes from the input buffers\n+   * are processed.\n+   */\n   protected void deflate () throws IOException\n   {\n     do\n@@ -76,23 +82,49 @@ protected void deflate () throws IOException\n     while (! def.needsInput());\n   }\n \n+  /** \n+   * Creates a new DeflaterOutputStream with a default Deflater and\n+   * default buffer size.\n+   * @param out the output stream where deflated output should be written.\n+   */\n   public DeflaterOutputStream (OutputStream out)\n   {\n     this (out, new Deflater (), 512);\n   }\n \n+  /** \n+   * Creates a new DeflaterOutputStream with the given Deflater and\n+   * default buffer size.\n+   * @param out the output stream where deflated output should be written.\n+   * @param defl the underlying deflater.\n+   */\n   public DeflaterOutputStream (OutputStream out, Deflater defl)\n   {\n     this (out, defl, 512);\n   }\n \n+  /** \n+   * Creates a new DeflaterOutputStream with the given Deflater and\n+   * buffer size.\n+   * @param out the output stream where deflated output should be written.\n+   * @param defl the underlying deflater.\n+   * @param bufsize the buffer size.\n+   * @exception IllegalArgumentException if bufsize isn't positive.\n+   */\n   public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)\n   {\n     super (out);\n+    if (bufsize <= 0)\n+      throw new IllegalArgumentException(\"bufsize <= 0\");\n     buf = new byte[bufsize];\n     def = defl;\n   }\n \n+  /**\n+   * Finishes the stream by calling finish() on the deflater.  This\n+   * was the only way to ensure that all bytes are flushed in Sun's\n+   * JDK.  \n+   */\n   public void finish () throws IOException\n   {\n     if (inbufLength > 0)"}, {"sha": "28e89ea4449a3afb5639d5d794867324f1aab349", "filename": "libjava/java/util/zip/Inflater.java", "status": "modified", "additions": 170, "deletions": 26, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FInflater.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98ad5807938624cd8ceceec07250147f8783552f/libjava%2Fjava%2Futil%2Fzip%2FInflater.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflater.java?ref=98ad5807938624cd8ceceec07250147f8783552f", "patch": "@@ -1,5 +1,5 @@\n /* Inflater.java - Decompress a data stream\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,87 +39,231 @@\n \n import gnu.gcj.RawData;\n \n-/**\n- * @author Tom Tromey\n- * @date May 17, 1999\n- */\n-\n /* Written using on-line Java Platform 1.2 API Specification\n  * and JCL book.\n  * Believed complete and correct.\n  */\n \n+/**\n+ * Inflater is used to decompress data that has been compressed according \n+ * to the \"deflate\" standard described in rfc1950.\n+ *\n+ * The usage is as following.  First you have to set some input with\n+ * <code>setInput()</code>, then inflate() it.  If inflate doesn't\n+ * inflate any bytes there may be three reasons:\n+ * <ul>\n+ * <li>needsInput() returns true because the input buffer is empty.\n+ * You have to provide more input with <code>setInput()</code>.  \n+ * NOTE: needsInput() also returns true when, the stream is finished.\n+ * </li>\n+ * <li>needsDictionary() returns true, you have to provide a preset \n+ *     dictionary with <code>setDictionary()</code>.</li>\n+ * <li>finished() returns true, the inflater has finished.</li>\n+ * </ul>\n+ * Once the first output byte is produced, a dictionary will not be\n+ * needed at a later stage.\n+ *\n+ * @author John Leuner, Jochen Hoenicke\n+ * @author Tom Tromey\n+ * @date May 17, 1999\n+ * @since JDK 1.1\n+ */\n public class Inflater\n {\n-  public native void end ();\n+  // The zlib stream.\n+  private RawData zstream;\n+\n+  // True if finished.\n+  private boolean is_finished;\n+\n+  // True if dictionary needed.\n+  private boolean dict_needed;\n+\n+  /**\n+   * Creates a new inflater.\n+   */\n+  public Inflater ()\n+  {\n+    this (false);\n+  }\n+\n+  /**\n+   * Creates a new inflater.\n+   * @param nowrap true if no header and checksum field appears in the\n+   * stream.  This is used for GZIPed input.  For compatibility with\n+   * Sun JDK you should provide one byte of input more than needed in\n+   * this case.\n+   */\n+  public Inflater (boolean noHeader)\n+  {\n+    init (noHeader);\n+  }\n \n+  /**\n+   * Finalizes this object.\n+   */\n   protected void finalize ()\n   {\n     end ();\n   }\n \n+  /**\n+   * Frees all objects allocated by the inflater.  There's no reason\n+   * to call this, since you can just rely on garbage collection (even\n+   * for the Sun implementation).  Exists only for compatibility\n+   * with Sun's JDK, where the compressor allocates native memory.\n+   * If you call any method (even reset) afterwards the behaviour is\n+   * <i>undefined</i>.  \n+   * @deprecated Just clear all references to inflater instead.\n+   */\n+  public native void end ();\n+\n+  /**\n+   * Returns true, if the inflater has finished.  This means, that no\n+   * input is needed and no output can be produced.\n+   */\n   public synchronized boolean finished ()\n   {\n     return is_finished;\n   }\n \n+  /**\n+   * Gets the adler checksum.  This is either the checksum of all\n+   * uncompressed bytes returned by inflate(), or if needsDictionary()\n+   * returns true (and thus no output was yet produced) this is the\n+   * adler checksum of the expected dictionary.\n+   * @returns the adler checksum.\n+   */\n   public native int getAdler ();\n+  \n+  /**\n+   * Gets the number of unprocessed input.  Useful, if the end of the\n+   * stream is reached and you want to further process the bytes after\n+   * the deflate stream.  \n+   * @return the number of bytes of the input which were not processed.\n+   */\n   public native int getRemaining ();\n+  \n+  /**\n+   * Gets the total number of processed compressed input bytes.\n+   * @return the total number of bytes of processed input bytes.\n+   */\n   public native int getTotalIn ();\n+\n+  /**\n+   * Gets the total number of output bytes returned by inflate().\n+   * @return the total number of output bytes.\n+   */\n   public native int getTotalOut ();\n \n+  /**\n+   * Inflates the compressed stream to the output buffer.  If this\n+   * returns 0, you should check, whether needsDictionary(),\n+   * needsInput() or finished() returns true, to determine why no \n+   * further output is produced.\n+   * @param buffer the output buffer.\n+   * @return the number of bytes written to the buffer, 0 if no further\n+   * output can be produced.  \n+   * @exception DataFormatException if deflated stream is invalid.\n+   * @exception IllegalArgumentException if buf has length 0.\n+   */\n   public int inflate (byte[] buf) throws DataFormatException\n   {\n     return inflate (buf, 0, buf.length);\n   }\n \n+  /**\n+   * Inflates the compressed stream to the output buffer.  If this\n+   * returns 0, you should check, whether needsDictionary(),\n+   * needsInput() or finished() returns true, to determine why no \n+   * further output is produced.\n+   * @param buffer the output buffer.\n+   * @param off the offset into buffer where the output should start.\n+   * @param len the maximum length of the output.\n+   * @return the number of bytes written to the buffer, 0 if no further\n+   * output can be produced.  \n+   * @exception DataFormatException if deflated stream is invalid.\n+   * @exception IndexOutOfBoundsException if the off and/or len are wrong.\n+   */\n   public native int inflate (byte[] buf, int off, int len)\n     throws DataFormatException;\n \n   private native void init (boolean noHeader);\n \n-  public Inflater ()\n-  {\n-    this (false);\n-  }\n-\n-  public Inflater (boolean noHeader)\n-  {\n-    init (noHeader);\n-  }\n-\n+  /**\n+   * Returns true, if a preset dictionary is needed to inflate the input.\n+   */\n   public synchronized boolean needsDictionary ()\n   {\n     return dict_needed;\n   }\n \n+  /**\n+   * Returns true, if the input buffer is empty.\n+   * You should then call setInput(). <br>\n+   *\n+   * <em>NOTE</em>: This method also returns true when the stream is finished.\n+   */\n   public synchronized boolean needsInput ()\n   {\n     return getRemaining () == 0;\n   }\n \n+  /**\n+   * Resets the inflater so that a new stream can be decompressed.  All\n+   * pending input and output will be discarded.\n+   */\n   public native void reset ();\n \n+  /**\n+   * Sets the preset dictionary.  This should only be called, if\n+   * needsDictionary() returns true and it should set the same\n+   * dictionary, that was used for deflating.  The getAdler()\n+   * function returns the checksum of the dictionary needed.\n+   * @param buffer the dictionary.\n+   * @exception IllegalStateException if no dictionary is needed.\n+   * @exception IllegalArgumentException if the dictionary checksum is\n+   * wrong.  \n+   */\n   public void setDictionary (byte[] buf)\n   {\n     setDictionary (buf, 0, buf.length);\n   }\n \n+  /**\n+   * Sets the preset dictionary.  This should only be called, if\n+   * needsDictionary() returns true and it should set the same\n+   * dictionary, that was used for deflating.  The getAdler()\n+   * function returns the checksum of the dictionary needed.\n+   * @param buffer the dictionary.\n+   * @param off the offset into buffer where the dictionary starts.\n+   * @param len the length of the dictionary.\n+   * @exception IllegalStateException if no dictionary is needed.\n+   * @exception IllegalArgumentException if the dictionary checksum is\n+   * wrong.  \n+   * @exception IndexOutOfBoundsException if the off and/or len are wrong.\n+   */\n   public native void setDictionary (byte[] buf, int off, int len);\n \n+  /**\n+   * Sets the input.  This should only be called, if needsInput()\n+   * returns true.\n+   * @param buffer the input.\n+   * @exception IllegalStateException if no input is needed.\n+   */\n   public void setInput (byte[] buf)\n   {\n     setInput (buf, 0, buf.length);\n   }\n \n+  /**\n+   * Sets the input.  This should only be called, if needsInput()\n+   * returns true.\n+   * @param buffer the input.\n+   * @param off the offset into buffer where the input starts.\n+   * @param len the length of the input.  \n+   * @exception IllegalStateException if no input is needed.\n+   * @exception IndexOutOfBoundsException if the off and/or len are wrong.\n+   */\n   public native void setInput (byte[] buf, int off, int len);\n-\n-  // The zlib stream.\n-  private RawData zstream;\n-\n-  // True if finished.\n-  private boolean is_finished;\n-\n-  // True if dictionary needed.\n-  private boolean dict_needed;\n }"}]}