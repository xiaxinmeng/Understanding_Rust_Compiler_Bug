{"sha": "88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhkMGMzZjBhMTQ0OGU3MWRjZjQ5YzJmMzQ5MDllYzhkN2NlMzQ4Zg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-09-21T01:39:27Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-09-21T01:39:27Z"}, "message": "PR middle-end/49905 - Better sanity checking on sprintf src & dest to\n\ngcc/ChangeLog:\n\n\tPR middle-end/49905\n\t* Makefile.in (OBJS): Add gimple-ssa-sprintf.o.\n\t* config/linux.h (TARGET_PRINTF_POINTER_FORMAT): Redefine.\n\t* config/linux.c (gnu_libc_printf_pointer_format): New function.\n\t* config/sol2.h (TARGET_PRINTF_POINTER_FORMAT): Same.\n\t* config/sol2.c (solaris_printf_pointer_format): New function.\n\t* doc/invoke.texi (-Wformat-length, -fprintf-return-value): New\n\toptions.\n\t* doc/tm.texi.in (TARGET_PRINTF_POINTER_FORMAT): Document.\n\t* doc/tm.texi: Regenerate.\n\t* gimple-fold.h (get_range_strlen): New function.\n\t(get_maxval_strlen): Declare existing function.\n\t* gimple-fold.c (get_range_strlen): Add arguments and compute both\n\tmaximum and minimum.\n\t (get_range_strlen): Define overload.\n\t(get_maxval_strlen): Adjust.\n\t* gimple-ssa-sprintf.c: New file and pass.\n\t* passes.def (pass_sprintf_length): Add new pass.\n\t* targhooks.h (default_printf_pointer_format): Declare new function.\n\t(gnu_libc_printf_pointer_format): Same.\n\t(solaris_libc_printf_pointer_format): Same.\n\t* targhooks.c (default_printf_pointer_format): Define new function.\n\t* tree-pass.h (make_pass_sprintf_length): Declare new function.\n\t* print-tree.c: Increase buffer size.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/49905\n\t* c.opt: Add -Wformat-length and -fprintf-return-value.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/49905\n\t* gcc.dg/builtin-stringop-chk-1.c: Adjust.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: New test.\n\nFrom-SVN: r240298", "tree": {"sha": "31a2a49deedcccbfcfdac5857b76449a9235f4a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31a2a49deedcccbfcfdac5857b76449a9235f4a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6283a8db1fdcd3d505fabe0dca27e8fdf10c2ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6283a8db1fdcd3d505fabe0dca27e8fdf10c2ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6283a8db1fdcd3d505fabe0dca27e8fdf10c2ac7"}], "stats": {"total": 5713, "additions": 5683, "deletions": 30}, "files": [{"sha": "8ccafc548a0a9966177dfc1d8dc2b4911c59459e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1,3 +1,30 @@\n+2016-09-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/49905\n+\t* Makefile.in (OBJS): Add gimple-ssa-sprintf.o.\n+\t* config/linux.h (TARGET_PRINTF_POINTER_FORMAT): Redefine.\n+\t* config/linux.c (gnu_libc_printf_pointer_format): New function.\n+\t* config/sol2.h (TARGET_PRINTF_POINTER_FORMAT): Same.\n+\t* config/sol2.c (solaris_printf_pointer_format): New function.\n+\t* doc/invoke.texi (-Wformat-length, -fprintf-return-value): New\n+\toptions.\n+\t* doc/tm.texi.in (TARGET_PRINTF_POINTER_FORMAT): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* gimple-fold.h (get_range_strlen): New function.\n+\t(get_maxval_strlen): Declare existing function.\n+\t* gimple-fold.c (get_range_strlen): Add arguments and compute both\n+\tmaximum and minimum.\n+\t (get_range_strlen): Define overload.\n+\t(get_maxval_strlen): Adjust.\n+\t* gimple-ssa-sprintf.c: New file and pass.\n+\t* passes.def (pass_sprintf_length): Add new pass.\n+\t* targhooks.h (default_printf_pointer_format): Declare new function.\n+\t(gnu_libc_printf_pointer_format): Same.\n+\t(solaris_libc_printf_pointer_format): Same.\n+\t* targhooks.c (default_printf_pointer_format): Define new function.\n+\t* tree-pass.h (make_pass_sprintf_length): Declare new function.\n+\t* print-tree.c: Increase buffer size.\n+\n 2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t * tree-vrp.c (get_value_range): Teach PARM_DECL to use ipa-vrp"}, {"sha": "69ff9fa988da9010b7b68e79964997ee3018b37d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1296,6 +1296,7 @@ OBJS = \\\n \tgimple-ssa-nonnull-compare.o \\\n \tgimple-ssa-split-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n+\tgimple-ssa-sprintf.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\\n \tgimple-walk.o \\"}, {"sha": "da3fdd43aad4202dcd909153732f9811348a578d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1,3 +1,8 @@\n+2016-09-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/49905\n+\t* c.opt: Add -Wformat-length and -fprintf-return-value.\n+\n 2016-09-19  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR c++/77434"}, {"sha": "d01052d44e0b3f394d2e289fc81a4a10e47b3cdd", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -478,6 +478,11 @@ Wformat-extra-args\n C ObjC C++ ObjC++ Var(warn_format_extra_args) Warning LangEnabledBy(C ObjC C++ ObjC++,Wformat=, warn_format >= 1, 0)\n Warn if passing too many arguments to a function for its format string.\n \n+Wformat-length\n+C ObjC C++ ObjC++ Warning Alias(Wformat-length=, 1, 0)\n+Warn about function calls with format strings that write past the end\n+of the destination region.  Same as -Wformat-length=1.\n+\n Wformat-nonliteral\n C ObjC C++ ObjC++ Var(warn_format_nonliteral) Warning LangEnabledBy(C ObjC C++ ObjC++,Wformat=, warn_format >= 2, 0)\n Warn about format strings that are not literals.\n@@ -502,6 +507,11 @@ Wformat=\n C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_format) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall, 1, 0)\n Warn about printf/scanf/strftime/strfmon format string anomalies.\n \n+Wformat-length=\n+C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_format_length) Warning LangEnabledBy(C ObjC C++ ObjC++,Wformat=, warn_format >= 1, 0)\n+Warn about function calls with format strings that write past the end\n+of the destination region.\n+\n Wignored-qualifiers\n C C++ Var(warn_ignored_qualifiers) Warning EnabledBy(Wextra)\n Warn whenever type qualifiers are ignored.\n@@ -1487,6 +1497,10 @@ fpretty-templates\n C++ ObjC++ Var(flag_pretty_templates) Init(1)\n -fno-pretty-templates Do not pretty-print template specializations as the template signature followed by the arguments.\n \n+fprintf-return-value\n+C ObjC C++ ObjC++ LTO Optimization Var(flag_printf_return_value) Init(1)\n+Treat known sprintf return values as constants.\n+\n freplace-objc-classes\n ObjC ObjC++ LTO Var(flag_replace_objc_classes)\n Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime."}, {"sha": "9aac38b8658d58ad707a256c505c3b3ae55c2794", "filename": "gcc/config/linux.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Flinux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Flinux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -21,8 +21,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"tree.h\"\n #include \"linux-protos.h\"\n \n+#undef TARGET_PRINTF_POINTER_FORMAT\n+#define TARGET_PRINTF_POINTER_FORMAT gnu_libc_printf_pointer_format\n+\n bool\n linux_libc_has_function (enum function_class fn_class)\n {\n@@ -36,3 +40,16 @@ linux_libc_has_function (enum function_class fn_class)\n \n   return false;\n }\n+\n+/* Glibc formats pointers as if by \"%zx\" except for the null pointer\n+   which outputs \"(nil)\".  It ignores the pound ('#') format flag but\n+   interprets the space and plus flags the same as in the integer\n+   directive.  */\n+\n+const char*\n+gnu_libc_printf_pointer_format (tree arg, const char **flags)\n+{\n+  *flags = \" +\";\n+\n+  return arg && integer_zerop (arg) ? \"(nil)\" : \"%#zx\";\n+}"}, {"sha": "3ff005b90a2acde65fc5444137647a2483c909f9", "filename": "gcc/config/linux.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.h?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -208,3 +208,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n # define TARGET_LIBC_HAS_FUNCTION linux_libc_has_function\n \n #endif\n+\n+/* The format string to which \"%p\" corresponds.  */\n+#undef TARGET_PRINTF_POINTER_FORMAT\n+#define TARGET_PRINTF_POINTER_FORMAT gnu_libc_printf_pointer_format"}, {"sha": "30c525acbc347877c360af9be461a85b1b8ba56d", "filename": "gcc/config/sol2.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Fsol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Fsol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -30,6 +30,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"output.h\"\n \n+#undef TARGET_PRINTF_POINTER_FORMAT\n+#define TARGET_PRINTF_POINTER_FORMAT solaris_printf_pointer_format\n+\n tree solaris_pending_aligns, solaris_pending_inits, solaris_pending_finis;\n \n /* Attach any pending attributes for DECL to the list in *ATTRIBUTES.\n@@ -297,3 +300,14 @@ solaris_override_options (void)\n   if (!HAVE_LD_EH_FRAME_CIEV3 && !global_options_set.x_dwarf_version)\n     dwarf_version = 2;\n }\n+\n+/* Solaris libc formats pointers as if by \"%zx\" with the pound ('#')\n+   format flag having the same meaning as in the integer directive.  */\n+\n+const char*\n+solaris_printf_pointer_format (tree, const char **flags)\n+{\n+  *flags = \"#\";\n+\n+  return \"%zx\";\n+}"}, {"sha": "6f0270891f552e435552dfc10cd94793cde03db8", "filename": "gcc/config/sol2.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fconfig%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.h?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -440,6 +440,10 @@ along with GCC; see the file COPYING3.  If not see\n #undef TARGET_LIBC_HAS_FUNCTION\n #define TARGET_LIBC_HAS_FUNCTION default_libc_has_function\n \n+/* The format string to which \"%p\" corresponds.  */\n+#undef TARGET_LIBC_PRINTF_POINTER_FORMAT\n+#define TARGET_LIBC_PRINTF_POINTER_FORMAT solaris_libc_printf_pointer_format\n+\n extern GTY(()) tree solaris_pending_aligns;\n extern GTY(()) tree solaris_pending_inits;\n extern GTY(()) tree solaris_pending_finis;"}, {"sha": "cfba069cf2bb416479de565e429ee7a258ad6f3e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -268,7 +268,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-div-by-zero -Wdouble-promotion -Wduplicated-cond @gol\n -Wempty-body  -Wenum-compare -Wno-endif-labels @gol\n -Werror  -Werror=* -Wfatal-errors -Wfloat-equal  -Wformat  -Wformat=2 @gol\n--Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol\n+-Wno-format-contains-nul -Wno-format-extra-args -Wformat-length=@var{n} @gol\n+-Wformat-nonliteral @gol\n -Wformat-security  -Wformat-signedness  -Wformat-y2k -Wframe-address @gol\n -Wframe-larger-than=@var{len} -Wno-free-nonheap-object -Wjump-misses-init @gol\n -Wignored-qualifiers  -Wignored-attributes  -Wincompatible-pointer-types @gol\n@@ -379,7 +380,7 @@ Objective-C and Objective-C++ Dialects}.\n -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer -foptimize-sibling-calls @gol\n -fpartial-inlining -fpeel-loops -fpredictive-commoning @gol\n--fprefetch-loop-arrays @gol\n+-fprefetch-loop-arrays -fprintf-return-value @gol\n -fprofile-correction @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n -fprofile-reorder-functions @gol\n@@ -3888,6 +3889,88 @@ in the case of @code{scanf} formats, this option suppresses the\n warning if the unused arguments are all pointers, since the Single\n Unix Specification says that such unused arguments are allowed.\n \n+@item -Wformat-length\n+@itemx -Wformat-length=@var{level}\n+@opindex Wformat-length\n+@opindex Wno-format-length\n+Warn about calls to formatted input/output functions such as @code{sprintf}\n+that might overflow the destination buffer, or about bounded functions such\n+as @code{snprintf} that might result in output truncation.  When the exact\n+number of bytes written by a format directive cannot be determined at\n+compile-time it is estimated based on heuristics that depend on the\n+@var{level} argument and on optimization.  While enabling optimization\n+will in most cases improve the accuracy of the warning, it may also\n+result in false positives.\n+\n+@table @gcctabopt\n+@item -Wformat-length\n+@item -Wformat-length=1\n+@opindex Wformat-length\n+@opindex Wno-format-length\n+Level @var{1} of @option{-Wformat-length} enabled by @option{-Wformat}\n+employs a conservative approach that warns only about calls that most\n+likely overflow the buffer or result in output truncation.  At this\n+level, numeric arguments to format directives with unknown values are\n+assumed to have the value of one, and strings of unknown length to be\n+empty.  Numeric arguments that are known to be bounded to a subrange\n+of their type, or string arguments whose output is bounded either by\n+their directive's precision or by a finite set of string literals, are\n+assumed to take on the value within the range that results in the most\n+bytes on output.  For example, the call to @code{sprintf} below is\n+diagnosed because even with both @var{a} and @var{b} equal to zero,\n+the terminating NUL character (@code{'\\0'}) appended by the function\n+to the destination buffer will be written past its end.  Increasing\n+the size of the buffer by a single byte is sufficient to avoid the\n+warning, though it may not be sufficient to avoid the overflow.\n+\n+@smallexample\n+void f (int a, int b)\n+@{\n+  char buf [12];\n+  sprintf (buf, \"a = %i, b = %i\\n\", a, b);\n+@}\n+@end smallexample\n+\n+@item -Wformat-length=2\n+Level @var{2} warns also about calls that might overflow the destination\n+buffer or result in truncation given an argument of sufficient length\n+or magnitude.  At level @var{2}, unknown numeric arguments are assumed\n+to have the minimum representable value for signed types with a precision\n+greater than 1, and the maximum representable value otherwise.  Unknown\n+string arguments whose length cannot be assumed to be bounded either by\n+the directive's precision, or by a finite set of string literals they\n+may evaluate to, or the character array they may point to, are assumed\n+to be 1 character long.\n+\n+At level @var{2}, the call in the example above is again diagnosed, but\n+this time because with @var{a} equal to a 32-bit @code{INT_MIN} the first\n+@code{%i} directive will write some of its digits beyond the end of\n+the destination buffer.  To make the call safe regardless of the values\n+of the two variables, the size of the destination buffer must be increased\n+to at least 34 bytes.  GCC includes the minimum size of the buffer in\n+an informational note following the warning.\n+\n+An alternative to increasing the size of the destination buffer is to\n+constrain the range of formatted values.  The maximum length of string\n+arguments can be bounded by specifying the precision in the format\n+directive.  When numeric arguments of format directives can be assumed\n+to be bounded by less than the precision of their type, choosing\n+an appropriate length modifier to the format specifier will reduce\n+the required buffer size.  For example, if @var{a} and @var{b} in the\n+example above can be assumed to be within the precision of\n+the @code{short int} type then using either the @code{%hi} format\n+directive or casting the argument to @code{short} reduces the maximum\n+required size of the buffer to 24 bytes.\n+\n+@smallexample\n+void f (int a, int b)\n+@{\n+  char buf [23];\n+  sprintf (buf, \"a = %hi, b = %i\\n\", a, (short)b);\n+@}\n+@end smallexample\n+@end table\n+\n @item -Wno-format-zero-length\n @opindex Wno-format-zero-length\n @opindex Wformat-zero-length\n@@ -7855,6 +7938,30 @@ dependent on the structure of loops within the source code.\n \n Disabled at level @option{-Os}.\n \n+@item -fprintf-return-value\n+@opindex fprintf-return-value\n+Substitute constants for known return value of formatted output functions\n+such as @code{sprintf}, @code{snprintf}, @code{vsprintf}, and @code{vsnprintf}\n+(but not @code{printf} of @code{fprintf}).  This transformation allows GCC\n+to optimize or even eliminate branches based on the known return value of\n+these functions called with arguments that are either constant, or whose\n+values are known to be in a range that makes determining the exact return\n+value possible.  For example, both the branch and the body of the @code{if}\n+statement (but not the call to @code{snprint}) can be optimized away when\n+@code{i} is a 32-bit or smaller integer because the return value is guaranteed\n+to be at most 8.\n+\n+@smallexample\n+char buf[9];\n+if (snprintf (buf, \"%08x\", i) >= sizeof buf)\n+  @dots{}\n+@end smallexample\n+\n+The @option{-fprintf-return-value} option relies on other optimizations\n+and yields best results with @option{-O2}.  It works in tandem with the\n+@option{-Wformat-length} option.  The @option{-fprintf-return-value}\n+option is disabled by default.\n+\n @item -fno-peephole\n @itemx -fno-peephole2\n @opindex fno-peephole"}, {"sha": "61d3a67c88eee412f28cd9da77aa08c1bb47923b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -5332,6 +5332,10 @@ In either case, it remains possible to select code-generation for the alternate\n scheme, by means of compiler command line switches.\n @end defmac\n \n+@deftypefn {Target Hook} {const char*} TARGET_PRINTF_POINTER_FORMAT (tree, const char **@var{flags})\n+Determine the target @code{printf} implementation format string that the most closely corresponds to the @code{%p} format directive.  The object pointed to by the @var{flags} is set to a string consisting of recognized format flags such as the @code{'#'} character.\n+@end deftypefn\n+\n @node Addressing Modes\n @section Addressing Modes\n @cindex addressing modes"}, {"sha": "fd3d65dcf3e24ef5cc288474048f6ac6fd5550b4", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -4065,6 +4065,8 @@ In either case, it remains possible to select code-generation for the alternate\n scheme, by means of compiler command line switches.\n @end defmac\n \n+@hook TARGET_PRINTF_POINTER_FORMAT\n+\n @node Addressing Modes\n @section Addressing Modes\n @cindex addressing modes"}, {"sha": "addabb745efc73465f313d1d591aea383f7f4a13", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1159,21 +1159,30 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n }\n \n \n-/* Return the string length, maximum string length or maximum value of\n-   ARG in LENGTH.\n-   If ARG is an SSA name variable, follow its use-def chains.  If LENGTH\n-   is not NULL and, for TYPE == 0, its value is not equal to the length\n-   we determine or if we are unable to determine the length or value,\n-   return false.  VISITED is a bitmap of visited variables.\n-   TYPE is 0 if string length should be returned, 1 for maximum string\n-   length and 2 for maximum value ARG can have.  */\n+/* Obtain the minimum and maximum string length or minimum and maximum\n+   value of ARG in LENGTH[0] and LENGTH[1], respectively.\n+   If ARG is an SSA name variable, follow its use-def chains.  When\n+   TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n+   if we are unable to determine the length or value, return False.\n+   VISITED is a bitmap of visited variables.\n+   TYPE is 0 if string length should be obtained, 1 for maximum string\n+   length and 2 for maximum value ARG can have.\n+   When FUZZY is set and the length of a string cannot be determined,\n+   the function instead considers as the maximum possible length the\n+   size of a character array it may refer to.  */\n \n static bool\n-get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n+get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n+\t\t  bool fuzzy)\n {\n   tree var, val;\n   gimple *def_stmt;\n \n+  /* The minimum and maximum length.  The MAXLEN pointer stays unchanged\n+     but MINLEN may be cleared during the execution of the function.  */\n+  tree *minlen = length;\n+  tree *const maxlen = length + 1;\n+\n   if (TREE_CODE (arg) != SSA_NAME)\n     {\n       /* We can end up with &(*iftmp_1)[0] here as well, so handle it.  */\n@@ -1184,8 +1193,8 @@ get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n \t  tree aop0 = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t  if (TREE_CODE (aop0) == INDIRECT_REF\n \t      && TREE_CODE (TREE_OPERAND (aop0, 0)) == SSA_NAME)\n-\t    return get_maxval_strlen (TREE_OPERAND (aop0, 0),\n-\t\t\t\t      length, visited, type);\n+\t    return get_range_strlen (TREE_OPERAND (aop0, 0),\n+\t\t\t\t     length, visited, type, fuzzy);\n \t}\n \n       if (type == 2)\n@@ -1197,26 +1206,60 @@ get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n \t}\n       else\n \tval = c_strlen (arg, 1);\n+\n+      if (!val && fuzzy)\n+\t{\n+\t  if (TREE_CODE (arg) == ADDR_EXPR)\n+\t    return get_range_strlen (TREE_OPERAND (arg, 0), length,\n+\t\t\t\t     visited, type, fuzzy);\n+\n+\t  if (TREE_CODE (arg) == COMPONENT_REF\n+\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 1))) == ARRAY_TYPE)\n+\t    {\n+\t      /* Use the type of the member array to determine the upper\n+\t\t bound on the length of the array.  This may be overly\n+\t\t optimistic if the array itself isn't NUL-terminated and\n+\t\t the caller relies on the subsequent member to contain\n+\t\t the NUL.  */\n+\t      arg = TREE_OPERAND (arg, 1);\n+\t      val = TYPE_SIZE_UNIT (TREE_TYPE (arg));\n+\t      if (!val || integer_zerop (val))\n+\t\treturn false;\n+\t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n+\t\t\t\t integer_one_node);\n+\t      /* Avoid using the array size as the minimum.  */\n+\t      minlen = NULL;\n+\t    }\n+\t}\n+\n       if (!val)\n \treturn false;\n \n-      if (*length)\n+      if (minlen\n+\t  && (!*minlen\n+\t      || (type > 0\n+\t\t  && TREE_CODE (*minlen) == INTEGER_CST\n+\t\t  && TREE_CODE (val) == INTEGER_CST\n+\t\t  && tree_int_cst_lt (val, *minlen))))\n+\t*minlen = val;\n+\n+      if (*maxlen)\n \t{\n \t  if (type > 0)\n \t    {\n-\t      if (TREE_CODE (*length) != INTEGER_CST\n+\t      if (TREE_CODE (*maxlen) != INTEGER_CST\n \t\t  || TREE_CODE (val) != INTEGER_CST)\n \t\treturn false;\n \n-\t      if (tree_int_cst_lt (*length, val))\n-\t\t*length = val;\n+\t      if (tree_int_cst_lt (*maxlen, val))\n+\t\t*maxlen = val;\n \t      return true;\n \t    }\n-\t  else if (simple_cst_equal (val, *length) != 1)\n+\t  else if (simple_cst_equal (val, *maxlen) != 1)\n \t    return false;\n \t}\n \n-      *length = val;\n+      *maxlen = val;\n       return true;\n     }\n \n@@ -1244,14 +1287,14 @@ get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n             || gimple_assign_unary_nop_p (def_stmt))\n           {\n             tree rhs = gimple_assign_rhs1 (def_stmt);\n-            return get_maxval_strlen (rhs, length, visited, type);\n+\t    return get_range_strlen (rhs, length, visited, type, fuzzy);\n           }\n \telse if (gimple_assign_rhs_code (def_stmt) == COND_EXPR)\n \t  {\n \t    tree op2 = gimple_assign_rhs2 (def_stmt);\n \t    tree op3 = gimple_assign_rhs3 (def_stmt);\n-\t    return get_maxval_strlen (op2, length, visited, type)\n-\t\t   && get_maxval_strlen (op3, length, visited, type);\n+\t    return get_range_strlen (op2, length, visited, type, fuzzy)\n+\t      && get_range_strlen (op3, length, visited, type, fuzzy);\n           }\n         return false;\n \n@@ -1274,8 +1317,13 @@ get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n             if (arg == gimple_phi_result (def_stmt))\n               continue;\n \n-            if (!get_maxval_strlen (arg, length, visited, type))\n-              return false;\n+\t    if (!get_range_strlen (arg, length, visited, type, fuzzy))\n+\t      {\n+\t\tif (fuzzy)\n+\t\t  *maxlen = build_all_ones_cst (size_type_node);\n+\t\telse\n+\t\t  return false;\n+\t      }\n           }\n         }\n         return true;\n@@ -1285,17 +1333,40 @@ get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n     }\n }\n \n+/* Determine the minimum and maximum value or string length that ARG\n+   refers to and store each in the first two elements of MINMAXLEN.\n+   For expressions that point to strings of unknown lengths that are\n+   character arrays, use the upper bound of the array as the maximum\n+   length.  For example, given an expression like 'x ? array : \"xyz\"'\n+   and array declared as 'char array[8]', MINMAXLEN[0] will be set\n+   to 3 and MINMAXLEN[1] to 7, the longest string that could be\n+   stored in array.\n+*/\n+\n+void get_range_strlen (tree arg, tree minmaxlen[2])\n+{\n+  bitmap visited = NULL;\n+\n+  minmaxlen[0] = NULL_TREE;\n+  minmaxlen[1] = NULL_TREE;\n+\n+  get_range_strlen (arg, minmaxlen, &visited, 1, true);\n+\n+  if (visited)\n+    BITMAP_FREE (visited);\n+}\n+\n tree\n get_maxval_strlen (tree arg, int type)\n {\n   bitmap visited = NULL;\n-  tree len = NULL_TREE;\n-  if (!get_maxval_strlen (arg, &len, &visited, type))\n-    len = NULL_TREE;\n+  tree len[2] = { NULL_TREE, NULL_TREE };\n+  if (!get_range_strlen (arg, len, &visited, type, false))\n+    len[1] = NULL_TREE;\n   if (visited)\n     BITMAP_FREE (visited);\n \n-  return len;\n+  return len[1];\n }\n \n "}, {"sha": "5add30c99bd3b577299a4e8431362d7ee09dd1e8", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -24,6 +24,8 @@ along with GCC; see the file COPYING3.  If not see\n \n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n+extern void get_range_strlen (tree, tree[2]);\n+extern tree get_maxval_strlen (tree, int);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));"}, {"sha": "0afcf68c7bbb7a319e73734da4d5fe86e498b85c", "filename": "gcc/gimple-ssa-sprintf.c", "status": "added", "additions": 2686, "deletions": 0, "changes": 2686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,2686 @@\n+/* Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Martin Sebor <msebor@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements the printf-return-value pass.  The pass does\n+   two things: 1) it analyzes calls to formatted output functions like\n+   sprintf looking for possible buffer overflows and calls to bounded\n+   functions like snprintf for early truncation (and under the control\n+   of the -Wformat-length option issues warnings), and 2) under the\n+   control of the -fprintf-return-value option it folds the return\n+   value of safe calls into constants, making it possible to eliminate\n+   code that depends on the value of those constants.\n+\n+   For all functions (bounded or not) the pass uses the size of the\n+   destination object.  That means that it will diagnose calls to\n+   snprintf not on the basis of the size specified by the function's\n+   second argument but rathger on the basis of the size the first\n+   argument points to (if possible).  For bound-checking built-ins\n+   like __builtin___snprintf_chk the pass uses the size typically\n+   determined by __builtin_object_size and passed to the built-in\n+   by the Glibc inline wrapper.\n+\n+   The pass handles all forms standard sprintf format directives,\n+   including character, integer, floating point, pointer, and strings,\n+   with  the standard C flags, widths, and precisions.  For integers\n+   and strings it computes the length of output itself.  For floating\n+   point it uses MPFR to fornmat known constants with up and down\n+   rounding and uses the resulting range of output lengths.  For\n+   strings it uses the length of string literals and the sizes of\n+   character arrays that a character pointer may point to as a bound\n+   on the longest string.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-object-size.h\"\n+#include \"params.h\"\n+#include \"tree-cfg.h\"\n+#include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"intl.h\"\n+\n+#include \"builtins.h\"\n+#include \"stor-layout.h\"\n+\n+#include \"realmpfr.h\"\n+#include \"target.h\"\n+#include \"targhooks.h\"\n+\n+#include \"cpplib.h\"\n+#include \"input.h\"\n+#include \"toplev.h\"\n+#include \"substring-locations.h\"\n+#include \"diagnostic.h\"\n+\n+namespace {\n+\n+const pass_data pass_data_sprintf_length = {\n+  GIMPLE_PASS,             // pass type\n+  \"printf-return-value\",   // pass name\n+  OPTGROUP_NONE,           // optinfo_flags\n+  TV_NONE,                 // tv_id\n+  PROP_cfg,                // properties_required\n+  0,\t                   // properties_provided\n+  0,\t                   // properties_destroyed\n+  0,\t                   // properties_start\n+  0,\t                   // properties_finish\n+};\n+\n+struct format_result;\n+\n+class pass_sprintf_length : public gimple_opt_pass\n+{\n+  bool fold_return_value;\n+\n+public:\n+  pass_sprintf_length (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_sprintf_length, ctxt),\n+    fold_return_value (false)\n+  { }\n+\n+  opt_pass * clone () { return new pass_sprintf_length (m_ctxt); }\n+\n+  virtual bool gate (function *);\n+\n+  virtual unsigned int execute (function *);\n+\n+  void set_pass_param (unsigned int n, bool param)\n+    {\n+      gcc_assert (n == 0);\n+      fold_return_value = param;\n+    }\n+\n+  void handle_gimple_call (gimple_stmt_iterator);\n+\n+  struct call_info;\n+  void compute_format_length (const call_info &, format_result *);\n+};\n+\n+bool\n+pass_sprintf_length::gate (function *)\n+{\n+  /* Run the pass iff -Warn-format-length is specified and either\n+     not optimizing and the pass is being invoked early, or when\n+     optimizing and the pass is being invoked during optimization\n+     (i.e., \"late\").  */\n+  return ((0 < warn_format_length || flag_printf_return_value)\n+\t  && (0 < optimize) == fold_return_value);\n+}\n+\n+/* The result of a call to a formatted function.  */\n+\n+struct format_result\n+{\n+  /* Number of characters written by the formatted function, exact,\n+     minimum and maximum when an exact number cannot be determined.\n+     Setting the minimum to HOST_WIDE_INT_MAX disables all length\n+     tracking for the remainder of the format string.\n+     Setting either of the other two members to HOST_WIDE_INT_MAX\n+     disables the exact or maximum length tracking, respectively,\n+     but continues to track the maximum.  */\n+  unsigned HOST_WIDE_INT number_chars;\n+  unsigned HOST_WIDE_INT number_chars_min;\n+  unsigned HOST_WIDE_INT number_chars_max;\n+\n+  /* True when the range given by NUMBER_CHARS_MIN and NUMBER_CHARS_MAX\n+     is the output of all directives determined to be bounded to some\n+     subrange of their types or possible lengths, false otherwise.\n+     Note that BOUNDED only implies that the length of a function's\n+     output is known to be within some range, not that it's constant\n+     and a candidate for folding.  */\n+  bool bounded;\n+\n+  /* True when the output of the formatted call is constant (and\n+     thus a candidate for string constant folding).  This is rare\n+     and typically requires that the arguments of all directives\n+     are also constant.  Constant implies bounded.  */\n+  bool constant;\n+\n+  /* True if no individual directive resulted in more than 4095 bytes\n+     of output (the total NUMBER_CHARS might be greater).  */\n+  bool under4k;\n+\n+  /* True when a floating point directive has been seen in the format\n+     string.  */\n+  bool floating;\n+\n+  /* True when an intermediate result has caused a warning.  Used to\n+     avoid issuing duplicate warnings while finishing the processing\n+     of a call.  */\n+  bool warned;\n+\n+  /* Preincrement the number of output characters by 1.  */\n+  format_result& operator++ ()\n+  {\n+    return *this += 1;\n+  }\n+\n+  /* Postincrement the number of output characters by 1.  */\n+  format_result operator++ (int)\n+  {\n+    format_result prev (*this);\n+    *this += 1;\n+    return prev;\n+  }\n+\n+  /* Increment the number of output characters by N.  */\n+  format_result& operator+= (unsigned HOST_WIDE_INT n)\n+  {\n+    gcc_assert (n < HOST_WIDE_INT_MAX);\n+\n+    if (number_chars < HOST_WIDE_INT_MAX)\n+      number_chars += n;\n+    if (number_chars_min < HOST_WIDE_INT_MAX)\n+      number_chars_min += n;\n+    if (number_chars_max < HOST_WIDE_INT_MAX)\n+      number_chars_max += n;\n+    return *this;\n+  }\n+};\n+\n+/* Return the value of INT_MIN for the target.  */\n+\n+static HOST_WIDE_INT\n+target_int_min ()\n+{\n+  static const unsigned HOST_WIDE_INT int_min\n+    = 1LLU << (sizeof int_min * CHAR_BIT\n+\t       - TYPE_PRECISION (integer_type_node) + 1);\n+  return int_min;\n+}\n+\n+/* Return the value of INT_MAX for the target.  */\n+\n+static unsigned HOST_WIDE_INT\n+target_int_max ()\n+{\n+  static const unsigned HOST_WIDE_INT int_max\n+    = HOST_WIDE_INT_M1U >> (sizeof int_max * CHAR_BIT\n+\t\t\t    - TYPE_PRECISION (integer_type_node) + 1);\n+  return int_max;\n+}\n+\n+/* Return the constant initial value of DECL if available or DECL\n+   otherwise.  Same as the synonymous function in c/c-typeck.c.  */\n+\n+static tree\n+decl_constant_value (tree decl)\n+{\n+  if (/* Don't change a variable array bound or initial value to a constant\n+\t in a place where a variable is invalid.  Note that DECL_INITIAL\n+\t isn't valid for a PARM_DECL.  */\n+      current_function_decl != 0\n+      && TREE_CODE (decl) != PARM_DECL\n+      && !TREE_THIS_VOLATILE (decl)\n+      && TREE_READONLY (decl)\n+      && DECL_INITIAL (decl) != 0\n+      && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n+      /* This is invalid if initial value is not constant.\n+\t If it has either a function call, a memory reference,\n+\t or a variable, then re-evaluating it could give different results.  */\n+      && TREE_CONSTANT (DECL_INITIAL (decl))\n+      /* Check for cases where this is sub-optimal, even though valid.  */\n+      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR)\n+    return DECL_INITIAL (decl);\n+  return decl;\n+}\n+\n+/* Given FORMAT, set *PLOC to the source location of the format string\n+   and return the format string if it is known or null otherwise.  */\n+\n+static const char*\n+get_format_string (tree format, location_t *ploc)\n+{\n+  if (VAR_P (format))\n+    {\n+      /* Pull out a constant value if the front end didn't.  */\n+      format = decl_constant_value (format);\n+      STRIP_NOPS (format);\n+    }\n+\n+  if (integer_zerop (format))\n+    {\n+      /* FIXME: Diagnose null format string if it hasn't been diagnosed\n+\t by -Wformat (the latter diagnoses only nul pointer constants,\n+\t this pass can do better).  */\n+      return NULL;\n+    }\n+\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (TREE_CODE (format) == POINTER_PLUS_EXPR)\n+    {\n+      tree arg0 = TREE_OPERAND (format, 0);\n+      tree arg1 = TREE_OPERAND (format, 1);\n+      STRIP_NOPS (arg0);\n+      STRIP_NOPS (arg1);\n+\n+      if (TREE_CODE (arg1) != INTEGER_CST)\n+\treturn NULL;\n+\n+      format = arg0;\n+\n+      /* POINTER_PLUS_EXPR offsets are to be interpreted signed.  */\n+      if (!cst_and_fits_in_hwi (arg1))\n+\treturn NULL;\n+\n+      offset = int_cst_value (arg1);\n+    }\n+\n+  if (TREE_CODE (format) != ADDR_EXPR)\n+    return NULL;\n+\n+  *ploc = EXPR_LOC_OR_LOC (format, input_location);\n+\n+  format = TREE_OPERAND (format, 0);\n+\n+  if (TREE_CODE (format) == ARRAY_REF\n+      && tree_fits_shwi_p (TREE_OPERAND (format, 1))\n+      && (offset += tree_to_shwi (TREE_OPERAND (format, 1))) >= 0)\n+    format = TREE_OPERAND (format, 0);\n+\n+  if (offset < 0)\n+    return NULL;\n+\n+  tree array_init;\n+  tree array_size = NULL_TREE;\n+\n+  if (VAR_P (format)\n+      && TREE_CODE (TREE_TYPE (format)) == ARRAY_TYPE\n+      && (array_init = decl_constant_value (format)) != format\n+      && TREE_CODE (array_init) == STRING_CST)\n+    {\n+      /* Extract the string constant initializer.  Note that this may\n+\t include a trailing NUL character that is not in the array (e.g.\n+\t const char a[3] = \"foo\";).  */\n+      array_size = DECL_SIZE_UNIT (format);\n+      format = array_init;\n+    }\n+\n+  if (TREE_CODE (format) != STRING_CST)\n+    return NULL;\n+\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (format))) != char_type_node)\n+    {\n+      /* Wide format string.  */\n+      return NULL;\n+    }\n+\n+  const char *fmtstr = TREE_STRING_POINTER (format);\n+  unsigned fmtlen = TREE_STRING_LENGTH (format);\n+\n+  if (array_size)\n+    {\n+      /* Variable length arrays can't be initialized.  */\n+      gcc_assert (TREE_CODE (array_size) == INTEGER_CST);\n+\n+      if (tree_fits_shwi_p (array_size))\n+\t{\n+\t  HOST_WIDE_INT array_size_value = tree_to_shwi (array_size);\n+\t  if (array_size_value > 0\n+\t      && array_size_value == (int) array_size_value\n+\t      && fmtlen > array_size_value)\n+\t    fmtlen = array_size_value;\n+\t}\n+    }\n+  if (offset)\n+    {\n+      if (offset >= fmtlen)\n+\treturn NULL;\n+\n+      fmtstr += offset;\n+      fmtlen -= offset;\n+    }\n+\n+  if (fmtlen < 1 || fmtstr[--fmtlen] != 0)\n+    {\n+      /* FIXME: Diagnose an unterminated format string if it hasn't been\n+\t diagnosed by -Wformat.  Similarly to a null format pointer,\n+\t -Wformay diagnoses only nul pointer constants, this pass can\n+\t do better).  */\n+      return NULL;\n+    }\n+\n+  return fmtstr;\n+}\n+\n+/* The format_warning_at_substring function is not used here in a way\n+   that makes using attribute format viable.  Suppress the warning.  */\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n+\n+/* For convenience and brevity.  */\n+\n+static bool\n+  (* const fmtwarn) (const substring_loc &, const source_range *,\n+\t\t     const char *, int, const char *, ...)\n+  = format_warning_at_substring;\n+\n+/* Format length modifiers.  */\n+\n+enum format_lengths\n+{\n+  FMT_LEN_none,\n+  FMT_LEN_hh,    // char argument\n+  FMT_LEN_h,     // short\n+  FMT_LEN_l,     // long\n+  FMT_LEN_ll,    // long long\n+  FMT_LEN_L,     // long double (and GNU long long)\n+  FMT_LEN_z,     // size_t\n+  FMT_LEN_t,     // ptrdiff_t\n+  FMT_LEN_j      // intmax_t\n+};\n+\n+\n+/* A minimum and maximum number of bytes.  */\n+\n+struct result_range\n+{\n+  unsigned HOST_WIDE_INT min, max;\n+};\n+\n+/* Description of the result of conversion either of a single directive\n+   or the whole format string.  */\n+\n+struct fmtresult\n+{\n+  /* The range a directive's argument is in.  */\n+  tree argmin, argmax;\n+\n+  /* The minimum and maximum number of bytes that a directive\n+     results in on output for an argument in the range above.  */\n+  result_range range;\n+\n+  /* True when the range is the result of an argument determined\n+     to be bounded to a subrange of its type or value (such as by\n+     value range propagation or the width of the formt directive),\n+     false otherwise.  */\n+  bool bounded;\n+  /* True when the output of a directive is constant.  This is rare\n+     and typically requires that the argument(s) of the directive\n+     are also constant (such as determined by constant propagation,\n+     though not value range propagation).  */\n+  bool constant;\n+};\n+\n+/* Description of a conversion specification.  */\n+\n+struct conversion_spec\n+{\n+  /* A bitmap of flags, one for each character.  */\n+  unsigned flags[256 / sizeof (int)];\n+  /* Numeric width as in \"%8x\".  */\n+  int width;\n+  /* Numeric precision as in \"%.32s\".  */\n+  int precision;\n+\n+  /* Width specified via the '*' character.  */\n+  tree star_width;\n+  /* Precision specified via the asterisk.  */\n+  tree star_precision;\n+\n+  /* Length modifier.  */\n+  format_lengths modifier;\n+\n+  /* Format specifier character.  */\n+  char specifier;\n+\n+  /* Numeric width was given.  */\n+  unsigned have_width: 1;\n+  /* Numeric precision was given.  */\n+  unsigned have_precision: 1;\n+  /* Non-zero when certain flags should be interpreted even for a directive\n+     that normally doesn't accept them (used when \"%p\" with flags such as\n+     space or plus is interepreted as a \"%x\".  */\n+  unsigned force_flags: 1;\n+\n+  /* Format conversion function that given a conversion specification\n+     and an argument returns the formatting result.  */\n+  fmtresult  (*fmtfunc) (const conversion_spec &, tree);\n+\n+  /* Return True when a the format flag CHR has been used.  */\n+  bool get_flag (char chr) const\n+  {\n+    unsigned char c = chr & 0xff;\n+    return (flags[c / (CHAR_BIT * sizeof *flags)]\n+\t    & (1U << (c % (CHAR_BIT * sizeof *flags))));\n+  }\n+\n+  /* Make a record of the format flag CHR having been used.  */\n+  void set_flag (char chr)\n+  {\n+    unsigned char c = chr & 0xff;\n+    flags[c / (CHAR_BIT * sizeof *flags)]\n+      |= (1U << (c % (CHAR_BIT * sizeof *flags)));\n+  }\n+\n+  /* Reset the format flag CHR.  */\n+  void clear_flag (char chr)\n+  {\n+    unsigned char c = chr & 0xff;\n+    flags[c / (CHAR_BIT * sizeof *flags)]\n+      &= ~(1U << (c % (CHAR_BIT * sizeof *flags)));\n+  }\n+};\n+\n+/* Return the logarithm of X in BASE.  */\n+\n+static int\n+ilog (unsigned HOST_WIDE_INT x, int base)\n+{\n+  int res = 0;\n+  do\n+    {\n+      ++res;\n+      x /= base;\n+    } while (x);\n+  return res;\n+}\n+\n+/* Return the number of bytes resulting from converting into a string\n+   the INTEGER_CST tree node X in BASE.  PLUS indicates whether 1 for\n+   a plus sign should be added for positive numbers, and PREFIX whether\n+   the length of an octal ('O') or hexadecimal ('0x') prefix should be\n+   added for nonzero numbers.  Return -1 if X cannot be represented.  */\n+\n+static int\n+tree_digits (tree x, int base, bool plus, bool prefix)\n+{\n+  unsigned HOST_WIDE_INT absval;\n+\n+  int res;\n+\n+  if (TYPE_UNSIGNED (TREE_TYPE (x)))\n+    {\n+      if (tree_fits_uhwi_p (x))\n+\t{\n+\t  absval = tree_to_uhwi (x);\n+\t  res = plus;\n+\t}\n+      else\n+\treturn -1;\n+    }\n+  else\n+    {\n+      if (tree_fits_shwi_p (x))\n+\t{\n+\t  HOST_WIDE_INT i = tree_to_shwi (x);\n+\t  if (i < 0)\n+\t    {\n+\t      absval = -i;\n+\t      res = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      absval = i;\n+\t      res = plus;\n+\t    }\n+\t}\n+      else\n+\treturn -1;\n+    }\n+\n+  res += ilog (absval, base);\n+\n+  if (prefix && absval)\n+    {\n+      if (base == 8)\n+\tres += 1;\n+      else if (base == 16)\n+\tres += 2;\n+    }\n+\n+  return res;\n+}\n+\n+/* Given the formatting result described by RES and NAVAIL, the number\n+   of available in the destination, return the number of bytes remaining\n+   in the destination.  */\n+\n+static inline result_range\n+bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n+{\n+  result_range range;\n+\n+  if (HOST_WIDE_INT_MAX <= navail)\n+    {\n+      range.min = range.max = navail;\n+      return range;\n+    }\n+\n+  if (res.number_chars < navail)\n+    {\n+      range.min = range.max = navail - res.number_chars;\n+    }\n+  else if (res.number_chars_min < navail)\n+    {\n+      range.max = navail - res.number_chars_min;\n+    }\n+  else\n+    range.max = 0;\n+\n+  if (res.number_chars_max < navail)\n+    range.min = navail - res.number_chars_max;\n+  else\n+    range.min = 0;\n+\n+  return range;\n+}\n+\n+/* Given the formatting result described by RES and NAVAIL, the number\n+   of available in the destination, return the minimum number of bytes\n+   remaining in the destination.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+min_bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n+{\n+  if (HOST_WIDE_INT_MAX <= navail)\n+    return navail;\n+\n+  if (1 < warn_format_length || res.bounded)\n+    {\n+      /* At level 2, or when all directives output an exact number\n+\t of bytes or when their arguments were bounded by known\n+\t ranges, use the greater of the two byte counters if it's\n+\t valid to compute the result.  */\n+      if (res.number_chars_max < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars_max;\n+      else if (res.number_chars < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars;\n+      else if (res.number_chars_min < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars_min;\n+    }\n+  else\n+    {\n+      /* At level 1 use the smaller of the byte counters to compute\n+\t the result.  */\n+      if (res.number_chars < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars;\n+      else if (res.number_chars_min < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars_min;\n+      else if (res.number_chars_max < HOST_WIDE_INT_MAX)\n+\tnavail -= res.number_chars_max;\n+    }\n+\n+  if (navail > HOST_WIDE_INT_MAX)\n+    navail = 0;\n+\n+  return navail;\n+}\n+\n+/* Description of a call to a formatted function.  */\n+\n+struct pass_sprintf_length::call_info\n+{\n+  /* Function call statement.  */\n+  gimple *callstmt;\n+\n+  /* Function called.  */\n+  tree func;\n+\n+  /* Called built-in function code.  */\n+  built_in_function fncode;\n+\n+  /* Format argument and format string extracted from it.  */\n+  tree format;\n+  const char *fmtstr;\n+\n+  /* The location of the format argument.  */\n+  location_t fmtloc;\n+\n+  /* The destination object size for __builtin___xxx_chk functions\n+     typically determined by __builtin_object_size, or -1 if unknown.  */\n+  unsigned HOST_WIDE_INT objsize;\n+\n+  /* Number of the first variable argument.  */\n+  unsigned HOST_WIDE_INT argidx;\n+\n+  /* True for functions like snprintf that specify the size of\n+     the destination, false for others like sprintf that don't.  */\n+  bool bounded;\n+};\n+\n+/* Return the result of formatting the '%%' directive.  */\n+\n+static fmtresult\n+format_percent (const conversion_spec &, tree)\n+{\n+  fmtresult res;\n+  res.argmin = res.argmax = NULL_TREE;\n+  res.range.min = res.range.max = 1;\n+  res.bounded = res.constant = true;\n+  return res;\n+}\n+\n+\n+/* Ugh.  Compute intmax_type_node and uintmax_type_node the same way\n+   lto/lto-lang.c does it.  This should be available in tree.h.  */\n+\n+static void\n+build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n+{\n+  if (strcmp (SIZE_TYPE, \"unsigned int\") == 0)\n+    {\n+      *pintmax = integer_type_node;\n+      *puintmax = unsigned_type_node;\n+    }\n+  else if (strcmp (SIZE_TYPE, \"long unsigned int\") == 0)\n+    {\n+      *pintmax = long_integer_type_node;\n+      *puintmax = long_unsigned_type_node;\n+    }\n+  else if (strcmp (SIZE_TYPE, \"long long unsigned int\") == 0)\n+    {\n+      *pintmax = long_long_integer_type_node;\n+      *puintmax = long_long_unsigned_type_node;\n+    }\n+  else\n+    {\n+      for (int i = 0; i < NUM_INT_N_ENTS; i++)\n+\tif (int_n_enabled_p[i])\n+\t  {\n+\t    char name[50];\n+\t    sprintf (name, \"__int%d unsigned\", int_n_data[i].bitsize);\n+\n+\t    if (strcmp (name, SIZE_TYPE) == 0)\n+\t      {\n+\t        *pintmax = int_n_trees[i].signed_type;\n+\t        *puintmax = int_n_trees[i].unsigned_type;\n+\t      }\n+\t  }\n+    }\n+}\n+\n+static fmtresult\n+format_integer (const conversion_spec &, tree);\n+\n+/* Return a range representing the minimum and maximum number of bytes\n+   that the conversion specification SPEC will write on output for the\n+   pointer argument ARG when non-null.  ARG may be null (for vararg\n+   functions).  */\n+\n+static fmtresult\n+format_pointer (const conversion_spec &spec, tree arg)\n+{\n+  fmtresult res = fmtresult ();\n+\n+  /* Determine the target's integer format corresponding to \"%p\".  */\n+  const char *flags;\n+  const char *pfmt = targetm.printf_pointer_format (arg, &flags);\n+  if (!pfmt)\n+    {\n+      /* The format couldn't be determined.  */\n+      res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n+      return res;\n+    }\n+\n+  if (pfmt [0] == '%')\n+    {\n+      /* Format the pointer using the integer format string.  */\n+      conversion_spec pspec = spec;\n+\n+      /* Clear flags that are not listed as recognized.  */\n+      for (const char *pf = \"+ #0\"; *pf; ++pf)\n+\t{\n+\t  if (!strchr (flags, *pf))\n+\t    pspec.clear_flag (*pf);\n+\t}\n+\n+      /* Set flags that are specified in the format string.  */\n+      bool flag_p = true;\n+      do\n+\t{\n+\t  switch (*++pfmt)\n+\t    {\n+\t    case '+': case ' ': case '#': case '0':\n+\t      pspec.set_flag (*pfmt);\n+\t      break;\n+\t    default:\n+\t      flag_p = false;\n+\t    }\n+\t}\n+      while (flag_p);\n+\n+      /* Set the appropriate length modifier taking care to clear\n+       the one that may be set (Glibc's %p accepts but ignores all\n+       the integer length modifiers).  */\n+      switch (*pfmt)\n+\t{\n+\tcase 'l': pspec.modifier = FMT_LEN_l; ++pfmt; break;\n+\tcase 't': pspec.modifier = FMT_LEN_t; ++pfmt; break;\n+\tcase 'z': pspec.modifier = FMT_LEN_z; ++pfmt; break;\n+\tdefault: pspec.modifier = FMT_LEN_none;\n+\t}\n+\n+      pspec.force_flags = 1;\n+      pspec.specifier = *pfmt++;\n+      gcc_assert (*pfmt == '\\0');\n+      return format_integer (pspec, arg);\n+    }\n+\n+  /* The format is a plain string such as Glibc's \"(nil)\".  */\n+  res.range.min = res.range.max = strlen (pfmt);\n+  return res;\n+}\n+\n+/* Return a range representing the minimum and maximum number of bytes\n+   that the conversion specification SPEC will write on output for the\n+   integer argument ARG when non-null.  ARG may be null (for vararg\n+   functions).  */\n+\n+static fmtresult\n+format_integer (const conversion_spec &spec, tree arg)\n+{\n+  /* These are available as macros in the C and C++ front ends but,\n+     sadly, not here.  */\n+  static tree intmax_type_node;\n+  static tree uintmax_type_node;\n+\n+  /* Initialize the intmax nodes above the first time through here.  */\n+  if (!intmax_type_node)\n+    build_intmax_type_nodes (&intmax_type_node, &uintmax_type_node);\n+\n+  /* Set WIDTH and PRECISION to either the values in the format\n+     specification or to zero.  */\n+  int width = spec.have_width ? spec.width : 0;\n+  int prec = spec.have_precision ? spec.precision : 0;\n+\n+  if (spec.star_width)\n+    width = (TREE_CODE (spec.star_width) == INTEGER_CST\n+\t     ? tree_to_shwi (spec.star_width) : 0);\n+\n+  if (spec.star_precision)\n+    prec = (TREE_CODE (spec.star_precision) == INTEGER_CST\n+\t    ? tree_to_shwi (spec.star_precision) : 0);\n+\n+  bool sign = spec.specifier == 'd' || spec.specifier == 'i';\n+\n+  /* The type of the \"formal\" argument expected by the directive.  */\n+  tree dirtype = NULL_TREE;\n+\n+  /* Determine the expected type of the argument from the length\n+     modifier.  */\n+  switch (spec.modifier)\n+    {\n+    case FMT_LEN_none:\n+      if (spec.specifier == 'p')\n+\tdirtype = ptr_type_node;\n+      else\n+\tdirtype = sign ? integer_type_node : unsigned_type_node;\n+      break;\n+\n+    case FMT_LEN_h:\n+      dirtype = sign ? short_integer_type_node : short_unsigned_type_node;\n+      break;\n+\n+    case FMT_LEN_hh:\n+      dirtype = sign ? signed_char_type_node : unsigned_char_type_node;\n+      break;\n+\n+    case FMT_LEN_l:\n+      dirtype = sign ? long_integer_type_node : long_unsigned_type_node;\n+      break;\n+\n+    case FMT_LEN_L:\n+    case FMT_LEN_ll:\n+      dirtype = sign ? long_integer_type_node : long_unsigned_type_node;\n+      break;\n+\n+    case FMT_LEN_z:\n+      dirtype = sign ? ptrdiff_type_node : size_type_node;\n+      break;\n+\n+    case FMT_LEN_t:\n+      dirtype = sign ? ptrdiff_type_node : size_type_node;\n+      break;\n+\n+    case FMT_LEN_j:\n+      dirtype = sign ? intmax_type_node : uintmax_type_node;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* The type of the argument to the directive, either deduced from\n+     the actual non-constant argument if one is known, or from\n+     the directive itself when none has been provided because it's\n+     a va_list.  */\n+  tree argtype = NULL_TREE;\n+\n+  if (!arg)\n+    {\n+      /* When the argument has not been provided, use the type of\n+\t the directive's argument as an approximation.  This will\n+\t result in false positives for directives like %i with\n+\t arguments with smaller precision (such as short or char).  */\n+      argtype = dirtype;\n+    }\n+  else if (TREE_CODE (arg) == INTEGER_CST)\n+    {\n+      /* The minimum and maximum number of bytes produced by\n+\t the directive.  */\n+      fmtresult res = fmtresult ();\n+\n+      /* When a constant argument has been provided use its value\n+\t rather than type to determine the length of the output.  */\n+      res.bounded = true;\n+      res.constant = true;\n+\n+      /* Base to format the number in.  */\n+      int base;\n+\n+      /* True when a signed conversion is preceded by a sign or space.  */\n+      bool maybesign;\n+\n+      switch (spec.specifier)\n+\t{\n+\tcase 'd':\n+\tcase 'i':\n+\t  /* Space is only effective for signed conversions.  */\n+\t  maybesign = spec.get_flag (' ');\n+\t  base = 10;\n+\t  break;\n+\tcase 'u':\n+\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n+\t  base = 10;\n+\t  break;\n+\tcase 'o':\n+\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n+\t  base = 8;\n+\t  break;\n+\tcase 'X':\n+\tcase 'x':\n+\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n+\t  base = 16;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Convert the argument to the type of the directive.  */\n+      arg = fold_convert (dirtype, arg);\n+\n+      maybesign |= spec.get_flag ('+');\n+\n+      /* True when a conversion is preceded by a prefix indicating the base\n+\t of the argument (octal or hexadecimal).  */\n+      bool maybebase = spec.get_flag ('#');\n+      int len = tree_digits (arg, base, maybesign, maybebase);\n+\n+      if (len < prec)\n+\tlen = prec;\n+\n+      if (len < width)\n+\tlen = width;\n+\n+      res.range.max = len;\n+      res.range.min = res.range.max;\n+      res.bounded = true;\n+\n+      return res;\n+    }\n+  else if (TREE_CODE (TREE_TYPE (arg)) == INTEGER_TYPE\n+\t   || TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE)\n+    {\n+      /* Determine the type of the provided non-constant argument.  */\n+      if (TREE_CODE (arg) == NOP_EXPR)\n+\targ = TREE_OPERAND (arg, 0);\n+      else if (TREE_CODE (arg) == CONVERT_EXPR)\n+\targ = TREE_OPERAND (arg, 0);\n+      if (TREE_CODE (arg) == COMPONENT_REF)\n+\targ = TREE_OPERAND (arg, 1);\n+\n+      argtype = TREE_TYPE (arg);\n+    }\n+  else\n+    {\n+      /* Don't bother with invalid arguments since they likely would\n+\t have already been diagnosed, and disable any further checking\n+\t of the format string by returning [-1, -1].  */\n+      fmtresult res = fmtresult ();\n+      res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n+      return res;\n+    }\n+\n+  fmtresult res = fmtresult ();\n+\n+  /* Using either the range the non-constant argument is in, or its\n+     type (either \"formal\" or actual), create a range of values that\n+     constrain the length of output given the warning level.  */\n+  tree argmin = NULL_TREE;\n+  tree argmax = NULL_TREE;\n+\n+  if (arg && TREE_CODE (arg) == SSA_NAME\n+      && TREE_CODE (argtype) == INTEGER_TYPE)\n+    {\n+      /* Try to determine the range of values of the integer argument\n+\t (range information is not available for pointers).  */\n+      wide_int min, max;\n+      enum value_range_type range_type = get_range_info (arg, &min, &max);\n+      if (range_type == VR_RANGE)\n+\t{\n+\t  res.argmin = build_int_cst (argtype, wi::fits_uhwi_p (min)\n+\t\t\t\t      ? min.to_uhwi () : min.to_shwi ());\n+\t  res.argmax = build_int_cst (argtype, wi::fits_uhwi_p (max)\n+\t\t\t\t      ? max.to_uhwi () : max.to_shwi ());\n+\n+\t  /* For a range with a negative lower bound and a non-negative\n+\t     upper bound, use one to determine the minimum number of bytes\n+\t     on output and whichever of the two bounds that results in\n+\t     the greater number of bytes on output for the upper bound.\n+\t     For example, for ARG in the range of [-3, 123], use 123 as\n+\t     the upper bound for %i but -3 for %u.  */\n+\t  if (wi::neg_p (min) && !wi::neg_p (max))\n+\t    {\n+\t      argmin = build_int_cst (argtype, wi::fits_uhwi_p (min)\n+\t\t\t\t      ? min.to_uhwi () : min.to_shwi ());\n+\n+\t      argmax = build_int_cst (argtype, wi::fits_uhwi_p (max)\n+\t\t\t\t      ? max.to_uhwi () : max.to_shwi ());\n+\n+\t      int minbytes = format_integer (spec, res.argmin).range.min;\n+\t      int maxbytes = format_integer (spec, res.argmax).range.max;\n+\t      if (maxbytes < minbytes)\n+\t\targmax = res.argmin;\n+\n+\t      argmin = integer_zero_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      argmin = res.argmin;\n+\t      argmax = res.argmax;\n+\t    }\n+\n+\t  /* The argument is bounded by the range of values determined\n+\t     by Value Range Propagation.  */\n+\t  res.bounded = true;\n+\t}\n+      else if (range_type == VR_ANTI_RANGE)\n+\t{\n+\t  /* Handle anti-ranges if/when bug 71690 is resolved.  */\n+\t}\n+      else if (range_type == VR_VARYING)\n+\t{\n+\t  /* The argument here may be the result of promoting the actual\n+\t     argument to int.  Try to determine the type of the actual\n+\t     argument before promotion and  narrow down its range that\n+\t     way.  */\n+\t  gimple *def = SSA_NAME_DEF_STMT (arg);\n+\t  if (gimple_code (def) == GIMPLE_ASSIGN)\n+\t    {\n+\t      tree_code code = gimple_assign_rhs_code (def);\n+\t      if (code == NOP_EXPR)\n+\t\targtype = TREE_TYPE (gimple_assign_rhs1 (def));\n+\t    }\n+\t}\n+    }\n+\n+  if (!argmin)\n+    {\n+      /* For an unknown argument (e.g., one passed to a vararg function)\n+\t or one whose value range cannot be determined, create a T_MIN\n+\t constant if the argument's type is signed and T_MAX otherwise,\n+\t and use those to compute the range of bytes that the directive\n+\t can output.  */\n+      argmin = build_int_cst (argtype, 1);\n+\n+      int typeprec = TYPE_PRECISION (dirtype);\n+      int argprec = TYPE_PRECISION (argtype);\n+\n+      if (argprec < typeprec || POINTER_TYPE_P (argtype))\n+\t{\n+\t  if (TYPE_UNSIGNED (argtype))\n+\t    argmax = build_all_ones_cst (argtype);\n+\t  else\n+\t    argmax = fold_build2 (LSHIFT_EXPR, argtype, integer_one_node,\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t argprec - 1));\n+\t}\n+      else\n+\t{\n+\t  argmax = fold_build2 (LSHIFT_EXPR, dirtype, integer_one_node,\n+\t\t\t\tbuild_int_cst (integer_type_node,\n+\t\t\t\t\t       typeprec - 1));\n+\t}\n+      res.argmin = argmin;\n+      res.argmax = argmax;\n+    }\n+\n+  /* Recursively compute the minimum and maximum from the known range,\n+     taking care to swap them if the lower bound results in longer\n+     output than the upper bound (e.g., in the range [-1, 0].  */\n+  res.range.min = format_integer (spec, argmin).range.min;\n+  res.range.max = format_integer (spec, argmax).range.max;\n+\n+  /* The result is bounded either when the argument is determined to be\n+     (e.g., when it's within some range) or when the minimum and maximum\n+     are the same.  That can happen here for example when the specified\n+     width is as wide as the greater of MIN and MAX, as would be the case\n+     with sprintf (d, \"%08x\", x) with a 32-bit integer x.  */\n+  res.bounded |= res.range.min == res.range.max;\n+\n+  if (res.range.max < res.range.min)\n+    {\n+      unsigned HOST_WIDE_INT tmp = res.range.max;\n+      res.range.max = res.range.min;\n+      res.range.min = tmp;\n+    }\n+\n+  return res;\n+}\n+\n+/* Return the number of bytes to format using the format specifier\n+   SPEC the largest value in the real floating TYPE.  */\n+\n+static int\n+format_floating_max (tree type, char spec)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+\n+  /* IBM Extended mode.  */\n+  if (MODE_COMPOSITE_P (mode))\n+    mode = DFmode;\n+\n+  /* Get the real type format desription for the target.  */\n+  const real_format *rfmt = REAL_MODE_FORMAT (mode);\n+  REAL_VALUE_TYPE rv;\n+\n+  {\n+    char buf[256];\n+    get_max_float (rfmt, buf, sizeof buf);\n+    real_from_string (&rv, buf);\n+  }\n+\n+  /* Convert the GCC real value representation with the precision\n+     of the real type to the mpfr_t format with the GCC default\n+     round-to-nearest mode.  */\n+  mpfr_t x;\n+  mpfr_init2 (x, rfmt->p);\n+  mpfr_from_real (x, &rv, MPFR_RNDN);\n+\n+  const char fmt[] = { '%', 'R', spec, '\\0' };\n+  int n = mpfr_snprintf (NULL, 0, fmt, x);\n+  return n;\n+}\n+\n+/* Return a range representing the minimum and maximum number of bytes\n+   that the conversion specification SPEC will output for any argument\n+   given the WIDTH and PRECISION (extracted from SPEC).  This function\n+   is used when the directive argument or its value isn't known.  */\n+\n+static fmtresult\n+format_floating (const conversion_spec &spec, int width, int prec)\n+{\n+  tree type;\n+  bool ldbl = false;\n+\n+  switch (spec.modifier)\n+    {\n+    case FMT_LEN_none:\n+      type = double_type_node;\n+      break;\n+\n+    case FMT_LEN_L:\n+      type = long_double_type_node;\n+      ldbl = true;\n+      break;\n+\n+    case FMT_LEN_ll:\n+      type = long_double_type_node;\n+      ldbl = true;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* The minimum and maximum number of bytes produced by the directive.  */\n+  fmtresult res = fmtresult ();\n+  res.constant = false;\n+\n+  /* Log10 of of the maximum number of exponent digits for the type.  */\n+  int logexpdigs = 2;\n+\n+  if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2)\n+    {\n+      /* The base in which the exponent is represented should always\n+\t be 2 in GCC.  */\n+\n+      const double log10_2 = .30102999566398119521;\n+\n+      /* Compute T_MAX_EXP for base 2.  */\n+      int expdigs = REAL_MODE_FORMAT (TYPE_MODE (type))->emax * log10_2;\n+      logexpdigs = ilog (expdigs, 10);\n+    }\n+\n+  switch (spec.specifier)\n+    {\n+    case 'A':\n+    case 'a':\n+      {\n+\t/* The minimum output is \"0x.p+0\".  */\n+\tres.range.min = 6 + (0 < prec ? prec : 0);\n+\n+\t/* Compute the maximum just once.  */\n+\tstatic const int a_max[] = {\n+\t  format_floating_max (double_type_node, 'a'),\n+\t  format_floating_max (long_double_type_node, 'a')\n+\t};\n+\tres.range.max = a_max [ldbl];\n+\tbreak;\n+      }\n+\n+    case 'E':\n+    case 'e':\n+      {\n+\tbool sign = spec.get_flag ('+') || spec.get_flag (' ');\n+\t/* The minimum output is \"[-+]1.234567e+00\" regardless\n+\t   of the value of the actual argument.  */\n+\tres.range.min = (sign\n+\t\t\t + 1 /* unit */ + (prec < 0 ? 7 : prec ? prec + 1 : 0)\n+\t\t\t + 2 /* e+ */ + 2);\n+\t/* The maximum output is the minimum plus sign (unless already\n+\t   included), plus the difference between the minimum exponent\n+\t   of 2 and the maximum exponent for the type.  */\n+\tres.range.max = res.range.min + !sign + logexpdigs - 2;\n+\tbreak;\n+      }\n+\n+    case 'F':\n+    case 'f':\n+      {\n+\t/* The minimum output is \"1.234567\" regardless of the value\n+\t   of the actual argument.  */\n+\tres.range.min = 2 + (prec < 0 ? 6 : prec);\n+\n+\t/* Compute the maximum just once.  */\n+\tstatic const int f_max[] = {\n+\t  format_floating_max (double_type_node, 'f'),\n+\t  format_floating_max (long_double_type_node, 'f')\n+\t};\n+\tres.range.max = f_max [ldbl];\n+\tbreak;\n+      }\n+    case 'G':\n+    case 'g':\n+      {\n+\t/* The minimum is the same as for '%F'.  */\n+\tres.range.min = 2 + (prec < 0 ? 6 : prec);\n+\n+\t/* Compute the maximum just once.  */\n+\tstatic const int g_max[] = {\n+\t  format_floating_max (double_type_node, 'g'),\n+\t  format_floating_max (long_double_type_node, 'g')\n+\t};\n+\tres.range.max = g_max [ldbl];\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (0 < width)\n+    {\n+      if (res.range.min < (unsigned)width)\n+\tres.range.min = width;\n+      if (res.range.max < (unsigned)width)\n+\tres.range.max = width;\n+    }\n+\n+  /* The argument is only considered bounded when the range of output\n+     bytes is exact.  */\n+  res.bounded = res.range.min == res.range.max;\n+  return res;\n+}\n+\n+/* Return a range representing the minimum and maximum number of bytes\n+   that the conversion specification SPEC will write on output for the\n+   floating argument ARG.  */\n+\n+static fmtresult\n+format_floating (const conversion_spec &spec, tree arg)\n+{\n+  int width = -1;\n+  int prec = -1;\n+\n+  /* The minimum and maximum number of bytes produced by the directive.  */\n+  fmtresult res = fmtresult ();\n+  res.constant = arg && TREE_CODE (arg) == REAL_CST;\n+\n+  if (spec.have_width)\n+    width = spec.width;\n+  else if (spec.star_width)\n+    {\n+      if (TREE_CODE (spec.star_width) == INTEGER_CST)\n+\twidth = tree_to_shwi (spec.star_width);\n+      else\n+\t{\n+\t  res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n+\t  return res;\n+\t}\n+    }\n+\n+  if (spec.have_precision)\n+    prec = spec.precision;\n+  else if (spec.star_precision)\n+    {\n+      if (TREE_CODE (spec.star_precision) == INTEGER_CST)\n+\tprec = tree_to_shwi (spec.star_precision);\n+      else\n+\t{\n+\t  res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n+\t  return res;\n+\t}\n+    }\n+  else if (res.constant && TOUPPER (spec.specifier) != 'A')\n+    {\n+      /* Specify the precision explicitly since mpfr_sprintf defaults\n+\t to zero.  */\n+      prec = 6;\n+    }\n+\n+  if (res.constant)\n+    {\n+      /* Set up an array to easily iterate over.  */\n+      unsigned HOST_WIDE_INT* const minmax[] = {\n+\t&res.range.min, &res.range.max\n+      };\n+\n+      /* Get the real type format desription for the target.  */\n+      const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n+      const real_format *rfmt = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)));\n+\n+      /* Convert the GCC real value representation with the precision\n+\t of the real type to the mpfr_t format with the GCC default\n+\t round-to-nearest mode.  */\n+      mpfr_t mpfrval;\n+      mpfr_init2 (mpfrval, rfmt->p);\n+      mpfr_from_real (mpfrval, rvp, MPFR_RNDN);\n+\n+      char fmtstr [40];\n+      char *pfmt = fmtstr;\n+      *pfmt++ = '%';\n+\n+      /* Append flags.  */\n+      for (const char *pf = \"-+ #0\"; *pf; ++pf)\n+\tif (spec.get_flag (*pf))\n+\t  *pfmt++ = *pf;\n+\n+      /* Append width when specified and precision.  */\n+      if (width != -1)\n+\tpfmt += sprintf (pfmt, \"%i\", width);\n+      if (prec != -1)\n+\tpfmt += sprintf (pfmt, \".%i\", prec);\n+\n+      /* Append the MPFR 'R' floating type specifier (no length modifier\n+\t is necessary or allowed by MPFR for mpfr_t values).  */\n+      *pfmt++ = 'R';\n+\n+      /* Save the position of the MPFR rounding specifier and skip over\n+\t it.  It will be set in each iteration in the loop below.  */\n+      char* const rndspec = pfmt++;\n+\n+      /* Append the C type specifier and nul-terminate.  */\n+      *pfmt++ = spec.specifier;\n+      *pfmt = '\\0';\n+\n+      for (int i = 0; i != sizeof minmax / sizeof *minmax; ++i)\n+\t{\n+\t  /* Use the MPFR rounding specifier to round down in the first\n+\t     iteration and then up.  In most but not all cases this will\n+\t     result in the same number of bytes.  */\n+\t  *rndspec = \"DU\"[i];\n+\n+\t  /* Format it and store the result in the corresponding\n+\t     member of the result struct.  */\n+\t  *minmax[i] = mpfr_snprintf (NULL, 0, fmtstr, mpfrval);\n+\t}\n+\n+      res.bounded = res.range.min < HOST_WIDE_INT_MAX;\n+      return res;\n+    }\n+\n+  return format_floating (spec, width, prec);\n+}\n+\n+/* Return a FMTRESULT struct set to the lengths of the shortest and longest\n+   strings referenced by the expression STR, or (-1, -1) when not known.\n+   Used by the format_string function below.  */\n+\n+static fmtresult\n+get_string_length (tree str)\n+{\n+  if (!str)\n+    {\n+      fmtresult res;\n+      res.range.min = HOST_WIDE_INT_MAX;\n+      res.range.max = HOST_WIDE_INT_MAX;\n+      res.bounded = false;\n+      res.constant = false;\n+      return res;\n+    }\n+\n+  if (tree slen = c_strlen (str, 1))\n+    {\n+      /* Simply return the length of the string.  */\n+      fmtresult res;\n+      res.range.min = res.range.max = tree_to_shwi (slen);\n+      res.bounded = true;\n+      res.constant = true;\n+      return res;\n+    }\n+\n+  /* Determine the length of the shortest and longest string referenced\n+     by STR.  Strings of unknown lengths are bounded by the sizes of\n+     arrays that subexpressions of STR may refer to.  Pointers that\n+     aren't known to point any such arrays result in LENRANGE[1] set\n+     to SIZE_MAX.  */\n+  tree lenrange[2];\n+  get_range_strlen (str, lenrange);\n+\n+  if (lenrange [0] || lenrange [1])\n+    {\n+      fmtresult res = fmtresult ();\n+\n+      res.range.min = (tree_fits_uhwi_p (lenrange[0])\n+\t\t       ? tree_to_uhwi (lenrange[0]) : 1 < warn_format_length);\n+      res.range.max = (tree_fits_uhwi_p (lenrange[1])\n+\t\t       ? tree_to_uhwi (lenrange[1]) : HOST_WIDE_INT_M1U);\n+\n+      /* Set RES.BOUNDED to true if and only if all strings referenced\n+\t by STR are known to be bounded (though not necessarily by their\n+\t actual length but perhaps by their maximum possible length).  */\n+      res.bounded = res.range.max < HOST_WIDE_INT_MAX;\n+\n+      /* Set RES.CONSTANT to false even though that may be overly\n+\t conservative in rare cases like: 'x ? a : b' where a and\n+\t b have the same lengths and consist of the same characters.  */\n+      res.constant = false;\n+      return res;\n+    }\n+\n+  return get_string_length (NULL_TREE);\n+}\n+\n+/* Return the minimum and maximum number of characters formatted\n+   by the '%c' and '%s' format directives and ther wide character\n+   forms for the argument ARG.  ARG can be null (for functions\n+   such as vsprinf).  */\n+\n+static fmtresult\n+format_string (const conversion_spec &spec, tree arg)\n+{\n+  unsigned width = spec.have_width && 0 < spec.width ? spec.width : 0;\n+  int prec = spec.have_precision ? spec.precision : -1;\n+\n+  if (spec.star_width)\n+    {\n+      width = (TREE_CODE (spec.star_width) == INTEGER_CST\n+\t       ? tree_to_shwi (spec.star_width) : 0);\n+      if (width > INT_MAX)\n+\twidth = 0;\n+    }\n+\n+  if (spec.star_precision)\n+    prec = (TREE_CODE (spec.star_precision) == INTEGER_CST\n+\t    ? tree_to_shwi (spec.star_precision) : -1);\n+\n+  fmtresult res = fmtresult ();\n+\n+  /* The maximum number of bytes for an unknown wide character argument\n+     to a \"%lc\" directive adjusted for precision but not field width.  */\n+  const unsigned HOST_WIDE_INT max_bytes_for_unknown_wc\n+    = (1 == warn_format_length ? 0 <= prec ? prec : 0\n+       : 2 == warn_format_length ? 0 <= prec ? prec : 1\n+       : 0 <= prec ? prec : 6 /* Longest UTF-8 sequence.  */);\n+\n+  /* The maximum number of bytes for an unknown string argument to either\n+     a \"%s\" or \"%ls\" directive adjusted for precision but not field width.  */\n+  const unsigned HOST_WIDE_INT max_bytes_for_unknown_str\n+    = (1 == warn_format_length ? 0 <= prec ? prec : 0\n+       : 2 == warn_format_length ? 0 <= prec ? prec : 1\n+       : HOST_WIDE_INT_MAX);\n+\n+  if (spec.specifier == 'c')\n+    {\n+      if (spec.modifier == FMT_LEN_l)\n+\t{\n+\t  /* Positive if the argument is a wide NUL character?  */\n+\t  int nul = (arg && TREE_CODE (arg) == INTEGER_CST\n+\t\t     ? integer_zerop (arg) : -1);\n+\n+\t  /* A '%lc' directive is the same as '%ls' for a two element\n+\t     wide string character with the second element of NUL, so\n+\t     when the character is unknown the minimum number of bytes\n+\t     is the smaller of either 0 (at level 1) or 1 (at level 2)\n+\t     and WIDTH, and the maximum is MB_CUR_MAX in the selected\n+\t     locale, which is unfortunately, unknown.  */\n+\t  res.range.min = 1 == warn_format_length ? !nul : nul < 1;\n+\t  res.range.max = max_bytes_for_unknown_wc;\n+\t  res.bounded = true;\n+\t}\n+      else\n+\t{\n+\t  /* A plain '%c' directive.  */\n+\t  res.range.min = res.range.max = 1;\n+\t  res.bounded = true;\n+\t  res.constant = arg && TREE_CODE (arg) == INTEGER_CST;\n+\t}\n+    }\n+  else   /* spec.specifier == 's' */\n+    {\n+      /* Compute the range the argument's length can be in.  */\n+      fmtresult slen = get_string_length (arg);\n+      if (slen.constant)\n+\t{\n+\t  gcc_checking_assert (slen.range.min == slen.range.max);\n+\n+\t  res.bounded = true;\n+\n+\t  /* A '%s' directive with a string argument with constant length.  */\n+\t  res.range = slen.range;\n+\n+\t  if (spec.modifier == FMT_LEN_l)\n+\t    {\n+\t      if (warn_format_length > 2)\n+\t\t{\n+\t\t  res.range.min *= 6;\n+\n+\t\t  /* It's possible to be smarter about computing the maximum\n+\t\t     by scanning the wide string for any 8-bit characters and\n+\t\t     if it contains none, using its length for the maximum.\n+\t\t     Even though this would be simple to do it's unlikely to\n+\t\t     be worth it when dealing with wide characters.  */\n+\t\t  res.range.max *= 6;\n+\t\t}\n+\t      /* For a wide character string, use precision as the maximum\n+\t\t even if precision is greater than the string length since\n+\t\t the number of bytes the string converts to may be greater\n+\t\t (due to MB_CUR_MAX).  */\n+\t      if (0 <= prec)\n+\t\tres.range.max = prec;\n+\t    }\n+\t  else\n+\t    res.constant = true;\n+\n+\t  if (0 <= prec && (unsigned)prec < res.range.min)\n+\t    {\n+\t      res.range.min = prec;\n+\t      res.range.max = prec;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* For a '%s' and '%ls' directive with a non-constant string,\n+\t     the minimum number of characters is the greater of WIDTH\n+\t     and either 0 in mode 1 or the smaller of PRECISION and 1\n+\t     in mode 2, and the maximum is PRECISION or -1 to disable\n+\t     tracking.  */\n+\n+\t  if (0 <= prec)\n+\t    {\n+\t      if ((unsigned)prec < slen.range.min\n+\t\t  || slen.range.min >= HOST_WIDE_INT_MAX)\n+\t\tslen.range.min = prec;\n+\t      if ((unsigned)prec < slen.range.max\n+\t\t  || slen.range.max >= HOST_WIDE_INT_MAX)\n+\t\tslen.range.max = prec;\n+\t    }\n+\t  else if (slen.range.min >= HOST_WIDE_INT_MAX)\n+\t    {\n+\t      slen.range.min = max_bytes_for_unknown_str;\n+\t      slen.range.max = max_bytes_for_unknown_str;\n+\t    }\n+\n+\t  res.range = slen.range;\n+\n+\t  /* The output is considered bounded when a precision has been\n+\t     specified to limit the number of bytes or when the number\n+\t     of bytes is known or contrained to some range.  */\n+\t  res.bounded = 0 <= prec || slen.bounded;\n+\t  res.constant = false;\n+\t}\n+    }\n+\n+  /* Adjust the lengths for field width.  */\n+  if (res.range.min < width)\n+    res.range.min = width;\n+\n+  if (res.range.max < width)\n+    res.range.max = width;\n+\n+  /* Adjust BOUNDED if width happens to make them equal.  */\n+  if (res.range.min == res.range.max && res.range.min < HOST_WIDE_INT_MAX)\n+    res.bounded = true;\n+\n+  return res;\n+}\n+\n+/* Compute the length of the output resulting from the conversion\n+   specification SPEC with the argument ARG in a call described by INFO\n+   and update the overall result of the call in *RES.  The format directive\n+   corresponding to SPEC starts at CVTBEG and is CVTLEN characters long.  */\n+\n+static void\n+format_directive (const pass_sprintf_length::call_info &info,\n+\t\t  format_result *res, const char *cvtbeg, size_t cvtlen,\n+\t\t  const conversion_spec &spec, tree arg)\n+{\n+  /* Offset of the beginning of the directive from the beginning\n+     of the format string.  */\n+  size_t offset = cvtbeg - info.fmtstr;\n+\n+  /* Create a location for the whole directive from the % to the format\n+     specifier.  */\n+  substring_loc dirloc (info.fmtloc, TREE_TYPE (info.format),\n+\t\t\toffset, offset, offset + cvtlen - 1);\n+\n+  /* Also create a location range for the argument if possible.\n+     This doesn't work for integer literals or function calls.  */\n+  source_range argrange;\n+  source_range *pargrange;\n+  if (arg && CAN_HAVE_LOCATION_P (arg))\n+    {\n+      argrange = EXPR_LOCATION_RANGE (arg);\n+      pargrange = &argrange;\n+    }\n+  else\n+    pargrange = NULL;\n+\n+  /* Bail when there is no function to compute the output length,\n+     or when minimum length checking has been disabled.   */\n+  if (!spec.fmtfunc || res->number_chars_min >= HOST_WIDE_INT_MAX)\n+    return;\n+\n+  /* Compute the (approximate) length of the formatted output.  */\n+  fmtresult fmtres = spec.fmtfunc (spec, arg);\n+\n+  /* The overall result is bounded only if the output of every\n+     directive is exact or bounded.  */\n+  res->bounded = res->bounded && fmtres.bounded;\n+  res->constant = res->constant && fmtres.constant;\n+\n+  if (fmtres.range.max >= HOST_WIDE_INT_MAX)\n+    {\n+      /* Disable exact and maximum length checking after a failure\n+\t to determine the maximum number of characters (for example\n+\t for wide characters or wide character strings) but continue\n+\t tracking the minimum number of characters.  */\n+      res->number_chars_max = HOST_WIDE_INT_M1U;\n+      res->number_chars = HOST_WIDE_INT_M1U;\n+    }\n+\n+  if (fmtres.range.min >= HOST_WIDE_INT_MAX)\n+    {\n+      /* Disable exact length checking after a failure to determine\n+\t even the minimum number of characters (it shouldn't happen\n+\t except in an error) but keep tracking the minimum and maximum\n+\t number of characters.  */\n+      res->number_chars = HOST_WIDE_INT_M1U;\n+      return;\n+    }\n+\n+  /* Compute the number of available bytes in the destination.  There\n+     must always be at least one byte of space for the terminating\n+     NUL that's appended after the format string has been processed.  */\n+  unsigned HOST_WIDE_INT navail = min_bytes_remaining (info.objsize, *res);\n+\n+  if (fmtres.range.min < fmtres.range.max)\n+    {\n+      /* The result is a range (i.e., it's inexact).  */\n+      if (!res->warned)\n+\t{\n+\t  bool warned = false;\n+\n+\t  if (navail < fmtres.range.min)\n+\t    {\n+\t      /* The minimum directive output is longer than there is\n+\t\t room in the destination.  */\n+\t      if (fmtres.range.min == fmtres.range.max)\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"%wu bytes into a region of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t\t    (int)cvtlen, cvtbeg, fmtres.range.min,\n+\t\t\t\t    navail);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"between %wu and %wu bytes into a region of \"\n+\t\t\t    \"size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing between %wu and \"\n+\t\t\t    \"%wu bytes into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t\t    fmtres.range.min, fmtres.range.max, navail);\n+\t\t}\n+\t    }\n+\t  else if (navail < fmtres.range.max\n+\t\t   && (fmtres.bounded || 1 < warn_format_length))\n+\t    {\n+\t      /* The maximum directive output is longer than there is\n+\t\t room in the destination and the output is either bounded\n+\t\t or the warning level is greater than 1.  */\n+\t      if (fmtres.range.max >= HOST_WIDE_INT_MAX)\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n+\t\t\t    \"writing %wu or more bytes a region of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t\t    fmtres.range.min, navail);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n+\t\t\t    \"writing between %wu and %wu bytes into a region \"\n+\t\t\t    \"of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing between %wu and %wu \"\n+\t\t\t    \"bytes into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t\t    fmtres.range.min, fmtres.range.max,\n+\t\t\t\t    navail);\n+\t\t}\n+\t    }\n+\n+\t  res->warned |= warned;\n+\n+\t  if (warned && fmtres.argmin)\n+\t    {\n+\t      if (fmtres.argmin == fmtres.argmax)\n+\t\tinform (info.fmtloc, \"directive argument %qE\", fmtres.argmin);\n+\t      else if (fmtres.bounded)\n+\t\tinform (info.fmtloc, \"directive argument in the range [%E, %E]\",\n+\t\t\tfmtres.argmin, fmtres.argmax);\n+\t      else\n+\t\tinform (info.fmtloc,\n+\t\t\t\"using the range [%qE, %qE] for directive argument\",\n+\t\t\tfmtres.argmin, fmtres.argmax);\n+\t    }\n+\t}\n+\n+      /* Disable exact length checking but adjust the minimum and maximum.  */\n+      res->number_chars = HOST_WIDE_INT_M1U;\n+      if (res->number_chars_max < HOST_WIDE_INT_MAX\n+\t  && fmtres.range.max < HOST_WIDE_INT_MAX)\n+\tres->number_chars_max += fmtres.range.max;\n+\n+      res->number_chars_min += fmtres.range.min;\n+    }\n+  else\n+    {\n+      if (!res->warned && 0 < fmtres.range.min && navail < fmtres.range.min)\n+\t{\n+\t  const char* fmtstr\n+\t    = (info.bounded\n+\t       ? (1 < fmtres.range.min\n+\t\t  ? G_(\"%<%.*s%> directive output truncated while writing \"\n+\t\t       \"%wu bytes into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive output truncated while writing \"\n+\t\t       \"%wu byte into a region of size %wu\"))\n+\t       : (1 < fmtres.range.min\n+\t\t  ? G_(\"%<%.*s%> directive writing %wu bytes \"\n+\t\t       \"into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive writing %wu byte \"\n+\t\t       \"into a region of size %wu\")));\n+\n+\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t OPT_Wformat_length_, fmtstr,\n+\t\t\t\t (int)cvtlen, cvtbeg, fmtres.range.min,\n+\t\t\t\t navail);\n+\t}\n+      *res += fmtres.range.min;\n+    }\n+\n+  /* Has the minimum directive output length exceeded the maximum\n+     of 4095 bytes required to be supported?  */\n+  bool minunder4k = fmtres.range.min < 4096;\n+  if (!minunder4k || fmtres.range.max > 4095)\n+    res->under4k = false;\n+\n+  if (!res->warned && 1 < warn_format_length\n+      && (!minunder4k || fmtres.range.max > 4095))\n+    {\n+      /* The directive output may be longer than the maximum required\n+\t to be handled by an implementation according to 7.21.6.1, p15\n+\t of C11.  Warn on this only at level 2 but remember this and\n+\t prevent folding the return value when done.  This allows for\n+\t the possibility of the actual libc call failing due to ENOMEM\n+\t (like Glibc does under some conditions).  */\n+\n+      if (fmtres.range.min == fmtres.range.max)\n+\tres->warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t       OPT_Wformat_length_,\n+\t\t\t       \"%<%.*s%> directive output of %wu bytes exceeds \"\n+\t\t\t       \"minimum required size of 4095\",\n+\t\t\t       (int)cvtlen, cvtbeg, fmtres.range.min);\n+      else\n+\t{\n+\t  const char *fmtstr\n+\t    = (minunder4k\n+\t       ? G_(\"%<%.*s%> directive output between %qu and %wu \"\n+\t\t    \"bytes may exceed minimum required size of 4095\")\n+\t       : G_(\"%<%.*s%> directive output between %qu and %wu \"\n+\t\t    \"bytes exceeds minimum required size of 4095\"));\n+\n+\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t OPT_Wformat_length_, fmtstr,\n+\t\t\t\t (int)cvtlen, cvtbeg,\n+\t\t\t\t fmtres.range.min, fmtres.range.max);\n+\t}\n+    }\n+\n+  /* Has the minimum directive output length exceeded INT_MAX?  */\n+  bool exceedmin = res->number_chars_min > target_int_max ();\n+\n+  if (!res->warned\n+      && (exceedmin\n+\t  || (1 < warn_format_length\n+\t      && res->number_chars_max > target_int_max ())))\n+    {\n+      /* The directive output causes the total length of output\n+\t to exceed INT_MAX bytes.  */\n+\n+      if (fmtres.range.min == fmtres.range.max)\n+\tres->warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t       OPT_Wformat_length_,\n+\t\t\t       \"%<%.*s%> directive output of %wu bytes causes \"\n+\t\t\t       \"result to exceed %<INT_MAX%>\",\n+\t\t\t       (int)cvtlen, cvtbeg, fmtres.range.min);\n+      else\n+\t{\n+\t  const char *fmtstr\n+\t    = (exceedmin\n+\t       ? G_ (\"%<%.*s%> directive output between %wu and %wu \"\n+\t\t     \"bytes causes result to exceed %<INT_MAX%>\")\n+\t       : G_ (\"%<%.*s%> directive output between %wu and %wu \"\n+\t\t     \"bytes may cause result to exceed %<INT_MAX%>\"));\n+\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t OPT_Wformat_length_, fmtstr,\n+\t\t\t\t (int)cvtlen, cvtbeg,\n+\t\t\t\t fmtres.range.min, fmtres.range.max);\n+\t}\n+    }\n+}\n+\n+/* Account for the number of bytes between BEG and END (or between\n+   BEG + strlen (BEG) when END is null) in the format string in a call\n+   to a formatted output function described by INFO.  Reflect the count\n+   in RES and issue warnings as appropriate.  */\n+\n+static void\n+add_bytes (const pass_sprintf_length::call_info &info,\n+\t   const char *beg, const char *end, format_result *res)\n+{\n+  if (res->number_chars_min >= HOST_WIDE_INT_MAX)\n+    return;\n+\n+  /* The number of bytes to output is the number of bytes between\n+     the end of the last directive and the beginning of the next\n+     one if it exists, otherwise the number of characters remaining\n+     in the format string plus 1 for the terminating NUL.  */\n+  size_t nbytes = end ? end - beg : strlen (beg) + 1;\n+\n+  /* Return if there are no bytes to add at this time but there are\n+     directives remaining in the format string.  */\n+  if (!nbytes)\n+    return;\n+\n+  /* Compute the range of available bytes in the destination.  There\n+     must always be at least one byte left for the terminating NUL\n+     that's appended after the format string has been processed.  */\n+  result_range avail_range = bytes_remaining (info.objsize, *res);\n+\n+  /* If issuing a diagnostic (only when one hasn't already been issued),\n+     distinguish between a possible overflow (\"may write\") and a certain\n+     overflow somewhere \"past the end.\"  (Ditto for truncation.)  */\n+  if (!res->warned\n+      && (avail_range.max < nbytes\n+\t  || ((res->bounded || 1 < warn_format_length)\n+\t      && avail_range.min < nbytes)))\n+    {\n+      /* Set NAVAIL to the number of available bytes used to decide\n+\t whether or not to issue a warning below.  The exact kind of\n+\t warning will depend on AVAIL_RANGE.  */\n+      unsigned HOST_WIDE_INT navail = avail_range.max;\n+      if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n+\t  && (res->bounded || 1 < warn_format_length))\n+\tnavail = avail_range.min;\n+\n+      /* Compute the offset of the first format character that is beyond\n+\t the end of the destination region and the length of the rest of\n+\t the format string from that point on.  */\n+      unsigned HOST_WIDE_INT off\n+\t= (unsigned HOST_WIDE_INT)(beg - info.fmtstr) + navail;\n+\n+      size_t len = strlen (info.fmtstr + off);\n+\n+      substring_loc loc\n+\t(info.fmtloc, TREE_TYPE (info.format), off - !len, len ? off : 0,\n+\t off + len - !!len);\n+\n+      /* Is the output of the last directive the result of the argument\n+\t being within a range whose lower bound would fit in the buffer\n+\t but the upper bound would not?  If so, use the word \"may\" to\n+\t indicate that the overflow/truncation may (but need not) happen.  */\n+      bool boundrange\n+\t= (res->number_chars_min < res->number_chars_max\n+\t   && res->number_chars_min < info.objsize);\n+\n+      if (!end && (nbytes - navail) == 1)\n+\t{\n+\t  /* There is room for the rest of the format string but none\n+\t     for the terminating nul.  */\n+\t  const char *text\n+\t    = (info.bounded   // Snprintf and the like.\n+\t       ? (boundrange\n+\t\t  ? G_(\"output may be truncated before the last format character\"\n+\t\t       : \"output truncated before the last format character\"))\n+\t       : (boundrange\n+\t\t  ? G_(\"may write a terminating nul past the end \"\n+\t\t       \"of the destination\")\n+\t\t  : G_(\"writing a terminating nul past the end \"\n+\t\t       \"of the destination\")));\n+\n+\t  res->warned = fmtwarn (loc, NULL, NULL, OPT_Wformat_length_, text);\n+\t}\n+      else\n+\t{\n+\t  /* There isn't enough room for 1 or more characters that remain\n+\t     to copy from the format string.  */\n+\t  const char *text\n+\t    = (info.bounded   // Snprintf and the like.\n+\t       ? (boundrange\n+\t\t  ? G_(\"output may be truncated at or before format character \"\n+\t\t       \"%qc at offset %wu\")\n+\t\t  : G_(\"output truncated at format character %qc at offset %wu\"))\n+\t       : (res->number_chars >= HOST_WIDE_INT_MAX\n+\t\t  ? G_(\"may write format character %#qc at offset %wu past \"\n+\t\t       \"the end of the destination\")\n+\t\t  : G_(\"writing format character %#qc at offset %wu past \"\n+\t\t       \"the end of the destination\")));\n+\n+\t  res->warned = fmtwarn (loc, NULL, NULL, OPT_Wformat_length_,\n+\t\t\t\t text, info.fmtstr[off], off);\n+\t}\n+    }\n+\n+  if (res->warned && !end && info.objsize < HOST_WIDE_INT_MAX)\n+    {\n+      /* If a warning has been issued for buffer overflow or truncation\n+\t (but not otherwise) help the user figure out how big a buffer\n+\t they need.  */\n+\n+      location_t callloc = gimple_location (info.callstmt);\n+\n+      unsigned HOST_WIDE_INT min = res->number_chars_min;\n+      unsigned HOST_WIDE_INT max = res->number_chars_max;\n+      unsigned HOST_WIDE_INT exact\n+\t= (res->number_chars < HOST_WIDE_INT_MAX\n+\t   ? res->number_chars : res->number_chars_min);\n+\n+      if (min < max && max < HOST_WIDE_INT_MAX)\n+\tinform (callloc,\n+\t\t\"format output between %wu and %wu bytes into \"\n+\t\t\"a destination of size %wu\",\n+\t\tmin + nbytes, max + nbytes, info.objsize);\n+      else\n+\tinform (callloc,\n+\t\t(nbytes + exact == 1\n+\t\t ? G_(\"format output %wu byte into a destination of size %wu\")\n+\t\t : G_(\"format output %wu bytes into a destination of size %wu\")),\n+\t\tnbytes + exact, info.objsize);\n+    }\n+\n+  /* Add the number of bytes and then check for INT_MAX overflow.  */\n+  *res += nbytes;\n+\n+  /* Has the minimum output length minus the terminating nul exceeded\n+     INT_MAX?  */\n+  bool exceedmin = (res->number_chars_min - !end) > target_int_max ();\n+\n+  if (!res->warned\n+      && (exceedmin\n+\t  || (1 < warn_format_length\n+\t      && (res->number_chars_max - !end) > target_int_max ())))\n+    {\n+      /* The function's output exceeds INT_MAX bytes.  */\n+\n+      /* Set NAVAIL to the number of available bytes used to decide\n+\t whether or not to issue a warning below.  The exact kind of\n+\t warning will depend on AVAIL_RANGE.  */\n+      unsigned HOST_WIDE_INT navail = avail_range.max;\n+      if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n+\t  && (res->bounded || 1 < warn_format_length))\n+\tnavail = avail_range.min;\n+\n+      /* Compute the offset of the first format character that is beyond\n+\t the end of the destination region and the length of the rest of\n+\t the format string from that point on.  */\n+      unsigned HOST_WIDE_INT off = (unsigned HOST_WIDE_INT)(beg - info.fmtstr);\n+      if (navail < HOST_WIDE_INT_MAX)\n+\toff += navail;\n+\n+      size_t len = strlen (info.fmtstr + off);\n+\n+      substring_loc loc\n+\t(info.fmtloc, TREE_TYPE (info.format), off - !len, len ? off : 0,\n+\t off + len - !!len);\n+\n+      if (res->number_chars_min == res->number_chars_max)\n+\tres->warned = fmtwarn (loc, NULL, NULL,\n+\t\t\t       OPT_Wformat_length_,\n+\t\t\t       \"output of %wu bytes causes \"\n+\t\t\t       \"result to exceed %<INT_MAX%>\",\n+\t\t\t       res->number_chars_min - !end);\n+      else\n+\t{\n+\t  const char *text\n+\t    = (exceedmin\n+\t       ? G_ (\"output between %wu and %wu bytes causes \"\n+\t\t     \"result to exceed %<INT_MAX%>\")\n+\t       : G_ (\"output between %wu and %wu bytes may cause \"\n+\t\t     \"result to exceed %<INT_MAX%>\"));\n+\t  res->warned = fmtwarn (loc, NULL, NULL, OPT_Wformat_length_,\n+\t\t\t\t text,\n+\t\t\t\t res->number_chars_min - !end,\n+\t\t\t\t res->number_chars_max - !end);\n+\t}\n+    }\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+/* Compute the length of the output resulting from the call to a formatted\n+   output function described by INFO and store the result of the call in\n+   *RES.  Issue warnings for detected past the end writes.  */\n+\n+void\n+pass_sprintf_length::compute_format_length (const call_info &info,\n+\t\t\t\t\t    format_result *res)\n+{\n+  /* The variadic argument counter.  */\n+  unsigned argno = info.argidx;\n+\n+  /* Reset exact, minimum, and maximum character counters.  */\n+  res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n+\n+  /* No directive has been seen yet so the output is bounded and constant\n+     (with no conversion producing more than 4K bytes) until determined\n+     otherwise.  */\n+  res->bounded = true;\n+  res->constant = true;\n+  res->under4k = true;\n+  res->floating = false;\n+  res->warned = false;\n+\n+  const char *pf = info.fmtstr;\n+\n+  for ( ; ; )\n+    {\n+      /* The beginning of the next format directive.  */\n+      const char *dir = strchr (pf, '%');\n+\n+      /* Add the number of bytes between the end of the last directive\n+\t and either the next if one exists, or the end of the format\n+\t string.  */\n+      add_bytes (info, pf, dir, res);\n+\n+      if (!dir)\n+\tbreak;\n+\n+      pf = dir + 1;\n+\n+      if (0 && *pf == 0)\n+\t{\n+\t  /* Incomplete directive.  */\n+\t  return;\n+\t}\n+\n+      conversion_spec spec = conversion_spec ();\n+\n+      /* POSIX numbered argument index or zero when none.  */\n+      unsigned dollar = 0;\n+\n+      if (ISDIGIT (*pf))\n+\t{\n+\t  /* This could be either a POSIX positional argument, the '0'\n+\t     flag, or a width, depending on what follows.  Store it as\n+\t     width and sort it out later after the next character has\n+\t     been seen.  */\n+\t  char *end;\n+\t  spec.width = strtol (pf, &end, 10);\n+\t  spec.have_width = true;\n+\t  pf = end;\n+\t}\n+      else if ('*' == *pf)\n+\t{\n+\t  /* Similarly to the block above, this could be either a POSIX\n+\t     positional argument or a width, depending on what follows.  */\n+\t  if (argno < gimple_call_num_args (info.callstmt))\n+\t    spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t  else\n+\t    return;\n+\t  ++pf;\n+\t}\n+\n+      if (*pf == '$')\n+\t{\n+\t  /* Handle the POSIX dollar sign which references the 1-based\n+\t     positional argument number.  */\n+\t  if (spec.have_width)\n+\t    dollar = spec.width + info.argidx;\n+\t  else if (spec.star_width\n+\t\t   && TREE_CODE (spec.star_width) == INTEGER_CST)\n+\t    dollar = spec.width + tree_to_shwi (spec.star_width);\n+\n+\t  /* Bail when the numbered argument is out of range (it will\n+\t     have already been diagnosed by -Wformat).  */\n+\t  if (dollar == 0\n+\t      || dollar == info.argidx\n+\t      || dollar > gimple_call_num_args (info.callstmt))\n+\t    return;\n+\n+\t  --dollar;\n+\n+\t  spec.star_width = NULL_TREE;\n+\t  spec.have_width = false;\n+\t  ++pf;\n+\t}\n+\n+      if (dollar || !spec.star_width)\n+\t{\n+\t  if (spec.have_width && spec.width == 0)\n+\t    {\n+\t      /* The '0' that has been interpreted as a width above is\n+\t\t actually a flag.  Reset HAVE_WIDTH, set the '0' flag,\n+\t\t and continue processing other flags.  */\n+\t      spec.have_width = false;\n+\t      spec.set_flag ('0');\n+\t    }\n+\t  /* When either '$' has been seen, or width has not been seen,\n+\t     the next field is the optional flags followed by an optional\n+\t     width.  */\n+\t  for ( ; ; ) {\n+\t    switch (*pf)\n+\t      {\n+\t      case ' ':\n+\t      case '0':\n+\t      case '+':\n+\t      case '-':\n+\t      case '#':\n+\t\tspec.set_flag (*pf++);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgoto start_width;\n+\t      }\n+\t  }\n+\n+\tstart_width:\n+\t  if (ISDIGIT (*pf))\n+\t    {\n+\t      char *end;\n+\t      spec.width = strtol (pf, &end, 10);\n+\t      spec.have_width = true;\n+\t      pf = end;\n+\t    }\n+\t  else if ('*' == *pf)\n+\t    {\n+\t      spec.star_width = gimple_call_arg (info.callstmt, argno++);\n+\t      ++pf;\n+\t    }\n+\t  else if ('\\'' == *pf)\n+\t    {\n+\t      /* The POSIX apostrophe indicating a numeric grouping\n+\t\t in the current locale.  Even though it's possible to\n+\t\t estimate the upper bound on the size of the output\n+\t\t based on the number of digits it probably isn't worth\n+\t\t continuing.  */\n+\t      return;\n+\t    }\n+\t}\n+\n+      if ('.' == *pf)\n+\t{\n+\t  ++pf;\n+\n+\t  if (ISDIGIT (*pf))\n+\t    {\n+\t      char *end;\n+\t      spec.precision = strtol (pf, &end, 10);\n+\t      spec.have_precision = true;\n+\t      pf = end;\n+\t    }\n+\t  else if ('*' == *pf)\n+\t    {\n+\t      spec.star_precision = gimple_call_arg (info.callstmt, argno++);\n+\t      ++pf;\n+\t    }\n+\t  else\n+\t    return;\n+\t}\n+\n+      switch (*pf)\n+\t{\n+\tcase 'h':\n+\t  if (pf[1] == 'h')\n+\t    {\n+\t      ++pf;\n+\t      spec.modifier = FMT_LEN_hh;\n+\t    }\n+\t  else\n+\t    spec.modifier = FMT_LEN_h;\n+\t  ++pf;\n+\t  break;\n+\n+\tcase 'j':\n+\t  spec.modifier = FMT_LEN_j;\n+\t  ++pf;\n+\t  break;\n+\n+\tcase 'L':\n+\t  spec.modifier = FMT_LEN_L;\n+\t  ++pf;\n+\t  break;\n+\n+\tcase 'l':\n+\t  if (pf[1] == 'l')\n+\t    {\n+\t      ++pf;\n+\t      spec.modifier = FMT_LEN_ll;\n+\t    }\n+\t  else\n+\t    spec.modifier = FMT_LEN_l;\n+\t  ++pf;\n+\t  break;\n+\n+\tcase 't':\n+\t  spec.modifier = FMT_LEN_t;\n+\t  ++pf;\n+\t  break;\n+\n+\tcase 'z':\n+\t  spec.modifier = FMT_LEN_z;\n+\t  ++pf;\n+\t  break;\n+\t}\n+\n+      switch (*pf)\n+\t{\n+\t  /* Handle a sole '%' character the same as \"%%\" but since it's\n+\t     undefined prevent the result from being folded.  */\n+\tcase '\\0':\n+\t  --pf;\n+\t  res->bounded = false;\n+\tcase '%':\n+\t  spec.fmtfunc = format_percent;\n+\t  break;\n+\n+\tcase 'a':\n+\tcase 'A':\n+\tcase 'e':\n+\tcase 'E':\n+\tcase 'f':\n+\tcase 'F':\n+\tcase 'g':\n+\tcase 'G':\n+\t  res->floating = true;\n+\t  spec.fmtfunc = format_floating;\n+\t  break;\n+\n+\tcase 'd':\n+\tcase 'i':\n+\tcase 'o':\n+\tcase 'u':\n+\tcase 'x':\n+\tcase 'X':\n+\t  spec.fmtfunc = format_integer;\n+\t  break;\n+\n+\tcase 'p':\n+\t  spec.fmtfunc = format_pointer;\n+\t  break;\n+\n+\tcase 'n':\n+\t  return;\n+\n+\tcase 'c':\n+\tcase 'S':\n+\tcase 's':\n+\t  spec.fmtfunc = format_string;\n+\t  break;\n+\n+\tdefault:\n+\t  return;\n+\t}\n+\n+      spec.specifier = *pf++;\n+\n+      /* Compute the length of the format directive.  */\n+      size_t dirlen = pf - dir;\n+\n+      /* Extract the argument if the directive takes one and if it's\n+\t available (e.g., the function doesn't take a va_list).  Treat\n+\t missing arguments the same as va_list, even though they will\n+\t have likely already been diagnosed by -Wformat.  */\n+      tree arg = NULL_TREE;\n+      if (spec.specifier != '%'\n+\t  && argno < gimple_call_num_args (info.callstmt))\n+\targ = gimple_call_arg (info.callstmt, dollar ? dollar : argno++);\n+\n+      ::format_directive (info, res, dir, dirlen, spec, arg);\n+    }\n+}\n+\n+/* Return the size of the object referenced by the expression DEST if\n+   available, or -1 otherwise.  */\n+\n+static unsigned HOST_WIDE_INT\n+get_destination_size (tree dest)\n+{\n+  /* Use __builtin_object_size to determine the size of the destination\n+     object.  When optimizing, determine the smallest object (such as\n+     a member array as opposed to the whole enclosing object), otherwise\n+     use type-zero object size to determine the size of the enclosing\n+     object (the function fails without optimization in this type).  */\n+  int ost = 0 < optimize;\n+  unsigned HOST_WIDE_INT size;\n+  if (compute_builtin_object_size (dest, ost, &size))\n+    return size;\n+\n+  return HOST_WIDE_INT_M1U;\n+}\n+\n+/* Given a suitable result RES of a call to a formatted output function\n+   described by INFO, substitute the result for the return value of\n+   the call.  The result is suitable if the number of bytes it represents\n+   is known and exact.  A result that isn't suitable for substitution may\n+   have its range set to the range of return values, if that is known.  */\n+\n+static void\n+try_substitute_return_value (gimple_stmt_iterator gsi,\n+\t\t\t     const pass_sprintf_length::call_info &info,\n+\t\t\t     const format_result &res)\n+{\n+  tree lhs = gimple_get_lhs (info.callstmt);\n+\n+  /* Avoid the return value optimization when the behavior of the call\n+     is undefined either because any directive may have produced 4K or\n+     more of output, or the return value exceeds INT_MAX, or because\n+     the output overflows the destination object (but leave it enabled\n+     when the function is bounded because then the behavior is well-\n+     defined).  */\n+  if (lhs && res.bounded && res.under4k\n+      && (info.bounded || res.number_chars <= info.objsize)\n+      && res.number_chars - 1 <= target_int_max ())\n+    {\n+      /* Replace the left-hand side of the call with the constant\n+\t result of the formatted function minus 1 for the terminating\n+\t NUL which the functions' return value does not include.  */\n+      gimple_call_set_lhs (info.callstmt, NULL_TREE);\n+      tree cst = build_int_cst (integer_type_node, res.number_chars - 1);\n+      gimple *g = gimple_build_assign (lhs, cst);\n+      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+      update_stmt (info.callstmt);\n+\n+      if (dump_file)\n+\t{\n+\t  location_t callloc = gimple_location (info.callstmt);\n+\t  fprintf (dump_file, \"On line %i substituting \",\n+\t\t   LOCATION_LINE (callloc));\n+\t  print_generic_expr (dump_file, cst, dump_flags);\n+\t  fprintf (dump_file, \" for \");\n+\t  print_generic_expr (dump_file, info.func, dump_flags);\n+\t  fprintf (dump_file, \" return value (output %s).\\n\",\n+\t\t   res.constant ? \"constant\" : \"variable\");\n+\t}\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT maxbytes;\n+\n+      if (lhs\n+\t  && ((maxbytes = res.number_chars - 1) <= target_int_max ()\n+\t      || (res.number_chars_min - 1 <= target_int_max ()\n+\t\t  && (maxbytes = res.number_chars_max - 1) <= target_int_max ()))\n+\t  && (info.bounded || maxbytes < info.objsize))\n+\t{\n+\t  /* If the result is in a valid range bounded by the size of\n+\t     the destination set it so that it can be used for subsequent\n+\t     optimizations.  */\n+\t  int prec = TYPE_PRECISION (integer_type_node);\n+\n+\t  if (res.number_chars < target_int_max () && res.under4k)\n+\t    {\n+\t      wide_int num = wi::shwi (res.number_chars - 1, prec);\n+\t      set_range_info (lhs, VR_RANGE, num, num);\n+\t    }\n+\t  else if (res.number_chars_min < target_int_max ()\n+\t\t   && res.number_chars_max < target_int_max ())\n+\t    {\n+\t      wide_int min = wi::shwi (res.under4k ? res.number_chars_min - 1\n+\t\t\t\t       : target_int_min (), prec);\n+\t      wide_int max = wi::shwi (res.number_chars_max - 1, prec);\n+\t      set_range_info (lhs, VR_RANGE, min, max);\n+\t    }\n+\t}\n+\n+      if (dump_file)\n+\t{\n+\t  const char *inbounds\n+\t    = (res.number_chars_min <= info.objsize\n+\t       ? (res.number_chars_max <= info.objsize\n+\t\t  ? \"in\" : \"potentially out-of\")\n+\t       : \"out-of\");\n+\n+\t  location_t callloc = gimple_location (info.callstmt);\n+\t  fprintf (dump_file, \"On line %i \", LOCATION_LINE (callloc));\n+\t  print_generic_expr (dump_file, info.func, dump_flags);\n+\n+\t  const char *ign = lhs ? \"\" : \" ignored\";\n+\t  if (res.number_chars >= HOST_WIDE_INT_MAX)\n+\t    fprintf (dump_file,\n+\t\t     \" %s-bounds return value in range [%lu, %lu]%s.\\n\",\n+\t\t     inbounds,\n+\t\t     (unsigned long)res.number_chars_min,\n+\t\t     (unsigned long)res.number_chars_max, ign);\n+\t  else\n+\t    fprintf (dump_file, \" %s-bounds return value %lu%s.\\n\",\n+\t\t     inbounds, (unsigned long)res.number_chars, ign);\n+\t}\n+    }\n+}\n+\n+/* Determine if a GIMPLE CALL is to one of the sprintf-like built-in\n+   functions and if so, handle it.  */\n+\n+void\n+pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator gsi)\n+{\n+  call_info info = call_info ();\n+\n+  info.callstmt = gsi_stmt (gsi);\n+  info.func = gimple_call_fn (info.callstmt);\n+  if (!info.func)\n+    return;\n+\n+  if (TREE_CODE (info.func) == ADDR_EXPR)\n+    info.func = TREE_OPERAND (info.func, 0);\n+\n+  if (TREE_CODE (info.func) != FUNCTION_DECL\n+      || !DECL_BUILT_IN(info.func)\n+      || DECL_BUILT_IN_CLASS (info.func) != BUILT_IN_NORMAL)\n+    return;\n+\n+  info.fncode = DECL_FUNCTION_CODE (info.func);\n+\n+  /* The size of the destination as in snprintf(dest, size, ...).  */\n+  unsigned HOST_WIDE_INT dstsize = HOST_WIDE_INT_M1U;\n+\n+  /* The size of the destination determined by __builtin_object_size.  */\n+  unsigned HOST_WIDE_INT objsize = HOST_WIDE_INT_M1U;\n+\n+  /* Buffer size argument number (snprintf and vsnprintf).  */\n+  unsigned HOST_WIDE_INT idx_dstsize = HOST_WIDE_INT_M1U;\n+\n+  /* Object size argument number (snprintf_chk and vsnprintf_chk).  */\n+  unsigned HOST_WIDE_INT idx_objsize = HOST_WIDE_INT_M1U;\n+\n+  /* Format string argument number (valid for all functions).  */\n+  unsigned idx_format;\n+\n+  switch (info.fncode)\n+    {\n+    case BUILT_IN_SPRINTF:\n+      // Signature:\n+      //   __builtin_sprintf (dst, format, ...)\n+      idx_format = 1;\n+      info.argidx = 2;\n+      break;\n+\n+    case BUILT_IN_SNPRINTF:\n+      // Signature:\n+      //   __builtin_snprintf (dst, size, format, ...)\n+      idx_dstsize = 1;\n+      idx_format = 2;\n+      info.argidx = 3;\n+      info.bounded = true;\n+      break;\n+\n+    case BUILT_IN_SNPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___sprintf_chk (dst, size, ost, objsize, format, ...)\n+      idx_dstsize = 1;\n+      idx_objsize = 3;\n+      idx_format = 4;\n+      info.argidx = 5;\n+      info.bounded = true;\n+      break;\n+\n+    case BUILT_IN_SPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___sprintf_chk (dst, ost, objsize, format, ...)\n+      idx_objsize = 2;\n+      idx_format = 3;\n+      info.argidx = 4;\n+      break;\n+\n+    case BUILT_IN_VSNPRINTF:\n+      // Signature:\n+      //   __builtin_vsprintf (dst, size, format, va)\n+      idx_dstsize = 1;\n+      idx_format = 2;\n+      info.argidx = -1;\n+      info.bounded = true;\n+      break;\n+\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___vsnprintf_chk (dst, size, ost, objsize, format, va)\n+      idx_dstsize = 1;\n+      idx_objsize = 2;\n+      idx_format = 3;\n+      info.argidx = -1;\n+      info.bounded = true;\n+      break;\n+\n+    case BUILT_IN_VSPRINTF:\n+      // Signature:\n+      //   __builtin_vsprintf (dst, format, va)\n+      idx_format = 1;\n+      info.argidx = -1;\n+      break;\n+\n+    case BUILT_IN_VSPRINTF_CHK:\n+      // Signature:\n+      //   __builtin___vsprintf_chk (dst, ost, objsize, format, va)\n+      idx_format = 3;\n+      idx_objsize = 2;\n+      info.argidx = -1;\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  info.format = gimple_call_arg (info.callstmt, idx_format);\n+\n+  if (idx_dstsize == HOST_WIDE_INT_M1U)\n+    {\n+      // For non-bounded functions like sprintf, to to determine\n+      // the size of the destination from the object or pointer\n+      // passed to it as the first argument.\n+      dstsize = get_destination_size (gimple_call_arg (info.callstmt, 0));\n+    }\n+  else if (tree size = gimple_call_arg (info.callstmt, idx_dstsize))\n+    {\n+      /* For bounded functions try to get the size argument.  */\n+\n+      if (TREE_CODE (size) == INTEGER_CST)\n+\t{\n+\t  dstsize = tree_to_uhwi (size);\n+\t  /* No object can be larger than HOST_WIDE_INT_MAX bytes\n+\t     (half the address space).  This imposes a limit that's\n+\t     one byte less than that.  */\n+\t  if (dstsize >= HOST_WIDE_INT_MAX)\n+\t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n+\t\t\t\"specified destination size %wu too large\",\n+\t\t\tdstsize);\n+\t}\n+      else if (TREE_CODE (size) == SSA_NAME)\n+\t{\n+\t  /* Try to determine the range of values of the argument\n+\t     and use the greater of the two at -Wformat-level 1 and\n+\t     the smaller of them at level 2.  */\n+\t  wide_int min, max;\n+\t  enum value_range_type range_type\n+\t    = get_range_info (size, &min, &max);\n+\t  if (range_type == VR_RANGE)\n+\t    {\n+\t      dstsize\n+\t\t= (warn_format_length < 2\n+\t\t   ? wi::fits_uhwi_p (max) ? max.to_uhwi () : max.to_shwi ()\n+\t\t   : wi::fits_uhwi_p (min) ? min.to_uhwi () : min.to_shwi ());\n+\t    }\n+\t}\n+    }\n+\n+  if (idx_objsize != HOST_WIDE_INT_M1U)\n+    {\n+      if (tree size = gimple_call_arg (info.callstmt, idx_objsize))\n+\t  if (tree_fits_uhwi_p (size))\n+\t    objsize = tree_to_uhwi (size);\n+    }\n+\n+  if (info.bounded && !dstsize)\n+    {\n+      /* As a special case, when the explicitly specified destination\n+\t size argument (to a bounded function like snprintf) is zero\n+\t it is a request to determine the number of bytes on output\n+\t without actually producing any.  Pretend the size is\n+\t unlimited in this case.  */\n+      info.objsize = HOST_WIDE_INT_MAX;\n+    }\n+  else\n+    {\n+      /* Set the object size to the smaller of the two arguments\n+\t of both have been specified and they're not equal.  */\n+      info.objsize = dstsize < objsize ? dstsize : objsize;\n+\n+      if (info.bounded\n+\t  && dstsize != HOST_WIDE_INT_M1U && objsize < dstsize)\n+\t{\n+\t  warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n+\t\t      \"specified size %wu exceeds the size %wu \"\n+\t\t      \"of the destination object\", dstsize, objsize);\n+\t}\n+    }\n+\n+  if (integer_zerop (info.format))\n+    {\n+      /* This is diagnosed with -Wformat only when the null is a constant\n+\t pointer.  The warning here diagnoses instances where the pointer\n+\t is not constant.  */\n+      warning_at (EXPR_LOC_OR_LOC (info.format, input_location),\n+\t\t  OPT_Wformat_length_, \"null format string\");\n+      return;\n+    }\n+\n+  info.fmtstr = get_format_string (info.format, &info.fmtloc);\n+  if (!info.fmtstr)\n+    return;\n+\n+  /* The result is the number of bytes output by the formatted function,\n+     including the terminating NUL.  */\n+  format_result res = format_result ();\n+  compute_format_length (info, &res);\n+\n+  /* When optimizing and the printf return value optimization is enabled,\n+     attempt to substitute the computed result for the return value of\n+     the call.  Avoid this optimization when -frounding-math is in effect\n+     and the format string contains a floating point directive.  */\n+  if (0 < optimize && flag_printf_return_value\n+      && (!flag_rounding_math || !res.floating))\n+    try_substitute_return_value (gsi, info, res);\n+}\n+\n+/* Execute the pass for function FUN.  */\n+\n+unsigned int\n+pass_sprintf_length::execute (function *fun)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, fun)\n+    {\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  /* Iterate over statements, looking for function calls.  */\n+\t  gimple *stmt = gsi_stmt (si);\n+\n+\t  if (gimple_code (stmt) == GIMPLE_CALL)\n+\t    handle_gimple_call (si);\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+}   /* Unnamed namespace.  */\n+\n+/* Return a pointer to a pass object newly constructed from the context\n+   CTXT.  */\n+\n+gimple_opt_pass *\n+make_pass_sprintf_length (gcc::context *ctxt)\n+{\n+  return new pass_sprintf_length (ctxt);\n+}"}, {"sha": "1375254e971fa70e8a8b4d8e50b6b369f8811a0c", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_expand_omp);\n   NEXT_PASS (pass_build_cgraph_edges);\n+  NEXT_PASS (pass_sprintf_length, false);\n   TERMINATE_PASS_LIST (all_lowering_passes)\n \n   /* Interprocedural optimization passes.  */\n@@ -306,6 +307,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_simduid_cleanup);\n       NEXT_PASS (pass_lower_vector_ssa);\n       NEXT_PASS (pass_cse_reciprocals);\n+      NEXT_PASS (pass_sprintf_length, true);\n       NEXT_PASS (pass_reassoc, false /* insert_powi_p */);\n       NEXT_PASS (pass_strength_reduction);\n       NEXT_PASS (pass_split_paths);"}, {"sha": "60957f9525974be74ef8f1b7cdabe50a0718ad2a", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -769,7 +769,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n \tcase VECTOR_CST:\n \t  {\n-\t    char buf[10];\n+\t    /* Big enough for 2 UINT_MAX plus the string below.  */\n+\t    char buf[32];\n \t    unsigned i;\n \n \t    for (i = 0; i < VECTOR_CST_NELTS (node); ++i)"}, {"sha": "33acc79d5ed24f24293158bf69dcc2fb46631ad0", "filename": "gcc/target.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -3353,6 +3353,12 @@ greater than 128 and a multiple of 32.\",\n  machine_mode, (int n, bool extended),\n  default_floatn_mode)\n \n+DEFHOOK\n+(printf_pointer_format,\n+ \"Determine the target @code{printf} implementation format string that the most closely corresponds to the @code{%p} format directive.  The object pointed to by the @var{flags} is set to a string consisting of recognized format flags such as the @code{'#'} character.\",\n+ const char*, (tree, const char **flags),\n+ default_printf_pointer_format)\n+\n /* Compute cost of moving data from a register of class FROM to one of\n    TO, using MODE.  */\n DEFHOOK"}, {"sha": "d75650fede333ecdc3d727ba107a0447ef9a1923", "filename": "gcc/targhooks.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1509,6 +1509,20 @@ no_c99_libc_has_function (enum function_class fn_class ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Return the format string to which \"%p\" corresponds.  By default,\n+   assume it corresponds to the C99 \"%zx\" format and set *FLAGS to\n+   the empty string to indicate that format flags have no effect.\n+   An example of an implementation that matches this description\n+   is AIX.  */\n+\n+const char*\n+default_printf_pointer_format (tree, const char **flags)\n+{\n+  *flags = \"\";\n+\n+  return \"%zx\";\n+}\n+\n tree\n default_builtin_tm_load_store (tree ARG_UNUSED (type))\n {"}, {"sha": "3356f0afe0fbb523c7917969f5f84a48fd4d97ab", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -191,6 +191,10 @@ extern bool default_libc_has_function (enum function_class);\n extern bool no_c99_libc_has_function (enum function_class);\n extern bool gnu_libc_has_function (enum function_class);\n \n+extern const char* default_printf_pointer_format (tree, const char **);\n+extern const char* gnu_libc_printf_pointer_format (tree, const char **);\n+extern const char* solaris_printf_pointer_format (tree, const char **);\n+\n extern tree default_builtin_tm_load_store (tree);\n \n extern int default_memory_move_cost (machine_mode, reg_class_t, bool);"}, {"sha": "6d26e43fcef92e79197815eeb57c52dc3ea1683e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1,3 +1,14 @@\n+2016-09-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/49905\n+\t* gcc.dg/builtin-stringop-chk-1.c: Adjust.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: New test.\n+\n 2016-09-21  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* gcc.dg/guality/pr54519-1.c: Add -fno-ipa-vrp. Else constant"}, {"sha": "e491ff52680171d70e57046094d895dfecd4a288", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -1,7 +1,7 @@\n /* Test whether buffer overflow warnings for __*_chk builtins\n    are emitted properly.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -std=gnu99 -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-O2 -Wno-format -std=gnu99 -ftrack-macro-expansion=0\" } */\n /* { dg-additional-options \"-mstructure-size-boundary=8\" { target arm*-*-* } } */\n // { dg-skip-if \"packed attribute missing for t\" { \"epiphany-*-*\" } { \"*\" } { \"\" } }\n "}, {"sha": "f7abfd8ba0d7f5bb995cada912086ee52f00bdf3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,218 @@\n+/* Test to verify that the return value of calls to __builtin_sprintf\n+   is not folded if the call has undefined behavior even if it would\n+   otherwise produce a known number of bytes on output, and that if\n+   the return value is in a known range the range is not made\n+   available to subsequent passes and doesn't affect branching and\n+   the removal of code.\n+   The test is compiled with warnings disabled to make sure the absence\n+   of optimizations does not depend on the presence of warnings.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fprintf-return-value -fdump-tree-optimized -ftrack-macro-expansion=0 -w\" } */\n+\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+#define INT_MAX __INT_MAX__\n+\n+char *buf;\n+char buf8k [8192];\n+\n+#define concat(a, b)   a ## b\n+#define CAT(a, b)      concat (a, b)\n+\n+#define EQL(expect, size, fmt, ...)\t\t\t\t\t\\\n+  void CAT (test_on_line_, __LINE__)(void)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar *dst = size < 0 ? buf : buf8k + sizeof buf8k - size;\t\\\n+\tint result = __builtin_sprintf (dst, fmt, __VA_ARGS__);\t\t\\\n+\tif (result != expect)\t\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Verify that the return value or range or return values from the call\n+   to the formatted function is not treated as a constant or made available\n+   to subsequent optimization passes.  */\n+#define RNG(min, max, size, fmt, ...)\t\t\t\t\t\\\n+  void CAT (test_on_line_, __LINE__)(void)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar *dst = size < 0 ? buf : buf8k + sizeof buf8k - size;\t\\\n+\tint result = __builtin_sprintf (dst, fmt, __VA_ARGS__);\t\t\\\n+\tif (result < min || max < result)\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+extern int i;\n+extern long li;\n+extern char *str;\n+\n+/* Verify that overflowing the destination object disables the return\n+   value optimization.  */\n+EQL (0, 0, \"%c\",  ' ');\n+EQL (0, 0, \"%c\",  i)\n+EQL (0, 0, \"%-s\", \"\");\n+\n+EQL (1, 1, \"%c\",  'x');\n+EQL (1, 1, \"%-s\", \"x\");\n+\n+EQL (4, 4, \"%4c\", 'x');\n+\n+/* Verify that exceeding the environmental limit of 4095 bytes for\n+   a single conversion specification disables the return value\n+   folding.  */\n+EQL (   4096, sizeof buf8k, \"%4096c\", 'x');\n+\n+EQL (INT_MAX, -1, \"%*c\", INT_MAX, 'x');\n+\n+EQL (   4096, sizeof buf8k, \"%4096.4094f\", 1.0);\n+EQL (   4096, sizeof buf8k, \"%.4094f\",     1.0);\n+EQL (   4097, sizeof buf8k, \"%.4095f\",     1.0);\n+\n+enum { imax2 = (INT_MAX / 2) * 2 };\n+EQL (imax2, -1, \"%*c%*c\", INT_MAX / 2, 'x', INT_MAX / 2, 'y');\n+\n+/* Verify that range inforation for calls that overflow the destination\n+   isn't available.  */\n+RNG (0,  0,  0, \"%hhi\", i)\n+RNG (0,  0,  1, \"%hhi\", i)\n+RNG (0,  1,  1, \"%hhi\", i)\n+RNG (0,  0,  2, \"%hhi\", i)\n+RNG (0,  1,  2, \"%hhi\", i)\n+RNG (0,  2,  2, \"%hhi\", i)\n+RNG (0,  0,  3, \"%hhi\", i)\n+RNG (0,  1,  3, \"%hhi\", i)\n+RNG (0,  2,  3, \"%hhi\", i)\n+RNG (0,  3,  3, \"%hhi\", i)\n+RNG (0,  0,  4, \"%hhi\", i)\n+RNG (0,  1,  4, \"%hhi\", i)\n+RNG (0,  2,  4, \"%hhi\", i)\n+RNG (0,  3,  4, \"%hhi\", i)\n+RNG (0,  4,  4, \"%hhi\", i)\n+\n+RNG (0,  0,  0, \"%hhu\", i)\n+RNG (0,  0,  1, \"%hhu\", i)\n+RNG (0,  1,  1, \"%hhu\", i)\n+RNG (0,  0,  2, \"%hhu\", i)\n+RNG (0,  1,  2, \"%hhu\", i)\n+RNG (0,  2,  2, \"%hhu\", i)\n+RNG (0,  0,  3, \"%hhu\", i)\n+RNG (0,  1,  3, \"%hhu\", i)\n+RNG (0,  2,  3, \"%hhu\", i)\n+RNG (0,  3,  3, \"%hhu\", i)\n+\n+RNG (0,  0,  0, \"%i\", i)\n+\n+RNG (0,  0,  1, \"%i\", i)\n+RNG (0,  1,  1, \"%i\", i)\n+\n+RNG (0,  0,  2, \"%i\", i)\n+RNG (0,  1,  2, \"%i\", i)\n+RNG (0,  2,  2, \"%i\", i)\n+\n+RNG (0,  0,  3, \"%i\", i)\n+RNG (0,  1,  3, \"%i\", i)\n+RNG (0,  2,  3, \"%i\", i)\n+RNG (0,  3,  3, \"%i\", i)\n+\n+RNG (0,  0,  4, \"%i\", i)\n+RNG (0,  1,  4, \"%i\", i)\n+RNG (0,  2,  4, \"%i\", i)\n+RNG (0,  3,  4, \"%i\", i)\n+RNG (0,  4,  4, \"%i\", i)\n+\n+RNG (0,  0,  5, \"%i\", i)\n+RNG (0,  1,  5, \"%i\", i)\n+RNG (0,  2,  5, \"%i\", i)\n+RNG (0,  3,  5, \"%i\", i)\n+RNG (0,  4,  5, \"%i\", i)\n+RNG (0,  5,  5, \"%i\", i)\n+\n+RNG (0,  0,  6, \"%i\", i)\n+RNG (0,  1,  6, \"%i\", i)\n+RNG (0,  2,  6, \"%i\", i)\n+RNG (0,  3,  6, \"%i\", i)\n+RNG (0,  4,  6, \"%i\", i)\n+RNG (0,  5,  6, \"%i\", i)\n+RNG (0,  6,  6, \"%i\", i)\n+\n+RNG (0,  0,  7, \"%i\", i)\n+RNG (0,  1,  7, \"%i\", i)\n+RNG (0,  2,  7, \"%i\", i)\n+RNG (0,  3,  7, \"%i\", i)\n+RNG (0,  4,  7, \"%i\", i)\n+RNG (0,  5,  7, \"%i\", i)\n+RNG (0,  6,  7, \"%i\", i)\n+\n+#if __SIZEOF_INT__ == 4\n+\n+/* A 32-bit int takes up at most 11 bytes (-2147483648) not including\n+   the terminating nul.  */\n+RNG (0,  7,  7, \"%i\", i)\n+\n+RNG (0,  0,  8, \"%i\", i)\n+RNG (0,  1,  8, \"%i\", i)\n+RNG (0,  2,  8, \"%i\", i)\n+RNG (0,  3,  8, \"%i\", i)\n+RNG (0,  4,  8, \"%i\", i)\n+RNG (0,  5,  8, \"%i\", i)\n+RNG (0,  6,  8, \"%i\", i)\n+RNG (0,  7,  8, \"%i\", i)\n+RNG (0,  8,  8, \"%i\", i)\n+\n+RNG (0,  0,  9, \"%i\", i)\n+RNG (0,  1,  9, \"%i\", i)\n+RNG (0,  2,  9, \"%i\", i)\n+RNG (0,  3,  9, \"%i\", i)\n+RNG (0,  4,  9, \"%i\", i)\n+RNG (0,  5,  9, \"%i\", i)\n+RNG (0,  6,  9, \"%i\", i)\n+RNG (0,  7,  9, \"%i\", i)\n+RNG (0,  8,  9, \"%i\", i)\n+RNG (0,  9,  9, \"%i\", i)\n+\n+RNG (0,  0, 10, \"%i\", i)\n+RNG (0,  1, 10, \"%i\", i)\n+RNG (0,  2, 10, \"%i\", i)\n+RNG (0,  3, 10, \"%i\", i)\n+RNG (0,  4, 10, \"%i\", i)\n+RNG (0,  5, 10, \"%i\", i)\n+RNG (0,  6, 10, \"%i\", i)\n+RNG (0,  7, 10, \"%i\", i)\n+RNG (0,  8, 10, \"%i\", i)\n+RNG (0,  9, 10, \"%i\", i)\n+RNG (0, 10, 10, \"%i\", i)\n+\n+#endif\n+\n+/* Verify the result of a conditional expression involving a string\n+   literal and an unknown string isn't optimized.  */\n+RNG (0,  1,   4, \"%-s\", i ? str : \"123\");\n+RNG (0,  1,   4, \"%-s\", i ? \"123\" : str);\n+\n+/* Verify that no call to abort has been eliminated and that each call\n+   is at the beginning of a basic block (and thus the result of a branch).\n+   This latter test tries to verify that the test preceding the call to\n+   abort has not been eliminated either.\n+\n+   The expected output looks something like this:\n+\n+   <bb 2>:\n+   result_3 = __builtin_sprintf (&MEM[(void *)&buf8k + 8192B], \"%c\", 32);\n+   if (result_3 != 0)\n+     goto <bb 3>;\n+   else\n+     goto <bb 4>;\n+\n+   <bb 3>:\n+   __builtin_abort ();\n+\n+*/\n+\n+/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 105 \"optimized\" { target { ilp32 || lp64 } } } } */\n+/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 74 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } } */"}, {"sha": "7261dbdc4a8c2e0c45194d210eb09b66d4bc76c4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "added", "additions": 1417, "deletions": 0, "changes": 1417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,1417 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+#define INT_MAX __INT_MAX__\n+\n+char buffer [256];\n+extern char *ptr;\n+\n+/* Evaluate to an array of SIZE characters when non-negative and LINE\n+   is not set or set to the line the macro is on, or to a pointer to\n+   an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\t\t\\\n+  (0 <= size && (!LINE || __LINE__ == LINE)\t\t\t\t\\\n+   ? buffer + sizeof buffer - size : ptr)\n+\n+/* Evaluate to SIZE when non-negative and LINE is not set or set to\n+   the line the macro is on, or to SIZE_MAX otherise.  */\n+#define objsize(size)\t\t\t\t\t\t\t\\\n+  (0 <= size && (!LINE || __LINE__ == LINE)\t\t\t\t\\\n+   ? size : __SIZE_MAX__)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+typedef unsigned char UChar;\n+\n+const char s0[] = \"\";\n+const char s1[] = \"1\";\n+const char s2[] = \"12\";\n+const char s3[] = \"123\";\n+const char s4[] = \"1234\";\n+const char s5[] = \"12345\";\n+const char s6[] = \"123456\";\n+const char s7[] = \"1234567\";\n+const char s8[] = \"12345678\";\n+\n+void sink (void*, ...);\n+\n+/* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#define T(size, fmt, ...)\t\t\t\t\t\t\\\n+  __builtin_sprintf (buffer (size), fmt, __VA_ARGS__),\t\t\t\\\n+    sink (buffer, ptr);\n+\n+/* Exercise the \"%c\" and \"%lc\" directive with constant arguments.  */\n+\n+void test_sprintf_c_const (void)\n+{\n+  T (-1, \"%c\",    0);           /* No warning for unknown destination size.  */\n+  T ( 0, \"%c\",    0);           /* { dg-warning \".%c. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%c\",    0);           /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T ( 1, \"%c\",   '1');          /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%c\",   '1');\n+  T ( 2, \"%2c\",  '1');          /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%3c\",  '1');          /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%c%c\", '1', '2');     /* { dg-warning \"nul past the end\" } */\n+  T ( 3, \"%c%c\", '1', '2');\n+\n+  T ( 2, \"%1$c%2$c\", '1', '2'); /* { dg-warning \"does not support %n.|nul past the end\" } */\n+  T ( 3, \"%1$c%2$c\", '1', '2');\n+\n+  /* Verify that a warning is issued for exceeding INT_MAX bytes and\n+     not otherwise.  */\n+  T (-1, \"%*c\",  INT_MAX - 1, '1');\n+  T (-1, \"%*c\",  INT_MAX,     '1');\n+  T (-1, \"X%*c\", INT_MAX - 1, '1');\n+  T (-1, \"X%*c\", INT_MAX,     '1'); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (-1, \"%*c%*c\", INT_MAX - 1, '1', INT_MAX - 1, '2'); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  T (-1, \"%*cX\", INT_MAX - 2, '1');\n+  T (-1, \"%*cX\", INT_MAX - 1, '1');\n+  T (-1, \"%*cX\", INT_MAX,     '1'); /* { dg-warning \"output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+}\n+\n+/* Exercise the \"%p\" directive with constant arguments.  */\n+\n+void test_sprintf_p_const (void)\n+{\n+  /* GLIBC and uClibc format null pointers as \"(nil)\".  Sane implementations\n+     format null pointers as 0 or 0x0 and so the following will only be\n+     diagnosed on the former targets.  */\n+  T (5, \"%p\",     (void*)0);\n+  /* { dg-warning \"nul past the end\" \"(nil)\" { target *-linux-gnu *-*-uclinux } 94 } */\n+\n+  /* The exact output for %p is unspecified by C.  Two formats are known:\n+     same as %tx (for example AIX) and same as %#tx (for example Solaris).  */\n+  T (0, \"%p\",     (void*)0x1);    /* { dg-warning \".%p. directive writing . bytes into a region of size 0\" } */\n+  T (1, \"%p\",     (void*)0x12);   /* { dg-warning \".%p. directive writing . bytes into a region of size 1\" } */\n+  T (2, \"%p\",     (void*)0x123);  /* { dg-warning \".%p. directive writing . bytes into a region of size 2\" } */\n+\n+  /* GLIBC and uClibc treat the ' ' flag with the \"%p\" directive the same\n+     as with signed integer conversions (i.e., it prepends a space).  Other\n+     known implementations ignore it.  */\n+  T (6, \"% p\",    (void*)0x234);  /* { dg-warning \". . flag used with .%p.\" } */\n+  /* { dg-warning \"nul past the end\" \"Glibc %p\" { target *-linux-gnu } 106 } */\n+  /* { dg-warning \"nul past the end\" \"Generic %p\" { target *-*-uclinux } 106 } */\n+}\n+\n+/* Verify that no warning is issued for calls that write into a flexible\n+   array member whose size isn't known.  Also verify that calls that use\n+   a flexible array member as an argument to the \"%s\" directive do not\n+   cause a warning.  */\n+\n+void test_sprintf_flexarray (void *p, int i)\n+{\n+  struct S\n+  {\n+    int n;\n+    char a [];\n+  } *s = p;\n+\n+  __builtin_sprintf (s->a, \"%c\",       'x');\n+\n+  __builtin_sprintf (s->a, \"%s\",       \"\");\n+  __builtin_sprintf (s->a, \"%s\",       \"abc\");\n+  __builtin_sprintf (s->a, \"abc%sghi\", \"def\");\n+\n+  __builtin_sprintf (s->a, \"%i\",       1234);\n+\n+  __builtin_sprintf (buffer (1), \"%s\",  s->a);\n+  __builtin_sprintf (buffer (1), \"%s\",  s [i].a);\n+}\n+\n+/* Same as above but for zero-length arrays.  */\n+\n+void test_sprintf_zero_length_array (void *p, int i)\n+{\n+  struct S\n+  {\n+    int n;\n+    char a [0];\n+  } *s = p;\n+\n+  __builtin_sprintf (s->a, \"%c\",       'x');\n+\n+  __builtin_sprintf (s->a, \"%s\",       \"\");\n+  __builtin_sprintf (s->a, \"%s\",       \"abc\");\n+  __builtin_sprintf (s->a, \"abc%sghi\", \"def\");\n+\n+  __builtin_sprintf (s->a, \"%i\",       1234);\n+\n+  __builtin_sprintf (buffer (1), \"%s\",  s->a);\n+  __builtin_sprintf (buffer (1), \"%s\",  s [i].a);\n+}\n+\n+/* Verify that the note printed along with the diagnostic mentions\n+   the correct sizes and refers to the location corresponding to\n+   the affected directive.  */\n+\n+void test_sprintf_note (void)\n+{\n+#define P __builtin_sprintf\n+\n+  /* Diagnostic column numbers are 1-based.  */\n+\n+  P (buffer (0),                /* { dg-message \"format output 4 bytes into a destination of size 0\" } */\n+     \"%c%s%i\", '1', \"2\", 3);    /* { dg-warning \"7:.%c. directive writing 1 byte into a region of size 0\" } */\n+\n+  P (buffer (1),                /* { dg-message \"format output 6 bytes into a destination of size 1\" } */\n+     \"%c%s%i\", '1', \"23\", 45);  /* { dg-warning \"9:.%s. directive writing 2 bytes into a region of size 0\" } */\n+\n+  P (buffer (2),                /* { dg-message \"format output 6 bytes into a destination of size 2\" } */\n+     \"%c%s%i\", '1', \"2\", 345);  /* { dg-warning \"11:.%i. directive writing 3 bytes into a region of size 0\" } */\n+\n+  /* It would be nice if the caret in the location range for the format\n+     string below could be made to point at the closing quote of the format\n+     string, like so:\n+       sprintf (d, \"%c%s%i\", '1', \"2\", 3456);\n+\t            ~~~~~~^\n+     Unfortunately, that doesn't work with the current setup.  */\n+  P (buffer (6),                /* { dg-message \"format output 7 bytes into a destination of size 6\" } */\n+     \"%c%s%i\", '1', \"2\", 3456); /* { dg-warning \"writing a terminating nul past the end of the destination\" } */\n+}\n+\n+#undef T\n+#define T(size, fmt, ...)\t\t\t\t\t  \\\n+  __builtin___sprintf_chk (buffer (size), 0, objsize (size), fmt, \\\n+\t\t\t   __VA_ARGS__), sink (buffer, ptr)\n+\n+/* Exercise the \"%c\" and \"%lc\" directive with constant arguments.  */\n+\n+void test_sprintf_chk_c_const (void)\n+{\n+  T (-1, \"%c\",    0);            /* No warning for unknown destination size.  */\n+  /* Verify the full text of the diagnostic for just the distinct messages\n+     and use abbreviations in subsequent test cases.  */\n+  T (0, \"%c\",     0);            /* { dg-warning \".%c. directive writing 1 byte into a region of size 0\" } */\n+  T (1, \"%c\",     0);            /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (1, \"%c\",   '1');            /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%c\",   '1');\n+  T (2, \"%2c\",  '1');            /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%3c\",  '1');            /* { dg-warning \"into a region\" } */\n+  T (2, \"%c%c\", '1', '2');       /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%c%c\", '1', '2');\n+\n+  /* Wide characters.  */\n+  T (0, \"%lc\",     0);           /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%lc\",     0);\n+  T (1, \"%lc%lc\",  0, 0);\n+  T (2, \"%lc\",     0);\n+  T (2, \"%lc%lc\",  0, 0);\n+\n+  /* The following could result in as few as no bytes and in as many as\n+     MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n+     the write cannot be reliably diagnosed.  */\n+  T (2, \"%lc\",  L'1');\n+  T (2, \"%1lc\", L'1');\n+  /* Writing some unknown number of bytes into a field two characters wide.  */\n+  T (2, \"%2lc\", L'1');          /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%lc%c\",   L'1', '2');\n+  /* Here in the best case each argument will format as single character,\n+     causing the terminating NUL to be written past the end.  */\n+  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"nul past the end\" } */\n+}\n+\n+/* Exercise the \"%s\" and \"%ls\" directive with constant arguments.  */\n+\n+void test_sprintf_chk_s_const (void)\n+{\n+  T (-1, \"%*s\",  0, \"\");        /* No warning for unknown destination size.  */\n+  T ( 0, \"%*s\",  0, \"\");        /* { dg-warning \"nul past the end\" } */\n+  T ( 0, \"%-s\",     \"\");        /* { dg-warning \"nul past the end\" } */\n+  T ( 0, \"%*s\",  0, s0);        /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%*s\",  0, \"\");\n+  T ( 1, \"%*s\",  0, s0);\n+  T ( 1, \"%*s\",  0, \"\\0\");\n+  T ( 1, \"%*s\",  0, \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%*s\",  0, s1);        /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%1s\",     \"\");        /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%1s\",     s0);        /* { dg-warning \"nul past the end\" } */\n+  T (-1, \"%1s\",    \"1\");        /* No warning for unknown destination size.  */\n+  T ( 1, \"%*s\",  1, \"\");        /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%*s\",  1, s0);        /* { dg-warning \"nul past the end\" } */\n+  T (-1, \"%*s\",  1, s0);        /* No warning for unknown destination size.  */\n+\n+  T (1, \"%.0s\",    \"123\");\n+  T (1, \"%.0s\",    s3);\n+  T (1, \"%.*s\", 0, \"123\");\n+  T (1, \"%.*s\", 0, s3);\n+  T (1, \"%.1s\",    \"123\");      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.1s\",    s3);         /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.*s\", 1, \"123\");      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.*s\", 1, s3);         /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%.*s\", 0, \"\");\n+  T (2, \"%.*s\", 0, \"1\");\n+  T (2, \"%.*s\", 0, s1);\n+  T (2, \"%.*s\", 0, \"1\\0\");\n+  T (2, \"%.*s\", 0, \"12\");\n+  T (2, \"%.*s\", 0, s2);\n+\n+  T (2, \"%.*s\", 1, \"\");\n+  T (2, \"%.*s\", 1, \"1\");\n+  T (2, \"%.*s\", 1, s1);\n+  T (2, \"%.*s\", 1, \"1\\0\");\n+  T (2, \"%.*s\", 1, \"12\");\n+  T (2, \"%.*s\", 1, s2);\n+\n+  T (2, \"%.*s\", 2, \"\");\n+  T (2, \"%.*s\", 2, \"1\");\n+  T (2, \"%.*s\", 2, s1);\n+  T (2, \"%.*s\", 2, \"1\\0\");\n+  T (2, \"%.*s\", 2, \"12\");       /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*s\", 2, s2);         /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%.*s\", 3, \"\");\n+  T (2, \"%.*s\", 3, \"1\");\n+  T (2, \"%.*s\", 3, s1);\n+  T (2, \"%.*s\", 3, \"1\\0\");\n+  T (2, \"%.*s\", 3, \"12\");       /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*s\", 3, \"123\");      /* { dg-warning \"into a region\" } */\n+  T (2, \"%.*s\", 3, s2);         /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*s\", 3, s3);         /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%*s\",  0, \"\");\n+  T (2, \"%*s\",  0, \"1\");\n+  T (2, \"%*s\",  0, s1);\n+  T (2, \"%*s\",  0, \"1\\0\");\n+  T (2, \"%*s\",  0, \"12\");       /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*s\",  0, s2);         /* { dg-warning \"nul past the end\" } */\n+\n+  /* Verify that output in excess of INT_MAX bytes is diagnosed even\n+     when the size of the destination object is unknown.  */\n+  T (-1, \"%*s\",  INT_MAX - 1, \"\");\n+  T (-1, \"%*s\",  INT_MAX,     \"\");\n+  T (-1, \"X%*s\", INT_MAX,     \"\"); /* { dg-warning \"directive output of \\[0-9\\]+ bytes causes result to exceed .INT_MAX.\" } */\n+\n+  /* Multiple directives.  */\n+\n+  T (1, \"%s%s\", \"\", \"\");\n+  T (1, \"%s%s\", s0, s0);\n+  T (1, \"%s%s\", \"\", \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s%s\", s0, s1);        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s%s\", \"1\", \"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s%s\", s1, s0);        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s%s\", \"1\", \"2\");      /* { dg-warning \"into a region\" } */\n+  T (1, \"%s%s\", s1, s1);        /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%s%s\", \"\", \"\");\n+  T (2, \"%s%s\", \"\", \"1\");\n+  T (2, \"%s%s\", \"1\", \"\");\n+  T (2, \"%s%s\", \"\", \"12\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%s%s\", \"1\", \"2\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%s%s\", \"12\", \"2\");     /* { dg-warning \"into a region\" } */\n+  T (2, \"%s%s\", \"1\", \"23\");     /* { dg-warning \"into a region\" } */\n+  T (2, \"%s%s\", \"12\", \"3\");     /* { dg-warning \"into a region\" } */\n+  T (2, \"%s%s\", \"12\", \"34\");    /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"_%s\",   \"\");\n+  T (2, \"%%%s\",  \"\");\n+  T (2, \"%s%%\",  \"\");\n+  T (2, \"_%s\",   \"1\");          /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%%%s\",  \"1\");          /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%s%%\",  \"1\");          /* { dg-warning \"nul past the end\" } */\n+  T (2, \"_%s\",   \"12\");         /* { dg-warning \"into a region\" } */\n+  T (2, \"__%s\",  \"1\");          /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%1$s%2$s\", \"12\", \"3\"); /* { dg-warning \".%2.s. directive writing 1 byte into a region of size 0\" } */\n+  T (2, \"%1$s%1$s\", \"12\");      /* { dg-warning \"does not support|.%1.s. directive writing 2 bytes into a region of size 0\" } */\n+  T (2, \"%2$s%1$s\", \"1\", \"23\"); /* { dg-warning \".%1.s. directive writing 1 byte into a region of size 0\" } */\n+  T (2, \"%2$s%2$s\", \"1\", \"23\"); /* { dg-warning \"unused|%2.s. directive writing 2 bytes into a region of size 0\" } */\n+\n+  T (3, \"__%s\", \"\");\n+  T (3, \"__%s\", \"1\");           /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%s_%s\", \"\", \"\");\n+  T (3, \"%s_%s\", \"1\", \"\");\n+  T (3, \"%s_%s\", \"\", \"1\");\n+  T (3, \"%s_%s\", \"1\", \"2\");     /* { dg-warning \"nul past the end\" } */\n+\n+  /* Wide strings.  */\n+  T (-1, \"%ls\",      L\"\");\n+  T ( 0, \"%ls\",      L\"\");      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%ls\",      L\"\");\n+  T ( 1, \"%ls\",      L\"\\0\");\n+  T ( 1, \"%1ls\",     L\"\");      /* { dg-warning \"nul past the end\" } */\n+\n+  T (0, \"%*ls\",  0, L\"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%*ls\",  0, L\"\");\n+  T (1, \"%*ls\",  0, L\"\\0\");\n+  T (1, \"%*ls\",  1, L\"\");       /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.0ls\",    L\"1\");\n+  T (2, \"%.0ls\",    L\"1\");\n+  T (2, \"%.1ls\",    L\"1\");\n+  T (2, \"%.*ls\", 1, L\"1\");\n+\n+  /* The \"%.2ls\" directive below will write at a minimum 1 byte (because\n+     L\"1\" is known and can be assumed to convert to at least one multibyte\n+     character), and at most 2 bytes because of the precision.  Since its\n+     output is explicitly bounded it is diagnosed.  */\n+  T (2, \"%.2ls\",    L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*ls\", 2, L\"1\");      /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%.0ls\",    L\"1\");\n+  T (3, \"%.1ls\",    L\"1\");\n+  T (3, \"%.2ls\",    L\"1\");\n+}\n+\n+/* Exercise the \"%hhd\", \"%hhi\", \"%hho\", \"%hhu\", and \"%hhx\" directives\n+   with constant arguments.  */\n+\n+void test_sprintf_chk_hh_const (void)\n+{\n+  T (-1, \"%hhd\",        0);\n+\n+  T (1, \"%hhd\",         0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhd\",         1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhd\",        -1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhd\",        0);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhd\",        1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-hhd\",        0);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%hhi\",         0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhi\",         1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhi\",        -1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhi\",        0);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhi\",        1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-hhi\",        0);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%hhi\",         0);\n+  T (2, \"%hhi\",         1);\n+  T (2, \"%hhi\",         9);\n+  T (2, \"% hhi\",        9);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%+hhi\",        9);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%-hhi\",        9);\n+  T (2, \"%hhi\",        10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hhi\",        -1);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hhi\",       -1);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%+hhi\",       -1);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%-hhi\",       -1);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%hho\",         0);\n+  T (2, \"%hho\",         1);\n+  T (2, \"%hho\",         7);\n+  T (2, \"%hho\",       010);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hho\",       077);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hho\",        -1);     /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%hhx\",         0);\n+  T (2, \"%hhX\",         1);\n+  T (2, \"%hhx\",         7);\n+  T (2, \"%hhX\",         8);\n+  T (2, \"%hhx\",        -1);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hhX\",       0xf);\n+  T (2, \"%hhx\",      0x10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hhX\",      0xff);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%#hhx\",        0);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%#hhx\",        0);\n+  T (3, \"%#hhx\",        1);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (4, \"%hhd\",       255);\n+  T (4, \"%hhd\",       256);\n+  T (4, \"%hhd\",     0xfff);\n+  T (4, \"%hhd\",    0xffff);\n+\n+  T (4, \"%hhi\",       255);\n+  T (4, \"%hhi\",       256);\n+  T (4, \"%hhi\",     0xfff);\n+  T (4, \"%hhi\",    0xffff);\n+\n+  T (4, \"%hhu\",        -1);\n+  T (4, \"%hhu\",       255);\n+  T (4, \"%hhu\",       256);\n+  T (4, \"%hhu\",     0xfff);\n+  T (4, \"%hhu\",    0xffff);\n+\n+  T (4, \"%#hhx\",        0);\n+  T (4, \"%#hhx\",        1);\n+  T (4, \"%#hhx\",       -1);     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%#hhx\",      0xf);\n+  T (4, \"%#hhx\",     0x10);     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%#hhx\",     0xff);     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%#hhx\",    0xfff);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (4, \"%hhi %hhi\",  0,  0);\n+  T (4, \"%hhi %hhi\",  9,  9);\n+  T (4, \"%hhi %hhi\",  1, 10);   /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%hhi %hhi\", 10,  1);   /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%hhi %hhi\", 11, 12);   /* { dg-warning \"into a region\" } */\n+\n+  T (5, \"%0*hhd %0*hhi\", 0,  7, 0,   9);\n+  T (5, \"%0*hhd %0*hhi\", 1,  7, 1,   9);\n+  T (5, \"%0*hhd %0*hhi\", 1,  7, 2,   9);\n+  T (5, \"%0*hhd %0*hhi\", 2,  7, 1,   9);\n+  T (5, \"%0*hhd %0*hhi\", 2,  7, 2,   9); /* { dg-warning \"nul past the end\" } */\n+  T (5, \"%0*hhd %0*hhi\", 0, 12, 0, 123); /* { dg-warning \".%0\\\\*hhi. directive writing 3 bytes into a region of size 2\" } */\n+  T (5, \"%0*hhd %0*hhi\", 1, 12, 1, 123); /* { dg-warning \".%0\\\\*hhi. directive writing 3 bytes into a region of size 2\" } */\n+  T (5, \"%0*hhd %0*hhi\", 2, 12, 3, 123); /* { dg-warning \".%0\\\\*hhi. directive writing 3 bytes into a region of size 2\" } */\n+\n+  /* FIXME: Move the boundary test cases into a file of their own that's\n+     exercised only on targets with the matching type limits (otherwise\n+     they'll fail).  */\n+#undef MAX\n+#define MAX   127\n+\n+#undef MIN\n+#define MIN   (-MAX -1)\n+\n+  T (1, \"%hhi\",        MAX);    /* { dg-warning \"into a region\" } */\n+  T (1, \"%hhi\",        MIN);    /* { dg-warning \"into a region\" } */\n+  T (1, \"%hhi\",  MAX +   1);    /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%hhi\",  MAX +   1);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%hhi\",  MAX +  10);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%hhi\",  MAX + 100);    /* { dg-warning \"into a region\" } */\n+}\n+\n+/* Exercise the \"%hhd\", \"%hi\", \"%ho\", \"%hu\", and \"%hx\" directives\n+   with constant arguments.  */\n+\n+void test_sprintf_chk_h_const (void)\n+{\n+  T (1, \"%hu\",          0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",          1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",         -1);     /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%hi\",          0);\n+  T (2, \"%hi\",          1);\n+  T (2, \"%hi\",          9);\n+  T (2, \"% hi\",         9);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%+hi\",         9);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%-hi\",         9);\n+  T (2, \"%hi\",         10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hi\",         -1);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hi\",        -2);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%+hi\",        -3);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%-hi\",        -4);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%hu\",          0);\n+  T (2, \"%hu\",          1);\n+  T (2, \"%hu\",          9);\n+  T (2, \"%hu\",         10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hu\",         -1);     /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%ho\",          0);\n+  T (2, \"%ho\",          1);\n+  T (2, \"%ho\",          7);\n+  T (2, \"%ho\",        010);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%ho\",        077);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%ho\",       0100);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%ho\",         -1);     /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%hx\",          0);\n+  T (2, \"%hx\",          1);\n+  T (2, \"%hx\",          7);\n+  T (2, \"%hx\",        0xf);\n+  T (2, \"%hx\",       0x10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hx\",       0xff);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hx\",      0x100);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%hx\",         -1);     /* { dg-warning \"into a region\" } */\n+\n+  T (3, \"% hi\",         7);\n+  T (3, \"%+hi\",         8);\n+  T (3, \"%-hi\",         9);\n+  T (3, \"%hi\",         10);\n+  T (3, \"%hi\",         -1);\n+  T (3, \"% hi\",        -2);\n+  T (3, \"%+hi\",        -3);\n+  T (3, \"%-hi\",        -4);\n+\n+  T (5, \"%hu\",       9999);\n+  T (5, \"%hu\",      10000);     /* { dg-warning \"nul past the end\" } */\n+  T (5, \"%hu\",      65535);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%#hx\",         0);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%#hx\",         0);\n+  T (3, \"%#hx\",         1);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (4, \"%#hx\",         0);\n+  T (4, \"%#hx\",         1);\n+  T (4, \"%#hx\",       0xf);\n+  T (4, \"%#hx\",      0x10);     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%#hx\",      0xff);     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%#hx\",     0x100);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%#hx\",        -1);     /* { dg-warning \"into a region\" } */\n+\n+#undef MAX\n+#define MAX   65535\n+\n+  T (1, \"%hhu\",         0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhu\",         1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhu\",        -1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%hhu\",       MAX);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%hhu\",  MAX +  1);     /* { dg-warning \"nul past the end\" } */\n+}\n+\n+/* Exercise the \"%d\", \"%i\", \"%o\", \"%u\", and \"%x\" directives with\n+   constant arguments.  */\n+\n+void test_sprintf_chk_integer_const (void)\n+{\n+  T ( 1, \"%i\",          0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",          1);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",         -1);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%i_\",         1);         /* { dg-warning \"character ._. at offset 2 past the end\" } */\n+  T ( 1, \"_%i\",         1);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%i_\",        1);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%o\",          0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%u\",          0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%x\",          0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#x\",         0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%x\",          1);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#x\",         1);         /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%i\",          0);\n+  T ( 2, \"%i\",          1);\n+  T ( 2, \"%i\",          9);\n+  T ( 2, \"%i\",         -1);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",         10);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i_\",         0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%i\",         0);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%i_\",        0);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 2, \"%o\",          1);\n+  T ( 2, \"%o\",          7);\n+  T ( 2, \"%o\",        010);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%o\",       0100);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%x\",          1);\n+  T ( 2, \"%#x\",         1);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%x\",        0xa);\n+  T ( 2, \"%x\",        0xf);\n+  T ( 2, \"%x\",       0x10);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%x\",       0xff);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%x\",      0x1ff);         /* { dg-warning \"into a region\" } */\n+\n+  T ( 3, \"%i\",          0);\n+  T ( 3, \"%i\",          1);\n+  T ( 3, \"%i\",          9);\n+  T ( 3, \"%i\",         -9);\n+  T ( 3, \"%i\",         10);\n+  T ( 3, \"%i\",         99);\n+  T ( 3, \"%i\",        -99);         /* { dg-warning \"nul past the end\" } */\n+\n+  /* ~0U is formatted into exactly three bytes as \"-1\" followed by\n+     the terminating NUL character.  */\n+  T ( 3, \"%+i\",       ~0U);\n+  T ( 3, \"%-i\",       ~0U);\n+  T ( 3, \"% i\",       ~0U);\n+\n+  T ( 8, \"%8u\",         1);        /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%8u\",         1);\n+\n+  T ( 7, \"%1$i%2$i%3$i\",     1, 23, 456);\n+  T ( 8, \"%1$i%2$i%3$i%1$i\", 1, 23, 456);\n+  T ( 8, \"%1$i%2$i%3$i%2$i\", 1, 23, 456);   /* { dg-warning \"nul past the end\" } */\n+  T ( 8, \"%1$i%2$i%3$i%3$i\", 1, 23, 456);   /* { dg-warning \"into a region\" } */\n+\n+#undef MAX\n+#define MAX   2147483647   /* 10 digits.  */\n+#undef MIN\n+#define MIN   (-MAX -1)    /* Sign plus 10 digits.  */\n+\n+  T ( 1, \"%i\",        MAX);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%i\",        MIN);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%i\",        MAX);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%i\",        MIN);         /* { dg-warning \"into a region\" } */\n+  T (10, \"%i\",  123456789);\n+  T (10, \"%i\", -123456789);         /* { dg-warning \"nul past the end\" } */\n+  T (10, \"%i\",        MAX);         /* { dg-warning \"nul past the end\" } */\n+  T (10, \"%i\",        MIN);         /* { dg-warning \"into a region\" } */\n+\n+  T (11, \"%i\",        MAX);\n+  T (11, \"%i\",        MIN);         /* { dg-warning \"nul past the end\" } */\n+}\n+\n+/* Exercise the \"%jd\", \"%ji\", \"%jo\", \"%ju\", and \"%jx\" directives\n+   for the formatting of intmax_t and uintmax_t values with constant\n+   arguments.  */\n+\n+void test_sprintf_chk_j_const (void)\n+{\n+#define I(x) ((__INTMAX_TYPE__)x)\n+\n+  T ( 1, \"%ji\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%ji\",  I (    1));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%ji\",  I (   -1));      /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%ji_\", I (    1));      /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"_%ji\", I (    1));      /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%ji_\",I (    1));      /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%jo\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%ju\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%jx\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#jx\", I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%jx\",  I (    1));      /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#jx\", I (    1));      /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%ji\",  I (    0));\n+  T ( 2, \"%ji\",  I (    1));\n+  T ( 2, \"%ji\",  I (    9));\n+  T ( 2, \"%ji\",  I (   -1));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%ji\",  I (   10));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%ji_\", I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%ji\", I (    0));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%ji_\",I (    0));      /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 2, \"%jo\",  I (    1));\n+  T ( 2, \"%jo\",  I (    7));\n+  T ( 2, \"%jo\",  I (  010));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%jo\",  I ( 0100));      /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%jx\",  I (    1));\n+  T ( 2, \"%#jx\", I (    1));      /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%jx\",  I (  0xa));\n+  T ( 2, \"%jx\",  I (  0xf));\n+  T ( 2, \"%jx\",  I ( 0x10));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%jx\",  I ( 0xff));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%jx\",  I (0x1ff));      /* { dg-warning \"into a region\" } */\n+\n+  T ( 3, \"%ji\",  I (    0));\n+  T ( 3, \"%ji\",  I (    1));\n+  T ( 3, \"%ji\",  I (    9));\n+  T ( 3, \"%ji\",  I (   -9));\n+  T ( 3, \"%ji\",  I (   10));\n+  T ( 3, \"%ji\",  I (   99));\n+  T ( 3, \"%ji\",  I (  -99));      /* { dg-warning \"nul past the end\" } */\n+\n+  /* ~0 is formatted into exactly three bytes as \"-1\" followed by\n+     the terminating NUL character.  */\n+  T ( 3, \"%+ji\",    ~I (0));\n+  T ( 3, \"%-ji\",    ~I (0));\n+  T ( 3, \"% ji\",    ~I (0));\n+\n+  T ( 8, \"%8ju\",     I (1));      /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%8ju\",     I (1));\n+}\n+\n+/* Exercise the \"%ld\", \"%li\", \"%lo\", \"%lu\", and \"%lx\" directives\n+   with constant arguments.  */\n+\n+void test_sprintf_chk_l_const (void)\n+{\n+  T ( 1, \"%li\",      0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%li\",      1L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%li\",     -1L);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%li_\",     1L);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"_%li\",     1L);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%li_\",    1L);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%lo\",      0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%lu\",      0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%lx\",      0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#lx\",     0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%lx\",      1L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#lx\",     1L);         /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%li\",      0L);\n+  T ( 2, \"%li\",      1L);\n+  T ( 2, \"%li\",      9L);\n+  T ( 2, \"%li\",     -1L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%li\",     10L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%li_\",     0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%li\",     0L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%li_\",    0L);         /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 2, \"%lo\",      1L);\n+  T ( 2, \"%lo\",      7L);\n+  T ( 2, \"%lo\",    010L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%lo\",   0100L);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%lx\",      1L);\n+  T ( 2, \"%#lx\",     1L);         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%lx\",    0xaL);\n+  T ( 2, \"%lx\",    0xfL);\n+  T ( 2, \"%lx\",   0x10L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%lx\",   0xffL);         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%lx\",  0x1ffL);         /* { dg-warning \"into a region\" } */\n+\n+  T ( 3, \"%li\",      0L);\n+  T ( 3, \"%li\",      1L);\n+  T ( 3, \"%li\",      9L);\n+  T ( 3, \"%li\",     -9L);\n+  T ( 3, \"%li\",     10L);\n+  T ( 3, \"%li\",     99L);\n+  T ( 3, \"%li\",    -99L);         /* { dg-warning \"nul past the end\" } */\n+\n+  /* ~0U is formatted into exactly three bytes as \"-1\" followed by\n+     the terminating NUL character.  */\n+  T ( 3, \"%+li\",   ~0LU);\n+  T ( 3, \"%-li\",   ~0LU);\n+  T ( 3, \"% li\",   ~0LU);\n+\n+  T ( 8, \"%8lu\",     1L);         /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%8lu\",     1L);\n+}\n+\n+/* Exercise the \"%lld\", \"%lli\", \"%llo\", \"%llu\", and \"%llx\" directives\n+   with constant arguments.  */\n+\n+void test_sprintf_chk_ll_const (void)\n+{\n+  T ( 1, \"%lli\",      0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%lli\",      1LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%lli\",     -1LL);     /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%lli_\",     1LL);     /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 1, \"_%lli\",     1LL);     /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%lli_\",    1LL);     /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%llo\",      0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%llu\",      0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%llx\",      0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#llx\",     0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%llx\",      1LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#llx\",     1LL);     /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%lli\",      0LL);\n+  T ( 2, \"%lli\",      1LL);\n+  T ( 2, \"%lli\",      9LL);\n+  T ( 2, \"%lli\",     -1LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%lli\",     10LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%lli_\",     0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%lli\",     0LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%lli_\",    0LL);     /* { dg-warning \"character ._. at offset 5 past the end\" } */\n+  T ( 2, \"%llo\",      1LL);\n+  T ( 2, \"%llo\",      7LL);\n+  T ( 2, \"%llo\",    010LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%llo\",   0100LL);     /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%llx\",      1LL);\n+  T ( 2, \"%#llx\",     1LL);     /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%llx\",    0xaLL);\n+  T ( 2, \"%llx\",    0xfLL);\n+  T ( 2, \"%llx\",   0x10LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%llx\",   0xffLL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%llx\",  0x1ffLL);     /* { dg-warning \"into a region\" } */\n+\n+  T ( 3, \"%lli\",      0LL);\n+  T ( 3, \"%lli\",      1LL);\n+  T ( 3, \"%lli\",      9LL);\n+  T ( 3, \"%lli\",     -9LL);\n+  T ( 3, \"%lli\",     10LL);\n+  T ( 3, \"%lli\",     99LL);\n+  T ( 3, \"%lli\",    -99LL);     /* { dg-warning \"nul past the end\" } */\n+\n+  /* ~0U is formatted into exactly three bytes as \"-1\" followed by\n+     the terminating NUL character.  */\n+  T ( 3, \"%+lli\",   ~0LLU);\n+  T ( 3, \"%-lli\",   ~0LLU);\n+  T ( 3, \"% lli\",   ~0LLU);\n+\n+  T ( 8, \"%8llu\",     1LL);     /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%8llu\",     1LL);\n+\n+  /* assume 64-bit long long.  */\n+#define LLONG_MAX   9223372036854775807LL   /* 19 bytes */\n+#define LLONG_MIN   (-LLONG_MAX - 1)        /* 20 bytes */\n+\n+  T (18, \"%lli\", LLONG_MIN);    /* { dg-warning \"into a region\" } */\n+  T (19, \"%lli\", LLONG_MIN);    /* { dg-warning \"into a region\" } */\n+  T (20, \"%lli\", LLONG_MIN);    /* { dg-warning \"nul past the end\" } */\n+  T (21, \"%lli\", LLONG_MIN);\n+\n+  T (18, \"%lli\", LLONG_MAX);    /* { dg-warning \"into a region\" } */\n+  T (19, \"%lli\", LLONG_MAX);    /* { dg-warning \"nul past the end\" } */\n+  T (20, \"%lli\", LLONG_MAX);\n+\n+  T (21, \"%llo\",      -1LL);    /* { dg-warning \"into a region\" } */\n+  T (22, \"%llo\",      -1LL);    /* { dg-warning \"nul past the end\" } */\n+  T (23, \"%llo\",      -1LL);\n+\n+  T (19, \"%llu\",      -1LL);    /* { dg-warning \"into a region\" } */\n+  T (20, \"%llu\",      -1LL);    /* { dg-warning \"nul past the end\" } */\n+  T (21, \"%llu\",      -1LL);\n+\n+  T (15, \"%llx\",      -1LL);    /* { dg-warning \"into a region\" } */\n+  T (16, \"%llx\",      -1LL);    /* { dg-warning \"nul past the end\" } */\n+  T (17, \"%llx\",      -1LL);\n+}\n+\n+void test_sprintf_chk_L_const (void)\n+{\n+  T (-1, \"%Li\",        0LL);\n+  T ( 1, \"%Li\",        0LL);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%Li\",        1LL);         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%Li\",       -1LL);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%Li_\",       1LL);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"_%Li\",       1LL);         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%Li_\",      1LL);         /* { dg-warning \"into a region\" } */\n+}\n+\n+void test_sprintf_chk_z_const (void)\n+{\n+  T (-1, \"%zi\",        (size_t)0);\n+  T ( 1, \"%zi\",        (size_t)0);  /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%zi\",        (size_t)1);  /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%zi\",        (size_t)-1L);/* { dg-warning \"into a region\" } */\n+  T ( 1, \"%zi_\",       (size_t)1);  /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"_%zi\",       (size_t)1);  /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%zi_\",      (size_t)1);  /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%zu\",        (size_t)1);\n+  T ( 2, \"%zu\",        (size_t)9);\n+  T ( 2, \"%zu\",        (size_t)10); /* { dg-warning \"nul past the end\" } */\n+}\n+\n+void test_sprintf_chk_e_const (void)\n+{\n+  T (-1, \"%E\",   0.0);\n+  T ( 0, \"%E\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T ( 0, \"%e\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%E\",   1.0);          /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%e\",   1.0);          /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%e\",   2.0);          /* { dg-warning \"into a region\" } */\n+  T ( 3, \"%e\",   3.0);          /* { dg-warning \"into a region\" } */\n+  T (12, \"%e\",   1.2);          /* { dg-warning \"nul past the end\" } */\n+  T (12, \"%e\",  12.0);          /* { dg-warning \"nul past the end\" } */\n+  T (13, \"%e\",   1.3);          /* 1.300000e+00 */\n+  T (13, \"%E\",  13.0);          /* 1.300000e+01 */\n+  T (13, \"%e\",  13.0);\n+  T (13, \"%E\",  1.4e+99);       /* 1.400000e+99 */\n+  T (13, \"%e\",  1.5e+100);      /* { dg-warning \"nul past the end\" } */\n+  T (14, \"%E\",  1.6e+101);      /* 1.600000E+101 */\n+  T (14, \"%e\", -1.7e+102);      /* { dg-warning \"nul past the end\" } */\n+  T (15, \"%E\", -1.8e+103);      /* -1.800000E+103 */\n+\n+  T (16, \"%.8e\", -1.9e+104);    /* { dg-warning \"nul past the end\" } */\n+  T (17, \"%.8e\", -2.0e+105);    /* -2.00000000e+105 */\n+\n+  T ( 5, \"%.0e\", 0.0);          /* { dg-warning \"nul past the end\" } */\n+  T ( 5, \"%.0e\", 1.0);          /* { dg-warning \"nul past the end\" } */\n+  T ( 6, \"%.0e\", 1.0);\n+\n+  /* The actual output of the following directives depends on the rounding\n+     mode.  Verify that the warning correctly reflects that.  */\n+  T (12, \"%e\",  9.999999e+99);  /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%e\",  9.9999994e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%e\",  9.9999995e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%e\",  9.9999996e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%e\",  9.9999997e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%e\",  9.9999998e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+\n+  T (12, \"%Le\", 9.9999994e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%Le\", 9.9999995e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%Le\", 9.9999996e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%Le\", 9.9999997e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%Le\", 9.9999998e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+  T (12, \"%Le\", 9.9999999e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+}\n+\n+/* At -Wformat-length level 1 unknown numbers are assumed to have\n+   the value one, and unknown strings are assumed to have a zero\n+   length.  */\n+\n+void test_sprintf_chk_s_nonconst (int i, const char *s)\n+{\n+  T (-1, \"%s\",   s);\n+  T ( 0, \"%s\",   s);            /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%s\",   s);\n+  T ( 1, \"%.0s\", s);\n+  T ( 1, \"%.1s\", s);            /* { dg-warning \"nul past the end\" } */\n+\n+  /* The following will definitely write past the end of the buffer,\n+     but since at level 1 the length of an unknown string argument\n+     is assumed to be zero, it will write the terminating nul past\n+     the end (we don't print \"past the end\" when we're not\n+     sure which we can't be with an unknown string.  */\n+  T (1, \"%1s\",  s);             /* { dg-warning \"writing a terminating nul past the end\" } */\n+}\n+\n+/* Exercise the hh length modifier with all integer specifiers and\n+   a non-constant argument.  */\n+\n+void test_sprintf_chk_hh_nonconst (int a)\n+{\n+  T (-1, \"%hhd\",        a);\n+\n+  T (0, \"%hhd\",         a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hhi\",         a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hhu\",         a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hhx\",         a);     /* { dg-warning \"into a region\" } */\n+\n+  T (1, \"%hhd\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhi\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhu\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhx\",         a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"% hhd\",        a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"% hhi\",        a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhd\",        a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hhi\",        a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-hhd\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-hhi\",        a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%hhd\",         a);\n+  T (2, \"%hhi\",         a);\n+  T (2, \"%hho\",         a);\n+  T (2, \"%hhu\",         a);\n+  T (2, \"%hhx\",         a);\n+\n+  T (2, \"% hhd\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hhi\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hho\",        a);     /* { dg-warning \". . flag used with .%o.\" } */\n+  T (2, \"% hhu\",        a);     /* { dg-warning \". . flag used with .%u.\" } */\n+  T (2, \"% hhx\",        a);     /* { dg-warning \". . flag used with .%x.\" } */\n+\n+  T (2, \"#%hho\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"#%hhx\",        a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%2hhd\",        a);\n+  T (3, \"%2hhi\",        a);\n+  T (3, \"%2hho\",        a);\n+  T (3, \"%2hhu\",        a);\n+  T (3, \"%2hhx\",        a);\n+\n+  /* Exercise cases where the type of the actual argument (whose value\n+     and range are unknown) constrain the size of the output and so\n+     can be used to avoid what would otherwise be false positives.  */\n+\n+  T (2, \"%hhd\", (UChar)a);\n+  T (2, \"%hhi\", (UChar)a);\n+  T (2, \"%-hhi\", (UChar)a);\n+}\n+\n+/* Exercise the h length modifier with all integer specifiers and\n+   a non-constant argument.  */\n+\n+void test_sprintf_chk_h_nonconst (int a)\n+{\n+  T (-1, \"%hd\",         a);\n+\n+  T (0, \"%hd\",          a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hi\",          a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hu\",          a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hx\",          a);     /* { dg-warning \"into a region\" } */\n+\n+  T (1, \"%hd\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hi\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hx\",          a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"% hd\",         a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"% hi\",         a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hd\",         a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+hi\",         a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-hd\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-hi\",         a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%hd\",          a);\n+  T (2, \"%hi\",          a);\n+  T (2, \"%ho\",          a);\n+  T (2, \"%hu\",          a);\n+  T (2, \"%hx\",          a);\n+\n+  T (2, \"% hd\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hi\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% ho\",         a);     /* { dg-warning \". . flag used with .%o.\" } */\n+  T (2, \"% hu\",         a);     /* { dg-warning \". . flag used with .%u.\" } */\n+  T (2, \"% hx\",         a);     /* { dg-warning \". . flag used with .%x.\" } */\n+\n+  T (2, \"#%ho\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"#%hx\",         a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%2hd\",         a);\n+  T (3, \"%2hi\",         a);\n+  T (3, \"%2ho\",         a);\n+  T (3, \"%2hu\",         a);\n+  T (3, \"%2hx\",         a);\n+}\n+\n+/* Exercise all integer specifiers with no modifier and a non-constant\n+   argument.  */\n+\n+void test_sprintf_chk_int_nonconst (int a)\n+{\n+  T (-1, \"%d\",          a);\n+\n+  T (0, \"%d\",           a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%i\",           a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%u\",           a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%x\",           a);     /* { dg-warning \"into a region\" } */\n+\n+  T (1, \"%d\",           a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%i\",           a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%u\",           a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%x\",           a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"% d\",          a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"% i\",          a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+d\",          a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+i\",          a);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-d\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-i\",          a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%d\",           a);\n+  T (2, \"%i\",           a);\n+  T (2, \"%o\",           a);\n+  T (2, \"%u\",           a);\n+  T (2, \"%x\",           a);\n+\n+  T (2, \"% d\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% i\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% o\",          a);     /* { dg-warning \". . flag used with .%o.\" } */\n+  T (2, \"% u\",          a);     /* { dg-warning \". . flag used with .%u.\" } */\n+  T (2, \"% x\",          a);     /* { dg-warning \". . flag used with .%x.\" } */\n+\n+  T (2, \"#%o\",          a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"#%x\",          a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%2d\",          a);\n+  T (3, \"%2i\",          a);\n+  T (3, \"%2o\",          a);\n+  T (3, \"%2u\",          a);\n+  T (3, \"%2x\",          a);\n+}\n+\n+void test_sprintf_chk_e_nonconst (double d)\n+{\n+  T (-1, \"%E\",          d);\n+  T ( 0, \"%E\",          d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n+  T ( 0, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%E\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 3, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n+  T (12, \"%e\",          d);           /* { dg-warning \"past the end\" } */\n+  T (12, \"%e\",          d);           /* { dg-warning \"past the end\" } */\n+  T (13, \"%E\",          d);           /* 1.000000E+00 */\n+  T (13, \"%e\",          d);\n+  T (14, \"%E\",          d);\n+  T (14, \"%e\",          d);\n+\n+  T  (0, \"%+E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n+  T  (0, \"%-e\",         d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n+  T  (0, \"% E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n+\n+  /* The range of output of \"%.0e\" is between 5 and 7 bytes (not counting\n+     the terminating NUL.  */\n+  T ( 5, \"%.0e\",        d);           /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T ( 6, \"%.0e\",        d);           /* 1e+00 */\n+\n+  /* The range of output of \"%.1e\" is between 7 and 9 bytes (not counting\n+     the terminating NUL.  */\n+  T ( 7, \"%.1e\",        d);           /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T ( 8, \"%.1e\",        d);\n+}\n+\n+void test_sprintf_chk_f_nonconst (double d)\n+{\n+  T (-1, \"%F\",          d);\n+  T ( 0, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 0, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 3, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 3, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 4, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 4, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 5, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 5, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 6, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 6, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 7, \"%F\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 7, \"%f\",          d);           /* { dg-warning \"into a region\" } */\n+  T ( 8, \"%F\",          d);           /* { dg-warning \"nul past the end\" } */\n+  T ( 8, \"%f\",          d);           /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%F\",          d);\n+  T ( 9, \"%f\",          d);\n+}\n+\n+/* Tests for __builtin_vsprintf_chk are the same as those for\n+   __builtin_sprintf_chk with non-constant arguments.  */\n+#undef T\n+#define T(size, fmt)\t\t\t\t\t\t\t\\\n+  __builtin___vsprintf_chk (buffer (size), 0, objsize (size), fmt, va)\n+\n+void test_vsprintf_chk_c (__builtin_va_list va)\n+{\n+  T (-1, \"%c\");\n+\n+  /* Verify the full text of the diagnostic for just the distinct messages\n+     and use abbreviations in subsequent test cases.  */\n+  T (0, \"%c\");              /* { dg-warning \".%c. directive writing 1 byte into a region of size 0\" } */\n+  T (1, \"%c\");              /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (1, \"%c\");              /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%c\");\n+  T (2, \"%2c\");             /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%3c\");             /* { dg-warning \"into a region\" } */\n+  T (2, \"%c%c\");            /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%c%c\");\n+\n+  /* Wide characters.  */\n+  T (0, \"%lc\");             /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%lc\");\n+  T (2, \"%lc\");\n+\n+  /* The following could result in as few as a single byte and in as many\n+     as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n+     the write cannot be reliably diagnosed.  */\n+  T (2, \"%lc\");\n+  T (2, \"%1lc\");\n+  /* Writing some unknown number of bytes into a field two characters wide.  */\n+  T (2, \"%2lc\");            /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%lc%lc\");\n+\n+  T (3, \"%lc%c\");\n+  /* Here in the best case each argument will format as single character,\n+     causing the terminating NUL to be written past the end.  */\n+  T (3, \"%lc%c%c\");\n+\n+}\n+\n+void test_vsprintf_chk_int (__builtin_va_list va)\n+{\n+  T (-1, \"%d\");\n+\n+  T (0, \"%d\");                /* { dg-warning \"into a region\" } */\n+  T (0, \"%i\");                /* { dg-warning \"into a region\" } */\n+  T (0, \"%u\");                /* { dg-warning \"into a region\" } */\n+  T (0, \"%x\");                /* { dg-warning \"into a region\" } */\n+\n+  T (1, \"%d\");                /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%i\");                /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%u\");                /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%x\");                /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"% d\");               /* { dg-warning \"into a region\" } */\n+  T (1, \"% i\");               /* { dg-warning \"into a region\" } */\n+  T (1, \"%+d\");               /* { dg-warning \"into a region\" } */\n+  T (1, \"%+i\");               /* { dg-warning \"into a region\" } */\n+  T (1, \"%-d\");               /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-i\");               /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%d\");\n+  T (2, \"%i\");\n+  T (2, \"%o\");\n+  T (2, \"%u\");\n+  T (2, \"%x\");\n+\n+  T (2, \"% d\");               /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% i\");               /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% o\");               /* { dg-warning \". . flag used with .%o.\" } */\n+  T (2, \"% u\");               /* { dg-warning \". . flag used with .%u.\" } */\n+  T (2, \"% x\");               /* { dg-warning \". . flag used with .%x.\" } */\n+\n+  T (2, \"#%o\");               /* { dg-warning \"nul past the end\" } */\n+  T (2, \"#%x\");               /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%2d\");\n+  T (3, \"%2i\");\n+  T (3, \"%2o\");\n+  T (3, \"%2u\");\n+  T (3, \"%2x\");\n+}\n+\n+#undef T\n+#define T(size, fmt, ...)\t\t\t\t\t\t\\\n+  __builtin_snprintf (buffer (size), objsize (size), fmt, __VA_ARGS__)\n+\n+void test_snprintf_c_const (void)\n+{\n+  T (-1, \"%c\",    0);            /* { dg-warning \"specified destination size \\[0-9\\]+ too large\" } */\n+\n+  /* Verify the full text of the diagnostic for just the distinct messages\n+     and use abbreviations in subsequent test cases.  */\n+\n+  /* A call to snprintf with a buffer of zero size is a request to determine\n+     the size of output without writing anything into the destination. No\n+     warning must be issued.  */\n+  T (0, \"%c\",     0);\n+  T (1, \"%c\",     0);            /* { dg-warning \"output truncated before the last format character\" } */\n+  T (1, \"%c\",   '1');            /* { dg-warning \"output truncated\" } */\n+  T (2, \"%c\",   '1');\n+  T (2, \"%2c\",  '1');            /* { dg-warning \"output truncated\" } */\n+  T (2, \"%3c\",  '1');            /* { dg-warning \"directive output truncated\" } */\n+  T (2, \"%c%c\", '1', '2');       /* { dg-warning \"output truncated\" } */\n+  T (3, \"%c%c\", '1', '2');\n+\n+  /* Wide characters.  */\n+  T (0, \"%lc\",  0);\n+  T (1, \"%lc\",  0);\n+  T (2, \"%lc\",  0);\n+\n+  /* The following could result in as few as a single byte and in as many\n+     as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n+     the write cannot be reliably diagnosed.  */\n+  T (2, \"%lc\",  L'1');\n+  T (2, \"%1lc\", L'1');\n+  /* Writing at least 1 characted into a field two characters wide.  */\n+  T (2, \"%2lc\", L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n+\n+  T (3, \"%lc%c\",   L'1', '2');\n+  /* Here in the best case each argument will format as single character,\n+     causing the output to be truncated just before the terminating NUL\n+     (i.e., cutting off the '3').  */\n+  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"output truncated\" } */\n+}\n+\n+#undef T\n+#define T(size, fmt, ...)\t\t\t\t\t\t\\\n+  __builtin___snprintf_chk (buffer (size), objsize (size),\t\t\\\n+\t\t\t    0, objsize (size), fmt, __VA_ARGS__)\n+\n+void test_snprintf_chk_c_const (void)\n+{\n+  /* Verify that specifying a size of the destination buffer that's\n+     bigger than its actual size (normally determined and passed to\n+     the function by __builtin_object_size) is diagnosed.  */\n+  __builtin___snprintf_chk (buffer, 3, 0, 2, \" \");   /* { dg-warning \"always overflow|specified size 3 exceeds the size 2 of the destination\" } */\n+\n+  T (-1, \"%c\",    0);           /* { dg-warning \"specified destination size \\[^ \\]* too large\" } */\n+\n+  T (0, \"%c\",     0);\n+  T (0, \"%c%c\",   0, 0);\n+  T (0, \"%c_%c\",  0, 0);\n+  T (0, \"_%c_%c\", 0, 0);\n+\n+  T (1, \"%c\",     0);            /* { dg-warning \"output truncated before the last format character\" } */\n+  T (1, \"%c\",   '1');            /* { dg-warning \"output truncated\" } */\n+  T (2, \"%c\",   '1');\n+  T (2, \"%2c\",  '1');            /* { dg-warning \"output truncated\" } */\n+  T (2, \"%3c\",  '1');            /* { dg-warning \"directive output truncated\" } */\n+  T (2, \"%c%c\", '1', '2');       /* { dg-warning \"output truncated before the last format character\" } */\n+  T (3, \"%c%c\", '1', '2');\n+  T (3, \"%c_%c\", '1', '2');      /* { dg-warning \"output truncated\" } */\n+\n+  /* Wide characters.  */\n+  T (0, \"%lc\",  0);\n+  T (1, \"%lc\",  0);\n+  T (2, \"%lc\",  0);\n+\n+  /* The following could result in as few as a single byte and in as many\n+     as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n+     the write cannot be reliably diagnosed.  */\n+  T (2, \"%lc\",  L'1');\n+  T (2, \"%1lc\", L'1');\n+  /* Writing at least 1 characted into a field two characters wide.  */\n+  T (2, \"%2lc\", L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n+\n+  T (3, \"%lc%c\",   L'1', '2');\n+  /* Here in the best case each argument will format as single character,\n+     causing the output to be truncated just before the terminating NUL\n+     (i.e., cutting off the '3').  */\n+  T (3, \"%lc%c%c\", L'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n+  T (3, \"%lc%lc%c\", L'1', L'2', '3'); /* { dg-warning \"output truncated\" } */\n+}\n+\n+/* Macro to verify that calls to __builtin_vsprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#undef T\n+#define T(size, fmt)\t\t\t\t\\\n+  __builtin_vsprintf (buffer (size), fmt, va)\n+\n+void test_vsprintf_s (__builtin_va_list va)\n+{\n+  T (-1, \"%s\");\n+\n+  T (0, \"%s\");              /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (1, \"%s\");\n+  T (1, \"%1s\");             /* { dg-warning \"writing a terminating nul past the end\" } */\n+\n+  T (2, \"%s%s\");\n+  T (2, \"%s%s_\");\n+  T (2, \"%s_%s\");\n+  T (2, \"_%s%s\");\n+  T (2, \"_%s_%s\");          /* { dg-warning \"writing a terminating nul past the end\" } */\n+}\n+\n+/* Exercise all integer specifiers with no modifier and a non-constant\n+   argument.  */\n+\n+void test_vsprintf_int (__builtin_va_list va)\n+{\n+  T (-1, \"%d\");\n+\n+  T (0, \"%d\");     /* { dg-warning \"into a region\" } */\n+  T (0, \"%i\");     /* { dg-warning \"into a region\" } */\n+  T (0, \"%u\");     /* { dg-warning \"into a region\" } */\n+  T (0, \"%x\");     /* { dg-warning \"into a region\" } */\n+\n+  T (1, \"%d\");     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%i\");     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%u\");     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%x\");     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"% d\");     /* { dg-warning \"into a region\" } */\n+  T (1, \"% i\");     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+d\");     /* { dg-warning \"into a region\" } */\n+  T (1, \"%+i\");     /* { dg-warning \"into a region\" } */\n+  T (1, \"%-d\");     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-i\");     /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%d\");\n+  T (2, \"%i\");\n+  T (2, \"%o\");\n+  T (2, \"%u\");\n+  T (2, \"%x\");\n+\n+  T (2, \"% d\");     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% i\");     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% o\");     /* { dg-warning \". . flag used with .%o.\" } */\n+  T (2, \"% u\");     /* { dg-warning \". . flag used with .%u.\" } */\n+  T (2, \"% x\");     /* { dg-warning \". . flag used with .%x.\" } */\n+\n+  T (2, \"#%o\");     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"#%x\");     /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%2d\");\n+  T (3, \"%2i\");\n+  T (3, \"%2o\");\n+  T (3, \"%2u\");\n+  T (3, \"%2x\");\n+}\n+\n+#undef T\n+#define T(size, fmt)\t\t\t\t\t\t\t\\\n+  __builtin_vsnprintf (buffer (size), objsize (size), fmt, va)\n+\n+void test_vsnprintf_s (__builtin_va_list va)\n+{\n+  T (-1, \"%s\");             /* { dg-warning \"specified destination size \\[^ \\]* too large\" } */\n+\n+  T (0, \"%s\");\n+  T (1, \"%s\");\n+  T (1, \"%1s\");             /* { dg-warning \"output truncated before the last format character\" } */\n+\n+  T (2, \"%s%s\");\n+  T (2, \"%s%s_\");\n+  T (2, \"%s_%s\");\n+  T (2, \"_%s%s\");\n+  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated before the last format character\" } */\n+}\n+\n+#undef T\n+#define T(size, fmt)\t\t\t\t\t\t\t\\\n+  __builtin___vsnprintf_chk (buffer (size), objsize (size),\t\t\\\n+\t\t\t     0, objsize (size), fmt, va)\n+\n+void test_vsnprintf_chk_s (__builtin_va_list va)\n+{\n+  /* Verify that specifying a size of the destination buffer that's\n+     bigger than its actual size (normally determined and passed to\n+     the function by __builtin_object_size) is diagnosed.  */\n+  __builtin___snprintf_chk (buffer, 123, 0, 122, \" \");   /* { dg-warning \"always overflow|specified size 123 exceeds the size 122 of the destination object\" } */\n+\n+  __builtin___snprintf_chk (buffer, __SIZE_MAX__, 0, 2, \" \");   /* { dg-warning \"always overflow|destination size .\\[0-9\\]+. too large\" } */\n+\n+  T (0, \"%s\");\n+  T (1, \"%s\");\n+  T (1, \"%1s\");             /* { dg-warning \"output truncated before the last format character\" } */\n+\n+  T (2, \"%s%s\");\n+  T (2, \"%s%s_\");\n+  T (2, \"%s_%s\");\n+  T (2, \"_%s%s\");\n+  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated before the last format character\" } */\n+}"}, {"sha": "b0f2d450077012d92708c3638c47f1fd3611aa7a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-2.c", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,214 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -Wformat -Wformat-length=2 -ftrack-macro-expansion=0\" } */\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+char buffer [256];\n+extern char *ptr;\n+\n+#define buffer(size)\t\t\t\t\t\t\t\\\n+  (!LINE || __LINE__ == LINE ? buffer + sizeof buffer - size : ptr)\n+\n+#define objsize(size)  (!LINE || __LINE__ == LINE ? size : __SIZE_MAX__ / 2)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#if !__cplusplus\n+typedef __WCHAR_TYPE__ wchar_t;\n+#endif\n+\n+typedef unsigned char UChar;\n+\n+#define T(size, fmt, ...)\t\t\t\t\\\n+  __builtin_sprintf (buffer (size), fmt, __VA_ARGS__)\n+\n+__builtin_va_list va;\n+\n+/* Exercise buffer overflow detection with const string arguments.  */\n+\n+void test_s_const (void)\n+{\n+    /* Wide string literals are handled slightly differently than\n+       at level 1.  At level 1, each wide character is assumed to\n+       convert into a single byte.  At level 2, they are assumed\n+       to convert into at least one byte.  */\n+  T (0, \"%ls\",      L\"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%ls\",      L\"\");\n+  T (1, \"%ls\",      L\"\\0\");\n+  T (1, \"%1ls\",     L\"\");       /* { dg-warning \"nul past the end\" } */\n+\n+  T (0, \"%*ls\",  0, L\"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%*ls\",  0, L\"\");\n+  T (1, \"%*ls\",  0, L\"\\0\");\n+  T (1, \"%*ls\",  1, L\"\");       /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.0ls\",    L\"1\");\n+  T (2, \"%.0ls\",    L\"1\");\n+  T (2, \"%.1ls\",    L\"1\");\n+\n+  /* The \"%.2ls\" directive below will write at a minimum 1 byte (because\n+     L\"1\" is known and can be assumed to convert to at least one multibyte\n+     character), and at most 2 bytes because of the precision.  Since its\n+     output is explicitly bounded it is diagnosed.  */\n+  T (2, \"%.2ls\",    L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*ls\", 2, L\"1\");      /* { dg-warning \"nul past the end\" } */\n+\n+  /* The following three are constrained by the precision to at most\n+     that many bytes of the converted wide string plus a terminating NUL.  */\n+  T (2, \"%.0ls\",    L\"1\");\n+  T (2, \"%.1ls\",    L\"1\");\n+  T (3, \"%.2ls\",    L\"1\");\n+}\n+\n+\n+struct Arrays {\n+  char a1 [1];\n+  char a2 [2];\n+  char a3 [3];\n+  char a4 [4];\n+  char a0 [0];\n+  char ax [];\n+};\n+\n+/* Exercise buffer overflow detection with non-const string arguments.  */\n+\n+void test_s_nonconst (const char *s, const wchar_t *ws, struct Arrays *a)\n+{\n+  T (0, \"%s\",   s);             /* { dg-warning \"into a region\" \"sprintf transformed into strcpy\" { xfail *-*-*-* } } */\n+  T (1, \"%s\",   s);             /* { dg-warning \"nul past the end\" \"sprintf transformed into strcpy\" { xfail *-*-*-* } } */\n+  T (1, \"%1s\",  s);             /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.0s\", s);\n+  T (1, \"%.1s\", s);             /* { dg-warning \"writing a terminating nul\" } */\n+\n+  T (1, \"%ls\",  ws);            /* { dg-warning \"writing a terminating nul\" } */\n+\n+  /* Verify that the size of the array is used in lieu of its length.\n+     The minus sign disables GCC's sprintf to strcpy transformation.  */\n+  T (1, \"%-s\", a->a1);          /* { dg-warning \"nul past the end\" } */\n+\n+  /* In the following test, since the length of the strings isn't known,\n+     their type (the array) is used to bound the maximum length to 1,\n+     which means the \"%-s\" directive would not overflow the buffer,\n+     but it would leave no room for the terminating nul.  */\n+  T (1, \"%-s\", a->a2);          /* { dg-warning \"writing a terminating nul\" } */\n+\n+  /* Unlike in the test above, since the length of the string is bounded\n+     by the array type to at most 2, the \"^-s\" directive is diagnosed firts,\n+     preventing the diagnostic about the terminatinb nul.  */\n+  T (1, \"%-s\", a->a3);          /* { dg-warning \"directive writing between 1 and 2 bytes\" } */\n+\n+  /* The length of a zero length array and flexible array member is\n+     unknown and at leve 2 assumed to be at least 1.  */\n+  T (1, \"%-s\", a->a0);          /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", a->ax);          /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%-s\", a->a0);\n+  T (2, \"%-s\", a->ax);\n+}\n+\n+  /* Exercise buffer overflow detection with non-const integer arguments.  */\n+\n+void test_hh_nonconst (int x)\n+{\n+  T (1, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%hhi\",         x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}\n+\n+void test_h_nonconst (int x)\n+{\n+  extern UChar uc;\n+\n+  T (1, \"%hi\",         uc);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%hi\",         uc);     /* { dg-warning \"into a region\" } */\n+  /* Formatting an 8-bit unsigned char as a signed short (or any other\n+     type with greater precision) can write at most 3 characters.  */\n+  T (3, \"%hi\",         uc);     /* { dg-warning \"terminating nul past\" } */\n+  T (4, \"%hi\",         uc);\n+\n+  /* Verify that the same thing works when the int argument is cast\n+     to unsigned char.  */\n+  T (1, \"%hi\",   (UChar)x);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%hi\",   (UChar)x);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%hi\",   (UChar)x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T (4, \"%hi\",   (UChar)x);\n+}\n+\n+void test_i_nonconst (int x)\n+{\n+  extern UChar uc;\n+\n+  T (1, \"%i\",          uc);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%i\",          uc);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%i\",          uc);     /* { dg-warning \"terminating nul past\" } */\n+  T (4, \"%i\",          uc);\n+\n+  T (1, \"%i\",    (UChar)x);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%i\",    (UChar)x);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%i\",    (UChar)x);     /* { dg-warning \"terminating nul past\" } */\n+  T (4, \"%i\",    (UChar)x);\n+\n+  /* Verify the same thing using a bit-field.  */\n+  extern struct {\n+    unsigned int  b1: 1;\n+    unsigned int  b2: 2;\n+    unsigned int  b3: 3;\n+    unsigned int  b4: 4;\n+\t     int sb4: 4;\n+    unsigned int  b5: 5;\n+    unsigned int  b6: 6;\n+    unsigned int  b7: 7;\n+    unsigned int  b8: 8;\n+  } bf, abf[], *pbf;\n+\n+  T (1, \"%i\",       bf.b1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%i\",  abf [x].b1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%i\",     pbf->b1);     /* { dg-warning \"nul past the end\" } */\n+  /* A one bit bit-field can only be formatted as '0' or '1'.  Similarly,\n+     two- and three-bit bit-fields can only be formatted as a single\n+     decimal digit.  */\n+  T (2, \"%i\",       bf.b1);\n+  T (2, \"%i\",  abf [x].b1);\n+  T (2, \"%i\",     pbf->b1);\n+  T (2, \"%i\",       bf.b2);\n+  T (2, \"%i\",  abf [x].b2);\n+  T (2, \"%i\",     pbf->b2);\n+  T (2, \"%i\",       bf.b3);\n+  T (2, \"%i\",  abf [x].b3);\n+  T (2, \"%i\",     pbf->b3);\n+  /* A four-bit bit-field can be formatted as either one or two digits.  */\n+  T (2, \"%i\",       bf.b4);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%i\",  abf [x].b4);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%i\",     pbf->b4);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (3, \"%i\",       bf.b4);\n+  T (3, \"%i\",     pbf->b4);\n+  T (3, \"%i\",       bf.b5);\n+  T (3, \"%i\",     pbf->b5);\n+  T (3, \"%i\",       bf.b6);\n+  T (3, \"%i\",     pbf->b6);\n+  T (3, \"%i\",       bf.b7);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%i\",     pbf->b7);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (1, \"%i\",       bf.b8);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%i\",       bf.b8);     /* { dg-warning \"into a region\" } */\n+  /* Formatting an 8-bit unsigned char as a signed short (or any other\n+     type with greater precision) int can write at most 3 characters.  */\n+  T (3, \"%i\",       bf.b8);     /* { dg-warning \"terminating nul past\" } */\n+  T (4, \"%i\",       bf.b8);\n+\n+  T (1, \"%i\",       bf.b8);     /* { dg-warning \"into a region\" } */\n+  T (2, \"%i\",       bf.b8);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%i\",       bf.b8);     /* { dg-warning \"terminating nul past\" } */\n+\n+  T (2, \"%i\",      bf.sb4);     /* { dg-warning \"terminating nul past\" } */\n+  T (3, \"%i\",      bf.sb4);\n+  T (4, \"%i\",      bf.sb4);\n+}"}, {"sha": "625d055bafb9a873aa3d4f7abb780a44ee2cbf79", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,234 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -O2 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n+\n+#ifndef LINE\n+#  define LINE 0\n+#endif\n+\n+#define bos(x) __builtin_object_size (x, 0)\n+\n+#define T(bufsize, fmt, ...)\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      if (!LINE || __LINE__ == LINE)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  char *d = (char *)__builtin_malloc (bufsize);\t\t\t\\\n+\t  __builtin___sprintf_chk (d, 0, bos (d), fmt, __VA_ARGS__);\t\\\n+\t  sink (d);\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    } while (0)\n+\n+void\n+sink (void*);\n+\n+/* Identity function to verify that the checker figures out the value\n+   of the operand even when it's not constant (i.e., makes use of\n+   inlining and constant propagation information).  */\n+\n+int i (int x) { return x; }\n+const char* s (const char *str) { return str; }\n+\n+/* Function to \"generate\" a unique unknown number (as far as GCC can\n+   tell) each time it's called.  It prevents the optimizer from being\n+   able to narrow down the ranges of possible values in test functions\n+   with repeated references to the same variable.  */\n+extern int x (void);\n+\n+/* Verify that the checker can detect buffer overflow when the \"%s\"\n+   argument is in a known range of lengths and one or both of which\n+   exceed the size of the destination.  */\n+\n+void test_sprintf_chk_string (const char *s, const char *t)\n+{\n+#define x x ()\n+\n+  T (1, \"%s\", x ? \"\" : \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s\", x ? \"1\" : \"\");       /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s\", x ? s : \"1\");        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s\", x ? \"1\" : s);        /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%s\", x ? s : t);\n+\n+  T (2, \"%s\", x ? \"\" : \"1\");\n+  T (2, \"%s\", x ? \"\" : s);\n+  T (2, \"%s\", x ? \"1\" : \"\");\n+  T (2, \"%s\", x ? s : \"\");\n+  T (2, \"%s\", x ? \"1\" : \"2\");\n+  T (2, \"%s\", x ? \"\" : \"12\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%s\", x ? \"12\" : \"\");      /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%s\", x ? \"\" : \"123\");     /* { dg-warning \"into a region\" } */\n+  T (2, \"%s\", x ? \"123\" : \"\");     /* { dg-warning \"into a region\" } */\n+\n+#undef x\n+}\n+\n+\n+/* Verify that the checker makes use of integer constant propagation\n+   to detect buffer overflow in non-constant cases.  */\n+\n+void test_sprintf_chk_integer_value (void)\n+{\n+  T ( 1, \"%i\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  i (    1));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  i (   -1));         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%i_\", i (    1));         /* { dg-warning \"character ._. at offset 2 past the end\" } */\n+  T ( 1, \"_%i\", i (    1));         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"_%i_\",i (    1));         /* { dg-warning \"into a region\" } */\n+  T ( 1, \"%o\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%u\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%x\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#x\", i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%x\",  i (    1));         /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%#x\", i (    1));         /* { dg-warning \"into a region\" } */\n+\n+  T ( 2, \"%i\",  i (    0));\n+  T ( 2, \"%i\",  i (    1));\n+  T ( 2, \"%i\",  i (    9));\n+  T ( 2, \"%i\",  i (   -1));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  i (   10));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i_\", i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%i\", i (    0));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"_%i_\",i (    0));         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 2, \"%o\",  i (    1));\n+  T ( 2, \"%o\",  i (    7));\n+  T ( 2, \"%o\",  i (  010));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%o\",  i ( 0100));         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%x\",  i (    1));\n+  T ( 2, \"%#x\", i (    1));         /* { dg-warning \"into a region\" } */\n+  T ( 2, \"%x\",  i (  0xa));\n+  T ( 2, \"%x\",  i (  0xf));\n+  T ( 2, \"%x\",  i ( 0x10));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%x\",  i ( 0xff));         /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%x\",  i (0x1ff));         /* { dg-warning \"into a region\" } */\n+\n+  T ( 3, \"%i\",  i (    0));\n+  T ( 3, \"%i\",  i (    1));\n+  T ( 3, \"%i\",  i (    9));\n+  T ( 3, \"%i\",  i (   -9));\n+  T ( 3, \"%i\",  i (   10));\n+  T ( 3, \"%i\",  i (   99));\n+  T ( 3, \"%i\",  i (  -99));         /* { dg-warning \"nul past the end\" } */\n+\n+  T ( 3, \"%i\",  i (99) + i (1));    /* { dg-warning \"nul past the end\" } */\n+\n+  T ( 8, \"%8u\", i (    1));         /* { dg-warning \"nul past the end\" } */\n+  T ( 9, \"%8u\", i (    1));\n+}\n+\n+/* Functions to require optimization to figure out the range of the operand.\n+   Used to verify that the checker makes use of the range information to\n+   avoid diagnosing the output of sufficiently constrained arguments to\n+   integer directives.  */\n+\n+signed char*\n+range_schar (signed char *val, signed char min, signed char max)\n+{\n+  if (*val < min || max < *val) __builtin_abort ();\n+  return val;\n+}\n+\n+unsigned char*\n+range_uchar (unsigned char *val, unsigned char min, unsigned char max)\n+{\n+  if (*val < min || max < *val) __builtin_abort ();\n+  return val;\n+}\n+\n+signed short*\n+range_sshort (signed short *val, signed short min, signed short max)\n+{\n+  if (*val < min || max < *val) __builtin_abort ();\n+  return val;\n+}\n+\n+unsigned short*\n+range_ushort (unsigned short *val, unsigned short min, unsigned short max)\n+{\n+  if (*val < min || max < *val) __builtin_abort ();\n+  return val;\n+}\n+\n+/* Helper to prevent GCC from figuring out the return value.  */\n+extern int idx (void);\n+\n+/* Exercise ranges only in types signed and unsigned char and short.\n+   No other types work due to bug 71690.  */\n+\n+void test_sprintf_chk_range_schar (signed char *a)\n+{\n+  (void)&a;\n+\n+  /* Ra creates a range of signed char for A [idx].  A different\n+     value is used each time to prevent the ranges from intesecting\n+     one another, possibly even eliminating some tests as a result\n+     of the range being empty.  */\n+#define R(min, max) *range_schar (a + idx (), min, max)\n+\n+  T ( 0, \"%i\",  R (0, 9));      /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R (0, 9));      /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R (0, 9));\n+  T ( 2, \"%i\",  R (-1, 0));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 2, \"%i\",  R (9, 10));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  R ( -9,   9));\n+  T ( 3, \"%i\",  R (-99,  99));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 3, \"%i\",  R (  0,  99));\n+  T ( 3, \"%i\",  R (  0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  /* The following call may write as few as 3 bytes and as many as 5.\n+     It's judgment call how best to diagnose it to make the potential\n+     problem clear.  */\n+  T ( 3, \"%i%i\", R (1, 10), R (9, 10));   /* { dg-warning \".%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+\n+  T ( 4, \"%i%i\", R (10, 11), R (12, 13));   /* { dg-warning \"nul past the end\" } */\n+\n+  T ( 5, \"%i%i\", R (-9, 99), R (-9, 99));\n+\n+  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 9), R (0,  9));\n+  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 9), R (0, 10));  /* { dg-warning \"may write a terminating nul past the end\" } */\n+  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n+  T ( 6, \"%i_%i_%i\", R (0, 10), R (0, 9), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n+  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \".%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+}\n+\n+void test_sprintf_chk_range_uchar (unsigned char *a, unsigned char *b)\n+{\n+  (void)&a;\n+  (void)&b;\n+\n+#undef Ra\n+#define Ra(min, max) *range_uchar (a + idx (), min, max)\n+\n+  T ( 0, \"%i\",  Ra (0,  9));   /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  Ra (0,  9));   /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  Ra (0,  9));\n+  T ( 2, \"%i\",  Ra (9, 10));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  Ra (0,  99));\n+  T ( 3, \"%i\",  Ra (0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}\n+\n+void test_sprintf_chk_range_sshort (signed short *a, signed short *b)\n+{\n+  (void)&a;\n+  (void)&b;\n+\n+#undef Ra\n+#define Ra(min, max) *range_sshort (a + idx (), min, max)\n+\n+  T ( 0, \"%i\",  Ra ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  Ra ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  Ra ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  Ra ( 0, 1));\n+  T ( 2, \"%i\",  Ra ( 8, 9));\n+  T ( 2, \"%i\",  Ra ( 0, 9));\n+  T ( 2, \"%i\",  Ra (-1, 0));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 2, \"%i\",  Ra ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  Ra ( 0, 99));\n+  T ( 3, \"%i\",  Ra (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 4, \"%i\",  Ra (  0,  999));\n+  T ( 4, \"%i\",  Ra ( 99,  999));\n+  T ( 4, \"%i\",  Ra (998,  999));\n+  T ( 4, \"%i\",  Ra (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}"}, {"sha": "944c36e242c410cb170533933995787a1eb6b4b9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wformat -Wformat-length=1 -fdiagnostics-show-caret -ftrack-macro-expansion=0\" } */\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+char dst [8];\n+\n+void test (void)\n+{\n+  sprintf (dst + 7, \"%-s\", \"1\");\n+  /* { dg-warning \"writing a terminating nul past the end of the destination\" \"\" { target *-*-*-* } 10 }\n+     { dg-message \"format output 2 bytes into a destination of size 1\" \"\" { target *-*-*-* } 10 }\n+     { dg-begin-multiline-output \"\" }\n+   sprintf (dst + 7, \"%-s\", \"1\");\n+                     ^~~~~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"\" }\n+   sprintf (dst + 7, \"%-s\", \"1\");\n+   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (dst + 7, \"%-s\", \"abcd\");\n+  /* { dg-warning \".%-s. directive writing 4 bytes into a region of size 1\" \"\" { target *-*-*-* } 22 }\n+     { dg-message \"format output 5 bytes into a destination of size 1\" \"\" { target *-*-*-* } 22 }\n+     { dg-begin-multiline-output \"\" }\n+   sprintf (dst + 7, \"%-s\", \"abcd\");\n+                      ^~~   ~~~~~~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"\" }\n+   sprintf (dst + 7, \"%-s\", \"abcd\");\n+   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+    { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "1e50be15f05665114d000e08f9ac677d25d2b5c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c", "status": "added", "additions": 540, "deletions": 0, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -0,0 +1,540 @@\n+/* Test to verify that the return value of calls to __builtin_sprintf\n+   that produce a known number of bytes on output is available for\n+   constant folding.  With optimization enabled the test will fail to\n+   link if any of the assertions fails.  Without optimization the test\n+   aborts at runtime if any of the assertions fails.  */\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -Wall -Wno-pedantic -fprintf-return-value\" } */\n+\n+#ifndef LINE\n+#  define LINE   0\n+#endif\n+\n+#if __STDC_VERSION__ < 199901L\n+#  define __func__   __FUNCTION__\n+#endif\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+unsigned ntests;\n+unsigned nfails;\n+\n+void __attribute__ ((noclone, noinline))\n+checkv (const char *func, int line, int res, int min, int max,\n+\tchar *dst, const char *fmt, __builtin_va_list va)\n+{\n+  int n = __builtin_vsprintf (dst, fmt, va);\n+  int len = __builtin_strlen (dst);\n+\n+  ++ntests;\n+\n+  int fail = 0;\n+  if (n != res)\n+    {\n+      __builtin_printf (\"FAIL: %s:%i: \\\"%s\\\" expected result for \\\"%s\\\" \"\n+\t\t\t\"doesn't match function call return value: \",\n+\t\t\tfunc, line, fmt, dst);\n+      if (min == max)\n+\t__builtin_printf (\"%i != %i\\n\", n, min);\n+      else\n+\t__builtin_printf (\"%i not in [%i, %i]\\n\", n, min, max);\n+\n+      fail = 1;\n+    }\n+  else\n+    {\n+      if (len < min || max < len)\n+\t{\n+\t  __builtin_printf (\"FAIL: %s:%i: \\\"%s\\\" expected result for \\\"%s\\\" \"\n+\t\t\t    \"doesn't match output length: \",\n+\t\t\t    func, line, fmt, dst);\n+\n+\t  if (min == max)\n+\t    __builtin_printf (\"%i != %i\\n\", len, min);\n+\t  else\n+\t    __builtin_printf (\"%i not in [%i, %i]\\n\", len, min, max);\n+\n+\t  fail = 1;\n+\t}\n+      else\n+\t__builtin_printf (\"PASS: %s:%i: \\\"%s\\\" result %i: \\\"%s\\\"\\n\",\n+\t\t\t  func, line, fmt, n, dst);\n+    }\n+\n+  if (fail)\n+    ++nfails;\n+}\n+\n+void __attribute__ ((noclone, noinline))\n+check (const char *func, int line, int res, int min, int max,\n+       char *dst, const char *fmt, ...)\n+{\n+  __builtin_va_list va;\n+  __builtin_va_start (va, fmt);\n+  checkv (func, line, res, min, max, dst, fmt, va);\n+  __builtin_va_end (va);\n+}\n+\n+char buffer[256];\n+char* volatile dst = buffer;\n+char* ptr = buffer;\n+\n+#define concat(a, b)   a ## b\n+#define CAT(a, b)      concat (a, b)\n+\n+#if __OPTIMIZE__\n+/* With optimization references to the following undefined symbol which\n+   is unique for each test case are expected to be eliminated.  */\n+#  define TEST_FAILURE(line, ignore1, ignore2, ignore3)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    extern void CAT (failure_on_line_, line)(void);\t\t\t\\\n+    CAT (failure_on_line_, line)();\t\t\t\t\t\\\n+  } while (0)\n+#else\n+/* The test is run by DejaGnu with optimization enabled.  When it's run\n+   with it disabled (i.e., at -O0) each test case is verified at runtime\n+   and the test aborts just before exiting if any of them failed.  */\n+#  define TEST_FAILURE(line, result, min, max)\t\t\t\t\\\n+  if (min == max)\t\t\t\t\t\t\t\\\n+    __builtin_printf (\"FAIL: %s:%i: expected %i, got %i\\n\",\t\t\\\n+\t\t      __func__, line, min, result);\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    __builtin_printf (\"FAIL: %s:%i: expected range [%i, %i], got %i\\n\",\t\\\n+\t\t      __func__, line, min, max, result);\n+#endif\n+\n+/* Verify that the result is exactly equal to RES.  */\n+#define EQL(expect, size, fmt, ...)\t\t\t\t\t\\\n+  if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      char *buf = (size) < 0 ? ptr : buffer + sizeof buffer - (size);\t\\\n+      int result = __builtin_sprintf (buf, fmt, __VA_ARGS__);\t\t\\\n+      if (result != expect)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  TEST_FAILURE (__LINE__, expect, expect, result);\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      check (__func__, __LINE__, result, expect, expect, dst, fmt,\t\\\n+\t     __VA_ARGS__);\t\t\t\t\t\t\\\n+    } while (0)\n+\n+/* Verify that the result is in the range [MIN, MAX].  */\n+#define RNG(min, max, size, fmt, ...)\t\t\t\t\t\\\n+  if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      char *buf = (size) < 0 ? ptr : buffer + sizeof buffer - (size);\t\\\n+      int result = __builtin_sprintf (buf, fmt, __VA_ARGS__);\t\t\\\n+      if (result < min || max < result)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  TEST_FAILURE (__LINE__, min, max, result);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      check (__func__, __LINE__, result, min, max, dst, fmt,\t\t\\\n+\t     __VA_ARGS__);\t\t\t\t\t\t\\\n+    } while (0)\n+\n+static void __attribute__ ((noinline, noclone))\n+test_c (char c)\n+{\n+  EQL (1,  2, \"%c\",       c);\n+  EQL (1, -1, \"%c\",       c);\n+  EQL (1,  2, \"%1c\",      c);\n+  EQL (1, -1, \"%1c\",      c);\n+  EQL (1,  2, \"%*c\",      1, c);\n+  EQL (1, -1, \"%*c\",      1, c);\n+  EQL (2,  3, \"%c%c\",     '1', '2');\n+  EQL (2, -1, \"%c%c\",     '1', '2');\n+  EQL (3,  4, \"%3c\",      c);\n+  EQL (3, -1, \"%3c\",      c);\n+  EQL (3,  4, \"%*c\",      3, c);\n+  EQL (3, -1, \"%*c\",      3, c);\n+\n+  EQL (3,  4, \"%*c%*c\",     2,  c,  1,  c);\n+  EQL (3,  4, \"%*c%*c\",     1,  c,  2,  c);\n+  EQL (3,  4, \"%c%c%c\",        '1',    '2',    '3');\n+  EQL (3,  4, \"%*c%c%c\",    1, '1',    '2',    '3');\n+  EQL (3,  4, \"%*c%*c%c\",   1, '1', 1, '2',    '3');\n+  EQL (3,  4, \"%*c%*c%*c\",  1, '1', 1, '2', 1, '3');\n+\n+  EQL (3, -1, \"%*c%*c\",     2,  c,  1,  c);\n+  EQL (3, -1, \"%*c%*c\",     1,  c,  2,  c);\n+  EQL (3, -1, \"%c%c%c\",        '1',    '2',    '3');\n+  EQL (3, -1, \"%*c%c%c\",    1, '1',    '2',    '3');\n+  EQL (3, -1, \"%*c%*c%c\",   1, '1', 1, '2',    '3');\n+  EQL (3, -1, \"%*c%*c%*c\",  1, '1', 1, '2', 1, '3');\n+\n+  EQL (4,  5, \"%c%c %c\",  '1', '2', '3');\n+  EQL (5,  6, \"%c %c %c\", '1', '2', '3');\n+  EQL (5,  6, \"%c %c %c\",  c,   c,   c);\n+}\n+\n+/* Generate a pseudo-random value in the specified range.  The return\n+   value must be unsigned char to work around limitations in the GCC\n+   range information.  Similarly for the declaration of rand() whose\n+   correct return value should be int, but that also prevents the range\n+   information from making it to the printf pass.  */\n+\n+unsigned char uchar_range (unsigned min, unsigned max)\n+{\n+  extern unsigned rand (void);\n+\n+  unsigned x;\n+  x = rand ();\n+\n+  if (x < min)\n+    x = min;\n+  else if (max < x)\n+    x = max;\n+\n+  return x;\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_d_i (int i, long li)\n+{\n+  /*    +-------------------------- expected return value */\n+  /*    |   +---------------------- destination size */\n+  /*    |   |  +------------------- format string */\n+  /*    |   |  |                +-- variable argument(s) */\n+  /*    |   |  |                | */\n+  /*    V   V  V                V */\n+  EQL ( 1,  2, \"%d\",            0);\n+  EQL ( 2,  3, \"%d%d\",          0,   1);\n+  EQL ( 3,  4, \"%d%d\",          9,  10);\n+  EQL ( 4,  5, \"%d%d\",         11,  12);\n+  EQL ( 5,  6, \"%d:%d\",        12,  34);\n+  EQL ( 5,  6, \"%d\",           12345);\n+  EQL ( 6,  7, \"%d\",          -12345);\n+  EQL (15, 16, \"%d:%d:%d:%d\", 123, 124, 125, 126);\n+\n+  EQL ( 1,  2, \"%i\", uchar_range (0, 9));\n+  EQL ( 1, -1, \"%i\", uchar_range (0, 9));\n+\n+  /* The range information available to passes other than the Value\n+     Range Propoagation pass itself is so bad that the following two\n+     tests fail (the range seen in the test below is [0, 99] rather\n+     than [10, 99].\n+  EQL ( 2,  3, \"%i\", uchar_range (10, 99));\n+  EQL ( 3,  4, \"%i\", uchar_range (100, 199));\n+  */\n+\n+  /* Verify that the width allows the return value in the following\n+     calls can be folded despite the unknown value of the argument.  */\n+#if __SIZEOF_INT__ == 2\n+  EQL ( 6,  7, \"%6d\",      i);\n+  EQL ( 6,  7, \"%+6d\",     i);\n+  EQL ( 6,  7, \"%-6d\",     i);\n+  EQL ( 6,  7, \"%06d\",     i);\n+#elif __SIZEOF_INT__ == 4\n+  EQL (11, 12, \"%11d\",     i);\n+  EQL (11, 12, \"%+11d\",    i);\n+  EQL (11, 12, \"%-11d\",    i);\n+  EQL (11, 12, \"%011d\",    i);\n+#elif __SIZEOF_INT__ == 8\n+  EQL (20, 21, \"%20d\",     i);\n+  EQL (20, 21, \"%+20d\",    i);\n+  EQL (20, 21, \"%-29d\",    i);\n+  EQL (20, 21, \"%020d\",    i);\n+#endif\n+\n+#if __SIZEOF_LONG__ == 2\n+  EQL ( 6,  7, \"%6ld\",      li);\n+  EQL ( 6,  7, \"%+6ld\",     li);\n+  EQL ( 6,  7, \"%-6ld\",     li);\n+  EQL ( 6,  7, \"%06ld\",     li);\n+#elif __SIZEOF_LONG__ == 4\n+  EQL (11, 12, \"%11ld\",     li);\n+  EQL (11, 12, \"%+11ld\",    li);\n+  EQL (11, 12, \"%-11ld\",    li);\n+  EQL (11, 12, \"%011ld\",    li);\n+#elif __SIZEOF_LONG__ == 8\n+  EQL (20, 21, \"%20ld\",     li);\n+  EQL (20, 21, \"%+20ld\",    li);\n+  EQL (20, 21, \"%-20ld\",    li);\n+  EQL (20, 21, \"%020ld\",    li);\n+#endif\n+\n+  /* Verify that the output of a directive with an unknown argument\n+     is correctly determined at compile time to be in the expected\n+     range.  */\n+\n+  /*    +---------------------------- expected minimum return value */\n+  /*    |   +------------------------ expected maximum return value */\n+  /*    |   |   +-------------------- destination size */\n+  /*    |   |   |  +----------------- format string */\n+  /*    |   |   |  |           +----- variable argument(s) */\n+  /*    |   |   |  |           | */\n+  /*    V   V   V  V           V */\n+  RNG ( 1,  4,  5, \"%hhi\",     i);\n+  RNG ( 1,  3,  4, \"%hhu\",     i);\n+\n+#if __SIZEOF_SHORT__ == 2\n+  RNG ( 1,  6,  7, \"%hi\",      i);\n+  RNG ( 1,  5,  6, \"%hu\",      i);\n+#elif __SIZEOF_SHORT__ == 4\n+  RNG ( 1, 11, 12, \"%hi\",      i);\n+  RNG ( 1, 10, 11, \"%hu\",      i);\n+#endif\n+\n+#if __SIZEOF_INT__ == 2\n+  RNG ( 1,  6,  7, \"%i\",       i);\n+  RNG ( 1,  5,  6, \"%u\",       i);\n+#elif __SIZEOF_INT__ == 4\n+  RNG ( 1, 11, 12, \"%i\",       i);\n+  RNG ( 1, 10, 11, \"%u\",       i);\n+#elif __SIZEOF_INT__ == 8\n+  RNG ( 1, 20, 21, \"%i\",       i);\n+  RNG ( 1, 19, 20, \"%u\",       i);\n+#endif\n+\n+#if __SIZEOF_LONG__ == 4\n+  RNG ( 1, 11, 12, \"%li\",      li);\n+  RNG ( 1, 10, 11, \"%lu\",      li);\n+#elif __SIZEOF_LONG__ == 8\n+  RNG ( 1, 20, 21, \"%li\",      li);\n+  RNG ( 1, 19, 20, \"%lu\",      li);\n+#endif\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_x (unsigned char uc, unsigned short us, unsigned ui)\n+{\n+  EQL ( 1,  2, \"%hhx\",          0);\n+  EQL ( 2,  3, \"%2hhx\",         0);\n+  EQL ( 2,  3, \"%02hhx\",        0);\n+  EQL ( 2,  3, \"%#02hhx\",       0);\n+\n+  EQL ( 1,  2, \"%hhx\",          1);\n+  EQL ( 2,  3, \"%2hhx\",         1);\n+  EQL ( 2,  3, \"%02hhx\",        1);\n+  EQL ( 3,  4, \"%#02hhx\",       1);\n+\n+  EQL ( 2,  3, \"%2hhx\",        uc);\n+  EQL ( 2,  3, \"%02hhx\",       uc);\n+  EQL ( 5,  6, \"%#05hhx\",      uc);\n+\n+  EQL ( 2,  3, \"%2hhx\",        us);\n+  EQL ( 2,  3, \"%02hhx\",       us);\n+  EQL ( 5,  6, \"%#05hhx\",      us);\n+\n+  EQL ( 2,  3, \"%2hhx\",        ui);\n+  EQL ( 2,  3, \"%02hhx\",       ui);\n+  EQL ( 5,  6, \"%#05hhx\",      ui);\n+\n+  EQL ( 1,  2, \"%x\",            0);\n+  EQL ( 1,  2, \"%#x\",           0);\n+  EQL ( 1,  2, \"%#0x\",          0);\n+  EQL ( 1,  2, \"%x\",            1);\n+  EQL ( 1,  2, \"%x\",          0xf);\n+  EQL ( 2,  3, \"%x\",         0x10);\n+  EQL ( 2,  3, \"%x\",         0xff);\n+  EQL ( 3,  4, \"%x\",        0x100);\n+\n+  EQL (11, 12, \"%02x:%02x:%02x:%02x\",         0xde, 0xad, 0xbe, 0xef);\n+\n+  /* The following would be optimized if the range information of\n+  the variable's type was made available.  Alas, it's lost due\n+  to the promotion of the actual argument (unsined char) to\n+  the type of the \"formal\" argument (int in the case of the\n+  ellipsis).\n+  EQL (11, 12, \"%02x:%02x:%02x:%02x\",   uc,   uc,   uc,   uc);\n+  */\n+  EQL (11, 12, \"%02hhx:%02hhx:%02hhx:%02hhx\",   uc,   uc,   uc,   uc);\n+\n+#if __SIZEOF_SHORT__ == 2\n+  EQL ( 4,  5, \"%04hx\",                   us);\n+  EQL ( 9, 10, \"%04hx:%04hx\",             us, us);\n+  EQL (14, 15, \"%04hx:%04hx:%04hx\",       us, us, us);\n+  EQL (19, 20, \"%04hx:%04hx:%04hx:%04hx\", us, us, us, us);\n+#endif\n+\n+#if __SIZEOF_INT__ == 2\n+  EQL ( 4,  5, \"%04x\", ui);\n+  EQL ( 6,  7, \"%#06x\", ui);\n+#elif __SIZEOF_INT__ == 4\n+  EQL ( 8,  9, \"%08x\", ui);\n+  EQL (10, 10 + 1, \"%#010x\", ui);\n+#elif __SIZEOF_INT__ == 8\n+  EQL (16, 17, \"%016x\", ui);\n+  EQL (18, 19, \"%#018x\",  ui);\n+#endif\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_a_double (void)\n+{\n+  EQL ( 6,  7, \"%a\",   0.0);        /* 0x0p+0 */\n+  EQL ( 6,  7, \"%a\",   1.0);        /* 0x8p-3 */\n+  EQL ( 6,  7, \"%a\",   2.0);        /* 0x8p-2 */\n+\n+  EQL ( 8,  9, \"%.1a\", 3.0);        /* 0xc.0p-2 */\n+  EQL ( 9, 10, \"%.2a\", 4.0);        /* 0xa.00p-1 */\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_a_long_double (void)\n+{\n+  EQL ( 6,  7, \"%La\",   0.0L);      /* 0x0p+0 */\n+  EQL ( 6,  7, \"%La\",   1.0L);      /* 0x8p-3 */\n+  EQL ( 6,  7, \"%La\",   2.0L);      /* 0x8p-2 */\n+\n+  EQL ( 8,  9, \"%.1La\", 3.0L);      /* 0xc.0p-2 */\n+  EQL ( 9, 10, \"%.2La\", 4.0L);      /* 0xa.00p-1 */\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_e_double (void)\n+{\n+  EQL (12, 13, \"%e\",  1.0e0);\n+  EQL (13, 14, \"%e\", -1.0e0);\n+  EQL (12, 13, \"%e\",  1.0e+1);\n+  EQL (13, 14, \"%e\", -1.0e+1);\n+  EQL (12, 13, \"%e\",  1.0e+12);\n+  EQL (13, 14, \"%e\", -1.0e+12);\n+  EQL (13, 14, \"%e\",  1.0e+123);\n+  EQL (14, 15, \"%e\", -1.0e+123);\n+\n+  EQL (12, 13, \"%e\",  9.999e+99);\n+  EQL (12, 13, \"%e\",  9.9999e+99);\n+  EQL (12, 13, \"%e\",  9.99999e+99);\n+\n+  /* The actual output of the following directive depends on the rounding\n+     mode.  */\n+  /* EQL (12, \"%e\",  9.9999994e+99); */\n+\n+  EQL (12, 13, \"%e\",  1.0e-1);\n+  EQL (12, 13, \"%e\",  1.0e-12);\n+  EQL (13, 14, \"%e\",  1.0e-123);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_e_long_double (void)\n+{\n+  EQL (12, 13, \"%Le\",  1.0e0L);\n+  EQL (13, 14, \"%Le\", -1.0e0L);\n+  EQL (12, 13, \"%Le\",  1.0e+1L);\n+  EQL (13, 14, \"%Le\", -1.0e+1L);\n+  EQL (12, 13, \"%Le\",  1.0e+12L);\n+  EQL (13, 14, \"%Le\", -1.0e+12L);\n+  EQL (13, 14, \"%Le\",  1.0e+123L);\n+  EQL (14, 15, \"%Le\", -1.0e+123L);\n+\n+  EQL (12, 13, \"%Le\",  9.999e+99L);\n+  EQL (12, 13, \"%Le\",  9.9999e+99L);\n+  EQL (12, 13, \"%Le\",  9.99999e+99L);\n+  EQL (12, 13, \"%Le\",  9.999999e+99L);\n+\n+  /* The actual output of the following directive depends on the rounding\n+     mode.  */\n+  /* EQL (12, \"%Le\",  9.9999994e+99L); */\n+\n+  EQL (12, 13, \"%Le\",  1.0e-1L);\n+  EQL (12, 13, \"%Le\",  1.0e-12L);\n+  EQL (13, 14, \"%Le\",  1.0e-123L);\n+\n+  EQL ( 6,  7, \"%.0Le\",   1.0e-111L);\n+  EQL ( 8,  9, \"%.1Le\",   1.0e-111L);\n+  EQL (19, 20, \"%.12Le\",  1.0e-112L);\n+  EQL (20, 21, \"%.13Le\",  1.0e-113L);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_f_double (void)\n+{\n+  EQL (  8,   9, \"%f\", 0.0e0);\n+  EQL (  8,   9, \"%f\", 0.1e0);\n+  EQL (  8,   9, \"%f\", 0.12e0);\n+  EQL (  8,   9, \"%f\", 0.123e0);\n+  EQL (  8,   9, \"%f\", 0.1234e0);\n+  EQL (  8,   9, \"%f\", 0.12345e0);\n+  EQL (  8,   9, \"%f\", 0.123456e0);\n+  EQL (  8,   9, \"%f\", 1.234567e0);\n+\n+  EQL (  9,  10, \"%f\", 1.0e+1);\n+  EQL ( 20,  21, \"%f\", 1.0e+12);\n+  EQL (130, 131, \"%f\", 1.0e+123);\n+\n+  EQL (  8,   9, \"%f\", 1.0e-1);\n+  EQL (  8,   9, \"%f\", 1.0e-12);\n+  EQL (  8,   9, \"%f\", 1.0e-123);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_f_long_double (void)\n+{\n+  EQL (  8,   9, \"%Lf\", 0.0e0L);\n+  EQL (  8,   9, \"%Lf\", 0.1e0L);\n+  EQL (  8,   9, \"%Lf\", 0.12e0L);\n+  EQL (  8,   9, \"%Lf\", 0.123e0L);\n+  EQL (  8,   9, \"%Lf\", 0.1234e0L);\n+  EQL (  8,   9, \"%Lf\", 0.12345e0L);\n+  EQL (  8,   9, \"%Lf\", 0.123456e0L);\n+  EQL (  8,   9, \"%Lf\", 1.234567e0L);\n+\n+  EQL (  9,  10, \"%Lf\", 1.0e+1L);\n+  EQL ( 20,  21, \"%Lf\", 1.0e+12L);\n+  EQL (130, 131, \"%Lf\", 1.0e+123L);\n+\n+  EQL (  8,   9, \"%Lf\", 1.0e-1L);\n+  EQL (  8,   9, \"%Lf\", 1.0e-12L);\n+  EQL (  8,   9, \"%Lf\", 1.0e-123L);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+test_s (int i)\n+{\n+  EQL (  0,   1, \"%s\", \"\");\n+  EQL (  0,   1, \"%s\", \"\\0\");\n+  EQL (  1,   2, \"%1s\", \"\");\n+  EQL (  1,   2, \"%s\", \"1\");\n+  EQL (  2,   3, \"%2s\", \"\");\n+  EQL (  2,   3, \"%s\", \"12\");\n+  EQL (  2,   3, \"%s%s\", \"12\", \"\");\n+  EQL (  2,   3, \"%s%s\", \"\", \"12\");\n+  EQL (  2,   3, \"%s%s\", \"1\", \"2\");\n+  EQL (  3,   4, \"%3s\", \"\");\n+  EQL (  3,   4, \"%3s\", \"1\");\n+  EQL (  3,   4, \"%3s\", \"12\");\n+  EQL (  3,   4, \"%3s\", \"123\");\n+  EQL (  3,   4, \"%3.3s\", \"1\");\n+  EQL (  3,   4, \"%3.3s\", \"12\");\n+  EQL (  3,   4, \"%3.3s\", \"123\");\n+  EQL (  3,   4, \"%3.3s\", \"1234\");\n+  EQL (  3,   4, \"%3.3s\", \"12345\");\n+  EQL (  3,   4, \"%s %s\", \"1\", \"2\");\n+  EQL (  4,   5, \"%s %s\", \"12\", \"3\");\n+  EQL (  5,   6, \"%s %s\", \"12\", \"34\");\n+  EQL (  5,   6, \"[%s %s]\", \"1\", \"2\");\n+  EQL (  6,   7, \"[%s %s]\", \"12\", \"3\");\n+  EQL (  7,   8, \"[%s %s]\", \"12\", \"34\");\n+\n+  /* Verify the result of a conditional expression involving string\n+     literals is in the expected range of their lengths.  */\n+  RNG (  0,   3,   4, \"%-s\", i ? \"\"    : \"123\");\n+  RNG (  1,   4,   5, \"%-s\", i ? \"1\"   : \"1234\");\n+  RNG (  2,   5,   6, \"%-s\", i ? \"12\"  : \"12345\");\n+  RNG (  3,   6,   7, \"%-s\", i ? \"123\" : \"123456\");\n+}\n+\n+int main (void)\n+{\n+  test_c ('?');\n+  test_d_i (0xdeadbeef, 0xdeadbeefL);\n+  test_x ('?', 0xdead, 0xdeadbeef);\n+\n+  test_a_double ();\n+  test_e_double ();\n+  test_f_double ();\n+\n+  test_a_long_double ();\n+  test_e_long_double ();\n+  test_f_long_double ();\n+\n+  test_s (0);\n+\n+  if (nfails)\n+    {\n+      __builtin_printf (\"%u out of %u tests failed\\n\", nfails, ntests);\n+      __builtin_abort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "5903fde0bb5050e73d74b5346915c0e4fcb5968a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=88d0c3f0a1448e71dcf49c2f34909ec8d7ce348f", "patch": "@@ -471,6 +471,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_oacc (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_oacc_kernels (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_gen_hsail (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_nonnull_compare (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_sprintf_length (gcc::context *ctxt);\n \n /* IPA Passes */\n extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);"}]}