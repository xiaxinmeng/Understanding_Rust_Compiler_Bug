{"sha": "a5e3d6146d07611eb967befec4dc480c8a19db0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlM2Q2MTQ2ZDA3NjExZWI5NjdiZWZlYzRkYzQ4MGM4YTE5ZGIwZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-10-13T11:03:31Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-10-13T11:03:31Z"}, "message": "tree-vect-loop-manip.c (adjust_vec_debug_stmts): Don't release adjust_vec automatically.\n\n\t* tree-vect-loop-manip.c (adjust_vec_debug_stmts): Don't release\n\tadjust_vec automatically.\n\t(slpeel_add_loop_guard): Remove param cond_expr_stmt_list.  Rename\n\tparam exit_bb to guard_to.\n\t(slpeel_checking_verify_cfg_after_peeling):\n\t(set_prologue_iterations):\n\t(create_lcssa_for_virtual_phi): New func which is factored out from\n\tslpeel_tree_peel_loop_to_edge.\n\t(slpeel_tree_peel_loop_to_edge):\n\t(iv_phi_p): New func.\n\t(vect_can_advance_ivs_p): Call iv_phi_p.\n\t(vect_update_ivs_after_vectorizer): Call iv_phi_p.  Directly insert\n\tnew gimple stmts in basic block.\n\t(vect_do_peeling_for_loop_bound):\n\t(vect_do_peeling_for_alignment):\n\t(vect_gen_niters_for_prolog_loop): Rename to...\n\t(vect_gen_prolog_loop_niters): ...Rename from.  Change parameters and\n\tadjust implementation.\n\t(vect_update_inits_of_drs): Fix code style issue.  Convert niters to\n\tsizetype if necessary.\n\t(vect_build_loop_niters): Move to here from tree-vect-loop.c.  Change\n\tit to external function.\n\t(vect_gen_scalar_loop_niters, vect_gen_vector_loop_niters): New.\n\t(vect_gen_vector_loop_niters_mult_vf): New.\n\t(slpeel_update_phi_nodes_for_loops): New.\n\t(slpeel_update_phi_nodes_for_guard1): Reimplement.\n\t(find_guard_arg, slpeel_update_phi_nodes_for_guard2): Reimplement.\n\t(slpeel_update_phi_nodes_for_lcssa, vect_do_peeling): New.\n\t* tree-vect-loop.c (vect_build_loop_niters): Move to file\n\ttree-vect-loop-manip.c\n\t(vect_generate_tmps_on_preheader): Delete.\n\t(vect_transform_loop): Rename vectorization_factor to vf.  Call\n\tvect_do_peeling instead of vect_do_peeling-* functions.\n\t* tree-vectorizer.h (vect_do_peeling): New decl.\n\t(vect_build_loop_niters, vect_gen_vector_loop_niters): New decls.\n\t(vect_do_peeling_for_loop_bound): Delete.\n\t(vect_do_peeling_for_alignment): Delete.\n\nFrom-SVN: r241099", "tree": {"sha": "d06f61f6ed26f287b7714e5de2d0d009eff03904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d06f61f6ed26f287b7714e5de2d0d009eff03904"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e3d6146d07611eb967befec4dc480c8a19db0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e3d6146d07611eb967befec4dc480c8a19db0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e3d6146d07611eb967befec4dc480c8a19db0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e3d6146d07611eb967befec4dc480c8a19db0d/comments", "author": null, "committer": null, "parents": [{"sha": "3884da6f21ef44778d38b90afc5738ee3d49b4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3884da6f21ef44778d38b90afc5738ee3d49b4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3884da6f21ef44778d38b90afc5738ee3d49b4e6"}], "stats": {"total": 2213, "additions": 910, "deletions": 1303}, "files": [{"sha": "74749aee8a5d3dd021c04c5d91b809800aa071e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5e3d6146d07611eb967befec4dc480c8a19db0d", "patch": "@@ -1,3 +1,43 @@\n+2016-10-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-loop-manip.c (adjust_vec_debug_stmts): Don't release\n+\tadjust_vec automatically.\n+\t(slpeel_add_loop_guard): Remove param cond_expr_stmt_list.  Rename\n+\tparam exit_bb to guard_to.\n+\t(slpeel_checking_verify_cfg_after_peeling):\n+\t(set_prologue_iterations):\n+\t(create_lcssa_for_virtual_phi): New func which is factored out from\n+\tslpeel_tree_peel_loop_to_edge.\n+\t(slpeel_tree_peel_loop_to_edge):\n+\t(iv_phi_p): New func.\n+\t(vect_can_advance_ivs_p): Call iv_phi_p.\n+\t(vect_update_ivs_after_vectorizer): Call iv_phi_p.  Directly insert\n+\tnew gimple stmts in basic block.\n+\t(vect_do_peeling_for_loop_bound):\n+\t(vect_do_peeling_for_alignment):\n+\t(vect_gen_niters_for_prolog_loop): Rename to...\n+\t(vect_gen_prolog_loop_niters): ...Rename from.  Change parameters and\n+\tadjust implementation.\n+\t(vect_update_inits_of_drs): Fix code style issue.  Convert niters to\n+\tsizetype if necessary.\n+\t(vect_build_loop_niters): Move to here from tree-vect-loop.c.  Change\n+\tit to external function.\n+\t(vect_gen_scalar_loop_niters, vect_gen_vector_loop_niters): New.\n+\t(vect_gen_vector_loop_niters_mult_vf): New.\n+\t(slpeel_update_phi_nodes_for_loops): New.\n+\t(slpeel_update_phi_nodes_for_guard1): Reimplement.\n+\t(find_guard_arg, slpeel_update_phi_nodes_for_guard2): Reimplement.\n+\t(slpeel_update_phi_nodes_for_lcssa, vect_do_peeling): New.\n+\t* tree-vect-loop.c (vect_build_loop_niters): Move to file\n+\ttree-vect-loop-manip.c\n+\t(vect_generate_tmps_on_preheader): Delete.\n+\t(vect_transform_loop): Rename vectorization_factor to vf.  Call\n+\tvect_do_peeling instead of vect_do_peeling-* functions.\n+\t* tree-vectorizer.h (vect_do_peeling): New decl.\n+\t(vect_build_loop_niters, vect_gen_vector_loop_niters): New decls.\n+\t(vect_do_peeling_for_loop_bound): Delete.\n+\t(vect_do_peeling_for_alignment): Delete.\n+\n 2016-10-13  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-loop-manip.c (slpeel_tree_duplicate_loop_to_edge_cfg): Put"}, {"sha": "291ecd940dba5885bfc1c703a6a114128db54d78", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 843, "deletions": 1131, "changes": 1974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=a5e3d6146d07611eb967befec4dc480c8a19db0d", "patch": "@@ -188,8 +188,6 @@ adjust_vec_debug_stmts (void)\n       adjust_debug_stmts_now (&adjust_vec.last ());\n       adjust_vec.pop ();\n     }\n-\n-  adjust_vec.release ();\n }\n \n /* Adjust any debug stmts that referenced FROM values to use the\n@@ -235,434 +233,6 @@ adjust_phi_and_debug_stmts (gimple *update_phi, edge e, tree new_def)\n \t\t\tgimple_bb (update_phi));\n }\n \n-\n-/* Update PHI nodes for a guard of the LOOP.\n-\n-   Input:\n-   - LOOP, GUARD_EDGE: LOOP is a loop for which we added guard code that\n-        controls whether LOOP is to be executed.  GUARD_EDGE is the edge that\n-        originates from the guard-bb, skips LOOP and reaches the (unique) exit\n-        bb of LOOP.  This loop-exit-bb is an empty bb with one successor.\n-        We denote this bb NEW_MERGE_BB because before the guard code was added\n-        it had a single predecessor (the LOOP header), and now it became a merge\n-        point of two paths - the path that ends with the LOOP exit-edge, and\n-        the path that ends with GUARD_EDGE.\n-   - NEW_EXIT_BB: New basic block that is added by this function between LOOP\n-        and NEW_MERGE_BB. It is used to place loop-closed-ssa-form exit-phis.\n-\n-   ===> The CFG before the guard-code was added:\n-        LOOP_header_bb:\n-          loop_body\n-          if (exit_loop) goto update_bb\n-          else           goto LOOP_header_bb\n-        update_bb:\n-\n-   ==> The CFG after the guard-code was added:\n-        guard_bb:\n-          if (LOOP_guard_condition) goto new_merge_bb\n-          else                      goto LOOP_header_bb\n-        LOOP_header_bb:\n-          loop_body\n-          if (exit_loop_condition) goto new_merge_bb\n-          else                     goto LOOP_header_bb\n-        new_merge_bb:\n-          goto update_bb\n-        update_bb:\n-\n-   ==> The CFG after this function:\n-        guard_bb:\n-          if (LOOP_guard_condition) goto new_merge_bb\n-          else                      goto LOOP_header_bb\n-        LOOP_header_bb:\n-          loop_body\n-          if (exit_loop_condition) goto new_exit_bb\n-          else                     goto LOOP_header_bb\n-        new_exit_bb:\n-        new_merge_bb:\n-          goto update_bb\n-        update_bb:\n-\n-   This function:\n-   1. creates and updates the relevant phi nodes to account for the new\n-      incoming edge (GUARD_EDGE) into NEW_MERGE_BB. This involves:\n-      1.1. Create phi nodes at NEW_MERGE_BB.\n-      1.2. Update the phi nodes at the successor of NEW_MERGE_BB (denoted\n-           UPDATE_BB).  UPDATE_BB was the exit-bb of LOOP before NEW_MERGE_BB\n-   2. preserves loop-closed-ssa-form by creating the required phi nodes\n-      at the exit of LOOP (i.e, in NEW_EXIT_BB).\n-\n-   There are two flavors to this function:\n-\n-   slpeel_update_phi_nodes_for_guard1:\n-     Here the guard controls whether we enter or skip LOOP, where LOOP is a\n-     prolog_loop (loop1 below), and the new phis created in NEW_MERGE_BB are\n-     for variables that have phis in the loop header.\n-\n-   slpeel_update_phi_nodes_for_guard2:\n-     Here the guard controls whether we enter or skip LOOP, where LOOP is an\n-     epilog_loop (loop2 below), and the new phis created in NEW_MERGE_BB are\n-     for variables that have phis in the loop exit.\n-\n-   I.E., the overall structure is:\n-\n-        loop1_preheader_bb:\n-                guard1 (goto loop1/merge1_bb)\n-        loop1\n-        loop1_exit_bb:\n-                guard2 (goto merge1_bb/merge2_bb)\n-        merge1_bb\n-        loop2\n-        loop2_exit_bb\n-        merge2_bb\n-        next_bb\n-\n-   slpeel_update_phi_nodes_for_guard1 takes care of creating phis in\n-   loop1_exit_bb and merge1_bb. These are entry phis (phis for the vars\n-   that have phis in loop1->header).\n-\n-   slpeel_update_phi_nodes_for_guard2 takes care of creating phis in\n-   loop2_exit_bb and merge2_bb. These are exit phis (phis for the vars\n-   that have phis in next_bb). It also adds some of these phis to\n-   loop1_exit_bb.\n-\n-   slpeel_update_phi_nodes_for_guard1 is always called before\n-   slpeel_update_phi_nodes_for_guard2. They are both needed in order\n-   to create correct data-flow and loop-closed-ssa-form.\n-\n-   Generally slpeel_update_phi_nodes_for_guard1 creates phis for variables\n-   that change between iterations of a loop (and therefore have a phi-node\n-   at the loop entry), whereas slpeel_update_phi_nodes_for_guard2 creates\n-   phis for variables that are used out of the loop (and therefore have\n-   loop-closed exit phis). Some variables may be both updated between\n-   iterations and used after the loop. This is why in loop1_exit_bb we\n-   may need both entry_phis (created by slpeel_update_phi_nodes_for_guard1)\n-   and exit phis (created by slpeel_update_phi_nodes_for_guard2).\n-\n-   - IS_NEW_LOOP: if IS_NEW_LOOP is true, then LOOP is a newly created copy of\n-     an original loop. i.e., we have:\n-\n-           orig_loop\n-           guard_bb (goto LOOP/new_merge)\n-           new_loop <-- LOOP\n-           new_exit\n-           new_merge\n-           next_bb\n-\n-     If IS_NEW_LOOP is false, then LOOP is an original loop, in which case we\n-     have:\n-\n-           new_loop\n-           guard_bb (goto LOOP/new_merge)\n-           orig_loop <-- LOOP\n-           new_exit\n-           new_merge\n-           next_bb\n-\n-     The SSA names defined in the original loop have a current\n-     reaching definition that records the corresponding new ssa-name\n-     used in the new duplicated loop copy.\n-  */\n-\n-/* Function slpeel_update_phi_nodes_for_guard1\n-\n-   Input:\n-   - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.\n-   - DEFS - a bitmap of ssa names to mark new names for which we recorded\n-            information.\n-\n-   In the context of the overall structure, we have:\n-\n-        loop1_preheader_bb:\n-                guard1 (goto loop1/merge1_bb)\n-LOOP->  loop1\n-        loop1_exit_bb:\n-                guard2 (goto merge1_bb/merge2_bb)\n-        merge1_bb\n-        loop2\n-        loop2_exit_bb\n-        merge2_bb\n-        next_bb\n-\n-   For each name updated between loop iterations (i.e - for each name that has\n-   an entry (loop-header) phi in LOOP) we create a new phi in:\n-   1. merge1_bb (to account for the edge from guard1)\n-   2. loop1_exit_bb (an exit-phi to keep LOOP in loop-closed form)\n-*/\n-\n-static void\n-slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n-                                    bool is_new_loop, basic_block *new_exit_bb)\n-{\n-  gphi *orig_phi, *new_phi;\n-  gphi *update_phi, *update_phi2;\n-  tree guard_arg, loop_arg;\n-  basic_block new_merge_bb = guard_edge->dest;\n-  edge e = EDGE_SUCC (new_merge_bb, 0);\n-  basic_block update_bb = e->dest;\n-  basic_block orig_bb = loop->header;\n-  edge new_exit_e;\n-  tree current_new_name;\n-  gphi_iterator gsi_orig, gsi_update;\n-\n-  /* Create new bb between loop and new_merge_bb.  */\n-  *new_exit_bb = split_edge (single_exit (loop));\n-\n-  new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n-\n-  for (gsi_orig = gsi_start_phis (orig_bb),\n-       gsi_update = gsi_start_phis (update_bb);\n-       !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_update);\n-       gsi_next (&gsi_orig), gsi_next (&gsi_update))\n-    {\n-      source_location loop_locus, guard_locus;\n-      tree new_res;\n-      orig_phi = gsi_orig.phi ();\n-      update_phi = gsi_update.phi ();\n-\n-      /** 1. Handle new-merge-point phis  **/\n-\n-      /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-      new_phi = create_phi_node (new_res, new_merge_bb);\n-\n-      /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n-            of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n-      loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, EDGE_SUCC (loop->latch, 0));\n-      loop_locus = gimple_phi_arg_location_from_edge (orig_phi,\n-\t\t\t\t\t\t      EDGE_SUCC (loop->latch,\n-\t\t\t\t\t\t\t\t 0));\n-      guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, loop_preheader_edge (loop));\n-      guard_locus\n-\t= gimple_phi_arg_location_from_edge (orig_phi,\n-\t\t\t\t\t     loop_preheader_edge (loop));\n-\n-      add_phi_arg (new_phi, loop_arg, new_exit_e, loop_locus);\n-      add_phi_arg (new_phi, guard_arg, guard_edge, guard_locus);\n-\n-      /* 1.3. Update phi in successor block.  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n-                  || PHI_ARG_DEF_FROM_EDGE (update_phi, e) == guard_arg);\n-      adjust_phi_and_debug_stmts (update_phi, e, PHI_RESULT (new_phi));\n-      update_phi2 = new_phi;\n-\n-\n-      /** 2. Handle loop-closed-ssa-form phis  **/\n-\n-      if (virtual_operand_p (PHI_RESULT (orig_phi)))\n-\tcontinue;\n-\n-      /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-      new_phi = create_phi_node (new_res, *new_exit_bb);\n-\n-      /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, single_exit (loop), loop_locus);\n-\n-      /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n-      adjust_phi_and_debug_stmts (update_phi2, new_exit_e,\n-\t\t\t\t  PHI_RESULT (new_phi));\n-\n-      /* 2.4. Record the newly created name with set_current_def.\n-         We want to find a name such that\n-                name = get_current_def (orig_loop_name)\n-         and to set its current definition as follows:\n-                set_current_def (name, new_phi_name)\n-\n-         If LOOP is a new loop then loop_arg is already the name we're\n-         looking for. If LOOP is the original loop, then loop_arg is\n-         the orig_loop_name and the relevant name is recorded in its\n-         current reaching definition.  */\n-      if (is_new_loop)\n-        current_new_name = loop_arg;\n-      else\n-        {\n-          current_new_name = get_current_def (loop_arg);\n-\t  /* current_def is not available only if the variable does not\n-\t     change inside the loop, in which case we also don't care\n-\t     about recording a current_def for it because we won't be\n-\t     trying to create loop-exit-phis for it.  */\n-\t  if (!current_new_name)\n-\t    continue;\n-        }\n-      tree new_name = get_current_def (current_new_name);\n-      /* Because of peeled_chrec optimization it is possible that we have\n-\t set this earlier.  Verify the PHI has the same value.  */\n-      if (new_name)\n-\t{\n-\t  gimple *phi = SSA_NAME_DEF_STMT (new_name);\n-\t  gcc_assert (gimple_code (phi) == GIMPLE_PHI\n-\t\t      && gimple_bb (phi) == *new_exit_bb\n-\t\t      && (PHI_ARG_DEF_FROM_EDGE (phi, single_exit (loop))\n-\t\t\t  == loop_arg));\n-\t  continue;\n-\t}\n-\n-      set_current_def (current_new_name, PHI_RESULT (new_phi));\n-    }\n-}\n-\n-\n-/* Function slpeel_update_phi_nodes_for_guard2\n-\n-   Input:\n-   - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.\n-\n-   In the context of the overall structure, we have:\n-\n-        loop1_preheader_bb:\n-                guard1 (goto loop1/merge1_bb)\n-        loop1\n-        loop1_exit_bb:\n-                guard2 (goto merge1_bb/merge2_bb)\n-        merge1_bb\n-LOOP->  loop2\n-        loop2_exit_bb\n-        merge2_bb\n-        next_bb\n-\n-   For each name used out side the loop (i.e - for each name that has an exit\n-   phi in next_bb) we create a new phi in:\n-   1. merge2_bb (to account for the edge from guard_bb)\n-   2. loop2_exit_bb (an exit-phi to keep LOOP in loop-closed form)\n-   3. guard2 bb (an exit phi to keep the preceding loop in loop-closed form),\n-      if needed (if it wasn't handled by slpeel_update_phis_nodes_for_phi1).\n-*/\n-\n-static void\n-slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n-                                    bool is_new_loop, basic_block *new_exit_bb)\n-{\n-  gphi *orig_phi, *new_phi;\n-  gphi *update_phi, *update_phi2;\n-  tree guard_arg, loop_arg;\n-  basic_block new_merge_bb = guard_edge->dest;\n-  edge e = EDGE_SUCC (new_merge_bb, 0);\n-  basic_block update_bb = e->dest;\n-  edge new_exit_e;\n-  tree orig_def, orig_def_new_name;\n-  tree new_name, new_name2;\n-  tree arg;\n-  gphi_iterator gsi;\n-\n-  /* Create new bb between loop and new_merge_bb.  */\n-  *new_exit_bb = split_edge (single_exit (loop));\n-\n-  new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n-\n-  for (gsi = gsi_start_phis (update_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      tree new_res;\n-      update_phi = gsi.phi ();\n-      orig_phi = update_phi;\n-      orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-      /* This loop-closed-phi actually doesn't represent a use\n-         out of the loop - the phi arg is a constant.  */\n-      if (TREE_CODE (orig_def) != SSA_NAME)\n-        continue;\n-      orig_def_new_name = get_current_def (orig_def);\n-      arg = NULL_TREE;\n-\n-      /** 1. Handle new-merge-point phis  **/\n-\n-      /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-      new_phi = create_phi_node (new_res, new_merge_bb);\n-\n-      /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n-            of LOOP. Set the two PHI args in NEW_PHI for these edges:  */\n-      new_name = orig_def;\n-      new_name2 = NULL_TREE;\n-      if (orig_def_new_name)\n-        {\n-          new_name = orig_def_new_name;\n-\t  /* Some variables have both loop-entry-phis and loop-exit-phis.\n-\t     Such variables were given yet newer names by phis placed in\n-\t     guard_bb by slpeel_update_phi_nodes_for_guard1. I.e:\n-\t     new_name2 = get_current_def (get_current_def (orig_name)).  */\n-          new_name2 = get_current_def (new_name);\n-        }\n-\n-      if (is_new_loop)\n-        {\n-          guard_arg = orig_def;\n-          loop_arg = new_name;\n-        }\n-      else\n-        {\n-          guard_arg = new_name;\n-          loop_arg = orig_def;\n-        }\n-      if (new_name2)\n-        guard_arg = new_name2;\n-\n-      add_phi_arg (new_phi, loop_arg, new_exit_e, UNKNOWN_LOCATION);\n-      add_phi_arg (new_phi, guard_arg, guard_edge, UNKNOWN_LOCATION);\n-\n-      /* 1.3. Update phi in successor block.  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == orig_def);\n-      adjust_phi_and_debug_stmts (update_phi, e, PHI_RESULT (new_phi));\n-      update_phi2 = new_phi;\n-\n-\n-      /** 2. Handle loop-closed-ssa-form phis  **/\n-\n-      if (virtual_operand_p (PHI_RESULT (orig_phi)))\n-\tcontinue;\n-\n-      /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-      new_phi = create_phi_node (new_res, *new_exit_bb);\n-\n-      /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, single_exit (loop), UNKNOWN_LOCATION);\n-\n-      /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n-      adjust_phi_and_debug_stmts (update_phi2, new_exit_e,\n-\t\t\t\t  PHI_RESULT (new_phi));\n-\n-\n-      /** 3. Handle loop-closed-ssa-form phis for first loop  **/\n-\n-      /* 3.1. Find the relevant names that need an exit-phi in\n-\t GUARD_BB, i.e. names for which\n-\t slpeel_update_phi_nodes_for_guard1 had not already created a\n-\t phi node. This is the case for names that are used outside\n-\t the loop (and therefore need an exit phi) but are not updated\n-\t across loop iterations (and therefore don't have a\n-\t loop-header-phi).\n-\n-\t slpeel_update_phi_nodes_for_guard1 is responsible for\n-\t creating loop-exit phis in GUARD_BB for names that have a\n-\t loop-header-phi.  When such a phi is created we also record\n-\t the new name in its current definition.  If this new name\n-\t exists, then guard_arg was set to this new name (see 1.2\n-\t above).  Therefore, if guard_arg is not this new name, this\n-\t is an indication that an exit-phi in GUARD_BB was not yet\n-\t created, so we take care of it here.  */\n-      if (guard_arg == new_name2)\n-\tcontinue;\n-      arg = guard_arg;\n-\n-      /* 3.2. Generate new phi node in GUARD_BB:  */\n-      new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n-      new_phi = create_phi_node (new_res, guard_edge->src);\n-\n-      /* 3.3. GUARD_BB has one incoming edge:  */\n-      gcc_assert (EDGE_COUNT (guard_edge->src->preds) == 1);\n-      add_phi_arg (new_phi, arg, EDGE_PRED (guard_edge->src, 0),\n-\t\t   UNKNOWN_LOCATION);\n-\n-      /* 3.4. Update phi in successor of GUARD_BB:  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, guard_edge)\n-                                                                == guard_arg);\n-      adjust_phi_and_debug_stmts (update_phi2, guard_edge,\n-\t\t\t\t  PHI_RESULT (new_phi));\n-    }\n-}\n-\n-\n /* Make the LOOP iterate NITERS times. This is done by adding a new IV\n    that starts at zero, increases by one and its limit is NITERS.\n \n@@ -942,15 +512,14 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop,\n }\n \n \n-/* Given the condition statement COND, put it as the last statement\n-   of GUARD_BB; EXIT_BB is the basic block to skip the loop;\n-   Assumes that this is the single exit of the guarded loop.\n-   Returns the skip edge, inserts new stmts on the COND_EXPR_STMT_LIST.  */\n+/* Given the condition expression COND, put it as the last statement of\n+   GUARD_BB; set both edges' probability; set dominator of GUARD_TO to\n+   DOM_BB; return the skip edge.  GUARD_TO is the target basic block to\n+   skip the loop.  PROBABILITY is the skip edge's probability.  */\n \n static edge\n slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n-\t\t       gimple_seq cond_expr_stmt_list,\n-\t\t       basic_block exit_bb, basic_block dom_bb,\n+\t\t       basic_block guard_to, basic_block dom_bb,\n \t\t       int probability)\n {\n   gimple_stmt_iterator gsi;\n@@ -966,23 +535,21 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n   cond = force_gimple_operand_1 (cond, &gimplify_stmt_list, is_gimple_condexpr,\n \t\t\t\t NULL_TREE);\n   if (gimplify_stmt_list)\n-    gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n-  cond_stmt = gimple_build_cond_from_tree (cond, NULL_TREE, NULL_TREE);\n-  if (cond_expr_stmt_list)\n-    gsi_insert_seq_after (&gsi, cond_expr_stmt_list, GSI_NEW_STMT);\n+    gsi_insert_seq_after (&gsi, gimplify_stmt_list, GSI_NEW_STMT);\n \n+  cond_stmt = gimple_build_cond_from_tree (cond, NULL_TREE, NULL_TREE);\n   gsi = gsi_last_bb (guard_bb);\n   gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n \n   /* Add new edge to connect guard block to the merge/loop-exit block.  */\n-  new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n+  new_e = make_edge (guard_bb, guard_to, EDGE_TRUE_VALUE);\n \n   new_e->count = guard_bb->count;\n   new_e->probability = probability;\n   new_e->count = apply_probability (enter_e->count, probability);\n   enter_e->count -= new_e->count;\n   enter_e->probability = inverse_probability (probability);\n-  set_immediate_dominator (CDI_DOMINATORS, exit_bb, dom_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, guard_to, dom_bb);\n   return new_e;\n }\n \n@@ -1018,217 +585,19 @@ slpeel_can_duplicate_loop_p (const struct loop *loop, const_edge e)\n   return true;\n }\n \n-static void\n-slpeel_checking_verify_cfg_after_peeling (struct loop *first_loop,\n-\t\t\t\t\t  struct loop *second_loop)\n-{\n-  if (!flag_checking)\n-    return;\n-\n-  basic_block loop1_exit_bb = single_exit (first_loop)->dest;\n-  basic_block loop2_entry_bb = loop_preheader_edge (second_loop)->src;\n-  basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n-\n-  /* A guard that controls whether the second_loop is to be executed or skipped\n-     is placed in first_loop->exit.  first_loop->exit therefore has two\n-     successors - one is the preheader of second_loop, and the other is a bb\n-     after second_loop.\n-   */\n-  gcc_assert (EDGE_COUNT (loop1_exit_bb->succs) == 2);\n-\n-  /* 1. Verify that one of the successors of first_loop->exit is the preheader\n-        of second_loop.  */\n-\n-  /* The preheader of new_loop is expected to have two predecessors:\n-     first_loop->exit and the block that precedes first_loop.  */\n-\n-  gcc_assert (EDGE_COUNT (loop2_entry_bb->preds) == 2\n-              && ((EDGE_PRED (loop2_entry_bb, 0)->src == loop1_exit_bb\n-                   && EDGE_PRED (loop2_entry_bb, 1)->src == loop1_entry_bb)\n-               || (EDGE_PRED (loop2_entry_bb, 1)->src ==  loop1_exit_bb\n-                   && EDGE_PRED (loop2_entry_bb, 0)->src == loop1_entry_bb)));\n-\n-  /* Verify that the other successor of first_loop->exit is after the\n-     second_loop.  */\n-  /* TODO */\n-}\n-\n-/* If the run time cost model check determines that vectorization is\n-   not profitable and hence scalar loop should be generated then set\n-   FIRST_NITERS to prologue peeled iterations. This will allow all the\n-   iterations to be executed in the prologue peeled scalar loop.  */\n+/* If the loop has a virtual PHI, but exit bb doesn't, create a virtual PHI\n+   in the exit bb and rename all the uses after the loop.  This simplifies\n+   the *guard[12] routines, which assume loop closed SSA form for all PHIs\n+   (but normally loop closed SSA form doesn't require virtual PHIs to be\n+   in the same form).  Doing this early simplifies the checking what\n+   uses should be renamed.  */\n \n static void\n-set_prologue_iterations (basic_block bb_before_first_loop,\n-\t\t\t tree *first_niters,\n-\t\t\t struct loop *loop,\n-\t\t\t unsigned int th,\n-\t\t\t int probability)\n+create_lcssa_for_virtual_phi (struct loop *loop)\n {\n-  edge e;\n-  basic_block cond_bb, then_bb;\n-  tree var, prologue_after_cost_adjust_name;\n-  gimple_stmt_iterator gsi;\n-  gphi *newphi;\n-  edge e_true, e_false, e_fallthru;\n-  gcond *cond_stmt;\n-  gimple_seq stmts = NULL;\n-  tree cost_pre_condition = NULL_TREE;\n-  tree scalar_loop_iters =\n-    unshare_expr (LOOP_VINFO_NITERS_UNCHANGED (loop_vec_info_for_loop (loop)));\n-\n-  e = single_pred_edge (bb_before_first_loop);\n-  cond_bb = split_edge (e);\n-\n-  e = single_pred_edge (bb_before_first_loop);\n-  then_bb = split_edge (e);\n-  set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n-\n-  e_false = make_single_succ_edge (cond_bb, bb_before_first_loop,\n-\t\t\t\t   EDGE_FALSE_VALUE);\n-  set_immediate_dominator (CDI_DOMINATORS, bb_before_first_loop, cond_bb);\n-\n-  e_true = EDGE_PRED (then_bb, 0);\n-  e_true->flags &= ~EDGE_FALLTHRU;\n-  e_true->flags |= EDGE_TRUE_VALUE;\n-\n-  e_true->probability = probability;\n-  e_false->probability = inverse_probability (probability);\n-  e_true->count = apply_probability (cond_bb->count, probability);\n-  e_false->count = cond_bb->count - e_true->count;\n-  then_bb->frequency = EDGE_FREQUENCY (e_true);\n-  then_bb->count = e_true->count;\n-\n-  e_fallthru = EDGE_SUCC (then_bb, 0);\n-  e_fallthru->count = then_bb->count;\n-\n-  gsi = gsi_last_bb (cond_bb);\n-  cost_pre_condition =\n-    fold_build2 (LE_EXPR, boolean_type_node, scalar_loop_iters,\n-\t         build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n-  cost_pre_condition =\n-    force_gimple_operand_gsi_1 (&gsi, cost_pre_condition, is_gimple_condexpr,\n-\t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n-  cond_stmt = gimple_build_cond_from_tree (cost_pre_condition,\n-\t\t\t\t\t   NULL_TREE, NULL_TREE);\n-  gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n-\n-  var = create_tmp_var (TREE_TYPE (scalar_loop_iters),\n-\t\t\t\"prologue_after_cost_adjust\");\n-  prologue_after_cost_adjust_name =\n-    force_gimple_operand (scalar_loop_iters, &stmts, false, var);\n-\n-  gsi = gsi_last_bb (then_bb);\n-  if (stmts)\n-    gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n-\n-  newphi = create_phi_node (var, bb_before_first_loop);\n-  add_phi_arg (newphi, prologue_after_cost_adjust_name, e_fallthru,\n-\t       UNKNOWN_LOCATION);\n-  add_phi_arg (newphi, *first_niters, e_false, UNKNOWN_LOCATION);\n-\n-  *first_niters = PHI_RESULT (newphi);\n-}\n-\n-/* Function slpeel_tree_peel_loop_to_edge.\n-\n-   Peel the first (last) iterations of LOOP into a new prolog (epilog) loop\n-   that is placed on the entry (exit) edge E of LOOP. After this transformation\n-   we have two loops one after the other - first-loop iterates FIRST_NITERS\n-   times, and second-loop iterates the remainder NITERS - FIRST_NITERS times.\n-   If the cost model indicates that it is profitable to emit a scalar\n-   loop instead of the vector one, then the prolog (epilog) loop will iterate\n-   for the entire unchanged scalar iterations of the loop.\n-\n-   Input:\n-   - LOOP: the loop to be peeled.\n-   - SCALAR_LOOP: if non-NULL, the alternate loop from which basic blocks\n-\tshould be copied.\n-   - E: the exit or entry edge of LOOP.\n-        If it is the entry edge, we peel the first iterations of LOOP. In this\n-        case first-loop is LOOP, and second-loop is the newly created loop.\n-        If it is the exit edge, we peel the last iterations of LOOP. In this\n-        case, first-loop is the newly created loop, and second-loop is LOOP.\n-   - NITERS: the number of iterations that LOOP iterates.\n-   - FIRST_NITERS: the number of iterations that the first-loop should iterate.\n-   - UPDATE_FIRST_LOOP_COUNT:  specified whether this function is responsible\n-        for updating the loop bound of the first-loop to FIRST_NITERS.  If it\n-        is false, the caller of this function may want to take care of this\n-        (this can be useful if we don't want new stmts added to first-loop).\n-   - TH: cost model profitability threshold of iterations for vectorization.\n-   - CHECK_PROFITABILITY: specify whether cost model check has not occurred\n-                          during versioning and hence needs to occur during\n-\t\t\t  prologue generation or whether cost model check\n-\t\t\t  has not occurred during prologue generation and hence\n-\t\t\t  needs to occur during epilogue generation.\n-   - BOUND1 is the upper bound on number of iterations of the first loop (if known)\n-   - BOUND2 is the upper bound on number of iterations of the second loop (if known)\n-\n-\n-   Output:\n-   The function returns a pointer to the new loop-copy, or NULL if it failed\n-   to perform the transformation.\n-\n-   The function generates two if-then-else guards: one before the first loop,\n-   and the other before the second loop:\n-   The first guard is:\n-     if (FIRST_NITERS == 0) then skip the first loop,\n-     and go directly to the second loop.\n-   The second guard is:\n-     if (FIRST_NITERS == NITERS) then skip the second loop.\n-\n-   If the optional COND_EXPR and COND_EXPR_STMT_LIST arguments are given\n-   then the generated condition is combined with COND_EXPR and the\n-   statements in COND_EXPR_STMT_LIST are emitted together with it.\n-\n-   FORNOW only simple loops are supported (see slpeel_can_duplicate_loop_p).\n-   FORNOW the resulting code will not be in loop-closed-ssa form.\n-*/\n-\n-static struct loop *\n-slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n-\t\t\t       edge e, tree *first_niters,\n-\t\t\t       tree niters, bool update_first_loop_count,\n-\t\t\t       unsigned int th, bool check_profitability,\n-\t\t\t       tree cond_expr, gimple_seq cond_expr_stmt_list,\n-\t\t\t       int bound1, int bound2)\n-{\n-  struct loop *new_loop = NULL, *first_loop, *second_loop;\n-  edge skip_e;\n-  tree pre_condition = NULL_TREE;\n-  basic_block bb_before_second_loop, bb_after_second_loop;\n-  basic_block bb_before_first_loop;\n-  basic_block bb_between_loops;\n-  basic_block new_exit_bb;\n   gphi_iterator gsi;\n   edge exit_e = single_exit (loop);\n-  source_location loop_loc;\n-  /* There are many aspects to how likely the first loop is going to be executed.\n-     Without histogram we can't really do good job.  Simply set it to\n-     2/3, so the first loop is not reordered to the end of function and\n-     the hot path through stays short.  */\n-  int first_guard_probability = 2 * REG_BR_PROB_BASE / 3;\n-  int second_guard_probability = 2 * REG_BR_PROB_BASE / 3;\n-  int probability_of_second_loop;\n-\n-  if (!slpeel_can_duplicate_loop_p (loop, e))\n-    return NULL;\n \n-  /* We might have a queued need to update virtual SSA form.  As we\n-     delete the update SSA machinery below after doing a regular\n-     incremental SSA update during loop copying make sure we don't\n-     lose that fact.\n-     ???  Needing to update virtual SSA form by renaming is unfortunate\n-     but not all of the vectorizer code inserting new loads / stores\n-     properly assigns virtual operands to those statements.  */\n-  update_ssa (TODO_update_ssa_only_virtuals);\n- \n-  /* If the loop has a virtual PHI, but exit bb doesn't, create a virtual PHI\n-     in the exit bb and rename all the uses after the loop.  This simplifies\n-     the *guard[12] routines, which assume loop closed SSA form for all PHIs\n-     (but normally loop closed SSA form doesn't require virtual PHIs to be\n-     in the same form).  Doing this early simplifies the checking what\n-     uses should be renamed.  */\n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n     if (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n       {\n@@ -1257,247 +626,6 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loop *scalar_loop,\n \tbreak;\n       }\n \n-  /* 1. Generate a copy of LOOP and put it on E (E is the entry/exit of LOOP).\n-        Resulting CFG would be:\n-\n-        first_loop:\n-        do {\n-        } while ...\n-\n-        second_loop:\n-        do {\n-        } while ...\n-\n-        orig_exit_bb:\n-   */\n-\n-  if (!(new_loop = slpeel_tree_duplicate_loop_to_edge_cfg (loop, scalar_loop,\n-\t\t\t\t\t\t\t   e)))\n-    {\n-      loop_loc = find_loop_location (loop);\n-      dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n-                       \"tree_duplicate_loop_to_edge_cfg failed.\\n\");\n-      return NULL;\n-    }\n-\n-  if (MAY_HAVE_DEBUG_STMTS)\n-    {\n-      gcc_assert (!adjust_vec.exists ());\n-      adjust_vec.create (32);\n-    }\n-\n-  if (e == exit_e)\n-    {\n-      /* NEW_LOOP was placed after LOOP.  */\n-      first_loop = loop;\n-      second_loop = new_loop;\n-    }\n-  else\n-    {\n-      /* NEW_LOOP was placed before LOOP.  */\n-      first_loop = new_loop;\n-      second_loop = loop;\n-    }\n-\n-  /* 2.  Add the guard code in one of the following ways:\n-\n-     2.a Add the guard that controls whether the first loop is executed.\n-         This occurs when this function is invoked for prologue or epilogue\n-\t generation and when the cost model check can be done at compile time.\n-\n-         Resulting CFG would be:\n-\n-         bb_before_first_loop:\n-         if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n-                                GOTO first-loop\n-\n-         first_loop:\n-         do {\n-         } while ...\n-\n-         bb_before_second_loop:\n-\n-         second_loop:\n-         do {\n-         } while ...\n-\n-         orig_exit_bb:\n-\n-     2.b Add the cost model check that allows the prologue\n-         to iterate for the entire unchanged scalar\n-         iterations of the loop in the event that the cost\n-         model indicates that the scalar loop is more\n-         profitable than the vector one. This occurs when\n-\t this function is invoked for prologue generation\n-\t and the cost model check needs to be done at run\n-\t time.\n-\n-         Resulting CFG after prologue peeling would be:\n-\n-         if (scalar_loop_iterations <= th)\n-           FIRST_NITERS = scalar_loop_iterations\n-\n-         bb_before_first_loop:\n-         if (FIRST_NITERS == 0) GOTO bb_before_second_loop\n-                                GOTO first-loop\n-\n-         first_loop:\n-         do {\n-         } while ...\n-\n-         bb_before_second_loop:\n-\n-         second_loop:\n-         do {\n-         } while ...\n-\n-         orig_exit_bb:\n-\n-     2.c Add the cost model check that allows the epilogue\n-         to iterate for the entire unchanged scalar\n-         iterations of the loop in the event that the cost\n-         model indicates that the scalar loop is more\n-         profitable than the vector one. This occurs when\n-\t this function is invoked for epilogue generation\n-\t and the cost model check needs to be done at run\n-\t time.  This check is combined with any pre-existing\n-\t check in COND_EXPR to avoid versioning.\n-\n-         Resulting CFG after prologue peeling would be:\n-\n-         bb_before_first_loop:\n-         if ((scalar_loop_iterations <= th)\n-             ||\n-             FIRST_NITERS == 0) GOTO bb_before_second_loop\n-                                GOTO first-loop\n-\n-         first_loop:\n-         do {\n-         } while ...\n-\n-         bb_before_second_loop:\n-\n-         second_loop:\n-         do {\n-         } while ...\n-\n-         orig_exit_bb:\n-  */\n-\n-  bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n-  /* Loop copying insterted a forwarder block for us here.  */\n-  bb_before_second_loop = single_exit (first_loop)->dest;\n-\n-  probability_of_second_loop = (inverse_probability (first_guard_probability)\n-\t\t\t        + combine_probabilities (second_guard_probability,\n-                                                         first_guard_probability));\n-  /* Theoretically preheader edge of first loop and exit edge should have\n-     same frequencies.  Loop exit probablities are however easy to get wrong.\n-     It is safer to copy value from original loop entry.  */\n-  bb_before_second_loop->frequency\n-     = combine_probabilities (bb_before_first_loop->frequency,\n-                              probability_of_second_loop);\n-  bb_before_second_loop->count\n-     = apply_probability (bb_before_first_loop->count,\n-\t\t\t  probability_of_second_loop);\n-  single_succ_edge (bb_before_second_loop)->count\n-     = bb_before_second_loop->count;\n-\n-  /* Epilogue peeling.  */\n-  if (!update_first_loop_count)\n-    {\n-      loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n-      tree scalar_loop_iters = LOOP_VINFO_NITERSM1 (loop_vinfo);\n-      unsigned limit = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1;\n-      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-\tlimit = limit + 1;\n-      if (check_profitability\n-\t  && th > limit)\n-\tlimit = th;\n-      pre_condition =\n-\tfold_build2 (LT_EXPR, boolean_type_node, scalar_loop_iters,\n-\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters), limit));\n-      if (cond_expr)\n-\t{\n-\t  pre_condition =\n-\t    fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t pre_condition,\n-\t\t\t fold_build1 (TRUTH_NOT_EXPR, boolean_type_node,\n-\t\t\t\t      cond_expr));\n-\t}\n-    }\n-\n-  /* Prologue peeling.  */\n-  else\n-    {\n-      if (check_profitability)\n-\tset_prologue_iterations (bb_before_first_loop, first_niters,\n-\t\t\t\t loop, th, first_guard_probability);\n-\n-      pre_condition =\n-\tfold_build2 (LE_EXPR, boolean_type_node, *first_niters,\n-\t\t     build_int_cst (TREE_TYPE (*first_niters), 0));\n-    }\n-\n-  skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n-\t\t\t\t  cond_expr_stmt_list,\n-                                  bb_before_second_loop, bb_before_first_loop,\n-\t\t\t\t  inverse_probability (first_guard_probability));\n-  scale_loop_profile (first_loop, first_guard_probability,\n-\t\t      check_profitability && (int)th > bound1 ? th : bound1);\n-  slpeel_update_phi_nodes_for_guard1 (skip_e, first_loop,\n-\t\t\t\t      first_loop == new_loop,\n-\t\t\t\t      &new_exit_bb);\n-\n-\n-  /* 3. Add the guard that controls whether the second loop is executed.\n-        Resulting CFG would be:\n-\n-        bb_before_first_loop:\n-        if (FIRST_NITERS == 0) GOTO bb_before_second_loop (skip first loop)\n-                               GOTO first-loop\n-\n-        first_loop:\n-        do {\n-        } while ...\n-\n-        bb_between_loops:\n-        if (FIRST_NITERS == NITERS) GOTO bb_after_second_loop (skip second loop)\n-                                    GOTO bb_before_second_loop\n-\n-        bb_before_second_loop:\n-\n-        second_loop:\n-        do {\n-        } while ...\n-\n-        bb_after_second_loop:\n-\n-        orig_exit_bb:\n-   */\n-\n-  bb_between_loops = new_exit_bb;\n-  bb_after_second_loop = split_edge (single_exit (second_loop));\n-\n-  pre_condition =\n-\tfold_build2 (EQ_EXPR, boolean_type_node, *first_niters, niters);\n-  skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition, NULL,\n-                                  bb_after_second_loop, bb_before_first_loop,\n-\t\t\t\t  inverse_probability (second_guard_probability));\n-  scale_loop_profile (second_loop, probability_of_second_loop, bound2);\n-  slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,\n-                                     second_loop == new_loop, &new_exit_bb);\n-\n-  /* 4. Make first-loop iterate FIRST_NITERS times, if requested.\n-   */\n-  if (update_first_loop_count)\n-    slpeel_make_loop_iterate_ntimes (first_loop, *first_niters);\n-\n-  delete_update_ssa ();\n-\n-  adjust_vec_debug_stmts ();\n-\n-  return new_loop;\n }\n \n /* Function vect_get_loop_location.\n@@ -1541,6 +669,22 @@ find_loop_location (struct loop *loop)\n   return UNKNOWN_LOCATION;\n }\n \n+/* Return true if PHI defines an IV of the loop to be vectorized.  */\n+\n+static bool\n+iv_phi_p (gphi *phi)\n+{\n+  if (virtual_operand_p (PHI_RESULT (phi)))\n+    return false;\n+\n+  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n+  gcc_assert (stmt_info != NULL);\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+      || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n+    return false;\n+\n+  return true;\n+}\n \n /* Function vect_can_advance_ivs_p\n \n@@ -1556,7 +700,6 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block bb = loop->header;\n-  gimple *phi;\n   gphi_iterator gsi;\n \n   /* Analyze phi functions of the loop header.  */\n@@ -1567,34 +710,25 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n     {\n       tree evolution_part;\n \n-      phi = gsi.phi ();\n+      gphi *phi = gsi.phi ();\n       if (dump_enabled_p ())\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n-         virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */\n+\t virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.\n \n-      if (virtual_operand_p (PHI_RESULT (phi)))\n+\t Skip reduction phis.  */\n+      if (!iv_phi_p (phi))\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"virtual phi. skip.\\n\");\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"reduc or virtual phi. skip.\\n\");\n \t  continue;\n \t}\n \n-      /* Skip reduction phis.  */\n-\n-      if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n-        {\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"reduc phi. skip.\\n\");\n-          continue;\n-        }\n-\n       /* Analyze the evolution function.  */\n \n       evolution_part\n@@ -1676,19 +810,17 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n  */\n \n static void\n-vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n-\t\t\t\t  edge update_e)\n+vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n+\t\t\t\t  tree niters, edge update_e)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block exit_bb = single_exit (loop)->dest;\n-  gphi *phi, *phi1;\n   gphi_iterator gsi, gsi1;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block update_bb = update_e->dest;\n-\n-  gcc_checking_assert (vect_can_advance_ivs_p (loop_vinfo));\n+  basic_block exit_bb = single_exit (loop)->dest;\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n   gcc_assert (single_pred_p (exit_bb));\n+  gcc_assert (single_succ_edge (exit_bb) == update_e);\n \n   for (gsi = gsi_start_phis (loop->header), gsi1 = gsi_start_phis (update_bb);\n        !gsi_end_p (gsi) && !gsi_end_p (gsi1);\n@@ -1699,39 +831,27 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       tree type;\n       tree var, ni, ni_name;\n       gimple_stmt_iterator last_gsi;\n-      stmt_vec_info stmt_info;\n \n-      phi = gsi.phi ();\n-      phi1 = gsi1.phi ();\n+      gphi *phi = gsi.phi ();\n+      gphi *phi1 = gsi1.phi ();\n       if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"vect_update_ivs_after_vectorizer: phi: \");\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"vect_update_ivs_after_vectorizer: phi: \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n-        }\n+\t}\n \n-      /* Skip virtual phi's.  */\n-      if (virtual_operand_p (PHI_RESULT (phi)))\n+      /* Skip reduction and virtual phis.  */\n+      if (!iv_phi_p (phi))\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"virtual phi. skip.\\n\");\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"reduc or virtual phi. skip.\\n\");\n \t  continue;\n \t}\n \n-      /* Skip reduction phis.  */\n-      stmt_info = vinfo_for_stmt (phi);\n-      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n-\t  || STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n-        {\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"reduc phi. skip.\\n\");\n-          continue;\n-        }\n-\n       type = TREE_TYPE (gimple_phi_result (phi));\n-      step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info);\n+      step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (vinfo_for_stmt (phi));\n       step_expr = unshare_expr (step_expr);\n \n       /* FORNOW: We do not support IVs whose evolution function is a polynomial\n@@ -1752,118 +872,40 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       var = create_tmp_var (type, \"tmp\");\n \n       last_gsi = gsi_last_bb (exit_bb);\n-      ni_name = force_gimple_operand_gsi (&last_gsi, ni, false, var,\n-\t\t\t\t\t  true, GSI_SAME_STMT);\n+      gimple_seq new_stmts = NULL;\n+      ni_name = force_gimple_operand (ni, &new_stmts, false, var);\n+      /* Exit_bb shouldn't be empty.  */\n+      if (!gsi_end_p (last_gsi))\n+\tgsi_insert_seq_after (&last_gsi, new_stmts, GSI_SAME_STMT);\n+      else\n+\tgsi_insert_seq_before (&last_gsi, new_stmts, GSI_SAME_STMT);\n \n       /* Fix phi expressions in the successor bb.  */\n       adjust_phi_and_debug_stmts (phi1, update_e, ni_name);\n     }\n }\n \n-/* Function vect_do_peeling_for_loop_bound\n-\n-   Peel the last iterations of the loop represented by LOOP_VINFO.\n-   The peeled iterations form a new epilog loop.  Given that the loop now\n-   iterates NITERS times, the new epilog loop iterates\n-   NITERS % VECTORIZATION_FACTOR times.\n-\n-   If CHECK_PROFITABILITY is 1 then profitability check is generated\n-   using TH as a cost model profitability threshold of iterations for\n-   vectorization.\n-\n-   The original loop will later be made to iterate\n-   NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).\n-\n-   COND_EXPR and COND_EXPR_STMT_LIST are combined with a new generated\n-   test.  */\n+/* Function vect_gen_prolog_loop_niters\n \n-void\n-vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo,\n-\t\t\t\ttree ni_name, tree ratio_mult_vf_name,\n-\t\t\t\tunsigned int th, bool check_profitability)\n-{\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n-  struct loop *new_loop;\n-  edge update_e;\n-  basic_block preheader;\n-  int max_iter;\n-  tree cond_expr = NULL_TREE;\n-  gimple_seq cond_expr_stmt_list = NULL;\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_do_peeling_for_loop_bound ===\\n\");\n-\n-  initialize_original_copy_tables ();\n-\n-  new_loop\n-    = slpeel_tree_peel_loop_to_edge (loop, scalar_loop, single_exit (loop),\n-\t\t\t\t     &ratio_mult_vf_name, ni_name, false,\n-\t\t\t\t     th, check_profitability,\n-\t\t\t\t     cond_expr, cond_expr_stmt_list,\n-\t\t\t\t     0, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-  gcc_assert (new_loop);\n-  slpeel_checking_verify_cfg_after_peeling (loop, new_loop);\n-\n-  /* A guard that controls whether the new_loop is to be executed or skipped\n-     is placed in LOOP->exit.  LOOP->exit therefore has two successors - one\n-     is the preheader of NEW_LOOP, where the IVs from LOOP are used.  The other\n-     is a bb after NEW_LOOP, where these IVs are not used.  Find the edge that\n-     is on the path where the LOOP IVs are used and need to be updated.  */\n-\n-  preheader = loop_preheader_edge (new_loop)->src;\n-  if (EDGE_PRED (preheader, 0)->src == single_exit (loop)->dest)\n-    update_e = EDGE_PRED (preheader, 0);\n-  else\n-    update_e = EDGE_PRED (preheader, 1);\n-\n-  /* Update IVs of original loop as if they were advanced\n-     by ratio_mult_vf_name steps.  */\n-  vect_update_ivs_after_vectorizer (loop_vinfo, ratio_mult_vf_name, update_e);\n-\n-  /* For vectorization factor N, we need to copy last N-1 values in epilogue\n-     and this means N-2 loopback edge executions.\n-\n-     PEELING_FOR_GAPS works by subtracting last iteration and thus the epilogue\n-     will execute at least LOOP_VINFO_VECT_FACTOR times.  */\n-  max_iter = (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n-\t      ? LOOP_VINFO_VECT_FACTOR (loop_vinfo) * 2\n-\t      : LOOP_VINFO_VECT_FACTOR (loop_vinfo)) - 2;\n-  if (check_profitability)\n-    max_iter = MAX (max_iter, (int) th - 1);\n-  record_niter_bound (new_loop, max_iter, false, true);\n-  dump_printf (MSG_NOTE,\n-               \"Setting upper bound of nb iterations for epilogue \"\n-               \"loop to %d\\n\", max_iter);\n-\n-  /* After peeling we have to reset scalar evolution analyzer.  */\n-  scev_reset ();\n-\n-  free_original_copy_tables ();\n-}\n-\n-\n-/* Function vect_gen_niters_for_prolog_loop\n-\n-   Set the number of iterations for the loop represented by LOOP_VINFO\n-   to the minimum between LOOP_NITERS (the original iteration count of the loop)\n-   and the misalignment of DR - the data reference recorded in\n-   LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).  As a result, after the execution of\n-   this loop, the data reference DR will refer to an aligned location.\n-\n-   The following computation is generated:\n+   Generate the number of iterations which should be peeled as prolog for the\n+   loop represented by LOOP_VINFO.  It is calculated as the misalignment of\n+   DR - the data reference recorded in LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).\n+   As a result, after the execution of this loop, the data reference DR will\n+   refer to an aligned location.  The following computation is generated:\n \n    If the misalignment of DR is known at compile time:\n      addr_mis = int mis = DR_MISALIGNMENT (dr);\n    Else, compute address misalignment in bytes:\n      addr_mis = addr & (vectype_align - 1)\n \n-   prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)\n+   prolog_niters = ((VF - addr_mis/elem_size)&(VF-1))/step\n \n    (elem_size = element type size; an element is the scalar element whose type\n    is the inner type of the vectype)\n \n+   The computations will be emitted at the end of BB.  We also compute and\n+   store upper bound of the result in BOUND.\n+\n    When the step of the data-ref in the loop is not 1 (as in interleaved data\n    and SLP), the number of iterations of the prolog must be divided by the step\n    (which is equal to the size of interleaved group).\n@@ -1875,24 +917,21 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo,\n    use TYPE_VECTOR_SUBPARTS.  */\n \n static tree\n-vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int *bound)\n+vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n+\t\t\t     basic_block bb, int *bound)\n {\n   struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree var;\n-  gimple_seq stmts;\n+  tree niters_type = TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo));\n+  gimple_seq stmts = NULL, new_stmts = NULL;\n   tree iters, iters_name;\n-  edge pe;\n-  basic_block new_bb;\n   gimple *dr_stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n-  tree niters_type = TREE_TYPE (loop_niters);\n   int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  pe = loop_preheader_edge (loop);\n-\n   if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n       int npeel = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n@@ -1902,16 +941,15 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n                          \"known peeling = %d.\\n\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n-      *bound = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+      *bound = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) + 1;\n     }\n   else\n     {\n-      gimple_seq new_stmts = NULL;\n       bool negative = tree_int_cst_compare (DR_STEP (dr), size_zero_node) < 0;\n       tree offset = negative\n \t  ? size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1) : size_zero_node;\n       tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n-\t\t\t\t\t\t&new_stmts, offset, loop);\n+\t\t\t\t\t\t&stmts, offset, loop);\n       tree type = unsigned_type_for (TREE_TYPE (start_addr));\n       tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);\n       HOST_WIDE_INT elem_size =\n@@ -1922,17 +960,14 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n       tree byte_misalign;\n       tree elem_misalign;\n \n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmts);\n-      gcc_assert (!new_bb);\n-\n       /* Create:  byte_misalign = addr & (vectype_align - 1)  */\n       byte_misalign =\n-        fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), \n-                     vectype_align_minus_1);\n+\tfold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr),\n+\t\t     vectype_align_minus_1);\n \n       /* Create:  elem_misalign = byte_misalign / element_size  */\n       elem_misalign =\n-        fold_build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n+\tfold_build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n \n       /* Create:  (niters_type) (nelements - elem_misalign)&(nelements - 1)  */\n       if (negative)\n@@ -1944,13 +979,6 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n       *bound = nelements;\n     }\n \n-  /* Create:  prolog_loop_niters = min (iters, loop_niters) */\n-  /* If the loop bound is known at compile time we already verified that it is\n-     greater than vf; since the misalignment ('iters') is at most vf, there's\n-     no need to generate the MIN_EXPR in this case.  */\n-  if (TREE_CODE (loop_niters) != INTEGER_CST)\n-    iters = fold_build2 (MIN_EXPR, niters_type, iters, loop_niters);\n-\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1960,16 +988,19 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n     }\n \n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n-  stmts = NULL;\n-  iters_name = force_gimple_operand (iters, &stmts, false, var);\n+  iters_name = force_gimple_operand (iters, &new_stmts, false, var);\n \n-  /* Insert stmt on loop preheader edge.  */\n+  if (new_stmts)\n+    gimple_seq_add_seq (&stmts, new_stmts);\n   if (stmts)\n     {\n-      basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n+      gcc_assert (single_succ_p (bb));\n+      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+      if (gsi_end_p (gsi))\n+\tgsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+      else\n+\tgsi_insert_seq_after (&gsi, stmts, GSI_SAME_STMT);\n     }\n-\n   return iters_name;\n }\n \n@@ -2009,102 +1040,783 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   unsigned int i;\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n- \n- if (dump_enabled_p ())\n+\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_update_inits_of_dr ===\\n\");\n+\t\t     \"=== vect_update_inits_of_dr ===\\n\");\n+\n+  /* Adjust niters to sizetype and insert stmts on loop preheader edge.  */\n+  if (!types_compatible_p (sizetype, TREE_TYPE (niters)))\n+    {\n+      gimple_seq seq;\n+      edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+      tree var = create_tmp_var (sizetype, \"prolog_loop_adjusted_niters\");\n+\n+      niters = fold_convert (sizetype, niters);\n+      niters = force_gimple_operand (niters, &seq, false, var);\n+      if (seq)\n+\t{\n+\t  basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n+\t  gcc_assert (!new_bb);\n+\t}\n+    }\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     vect_update_init_of_dr (dr, niters);\n }\n \n \n-/* Function vect_do_peeling_for_alignment\n+/* This function builds ni_name = number of iterations.  Statements\n+   are emitted on the loop preheader edge.  */\n+\n+tree\n+vect_build_loop_niters (loop_vec_info loop_vinfo)\n+{\n+  tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n+  if (TREE_CODE (ni) == INTEGER_CST)\n+    return ni;\n+  else\n+    {\n+      tree ni_name, var;\n+      gimple_seq stmts = NULL;\n+      edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+\n+      var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n+      ni_name = force_gimple_operand (ni, &stmts, false, var);\n+      if (stmts)\n+\tgsi_insert_seq_on_edge_immediate (pe, stmts);\n+\n+      return ni_name;\n+    }\n+}\n+\n+/* Calculate the number of iterations under which scalar loop will be\n+   preferred than vectorized loop.  NITERS_PROLOG is the number of\n+   iterations of prolog loop.  If it's integer const, the integer\n+   number is also passed by INT_NITERS_PROLOG.  VF is vector factor;\n+   TH is the threshold for vectorized loop if CHECK_PROFITABILITY is\n+   true.  This function also store upper bound of the result in BOUND.  */\n+\n+static tree\n+vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n+\t\t\t     int bound_prolog, int vf, int th, int *bound,\n+\t\t\t     bool check_profitability)\n+{\n+  tree type = TREE_TYPE (niters_prolog);\n+  tree niters = fold_build2 (PLUS_EXPR, type, niters_prolog,\n+\t\t\t     build_int_cst (type, vf));\n \n-   Peel the first 'niters' iterations of the loop represented by LOOP_VINFO.\n-   'niters' is set to the misalignment of one of the data references in the\n-   loop, thereby forcing it to refer to an aligned location at the beginning\n-   of the execution of this loop.  The data reference for which we are\n-   peeling is recorded in LOOP_VINFO_UNALIGNED_DR.\n+  *bound = vf + bound_prolog;\n+  if (check_profitability)\n+    {\n+      th++;\n+      /* Peeling for constant times.  */\n+      if (int_niters_prolog >= 0)\n+\t{\n+\t  *bound = (int_niters_prolog + vf < th\n+\t\t\t\t\t   ? th\n+\t\t\t\t\t   : vf + int_niters_prolog);\n+\t  return build_int_cst (type, *bound);\n+\t}\n+      /* Peeling for unknown times, in this case, prolog loop must\n+\t execute less than bound_prolog times.  */\n+      if (th >=  vf + bound_prolog - 1)\n+\t{\n+\t  *bound = th;\n+\t  return build_int_cst (type, th);\n+\t}\n+      /* Need to do runtime comparison, but bound remains the same.  */\n+      else if (th > vf)\n+\treturn fold_build2 (MAX_EXPR, type, build_int_cst (type, th), niters);\n+    }\n+  return niters;\n+}\n+\n+/* This function generates the following statements:\n \n-   If CHECK_PROFITABILITY is 1 then profitability check is generated\n-   using TH as a cost model profitability threshold of iterations for\n-   vectorization.  */\n+   niters = number of iterations loop executes (after peeling)\n+   niters_vector = niters / vf\n+\n+   and places them on the loop preheader edge.  NITERS_NO_OVERFLOW is\n+   true if NITERS doesn't overflow.  */\n \n void\n-vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n-\t\t\t       unsigned int th, bool check_profitability)\n+vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n+\t\t\t     tree *niters_vector_ptr, bool niters_no_overflow)\n {\n+  tree ni_minus_gap, var;\n+  tree niters_vector;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n+  tree log_vf = build_int_cst (TREE_TYPE (niters), exact_log2 (vf));\n+\n+  /* If epilogue loop is required because of data accesses with gaps, we\n+     subtract one iteration from the total number of iterations here for\n+     correct calculation of RATIO.  */\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    {\n+      ni_minus_gap = fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n+\t\t\t\t  niters,\n+\t\t\t\t  build_one_cst (TREE_TYPE (niters)));\n+      if (!is_gimple_val (ni_minus_gap))\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (niters), \"ni_gap\");\n+\t  gimple *stmts = NULL;\n+\t  ni_minus_gap = force_gimple_operand (ni_minus_gap, &stmts,\n+\t\t\t\t\t       true, var);\n+\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t}\n+    }\n+  else\n+    ni_minus_gap = niters;\n+\n+  /* Create: niters >> log2(vf) */\n+  /* If it's known that niters == number of latch executions + 1 doesn't\n+     overflow, we can generate niters >> log2(vf); otherwise we generate\n+     (niters - vf) >> log2(vf) + 1 by using the fact that we know ratio\n+     will be at least one.  */\n+  if (niters_no_overflow)\n+    niters_vector = fold_build2 (RSHIFT_EXPR, TREE_TYPE (niters),\n+\t\t\t\t ni_minus_gap, log_vf);\n+  else\n+    niters_vector\n+      = fold_build2 (PLUS_EXPR, TREE_TYPE (niters),\n+\t\t     fold_build2 (RSHIFT_EXPR, TREE_TYPE (niters),\n+\t\t\t\t  fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n+\t\t\t\t\t       ni_minus_gap,\n+\t\t\t\t\t       build_int_cst\n+\t\t\t\t\t\t (TREE_TYPE (niters), vf)),\n+\t\t\t\t  log_vf),\n+\t\t     build_int_cst (TREE_TYPE (niters), 1));\n+\n+  if (!is_gimple_val (niters_vector))\n+    {\n+      var = create_tmp_var (TREE_TYPE (niters), \"bnd\");\n+      gimple *stmts = NULL;\n+      niters_vector = force_gimple_operand (niters_vector, &stmts, true, var);\n+      gsi_insert_seq_on_edge_immediate (pe, stmts);\n+    }\n+  *niters_vector_ptr = niters_vector;\n+\n+  return;\n+}\n+\n+/* Given NITERS_VECTOR which is the number of iterations for vectorized\n+   loop specified by LOOP_VINFO after vectorization, compute the number\n+   of iterations before vectorization (niters_vector * vf) and store it\n+   to NITERS_VECTOR_MULT_VF_PTR.  */\n+\n+static void\n+vect_gen_vector_loop_niters_mult_vf (loop_vec_info loop_vinfo,\n+\t\t\t\t     tree niters_vector,\n+\t\t\t\t     tree *niters_vector_mult_vf_ptr)\n+{\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n-  tree niters_of_prolog_loop;\n-  tree wide_prolog_niters;\n-  struct loop *new_loop;\n-  int max_iter;\n-  int bound = 0;\n+  tree type = TREE_TYPE (niters_vector);\n+  tree log_vf = build_int_cst (type, exact_log2 (vf));\n+  basic_block exit_bb = single_exit (loop)->dest;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-                     \"loop peeled for vectorization to enhance\"\n-                     \" alignment\\n\");\n+  gcc_assert (niters_vector_mult_vf_ptr != NULL);\n+  tree niters_vector_mult_vf = fold_build2 (LSHIFT_EXPR, type,\n+\t\t\t\t\t    niters_vector, log_vf);\n+  if (!is_gimple_val (niters_vector_mult_vf))\n+    {\n+      tree var = create_tmp_var (type, \"niters_vector_mult_vf\");\n+      gimple_seq stmts = NULL;\n+      niters_vector_mult_vf = force_gimple_operand (niters_vector_mult_vf,\n+\t\t\t\t\t\t    &stmts, true, var);\n+      gimple_stmt_iterator gsi = gsi_start_bb (exit_bb);\n+      gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+    }\n+  *niters_vector_mult_vf_ptr = niters_vector_mult_vf;\n+}\n \n+/* Function slpeel_tree_duplicate_loop_to_edge_cfg duplciates FIRST/SECOND\n+   from SECOND/FIRST and puts it at the original loop's preheader/exit\n+   edge, the two loops are arranged as below:\n+\n+       preheader_a:\n+     first_loop:\n+       header_a:\n+\t i_1 = PHI<i_0, i_2>;\n+\t ...\n+\t i_2 = i_1 + 1;\n+\t if (cond_a)\n+\t   goto latch_a;\n+\t else\n+\t   goto between_bb;\n+       latch_a:\n+\t goto header_a;\n+\n+       between_bb:\n+\t ;; i_x = PHI<i_2>;   ;; LCSSA phi node to be created for FIRST,\n+\n+     second_loop:\n+       header_b:\n+\t i_3 = PHI<i_0, i_4>; ;; Use of i_0 to be replaced with i_x,\n+\t\t\t\t or with i_2 if no LCSSA phi is created\n+\t\t\t\t under condition of CREATE_LCSSA_FOR_IV_PHIS.\n+\t ...\n+\t i_4 = i_3 + 1;\n+\t if (cond_b)\n+\t   goto latch_b;\n+\t else\n+\t   goto exit_bb;\n+       latch_b:\n+\t goto header_b;\n+\n+       exit_bb:\n+\n+   This function creates loop closed SSA for the first loop; update the\n+   second loop's PHI nodes by replacing argument on incoming edge with the\n+   result of newly created lcssa PHI nodes.  IF CREATE_LCSSA_FOR_IV_PHIS\n+   is false, Loop closed ssa phis will only be created for non-iv phis for\n+   the first loop.\n+\n+   This function assumes exit bb of the first loop is preheader bb of the\n+   second loop, i.e, between_bb in the example code.  With PHIs updated,\n+   the second loop will execute rest iterations of the first.  */\n+\n+static void\n+slpeel_update_phi_nodes_for_loops (loop_vec_info loop_vinfo,\n+\t\t\t\t   struct loop *first, struct loop *second,\n+\t\t\t\t   bool create_lcssa_for_iv_phis)\n+{\n+  gphi_iterator gsi_update, gsi_orig;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  edge first_latch_e = EDGE_SUCC (first->latch, 0);\n+  edge second_preheader_e = loop_preheader_edge (second);\n+  basic_block between_bb = single_exit (first)->dest;\n+\n+  gcc_assert (between_bb == second_preheader_e->src);\n+  gcc_assert (single_pred_p (between_bb) && single_succ_p (between_bb));\n+  /* Either the first loop or the second is the loop to be vectorized.  */\n+  gcc_assert (loop == first || loop == second);\n+\n+  for (gsi_orig = gsi_start_phis (first->header),\n+       gsi_update = gsi_start_phis (second->header);\n+       !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_update);\n+       gsi_next (&gsi_orig), gsi_next (&gsi_update))\n+    {\n+      gphi *orig_phi = gsi_orig.phi ();\n+      gphi *update_phi = gsi_update.phi ();\n+\n+      tree arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, first_latch_e);\n+      /* Generate lcssa PHI node for the first loop.  */\n+      gphi *vect_phi = (loop == first) ? orig_phi : update_phi;\n+      if (create_lcssa_for_iv_phis || !iv_phi_p (vect_phi))\n+\t{\n+\t  tree new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n+\t  gphi *lcssa_phi = create_phi_node (new_res, between_bb);\n+\t  add_phi_arg (lcssa_phi, arg, single_exit (first), UNKNOWN_LOCATION);\n+\t  arg = new_res;\n+\t}\n+\n+      /* Update PHI node in the second loop by replacing arg on the loop's\n+\t incoming edge.  */\n+      adjust_phi_and_debug_stmts (update_phi, second_preheader_e, arg);\n+    }\n+}\n+\n+/* Function slpeel_add_loop_guard adds guard skipping from the beginning\n+   of SKIP_LOOP to the beginning of UPDATE_LOOP.  GUARD_EDGE and MERGE_EDGE\n+   are two pred edges of the merge point before UPDATE_LOOP.  The two loops\n+   appear like below:\n+\n+       guard_bb:\n+\t if (cond)\n+\t   goto merge_bb;\n+\t else\n+\t   goto skip_loop;\n+\n+     skip_loop:\n+       header_a:\n+\t i_1 = PHI<i_0, i_2>;\n+\t ...\n+\t i_2 = i_1 + 1;\n+\t if (cond_a)\n+\t   goto latch_a;\n+\t else\n+\t   goto exit_a;\n+       latch_a:\n+\t goto header_a;\n+\n+       exit_a:\n+\t i_5 = PHI<i_2>;\n+\n+       merge_bb:\n+\t ;; PHI (i_x = PHI<i_0, i_5>) to be created at merge point.\n+\n+     update_loop:\n+       header_b:\n+\t i_3 = PHI<i_5, i_4>;  ;; Use of i_5 to be replaced with i_x.\n+\t ...\n+\t i_4 = i_3 + 1;\n+\t if (cond_b)\n+\t   goto latch_b;\n+\t else\n+\t   goto exit_bb;\n+       latch_b:\n+\t goto header_b;\n+\n+       exit_bb:\n+\n+   This function creates PHI nodes at merge_bb and replaces the use of i_5\n+   in the update_loop's PHI node with the result of new PHI result.  */\n+\n+static void\n+slpeel_update_phi_nodes_for_guard1 (struct loop *skip_loop,\n+\t\t\t\t    struct loop *update_loop,\n+\t\t\t\t    edge guard_edge, edge merge_edge)\n+{\n+  source_location merge_loc, guard_loc;\n+  edge orig_e = loop_preheader_edge (skip_loop);\n+  edge update_e = loop_preheader_edge (update_loop);\n+  gphi_iterator gsi_orig, gsi_update;\n+\n+  for ((gsi_orig = gsi_start_phis (skip_loop->header),\n+\tgsi_update = gsi_start_phis (update_loop->header));\n+       !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_update);\n+       gsi_next (&gsi_orig), gsi_next (&gsi_update))\n+    {\n+      gphi *orig_phi = gsi_orig.phi ();\n+      gphi *update_phi = gsi_update.phi ();\n+\n+      /* Generate new phi node at merge bb of the guard.  */\n+      tree new_res = copy_ssa_name (PHI_RESULT (orig_phi));\n+      gphi *new_phi = create_phi_node (new_res, guard_edge->dest);\n+\n+      /* Merge bb has two incoming edges: GUARD_EDGE and MERGE_EDGE.  Set the\n+\t args in NEW_PHI for these edges.  */\n+      tree merge_arg = PHI_ARG_DEF_FROM_EDGE (update_phi, update_e);\n+      tree guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, orig_e);\n+      merge_loc = gimple_phi_arg_location_from_edge (update_phi, update_e);\n+      guard_loc = gimple_phi_arg_location_from_edge (orig_phi, orig_e);\n+      add_phi_arg (new_phi, merge_arg, merge_edge, merge_loc);\n+      add_phi_arg (new_phi, guard_arg, guard_edge, guard_loc);\n+\n+      /* Update phi in UPDATE_PHI.  */\n+      adjust_phi_and_debug_stmts (update_phi, update_e, new_res);\n+    }\n+}\n+\n+/* LCSSA_PHI is a lcssa phi of EPILOG loop which is copied from LOOP,\n+   this function searches for the corresponding lcssa phi node in exit\n+   bb of LOOP.  If it is found, return the phi result; otherwise return\n+   NULL.  */\n+\n+static tree\n+find_guard_arg (struct loop *loop, struct loop *epilog ATTRIBUTE_UNUSED,\n+\t\tgphi *lcssa_phi)\n+{\n+  gphi_iterator gsi;\n+  edge e = single_exit (loop);\n+\n+  gcc_assert (single_pred_p (e->dest));\n+  for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *phi = gsi.phi ();\n+      if (operand_equal_p (PHI_ARG_DEF (phi, 0),\n+\t\t\t   PHI_ARG_DEF (lcssa_phi, 0), 0))\n+\treturn PHI_RESULT (phi);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* LOOP and EPILOG are two consecutive loops in CFG and EPILOG is copied\n+   from LOOP.  Function slpeel_add_loop_guard adds guard skipping from a\n+   point between the two loops to the end of EPILOG.  Edges GUARD_EDGE\n+   and MERGE_EDGE are the two pred edges of merge_bb at the end of EPILOG.\n+   The CFG looks like:\n+\n+     loop:\n+       header_a:\n+\t i_1 = PHI<i_0, i_2>;\n+\t ...\n+\t i_2 = i_1 + 1;\n+\t if (cond_a)\n+\t   goto latch_a;\n+\t else\n+\t   goto exit_a;\n+       latch_a:\n+\t goto header_a;\n+\n+       exit_a:\n+\n+       guard_bb:\n+\t if (cond)\n+\t   goto merge_bb;\n+\t else\n+\t   goto epilog_loop;\n+\n+       ;; fall_through_bb\n+\n+     epilog_loop:\n+       header_b:\n+\t i_3 = PHI<i_2, i_4>;\n+\t ...\n+\t i_4 = i_3 + 1;\n+\t if (cond_b)\n+\t   goto latch_b;\n+\t else\n+\t   goto merge_bb;\n+       latch_b:\n+\t goto header_b;\n+\n+       merge_bb:\n+\t ; PHI node (i_y = PHI<i_2, i_4>) to be created at merge point.\n+\n+       exit_bb:\n+\t i_x = PHI<i_4>;  ;Use of i_4 to be replaced with i_y in merge_bb.\n+\n+   For each name used out side EPILOG (i.e - for each name that has a lcssa\n+   phi in exit_bb) we create a new PHI in merge_bb.  The new PHI has two\n+   args corresponding to GUARD_EDGE and MERGE_EDGE.  Arg for MERGE_EDGE is\n+   the arg of the original PHI in exit_bb, arg for GUARD_EDGE is defined\n+   by LOOP and is found in the exit bb of LOOP.  Arg of the original PHI\n+   in exit_bb will also be updated.  */\n+\n+static void\n+slpeel_update_phi_nodes_for_guard2 (struct loop *loop, struct loop *epilog,\n+\t\t\t\t    edge guard_edge, edge merge_edge)\n+{\n+  gphi_iterator gsi;\n+  basic_block merge_bb = guard_edge->dest;\n+\n+  gcc_assert (single_succ_p (merge_bb));\n+  edge e = single_succ_edge (merge_bb);\n+  basic_block exit_bb = e->dest;\n+  gcc_assert (single_pred_p (exit_bb));\n+  gcc_assert (single_pred (exit_bb) == single_exit (epilog)->dest);\n+\n+  for (gsi = gsi_start_phis (exit_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gphi *update_phi = gsi.phi ();\n+      tree old_arg = PHI_ARG_DEF (update_phi, 0);\n+      /* This loop-closed-phi actually doesn't represent a use out of the\n+\t loop - the phi arg is a constant.  */\n+      if (TREE_CODE (old_arg) != SSA_NAME)\n+\tcontinue;\n+\n+      tree merge_arg = get_current_def (old_arg);\n+      if (!merge_arg)\n+\tmerge_arg = old_arg;\n+\n+      tree guard_arg = find_guard_arg (loop, epilog, update_phi);\n+      /* If the var is live after loop but not a reduction, we simply\n+\t use the old arg.  */\n+      if (!guard_arg)\n+\tguard_arg = old_arg;\n+\n+      /* Create new phi node in MERGE_BB:  */\n+      tree new_res = copy_ssa_name (PHI_RESULT (update_phi));\n+      gphi *merge_phi = create_phi_node (new_res, merge_bb);\n+\n+      /* MERGE_BB has two incoming edges: GUARD_EDGE and MERGE_EDGE, Set\n+\t the two PHI args in merge_phi for these edges.  */\n+      add_phi_arg (merge_phi, merge_arg, merge_edge, UNKNOWN_LOCATION);\n+      add_phi_arg (merge_phi, guard_arg, guard_edge, UNKNOWN_LOCATION);\n+\n+      /* Update the original phi in exit_bb.  */\n+      adjust_phi_and_debug_stmts (update_phi, e, new_res);\n+    }\n+}\n+\n+/* EPILOG loop is duplicated from the original loop for vectorizing,\n+   the arg of its loop closed ssa PHI needs to be updated.  */\n+\n+static void\n+slpeel_update_phi_nodes_for_lcssa (struct loop *epilog)\n+{\n+  gphi_iterator gsi;\n+  basic_block exit_bb = single_exit (epilog)->dest;\n+\n+  gcc_assert (single_pred_p (exit_bb));\n+  edge e = EDGE_PRED (exit_bb, 0);\n+  for (gsi = gsi_start_phis (exit_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi.phi (), e));\n+}\n+\n+/* Function vect_do_peeling.\n+\n+   Input:\n+   - LOOP_VINFO: Represent a loop to be vectorized, which looks like:\n+\n+       preheader:\n+     LOOP:\n+       header_bb:\n+\t loop_body\n+\t if (exit_loop_cond) goto exit_bb\n+\t else                goto header_bb\n+       exit_bb:\n+\n+   - NITERS: The number of iterations of the loop.\n+   - NITERSM1: The number of iterations of the loop's latch.\n+   - NITERS_NO_OVERFLOW: No overflow in computing NITERS.\n+   - TH, CHECK_PROFITABILITY: Threshold of niters to vectorize loop if\n+\t\t\t      CHECK_PROFITABILITY is true.\n+   Output:\n+   - NITERS_VECTOR: The number of iterations of loop after vectorization.\n+\n+   This function peels prolog and epilog from the loop, adds guards skipping\n+   PROLOG and EPILOG for various conditions.  As a result, the changed CFG\n+   would look like:\n+\n+       guard_bb_1:\n+\t if (prefer_scalar_loop) goto merge_bb_1\n+\t else                    goto guard_bb_2\n+\n+       guard_bb_2:\n+         if (skip_prolog) goto merge_bb_2\n+         else             goto prolog_preheader\n+\n+       prolog_preheader:\n+     PROLOG:\n+       prolog_header_bb:\n+\t prolog_body\n+\t if (exit_prolog_cond) goto prolog_exit_bb\n+\t else                  goto prolog_header_bb\n+       prolog_exit_bb:\n+\n+       merge_bb_2:\n+\n+       vector_preheader:\n+     VECTOR LOOP:\n+       vector_header_bb:\n+\t vector_body\n+\t if (exit_vector_cond) goto vector_exit_bb\n+\t else                  goto vector_header_bb\n+       vector_exit_bb:\n+\n+       guard_bb_3:\n+\t if (skip_epilog) goto merge_bb_3\n+\t else             goto epilog_preheader\n+\n+       merge_bb_1:\n+\n+       epilog_preheader:\n+     EPILOG:\n+       epilog_header_bb:\n+\t epilog_body\n+\t if (exit_epilog_cond) goto merge_bb_3\n+\t else                  goto epilog_header_bb\n+\n+       merge_bb_3:\n+\n+   Note this function peels prolog and epilog only if it's necessary,\n+   as well as guards.\n+\n+   TODO: Guard for prefer_scalar_loop should be emitted along with\n+   versioning conditions if loop versioning is needed.  */\n+\n+void\n+vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n+\t\t tree *niters_vector, int th, bool check_profitability,\n+\t\t bool niters_no_overflow)\n+{\n+  edge e, guard_e;\n+  tree type = TREE_TYPE (niters), guard_cond;\n+  basic_block guard_bb, guard_to;\n+  int prob_prolog, prob_vector, prob_epilog;\n+  int bound_prolog = 0, bound_epilog = 0, bound = 0;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+  bool epilog_peeling = (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n+\t\t\t || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n+\n+  if (!prolog_peeling && !epilog_peeling)\n+    return;\n+\n+  prob_vector = 9 * REG_BR_PROB_BASE / 10;\n+  if ((vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo)) == 2)\n+    vf = 3;\n+  prob_prolog = prob_epilog = (vf - 1) * REG_BR_PROB_BASE / vf;\n+  vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  struct loop *prolog, *epilog, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *first_loop = loop;\n+  create_lcssa_for_virtual_phi (loop);\n+  update_ssa (TODO_update_ssa_only_virtuals);\n+\n+  if (MAY_HAVE_DEBUG_STMTS)\n+    {\n+      gcc_assert (!adjust_vec.exists ());\n+      adjust_vec.create (32);\n+    }\n   initialize_original_copy_tables ();\n \n-  niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo,\n-\t\t\t\t\t\t\t   ni_name,\n-\t\t\t\t\t\t\t   &bound);\n-\n-  /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n-  new_loop =\n-    slpeel_tree_peel_loop_to_edge (loop, scalar_loop,\n-\t\t\t\t   loop_preheader_edge (loop),\n-\t\t\t\t   &niters_of_prolog_loop, ni_name, true,\n-\t\t\t\t   th, check_profitability, NULL_TREE, NULL,\n-\t\t\t\t   bound, 0);\n-\n-  gcc_assert (new_loop);\n-  slpeel_checking_verify_cfg_after_peeling (new_loop, loop);\n-  /* For vectorization factor N, we need to copy at most N-1 values \n-     for alignment and this means N-2 loopback edge executions.  */\n-  max_iter = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 2;\n-  if (check_profitability)\n-    max_iter = MAX (max_iter, (int) th - 1);\n-  record_niter_bound (new_loop, max_iter, false, true);\n-  dump_printf (MSG_NOTE,\n-               \"Setting upper bound of nb iterations for prologue \"\n-               \"loop to %d\\n\", max_iter);\n-\n-  /* Update number of times loop executes.  */\n-  LOOP_VINFO_NITERS (loop_vinfo) = fold_build2 (MINUS_EXPR,\n-\t\tTREE_TYPE (ni_name), ni_name, niters_of_prolog_loop);\n-  LOOP_VINFO_NITERSM1 (loop_vinfo) = fold_build2 (MINUS_EXPR,\n-\t\tTREE_TYPE (ni_name),\n-\t\tLOOP_VINFO_NITERSM1 (loop_vinfo), niters_of_prolog_loop);\n-\n-  if (types_compatible_p (sizetype, TREE_TYPE (niters_of_prolog_loop)))\n-    wide_prolog_niters = niters_of_prolog_loop;\n-  else\n+  /* Prolog loop may be skipped.  */\n+  bool skip_prolog = (prolog_peeling != 0);\n+  /* Skip to epilog if scalar loop may be preferred.  It's only used when\n+     we peel for epilog loop.  */\n+  bool skip_vector = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo));\n+  /* Epilog loop must be executed if the number of iterations for epilog\n+     loop is known at compile time, otherwise we need to add a check at\n+     the end of vector loop and skip to the end of epilog loop.  */\n+  bool skip_epilog = (prolog_peeling < 0\n+\t\t      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo));\n+  /* PEELING_FOR_GAPS is special because epilog loop must be executed.  */\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    skip_epilog = false;\n+\n+  /* Record the anchor bb at which guard should be placed if scalar loop\n+     may be preferred.  */\n+  basic_block anchor = loop_preheader_edge (loop)->src;\n+  if (skip_vector)\n+    split_edge (loop_preheader_edge (loop));\n+\n+  tree niters_prolog = build_int_cst (type, 0);\n+  source_location loop_loc = find_loop_location (loop);\n+  struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n+  if (prolog_peeling)\n     {\n-      gimple_seq seq = NULL;\n-      edge pe = loop_preheader_edge (loop);\n-      tree wide_iters = fold_convert (sizetype, niters_of_prolog_loop);\n-      tree var = create_tmp_var (sizetype, \"prolog_loop_adjusted_niters\");\n-      wide_prolog_niters = force_gimple_operand (wide_iters, &seq, false,\n-                                                 var);\n-      if (seq)\n+      e = loop_preheader_edge (loop);\n+      if (!slpeel_can_duplicate_loop_p (loop, e))\n \t{\n-\t  /* Insert stmt on loop preheader edge.  */\n-          basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n-          gcc_assert (!new_bb);\n-        }\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n+\t\t\t   \"loop can't be duplicated to preheader edge.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      /* Peel prolog and put it on preheader edge of loop.  */\n+      prolog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, scalar_loop, e);\n+      if (!prolog)\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n+\t\t\t   \"slpeel_tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      slpeel_update_phi_nodes_for_loops (loop_vinfo, prolog, loop, true);\n+      first_loop = prolog;\n+      reset_original_copy_tables ();\n+\n+      /* Generate and update the number of iterations for prolog loop.  */\n+      niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n+\t\t\t\t\t\t   &bound_prolog);\n+      slpeel_make_loop_iterate_ntimes (prolog, niters_prolog);\n+\n+      /* Skip the prolog loop.  */\n+      if (skip_prolog)\n+\t{\n+\t  guard_cond = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    niters_prolog, build_int_cst (type, 0));\n+\t  guard_bb = loop_preheader_edge (prolog)->src;\n+\t  guard_to = split_edge (loop_preheader_edge (loop));\n+\t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n+\t\t\t\t\t   guard_to, guard_bb,\n+\t\t\t\t\t   inverse_probability (prob_prolog));\n+\t  e = EDGE_PRED (guard_to, 0);\n+\t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n+\t  slpeel_update_phi_nodes_for_guard1 (prolog, loop, guard_e, e);\n+\t  scale_loop_profile (prolog, prob_prolog, bound_prolog);\n+\t}\n+      /* Update init address of DRs.  */\n+      vect_update_inits_of_drs (loop_vinfo, niters_prolog);\n+      /* Update niters for vector loop.  */\n+      LOOP_VINFO_NITERS (loop_vinfo)\n+\t= fold_build2 (MINUS_EXPR, type, niters, niters_prolog);\n+      LOOP_VINFO_NITERSM1 (loop_vinfo)\n+\t= fold_build2 (MINUS_EXPR, type,\n+\t\t       LOOP_VINFO_NITERSM1 (loop_vinfo), niters_prolog);\n+      niters = vect_build_loop_niters (loop_vinfo);\n+\n+      /* Prolog iterates at most bound_prolog - 1 times, latch iterates\n+\t at most bound_prolog - 2 times.  */\n+      record_niter_bound (prolog, bound_prolog - 2, false, true);\n+      delete_update_ssa ();\n+      adjust_vec_debug_stmts ();\n+      scev_reset ();\n     }\n \n-  /* Update the init conditions of the access functions of all data refs.  */\n-  vect_update_inits_of_drs (loop_vinfo, wide_prolog_niters);\n+  if (epilog_peeling)\n+    {\n+      e = single_exit (loop);\n+      if (!slpeel_can_duplicate_loop_p (loop, e))\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n+\t\t\t   \"loop can't be duplicated to exit edge.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      /* Peel epilog and put it on exit edge of loop.  */\n+      epilog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, scalar_loop, e);\n+      if (!epilog)\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, loop_loc,\n+\t\t\t   \"slpeel_tree_duplicate_loop_to_edge_cfg failed.\\n\");\n+\t  gcc_unreachable ();\n+\t}\n+      slpeel_update_phi_nodes_for_loops (loop_vinfo, loop, epilog, false);\n+\n+      /* Scalar version loop may be preferred.  In this case, add guard\n+\t and skip to epilog.  Note this only happens when the number of\n+\t iterations of loop is unknown at compile time, otherwise this\n+\t won't be vectorized.  */\n+      if (skip_vector)\n+\t{\n+\t  /* Guard_cond needs is based on NITERSM1 because NITERS might\n+\t     overflow, so here it is niters_scalar - 1 generated.  In\n+\t     other words, both niters_scalar and bound_epilog are for\n+\t     scalar loop's latch.  */\n+\t  tree t = vect_gen_scalar_loop_niters (niters_prolog, prolog_peeling,\n+\t\t\t\t\t\tbound_prolog, vf - 1, th - 1,\n+\t\t\t\t\t\t&bound_epilog,\n+\t\t\t\t\t\tcheck_profitability);\n+\t  guard_cond = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t    nitersm1, t);\n+\t  guard_bb = anchor;\n+\t  guard_to = split_edge (loop_preheader_edge (epilog));\n+\t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond,\n+\t\t\t\t\t   guard_to, guard_bb,\n+\t\t\t\t\t   inverse_probability (prob_vector));\n+\t  e = EDGE_PRED (guard_to, 0);\n+\t  e = (e != guard_e ? e : EDGE_PRED (guard_to, 1));\n+\t  slpeel_update_phi_nodes_for_guard1 (first_loop, epilog, guard_e, e);\n+\t  scale_loop_profile (epilog, prob_vector, bound_epilog);\n+\t}\n \n-  /* After peeling we have to reset scalar evolution analyzer.  */\n-  scev_reset ();\n+      tree niters_vector_mult_vf;\n+      /* If loop is peeled for non-zero constant times, now niters refers to\n+\t orig_niters - prolog_peeling, it won't overflow even the orig_niters\n+\t overflows.  */\n+      niters_no_overflow |= (prolog_peeling > 0);\n+      vect_gen_vector_loop_niters (loop_vinfo, niters,\n+\t\t\t\t   niters_vector, niters_no_overflow);\n+      vect_gen_vector_loop_niters_mult_vf (loop_vinfo, *niters_vector,\n+\t\t\t\t\t   &niters_vector_mult_vf);\n+      /* Update IVs of original loop as if they were advanced by\n+\t niters_vector_mult_vf steps.  */\n+      gcc_checking_assert (vect_can_advance_ivs_p (loop_vinfo));\n+      edge update_e = skip_vector ? e : loop_preheader_edge (epilog);\n+      vect_update_ivs_after_vectorizer (loop_vinfo, niters_vector_mult_vf,\n+\t\t\t\t\tupdate_e);\n+\n+      if (skip_epilog)\n+\t{\n+\t  guard_cond = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t    niters, niters_vector_mult_vf);\n+\t  guard_bb = single_exit (loop)->dest;\n+\t  guard_to = split_edge (single_exit (epilog));\n+\t  guard_e = slpeel_add_loop_guard (guard_bb, guard_cond, guard_to,\n+\t\t\t\t\t   skip_vector ? anchor : guard_bb,\n+\t\t\t\t\t   inverse_probability (prob_epilog));\n+\t  slpeel_update_phi_nodes_for_guard2 (loop, epilog, guard_e,\n+\t\t\t\t\t      single_exit (epilog));\n+\t  scale_loop_profile (epilog, prob_epilog, bound);\n+\t}\n+      else\n+\tslpeel_update_phi_nodes_for_lcssa (epilog);\n \n+      bound = (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? vf * 2 : vf) - 2;\n+      /* We share epilog loop with scalar version loop.  */\n+      bound_epilog = MAX (bound, bound_epilog - 1);\n+      record_niter_bound (epilog, bound_epilog, false, true);\n+\n+      delete_update_ssa ();\n+      adjust_vec_debug_stmts ();\n+      scev_reset ();\n+    }\n+  adjust_vec.release ();\n   free_original_copy_tables ();\n }\n "}, {"sha": "0470445de81d284216d07bdb2927a69266db7f50", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 23, "deletions": 168, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a5e3d6146d07611eb967befec4dc480c8a19db0d", "patch": "@@ -6620,120 +6620,6 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple *stmt)\n     }\n }\n \n-\n-/* This function builds ni_name = number of iterations.  Statements\n-   are emitted on the loop preheader edge.  */\n-\n-static tree\n-vect_build_loop_niters (loop_vec_info loop_vinfo)\n-{\n-  tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n-  if (TREE_CODE (ni) == INTEGER_CST)\n-    return ni;\n-  else\n-    {\n-      tree ni_name, var;\n-      gimple_seq stmts = NULL;\n-      edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n-\n-      var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n-      ni_name = force_gimple_operand (ni, &stmts, false, var);\n-      if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (pe, stmts);\n-\n-      return ni_name;\n-    }\n-}\n-\n-\n-/* This function generates the following statements:\n-\n-   ni_name = number of iterations loop executes\n-   ratio = ni_name / vf\n-   ratio_mult_vf_name = ratio * vf\n-\n-   and places them on the loop preheader edge.  */\n-\n-static void\n-vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n-\t\t\t\t tree ni_name,\n-\t\t\t\t tree *ratio_mult_vf_name_ptr,\n-\t\t\t\t tree *ratio_name_ptr)\n-{\n-  tree ni_minus_gap_name;\n-  tree var;\n-  tree ratio_name;\n-  tree ratio_mult_vf_name;\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n-  tree log_vf;\n-\n-  log_vf = build_int_cst (TREE_TYPE (ni_name), exact_log2 (vf));\n-\n-  /* If epilogue loop is required because of data accesses with gaps, we\n-     subtract one iteration from the total number of iterations here for\n-     correct calculation of RATIO.  */\n-  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-    {\n-      ni_minus_gap_name = fold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n-\t\t\t\t       ni_name,\n-\t\t\t               build_one_cst (TREE_TYPE (ni_name)));\n-      if (!is_gimple_val (ni_minus_gap_name))\n-\t{\n-\t  var = create_tmp_var (TREE_TYPE (ni_name), \"ni_gap\");\n-\t  gimple *stmts = NULL;\n-          ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n-\t\t\t\t\t\t    true, var);\n-\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n-        }\n-    }\n-  else\n-    ni_minus_gap_name = ni_name;\n-\n-  /* Create: ratio = ni >> log2(vf) */\n-  /* ???  As we have ni == number of latch executions + 1, ni could\n-     have overflown to zero.  So avoid computing ratio based on ni\n-     but compute it using the fact that we know ratio will be at least\n-     one, thus via (ni - vf) >> log2(vf) + 1.  */\n-  ratio_name\n-    = fold_build2 (PLUS_EXPR, TREE_TYPE (ni_name),\n-\t\t   fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_name),\n-\t\t\t\tfold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n-\t\t\t\t\t     ni_minus_gap_name,\n-\t\t\t\t\t     build_int_cst\n-\t\t\t\t\t       (TREE_TYPE (ni_name), vf)),\n-\t\t\t\tlog_vf),\n-\t\t   build_int_cst (TREE_TYPE (ni_name), 1));\n-  if (!is_gimple_val (ratio_name))\n-    {\n-      var = create_tmp_var (TREE_TYPE (ni_name), \"bnd\");\n-      gimple *stmts = NULL;\n-      ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n-      gsi_insert_seq_on_edge_immediate (pe, stmts);\n-    }\n-  *ratio_name_ptr = ratio_name;\n-\n-  /* Create: ratio_mult_vf = ratio << log2 (vf).  */\n-\n-  if (ratio_mult_vf_name_ptr)\n-    {\n-      ratio_mult_vf_name = fold_build2 (LSHIFT_EXPR, TREE_TYPE (ratio_name),\n-\t\t\t\t\tratio_name, log_vf);\n-      if (!is_gimple_val (ratio_mult_vf_name))\n-\t{\n-\t  var = create_tmp_var (TREE_TYPE (ni_name), \"ratio_mult_vf\");\n-\t  gimple *stmts = NULL;\n-\t  ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n-\t\t\t\t\t\t     true, var);\n-\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t}\n-      *ratio_mult_vf_name_ptr = ratio_mult_vf_name;\n-    }\n-\n-  return;\n-}\n-\n-\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -6747,8 +6633,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   int i;\n-  tree ratio = NULL;\n-  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  tree niters_vector = NULL;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   bool grouped_store;\n   bool slp_scheduled = false;\n   gimple *stmt, *pattern_stmt;\n@@ -6818,49 +6704,20 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-  tree ni_name = vect_build_loop_niters (loop_vinfo);\n-  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = ni_name;\n-\n-  /* Peel the loop if there are data refs with unknown alignment.\n-     Only one data ref with unknown store is allowed.  */\n-\n-  if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  tree niters = vect_build_loop_niters (loop_vinfo);\n+  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = niters;\n+  tree nitersm1 = unshare_expr (LOOP_VINFO_NITERSM1 (loop_vinfo));\n+  vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector, th,\n+\t\t   check_profitability, false);\n+  if (niters_vector == NULL_TREE)\n     {\n-      vect_do_peeling_for_alignment (loop_vinfo, ni_name,\n-\t\t\t\t     th, check_profitability);\n-      check_profitability = false;\n-      /* The above adjusts LOOP_VINFO_NITERS, so cause ni_name to\n-\t be re-computed.  */\n-      ni_name = NULL_TREE;\n-    }\n-\n-  /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n-     compile time constant), or it is a constant that doesn't divide by the\n-     vectorization factor, then an epilog loop needs to be created.\n-     We therefore duplicate the loop: the original loop will be vectorized,\n-     and will compute the first (n/VF) iterations.  The second copy of the loop\n-     will remain scalar and will compute the remaining (n%VF) iterations.\n-     (VF is the vectorization factor).  */\n-\n-  if (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n-      || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-    {\n-      tree ratio_mult_vf;\n-      if (!ni_name)\n-\tni_name = vect_build_loop_niters (loop_vinfo);\n-      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, &ratio_mult_vf,\n-\t\t\t\t       &ratio);\n-      vect_do_peeling_for_loop_bound (loop_vinfo, ni_name, ratio_mult_vf,\n-\t\t\t\t      th, check_profitability);\n-    }\n-  else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-    ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n-\t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);\n-  else\n-    {\n-      if (!ni_name)\n-\tni_name = vect_build_loop_niters (loop_vinfo);\n-      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, NULL, &ratio);\n+      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\tniters_vector\n+\t  = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n+\t\t\t   LOOP_VINFO_INT_NITERS (loop_vinfo) / vf);\n+      else\n+\tvect_gen_vector_loop_niters (loop_vinfo, niters, &niters_vector,\n+\t\t\t\t     false);\n     }\n \n   /* 1) Make sure the loop header has exactly two entries\n@@ -6903,7 +6760,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if (STMT_VINFO_VECTYPE (stmt_info)\n \t      && (TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n-\t\t  != (unsigned HOST_WIDE_INT) vectorization_factor)\n+\t\t  != (unsigned HOST_WIDE_INT) vf)\n \t      && dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n \n@@ -7036,7 +6893,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t= (unsigned int)\n \t\t  TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n \t      if (!STMT_SLP_TYPE (stmt_info)\n-\t\t  && nunits != (unsigned int) vectorization_factor\n+\t\t  && nunits != (unsigned int) vf\n \t\t  && dump_enabled_p ())\n \t\t  /* For SLP VF is set according to unrolling factor, and not\n \t\t     to vector size, hence for SLP this print is not valid.  */\n@@ -7108,11 +6965,11 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n \n-  slpeel_make_loop_iterate_ntimes (loop, ratio);\n+  slpeel_make_loop_iterate_ntimes (loop, niters_vector);\n \n   /* Reduce loop iterations by the vectorization factor.  */\n-  scale_loop_profile (loop, GCOV_COMPUTE_SCALE (1, vectorization_factor),\n-\t\t      expected_iterations / vectorization_factor);\n+  scale_loop_profile (loop, GCOV_COMPUTE_SCALE (1, vf),\n+\t\t      expected_iterations / vf);\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     {\n       if (loop->nb_iterations_upper_bound != 0)\n@@ -7122,16 +6979,14 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t   = loop->nb_iterations_likely_upper_bound - 1;\n     }\n   loop->nb_iterations_upper_bound\n-    = wi::udiv_floor (loop->nb_iterations_upper_bound + 1,\n-\t\t      vectorization_factor) - 1;\n+    = wi::udiv_floor (loop->nb_iterations_upper_bound + 1, vf) - 1;\n   loop->nb_iterations_likely_upper_bound\n-    = wi::udiv_floor (loop->nb_iterations_likely_upper_bound + 1,\n-\t\t      vectorization_factor) - 1;\n+    = wi::udiv_floor (loop->nb_iterations_likely_upper_bound + 1, vf) - 1;\n \n   if (loop->any_estimate)\n     {\n       loop->nb_iterations_estimate\n-        = wi::udiv_floor (loop->nb_iterations_estimate, vectorization_factor);\n+\t= wi::udiv_floor (loop->nb_iterations_estimate, vf);\n        if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n \t   && loop->nb_iterations_estimate != 0)\n \t loop->nb_iterations_estimate = loop->nb_iterations_estimate - 1;"}, {"sha": "386654862b4a11df804c1d5636c15957b0e27ecd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e3d6146d07611eb967befec4dc480c8a19db0d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a5e3d6146d07611eb967befec4dc480c8a19db0d", "patch": "@@ -1032,10 +1032,8 @@ extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *,\n \t\t\t\t\t\t     struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n-extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree, tree,\n-\t\t\t\t\t    unsigned int, bool);\n-extern void vect_do_peeling_for_alignment (loop_vec_info, tree,\n-\t\t\t\t\t   unsigned int, bool);\n+extern void vect_do_peeling (loop_vec_info, tree, tree,\n+\t\t\t     tree *, int, bool, bool);\n extern source_location find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n@@ -1147,6 +1145,8 @@ extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *, bool,\n \t\t\t\t\t    bool *, bool);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n+extern tree vect_build_loop_niters (loop_vec_info);\n+extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *, bool);\n /* Drive for loop transformation stage.  */\n extern void vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);"}]}