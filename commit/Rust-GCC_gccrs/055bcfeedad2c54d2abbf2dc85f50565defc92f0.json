{"sha": "055bcfeedad2c54d2abbf2dc85f50565defc92f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU1YmNmZWVkYWQyYzU0ZDJhYmJmMmRjODVmNTA1NjVkZWZjOTJmMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-12T16:28:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-12T16:28:10Z"}, "message": "sibcall.c (uses_addressof): Accept both addressof and current_function_internal_arg_pointer inside a mem.\n\n        * sibcall.c (uses_addressof): Accept both addressof and\n        current_function_internal_arg_pointer inside a mem.\n        (optimize_sibling_and_tail_recursive_call): Fail tail recursion\n        if current_function_uses_addressof.\n        * stmt.c (expand_return): Kill tail recursion and HAVE_return\n        optimizations.\n\nFrom-SVN: r35657", "tree": {"sha": "0b58003a89bb66321aeaebb663ee8fe8ba653669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b58003a89bb66321aeaebb663ee8fe8ba653669"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/055bcfeedad2c54d2abbf2dc85f50565defc92f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055bcfeedad2c54d2abbf2dc85f50565defc92f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/055bcfeedad2c54d2abbf2dc85f50565defc92f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055bcfeedad2c54d2abbf2dc85f50565defc92f0/comments", "author": null, "committer": null, "parents": [{"sha": "3ac597cb9a7b77b48e54670f6d9f3a028bd75b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac597cb9a7b77b48e54670f6d9f3a028bd75b8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac597cb9a7b77b48e54670f6d9f3a028bd75b8f"}], "stats": {"total": 125, "additions": 25, "deletions": 100}, "files": [{"sha": "402fe228aecf57395f23d2a8c4ac4b125f5fe362", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=055bcfeedad2c54d2abbf2dc85f50565defc92f0", "patch": "@@ -1,3 +1,12 @@\n+2000-08-12  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sibcall.c (uses_addressof): Accept both addressof and\n+\tcurrent_function_internal_arg_pointer inside a mem.\n+\t(optimize_sibling_and_tail_recursive_call): Fail tail recursion\n+\tif current_function_uses_addressof.\n+\t* stmt.c (expand_return): Kill tail recursion and HAVE_return\n+\toptimizations.\n+\n 2000-08-11  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64.md (addsi3): Remove expander."}, {"sha": "42a9d70fb815a3ef35a8e1e40b3a76f643022672", "filename": "gcc/sibcall.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=055bcfeedad2c54d2abbf2dc85f50565defc92f0", "patch": "@@ -37,7 +37,7 @@ static rtx skip_copy_to_return_value\tPARAMS ((rtx, rtx, rtx));\n static rtx skip_use_of_return_value\tPARAMS ((rtx, enum rtx_code));\n static rtx skip_stack_adjustment\tPARAMS ((rtx));\n static rtx skip_jump_insn\t\tPARAMS ((rtx));\n-static int uses_addressof\t\tPARAMS ((rtx, int));\n+static int uses_addressof\t\tPARAMS ((rtx));\n static int sequence_uses_addressof\tPARAMS ((rtx));\n static void purge_reg_equiv_notes\tPARAMS ((void));\n \n@@ -237,16 +237,12 @@ skip_jump_insn (orig_insn)\n \n /* Scan the rtx X for ADDRESSOF expressions or\n    current_function_internal_arg_pointer registers.\n-   INMEM argument should be 1 if we're looking at inner part of some\n-   MEM expression, otherwise 0.\n-   Return nonzero if an ADDRESSOF expresion is found or if\n-   current_function_internal_arg_pointer is found outside of some MEM\n-   expression, else return zero.  */\n+   Return nonzero if an ADDRESSOF or current_function_internal_arg_pointer\n+   is found outside of some MEM expression, else return zero.  */\n \n static int\n-uses_addressof (x, inmem)\n+uses_addressof (x)\n      rtx x;\n-     int inmem;\n {\n   RTX_CODE code;\n   int i, j;\n@@ -257,28 +253,25 @@ uses_addressof (x, inmem)\n \n   code = GET_CODE (x);\n \n-  if (code == ADDRESSOF)\n-    return 1;\n-\n-  if (x == current_function_internal_arg_pointer && ! inmem)\n+  if (code == ADDRESSOF || x == current_function_internal_arg_pointer)\n     return 1;\n \n   if (code == MEM)\n-    return uses_addressof (XEXP (x, 0), 1);\n+    return 0;\n \n   /* Scan all subexpressions. */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  if (uses_addressof (XEXP (x, i), inmem))\n+\t  if (uses_addressof (XEXP (x, i)))\n \t    return 1;\n \t}\n       else if (*fmt == 'E')\n \t{\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (uses_addressof (XVECEXP (x, i, j), inmem))\n+\t    if (uses_addressof (XVECEXP (x, i, j)))\n \t      return 1;\n \t}\n     }\n@@ -318,8 +311,8 @@ sequence_uses_addressof (seq)\n \t\t&& sequence_uses_addressof (XEXP (PATTERN (insn), 2)))\n \t      return 1;\n \t  }\n-\telse if (uses_addressof (PATTERN (insn), 0)\n-\t\t || (REG_NOTES (insn) && uses_addressof (REG_NOTES (insn), 0)))\n+\telse if (uses_addressof (PATTERN (insn))\n+\t\t || (REG_NOTES (insn) && uses_addressof (REG_NOTES (insn))))\n \t  return 1;\n       }\n   return 0;\n@@ -490,14 +483,16 @@ optimize_sibling_and_tail_recursive_calls ()\n \t  if (frame_offset)\n \t    goto failure;\n \n+\t  /* Taking the address of a local variable is fatal to tail\n+\t     recursion if the address is used by the recursive call.  */\n+\t  if (current_function_uses_addressof)\n+\t    goto failure;\n+\n \t  /* alloca (until we have stack slot life analysis) inhibits\n \t     sibling call optimizations, but not tail recursion.\n-\n-\t     Similarly if we have ADDRESSOF expressions.\n-\n \t     Similarly if we use varargs or stdarg since they implicitly\n \t     may take the address of an argument.  */\n- \t  if (current_function_calls_alloca || current_function_uses_addressof\n+ \t  if (current_function_calls_alloca\n \t      || current_function_varargs || current_function_stdarg)\n \t    sibcall = 0;\n "}, {"sha": "38572ca6fe86eb8ffe25dcccaf0dfd6891741017", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/055bcfeedad2c54d2abbf2dc85f50565defc92f0/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=055bcfeedad2c54d2abbf2dc85f50565defc92f0", "patch": "@@ -2809,9 +2809,6 @@ expand_return (retval)\n   rtx last_insn = 0;\n   rtx result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n   register rtx val = 0;\n-#ifdef HAVE_return\n-  register rtx op0;\n-#endif\n   tree retval_rhs;\n   int cleanups;\n \n@@ -2885,82 +2882,6 @@ expand_return (retval)\n       return;\n     }\n \n-  /* Attempt to optimize the call if it is tail recursive.  */\n-  if (flag_optimize_sibling_calls\n-      && retval_rhs != NULL_TREE\n-      && frame_offset == 0\n-      && TREE_CODE (retval_rhs) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (retval_rhs, 0)) == ADDR_EXPR\n-      && (TREE_OPERAND (TREE_OPERAND (retval_rhs, 0), 0)\n-\t  == current_function_decl)\n-      && optimize_tail_recursion (TREE_OPERAND (retval_rhs, 1), last_insn))\n-    return;\n-\n-#ifdef HAVE_return\n-  /* This optimization is safe if there are local cleanups\n-     because expand_null_return takes care of them.\n-     ??? I think it should also be safe when there is a cleanup label,\n-     because expand_null_return takes care of them, too.\n-     Any reason why not?  */\n-  if (HAVE_return && cleanup_label == 0\n-      && ! current_function_returns_pcc_struct\n-      && BRANCH_COST <= 1)\n-    {\n-      /* If this is  return x == y;  then generate\n-\t if (x == y) return 1; else return 0;\n-\t if we can do it with explicit return insns and branches are cheap,\n-\t but not if we have the corresponding scc insn.  */\n-      int has_scc = 0;\n-      if (retval_rhs)\n-\tswitch (TREE_CODE (retval_rhs))\n-\t  {\n-\t  case EQ_EXPR:\n-#ifdef HAVE_seq\n-\t    has_scc = HAVE_seq;\n-#endif\n-\t  case NE_EXPR:\n-#ifdef HAVE_sne\n-\t    has_scc = HAVE_sne;\n-#endif\n-\t  case GT_EXPR:\n-#ifdef HAVE_sgt\n-\t    has_scc = HAVE_sgt;\n-#endif\n-\t  case GE_EXPR:\n-#ifdef HAVE_sge\n-\t    has_scc = HAVE_sge;\n-#endif\n-\t  case LT_EXPR:\n-#ifdef HAVE_slt\n-\t    has_scc = HAVE_slt;\n-#endif\n-\t  case LE_EXPR:\n-#ifdef HAVE_sle\n-\t    has_scc = HAVE_sle;\n-#endif\n-\t  case TRUTH_ANDIF_EXPR:\n-\t  case TRUTH_ORIF_EXPR:\n-\t  case TRUTH_AND_EXPR:\n-\t  case TRUTH_OR_EXPR:\n-\t  case TRUTH_NOT_EXPR:\n-\t  case TRUTH_XOR_EXPR:\n-\t    if (! has_scc)\n-\t      {\n-\t\top0 = gen_label_rtx ();\n-\t\tjumpifnot (retval_rhs, op0);\n-\t\texpand_value_return (const1_rtx);\n-\t\temit_label (op0);\n-\t\texpand_value_return (const0_rtx);\n-\t\treturn;\n-\t      }\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-    }\n-#endif /* HAVE_return */\n-\n   /* If the result is an aggregate that is being returned in one (or more)\n      registers, load the registers here.  The compiler currently can't handle\n      copying a BLKmode value into registers.  We could put this code in a"}]}