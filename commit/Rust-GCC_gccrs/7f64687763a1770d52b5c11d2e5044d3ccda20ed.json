{"sha": "7f64687763a1770d52b5c11d2e5044d3ccda20ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y2NDY4Nzc2M2ExNzcwZDUyYjVjMTFkMmU1MDQ0ZDNjY2RhMjBlZA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2001-07-28T03:13:34Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-07-28T03:13:34Z"}, "message": "ifcvt.c (noce_get_alt_condition): If the condition is a compare against a constant...\n\n* ifcvt.c (noce_get_alt_condition): If the condition is a compare\nagainst a constant, try to adjust the compare to have the desired\nconstant in it so that min/max optimizations happen more often.\n\nFrom-SVN: r44435", "tree": {"sha": "b6602dcfbcbb2441cb51d0b3db365bfa56c733e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6602dcfbcbb2441cb51d0b3db365bfa56c733e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f64687763a1770d52b5c11d2e5044d3ccda20ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f64687763a1770d52b5c11d2e5044d3ccda20ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f64687763a1770d52b5c11d2e5044d3ccda20ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f64687763a1770d52b5c11d2e5044d3ccda20ed/comments", "author": null, "committer": null, "parents": [{"sha": "da397f8ed09544229b06599cb2878421a2844670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da397f8ed09544229b06599cb2878421a2844670", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da397f8ed09544229b06599cb2878421a2844670"}], "stats": {"total": 116, "additions": 115, "deletions": 1}, "files": [{"sha": "6b0f4f7118a794a5492dcf2de0aefda801036fc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f64687763a1770d52b5c11d2e5044d3ccda20ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f64687763a1770d52b5c11d2e5044d3ccda20ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f64687763a1770d52b5c11d2e5044d3ccda20ed", "patch": "@@ -1,3 +1,9 @@\n+2001-07-27  DJ Delorie  <dj@redhat.com>\n+\n+\t* ifcvt.c (noce_get_alt_condition): If the condition is a compare\n+\tagainst a constant, try to adjust the compare to have the desired\n+\tconstant in it so that min/max optimizations happen more often.\n+\n Fri Jul 27 17:53:00 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (last_loop_beg_note): New function."}, {"sha": "4de879d7d82648f4fa45ed1eed21d7d785c37b92", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f64687763a1770d52b5c11d2e5044d3ccda20ed/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f64687763a1770d52b5c11d2e5044d3ccda20ed/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=7f64687763a1770d52b5c11d2e5044d3ccda20ed", "patch": "@@ -1,5 +1,5 @@\n /* If-conversion support.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n \n    This file is part of GNU CC.\n \n@@ -1150,6 +1150,114 @@ noce_get_alt_condition (if_info, target, earliest)\n     = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n       && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (if_info->jump);\n \n+  /* If we're looking for a constant, try to make the conditional\n+     have that constant in it.  There are two reasons why it may\n+     not have the constant we want:\n+\n+     1. GCC may have needed to put the constant in a register, because\n+        the target can't compare directly against that constant.  For\n+        this case, we look for a SET immediately before the comparison\n+        that puts a constant in that register.\n+\n+     2. GCC may have canonicalized the conditional, for example\n+\treplacing \"if x < 4\" with \"if x <= 3\".  We can undo that (or\n+\tmake equivalent types of changes) to get the constants we need\n+\tif they're off by one in the right direction.  */\n+\n+  if (GET_CODE (target) == CONST_INT)\n+    {\n+      enum rtx_code code = GET_CODE (if_info->cond);\n+      rtx op_a = XEXP (if_info->cond, 0);\n+      rtx op_b = XEXP (if_info->cond, 1);\n+      rtx prev_insn;\n+\n+      /* First, look to see if we put a constant in a register.  */\n+      prev_insn = PREV_INSN (if_info->cond_earliest);\n+      if (prev_insn\n+\t  && INSN_P (prev_insn)\n+\t  && GET_CODE (PATTERN (prev_insn)) == SET)\n+\t{\n+\t  rtx src = find_reg_equal_equiv_note (prev_insn);\n+\t  if (!src)\n+\t    src = SET_SRC (PATTERN (prev_insn));\n+\t  if (GET_CODE (src) == CONST_INT)\n+\t    {\n+\t      if (rtx_equal_p (op_a, SET_DEST (PATTERN (prev_insn))))\n+\t\t{\n+\t\t  op_a = src;\n+\t\t  if_info->cond_earliest = prev_insn;\n+\t\t}\n+\t      else if (rtx_equal_p (op_b, SET_DEST (PATTERN (prev_insn))))\n+\t\t{\n+\t\t  op_b = src;\n+\t\t  if_info->cond_earliest = prev_insn;\n+\t\t}\n+\n+\t      if (GET_CODE (op_a) == CONST_INT)\n+\t\t{\n+\t\t  rtx tmp = op_a;\n+\t\t  op_a = op_b;\n+\t\t  op_b = tmp;\n+\t\t  code = swap_condition (code);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Now, look to see if we can get the right constant by\n+\t adjusting the conditional.  */\n+      if (GET_CODE (op_b) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT desired_val = INTVAL (target);\n+\t  HOST_WIDE_INT actual_val = INTVAL (op_b);\n+\n+\t  switch (code)\n+\t    {\n+\t    case LT:\n+\t      if (actual_val == desired_val + 1)\n+\t\t{\n+\t\t  code = LE;\n+\t\t  op_b = GEN_INT (desired_val);\n+\t\t}\n+\t      break;\n+\t    case LE:\n+\t      if (actual_val == desired_val - 1)\n+\t\t{\n+\t\t  code = LT;\n+\t\t  op_b = GEN_INT (desired_val);\n+\t\t}\n+\t      break;\n+\t    case GT:\n+\t      if (actual_val == desired_val - 1)\n+\t\t{\n+\t\t  code = GE;\n+\t\t  op_b = GEN_INT (desired_val);\n+\t\t}\n+\t      break;\n+\t    case GE:\n+\t      if (actual_val == desired_val + 1)\n+\t\t{\n+\t\t  code = GT;\n+\t\t  op_b = GEN_INT (desired_val);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* If we made any changes, generate a new conditional that is\n+\t equivalent to what we started with, but has the right\n+\t constants in it.  */\n+      if (code != GET_CODE (if_info->cond)\n+\t  || op_a != XEXP (if_info->cond, 0)\n+\t  || op_b != XEXP (if_info->cond, 1))\n+\t{\n+\t  cond = gen_rtx_fmt_ee (code, GET_MODE (cond), op_a, op_b);\n+\t  *earliest = if_info->cond_earliest;\n+\t  return cond;\n+\t}\n+    }\n+\n   cond = canonicalize_condition (if_info->jump, cond, reverse,\n \t\t\t\t earliest, target);\n   if (! cond || ! reg_mentioned_p (target, cond))"}]}