{"sha": "2f1bb00ba340e53663651be7874011fd54e1d085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxYmIwMGJhMzQwZTUzNjYzNjUxYmU3ODc0MDExZmQ1NGUxZDA4NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-05T15:47:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-05-14T16:11:12Z"}, "message": "c++: simplify enclosing_instantiation_of [PR95870]\n\nComparing DECL_SOURCE_LOCATION like the GCC 11 patch for PR 95870 will also\nwork for user-defined functions, if we update their location when\ninstantiating.  Another option would be to use LAMBDA_EXPR_REGEN_INFO for\nlambdas, but this way is even simpler.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95870\n\t* pt.c (enclosing_instantiation_of): Just compare\n\tDECL_SOURCE_LOCATION.\n\t(regenerate_decl_from_template): Copy DECL_SOURCE_LOCATION.", "tree": {"sha": "bb93915785935c106428d2d2a34463e19e235abf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb93915785935c106428d2d2a34463e19e235abf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f1bb00ba340e53663651be7874011fd54e1d085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1bb00ba340e53663651be7874011fd54e1d085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1bb00ba340e53663651be7874011fd54e1d085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1bb00ba340e53663651be7874011fd54e1d085/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff863ab01640d181c3afb73c99701664efa7e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff863ab01640d181c3afb73c99701664efa7e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff863ab01640d181c3afb73c99701664efa7e7a"}], "stats": {"total": 54, "additions": 12, "deletions": 42}, "files": [{"sha": "bf996358328cdec333ad66078b7669d0f83bf84c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1bb00ba340e53663651be7874011fd54e1d085/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1bb00ba340e53663651be7874011fd54e1d085/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2f1bb00ba340e53663651be7874011fd54e1d085", "patch": "@@ -14437,55 +14437,22 @@ most_general_lambda (tree t)\n }\n \n /* We're instantiating a variable from template function TCTX.  Return the\n-   corresponding current enclosing scope.  This gets complicated because lambda\n-   functions in templates are regenerated rather than instantiated, but generic\n-   lambda functions are subsequently instantiated.  */\n+   corresponding current enclosing scope.  We can match them up using\n+   DECL_SOURCE_LOCATION because lambdas only ever have one source location, and\n+   the DECL_SOURCE_LOCATION for a function instantiation is updated to match\n+   the template definition in regenerate_decl_from_template.  */\n \n static tree\n-enclosing_instantiation_of (tree otctx)\n+enclosing_instantiation_of (tree tctx)\n {\n-  tree tctx = otctx;\n   tree fn = current_function_decl;\n-  int lambda_count = 0;\n \n-  for (; tctx && (lambda_fn_in_template_p (tctx)\n-\t\t  || regenerated_lambda_fn_p (tctx));\n-       tctx = decl_function_context (tctx))\n-    ++lambda_count;\n-\n-  if (!tctx)\n-    {\n-      /* Match using DECL_SOURCE_LOCATION, which is unique for all lambdas.\n-\n-\t For GCC 11 the above condition limits this to the previously failing\n-\t case where all enclosing functions are lambdas (95870).  FIXME.  */\n-      for (tree ofn = fn; ofn; ofn = decl_function_context (ofn))\n-\tif (DECL_SOURCE_LOCATION (ofn) == DECL_SOURCE_LOCATION (otctx))\n-\t  return ofn;\n-      gcc_unreachable ();\n-    }\n+  /* We shouldn't ever need to do this for other artificial functions.  */\n+  gcc_assert (!DECL_ARTIFICIAL (tctx) || LAMBDA_FUNCTION_P (tctx));\n \n   for (; fn; fn = decl_function_context (fn))\n-    {\n-      tree ofn = fn;\n-      int flambda_count = 0;\n-      for (; fn && regenerated_lambda_fn_p (fn);\n-\t   fn = decl_function_context (fn))\n-\t++flambda_count;\n-      if ((fn && DECL_TEMPLATE_INFO (fn))\n-\t  ? most_general_template (fn) != most_general_template (tctx)\n-\t  : fn != tctx)\n-\tcontinue;\n-      if (flambda_count != lambda_count)\n-\t{\n-\t  gcc_assert (flambda_count > lambda_count);\n-\t  for (; flambda_count > lambda_count; --flambda_count)\n-\t    ofn = decl_function_context (ofn);\n-\t}\n-      gcc_assert (DECL_NAME (ofn) == DECL_NAME (otctx)\n-\t\t  || DECL_CONV_FN_P (ofn));\n-      return ofn;\n-    }\n+    if (DECL_SOURCE_LOCATION (fn) == DECL_SOURCE_LOCATION (tctx))\n+      return fn;\n   gcc_unreachable ();\n }\n \n@@ -25492,6 +25459,9 @@ regenerate_decl_from_template (tree decl, tree tmpl, tree args)\n       int args_depth;\n       int parms_depth;\n \n+      /* Use the source location of the definition.  */\n+      DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (tmpl);\n+\n       args_depth = TMPL_ARGS_DEPTH (args);\n       parms_depth = TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl));\n       if (args_depth > parms_depth)"}]}