{"sha": "2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFjMmYxNjQ3ZGJjNjA5ZTJjN2FlOGI1ODAxMmUxNGVlZWZkNzY5OA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-10-08T10:21:42Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-10-08T10:21:42Z"}, "message": "c-typeck.c (enum impl_conv): New.\n\n\t* c-typeck.c (enum impl_conv): New.\n\t(convert_for_assignment): Use it.  Take tree for function called\n\tinstead of its name.  Handle ObjC selectors for diagnostics at\n\tstart of function.  Select diagnostic text within the function\n\tusing full sentences for diagnsotics.  Use %qE to name functions\n\tin diagnostics.\n\t(convert_arguments, build_modify_expr,\n\tc_convert_parm_for_inlining, digest_init, c_finish_return): Update\n\tcallers to convert_for_assignment.\n\t(warn_for_assignment): Remove.\n\ntestsuite:\n\t* gcc.dg/assign-warn-1.c, gcc.dg/assign-warn-2.c: New tests.\n\t* gcc.dg/warn-1.c, gcc.dg/noncompile/20020213-1.c,\n\tobjc.dg/method-9.m: Update expected diagnostics.\n\nFrom-SVN: r88741", "tree": {"sha": "25377bd40c2e1609d1b911592b00902eb3f045f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25377bd40c2e1609d1b911592b00902eb3f045f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "710acc5772a2f5da08b7c8ff66862f8966ecadf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710acc5772a2f5da08b7c8ff66862f8966ecadf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710acc5772a2f5da08b7c8ff66862f8966ecadf5"}], "stats": {"total": 548, "additions": 436, "deletions": 112}, "files": [{"sha": "2c0a9055724a52a43157e335b211f459a9f7d9ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -1,3 +1,16 @@\n+2004-10-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-typeck.c (enum impl_conv): New.\n+\t(convert_for_assignment): Use it.  Take tree for function called\n+\tinstead of its name.  Handle ObjC selectors for diagnostics at\n+\tstart of function.  Select diagnostic text within the function\n+\tusing full sentences for diagnsotics.  Use %qE to name functions\n+\tin diagnostics.\n+\t(convert_arguments, build_modify_expr,\n+\tc_convert_parm_for_inlining, digest_init, c_finish_return): Update\n+\tcallers to convert_for_assignment.\n+\t(warn_for_assignment): Remove.\n+\n 2004-10-08  Nick Clifton  <nickc@redhat.com>\n \n \t* config/sh/symbian.c (symbian_possibly_export_base_class):"}, {"sha": "64669c88ca38c1f450ba9fe77f063e282ea6e561", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 163, "deletions": 105, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -55,6 +55,15 @@ enum lvalue_use {\n   lv_asm\n };\n \n+/* Possible cases of implicit bad conversions.  Used to select\n+   diagnostic messages in convert_for_assignment.  */\n+enum impl_conv {\n+  ic_argpass,\n+  ic_assign,\n+  ic_init,\n+  ic_return\n+};\n+\n /* The level of nesting inside \"__alignof__\".  */\n int in_alignof;\n \n@@ -81,9 +90,8 @@ static tree default_function_array_conversion (tree);\n static tree lookup_field (tree, tree);\n static tree convert_arguments (tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n-static tree convert_for_assignment (tree, tree, const char *, tree, tree,\n+static tree convert_for_assignment (tree, tree, enum impl_conv, tree, tree,\n \t\t\t\t    int);\n-static void warn_for_assignment (const char *, const char *, tree, int);\n static tree valid_compound_expr_initializer (tree, tree);\n static void push_string (const char *);\n static void push_member_name (tree);\n@@ -2029,16 +2037,12 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n   tree result = NULL;\n   int parmnum;\n   tree selector;\n-  tree name = NULL_TREE;\n \n-  /* Determine the function name for the use of convert_for_assignment\n-     and warn_for_assignment called from there.  */\n+  /* Change pointer to function to the function itself for\n+     diagnostics.  */\n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n-    {\n-      function = TREE_OPERAND (function, 0);\n-      name = DECL_NAME (function);\n-    }\n+    function = TREE_OPERAND (function, 0);\n \n   /* Handle an ObjC selector specially for diagnostics.  */\n   selector = objc_message_selector ();\n@@ -2189,9 +2193,9 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t\t    }\n \t\t}\n \n-\t      parmval = convert_for_assignment (type, val,\n-\t\t\t\t\t        (char *) 0, /* arg passing  */\n-\t\t\t\t\t\tfundecl, name, parmnum + 1);\n+\t      parmval = convert_for_assignment (type, val, ic_argpass,\n+\t\t\t\t\t\tfundecl, function,\n+\t\t\t\t\t\tparmnum + 1);\n \n \t      if (targetm.calls.promote_prototypes (fundecl ? TREE_TYPE (fundecl) : 0)\n \t\t  && INTEGRAL_TYPE_P (type)\n@@ -3390,7 +3394,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n   /* Convert new value to destination type.  */\n \n-  newrhs = convert_for_assignment (lhstype, newrhs, _(\"assignment\"),\n+  newrhs = convert_for_assignment (lhstype, newrhs, ic_assign,\n \t\t\t\t   NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n@@ -3407,7 +3411,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n   if (olhstype == TREE_TYPE (result))\n     return result;\n-  return convert_for_assignment (olhstype, result, _(\"assignment\"),\n+  return convert_for_assignment (olhstype, result, ic_assign,\n \t\t\t\t NULL_TREE, NULL_TREE, 0);\n }\n \f\n@@ -3416,21 +3420,63 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n    The real work of conversion is done by `convert'.\n    The purpose of this function is to generate error messages\n    for assignments that are not allowed in C.\n-   ERRTYPE is a string to use in error messages:\n-   \"assignment\", \"return\", etc.  If it is null, this is parameter passing\n-   for a function call (and different error messages are output).\n+   ERRTYPE says whether it is argument passing, assignment,\n+   initialization or return.\n \n-   FUNNAME is the name of the function being called,\n-   as an IDENTIFIER_NODE, or null.\n+   FUNCTION is a tree for the function being called.\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (tree type, tree rhs, const char *errtype,\n-\t\t\ttree fundecl, tree funname, int parmnum)\n+convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n+\t\t\ttree fundecl, tree function, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree rhstype;\n   enum tree_code coder;\n+  tree rname = NULL_TREE;\n+\n+  if (errtype == ic_argpass)\n+    {\n+      tree selector;\n+      /* Change pointer to function to the function itself for\n+\t diagnostics.  */\n+      if (TREE_CODE (function) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n+\tfunction = TREE_OPERAND (function, 0);\n+\n+      /* Handle an ObjC selector specially for diagnostics.  */\n+      selector = objc_message_selector ();\n+      rname = function;\n+      if (selector && parmnum > 2)\n+\t{\n+\t  rname = selector;\n+\t  parmnum -= 2;\n+\t}\n+    }\n+\n+  /* This macro is used to emit diagnostics to ensure that all format\n+     strings are complete sentences, visible to gettext and checked at\n+     compile time.  */\n+#define WARN_FOR_ASSIGNMENT(AR, AS, IN, RE)\t\\\n+  do {\t\t\t\t\t\t\\\n+    switch (errtype)\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+      case ic_argpass:\t\t\t\t\\\n+\tpedwarn (AR, parmnum, rname);\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      case ic_assign:\t\t\t\t\\\n+\tpedwarn (AS);\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      case ic_init:\t\t\t\t\\\n+\tpedwarn (IN);\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      case ic_return:\t\t\t\t\\\n+\tpedwarn (RE);\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\\\n+      default:\t\t\t\t\t\\\n+\tgcc_unreachable ();\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  } while (0)\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   /* Do not use STRIP_NOPS here.  We do not want an enumerator\n@@ -3507,7 +3553,8 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \n   /* Conversion to a transparent union from its member types.\n      This applies only to function arguments.  */\n-  else if (codel == UNION_TYPE && TYPE_TRANSPARENT_UNION (type) && !errtype)\n+  else if (codel == UNION_TYPE && TYPE_TRANSPARENT_UNION (type)\n+\t   && errtype == ic_argpass)\n     {\n       tree memb_types;\n       tree marginal_memb_type = 0;\n@@ -3582,13 +3629,27 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t     function where an ordinary one is wanted, but not\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\t    warn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n-\t\t\t\t\t errtype, funname, parmnum);\n+\t\t    WARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE \"\n+\t\t\t\t\t    \"makes qualified function \"\n+\t\t\t\t\t    \"pointer from unqualified\"),\n+\t\t\t\t\t N_(\"assignment makes qualified \"\n+\t\t\t\t\t    \"function pointer from \"\n+\t\t\t\t\t    \"unqualified\"),\n+\t\t\t\t\t N_(\"initialization makes qualified \"\n+\t\t\t\t\t    \"function pointer from \"\n+\t\t\t\t\t    \"unqualified\"),\n+\t\t\t\t\t N_(\"return makes qualified function \"\n+\t\t\t\t\t    \"pointer from unqualified\"));\n \t\t}\n \t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n-\t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n-\t\t\t\t     errtype, funname,\n-\t\t\t\t     parmnum);\n+\t\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t\"qualifiers from pointer target type\"),\n+\t\t\t\t     N_(\"assignment discards qualifiers \"\n+\t\t\t\t\t\"from pointer target type\"),\n+\t\t\t\t     N_(\"initialization discards qualifiers \"\n+\t\t\t\t\t\"from pointer target type\"),\n+\t\t\t\t     N_(\"return discards qualifiers from \"\n+\t\t\t\t\t\"pointer target type\"));\n \t    }\n \n \t  if (pedantic && !DECL_IN_SYSTEM_HEADER (fundecl))\n@@ -3630,26 +3691,44 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t      which are not ANSI null ptr constants.  */\n \t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    warn_for_assignment (\"ISO C forbids %s between function \"\n-\t\t\t\t \"pointer and %<void *%>\",\n-\t\t\t\t errtype, funname, parmnum);\n+\t    WARN_FOR_ASSIGNMENT (N_(\"ISO C forbids passing argument %d of \"\n+\t\t\t\t    \"%qE between function pointer \"\n+\t\t\t\t    \"and %<void *%>\"),\n+\t\t\t\t N_(\"ISO C forbids assignment between \"\n+\t\t\t\t    \"function pointer and %<void *%>\"),\n+\t\t\t\t N_(\"ISO C forbids initialization between \"\n+\t\t\t\t    \"function pointer and %<void *%>\"),\n+\t\t\t\t N_(\"ISO C forbids return between function \"\n+\t\t\t\t    \"pointer and %<void *%>\"));\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n \t      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n-\t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t\"qualifiers from pointer target type\"),\n+\t\t\t\t     N_(\"assignment discards qualifiers \"\n+\t\t\t\t\t\"from pointer target type\"),\n+\t\t\t\t     N_(\"initialization discards qualifiers \"\n+\t\t\t\t\t\"from pointer target type\"),\n+\t\t\t\t     N_(\"return discards qualifiers from \"\n+\t\t\t\t\t\"pointer target type\"));\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n \t      else if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n \t\t       || target_cmp)\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else\n-\t\twarn_for_assignment (\"pointer targets in %s differ in signedness\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\tWARN_FOR_ASSIGNMENT (N_(\"pointer targets in passing argument \"\n+\t\t\t\t\t\"%d of %qE differ in signedness\"),\n+\t\t\t\t     N_(\"pointer targets in assignment \"\n+\t\t\t\t\t\"differ in signedness\"),\n+\t\t\t\t     N_(\"pointer targets in initialization \"\n+\t\t\t\t\t\"differ in signedness\"),\n+\t\t\t\t     N_(\"pointer targets in return differ \"\n+\t\t\t\t\t\"in signedness\"));\n \t    }\n \t  else if (TREE_CODE (ttl) == FUNCTION_TYPE\n \t\t   && TREE_CODE (ttr) == FUNCTION_TYPE)\n@@ -3659,13 +3738,24 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t it is okay to use a const or volatile function\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\twarn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n-\t\t\t\t     errtype, funname, parmnum);\n+\t\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE makes \"\n+\t\t\t\t\t\"qualified function pointer \"\n+\t\t\t\t\t\"from unqualified\"),\n+\t\t\t\t     N_(\"assignment makes qualified function \"\n+\t\t\t\t\t\"pointer from unqualified\"),\n+\t\t\t\t     N_(\"initialization makes qualified \"\n+\t\t\t\t\t\"function pointer from unqualified\"),\n+\t\t\t\t     N_(\"return makes qualified function \"\n+\t\t\t\t\t\"pointer from unqualified\"));\n \t    }\n \t}\n       else\n-\twarn_for_assignment (\"%s from incompatible pointer type\",\n-\t\t\t     errtype, funname, parmnum);\n+\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE from \"\n+\t\t\t\t\"incompatible pointer type\"),\n+\t\t\t     N_(\"assignment from incompatible pointer type\"),\n+\t\t\t     N_(\"initialization from incompatible \"\n+\t\t\t\t\"pointer type\"),\n+\t\t\t     N_(\"return from incompatible pointer type\"));\n       return convert (type, rhs);\n     }\n   else if (codel == POINTER_TYPE && coder == ARRAY_TYPE)\n@@ -3684,39 +3774,49 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t    && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n \t    && TREE_CODE (TREE_OPERAND (rhs, 0)) == INTEGER_CST\n \t    && integer_zerop (TREE_OPERAND (rhs, 0))))\n-\t  warn_for_assignment (\"%s makes pointer from integer without a cast\",\n-\t\t\t       errtype, funname, parmnum);\n+\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE makes \"\n+\t\t\t\t\"pointer from integer without a cast\"),\n+\t\t\t     N_(\"assignment makes pointer from integer \"\n+\t\t\t\t\"without a cast\"),\n+\t\t\t     N_(\"initialization makes pointer from \"\n+\t\t\t\t\"integer without a cast\"),\n+\t\t\t     N_(\"return makes pointer from integer \"\n+\t\t\t\t\"without a cast\"));\n \n       return convert (type, rhs);\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n-      warn_for_assignment (\"%s makes integer from pointer without a cast\",\n-\t\t\t   errtype, funname, parmnum);\n+      WARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE makes integer \"\n+\t\t\t      \"from pointer without a cast\"),\n+\t\t\t   N_(\"assignment makes integer from pointer \"\n+\t\t\t      \"without a cast\"),\n+\t\t\t   N_(\"initialization makes integer from pointer \"\n+\t\t\t      \"without a cast\"),\n+\t\t\t   N_(\"return makes integer from pointer \"\n+\t\t\t      \"without a cast\"));\n       return convert (type, rhs);\n     }\n   else if (codel == BOOLEAN_TYPE && coder == POINTER_TYPE)\n     return convert (type, rhs);\n \n-  if (!errtype)\n+  switch (errtype)\n     {\n-      if (funname)\n-\t{\n-\t  tree selector = objc_message_selector ();\n-\n-\t  if (selector && parmnum > 2)\n-\t    error (\"incompatible type for argument %d of %qs\",\n-\t\t   parmnum - 2, IDENTIFIER_POINTER (selector));\n-\t  else\n-\t    error (\"incompatible type for argument %d of %qs\",\n-\t\t   parmnum, IDENTIFIER_POINTER (funname));\n-\t}\n-      else\n-\terror (\"incompatible type for argument %d of indirect function call\",\n-\t       parmnum);\n+    case ic_argpass:\n+      error (\"incompatible type for argument %d of %qE\", parmnum, rname);\n+      break;\n+    case ic_assign:\n+      error (\"incompatible types in assignment\");\n+      break;\n+    case ic_init:\n+      error (\"incompatible types in initialization\");\n+      break;\n+    case ic_return:\n+      error (\"incompatible types in return\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    error (\"incompatible types in %s\", errtype);\n \n   return error_mark_node;\n }\n@@ -3737,56 +3837,14 @@ c_convert_parm_for_inlining (tree parm, tree value, tree fn, int argnum)\n \n   type = TREE_TYPE (parm);\n   ret = convert_for_assignment (type, value,\n-\t\t\t\t(char *) 0 /* arg passing  */, fn,\n-\t\t\t\tDECL_NAME (fn), argnum);\n+\t\t\t\tic_argpass, fn,\n+\t\t\t\tfn, argnum);\n   if (targetm.calls.promote_prototypes (TREE_TYPE (fn))\n       && INTEGRAL_TYPE_P (type)\n       && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n     ret = default_conversion (ret);\n   return ret;\n }\n-\n-/* Print a warning using MSGID.\n-   It gets OPNAME as its one parameter.\n-   If OPNAME is null, it is replaced by \"passing arg ARGNUM of 'FUNCTION'\".\n-   FUNCTION and ARGNUM are handled specially if we are building an\n-   Objective-C selector.  */\n-\n-static void\n-warn_for_assignment (const char *msgid, const char *opname, tree function,\n-\t\t     int argnum)\n-{\n-  if (opname == 0)\n-    {\n-      tree selector = objc_message_selector ();\n-      char * new_opname;\n-\n-      if (selector && argnum > 2)\n-\t{\n-\t  function = selector;\n-\t  argnum -= 2;\n-\t}\n-      gcc_assert (argnum > 0);\n-      if (function)\n-\t{\n-\t  /* Function name is known; supply it.  */\n-\t  const char *const argstring = _(\"passing arg %d of '%s'\");\n-\t  new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n-\t\t\t       + strlen (argstring) + 1 + 25 /*%d*/ + 1);\n-\t  sprintf (new_opname, argstring, argnum,\n-\t\t   IDENTIFIER_POINTER (function));\n-\t}\n-      else\n-\t{\n-\t  /* Function name unknown (call through ptr); just give arg number.  */\n-\t  const char *const argnofun = _(\"passing arg %d of pointer to function\");\n-\t  new_opname = (char *) alloca (strlen (argnofun) + 1 + 25 /*%d*/ + 1);\n-\t  sprintf (new_opname, argnofun, argnum);\n-\t}\n-      opname = new_opname;\n-    }\n-  pedwarn (msgid, opname);\n-}\n \f\n /* If VALUE is a compound expr all of whose expressions are constant, then\n    return its value.  Otherwise, return error_mark_node.\n@@ -4254,7 +4312,7 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \t for arrays and functions.  We must not call it in the\n \t case where inside_init is a null pointer constant.  */\n       inside_init\n-\t= convert_for_assignment (type, init, _(\"initialization\"),\n+\t= convert_for_assignment (type, init, ic_init,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n       /* Check to see if we have already given an error message.  */\n@@ -6394,7 +6452,7 @@ c_finish_return (tree retval)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (valtype, retval, _(\"return\"),\n+      tree t = convert_for_assignment (valtype, retval, ic_return,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;"}, {"sha": "616e74c2a6013823af7e346ea30ec1327cc7d710", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -1,3 +1,9 @@\n+2004-10-08  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.dg/assign-warn-1.c, gcc.dg/assign-warn-2.c: New tests.\n+\t* gcc.dg/warn-1.c, gcc.dg/noncompile/20020213-1.c,\n+\tobjc.dg/method-9.m: Update expected diagnostics.\n+\n 2004-10-07  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gcc.dg/ppc-fsel-3.c: New file."}, {"sha": "857b1a85333c7da8fed500f92fcbe64fce1843f1", "filename": "gcc/testsuite/gcc.dg/assign-warn-1.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-1.c?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -0,0 +1,123 @@\n+/* Test diagnostics for bad implicit type conversions.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic\" } */\n+\n+#define TESTARG(ID, TL, TR) void ID##F(TL); void ID##F2(TR x) { ID##F(x); } extern int dummy\n+#define TESTARP(ID, TL, TR) struct { void (*x)(TL); } ID##Fp; void ID##F2(TR x) { ID##Fp.x(x); } extern int dummy\n+#define TESTASS(ID, TL, TR) void ID##F(TR x) { TL y; y = x; } extern int dummy\n+#define TESTINI(ID, TL, TR) void ID##F(TR x) { TL y = x; } extern int dummy\n+#define TESTRET(ID, TL, TR) TR ID##V; TL ID##F(void) { return ID##V; } extern int dummy\n+\n+typedef void (*fp)(void);\n+typedef void (*nrfp)(void) __attribute__((noreturn));\n+\n+TESTARG(fqa, nrfp, fp); /* { dg-warning \"warning: passing argument 1 of 'fqaF' makes qualified function pointer from unqualified\" } */\n+TESTARP(fqb, nrfp, fp); /* { dg-warning \"warning: passing argument 1 of 'fqbFp.x' makes qualified function pointer from unqualified\" } */\n+TESTASS(fqc, nrfp, fp); /* { dg-warning \"warning: assignment makes qualified function pointer from unqualified\" } */\n+TESTINI(fqd, nrfp, fp); /* { dg-warning \"warning: initialization makes qualified function pointer from unqualified\" } */\n+TESTRET(fqe, nrfp, fp); /* { dg-warning \"warning: return makes qualified function pointer from unqualified\" } */\n+\n+TESTARG(ofqa, fp, nrfp);\n+TESTARP(ofqb, fp, nrfp);\n+TESTASS(ofqc, fp, nrfp);\n+TESTINI(ofqd, fp, nrfp);\n+TESTRET(ofqe, fp, nrfp);\n+\n+TESTARG(qa, char *, const char *); /* { dg-warning \"warning: passing argument 1 of 'qaF' discards qualifiers from pointer target type\" } */\n+TESTARP(qb, char *, const char *); /* { dg-warning \"warning: passing argument 1 of 'qbFp.x' discards qualifiers from pointer target type\" } */\n+TESTASS(qc, char *, const char *); /* { dg-warning \"warning: assignment discards qualifiers from pointer target type\" } */\n+TESTINI(qd, char *, const char *); /* { dg-warning \"warning: initialization discards qualifiers from pointer target type\" } */\n+TESTRET(qe, char *, const char *); /* { dg-warning \"warning: return discards qualifiers from pointer target type\" } */\n+\n+TESTARG(oqa, const char *, char *);\n+TESTARP(oqb, const char *, char *);\n+TESTASS(oqc, const char *, char *);\n+TESTINI(oqd, const char *, char *);\n+TESTRET(oqe, const char *, char *);\n+\n+TESTARG(fda, fp, void *); /* { dg-warning \"warning: ISO C forbids passing argument 1 of 'fdaF' between function pointer and 'void \\\\*'\" } */\n+TESTARP(fdb, fp, void *); /* { dg-warning \"warning: ISO C forbids passing argument 1 of 'fdbFp.x' between function pointer and 'void \\\\*'\" } */\n+TESTASS(fdc, fp, void *); /* { dg-warning \"warning: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+TESTINI(fdd, fp, void *); /* { dg-warning \"warning: ISO C forbids initialization between function pointer and 'void \\\\*'\" } */\n+TESTRET(fde, fp, void *); /* { dg-warning \"warning: ISO C forbids return between function pointer and 'void \\\\*'\" } */\n+\n+TESTARG(dfa, void *, fp); /* { dg-warning \"warning: ISO C forbids passing argument 1 of 'dfaF' between function pointer and 'void \\\\*'\" } */\n+TESTARP(dfb, void *, fp); /* { dg-warning \"warning: ISO C forbids passing argument 1 of 'dfbFp.x' between function pointer and 'void \\\\*'\" } */\n+TESTASS(dfc, void *, fp); /* { dg-warning \"warning: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+TESTINI(dfd, void *, fp); /* { dg-warning \"warning: ISO C forbids initialization between function pointer and 'void \\\\*'\" } */\n+TESTRET(dfe, void *, fp); /* { dg-warning \"warning: ISO C forbids return between function pointer and 'void \\\\*'\" } */\n+\n+TESTARG(sua, int *, unsigned int *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'suaF' differ in signedness\" } */\n+TESTARP(sub, int *, unsigned int *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'subFp.x' differ in signedness\" } */\n+TESTASS(suc, int *, unsigned int *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(sud, int *, unsigned int *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(sue, int *, unsigned int *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(usa, unsigned int *, int *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'usaF' differ in signedness\" } */\n+TESTARP(usb, unsigned int *, int *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'usbFp.x' differ in signedness\" } */\n+TESTASS(usc, unsigned int *, int *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(usd, unsigned int *, int *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(use, unsigned int *, int *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(cua, char *, unsigned char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'cuaF' differ in signedness\" } */\n+TESTARP(cub, char *, unsigned char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'cubFp.x' differ in signedness\" } */\n+TESTASS(cuc, char *, unsigned char *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(cud, char *, unsigned char *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(cue, char *, unsigned char *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(uca, unsigned char *, char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'ucaF' differ in signedness\" } */\n+TESTARP(ucb, unsigned char *, char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'ucbFp.x' differ in signedness\" } */\n+TESTASS(ucc, unsigned char *, char *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(ucd, unsigned char *, char *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(uce, unsigned char *, char *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(csa, char *, signed char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'csaF' differ in signedness\" } */\n+TESTARP(csb, char *, signed char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'csbFp.x' differ in signedness\" } */\n+TESTASS(csc, char *, signed char *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(csd, char *, signed char *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(cse, char *, signed char *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(sca, signed char *, char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'scaF' differ in signedness\" } */\n+TESTARP(scb, signed char *, char *); /* { dg-warning \"warning: pointer targets in passing argument 1 of 'scbFp.x' differ in signedness\" } */\n+TESTASS(scc, signed char *, char *); /* { dg-warning \"warning: pointer targets in assignment differ in signedness\" } */\n+TESTINI(scd, signed char *, char *); /* { dg-warning \"warning: pointer targets in initialization differ in signedness\" } */\n+TESTRET(sce, signed char *, char *); /* { dg-warning \"warning: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(cia, char *, int *); /* { dg-warning \"warning: passing argument 1 of 'ciaF' from incompatible pointer type\" } */\n+TESTARP(cib, char *, int *); /* { dg-warning \"warning: passing argument 1 of 'cibFp.x' from incompatible pointer type\" } */\n+TESTASS(cic, char *, int *); /* { dg-warning \"warning: assignment from incompatible pointer type\" } */\n+TESTINI(cid, char *, int *); /* { dg-warning \"warning: initialization from incompatible pointer type\" } */\n+TESTRET(cie, char *, int *); /* { dg-warning \"warning: return from incompatible pointer type\" } */\n+\n+TESTARG(ica, int *, char *); /* { dg-warning \"warning: passing argument 1 of 'icaF' from incompatible pointer type\" } */\n+TESTARP(icb, int *, char *); /* { dg-warning \"warning: passing argument 1 of 'icbFp.x' from incompatible pointer type\" } */\n+TESTASS(icc, int *, char *); /* { dg-warning \"warning: assignment from incompatible pointer type\" } */\n+TESTINI(icd, int *, char *); /* { dg-warning \"warning: initialization from incompatible pointer type\" } */\n+TESTRET(ice, int *, char *); /* { dg-warning \"warning: return from incompatible pointer type\" } */\n+\n+TESTARG(ciia, char *, int); /* { dg-warning \"warning: passing argument 1 of 'ciiaF' makes pointer from integer without a cast\" } */\n+TESTARP(ciib, char *, int); /* { dg-warning \"warning: passing argument 1 of 'ciibFp.x' makes pointer from integer without a cast\" } */\n+TESTASS(ciic, char *, int); /* { dg-warning \"warning: assignment makes pointer from integer without a cast\" } */\n+TESTINI(ciid, char *, int); /* { dg-warning \"warning: initialization makes pointer from integer without a cast\" } */\n+TESTRET(ciie, char *, int); /* { dg-warning \"warning: return makes pointer from integer without a cast\" } */\n+\n+TESTARG(iica, int, char *); /* { dg-warning \"warning: passing argument 1 of 'iicaF' makes integer from pointer without a cast\" } */\n+TESTARP(iicb, int, char *); /* { dg-warning \"warning: passing argument 1 of 'iicbFp.x' makes integer from pointer without a cast\" } */\n+TESTASS(iicc, int, char *); /* { dg-warning \"warning: assignment makes integer from pointer without a cast\" } */\n+TESTINI(iicd, int, char *); /* { dg-warning \"warning: initialization makes integer from pointer without a cast\" } */\n+TESTRET(iice, int, char *); /* { dg-warning \"warning: return makes integer from pointer without a cast\" } */\n+\n+struct s { int a; };\n+\n+TESTARG(stria, struct s, int); /* { dg-error \"error: incompatible type for argument 1 of 'striaF'\" } */\n+TESTARP(strib, struct s, int); /* { dg-error \"error: incompatible type for argument 1 of 'stribFp.x'\" } */\n+TESTASS(stric, struct s, int); /* { dg-error \"error: incompatible types in assignment\" } */\n+TESTINI(strid, struct s, int); /* { dg-error \"error: invalid initializer\" } */\n+TESTRET(strie, struct s, int); /* { dg-error \"error: incompatible types in return\" } */\n+\n+TESTARG(istra, int, struct s); /* { dg-error \"error: incompatible type for argument 1 of 'istraF'\" } */\n+TESTARP(istrb, int, struct s); /* { dg-error \"error: incompatible type for argument 1 of 'istrbFp.x'\" } */\n+TESTASS(istrc, int, struct s); /* { dg-error \"error: incompatible types in assignment\" } */\n+TESTINI(istrd, int, struct s); /* { dg-error \"error: incompatible types in initialization\" } */\n+TESTRET(istre, int, struct s); /* { dg-error \"error: incompatible types in return\" } */"}, {"sha": "eae22d1549b91cd3e34caba9a8c1afda6434c56a", "filename": "gcc/testsuite/gcc.dg/assign-warn-2.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fassign-warn-2.c?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -0,0 +1,124 @@\n+/* Test diagnostics for bad implicit type conversions.\n+   -pedantic-errors test.  */\n+/* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors\" } */\n+\n+#define TESTARG(ID, TL, TR) void ID##F(TL); void ID##F2(TR x) { ID##F(x); } extern int dummy\n+#define TESTARP(ID, TL, TR) struct { void (*x)(TL); } ID##Fp; void ID##F2(TR x) { ID##Fp.x(x); } extern int dummy\n+#define TESTASS(ID, TL, TR) void ID##F(TR x) { TL y; y = x; } extern int dummy\n+#define TESTINI(ID, TL, TR) void ID##F(TR x) { TL y = x; } extern int dummy\n+#define TESTRET(ID, TL, TR) TR ID##V; TL ID##F(void) { return ID##V; } extern int dummy\n+\n+typedef void (*fp)(void);\n+typedef void (*nrfp)(void) __attribute__((noreturn));\n+\n+TESTARG(fqa, nrfp, fp); /* { dg-error \"error: passing argument 1 of 'fqaF' makes qualified function pointer from unqualified\" } */\n+TESTARP(fqb, nrfp, fp); /* { dg-error \"error: passing argument 1 of 'fqbFp.x' makes qualified function pointer from unqualified\" } */\n+TESTASS(fqc, nrfp, fp); /* { dg-error \"error: assignment makes qualified function pointer from unqualified\" } */\n+TESTINI(fqd, nrfp, fp); /* { dg-error \"error: initialization makes qualified function pointer from unqualified\" } */\n+TESTRET(fqe, nrfp, fp); /* { dg-error \"error: return makes qualified function pointer from unqualified\" } */\n+\n+TESTARG(ofqa, fp, nrfp);\n+TESTARP(ofqb, fp, nrfp);\n+TESTASS(ofqc, fp, nrfp);\n+TESTINI(ofqd, fp, nrfp);\n+TESTRET(ofqe, fp, nrfp);\n+\n+TESTARG(qa, char *, const char *); /* { dg-error \"error: passing argument 1 of 'qaF' discards qualifiers from pointer target type\" } */\n+TESTARP(qb, char *, const char *); /* { dg-error \"error: passing argument 1 of 'qbFp.x' discards qualifiers from pointer target type\" } */\n+TESTASS(qc, char *, const char *); /* { dg-error \"error: assignment discards qualifiers from pointer target type\" } */\n+TESTINI(qd, char *, const char *); /* { dg-error \"error: initialization discards qualifiers from pointer target type\" } */\n+TESTRET(qe, char *, const char *); /* { dg-error \"error: return discards qualifiers from pointer target type\" } */\n+\n+TESTARG(oqa, const char *, char *);\n+TESTARP(oqb, const char *, char *);\n+TESTASS(oqc, const char *, char *);\n+TESTINI(oqd, const char *, char *);\n+TESTRET(oqe, const char *, char *);\n+\n+TESTARG(fda, fp, void *); /* { dg-error \"error: ISO C forbids passing argument 1 of 'fdaF' between function pointer and 'void \\\\*'\" } */\n+TESTARP(fdb, fp, void *); /* { dg-error \"error: ISO C forbids passing argument 1 of 'fdbFp.x' between function pointer and 'void \\\\*'\" } */\n+TESTASS(fdc, fp, void *); /* { dg-error \"error: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+TESTINI(fdd, fp, void *); /* { dg-error \"error: ISO C forbids initialization between function pointer and 'void \\\\*'\" } */\n+TESTRET(fde, fp, void *); /* { dg-error \"error: ISO C forbids return between function pointer and 'void \\\\*'\" } */\n+\n+TESTARG(dfa, void *, fp); /* { dg-error \"error: ISO C forbids passing argument 1 of 'dfaF' between function pointer and 'void \\\\*'\" } */\n+TESTARP(dfb, void *, fp); /* { dg-error \"error: ISO C forbids passing argument 1 of 'dfbFp.x' between function pointer and 'void \\\\*'\" } */\n+TESTASS(dfc, void *, fp); /* { dg-error \"error: ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+TESTINI(dfd, void *, fp); /* { dg-error \"error: ISO C forbids initialization between function pointer and 'void \\\\*'\" } */\n+TESTRET(dfe, void *, fp); /* { dg-error \"error: ISO C forbids return between function pointer and 'void \\\\*'\" } */\n+\n+TESTARG(sua, int *, unsigned int *); /* { dg-error \"error: pointer targets in passing argument 1 of 'suaF' differ in signedness\" } */\n+TESTARP(sub, int *, unsigned int *); /* { dg-error \"error: pointer targets in passing argument 1 of 'subFp.x' differ in signedness\" } */\n+TESTASS(suc, int *, unsigned int *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(sud, int *, unsigned int *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(sue, int *, unsigned int *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(usa, unsigned int *, int *); /* { dg-error \"error: pointer targets in passing argument 1 of 'usaF' differ in signedness\" } */\n+TESTARP(usb, unsigned int *, int *); /* { dg-error \"error: pointer targets in passing argument 1 of 'usbFp.x' differ in signedness\" } */\n+TESTASS(usc, unsigned int *, int *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(usd, unsigned int *, int *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(use, unsigned int *, int *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(cua, char *, unsigned char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'cuaF' differ in signedness\" } */\n+TESTARP(cub, char *, unsigned char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'cubFp.x' differ in signedness\" } */\n+TESTASS(cuc, char *, unsigned char *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(cud, char *, unsigned char *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(cue, char *, unsigned char *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(uca, unsigned char *, char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'ucaF' differ in signedness\" } */\n+TESTARP(ucb, unsigned char *, char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'ucbFp.x' differ in signedness\" } */\n+TESTASS(ucc, unsigned char *, char *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(ucd, unsigned char *, char *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(uce, unsigned char *, char *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(csa, char *, signed char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'csaF' differ in signedness\" } */\n+TESTARP(csb, char *, signed char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'csbFp.x' differ in signedness\" } */\n+TESTASS(csc, char *, signed char *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(csd, char *, signed char *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(cse, char *, signed char *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(sca, signed char *, char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'scaF' differ in signedness\" } */\n+TESTARP(scb, signed char *, char *); /* { dg-error \"error: pointer targets in passing argument 1 of 'scbFp.x' differ in signedness\" } */\n+TESTASS(scc, signed char *, char *); /* { dg-error \"error: pointer targets in assignment differ in signedness\" } */\n+TESTINI(scd, signed char *, char *); /* { dg-error \"error: pointer targets in initialization differ in signedness\" } */\n+TESTRET(sce, signed char *, char *); /* { dg-error \"error: pointer targets in return differ in signedness\" } */\n+\n+TESTARG(cia, char *, int *); /* { dg-error \"error: passing argument 1 of 'ciaF' from incompatible pointer type\" } */\n+TESTARP(cib, char *, int *); /* { dg-error \"error: passing argument 1 of 'cibFp.x' from incompatible pointer type\" } */\n+TESTASS(cic, char *, int *); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+TESTINI(cid, char *, int *); /* { dg-error \"error: initialization from incompatible pointer type\" } */\n+TESTRET(cie, char *, int *); /* { dg-error \"error: return from incompatible pointer type\" } */\n+\n+TESTARG(ica, int *, char *); /* { dg-error \"error: passing argument 1 of 'icaF' from incompatible pointer type\" } */\n+TESTARP(icb, int *, char *); /* { dg-error \"error: passing argument 1 of 'icbFp.x' from incompatible pointer type\" } */\n+TESTASS(icc, int *, char *); /* { dg-error \"error: assignment from incompatible pointer type\" } */\n+TESTINI(icd, int *, char *); /* { dg-error \"error: initialization from incompatible pointer type\" } */\n+TESTRET(ice, int *, char *); /* { dg-error \"error: return from incompatible pointer type\" } */\n+\n+TESTARG(ciia, char *, int); /* { dg-error \"error: passing argument 1 of 'ciiaF' makes pointer from integer without a cast\" } */\n+TESTARP(ciib, char *, int); /* { dg-error \"error: passing argument 1 of 'ciibFp.x' makes pointer from integer without a cast\" } */\n+TESTASS(ciic, char *, int); /* { dg-error \"error: assignment makes pointer from integer without a cast\" } */\n+TESTINI(ciid, char *, int); /* { dg-error \"error: initialization makes pointer from integer without a cast\" } */\n+TESTRET(ciie, char *, int); /* { dg-error \"error: return makes pointer from integer without a cast\" } */\n+\n+TESTARG(iica, int, char *); /* { dg-error \"error: passing argument 1 of 'iicaF' makes integer from pointer without a cast\" } */\n+TESTARP(iicb, int, char *); /* { dg-error \"error: passing argument 1 of 'iicbFp.x' makes integer from pointer without a cast\" } */\n+TESTASS(iicc, int, char *); /* { dg-error \"error: assignment makes integer from pointer without a cast\" } */\n+TESTINI(iicd, int, char *); /* { dg-error \"error: initialization makes integer from pointer without a cast\" } */\n+TESTRET(iice, int, char *); /* { dg-error \"error: return makes integer from pointer without a cast\" } */\n+\n+struct s { int a; };\n+\n+TESTARG(stria, struct s, int); /* { dg-error \"error: incompatible type for argument 1 of 'striaF'\" } */\n+TESTARP(strib, struct s, int); /* { dg-error \"error: incompatible type for argument 1 of 'stribFp.x'\" } */\n+TESTASS(stric, struct s, int); /* { dg-error \"error: incompatible types in assignment\" } */\n+TESTINI(strid, struct s, int); /* { dg-error \"error: invalid initializer\" } */\n+TESTRET(strie, struct s, int); /* { dg-error \"error: incompatible types in return\" } */\n+\n+TESTARG(istra, int, struct s); /* { dg-error \"error: incompatible type for argument 1 of 'istraF'\" } */\n+TESTARP(istrb, int, struct s); /* { dg-error \"error: incompatible type for argument 1 of 'istrbFp.x'\" } */\n+TESTASS(istrc, int, struct s); /* { dg-error \"error: incompatible types in assignment\" } */\n+TESTINI(istrd, int, struct s); /* { dg-error \"error: incompatible types in initialization\" } */\n+TESTRET(istre, int, struct s); /* { dg-error \"error: incompatible types in return\" } */"}, {"sha": "c1de5663acecff297bc35a8dc7b7b6a4964c9df1", "filename": "gcc/testsuite/gcc.dg/noncompile/20020213-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -24,8 +24,8 @@ int main ()\n   return 0;\n }\n \n-/* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 15 } */\n-/* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 16 } */\n-/* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 16 } */\n-/* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 18 } */\n-/* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 20 } */\n+/* { dg-warning \"passing argument 2 of\" \"2nd incompatible\" { target *-*-* } 15 } */\n+/* { dg-warning \"passing argument 1 of\" \"1st incompatible\" { target *-*-* } 16 } */\n+/* { dg-warning \"passing argument 2 of\" \"2nd incompatible\" { target *-*-* } 16 } */\n+/* { dg-warning \"passing argument 1 of\" \"1st incompatible\" { target *-*-* } 18 } */\n+/* { dg-warning \"passing argument 1 of\" \"1st incompatible\" { target *-*-* } 20 } */"}, {"sha": "dc2cd0e7c71687e1357cd53393c2656c016afed6", "filename": "gcc/testsuite/gcc.dg/warn-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-1.c?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -12,5 +12,5 @@ void bar (void)\n {\n   void *vp;\n \n-  foo (vp);\t/* { dg-warning \"passing arg 1 of\" } */\n+  foo (vp);\t/* { dg-warning \"passing argument 1 of\" } */\n }"}, {"sha": "3921663ec8f99c1e76a7bd95855f9435494af700", "filename": "gcc/testsuite/objc.dg/method-9.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-9.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac2f1647dbc609e2c7ae8b58012e14eeefd7698/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-9.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-9.m?ref=2ac2f1647dbc609e2c7ae8b58012e14eeefd7698", "patch": "@@ -37,7 +37,7 @@ + (NTGridDataObject*)dataObject:(id<MyObject, MyCoding>)data\n      /* { dg-warning \"also found .\\\\-\\\\(id\\\\)initWithData:\\\\(int\\\\)data.\" \"\" { target *-*-* } 13 } */\n \n      /* The following warning is a consequence of picking the \"wrong\" method signature.  */\n-     /* { dg-warning \"passing arg 1 of .initWithData:. from incompatible pointer type\" \"\" { target *-*-* } 33 } */\n+     /* { dg-warning \"passing argument 1 of .initWithData:. from incompatible pointer type\" \"\" { target *-*-* } 33 } */\n     return result;\n }\n @end"}]}