{"sha": "3ccb989ed8ead8947202fdc14150ace1f2d6619f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjYjk4OWVkOGVhZDg5NDcyMDJmZGMxNDE1MGFjZTFmMmQ2NjE5Zg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-17T19:33:24Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-17T19:33:24Z"}, "message": "emit-rtl.c (link_insn_into_chain): Handle chaining of SEQUENCEs.\n\n\n\t* emit-rtl.c (link_insn_into_chain): Handle chaining of SEQUENCEs.\n\t* reorg.c (emit_delay_sequence): Simplify with emit-rtl API.\n\nFrom-SVN: r198036", "tree": {"sha": "0fcf1bced9e337bdcc941f146c80f42ae9406b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fcf1bced9e337bdcc941f146c80f42ae9406b42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ccb989ed8ead8947202fdc14150ace1f2d6619f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccb989ed8ead8947202fdc14150ace1f2d6619f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccb989ed8ead8947202fdc14150ace1f2d6619f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccb989ed8ead8947202fdc14150ace1f2d6619f/comments", "author": null, "committer": null, "parents": [{"sha": "82b541a12a8e0911a278898934157956d67e61fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b541a12a8e0911a278898934157956d67e61fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b541a12a8e0911a278898934157956d67e61fe"}], "stats": {"total": 113, "additions": 37, "deletions": 76}, "files": [{"sha": "19d51f1f5e771c7c5a850cd7023a0751feb7cfd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ccb989ed8ead8947202fdc14150ace1f2d6619f", "patch": "@@ -1,11 +1,16 @@\n-2013-04-17  Greta Yorsh  <Greta.Yorsh at arm.com>\n+2013-04-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* emit-rtl.c (link_insn_into_chain): Handle chaining of SEQUENCEs.\n+\t* reorg.c (emit_delay_sequence): Simplify with emit-rtl API.\n+\n+2013-04-17  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.md (movsicc_insn): Convert define_insn into\n \tdefine_insn_and_split.\n \t(and_scc,ior_scc,negscc): Likewise.\n \t(cmpsi2_addneg, subsi3_compare): Convert to named patterns.\n \n-2013-04-17  Greta Yorsh  <Greta.Yorsh at arm.com>\n+2013-04-17  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.c (use_return_insn): Return 0 for targets that\n \tcan benefit from using a sequence of LDRD instructions in epilogue"}, {"sha": "a7cdf843fd9e3cef54ba1fa67af37b736beb8461", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3ccb989ed8ead8947202fdc14150ace1f2d6619f", "patch": "@@ -3806,6 +3806,13 @@ link_insn_into_chain (rtx insn, rtx prev, rtx next)\n       if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n \tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = insn;\n     }\n+\n+  if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      rtx sequence = PATTERN (insn);\n+      PREV_INSN (XVECEXP (sequence, 0, 0)) = prev;\n+      NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = next;\n+    }\n }\n \n /* Add INSN to the end of the doubly-linked list."}, {"sha": "5a457e2c8e54bd8ec6466afb2a1f5b6eca0b6556", "filename": "gcc/reorg.c", "status": "modified", "additions": 23, "deletions": 74, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccb989ed8ead8947202fdc14150ace1f2d6619f/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=3ccb989ed8ead8947202fdc14150ace1f2d6619f", "patch": "@@ -458,86 +458,52 @@ find_end_label (rtx kind)\n /* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace\n    the pattern of INSN with the SEQUENCE.\n \n-   Chain the insns so that NEXT_INSN of each insn in the sequence points to\n-   the next and NEXT_INSN of the last insn in the sequence points to\n-   the first insn after the sequence.  Similarly for PREV_INSN.  This makes\n-   it easier to scan all insns.\n-\n    Returns the SEQUENCE that replaces INSN.  */\n \n static rtx\n emit_delay_sequence (rtx insn, rtx list, int length)\n {\n-  int i = 1;\n-  rtx li;\n-  int had_barrier = 0;\n-\n   /* Allocate the rtvec to hold the insns and the SEQUENCE.  */\n   rtvec seqv = rtvec_alloc (length + 1);\n   rtx seq = gen_rtx_SEQUENCE (VOIDmode, seqv);\n   rtx seq_insn = make_insn_raw (seq);\n-  rtx first = get_insns ();\n-  rtx last = get_last_insn ();\n-\n-  /* Make a copy of the insn having delay slots.  */\n-  rtx delay_insn = copy_rtx (insn);\n-\n-  /* If INSN is followed by a BARRIER, delete the BARRIER since it will only\n-     confuse further processing.  Update LAST in case it was the last insn.\n-     We will put the BARRIER back in later.  */\n-  if (NEXT_INSN (insn) && BARRIER_P (NEXT_INSN (insn)))\n-    {\n-      delete_related_insns (NEXT_INSN (insn));\n-      last = get_last_insn ();\n-      had_barrier = 1;\n-    }\n-\n-  /* Splice our SEQUENCE into the insn stream where INSN used to be.  */\n-  NEXT_INSN (seq_insn) = NEXT_INSN (insn);\n-  PREV_INSN (seq_insn) = PREV_INSN (insn);\n-\n-  if (insn != last)\n-    PREV_INSN (NEXT_INSN (seq_insn)) = seq_insn;\n-\n-  if (insn != first)\n-    NEXT_INSN (PREV_INSN (seq_insn)) = seq_insn;\n \n-  /* Note the calls to set_new_first_and_last_insn must occur after\n-     SEQ_INSN has been completely spliced into the insn stream.\n+  /* If DELAY_INSN has a location, use it for SEQ_INSN.  If DELAY_INSN does\n+     not have a location, but one of the delayed insns does, we pick up a\n+     location from there later.  */\n+  INSN_LOCATION (seq_insn) = INSN_LOCATION (insn);\n \n-     Otherwise CUR_INSN_UID will get set to an incorrect value because\n-     set_new_first_and_last_insn will not find SEQ_INSN in the chain.  */\n-  if (insn == last)\n-    set_new_first_and_last_insn (first, seq_insn);\n-\n-  if (insn == first)\n-    set_new_first_and_last_insn (seq_insn, last);\n+  /* Unlink INSN from the insn chain, so that we can put it into\n+     the SEQUENCE.   Remember where we want to emit SEQUENCE in AFTER.  */\n+  rtx after = PREV_INSN (insn);\n+  remove_insn (insn);\n+  NEXT_INSN (insn) = PREV_INSN (insn) = NULL;\n \n   /* Build our SEQUENCE and rebuild the insn chain.  */\n-  XVECEXP (seq, 0, 0) = delay_insn;\n-  INSN_DELETED_P (delay_insn) = 0;\n-  PREV_INSN (delay_insn) = PREV_INSN (seq_insn);\n-\n-  INSN_LOCATION (seq_insn) = INSN_LOCATION (delay_insn);\n-\n-  for (li = list; li; li = XEXP (li, 1), i++)\n+  int i = 1;\n+  start_sequence ();\n+  XVECEXP (seq, 0, 0) = emit_insn (insn);\n+  for (rtx li = list; li; li = XEXP (li, 1), i++)\n     {\n       rtx tem = XEXP (li, 0);\n       rtx note, next;\n \n       /* Show that this copy of the insn isn't deleted.  */\n       INSN_DELETED_P (tem) = 0;\n \n-      XVECEXP (seq, 0, i) = tem;\n-      PREV_INSN (tem) = XVECEXP (seq, 0, i - 1);\n-      NEXT_INSN (XVECEXP (seq, 0, i - 1)) = tem;\n+      /* Unlink insn from its original place, and re-emit it into\n+\t the sequence.  */\n+      NEXT_INSN (tem) = PREV_INSN (tem) = NULL;\n+      XVECEXP (seq, 0, i) = emit_insn (tem);\n \n       /* SPARC assembler, for instance, emit warning when debug info is output\n          into the delay slot.  */\n       if (INSN_LOCATION (tem) && !INSN_LOCATION (seq_insn))\n \tINSN_LOCATION (seq_insn) = INSN_LOCATION (tem);\n       INSN_LOCATION (tem) = 0;\n \n+      /* Remove any REG_DEAD notes because we can't rely on them now\n+\t that the insn has been moved.  */\n       for (note = REG_NOTES (tem); note; note = next)\n \t{\n \t  next = XEXP (note, 1);\n@@ -561,29 +527,12 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n \t    }\n \t}\n     }\n-\n-  NEXT_INSN (XVECEXP (seq, 0, length)) = NEXT_INSN (seq_insn);\n-\n-  /* If the previous insn is a SEQUENCE, update the NEXT_INSN pointer on the\n-     last insn in that SEQUENCE to point to us.  Similarly for the first\n-     insn in the following insn if it is a SEQUENCE.  */\n-\n-  if (PREV_INSN (seq_insn) && NONJUMP_INSN_P (PREV_INSN (seq_insn))\n-      && GET_CODE (PATTERN (PREV_INSN (seq_insn))) == SEQUENCE)\n-    NEXT_INSN (XVECEXP (PATTERN (PREV_INSN (seq_insn)), 0,\n-\t\t\tXVECLEN (PATTERN (PREV_INSN (seq_insn)), 0) - 1))\n-      = seq_insn;\n-\n-  if (NEXT_INSN (seq_insn) && NONJUMP_INSN_P (NEXT_INSN (seq_insn))\n-      && GET_CODE (PATTERN (NEXT_INSN (seq_insn))) == SEQUENCE)\n-    PREV_INSN (XVECEXP (PATTERN (NEXT_INSN (seq_insn)), 0, 0)) = seq_insn;\n-\n-  /* If there used to be a BARRIER, put it back.  */\n-  if (had_barrier)\n-    emit_barrier_after (seq_insn);\n-\n+  end_sequence ();\n   gcc_assert (i == length + 1);\n \n+  /* Splice our SEQUENCE into the insn stream where INSN used to be.  */\n+  add_insn_after (seq_insn, after, NULL);\n+\n   return seq_insn;\n }\n "}]}