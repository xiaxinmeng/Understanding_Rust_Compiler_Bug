{"sha": "44d10d9547612b5fda3d27bb628d5d6ee79108af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRkMTBkOTU0NzYxMmI1ZmRhM2QyN2JiNjI4ZDVkNmVlNzkxMDhhZg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-12T12:56:02Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "TypeResolution pass now with a TyTy module\n\nResolution must implement the Gathering specified in the rust-dev guide.\nWe need to be able to handle cases such as:\n\n  let mut x;\n  x = 1;\n\nor\n\n  let mut x = vec!{}\n  x.push(1)\n\nNow the TyTy module has a combine abstract method to allow the combination\nof types to condense down from their integral parts.", "tree": {"sha": "ee39563bec035ad3882c1e655a49ba55df12d47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee39563bec035ad3882c1e655a49ba55df12d47c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44d10d9547612b5fda3d27bb628d5d6ee79108af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d10d9547612b5fda3d27bb628d5d6ee79108af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d10d9547612b5fda3d27bb628d5d6ee79108af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d10d9547612b5fda3d27bb628d5d6ee79108af/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb0ab7e635c65318aadf958e0e1303f3435c4e5"}], "stats": {"total": 2282, "additions": 2039, "deletions": 243}, "files": [{"sha": "96457edbca9d651ceaefe6ed749321b40e59fe82", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -78,6 +78,9 @@ GRS_OBJS = \\\n     rust/rust-hir-map.o \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-resolve.o \\\n+    rust/rust-hir-type-check.o \\\n+    rust/rust-tyty.o \\\n+    rust/rust-tyctx.o \\\n     $(END)\n # removed object files from here\n \n@@ -231,7 +234,8 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/hir/tree \\\n \t-I $(srcdir)/rust/hir \\\n \t-I $(srcdir)/rust/resolve \\\n-\t-I $(srcdir)/rust/util\n+\t-I $(srcdir)/rust/util \\\n+\t-I $(srcdir)/rust/typecheck\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -287,8 +291,13 @@ rust/%.o: rust/hir/tree/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n-# build rust/hir/tree files in rust folder\n+# build rust/resolve files in rust folder\n rust/%.o: rust/resolve/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+# build rust/typecheck files in rust folder\n+rust/%.o: rust/typecheck/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+"}, {"sha": "e0ce8628faf163af19ae271092ed2bf0058065b7", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -93,6 +93,8 @@ class ASTLoweringItem : public ASTLoweringBase\n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n \t\t\t       translated);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       function.get_locus ());\n   }\n \n   // Helpers"}, {"sha": "c8136398bc17f489198c5671870724df15df0f6a", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -58,6 +58,8 @@ class ASTLoweringStmt : public ASTLoweringBase\n       = new HIR::ExprStmtWithoutBlock (mapping,\n \t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n \t\t\t\t       stmt.get_locus ());\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       stmt.get_locus ());\n   }\n \n   void visit (AST::LetStmt &stmt)\n@@ -82,6 +84,8 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t  std::unique_ptr<HIR::Expr> (init_expression),\n \t\t\t  std::unique_ptr<HIR::Type> (type),\n \t\t\t  std::move (outer_attrs), stmt.get_locus ());\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       stmt.get_locus ());\n   }\n \n private:"}, {"sha": "4193415fcbc8938aa04efda88ef1dd650449080e", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -65,9 +65,16 @@ class ASTLoweringType : public ASTLoweringBase\n       return true;\n     });\n \n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, path.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n     translated\n-      = new HIR::TypePath (std::move (translated_segments), path.get_locus (),\n+      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t   path.get_locus (),\n \t\t\t   path.has_opening_scope_resolution_op ());\n+    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n   }\n \n private:"}, {"sha": "b08aa911cac40fcab455b4b645cc745ad7053b20", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -2169,6 +2169,8 @@ class CallExpr : public ExprWithoutBlock\n \n   Expr *get_fnexpr () { return function.get (); }\n \n+  size_t num_params () const { return params.size (); }\n+\n   void iterate_params (std::function<bool (Expr *)> cb)\n   {\n     for (auto it = params.begin (); it != params.end (); it++)\n@@ -2551,6 +2553,15 @@ class BlockExpr : public ExprWithBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  void iterate_stmts (std::function<bool (Stmt *)> cb)\n+  {\n+    for (auto it = statements.begin (); it != statements.end (); it++)\n+      {\n+\tif (!cb (it->get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3118,6 +3129,8 @@ class ReturnExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Expr *get_expr () { return return_expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "cf24baea6a6f62d3a8b803e11ab98afd339b89b5", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -319,19 +319,6 @@ struct SelfParam\n     // not having either is not an error\n   }\n \n-  // Creates an error state self-param.\n-  static SelfParam create_error ()\n-  {\n-    /* HACK: creates a dummy type. Since it's a unique pointer, it should\n-     * clean it up, but it still allocates memory, which is not ideal. */\n-    return SelfParam (Lifetime (Lifetime::STATIC), false, false,\n-\t\t      new QualifiedPathInType (\n-\t\t\tQualifiedPathInType::create_error ()));\n-    /* FIXME: is there a reason why I didn't just create a null pointer? Is it\n-     * due to error being having both a type and a lifetime? If it is, wouldn't\n-     * something like \"not has_ref and has lifetime\" for error be better? */\n-  }\n-\n   // Type-based self parameter (not ref, no lifetime)\n   SelfParam (std::unique_ptr<Type> type, bool is_mut, Location locus)\n     : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n@@ -588,22 +575,6 @@ class Method : public InherentImplItem, public TraitImplItem\n   Location locus;\n \n public:\n-  // Returns whether the method is in an error state.\n-  bool is_error () const\n-  {\n-    return expr == nullptr || method_name.empty () || self_param.is_error ();\n-  }\n-\n-  // Creates an error state method.\n-  static Method create_error ()\n-  {\n-    return Method (\"\", FunctionQualifiers (FunctionQualifiers::NONE, true),\n-\t\t   std::vector<std::unique_ptr<GenericParam> > (),\n-\t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n-\t\t   nullptr, WhereClause::create_empty (), nullptr,\n-\t\t   Visibility::create_error (), std::vector<Attribute> ());\n-  }\n-\n   // Returns whether the method has generic parameters.\n   bool has_generics () const { return !generic_params.empty (); }\n "}, {"sha": "84b4914ef5740f974fd251291333b20889c6c11b", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -345,7 +345,8 @@ class MacroInvocation : public TypeNoBounds,\n   MacroInvocation (Analysis::NodeMapping mappings, SimplePath path,\n \t\t   DelimTokenTree token_tree,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n+    : TypeNoBounds (mappings),\n+      ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n       path (std::move (path)), token_tree (std::move (token_tree)),\n       locus (locus)\n   {}"}, {"sha": "1bba50687d18b39204e6dd9fa3bede407ff1cedd", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -591,20 +591,24 @@ class TypePath : public TypeNoBounds\n   // Creates an error state TypePath.\n   static TypePath create_error ()\n   {\n-    return TypePath (std::vector<std::unique_ptr<TypePathSegment> > (),\n+    return TypePath (Analysis::NodeMapping::get_error (),\n+\t\t     std::vector<std::unique_ptr<TypePathSegment> > (),\n \t\t     Location ());\n   }\n \n   // Constructor\n-  TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n+  TypePath (Analysis::NodeMapping mappings,\n+\t    std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n-    : has_opening_scope_resolution (has_opening_scope_resolution),\n+    : TypeNoBounds (mappings),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n       segments (std::move (segments)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   TypePath (TypePath const &other)\n-    : has_opening_scope_resolution (other.has_opening_scope_resolution),\n+    : TypeNoBounds (other.mappings),\n+      has_opening_scope_resolution (other.has_opening_scope_resolution),\n       locus (other.locus)\n   {\n     segments.reserve (other.segments.size ());\n@@ -617,6 +621,7 @@ class TypePath : public TypeNoBounds\n   {\n     has_opening_scope_resolution = other.has_opening_scope_resolution;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     segments.reserve (other.segments.size ());\n     for (const auto &e : other.segments)\n@@ -793,10 +798,10 @@ class QualifiedPathInType : public TypeNoBounds\n \n public:\n   QualifiedPathInType (\n-    QualifiedPathType qual_path_type,\n+    Analysis::NodeMapping mappings, QualifiedPathType qual_path_type,\n     std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n     Location locus = Location ())\n-    : path_type (std::move (qual_path_type)),\n+    : TypeNoBounds (mappings), path_type (std::move (qual_path_type)),\n       segments (std::move (path_segments)), locus (locus)\n   {}\n \n@@ -805,7 +810,7 @@ class QualifiedPathInType : public TypeNoBounds\n \n   // Copy constructor with vector clone\n   QualifiedPathInType (QualifiedPathInType const &other)\n-    : path_type (other.path_type), locus (other.locus)\n+    : TypeNoBounds (mappings), path_type (other.path_type), locus (other.locus)\n   {\n     segments.reserve (other.segments.size ());\n     for (const auto &e : other.segments)\n@@ -817,6 +822,7 @@ class QualifiedPathInType : public TypeNoBounds\n   {\n     path_type = other.path_type;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     segments.reserve (other.segments.size ());\n     for (const auto &e : other.segments)\n@@ -829,17 +835,6 @@ class QualifiedPathInType : public TypeNoBounds\n   QualifiedPathInType (QualifiedPathInType &&other) = default;\n   QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n \n-  // Returns whether qualified path in type is in an error state.\n-  bool is_error () const { return path_type.is_error (); }\n-\n-  // Creates an error state qualified path in type.\n-  static QualifiedPathInType create_error ()\n-  {\n-    return QualifiedPathInType (\n-      QualifiedPathType::create_error (),\n-      std::vector<std::unique_ptr<TypePathSegment> > ());\n-  }\n-\n   std::string as_string () const override;\n \n   void accept_vis (HIRVisitor &vis) override;"}, {"sha": "31d55b6b1cf907129c43ab6c93065098ed448b25", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -113,6 +113,10 @@ class LetStmt : public Stmt\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  HIR::Type *get_type () { return type.get (); }\n+\n+  HIR::Expr *get_init_expr () { return init_expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "f8c851c811e5eba9cdd426c454434337cec8220f", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 68, "deletions": 37, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -92,13 +92,16 @@ class ImplTraitType : public Type\n \n public:\n   ImplTraitType (\n+    Analysis::NodeMapping mappings,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus)\n-    : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+    : Type (mappings), type_param_bounds (std::move (type_param_bounds)),\n+      locus (locus)\n   {}\n \n   // copy constructor with vector clone\n-  ImplTraitType (ImplTraitType const &other) : locus (other.locus)\n+  ImplTraitType (ImplTraitType const &other)\n+    : Type (other.mappings), locus (other.locus)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -109,6 +112,7 @@ class ImplTraitType : public Type\n   ImplTraitType &operator= (ImplTraitType const &other)\n   {\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -148,15 +152,16 @@ class TraitObjectType : public Type\n \n public:\n   TraitObjectType (\n+    Analysis::NodeMapping mappings,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus, bool is_dyn_dispatch = false)\n-    : has_dyn (is_dyn_dispatch),\n+    : Type (mappings), has_dyn (is_dyn_dispatch),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   TraitObjectType (TraitObjectType const &other)\n-    : has_dyn (other.has_dyn), locus (other.locus)\n+    : Type (other.mappings), has_dyn (other.has_dyn), locus (other.locus)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -166,6 +171,7 @@ class TraitObjectType : public Type\n   // overloaded assignment operator to clone\n   TraitObjectType &operator= (TraitObjectType const &other)\n   {\n+    mappings = other.mappings;\n     has_dyn = other.has_dyn;\n     locus = other.locus;\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n@@ -209,19 +215,23 @@ class ParenthesisedType : public TypeNoBounds\n \n public:\n   // Constructor uses Type pointer for polymorphism\n-  ParenthesisedType (std::unique_ptr<Type> type_inside_parens, Location locus)\n-    : type_in_parens (std::move (type_inside_parens)), locus (locus)\n+  ParenthesisedType (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : TypeNoBounds (mappings), type_in_parens (std::move (type_inside_parens)),\n+      locus (locus)\n   {}\n \n   /* Copy constructor uses custom deep copy method for type to preserve\n    * polymorphism */\n   ParenthesisedType (ParenthesisedType const &other)\n-    : type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings),\n+      type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n   {}\n \n   // overload assignment operator to use custom clone method\n   ParenthesisedType &operator= (ParenthesisedType const &other)\n   {\n+    mappings = other.mappings;\n     type_in_parens = other.type_in_parens->clone_type ();\n     locus = other.locus;\n     return *this;\n@@ -273,8 +283,10 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   }\n \n public:\n-  ImplTraitTypeOneBound (TraitBound trait_bound, Location locus)\n-    : trait_bound (std::move (trait_bound)), locus (locus)\n+  ImplTraitTypeOneBound (Analysis::NodeMapping mappings, TraitBound trait_bound,\n+\t\t\t Location locus)\n+    : TypeNoBounds (mappings), trait_bound (std::move (trait_bound)),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -309,10 +321,11 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   }\n \n public:\n-  TraitObjectTypeOneBound (TraitBound trait_bound, Location locus,\n+  TraitObjectTypeOneBound (Analysis::NodeMapping mappings,\n+\t\t\t   TraitBound trait_bound, Location locus,\n \t\t\t   bool is_dyn_dispatch = false)\n-    : has_dyn (is_dyn_dispatch), trait_bound (std::move (trait_bound)),\n-      locus (locus)\n+    : TypeNoBounds (mappings), has_dyn (is_dyn_dispatch),\n+      trait_bound (std::move (trait_bound)), locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -343,13 +356,16 @@ class TupleType : public TypeNoBounds\n   // Returns whether the tuple type is the unit type, i.e. has no elements.\n   bool is_unit_type () const { return elems.empty (); }\n \n-  TupleType (std::vector<std::unique_ptr<Type> > elems, Location locus)\n-    : elems (std::move (elems)), locus (locus)\n+  TupleType (Analysis::NodeMapping mappings,\n+\t     std::vector<std::unique_ptr<Type> > elems, Location locus)\n+    : TypeNoBounds (mappings), elems (std::move (elems)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n-  TupleType (TupleType const &other) : locus (other.locus)\n+  TupleType (TupleType const &other)\n+    : TypeNoBounds (other.mappings), locus (other.locus)\n   {\n+    mappings = other.mappings;\n     elems.reserve (other.elems.size ());\n     for (const auto &e : other.elems)\n       elems.push_back (e->clone_type ());\n@@ -410,7 +426,9 @@ class NeverType : public TypeNoBounds\n   }\n \n public:\n-  NeverType (Location locus) : locus (locus) {}\n+  NeverType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings), locus (locus)\n+  {}\n \n   std::string as_string () const override { return \"! (never type)\"; }\n \n@@ -439,21 +457,22 @@ class RawPointerType : public TypeNoBounds\n   PointerType get_pointer_type () const { return pointer_type; }\n \n   // Constructor requires pointer for polymorphism reasons\n-  RawPointerType (PointerType pointer_type,\n+  RawPointerType (Analysis::NodeMapping mappings, PointerType pointer_type,\n \t\t  std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus)\n-    : pointer_type (pointer_type), type (std::move (type_no_bounds)),\n-      locus (locus)\n+    : TypeNoBounds (mappings), pointer_type (pointer_type),\n+      type (std::move (type_no_bounds)), locus (locus)\n   {}\n \n   // Copy constructor calls custom polymorphic clone function\n   RawPointerType (RawPointerType const &other)\n-    : pointer_type (other.pointer_type),\n+    : TypeNoBounds (other.mappings), pointer_type (other.pointer_type),\n       type (other.type->clone_type_no_bounds ()), locus (other.locus)\n   {}\n \n   // overload assignment operator to use custom clone method\n   RawPointerType &operator= (RawPointerType const &other)\n   {\n+    mappings = other.mappings;\n     pointer_type = other.pointer_type;\n     type = other.type->clone_type_no_bounds ();\n     locus = other.locus;\n@@ -504,21 +523,24 @@ class ReferenceType : public TypeNoBounds\n   bool has_lifetime () const { return !lifetime.is_error (); }\n \n   // Constructor\n-  ReferenceType (bool is_mut, std::unique_ptr<TypeNoBounds> type_no_bounds,\n-\t\t Location locus, Lifetime lifetime = Lifetime::error ())\n-    : lifetime (std::move (lifetime)), has_mut (is_mut),\n-      type (std::move (type_no_bounds)), locus (locus)\n+  ReferenceType (Analysis::NodeMapping mappings, bool is_mut,\n+\t\t std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus,\n+\t\t Lifetime lifetime = Lifetime::error ())\n+    : TypeNoBounds (mappings), lifetime (std::move (lifetime)),\n+      has_mut (is_mut), type (std::move (type_no_bounds)), locus (locus)\n   {}\n \n   // Copy constructor with custom clone method\n   ReferenceType (ReferenceType const &other)\n-    : lifetime (other.lifetime), has_mut (other.has_mut),\n-      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings), lifetime (other.lifetime),\n+      has_mut (other.has_mut), type (other.type->clone_type_no_bounds ()),\n+      locus (other.locus)\n   {}\n \n   // Operator overload assignment operator to custom clone the unique pointer\n   ReferenceType &operator= (ReferenceType const &other)\n   {\n+    mappings = other.mappings;\n     lifetime = other.lifetime;\n     has_mut = other.has_mut;\n     type = other.type->clone_type_no_bounds ();\n@@ -562,20 +584,22 @@ class ArrayType : public TypeNoBounds\n \n public:\n   // Constructor requires pointers for polymorphism\n-  ArrayType (std::unique_ptr<Type> type, std::unique_ptr<Expr> array_size,\n-\t     Location locus)\n-    : elem_type (std::move (type)), size (std::move (array_size)), locus (locus)\n+  ArrayType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     std::unique_ptr<Expr> array_size, Location locus)\n+    : TypeNoBounds (mappings), elem_type (std::move (type)),\n+      size (std::move (array_size)), locus (locus)\n   {}\n \n   // Copy constructor requires deep copies of both unique pointers\n   ArrayType (ArrayType const &other)\n-    : elem_type (other.elem_type->clone_type ()),\n+    : TypeNoBounds (mappings), elem_type (other.elem_type->clone_type ()),\n       size (other.size->clone_expr ()), locus (other.locus)\n   {}\n \n   // Overload assignment operator to deep copy pointers\n   ArrayType &operator= (ArrayType const &other)\n   {\n+    mappings = other.mappings;\n     elem_type = other.elem_type->clone_type ();\n     size = other.size->clone_expr ();\n     locus = other.locus;\n@@ -620,18 +644,21 @@ class SliceType : public TypeNoBounds\n \n public:\n   // Constructor requires pointer for polymorphism\n-  SliceType (std::unique_ptr<Type> type, Location locus)\n-    : elem_type (std::move (type)), locus (locus)\n+  SliceType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     Location locus)\n+    : TypeNoBounds (mappings), elem_type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor requires deep copy of Type smart pointer\n   SliceType (SliceType const &other)\n-    : elem_type (other.elem_type->clone_type ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings), elem_type (other.elem_type->clone_type ()),\n+      locus (other.locus)\n   {}\n \n   // Overload assignment operator to deep copy\n   SliceType &operator= (SliceType const &other)\n   {\n+    mappings = other.mappings;\n     elem_type = other.elem_type->clone_type ();\n     locus = other.locus;\n \n@@ -684,7 +711,9 @@ class InferredType : public TypeNoBounds\n   }\n \n public:\n-  InferredType (Location locus) : locus (locus) {}\n+  InferredType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings), locus (locus)\n+  {}\n \n   std::string as_string () const override;\n \n@@ -783,19 +812,20 @@ class BareFunctionType : public TypeNoBounds\n   // Whether the function has ForLifetimes.\n   bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n \n-  BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n+  BareFunctionType (Analysis::NodeMapping mappings,\n+\t\t    std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n \t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n \t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n-    : for_lifetimes (std::move (lifetime_params)),\n+    : TypeNoBounds (mappings), for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n       return_type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   BareFunctionType (BareFunctionType const &other)\n-    : for_lifetimes (other.for_lifetimes),\n+    : TypeNoBounds (other.mappings), for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n       is_variadic (other.is_variadic),\n       return_type (other.return_type->clone_type_no_bounds ()),\n@@ -805,6 +835,7 @@ class BareFunctionType : public TypeNoBounds\n   // Overload assignment operator to deep copy\n   BareFunctionType &operator= (BareFunctionType const &other)\n   {\n+    mappings = other.mappings;\n     for_lifetimes = other.for_lifetimes;\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;"}, {"sha": "cbaa2e9ae66793999ef4bdfa289f9f8d81ff4037", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -968,9 +968,15 @@ class Type\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual Analysis::NodeMapping get_mappings () { return mappings; }\n+\n protected:\n+  Type (Analysis::NodeMapping mappings) : mappings (mappings) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n };\n \n // A type without parentheses? - abstract\n@@ -984,6 +990,8 @@ class TypeNoBounds : public Type\n   }\n \n protected:\n+  TypeNoBounds (Analysis::NodeMapping mappings) : Type (mappings) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n "}, {"sha": "b9e7f6a397a1d68429748a296389a41b6ed706be", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -49,23 +49,24 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ReturnExpr &expr)\n   {\n-    if (expr.has_return_expr ())\n-      ResolveExpr::go (expr.get_expr (), expr.get_node_id ());\n+    if (expr.has_returned_expr ())\n+      ResolveExpr::go (expr.get_returned_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::CallExpr &expr)\n   {\n-    ResolveExpr::go (expr.function.get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_function_expr ().get (), expr.get_node_id ());\n     expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n       ResolveExpr::go (p, expr.get_node_id ());\n       return true;\n     });\n+    /// resolver->insert_resolved_name(NodeId refId,NodeId defId)\n   }\n \n   void visit (AST::AssignmentExpr &expr)\n   {\n-    ResolveExpr::go (expr.get_lhs (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_rhs (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IdentifierExpr &expr)\n@@ -84,8 +85,8 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr)\n   {\n-    ResolveExpr::go (expr.get_lhs (), expr.get_node_id ());\n-    ResolveExpr::go (expr.right_expr.get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n private:"}, {"sha": "2c21a5212dcd4ecb7fe7d4a3a46a216db0b0ee51", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -51,11 +52,21 @@ class ResolveItem : public ResolverBase\n \t\t\t\tparam.get_node_id ());\n       }\n \n+    // setup parent scoping for names\n+    NodeId scope_node_id = function.get_definition ()->get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n     function.get_definition ()->iterate_stmts (\n       [&] (AST::Stmt *s) mutable -> bool {\n-\t// TODO\n+\tResolveStmt::go (s, s->get_node_id ());\n \treturn true;\n       });\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n   }\n \n private:"}, {"sha": "a393d310c0b5425e6015c7caa739dab6c3ac8040", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -78,6 +78,7 @@ class PatternDeclaration : public ResolverBase\n \n   void visit (AST::IdentifierPattern &pattern)\n   {\n+    printf (\"declaration for: %s\\n\", pattern.as_string ().c_str ());\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n     resolver->get_name_scope ().insert (pattern.get_ident (),"}, {"sha": "623fbd449c0738e156ee713fcbc39d9d7d49ed99", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -41,16 +41,16 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::LetStmt &stmt)\n   {\n-    PatternDeclaration::go (stmt.variables_pattern.get (), stmt.get_node_id ());\n+    PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());\n     if (stmt.has_type ())\n-      ResolveType::go (stmt.type.get (), stmt.get_node_id ());\n+      ResolveType::go (stmt.get_type ().get (), stmt.get_node_id ());\n \n     if (stmt.has_init_expr ())\n-      ResolveExpr::go (stmt.init_expr.get (), stmt.get_node_id ());\n+      ResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n   }\n \n private:\n-  ResolveStmt () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveStmt (NodeId parent) : ResolverBase (parent) {}\n };\n \n } // namespace Resolver"}, {"sha": "57bd0f3d12d9e506483356790c0994fd9c987b95", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -20,8 +20,9 @@\n #include \"rust-ast-resolve-toplevel.h\"\n #include \"rust-ast-resolve-item.h\"\n #include \"rust-ast-full.h\"\n+#include \"rust-tyty.h\"\n \n-#define MKBUILTIN_TYPE(_X, _R)                                                 \\\n+#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n   do                                                                           \\\n     {                                                                          \\\n       AST::PathIdentSegment seg (_X);                                          \\\n@@ -34,6 +35,8 @@\n \t= new AST::TypePath (::std::move (segs),                               \\\n \t\t\t     Linemap::predeclared_location (), false);         \\\n       _R.push_back (builtin_type);                                             \\\n+      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n+\t\t\t     _TY);                                             \\\n     }                                                                          \\\n   while (0)\n \n@@ -43,7 +46,7 @@ namespace Resolver {\n // Resolver\n \n Resolver::Resolver ()\n-  : mappings (Analysis::Mappings::get ()),\n+  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n     name_scope (Scope (mappings->get_current_crate ())),\n     type_scope (Scope (mappings->get_current_crate ()))\n {\n@@ -116,22 +119,26 @@ Resolver::get_builtin_types ()\n void\n Resolver::generate_builtins ()\n {\n-  MKBUILTIN_TYPE (\"u8\", builtins);\n-  MKBUILTIN_TYPE (\"u16\", builtins);\n-  MKBUILTIN_TYPE (\"u32\", builtins);\n-  MKBUILTIN_TYPE (\"u64\", builtins);\n-\n-  MKBUILTIN_TYPE (\"i8\", builtins);\n-  MKBUILTIN_TYPE (\"i16\", builtins);\n-  MKBUILTIN_TYPE (\"i32\", builtins);\n-  MKBUILTIN_TYPE (\"i64\", builtins);\n-\n-  MKBUILTIN_TYPE (\"f32\", builtins);\n-  MKBUILTIN_TYPE (\"f64\", builtins);\n-\n-  MKBUILTIN_TYPE (\"char\", builtins);\n-  MKBUILTIN_TYPE (\"str\", builtins);\n-  MKBUILTIN_TYPE (\"bool\", builtins);\n+  auto u8\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n+  auto u16\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n+  auto u32\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n+  auto i16\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n+  auto i32\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+\n+  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n+  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n+  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n+  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n+  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n }\n \n void"}, {"sha": "2aa592c5e11d80e7269a3bee596a4f386d39071b", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-system.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -55,6 +56,15 @@ class Rib\n   CrateNum get_crate_num () const { return crate_num; }\n   NodeId get_node_id () const { return node_id; }\n \n+  void iterate_decls (std::function<bool (NodeId)> cb)\n+  {\n+    for (auto it : decls_within_rib)\n+      {\n+\tif (!cb (it))\n+\t  return;\n+      }\n+  }\n+\n private:\n   CrateNum crate_num;\n   NodeId node_id;\n@@ -174,6 +184,7 @@ class Resolver\n   void generate_builtins ();\n \n   Analysis::Mappings *mappings;\n+  TypeCheckContext *tyctx;\n \n   std::vector<AST::TypePath *> builtins;\n "}, {"sha": "fc64994c7e32ce86c4dbdd9294f04c63f7488e57", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -26,16 +26,15 @@\n #include \"tm.h\"\n #include \"tm_p.h\"\n \n+#include \"rust-target.h\"\n+\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n #include \"rust-scan.h\"\n #include \"rust-macro-expand.h\"\n-#include \"rust-compile.h\"\n-#include \"rust-target.h\"\n-\n-// hir passes wip\n #include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n+#include \"rust-hir-type-check.h\"\n \n extern Linemap *\n rust_get_linemap ();\n@@ -531,21 +530,21 @@ Session::parse_file (const char *filename)\n     }\n \n   // lower AST to HIR\n-  HIR::Crate hir = HIR::ASTLowering::Resolve (parsed_crate);\n+  HIR::Crate hir = lower_ast (parsed_crate);\n   if (options.dump_option == CompileOptions::HIR_DUMP)\n     {\n       fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n       return;\n     }\n \n   // type resolve\n-  // TODO\n+  type_resolution (hir);\n \n   if (saw_errors ())\n     return;\n \n   // do compile\n-  Compile::Compilation::Compile (parsed_crate, backend);\n+  // Compile::Compilation::Compile (parsed_crate, backend);\n }\n \n // TODO: actually implement method\n@@ -777,6 +776,23 @@ Session::resolution (AST::Crate &crate)\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n \n+HIR::Crate\n+Session::lower_ast (AST::Crate &crate)\n+{\n+  fprintf (stderr, \"started lowering AST\\n\");\n+  auto hir = HIR::ASTLowering::Resolve (crate);\n+  fprintf (stderr, \"finished lowering AST\\n\");\n+  return hir;\n+}\n+\n+void\n+Session::type_resolution (HIR::Crate &crate)\n+{\n+  fprintf (stderr, \"started type resolution\\n\");\n+  Resolver::TypeResolution::Resolve (crate);\n+  fprintf (stderr, \"finished type resolution\\n\");\n+}\n+\n void\n TargetOptions::dump_target_options () const\n {"}, {"sha": "4836cc8dcbf5125969d3f8f286c85813adf7cc75", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -37,6 +37,10 @@ class Lexer;\n namespace AST {\n struct Crate;\n }\n+// crate forward decl\n+namespace HIR {\n+struct Crate;\n+}\n \n /* Data related to target, most useful for conditional compilation and\n  * whatever. */\n@@ -240,6 +244,11 @@ struct Session\n    * Performs name resolution and type resolution, maybe complete gated\n    * feature checking, maybe create buffered lints in future. */\n   void resolution (AST::Crate &crate);\n+  /* This lowers the AST down to HIR and assigns all mappings from AST\n+   * NodeIds back to HirIds */\n+  HIR::Crate lower_ast (AST::Crate &crate);\n+  /* This adds the type resolution process */\n+  void type_resolution (HIR::Crate &crate);\n };\n } // namespace Rust\n "}, {"sha": "78afff956abb3c483de3ae69ea44b1a0cf8439f3", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,256 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_BASE\n+#define RUST_HIR_TYPE_CHECK_BASE\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// base class to allow derivatives to overload as needed\n+class TypeCheckBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~TypeCheckBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (HIR::Token &tok) {}\n+  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (HIR::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (HIR::PathInExpression &path) {}\n+  virtual void visit (HIR::TypePathSegment &segment) {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (HIR::TypePathSegmentFunction &segment) {}\n+  virtual void visit (HIR::TypePath &path) {}\n+  virtual void visit (HIR::QualifiedPathInExpression &path) {}\n+  virtual void visit (HIR::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (HIR::LiteralExpr &expr) {}\n+  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n+  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n+  virtual void visit (HIR::BorrowExpr &expr) {}\n+  virtual void visit (HIR::DereferenceExpr &expr) {}\n+  virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n+  virtual void visit (HIR::NegationExpr &expr) {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (HIR::ComparisonExpr &expr) {}\n+  virtual void visit (HIR::LazyBooleanExpr &expr) {}\n+  virtual void visit (HIR::TypeCastExpr &expr) {}\n+  virtual void visit (HIR::AssignmentExpr &expr) {}\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (HIR::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (HIR::ArrayElemsValues &elems) {}\n+  virtual void visit (HIR::ArrayElemsCopied &elems) {}\n+  virtual void visit (HIR::ArrayExpr &expr) {}\n+  virtual void visit (HIR::ArrayIndexExpr &expr) {}\n+  virtual void visit (HIR::TupleExpr &expr) {}\n+  virtual void visit (HIR::TupleIndexExpr &expr) {}\n+  virtual void visit (HIR::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::StructExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::StructExprStructFields &expr) {}\n+  virtual void visit (HIR::StructExprStructBase &expr) {}\n+  virtual void visit (HIR::StructExprTuple &expr) {}\n+  virtual void visit (HIR::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::EnumExprStruct &expr) {}\n+  virtual void visit (HIR::EnumExprTuple &expr) {}\n+  virtual void visit (HIR::EnumExprFieldless &expr) {}\n+  virtual void visit (HIR::CallExpr &expr) {}\n+  virtual void visit (HIR::MethodCallExpr &expr) {}\n+  virtual void visit (HIR::FieldAccessExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInner &expr) {}\n+  virtual void visit (HIR::BlockExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (HIR::ContinueExpr &expr) {}\n+  virtual void visit (HIR::BreakExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToExpr &expr) {}\n+  virtual void visit (HIR::RangeFromExpr &expr) {}\n+  virtual void visit (HIR::RangeToExpr &expr) {}\n+  virtual void visit (HIR::RangeFullExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToInclExpr &expr) {}\n+  virtual void visit (HIR::RangeToInclExpr &expr) {}\n+  virtual void visit (HIR::ReturnExpr &expr) {}\n+  virtual void visit (HIR::UnsafeBlockExpr &expr) {}\n+  virtual void visit (HIR::LoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLetLoopExpr &expr) {}\n+  virtual void visit (HIR::ForLoopExpr &expr) {}\n+  virtual void visit (HIR::IfExpr &expr) {}\n+  virtual void visit (HIR::IfExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfExprConseqIfLet &expr) {}\n+  virtual void visit (HIR::IfLetExpr &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (HIR::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (HIR::MatchCaseExpr &match_case) {}\n+  virtual void visit (HIR::MatchExpr &expr) {}\n+  virtual void visit (HIR::AwaitExpr &expr) {}\n+  virtual void visit (HIR::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (HIR::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (HIR::Method &method) {}\n+  virtual void visit (HIR::ModuleBodied &module) {}\n+  virtual void visit (HIR::ModuleNoBody &module) {}\n+  virtual void visit (HIR::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (HIR::UseTreeGlob &use_tree) {}\n+  virtual void visit (HIR::UseTreeList &use_tree) {}\n+  virtual void visit (HIR::UseTreeRebind &use_tree) {}\n+  virtual void visit (HIR::UseDeclaration &use_decl) {}\n+  virtual void visit (HIR::Function &function) {}\n+  virtual void visit (HIR::TypeAlias &type_alias) {}\n+  virtual void visit (HIR::StructStruct &struct_item) {}\n+  virtual void visit (HIR::TupleStruct &tuple_struct) {}\n+  virtual void visit (HIR::EnumItem &item) {}\n+  virtual void visit (HIR::EnumItemTuple &item) {}\n+  virtual void visit (HIR::EnumItemStruct &item) {}\n+  virtual void visit (HIR::EnumItemDiscriminant &item) {}\n+  virtual void visit (HIR::Enum &enum_item) {}\n+  virtual void visit (HIR::Union &union_item) {}\n+  virtual void visit (HIR::ConstantItem &const_item) {}\n+  virtual void visit (HIR::StaticItem &static_item) {}\n+  virtual void visit (HIR::TraitItemFunc &item) {}\n+  virtual void visit (HIR::TraitItemMethod &item) {}\n+  virtual void visit (HIR::TraitItemConst &item) {}\n+  virtual void visit (HIR::TraitItemType &item) {}\n+  virtual void visit (HIR::Trait &trait) {}\n+  virtual void visit (HIR::InherentImpl &impl) {}\n+  virtual void visit (HIR::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (HIR::ExternalStaticItem &item) {}\n+  virtual void visit (HIR::ExternalFunctionItem &item) {}\n+  virtual void visit (HIR::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (HIR::MacroMatchFragment &match) {}\n+  virtual void visit (HIR::MacroMatchRepetition &match) {}\n+  virtual void visit (HIR::MacroMatcher &matcher) {}\n+  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n+  virtual void visit (HIR::MetaItemPath &meta_item) {}\n+  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n+  virtual void visit (HIR::MetaWord &meta_item) {}\n+  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n+  virtual void visit (HIR::MetaListPaths &meta_item) {}\n+  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (HIR::LiteralPattern &pattern) {}\n+  virtual void visit (HIR::IdentifierPattern &pattern) {}\n+  virtual void visit (HIR::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (HIR::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (HIR::RangePatternBoundPath &bound) {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (HIR::RangePattern &pattern) {}\n+  virtual void visit (HIR::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (HIR::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdent &field) {}\n+  virtual void visit (HIR::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (HIR::TuplePattern &pattern) {}\n+  virtual void visit (HIR::GroupedPattern &pattern) {}\n+  virtual void visit (HIR::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (HIR::EmptyStmt &stmt) {}\n+  virtual void visit (HIR::LetStmt &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (HIR::TraitBound &bound) {}\n+  virtual void visit (HIR::ImplTraitType &type) {}\n+  virtual void visit (HIR::TraitObjectType &type) {}\n+  virtual void visit (HIR::ParenthesisedType &type) {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (HIR::TupleType &type) {}\n+  virtual void visit (HIR::NeverType &type) {}\n+  virtual void visit (HIR::RawPointerType &type) {}\n+  virtual void visit (HIR::ReferenceType &type) {}\n+  virtual void visit (HIR::ArrayType &type) {}\n+  virtual void visit (HIR::SliceType &type) {}\n+  virtual void visit (HIR::InferredType &type) {}\n+  virtual void visit (HIR::BareFunctionType &type) {}\n+\n+protected:\n+  TypeCheckBase ()\n+    : mappings (Analysis::Mappings::get ()), resolver (Resolver::get ()),\n+      context (TypeCheckContext::get ())\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver *resolver;\n+  TypeCheckContext *context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_BASE"}, {"sha": "2e715e9d6e9f405bd8c0ec693bb544be1806b2a8", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,173 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_EXPR\n+#define RUST_HIR_TYPE_CHECK_EXPR\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-call.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckExpr : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::Expr *expr)\n+  {\n+    TypeCheckExpr resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.infered != nullptr)\n+      resolver.context->insert_type (expr->get_mappings ().get_hirid (),\n+\t\t\t\t     resolver.infered);\n+\n+    return resolver.infered;\n+  }\n+\n+  void visit (HIR::ReturnExpr &expr)\n+  {\n+    auto ret = context->peek_return_type ();\n+    rust_assert (ret != nullptr);\n+\n+    auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n+    infered = ret->combine (expr_ty);\n+  }\n+\n+  void visit (HIR::CallExpr &expr)\n+  {\n+    auto fn = expr.get_fnexpr ();\n+    auto fn_node_id = fn->get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // check if this has a type\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\t// FIXME we need to be able to lookup the location info for the\n+\t// reference here\n+\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    infered = TyTy::TypeCheckCallExpr::go (lookup, expr);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // check if this has a type\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\t// FIXME we need to be able to lookup the location info for the\n+\t// reference here\n+\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // FIXME this needs to be cloned for memory management later on\n+    infered = lookup;\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+      case HIR::Literal::LitType::INT:\n+\tinfered = new TyTy::IntType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t     TyTy::IntType::IntKind::I32);\n+\tbreak;\n+\n+      case HIR::Literal::LitType::BOOL:\n+\tinfered = new TyTy::BoolType (expr.get_mappings ().get_hirid ());\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+  }\n+\n+private:\n+  TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+\n+  TyTy::TyBase *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_EXPR"}, {"sha": "29d6db62ff72d0924bcaf7e9a0ae0a060c005db3", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,90 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ITEM\n+#define RUST_HIR_TYPE_CHECK_ITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveFnType : public TyTy::TyVisitor\n+{\n+public:\n+  ResolveFnType (TyTy::TyBase *base) : base (base), state (nullptr) {}\n+\n+  TyTy::TyBase *go ()\n+  {\n+    base->accept_vis (*this);\n+    if (state == nullptr)\n+      gcc_unreachable ();\n+\n+    return state;\n+  }\n+\n+  void visit (TyTy::FnType &type) override { state = type.return_type (); }\n+\n+private:\n+  TyTy::TyBase *base;\n+  TyTy::TyBase *state;\n+};\n+\n+class TypeCheckItem : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Item *item)\n+  {\n+    TypeCheckItem resolver;\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *fnType;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &fnType))\n+      {\n+\trust_error_at (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+    // need to get the return type from this\n+    ResolveFnType resolve_fn_type (fnType);\n+    context->push_return_type (resolve_fn_type.go ());\n+\n+    // walk statements to make sure they are all typed correctly and they match\n+    // up\n+    function.function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      TypeCheckStmt::Resolve (s);\n+      return true;\n+    });\n+\n+    context->pop_return_type ();\n+  }\n+\n+private:\n+  TypeCheckItem () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ITEM"}, {"sha": "39c48f08c0a05e726616268416776e52695f3785", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STMT\n+#define RUST_HIR_TYPE_CHECK_STMT\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStmt : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Stmt *stmt)\n+  {\n+    TypeCheckStmt resolver;\n+    stmt->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    TyTy::TyBase *init_expr_ty = nullptr;\n+    if (stmt.has_init_expr ())\n+      init_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n+\n+    TyTy::TyBase *specified_ty = nullptr;\n+    if (stmt.has_type ())\n+      specified_ty = TypeCheckType::Resolve (stmt.get_type ());\n+\n+    // let x:i32 = 123;\n+    if (specified_ty != nullptr && init_expr_ty != nullptr)\n+      {\n+\tcontext->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t      specified_ty->combine (init_expr_ty));\n+      }\n+    else\n+      {\n+\t// let x:i32;\n+\tif (specified_ty != nullptr)\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  specified_ty);\n+\t  }\n+\t// let x = 123;\n+\telse if (init_expr_ty != nullptr)\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  init_expr_ty);\n+\t  }\n+\t// let x;\n+\telse\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  new TyTy::InferType (\n+\t\t\t\t    stmt.get_mappings ().get_hirid ()));\n+\t  }\n+      }\n+  }\n+\n+private:\n+  TypeCheckStmt () : TypeCheckBase () {}\n+}; // namespace Resolver\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STMT"}, {"sha": "c15aaef7d87bf51c9ec78c63d311b9594ae2a67b", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TOPLEVEL\n+#define RUST_HIR_TYPE_CHECK_TOPLEVEL\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckTopLevel : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Item *item)\n+  {\n+    TypeCheckTopLevel resolver;\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *ret_type = nullptr;\n+    if (!function.has_function_return_type ())\n+      ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n+    else\n+      ret_type = TypeCheckType::Resolve (function.return_type.get ());\n+\n+    std::vector<TyTy::TyBase *> params;\n+    for (auto &param : function.function_params)\n+      params.push_back (TypeCheckType::Resolve (param.type.get ()));\n+\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    params, ret_type);\n+    context->insert_type (function.get_mappings ().get_hirid (), fnType);\n+  }\n+\n+private:\n+  TypeCheckTopLevel () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TOPLEVEL"}, {"sha": "d8721a3caac43a4f1786985e289c7ec7960e2213", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TYPE\n+#define RUST_HIR_TYPE_CHECK_TYPE\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckType : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::Type *type)\n+  {\n+    TypeCheckType resolver;\n+    type->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      resolver.context->insert_type (type->get_mappings ().get_hirid (),\n+\t\t\t\t     resolver.translated);\n+\n+    return resolver.translated;\n+  }\n+\n+  virtual void visit (HIR::TypePath &path)\n+  {\n+    // check if this is already defined or not\n+    if (context->lookup_type (path.get_mappings ().get_hirid (), &translated))\n+      return;\n+\n+    // lookup the Node this resolves to\n+    NodeId ref;\n+    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t\t &ref))\n+      {\n+\trust_error_at (path.get_locus (), \"Type was not resolved\");\n+\treturn;\n+      }\n+\n+    HirId hir_lookup;\n+    if (context->lookup_type_by_node_id (ref, &hir_lookup))\n+      {\n+\t// we got an HIR node\n+\tif (context->lookup_type (hir_lookup, &translated))\n+\t  return;\n+      }\n+\n+    // this might be a struct type reference\n+    // TODO\n+    printf (\"UNREACHABLE %s\\n\", path.as_string ().c_str ());\n+    gcc_unreachable ();\n+  }\n+\n+private:\n+  TypeCheckType () : TypeCheckBase (), translated (nullptr) {}\n+\n+  TyTy::TyBase *translated;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TYPE"}, {"sha": "f9dbe495484146ffba5c57863d682539428a3696", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-toplevel.h\"\n+#include \"rust-hir-type-check-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeResolution::Resolve (HIR::Crate &crate)\n+{\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckTopLevel::Resolve (it->get ());\n+\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckItem::Resolve (it->get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "5a8abe1b01afb4fa4ee5cee56725fc28da85ebbe", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK\n+#define RUST_HIR_TYPE_CHECK\n+\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckContext\n+{\n+public:\n+  static TypeCheckContext *get ();\n+\n+  ~TypeCheckContext ();\n+\n+  void insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type);\n+\n+  void insert_type (HirId id, TyTy::TyBase *type);\n+  bool lookup_type (HirId id, TyTy::TyBase **type);\n+\n+  void insert_type_by_node_id (NodeId ref, HirId id);\n+  bool lookup_type_by_node_id (NodeId ref, HirId *id);\n+\n+  TyTy::TyBase *peek_return_type ();\n+  void push_return_type (TyTy::TyBase *return_type);\n+  void pop_return_type ();\n+\n+private:\n+  TypeCheckContext ();\n+\n+  std::map<NodeId, HirId> node_id_refs;\n+  std::map<HirId, TyTy::TyBase *> resolved;\n+  std::vector<std::unique_ptr<TyTy::TyBase> > builtins;\n+  std::vector<TyTy::TyBase *> return_type_stack;\n+};\n+\n+class TypeResolution\n+{\n+public:\n+  static void Resolve (HIR::Crate &crate);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK"}, {"sha": "195291e29b3390cc1acb02a3a3115c4ca152ac39", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckContext *\n+TypeCheckContext::get ()\n+{\n+  static TypeCheckContext *instance;\n+  if (instance == nullptr)\n+    instance = new TypeCheckContext ();\n+\n+  return instance;\n+}\n+\n+TypeCheckContext::TypeCheckContext () {}\n+\n+TypeCheckContext::~TypeCheckContext () {}\n+\n+void\n+TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type)\n+{\n+  printf (\"inserting builtin: hir %u node %u -> %s\\n\", id, ref,\n+\t  type->as_string ().c_str ());\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+  builtins.push_back (std::unique_ptr<TyTy::TyBase> (type));\n+}\n+\n+void\n+TypeCheckContext::insert_type (HirId id, TyTy::TyBase *type)\n+{\n+  rust_assert (resolved.find (id) == resolved.end ());\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type (HirId id, TyTy::TyBase **type)\n+{\n+  auto it = resolved.find (id);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_type_by_node_id (NodeId ref, HirId id)\n+{\n+  rust_assert (node_id_refs.find (ref) == node_id_refs.end ());\n+  node_id_refs[ref] = id;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n+{\n+  auto it = node_id_refs.find (ref);\n+  if (it == node_id_refs.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+TyTy::TyBase *\n+TypeCheckContext::peek_return_type ()\n+{\n+  return return_type_stack.back ();\n+}\n+\n+void\n+TypeCheckContext::push_return_type (TyTy::TyBase *return_type)\n+{\n+  return_type_stack.push_back (return_type);\n+}\n+\n+void\n+TypeCheckContext::pop_return_type ()\n+{\n+  return_type_stack.pop_back ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "d1341df6472d85142860cf8a164333878bc437d8", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CALL\n+#define RUST_TYTY_CALL\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TypeCheckCallExpr : private TyVisitor\n+{\n+public:\n+  static TyBase *go (TyBase *ref, HIR::CallExpr &call)\n+  {\n+    TypeCheckCallExpr checker (call);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+  ~TypeCheckCallExpr () {}\n+\n+  void visit (FnType &type) override;\n+\n+private:\n+  TypeCheckCallExpr (HIR::CallExpr &c) : resolved (nullptr), call (c) {}\n+\n+  TyBase *resolved;\n+  HIR::CallExpr &call;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CALL"}, {"sha": "375d909dc81b103528994e0cbf5d5b3ee96a465c", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,241 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_RULES\n+#define RUST_TYTY_RULES\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseRules : public TyVisitor\n+{\n+public:\n+  virtual ~BaseRules () {}\n+\n+  virtual void visit (UnitType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (InferType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ParamType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (BoolType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+protected:\n+  BaseRules (TyBase *base) : mappings (Analysis::Mappings::get ()), base (base)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+\n+private:\n+  TyBase *base;\n+};\n+\n+class InferRules : protected BaseRules\n+{\n+public:\n+  InferRules (InferType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~InferRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  InferType *base;\n+  TyBase *resolved;\n+};\n+\n+class UnitRules : protected BaseRules\n+{\n+public:\n+  UnitRules (UnitType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~UnitRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  UnitType *base;\n+  TyBase *resolved;\n+};\n+\n+class FnRules : protected BaseRules\n+{\n+public:\n+  FnRules (FnType *base) : BaseRules (base), base (base), resolved (nullptr) {}\n+  ~FnRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  FnType *base;\n+  TyBase *resolved;\n+};\n+\n+class ParamRules : protected BaseRules\n+{\n+public:\n+  ParamRules (ParamType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~ParamRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  ParamType *base;\n+  TyBase *resolved;\n+};\n+\n+class BoolRules : protected BaseRules\n+{\n+public:\n+  BoolRules (BoolType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~BoolRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref ());\n+  }\n+\n+private:\n+  BoolType *base;\n+  TyBase *resolved;\n+};\n+\n+class IntRules : protected BaseRules\n+{\n+public:\n+  IntRules (IntType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~IntRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    // FIXME we should look at the IntTypeKind and check if i8 vs i16 etc..\n+    resolved = new IntType (type.get_ref (), type.get_kind ());\n+  }\n+\n+private:\n+  IntType *base;\n+  TyBase *resolved;\n+};\n+\n+class UintRules : protected BaseRules\n+{\n+public:\n+  UintRules (UintType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~UintRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    // FIXME we should look at the IntTypeKind and check if u8 vs u16 etc..\n+    resolved = new UintType (type.get_ref (), type.get_kind ());\n+  }\n+\n+private:\n+  UintType *base;\n+  TyBase *resolved;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_RULES"}, {"sha": "68a8a433187df8e30736624827f764d6b872702e", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_VISITOR\n+#define RUST_TYTY_VISITOR\n+\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TyVisitor\n+{\n+public:\n+  virtual void visit (UnitType &type) {}\n+  virtual void visit (InferType &type) {}\n+  virtual void visit (FnType &type) {}\n+  virtual void visit (ParamType &type) {}\n+  virtual void visit (BoolType &type) {}\n+  virtual void visit (IntType &type) {}\n+  virtual void visit (UintType &type) {}\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_VISITOR"}, {"sha": "21244088251052aa095acf82d654d5acccf10536", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,223 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-tyty-rules.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+void\n+UnitType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+UnitType::as_string () const\n+{\n+  return \"()\";\n+}\n+\n+TyBase *\n+UnitType::combine (TyBase *other)\n+{\n+  UnitRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+InferType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+InferType::as_string () const\n+{\n+  return \"[_]\";\n+}\n+\n+TyBase *\n+InferType::combine (TyBase *other)\n+{\n+  InferRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+FnType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FnType::as_string () const\n+{\n+  std::string params_str = \"\";\n+  for (auto &param : params)\n+    {\n+      params_str += param->as_string ();\n+      params_str += \",\";\n+    }\n+\n+  std::string ret_str = type->as_string ();\n+  return \"fn (\" + params_str + \") -> \" + ret_str;\n+}\n+\n+TyBase *\n+FnType::combine (TyBase *other)\n+{\n+  FnRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+ParamType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ParamType::as_string () const\n+{\n+  return \"(\" + type->as_string () + \")\";\n+}\n+\n+TyBase *\n+ParamType::combine (TyBase *other)\n+{\n+  ParamRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+BoolType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+BoolType::as_string () const\n+{\n+  return \"bool\";\n+}\n+\n+TyBase *\n+BoolType::combine (TyBase *other)\n+{\n+  BoolRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+IntType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+IntType::as_string () const\n+{\n+  switch (int_kind)\n+    {\n+    case I8:\n+      return \"i8\";\n+    case I16:\n+      return \"i16\";\n+    case I32:\n+      return \"i32\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_int_type\";\n+}\n+\n+TyBase *\n+IntType::combine (TyBase *other)\n+{\n+  IntRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+UintType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+UintType::as_string () const\n+{\n+  switch (uint_kind)\n+    {\n+    case U8:\n+      return \"u8\";\n+    case U16:\n+      return \"u16\";\n+    case U32:\n+      return \"u32\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_uint_type\";\n+}\n+\n+TyBase *\n+UintType::combine (TyBase *other)\n+{\n+  UintRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (), \"differing number of arguments\");\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+    TyBase *pt = type.param_at (i);\n+    auto t = Resolver::TypeCheckExpr::Resolve (p);\n+    if (t == nullptr)\n+      {\n+\trust_error_at (p->get_locus_slow (), \"failed to resolve type\");\n+\treturn false;\n+      }\n+\n+    auto res = pt->combine (t);\n+    if (res == nullptr)\n+      return false;\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != call.num_params ())\n+    return;\n+\n+  resolved = type.get_return_type ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "688643cd692c2f8b67803b2b40523bd83c7de2ad", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -0,0 +1,208 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY\n+#define RUST_TYTY\n+\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants\n+enum TypeKind\n+{\n+  INFER,\n+  ADT,\n+  STR,\n+  REF,\n+  PARAM,\n+  ARRAY,\n+  FNDEF,\n+  TUPLE,\n+  BOOL,\n+  CHAR,\n+  INT,\n+  UINT,\n+  FLOAT,\n+  UNIT,\n+  // there are more to add...\n+};\n+\n+class TyVisitor;\n+class TyBase\n+{\n+public:\n+  ~TyBase () {}\n+\n+  HirId get_ref () const { return ref; }\n+\n+  virtual void accept_vis (TyVisitor &vis) = 0;\n+\n+  virtual bool is_unit () const { return false; }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual TyBase *combine (TyBase *other) = 0;\n+\n+protected:\n+  TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n+\n+  TypeKind kind;\n+  HirId ref;\n+};\n+\n+class InferType : public TyBase\n+{\n+public:\n+  InferType (HirId ref) : TyBase (ref, TypeKind::INFER) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return true; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class UnitType : public TyBase\n+{\n+public:\n+  UnitType (HirId ref) : TyBase (ref, TypeKind::UNIT) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return true; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class FnType : public TyBase\n+{\n+public:\n+  FnType (HirId ref, std::vector<TyBase *> params, TyBase *type)\n+    : TyBase (ref, TypeKind::FNDEF), params (params), type (type)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *return_type () { return type; }\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  TyBase *param_at (size_t idx) { return params[idx]; }\n+\n+  TyBase *get_return_type () { return type; }\n+\n+private:\n+  std::vector<TyBase *> params;\n+  TyBase *type;\n+};\n+\n+class ParamType : public TyBase\n+{\n+public:\n+  ParamType (HirId ref, TyBase *type)\n+    : TyBase (ref, TypeKind::PARAM), type (type)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+private:\n+  TyBase *type;\n+};\n+\n+class BoolType : public TyBase\n+{\n+public:\n+  BoolType (HirId ref) : TyBase (ref, TypeKind::BOOL) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class IntType : public TyBase\n+{\n+public:\n+  enum IntKind\n+  {\n+    I8,\n+    I16,\n+    I32,\n+  };\n+\n+  IntType (HirId ref, IntKind kind)\n+    : TyBase (ref, TypeKind::INT), int_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  IntKind get_kind () const { return int_kind; }\n+\n+private:\n+  IntKind int_kind;\n+};\n+\n+class UintType : public TyBase\n+{\n+public:\n+  enum UintKind\n+  {\n+    U8,\n+    U16,\n+    U32,\n+  };\n+\n+  UintType (HirId ref, UintKind kind)\n+    : TyBase (ref, TypeKind::UINT), uint_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  UintKind get_kind () const { return uint_kind; }\n+\n+private:\n+  UintKind uint_kind;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY"}, {"sha": "70c59f323112e1d29de403496b191a6c806e38b8", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -133,6 +133,8 @@ Mappings::get_current_crate ()\n       hirIdIter[currentCrateNum] = UNKNOWN_HIRID;\n       nodeIdIter[currentCrateNum] = UNKNOWN_NODEID;\n       localIdIter[currentCrateNum] = UNKNOWN_LOCAL_DEFID;\n+      nodeIdToHirMappings[currentCrateNum] = {};\n+      locations[currentCrateNum] = {};\n     }\n \n   return currentCrateNum;\n@@ -157,7 +159,7 @@ Mappings::get_next_hir_id (CrateNum crateNum)\n \n   auto id = it->second + 1;\n   hirIdIter[crateNum] = id;\n-  return id++;\n+  return id;\n }\n \n LocalDefId\n@@ -238,6 +240,7 @@ Mappings::insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item)\n   rust_assert (lookup_hir_item (crateNum, id) == nullptr);\n \n   hirItemMappings[crateNum][id] = item;\n+  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n }\n \n HIR::Item *\n@@ -260,6 +263,8 @@ Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n   rust_assert (lookup_hir_expr (crateNum, id) == nullptr);\n \n   hirExprMappings[crateNum][id] = expr;\n+  nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n+  insert_location (crateNum, id, expr->get_locus_slow ());\n }\n \n HIR::Expr *\n@@ -276,6 +281,29 @@ Mappings::lookup_hir_expr (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type)\n+{\n+  rust_assert (lookup_hir_type (crateNum, id) == nullptr);\n+\n+  hirTypeMappings[crateNum][id] = type;\n+  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::Type *\n+Mappings::lookup_hir_type (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirTypeMappings.find (crateNum);\n+  if (it == hirTypeMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n \t\t\t\t      HIR::Item *item)\n@@ -314,5 +342,40 @@ Mappings::walk_local_defids_for_crate (CrateNum crateNum,\n     }\n }\n \n+bool\n+Mappings::lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref)\n+{\n+  auto it = nodeIdToHirMappings.find (crate);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  *ref = iy->second;\n+  return true;\n+}\n+\n+void\n+Mappings::insert_location (CrateNum crate, HirId id, Location locus)\n+{\n+  locations[crate][id] = locus;\n+}\n+\n+Location\n+Mappings::lookup_location (CrateNum crate, HirId id)\n+{\n+  auto it = locations.find (crate);\n+  if (it == locations.end ())\n+    return Location ();\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return Location ();\n+\n+  return iy->second;\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "7fc877707a5a4eb9c2c43ff053427b49f522dc93", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d10d9547612b5fda3d27bb628d5d6ee79108af/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=44d10d9547612b5fda3d27bb628d5d6ee79108af", "patch": "@@ -20,6 +20,7 @@\n #define RUST_HIR_MAP_H\n \n #include \"rust-system.h\"\n+#include \"rust-location.h\"\n \n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n@@ -40,11 +41,11 @@ typedef uint64_t DefId;\n #define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n #define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n \n-#define UNKNOWN_CREATENUM ((uint32_t) (-1))\n-#define UNKNOWN_NODEID ((uint32_t) (-1))\n-#define UNKNOWN_HIRID ((uint32_t) (-1))\n-#define UNKNOWN_LOCAL_DEFID ((uint32_t) (-1))\n-#define UNKNOWN_DEFID ((uint64_t) (-1))\n+#define UNKNOWN_CREATENUM ((uint32_t) (0))\n+#define UNKNOWN_NODEID ((uint32_t) (0))\n+#define UNKNOWN_HIRID ((uint32_t) (0))\n+#define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n+#define UNKNOWN_DEFID ((uint64_t) (0))\n \n namespace Analysis {\n \n@@ -86,7 +87,10 @@ class Mappings\n \n   NodeId get_next_node_id () { return get_next_node_id (get_current_crate ()); }\n   NodeId get_next_node_id (CrateNum crateNum);\n+\n+  HirId get_next_hir_id () { return get_next_hir_id (get_current_crate ()); }\n   HirId get_next_hir_id (CrateNum crateNum);\n+\n   LocalDefId get_next_localdef_id (CrateNum crateNum);\n \n   AST::Crate *get_ast_crate (CrateNum crateNum);\n@@ -108,9 +112,21 @@ class Mappings\n   void insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr);\n   HIR::Expr *lookup_hir_expr (CrateNum crateNum, HirId id);\n \n+  void insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type);\n+  HIR::Type *lookup_hir_type (CrateNum crateNum, HirId id);\n+\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n+  bool lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref);\n+\n+  void insert_location (CrateNum crate, HirId id, Location locus);\n+  Location lookup_location (CrateNum crate, HirId id);\n+  Location lookup_location (HirId id)\n+  {\n+    return lookup_location (get_current_crate (), id);\n+  }\n+\n private:\n   Mappings ();\n \n@@ -127,8 +143,12 @@ class Mappings\n   std::map<DefId, HIR::Item *> defIdMappings;\n   std::map<CrateNum, std::map<LocalDefId, HIR::Item *> > localDefIdMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Item *> > hirItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Type *> > hirTypeMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n \n+  // location info\n+  std::map<CrateNum, std::map<NodeId, Location> > locations;\n+\n   // reverse mappings\n   std::map<CrateNum, std::map<NodeId, HirId> > nodeIdToHirMappings;\n };"}, {"sha": "87decd5482ce4e2aa9fe071b6bd4d5c1c6776de1", "filename": "gcc/rust/util/rust-inference-var.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-inference-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-inference-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-inference-var.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -1,112 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_INFERENCE_VAR\n-#define RUST_HIR_INFERENCE_VAR\n-\n-#include \"rust-system.h\"\n-#include \"rust-hir-full-decls.h\"\n-\n-namespace Rust {\n-namespace HIR {\n-\n-class GeneralInferenceVariable;\n-class IntegralInferenceVariable;\n-class FloatInferenceVariable;\n-class InferenceVarVisitor\n-{\n-public:\n-  virtual void visit (GeneralInferenceVariable &v) {}\n-  virtual void visit (IntegralInferenceVariable &v) {}\n-  virtual void visit (FloatInferenceVariable &v) {}\n-};\n-\n-// Base\n-class InferenceVariable\n-{\n-public:\n-  virtual ~InferenceVariable () {}\n-\n-  virtual std::string as_string () const = 0;\n-\n-  HIR::Type *get_type () { return resolved; }\n-\n-  void set_type (HIR::Type *type) { resolved = type; }\n-\n-  bool was_resolved () { return resolved != nullptr; }\n-\n-  virtual void accept_vis (InferenceVarVisitor &vis) = 0;\n-\n-protected:\n-  InferenceVariable () : resolved (nullptr) {}\n-\n-  HIR::Type *resolved;\n-};\n-\n-class GeneralInferenceVariable : public InferenceVariable\n-{\n-public:\n-  GeneralInferenceVariable () : InferenceVariable () {}\n-\n-  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n-\n-  std::string as_string () const override\n-  {\n-    if (resolved)\n-      return resolved->as_string ();\n-\n-    return \"[G::?T]\";\n-  }\n-};\n-\n-class IntegralInferenceVariable : public InferenceVariable\n-{\n-public:\n-  IntegralInferenceVariable () : InferenceVariable () {}\n-\n-  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n-\n-  std::string as_string () const override\n-  {\n-    if (resolved)\n-      return resolved->as_string ();\n-\n-    return \"[I::?T]\";\n-  }\n-};\n-\n-class FloatInferenceVariable : public InferenceVariable\n-{\n-public:\n-  FloatInferenceVariable () : InferenceVariable () {}\n-\n-  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n-\n-  std::string as_string () const override\n-  {\n-    if (resolved)\n-      return resolved->as_string ();\n-\n-    return \"[F::?T]\";\n-  }\n-};\n-\n-} // namespace HIR\n-} // namespace Rust\n-\n-#endif // RUST_HIR_INFERENCE_VAR"}]}