{"sha": "ca3f2950267c25a44aa73f8290b5fb407af81260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzZjI5NTAyNjdjMjVhNDRhYTczZjgyOTBiNWZiNDA3YWY4MTI2MA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-17T21:12:24Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-17T21:12:24Z"}, "message": "output.h (split_double): Move prototype to rtl.h.\n\n\t* output.h (split_double): Move prototype to rtl.h.\n\t(constructor_static_from_elts_p): Move prototype to tree.c.\n\t* rtl.h (split_double): Moved here from output.h.\n\t* tree.h (constructor_static_from_elts_p): Moved here from output.h.\n\t* final.c (split_double): Move from here ...\n\t* rtlanal.c (split_double): ... to here.\n\t* expr.c: Do not include output.h.\n\nFrom-SVN: r188714", "tree": {"sha": "e814ff4111b16d31e2e72a0a4c64d66ee862eaf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e814ff4111b16d31e2e72a0a4c64d66ee862eaf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3f2950267c25a44aa73f8290b5fb407af81260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3f2950267c25a44aa73f8290b5fb407af81260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3f2950267c25a44aa73f8290b5fb407af81260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3f2950267c25a44aa73f8290b5fb407af81260/comments", "author": null, "committer": null, "parents": [{"sha": "172a84ffae1199c36f0c0c3ac5721f13808d2041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/172a84ffae1199c36f0c0c3ac5721f13808d2041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/172a84ffae1199c36f0c0c3ac5721f13808d2041"}], "stats": {"total": 317, "additions": 162, "deletions": 155}, "files": [{"sha": "7c9b56e57071957174a44481dab5fd1d1031a55e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -1,3 +1,13 @@\n+2012-06-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* output.h (split_double): Move prototype to rtl.h.\n+\t(constructor_static_from_elts_p): Move prototype to tree.c.\n+\t* rtl.h (split_double): Moved here from output.h.\n+\t* tree.h (constructor_static_from_elts_p): Moved here from output.h.\n+\t* final.c (split_double): Move from here ...\n+\t* rtlanal.c (split_double): ... to here.\n+\t* expr.c: Do not include output.h.\n+\n 2012-06-17  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfglayout.h: Remove."}, {"sha": "6012c5d318905ce59ba3ce8135e10097972abb90", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libfuncs.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n-#include \"output.h\"\n #include \"typeclass.h\"\n #include \"toplev.h\"\n #include \"langhooks.h\""}, {"sha": "78e9620c4fd2c87af01f54f8bc855f5b72e4d578", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -4068,149 +4068,6 @@ asm_fprintf (FILE *file, const char *p, ...)\n   va_end (argptr);\n }\n \f\n-/* Split up a CONST_DOUBLE or integer constant rtx\n-   into two rtx's for single words,\n-   storing in *FIRST the word that comes first in memory in the target\n-   and in *SECOND the other.  */\n-\n-void\n-split_double (rtx value, rtx *first, rtx *second)\n-{\n-  if (CONST_INT_P (value))\n-    {\n-      if (HOST_BITS_PER_WIDE_INT >= (2 * BITS_PER_WORD))\n-\t{\n-\t  /* In this case the CONST_INT holds both target words.\n-\t     Extract the bits from it into two word-sized pieces.\n-\t     Sign extend each half to HOST_WIDE_INT.  */\n-\t  unsigned HOST_WIDE_INT low, high;\n-\t  unsigned HOST_WIDE_INT mask, sign_bit, sign_extend;\n-\t  unsigned bits_per_word = BITS_PER_WORD;\n-\n-\t  /* Set sign_bit to the most significant bit of a word.  */\n-\t  sign_bit = 1;\n-\t  sign_bit <<= bits_per_word - 1;\n-\n-\t  /* Set mask so that all bits of the word are set.  We could\n-\t     have used 1 << BITS_PER_WORD instead of basing the\n-\t     calculation on sign_bit.  However, on machines where\n-\t     HOST_BITS_PER_WIDE_INT == BITS_PER_WORD, it could cause a\n-\t     compiler warning, even though the code would never be\n-\t     executed.  */\n-\t  mask = sign_bit << 1;\n-\t  mask--;\n-\n-\t  /* Set sign_extend as any remaining bits.  */\n-\t  sign_extend = ~mask;\n-\n-\t  /* Pick the lower word and sign-extend it.  */\n-\t  low = INTVAL (value);\n-\t  low &= mask;\n-\t  if (low & sign_bit)\n-\t    low |= sign_extend;\n-\n-\t  /* Pick the higher word, shifted to the least significant\n-\t     bits, and sign-extend it.  */\n-\t  high = INTVAL (value);\n-\t  high >>= bits_per_word - 1;\n-\t  high >>= 1;\n-\t  high &= mask;\n-\t  if (high & sign_bit)\n-\t    high |= sign_extend;\n-\n-\t  /* Store the words in the target machine order.  */\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      *first = GEN_INT (high);\n-\t      *second = GEN_INT (low);\n-\t    }\n-\t  else\n-\t    {\n-\t      *first = GEN_INT (low);\n-\t      *second = GEN_INT (high);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* The rule for using CONST_INT for a wider mode\n-\t     is that we regard the value as signed.\n-\t     So sign-extend it.  */\n-\t  rtx high = (INTVAL (value) < 0 ? constm1_rtx : const0_rtx);\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    {\n-\t      *first = high;\n-\t      *second = value;\n-\t    }\n-\t  else\n-\t    {\n-\t      *first = value;\n-\t      *second = high;\n-\t    }\n-\t}\n-    }\n-  else if (GET_CODE (value) != CONST_DOUBLE)\n-    {\n-      if (WORDS_BIG_ENDIAN)\n-\t{\n-\t  *first = const0_rtx;\n-\t  *second = value;\n-\t}\n-      else\n-\t{\n-\t  *first = value;\n-\t  *second = const0_rtx;\n-\t}\n-    }\n-  else if (GET_MODE (value) == VOIDmode\n-\t   /* This is the old way we did CONST_DOUBLE integers.  */\n-\t   || GET_MODE_CLASS (GET_MODE (value)) == MODE_INT)\n-    {\n-      /* In an integer, the words are defined as most and least significant.\n-\t So order them by the target's convention.  */\n-      if (WORDS_BIG_ENDIAN)\n-\t{\n-\t  *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n-\t  *second = GEN_INT (CONST_DOUBLE_LOW (value));\n-\t}\n-      else\n-\t{\n-\t  *first = GEN_INT (CONST_DOUBLE_LOW (value));\n-\t  *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n-\t}\n-    }\n-  else\n-    {\n-      REAL_VALUE_TYPE r;\n-      long l[2];\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, value);\n-\n-      /* Note, this converts the REAL_VALUE_TYPE to the target's\n-\t format, splits up the floating point double and outputs\n-\t exactly 32 bits of it into each of l[0] and l[1] --\n-\t not necessarily BITS_PER_WORD bits.  */\n-      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\n-      /* If 32 bits is an entire word for the target, but not for the host,\n-\t then sign-extend on the host so that the number will look the same\n-\t way on the host that it would on the target.  See for instance\n-\t simplify_unary_operation.  The #if is needed to avoid compiler\n-\t warnings.  */\n-\n-#if HOST_BITS_PER_LONG > 32\n-      if (BITS_PER_WORD < HOST_BITS_PER_LONG && BITS_PER_WORD == 32)\n-\t{\n-\t  if (l[0] & ((long) 1 << 31))\n-\t    l[0] |= ((long) (-1) << 32);\n-\t  if (l[1] & ((long) 1 << 31))\n-\t    l[1] |= ((long) (-1) << 32);\n-\t}\n-#endif\n-\n-      *first = GEN_INT (l[0]);\n-      *second = GEN_INT (l[1]);\n-    }\n-}\n-\f\n /* Return nonzero if this function has no function calls.  */\n \n int"}, {"sha": "dfd6e548c2cc8c4e8b3dd809c554d11377879015", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -132,10 +132,6 @@ extern int sprint_ul (char *, unsigned long);\n extern void asm_fprintf (FILE *file, const char *p, ...)\n      ATTRIBUTE_ASM_FPRINTF(2, 3);\n \n-/* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n-   words.  */\n-extern void split_double (rtx, rtx *, rtx *);\n-\n /* Return nonzero if this function has no function calls.  */\n extern int leaf_function_p (void);\n \n@@ -292,13 +288,6 @@ extern void output_object_blocks (void);\n \n extern void output_quoted_string (FILE *, const char *);\n \n-/* Whether a constructor CTOR is a valid static constant initializer if all\n-   its elements are.  This used to be internal to initializer_constant_valid_p\n-   and has been exposed to let other functions like categorize_ctor_elements\n-   evaluate the property while walking a constructor for other purposes.  */\n-\n-extern bool constructor_static_from_elts_p (const_tree);\n-\n /* Output assembler code for constant EXP to FILE, with no label.\n    This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n    Assumes output_addressed_constants has been done on EXP already."}, {"sha": "cbed2005e32e1fcf131529437dc662262cccc1f9", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -1226,6 +1226,7 @@ extern unsigned int num_sign_bit_copies (const_rtx, enum machine_mode);\n extern bool constant_pool_constant_p (rtx);\n extern bool truncated_to_mode (enum machine_mode, const_rtx);\n extern int low_bitmask_len (enum machine_mode, unsigned HOST_WIDE_INT);\n+extern void split_double (rtx, rtx *, rtx *);\n \n #ifndef GENERATOR_FILE\n /* Return the cost of SET X.  SPEED_P is true if optimizing for speed"}, {"sha": "f3527b4f1a6bb5bf8d4bffc20db70a78c455df66", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -5293,3 +5293,147 @@ get_address_mode (rtx mem)\n     return mode;\n   return targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));\n }\n+\f\n+/* Split up a CONST_DOUBLE or integer constant rtx\n+   into two rtx's for single words,\n+   storing in *FIRST the word that comes first in memory in the target\n+   and in *SECOND the other.  */\n+\n+void\n+split_double (rtx value, rtx *first, rtx *second)\n+{\n+  if (CONST_INT_P (value))\n+    {\n+      if (HOST_BITS_PER_WIDE_INT >= (2 * BITS_PER_WORD))\n+\t{\n+\t  /* In this case the CONST_INT holds both target words.\n+\t     Extract the bits from it into two word-sized pieces.\n+\t     Sign extend each half to HOST_WIDE_INT.  */\n+\t  unsigned HOST_WIDE_INT low, high;\n+\t  unsigned HOST_WIDE_INT mask, sign_bit, sign_extend;\n+\t  unsigned bits_per_word = BITS_PER_WORD;\n+\n+\t  /* Set sign_bit to the most significant bit of a word.  */\n+\t  sign_bit = 1;\n+\t  sign_bit <<= bits_per_word - 1;\n+\n+\t  /* Set mask so that all bits of the word are set.  We could\n+\t     have used 1 << BITS_PER_WORD instead of basing the\n+\t     calculation on sign_bit.  However, on machines where\n+\t     HOST_BITS_PER_WIDE_INT == BITS_PER_WORD, it could cause a\n+\t     compiler warning, even though the code would never be\n+\t     executed.  */\n+\t  mask = sign_bit << 1;\n+\t  mask--;\n+\n+\t  /* Set sign_extend as any remaining bits.  */\n+\t  sign_extend = ~mask;\n+\n+\t  /* Pick the lower word and sign-extend it.  */\n+\t  low = INTVAL (value);\n+\t  low &= mask;\n+\t  if (low & sign_bit)\n+\t    low |= sign_extend;\n+\n+\t  /* Pick the higher word, shifted to the least significant\n+\t     bits, and sign-extend it.  */\n+\t  high = INTVAL (value);\n+\t  high >>= bits_per_word - 1;\n+\t  high >>= 1;\n+\t  high &= mask;\n+\t  if (high & sign_bit)\n+\t    high |= sign_extend;\n+\n+\t  /* Store the words in the target machine order.  */\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    {\n+\t      *first = GEN_INT (high);\n+\t      *second = GEN_INT (low);\n+\t    }\n+\t  else\n+\t    {\n+\t      *first = GEN_INT (low);\n+\t      *second = GEN_INT (high);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* The rule for using CONST_INT for a wider mode\n+\t     is that we regard the value as signed.\n+\t     So sign-extend it.  */\n+\t  rtx high = (INTVAL (value) < 0 ? constm1_rtx : const0_rtx);\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    {\n+\t      *first = high;\n+\t      *second = value;\n+\t    }\n+\t  else\n+\t    {\n+\t      *first = value;\n+\t      *second = high;\n+\t    }\n+\t}\n+    }\n+  else if (GET_CODE (value) != CONST_DOUBLE)\n+    {\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  *first = const0_rtx;\n+\t  *second = value;\n+\t}\n+      else\n+\t{\n+\t  *first = value;\n+\t  *second = const0_rtx;\n+\t}\n+    }\n+  else if (GET_MODE (value) == VOIDmode\n+\t   /* This is the old way we did CONST_DOUBLE integers.  */\n+\t   || GET_MODE_CLASS (GET_MODE (value)) == MODE_INT)\n+    {\n+      /* In an integer, the words are defined as most and least significant.\n+\t So order them by the target's convention.  */\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t  *second = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t}\n+      else\n+\t{\n+\t  *first = GEN_INT (CONST_DOUBLE_LOW (value));\n+\t  *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n+\t}\n+    }\n+  else\n+    {\n+      REAL_VALUE_TYPE r;\n+      long l[2];\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, value);\n+\n+      /* Note, this converts the REAL_VALUE_TYPE to the target's\n+\t format, splits up the floating point double and outputs\n+\t exactly 32 bits of it into each of l[0] and l[1] --\n+\t not necessarily BITS_PER_WORD bits.  */\n+      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+\n+      /* If 32 bits is an entire word for the target, but not for the host,\n+\t then sign-extend on the host so that the number will look the same\n+\t way on the host that it would on the target.  See for instance\n+\t simplify_unary_operation.  The #if is needed to avoid compiler\n+\t warnings.  */\n+\n+#if HOST_BITS_PER_LONG > 32\n+      if (BITS_PER_WORD < HOST_BITS_PER_LONG && BITS_PER_WORD == 32)\n+\t{\n+\t  if (l[0] & ((long) 1 << 31))\n+\t    l[0] |= ((long) (-1) << 32);\n+\t  if (l[1] & ((long) 1 << 31))\n+\t    l[1] |= ((long) (-1) << 32);\n+\t}\n+#endif\n+\n+      *first = GEN_INT (l[0]);\n+      *second = GEN_INT (l[1]);\n+    }\n+}\n+"}, {"sha": "1539becd95c6f9e3da7c6c72292f35a13843e37c", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3f2950267c25a44aa73f8290b5fb407af81260/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ca3f2950267c25a44aa73f8290b5fb407af81260", "patch": "@@ -5709,6 +5709,13 @@ extern tree initializer_constant_valid_p (tree, tree);\n    an element of a \"constant\" initializer.  */\n extern bool initializer_constant_valid_for_bitfield_p (tree);\n \n+/* Whether a constructor CTOR is a valid static constant initializer if all\n+   its elements are.  This used to be internal to initializer_constant_valid_p\n+   and has been exposed to let other functions like categorize_ctor_elements\n+   evaluate the property while walking a constructor for other purposes.  */\n+\n+extern bool constructor_static_from_elts_p (const_tree);\n+\n /* In stmt.c */\n extern void expand_computed_goto (tree);\n extern bool parse_output_constraint (const char **, int, int, int,"}]}