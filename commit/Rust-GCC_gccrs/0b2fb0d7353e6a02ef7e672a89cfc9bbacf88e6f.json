{"sha": "0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyZmIwZDczNTNlNmEwMmVmN2U2NzJhODljZmM5YmJhY2Y4OGU2Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2002-05-03T21:13:25Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2002-05-03T21:13:25Z"}, "message": "genautomata.c (min_issue_delay_pass_states): Change return type in the prototype.\n\n2002-05-03  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c (min_issue_delay_pass_states): Change return type\n\tin the prototype.\n\t(min_issue_delay_pass_states): Change the algorithm.\n\t(min_issue_delay): Set up min_insn_issue_delay for the state.\n\t(output_min_issue_delay_table): Interchange the nested loops and\n\tand initiate min_insn_issue_delay for states.\n\nFrom-SVN: r53130", "tree": {"sha": "c16cb616357ad992fcf42ec80e70266b0d871ecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c16cb616357ad992fcf42ec80e70266b0d871ecd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d4ce12a5acd0210b6c90b3dd8a7c5033be19562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4ce12a5acd0210b6c90b3dd8a7c5033be19562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d4ce12a5acd0210b6c90b3dd8a7c5033be19562"}], "stats": {"total": 75, "additions": 47, "deletions": 28}, "files": [{"sha": "bba1c7e72134fce99782d58c5860b2bb4f1ae051", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "patch": "@@ -1,3 +1,12 @@\n+2002-05-03  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (min_issue_delay_pass_states): Change return type\n+\tin the prototype.\n+\t(min_issue_delay_pass_states): Change the algorithm.\n+\t(min_issue_delay): Set up min_insn_issue_delay for the state.\n+\t(output_min_issue_delay_table): Interchange the nested loops and\n+\tand initiate min_insn_issue_delay for states.\n+\t\n Fri May  3 22:59:15 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* cfgcleanup.c (try_optimize_cfg):  Call merge_block only when"}, {"sha": "f39aab3df4ade9e8830e8c1de0c2e9af3f2da21c", "filename": "gcc/genautomata.c", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=0b2fb0d7353e6a02ef7e672a89cfc9bbacf88e6f", "patch": "@@ -1,5 +1,5 @@\n /* Pipeline hazard description translator.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n \n    Written by Vladimir Makarov <vmakarov@redhat.com>\n    \n@@ -448,7 +448,7 @@ static void add_vect_el \t         PARAMS ((vla_hwint_t *,\n static void add_states_vect_el           PARAMS ((state_t));\n static void output_trans_table           PARAMS ((automaton_t));\n static void output_state_alts_table      PARAMS ((automaton_t));\n-static void min_issue_delay_pass_states  PARAMS ((state_t, ainsn_t));\n+static int min_issue_delay_pass_states  PARAMS ((state_t, ainsn_t));\n static int min_issue_delay               PARAMS ((state_t, ainsn_t));\n static void initiate_min_issue_delay_pass_states PARAMS ((void));\n static void output_min_issue_delay_table PARAMS ((automaton_t));\n@@ -7114,19 +7114,24 @@ static int curr_state_pass_num;\n \n \n /* This recursive function passes states to find minimal issue delay\n-   value for AINSN.  The state being visited is STATE.  */\n-static void\n+   value for AINSN.  The state being visited is STATE.  The function\n+   returns minimal issue delay value for AINSN in STATE or -1 if we\n+   enter into a loop.  */\n+static int\n min_issue_delay_pass_states (state, ainsn)\n      state_t state;\n      ainsn_t ainsn;\n {\n   arc_t arc;\n   int min_insn_issue_delay, insn_issue_delay;\n \n-  if (state->state_pass_num == curr_state_pass_num)\n-    return;\n+  if (state->state_pass_num == curr_state_pass_num\n+      || state->min_insn_issue_delay != -1)\n+    /* We've entered into a loop or already have the correct value for\n+       given state and ainsn. */\n+    return state->min_insn_issue_delay;\n   state->state_pass_num = curr_state_pass_num;\n-  min_insn_issue_delay = state->min_insn_issue_delay = -1;\n+  min_insn_issue_delay = -1;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     if (arc->insn == ainsn)\n       {\n@@ -7135,31 +7140,34 @@ min_issue_delay_pass_states (state, ainsn)\n       }\n     else\n       {\n-        min_issue_delay_pass_states (arc->to_state, ainsn);\n-\tif (arc->to_state->min_insn_issue_delay != -1)\n+        insn_issue_delay = min_issue_delay_pass_states (arc->to_state, ainsn);\n+\tif (insn_issue_delay != -1)\n \t  {\n-\t    insn_issue_delay\n-\t      = (arc->to_state->min_insn_issue_delay\n-\t\t + (arc->insn->insn_reserv_decl\n-\t\t    == &advance_cycle_insn_decl->decl.insn_reserv ? 1 : 0));\n+\t    if (arc->insn->insn_reserv_decl\n+\t\t== &advance_cycle_insn_decl->decl.insn_reserv)\n+\t      insn_issue_delay++;\n \t    if (min_insn_issue_delay == -1\n \t\t|| min_insn_issue_delay > insn_issue_delay)\n-\t      min_insn_issue_delay = insn_issue_delay;\n+\t      {\n+\t\tmin_insn_issue_delay = insn_issue_delay;\n+\t\tif (insn_issue_delay == 0)\n+\t\t  break;\n+\t      }\n \t  }\n       }\n-  state->min_insn_issue_delay = min_insn_issue_delay;\n+  return min_insn_issue_delay;\n }\n \n /* The function searches minimal issue delay value for AINSN in STATE.\n-   The function can return negative can not issue AINSN.  We will\n-   report about it later.  */\n+   The function can return negative value if we can not issue AINSN.  We\n+   will report about it later.  */\n static int\n min_issue_delay (state, ainsn)\n      state_t state;\n      ainsn_t ainsn;\n {\n   curr_state_pass_num++;\n-  min_issue_delay_pass_states (state, ainsn);\n+  state->min_insn_issue_delay = min_issue_delay_pass_states (state, ainsn);\n   return state->min_insn_issue_delay;\n }\n \n@@ -7199,15 +7207,17 @@ output_min_issue_delay_table (automaton)\n        i++)\n     VLA_HWINT (min_issue_delay_vect, i) = 0;\n   automaton->max_min_delay = 0;\n-  for (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n-       state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n-       state_ptr++)\n-    {\n-      for (ainsn = automaton->ainsn_list;\n-\t   ainsn != NULL;\n-\t   ainsn = ainsn->next_ainsn)\n-        if (ainsn->first_ainsn_with_given_equialence_num)\n-          {\n+  for (ainsn = automaton->ainsn_list; ainsn != NULL; ainsn = ainsn->next_ainsn)\n+    if (ainsn->first_ainsn_with_given_equialence_num)\n+      {\n+\tfor (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n+\t     state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n+\t     state_ptr++)\n+\t  (*state_ptr)->min_insn_issue_delay = -1;\n+\tfor (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n+\t     state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n+\t     state_ptr++)\n+\t  {\n             min_delay = min_issue_delay (*state_ptr, ainsn);\n \t    if (automaton->max_min_delay < min_delay)\n \t      automaton->max_min_delay = min_delay;\n@@ -7216,7 +7226,7 @@ output_min_issue_delay_table (automaton)\n \t\t       * automaton->insn_equiv_classes_num\n \t\t       + ainsn->insn_equiv_class_num) = min_delay;\n \t  }\n-    }\n+      }\n   fprintf (output_file, \"/* Vector of min issue delay of insns.*/\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, automaton->max_min_delay);"}]}