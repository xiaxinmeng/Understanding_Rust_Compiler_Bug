{"sha": "f89b66f5ad705120584101c4d7a15532d0286e9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5YjY2ZjVhZDcwNTEyMDU4NDEwMWM0ZDdhMTU1MzJkMDI4NmU5ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-28T18:00:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-12-28T18:00:30Z"}, "message": "net: work around Solaris connect issue when server closes socket\n\nOn Solaris, if you do a in-progress connect, and then the\nserver accepts and closes the socket, the client's later\nattempt to complete the connect will fail with EINVAL.  Handle\nthis case by assuming that the connect succeeded.  This code\nis weird enough that it is implemented as Solaris-only so that\nit doesn't hide a real error on a different OS.\n\nSee http://golang.org/issue/6828.\n\nFrom-SVN: r206232", "tree": {"sha": "edcb545da1741175776adf7bc27e61b808637602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edcb545da1741175776adf7bc27e61b808637602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f89b66f5ad705120584101c4d7a15532d0286e9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89b66f5ad705120584101c4d7a15532d0286e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f89b66f5ad705120584101c4d7a15532d0286e9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89b66f5ad705120584101c4d7a15532d0286e9e/comments", "author": null, "committer": null, "parents": [{"sha": "24879fd09218e5cdc8696f66a0de667285c08409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24879fd09218e5cdc8696f66a0de667285c08409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24879fd09218e5cdc8696f66a0de667285c08409"}], "stats": {"total": 10, "additions": 10, "deletions": 0}, "files": [{"sha": "a89303e37e9f3093998d0a4c51ea93bb74e12fc2", "filename": "libgo/go/net/fd_unix.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89b66f5ad705120584101c4d7a15532d0286e9e/libgo%2Fgo%2Fnet%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89b66f5ad705120584101c4d7a15532d0286e9e/libgo%2Fgo%2Fnet%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_unix.go?ref=f89b66f5ad705120584101c4d7a15532d0286e9e", "patch": "@@ -80,6 +80,16 @@ func (fd *netFD) connect(la, ra syscall.Sockaddr) error {\n \t\tif err == nil || err == syscall.EISCONN {\n \t\t\tbreak\n \t\t}\n+\n+\t\t// On Solaris we can see EINVAL if the socket has\n+\t\t// already been accepted and closed by the server.\n+\t\t// Treat this as a successful connection--writes to\n+\t\t// the socket will see EOF.  For details and a test\n+\t\t// case in C see http://golang.org/issue/6828.\n+\t\tif runtime.GOOS == \"solaris\" && err == syscall.EINVAL {\n+\t\t\tbreak\n+\t\t}\n+\n \t\tif err != syscall.EINPROGRESS && err != syscall.EALREADY && err != syscall.EINTR {\n \t\t\treturn err\n \t\t}"}]}