{"sha": "83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmMmNjZjRmODc0ZjBlYzRkZWI1NjBiODJhYzg3YTE3MWJmNjYxNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-07-27T18:15:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-07-27T18:15:21Z"}, "message": "cp-tree.h (BINFO_VIRTUALS): Document new format.\n\n\t* cp-tree.h (BINFO_VIRTUALS): Document new format.\n\t* class.c (modify_one_vtable): Change prototype accordingly.\n\t(modify_all_vtables): Likewise.\n\t(modify_all_direct_vtables): Likewise.\n\t(modify_all_indirect_vtables): Likewise.\n\t(build_vtable_entry_for_fn): New function.\n\t(set_rtti_entry): Simplify for new BINFO_VIRTUALS format.\n\t(modify_vtable_entry): Likewise.\n\t(add_virtual_function): Likewise.\n\t(build_vtbl_initializer): New function.\n\t(finish_vtbls): Simplify for new BINFO_VIRTUALS format.\n\t(fixup_vtable_deltas1): Likewise.\n\t(fixup_vtable_deltas): Likewise.\n\t(override_one_vtable): Likewise.\n\t(finish_struct_1): Likewise.\n\t* error.c (dump_expr): Likewise.\n\t* search.c (get_abstract_virtuals_1): Likewise.\n\t(get_abstract_virtuals): Likewise.\n\t(expand_upcast_fixups): Likewise.\n\t* tree.c (debug_binfo): Likewise.\n\t* decl2.c (mark_vtable_entries): Don't bash abstract virtuals to\n\t__pure_virtual here.\n\nFrom-SVN: r28298", "tree": {"sha": "6a75d188c0fbbd46be51bc41b17c6e7fcb5cdc03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a75d188c0fbbd46be51bc41b17c6e7fcb5cdc03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/comments", "author": null, "committer": null, "parents": [{"sha": "f55dcd41d022f1efd89a609954252be89587b768", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f55dcd41d022f1efd89a609954252be89587b768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f55dcd41d022f1efd89a609954252be89587b768"}], "stats": {"total": 383, "additions": 251, "deletions": 132}, "files": [{"sha": "f3e9d0015ee25f72d04f08db03ba118ddd64d8d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -1,3 +1,28 @@\n+1999-07-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (BINFO_VIRTUALS): Document new format.\n+\t* class.c (modify_one_vtable): Change prototype accordingly.\n+\t(modify_all_vtables): Likewise.\n+\t(modify_all_direct_vtables): Likewise.\n+\t(modify_all_indirect_vtables): Likewise.\n+\t(build_vtable_entry_for_fn): New function.\n+\t(set_rtti_entry): Simplify for new BINFO_VIRTUALS format.\n+\t(modify_vtable_entry): Likewise.\n+\t(add_virtual_function): Likewise.\n+\t(build_vtbl_initializer): New function.\n+\t(finish_vtbls): Simplify for new BINFO_VIRTUALS format.\n+\t(fixup_vtable_deltas1): Likewise.\n+\t(fixup_vtable_deltas): Likewise.\n+\t(override_one_vtable): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* search.c (get_abstract_virtuals_1): Likewise.\n+\t(get_abstract_virtuals): Likewise.\n+\t(expand_upcast_fixups): Likewise.\n+\t* tree.c (debug_binfo): Likewise.\n+\t* decl2.c (mark_vtable_entries): Don't bash abstract virtuals to\n+\t__pure_virtual here.\n+\t\n 1999-07-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (build_cplus_new): Adjust call to abstract_virtuals_error"}, {"sha": "4207d8f73e273752841f95110c8d15d09561fddd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 168, "deletions": 115, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -121,12 +121,10 @@ static void mark_overriders PROTO((tree, tree));\n static void check_for_override PROTO((tree, tree));\n static tree get_class_offset_1 PROTO((tree, tree, tree, tree, tree));\n static tree get_class_offset PROTO((tree, tree, tree, tree));\n-static void modify_one_vtable PROTO((tree, tree, tree, tree));\n-static void modify_all_vtables PROTO((tree, tree, tree));\n-static void modify_all_direct_vtables PROTO((tree, int, tree, tree,\n-\t\t\t\t\t     tree));\n-static void modify_all_indirect_vtables PROTO((tree, int, int, tree,\n-\t\t\t\t\t       tree, tree));\n+static void modify_one_vtable PROTO((tree, tree, tree));\n+static void modify_all_vtables PROTO((tree, tree));\n+static void modify_all_direct_vtables PROTO((tree, int, tree, tree));\n+static void modify_all_indirect_vtables PROTO((tree, int, int, tree, tree));\n static int finish_base_struct PROTO((tree, struct base_info *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n@@ -139,6 +137,8 @@ static tree fixed_type_or_null PROTO((tree, int *));\n static tree resolve_address_of_overloaded_function PROTO((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n static void build_vtable_entry_ref PROTO((tree, tree, tree));\n+static tree build_vtable_entry_for_fn PROTO((tree, tree));\n+static tree build_vtbl_initializer PROTO((tree));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -466,6 +466,25 @@ build_vtable_entry (delta, pfn)\n     }\n }\n \n+/* Build a vtable entry for FNDECL.  DELTA is the amount by which we\n+   must adjust the this pointer when calling F.  */\n+\n+static tree\n+build_vtable_entry_for_fn (delta, fndecl)\n+     tree delta;\n+     tree fndecl;\n+{\n+  tree pfn;\n+\n+  /* Take the address of the function, considering it to be of an\n+     appropriate generic type.  */\n+  pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n+  /* The address of a function can't change.  */\n+  TREE_CONSTANT (pfn) = 1;\n+  /* Now build the vtable entry itself.  */\n+  return build_vtable_entry (delta, pfn);\n+}\n+\n /* We want to give the assembler the vtable identifier as well as\n    the offset to the function pointer.  So we generate\n \n@@ -669,30 +688,34 @@ static void\n set_rtti_entry (virtuals, offset, type)\n      tree virtuals, offset, type;\n {\n-  tree vfn;\n+  tree fn;\n \n   if (CLASSTYPE_COM_INTERFACE (type))\n     return;\n \n   if (flag_rtti)\n-    vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, get_tinfo_fn (type));\n+    fn = get_tinfo_fn (type);\n   else\n-    vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, size_zero_node);\n-  TREE_CONSTANT (vfn) = 1;\n+    /* If someone tries to get RTTI information for a type compiled\n+       without RTTI, they're out of luck.  By calling __pure_virtual\n+       in this case, we give a small clue as to what went wrong.  We\n+       could consider having a __no_typeinfo function as well, for a\n+       more specific hint.  */\n+    fn = abort_fndecl;\n \n-  if (! flag_vtable_thunks)\n-    TREE_VALUE (virtuals) = build_vtable_entry (offset, vfn);\n-  else\n+  if (flag_vtable_thunks)\n     {\n-      tree voff = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (voff) = 1;\n-\n-      TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, voff);\n+      /* The first slot holds the offset.  */\n+      TREE_PURPOSE (virtuals) = offset;\n \n-      /* The second slot is for the tdesc pointer when thunks are used.  */\n-      TREE_VALUE (TREE_CHAIN (virtuals))\n-\t= build_vtable_entry (integer_zero_node, vfn);\n+      /* The next node holds the function.  */\n+      virtuals = TREE_CHAIN (virtuals);\n+      offset = integer_zero_node;\n     }\n+\n+  /* This slot holds the function to call.  */\n+  TREE_PURPOSE (virtuals) = offset;\n+  TREE_VALUE (virtuals) = fn;\n }\n \n /* Build a virtual function for type TYPE.\n@@ -952,25 +975,21 @@ get_vtable_entry (virtuals, base_fndecl)\n }\n #endif\n \n-/* Put new entry ENTRY into virtual function table initializer\n-   VIRTUALS.\n-\n-   Also update DECL_VINDEX (FNDECL).  */\n+/* Change the offset for the FNDECL entry to NEW_OFFSET.  Also update\n+   DECL_VINDEX (FNDECL).  */\n \n static void\n-modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n-     tree old_entry_in_list, new_entry, fndecl;\n+modify_vtable_entry (old_entry_in_list, new_offset, fndecl)\n+     tree old_entry_in_list, new_offset, fndecl;\n {\n-  tree base_fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (old_entry_in_list)), 0);\n+  tree base_fndecl = TREE_VALUE (old_entry_in_list);\n \n-#ifdef NOTQUITE\n-  cp_warning (\"replaced %D with %D\", DECL_ASSEMBLER_NAME (base_fndecl),\n-\t      DECL_ASSEMBLER_NAME (fndecl));\n-#endif\n-  TREE_VALUE (old_entry_in_list) = new_entry;\n+  /* Update the entry.  */\n+  TREE_PURPOSE (old_entry_in_list) = new_offset;\n+  TREE_VALUE (old_entry_in_list) = fndecl;\n \n-  /* Now assign virtual dispatch information, if unset.  */\n-  /* We can dispatch this, through any overridden base function.  */\n+  /* Now assign virtual dispatch information, if unset.  We can\n+     dispatch this, through any overridden base function.  */\n   if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n       DECL_VINDEX (fndecl) = DECL_VINDEX (base_fndecl);\n@@ -1012,11 +1031,6 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n   tree pending_virtuals = *pv;\n   tree pending_hard_virtuals = *phv;\n \n-  /* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely\n-     convert to void *.  Make such a conversion here.  */\n-  tree vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n-  TREE_CONSTANT (vfn) = 1;\n-\n #ifndef DUMB_USER\n   if (current_class_type == 0)\n     cp_warning (\"internal problem, current_class_type is zero when adding `%D', please report\",\n@@ -1032,8 +1046,6 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n      to hold that entry.  */\n   if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n-      tree entry;\n-\n       /* We remember that this was the base sub-object for rtti.  */\n       CLASSTYPE_RTTI (t) = t;\n \n@@ -1068,16 +1080,20 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n \tDECL_VINDEX (fndecl) = idx;\n \tDECL_CONTEXT (fndecl) = t;\n       }\n-      entry = build_vtable_entry (integer_zero_node, vfn);\n-      pending_virtuals = tree_cons (DECL_VINDEX (fndecl), entry, pending_virtuals);\n+      /* Save the state we've computed on the PENDING_VIRTUALS list.  */\n+      pending_virtuals = tree_cons (integer_zero_node,\n+\t\t\t\t    fndecl,\n+\t\t\t\t    pending_virtuals);\n     }\n   /* Might already be INTEGER_CST if declared twice in class.  We will\n      give error later or we've already given it.  */\n   else if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n     {\n       /* Need an entry in some other virtual function table.\n          Deal with this after we have laid out our virtual base classes.  */\n-      pending_hard_virtuals = temp_tree_cons (fndecl, vfn, pending_hard_virtuals);\n+      pending_hard_virtuals = temp_tree_cons (NULL_TREE, \n+\t\t\t\t\t      fndecl, \n+\t\t\t\t\t      pending_hard_virtuals);\n     }\n   *pv = pending_virtuals;\n   *phv = pending_hard_virtuals;\n@@ -2207,6 +2223,78 @@ duplicate_tag_error (t)\n   TYPE_NONCOPIED_PARTS (t) = NULL_TREE;\n }\n \n+/* Construct the initializer for BINFOs virtual function table.  */\n+\n+static tree\n+build_vtbl_initializer (binfo)\n+     tree binfo;\n+{\n+  tree v = BINFO_VIRTUALS (binfo);\n+  tree inits = NULL_TREE;\n+\n+  /* Process the RTTI stuff at the head of the list.  If we're not\n+     using vtable thunks, then the RTTI entry is just an ordinary\n+     function, and we can process it just like the other virtual\n+     function entries.  */\n+  if (!CLASSTYPE_COM_INTERFACE (BINFO_TYPE (binfo))\n+      && flag_vtable_thunks)\n+    {\n+      tree offset;\n+      tree init;\n+\n+      /* The first entry is an offset.  */\n+      offset = TREE_PURPOSE (v);\n+      my_friendly_assert (TREE_CODE (offset) == INTEGER_CST,\n+\t\t\t  19990727);\n+\n+      /* Convert the offset to look like a function pointer, so that\n+\t we can put it in the vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (init) = 1;\n+      init = build_vtable_entry (integer_zero_node, init);\n+      inits = tree_cons (NULL_TREE, init, inits);\n+\n+      /* Even in this case, the second entry (the tdesc pointer) is\n+\t just an ordinary function.  */\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  /* Go through all the ordinary virtual functions, building up\n+     initializers.  */\n+  while (v)\n+    {\n+      tree delta;\n+      tree fn;\n+      tree init;\n+\n+      /* Pull the offset for `this', and the function to call, out of\n+\t the list.  */\n+      delta = TREE_PURPOSE (v);\n+      fn = TREE_VALUE (v);\n+      my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n+      my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n+\n+      /* You can't call an abstract virtual function; it's abstract.\n+\t So, we replace these functions with __pure_virtual.  */\n+      if (DECL_ABSTRACT_VIRTUAL_P (fn))\n+\tfn = abort_fndecl;\n+\n+      /* Package up that information for the vtable.  */\n+      init = build_vtable_entry_for_fn (delta, fn);\n+      /* And add it to the chain of initializers.  */\n+      inits = tree_cons (NULL_TREE, init, inits);\n+\n+      /* Keep going.  */\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  /* The initializers were built up in reverse order; straighten them\n+     out now.  */\n+  inits = nreverse (inits);\n+  /* Package all the initializers up as an array initializer.  */\n+  return build_nt (CONSTRUCTOR, NULL_TREE, inits);\n+}\n+\n /* finish up all new vtables.  */\n \n static void\n@@ -2228,14 +2316,7 @@ finish_vtbls (binfo, do_self, t)\n \t  decl = BINFO_VTABLE (binfo);\n \t  context = DECL_CONTEXT (decl);\n \t  DECL_CONTEXT (decl) = 0;\n-\n-\t  /* We make a copy here in case we need to replace pure\n-\t     virtual functions with __pure_virtual.  We don't want to\n-\t     mess up BINFO_VIRTUALS when we do this.  */\n-\t  DECL_INITIAL (decl) = copy_list (BINFO_VIRTUALS (binfo));\n-\t  DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t\t\t  DECL_INITIAL (decl));\n-\n+\t  DECL_INITIAL (decl) = build_vtbl_initializer (binfo);\n \t  cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n \t  DECL_CONTEXT (decl) = context;\n \t}\n@@ -2248,9 +2329,8 @@ finish_vtbls (binfo, do_self, t)\n       int is_not_base_vtable\n \t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n       if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  base_binfo = binfo_member (BINFO_TYPE (base_binfo), CLASSTYPE_VBASECLASSES (t));\n-\t}\n+\tbase_binfo = binfo_member (BINFO_TYPE (base_binfo), \n+\t\t\t\t   CLASSTYPE_VBASECLASSES (t));\n       finish_vtbls (base_binfo, is_not_base_vtable, t);\n     }\n }\n@@ -2396,8 +2476,8 @@ skip_rtti_stuff (virtuals, t)\n }\n \n static void\n-modify_one_vtable (binfo, t, fndecl, pfn)\n-     tree binfo, t, fndecl, pfn;\n+modify_one_vtable (binfo, t, fndecl)\n+     tree binfo, t, fndecl;\n {\n   tree virtuals = BINFO_VIRTUALS (binfo);\n   unsigned HOST_WIDE_INT n;\n@@ -2424,8 +2504,14 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n-      current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n-      current_fndecl = TREE_OPERAND (current_fndecl, 0);\n+\n+      /* We should never have an instance of __pure_virtual on the\n+\t BINFO_VIRTUALS list.  If we do, then we will never notice\n+\t that the function that should have been there instead has\n+\t been overridden.  */\n+      my_friendly_assert (current_fndecl != abort_fndecl,\n+\t\t\t  19990727);\n+\n       if (current_fndecl && overrides (fndecl, current_fndecl))\n \t{\n \t  tree base_offset, offset;\n@@ -2469,7 +2555,7 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n #endif\n \t  modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n-\t\t\t       build_vtable_entry (this_offset, pfn),\n+\t\t\t       this_offset,\n \t\t\t       fndecl);\n \t}\n       ++n;\n@@ -2480,27 +2566,25 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n /* These are the ones that are not through virtual base classes.  */\n \n static void\n-modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n+modify_all_direct_vtables (binfo, do_self, t, fndecl)\n      tree binfo;\n      int do_self;\n-     tree t, fndecl, pfn;\n+     tree t, fndecl;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    {\n-      modify_one_vtable (binfo, t, fndecl, pfn);\n-    }\n+    modify_one_vtable (binfo, t, fndecl);\n \n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       int is_not_base_vtable\n \t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n       if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tmodify_all_direct_vtables (base_binfo, is_not_base_vtable, t, fndecl, pfn);\n+\tmodify_all_direct_vtables (base_binfo, is_not_base_vtable, t, fndecl);\n     }\n }\n \n@@ -2518,9 +2602,8 @@ fixup_vtable_deltas1 (binfo, t)\n   while (virtuals)\n     {\n       tree fndecl = TREE_VALUE (virtuals);\n-      tree pfn = FNADDR_FROM_VTABLE_ENTRY (fndecl);\n-      tree delta = DELTA_FROM_VTABLE_ENTRY (fndecl);\n-      fndecl = TREE_OPERAND (pfn, 0);\n+      tree delta = TREE_PURPOSE (virtuals);\n+\n       if (fndecl)\n \t{\n \t  tree base_offset, offset;\n@@ -2565,7 +2648,7 @@ fixup_vtable_deltas1 (binfo, t)\n \t\t}\n \n \t      modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n-\t\t\t\t   build_vtable_entry (this_offset, pfn),\n+\t\t\t\t   this_offset,\n \t\t\t\t   fndecl);\n \t    }\n \t}\n@@ -2598,27 +2681,23 @@ fixup_vtable_deltas (binfo, init_self, t)\n     }\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    {\n-      fixup_vtable_deltas1 (binfo, t);\n-    }\n+    fixup_vtable_deltas1 (binfo, t);\n }\n \n /* These are the ones that are through virtual base classes.  */\n \n static void\n-modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n+modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl)\n      tree binfo;\n      int do_self, via_virtual;\n-     tree t, fndecl, pfn;\n+     tree t, fndecl;\n {\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (do_self && via_virtual && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    {\n-      modify_one_vtable (binfo, t, fndecl, pfn);\n-    }\n+    modify_one_vtable (binfo, t, fndecl);\n \n   for (i = 0; i < n_baselinks; i++)\n     {\n@@ -2630,19 +2709,20 @@ modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n \t  via_virtual = 1;\n \t  base_binfo = binfo_member (BINFO_TYPE (base_binfo), CLASSTYPE_VBASECLASSES (t));\n \t}\n-      modify_all_indirect_vtables (base_binfo, is_not_base_vtable, via_virtual, t, fndecl, pfn);\n+      modify_all_indirect_vtables (base_binfo, is_not_base_vtable, via_virtual, t, fndecl);\n     }\n }\n \n static void\n-modify_all_vtables (t, fndecl, vfn)\n-     tree t, fndecl, vfn;\n+modify_all_vtables (t, fndecl)\n+     tree t;\n+     tree fndecl;\n {\n   /* Do these first, so that we will make use of any non-virtual class's\n      vtable, over a virtual classes vtable.  */\n-  modify_all_direct_vtables (TYPE_BINFO (t), 1, t, fndecl, vfn);\n+  modify_all_direct_vtables (TYPE_BINFO (t), 1, t, fndecl);\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl, vfn);\n+    modify_all_indirect_vtables (TYPE_BINFO (t), 1, 0, t, fndecl);\n }\n \n /* Here, we already know that they match in every respect.\n@@ -2693,10 +2773,7 @@ override_one_vtable (binfo, old, t)\n     {\n       tree fndecl = TREE_VALUE (virtuals);\n       tree old_fndecl = TREE_VALUE (old_virtuals);\n-      fndecl = FNADDR_FROM_VTABLE_ENTRY (fndecl);\n-      old_fndecl = FNADDR_FROM_VTABLE_ENTRY (old_fndecl);\n-      fndecl = TREE_OPERAND (fndecl, 0);\n-      old_fndecl = TREE_OPERAND (old_fndecl, 0);\n+\n       /* First check to see if they are the same.  */\n       if (DECL_ASSEMBLER_NAME (fndecl) == DECL_ASSEMBLER_NAME (old_fndecl))\n \t{\n@@ -2748,8 +2825,7 @@ override_one_vtable (binfo, old, t)\n \t    }\n \t  {\n \t    /* This MUST be overridden, or the class is ill-formed.  */\n-\t    tree fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n-\t    tree vfn;\n+\t    tree fndecl = TREE_VALUE (virtuals);\n \n \t    fndecl = copy_node (fndecl);\n \t    copy_lang_decl (fndecl);\n@@ -2758,12 +2834,10 @@ override_one_vtable (binfo, old, t)\n \t    if (! CLASSTYPE_ABSTRACT_VIRTUALS (t))\n \t      CLASSTYPE_ABSTRACT_VIRTUALS (t) = error_mark_node;\n \n-\t    vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n-\t    TREE_CONSTANT (vfn) = 1;\n-\t    \n \t    /* We can use integer_zero_node, as we will core dump\n \t       if this is used anyway.  */\n-\t    TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, vfn);\n+\t    TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, \n+\t\t\t\t\t\t\tfndecl);\n \t  }\n \t}\n       virtuals = TREE_CHAIN (virtuals);\n@@ -3960,12 +4034,11 @@ finish_struct_1 (t)\n     TYPE_VIRTUAL_P (t) = 1;\n \n   if (flag_rtti && TYPE_VIRTUAL_P (t) && !pending_hard_virtuals)\n-    modify_all_vtables (t, NULL_TREE, NULL_TREE);\n+    modify_all_vtables (t, NULL_TREE);\n \n   while (pending_hard_virtuals)\n     {\n       modify_all_vtables (t,\n-\t\t\t  TREE_PURPOSE (pending_hard_virtuals),\n \t\t\t  TREE_VALUE (pending_hard_virtuals));\n       pending_hard_virtuals = TREE_CHAIN (pending_hard_virtuals);\n     }\n@@ -4146,26 +4219,6 @@ finish_struct_1 (t)\n \n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n-#if 0\n-      /* This is now done above.  */\n-      if (DECL_FIELD_CONTEXT (vfield) != t)\n-\t{\n-\t  tree binfo = get_binfo (DECL_FIELD_CONTEXT (vfield), t, 0);\n-\t  tree offset = BINFO_OFFSET (binfo);\n-\n-\t  vfield = copy_node (vfield);\n-\t  copy_lang_decl (vfield);\n-\n-\t  if (! integer_zerop (offset))\n-\t    offset = size_binop (MULT_EXPR, offset, size_int (BITS_PER_UNIT));\n-\t  DECL_FIELD_CONTEXT (vfield) = t;\n-\t  DECL_CLASS_CONTEXT (vfield) = t;\n-\t  DECL_FIELD_BITPOS (vfield)\n-\t    = size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n-\t  CLASSTYPE_VFIELD (t) = vfield;\n-\t}\n-#endif\n-\n       /* In addition to this one, all the other vfields should be listed.  */\n       /* Before that can be done, we have to have FIELD_DECLs for them, and\n \t a place to find them.  */"}, {"sha": "4a47e9bcd3342f5635bf796e8e0e12c6679cedcf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -98,7 +98,14 @@ Boston, MA 02111-1307, USA.  */\n \n    DECL_SAVED_INSNS/DECL_FIELD_SIZE\n      For a static VAR_DECL, this is DECL_INIT_PRIORITY.\n-*/\n+\n+   BINFO_VIRTUALS\n+     For a binfo, this is a TREE_LIST.  The TREE_PURPOSE of each node\n+     gives the amount by which to adjust the `this' pointer when\n+     calling the function.  The TREE_VALUE is the declaration for the \n+     virtual function itself.  When CLASSTYPE_COM_INTERFACE_P does not\n+     hold, the first entry does not have a TREE_VALUE; it is just an\n+     offset.  */ \n \n /* Language-dependent contents of an identifier.  */\n "}, {"sha": "d5125fc61d336cdb686404dd9b9e3db95e0ee49c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -2414,11 +2414,6 @@ mark_vtable_entries (decl)\n \n       fn = TREE_OPERAND (fnaddr, 0);\n       TREE_ADDRESSABLE (fn) = 1;\n-      if (DECL_LANG_SPECIFIC (fn) && DECL_ABSTRACT_VIRTUAL_P (fn))\n-\t{\n-\t  TREE_OPERAND (fnaddr, 0) = abort_fndecl;\n-\t  mark_used (abort_fndecl);\n-\t}\n       if (TREE_CODE (fn) == THUNK_DECL && DECL_EXTERNAL (fn))\n \t{\n \t  DECL_EXTERNAL (fn) = 0;"}, {"sha": "22be2017804d1b2b380ae74fc2df110aea54b761", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -1670,7 +1670,7 @@ dump_expr (t, nop)\n \n \t      t = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n \t      t = TYPE_METHOD_BASETYPE (t);\n-\t      virtuals = BINFO_VIRTUALS (TYPE_BINFO (TYPE_MAIN_VARIANT (t)));\n+\t      virtuals = TYPE_BINFO_VIRTUALS (TYPE_MAIN_VARIANT (t));\n \t      \n \t      n = TREE_INT_CST_LOW (idx);\n \n@@ -1685,7 +1685,7 @@ dump_expr (t, nop)\n \t\t}\n \t      if (virtuals)\n \t\t{\n-\t\t  dump_expr (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n+\t\t  dump_expr (TREE_VALUE (virtuals), 0);\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "3af71f1cfc2e3d9d6724a1c09d91c217103f172f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -2032,10 +2032,10 @@ get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n \n       while (virtuals)\n \t{\n-\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));\n-\t  tree base_fndecl = TREE_OPERAND (base_pfn, 0);\n+\t  tree base_fndecl = TREE_VALUE (virtuals);\n \t  if (DECL_ABSTRACT_VIRTUAL_P (base_fndecl))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, abstract_virtuals);\n+\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, \n+\t\t\t\t\t   abstract_virtuals);\n \t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n@@ -2065,12 +2065,12 @@ get_abstract_virtuals (type)\n \n       while (virtuals)\n \t{\n-\t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals));\n-\t  tree base_fndecl = TREE_OPERAND (base_pfn, 0);\n+\t  tree base_fndecl = TREE_VALUE (virtuals);\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (base_fndecl))\n \t    cp_error (\"`%#D' needs a final overrider\", base_fndecl);\n \t  else if (DECL_ABSTRACT_VIRTUAL_P (base_fndecl))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, abstract_virtuals);\n+\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, \n+\t\t\t\t\t   abstract_virtuals);\n \t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n@@ -2541,8 +2541,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n-      current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n-      current_fndecl = TREE_OPERAND (current_fndecl, 0);\n+\n       if (current_fndecl\n \t  && current_fndecl != abort_fndecl\n \t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)"}, {"sha": "9076cc76cc4246285f31330f0b37f22ccc2228a7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -1245,7 +1245,7 @@ debug_binfo (elem)\n \n   while (virtuals)\n     {\n-      tree fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n+      tree fndecl = TREE_VALUE (virtuals);\n       fprintf (stderr, \"%s [%ld =? %ld]\\n\",\n \t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)),\n \t       (long) n, (long) TREE_INT_CST_LOW (DECL_VINDEX (fndecl)));"}, {"sha": "64dc51a4081d17496a6f1942e9a1f877bdae3a96", "filename": "gcc/testsuite/g++.old-deja/g++.pt/virtual4.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvirtual4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83f2ccf4f874f0ec4deb560b82ac87a171bf6617/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvirtual4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvirtual4.C?ref=83f2ccf4f874f0ec4deb560b82ac87a171bf6617", "patch": "@@ -0,0 +1,40 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct B \n+{\n+  B ();\n+  virtual void f () = 0;\n+};\n+\n+B::B () \n+{\n+}\n+\n+extern B* bp;\n+\n+template <class T>\n+struct C : public B\n+{\n+  virtual void f () \n+    {\n+    }\n+};\n+\n+template <class T>\n+struct D : public B\n+{\n+  virtual void f () \n+    {\n+      bp = new C<T*>;\n+    }\n+};\n+\n+B* bp = new D<int>;\n+\n+int main ()\n+{\n+  bp->f ();\n+  bp->f ();\n+}\n+\n+"}]}