{"sha": "2368f04ec19f5d2aa5439e2454217d3135603dd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM2OGYwNGVjMTlmNWQyYWE1NDM5ZTI0NTQyMTdkMzEzNTYwM2RkMA==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2005-11-15T13:54:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:54:02Z"}, "message": "a-crbtgo.ads, [...]: Compiles against the spec for ordered maps described in sections A.18.6 of the...\n\n2005-11-14  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-crbtgo.ads, a-crbtgo.adb, a-coorse.ads, a-coorse.adb, a-convec.ads, \n\ta-convec.adb, a-coinve.ads, a-coinve.adb, a-cohama.ads, a-cohama.adb, \n\ta-ciorse.ads, a-ciorse.adb, a-cihama.ads, a-cihama.adb, a-cidlli.ads, \n\ta-cidlli.adb, a-cdlili.ads, a-cdlili.adb, a-coormu.adb, a-ciormu.adb, \n\ta-cihase.adb, a-cihase.ads, a-cohase.adb, a-cohase.ads, a-ciorma.ads, \n\ta-coorma.ads, a-ciormu.ads, a-coormu.ads, a-ciorma.adb, a-coorma.adb: \n\tCompiles against the spec for ordered maps described in sections\n\tA.18.6 of the most recent (August 2005) AI-302 draft.\n\nFrom-SVN: r106962", "tree": {"sha": "129bc8844811a17598b415668a54b3f7b4c278d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/129bc8844811a17598b415668a54b3f7b4c278d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2368f04ec19f5d2aa5439e2454217d3135603dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2368f04ec19f5d2aa5439e2454217d3135603dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2368f04ec19f5d2aa5439e2454217d3135603dd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2368f04ec19f5d2aa5439e2454217d3135603dd0/comments", "author": null, "committer": null, "parents": [{"sha": "5e61ef090a8910843dd421fad19eae41c4fca816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e61ef090a8910843dd421fad19eae41c4fca816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e61ef090a8910843dd421fad19eae41c4fca816"}], "stats": {"total": 4637, "additions": 3270, "deletions": 1367}, "files": [{"sha": "958a105a734776154fb997dc3a4327cae8d33f4e", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 171, "deletions": 130, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -34,6 +34,7 @@\n ------------------------------------------------------------------------------\n \n with System;  use type System.Address;\n+\n with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Doubly_Linked_Lists is\n@@ -129,7 +130,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    procedure Append\n      (Container : in out List;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1) is\n+      Count     : Count_Type := 1)\n+   is\n    begin\n       Insert (Container, No_Element, New_Item, Count);\n    end Append;\n@@ -185,7 +187,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Contains\n      (Container : List;\n-      Item      : Element_Type) return Boolean is\n+      Item      : Element_Type) return Boolean\n+   is\n    begin\n       return Find (Container, Item) /= No_Element;\n    end Contains;\n@@ -202,8 +205,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n@@ -212,13 +213,16 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = Container.First then\n          Delete_First (Container, Count);\n-         Position := First (Container);\n+         Position := No_Element; --  Post-York behavior\n          return;\n       end if;\n \n       if Count = 0 then\n+         Position := No_Element;  --  Post-York behavior\n          return;\n       end if;\n \n@@ -247,6 +251,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n          Free (X);\n       end loop;\n+\n+      Position := No_Element;  --  Post-York behavior\n    end Delete;\n \n    ------------------\n@@ -329,12 +335,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -354,11 +360,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         pragma Assert (Vet (Position), \"bad cursor in Find\");\n-\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n       while Node /= null loop\n@@ -604,12 +610,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Container'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n@@ -656,12 +662,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Container'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n@@ -937,12 +943,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          C : List renames Position.Container.all'Unrestricted_Access.all;\n          B : Natural renames C.Busy;\n@@ -1018,97 +1024,46 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end loop;\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n    procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type)\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container.Lock > 0 then\n+      if Position.Container /= Container'Unchecked_Access then\n          raise Program_Error;\n       end if;\n \n-      Position.Node.Element := By;\n-   end Replace_Element;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      Node : Node_Access := Position.Node;\n-\n-   begin\n-      if Node = null then\n-         Node := Container.Last;\n-\n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n-\n-         if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n-         end if;\n+      if Container.Lock > 0 then\n+         raise Program_Error;\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element = Item then\n-            return Cursor'(Container'Unchecked_Access, Node);\n-         end if;\n-\n-         Node := Node.Prev;\n-      end loop;\n-\n-      return No_Element;\n-   end Reverse_Find;\n-\n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : List;\n-      Process   : not null access procedure (Position : Cursor))\n-   is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-\n-      Node : Node_Access := Container.Last;\n-\n-   begin\n-      B := B + 1;\n-\n-      begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n-            Node := Node.Prev;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-      B := B - 1;\n-   end Reverse_Iterate;\n+      Position.Node.Element := New_Item;\n+   end Replace_Element;\n \n-   ------------------\n-   -- Reverse_List --\n-   ------------------\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n \n-   procedure Reverse_List (Container : in out List) is\n+   procedure Reverse_Elements (Container : in out List) is\n       I : Node_Access := Container.First;\n       J : Node_Access := Container.Last;\n \n@@ -1152,7 +1107,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          end if;\n       end Swap;\n \n-   --  Start of processing for Reverse_List\n+   --  Start of processing for Reverse_Elements\n \n    begin\n       if Container.Length <= 1 then\n@@ -1188,7 +1143,72 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n-   end Reverse_List;\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.Last;\n+\n+      else\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element = Item then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n+      Node : Node_Access := Container.Last;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Prev;\n+         end loop;\n+\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n \n    ------------\n    -- Splice --\n@@ -1200,12 +1220,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      pragma Assert (Vet (Before), \"bad cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n       if Target'Address = Source'Address\n@@ -1274,13 +1294,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position : Cursor)\n    is\n    begin\n-      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n-      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unchecked_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unchecked_Access\n-      then\n-         raise Program_Error;\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n@@ -1291,6 +1310,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n       if Position.Node = Before.Node\n         or else Position.Node.Next = Before.Node\n       then\n@@ -1378,13 +1399,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n-      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n@@ -1395,6 +1415,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n       if Target.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n@@ -1474,34 +1496,40 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    -- Swap --\n    ----------\n \n-   procedure Swap (I, J : Cursor) is\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n    begin\n-      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n-\n       if I.Node = null\n         or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= J.Container then\n+      if I.Container /= Container'Unchecked_Access\n+        or else J.Container /= Container'Unchecked_Access\n+      then\n          raise Program_Error;\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if I.Container.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n       declare\n          EI : Element_Type renames I.Node.Element;\n          EJ : Element_Type renames J.Node.Element;\n \n          EI_Copy : constant Element_Type := EI;\n+\n       begin\n          EI := EJ;\n          EJ := EI_Copy;\n@@ -1514,11 +1542,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Swap_Links\n      (Container : in out List;\n-      I, J      : Cursor) is\n+      I, J      : Cursor)\n+   is\n    begin\n-      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n-\n       if I.Node = null\n         or else J.Node = null\n       then\n@@ -1539,6 +1565,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n       declare\n          I_Next : constant Cursor := Next (I);\n \n@@ -1570,20 +1599,24 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Container /= Container'Unchecked_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n       declare\n-         C : List renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n@@ -1761,4 +1794,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end loop;\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Doubly_Linked_Lists;"}, {"sha": "3682104cba9a32bf3c68f575e58dba9eda95a8c6", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -63,49 +63,51 @@ package Ada.Containers.Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type));\n-\n-   procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type);\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Move\n      (Target : in out List;\n       Source : in out List);\n \n-   procedure Prepend\n+   procedure Insert\n      (Container : in out List;\n+      Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n \n-   procedure Append\n+   procedure Insert\n      (Container : in out List;\n+      Before    : Cursor;\n       New_Item  : Element_Type;\n+      Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n-      New_Item  : Element_Type;\n+      Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Insert\n+   procedure Prepend\n      (Container : in out List;\n-      Before    : Cursor;\n       New_Item  : Element_Type;\n-      Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Insert\n+   procedure Append\n      (Container : in out List;\n-      Before    : Cursor;\n-      Position  : out Cursor;\n+      New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n \n    procedure Delete\n@@ -121,21 +123,11 @@ package Ada.Containers.Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1);\n \n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   package Generic_Sorting is\n-\n-      function Is_Sorted (Container : List) return Boolean;\n-\n-      procedure Sort (Container : in out List);\n+   procedure Reverse_Elements (Container : in out List);\n \n-      procedure Merge (Target, Source : in out List);\n-\n-   end Generic_Sorting;\n-\n-   procedure Reverse_List (Container : in out List);\n-\n-   procedure Swap (I, J : Cursor);\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor);\n \n    procedure Swap_Links\n      (Container : in out List;\n@@ -149,13 +141,13 @@ package Ada.Containers.Doubly_Linked_Lists is\n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n-      Position : Cursor);\n+      Source   : in out List;\n+      Position : in out Cursor);\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor);\n+      Position : Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -165,9 +157,13 @@ package Ada.Containers.Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type;\n \n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean;\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n \n    function Find\n      (Container : List;\n@@ -179,13 +175,9 @@ package Ada.Containers.Doubly_Linked_Lists is\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n \n-   function Next (Position : Cursor) return Cursor;\n-\n-   function Previous (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   procedure Previous (Position : in out Cursor);\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n \n    function Has_Element (Position : Cursor) return Boolean;\n \n@@ -197,6 +189,18 @@ package Ada.Containers.Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n \n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n+\n private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n@@ -248,6 +252,18 @@ private\n          Node      : Node_Access;\n       end record;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n    No_Element : constant Cursor := Cursor'(null, null);\n \n end Ada.Containers.Doubly_Linked_Lists;"}, {"sha": "46d94449b03024ccbe32499a1f74c4026f49ea0d", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 221, "deletions": 123, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -211,7 +211,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Contains\n      (Container : List;\n-      Item      : Element_Type) return Boolean is\n+      Item      : Element_Type) return Boolean\n+   is\n    begin\n       return Find (Container, Item) /= No_Element;\n    end Contains;\n@@ -228,23 +229,28 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = Container.First then\n          Delete_First (Container, Count);\n-         Position := First (Container);\n+         Position := No_Element;  --  Post-York behavior\n          return;\n       end if;\n \n       if Count = 0 then\n+         Position := No_Element;  --  Post-York behavior\n          return;\n       end if;\n \n@@ -273,6 +279,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          Free (X);\n       end loop;\n+\n+      Position := No_Element;  --  Post-York behavior\n    end Delete;\n \n    ------------------\n@@ -355,12 +363,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -380,11 +392,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+         if Node.Element = null then\n+            raise Program_Error;\n+         end if;\n \n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n       while Node /= null loop\n@@ -635,12 +651,18 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+      if Before.Container /= null then\n+         if Before.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Container'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         if Before.Node = null\n+           or else Before.Node.Element = null\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n@@ -942,12 +964,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n       declare\n          C : List renames Position.Container.all'Unrestricted_Access.all;\n          B : Natural renames C.Busy;\n@@ -1024,102 +1050,56 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end loop;\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n    procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type)\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n-\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container.Lock > 0 then\n+      if Position.Container /= Container'Unchecked_Access then\n          raise Program_Error;\n       end if;\n \n-      declare\n-         X : Element_Access := Position.Node.Element;\n-      begin\n-         Position.Node.Element := new Element_Type'(By);\n-         Free (X);\n-      end;\n-   end Replace_Element;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      Node : Node_Access := Position.Node;\n-\n-   begin\n-      if Node = null then\n-         Node := Container.Last;\n-\n-      else\n-         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n-\n-         if Position.Container /= Container'Unrestricted_Access then\n-            raise Program_Error;\n-         end if;\n+      if Position.Container.Lock > 0 then\n+         raise Program_Error;\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element.all = Item then\n-            return Cursor'(Container'Unchecked_Access, Node);\n-         end if;\n-\n-         Node := Node.Prev;\n-      end loop;\n-\n-      return No_Element;\n-   end Reverse_Find;\n-\n-   ---------------------\n-   -- Reverse_Iterate --\n-   ---------------------\n-\n-   procedure Reverse_Iterate\n-     (Container : List;\n-      Process   : not null access procedure (Position : in Cursor))\n-   is\n-      C : List renames Container'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n \n-      Node : Node_Access := Container.Last;\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-   begin\n-      B := B + 1;\n+      declare\n+         X : Element_Access := Position.Node.Element;\n \n       begin\n-         while Node /= null loop\n-            Process (Cursor'(Container'Unchecked_Access, Node));\n-            Node := Node.Prev;\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n+         Position.Node.Element := new Element_Type'(New_Item);\n+         Free (X);\n       end;\n+   end Replace_Element;\n \n-      B := B - 1;\n-   end Reverse_Iterate;\n-\n-   ------------------\n-   -- Reverse_List --\n-   ------------------\n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n \n-   procedure Reverse_List (Container : in out List) is\n+   procedure Reverse_Elements (Container : in out List) is\n       I : Node_Access := Container.First;\n       J : Node_Access := Container.Last;\n \n@@ -1163,7 +1143,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          end if;\n       end Swap;\n \n-   --  Start of processing for Reverse_List\n+   --  Start of processing for Reverse_Elements\n \n    begin\n       if Container.Length <= 1 then\n@@ -1199,7 +1179,75 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       pragma Assert (Container.First.Prev = null);\n       pragma Assert (Container.Last.Next = null);\n-   end Reverse_List;\n+   end Reverse_Elements;\n+\n+   ------------------\n+   -- Reverse_Find --\n+   ------------------\n+\n+   function Reverse_Find\n+     (Container : List;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n+      Node : Node_Access := Position.Node;\n+\n+   begin\n+      if Node = null then\n+         Node := Container.Last;\n+\n+      else\n+         if Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+      end if;\n+\n+      while Node /= null loop\n+         if Node.Element.all = Item then\n+            return Cursor'(Container'Unchecked_Access, Node);\n+         end if;\n+\n+         Node := Node.Prev;\n+      end loop;\n+\n+      return No_Element;\n+   end Reverse_Find;\n+\n+   ---------------------\n+   -- Reverse_Iterate --\n+   ---------------------\n+\n+   procedure Reverse_Iterate\n+     (Container : List;\n+      Process   : not null access procedure (Position : in Cursor))\n+   is\n+      C : List renames Container'Unrestricted_Access.all;\n+      B : Natural renames C.Busy;\n+\n+      Node : Node_Access := Container.Last;\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         while Node /= null loop\n+            Process (Cursor'(Container'Unchecked_Access, Node));\n+            Node := Node.Prev;\n+         end loop;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Reverse_Iterate;\n \n    ------------\n    -- Splice --\n@@ -1211,12 +1259,18 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      pragma Assert (Vet (Before), \"bad cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         if Before.Node = null\n+           or else Before.Node.Element = null\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n       if Target'Address = Source'Address\n@@ -1284,23 +1338,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position : Cursor)\n    is\n    begin\n-      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n-      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unchecked_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unchecked_Access\n-      then\n-         raise Program_Error;\n+         if Before.Node = null\n+           or else Before.Node.Element = null\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Target'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n       if Position.Node = Before.Node\n         or else Position.Node.Next = Before.Node\n       then\n@@ -1388,23 +1453,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n-      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+      if Before.Container /= null then\n+         if Before.Container /= Target'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n \n-      if Before.Container /= null\n-        and then Before.Container /= Target'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+         if Before.Node = null\n+           or else Before.Node.Element = null\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+\n       if Target.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n@@ -1484,31 +1560,37 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    -- Swap --\n    ----------\n \n-   procedure Swap (I, J : Cursor) is\n+   procedure Swap\n+     (Container : in out List;\n+      I, J      : Cursor)\n+   is\n    begin\n-      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n-\n       if I.Node = null\n         or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= J.Container then\n+      if I.Container /= Container'Unchecked_Access\n+        or else J.Container /= Container'Unchecked_Access\n+      then\n          raise Program_Error;\n       end if;\n \n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      if I.Container.Lock > 0 then\n+      if Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n       declare\n          EI_Copy : constant Element_Access := I.Node.Element;\n+\n       begin\n          I.Node.Element := J.Node.Element;\n          J.Node.Element := EI_Copy;\n@@ -1524,9 +1606,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n-\n       if I.Node = null\n         or else J.Node = null\n       then\n@@ -1547,6 +1626,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n       declare\n          I_Next : constant Cursor := Next (I);\n \n@@ -1580,20 +1662,28 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unchecked_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n       declare\n-         C : List renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n \n       begin\n          B := B + 1;\n@@ -1775,4 +1865,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end loop;\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Indefinite_Doubly_Linked_Lists;"}, {"sha": "9e2d2351268bc4efd5d9204615c7fa37e33afc2e", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -62,46 +62,47 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    procedure Clear (Container : in out List);\n \n-   function Element (Position : Cursor)\n-      return Element_Type;\n+   function Element (Position : Cursor) return Element_Type;\n+\n+   procedure Replace_Element\n+     (Container : in out List;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type));\n-\n-   procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type);\n+     (Container : in out List;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Move\n      (Target : in out List;\n       Source : in out List);\n \n-   procedure Prepend\n+   procedure Insert\n      (Container : in out List;\n+      Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n \n-   procedure Append\n+   procedure Insert\n      (Container : in out List;\n+      Before    : Cursor;\n       New_Item  : Element_Type;\n+      Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Insert\n+   procedure Prepend\n      (Container : in out List;\n-      Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type := 1);\n \n-   procedure Insert\n+   procedure Append\n      (Container : in out List;\n-      Before    : Cursor;\n       New_Item  : Element_Type;\n-      Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n    procedure Delete\n@@ -117,21 +118,9 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : in out List;\n       Count     : Count_Type := 1);\n \n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   package Generic_Sorting is\n-\n-      function Is_Sorted (Container : List) return Boolean;\n-\n-      procedure Sort (Container : in out List);\n-\n-      procedure Merge (Target, Source : in out List);\n-\n-   end Generic_Sorting;\n+   procedure Reverse_Elements (Container : in out List);\n \n-   procedure Reverse_List (Container : in out List);\n-\n-   procedure Swap (I, J : Cursor);\n+   procedure Swap (Container : in out List; I, J : Cursor);\n \n    procedure Swap_Links (Container : in out List; I, J : Cursor);\n \n@@ -143,13 +132,13 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n-      Position : Cursor);\n+      Source   : in out List;\n+      Position : in out Cursor);\n \n    procedure Splice\n      (Target   : in out List;\n       Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor);\n+      Position : Cursor);\n \n    function First (Container : List) return Cursor;\n \n@@ -159,9 +148,13 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type;\n \n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean;\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Previous (Position : Cursor) return Cursor;\n+\n+   procedure Previous (Position : in out Cursor);\n \n    function Find\n      (Container : List;\n@@ -173,13 +166,9 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Item      : Element_Type;\n       Position  : Cursor := No_Element) return Cursor;\n \n-   function Next (Position : Cursor) return Cursor;\n-\n-   function Previous (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   procedure Previous (Position : in out Cursor);\n+   function Contains\n+     (Container : List;\n+      Item      : Element_Type) return Boolean;\n \n    function Has_Element (Position : Cursor) return Boolean;\n \n@@ -191,6 +180,18 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n \n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : List) return Boolean;\n+\n+      procedure Sort (Container : in out List);\n+\n+      procedure Merge (Target, Source : in out List);\n+\n+   end Generic_Sorting;\n+\n private\n    type Node_Type;\n    type Node_Access is access Node_Type;\n@@ -244,6 +245,18 @@ private\n          Node      : Node_Access;\n       end record;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n    No_Element : constant Cursor := Cursor'(null, null);\n \n end Ada.Containers.Indefinite_Doubly_Linked_Lists;"}, {"sha": "3836f7eb035267bea00b20206e00dab68d197518", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -713,6 +713,14 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Read_Nodes (Stream, Container.HT);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------\n    -- Read_Node --\n    ---------------\n@@ -787,14 +795,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    -- Replace_Element --\n    ---------------------\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container.HT.Lock > 0 then\n          raise Program_Error;\n       end if;\n@@ -803,7 +819,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          X : Element_Access := Position.Node.Element;\n \n       begin\n-         Position.Node.Element := new Element_Type'(By);\n+         Position.Node.Element := new Element_Type'(New_Item);\n          Free_Element (X);\n       end;\n    end Replace_Element;\n@@ -834,9 +850,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type))\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n    is\n    begin\n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n@@ -845,9 +862,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n-         M  : Map renames Position.Container.all;\n-         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+         HT : Hash_Table_Type renames Container.HT;\n \n          B : Natural renames HT.Busy;\n          L : Natural renames HT.Lock;\n@@ -859,7 +879,6 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          declare\n             K : Key_Type renames Position.Node.Key.all;\n             E : Element_Type renames Position.Node.Element.all;\n-\n          begin\n             Process (K, E);\n          exception\n@@ -951,6 +970,14 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Write_Nodes (Stream, Container.HT);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n    ----------------\n    -- Write_Node --\n    ----------------"}, {"sha": "18963d5048cb64cd73c5bc1c772667ac477390b1", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -57,6 +57,12 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean;\n \n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type);\n+\n    function Length (Container : Map) return Count_Type;\n \n    function Is_Empty (Container : Map) return Boolean;\n@@ -67,20 +73,22 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n                                             Element : in out Element_Type));\n \n-   procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type);\n-\n    procedure Move (Target : in out Map; Source : in out Map);\n \n    procedure Insert\n@@ -105,59 +113,36 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Delete\n-     (Container : in out Map;\n-      Key       : Key_Type);\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n \n-   procedure Delete\n-     (Container : in out Map;\n-      Position  : in out Cursor);\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n \n-   procedure Exclude\n-     (Container : in out Map;\n-      Key       : Key_Type);\n-\n-   function Contains\n-     (Container : Map;\n-      Key       : Key_Type) return Boolean;\n-\n-   function Find\n-     (Container : Map;\n-      Key       : Key_Type) return Cursor;\n-\n-   function Element\n-     (Container : Map;\n-      Key       : Key_Type) return Element_Type;\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n \n    function First (Container : Map) return Cursor;\n \n    function Next (Position : Cursor) return Cursor;\n \n    procedure Next (Position : in out Cursor);\n \n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n-   function Equivalent_Keys (Left, Right : Cursor)\n-     return Boolean;\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n \n-   function Equivalent_Keys\n-     (Left  : Cursor;\n-      Right : Key_Type) return Boolean;\n+   function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n \n-   function Equivalent_Keys\n-     (Left  : Key_Type;\n-      Right : Cursor) return Boolean;\n+   function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean;\n \n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n-   function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type);\n-\n private\n    pragma Inline (\"=\");\n    pragma Inline (Length);\n@@ -194,6 +179,7 @@ private\n \n    use HT_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    procedure Adjust (Container : in out Map);\n \n@@ -208,12 +194,22 @@ private\n          Node      : Node_Access;\n       end record;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n    No_Element : constant Cursor :=\n      (Container => null,\n       Node      => null);\n \n-   use Ada.Streams;\n-\n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Map);"}, {"sha": "9503e8859a201b6f706d203acbf229ed0617d223", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 92, "deletions": 32, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -73,6 +73,12 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Hash_Node (Node : Node_Access) return Hash_Type;\n    pragma Inline (Hash_Node);\n \n+   procedure Insert\n+     (HT       : in out Hash_Table_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n+\n    function Is_In (HT  : Hash_Table_Type; Key : Node_Access) return Boolean;\n    pragma Inline (Is_In);\n \n@@ -326,13 +332,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          begin\n             if not Is_In (Right.HT, L_Node) then\n                declare\n-                  Indx : constant Hash_Type :=\n-                           Hash (L_Node.Element.all) mod Buckets'Length;\n-\n+                  Src    : Element_Type renames L_Node.Element.all;\n+                  Indx   : constant Hash_Type := Hash (Src) mod Buckets'Length;\n                   Bucket : Node_Access renames Buckets (Indx);\n-\n+                  Tgt    : Element_Access := new Element_Type'(Src);\n                begin\n-                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+                  Bucket := new Node_Type'(Tgt, Bucket);\n+               exception\n+                  when others =>\n+                     Free_Element (Tgt);\n+                     raise;\n                end;\n \n                Length := Length + 1;\n@@ -643,6 +652,32 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n+   is\n+   begin\n+      Insert (Container.HT, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (HT       : in out Hash_Table_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n    is\n       function New_Node (Next : Node_Access) return Node_Access;\n       pragma Inline (New_Node);\n@@ -665,39 +700,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             raise;\n       end New_Node;\n \n-      HT : Hash_Table_Type renames Container.HT;\n-\n    --  Start of processing for Insert\n \n    begin\n       if HT_Ops.Capacity (HT) = 0 then\n          HT_Ops.Reserve_Capacity (HT, 1);\n       end if;\n \n-      Local_Insert (HT, New_Item, Position.Node, Inserted);\n+      Local_Insert (HT, New_Item, Node, Inserted);\n \n       if Inserted\n         and then HT.Length > HT_Ops.Capacity (HT)\n       then\n          HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n-\n-      Position.Container := Container'Unchecked_Access;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error;\n-      end if;\n    end Insert;\n \n    ------------------\n@@ -787,13 +803,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          begin\n             if Is_In (Right.HT, L_Node) then\n                declare\n-                  Indx : constant Hash_Type :=\n-                           Hash (L_Node.Element.all) mod Buckets'Length;\n+                  Src : Element_Type renames L_Node.Element.all;\n+\n+                  Indx : constant Hash_Type := Hash (Src) mod Buckets'Length;\n \n                   Bucket : Node_Access renames Buckets (Indx);\n \n+                  Tgt : Element_Access := new Element_Type'(Src);\n+\n                begin\n-                  Bucket := new Node_Type'(L_Node.Element, Bucket);\n+                  Bucket := new Node_Type'(Tgt, Bucket);\n+               exception\n+                  when others =>\n+                     Free_Element (Tgt);\n+                     raise;\n                end;\n \n                Length := Length + 1;\n@@ -1040,6 +1063,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Read_Nodes (Stream, Container.HT);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------\n    -- Read_Node --\n    ---------------\n@@ -1502,6 +1533,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       return (Controlled with HT => (Buckets, Length, 0, 0));\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      HT       : Hash_Table_Type;\n+      Node     : Node_Access;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (HT, New_Item, Node, Inserted);\n+      return Set'(Controlled with HT);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1609,13 +1654,20 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          -------------\n \n          procedure Process (L_Node : Node_Access) is\n-            J : constant Hash_Type :=\n-                  Hash (L_Node.Element.all) mod Buckets'Length;\n+            Src : Element_Type renames L_Node.Element.all;\n+\n+            J : constant Hash_Type := Hash (Src) mod Buckets'Length;\n \n             Bucket : Node_Access renames Buckets (J);\n \n+            Tgt : Element_Access := new Element_Type'(Src);\n+\n          begin\n-            Bucket := new Node_Type'(L_Node.Element, Bucket);\n+            Bucket := new Node_Type'(Tgt, Bucket);\n+         exception\n+            when others =>\n+               Free_Element (Tgt);\n+               raise;\n          end Process;\n \n       --  Start of processing for Process\n@@ -1751,6 +1803,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Write_Nodes (Stream, Container.HT);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n    ----------------\n    -- Write_Node --\n    ----------------"}, {"sha": "bde7917ff373fe7f07a00c0cad320c3c9a53dd49", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -63,6 +63,8 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Capacity (Container : Set) return Count_Type;\n \n    procedure Reserve_Capacity\n@@ -225,6 +227,7 @@ private\n \n    use HT_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -235,12 +238,22 @@ private\n          Node      : Node_Access;\n       end record;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n    No_Element : constant Cursor :=\n                   (Container => null,\n                    Node      => null);\n \n-   use Ada.Streams;\n-\n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;\n       Container : Set);"}, {"sha": "256304281a8b3c7d6ffb131d0e05fdfa79d3377b", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 332, "deletions": 67, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -135,16 +135,56 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Key = null\n+        or else Right.Node.Key = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Key.all < Right.Node.Key.all;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Key.all < Right;\n    end \"<\";\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Key.all;\n    end \"<\";\n \n@@ -163,16 +203,56 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Key = null\n+        or else Right.Node.Key = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Key.all < Left.Node.Key.all;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n       return Right < Left.Node.Key.all;\n    end \">\";\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Key.all < Left;\n    end \">\";\n \n@@ -194,12 +274,13 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Ceiling (Container.Tree, Key);\n+\n    begin\n       if Node = null then\n          return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Ceiling;\n \n    -----------\n@@ -268,25 +349,35 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unrestricted_Access) then\n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n \n       Position.Container := null;\n    end Delete;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) is\n       X : Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n       if X = null then\n          raise Constraint_Error;\n-      else\n-         Delete_Node_Sans_Free (Container.Tree, X);\n-         Free (X);\n       end if;\n+\n+      Delete_Node_Sans_Free (Container.Tree, X);\n+      Free (X);\n    end Delete;\n \n    ------------------\n@@ -295,6 +386,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Delete_First (Container : in out Map) is\n       X : Node_Access := Container.Tree.First;\n+\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -308,6 +400,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Delete_Last (Container : in out Map) is\n       X : Node_Access := Container.Tree.Last;\n+\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -321,15 +414,46 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Node.Element.all;\n    end Element;\n \n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Keys;\n+\n    -------------\n    -- Exclude --\n    -------------\n@@ -339,7 +463,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if X /= null then\n-         Delete_Node_Sans_Free (Container.Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n       end if;\n    end Exclude;\n@@ -350,43 +474,58 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n       if Node = null then\n          return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Find;\n \n    -----------\n    -- First --\n    -----------\n \n    function First (Container : Map) return Cursor is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      if Container.Tree.First = null then\n+      if T.First = null then\n          return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n       end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, T.First);\n    end First;\n \n    -------------------\n    -- First_Element --\n    -------------------\n \n    function First_Element (Container : Map) return Element_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.First.Element.all;\n+      if T.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.First.Element.all;\n    end First_Element;\n \n    ---------------\n    -- First_Key --\n    ---------------\n \n    function First_Key (Container : Map) return Key_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.First.Key.all;\n+      if T.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.First.Key.all;\n    end First_Key;\n \n    -----------\n@@ -395,12 +534,13 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Floor (Container.Tree, Key);\n+\n    begin\n       if Node = null then\n          return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Node);\n       end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n    ----------\n@@ -410,11 +550,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    procedure Free (X : in out Node_Access) is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n    begin\n       if X = null then\n          return;\n       end if;\n \n+      X.Parent := X;\n+      X.Left := X;\n+      X.Right := X;\n+\n       begin\n          Free_Key (X.Key);\n       exception\n@@ -664,6 +809,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Key\");\n+\n       return Position.Node.Key.all;\n    end Key;\n \n@@ -672,30 +828,44 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    ----------\n \n    function Last (Container : Map) return Cursor is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      if Container.Tree.Last = null then\n+      if T.Last = null then\n          return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n       end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, T.Last);\n    end Last;\n \n    ------------------\n    -- Last_Element --\n    ------------------\n \n    function Last_Element (Container : Map) return Element_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.Last.Element.all;\n+      if T.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.Last.Element.all;\n    end Last_Element;\n \n    --------------\n    -- Last_Key --\n    --------------\n \n    function Last_Key (Container : Map) return Key_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.Last.Key.all;\n+      if T.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.Last.Key.all;\n    end Last_Key;\n \n    ----------\n@@ -738,8 +908,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Key /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n-         Node : constant Node_Access := Tree_Operations.Next (Position.Node);\n+         Node : constant Node_Access :=\n+                  Tree_Operations.Next (Position.Node);\n+\n       begin\n          if Node = null then\n             return No_Element;\n@@ -773,9 +951,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Position.Node /= null);\n+      pragma Assert (Position.Node.Key /= null);\n+      pragma Assert (Position.Node.Element /= null);\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n-           Tree_Operations.Previous (Position.Node);\n+                  Tree_Operations.Previous (Position.Node);\n+\n       begin\n          if Node = null then\n             return No_Element;\n@@ -799,29 +984,46 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type))\n    is\n-      K : Key_Type renames Position.Node.Key.all;\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      T : Tree_Type renames Position.Container.Tree;\n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key.all;\n+            E : Element_Type renames Position.Node.Element.all;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -863,6 +1065,14 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -908,15 +1118,40 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Replace_Element --\n    ---------------------\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n-      X : Element_Access := Position.Node.Element;\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n-      if Position.Container.Tree.Lock > 0 then\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Position.Node.Element := new Element_Type'(By);\n-      Free_Element (X);\n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      declare\n+         X : Element_Access := Position.Node.Element;\n+\n+      begin\n+         Position.Node.Element := new Element_Type'(New_Item);\n+         Free_Element (X);\n+      end;\n    end Replace_Element;\n \n    ---------------------\n@@ -1010,33 +1245,55 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type))\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n    is\n-      K : Key_Type renames Position.Node.Key.all;\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      T : Tree_Type renames Position.Container.Tree;\n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Update_Element\");\n+\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key.all;\n+            E : Element_Type renames Position.Node.Element.all;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Update_Element;\n \n    -----------\n@@ -1074,4 +1331,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Indefinite_Ordered_Maps;"}, {"sha": "8837e048e003ed38126ed946061ec830c1649b4e", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -40,16 +40,16 @@ with Ada.Streams;\n \n generic\n    type Key_Type (<>) is private;\n-\n    type Element_Type (<>) is private;\n \n    with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n-\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Indefinite_Ordered_Maps is\n    pragma Preelaborate;\n \n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n    type Map is tagged private;\n \n    type Cursor is private;\n@@ -70,17 +70,21 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type));\n-\n-   procedure Replace_Element (Position : Cursor; By : Element_Type);\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type));\n \n    procedure Move (Target : in out Map; Source : in out Map);\n \n@@ -106,54 +110,28 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Delete\n-     (Container : in out Map;\n-      Key       : Key_Type);\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n \n-   procedure Delete\n-     (Container : in out Map;\n-      Position  : in out Cursor);\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n \n    procedure Delete_First (Container : in out Map);\n \n    procedure Delete_Last (Container : in out Map);\n \n-   procedure Exclude\n-     (Container : in out Map;\n-      Key       : Key_Type);\n-\n-   function Contains\n-     (Container : Map;\n-      Key       : Key_Type) return Boolean;\n-\n-   function Find\n-     (Container : Map;\n-      Key       : Key_Type) return Cursor;\n-\n-   function Element\n-     (Container : Map;\n-      Key       : Key_Type) return Element_Type;\n-\n-   function Floor\n-     (Container : Map;\n-      Key       : Key_Type) return Cursor;\n-\n-   function Ceiling\n-     (Container : Map;\n-      Key       : Key_Type) return Cursor;\n-\n    function First (Container : Map) return Cursor;\n \n-   function First_Key (Container : Map) return Key_Type;\n-\n    function First_Element (Container : Map) return Element_Type;\n \n-   function Last (Container : Map) return Cursor;\n+   function First_Key (Container : Map) return Key_Type;\n \n-   function Last_Key (Container : Map) return Key_Type;\n+   function Last (Container : Map) return Cursor;\n \n    function Last_Element (Container : Map) return Element_Type;\n \n+   function Last_Key (Container : Map) return Key_Type;\n+\n    function Next (Position : Cursor) return Cursor;\n \n    procedure Next (Position : in out Cursor);\n@@ -162,6 +140,16 @@ package Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -216,18 +204,29 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n-   type Map_Access is access Map;\n+   type Map_Access is access all Map;\n    for Map_Access'Storage_Size use 0;\n \n    type Cursor is record\n       Container : Map_Access;\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "458e42e4225f25aba98a77cdc05de8dc2fd8c5f6", "filename": "gcc/ada/a-ciormu.adb", "status": "modified", "additions": 287, "deletions": 74, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -87,6 +87,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Free (X : in out Node_Access);\n \n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access);\n+\n    procedure Insert_With_Hint\n      (Dst_Tree : in out Tree_Type;\n       Dst_Hint : Node_Access;\n@@ -157,16 +162,56 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null\n+        or else Right.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element.all < Right.Node.Element.all;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element.all < Right;\n    end \"<\";\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Element.all;\n    end \"<\";\n \n@@ -183,20 +228,60 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    -- \">\" --\n    ---------\n \n-   function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n-   begin\n-      return Right < Left.Node.Element.all;\n-   end \">\";\n-\n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null\n+        or else Right.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       --  L > R same as R < L\n \n       return Right.Node.Element.all < Left.Node.Element.all;\n    end \">\";\n \n+   function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n+   begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      return Right < Left.Node.Element.all;\n+   end \">\";\n+\n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Element.all < Left;\n    end \">\";\n \n@@ -313,6 +398,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n \n@@ -375,9 +463,35 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n    ---------------------\n    -- Equivalent_Sets --\n    ---------------------\n@@ -420,6 +534,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Node : Node_Access := Element_Keys.Ceiling (Tree, Item);\n       Done : constant Node_Access := Element_Keys.Upper_Bound (Tree, Item);\n       X    : Node_Access;\n+\n    begin\n       while Node /= Done loop\n          X := Node;\n@@ -464,6 +579,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Container.Tree.First.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       return Container.Tree.First.Element.all;\n    end First_Element;\n \n@@ -490,11 +613,16 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    procedure Free (X : in out Node_Access) is\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n    begin\n       if X = null then\n          return;\n       end if;\n \n+      X.Parent := X;\n+      X.Left := X;\n+      X.Right := X;\n+\n       begin\n          Free_Element (X.Element);\n       exception\n@@ -538,34 +666,6 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ---------\n-      -- \"<\" --\n-      ---------\n-\n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left < Right.Node.Element.all;\n-      end \"<\";\n-\n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right > Left.Node.Element.all;\n-      end \"<\";\n-\n-      ---------\n-      -- \">\" --\n-      ---------\n-\n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left > Right.Node.Element.all;\n-      end \">\";\n-\n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right < Left.Node.Element.all;\n-      end \">\";\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -621,11 +721,32 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       -------------\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n-         Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n+\n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n          return Node.Element.all;\n       end Element;\n \n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n       -------------\n       -- Exclude --\n       -------------\n@@ -681,9 +802,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       function Is_Greater_Key_Node\n         (Left  : Key_Type;\n-         Right : Node_Access) return Boolean is\n+         Right : Node_Access) return Boolean\n+      is\n       begin\n-         return Left > Right.Element.all;\n+         return Key (Right.Element.all) < Left;\n       end Is_Greater_Key_Node;\n \n       ----------------------\n@@ -692,9 +814,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       function Is_Less_Key_Node\n         (Left  : Key_Type;\n-         Right : Node_Access) return Boolean is\n+         Right : Node_Access) return Boolean\n+      is\n       begin\n-         return Left < Right.Element.all;\n+         return Left < Key (Right.Element.all);\n       end Is_Less_Key_Node;\n \n       -------------\n@@ -746,6 +869,17 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                        \"bad cursor in Key\");\n+\n          return Key (Position.Node.Element.all);\n       end Key;\n \n@@ -812,13 +946,20 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             raise Constraint_Error;\n          end if;\n \n+         if Position.Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n \n+         pragma Assert (Vet (Container.Tree, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n          declare\n             E : Element_Type renames Position.Node.Element.all;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n@@ -839,11 +980,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             L := L - 1;\n             B := B - 1;\n \n-            if K < E\n-              or else K > E\n-            then\n-               null;\n-            else\n+            if Equivalent_Keys (Left => K, Right => Key (E)) then\n                return;\n             end if;\n          end;\n@@ -883,6 +1020,24 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor)\n+   is\n+   begin\n+      Insert_Sans_Hint\n+        (Container.Tree,\n+         New_Item,\n+         Position.Node);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access)\n    is\n       function New_Node return Node_Access;\n       pragma Inline (New_Node);\n@@ -904,7 +1059,7 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return new Node_Type'(Parent  => null,\n                                Left    => null,\n                                Right   => null,\n-                               Color   => Red,\n+                               Color   => Red_Black_Trees.Red,\n                                Element => X);\n \n       exception\n@@ -913,16 +1068,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n             raise;\n       end New_Node;\n \n-   --  Start of processing for Insert\n+   --  Start of processing for Insert_Sans_Hint\n \n    begin\n       Unconditional_Insert_Sans_Hint\n-        (Container.Tree,\n+        (Tree,\n          New_Item,\n-         Position.Node);\n-\n-      Position.Container := Container'Unrestricted_Access;\n-   end Insert;\n+         Node);\n+   end Insert_Sans_Hint;\n \n    ----------------------\n    -- Insert_With_Hint --\n@@ -1156,6 +1309,10 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.Last.Element.all;\n    end Last_Element;\n \n@@ -1199,6 +1356,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n@@ -1245,6 +1405,9 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n@@ -1271,29 +1434,40 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      S : Set renames Position.Container.all;\n-      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element.all);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1334,6 +1508,14 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1382,6 +1564,11 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n          function New_Node return Node_Access is\n          begin\n             Node.Element := new Element_Type'(Item);  -- OK if fails\n+            Node.Color := Red_Black_Trees.Red;\n+            Node.Parent := null;\n+            Node.Left := null;\n+            Node.Right := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1403,22 +1590,27 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-    (Container : Set;\n+    (Container : in out Set;\n      Position  : Cursor;\n-     By        : Element_Type)\n+     New_Item  : Element_Type)\n    is\n-      Tree : Tree_Type renames Position.Container.Tree'Unrestricted_Access.all;\n-\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (Tree, Position.Node, By);\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n    ---------------------\n@@ -1563,6 +1755,19 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Tree     : Tree_Type;\n+      Node     : Node_Access;\n+\n+   begin\n+      Insert_Sans_Hint (Tree, New_Item, Node);\n+      return Set'(Controlled with Tree);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1613,4 +1818,12 @@ package body Ada.Containers.Indefinite_Ordered_Multisets is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Indefinite_Ordered_Multisets;"}, {"sha": "1240aca4d66f9194cf2664b240e87f355d41977a", "filename": "gcc/ada/a-ciormu.ads", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciormu.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -47,6 +47,8 @@ generic\n package Ada.Containers.Indefinite_Ordered_Multisets is\n    pragma Preelaborate;\n \n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+\n    type Set is tagged private;\n \n    type Cursor is private;\n@@ -59,6 +61,8 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -67,15 +71,15 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -85,6 +89,14 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Insert (Container : in out Set; New_Item : Element_Type);\n \n+--  TODO: include Replace too???\n+--\n+--     procedure Replace\n+--       (Container : in out Set;\n+--        New_Item  : Element_Type);\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n+\n    procedure Delete (Container : in out Set; Item : Element_Type);\n \n    procedure Delete (Container : in out Set; Position : in out Cursor);\n@@ -93,10 +105,7 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Delete_Last (Container : in out Set);\n \n-   procedure Exclude (Container : in out Set; Item : Element_Type);\n-\n-   procedure Union (Target : in out Set;\n-                    Source : Set);\n+   procedure Union (Target : in out Set; Source : Set);\n \n    function Union (Left, Right : Set) return Set;\n \n@@ -124,14 +133,6 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Floor (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n-\n    function First (Container : Set) return Cursor;\n \n    function First_Element (Container : Set) return Element_Type;\n@@ -148,6 +149,14 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -181,42 +190,31 @@ package Ada.Containers.Indefinite_Ordered_Multisets is\n       Process   : not null access procedure (Position : Cursor));\n \n    generic\n-\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n-      with function \"<\" (Left : Key_Type; Right : Element_Type)\n-          return Boolean is <>;\n-\n-      with function \">\" (Left : Key_Type; Right : Element_Type)\n-          return Boolean is <>;\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n \n    package Generic_Keys is\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Floor (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n       function Key (Position : Cursor) return Key_Type;\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Delete (Container : in out Set; Key : Key_Type);\n-\n       procedure Exclude (Container : in out Set; Key : Key_Type);\n \n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n \n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n@@ -266,6 +264,7 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -275,9 +274,19 @@ private\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write (Stream : access Root_Stream_Type'Class; Container : Set);\n "}, {"sha": "bb441a3201c91153fe4b1ba7bf741cdff5ed6e90", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 260, "deletions": 40, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -59,6 +59,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    procedure Free (X : in out Node_Access);\n \n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n+\n    procedure Insert_With_Hint\n      (Dst_Tree : in out Tree_Type;\n       Dst_Hint : Node_Access;\n@@ -144,16 +150,56 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null\n+        or else Right.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element.all < Right.Node.Element.all;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element.all < Right;\n    end \"<\";\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Element.all;\n    end \"<\";\n \n@@ -190,18 +236,58 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null\n+        or else Right.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       --  L > R same as R < L\n \n       return Right.Node.Element.all < Left.Node.Element.all;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n       return Right < Left.Node.Element.all;\n    end \">\";\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Element.all < Left;\n    end \">\";\n \n@@ -296,6 +382,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n       Position.Container := null;\n@@ -310,7 +399,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Constraint_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, X);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n       Free (X);\n    end Delete;\n \n@@ -366,6 +455,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -467,6 +567,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.First.Element.all;\n    end First_Element;\n \n@@ -491,7 +595,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    ----------\n \n    procedure Free (X : in out Node_Access) is\n-\n       procedure Deallocate is\n         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n \n@@ -500,6 +603,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return;\n       end if;\n \n+      X.Parent := X;\n+      X.Left := X;\n+      X.Right := X;\n+\n       begin\n          Free_Element (X.Element);\n       exception\n@@ -593,6 +700,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n                   Key_Keys.Find (Container.Tree, Key);\n \n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n          return Node.Element.all;\n       end Element;\n \n@@ -685,6 +796,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                        \"bad cursor in Key\");\n+\n          return Key (Position.Node.Element.all);\n       end Key;\n \n@@ -724,10 +846,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             raise Constraint_Error;\n          end if;\n \n+         if Position.Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n \n+         pragma Assert (Vet (Container.Tree, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n          declare\n             E : Element_Type renames Position.Node.Element.all;\n             K : constant Key_Type := Key (E);\n@@ -810,14 +939,45 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n+   is\n+   begin\n+      Insert_Sans_Hint\n+        (Container.Tree,\n+         New_Item,\n+         Position.Node,\n+         Inserted);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n    is\n       function New_Node return Node_Access;\n       pragma Inline (New_Node);\n \n       procedure Insert_Post is\n         new Element_Keys.Generic_Insert_Post (New_Node);\n \n-      procedure Insert_Sans_Hint is\n+      procedure Conditional_Insert_Sans_Hint is\n         new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n \n       --------------\n@@ -826,40 +986,28 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function New_Node return Node_Access is\n          Element : Element_Access := new Element_Type'(New_Item);\n+\n       begin\n          return new Node_Type'(Parent  => null,\n                                Left    => null,\n                                Right   => null,\n-                               Color   => Red,\n+                               Color   => Red_Black_Trees.Red,\n                                Element => Element);\n       exception\n          when others =>\n             Free_Element (Element);\n             raise;\n       end New_Node;\n \n-   --  Start of processing for Insert\n+   --  Start of processing for Insert_Sans_Hint\n \n    begin\n-      Insert_Sans_Hint\n-        (Container.Tree,\n+      Conditional_Insert_Sans_Hint\n+        (Tree,\n          New_Item,\n-         Position.Node,\n+         Node,\n          Inserted);\n-\n-      Position.Container := Container'Unrestricted_Access;\n-   end Insert;\n-\n-   procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error;\n-      end if;\n-   end Insert;\n+   end Insert_Sans_Hint;\n \n    ----------------------\n    -- Insert_With_Hint --\n@@ -1047,6 +1195,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.Last.Element.all;\n    end Last_Element;\n \n@@ -1095,6 +1247,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n@@ -1141,6 +1296,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n@@ -1162,29 +1320,40 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      (Position  : Cursor;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      S : Set renames Position.Container.all;\n-      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element.all);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1227,6 +1396,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -1242,6 +1419,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Constraint_Error;\n       end if;\n \n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n       X := Node.Element;\n       Node.Element := new Element_Type'(New_Item);\n       Free_Element (X);\n@@ -1295,6 +1476,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          function New_Node return Node_Access is\n          begin\n             Node.Element := new Element_Type'(Item);  -- OK if fails\n+            Node.Color := Red;\n+            Node.Parent := null;\n+            Node.Right := null;\n+            Node.Left := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1340,6 +1526,11 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n          function New_Node return Node_Access is\n          begin\n+            Node.Color := Red;\n+            Node.Parent := null;\n+            Node.Right := null;\n+            Node.Left := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1372,10 +1563,17 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n       Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n@@ -1482,6 +1680,20 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Tree     : Tree_Type;\n+      Node     : Node_Access;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert_Sans_Hint (Tree, New_Item, Node, Inserted);\n+      return Set'(Controlled with Tree);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1532,4 +1744,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Indefinite_Ordered_Sets;"}, {"sha": "1c1c7860332c3638a56102f4ea37b0003149dd21", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -61,6 +61,8 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -266,6 +268,7 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -275,9 +278,19 @@ private\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "d235d0b0c79ad35399623456517c5a8f4aca7f5c", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -624,6 +624,7 @@ package body Ada.Containers.Hashed_Maps is\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n+\n       begin\n          if Node = null then\n             return No_Element;\n@@ -695,6 +696,14 @@ package body Ada.Containers.Hashed_Maps is\n       Read_Nodes (Stream, Container.HT);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------\n    -- Read_Node --\n    ---------------\n@@ -743,19 +752,27 @@ package body Ada.Containers.Hashed_Maps is\n    -- Replace_Element --\n    ---------------------\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n       pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container.HT.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      Position.Node.Element := By;\n+      Position.Node.Element := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -784,9 +801,10 @@ package body Ada.Containers.Hashed_Maps is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type))\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n    is\n    begin\n       pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n@@ -795,12 +813,14 @@ package body Ada.Containers.Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n-      declare\n-         M  : Map renames Position.Container.all;\n-         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n \n-         B : Natural renames HT.Busy;\n-         L : Natural renames HT.Lock;\n+      declare\n+         HT : Hash_Table_Type renames Container.HT;\n+         B  : Natural renames HT.Busy;\n+         L  : Natural renames HT.Lock;\n \n       begin\n          B := B + 1;\n@@ -809,7 +829,6 @@ package body Ada.Containers.Hashed_Maps is\n          declare\n             K : Key_Type renames Position.Node.Key;\n             E : Element_Type renames Position.Node.Element;\n-\n          begin\n             Process (K, E);\n          exception\n@@ -891,6 +910,14 @@ package body Ada.Containers.Hashed_Maps is\n       Write_Nodes (Stream, Container.HT);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n    ----------------\n    -- Write_Node --\n    ----------------"}, {"sha": "42b1cada502b5cf93a3a36ef9f00a945f9a60ed5", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -39,13 +39,10 @@ with Ada.Finalization;\n \n generic\n    type Key_Type is private;\n-\n    type Element_Type is private;\n \n    with function Hash (Key : Key_Type) return Hash_Type;\n-\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Hashed_Maps is\n@@ -61,6 +58,11 @@ package Ada.Containers.Hashed_Maps is\n \n    function \"=\" (Left, Right : Map) return Boolean;\n \n+   function Capacity (Container : Map) return Count_Type;\n+\n+   procedure Reserve_Capacity (Container : in out Map;\n+                               Capacity  : Count_Type);\n+\n    function Length (Container : Map) return Count_Type;\n \n    function Is_Empty (Container : Map) return Boolean;\n@@ -71,18 +73,22 @@ package Ada.Containers.Hashed_Maps is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access\n                    procedure (Key : Key_Type; Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n                    procedure (Key : Key_Type; Element : in out Element_Type));\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type);\n-\n    procedure Move (Target : in out Map; Source : in out Map);\n \n    procedure Insert\n@@ -113,24 +119,24 @@ package Ada.Containers.Hashed_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n-   procedure Delete (Container : in out Map; Key : Key_Type);\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor);\n-\n    procedure Exclude (Container : in out Map; Key : Key_Type);\n \n-   function Contains (Container : Map; Key : Key_Type) return Boolean;\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor;\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n \n-   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n \n    function First (Container : Map) return Cursor;\n \n    function Next (Position : Cursor) return Cursor;\n \n    procedure Next (Position : in out Cursor);\n \n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n@@ -143,11 +149,6 @@ package Ada.Containers.Hashed_Maps is\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n \n-   function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity (Container : in out Map;\n-                               Capacity  : Count_Type);\n-\n private\n    pragma Inline (\"=\");\n    pragma Inline (Length);\n@@ -211,6 +212,18 @@ private\n          Node      : Node_Access;\n       end record;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n    No_Element : constant Cursor := (Container => null, Node => null);\n \n end Ada.Containers.Hashed_Maps;"}, {"sha": "afb219055d507e6cdb6096c2bdace1ea75b80ac7", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -72,6 +72,12 @@ package body Ada.Containers.Hashed_Sets is\n    function Hash_Node (Node : Node_Access) return Hash_Type;\n    pragma Inline (Hash_Node);\n \n+   procedure Insert\n+     (HT       : in out Hash_Table_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n+\n    function Is_In\n      (HT  : Hash_Table_Type;\n       Key : Node_Access) return Boolean;\n@@ -594,6 +600,32 @@ package body Ada.Containers.Hashed_Sets is\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n+   is\n+   begin\n+      Insert (Container.HT, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error;\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (HT       : in out Hash_Table_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n    is\n       function New_Node (Next : Node_Access) return Node_Access;\n       pragma Inline (New_Node);\n@@ -606,44 +638,24 @@ package body Ada.Containers.Hashed_Sets is\n       --------------\n \n       function New_Node (Next : Node_Access) return Node_Access is\n-         Node : constant Node_Access := new Node_Type'(New_Item, Next);\n       begin\n-         return Node;\n+         return new Node_Type'(New_Item, Next);\n       end New_Node;\n \n-      HT : Hash_Table_Type renames Container.HT;\n-\n    --  Start of processing for Insert\n \n    begin\n       if HT_Ops.Capacity (HT) = 0 then\n          HT_Ops.Reserve_Capacity (HT, 1);\n       end if;\n \n-      Local_Insert (HT, New_Item, Position.Node, Inserted);\n+      Local_Insert (HT, New_Item, Node, Inserted);\n \n       if Inserted\n         and then HT.Length > HT_Ops.Capacity (HT)\n       then\n          HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n-\n-      Position.Container := Container'Unchecked_Access;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error;\n-      end if;\n    end Insert;\n \n    ------------------\n@@ -970,6 +982,14 @@ package body Ada.Containers.Hashed_Sets is\n       Read_Nodes (Stream, Container.HT);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------\n    -- Read_Node --\n    ---------------\n@@ -1366,6 +1386,20 @@ package body Ada.Containers.Hashed_Sets is\n       return (Controlled with HT => (Buckets, Length, 0, 0));\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      HT       : Hash_Table_Type;\n+      Node     : Node_Access;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (HT, New_Item, Node, Inserted);\n+      return Set'(Controlled with HT);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1595,6 +1629,14 @@ package body Ada.Containers.Hashed_Sets is\n       Write_Nodes (Stream, Container.HT);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n    ----------------\n    -- Write_Node --\n    ----------------"}, {"sha": "19aad2911fa94faf91d67cf21fe60cc74c38d45b", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -62,6 +62,8 @@ package Ada.Containers.Hashed_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Capacity (Container : Set) return Count_Type;\n \n    procedure Reserve_Capacity\n@@ -222,6 +224,7 @@ private\n \n    use HT_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -232,9 +235,19 @@ private\n          Node      : Node_Access;\n       end record;\n \n-   No_Element : constant Cursor := (Container => null, Node => null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := (Container => null, Node => null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "b3c7cd8e910cff93bc5165ccb6aa43a3ca82422f", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 115, "deletions": 74, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -475,44 +475,6 @@ package body Ada.Containers.Indefinite_Vectors is\n          Count);\n    end Append;\n \n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign\n-     (Target : in out Vector;\n-      Source : Vector)\n-   is\n-      N : constant Count_Type := Length (Source);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      if N > Capacity (Target) then\n-         Reserve_Capacity (Target, Capacity => N);\n-      end if;\n-\n-      for J in Index_Type'First .. Source.Last loop\n-         declare\n-            EA : constant Element_Access := Source.Elements (J);\n-         begin\n-            if EA /= null then\n-               Target.Elements (J) := new Element_Type'(EA.all);\n-            end if;\n-         end;\n-\n-         Target.Last := J;\n-      end loop;\n-   end Assign;\n-\n    --------------\n    -- Capacity --\n    --------------\n@@ -553,7 +515,8 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    function Contains\n      (Container : Vector;\n-      Item      : Element_Type) return Boolean is\n+      Item      : Element_Type) return Boolean\n+   is\n    begin\n       return Find_Index (Container, Item) /= No_Index;\n    end Contains;\n@@ -649,20 +612,15 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /=\n-           Vector_Access'(Container'Unchecked_Access)\n+      if Position.Container /= Container'Unchecked_Access\n         or else Position.Index > Container.Last\n       then\n          raise Program_Error;\n       end if;\n \n       Delete (Container, Position.Index, Count);\n \n-      if Position.Index <= Container.Last then\n-         Position := (Container'Unchecked_Access, Position.Index);\n-      else\n-         Position := No_Element;\n-      end if;\n+      Position := No_Element;  -- See comment in a-convec.adb\n    end Delete;\n \n    ------------------\n@@ -738,7 +696,16 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error;\n       end if;\n \n-      return Container.Elements (Index).all;\n+      declare\n+         EA : constant Element_Access := Container.Elements (Index);\n+\n+      begin\n+         if EA = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         return EA.all;\n+      end;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n@@ -773,13 +740,12 @@ package body Ada.Containers.Indefinite_Vectors is\n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor is\n-\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n    begin\n       if Position.Container /= null\n-        and then (Position.Container /=\n-                    Vector_Access'(Container'Unchecked_Access)\n-                  or else Position.Index > Container.Last)\n+        and then (Position.Container /= Container'Unchecked_Access\n+                    or else Position.Index > Container.Last)\n       then\n          raise Program_Error;\n       end if;\n@@ -802,7 +768,8 @@ package body Ada.Containers.Indefinite_Vectors is\n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'First) return Extended_Index is\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   is\n    begin\n       for Indx in Index .. Container.Last loop\n          if Container.Elements (Indx) /= null\n@@ -1287,7 +1254,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error;\n       end if;\n@@ -1843,6 +1810,10 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error;\n       end if;\n \n+      if V.Elements (Index) = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       B := B + 1;\n       L := L + 1;\n \n@@ -1907,14 +1878,22 @@ package body Ada.Containers.Indefinite_Vectors is\n       end loop;\n    end Read;\n \n+   procedure Read\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n    procedure Replace_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n    begin\n       if Index > Container.Last then\n@@ -1928,18 +1907,26 @@ package body Ada.Containers.Indefinite_Vectors is\n       declare\n          X : Element_Access := Container.Elements (Index);\n       begin\n-         Container.Elements (Index) := new Element_Type'(By);\n+         Container.Elements (Index) := new Element_Type'(New_Item);\n          Free (X);\n       end;\n    end Replace_Element;\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      Replace_Element (Position.Container.all, Position.Index, By);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (Container, Position.Index, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -2083,6 +2070,41 @@ package body Ada.Containers.Indefinite_Vectors is\n       end;\n    end Reserve_Capacity;\n \n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out Vector) is\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         I : Index_Type := Index_Type'First;\n+         J : Index_Type := Container.Last;\n+         E : Elements_Type renames Container.Elements.all;\n+\n+      begin\n+         while I < J loop\n+            declare\n+               EI : constant Element_Access := E (I);\n+\n+            begin\n+               E (I) := E (J);\n+               E (J) := EI;\n+            end;\n+\n+            I := I + 1;\n+            J := J - 1;\n+         end loop;\n+      end;\n+   end Reverse_Elements;\n+\n    ------------------\n    -- Reverse_Find --\n    ------------------\n@@ -2096,8 +2118,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Position.Container /= null\n-        and then Position.Container /=\n-                   Vector_Access'(Container'Unchecked_Access)\n+        and then Position.Container /= Container'Unchecked_Access\n       then\n          raise Program_Error;\n       end if;\n@@ -2230,7 +2251,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    ----------\n \n    procedure Swap\n-     (Container : Vector;\n+     (Container : in out Vector;\n       I, J      : Index_Type)\n    is\n    begin\n@@ -2260,7 +2281,9 @@ package body Ada.Containers.Indefinite_Vectors is\n       end;\n    end Swap;\n \n-   procedure Swap (I, J : Cursor)\n+   procedure Swap\n+     (Container : in out Vector;\n+      I, J      : Cursor)\n    is\n    begin\n       if I.Container = null\n@@ -2269,11 +2292,13 @@ package body Ada.Containers.Indefinite_Vectors is\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= J.Container then\n+      if I.Container /= Container'Unrestricted_Access\n+        or else J.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error;\n       end if;\n \n-      Swap (I.Container.all, I.Index, J.Index);\n+      Swap (Container, I.Index, J.Index);\n    end Swap;\n \n    ---------------\n@@ -2387,24 +2412,27 @@ package body Ada.Containers.Indefinite_Vectors is\n    --------------------\n \n    procedure Update_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n+      B : Natural renames Container.Busy;\n+      L : Natural renames Container.Lock;\n \n    begin\n       if Index > Container.Last then\n          raise Constraint_Error;\n       end if;\n \n+      if Container.Elements (Index) = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       B := B + 1;\n       L := L + 1;\n \n       begin\n-         Process (V.Elements (Index).all);\n+         Process (Container.Elements (Index).all);\n       exception\n          when others =>\n             L := L - 1;\n@@ -2417,15 +2445,20 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Update_Element;\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      Update_Element (Position.Container.all, Position.Index, Process);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n    end Update_Element;\n \n    -----------\n@@ -2466,4 +2499,12 @@ package body Ada.Containers.Indefinite_Vectors is\n       end;\n    end Write;\n \n+   procedure Write\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Indefinite_Vectors;"}, {"sha": "822e797f04ad0883dc05c586fda8c09d7bc8f3f4", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -38,7 +38,6 @@ with Ada.Streams;\n \n generic\n    type Index_Type is range <>;\n-\n    type Element_Type (<>) is private;\n \n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n@@ -52,8 +51,6 @@ package Ada.Containers.Indefinite_Vectors is\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   subtype Index_Subtype is Index_Type;\n-\n    type Vector is tagged private;\n \n    type Cursor is private;\n@@ -62,6 +59,8 @@ package Ada.Containers.Indefinite_Vectors is\n \n    No_Element : constant Cursor;\n \n+   function \"=\" (Left, Right : Vector) return Boolean;\n+\n    function To_Vector (Length : Count_Type) return Vector;\n \n    function To_Vector\n@@ -76,8 +75,6 @@ package Ada.Containers.Indefinite_Vectors is\n \n    function \"&\" (Left, Right : Element_Type) return Vector;\n \n-   function \"=\" (Left, Right : Vector) return Boolean;\n-\n    function Capacity (Container : Vector) return Count_Type;\n \n    procedure Reserve_Capacity\n@@ -86,6 +83,10 @@ package Ada.Containers.Indefinite_Vectors is\n \n    function Length (Container : Vector) return Count_Type;\n \n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Count_Type);\n+\n    function Is_Empty (Container : Vector) return Boolean;\n \n    procedure Clear (Container : in out Vector);\n@@ -102,6 +103,16 @@ package Ada.Containers.Indefinite_Vectors is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Container : Vector;\n       Index     : Index_Type;\n@@ -112,24 +123,14 @@ package Ada.Containers.Indefinite_Vectors is\n       Process  : not null access procedure (Element : Element_Type));\n \n    procedure Update_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type));\n-\n-   procedure Replace_Element\n-     (Container : Vector;\n-      Index     : Index_Type;\n-      By        : Element_Type);\n-\n-   procedure Replace_Element\n-     (Position : Cursor;\n-      By       : Element_Type);\n-\n-   procedure Assign (Target : in out Vector; Source : Vector);\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Move (Target : in out Vector; Source : in out Vector);\n \n@@ -197,10 +198,6 @@ package Ada.Containers.Indefinite_Vectors is\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Set_Length\n-     (Container : in out Vector;\n-      Length    : Count_Type);\n-\n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n@@ -219,6 +216,12 @@ package Ada.Containers.Indefinite_Vectors is\n      (Container : in out Vector;\n       Count     : Count_Type := 1);\n \n+   procedure Reverse_Elements (Container : in out Vector);\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type);\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor);\n+\n    function First_Index (Container : Vector) return Index_Type;\n \n    function First (Container : Vector) return Cursor;\n@@ -231,21 +234,13 @@ package Ada.Containers.Indefinite_Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type;\n \n-   procedure Swap (Container : Vector; I, J : Index_Type);\n-\n-   procedure Swap (I, J : Cursor);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   package Generic_Sorting is\n-\n-      function Is_Sorted (Container : Vector) return Boolean;\n+   function Next (Position : Cursor) return Cursor;\n \n-      procedure Sort (Container : in out Vector);\n+   procedure Next (Position : in out Cursor);\n \n-      procedure Merge (Target, Source : in out Vector);\n+   function Previous (Position : Cursor) return Cursor;\n \n-   end Generic_Sorting;\n+   procedure Previous (Position : in out Cursor);\n \n    function Find_Index\n      (Container : Vector;\n@@ -255,30 +250,22 @@ package Ada.Containers.Indefinite_Vectors is\n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n-       Position  : Cursor := No_Element) return Cursor;\n+      Position  : Cursor := No_Element) return Cursor;\n \n    function Reverse_Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index;\n \n-   function Reverse_Find (Container : Vector;\n-                          Item      : Element_Type;\n-                          Position  : Cursor := No_Element)\n-      return Cursor;\n+   function Reverse_Find\n+     (Container : Vector;\n+      Item      : Element_Type;\n+      Position  : Cursor := No_Element) return Cursor;\n \n    function Contains\n      (Container : Vector;\n       Item      : Element_Type) return Boolean;\n \n-   function Next (Position : Cursor) return Cursor;\n-\n-   function Previous (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   procedure Previous (Position : in out Cursor);\n-\n    function Has_Element (Position : Cursor) return Boolean;\n \n    procedure Iterate\n@@ -289,6 +276,18 @@ package Ada.Containers.Indefinite_Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor));\n \n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector);\n+\n+   end Generic_Sorting;\n+\n private\n \n    pragma Inline (First_Index);\n@@ -346,6 +345,18 @@ private\n       Index     : Index_Type := Index_Type'First;\n    end record;\n \n+   procedure Write\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n    No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n \n end Ada.Containers.Indefinite_Vectors;"}, {"sha": "b298fd6a736fc2a91fc53b217a0c29ed468abfb1", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 127, "deletions": 64, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -303,37 +303,6 @@ package body Ada.Containers.Vectors is\n          Count);\n    end Append;\n \n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign\n-     (Target : in out Vector;\n-      Source : Vector)\n-   is\n-      N : constant Count_Type := Length (Source);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      if N = 0 then\n-         return;\n-      end if;\n-\n-      if N > Capacity (Target) then\n-         Reserve_Capacity (Target, Capacity => N);\n-      end if;\n-\n-      Target.Elements (Index_Type'First .. Source.Last) :=\n-        Source.Elements (Index_Type'First .. Source.Last);\n-\n-      Target.Last := Source.Last;\n-   end Assign;\n-\n    --------------\n    -- Capacity --\n    --------------\n@@ -443,20 +412,25 @@ package body Ada.Containers.Vectors is\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /=\n-           Vector_Access'(Container'Unchecked_Access)\n+      if Position.Container /= Container'Unrestricted_Access\n         or else Position.Index > Container.Last\n       then\n          raise Program_Error;\n       end if;\n \n       Delete (Container, Position.Index, Count);\n \n-      if Position.Index <= Container.Last then\n-         Position := (Container'Unchecked_Access, Position.Index);\n-      else\n-         Position := No_Element;\n-      end if;\n+      --  This is the old behavior, prior to the York API (2005/06):\n+\n+      --  if Position.Index <= Container.Last then\n+      --    Position := (Container'Unchecked_Access, Position.Index);\n+      --  else\n+      --    Position := No_Element;\n+      --  end if;\n+\n+      --  This is the behavior specified by the York API:\n+\n+      Position := No_Element;\n    end Delete;\n \n    ------------------\n@@ -539,6 +513,7 @@ package body Ada.Containers.Vectors is\n \n    procedure Finalize (Container : in out Vector) is\n       X : Elements_Access := Container.Elements;\n+\n    begin\n       if Container.Busy > 0 then\n          raise Program_Error;\n@@ -556,13 +531,12 @@ package body Ada.Containers.Vectors is\n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor is\n-\n+      Position  : Cursor := No_Element) return Cursor\n+   is\n    begin\n       if Position.Container /= null\n-        and then (Position.Container /=\n-                    Vector_Access'(Container'Unchecked_Access)\n-                  or else Position.Index > Container.Last)\n+        and then (Position.Container /= Container'Unrestricted_Access\n+                    or else Position.Index > Container.Last)\n       then\n          raise Program_Error;\n       end if;\n@@ -583,7 +557,8 @@ package body Ada.Containers.Vectors is\n    function Find_Index\n      (Container : Vector;\n       Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'First) return Extended_Index is\n+      Index     : Index_Type := Index_Type'First) return Extended_Index\n+   is\n    begin\n       for Indx in Index .. Container.Last loop\n          if Container.Elements (Indx) = Item then\n@@ -1152,6 +1127,31 @@ package body Ada.Containers.Vectors is\n       Position := Cursor'(Container'Unchecked_Access, Index);\n    end Insert;\n \n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Count);\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1)\n+   is\n+      New_Item : Element_Type;  -- Default-initialized value\n+      pragma Warnings (Off, New_Item);\n+\n+   begin\n+      Insert (Container, Before, New_Item, Position, Count);\n+   end Insert;\n+\n    ------------------\n    -- Insert_Space --\n    ------------------\n@@ -1339,7 +1339,7 @@ package body Ada.Containers.Vectors is\n          Index := Before.Index;\n       end if;\n \n-      Insert_Space (Container, Index, Count);\n+      Insert_Space (Container, Index, Count => Count);\n \n       Position := Cursor'(Container'Unchecked_Access, Index);\n    end Insert_Space;\n@@ -1365,7 +1365,6 @@ package body Ada.Containers.Vectors is\n       B : Natural renames V.Busy;\n \n    begin\n-\n       B := B + 1;\n \n       begin\n@@ -1379,7 +1378,6 @@ package body Ada.Containers.Vectors is\n       end;\n \n       B := B - 1;\n-\n    end Iterate;\n \n    ----------\n@@ -1620,14 +1618,22 @@ package body Ada.Containers.Vectors is\n       end loop;\n    end Read;\n \n+   procedure Read\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n \n    procedure Replace_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n    begin\n       if Index > Container.Last then\n@@ -1638,16 +1644,24 @@ package body Ada.Containers.Vectors is\n          raise Program_Error;\n       end if;\n \n-      Container.Elements (Index) := By;\n+      Container.Elements (Index) := New_Item;\n    end Replace_Element;\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      Replace_Element (Position.Container.all, Position.Index, By);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Replace_Element (Container, Position.Index, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -1799,6 +1813,41 @@ package body Ada.Containers.Vectors is\n       end;\n    end Reserve_Capacity;\n \n+   ----------------------\n+   -- Reverse_Elements --\n+   ----------------------\n+\n+   procedure Reverse_Elements (Container : in out Vector) is\n+   begin\n+      if Container.Length <= 1 then\n+         return;\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      declare\n+         I : Index_Type := Index_Type'First;\n+         J : Index_Type := Container.Last;\n+         E : Elements_Type renames Container.Elements.all;\n+\n+      begin\n+         while I < J loop\n+            declare\n+               EI : constant Element_Type := E (I);\n+\n+            begin\n+               E (I) := E (J);\n+               E (J) := EI;\n+            end;\n+\n+            I := I + 1;\n+            J := J - 1;\n+         end loop;\n+      end;\n+   end Reverse_Elements;\n+\n    ------------------\n    -- Reverse_Find --\n    ------------------\n@@ -1921,7 +1970,7 @@ package body Ada.Containers.Vectors is\n    -- Swap --\n    ----------\n \n-   procedure Swap (Container : Vector; I, J : Index_Type) is\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n       if I > Container.Last\n         or else J > Container.Last\n@@ -1949,19 +1998,21 @@ package body Ada.Containers.Vectors is\n       end;\n    end Swap;\n \n-   procedure Swap (I, J : Cursor) is\n+   procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n       if I.Container = null\n         or else J.Container = null\n       then\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= J.Container then\n+      if I.Container /= Container'Unrestricted_Access\n+        or else J.Container /= Container'Unrestricted_Access\n+      then\n          raise Program_Error;\n       end if;\n \n-      Swap (I.Container.all, I.Index, J.Index);\n+      Swap (Container, I.Index, J.Index);\n    end Swap;\n \n    ---------------\n@@ -2057,13 +2108,12 @@ package body Ada.Containers.Vectors is\n    --------------------\n \n    procedure Update_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n+      B : Natural renames Container.Busy;\n+      L : Natural renames Container.Lock;\n \n    begin\n       if Index > Container.Last then\n@@ -2074,7 +2124,7 @@ package body Ada.Containers.Vectors is\n       L := L + 1;\n \n       begin\n-         Process (V.Elements (Index));\n+         Process (Container.Elements (Index));\n       exception\n          when others =>\n             L := L - 1;\n@@ -2087,15 +2137,20 @@ package body Ada.Containers.Vectors is\n    end Update_Element;\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type))\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error;\n       end if;\n \n-      Update_Element (Position.Container.all, Position.Index, Process);\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n    end Update_Element;\n \n    -----------\n@@ -2114,4 +2169,12 @@ package body Ada.Containers.Vectors is\n       end loop;\n    end Write;\n \n+   procedure Write\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Vectors;"}, {"sha": "5b268b5e3f056767c2e6e0a0c7bbb0cb2506eb75", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -50,8 +50,6 @@ package Ada.Containers.Vectors is\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   subtype Index_Subtype is Index_Type;\n-\n    type Vector is tagged private;\n \n    type Cursor is private;\n@@ -60,6 +58,8 @@ package Ada.Containers.Vectors is\n \n    No_Element : constant Cursor;\n \n+   function \"=\" (Left, Right : Vector) return Boolean;\n+\n    function To_Vector (Length : Count_Type) return Vector;\n \n    function To_Vector\n@@ -74,8 +74,6 @@ package Ada.Containers.Vectors is\n \n    function \"&\" (Left, Right : Element_Type) return Vector;\n \n-   function \"=\" (Left, Right : Vector) return Boolean;\n-\n    function Capacity (Container : Vector) return Count_Type;\n \n    procedure Reserve_Capacity\n@@ -84,6 +82,10 @@ package Ada.Containers.Vectors is\n \n    function Length (Container : Vector) return Count_Type;\n \n+   procedure Set_Length\n+     (Container : in out Vector;\n+      Length    : Count_Type);\n+\n    function Is_Empty (Container : Vector) return Boolean;\n \n    procedure Clear (Container : in out Vector);\n@@ -100,6 +102,16 @@ package Ada.Containers.Vectors is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Index     : Index_Type;\n+      New_Item  : Element_Type);\n+\n+   procedure Replace_Element\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Container : Vector;\n       Index     : Index_Type;\n@@ -110,22 +122,14 @@ package Ada.Containers.Vectors is\n       Process  : not null access procedure (Element : Element_Type));\n \n    procedure Update_Element\n-     (Container : Vector;\n+     (Container : in out Vector;\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type));\n-\n-   procedure Replace_Element\n-     (Container : Vector;\n-      Index     : Index_Type;\n-      By        : Element_Type);\n-\n-   procedure Replace_Element (Position : Cursor; By : Element_Type);\n-\n-   procedure Assign (Target : in out Vector; Source : Vector);\n+     (Container : in out Vector;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Element : in out Element_Type));\n \n    procedure Move (Target : in out Vector; Source : in out Vector);\n \n@@ -164,6 +168,17 @@ package Ada.Containers.Vectors is\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Extended_Index;\n+      Count     : Count_Type := 1);\n+\n+   procedure Insert\n+     (Container : in out Vector;\n+      Before    : Cursor;\n+      Position  : out Cursor;\n+      Count     : Count_Type := 1);\n+\n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Vector);\n@@ -193,10 +208,6 @@ package Ada.Containers.Vectors is\n       Position  : out Cursor;\n       Count     : Count_Type := 1);\n \n-   procedure Set_Length\n-     (Container : in out Vector;\n-      Length    : Count_Type);\n-\n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n@@ -215,6 +226,12 @@ package Ada.Containers.Vectors is\n      (Container : in out Vector;\n       Count     : Count_Type := 1);\n \n+   procedure Reverse_Elements (Container : in out Vector);\n+\n+   procedure Swap (Container : in out Vector; I, J : Index_Type);\n+\n+   procedure Swap (Container : in out Vector; I, J : Cursor);\n+\n    function First_Index (Container : Vector) return Index_Type;\n \n    function First (Container : Vector) return Cursor;\n@@ -227,21 +244,13 @@ package Ada.Containers.Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type;\n \n-   procedure Swap (Container : Vector; I, J : Index_Type);\n-\n-   procedure Swap (I, J : Cursor);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   package Generic_Sorting is\n-\n-      function Is_Sorted (Container : Vector) return Boolean;\n+   function Next (Position : Cursor) return Cursor;\n \n-      procedure Sort (Container : in out Vector);\n+   procedure Next (Position : in out Cursor);\n \n-      procedure Merge (Target, Source : in out Vector);\n+   function Previous (Position : Cursor) return Cursor;\n \n-   end Generic_Sorting;\n+   procedure Previous (Position : in out Cursor);\n \n    function Find_Index\n      (Container : Vector;\n@@ -267,14 +276,6 @@ package Ada.Containers.Vectors is\n      (Container : Vector;\n       Item      : Element_Type) return Boolean;\n \n-   function Next (Position : Cursor) return Cursor;\n-\n-   function Previous (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   procedure Previous (Position : in out Cursor);\n-\n    function Has_Element (Position : Cursor) return Boolean;\n \n    procedure Iterate\n@@ -285,6 +286,18 @@ package Ada.Containers.Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor));\n \n+   generic\n+      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+   package Generic_Sorting is\n+\n+      function Is_Sorted (Container : Vector) return Boolean;\n+\n+      procedure Sort (Container : in out Vector);\n+\n+      procedure Merge (Target : in out Vector; Source : in out Vector);\n+\n+   end Generic_Sorting;\n+\n private\n \n    pragma Inline (First_Index);\n@@ -340,6 +353,18 @@ private\n       Index     : Index_Type := Index_Type'First;\n    end record;\n \n+   procedure Write\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream   : access Root_Stream_Type'Class;\n+      Position : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n    No_Element : constant Cursor := Cursor'(null, Index_Type'First);\n \n end Ada.Containers.Vectors;"}, {"sha": "fad63d4e49852cfaf0d2c12e2bd48796f52f1633", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 276, "deletions": 81, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -81,6 +81,8 @@ package body Ada.Containers.Ordered_Maps is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n+   procedure Free (X : in out Node_Access);\n+\n    function Is_Equal_Node_Node (L, R : Node_Access) return Boolean;\n    pragma Inline (Is_Equal_Node_Node);\n \n@@ -98,8 +100,6 @@ package body Ada.Containers.Ordered_Maps is\n    -- Local Instantiations --\n    --------------------------\n \n-   procedure Free is new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    package Tree_Operations is\n       new Red_Black_Trees.Generic_Operations (Tree_Types);\n \n@@ -127,16 +127,42 @@ package body Ada.Containers.Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Key < Right.Node.Key;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Key < Right;\n    end \"<\";\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Key;\n    end \"<\";\n \n@@ -155,16 +181,42 @@ package body Ada.Containers.Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Key < Left.Node.Key;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n       return Right < Left.Node.Key;\n    end \">\";\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Key < Left;\n    end \">\";\n \n@@ -231,12 +283,12 @@ package body Ada.Containers.Ordered_Maps is\n \n    function Copy_Node (Source : Node_Access) return Node_Access is\n       Target : constant Node_Access :=\n-                 new Node_Type'(Parent  => null,\n-                                Left    => null,\n-                                Right   => null,\n-                                Color   => Source.Color,\n+                 new Node_Type'(Color   => Source.Color,\n                                 Key     => Source.Key,\n-                                Element => Source.Element);\n+                                Element => Source.Element,\n+                                Parent  => null,\n+                                Left    => null,\n+                                Right   => null);\n    begin\n       return Target;\n    end Copy_Node;\n@@ -246,16 +298,20 @@ package body Ada.Containers.Ordered_Maps is\n    ------------\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n+      Tree : Tree_Type renames Container.Tree;\n+\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unrestricted_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n+      pragma Assert (Vet (Tree, Position.Node), \"bad cursor in Delete\");\n+\n+      Tree_Operations.Delete_Node_Sans_Free (Tree, Position.Node);\n       Free (Position.Node);\n \n       Position.Container := null;\n@@ -269,7 +325,7 @@ package body Ada.Containers.Ordered_Maps is\n          raise Constraint_Error;\n       end if;\n \n-      Delete_Node_Sans_Free (Container.Tree, X);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n       Free (X);\n    end Delete;\n \n@@ -279,6 +335,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    procedure Delete_First (Container : in out Map) is\n       X : Node_Access := Container.Tree.First;\n+\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -292,6 +349,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    procedure Delete_Last (Container : in out Map) is\n       X : Node_Access := Container.Tree.Last;\n+\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -305,15 +363,42 @@ package body Ada.Containers.Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n+\n    begin\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Node.Element;\n    end Element;\n \n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Keys;\n+\n    -------------\n    -- Exclude --\n    -------------\n@@ -323,7 +408,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if X /= null then\n-         Delete_Node_Sans_Free (Container.Tree, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n          Free (X);\n       end if;\n    end Exclude;\n@@ -348,30 +433,44 @@ package body Ada.Containers.Ordered_Maps is\n    -----------\n \n    function First (Container : Map) return Cursor is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      if Container.Tree.First = null then\n+      if T.First = null then\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n+      return Cursor'(Container'Unrestricted_Access, T.First);\n    end First;\n \n    -------------------\n    -- First_Element --\n    -------------------\n \n    function First_Element (Container : Map) return Element_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.First.Element;\n+      if T.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.First.Element;\n    end First_Element;\n \n    ---------------\n    -- First_Key --\n    ---------------\n \n    function First_Key (Container : Map) return Key_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.First.Key;\n+      if T.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.First.Key;\n    end First_Key;\n \n    -----------\n@@ -389,6 +488,26 @@ package body Ada.Containers.Ordered_Maps is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      if X = null then\n+         return;\n+      end if;\n+\n+      X.Parent := X;\n+      X.Left := X;\n+      X.Right := X;\n+\n+      Deallocate (X);\n+   end Free;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -444,15 +563,13 @@ package body Ada.Containers.Ordered_Maps is\n       --------------\n \n       function New_Node return Node_Access is\n-         Node : constant Node_Access :=\n-                  new Node_Type'(Parent  => null,\n-                                 Left    => null,\n-                                 Right   => null,\n-                                 Color   => Red,\n-                                 Key     => Key,\n-                                 Element => New_Item);\n       begin\n-         return Node;\n+         return new Node_Type'(Key     => Key,\n+                               Element => New_Item,\n+                               Color   => Red_Black_Trees.Red,\n+                               Parent  => null,\n+                               Left    => null,\n+                               Right   => null);\n       end New_Node;\n \n    --  Start of processing for Insert\n@@ -507,18 +624,13 @@ package body Ada.Containers.Ordered_Maps is\n       --------------\n \n       function New_Node return Node_Access is\n-         Node : Node_Access := new Node_Type;\n-\n       begin\n-         begin\n-            Node.Key := Key;\n-         exception\n-            when others =>\n-               Free (Node);\n-               raise;\n-         end;\n-\n-         return Node;\n+         return new Node_Type'(Key     => Key,\n+                               Element => <>,\n+                               Color   => Red_Black_Trees.Red,\n+                               Parent  => null,\n+                               Left    => null,\n+                               Right   => null);\n       end New_Node;\n \n    --  Start of processing for Insert\n@@ -633,6 +745,13 @@ package body Ada.Containers.Ordered_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Key\");\n+\n       return Position.Node.Key;\n    end Key;\n \n@@ -641,30 +760,44 @@ package body Ada.Containers.Ordered_Maps is\n    ----------\n \n    function Last (Container : Map) return Cursor is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      if Container.Tree.Last = null then\n+      if T.Last = null then\n          return No_Element;\n       end if;\n \n-      return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n+      return Cursor'(Container'Unrestricted_Access, T.Last);\n    end Last;\n \n    ------------------\n    -- Last_Element --\n    ------------------\n \n    function Last_Element (Container : Map) return Element_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.Last.Element;\n+      if T.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.Last.Element;\n    end Last_Element;\n \n    --------------\n    -- Last_Key --\n    --------------\n \n    function Last_Key (Container : Map) return Key_Type is\n+      T : Tree_Type renames Container.Tree;\n+\n    begin\n-      return Container.Tree.Last.Key;\n+      if T.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return T.Last.Key;\n    end Last_Key;\n \n    ----------\n@@ -712,6 +845,9 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n@@ -749,6 +885,9 @@ package body Ada.Containers.Ordered_Maps is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n@@ -771,29 +910,40 @@ package body Ada.Containers.Ordered_Maps is\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type))\n    is\n-      K : Key_Type renames Position.Node.Key;\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      T : Tree_Type renames Position.Container.Tree;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key;\n+            E : Element_Type renames Position.Node.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -835,6 +985,14 @@ package body Ada.Containers.Ordered_Maps is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -863,15 +1021,28 @@ package body Ada.Containers.Ordered_Maps is\n    -- Replace_Element --\n    ---------------------\n \n-   procedure Replace_Element (Position : Cursor; By : Element_Type) is\n-      E : Element_Type renames Position.Node.Element;\n-\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n    begin\n-      if Position.Container.Tree.Lock > 0 then\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      E := By;\n+      if Container.Tree.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Position.Node.Element := New_Item;\n    end Replace_Element;\n \n    ---------------------\n@@ -968,33 +1139,49 @@ package body Ada.Containers.Ordered_Maps is\n    --------------------\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type))\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n    is\n-      K : Key_Type renames Position.Node.Key;\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      T : Tree_Type renames Position.Container.Tree;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error;\n+      end if;\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Update_Element\");\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      declare\n+         T : Tree_Type renames Container.Tree;\n+\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key;\n+            E : Element_Type renames Position.Node.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Update_Element;\n \n    -----------\n@@ -1032,4 +1219,12 @@ package body Ada.Containers.Ordered_Maps is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Ordered_Maps;"}, {"sha": "7f8386b4b13cb864a5e93eb6fa6b339b476f66a3", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -38,9 +38,7 @@ with Ada.Finalization;\n with Ada.Streams;\n \n generic\n-\n    type Key_Type is private;\n-\n    type Element_Type is private;\n \n    with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n@@ -49,6 +47,8 @@ generic\n package Ada.Containers.Ordered_Maps is\n    pragma Preelaborate;\n \n+   function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n    type Map is tagged private;\n \n    type Cursor is private;\n@@ -69,18 +69,22 @@ package Ada.Containers.Ordered_Maps is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access\n                    procedure (Key : Key_Type; Element : Element_Type));\n \n    procedure Update_Element\n-     (Position : Cursor;\n-      Process  : not null access\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n                    procedure (Key : Key_Type; Element : in out Element_Type));\n \n-   procedure Replace_Element (Position : Cursor; By : in Element_Type);\n-\n    procedure Move (Target : in out Map; Source : in out Map);\n \n    procedure Insert\n@@ -111,6 +115,8 @@ package Ada.Containers.Ordered_Maps is\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n \n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+\n    procedure Delete (Container : in out Map; Key : Key_Type);\n \n    procedure Delete (Container : in out Map; Position : in out Cursor);\n@@ -119,30 +125,18 @@ package Ada.Containers.Ordered_Maps is\n \n    procedure Delete_Last (Container : in out Map);\n \n-   procedure Exclude (Container : in out Map; Key : Key_Type);\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean;\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor;\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type;\n-\n-   function Floor (Container : Map; Key : Key_Type) return Cursor;\n-\n-   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n-\n    function First (Container : Map) return Cursor;\n \n-   function First_Key (Container : Map) return Key_Type;\n-\n    function First_Element (Container : Map) return Element_Type;\n \n-   function Last (Container : Map) return Cursor;\n+   function First_Key (Container : Map) return Key_Type;\n \n-   function Last_Key (Container : Map) return Key_Type;\n+   function Last (Container : Map) return Cursor;\n \n    function Last_Element (Container : Map) return Element_Type;\n \n+   function Last_Key (Container : Map) return Key_Type;\n+\n    function Next (Position : Cursor) return Cursor;\n \n    procedure Next (Position : in out Cursor);\n@@ -151,6 +145,16 @@ package Ada.Containers.Ordered_Maps is\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+\n+   function Floor (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Ceiling (Container : Map; Key : Key_Type) return Cursor;\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -202,18 +206,29 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n-   type Map_Access is access Map;\n+   type Map_Access is access all Map;\n    for Map_Access'Storage_Size use 0;\n \n    type Cursor is record\n       Container : Map_Access;\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "eb1e36562291f21c8fc0a90909f91425175a72bb", "filename": "gcc/ada/a-coormu.adb", "status": "modified", "additions": 242, "deletions": 73, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -84,6 +84,13 @@ package body Ada.Containers.Ordered_Multisets is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n+   procedure Free (X : in out Node_Access);\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access);\n+\n    procedure Insert_With_Hint\n      (Dst_Tree : in out Tree_Type;\n       Dst_Hint : Node_Access;\n@@ -115,9 +122,6 @@ package body Ada.Containers.Ordered_Multisets is\n    -- Local Instantiations --\n    --------------------------\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    package Tree_Operations is\n      new Red_Black_Trees.Generic_Operations (Tree_Types);\n \n@@ -154,18 +158,44 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element < Right.Node.Element;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Element_Type)\n       return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element < Right;\n    end \"<\";\n \n    function \"<\" (Left : Element_Type; Right : Cursor)\n       return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Element;\n    end \"<\";\n \n@@ -184,6 +214,18 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       --  L > R same as R < L\n \n       return Right.Node.Element < Left.Node.Element;\n@@ -192,12 +234,26 @@ package body Ada.Containers.Ordered_Multisets is\n    function \">\" (Left : Cursor; Right : Element_Type)\n       return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n       return Right < Left.Node.Element;\n    end \">\";\n \n    function \">\" (Left : Element_Type; Right : Cursor)\n       return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Element < Left;\n    end \">\";\n \n@@ -299,7 +355,7 @@ package body Ada.Containers.Ordered_Multisets is\n       end loop;\n    end Delete;\n \n-   procedure Delete (Container : in out Set; Position  : in out Cursor) is\n+   procedure Delete (Container : in out Set; Position : in out Cursor) is\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n@@ -309,6 +365,9 @@ package body Ada.Containers.Ordered_Multisets is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n       Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n \n@@ -371,9 +430,31 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n    ---------------------\n    -- Equivalent_Sets --\n    ---------------------\n@@ -460,6 +541,10 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.First.Element;\n    end First_Element;\n \n@@ -479,6 +564,24 @@ package body Ada.Containers.Ordered_Multisets is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      if X /= null then\n+         X.Parent := X;\n+         X.Left := X;\n+         X.Right := X;\n+\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n    ------------------\n    -- Generic_Keys --\n    ------------------\n@@ -510,34 +613,6 @@ package body Ada.Containers.Ordered_Multisets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ---------\n-      -- \"<\" --\n-      ---------\n-\n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left < Right.Node.Element;\n-      end \"<\";\n-\n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right > Left.Node.Element;\n-      end \"<\";\n-\n-      ---------\n-      -- \">\" --\n-      ---------\n-\n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right < Left.Node.Element;\n-      end \">\";\n-\n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left > Right.Node.Element;\n-      end \">\";\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -596,9 +671,28 @@ package body Ada.Containers.Ordered_Multisets is\n          Node : constant Node_Access :=\n                   Key_Keys.Find (Container.Tree, Key);\n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n          return Node.Element;\n       end Element;\n \n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n       -------------\n       -- Exclude --\n       -------------\n@@ -608,6 +702,7 @@ package body Ada.Containers.Ordered_Multisets is\n          Node : Node_Access := Key_Keys.Ceiling (Tree, Key);\n          Done : constant Node_Access := Key_Keys.Upper_Bound (Tree, Key);\n          X    : Node_Access;\n+\n       begin\n          while Node /= Done loop\n             X := Node;\n@@ -657,7 +752,7 @@ package body Ada.Containers.Ordered_Multisets is\n         (Left  : Key_Type;\n          Right : Node_Access) return Boolean is\n       begin\n-         return Left > Right.Element;\n+         return Key (Right.Element) < Left;\n       end Is_Greater_Key_Node;\n \n       ----------------------\n@@ -668,7 +763,7 @@ package body Ada.Containers.Ordered_Multisets is\n         (Left  : Key_Type;\n          Right : Node_Access) return Boolean is\n       begin\n-         return Left < Right.Element;\n+         return Left < Key (Right.Element);\n       end Is_Less_Key_Node;\n \n       -------------\n@@ -720,6 +815,13 @@ package body Ada.Containers.Ordered_Multisets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                        \"bad cursor in Key\");\n+\n          return Key (Position.Node.Element);\n       end Key;\n \n@@ -786,9 +888,12 @@ package body Ada.Containers.Ordered_Multisets is\n             raise Program_Error;\n          end if;\n \n+         pragma Assert (Vet (Container.Tree, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n          declare\n             E : Element_Type renames Position.Node.Element;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n@@ -809,11 +914,7 @@ package body Ada.Containers.Ordered_Multisets is\n             L := L - 1;\n             B := B - 1;\n \n-            if K < E\n-              or else K > E\n-            then\n-               null;\n-            else\n+            if Equivalent_Keys (Left => K, Right => Key (E)) then\n                return;\n             end if;\n          end;\n@@ -853,6 +954,24 @@ package body Ada.Containers.Ordered_Multisets is\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor)\n+   is\n+   begin\n+      Insert_Sans_Hint\n+        (Container.Tree,\n+         New_Item,\n+         Position.Node);\n+\n+      Position.Container := Container'Unrestricted_Access;\n+   end Insert;\n+\n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access)\n    is\n       function New_Node return Node_Access;\n       pragma Inline (New_Node);\n@@ -869,25 +988,23 @@ package body Ada.Containers.Ordered_Multisets is\n \n       function New_Node return Node_Access is\n          Node : constant Node_Access :=\n-                  new Node_Type'(Parent => null,\n-                                 Left   => null,\n-                                 Right  => null,\n-                                 Color  => Red,\n+                  new Node_Type'(Parent  => null,\n+                                 Left    => null,\n+                                 Right   => null,\n+                                 Color   => Red_Black_Trees.Red,\n                                  Element => New_Item);\n       begin\n          return Node;\n       end New_Node;\n \n-   --  Start of processing for Insert\n+   --  Start of processing for Insert_Sans_Hint\n \n    begin\n       Unconditional_Insert_Sans_Hint\n-        (Container.Tree,\n+        (Tree,\n          New_Item,\n-         Position.Node);\n-\n-      Position.Container := Container'Unrestricted_Access;\n-   end Insert;\n+         Node);\n+   end Insert_Sans_Hint;\n \n    ----------------------\n    -- Insert_With_Hint --\n@@ -1116,6 +1233,10 @@ package body Ada.Containers.Ordered_Multisets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.Last.Element;\n    end Last_Element;\n \n@@ -1165,6 +1286,9 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n@@ -1211,6 +1335,9 @@ package body Ada.Containers.Ordered_Multisets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n@@ -1231,29 +1358,36 @@ package body Ada.Containers.Ordered_Multisets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      S : Set renames Position.Container.all;\n-      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1294,6 +1428,14 @@ package body Ada.Containers.Ordered_Multisets is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1336,6 +1478,11 @@ package body Ada.Containers.Ordered_Multisets is\n          function New_Node return Node_Access is\n          begin\n             Node.Element := Item;\n+            Node.Color := Red_Black_Trees.Red;\n+            Node.Parent := null;\n+            Node.Left := null;\n+            Node.Right := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1354,12 +1501,10 @@ package body Ada.Containers.Ordered_Multisets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-     (Container : Set;\n+     (Container : in out Set;\n       Position  : Cursor;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n-      Tree : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n@@ -1369,7 +1514,10 @@ package body Ada.Containers.Ordered_Multisets is\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (Tree, Position.Node, By);\n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n    ---------------------\n@@ -1514,6 +1662,19 @@ package body Ada.Containers.Ordered_Multisets is\n       return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Tree     : Tree_Type;\n+      Node     : Node_Access;\n+\n+   begin\n+      Insert_Sans_Hint (Tree, New_Item, Node);\n+      return Set'(Controlled with Tree);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1564,4 +1725,12 @@ package body Ada.Containers.Ordered_Multisets is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Ordered_Multisets;"}, {"sha": "ab3d4d4d01e55c90966f8c5de108cf6f1adb4fdf", "filename": "gcc/ada/a-coormu.ads", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coormu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coormu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coormu.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -46,6 +46,8 @@ generic\n package Ada.Containers.Ordered_Multisets is\n    pragma Preelaborate;\n \n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+\n    type Set is tagged private;\n \n    type Cursor is private;\n@@ -58,6 +60,8 @@ package Ada.Containers.Ordered_Multisets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -66,18 +70,16 @@ package Ada.Containers.Ordered_Multisets is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n-   procedure Move\n-     (Target : in out Set;\n-      Source : in out Set);\n+   procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n      (Container : in out Set;\n@@ -88,6 +90,16 @@ package Ada.Containers.Ordered_Multisets is\n      (Container : in out Set;\n       New_Item  : Element_Type);\n \n+--  TODO: include Replace too???\n+--\n+--     procedure Replace\n+--       (Container : in out Set;\n+--        New_Item  : Element_Type);\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type);\n@@ -100,10 +112,6 @@ package Ada.Containers.Ordered_Multisets is\n \n    procedure Delete_Last (Container : in out Set);\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type);\n-\n    procedure Union (Target : in out Set; Source : Set);\n \n    function Union (Left, Right : Set) return Set;\n@@ -132,14 +140,6 @@ package Ada.Containers.Ordered_Multisets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Floor (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n-\n    function First (Container : Set) return Cursor;\n \n    function First_Element (Container : Set) return Element_Type;\n@@ -156,6 +156,14 @@ package Ada.Containers.Ordered_Multisets is\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -189,47 +197,37 @@ package Ada.Containers.Ordered_Multisets is\n       Process   : not null access procedure (Position : Cursor));\n \n    generic\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n-      with function \"<\" (Left : Key_Type; Right : Element_Type)\n-        return Boolean is <>;\n-\n-      with function \">\" (Left : Key_Type; Right : Element_Type)\n-        return Boolean is <>;\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n \n    package Generic_Keys is\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Floor (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n       function Key (Position : Cursor) return Key_Type;\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Delete (Container : in out Set; Key : Key_Type);\n-\n       procedure Exclude (Container : in out Set; Key : Key_Type);\n \n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n-           procedure (Element : in out Element_Type));\n+                       procedure (Element : in out Element_Type));\n \n       procedure Iterate\n         (Container : Set;\n@@ -271,6 +269,7 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -280,9 +279,19 @@ private\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "9060552302b15399cd173ae672fc66a3cb9032da", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 229, "deletions": 52, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -84,6 +84,14 @@ package body Ada.Containers.Ordered_Sets is\n    function Copy_Node (Source : Node_Access) return Node_Access;\n    pragma Inline (Copy_Node);\n \n+   procedure Free (X : in out Node_Access);\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean);\n+\n    procedure Insert_With_Hint\n      (Dst_Tree : in out Tree_Type;\n       Dst_Hint : Node_Access;\n@@ -115,9 +123,6 @@ package body Ada.Containers.Ordered_Sets is\n    -- Local Instantiations --\n    --------------------------\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    package Tree_Operations is\n      new Red_Black_Trees.Generic_Operations (Tree_Types);\n \n@@ -154,16 +159,42 @@ package body Ada.Containers.Ordered_Sets is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element < Right.Node.Element;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\"<\"\"\");\n+\n       return Left.Node.Element < Right;\n    end \"<\";\n \n    function \"<\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\"<\"\"\");\n+\n       return Left < Right.Node.Element;\n    end \"<\";\n \n@@ -182,18 +213,44 @@ package body Ada.Containers.Ordered_Sets is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       --  L > R same as R < L\n \n       return Right.Node.Element < Left.Node.Element;\n    end \">\";\n \n    function \">\" (Left : Element_Type; Right : Cursor) return Boolean is\n    begin\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Right.Container.Tree, Right.Node),\n+                     \"bad Right cursor in \"\">\"\"\");\n+\n       return Right.Node.Element < Left;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Element_Type) return Boolean is\n    begin\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Left.Container.Tree, Left.Node),\n+                     \"bad Left cursor in \"\">\"\"\");\n+\n       return Right < Left.Node.Element;\n    end \">\";\n \n@@ -287,6 +344,9 @@ package body Ada.Containers.Ordered_Sets is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Delete\");\n+\n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n       Position.Container := null;\n@@ -356,6 +416,13 @@ package body Ada.Containers.Ordered_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Element\");\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -455,6 +522,10 @@ package body Ada.Containers.Ordered_Sets is\n \n    function First_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.First.Element;\n    end First_Element;\n \n@@ -474,6 +545,24 @@ package body Ada.Containers.Ordered_Sets is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end Floor;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      if X /= null then\n+         X.Parent := X;\n+         X.Left := X;\n+         X.Right := X;\n+\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n    ------------------\n    -- Generic_Keys --\n    ------------------\n@@ -550,13 +639,15 @@ package body Ada.Containers.Ordered_Sets is\n       -- Element --\n       -------------\n \n-      function Element\n-        (Container : Set;\n-         Key       : Key_Type) return Element_Type\n-      is\n-         Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n+      function Element (Container : Set; Key : Key_Type) return Element_Type is\n+         Node : constant Node_Access :=\n+                  Key_Keys.Find (Container.Tree, Key);\n \n       begin\n+         if Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n          return Node.Element;\n       end Element;\n \n@@ -649,6 +740,13 @@ package body Ada.Containers.Ordered_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                        \"bad cursor in Key\");\n+\n          return Key (Position.Node.Element);\n       end Key;\n \n@@ -691,6 +789,9 @@ package body Ada.Containers.Ordered_Sets is\n             raise Program_Error;\n          end if;\n \n+         pragma Assert (Vet (Container.Tree, Position.Node),\n+                        \"bad cursor in Update_Element_Preserving_Key\");\n+\n          declare\n             E : Element_Type renames Position.Node.Element;\n             K : constant Key_Type := Key (E);\n@@ -770,32 +871,6 @@ package body Ada.Containers.Ordered_Sets is\n       Position  : out Cursor;\n       Inserted  : out Boolean)\n    is\n-      function New_Node return Node_Access;\n-      pragma Inline (New_Node);\n-\n-      procedure Insert_Post is\n-        new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-      procedure Insert_Sans_Hint is\n-        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n-         Node : constant Node_Access :=\n-                  new Node_Type'(Parent => null,\n-                                 Left   => null,\n-                                 Right  => null,\n-                                 Color  => Red,\n-                                 Element => New_Item);\n-      begin\n-         return Node;\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n    begin\n       Insert_Sans_Hint\n         (Container.Tree,\n@@ -821,6 +896,48 @@ package body Ada.Containers.Ordered_Sets is\n       end if;\n    end Insert;\n \n+   ----------------------\n+   -- Insert_Sans_Hint --\n+   ----------------------\n+\n+   procedure Insert_Sans_Hint\n+     (Tree     : in out Tree_Type;\n+      New_Item : Element_Type;\n+      Node     : out Node_Access;\n+      Inserted : out Boolean)\n+   is\n+      function New_Node return Node_Access;\n+      pragma Inline (New_Node);\n+\n+      procedure Insert_Post is\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n+\n+      procedure Conditional_Insert_Sans_Hint is\n+        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Node_Access is\n+      begin\n+         return new Node_Type'(Parent  => null,\n+                               Left    => null,\n+                               Right   => null,\n+                               Color   => Red_Black_Trees.Red,\n+                               Element => New_Item);\n+      end New_Node;\n+\n+   --  Start of processing for Insert_Sans_Hint\n+\n+   begin\n+      Conditional_Insert_Sans_Hint\n+        (Tree,\n+         New_Item,\n+         Node,\n+         Inserted);\n+   end Insert_Sans_Hint;\n+\n    ----------------------\n    -- Insert_With_Hint --\n    ----------------------\n@@ -1012,6 +1129,10 @@ package body Ada.Containers.Ordered_Sets is\n \n    function Last_Element (Container : Set) return Element_Type is\n    begin\n+      if Container.Tree.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Tree.Last.Element;\n    end Last_Element;\n \n@@ -1055,6 +1176,9 @@ package body Ada.Containers.Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Next\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n@@ -1101,6 +1225,9 @@ package body Ada.Containers.Ordered_Sets is\n          return No_Element;\n       end if;\n \n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Previous\");\n+\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n@@ -1127,29 +1254,36 @@ package body Ada.Containers.Ordered_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      S : Set renames Position.Container.all;\n-      T : Tree_Type renames S.Tree'Unrestricted_Access.all;\n+      pragma Assert (Vet (Position.Container.Tree, Position.Node),\n+                     \"bad cursor in Query_Element\");\n \n-      B : Natural renames T.Busy;\n-      L : Natural renames T.Lock;\n+      declare\n+         T : Tree_Type renames Position.Container.Tree;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames T.Busy;\n+         L : Natural renames T.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1192,6 +1326,14 @@ package body Ada.Containers.Ordered_Sets is\n       Read (Stream, Container.Tree);\n    end Read;\n \n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Read;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -1254,6 +1396,11 @@ package body Ada.Containers.Ordered_Sets is\n          function New_Node return Node_Access is\n          begin\n             Node.Element := Item;\n+            Node.Color := Red;\n+            Node.Parent := null;\n+            Node.Right := null;\n+            Node.Left := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1294,6 +1441,11 @@ package body Ada.Containers.Ordered_Sets is\n \n          function New_Node return Node_Access is\n          begin\n+            Node.Color := Red;\n+            Node.Parent := null;\n+            Node.Right := null;\n+            Node.Left := null;\n+\n             return Node;\n          end New_Node;\n \n@@ -1330,6 +1482,9 @@ package body Ada.Containers.Ordered_Sets is\n          raise Program_Error;\n       end if;\n \n+      pragma Assert (Vet (Container.Tree, Position.Node),\n+                     \"bad cursor in Replace_Element\");\n+\n       Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n@@ -1436,6 +1591,20 @@ package body Ada.Containers.Ordered_Sets is\n       return Set'(Controlled with Tree);\n    end Symmetric_Difference;\n \n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      Tree     : Tree_Type;\n+      Node     : Node_Access;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert_Sans_Hint (Tree, New_Item, Node, Inserted);\n+      return Set'(Controlled with Tree);\n+   end To_Set;\n+\n    -----------\n    -- Union --\n    -----------\n@@ -1486,4 +1655,12 @@ package body Ada.Containers.Ordered_Sets is\n       Write (Stream, Container.Tree);\n    end Write;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error;\n+   end Write;\n+\n end Ada.Containers.Ordered_Sets;"}, {"sha": "8afbd01e96fd875deb85389ae2339c6e29ec40d9", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,6 +60,8 @@ package Ada.Containers.Ordered_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function To_Set (New_Item : Element_Type) return Set;\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -255,6 +257,7 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n+   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -264,9 +267,19 @@ private\n       Node      : Node_Access;\n    end record;\n \n-   No_Element : constant Cursor := Cursor'(null, null);\n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n \n-   use Ada.Streams;\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n      (Stream    : access Root_Stream_Type'Class;"}, {"sha": "4720f8cbb48079f7f05b3c7d54b7dfd4b360681b", "filename": "gcc/ada/a-crbtgo.adb", "status": "modified", "additions": 204, "deletions": 104, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-crbtgo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-crbtgo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.adb?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -49,91 +49,91 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n    procedure Left_Rotate  (Tree : in out Tree_Type; X : Node_Access);\n    procedure Right_Rotate (Tree : in out Tree_Type; Y : Node_Access);\n \n-   ---------------------\n-   -- Check_Invariant --\n-   ---------------------\n-\n-   procedure Check_Invariant (Tree : Tree_Type) is\n-      Root : constant Node_Access := Tree.Root;\n-\n-      function Check (Node : Node_Access) return Natural;\n-\n-      -----------\n-      -- Check --\n-      -----------\n-\n-      function Check (Node : Node_Access) return Natural is\n-      begin\n-         if Node = null then\n-            return 0;\n-         end if;\n-\n-         if Color (Node) = Red then\n-            declare\n-               L : constant Node_Access := Left (Node);\n-            begin\n-               pragma Assert (L = null or else Color (L) = Black);\n-               null;\n-            end;\n-\n-            declare\n-               R : constant Node_Access := Right (Node);\n-            begin\n-               pragma Assert (R = null or else Color (R) = Black);\n-               null;\n-            end;\n-\n-            declare\n-               NL : constant Natural := Check (Left (Node));\n-               NR : constant Natural := Check (Right (Node));\n-            begin\n-               pragma Assert (NL = NR);\n-               return NL;\n-            end;\n-         end if;\n-\n-         declare\n-            NL : constant Natural := Check (Left (Node));\n-            NR : constant Natural := Check (Right (Node));\n-         begin\n-            pragma Assert (NL = NR);\n-            return NL + 1;\n-         end;\n-      end Check;\n-\n-   --  Start of processing for Check_Invariant\n-\n-   begin\n-      if Root = null then\n-         pragma Assert (Tree.First = null);\n-         pragma Assert (Tree.Last = null);\n-         pragma Assert (Tree.Length = 0);\n-         null;\n-\n-      else\n-         pragma Assert (Color (Root) = Black);\n-         pragma Assert (Tree.Length > 0);\n-         pragma Assert (Tree.Root /= null);\n-         pragma Assert (Tree.First /= null);\n-         pragma Assert (Tree.Last /= null);\n-         pragma Assert (Parent (Tree.Root) = null);\n-         pragma Assert ((Tree.Length > 1)\n-                           or else (Tree.First = Tree.Last\n-                                      and Tree.First = Tree.Root));\n-         pragma Assert (Left (Tree.First) = null);\n-         pragma Assert (Right (Tree.Last) = null);\n-\n-         declare\n-            L  : constant Node_Access := Left (Root);\n-            R  : constant Node_Access := Right (Root);\n-            NL : constant Natural := Check (L);\n-            NR : constant Natural := Check (R);\n-         begin\n-            pragma Assert (NL = NR);\n-            null;\n-         end;\n-      end if;\n-   end Check_Invariant;\n+--     ---------------------\n+--     -- Check_Invariant --\n+--     ---------------------\n+\n+--     procedure Check_Invariant (Tree : Tree_Type) is\n+--        Root : constant Node_Access := Tree.Root;\n+--\n+--        function Check (Node : Node_Access) return Natural;\n+--\n+--        -----------\n+--        -- Check --\n+--        -----------\n+--\n+--        function Check (Node : Node_Access) return Natural is\n+--        begin\n+--           if Node = null then\n+--              return 0;\n+--           end if;\n+--\n+--           if Color (Node) = Red then\n+--              declare\n+--                 L : constant Node_Access := Left (Node);\n+--              begin\n+--                 pragma Assert (L = null or else Color (L) = Black);\n+--                 null;\n+--              end;\n+--\n+--              declare\n+--                 R : constant Node_Access := Right (Node);\n+--              begin\n+--                 pragma Assert (R = null or else Color (R) = Black);\n+--                 null;\n+--              end;\n+--\n+--              declare\n+--                 NL : constant Natural := Check (Left (Node));\n+--                 NR : constant Natural := Check (Right (Node));\n+--              begin\n+--                 pragma Assert (NL = NR);\n+--                 return NL;\n+--              end;\n+--           end if;\n+--\n+--           declare\n+--              NL : constant Natural := Check (Left (Node));\n+--              NR : constant Natural := Check (Right (Node));\n+--           begin\n+--              pragma Assert (NL = NR);\n+--              return NL + 1;\n+--           end;\n+--        end Check;\n+--\n+--     --  Start of processing for Check_Invariant\n+--\n+--     begin\n+--        if Root = null then\n+--           pragma Assert (Tree.First = null);\n+--           pragma Assert (Tree.Last = null);\n+--           pragma Assert (Tree.Length = 0);\n+--           null;\n+--\n+--        else\n+--           pragma Assert (Color (Root) = Black);\n+--           pragma Assert (Tree.Length > 0);\n+--           pragma Assert (Tree.Root /= null);\n+--           pragma Assert (Tree.First /= null);\n+--           pragma Assert (Tree.Last /= null);\n+--           pragma Assert (Parent (Tree.Root) = null);\n+--           pragma Assert ((Tree.Length > 1)\n+--                             or else (Tree.First = Tree.Last\n+--                                        and Tree.First = Tree.Root));\n+--           pragma Assert (Left (Tree.First) = null);\n+--           pragma Assert (Right (Tree.Last) = null);\n+--\n+--           declare\n+--              L  : constant Node_Access := Left (Root);\n+--              R  : constant Node_Access := Right (Root);\n+--              NL : constant Natural := Check (L);\n+--              NR : constant Natural := Check (R);\n+--           begin\n+--              pragma Assert (NL = NR);\n+--              null;\n+--           end;\n+--        end if;\n+--     end Check_Invariant;\n \n    ------------------\n    -- Delete_Fixup --\n@@ -249,22 +249,22 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Tree.Length > 0);\n-      pragma Assert (Tree.Root /= null);\n-      pragma Assert (Tree.First /= null);\n-      pragma Assert (Tree.Last /= null);\n-      pragma Assert (Parent (Tree.Root) = null);\n-      pragma Assert ((Tree.Length > 1)\n-                        or else (Tree.First = Tree.Last\n-                                   and then Tree.First = Tree.Root));\n-      pragma Assert ((Left (Node) = null)\n-                        or else (Parent (Left (Node)) = Node));\n-      pragma Assert ((Right (Node) = null)\n-                        or else (Parent (Right (Node)) = Node));\n-      pragma Assert (((Parent (Node) = null) and then (Tree.Root = Node))\n-                        or else ((Parent (Node) /= null) and then\n-                                  ((Left (Parent (Node)) = Node)\n-                                     or else (Right (Parent (Node)) = Node))));\n+--    pragma Assert (Tree.Length > 0);\n+--    pragma Assert (Tree.Root /= null);\n+--    pragma Assert (Tree.First /= null);\n+--    pragma Assert (Tree.Last /= null);\n+--    pragma Assert (Parent (Tree.Root) = null);\n+--    pragma Assert ((Tree.Length > 1)\n+--                      or else (Tree.First = Tree.Last\n+--                                 and then Tree.First = Tree.Root));\n+--    pragma Assert ((Left (Node) = null)\n+--                      or else (Parent (Left (Node)) = Node));\n+--    pragma Assert ((Right (Node) = null)\n+--                      or else (Parent (Right (Node)) = Node));\n+--    pragma Assert (((Parent (Node) = null) and then (Tree.Root = Node))\n+--                      or else ((Parent (Node) /= null) and then\n+--                                ((Left (Parent (Node)) = Node)\n+--                                   or else (Right (Parent (Node)) = Node))));\n \n       if Left (Z) = null then\n          if Right (Z) = null then\n@@ -545,7 +545,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       P, X        : Node_Access;\n \n    begin\n-\n       if Right (Source_Root) /= null then\n          Set_Right\n            (Node  => Target_Root,\n@@ -586,7 +585,6 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       when others =>\n          Delete_Tree (Target_Root);\n          raise;\n-\n    end Generic_Copy_Tree;\n \n    -------------------------\n@@ -1049,4 +1047,106 @@ package body Ada.Containers.Red_Black_Trees.Generic_Operations is\n       Set_Parent (Y, X);\n    end Right_Rotate;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Tree : Tree_Type; Node : Node_Access) return Boolean is\n+   begin\n+      if Node = null then\n+         return True;\n+      end if;\n+\n+      if Parent (Node) = Node\n+        or else Left (Node) = Node\n+        or else Right (Node) = Node\n+      then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 0\n+        or else Tree.Root = null\n+        or else Tree.First = null\n+        or else Tree.Last = null\n+      then\n+         return False;\n+      end if;\n+\n+      if Parent (Tree.Root) /= null then\n+         return False;\n+      end if;\n+\n+      if Left (Tree.First) /= null then\n+         return False;\n+      end if;\n+\n+      if Right (Tree.Last) /= null then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 1 then\n+         if Tree.First /= Tree.Last\n+           or else Tree.First /= Tree.Root\n+         then\n+            return False;\n+         end if;\n+\n+         if Node /= Tree.First then\n+            return False;\n+         end if;\n+\n+         if Parent (Node) /= null\n+           or else Left (Node) /= null\n+           or else Right (Node) /= null\n+         then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end if;\n+\n+      if Tree.First = Tree.Last then\n+         return False;\n+      end if;\n+\n+      if Tree.Length = 2 then\n+         if Tree.First /= Tree.Root\n+           and then Tree.Last /= Tree.Root\n+         then\n+            return False;\n+         end if;\n+\n+         if Tree.First /= Node\n+           and then Tree.Last /= Node\n+         then\n+            return False;\n+         end if;\n+      end if;\n+\n+      if Left (Node) /= null\n+        and then Parent (Left (Node)) /= Node\n+      then\n+         return False;\n+      end if;\n+\n+      if Right (Node) /= null\n+        and then Parent (Right (Node)) /= Node\n+      then\n+         return False;\n+      end if;\n+\n+      if Parent (Node) = null then\n+         if Tree.Root /= Node then\n+            return False;\n+         end if;\n+\n+      elsif Left (Parent (Node)) /= Node\n+        and then Right (Parent (Node)) /= Node\n+      then\n+         return False;\n+      end if;\n+\n+      return True;\n+   end Vet;\n+\n end Ada.Containers.Red_Black_Trees.Generic_Operations;"}, {"sha": "a213a28301037f9b9a7b290a2a39f27a7f3fb999", "filename": "gcc/ada/a-crbtgo.ads", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-crbtgo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368f04ec19f5d2aa5439e2454217d3135603dd0/gcc%2Fada%2Fa-crbtgo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-crbtgo.ads?ref=2368f04ec19f5d2aa5439e2454217d3135603dd0", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -56,7 +56,14 @@ package Ada.Containers.Red_Black_Trees.Generic_Operations is\n \n    function Max (Node : Node_Access) return Node_Access;\n \n-   procedure Check_Invariant (Tree : Tree_Type);\n+   --  NOTE: The Check_Invariant operation was used during early\n+   --  development of the red-black tree. Now that the tree type\n+   --  implementation has matured, we don't really need Check_Invariant\n+   --  anymore.\n+\n+   --  procedure Check_Invariant (Tree : Tree_Type);\n+\n+   function Vet (Tree : Tree_Type; Node : Node_Access) return Boolean;\n \n    function Next (Node : Node_Access) return Node_Access;\n "}]}