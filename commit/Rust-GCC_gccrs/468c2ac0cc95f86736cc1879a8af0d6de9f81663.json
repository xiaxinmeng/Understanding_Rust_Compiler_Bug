{"sha": "468c2ac0cc95f86736cc1879a8af0d6de9f81663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4YzJhYzBjYzk1Zjg2NzM2Y2MxODc5YThhZjBkNmRlOWY4MTY2Mw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-08-19T12:02:48Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-08-19T12:02:48Z"}, "message": "tree-data-refs.c (split_constant_offset): Expose.\n\n        * tree-data-refs.c (split_constant_offset): Expose.\n        * tree-data-refs.h (split_constant_offset): Add declaration.\n\n        * tree-vectorizer.h (dr_alignment_support): Renamed\n        dr_unaligned_software_pipeline to dr_explicit_realign_optimized.\n        Added a new value dr_explicit_realign.\n        (_stmt_vec_info): Added new fields: dr_base_address, dr_init,\n        dr_offset, dr_step, and dr_aligned_to, along with new access\n        functions for these fields: STMT_VINFO_DR_BASE_ADDRESS,\n        STMT_VINFO_DR_INIT, STMT_VINFO_DR_OFFSET, STMT_VINFO_DR_STEP, and\n        STMT_VINFO_DR_ALIGNED_TO.\n\n        * tree-vectorizer.c (vect_supportable_dr_alignment): Add\n        documentation.\n        In case of outer-loop vectorization with non-fixed misalignment - use\n        the dr_explicit_realign scheme instead of the optimized realignment\n        scheme.\n        (new_stmt_vec_info): Initialize new fields.\n\n        * tree-vect-analyze.c (vect_compute_data_ref_alignment): Handle the\n        'nested_in_vect_loop' case. Change verbosity level.\n        (vect_analyze_data_ref_access): Handle the 'nested_in_vect_loop' case.\n        Don't fail on zero step in the outer-loop for loads.\n        (vect_analyze_data_refs): Call split_constant_offset to calculate base,\n        offset and init relative to the outer-loop.\n\n        * tree-vect-transform.c (vect_create_data_ref_ptr): Replace the unused\n        BSI function argument with a new function argument - at_loop.\n        Simplify the condition that determines STEP. Takes additional argument\n        INV_P. Support outer-loop vectorization (handle the nested_in_vect_loop\n        case), including zero step in the outer-loop. Call\n        vect_create_addr_base_for_vector_ref with additional argument.\n        (vect_create_addr_base_for_vector_ref): Takes additional argument LOOP.\n        Updated function documentation. Handle the 'nested_in_vect_loop' case.\n        Fixed and simplified calculation of step.\n        (vectorizable_store): Call vect_create_data_ref_ptr with loop instead\n        of bsi, and with additional argument. Call bump_vector_ptr with\n        additional argument. Fix typos. Handle the 'nested_in_vect_loop' case.\n        (vect_setup_realignment): Takes additional arguments INIT_ADDR and\n        DR_ALIGNMENT_SUPPORT. Returns another value AT_LOOP. Handle the case\n        when the realignment setup needs to take place inside the loop.  Support\n        the dr_explicit_realign scheme. Allow generating the optimized\n        realignment scheme for outer-loop vectorization. Added documentation.\n        (vectorizable_load): Support the dr_explicit_realign scheme. Handle the\n        'nested_in_vect_loop' case, including loads that are invariant in the\n        outer-loop and the realignment schemes. Handle the case when the\n        realignment setup needs to take place inside the loop. Call\n        vect_setup_realignment with additional arguments.  Call\n        vect_create_data_ref_ptr with additional argument and with loop instead\n        of bsi. Fix 80-column overflow. Fix typos. Rename PHI_STMT to PHI.\n        (vect_gen_niters_for_prolog_loop): Call\n        vect_create_addr_base_for_vector_ref with additional arguments.\n        (vect_create_cond_for_align_checks): Likewise.\n        (bump_vector_ptr): Updated to support the new dr_explicit_realign\n        scheme: takes additional argument bump; argument ptr_incr is now\n        optional; updated documentation.\n        (vect_init_vector): Takes additional argument (bsi). Use it, if\n        available, to insert the vector initialization.\n        (get_initial_def_for_induction): Pass additional argument in call to\n        vect_init_vector.\n        (vect_get_vec_def_for_operand): Likewise.\n        (vect_setup_realignment): Likewise.\n        (vectorizable_load): Likewise.\n\nFrom-SVN: r127624", "tree": {"sha": "25bb935b47a86dcee54460eecb1a8c69809ec5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25bb935b47a86dcee54460eecb1a8c69809ec5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/468c2ac0cc95f86736cc1879a8af0d6de9f81663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468c2ac0cc95f86736cc1879a8af0d6de9f81663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468c2ac0cc95f86736cc1879a8af0d6de9f81663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468c2ac0cc95f86736cc1879a8af0d6de9f81663/comments", "author": null, "committer": null, "parents": [{"sha": "d29de1bf2836e4f06f32f7271192d7f92ba9235c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29de1bf2836e4f06f32f7271192d7f92ba9235c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29de1bf2836e4f06f32f7271192d7f92ba9235c"}], "stats": {"total": 2711, "additions": 2499, "deletions": 212}, "files": [{"sha": "057037b6d5e6ae3e226566c99d8a873ca423817d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -1,3 +1,69 @@\n+2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-data-refs.c (split_constant_offset): Expose.\n+\t* tree-data-refs.h (split_constant_offset): Add declaration.\n+\n+\t* tree-vectorizer.h (dr_alignment_support): Renamed\n+\tdr_unaligned_software_pipeline to dr_explicit_realign_optimized.\n+\tAdded a new value dr_explicit_realign.\n+\t(_stmt_vec_info): Added new fields: dr_base_address, dr_init,\n+\tdr_offset, dr_step, and dr_aligned_to, along with new access\n+\tfunctions for these fields: STMT_VINFO_DR_BASE_ADDRESS,\n+\tSTMT_VINFO_DR_INIT, STMT_VINFO_DR_OFFSET, STMT_VINFO_DR_STEP, and\n+\tSTMT_VINFO_DR_ALIGNED_TO.\n+\n+\t* tree-vectorizer.c (vect_supportable_dr_alignment): Add\n+\tdocumentation.\n+\tIn case of outer-loop vectorization with non-fixed misalignment - use\n+\tthe dr_explicit_realign scheme instead of the optimized realignment\n+\tscheme.\n+\t(new_stmt_vec_info): Initialize new fields.\n+\n+\t* tree-vect-analyze.c (vect_compute_data_ref_alignment): Handle the\n+\t'nested_in_vect_loop' case. Change verbosity level.\n+\t(vect_analyze_data_ref_access): Handle the 'nested_in_vect_loop' case.\n+\tDon't fail on zero step in the outer-loop for loads.\n+\t(vect_analyze_data_refs): Call split_constant_offset to calculate base,\n+\toffset and init relative to the outer-loop.\n+\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Replace the unused\n+\tBSI function argument with a new function argument - at_loop.\n+\tSimplify the condition that determines STEP. Takes additional argument\n+\tINV_P. Support outer-loop vectorization (handle the nested_in_vect_loop\n+\tcase), including zero step in the outer-loop. Call\n+\tvect_create_addr_base_for_vector_ref with additional argument.\n+\t(vect_create_addr_base_for_vector_ref): Takes additional argument LOOP.\n+\tUpdated function documentation. Handle the 'nested_in_vect_loop' case.\n+\tFixed and simplified calculation of step.\n+\t(vectorizable_store): Call vect_create_data_ref_ptr with loop instead\n+\tof bsi, and with additional argument. Call bump_vector_ptr with\n+\tadditional argument. Fix typos. Handle the 'nested_in_vect_loop' case.\n+\t(vect_setup_realignment): Takes additional arguments INIT_ADDR and\n+\tDR_ALIGNMENT_SUPPORT. Returns another value AT_LOOP. Handle the case\n+\twhen the realignment setup needs to take place inside the loop.  Support\n+\tthe dr_explicit_realign scheme. Allow generating the optimized\n+\trealignment scheme for outer-loop vectorization. Added documentation.\n+\t(vectorizable_load): Support the dr_explicit_realign scheme. Handle the\n+\t'nested_in_vect_loop' case, including loads that are invariant in the\n+\touter-loop and the realignment schemes. Handle the case when the\n+\trealignment setup needs to take place inside the loop. Call\n+\tvect_setup_realignment with additional arguments.  Call\n+\tvect_create_data_ref_ptr with additional argument and with loop instead\n+\tof bsi. Fix 80-column overflow. Fix typos. Rename PHI_STMT to PHI.\n+\t(vect_gen_niters_for_prolog_loop): Call\n+\tvect_create_addr_base_for_vector_ref with additional arguments.\n+\t(vect_create_cond_for_align_checks): Likewise.\n+\t(bump_vector_ptr): Updated to support the new dr_explicit_realign\n+\tscheme: takes additional argument bump; argument ptr_incr is now\n+\toptional; updated documentation.\n+\t(vect_init_vector): Takes additional argument (bsi). Use it, if\n+\tavailable, to insert the vector initialization.\n+\t(get_initial_def_for_induction): Pass additional argument in call to\n+\tvect_init_vector.\n+\t(vect_get_vec_def_for_operand): Likewise.\n+\t(vect_setup_realignment): Likewise.\n+\t(vectorizable_load): Likewise.\n+\n 2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.h (vect_is_simple_reduction): Takes a loop_vec_info"}, {"sha": "0ef6f864005527b5665ffc753f17c4cb121507b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -1,3 +1,38 @@\n+2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-117.c: Change inner-loop bound to\n+\tunknown (so that outer-loop wont get analyzed).\n+\t* gcc.dg/vect/vect-outer-1a.c: New test.\n+\t* gcc.dg/vect/vect-outer-1b.c: New test.\n+\t* gcc.dg/vect/vect-outer-1.c: New test.\n+\t* gcc.dg/vect/vect-outer-2a.c: New test.\n+\t* gcc.dg/vect/vect-outer-2b.c: New test.\n+\t* gcc.dg/vect/vect-outer-2c.c: New test.\n+\t* gcc.dg/vect/vect-outer-2.c: New test.\n+\t* gcc.dg/vect/vect-outer-3a.c: New test.\n+\t* gcc.dg/vect/vect-outer-3b.c: New test.\n+\t* gcc.dg/vect/vect-outer-3c.c: New test.\n+\t* gcc.dg/vect/vect-outer-3.c: New test.\n+\t* gcc.dg/vect/vect-outer-4a.c: New test.\n+\t* gcc.dg/vect/vect-outer-4b.c: New test.\n+\t* gcc.dg/vect/vect-outer-4c.c: New test.\n+\t* gcc.dg/vect/vect-outer-4d.c: New test.\n+\t* gcc.dg/vect/vect-outer-4e.c: New test.\n+\t* gcc.dg/vect/vect-outer-4f.c: New test.\n+\t* gcc.dg/vect/vect-outer-4g.c: New test.\n+\t* gcc.dg/vect/no-section-anchors-vect-outer-4h.c: New test.\n+\t* gcc.dg/vect/vect-outer-4i.c: New test.\n+\t* gcc.dg/vect/vect-outer-4j.c: New test.\n+\t* gcc.dg/vect/vect-outer-4k.c: New test.\n+\t* gcc.dg/vect/vect-outer-4l.c: New test.\n+\t* gcc.dg/vect/vect-outer-4m.c: New test.\n+\t* gcc.dg/vect/vect-outer-4.c: New test.\n+\t* gcc.dg/vect/vect-outer-5.c: New test.\n+\t* gcc.dg/vect/vect-outer-6.c: New test.\n+\t* gcc.dg/vect/vect-outer-fir.c: New test.\n+\t* gcc.dg/vect/vect-outer-fir-lb.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c: New test.\t\n+\n 2007-08-19  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect/vect.exp: Compile tests with -fno-tree-scev-cprop"}, {"sha": "97163e6c46baf0aa62b05c746300ae0a4af0b4ab", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-outer-fir.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-outer-fir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-outer-fir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-outer-fir.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+float in[N+M];\n+float coeff[M];\n+float out[N];\n+float fir_out[N];\n+\n+/* Should be vectorized. Fixed misaligment in the inner-loop.  */\n+/* Currently not vectorized because we get too many BBs in the inner-loop,\n+   because the compiler doesn't realize that the inner-loop executes at\n+   least once (cause k<4), and so there's no need to create a guard code\n+   to skip the inner-loop in case it doesn't execute.  */\n+void foo (){\n+ int i,j,k;\n+ float diff;\n+\n+ for (i = 0; i < N; i++) {\n+  out[i] = 0;\n+ }\n+\n+ for (k = 0; k < 4; k++) {\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = k; j < M; j+=4) {\n+      diff += in[j+i]*coeff[j];\n+    }\n+    out[i] += diff;\n+  }\n+ }\n+\n+/* Vectorized. Changing misalignment in the inner-loop.  */\n+void fir (){\n+  int i,j,k;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j++) {\n+      diff += in[j+i]*coeff[j];\n+    }\n+    fir_out[i] = diff;\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < M; i++)\n+    coeff[i] = i;\n+  for (i = 0; i < N+M; i++)\n+    in[i] = i;\n+\n+  foo ();\n+  fir ();\n+\n+  for (i = 0; i < N; i++) {\n+    if (out[i] != fir_out[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ab923814d32a94a59b39baa0d5ae9a808415c0f0", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-outer-4h.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-outer-4h.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-outer-4h.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-outer-4h.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+\n+#define N 40\n+#define M 128\n+unsigned short a[M][N];\n+unsigned int out[N];\n+\n+/* Outer-loop vectorization. */\n+\n+void\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < M; j++) {\n+      a[j][i] = 4;\n+    }\n+    out[i]=5;\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  check_vect ();\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < M; j++) {\n+      if (a[j][i] != 4)\n+        abort ();\n+    }\n+    if (out[i] != 5)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2180e22ac7c31584ea49851673fdc5773c3a96fe", "filename": "gcc/testsuite/gcc.dg/vect/vect-117.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-117.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -20,15 +20,15 @@ static  int c[N][N] = {{ 1, 2, 3, 4, 5},\n \n volatile int foo;\n \n-int main1 (int A[N][N]) \n+int main1 (int A[N][N], int n) \n {\n \n   int i,j;\n \n   /* vectorizable */\n   for (i = 1; i < N; i++)\n   {\n-    for (j = 0; j < N; j++)\n+    for (j = 0; j < n; j++)\n     {\n       A[i][j] = A[i-1][j] + A[i][j];\n     }\n@@ -42,7 +42,7 @@ int main (void)\n   int i,j;\n \n   foo = 0;\n-  main1 (a);\n+  main1 (a, N);\n \n   /* check results: */\n "}, {"sha": "79a2ba41a360c5fe9c2f718531501e57c6d38712", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+signed short image[N][N] __attribute__ ((__aligned__(16)));\n+signed short block[N][N] __attribute__ ((__aligned__(16)));\n+signed short out[N] __attribute__ ((__aligned__(16)));\n+\n+/* Can't do outer-loop vectorization because of non-consecutive access. */\n+\n+void\n+foo (){\n+  int i,j;\n+  int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j+=8) {\n+      diff += (image[i][j] - block[i][j]);\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2d6eb06d0c88f0561c21fd5d1af4c09fbce76db9", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-1a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1a.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+signed short image[N][N] __attribute__ ((__aligned__(16)));\n+signed short block[N][N] __attribute__ ((__aligned__(16)));\n+\n+/* Can't do outer-loop vectorization because of non-consecutive access.\n+   Currently fails to vectorize because the reduction pattern is not\n+   recognized.  */\n+\n+int\n+foo (){\n+  int i,j;\n+  int diff = 0;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j+=8) {\n+      diff += (image[i][j] - block[i][j]);\n+    }\n+  }\n+  return diff;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* FORNOW */\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"unexpected pattern\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e093d0ea3653dc20ec2d372e71d217f3b250f367", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-1b.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-1b.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+signed short image[N][N];\n+signed short block[N][N];\n+signed short out[N];\n+\n+/* Outer-loop cannot get vectorized because of non-consecutive access.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j+=4) {\n+      diff += (image[i][j] - block[i][j]);\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "caf38d7ef61d7b1c19ee07bc113405606aaa46a1", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N] __attribute__ ((__aligned__(16)));\n+float out[N];\n+\n+/* Outer-loop vectorization.  */\n+\n+void\n+foo (){\n+  int i,j;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[j][i] = j+i;\n+    }\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      if (image[j][i] != j+i)\n+\tabort ();\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4925c0826ce8671851652da38ba804d97476e0c9", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-2a.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2a.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N][N] __attribute__ ((__aligned__(16)));\n+\n+void\n+foo (){\n+  int i,j,k;\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[k][j][i] = j+i+k;\n+    }\n+  }\n+ }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j, k;\n+\n+  foo ();\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      if (image[k][j][i] != j+i+k)\n+\tabort ();\n+    }\n+  }\n+ }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "65c64fc7524647d61586462c7b1b3f80f0599a86", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-2b.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2b.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[2*N][N][N] __attribute__ ((__aligned__(16)));\n+\n+void\n+foo (){\n+  int i,j,k;\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[k+i][j][i] = j+i+k;\n+    }\n+  }\n+ }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j, k;\n+\n+  foo ();\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      if (image[k+i][j][i] != j+i+k)\n+\tabort ();\n+    }\n+  }\n+ }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c7242590667d91152a791b782cb1f3c6127887b4", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-2c.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2c.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[2*N][2*N][N] __attribute__ ((__aligned__(16)));\n+\n+void\n+foo (){\n+  int i,j,k;\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j+=2) {\n+      image[k][j][i] = j+i+k;\n+    }\n+  }\n+ }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j, k;\n+\n+  foo ();\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j+=2) {\n+      if (image[k][j][i] != j+i+k)\n+\tabort ();\n+    }\n+  }\n+ }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f6f9c359096dbcaf4b073fa827d2be91f24a2a2e", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-2d.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-2d.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N][N+1] __attribute__ ((__aligned__(16)));\n+\n+void\n+foo (){\n+  int i,j,k;\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < i+1; j++) {\n+      image[k][j][i] = j+i+k;\n+    }\n+  }\n+ }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j, k;\n+\n+  foo ();\n+\n+ for (k=0; k<N; k++) {\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < i+1; j++) {\n+      if (image[k][j][i] != j+i+k)\n+       abort ();\n+    }\n+  }\n+ }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6f41b826e4ed7865f2e4950c5ca9518fb862c384", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N] __attribute__ ((__aligned__(16)));\n+float out[N];\n+\n+/* Outer-loop vectoriation.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[i][j]=i+j;\n+    }\n+  }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][i];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a5fd23df51ec97d7759ccc239b3d571d75620d61", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3a.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N+1] __attribute__ ((__aligned__(16)));\n+float out[N];\n+\n+/* Outer-loop vectorization with misaliged accesses in the inner-loop.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[i][j]=i+j;\n+    }\n+  }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][i];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "67edb6032458f2338d027eb30b299ef825e16f66", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3b.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3b.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N] __attribute__ ((__aligned__(16)));\n+float out[N];\n+\n+/* Outer-loop vectorization with non-consecutive access. Not vectorized yet.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N/2; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][2*i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[i][j]=i+j;\n+    }\n+  }\n+\n+  foo ();\n+\n+  for (i = 0; i < N/2; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j++) {\n+      diff += image[j][2*i];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"strided access in outer loop\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1e28777c165c0ceeedbe7883423094a0b136b4a3", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3c.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3c.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_float } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+float image[N][N+1] __attribute__ ((__aligned__(16)));\n+float out[N];\n+\n+/* Outer-loop vectorization.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j+=4) {\n+      diff += image[j][i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    for (j = 0; j < N; j++) {\n+      image[i][j]=i+j;\n+    }\n+  }\n+\n+  foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < N; j+=4) {\n+      diff += image[j][i];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3b8f911cb73931ef6b7e57afc2a2e1b9f5bfb30e", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+float in[N+M];\n+float coeff[M];\n+float out[N];\n+\n+/* Outer-loop vectorization.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=4) {\n+      diff += in[j+i]*coeff[j]; \n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < M; i++)\n+    coeff[i] = i;\n+  for (i = 0; i < N+M; i++)\n+    in[i] = i;\n+\n+  foo ();\n+  \n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=4) {\n+      diff += in[j+i]*coeff[j];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8fd1a03db143a645ab6db2aeb7a2839ea0570186", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4a.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4a.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+signed short in[N+M];\n+signed short coeff[M];\n+signed short out[N];\n+\n+/* Outer-loop vectorization.\n+   Currently not vectorized because of multiple-data-types in the inner-loop.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i]*coeff[j]; \n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* FORNOW. not vectorized until we support 0-stride acceses like coeff[j]. should be:\n+   { scan-tree-dump-not \"multiple types in nested loop.\" \"vect\" { xfail *-*-* } } } */\n+\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1  \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ba2f7b4d0dfabce308a5fa29928786fb42071496", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4b.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4b.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+signed short in[N+M];\n+signed short coeff[M];\n+int out[N];\n+\n+/* Outer-loop vectorization.\n+   Currently not vectorized because of multiple-data-types in the inner-loop.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i]*coeff[j]; \n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* FORNOW. not vectorized until we support 0-stride acceses like coeff[j]. should be:\n+   { scan-tree-dump-not \"multiple types in nested loop.\" \"vect\" { xfail *-*-* } } } */\n+\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1  \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "eb6b30f41edadd346930bf8bef8769adb49686a0", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4c.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4c.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned short coeff[M];\n+unsigned int out[N];\n+\n+/* Outer-loop vectorization. */\n+\n+void\n+foo (){\n+  int i,j;\n+  unsigned short diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i]*coeff[j]; \n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { target vect_short_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "444a332b38bc9392f09804e323e6f4d061d6126a", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4d.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4d.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+float in[N+M];\n+float out[N];\n+\n+/* Outer-loop vectorization.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=4) {\n+      diff += in[j+i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < N; i++)\n+    in[i] = i;\n+\n+  foo ();\n+  \n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=4) {\n+      diff += in[j+i];\n+    }\n+    if (out[i] != diff)\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "243cc1af7ea05228c89073dfa6918e7a159b68c8", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4e.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4e.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+unsigned int in[N+M];\n+unsigned short out[N];\n+\n+/* Outer-loop vectorization. */\n+\n+void\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    out[i]=(unsigned short)diff;\n+  }\n+\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ebd0ef38f702654dd59b8c4114721ad59515b543", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4f.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4f.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned int out[N];\n+unsigned char arr[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+  unsigned int s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=diff;\n+  }\n+  return s;\n+}\n+\n+unsigned int\n+bar (int i, unsigned int diff, unsigned short *in)\n+{\n+    int j;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    return diff;\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  unsigned int diff;\n+  unsigned int s=0,sum=0;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+M; i++) {\n+    in[i] = i;\n+  }\n+\n+  sum=foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    diff = bar (i, diff, in);\n+    s += diff;\n+  }\n+\n+  if (s != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ebd0ef38f702654dd59b8c4114721ad59515b543", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4g.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4g.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned int out[N];\n+unsigned char arr[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+  unsigned int s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=diff;\n+  }\n+  return s;\n+}\n+\n+unsigned int\n+bar (int i, unsigned int diff, unsigned short *in)\n+{\n+    int j;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    return diff;\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  unsigned int diff;\n+  unsigned int s=0,sum=0;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+M; i++) {\n+    in[i] = i;\n+  }\n+\n+  sum=foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    diff = bar (i, diff, in);\n+    s += diff;\n+  }\n+\n+  if (s != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "bc43c5bc6d5406e607666cd794220b98090e6780", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4i.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4i.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+unsigned char in[N+M];\n+unsigned short out[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned short\n+foo (){\n+  int i,j;\n+  unsigned short diff;\n+  unsigned short s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=diff;\n+  }\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7e1b7ec81ee6e90d57ea5bd05b6bd92f3bfcbf11", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4j.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4j.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+\n+#define N 40\n+#define M 128\n+unsigned char in[N+M];\n+unsigned short out[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+void\n+foo (){\n+  int i,j;\n+  unsigned short diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    out[i]=diff;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ebd0ef38f702654dd59b8c4114721ad59515b543", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4k.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4k.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned int out[N];\n+unsigned char arr[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+  unsigned int s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=diff;\n+  }\n+  return s;\n+}\n+\n+unsigned int\n+bar (int i, unsigned int diff, unsigned short *in)\n+{\n+    int j;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    return diff;\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  unsigned int diff;\n+  unsigned int s=0,sum=0;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+M; i++) {\n+    in[i] = i;\n+  }\n+\n+  sum=foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    diff = bar (i, diff, in);\n+    s += diff;\n+  }\n+\n+  if (s != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ebd0ef38f702654dd59b8c4114721ad59515b543", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4l.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4l.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned int out[N];\n+unsigned char arr[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+  unsigned int s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=diff;\n+  }\n+  return s;\n+}\n+\n+unsigned int\n+bar (int i, unsigned int diff, unsigned short *in)\n+{\n+    int j;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    return diff;\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  unsigned int diff;\n+  unsigned int s=0,sum=0;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+M; i++) {\n+    in[i] = i;\n+  }\n+\n+  sum=foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = 3;\n+    diff = 0;\n+    diff = bar (i, diff, in);\n+    s += diff;\n+  }\n+\n+  if (s != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: not allowed\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f85ddbfd46758d6218dc6fad37f734dd64861881", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-4m.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4m.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4m.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-4m.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+unsigned short in[N+M];\n+unsigned int out[N];\n+\n+/* Outer-loop vectorization. */\n+/* Not vectorized due to multiple-types in the inner-loop.  */\n+\n+unsigned int\n+foo (){\n+  int i,j;\n+  unsigned int diff;\n+  unsigned int s=0;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s+=((unsigned short)diff>>3);\n+  }\n+  return s;\n+}\n+\n+int main (void)\n+{\n+  int i, j;\n+  unsigned int diff;\n+  unsigned int s=0,sum=0;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+M; i++) {\n+    in[i] = i;\n+  }\n+\n+  sum=foo ();\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j+=8) {\n+      diff += in[j+i];\n+    }\n+    s += ((unsigned short)diff>>3);\n+  }\n+\n+  if (s != sum)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\"  { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f998cb21b7c503c7d36c38ee2aefeafa97772e9e", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-5.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-5.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main1 ()\n+{  \n+  float A[N] __attribute__ ((__aligned__(16)));\n+  float B[N] __attribute__ ((__aligned__(16)));\n+  float C[N] __attribute__ ((__aligned__(16)));\n+  float D[N] __attribute__ ((__aligned__(16)));\n+  float s;\n+\n+  int i, j;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      A[i] = i;\n+      B[i] = i;\n+      C[i] = i;\n+      D[i] = i;\n+    }\n+\n+  /* Outer-loop 1: Vectorizable with respect to dependence distance. */\n+  for (i = 0; i < N-20; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<N; j+=4)\n+        s += C[j];\n+      A[i] = A[i+20] + s;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N-20; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<N; j+=4)\n+        s += C[j];\n+      if (A[i] != D[i+20] + s)\n+        abort ();\n+    }\n+\n+  /* Outer-loop 2: Not vectorizable because of dependence distance. */\n+  for (i = 0; i < 4; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<N; j+=4)\n+\ts += C[j];\n+      B[i] = B[i+3] + s;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 4; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<N; j+=4)\n+\ts += C[j];\n+      if (B[i] != D[i+3] + s)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+  return main1();\n+}\n+\n+/* NOTE: We temporarily xfail the following check until versioning for\n+   aliasing is fixed to avoid versioning when the dependence distance\n+   is known.  */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: possible dependence between data-refs\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f4adfaa06fcc0d5a73a70fa882008e810acef278", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-6.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-6.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define MAX 42\n+\n+float A[N] __attribute__ ((__aligned__(16)));\n+float B[N] __attribute__ ((__aligned__(16)));\n+float C[N] __attribute__ ((__aligned__(16)));\n+float D[N] __attribute__ ((__aligned__(16)));\n+extern void abort(void); \n+\n+int main1 ()\n+{  \n+  float s;\n+\n+  int i, j;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<8; j+=4)\n+\ts += C[j];\n+      A[i] = s;\n+    }\n+\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  int i,j;\n+  float s;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      A[i] = i;\n+      B[i] = i;\n+      C[i] = i;\n+      D[i] = i;\n+    }\n+\n+  main1();\n+\n+  /* check results:  */\n+  for (i = 0; i < 8; i++)\n+    {\n+      s = 0;\n+      for (j=0; j<8; j+=4)\n+        s += C[j];\n+      if (A[i] != s)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"zero step in outer loop.\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "768b1043261849b0f8c7bb4e5ba2c557733ca236", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 64\n+float in[N+M];\n+float coeff[M];\n+float out[N];\n+float fir_out[N];\n+\n+/* Should be vectorized. Fixed misaligment in the inner-loop.  */\n+/* Currently not vectorized because the loop-count for the inner-loop\n+   has a maybe_zero component. Will be fixed when we incorporate the\n+   \"cond_expr in rhs\" patch.  */\n+void foo (){\n+ int i,j,k;\n+ float diff;\n+\n+ for (i = 0; i < N; i++) {\n+  out[i] = 0;\n+ }\n+\n+ for (k = 0; k < 4; k++) {\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    j = k;\n+\n+    do {\n+      diff += in[j+i]*coeff[j];\n+      j+=4;\t\n+    } while (j < M);\n+\n+    out[i] += diff;\n+  }\n+ }\n+\n+}\n+\n+/* Vectorized. Changing misalignment in the inner-loop.  */\n+void fir (){\n+  int i,j,k;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j++) {\n+      diff += in[j+i]*coeff[j];\n+    }\n+    fir_out[i] = diff;\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < M; i++)\n+    coeff[i] = i;\n+  for (i = 0; i < N+M; i++)\n+    in[i] = i;\n+\n+  foo ();\n+  fir ();\n+  \n+  for (i = 0; i < N; i++) {\n+    if (out[i] != fir_out[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0b03dc9a848d9cafee8cf16632dcc3f6855ba2f8", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-fir.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 40\n+#define M 128\n+float in[N+M];\n+float coeff[M];\n+float out[N];\n+float fir_out[N];\n+\n+/* Should be vectorized. Fixed misaligment in the inner-loop.  */\n+/* Currently not vectorized because we get too many BBs in the inner-loop,\n+   because the compiler doesn't realize that the inner-loop executes at\n+   least once (cause k<4), and so there's no need to create a guard code\n+   to skip the inner-loop in case it doesn't execute.  */\n+void foo (){\n+ int i,j,k;\n+ float diff;\n+\n+ for (i = 0; i < N; i++) {\n+  out[i] = 0;\n+ }\n+\n+ for (k = 0; k < 4; k++) {\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = k; j < M; j+=4) {\n+      diff += in[j+i]*coeff[j]; \n+    }\n+    out[i] += diff;\n+  }\n+ }\n+\n+}\n+\n+/* Vectorized. Changing misalignment in the inner-loop.  */\n+void fir (){\n+  int i,j,k;\n+  float diff;\n+\n+  for (i = 0; i < N; i++) {\n+    diff = 0;\n+    for (j = 0; j < M; j++) {\n+      diff += in[j+i]*coeff[j];\n+    }\n+    fir_out[i] = diff;\n+  }\n+}\n+\n+\n+int main (void)\n+{\n+  check_vect ();\n+  int i, j;\n+  float diff;\n+\n+  for (i = 0; i < M; i++)\n+    coeff[i] = i;\n+  for (i = 0; i < N+M; i++)\n+    in[i] = i;\n+\n+  foo ();\n+  fir ();\n+  \n+  for (i = 0; i < N; i++) {\n+    if (out[i] != fir_out[i])\n+      abort ();\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 2 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "48a50ddfb10e64bd54869281a3751baaef2b7404", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -489,7 +489,7 @@ dump_ddrs (FILE *file, VEC (ddr_p, heap) *ddrs)\n /* Expresses EXP as VAR + OFF, where off is a constant.  The type of OFF\n    will be ssizetype.  */\n \n-static void\n+void\n split_constant_offset (tree exp, tree *var, tree *off)\n {\n   tree type = TREE_TYPE (exp), otype;"}, {"sha": "2ae58266db627ddb48bef02376b13dd2962daaae", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -388,4 +388,7 @@ index_in_loop_nest (int var, VEC (loop_p, heap) *loop_nest)\n /* In lambda-code.c  */\n bool lambda_transform_legal_p (lambda_trans_matrix, int, VEC (ddr_p, heap) *);\n \n+/* In tree-data-refs.c  */\n+void split_constant_offset (tree , tree *, tree *);\n+\n #endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "35e38d01471755cd057b551a8e7cb0520c66a922", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 191, "deletions": 36, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -1279,6 +1279,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n   tree stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);  \n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree ref = DR_REF (dr);\n   tree vectype;\n   tree base, base_addr;\n@@ -1295,13 +1297,42 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   misalign = DR_INIT (dr);\n   aligned_to = DR_ALIGNED_TO (dr);\n   base_addr = DR_BASE_ADDRESS (dr);\n+\n+  /* In case the dataref is in an inner-loop of the loop that is being\n+     vectorized (LOOP), we use the base and misalignment information\n+     relative to the outer-loop (LOOP). This is ok only if the misalignment\n+     stays the same throughout the execution of the inner-loop, which is why\n+     we have to check that the stride of the dataref in the inner-loop evenly\n+     divides by the vector size.  */\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      tree step = DR_STEP (dr);\n+      HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n+    \n+      if (dr_step % UNITS_PER_SIMD_WORD == 0)\n+        {\n+          if (vect_print_dump_info (REPORT_ALIGNMENT))\n+            fprintf (vect_dump, \"inner step divides the vector-size.\");\n+\t  misalign = STMT_VINFO_DR_INIT (stmt_info);\n+\t  aligned_to = STMT_VINFO_DR_ALIGNED_TO (stmt_info);\n+\t  base_addr = STMT_VINFO_DR_BASE_ADDRESS (stmt_info);\n+        }\n+      else\n+\t{\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\t    fprintf (vect_dump, \"inner step doesn't divide the vector-size.\");\n+\t  misalign = NULL_TREE;\n+\t}\n+    }\n+\n   base = build_fold_indirect_ref (base_addr);\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n \n-  if (tree_int_cst_compare (aligned_to, alignment) < 0)\n+  if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)\n+      || !misalign)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n+      if (vect_print_dump_info (REPORT_ALIGNMENT))\n \t{\n \t  fprintf (vect_dump, \"Unknown alignment for access: \");\n \t  print_generic_expr (vect_dump, base, TDF_SLIM);\n@@ -1980,20 +2011,39 @@ static bool\n vect_analyze_data_ref_access (struct data_reference *dr)\n {\n   tree step = DR_STEP (dr);\n-  HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n   HOST_WIDE_INT type_size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n   tree stmt = DR_STMT (dr);\n-  /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the \n-     interleaving group (including gaps).  */\n-  HOST_WIDE_INT stride = dr_step / type_size;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n+  HOST_WIDE_INT stride;\n+\n+  /* Don't allow invariant accesses.  */\n+  if (dr_step == 0)\n+    return false; \n \n-  if (!step)\n+  if (nested_in_vect_loop_p (loop, stmt))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data-ref access\");\n-      return false;\n+      /* For the rest of the analysis we use the outer-loop step.  */\n+      step = STMT_VINFO_DR_STEP (stmt_info);\n+      dr_step = TREE_INT_CST_LOW (step);\n+      \n+      if (dr_step == 0)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\t    fprintf (vect_dump, \"zero step in outer loop.\");\n+\t  if (DR_IS_READ (dr))\n+  \t    return true; \n+\t  else\n+\t    return false;\n+\t}\n     }\n+    \n+  /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the \n+     interleaving group (including gaps).  */\n+  stride = dr_step / type_size; \n \n   /* Consecutive?  */\n   if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n@@ -2003,6 +2053,13 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       return true;\n     }\n \n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\tfprintf (vect_dump, \"strided access in outer loop.\");\n+      return false;\n+    }\n+\n   /* Not consecutive access is possible only if it is a part of interleaving.  */\n   if (!DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n     {\n@@ -2231,43 +2288,21 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n       tree stmt;\n       stmt_vec_info stmt_info;\n       basic_block bb;\n+      tree base, offset, init;\t\n    \n       if (!dr || !DR_REF (dr))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n           return false;\n         }\n- \n-      /* Update DR field in stmt_vec_info struct.  */\n+\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n-      /* If outer-loop vectorization: we don't yet support datarefs\n-\t in the innermost loop.  */\n-      bb = bb_for_stmt (stmt);\n-      if (bb->loop_father != LOOP_VINFO_LOOP (loop_vinfo))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: data-ref in nested loop\");\n-\t  return false;\n-\t}\n-\n-      if (STMT_VINFO_DATA_REF (stmt_info))\n-        {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-            {\n-              fprintf (vect_dump,\n-                       \"not vectorized: more than one data ref in stmt: \");\n-              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-            }\n-          return false;\n-        }\n-      STMT_VINFO_DATA_REF (stmt_info) = dr;\n-     \n       /* Check that analysis of the data-ref succeeded.  */\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n-          || !DR_STEP (dr))   \n+          || !DR_STEP (dr))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n             {\n@@ -2294,7 +2329,127 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n             }\n           return false;\n         }\n-                       \n+\n+      base = unshare_expr (DR_BASE_ADDRESS (dr));\n+      offset = unshare_expr (DR_OFFSET (dr));\n+      init = unshare_expr (DR_INIT (dr));\n+\t\n+      /* Update DR field in stmt_vec_info struct.  */\n+      bb = bb_for_stmt (stmt);\n+\n+      /* If the dataref is in an inner-loop of the loop that is considered for\n+\t for vectorization, we also want to analyze the access relative to\n+\t the outer-loop (DR contains information only relative to the \n+\t inner-most enclosing loop).  We do that by building a reference to the\n+\t first location accessed by the inner-loop, and analyze it relative to\n+\t the outer-loop.  */ \t\n+      if (nested_in_vect_loop_p (loop, stmt)) \n+\t{\n+\t  tree outer_step, outer_base, outer_init;\n+\t  HOST_WIDE_INT pbitsize, pbitpos;\n+\t  tree poffset;\n+\t  enum machine_mode pmode;\n+\t  int punsignedp, pvolatilep;\n+\t  affine_iv base_iv, offset_iv;\n+\t  tree dinit;\n+\n+\t  /* Build a reference to the first location accessed by the \n+\t     inner-loop: *(BASE+INIT). (The first location is actually\n+\t     BASE+INIT+OFFSET, but we add OFFSET separately later.  */\n+\t  tree inner_base = build_fold_indirect_ref \n+\t\t\t\t(fold_build2 (PLUS_EXPR, TREE_TYPE (base), base, init));\n+\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"analyze in outer-loop: \");\n+\t      print_generic_expr (dump_file, inner_base, TDF_SLIM);\n+\t    }\n+\n+\t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos, \n+\t\t          &poffset, &pmode, &punsignedp, &pvolatilep, false);\n+\t  gcc_assert (outer_base != NULL_TREE);\n+\n+\t  if (pbitpos % BITS_PER_UNIT != 0)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (dump_file, \"failed: bit offset alignment.\\n\");\n+\t      return false;\n+\t    }\n+\n+\t  outer_base = build_fold_addr_expr (outer_base);\n+\t  if (!simple_iv (loop, stmt, outer_base, &base_iv, false))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n+\t      return false;\n+\t    }\n+\n+\t  if (offset)\n+\t    {\n+\t      if (poffset)\n+\t\tpoffset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, poffset);\n+\t      else\n+\t\tpoffset = offset;\n+\t    }\n+\n+\t  if (!poffset)\n+\t    {\n+\t      offset_iv.base = ssize_int (0);\n+\t      offset_iv.step = ssize_int (0);\n+\t    }\n+\t  else if (!simple_iv (loop, stmt, poffset, &offset_iv, false))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t        fprintf (dump_file, \"evolution of offset is not affine.\\n\");\n+\t      return false;\n+\t    }\n+\n+\t  outer_init = ssize_int (pbitpos / BITS_PER_UNIT);\n+\t  split_constant_offset (base_iv.base, &base_iv.base, &dinit);\n+\t  outer_init =  size_binop (PLUS_EXPR, outer_init, dinit);\n+\t  split_constant_offset (offset_iv.base, &offset_iv.base, &dinit);\n+\t  outer_init =  size_binop (PLUS_EXPR, outer_init, dinit);\n+\n+\t  outer_step = size_binop (PLUS_EXPR,\n+\t\t\t\tfold_convert (ssizetype, base_iv.step),\n+\t\t\t\tfold_convert (ssizetype, offset_iv.step));\n+\n+\t  STMT_VINFO_DR_STEP (stmt_info) = outer_step;\n+\t  /* FIXME: Use canonicalize_base_object_address (base_iv.base); */\n+\t  STMT_VINFO_DR_BASE_ADDRESS (stmt_info) = base_iv.base; \n+\t  STMT_VINFO_DR_INIT (stmt_info) = outer_init;\n+\t  STMT_VINFO_DR_OFFSET (stmt_info) = \n+\t\t\t\tfold_convert (ssizetype, offset_iv.base);\n+\t  STMT_VINFO_DR_ALIGNED_TO (stmt_info) = \n+\t\t\t\tsize_int (highest_pow2_factor (offset_iv.base));\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\touter base_address: \");\n+\t      print_generic_expr (dump_file, STMT_VINFO_DR_BASE_ADDRESS (stmt_info), TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\\touter offset from base address: \");\n+\t      print_generic_expr (dump_file, STMT_VINFO_DR_OFFSET (stmt_info), TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\\touter constant offset from base address: \");\n+\t      print_generic_expr (dump_file, STMT_VINFO_DR_INIT (stmt_info), TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\\touter step: \");\n+\t      print_generic_expr (dump_file, STMT_VINFO_DR_STEP (stmt_info), TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\\touter aligned to: \");\n+\t      print_generic_expr (dump_file, STMT_VINFO_DR_ALIGNED_TO (stmt_info), TDF_SLIM);\n+\t    }\n+\t}\n+\n+      if (STMT_VINFO_DATA_REF (stmt_info))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              fprintf (vect_dump,\n+                       \"not vectorized: more than one data ref in stmt: \");\n+              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+            }\n+          return false;\n+        }\n+      STMT_VINFO_DATA_REF (stmt_info) = dr;\n+     \n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n       STMT_VINFO_VECTYPE (stmt_info) ="}, {"sha": "7c5b1b20b4d020d45e03ccd205125efd07531dc9", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 553, "deletions": 166, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -49,14 +49,14 @@ along with GCC; see the file COPYING3.  If not see\n static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n-  (tree, block_stmt_iterator *, tree, tree *, tree *, bool, tree); \n-static tree vect_create_addr_base_for_vector_ref (tree, tree *, tree);\n-static tree vect_setup_realignment (tree, block_stmt_iterator *, tree *);\n+  (tree, struct loop*, tree, tree *, tree *, bool, tree, bool *); \n+static tree vect_create_addr_base_for_vector_ref \n+  (tree, tree *, tree, struct loop *);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n static tree vect_get_vec_def_for_operand (tree, tree, tree *);\n-static tree vect_init_vector (tree, tree, tree);\n+static tree vect_init_vector (tree, tree, tree, block_stmt_iterator *);\n static void vect_finish_stmt_generation \n-  (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n+  (tree stmt, tree vec_stmt, block_stmt_iterator *);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n static void vect_create_epilog_for_reduction (tree, tree, enum tree_code, tree);\n static tree get_initial_def_for_reduction (tree, tree, tree *);\n@@ -371,6 +371,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   enum machine_mode mode;\n   tree operation = GIMPLE_STMT_OPERAND (STMT_VINFO_STMT (stmt_info), 1);\n   int op_type = TREE_CODE_LENGTH (TREE_CODE (operation));\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Cost of reduction op inside loop.  */\n   STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) += ncopies * TARG_VEC_STMT_COST;\n@@ -393,30 +395,33 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n      We have a reduction operator that will reduce the vector in one statement.\n      Also requires scalar extract.  */\n \n-  if (reduc_code < NUM_TREE_CODES) \n-    outer_cost += TARG_VEC_STMT_COST + TARG_VEC_TO_SCALAR_COST;\n-  else \n+  if (!nested_in_vect_loop_p (loop, orig_stmt))\n     {\n-      int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n-      tree bitsize =\n-\tTYPE_SIZE (TREE_TYPE ( GIMPLE_STMT_OPERAND (orig_stmt, 0)));\n-      int element_bitsize = tree_low_cst (bitsize, 1);\n-      int nelements = vec_size_in_bits / element_bitsize;\n-\n-      optab = optab_for_tree_code (code, vectype);\n-\n-      /* We have a whole vector shift available.  */\n-      if (VECTOR_MODE_P (mode)\n-\t  && optab_handler (optab, mode)->insn_code != CODE_FOR_nothing\n-\t  && optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n-        /* Final reduction via vector shifts and the reduction operator. Also\n-           requires scalar extract.  */\n-\touter_cost += ((exact_log2(nelements) * 2) * TARG_VEC_STMT_COST\n-\t\t\t+ TARG_VEC_TO_SCALAR_COST); \n-      else\n-\t/* Use extracts and reduction op for final reduction.  For N elements,\n-           we have N extracts and N-1 reduction ops.  */\n-\touter_cost += ((nelements + nelements - 1) * TARG_VEC_STMT_COST);\n+      if (reduc_code < NUM_TREE_CODES) \n+\touter_cost += TARG_VEC_STMT_COST + TARG_VEC_TO_SCALAR_COST;\n+      else \n+\t{\n+\t  int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n+\t  tree bitsize =\n+\t    TYPE_SIZE (TREE_TYPE ( GIMPLE_STMT_OPERAND (orig_stmt, 0)));\n+\t  int element_bitsize = tree_low_cst (bitsize, 1);\n+\t  int nelements = vec_size_in_bits / element_bitsize;\n+\n+\t  optab = optab_for_tree_code (code, vectype);\n+\n+\t  /* We have a whole vector shift available.  */\n+\t  if (VECTOR_MODE_P (mode)\n+\t      && optab_handler (optab, mode)->insn_code != CODE_FOR_nothing\n+\t      && optab_handler (vec_shr_optab, mode)->insn_code != CODE_FOR_nothing)\n+\t    /* Final reduction via vector shifts and the reduction operator. Also\n+\t       requires scalar extract.  */\n+\t    outer_cost += ((exact_log2(nelements) * 2) * TARG_VEC_STMT_COST\n+\t\t\t\t+ TARG_VEC_TO_SCALAR_COST); \n+\t  else\n+\t    /* Use extracts and reduction op for final reduction.  For N elements,\n+               we have N extracts and N-1 reduction ops.  */\n+\t    outer_cost += ((nelements + nelements - 1) * TARG_VEC_STMT_COST);\n+\t}\n     }\n \n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = outer_cost;\n@@ -609,7 +614,19 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n \n         break;\n       }\n-    case dr_unaligned_software_pipeline:\n+    case dr_explicit_realign:\n+      {\n+        inner_cost += ncopies * (2*TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n+\n+        /* FIXME: If the misalignment remains fixed across the iterations of\n+           the containing loop, the following cost should be added to the\n+           outside costs.  */\n+        if (targetm.vectorize.builtin_mask_for_load)\n+          inner_cost += TARG_VEC_STMT_COST;\n+\n+        break;\n+      }\n+    case dr_explicit_realign_optimized:\n       {\n         int outer_cost = 0;\n \n@@ -706,6 +723,19 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n    STMT: The statement containing the data reference.\n    NEW_STMT_LIST: Must be initialized to NULL_TREE or a statement list.\n    OFFSET: Optional. If supplied, it is be added to the initial address.\n+   LOOP:    Specify relative to which loop-nest should the address be computed.\n+            For example, when the dataref is in an inner-loop nested in an\n+\t    outer-loop that is now being vectorized, LOOP can be either the\n+\t    outer-loop, or the inner-loop. The first memory location accessed\n+\t    by the following dataref ('in' points to short):\n+\n+\t\tfor (i=0; i<N; i++)\n+\t\t   for (j=0; j<M; j++)\n+\t\t     s += in[i+j]\n+\n+\t    is as follows:\n+\t    if LOOP=i_loop:\t&in\t\t(relative to i_loop)\n+\t    if LOOP=j_loop: \t&in+i*2B\t(relative to j_loop)\n \n    Output:\n    1. Return an SSA_NAME whose value is the address of the memory location of \n@@ -718,27 +748,42 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n static tree\n vect_create_addr_base_for_vector_ref (tree stmt,\n                                       tree *new_stmt_list,\n-\t\t\t\t      tree offset)\n+\t\t\t\t      tree offset,\n+\t\t\t\t      struct loop *loop)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree data_ref_base_expr = unshare_expr (DR_BASE_ADDRESS (dr));\n-  tree base_name = build_fold_indirect_ref (data_ref_base_expr);\n+  struct loop *containing_loop = (bb_for_stmt (stmt))->loop_father;\n+  tree data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n+  tree base_name;\n   tree data_ref_base_var;\n-  tree data_ref_base;\n   tree new_base_stmt;\n   tree vec_stmt;\n   tree addr_base, addr_expr;\n   tree dest, new_stmt;\n   tree base_offset = unshare_expr (DR_OFFSET (dr));\n   tree init = unshare_expr (DR_INIT (dr));\n   tree vect_ptr_type, addr_expr2;\n-  \n-  \n+  tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n+\n+  gcc_assert (loop);\n+  if (loop != containing_loop)\n+    {\n+      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+      gcc_assert (nested_in_vect_loop_p (loop, stmt));\n+\n+      data_ref_base = unshare_expr (STMT_VINFO_DR_BASE_ADDRESS (stmt_info));\n+      base_offset = unshare_expr (STMT_VINFO_DR_OFFSET (stmt_info));\n+      init = unshare_expr (STMT_VINFO_DR_INIT (stmt_info));\n+    }\n+\n   /* Create data_ref_base */\n-  data_ref_base_var = create_tmp_var (TREE_TYPE (data_ref_base_expr), \"batmp\");\n+  base_name = build_fold_indirect_ref (data_ref_base);\n+  data_ref_base_var = create_tmp_var (TREE_TYPE (data_ref_base), \"batmp\");\n   add_referenced_var (data_ref_base_var);\n-  data_ref_base = force_gimple_operand (data_ref_base_expr, &new_base_stmt,\n+  data_ref_base = force_gimple_operand (data_ref_base, &new_base_stmt,\n \t\t\t\t\ttrue, data_ref_base_var);\n   append_to_statement_list_force(new_base_stmt, new_stmt_list);\n \n@@ -753,16 +798,6 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   if (offset)\n     {\n       tree tmp = create_tmp_var (sizetype, \"offset\");\n-      tree step; \n-\n-      /* For interleaved access step we divide STEP by the size of the\n-        interleaving group.  */\n-      if (DR_GROUP_SIZE (stmt_info))\n-\tstep = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (offset), DR_STEP (dr),\n-\t\t\t    build_int_cst (TREE_TYPE (offset),\n-\t\t\t\t\t   DR_GROUP_SIZE (stmt_info)));\n-      else\n-\tstep = DR_STEP (dr);\n \n       add_referenced_var (tmp);\n       offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset, step);\n@@ -773,8 +808,8 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n     }\n   \n   /* base + base_offset */\n-  addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base,\n-\t\t\t   base_offset);\n+  addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base), \n+\t\t\t   data_ref_base, base_offset);\n \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n \n@@ -811,7 +846,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n    1. STMT: a stmt that references memory. Expected to be of the form\n          GIMPLE_MODIFY_STMT <name, data-ref> or\n \t GIMPLE_MODIFY_STMT <data-ref, name>.\n-   2. BSI: block_stmt_iterator where new stmts can be added.\n+   2. AT_LOOP: the loop where the vector memref is to be created.\n    3. OFFSET (optional): an offset to be added to the initial address accessed\n         by the data-ref in STMT.\n    4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n@@ -838,30 +873,54 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \n       Return the increment stmt that updates the pointer in PTR_INCR.\n \n-   3. Return the pointer.  */\n+   3. Set INV_P to true if the access pattern of the data reference in the \n+      vectorized loop is invariant. Set it to false otherwise.\n+\n+   4. Return the pointer.  */\n \n static tree\n-vect_create_data_ref_ptr (tree stmt,\n-\t\t\t  block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n+vect_create_data_ref_ptr (tree stmt, struct loop *at_loop,\n \t\t\t  tree offset, tree *initial_address, tree *ptr_incr,\n-\t\t\t  bool only_init, tree type)\n+\t\t\t  bool only_init, tree type, bool *inv_p)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+  struct loop *containing_loop = (bb_for_stmt (stmt))->loop_father;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vect_ptr_type;\n   tree vect_ptr;\n   tree tag;\n   tree new_temp;\n   tree vec_stmt;\n   tree new_stmt_list = NULL_TREE;\n-  edge pe = loop_preheader_edge (loop);\n+  edge pe;\n   basic_block new_bb;\n   tree vect_ptr_init;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  tree vptr;\n+  block_stmt_iterator incr_bsi;\n+  bool insert_after;\n+  tree indx_before_incr, indx_after_incr;\n+  tree incr;\n+  tree step;\n+\n+  /* Check the step (evolution) of the load in LOOP, and record\n+     whether it's invariant.  */\n+  if (nested_in_vect_loop)\n+    step = STMT_VINFO_DR_STEP (stmt_info);\n+  else\n+    step = DR_STEP (STMT_VINFO_DATA_REF (stmt_info));\n+    \n+  if (tree_int_cst_compare (step, size_zero_node) == 0)\n+    *inv_p = true;\n+  else\n+    *inv_p = false;\n \n+  /* Create an expression for the first address accessed by this load\n+     in LOOP.  */ \n   base_name =  build_fold_indirect_ref (unshare_expr (DR_BASE_ADDRESS (dr)));\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -904,12 +963,44 @@ vect_create_data_ref_ptr (tree stmt,\n \n   var_ann (vect_ptr)->subvars = DR_SUBVARS (dr);\n \n+  /** Note: If the dataref is in an inner-loop nested in LOOP, and we are\n+      vectorizing LOOP (i.e. outer-loop vectorization), we need to create two\n+      def-use update cycles for the pointer: One relative to the outer-loop\n+      (LOOP), which is what steps (3) and (4) below do. The other is relative\n+      to the inner-loop (which is the inner-most loop containing the dataref),\n+      and this is done be step (5) below. \n+\n+      When vectorizing inner-most loops, the vectorized loop (LOOP) is also the\n+      inner-most loop, and so steps (3),(4) work the same, and step (5) is\n+      redundant.  Steps (3),(4) create the following:\n+\n+\tvp0 = &base_addr;\n+\tLOOP:\tvp1 = phi(vp0,vp2)\n+\t\t...  \n+\t\t...\n+\t\tvp2 = vp1 + step\n+\t\tgoto LOOP\n+\t\t\t\n+      If there is an inner-loop nested in loop, then step (5) will also be\n+      applied, and an additional update in the inner-loop will be created:\n+\n+\tvp0 = &base_addr;\n+\tLOOP:   vp1 = phi(vp0,vp2)\n+\t\t...\n+        inner:     vp3 = phi(vp1,vp4)\n+\t           vp4 = vp3 + inner_step\n+\t           if () goto inner\n+\t\t...\n+\t\tvp2 = vp1 + step\n+\t\tif () goto LOOP   */\n+\n   /** (3) Calculate the initial address the vector-pointer, and set\n           the vector-pointer to point to it before the loop:  **/\n \n   /* Create: (&(base[init_val+offset]) in the loop preheader.  */\n+\n   new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list,\n-                                                   offset);\n+                                                   offset, loop);\n   pe = loop_preheader_edge (loop);\n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmt_list);\n   gcc_assert (!new_bb);\n@@ -924,25 +1015,31 @@ vect_create_data_ref_ptr (tree stmt,\n   gcc_assert (!new_bb);\n \n \n-  /** (4) Handle the updating of the vector-pointer inside the loop: **/\n+  /** (4) Handle the updating of the vector-pointer inside the loop.\n+\t  This is needed when ONLY_INIT is false, and also when AT_LOOP\n+\t  is the inner-loop nested in LOOP (during outer-loop vectorization).\n+   **/\n \n-  if (only_init) /* No update in loop is required.  */\n+  if (only_init && at_loop == loop) /* No update in loop is required.  */\n     {\n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n         duplicate_ssa_name_ptr_info (vect_ptr_init, DR_PTR_INFO (dr));\n-      return vect_ptr_init;\n+      vptr = vect_ptr_init;\n     }\n   else\n     {\n-      block_stmt_iterator incr_bsi;\n-      bool insert_after;\n-      tree indx_before_incr, indx_after_incr;\n-      tree incr;\n+      /* The step of the vector pointer is the Vector Size.  */\n+      tree step = TYPE_SIZE_UNIT (vectype);\n+      /* One exception to the above is when the scalar step of the load in \n+\t LOOP is zero. In this case the step here is also zero.  */\n+      if (*inv_p)\n+\tstep = size_zero_node;\n \n       standard_iv_increment_position (loop, &incr_bsi, &insert_after);\n+\n       create_iv (vect_ptr_init,\n-\t\t fold_convert (vect_ptr_type, TYPE_SIZE_UNIT (vectype)),\n+\t\t fold_convert (vect_ptr_type, step),\n \t\t NULL_TREE, loop, &incr_bsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = bsi_stmt (incr_bsi);\n@@ -960,15 +1057,51 @@ vect_create_data_ref_ptr (tree stmt,\n       if (ptr_incr)\n \t*ptr_incr = incr;\n \n-      return indx_before_incr;\n+      vptr = indx_before_incr;\n+    }\n+\n+  if (!nested_in_vect_loop || only_init)\n+    return vptr;\n+\n+\n+  /** (5) Handle the updating of the vector-pointer inside the inner-loop\n+\t  nested in LOOP, if exists: **/\n+\n+  gcc_assert (nested_in_vect_loop);\n+  if (!only_init)\n+    {\n+      standard_iv_increment_position (containing_loop, &incr_bsi, \n+\t\t\t\t      &insert_after);\n+      create_iv (vptr, fold_convert (vect_ptr_type, DR_STEP (dr)), NULL_TREE, \n+\t\t containing_loop, &incr_bsi, insert_after, &indx_before_incr, \n+\t\t &indx_after_incr);\n+      incr = bsi_stmt (incr_bsi);\n+      set_stmt_info (stmt_ann (incr), new_stmt_vec_info (incr, loop_vinfo));\n+\n+      /* Copy the points-to information if it exists. */\n+      if (DR_PTR_INFO (dr))\n+\t{\n+\t  duplicate_ssa_name_ptr_info (indx_before_incr, DR_PTR_INFO (dr));\n+\t  duplicate_ssa_name_ptr_info (indx_after_incr, DR_PTR_INFO (dr));\n+\t}\n+      merge_alias_info (vect_ptr_init, indx_before_incr);\n+      merge_alias_info (vect_ptr_init, indx_after_incr);\n+      if (ptr_incr)\n+\t*ptr_incr = incr;\n+\n+      return indx_before_incr; \n     }\n+  else\n+    gcc_unreachable ();\n }\n \n \n /* Function bump_vector_ptr\n \n-   Increment a pointer (to a vector type) by vector-size. Connect the new \n-   increment stmt to the existing def-use update-chain of the pointer.\n+   Increment a pointer (to a vector type) by vector-size. If requested,\n+   i.e. if PTR-INCR is given, then also connect the new increment stmt \n+   to the existing def-use update-chain of the pointer, by modifying\n+   the PTR_INCR as illustrated below:\n \n    The pointer def-use update-chain before this function:\n                         DATAREF_PTR = phi (p_0, p_2)\n@@ -978,26 +1111,28 @@ vect_create_data_ref_ptr (tree stmt,\n    The pointer def-use update-chain after this function:\n                         DATAREF_PTR = phi (p_0, p_2)\n                         ....\n-                        NEW_DATAREF_PTR = DATAREF_PTR + vector_size\n+                        NEW_DATAREF_PTR = DATAREF_PTR + BUMP\n                         ....\n         PTR_INCR:       p_2 = NEW_DATAREF_PTR + step\n \n    Input:\n    DATAREF_PTR - ssa_name of a pointer (to vector type) that is being updated \n                  in the loop.\n-   PTR_INCR - the stmt that updates the pointer in each iteration of the loop.\n-              The increment amount across iterations is also expected to be\n-              vector_size.      \n+   PTR_INCR - optional. The stmt that updates the pointer in each iteration of \n+\t      the loop.  The increment amount across iterations is expected\n+\t      to be vector_size.      \n    BSI - location where the new update stmt is to be placed.\n    STMT - the original scalar memory-access stmt that is being vectorized.\n+   BUMP - optional. The offset by which to bump the pointer. If not given,\n+\t  the offset is assumed to be vector_size.\n \n    Output: Return NEW_DATAREF_PTR as illustrated above.\n    \n */\n \n static tree\n bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n-                 tree stmt)\n+                 tree stmt, tree bump)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n@@ -1010,13 +1145,24 @@ bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n \n+  if (bump)\n+    update = bump;\n+    \n   incr_stmt = build_gimple_modify_stmt (ptr_var,\n \t\t\t\t\tbuild2 (POINTER_PLUS_EXPR, vptr_type,\n \t\t\t\t\t\tdataref_ptr, update));\n   new_dataref_ptr = make_ssa_name (ptr_var, incr_stmt);\n   GIMPLE_STMT_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n   vect_finish_stmt_generation (stmt, incr_stmt, bsi);\n \n+  /* Copy the points-to information if it exists. */\n+  if (DR_PTR_INFO (dr))\n+    duplicate_ssa_name_ptr_info (new_dataref_ptr, DR_PTR_INFO (dr));\n+  merge_alias_info (new_dataref_ptr, dataref_ptr);\n+\n+  if (!ptr_incr)\n+    return new_dataref_ptr;\n+\n   /* Update the vector-pointer's cross-iteration increment.  */\n   FOR_EACH_SSA_USE_OPERAND (use_p, ptr_incr, iter, SSA_OP_USE)\n     {\n@@ -1028,11 +1174,6 @@ bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n         gcc_assert (tree_int_cst_compare (use, update) == 0);\n     }\n \n-  /* Copy the points-to information if it exists. */\n-  if (DR_PTR_INFO (dr))\n-    duplicate_ssa_name_ptr_info (new_dataref_ptr, DR_PTR_INFO (dr));\n-  merge_alias_info (new_dataref_ptr, dataref_ptr);\n-\n   return new_dataref_ptr;\n }\n \n@@ -1067,35 +1208,42 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n /* Function vect_init_vector.\n \n    Insert a new stmt (INIT_STMT) that initializes a new vector variable with\n-   the vector elements of VECTOR_VAR. Return the DEF of INIT_STMT. It will be\n-   used in the vectorization of STMT.  */\n+   the vector elements of VECTOR_VAR. Place the initialization at BSI if it\n+   is not NULL. Otherwise, place the initialization at the loop preheader.\n+   Return the DEF of INIT_STMT. \n+   It will be used in the vectorization of STMT.  */\n \n static tree\n-vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n+vect_init_vector (tree stmt, tree vector_var, tree vector_type,\n+\t\t  block_stmt_iterator *bsi)\n {\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree new_var;\n   tree init_stmt;\n   tree vec_oprnd;\n   edge pe;\n   tree new_temp;\n   basic_block new_bb;\n  \n-  if (nested_in_vect_loop_p (loop, stmt))\n-    loop = loop->inner;\n-\n   new_var = vect_get_new_vect_var (vector_type, vect_simple_var, \"cst_\");\n   add_referenced_var (new_var); \n- \n   init_stmt = build_gimple_modify_stmt (new_var, vector_var);\n   new_temp = make_ssa_name (new_var, init_stmt);\n   GIMPLE_STMT_OPERAND (init_stmt, 0) = new_temp;\n \n-  pe = loop_preheader_edge (loop);\n-  new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n-  gcc_assert (!new_bb);\n+  if (bsi)\n+    vect_finish_stmt_generation (stmt, init_stmt, bsi);\n+  else\n+    {\n+      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+      if (nested_in_vect_loop_p (loop, stmt))\n+        loop = loop->inner;\n+      pe = loop_preheader_edge (loop);\n+      new_bb = bsi_insert_on_edge_immediate (pe, init_stmt);\n+      gcc_assert (!new_bb);\n+    }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1233,7 +1381,7 @@ get_initial_def_for_induction (tree iv_phi)\n \t}\n       /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n       vec = build_constructor_from_list (vectype, nreverse (t));\n-      vec_init = vect_init_vector (iv_phi, vec, vectype);\n+      vec_init = vect_init_vector (iv_phi, vec, vectype, NULL);\n     }\n \n \n@@ -1254,7 +1402,7 @@ get_initial_def_for_induction (tree iv_phi)\n   for (i = 0; i < nunits; i++)\n     t = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n   vec = build_constructor_from_list (vectype, t);\n-  vec_step = vect_init_vector (iv_phi, vec, vectype);\n+  vec_step = vect_init_vector (iv_phi, vec, vectype, NULL);\n \n \n   /* Create the following def-use cycle:\n@@ -1310,7 +1458,7 @@ get_initial_def_for_induction (tree iv_phi)\n       for (i = 0; i < nunits; i++)\n \tt = tree_cons (NULL_TREE, unshare_expr (new_name), t);\n       vec = build_constructor_from_list (vectype, t);\n-      vec_step = vect_init_vector (iv_phi, vec, vectype);\n+      vec_step = vect_init_vector (iv_phi, vec, vectype, NULL);\n \n       vec_def = induc_def;\n       prev_stmt_vinfo = vinfo_for_stmt (induction_phi);\n@@ -1447,7 +1595,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n         vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n         vec_cst = build_vector (vector_type, t);\n \n-        return vect_init_vector (stmt, vec_cst, vector_type);\n+        return vect_init_vector (stmt, vec_cst, vector_type, NULL);\n       }\n \n     /* Case 2: operand is defined outside the loop - loop invariant.  */\n@@ -1468,8 +1616,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \t/* FIXME: use build_constructor directly.  */\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n         vec_inv = build_constructor_from_list (vector_type, t);\n-\n-        return vect_init_vector (stmt, vec_inv, vector_type);\n+        return vect_init_vector (stmt, vec_inv, vector_type, NULL);\n       }\n \n     /* Case 3: operand is defined inside the loop.  */\n@@ -4112,7 +4259,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum machine_mode vec_mode;\n   tree dummy;\n-  enum dr_alignment_support alignment_support_cheme;\n+  enum dr_alignment_support alignment_support_scheme;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -4124,7 +4271,10 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   bool strided_store = false;\n   unsigned int group_size, i;\n   VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n+  bool inv_p;\n+\n   gcc_assert (ncopies >= 1);\n+\n   /* FORNOW. This restriction should be relaxed.  */\n   if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n     {\n@@ -4198,6 +4348,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n       DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n \n+      /* FORNOW */\n+      gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n+\n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n       if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt)) \n@@ -4220,9 +4373,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   dr_chain = VEC_alloc (tree, heap, group_size);\n   oprnds = VEC_alloc (tree, heap, group_size);\n \n-  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n-  gcc_assert (alignment_support_cheme);\n-  gcc_assert (alignment_support_cheme == dr_aligned);  /* FORNOW */\n+  alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n+  gcc_assert (alignment_support_scheme);\n+  gcc_assert (alignment_support_scheme == dr_aligned);  /* FORNOW */\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4292,9 +4445,10 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      VEC_quick_push(tree, oprnds, vec_oprnd); \n \t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n \t    }\n-\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, NULL_TREE, \n+\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE, \n \t\t\t\t\t\t  &dummy, &ptr_incr, false,\n-\t\t\t\t\t\t  TREE_TYPE (vec_oprnd));\n+\t\t\t\t\t\t  TREE_TYPE (vec_oprnd), &inv_p);\n+\t  gcc_assert (!inv_p);\n \t}\n       else \n \t{\n@@ -4312,7 +4466,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t      VEC_replace(tree, dr_chain, i, vec_oprnd);\n \t      VEC_replace(tree, oprnds, i, vec_oprnd);\n \t    }\n-\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n+\t  dataref_ptr = \n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\n \t}\n \n       if (strided_store)\n@@ -4348,7 +4503,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  if (!next_stmt)\n \t    break;\n \t  /* Bump the vector pointer.  */\n-\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n+\t  dataref_ptr = \n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\n \t}\n     }\n \n@@ -4359,14 +4515,17 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n /* Function vect_setup_realignment\n   \n    This function is called when vectorizing an unaligned load using\n-   the dr_unaligned_software_pipeline scheme.\n+   the dr_explicit_realign[_optimized] scheme.\n    This function generates the following code at the loop prolog:\n \n       p = initial_addr;\n-      msq_init = *(floor(p));   # prolog load\n+   x  msq_init = *(floor(p));   # prolog load\n       realignment_token = call target_builtin; \n     loop:\n-      msq = phi (msq_init, ---)\n+   x  msq = phi (msq_init, ---)\n+\n+   The stmts marked with x are generated only for the case of \n+   dr_explicit_realign_optimized.\n \n    The code above sets up a new (vector) pointer, pointing to the first \n    location accessed by STMT, and a \"floor-aligned\" load using that pointer.\n@@ -4375,19 +4534,29 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n    whose arguments are the result of the prolog-load (created by this\n    function) and the result of a load that takes place in the loop (to be\n    created by the caller to this function).\n+\n+   For the case of dr_explicit_realign_optimized:\n    The caller to this function uses the phi-result (msq) to create the \n    realignment code inside the loop, and sets up the missing phi argument,\n    as follows:\n-\n     loop: \n       msq = phi (msq_init, lsq)\n       lsq = *(floor(p'));        # load in loop\n       result = realign_load (msq, lsq, realignment_token);\n \n+   For the case of dr_explicit_realign:\n+    loop:\n+      msq = *(floor(p)); \t# load in loop\n+      p' = p + (VS-1);\n+      lsq = *(floor(p'));\t# load in loop\n+      result = realign_load (msq, lsq, realignment_token);\n+\n    Input:\n    STMT - (scalar) load stmt to be vectorized. This load accesses\n           a memory location that may be unaligned.\n    BSI - place where new code is to be inserted.\n+   ALIGNMENT_SUPPORT_SCHEME - which of the two misalignment handling schemes\n+\t\t\t      is used.\t\n    \n    Output:\n    REALIGNMENT_TOKEN - the result of a call to the builtin_mask_for_load\n@@ -4396,52 +4565,162 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n static tree\n vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n-                        tree *realignment_token)\n+                        tree *realignment_token,\n+\t\t\tenum dr_alignment_support alignment_support_scheme,\n+\t\t\ttree init_addr,\n+\t\t\tstruct loop **at_loop)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge pe = loop_preheader_edge (loop);\n+  edge pe;\n   tree scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   tree vec_dest;\n-  tree init_addr;\n   tree inc;\n   tree ptr;\n   tree data_ref;\n   tree new_stmt;\n   basic_block new_bb;\n-  tree msq_init;\n+  tree msq_init = NULL_TREE;\n   tree new_temp;\n   tree phi_stmt;\n-  tree msq;\n+  tree msq = NULL_TREE;\n+  tree stmts = NULL_TREE;\n+  bool inv_p;\n+  bool compute_in_loop = false;\n+  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+  struct loop *containing_loop = (bb_for_stmt (stmt))->loop_father;\n+  struct loop *loop_for_initial_load;\n+\n+  gcc_assert (alignment_support_scheme == dr_explicit_realign\n+\t      || alignment_support_scheme == dr_explicit_realign_optimized);\n+\n+  /* We need to generate three things:\n+     1. the misalignment computation\n+     2. the extra vector load (for the optimized realignment scheme).\n+     3. the phi node for the two vectors from which the realignment is\n+      done (for the optimized realignment scheme).\n+   */\n+\n+  /* 1. Determine where to generate the misalignment computation.\n+\n+     If INIT_ADDR is NULL_TREE, this indicates that the misalignment\n+     calculation will be generated by this function, outside the loop (in the\n+     preheader).  Otherwise, INIT_ADDR had already been computed for us by the\n+     caller, inside the loop.\n+\n+     Background: If the misalignment remains fixed throughout the iterations of\n+     the loop, then both realignment schemes are applicable, and also the\n+     misalignment computation can be done outside LOOP.  This is because we are\n+     vectorizing LOOP, and so the memory accesses in LOOP advance in steps that\n+     are a multiple of VS (the Vector Size), and therefore the misalignment in\n+     different vectorized LOOP iterations is always the same.\n+     The problem arises only if the memory access is in an inner-loop nested\n+     inside LOOP, which is now being vectorized using outer-loop vectorization.\n+     This is the only case when the misalignment of the memory access may not\n+     remain fixed thtoughout the iterations of the inner-loop (as exaplained in\n+     detail in vect_supportable_dr_alignment).  In this case, not only is the\n+     optimized realignment scheme not applicable, but also the misalignment\n+     computation (and generation of the realignment token that is passed to\n+     REALIGN_LOAD) have to be done inside the loop.\n+\n+     In short, INIT_ADDR indicates whether we are in a COMPUTE_IN_LOOP mode\n+     or not, which in turn determines if the misalignment is computed inside\n+     the inner-loop, or outside LOOP.  */\n+\n+  if (init_addr != NULL_TREE)\n+    {\n+      compute_in_loop = true;\n+      gcc_assert (alignment_support_scheme == dr_explicit_realign);\n+    }\n+\n+\n+  /* 2. Determine where to generate the extra vector load.\n+\n+     For the optimized realignment scheme, instead of generating two vector\n+     loads in each iteration, we generate a single extra vector load in the\n+     preheader of the loop, and in each iteration reuse the result of the\n+     vector load from the previous iteration.  In case the memory access is in\n+     an inner-loop nested inside LOOP, which is now being vectorized using\n+     outer-loop vectorization, we need to determine whether this initial vector\n+     load should be generated at the preheader of the inner-loop, or can be\n+     generated at the preheader of LOOP.  If the memory access has no evolution\n+     in LOOP, it can be generated in the preheader of LOOP. Otherwise, it has\n+     to be generated inside LOOP (in the preheader of the inner-loop).  */\n \n-  /* 1. Create msq_init = *(floor(p1)) in the loop preheader  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-  ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &init_addr, &inc, true,\n-\t\t\t\t  NULL_TREE);\n-  data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n-  new_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n-  new_temp = make_ssa_name (vec_dest, new_stmt);\n-  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n-  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n-  gcc_assert (!new_bb);\n-  msq_init = GIMPLE_STMT_OPERAND (new_stmt, 0);\n+  if (nested_in_vect_loop)\n+    {\n+      tree outerloop_step = STMT_VINFO_DR_STEP (stmt_info);\n+      bool invariant_in_outerloop =\n+            (tree_int_cst_compare (outerloop_step, size_zero_node) == 0);\n+      loop_for_initial_load = (invariant_in_outerloop ? loop : loop->inner);\n+    }\n+  else\n+    loop_for_initial_load = loop;\n+  if (at_loop)\n+    *at_loop = loop_for_initial_load;\n+\n+  /* 3. For the case of the optimized realignment, create the first vector\n+      load at the loop preheader.  */\n+\n+  if (alignment_support_scheme == dr_explicit_realign_optimized)\n+    {\n+      /* Create msq_init = *(floor(p1)) in the loop preheader  */\n+\n+      gcc_assert (!compute_in_loop);\n+      pe = loop_preheader_edge (loop_for_initial_load);\n+      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+      ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n+\t\t\t\t&init_addr, &inc, true, NULL_TREE, &inv_p);\n+      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n+      new_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n+      new_temp = make_ssa_name (vec_dest, new_stmt);\n+      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+      new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+      gcc_assert (!new_bb);\n+      msq_init = GIMPLE_STMT_OPERAND (new_stmt, 0);\n+    }\n+\n+  /* 4. Create realignment token using a target builtin, if available.\n+      It is done either inside the containing loop, or before LOOP (as\n+      determined above).  */\n \n-  /* 2. Create permutation mask, if required, in loop preheader.  */\n   if (targetm.vectorize.builtin_mask_for_load)\n     {\n       tree builtin_decl;\n \n+      /* Compute INIT_ADDR - the initial addressed accessed by this memref.  */\n+      if (compute_in_loop)\n+\tgcc_assert (init_addr); /* already computed by the caller.  */\n+      else\n+\t{\n+\t  /* Generate the INIT_ADDR computation outside LOOP.  */\n+\t  init_addr = vect_create_addr_base_for_vector_ref (stmt, &stmts,\n+\t\t\t\t\t\t\tNULL_TREE, loop);\n+\t  pe = loop_preheader_edge (loop);\n+\t  new_bb = bsi_insert_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n       builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n       new_stmt = build_call_expr (builtin_decl, 1, init_addr);\n       vec_dest = vect_create_destination_var (scalar_dest, \n \t\t\t\t\t      TREE_TYPE (new_stmt));\n       new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n-      new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n-      gcc_assert (!new_bb);\n+\n+      if (compute_in_loop)\n+\tbsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n+      else\n+\t{\n+\t  /* Generate the misalignment computation outside LOOP.  */\n+\t  pe = loop_preheader_edge (loop);\n+\t  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n       *realignment_token = GIMPLE_STMT_OPERAND (new_stmt, 0);\n \n       /* The result of the CALL_EXPR to this builtin is determined from\n@@ -4452,12 +4731,21 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n       gcc_assert (TREE_READONLY (builtin_decl));\n     }\n \n-  /* 3. Create msq = phi <msq_init, lsq> in loop  */\n+  if (alignment_support_scheme == dr_explicit_realign)\n+    return msq;\n+\n+  gcc_assert (!compute_in_loop);\n+  gcc_assert (alignment_support_scheme == dr_explicit_realign_optimized);\n+\n+\n+  /* 5. Create msq = phi <msq_init, lsq> in loop  */\n+\n+  pe = loop_preheader_edge (containing_loop);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n   msq = make_ssa_name (vec_dest, NULL_TREE);\n-  phi_stmt = create_phi_node (msq, loop->header); \n+  phi_stmt = create_phi_node (msq, containing_loop->header);\n   SSA_NAME_DEF_STMT (msq) = phi_stmt;\n-  add_phi_arg (phi_stmt, msq_init, loop_preheader_edge (loop));\n+  add_phi_arg (phi_stmt, msq_init, pe);\n \n   return msq;\n }\n@@ -4747,13 +5035,15 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   stmt_vec_info prev_stmt_info; \n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *containing_loop = (bb_for_stmt (stmt))->loop_father;\n+  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n   int mode;\n   tree new_stmt = NULL_TREE;\n   tree dummy;\n-  enum dr_alignment_support alignment_support_cheme;\n+  enum dr_alignment_support alignment_support_scheme;\n   tree dataref_ptr = NULL_TREE;\n   tree ptr_incr;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -4762,14 +5052,19 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n   tree realignment_token = NULL_TREE;\n-  tree phi_stmt = NULL_TREE;\n+  tree phi = NULL_TREE;\n   VEC(tree,heap) *dr_chain = NULL;\n   bool strided_load = false;\n   tree first_stmt;\n+  tree scalar_type;\n+  bool inv_p;\n+  bool compute_in_loop = false;\n+  struct loop *at_loop;\n \n   gcc_assert (ncopies >= 1);\n+\n   /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+  if (nested_in_vect_loop && ncopies > 1)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"multiple types in nested loop.\");\n@@ -4807,6 +5102,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n+  scalar_type = TREE_TYPE (DR_REF (dr));\n   mode = (int) TYPE_MODE (vectype);\n \n   /* FORNOW. In some cases can vectorize even if data-type not supported\n@@ -4822,6 +5118,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (DR_GROUP_FIRST_DR (stmt_info))\n     {\n       strided_load = true;\n+      /* FORNOW */\n+      gcc_assert (! nested_in_vect_loop);\n \n       /* Check if interleaving is supported.  */\n       if (!vect_strided_load_supported (vectype))\n@@ -4860,9 +5158,8 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       group_size = 1;\n     }\n \n-  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n-  gcc_assert (alignment_support_cheme);\n-\n+  alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n+  gcc_assert (alignment_support_scheme);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -4944,7 +5241,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n          }\n \n      Otherwise, the data reference is potentially unaligned on a target that\n-     does not support unaligned accesses (dr_unaligned_software_pipeline) - \n+     does not support unaligned accesses (dr_explicit_realign_optimized) - \n      then generate the following code, in which the data in each iteration is\n      obtained by two vector loads, one from the previous iteration, and one\n      from the current iteration:\n@@ -4961,27 +5258,52 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n            msq = lsq;\n          }   */\n \n-  if (alignment_support_cheme == dr_unaligned_software_pipeline)\n+  /* If the misalignment remains the same throughout the execution of the\n+     loop, we can create the init_addr and permutation mask at the loop\n+     preheader. Otherwise, it needs to be created inside the loop.\n+     This can only occur when vectorizing memory accesses in the inner-loop\n+     nested within an outer-loop that is being vectorized.  */\n+\n+  if (nested_in_vect_loop_p (loop, stmt)\n+      && (TREE_INT_CST_LOW (DR_STEP (dr)) % UNITS_PER_SIMD_WORD != 0))\n+    {\n+      gcc_assert (alignment_support_scheme != dr_explicit_realign_optimized);\n+      compute_in_loop = true;\n+    }\n+\n+  if ((alignment_support_scheme == dr_explicit_realign_optimized\n+       || alignment_support_scheme == dr_explicit_realign)\n+      && !compute_in_loop)\n     {\n-      msq = vect_setup_realignment (first_stmt, bsi, &realignment_token);\n-      phi_stmt = SSA_NAME_DEF_STMT (msq);\n-      offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n+      msq = vect_setup_realignment (first_stmt, bsi, &realignment_token,\n+\t\t\t\t    alignment_support_scheme, NULL_TREE,\n+\t\t\t\t    &at_loop);\n+      if (alignment_support_scheme == dr_explicit_realign_optimized)\n+\t{\n+\t  phi = SSA_NAME_DEF_STMT (msq);\n+\t  offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n+\t}\n     }\n+  else\n+    at_loop = loop;\n \n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     { \n       /* 1. Create the vector pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, offset, &dummy,\n-                                                &ptr_incr, false, NULL_TREE);\n+        dataref_ptr = vect_create_data_ref_ptr (first_stmt,\n+\t\t\t\t\t        at_loop, offset, \n+\t\t\t\t\t\t&dummy, &ptr_incr, false, \n+\t\t\t\t\t\tNULL_TREE, &inv_p);\n       else\n-        dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n+        dataref_ptr = \n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\n \n       for (i = 0; i < group_size; i++)\n \t{\n \t  /* 2. Create the vector-load in the loop.  */\n-\t  switch (alignment_support_cheme)\n+\t  switch (alignment_support_scheme)\n \t    {\n \t    case dr_aligned:\n \t      gcc_assert (aligned_access_p (first_dr));\n@@ -4992,14 +5314,39 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t\tint mis = DR_MISALIGNMENT (first_dr);\n \t\ttree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n \n-\t\tgcc_assert (!aligned_access_p (first_dr));\n \t\ttmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n \t\tdata_ref =\n \t\t  build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n \t\tbreak;\n \t      }\n-\t    case dr_unaligned_software_pipeline:\n-\t      gcc_assert (!aligned_access_p (first_dr));\n+\t    case dr_explicit_realign:\n+\t      {\n+\t\ttree ptr, bump;\n+\t\ttree vs_minus_1 = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n+\n+\t\tif (compute_in_loop)\n+\t\t  msq = vect_setup_realignment (first_stmt, bsi, \n+\t\t\t\t\t\t&realignment_token,\n+\t\t\t\t\t\tdr_explicit_realign, \n+\t\t\t\t\t\tdataref_ptr, NULL);\n+\n+\t\tdata_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+\t\tvec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t\tnew_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n+\t\tnew_temp = make_ssa_name (vec_dest, new_stmt);\n+\t\tGIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\t\tvect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t\tcopy_virtual_operands (new_stmt, stmt);\n+\t\tmark_symbols_for_renaming (new_stmt);\n+\t\tmsq = new_temp;\n+\n+\t\tbump = size_binop (MULT_EXPR, vs_minus_1,\n+\t\t\t\t   TYPE_SIZE_UNIT (scalar_type));\n+\t\tptr = bump_vector_ptr (dataref_ptr, NULL_TREE, bsi, stmt, bump);\n+\t        data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n+\t        break;\n+\t      }\n+\t    case dr_explicit_realign_optimized:\n \t      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n \t      break;\n \t    default:\n@@ -5012,29 +5359,70 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n \t  mark_symbols_for_renaming (new_stmt);\n \n-\t  /* 3. Handle explicit realignment if necessary/supported.  */\n-\t  if (alignment_support_cheme == dr_unaligned_software_pipeline)\n+\t  /* 3. Handle explicit realignment if necessary/supported. Create in\n+\t\tloop: vec_dest = realign_load (msq, lsq, realignment_token)  */\n+\t  if (alignment_support_scheme == dr_explicit_realign_optimized\n+\t      || alignment_support_scheme == dr_explicit_realign)\n \t    {\n-\t      /* Create in loop: \n-\t\t <vec_dest = realign_load (msq, lsq, realignment_token)>  */\n \t      lsq = GIMPLE_STMT_OPERAND (new_stmt, 0);\n \t      if (!realignment_token)\n \t\trealignment_token = dataref_ptr;\n \t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-\t      new_stmt =\n-\t\tbuild3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n+\t      new_stmt = build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, \n+\t\t\t\t realignment_token);\n \t      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-\t      if (i == group_size - 1 && j == ncopies - 1)\n-\t\tadd_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n-\t      msq = lsq;\n+\n+\t      if (alignment_support_scheme == dr_explicit_realign_optimized)\n+\t\t{\n+\t\t  if (i == group_size - 1 && j == ncopies - 1)\n+\t\t    add_phi_arg (phi, lsq, loop_latch_edge (containing_loop));\n+\t\t  msq = lsq;\n+\t\t}\n+\t    }\n+\n+\t  /* 4. Handle invariant-load.  */\n+\t  if (inv_p)\n+\t    {\n+\t      gcc_assert (!strided_load);\n+\t      gcc_assert (nested_in_vect_loop_p (loop, stmt));\n+\t      if (j == 0)\n+\t\t{\n+\t\t  int k;\n+\t\t  tree t = NULL_TREE;\n+\t\t  tree vec_inv, bitpos, bitsize = TYPE_SIZE (scalar_type);\n+\n+\t\t  /* CHECKME: bitpos depends on endianess?  */\n+\t\t  bitpos = bitsize_zero_node;\n+\t\t  vec_inv = build3 (BIT_FIELD_REF, scalar_type, new_temp, \n+\t\t\t\t\t\t\t    bitsize, bitpos);\n+\t\t  BIT_FIELD_REF_UNSIGNED (vec_inv) = \n+\t\t\t\t\t\t TYPE_UNSIGNED (scalar_type);\n+\t\t  vec_dest = \n+\t\t\tvect_create_destination_var (scalar_dest, NULL_TREE);\n+\t\t  new_stmt = build_gimple_modify_stmt (vec_dest, vec_inv);\n+                  new_temp = make_ssa_name (vec_dest, new_stmt);\n+                  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+                  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\n+\t\t  for (k = nunits - 1; k >= 0; --k)\n+\t\t    t = tree_cons (NULL_TREE, new_temp, t);\n+\t\t  /* FIXME: use build_constructor directly.  */\n+\t\t  vec_inv = build_constructor_from_list (vectype, t);\n+\t\t  new_temp = vect_init_vector (stmt, vec_inv, vectype, bsi);\n+\t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable (); /* FORNOW. */\n \t    }\n+\n \t  if (strided_load)\n \t    VEC_quick_push (tree, dr_chain, new_temp);\n \t  if (i < group_size - 1)\n-\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\t  \n+\t    dataref_ptr = \n+\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\t  \n \t}\n \n       if (strided_load)\n@@ -5805,8 +6193,8 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   else\n     {\n       tree new_stmts = NULL_TREE;\n-      tree start_addr =\n-        vect_create_addr_base_for_vector_ref (dr_stmt, &new_stmts, NULL_TREE);\n+      tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt, \n+\t\t\t\t\t\t&new_stmts, NULL_TREE, loop);\n       tree ptr_type = TREE_TYPE (start_addr);\n       tree size = TYPE_SIZE (ptr_type);\n       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);\n@@ -5979,6 +6367,7 @@ static tree\n vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n                                    tree *cond_expr_stmt_list)\n {\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   VEC(tree,heap) *may_misalign_stmts\n     = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo);\n   tree ref_stmt, tmp;\n@@ -6014,8 +6403,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n \n       /* create: addr_tmp = (int)(address_of_first_vector) */\n       addr_base = vect_create_addr_base_for_vector_ref (ref_stmt, \n-\t\t\t\t\t\t\t&new_stmt_list, \n-\t\t\t\t\t\t\tNULL_TREE);\n+\t\t\t\t\t&new_stmt_list, NULL_TREE, loop);\n \n       if (new_stmt_list != NULL_TREE)\n         append_to_statement_list_force (new_stmt_list, cond_expr_stmt_list);\n@@ -6087,7 +6475,7 @@ vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n {\n   tree segment_length;\n \n-  if (vect_supportable_dr_alignment (dr) == dr_unaligned_software_pipeline)\n+  if (vect_supportable_dr_alignment (dr) == dr_explicit_realign_optimized)\n     {\n       tree vector_size =\n         build_int_cst (integer_type_node,\n@@ -6100,8 +6488,6 @@ vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n \t    fold_build2 (MULT_EXPR, integer_type_node, DR_STEP (dr),\n \t\t\t vect_factor),\n \t    vector_size));\n-\n-\n     }\n   else\n     {\n@@ -6139,6 +6525,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \t\t\t\t   tree * cond_expr,\n \t\t\t\t   tree * cond_expr_stmt_list)\n {\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   VEC (ddr_p, heap) * may_alias_ddrs =\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n   tree vect_factor =\n@@ -6167,10 +6554,10 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n       tree addr_base_a =\n         vect_create_addr_base_for_vector_ref (stmt_a, cond_expr_stmt_list,\n-\t\t\t\t\t      NULL_TREE);\n+\t\t\t\t\t      NULL_TREE, loop);\n       tree addr_base_b =\n         vect_create_addr_base_for_vector_ref (stmt_b, cond_expr_stmt_list,\n-\t\t\t\t\t      NULL_TREE);\n+\t\t\t\t\t      NULL_TREE, loop);\n \n       tree segment_length_a = vect_vfa_segment_size (DDR_A (ddr), vect_factor);\n       tree segment_length_b = vect_vfa_segment_size (DDR_B (ddr), vect_factor);"}, {"sha": "372334dddd9ae7898a172be19c1839ba0a6f6bb9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 93, "deletions": 4, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -1345,6 +1345,13 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n   STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n+\n+  STMT_VINFO_DR_BASE_ADDRESS (res) = NULL;\n+  STMT_VINFO_DR_OFFSET (res) = NULL;\n+  STMT_VINFO_DR_INIT (res) = NULL;\n+  STMT_VINFO_DR_STEP (res) = NULL;\n+  STMT_VINFO_DR_ALIGNED_TO (res) = NULL;\n+\n   if (TREE_CODE (stmt) == PHI_NODE && is_loop_header_bb_p (bb_for_stmt (stmt)))\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n   else\n@@ -1655,21 +1662,103 @@ get_vectype_for_scalar_type (tree scalar_type)\n enum dr_alignment_support\n vect_supportable_dr_alignment (struct data_reference *dr)\n {\n-  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr)));\n+  tree stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   enum machine_mode mode = (int) TYPE_MODE (vectype);\n+  struct loop *vect_loop = LOOP_VINFO_LOOP (STMT_VINFO_LOOP_VINFO (stmt_info));\n+  bool nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n+  bool invariant_in_outerloop = false;\n \n   if (aligned_access_p (dr))\n     return dr_aligned;\n \n+  if (nested_in_vect_loop)\n+    {\n+      tree outerloop_step = STMT_VINFO_DR_STEP (stmt_info);\n+      invariant_in_outerloop =\n+\t(tree_int_cst_compare (outerloop_step, size_zero_node) == 0);\n+    }\n+\n   /* Possibly unaligned access.  */\n+\n+  /* We can choose between using the implicit realignment scheme (generating\n+     a misaligned_move stmt) and the explicit realignment scheme (generating\n+     aligned loads with a REALIGN_LOAD). There are two variants to the explicit\n+     realignment scheme: optimized, and unoptimized.\n+     We can optimize the realignment only if the step between consecutive\n+     vector loads is equal to the vector size.  Since the vector memory\n+     accesses advance in steps of VS (Vector Size) in the vectorized loop, it\n+     is guaranteed that the misalignment amount remains the same throughout the\n+     execution of the vectorized loop.  Therefore, we can create the\n+     \"realignment token\" (the permutation mask that is passed to REALIGN_LOAD)\n+     at the loop preheader.\n+\n+     However, in the case of outer-loop vectorization, when vectorizing a\n+     memory access in the inner-loop nested within the LOOP that is now being\n+     vectorized, while it is guaranteed that the misalignment of the\n+     vectorized memory access will remain the same in different outer-loop\n+     iterations, it is *not* guaranteed that is will remain the same throughout\n+     the execution of the inner-loop.  This is because the inner-loop advances\n+     with the original scalar step (and not in steps of VS).  If the inner-loop\n+     step happens to be a multiple of VS, then the misalignment remaines fixed\n+     and we can use the optimized realignment scheme.  For example:\n+\n+      for (i=0; i<N; i++)\n+        for (j=0; j<M; j++)\n+          s += a[i+j];\n+\n+     When vectorizing the i-loop in the above example, the step between\n+     consecutive vector loads is 1, and so the misalignment does not remain\n+     fixed across the execution of the inner-loop, and the realignment cannot\n+     be optimized (as illustrated in the following pseudo vectorized loop):\n+\n+      for (i=0; i<N; i+=4)\n+        for (j=0; j<M; j++){\n+          vs += vp[i+j]; // misalignment of &vp[i+j] is {0,1,2,3,0,1,2,3,...}\n+                         // when j is {0,1,2,3,4,5,6,7,...} respectively.\n+                         // (assuming that we start from an aligned address).\n+          }\n+\n+     We therefore have to use the unoptimized realignment scheme:\n+\n+      for (i=0; i<N; i+=4)\n+          for (j=k; j<M; j+=4)\n+          vs += vp[i+j]; // misalignment of &vp[i+j] is always k (assuming\n+                           // that the misalignment of the initial address is\n+                           // 0).\n+\n+     The loop can then be vectorized as follows:\n+\n+      for (k=0; k<4; k++){\n+        rt = get_realignment_token (&vp[k]);\n+        for (i=0; i<N; i+=4){\n+          v1 = vp[i+k];\n+          for (j=k; j<M; j+=4){\n+            v2 = vp[i+j+VS-1];\n+            va = REALIGN_LOAD <v1,v2,rt>;\n+            vs += va;\n+            v1 = v2;\n+          }\n+        }\n+    } */\n+\n   if (DR_IS_READ (dr))\n     {\n-      if (optab_handler (vec_realign_load_optab, mode)->insn_code != CODE_FOR_nothing\n+      if (optab_handler (vec_realign_load_optab, mode)->insn_code != \n+\t\t\t\t\t\t   \t     CODE_FOR_nothing\n \t  && (!targetm.vectorize.builtin_mask_for_load\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n-\treturn dr_unaligned_software_pipeline;\n+\t{\n+\t    if (nested_in_vect_loop\n+\t\t&& TREE_INT_CST_LOW (DR_STEP (dr)) != UNITS_PER_SIMD_WORD)\n+\t      return dr_explicit_realign;\n+\t    else\n+\t      return dr_explicit_realign_optimized;\n+\t}\n \n-      if (optab_handler (movmisalign_optab, mode)->insn_code != CODE_FOR_nothing)\n+      if (optab_handler (movmisalign_optab, mode)->insn_code != \n+\t\t\t\t\t\t\t     CODE_FOR_nothing)\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }"}, {"sha": "ad7ccea4b23f6bf40a2f4ddfcea32f49aafa53f3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468c2ac0cc95f86736cc1879a8af0d6de9f81663/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=468c2ac0cc95f86736cc1879a8af0d6de9f81663", "patch": "@@ -53,7 +53,8 @@ enum operation_type {\n enum dr_alignment_support {\n   dr_unaligned_unsupported,\n   dr_unaligned_supported,\n-  dr_unaligned_software_pipeline,\n+  dr_explicit_realign,\n+  dr_explicit_realign_optimized,\n   dr_aligned\n };\n \n@@ -249,9 +250,18 @@ typedef struct _stmt_vec_info {\n      data-ref (array/pointer/struct access). A GIMPLE stmt is expected to have \n      at most one such data-ref.  **/\n \n-  /* Information about the data-ref (access function, etc).  */\n+  /* Information about the data-ref (access function, etc),\n+     relative to the inner-most containing loop.  */\n   struct data_reference *data_ref_info;\n \n+  /* Information about the data-ref relative to this loop\n+     nest (the loop that is being considered for vectorization).  */\n+  tree dr_base_address;\n+  tree dr_init;\n+  tree dr_offset;\n+  tree dr_step;\n+  tree dr_aligned_to;\n+\n   /* Stmt is part of some pattern (computation idiom)  */\n   bool in_pattern_p;\n \n@@ -310,6 +320,13 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECTYPE(S)              (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)             (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n+\n+#define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address\n+#define STMT_VINFO_DR_INIT(S)              (S)->dr_init\n+#define STMT_VINFO_DR_OFFSET(S)            (S)->dr_offset\n+#define STMT_VINFO_DR_STEP(S)              (S)->dr_step\n+#define STMT_VINFO_DR_ALIGNED_TO(S)        (S)->dr_aligned_to\n+\n #define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n #define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n #define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs"}]}