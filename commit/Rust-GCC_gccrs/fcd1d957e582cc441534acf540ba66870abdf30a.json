{"sha": "fcd1d957e582cc441534acf540ba66870abdf30a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNkMWQ5NTdlNTgyY2M0NDE1MzRhY2Y1NDBiYTY2ODcwYWJkZjMwYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:42:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:42:36Z"}, "message": "sem_ch10.ads, [...] (Analyze_Compilation_Unit): Disable check on obsolescent withed unit in case of limited-withed units.\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch10.ads, sem_ch10.adb (Analyze_Compilation_Unit): Disable check\n\ton obsolescent withed unit in case of limited-withed units.\n\t(Analyze_Compilation_Unit): Add guard to code that removed an\n\tinstantiation from visibility, to prevent compiler aborts when\n\tinstantiation is abandoned early on.\n\t(Install_Limited_Withed_Unit): Recognize a limited-with clause on the\n\tcurrent unit being analyzed, and Distinguish local incomplete types\n\tfrom limited views of types declared elsewhere.\n\t(Build_Limited_Views.Decorate_Tagged_Type): Add documentation\n\tto state that the class-wide entity is shared by the limited-view\n\tand the full-view.\n\t(Analyze_With_Clause): Improve placement of flag for case of\n\tunimplemented unit.\n\t(Analyze_With_Clause): Recognize use of GNAT.Exception_Traces in a\n\tmanner similar to GNAT.Current_Exception. This is a violation of\n\trestriction (No_Exception_Propagation), and also inhibits the\n\toptimization of local raise to goto.\n\t(Analyze_With_Clause): Check for Most_Recent_Exception being with'ed,\n\tand if so set Most_Recent_Exception_Used flag in Opt, and also check\n\tfor violation of restriction No_Exception_Propagation.\n\nFrom-SVN: r125447", "tree": {"sha": "298947097aca76e99bed3f60f7d6ffc1ab05de20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/298947097aca76e99bed3f60f7d6ffc1ab05de20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcd1d957e582cc441534acf540ba66870abdf30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd1d957e582cc441534acf540ba66870abdf30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcd1d957e582cc441534acf540ba66870abdf30a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd1d957e582cc441534acf540ba66870abdf30a/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f0d9574d38e48c0faaf4692fadfb203871f68e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0d9574d38e48c0faaf4692fadfb203871f68e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f0d9574d38e48c0faaf4692fadfb203871f68e3"}], "stats": {"total": 572, "additions": 85, "deletions": 487}, "files": [{"sha": "fd9b6ffbd11d1807b1f7468aea8e5bb800764125", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 85, "deletions": 486, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd1d957e582cc441534acf540ba66870abdf30a/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd1d957e582cc441534acf540ba66870abdf30a/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=fcd1d957e582cc441534acf540ba66870abdf30a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,7 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -61,7 +62,6 @@ with Snames;   use Snames;\n with Style;    use Style;\n with Stylesw;  use Stylesw;\n with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n with Uname;    use Uname;\n \n package body Sem_Ch10 is\n@@ -84,10 +84,6 @@ package body Sem_Ch10 is\n    --  Check whether the source for the body of a compilation unit must\n    --  be included in a standalone library.\n \n-   procedure Check_With_Type_Clauses (N : Node_Id);\n-   --  If N is a body, verify that any with_type clauses on the spec, or\n-   --  on the spec of any parent, have a matching with_clause.\n-\n    procedure Check_Private_Child_Unit (N : Node_Id);\n    --  If a with_clause mentions a private child unit, the compilation\n    --  unit must be a member of the same family, as described in 10.1.2 (8).\n@@ -168,11 +164,6 @@ package body Sem_Ch10 is\n    --  Lib_Unit can also be a subprogram body that acts as its own spec. If\n    --  the Parent_Spec is  non-empty, this is also a child unit.\n \n-   procedure Remove_With_Type_Clause (Name : Node_Id);\n-   --  Remove imported type and its enclosing package from visibility, and\n-   --  remove attributes of imported type so they don't interfere with its\n-   --  analysis (should it appear otherwise in the context).\n-\n    procedure Remove_Context_Clauses (N : Node_Id);\n    --  Subsidiary of previous one. Remove use_ and with_clauses\n \n@@ -200,6 +191,10 @@ package body Sem_Ch10 is\n    --  entity for which the proper body provides a completion. Subprogram\n    --  stubs are handled differently because they can be declarations.\n \n+   procedure sm;\n+   --  A dummy procedure, for debugging use, called just before analyzing the\n+   --  main unit (after dealing with any context clauses).\n+\n    --------------------------\n    -- Limited_With_Clauses --\n    --------------------------\n@@ -373,7 +368,7 @@ package body Sem_Ch10 is\n                      Next (Use_Item);\n                   end loop;\n \n-               --  Type use clause\n+               --  USE TYPE clause\n \n                elsif Nkind (Cont_Item) = N_Use_Type_Clause\n                  and then not Used_Type_Or_Elab\n@@ -721,7 +716,7 @@ package body Sem_Ch10 is\n             Unum := Get_Cunit_Unit_Number (N);\n             Par_Spec_Name := Get_Parent_Spec_Name (Unit_Name (Unum));\n \n-            if Par_Spec_Name /= No_Name then\n+            if Par_Spec_Name /= No_Unit_Name then\n                Unum :=\n                  Load_Unit\n                    (Load_Name  => Par_Spec_Name,\n@@ -821,8 +816,15 @@ package body Sem_Ch10 is\n       end if;\n \n       --  All components of the context: with-clauses, library unit, ancestors\n-      --  if any, (and their context)  are analyzed and installed. Now analyze\n-      --  the unit itself, which is either a package, subprogram spec or body.\n+      --  if any, (and their context)  are analyzed and installed.\n+\n+      --  Call special debug routine sm if this is the main unit\n+\n+      if Current_Sem_Unit = Main_Unit then\n+         sm;\n+      end if;\n+\n+      --  Now analyze the unit (package, subprogram spec, body) itself\n \n       Analyze (Unit_Node);\n \n@@ -914,9 +916,11 @@ package body Sem_Ch10 is\n \n       --  If the unit is an instantiation whose body will be elaborated\n       --  for inlining purposes, use the the proper entity of the instance.\n+      --  The entity may be missing if the instantiation was illegal.\n \n       elsif Nkind (Unit_Node) = N_Package_Instantiation\n         and then not Error_Posted (Unit_Node)\n+        and then Present (Instance_Spec (Unit_Node))\n       then\n          Remove_Unit_From_Visibility\n            (Defining_Entity (Instance_Spec (Unit_Node)));\n@@ -1046,9 +1050,9 @@ package body Sem_Ch10 is\n \n       if Comes_From_Source (N)\n         and then\n-          (Nkind (Unit (N)) =  N_Package_Declaration         or else\n-           Nkind (Unit (N)) =  N_Generic_Package_Declaration or else\n-           Nkind (Unit (N)) =  N_Subprogram_Declaration      or else\n+          (Nkind (Unit (N)) =  N_Package_Declaration            or else\n+           Nkind (Unit (N)) =  N_Generic_Package_Declaration    or else\n+           Nkind (Unit (N)) =  N_Subprogram_Declaration         or else\n            Nkind (Unit (N)) =  N_Generic_Subprogram_Declaration)\n       then\n          declare\n@@ -1064,6 +1068,11 @@ package body Sem_Ch10 is\n             --  allow for this even if -gnatE is not set, since a client\n             --  may be compiled in -gnatE mode and reference the entity.\n \n+            --  These entities are also used by the binder to prevent multiple\n+            --  attempts to execute the elaboration code for the library case\n+            --  where the elaboration routine might otherwise be called more\n+            --  than once.\n+\n             --  Case of units which do not require elaboration checks\n \n             if\n@@ -1159,7 +1168,7 @@ package body Sem_Ch10 is\n          --  Push current compilation unit as scope, so that the test for\n          --  being within an obsolescent unit will work correctly.\n \n-         New_Scope (Defining_Entity (Unit (N)));\n+         Push_Scope (Defining_Entity (Unit (N)));\n \n          --  Loop through context items to deal with with clauses\n \n@@ -1171,7 +1180,14 @@ package body Sem_Ch10 is\n          begin\n             Item := First (Context_Items (N));\n             while Present (Item) loop\n-               if Nkind (Item) = N_With_Clause then\n+               if Nkind (Item) = N_With_Clause\n+\n+                  --  Suppress this check in limited-withed units. Further work\n+                  --  needed here if we decide to incorporate this check on\n+                  --  limited-withed units.\n+\n+                 and then not Limited_Present (Item)\n+               then\n                   Nam := Name (Item);\n                   Ent := Entity (Nam);\n \n@@ -1638,11 +1654,11 @@ package body Sem_Ch10 is\n             if Original_Operating_Mode = Generate_Code\n               and then Unum = No_Unit\n             then\n-               Error_Msg_Name_1 := Subunit_Name;\n-               Error_Msg_Name_2 :=\n+               Error_Msg_Unit_1 := Subunit_Name;\n+               Error_Msg_File_1 :=\n                  Get_File_Name (Subunit_Name, Subunit => True);\n                Error_Msg_N\n-                 (\"subunit% in file{ not found?\", N);\n+                 (\"subunit$$ in file{ not found?\", N);\n                Subunits_Missing := True;\n             end if;\n \n@@ -1939,7 +1955,7 @@ package body Sem_Ch10 is\n             Install_Siblings (Enclosing_Child, L);\n          end if;\n \n-         New_Scope (Scop);\n+         Push_Scope (Scop);\n \n          if Scop /= Par_Unit then\n             Set_Is_Immediately_Visible (Scop);\n@@ -2168,7 +2184,7 @@ package body Sem_Ch10 is\n \n       Unit_Kind : constant Node_Kind :=\n                     Nkind (Original_Node (Unit (Library_Unit (N))));\n-\n+      Nam       : constant Node_Id := Name (N);\n       E_Name    : Entity_Id;\n       Par_Name  : Entity_Id;\n       Pref      : Node_Id;\n@@ -2218,7 +2234,6 @@ package body Sem_Ch10 is\n       end if;\n \n       U := Unit (Library_Unit (N));\n-      Check_Restriction_No_Dependence (Name (N), N);\n       Intunit := Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit));\n \n       --  Following checks are skipped for dummy packages (those supplied\n@@ -2231,10 +2246,26 @@ package body Sem_Ch10 is\n          --  is an internal unit unless we are compiling the internal\n          --  unit as the main unit. We also skip this for dummy packages.\n \n+         Check_Restriction_No_Dependence (Nam, N);\n+\n          if not Intunit or else Current_Sem_Unit = Main_Unit then\n             Check_Restricted_Unit (Unit_Name (Get_Source_Unit (U)), N);\n          end if;\n \n+         --  Deal with special case of GNAT.Current_Exceptions which interacts\n+         --  with the optimization of local raise statements into gotos.\n+\n+         if Nkind (Nam) = N_Selected_Component\n+           and then Nkind (Prefix (Nam)) = N_Identifier\n+           and then Chars (Prefix (Nam)) = Name_Gnat\n+           and then (Chars (Selector_Name (Nam)) = Name_Most_Recent_Exception\n+                       or else\n+                     Chars (Selector_Name (Nam)) = Name_Exception_Traces)\n+         then\n+            Check_Restriction (No_Exception_Propagation, N);\n+            Special_Exception_Package_Used := True;\n+         end if;\n+\n          --  Check for inappropriate with of internal implementation unit\n          --  if we are currently compiling the main unit and the main unit\n          --  is itself not an internal unit. We do not issue this message\n@@ -2252,8 +2283,8 @@ package body Sem_Ch10 is\n \n             begin\n                if U_Kind = Implementation_Unit then\n-                  Error_Msg_N (\"& is an internal 'G'N'A'T unit?\", Name (N));\n-                  Error_Msg_N\n+                  Error_Msg_F (\"& is an internal 'G'N'A'T unit?\", Name (N));\n+                  Error_Msg_F\n                     (\"\\use of this unit is non-portable \" &\n                      \"and version-dependent?\",\n                      Name (N));\n@@ -2403,348 +2434,6 @@ package body Sem_Ch10 is\n       end if;\n    end Analyze_With_Clause;\n \n-   ------------------------------\n-   -- Analyze_With_Type_Clause --\n-   ------------------------------\n-\n-   procedure Analyze_With_Type_Clause (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Nam  : constant Node_Id    := Name (N);\n-      Pack : Node_Id;\n-      Decl : Node_Id;\n-      P    : Entity_Id;\n-      Unum : Unit_Number_Type;\n-      Sel  : Node_Id;\n-\n-      procedure Decorate_Tagged_Type (T : Entity_Id);\n-      --  Set basic attributes of type, including its class_wide type\n-\n-      function In_Chain (E : Entity_Id) return Boolean;\n-      --  Check that the imported type is not already in the homonym chain,\n-      --  for example through a with_type clause in a parent unit.\n-\n-      --------------------------\n-      -- Decorate_Tagged_Type --\n-      --------------------------\n-\n-      procedure Decorate_Tagged_Type (T : Entity_Id) is\n-         CW : Entity_Id;\n-\n-      begin\n-         Set_Ekind (T, E_Record_Type);\n-         Set_Is_Tagged_Type (T);\n-         Set_Etype (T, T);\n-         Set_From_With_Type (T);\n-         Set_Scope (T, P);\n-\n-         if not In_Chain (T) then\n-            Set_Homonym (T, Current_Entity (T));\n-            Set_Current_Entity (T);\n-         end if;\n-\n-         --  Build bogus class_wide type, if not previously done\n-\n-         if No (Class_Wide_Type (T)) then\n-            CW := Make_Defining_Identifier (Loc,  New_Internal_Name ('S'));\n-\n-            Set_Ekind            (CW, E_Class_Wide_Type);\n-            Set_Etype            (CW, T);\n-            Set_Scope            (CW, P);\n-            Set_Is_Tagged_Type   (CW);\n-            Set_Is_First_Subtype (CW, True);\n-            Init_Size_Align      (CW);\n-            Set_Has_Unknown_Discriminants\n-                                 (CW, True);\n-            Set_Class_Wide_Type  (CW, CW);\n-            Set_Equivalent_Type  (CW, Empty);\n-            Set_From_With_Type   (CW);\n-\n-            Set_Class_Wide_Type (T, CW);\n-         end if;\n-      end Decorate_Tagged_Type;\n-\n-      --------------\n-      -- In_Chain --\n-      --------------\n-\n-      function In_Chain (E : Entity_Id) return Boolean is\n-         H : Entity_Id;\n-\n-      begin\n-         H := Current_Entity (E);\n-         while Present (H) loop\n-            if H = E then\n-               return True;\n-            else\n-               H := Homonym (H);\n-            end if;\n-         end loop;\n-\n-         return False;\n-      end In_Chain;\n-\n-   --  Start of processing for Analyze_With_Type_Clause\n-\n-   begin\n-      if Nkind (Nam) = N_Selected_Component then\n-         Pack := New_Copy_Tree (Prefix (Nam));\n-         Sel  := Selector_Name (Nam);\n-\n-      else\n-         Error_Msg_N (\"illegal name for imported type\", Nam);\n-         return;\n-      end if;\n-\n-      Decl :=\n-        Make_Package_Declaration (Loc,\n-          Specification =>\n-             (Make_Package_Specification (Loc,\n-               Defining_Unit_Name   => Pack,\n-               Visible_Declarations => New_List,\n-               End_Label            => Empty)));\n-\n-      Unum :=\n-        Load_Unit\n-          (Load_Name  => Get_Unit_Name (Decl),\n-           Required   => True,\n-           Subunit    => False,\n-           Error_Node => Nam);\n-\n-      if Unum = No_Unit\n-         or else Nkind (Unit (Cunit (Unum))) /= N_Package_Declaration\n-      then\n-         Error_Msg_N (\"imported type must be declared in package\", Nam);\n-         return;\n-\n-      elsif Unum = Current_Sem_Unit then\n-\n-         --  If type is defined in unit being analyzed, then the clause\n-         --  is redundant.\n-\n-         return;\n-\n-      else\n-         P := Cunit_Entity (Unum);\n-      end if;\n-\n-      --  Find declaration for imported type, and set its basic attributes\n-      --  if it has not been analyzed (which will be the case if there is\n-      --  circular dependence).\n-\n-      declare\n-         Decl : Node_Id;\n-         Typ  : Entity_Id;\n-\n-      begin\n-         if not Analyzed (Cunit (Unum))\n-           and then not From_With_Type (P)\n-         then\n-            Set_Ekind (P, E_Package);\n-            Set_Etype (P, Standard_Void_Type);\n-            Set_From_With_Type (P);\n-            Set_Scope (P, Standard_Standard);\n-            Set_Homonym (P, Current_Entity (P));\n-            Set_Current_Entity (P);\n-\n-         elsif Analyzed (Cunit (Unum))\n-           and then Is_Child_Unit (P)\n-         then\n-            --  If the child unit is already in scope, indicate that it is\n-            --  visible, and remains so after intervening calls to rtsfind.\n-\n-            Set_Is_Visible_Child_Unit (P);\n-         end if;\n-\n-         if Nkind (Parent (P)) = N_Defining_Program_Unit_Name then\n-\n-            --  Make parent packages visible\n-\n-            declare\n-               Parent_Comp : Node_Id;\n-               Parent_Id   : Entity_Id;\n-               Child       : Entity_Id;\n-\n-            begin\n-               Child   := P;\n-               Parent_Comp := Parent_Spec (Unit (Cunit (Unum)));\n-\n-               loop\n-                  Parent_Id := Defining_Entity (Unit (Parent_Comp));\n-                  Set_Scope (Child, Parent_Id);\n-\n-                  --  The type may be imported from a child unit, in which\n-                  --  case the current compilation appears in the name. Do\n-                  --  not change its visibility here because it will conflict\n-                  --  with the subsequent normal processing.\n-\n-                  if not Analyzed (Unit_Declaration_Node (Parent_Id))\n-                    and then Parent_Id /= Cunit_Entity (Current_Sem_Unit)\n-                  then\n-                     Set_Ekind (Parent_Id, E_Package);\n-                     Set_Etype (Parent_Id, Standard_Void_Type);\n-\n-                     --  The same package may appear is several with_type\n-                     --  clauses.\n-\n-                     if not From_With_Type (Parent_Id) then\n-                        Set_Homonym (Parent_Id, Current_Entity (Parent_Id));\n-                        Set_Current_Entity (Parent_Id);\n-                        Set_From_With_Type (Parent_Id);\n-                     end if;\n-                  end if;\n-\n-                  Set_Is_Immediately_Visible (Parent_Id);\n-\n-                  Child := Parent_Id;\n-                  Parent_Comp := Parent_Spec (Unit (Parent_Comp));\n-                  exit when No (Parent_Comp);\n-               end loop;\n-\n-               Set_Scope (Parent_Id, Standard_Standard);\n-            end;\n-         end if;\n-\n-         --  Even if analyzed, the package may not be currently visible. It\n-         --  must be while the with_type clause is active.\n-\n-         Set_Is_Immediately_Visible (P);\n-\n-         Decl :=\n-           First (Visible_Declarations (Specification (Unit (Cunit (Unum)))));\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Full_Type_Declaration\n-              and then Chars (Defining_Identifier (Decl)) = Chars (Sel)\n-            then\n-               Typ := Defining_Identifier (Decl);\n-\n-               if Tagged_Present (N) then\n-\n-                  --  The declaration must indicate that this is a tagged\n-                  --  type or a type extension.\n-\n-                  if (Nkind (Type_Definition (Decl)) = N_Record_Definition\n-                       and then Tagged_Present (Type_Definition (Decl)))\n-                    or else\n-                      (Nkind (Type_Definition (Decl))\n-                          = N_Derived_Type_Definition\n-                         and then Present\n-                           (Record_Extension_Part (Type_Definition (Decl))))\n-                  then\n-                     null;\n-                  else\n-                     Error_Msg_N (\"imported type is not a tagged type\", Nam);\n-                     return;\n-                  end if;\n-\n-                  if not Analyzed (Decl) then\n-\n-                     --  Unit is not currently visible. Add basic attributes\n-                     --  to type and build its class-wide type.\n-\n-                     Init_Size_Align (Typ);\n-                     Decorate_Tagged_Type (Typ);\n-                  end if;\n-\n-               else\n-                  if Nkind (Type_Definition (Decl))\n-                     /= N_Access_To_Object_Definition\n-                  then\n-                     Error_Msg_N\n-                      (\"imported type is not an access type\", Nam);\n-\n-                  elsif not Analyzed (Decl) then\n-                     Set_Ekind                    (Typ, E_Access_Type);\n-                     Set_Etype                    (Typ, Typ);\n-                     Set_Scope                    (Typ, P);\n-                     Init_Size                    (Typ, System_Address_Size);\n-                     Init_Alignment               (Typ);\n-                     Set_Directly_Designated_Type (Typ, Standard_Integer);\n-                     Set_From_With_Type           (Typ);\n-\n-                     if not In_Chain (Typ) then\n-                        Set_Homonym               (Typ, Current_Entity (Typ));\n-                        Set_Current_Entity        (Typ);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Set_Entity (Sel, Typ);\n-               return;\n-\n-            elsif ((Nkind (Decl) = N_Private_Type_Declaration\n-                      and then Tagged_Present (Decl))\n-                or else (Nkind (Decl) = N_Private_Extension_Declaration))\n-              and then Chars (Defining_Identifier (Decl)) = Chars (Sel)\n-            then\n-               Typ := Defining_Identifier (Decl);\n-\n-               if not Tagged_Present (N) then\n-                  Error_Msg_N (\"type must be declared tagged\", N);\n-\n-               elsif not Analyzed (Decl) then\n-                  Decorate_Tagged_Type (Typ);\n-               end if;\n-\n-               Set_Entity (Sel, Typ);\n-               Set_From_With_Type (Typ);\n-               return;\n-            end if;\n-\n-            Decl := Next (Decl);\n-         end loop;\n-\n-         Error_Msg_NE (\"not a visible access or tagged type in&\", Nam, P);\n-      end;\n-   end Analyze_With_Type_Clause;\n-\n-   -----------------------------\n-   -- Check_With_Type_Clauses --\n-   -----------------------------\n-\n-   procedure Check_With_Type_Clauses (N : Node_Id) is\n-      Lib_Unit : constant Node_Id := Unit (N);\n-\n-      procedure Check_Parent_Context (U : Node_Id);\n-      --  Examine context items of parent unit to locate with_type clauses\n-\n-      --------------------------\n-      -- Check_Parent_Context --\n-      --------------------------\n-\n-      procedure Check_Parent_Context (U : Node_Id) is\n-         Item : Node_Id;\n-\n-      begin\n-         Item := First (Context_Items (U));\n-         while Present (Item) loop\n-            if Nkind (Item) = N_With_Type_Clause\n-              and then not Error_Posted (Item)\n-              and then\n-                From_With_Type (Scope (Entity (Selector_Name (Name (Item)))))\n-            then\n-               Error_Msg_Sloc := Sloc (Item);\n-               Error_Msg_N (\"missing With_Clause for With_Type_Clause#\", N);\n-            end if;\n-\n-            Next (Item);\n-         end loop;\n-      end Check_Parent_Context;\n-\n-   --  Start of processing for Check_With_Type_Clauses\n-\n-   begin\n-      if Extensions_Allowed\n-        and then (Nkind (Lib_Unit) = N_Package_Body\n-                   or else Nkind (Lib_Unit) = N_Subprogram_Body)\n-      then\n-         Check_Parent_Context (Library_Unit (N));\n-\n-         if Is_Child_Spec (Unit (Library_Unit (N))) then\n-            Check_Parent_Context (Parent_Spec (Unit (Library_Unit (N))));\n-         end if;\n-      end if;\n-   end Check_With_Type_Clauses;\n-\n    ------------------------------\n    -- Check_Private_Child_Unit --\n    ------------------------------\n@@ -3164,7 +2853,6 @@ package body Sem_Ch10 is\n \n       Install_Limited_Context_Clauses (N);\n \n-      Check_With_Type_Clauses (N);\n    end Install_Context;\n \n    -----------------------------\n@@ -3332,15 +3020,6 @@ package body Sem_Ch10 is\n          elsif Nkind (Item) = N_Use_Type_Clause then\n             Analyze_Use_Type (Item);\n \n-         --  Case of WITH TYPE clause\n-\n-         --  A With_Type_Clause is processed when installing the context,\n-         --  because it is a visibility mechanism and does not create a\n-         --  semantic dependence on other units, as a With_Clause does.\n-\n-         elsif Nkind (Item) = N_With_Type_Clause then\n-            Analyze_With_Type_Clause (Item);\n-\n          --  case of PRAGMA\n \n          elsif Nkind (Item) = N_Pragma then\n@@ -3913,7 +3592,7 @@ package body Sem_Ch10 is\n            or else Private_Present (Parent (Lib_Unit)));\n \n       P_Spec := Specification (Unit_Declaration_Node (P_Name));\n-      New_Scope (P_Name);\n+      Push_Scope (P_Name);\n \n       --  Save current visibility of unit\n \n@@ -4207,6 +3886,16 @@ package body Sem_Ch10 is\n          return;\n       end if;\n \n+      --  Do not install the limited view if this is the unit being analyzed.\n+      --  This unusual case will happen when a unit has a limited_with clause\n+      --  on one of its children. The compilation of the child forces the\n+      --  load of the parent which tries to install the limited view of the\n+      --  child again.\n+\n+      if P = Cunit_Entity (Current_Sem_Unit) then\n+         return;\n+      end if;\n+\n       --  A common use of the limited-with is to have a limited-with\n       --  in the package spec, and a normal with in its package body.\n       --  For example:\n@@ -4369,7 +4058,9 @@ package body Sem_Ch10 is\n \n                   --  Handle incomplete types\n \n-                  if Ekind (Prev) = E_Incomplete_Type then\n+                  if Ekind (Prev) = E_Incomplete_Type\n+                    and then Present (Full_View (Prev))\n+                  then\n                      E := Full_View (Prev);\n                   else\n                      E := Prev;\n@@ -4800,6 +4491,9 @@ package body Sem_Ch10 is\n \n          --  Build corresponding class_wide type, if not previously done\n \n+         --  Warning: The class-wide entity is shared by the limited-view\n+         --  and the full-view.\n+\n          if No (Class_Wide_Type (T)) then\n             CW := Make_Defining_Identifier (Loc,  New_Internal_Name ('S'));\n \n@@ -5289,9 +4983,6 @@ package body Sem_Ch10 is\n \n          elsif Nkind (Item) = N_Use_Type_Clause then\n             End_Use_Type (Item);\n-\n-         elsif Nkind (Item) = N_With_Type_Clause then\n-            Remove_With_Type_Clause (Name (Item));\n          end if;\n \n          Next (Item);\n@@ -5517,105 +5208,6 @@ package body Sem_Ch10 is\n       end loop;\n    end Remove_Private_With_Clauses;\n \n-   -----------------------------\n-   -- Remove_With_Type_Clause --\n-   -----------------------------\n-\n-   procedure Remove_With_Type_Clause (Name : Node_Id) is\n-      Typ : Entity_Id;\n-      P   : Entity_Id;\n-\n-      procedure Unchain (E : Entity_Id);\n-      --  Remove entity from visibility list\n-\n-      -------------\n-      -- Unchain --\n-      -------------\n-\n-      procedure Unchain (E : Entity_Id) is\n-         Prev : Entity_Id;\n-\n-      begin\n-         Prev := Current_Entity (E);\n-\n-         --  Package entity may appear is several with_type_clauses, and\n-         --  may have been removed already.\n-\n-         if No (Prev) then\n-            return;\n-\n-         elsif Prev = E then\n-            Set_Name_Entity_Id (Chars (E), Homonym (E));\n-\n-         else\n-            while Present (Prev)\n-              and then Homonym (Prev) /= E\n-            loop\n-               Prev := Homonym (Prev);\n-            end loop;\n-\n-            if Present (Prev) then\n-               Set_Homonym (Prev, Homonym (E));\n-            end if;\n-         end if;\n-      end Unchain;\n-\n-   --  Start of processing for Remove_With_Type_Clause\n-\n-   begin\n-      if Nkind (Name) = N_Selected_Component then\n-         Typ := Entity (Selector_Name (Name));\n-\n-         --  If no Typ, then error in declaration, ignore\n-\n-         if No (Typ) then\n-            return;\n-         end if;\n-      else\n-         return;\n-      end if;\n-\n-      P := Scope (Typ);\n-\n-      --  If the exporting package has been analyzed, it has appeared in the\n-      --  context already and should be left alone. Otherwise, remove from\n-      --  visibility.\n-\n-      if not Analyzed (Unit_Declaration_Node (P)) then\n-         Unchain (P);\n-         Unchain (Typ);\n-         Set_Is_Frozen (Typ, False);\n-      end if;\n-\n-      if Ekind (Typ) = E_Record_Type then\n-         Set_From_With_Type (Class_Wide_Type (Typ), False);\n-         Set_From_With_Type (Typ, False);\n-      end if;\n-\n-      Set_From_With_Type (P, False);\n-\n-      --  If P is a child unit, remove parents as well\n-\n-      P := Scope (P);\n-      while Present (P)\n-        and then P /= Standard_Standard\n-      loop\n-         Set_From_With_Type (P, False);\n-\n-         if not Analyzed (Unit_Declaration_Node (P)) then\n-            Unchain (P);\n-         end if;\n-\n-         P := Scope (P);\n-      end loop;\n-\n-      --  The back-end needs to know that an access type is imported, so it\n-      --  does not need elaboration and can appear in a mutually recursive\n-      --  record definition, so the imported flag on an access  type is\n-      --  preserved.\n-\n-   end Remove_With_Type_Clause;\n-\n    ---------------------------------\n    -- Remove_Unit_From_Visibility --\n    ---------------------------------\n@@ -5638,9 +5230,17 @@ package body Sem_Ch10 is\n \n       Set_Is_Potentially_Use_Visible (Unit_Name, False);\n       Set_Is_Immediately_Visible     (Unit_Name, False);\n-\n    end Remove_Unit_From_Visibility;\n \n+   --------\n+   -- sm --\n+   --------\n+\n+   procedure sm is\n+   begin\n+      null;\n+   end sm;\n+\n    -------------\n    -- Unchain --\n    -------------\n@@ -5674,7 +5274,6 @@ package body Sem_Ch10 is\n          Write_Name (Chars (E));\n          Write_Eol;\n       end if;\n-\n    end Unchain;\n \n end Sem_Ch10;"}, {"sha": "e59189196b7f8d0f21ebabf891ed312035fa555b", "filename": "gcc/ada/sem_ch10.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd1d957e582cc441534acf540ba66870abdf30a/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd1d957e582cc441534acf540ba66870abdf30a/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=fcd1d957e582cc441534acf540ba66870abdf30a", "patch": "@@ -28,7 +28,6 @@ with Types; use Types;\n package Sem_Ch10 is\n    procedure Analyze_Compilation_Unit                   (N : Node_Id);\n    procedure Analyze_With_Clause                        (N : Node_Id);\n-   procedure Analyze_With_Type_Clause                   (N : Node_Id);\n    procedure Analyze_Subprogram_Body_Stub               (N : Node_Id);\n    procedure Analyze_Package_Body_Stub                  (N : Node_Id);\n    procedure Analyze_Task_Body_Stub                     (N : Node_Id);"}]}