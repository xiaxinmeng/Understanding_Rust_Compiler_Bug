{"sha": "2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVmYjllYWFlZGZhYTViM2QxOTRjMzE4NGExZDU2YjcwMmUyZmUzOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-11T17:30:01Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-13T07:34:48Z"}, "message": "Group tree-vrp.c by functionality.\n\nEarlier in this cycle there was some work by Giuliano Belinassi and\nmyself to refactor tree-vrp.c.  A lot of functions and globals were\nmoved into independent classes, but the haphazard layout remained.\nAssertion methods were indispersed with the propagation code, and with\nthe jump threading code, etc etc.\n\nThis series of patches moves things around so that common\nfunctionality is geographically close.  There is no change in\nbehavior.\n\nI know this is all slated to go in the next release, but finding\nthings in the current code base, even if just to compare with the\nranger, is difficult.\n\nSince I keep getting bit by aarch64 regressions, I've tested the whole\nset of patches on aarch64, as well as individually on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-vrp.c (struct assert_locus): Move.\n\t(class vrp_insert): Rename to vrp_asserts.\n\t(vrp_insert::build_assert_expr_for): Move to vrp_asserts.\n\t(fp_predicate): Same.\n\t(vrp_insert::dump): Same.\n\t(vrp_insert::register_new_assert_for): Same.\n\t(extract_code_and_val_from_cond_with_ops): Move.\n\t(vrp_insert::finish_register_edge_assert_for): Move to vrp_asserts.\n\t(maybe_set_nonzero_bits): Move.\n\t(vrp_insert::find_conditional_asserts): Move to vrp_asserts.\n\t(stmt_interesting_for_vrp): Move.\n\t(struct case_info): Move.\n\t(compare_case_labels): Move.\n\t(lhs_of_dominating_assert): Move.\n\t(find_case_label_index): Move.\n\t(find_case_label_range): Move.\n\t(class vrp_asserts): New.\n\t(vrp_asserts::build_assert_expr_for): Rename from vrp_insert.\n\t(vrp_asserts::dump): Same.\n\t(vrp_asserts::register_new_assert_for): Same.\n\t(vrp_asserts::finish_register_edge_assert_for): Same.\n\t(vrp_asserts::find_conditional_asserts): Same.\n\t(vrp_asserts::compare_case_labels): Same.\n\t(vrp_asserts::find_switch_asserts): Same.\n\t(vrp_asserts::find_assert_locations_in_bb): Same.\n\t(vrp_asserts::find_assert_locations): Same.\n\t(vrp_asserts::process_assert_insertions_for): Same.\n\t(vrp_asserts::compare_assert_loc): Same.\n\t(vrp_asserts::process_assert_insertions): Same.\n\t(vrp_asserts::insert_range_assertions): Same.\n\t(vrp_asserts::all_imm_uses_in_stmt_or_feed_cond): Same.\n\t(vrp_asserts::remove_range_assertions): Same.\n\t(class vrp_prop): Move.\n\t(all_imm_uses_in_stmt_or_feed_cond): Move.\n\t(vrp_prop::vrp_initialize): Move.\n\t(class vrp_folder): Move.\n\t(vrp_folder::fold_predicate_in): Move.\n\t(vrp_folder::fold_stmt): Move.\n\t(vrp_prop::initialize): Move.\n\t(vrp_prop::visit_stmt): Move.\n\t(enum ssa_prop_result): Move.\n\t(vrp_prop::visit_phi): Move.\n\t(vrp_prop::finalize): Move.\n\t(class vrp_dom_walker): Rename to...\n\t(class vrp_jump_threader): ...this.\n\t(vrp_jump_threader::before_dom_children): Rename from\n\tvrp_dom_walker.\n\t(simplify_stmt_for_jump_threading): Rename to...\n\t(vrp_jump_threader::simplify_stmt): ...here.\n\t(vrp_jump_threader::after_dom_children): Same.\n\t(identify_jump_threads): Move.\n\t(vrp_prop::vrp_finalize): Move array bounds setup code to...\n\t(execute_vrp): ...here.", "tree": {"sha": "8b5e062619a3b46b3a311d3da4bf29fb2a6cd222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b5e062619a3b46b3a311d3da4bf29fb2a6cd222"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4109adf2565626ce73b1a7c15e3e686dae69ab95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4109adf2565626ce73b1a7c15e3e686dae69ab95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4109adf2565626ce73b1a7c15e3e686dae69ab95"}], "stats": {"total": 2127, "additions": 1057, "deletions": 1070}, "files": [{"sha": "d3816ab569eac9ff32002dafd840a8d5efa6d20b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1057, "deletions": 1070, "changes": 2127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2efb9eaaedfaa5b3d194c3184a1d56b702e2fe39", "patch": "@@ -161,153 +161,6 @@ live_names::live_on_block_p (tree name, basic_block bb)\n \t  && bitmap_bit_p (live[bb->index], SSA_NAME_VERSION (name)));\n }\n \n-\n-/* Location information for ASSERT_EXPRs.  Each instance of this\n-   structure describes an ASSERT_EXPR for an SSA name.  Since a single\n-   SSA name may have more than one assertion associated with it, these\n-   locations are kept in a linked list attached to the corresponding\n-   SSA name.  */\n-struct assert_locus\n-{\n-  /* Basic block where the assertion would be inserted.  */\n-  basic_block bb;\n-\n-  /* Some assertions need to be inserted on an edge (e.g., assertions\n-     generated by COND_EXPRs).  In those cases, BB will be NULL.  */\n-  edge e;\n-\n-  /* Pointer to the statement that generated this assertion.  */\n-  gimple_stmt_iterator si;\n-\n-  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n-  enum tree_code comp_code;\n-\n-  /* Value being compared against.  */\n-  tree val;\n-\n-  /* Expression to compare.  */\n-  tree expr;\n-\n-  /* Next node in the linked list.  */\n-  assert_locus *next;\n-};\n-\n-class vrp_insert\n-{\n-public:\n-  vrp_insert (struct function *fn) : fun (fn) { }\n-\n-  /* Traverse the flowgraph looking for conditional jumps to insert range\n-     expressions.  These range expressions are meant to provide information\n-     to optimizations that need to reason in terms of value ranges.  They\n-     will not be expanded into RTL.  See method implementation comment\n-     for example.  */\n-  void insert_range_assertions ();\n-\n-  /* Convert range assertion expressions into the implied copies and\n-     copy propagate away the copies.  */\n-  void remove_range_assertions ();\n-\n-  /* Dump all the registered assertions for all the names to FILE.  */\n-  void dump (FILE *);\n-\n-  /* Dump all the registered assertions for NAME to FILE.  */\n-  void dump (FILE *file, tree name);\n-\n-  /* Dump all the registered assertions for NAME to stderr.  */\n-  void debug (tree name)\n-  {\n-    dump (stderr, name);\n-  }\n-\n-  /* Dump all the registered assertions for all the names to stderr.  */\n-  void debug ()\n-  {\n-    dump (stderr);\n-  }\n-\n-private:\n-  /* Set of SSA names found live during the RPO traversal of the function\n-     for still active basic-blocks.  */\n-  live_names live;\n-\n-  /* Function to work on.  */\n-  struct function *fun;\n-\n-  /* If bit I is present, it means that SSA name N_i has a list of\n-     assertions that should be inserted in the IL.  */\n-  bitmap need_assert_for;\n-\n-  /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n-     holds a list of ASSERT_LOCUS_T nodes that describe where\n-     ASSERT_EXPRs for SSA name N_I should be inserted.  */\n-  assert_locus **asserts_for;\n-\n-  /* Finish found ASSERTS for E and register them at GSI.  */\n-  void finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n-\t\t\t\t\tvec<assert_info> &asserts);\n-\n-  /* Determine whether the outgoing edges of BB should receive an\n-     ASSERT_EXPR for each of the operands of BB's LAST statement.  The\n-     last statement of BB must be a SWITCH_EXPR.\n-\n-     If any of the sub-graphs rooted at BB have an interesting use of\n-     the predicate operands, an assert location node is added to the\n-     list of assertions for the corresponding operands.  */\n-  void find_switch_asserts (basic_block bb, gswitch *last);\n-\n-  /* Do an RPO walk over the function computing SSA name liveness\n-     on-the-fly and deciding on assert expressions to insert.  */\n-  void find_assert_locations ();\n-\n-  /* Traverse all the statements in block BB looking for statements that\n-     may generate useful assertions for the SSA names in their operand.\n-     See method implementation comentary for more information.  */\n-  void find_assert_locations_in_bb (basic_block bb);\n-\n-  /* Determine whether the outgoing edges of BB should receive an\n-     ASSERT_EXPR for each of the operands of BB's LAST statement.\n-     The last statement of BB must be a COND_EXPR.\n-\n-     If any of the sub-graphs rooted at BB have an interesting use of\n-     the predicate operands, an assert location node is added to the\n-     list of assertions for the corresponding operands.  */\n-  void find_conditional_asserts (basic_block bb, gcond *last);\n-\n-  /* Process all the insertions registered for every name N_i registered\n-     in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n-     found in ASSERTS_FOR[i].  */\n-  void process_assert_insertions ();\n-\n-  /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n-     'EXPR COMP_CODE VAL' at a location that dominates block BB or\n-     E->DEST, then register this location as a possible insertion point\n-     for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n-\n-     BB, E and SI provide the exact insertion point for the new\n-     ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n-     on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n-     BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n-     must not be NULL.  */\n-  void register_new_assert_for (tree name, tree expr,\n-\t\t\t\tenum tree_code comp_code,\n-\t\t\t\ttree val, basic_block bb,\n-\t\t\t\tedge e, gimple_stmt_iterator si);\n-\n-  /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n-     create a new SSA name N and return the assertion assignment\n-     'N = ASSERT_EXPR <V, V OP W>'.  */\n-  gimple *build_assert_expr_for (tree cond, tree v);\n-\n-  /* Create an ASSERT_EXPR for NAME and insert it in the location\n-     indicated by LOC.  Return true if we made any edge insertions.  */\n-  bool process_assert_insertions_for (tree name, assert_locus *loc);\n-\n-  /* Qsort callback for sorting assert locations.  */\n-  template <bool stable> static int compare_assert_loc (const void *,\n-\t\t\t\t\t\t\tconst void *);\n-};\n-\n /* Return true if the SSA name NAME is live on the edge E.  */\n \n bool\n@@ -1266,48 +1119,6 @@ range_fold_unary_expr (value_range *vr,\n   op->fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n }\n \n-/* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n-   create a new SSA name N and return the assertion assignment\n-   'N = ASSERT_EXPR <V, V OP W>'.  */\n-\n-gimple *\n-vrp_insert::build_assert_expr_for (tree cond, tree v)\n-{\n-  tree a;\n-  gassign *assertion;\n-\n-  gcc_assert (TREE_CODE (v) == SSA_NAME\n-\t      && COMPARISON_CLASS_P (cond));\n-\n-  a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond);\n-  assertion = gimple_build_assign (NULL_TREE, a);\n-\n-  /* The new ASSERT_EXPR, creates a new SSA name that replaces the\n-     operand of the ASSERT_EXPR.  Create it so the new name and the old one\n-     are registered in the replacement table so that we can fix the SSA web\n-     after adding all the ASSERT_EXPRs.  */\n-  tree new_def = create_new_def_for (v, assertion, NULL);\n-  /* Make sure we preserve abnormalness throughout an ASSERT_EXPR chain\n-     given we have to be able to fully propagate those out to re-create\n-     valid SSA when removing the asserts.  */\n-  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (v))\n-    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_def) = 1;\n-\n-  return assertion;\n-}\n-\n-\n-/* Return false if EXPR is a predicate expression involving floating\n-   point values.  */\n-\n-static inline bool\n-fp_predicate (gimple *stmt)\n-{\n-  GIMPLE_CHECK (stmt, GIMPLE_COND);\n-\n-  return FLOAT_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)));\n-}\n-\n /* If the range of values taken by OP can be inferred after STMT executes,\n    return the comparison code (COMP_CODE_P) and value (VAL_P) that\n    describes the inferred range.  Return true if a range could be\n@@ -1350,54 +1161,6 @@ infer_value_range (gimple *stmt, tree op, tree_code *comp_code_p, tree *val_p)\n   return false;\n }\n \n-/* Dump all the registered assertions for NAME to FILE.  */\n-\n-void\n-vrp_insert::dump (FILE *file, tree name)\n-{\n-  assert_locus *loc;\n-\n-  fprintf (file, \"Assertions to be inserted for \");\n-  print_generic_expr (file, name);\n-  fprintf (file, \"\\n\");\n-\n-  loc = asserts_for[SSA_NAME_VERSION (name)];\n-  while (loc)\n-    {\n-      fprintf (file, \"\\t\");\n-      print_gimple_stmt (file, gsi_stmt (loc->si), 0);\n-      fprintf (file, \"\\n\\tBB #%d\", loc->bb->index);\n-      if (loc->e)\n-\t{\n-\t  fprintf (file, \"\\n\\tEDGE %d->%d\", loc->e->src->index,\n-\t           loc->e->dest->index);\n-\t  dump_edge_info (file, loc->e, dump_flags, 0);\n-\t}\n-      fprintf (file, \"\\n\\tPREDICATE: \");\n-      print_generic_expr (file, loc->expr);\n-      fprintf (file, \" %s \", get_tree_code_name (loc->comp_code));\n-      print_generic_expr (file, loc->val);\n-      fprintf (file, \"\\n\\n\");\n-      loc = loc->next;\n-    }\n-\n-  fprintf (file, \"\\n\");\n-}\n-\n-/* Dump all the registered assertions for all the names to FILE.  */\n-\n-void\n-vrp_insert::dump (FILE *file)\n-{\n-  unsigned i;\n-  bitmap_iterator bi;\n-\n-  fprintf (file, \"\\nASSERT_EXPRs to be inserted\\n\\n\");\n-  EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)\n-    dump (file, ssa_name (i));\n-  fprintf (file, \"\\n\");\n-}\n-\n /* Dump assert_info structure.  */\n \n void\n@@ -1457,133 +1220,22 @@ add_assert_info (vec<assert_info> &asserts,\n \t\t name, expr, op_symbol_code (comp_code), val);\n }\n \n-/* If NAME doesn't have an ASSERT_EXPR registered for asserting\n-   'EXPR COMP_CODE VAL' at a location that dominates block BB or\n-   E->DEST, then register this location as a possible insertion point\n-   for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n-\n-   BB, E and SI provide the exact insertion point for the new\n-   ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n-   on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n-   BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n-   must not be NULL.  */\n+/* (COND_OP0 COND_CODE COND_OP1) is a predicate which uses NAME.\n+   Extract a suitable test code and value and store them into *CODE_P and\n+   *VAL_P so the predicate is normalized to NAME *CODE_P *VAL_P.\n \n-void\n-vrp_insert::register_new_assert_for (tree name, tree expr,\n-\t\t\t\t   enum tree_code comp_code,\n-\t\t\t\t   tree val,\n-\t\t\t\t   basic_block bb,\n-\t\t\t\t   edge e,\n-\t\t\t\t   gimple_stmt_iterator si)\n-{\n-  assert_locus *n, *loc, *last_loc;\n-  basic_block dest_bb;\n+   If no extraction was possible, return FALSE, otherwise return TRUE.\n \n-  gcc_checking_assert (bb == NULL || e == NULL);\n+   If INVERT is true, then we invert the result stored into *CODE_P.  */\n \n-  if (e == NULL)\n-    gcc_checking_assert (gimple_code (gsi_stmt (si)) != GIMPLE_COND\n-\t\t\t && gimple_code (gsi_stmt (si)) != GIMPLE_SWITCH);\n-\n-  /* Never build an assert comparing against an integer constant with\n-     TREE_OVERFLOW set.  This confuses our undefined overflow warning\n-     machinery.  */\n-  if (TREE_OVERFLOW_P (val))\n-    val = drop_tree_overflow (val);\n-\n-  /* The new assertion A will be inserted at BB or E.  We need to\n-     determine if the new location is dominated by a previously\n-     registered location for A.  If we are doing an edge insertion,\n-     assume that A will be inserted at E->DEST.  Note that this is not\n-     necessarily true.\n-\n-     If E is a critical edge, it will be split.  But even if E is\n-     split, the new block will dominate the same set of blocks that\n-     E->DEST dominates.\n-\n-     The reverse, however, is not true, blocks dominated by E->DEST\n-     will not be dominated by the new block created to split E.  So,\n-     if the insertion location is on a critical edge, we will not use\n-     the new location to move another assertion previously registered\n-     at a block dominated by E->DEST.  */\n-  dest_bb = (bb) ? bb : e->dest;\n-\n-  /* If NAME already has an ASSERT_EXPR registered for COMP_CODE and\n-     VAL at a block dominating DEST_BB, then we don't need to insert a new\n-     one.  Similarly, if the same assertion already exists at a block\n-     dominated by DEST_BB and the new location is not on a critical\n-     edge, then update the existing location for the assertion (i.e.,\n-     move the assertion up in the dominance tree).\n-\n-     Note, this is implemented as a simple linked list because there\n-     should not be more than a handful of assertions registered per\n-     name.  If this becomes a performance problem, a table hashed by\n-     COMP_CODE and VAL could be implemented.  */\n-  loc = asserts_for[SSA_NAME_VERSION (name)];\n-  last_loc = loc;\n-  while (loc)\n-    {\n-      if (loc->comp_code == comp_code\n-\t  && (loc->val == val\n-\t      || operand_equal_p (loc->val, val, 0))\n-\t  && (loc->expr == expr\n-\t      || operand_equal_p (loc->expr, expr, 0)))\n-\t{\n-\t  /* If E is not a critical edge and DEST_BB\n-\t     dominates the existing location for the assertion, move\n-\t     the assertion up in the dominance tree by updating its\n-\t     location information.  */\n-\t  if ((e == NULL || !EDGE_CRITICAL_P (e))\n-\t      && dominated_by_p (CDI_DOMINATORS, loc->bb, dest_bb))\n-\t    {\n-\t      loc->bb = dest_bb;\n-\t      loc->e = e;\n-\t      loc->si = si;\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Update the last node of the list and move to the next one.  */\n-      last_loc = loc;\n-      loc = loc->next;\n-    }\n-\n-  /* If we didn't find an assertion already registered for\n-     NAME COMP_CODE VAL, add a new one at the end of the list of\n-     assertions associated with NAME.  */\n-  n = XNEW (struct assert_locus);\n-  n->bb = dest_bb;\n-  n->e = e;\n-  n->si = si;\n-  n->comp_code = comp_code;\n-  n->val = val;\n-  n->expr = expr;\n-  n->next = NULL;\n-\n-  if (last_loc)\n-    last_loc->next = n;\n-  else\n-    asserts_for[SSA_NAME_VERSION (name)] = n;\n-\n-  bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));\n-}\n-\n-/* (COND_OP0 COND_CODE COND_OP1) is a predicate which uses NAME.\n-   Extract a suitable test code and value and store them into *CODE_P and\n-   *VAL_P so the predicate is normalized to NAME *CODE_P *VAL_P.\n-\n-   If no extraction was possible, return FALSE, otherwise return TRUE.\n-\n-   If INVERT is true, then we invert the result stored into *CODE_P.  */\n-\n-static bool\n-extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n-\t\t\t\t\t tree cond_op0, tree cond_op1,\n-\t\t\t\t\t bool invert, enum tree_code *code_p,\n-\t\t\t\t\t tree *val_p)\n-{\n-  enum tree_code comp_code;\n-  tree val;\n+static bool\n+extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n+\t\t\t\t\t tree cond_op0, tree cond_op1,\n+\t\t\t\t\t bool invert, enum tree_code *code_p,\n+\t\t\t\t\t tree *val_p)\n+{\n+  enum tree_code comp_code;\n+  tree val;\n \n   /* Otherwise, we have a comparison of the form NAME COMP VAL\n      or VAL COMP NAME.  */\n@@ -2578,94 +2230,746 @@ register_edge_assert_for (tree name, edge e,\n     }\n }\n \n-/* Finish found ASSERTS for E and register them at GSI.  */\n+/* Handle\n+   _4 = x_3 & 31;\n+   if (_4 != 0)\n+     goto <bb 6>;\n+   else\n+     goto <bb 7>;\n+   <bb 6>:\n+   __builtin_unreachable ();\n+   <bb 7>:\n+   x_5 = ASSERT_EXPR <x_3, ...>;\n+   If x_3 has no other immediate uses (checked by caller),\n+   var is the x_3 var from ASSERT_EXPR, we can clear low 5 bits\n+   from the non-zero bitmask.  */\n \n void\n-vrp_insert::finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n-\t\t\t\t\t   vec<assert_info> &asserts)\n+maybe_set_nonzero_bits (edge e, tree var)\n {\n-  for (unsigned i = 0; i < asserts.length (); ++i)\n-    /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n-       reachable from E.  */\n-    if (live.live_on_edge_p (asserts[i].name, e))\n-      register_new_assert_for (asserts[i].name, asserts[i].expr,\n-\t\t\t       asserts[i].comp_code, asserts[i].val,\n-\t\t\t       NULL, e, gsi);\n-}\n+  basic_block cond_bb = e->src;\n+  gimple *stmt = last_stmt (cond_bb);\n+  tree cst;\n \n+  if (stmt == NULL\n+      || gimple_code (stmt) != GIMPLE_COND\n+      || gimple_cond_code (stmt) != ((e->flags & EDGE_TRUE_VALUE)\n+\t\t\t\t     ? EQ_EXPR : NE_EXPR)\n+      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME\n+      || !integer_zerop (gimple_cond_rhs (stmt)))\n+    return;\n \n+  stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n+  if (!is_gimple_assign (stmt)\n+      || gimple_assign_rhs_code (stmt) != BIT_AND_EXPR\n+      || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)\n+    return;\n+  if (gimple_assign_rhs1 (stmt) != var)\n+    {\n+      gimple *stmt2;\n \n-/* Determine whether the outgoing edges of BB should receive an\n-   ASSERT_EXPR for each of the operands of BB's LAST statement.\n-   The last statement of BB must be a COND_EXPR.\n+      if (TREE_CODE (gimple_assign_rhs1 (stmt)) != SSA_NAME)\n+\treturn;\n+      stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n+      if (!gimple_assign_cast_p (stmt2)\n+\t  || gimple_assign_rhs1 (stmt2) != var\n+\t  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt2))\n+\t  || (TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t\t\t      != TYPE_PRECISION (TREE_TYPE (var))))\n+\treturn;\n+    }\n+  cst = gimple_assign_rhs2 (stmt);\n+  set_nonzero_bits (var, wi::bit_and_not (get_nonzero_bits (var),\n+\t\t\t\t\t  wi::to_wide (cst)));\n+}\n \n-   If any of the sub-graphs rooted at BB have an interesting use of\n-   the predicate operands, an assert location node is added to the\n-   list of assertions for the corresponding operands.  */\n+/* Return true if STMT is interesting for VRP.  */\n \n-void\n-vrp_insert::find_conditional_asserts (basic_block bb, gcond *last)\n+bool\n+stmt_interesting_for_vrp (gimple *stmt)\n {\n-  gimple_stmt_iterator bsi;\n-  tree op;\n-  edge_iterator ei;\n-  edge e;\n-  ssa_op_iter iter;\n-\n-  bsi = gsi_for_stmt (last);\n-\n-  /* Look for uses of the operands in each of the sub-graphs\n-     rooted at BB.  We need to check each of the outgoing edges\n-     separately, so that we know what kind of ASSERT_EXPR to\n-     insert.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n-      if (e->dest == bb)\n-\tcontinue;\n+      tree res = gimple_phi_result (stmt);\n+      return (!virtual_operand_p (res)\n+\t      && (INTEGRAL_TYPE_P (TREE_TYPE (res))\n+\t\t  || POINTER_TYPE_P (TREE_TYPE (res))));\n+    }\n+  else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n \n-      /* Register the necessary assertions for each operand in the\n-\t conditional predicate.  */\n-      auto_vec<assert_info, 8> asserts;\n-      FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tregister_edge_assert_for (op, e,\n-\t\t\t\t  gimple_cond_code (last),\n-\t\t\t\t  gimple_cond_lhs (last),\n-\t\t\t\t  gimple_cond_rhs (last), asserts);\n-      finish_register_edge_assert_for (e, bsi, asserts);\n+      /* In general, assignments with virtual operands are not useful\n+\t for deriving ranges, with the obvious exception of calls to\n+\t builtin functions.  */\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && (is_gimple_call (stmt)\n+\t      || !gimple_vuse (stmt)))\n+\treturn true;\n+      else if (is_gimple_call (stmt) && gimple_call_internal_p (stmt))\n+\tswitch (gimple_call_internal_fn (stmt))\n+\t  {\n+\t  case IFN_ADD_OVERFLOW:\n+\t  case IFN_SUB_OVERFLOW:\n+\t  case IFN_MUL_OVERFLOW:\n+\t  case IFN_ATOMIC_COMPARE_EXCHANGE:\n+\t    /* These internal calls return _Complex integer type,\n+\t       but are interesting to VRP nevertheless.  */\n+\t    if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t      return true;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n     }\n+  else if (gimple_code (stmt) == GIMPLE_COND\n+\t   || gimple_code (stmt) == GIMPLE_SWITCH)\n+    return true;\n+\n+  return false;\n }\n \n-struct case_info\n-{\n-  tree expr;\n-  basic_block bb;\n-};\n \n-/* Compare two case labels sorting first by the destination bb index\n-   and then by the case value.  */\n+/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n+   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n+   BB.  If no such ASSERT_EXPR is found, return OP.  */\n \n-static int\n-compare_case_labels (const void *p1, const void *p2)\n+static tree\n+lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n {\n-  const struct case_info *ci1 = (const struct case_info *) p1;\n-  const struct case_info *ci2 = (const struct case_info *) p2;\n-  int idx1 = ci1->bb->index;\n-  int idx2 = ci2->bb->index;\n+  imm_use_iterator imm_iter;\n+  gimple *use_stmt;\n+  use_operand_p use_p;\n \n-  if (idx1 < idx2)\n-    return -1;\n-  else if (idx1 == idx2)\n+  if (TREE_CODE (op) == SSA_NAME)\n     {\n-      /* Make sure the default label is first in a group.  */\n-      if (!CASE_LOW (ci1->expr))\n-\treturn -1;\n-      else if (!CASE_LOW (ci2->expr))\n-\treturn 1;\n-      else\n-\treturn tree_int_cst_compare (CASE_LOW (ci1->expr),\n-\t\t\t\t     CASE_LOW (ci2->expr));\n-    }\n-  else\n+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n+\t{\n+\t  use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt != stmt\n+\t      && gimple_assign_single_p (use_stmt)\n+\t      && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR\n+\t      && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op\n+\t      && dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))\n+\t    return gimple_assign_lhs (use_stmt);\n+\t}\n+    }\n+  return op;\n+}\n+\n+/* A hack.  */\n+static class vr_values *x_vr_values;\n+\n+/* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n+   that includes the value VAL.  The search is restricted to the range\n+   [START_IDX, n - 1] where n is the size of VEC.\n+\n+   If there is a CASE_LABEL for VAL, its index is placed in IDX and true is\n+   returned.\n+\n+   If there is no CASE_LABEL for VAL and there is one that is larger than VAL,\n+   it is placed in IDX and false is returned.\n+\n+   If VAL is larger than any CASE_LABEL, n is placed on IDX and false is\n+   returned. */\n+\n+bool\n+find_case_label_index (gswitch *stmt, size_t start_idx, tree val, size_t *idx)\n+{\n+  size_t n = gimple_switch_num_labels (stmt);\n+  size_t low, high;\n+\n+  /* Find case label for minimum of the value range or the next one.\n+     At each iteration we are searching in [low, high - 1]. */\n+\n+  for (low = start_idx, high = n; high != low; )\n+    {\n+      tree t;\n+      int cmp;\n+      /* Note that i != high, so we never ask for n. */\n+      size_t i = (high + low) / 2;\n+      t = gimple_switch_label (stmt, i);\n+\n+      /* Cache the result of comparing CASE_LOW and val.  */\n+      cmp = tree_int_cst_compare (CASE_LOW (t), val);\n+\n+      if (cmp == 0)\n+\t{\n+\t  /* Ranges cannot be empty. */\n+\t  *idx = i;\n+\t  return true;\n+\t}\n+      else if (cmp > 0)\n+        high = i;\n+      else\n+\t{\n+\t  low = i + 1;\n+\t  if (CASE_HIGH (t) != NULL\n+\t      && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n+\t    {\n+\t      *idx = i;\n+\t      return true;\n+\t    }\n+        }\n+    }\n+\n+  *idx = high;\n+  return false;\n+}\n+\n+/* Searches the case label vector VEC for the range of CASE_LABELs that is used\n+   for values between MIN and MAX. The first index is placed in MIN_IDX. The\n+   last index is placed in MAX_IDX. If the range of CASE_LABELs is empty\n+   then MAX_IDX < MIN_IDX.\n+   Returns true if the default label is not needed. */\n+\n+bool\n+find_case_label_range (gswitch *stmt, tree min, tree max, size_t *min_idx,\n+\t\t       size_t *max_idx)\n+{\n+  size_t i, j;\n+  bool min_take_default = !find_case_label_index (stmt, 1, min, &i);\n+  bool max_take_default = !find_case_label_index (stmt, i, max, &j);\n+\n+  if (i == j\n+      && min_take_default\n+      && max_take_default)\n+    {\n+      /* Only the default case label reached.\n+         Return an empty range. */\n+      *min_idx = 1;\n+      *max_idx = 0;\n+      return false;\n+    }\n+  else\n+    {\n+      bool take_default = min_take_default || max_take_default;\n+      tree low, high;\n+      size_t k;\n+\n+      if (max_take_default)\n+\tj--;\n+\n+      /* If the case label range is continuous, we do not need\n+\t the default case label.  Verify that.  */\n+      high = CASE_LOW (gimple_switch_label (stmt, i));\n+      if (CASE_HIGH (gimple_switch_label (stmt, i)))\n+\thigh = CASE_HIGH (gimple_switch_label (stmt, i));\n+      for (k = i + 1; k <= j; ++k)\n+\t{\n+\t  low = CASE_LOW (gimple_switch_label (stmt, k));\n+\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high)))\n+\t    {\n+\t      take_default = true;\n+\t      break;\n+\t    }\n+\t  high = low;\n+\t  if (CASE_HIGH (gimple_switch_label (stmt, k)))\n+\t    high = CASE_HIGH (gimple_switch_label (stmt, k));\n+\t}\n+\n+      *min_idx = i;\n+      *max_idx = j;\n+      return !take_default;\n+    }\n+}\n+\n+/* Given a SWITCH_STMT, return the case label that encompasses the\n+   known possible values for the switch operand.  RANGE_OF_OP is a\n+   range for the known values of the switch operand.  */\n+\n+tree\n+find_case_label_range (gswitch *switch_stmt, const irange *range_of_op)\n+{\n+  if (range_of_op->undefined_p ()\n+      || range_of_op->varying_p ()\n+      || range_of_op->symbolic_p ())\n+    return NULL_TREE;\n+\n+  size_t i, j;\n+  tree op = gimple_switch_index (switch_stmt);\n+  tree type = TREE_TYPE (op);\n+  tree tmin = wide_int_to_tree (type, range_of_op->lower_bound ());\n+  tree tmax = wide_int_to_tree (type, range_of_op->upper_bound ());\n+  find_case_label_range (switch_stmt, tmin, tmax, &i, &j);\n+  if (i == j)\n+    {\n+      /* Look for exactly one label that encompasses the range of\n+\t the operand.  */\n+      tree label = gimple_switch_label (switch_stmt, i);\n+      tree case_high\n+\t= CASE_HIGH (label) ? CASE_HIGH (label) : CASE_LOW (label);\n+      int_range_max label_range (CASE_LOW (label), case_high);\n+      if (!types_compatible_p (label_range.type (), range_of_op->type ()))\n+\trange_cast (label_range, range_of_op->type ());\n+      label_range.intersect (range_of_op);\n+      if (label_range == *range_of_op)\n+\treturn label;\n+    }\n+  else if (i > j)\n+    {\n+      /* If there are no labels at all, take the default.  */\n+      return gimple_switch_label (switch_stmt, 0);\n+    }\n+  else\n+    {\n+      /* Otherwise, there are various labels that can encompass\n+\t the range of operand.  In which case, see if the range of\n+\t the operand is entirely *outside* the bounds of all the\n+\t (non-default) case labels.  If so, take the default.  */\n+      unsigned n = gimple_switch_num_labels (switch_stmt);\n+      tree min_label = gimple_switch_label (switch_stmt, 1);\n+      tree max_label = gimple_switch_label (switch_stmt, n - 1);\n+      tree case_high = CASE_HIGH (max_label);\n+      if (!case_high)\n+\tcase_high = CASE_LOW (max_label);\n+      int_range_max label_range (CASE_LOW (min_label), case_high);\n+      if (!types_compatible_p (label_range.type (), range_of_op->type ()))\n+\trange_cast (label_range, range_of_op->type ());\n+      label_range.intersect (range_of_op);\n+      if (label_range.undefined_p ())\n+\treturn gimple_switch_label (switch_stmt, 0);\n+    }\n+  return NULL_TREE;\n+}\n+\n+struct case_info\n+{\n+  tree expr;\n+  basic_block bb;\n+};\n+\n+/* Location information for ASSERT_EXPRs.  Each instance of this\n+   structure describes an ASSERT_EXPR for an SSA name.  Since a single\n+   SSA name may have more than one assertion associated with it, these\n+   locations are kept in a linked list attached to the corresponding\n+   SSA name.  */\n+struct assert_locus\n+{\n+  /* Basic block where the assertion would be inserted.  */\n+  basic_block bb;\n+\n+  /* Some assertions need to be inserted on an edge (e.g., assertions\n+     generated by COND_EXPRs).  In those cases, BB will be NULL.  */\n+  edge e;\n+\n+  /* Pointer to the statement that generated this assertion.  */\n+  gimple_stmt_iterator si;\n+\n+  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n+  enum tree_code comp_code;\n+\n+  /* Value being compared against.  */\n+  tree val;\n+\n+  /* Expression to compare.  */\n+  tree expr;\n+\n+  /* Next node in the linked list.  */\n+  assert_locus *next;\n+};\n+\n+/* Class to traverse the flowgraph looking for conditional jumps to\n+   insert ASSERT_EXPR range expressions.  These range expressions are\n+   meant to provide information to optimizations that need to reason\n+   in terms of value ranges.  They will not be expanded into RTL.  */\n+\n+class vrp_asserts\n+{\n+public:\n+  vrp_asserts (struct function *fn) : fun (fn) { }\n+\n+  void insert_range_assertions ();\n+\n+  /* Convert range assertion expressions into the implied copies and\n+     copy propagate away the copies.  */\n+  void remove_range_assertions ();\n+\n+  /* Dump all the registered assertions for all the names to FILE.  */\n+  void dump (FILE *);\n+\n+  /* Dump all the registered assertions for NAME to FILE.  */\n+  void dump (FILE *file, tree name);\n+\n+  /* Dump all the registered assertions for NAME to stderr.  */\n+  void debug (tree name)\n+  {\n+    dump (stderr, name);\n+  }\n+\n+  /* Dump all the registered assertions for all the names to stderr.  */\n+  void debug ()\n+  {\n+    dump (stderr);\n+  }\n+\n+private:\n+  /* Set of SSA names found live during the RPO traversal of the function\n+     for still active basic-blocks.  */\n+  live_names live;\n+\n+  /* Function to work on.  */\n+  struct function *fun;\n+\n+  /* If bit I is present, it means that SSA name N_i has a list of\n+     assertions that should be inserted in the IL.  */\n+  bitmap need_assert_for;\n+\n+  /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]\n+     holds a list of ASSERT_LOCUS_T nodes that describe where\n+     ASSERT_EXPRs for SSA name N_I should be inserted.  */\n+  assert_locus **asserts_for;\n+\n+  /* Finish found ASSERTS for E and register them at GSI.  */\n+  void finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,\n+\t\t\t\t\tvec<assert_info> &asserts);\n+\n+  /* Determine whether the outgoing edges of BB should receive an\n+     ASSERT_EXPR for each of the operands of BB's LAST statement.  The\n+     last statement of BB must be a SWITCH_EXPR.\n+\n+     If any of the sub-graphs rooted at BB have an interesting use of\n+     the predicate operands, an assert location node is added to the\n+     list of assertions for the corresponding operands.  */\n+  void find_switch_asserts (basic_block bb, gswitch *last);\n+\n+  /* Do an RPO walk over the function computing SSA name liveness\n+     on-the-fly and deciding on assert expressions to insert.  */\n+  void find_assert_locations ();\n+\n+  /* Traverse all the statements in block BB looking for statements that\n+     may generate useful assertions for the SSA names in their operand.\n+     See method implementation comentary for more information.  */\n+  void find_assert_locations_in_bb (basic_block bb);\n+\n+  /* Determine whether the outgoing edges of BB should receive an\n+     ASSERT_EXPR for each of the operands of BB's LAST statement.\n+     The last statement of BB must be a COND_EXPR.\n+\n+     If any of the sub-graphs rooted at BB have an interesting use of\n+     the predicate operands, an assert location node is added to the\n+     list of assertions for the corresponding operands.  */\n+  void find_conditional_asserts (basic_block bb, gcond *last);\n+\n+  /* Process all the insertions registered for every name N_i registered\n+     in NEED_ASSERT_FOR.  The list of assertions to be inserted are\n+     found in ASSERTS_FOR[i].  */\n+  void process_assert_insertions ();\n+\n+  /* If NAME doesn't have an ASSERT_EXPR registered for asserting\n+     'EXPR COMP_CODE VAL' at a location that dominates block BB or\n+     E->DEST, then register this location as a possible insertion point\n+     for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n+\n+     BB, E and SI provide the exact insertion point for the new\n+     ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n+     on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n+     BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n+     must not be NULL.  */\n+  void register_new_assert_for (tree name, tree expr,\n+\t\t\t\tenum tree_code comp_code,\n+\t\t\t\ttree val, basic_block bb,\n+\t\t\t\tedge e, gimple_stmt_iterator si);\n+\n+  /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n+     create a new SSA name N and return the assertion assignment\n+     'N = ASSERT_EXPR <V, V OP W>'.  */\n+  gimple *build_assert_expr_for (tree cond, tree v);\n+\n+  /* Create an ASSERT_EXPR for NAME and insert it in the location\n+     indicated by LOC.  Return true if we made any edge insertions.  */\n+  bool process_assert_insertions_for (tree name, assert_locus *loc);\n+\n+  /* Qsort callback for sorting assert locations.  */\n+  template <bool stable> static int compare_assert_loc (const void *,\n+\t\t\t\t\t\t\tconst void *);\n+\n+  /* Return false if EXPR is a predicate expression involving floating\n+     point values.  */\n+  bool fp_predicate (gimple *stmt)\n+  {\n+    GIMPLE_CHECK (stmt, GIMPLE_COND);\n+    return FLOAT_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)));\n+  }\n+\n+  bool all_imm_uses_in_stmt_or_feed_cond (tree var, gimple *stmt,\n+\t\t\t\t\t  basic_block cond_bb);\n+\n+  static int compare_case_labels (const void *, const void *);\n+};\n+\n+/* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n+   create a new SSA name N and return the assertion assignment\n+   'N = ASSERT_EXPR <V, V OP W>'.  */\n+\n+gimple *\n+vrp_asserts::build_assert_expr_for (tree cond, tree v)\n+{\n+  tree a;\n+  gassign *assertion;\n+\n+  gcc_assert (TREE_CODE (v) == SSA_NAME\n+\t      && COMPARISON_CLASS_P (cond));\n+\n+  a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond);\n+  assertion = gimple_build_assign (NULL_TREE, a);\n+\n+  /* The new ASSERT_EXPR, creates a new SSA name that replaces the\n+     operand of the ASSERT_EXPR.  Create it so the new name and the old one\n+     are registered in the replacement table so that we can fix the SSA web\n+     after adding all the ASSERT_EXPRs.  */\n+  tree new_def = create_new_def_for (v, assertion, NULL);\n+  /* Make sure we preserve abnormalness throughout an ASSERT_EXPR chain\n+     given we have to be able to fully propagate those out to re-create\n+     valid SSA when removing the asserts.  */\n+  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (v))\n+    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_def) = 1;\n+\n+  return assertion;\n+}\n+\n+/* Dump all the registered assertions for NAME to FILE.  */\n+\n+void\n+vrp_asserts::dump (FILE *file, tree name)\n+{\n+  assert_locus *loc;\n+\n+  fprintf (file, \"Assertions to be inserted for \");\n+  print_generic_expr (file, name);\n+  fprintf (file, \"\\n\");\n+\n+  loc = asserts_for[SSA_NAME_VERSION (name)];\n+  while (loc)\n+    {\n+      fprintf (file, \"\\t\");\n+      print_gimple_stmt (file, gsi_stmt (loc->si), 0);\n+      fprintf (file, \"\\n\\tBB #%d\", loc->bb->index);\n+      if (loc->e)\n+\t{\n+\t  fprintf (file, \"\\n\\tEDGE %d->%d\", loc->e->src->index,\n+\t           loc->e->dest->index);\n+\t  dump_edge_info (file, loc->e, dump_flags, 0);\n+\t}\n+      fprintf (file, \"\\n\\tPREDICATE: \");\n+      print_generic_expr (file, loc->expr);\n+      fprintf (file, \" %s \", get_tree_code_name (loc->comp_code));\n+      print_generic_expr (file, loc->val);\n+      fprintf (file, \"\\n\\n\");\n+      loc = loc->next;\n+    }\n+\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Dump all the registered assertions for all the names to FILE.  */\n+\n+void\n+vrp_asserts::dump (FILE *file)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+\n+  fprintf (file, \"\\nASSERT_EXPRs to be inserted\\n\\n\");\n+  EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)\n+    dump (file, ssa_name (i));\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* If NAME doesn't have an ASSERT_EXPR registered for asserting\n+   'EXPR COMP_CODE VAL' at a location that dominates block BB or\n+   E->DEST, then register this location as a possible insertion point\n+   for ASSERT_EXPR <NAME, EXPR COMP_CODE VAL>.\n+\n+   BB, E and SI provide the exact insertion point for the new\n+   ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted\n+   on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on\n+   BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E\n+   must not be NULL.  */\n+\n+void\n+vrp_asserts::register_new_assert_for (tree name, tree expr,\n+\t\t\t\t      enum tree_code comp_code,\n+\t\t\t\t      tree val,\n+\t\t\t\t      basic_block bb,\n+\t\t\t\t      edge e,\n+\t\t\t\t      gimple_stmt_iterator si)\n+{\n+  assert_locus *n, *loc, *last_loc;\n+  basic_block dest_bb;\n+\n+  gcc_checking_assert (bb == NULL || e == NULL);\n+\n+  if (e == NULL)\n+    gcc_checking_assert (gimple_code (gsi_stmt (si)) != GIMPLE_COND\n+\t\t\t && gimple_code (gsi_stmt (si)) != GIMPLE_SWITCH);\n+\n+  /* Never build an assert comparing against an integer constant with\n+     TREE_OVERFLOW set.  This confuses our undefined overflow warning\n+     machinery.  */\n+  if (TREE_OVERFLOW_P (val))\n+    val = drop_tree_overflow (val);\n+\n+  /* The new assertion A will be inserted at BB or E.  We need to\n+     determine if the new location is dominated by a previously\n+     registered location for A.  If we are doing an edge insertion,\n+     assume that A will be inserted at E->DEST.  Note that this is not\n+     necessarily true.\n+\n+     If E is a critical edge, it will be split.  But even if E is\n+     split, the new block will dominate the same set of blocks that\n+     E->DEST dominates.\n+\n+     The reverse, however, is not true, blocks dominated by E->DEST\n+     will not be dominated by the new block created to split E.  So,\n+     if the insertion location is on a critical edge, we will not use\n+     the new location to move another assertion previously registered\n+     at a block dominated by E->DEST.  */\n+  dest_bb = (bb) ? bb : e->dest;\n+\n+  /* If NAME already has an ASSERT_EXPR registered for COMP_CODE and\n+     VAL at a block dominating DEST_BB, then we don't need to insert a new\n+     one.  Similarly, if the same assertion already exists at a block\n+     dominated by DEST_BB and the new location is not on a critical\n+     edge, then update the existing location for the assertion (i.e.,\n+     move the assertion up in the dominance tree).\n+\n+     Note, this is implemented as a simple linked list because there\n+     should not be more than a handful of assertions registered per\n+     name.  If this becomes a performance problem, a table hashed by\n+     COMP_CODE and VAL could be implemented.  */\n+  loc = asserts_for[SSA_NAME_VERSION (name)];\n+  last_loc = loc;\n+  while (loc)\n+    {\n+      if (loc->comp_code == comp_code\n+\t  && (loc->val == val\n+\t      || operand_equal_p (loc->val, val, 0))\n+\t  && (loc->expr == expr\n+\t      || operand_equal_p (loc->expr, expr, 0)))\n+\t{\n+\t  /* If E is not a critical edge and DEST_BB\n+\t     dominates the existing location for the assertion, move\n+\t     the assertion up in the dominance tree by updating its\n+\t     location information.  */\n+\t  if ((e == NULL || !EDGE_CRITICAL_P (e))\n+\t      && dominated_by_p (CDI_DOMINATORS, loc->bb, dest_bb))\n+\t    {\n+\t      loc->bb = dest_bb;\n+\t      loc->e = e;\n+\t      loc->si = si;\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Update the last node of the list and move to the next one.  */\n+      last_loc = loc;\n+      loc = loc->next;\n+    }\n+\n+  /* If we didn't find an assertion already registered for\n+     NAME COMP_CODE VAL, add a new one at the end of the list of\n+     assertions associated with NAME.  */\n+  n = XNEW (struct assert_locus);\n+  n->bb = dest_bb;\n+  n->e = e;\n+  n->si = si;\n+  n->comp_code = comp_code;\n+  n->val = val;\n+  n->expr = expr;\n+  n->next = NULL;\n+\n+  if (last_loc)\n+    last_loc->next = n;\n+  else\n+    asserts_for[SSA_NAME_VERSION (name)] = n;\n+\n+  bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));\n+}\n+\n+/* Finish found ASSERTS for E and register them at GSI.  */\n+\n+void\n+vrp_asserts::finish_register_edge_assert_for (edge e,\n+\t\t\t\t\t      gimple_stmt_iterator gsi,\n+\t\t\t\t\t      vec<assert_info> &asserts)\n+{\n+  for (unsigned i = 0; i < asserts.length (); ++i)\n+    /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n+       reachable from E.  */\n+    if (live.live_on_edge_p (asserts[i].name, e))\n+      register_new_assert_for (asserts[i].name, asserts[i].expr,\n+\t\t\t       asserts[i].comp_code, asserts[i].val,\n+\t\t\t       NULL, e, gsi);\n+}\n+\n+/* Determine whether the outgoing edges of BB should receive an\n+   ASSERT_EXPR for each of the operands of BB's LAST statement.\n+   The last statement of BB must be a COND_EXPR.\n+\n+   If any of the sub-graphs rooted at BB have an interesting use of\n+   the predicate operands, an assert location node is added to the\n+   list of assertions for the corresponding operands.  */\n+\n+void\n+vrp_asserts::find_conditional_asserts (basic_block bb, gcond *last)\n+{\n+  gimple_stmt_iterator bsi;\n+  tree op;\n+  edge_iterator ei;\n+  edge e;\n+  ssa_op_iter iter;\n+\n+  bsi = gsi_for_stmt (last);\n+\n+  /* Look for uses of the operands in each of the sub-graphs\n+     rooted at BB.  We need to check each of the outgoing edges\n+     separately, so that we know what kind of ASSERT_EXPR to\n+     insert.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (e->dest == bb)\n+\tcontinue;\n+\n+      /* Register the necessary assertions for each operand in the\n+\t conditional predicate.  */\n+      auto_vec<assert_info, 8> asserts;\n+      FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n+\tregister_edge_assert_for (op, e,\n+\t\t\t\t  gimple_cond_code (last),\n+\t\t\t\t  gimple_cond_lhs (last),\n+\t\t\t\t  gimple_cond_rhs (last), asserts);\n+      finish_register_edge_assert_for (e, bsi, asserts);\n+    }\n+}\n+\n+/* Compare two case labels sorting first by the destination bb index\n+   and then by the case value.  */\n+\n+int\n+vrp_asserts::compare_case_labels (const void *p1, const void *p2)\n+{\n+  const struct case_info *ci1 = (const struct case_info *) p1;\n+  const struct case_info *ci2 = (const struct case_info *) p2;\n+  int idx1 = ci1->bb->index;\n+  int idx2 = ci2->bb->index;\n+\n+  if (idx1 < idx2)\n+    return -1;\n+  else if (idx1 == idx2)\n+    {\n+      /* Make sure the default label is first in a group.  */\n+      if (!CASE_LOW (ci1->expr))\n+\treturn -1;\n+      else if (!CASE_LOW (ci2->expr))\n+\treturn 1;\n+      else\n+\treturn tree_int_cst_compare (CASE_LOW (ci1->expr),\n+\t\t\t\t     CASE_LOW (ci2->expr));\n+    }\n+  else\n     return 1;\n }\n \n@@ -2678,7 +2982,7 @@ compare_case_labels (const void *p1, const void *p2)\n    list of assertions for the corresponding operands.  */\n \n void\n-vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n+vrp_asserts::find_switch_asserts (basic_block bb, gswitch *last)\n {\n   gimple_stmt_iterator bsi;\n   tree op;\n@@ -2827,7 +3131,6 @@ vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n     }\n }\n \n-\n /* Traverse all the statements in block BB looking for statements that\n    may generate useful assertions for the SSA names in their operand.\n    If a statement produces a useful assertion A for name N_i, then the\n@@ -2888,7 +3191,7 @@ vrp_insert::find_switch_asserts (basic_block bb, gswitch *last)\n    P_4 will receive an ASSERT_EXPR.  */\n \n void\n-vrp_insert::find_assert_locations_in_bb (basic_block bb)\n+vrp_asserts::find_assert_locations_in_bb (basic_block bb)\n {\n   gimple *last;\n \n@@ -3008,7 +3311,7 @@ vrp_insert::find_assert_locations_in_bb (basic_block bb)\n    on-the-fly and deciding on assert expressions to insert.  */\n \n void\n-vrp_insert::find_assert_locations (void)\n+vrp_asserts::find_assert_locations (void)\n {\n   int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n   int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n@@ -3088,7 +3391,7 @@ vrp_insert::find_assert_locations (void)\n    indicated by LOC.  Return true if we made any edge insertions.  */\n \n bool\n-vrp_insert::process_assert_insertions_for (tree name, assert_locus *loc)\n+vrp_asserts::process_assert_insertions_for (tree name, assert_locus *loc)\n {\n   /* Build the comparison expression NAME_i COMP_CODE VAL.  */\n   gimple *stmt;\n@@ -3153,7 +3456,7 @@ vrp_insert::process_assert_insertions_for (tree name, assert_locus *loc)\n \n template <bool stable>\n int\n-vrp_insert::compare_assert_loc (const void *pa, const void *pb)\n+vrp_asserts::compare_assert_loc (const void *pa, const void *pb)\n {\n   assert_locus * const a = *(assert_locus * const *)pa;\n   assert_locus * const b = *(assert_locus * const *)pb;\n@@ -3221,7 +3524,7 @@ vrp_insert::compare_assert_loc (const void *pa, const void *pb)\n    found in ASSERTS_FOR[i].  */\n \n void\n-vrp_insert::process_assert_insertions ()\n+vrp_asserts::process_assert_insertions ()\n {\n   unsigned i;\n   bitmap_iterator bi;\n@@ -3314,7 +3617,6 @@ vrp_insert::process_assert_insertions ()\n \t\t\t    num_asserts);\n }\n \n-\n /* Traverse the flowgraph looking for conditional jumps to insert range\n    expressions.  These range expressions are meant to provide information\n    to optimizations that need to reason in terms of value ranges.  They\n@@ -3348,7 +3650,7 @@ vrp_insert::process_assert_insertions ()\n    definition of 'x'.  */\n \n void\n-vrp_insert::insert_range_assertions (void)\n+vrp_asserts::insert_range_assertions (void)\n {\n   need_assert_for = BITMAP_ALLOC (NULL);\n   asserts_for = XCNEWVEC (assert_locus *, num_ssa_names);\n@@ -3372,117 +3674,34 @@ vrp_insert::insert_range_assertions (void)\n   BITMAP_FREE (need_assert_for);\n }\n \n-class vrp_prop : public ssa_propagation_engine\n-{\n-public:\n-  enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;\n-  enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;\n-\n-  struct function *fun;\n-\n-  void vrp_initialize (struct function *);\n-  void vrp_finalize (class vrp_folder *, bool);\n-\n-  class vr_values vr_values;\n-\n-private:\n-  /* Temporary delegator to minimize code churn.  */\n-  const value_range_equiv *get_value_range (const_tree op)\n-    { return vr_values.get_value_range (op); }\n-  void set_def_to_varying (const_tree def)\n-    { vr_values.set_def_to_varying (def); }\n-  void set_defs_to_varying (gimple *stmt)\n-    { vr_values.set_defs_to_varying (stmt); }\n-  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\ttree *output_p, value_range_equiv *vr)\n-    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  bool update_value_range (const_tree op, value_range_equiv *vr)\n-    { return vr_values.update_value_range (op, vr); }\n-  void extract_range_basic (value_range_equiv *vr, gimple *stmt)\n-    { vr_values.extract_range_basic (vr, stmt); }\n-  void extract_range_from_phi_node (gphi *phi, value_range_equiv *vr)\n-    { vr_values.extract_range_from_phi_node (phi, vr); }\n-};\n-\n /* Return true if all imm uses of VAR are either in STMT, or\n    feed (optionally through a chain of single imm uses) GIMPLE_COND\n    in basic block COND_BB.  */\n-\n-static bool\n-all_imm_uses_in_stmt_or_feed_cond (tree var, gimple *stmt, basic_block cond_bb)\n-{\n-  use_operand_p use_p, use2_p;\n-  imm_use_iterator iter;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n-    if (USE_STMT (use_p) != stmt)\n-      {\n-\tgimple *use_stmt = USE_STMT (use_p), *use_stmt2;\n-\tif (is_gimple_debug (use_stmt))\n-\t  continue;\n-\twhile (is_gimple_assign (use_stmt)\n-\t       && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n-\t       && single_imm_use (gimple_assign_lhs (use_stmt),\n-\t\t\t\t  &use2_p, &use_stmt2))\n-\t  use_stmt = use_stmt2;\n-\tif (gimple_code (use_stmt) != GIMPLE_COND\n-\t    || gimple_bb (use_stmt) != cond_bb)\n-\t  return false;\n-      }\n-  return true;\n-}\n-\n-/* Handle\n-   _4 = x_3 & 31;\n-   if (_4 != 0)\n-     goto <bb 6>;\n-   else\n-     goto <bb 7>;\n-   <bb 6>:\n-   __builtin_unreachable ();\n-   <bb 7>:\n-   x_5 = ASSERT_EXPR <x_3, ...>;\n-   If x_3 has no other immediate uses (checked by caller),\n-   var is the x_3 var from ASSERT_EXPR, we can clear low 5 bits\n-   from the non-zero bitmask.  */\n-\n-void\n-maybe_set_nonzero_bits (edge e, tree var)\n-{\n-  basic_block cond_bb = e->src;\n-  gimple *stmt = last_stmt (cond_bb);\n-  tree cst;\n-\n-  if (stmt == NULL\n-      || gimple_code (stmt) != GIMPLE_COND\n-      || gimple_cond_code (stmt) != ((e->flags & EDGE_TRUE_VALUE)\n-\t\t\t\t     ? EQ_EXPR : NE_EXPR)\n-      || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME\n-      || !integer_zerop (gimple_cond_rhs (stmt)))\n-    return;\n-\n-  stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n-  if (!is_gimple_assign (stmt)\n-      || gimple_assign_rhs_code (stmt) != BIT_AND_EXPR\n-      || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)\n-    return;\n-  if (gimple_assign_rhs1 (stmt) != var)\n-    {\n-      gimple *stmt2;\n-\n-      if (TREE_CODE (gimple_assign_rhs1 (stmt)) != SSA_NAME)\n-\treturn;\n-      stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n-      if (!gimple_assign_cast_p (stmt2)\n-\t  || gimple_assign_rhs1 (stmt2) != var\n-\t  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt2))\n-\t  || (TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n-\t\t\t      != TYPE_PRECISION (TREE_TYPE (var))))\n-\treturn;\n-    }\n-  cst = gimple_assign_rhs2 (stmt);\n-  set_nonzero_bits (var, wi::bit_and_not (get_nonzero_bits (var),\n-\t\t\t\t\t  wi::to_wide (cst)));\n+\n+bool\n+vrp_asserts::all_imm_uses_in_stmt_or_feed_cond (tree var,\n+\t\t\t\t\t\tgimple *stmt,\n+\t\t\t\t\t\tbasic_block cond_bb)\n+{\n+  use_operand_p use_p, use2_p;\n+  imm_use_iterator iter;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    if (USE_STMT (use_p) != stmt)\n+      {\n+\tgimple *use_stmt = USE_STMT (use_p), *use_stmt2;\n+\tif (is_gimple_debug (use_stmt))\n+\t  continue;\n+\twhile (is_gimple_assign (use_stmt)\n+\t       && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n+\t       && single_imm_use (gimple_assign_lhs (use_stmt),\n+\t\t\t\t  &use2_p, &use_stmt2))\n+\t  use_stmt = use_stmt2;\n+\tif (gimple_code (use_stmt) != GIMPLE_COND\n+\t    || gimple_bb (use_stmt) != cond_bb)\n+\t  return false;\n+      }\n+  return true;\n }\n \n /* Convert range assertion expressions into the implied copies and\n@@ -3510,7 +3729,7 @@ maybe_set_nonzero_bits (edge e, tree var)\n    multiple ranges to be associated with one SSA_NAME.  */\n \n void\n-vrp_insert::remove_range_assertions ()\n+vrp_asserts::remove_range_assertions ()\n {\n   basic_block bb;\n   gimple_stmt_iterator si;\n@@ -3595,270 +3814,163 @@ vrp_insert::remove_range_assertions ()\n       }\n }\n \n-/* Return true if STMT is interesting for VRP.  */\n-\n-bool\n-stmt_interesting_for_vrp (gimple *stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    {\n-      tree res = gimple_phi_result (stmt);\n-      return (!virtual_operand_p (res)\n-\t      && (INTEGRAL_TYPE_P (TREE_TYPE (res))\n-\t\t  || POINTER_TYPE_P (TREE_TYPE (res))));\n-    }\n-  else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n-    {\n-      tree lhs = gimple_get_lhs (stmt);\n-\n-      /* In general, assignments with virtual operands are not useful\n-\t for deriving ranges, with the obvious exception of calls to\n-\t builtin functions.  */\n-      if (lhs && TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && (is_gimple_call (stmt)\n-\t      || !gimple_vuse (stmt)))\n-\treturn true;\n-      else if (is_gimple_call (stmt) && gimple_call_internal_p (stmt))\n-\tswitch (gimple_call_internal_fn (stmt))\n-\t  {\n-\t  case IFN_ADD_OVERFLOW:\n-\t  case IFN_SUB_OVERFLOW:\n-\t  case IFN_MUL_OVERFLOW:\n-\t  case IFN_ATOMIC_COMPARE_EXCHANGE:\n-\t    /* These internal calls return _Complex integer type,\n-\t       but are interesting to VRP nevertheless.  */\n-\t    if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t      return true;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-    }\n-  else if (gimple_code (stmt) == GIMPLE_COND\n-\t   || gimple_code (stmt) == GIMPLE_SWITCH)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Initialization required by ssa_propagate engine.  */\n-\n-void\n-vrp_prop::vrp_initialize (struct function *fn)\n+class vrp_folder : public substitute_and_fold_engine\n {\n-  basic_block bb;\n-  fun = fn;\n+ public:\n+  vrp_folder (vr_values *v)\n+    : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n+      m_vr_values (v), simplifier (v)\n+    {  }\n+  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n \n-  FOR_EACH_BB_FN (bb, fun)\n+  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n     {\n-      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n-\t   gsi_next (&si))\n-\t{\n-\t  gphi *phi = si.phi ();\n-\t  if (!stmt_interesting_for_vrp (phi))\n-\t    {\n-\t      tree lhs = PHI_RESULT (phi);\n-\t      set_def_to_varying (lhs);\n-\t      prop_set_simulate_again (phi, false);\n-\t    }\n-\t  else\n-\t    prop_set_simulate_again (phi, true);\n-\t}\n-\n-      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n-\t   gsi_next (&si))\n-        {\n-\t  gimple *stmt = gsi_stmt (si);\n-\n- \t  /* If the statement is a control insn, then we do not\n- \t     want to avoid simulating the statement once.  Failure\n- \t     to do so means that those edges will never get added.  */\n-\t  if (stmt_ends_bb_p (stmt))\n-\t    prop_set_simulate_again (stmt, true);\n-\t  else if (!stmt_interesting_for_vrp (stmt))\n-\t    {\n-\t      set_defs_to_varying (stmt);\n-\t      prop_set_simulate_again (stmt, false);\n-\t    }\n-\t  else\n-\t    prop_set_simulate_again (stmt, true);\n-\t}\n+      return m_vr_values->value_of_expr (name, stmt);\n     }\n-}\n-\n-/* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n-   that includes the value VAL.  The search is restricted to the range\n-   [START_IDX, n - 1] where n is the size of VEC.\n-\n-   If there is a CASE_LABEL for VAL, its index is placed in IDX and true is\n-   returned.\n-\n-   If there is no CASE_LABEL for VAL and there is one that is larger than VAL,\n-   it is placed in IDX and false is returned.\n-\n-   If VAL is larger than any CASE_LABEL, n is placed on IDX and false is\n-   returned. */\n-\n-bool\n-find_case_label_index (gswitch *stmt, size_t start_idx, tree val, size_t *idx)\n-{\n-  size_t n = gimple_switch_num_labels (stmt);\n-  size_t low, high;\n-\n-  /* Find case label for minimum of the value range or the next one.\n-     At each iteration we are searching in [low, high - 1]. */\n-\n-  for (low = start_idx, high = n; high != low; )\n-    {\n-      tree t;\n-      int cmp;\n-      /* Note that i != high, so we never ask for n. */\n-      size_t i = (high + low) / 2;\n-      t = gimple_switch_label (stmt, i);\n-\n-      /* Cache the result of comparing CASE_LOW and val.  */\n-      cmp = tree_int_cst_compare (CASE_LOW (t), val);\n+  class vr_values *m_vr_values;\n \n-      if (cmp == 0)\n-\t{\n-\t  /* Ranges cannot be empty. */\n-\t  *idx = i;\n-\t  return true;\n-\t}\n-      else if (cmp > 0)\n-        high = i;\n-      else\n-\t{\n-\t  low = i + 1;\n-\t  if (CASE_HIGH (t) != NULL\n-\t      && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n-\t    {\n-\t      *idx = i;\n-\t      return true;\n-\t    }\n-        }\n-    }\n+private:\n+  bool fold_predicate_in (gimple_stmt_iterator *);\n+  /* Delegators.  */\n+  tree vrp_evaluate_conditional (tree_code code, tree op0,\n+\t\t\t\t tree op1, gimple *stmt)\n+    { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n+  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n+    { return simplifier.simplify (gsi); }\n \n-  *idx = high;\n-  return false;\n-}\n+  simplify_using_ranges simplifier;\n+};\n \n-/* Searches the case label vector VEC for the range of CASE_LABELs that is used\n-   for values between MIN and MAX. The first index is placed in MIN_IDX. The\n-   last index is placed in MAX_IDX. If the range of CASE_LABELs is empty\n-   then MAX_IDX < MIN_IDX.\n-   Returns true if the default label is not needed. */\n+/* If the statement pointed by SI has a predicate whose value can be\n+   computed using the value range information computed by VRP, compute\n+   its value and return true.  Otherwise, return false.  */\n \n bool\n-find_case_label_range (gswitch *stmt, tree min, tree max, size_t *min_idx,\n-\t\t       size_t *max_idx)\n+vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)\n {\n-  size_t i, j;\n-  bool min_take_default = !find_case_label_index (stmt, 1, min, &i);\n-  bool max_take_default = !find_case_label_index (stmt, i, max, &j);\n+  bool assignment_p = false;\n+  tree val;\n+  gimple *stmt = gsi_stmt (*si);\n \n-  if (i == j\n-      && min_take_default\n-      && max_take_default)\n+  if (is_gimple_assign (stmt)\n+      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n     {\n-      /* Only the default case label reached.\n-         Return an empty range. */\n-      *min_idx = 1;\n-      *max_idx = 0;\n-      return false;\n+      assignment_p = true;\n+      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n+\t\t\t\t      gimple_assign_rhs1 (stmt),\n+\t\t\t\t      gimple_assign_rhs2 (stmt),\n+\t\t\t\t      stmt);\n     }\n+  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t    gimple_cond_lhs (cond_stmt),\n+\t\t\t\t    gimple_cond_rhs (cond_stmt),\n+\t\t\t\t    stmt);\n   else\n+    return false;\n+\n+  if (val)\n     {\n-      bool take_default = min_take_default || max_take_default;\n-      tree low, high;\n-      size_t k;\n+      if (assignment_p)\n+        val = fold_convert (gimple_expr_type (stmt), val);\n \n-      if (max_take_default)\n-\tj--;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Folding predicate \");\n+\t  print_gimple_expr (dump_file, stmt, 0);\n+\t  fprintf (dump_file, \" to \");\n+\t  print_generic_expr (dump_file, val);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n \n-      /* If the case label range is continuous, we do not need\n-\t the default case label.  Verify that.  */\n-      high = CASE_LOW (gimple_switch_label (stmt, i));\n-      if (CASE_HIGH (gimple_switch_label (stmt, i)))\n-\thigh = CASE_HIGH (gimple_switch_label (stmt, i));\n-      for (k = i + 1; k <= j; ++k)\n+      if (is_gimple_assign (stmt))\n+\tgimple_assign_set_rhs_from_tree (si, val);\n+      else\n \t{\n-\t  low = CASE_LOW (gimple_switch_label (stmt, k));\n-\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high)))\n-\t    {\n-\t      take_default = true;\n-\t      break;\n-\t    }\n-\t  high = low;\n-\t  if (CASE_HIGH (gimple_switch_label (stmt, k)))\n-\t    high = CASE_HIGH (gimple_switch_label (stmt, k));\n+\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n+\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n+\t  if (integer_zerop (val))\n+\t    gimple_cond_make_false (cond_stmt);\n+\t  else if (integer_onep (val))\n+\t    gimple_cond_make_true (cond_stmt);\n+\t  else\n+\t    gcc_unreachable ();\n \t}\n \n-      *min_idx = i;\n-      *max_idx = j;\n-      return !take_default;\n+      return true;\n     }\n+\n+  return false;\n }\n \n-/* Given a SWITCH_STMT, return the case label that encompasses the\n-   known possible values for the switch operand.  RANGE_OF_OP is a\n-   range for the known values of the switch operand.  */\n+/* Callback for substitute_and_fold folding the stmt at *SI.  */\n \n-tree\n-find_case_label_range (gswitch *switch_stmt, const irange *range_of_op)\n+bool\n+vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n {\n-  if (range_of_op->undefined_p ()\n-      || range_of_op->varying_p ()\n-      || range_of_op->symbolic_p ())\n-    return NULL_TREE;\n+  if (fold_predicate_in (si))\n+    return true;\n \n-  size_t i, j;\n-  tree op = gimple_switch_index (switch_stmt);\n-  tree type = TREE_TYPE (op);\n-  tree tmin = wide_int_to_tree (type, range_of_op->lower_bound ());\n-  tree tmax = wide_int_to_tree (type, range_of_op->upper_bound ());\n-  find_case_label_range (switch_stmt, tmin, tmax, &i, &j);\n-  if (i == j)\n-    {\n-      /* Look for exactly one label that encompasses the range of\n-\t the operand.  */\n-      tree label = gimple_switch_label (switch_stmt, i);\n-      tree case_high\n-\t= CASE_HIGH (label) ? CASE_HIGH (label) : CASE_LOW (label);\n-      int_range_max label_range (CASE_LOW (label), case_high);\n-      if (!types_compatible_p (label_range.type (), range_of_op->type ()))\n-\trange_cast (label_range, range_of_op->type ());\n-      label_range.intersect (range_of_op);\n-      if (label_range == *range_of_op)\n-\treturn label;\n-    }\n-  else if (i > j)\n-    {\n-      /* If there are no labels at all, take the default.  */\n-      return gimple_switch_label (switch_stmt, 0);\n-    }\n-  else\n+  return simplify_stmt_using_ranges (si);\n+}\n+\n+class vrp_prop : public ssa_propagation_engine\n+{\n+public:\n+  enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;\n+  enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;\n+\n+  struct function *fun;\n+\n+  void initialize (struct function *);\n+  void finalize ();\n+\n+  class vr_values vr_values;\n+};\n+\n+/* Initialization required by ssa_propagate engine.  */\n+\n+void\n+vrp_prop::initialize (struct function *fn)\n+{\n+  basic_block bb;\n+  fun = fn;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n-      /* Otherwise, there are various labels that can encompass\n-\t the range of operand.  In which case, see if the range of\n-\t the operand is entirely *outside* the bounds of all the\n-\t (non-default) case labels.  If so, take the default.  */\n-      unsigned n = gimple_switch_num_labels (switch_stmt);\n-      tree min_label = gimple_switch_label (switch_stmt, 1);\n-      tree max_label = gimple_switch_label (switch_stmt, n - 1);\n-      tree case_high = CASE_HIGH (max_label);\n-      if (!case_high)\n-\tcase_high = CASE_LOW (max_label);\n-      int_range_max label_range (CASE_LOW (min_label), case_high);\n-      if (!types_compatible_p (label_range.type (), range_of_op->type ()))\n-\trange_cast (label_range, range_of_op->type ());\n-      label_range.intersect (range_of_op);\n-      if (label_range.undefined_p ())\n-\treturn gimple_switch_label (switch_stmt, 0);\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  gphi *phi = si.phi ();\n+\t  if (!stmt_interesting_for_vrp (phi))\n+\t    {\n+\t      tree lhs = PHI_RESULT (phi);\n+\t      vr_values.set_def_to_varying (lhs);\n+\t      prop_set_simulate_again (phi, false);\n+\t    }\n+\t  else\n+\t    prop_set_simulate_again (phi, true);\n+\t}\n+\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+        {\n+\t  gimple *stmt = gsi_stmt (si);\n+\n+ \t  /* If the statement is a control insn, then we do not\n+ \t     want to avoid simulating the statement once.  Failure\n+ \t     to do so means that those edges will never get added.  */\n+\t  if (stmt_ends_bb_p (stmt))\n+\t    prop_set_simulate_again (stmt, true);\n+\t  else if (!stmt_interesting_for_vrp (stmt))\n+\t    {\n+\t      vr_values.set_defs_to_varying (stmt);\n+\t      prop_set_simulate_again (stmt, false);\n+\t    }\n+\t  else\n+\t    prop_set_simulate_again (stmt, true);\n+\t}\n     }\n-  return NULL_TREE;\n }\n \n /* Evaluate statement STMT.  If the statement produces a useful range,\n@@ -3875,11 +3987,11 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n {\n   tree lhs = gimple_get_lhs (stmt);\n   value_range_equiv vr;\n-  extract_range_from_stmt (stmt, taken_edge_p, output_p, &vr);\n+  vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, &vr);\n \n   if (*output_p)\n     {\n-      if (update_value_range (*output_p, &vr))\n+      if (vr_values.update_value_range (*output_p, &vr))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -3914,7 +4026,7 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t    use_operand_p use_p;\n \t    enum ssa_prop_result res = SSA_PROP_VARYING;\n \n-\t    set_def_to_varying (lhs);\n+\t    vr_values.set_def_to_varying (lhs);\n \n \t    FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n \t      {\n@@ -3944,8 +4056,9 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \t\t   {REAL,IMAG}PART_EXPR uses at all,\n \t\t   return SSA_PROP_VARYING.  */\n \t\tvalue_range_equiv new_vr;\n-\t\textract_range_basic (&new_vr, use_stmt);\n-\t\tconst value_range_equiv *old_vr = get_value_range (use_lhs);\n+\t\tvr_values.extract_range_basic (&new_vr, use_stmt);\n+\t\tconst value_range_equiv *old_vr\n+\t\t  = vr_values.get_value_range (use_lhs);\n \t\tif (!old_vr->equal_p (new_vr, /*ignore_equivs=*/false))\n \t\t  res = SSA_PROP_INTERESTING;\n \t\telse\n@@ -3963,248 +4076,88 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n \tbreak;\n       default:\n \tbreak;\n-      }\n-\n-  /* All other statements produce nothing of interest for VRP, so mark\n-     their outputs varying and prevent further simulation.  */\n-  set_defs_to_varying (stmt);\n-\n-  return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n-}\n-\n-/* Visit all arguments for PHI node PHI that flow through executable\n-   edges.  If a valid value range can be derived from all the incoming\n-   value ranges, set a new range for the LHS of PHI.  */\n-\n-enum ssa_prop_result\n-vrp_prop::visit_phi (gphi *phi)\n-{\n-  tree lhs = PHI_RESULT (phi);\n-  value_range_equiv vr_result;\n-  extract_range_from_phi_node (phi, &vr_result);\n-  if (update_value_range (lhs, &vr_result))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Found new range for \");\n-\t  print_generic_expr (dump_file, lhs);\n-\t  fprintf (dump_file, \": \");\n-\t  dump_value_range (dump_file, &vr_result);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      if (vr_result.varying_p ())\n-\treturn SSA_PROP_VARYING;\n-\n-      return SSA_PROP_INTERESTING;\n-    }\n-\n-  /* Nothing changed, don't add outgoing edges.  */\n-  return SSA_PROP_NOT_INTERESTING;\n-}\n-\n-class vrp_folder : public substitute_and_fold_engine\n-{\n- public:\n-  vrp_folder (vr_values *v)\n-    : substitute_and_fold_engine (/* Fold all stmts.  */ true),\n-      m_vr_values (v), simplifier (v)\n-    {  }\n-  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n-\n-  tree value_of_expr (tree name, gimple *stmt) OVERRIDE\n-    {\n-      return m_vr_values->value_of_expr (name, stmt);\n-    }\n-  class vr_values *m_vr_values;\n-\n-private:\n-  bool fold_predicate_in (gimple_stmt_iterator *);\n-  /* Delegators.  */\n-  tree vrp_evaluate_conditional (tree_code code, tree op0,\n-\t\t\t\t tree op1, gimple *stmt)\n-    { return simplifier.vrp_evaluate_conditional (code, op0, op1, stmt); }\n-  bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n-    { return simplifier.simplify (gsi); }\n-\n-  simplify_using_ranges simplifier;\n-};\n-\n-/* If the statement pointed by SI has a predicate whose value can be\n-   computed using the value range information computed by VRP, compute\n-   its value and return true.  Otherwise, return false.  */\n-\n-bool\n-vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)\n-{\n-  bool assignment_p = false;\n-  tree val;\n-  gimple *stmt = gsi_stmt (*si);\n-\n-  if (is_gimple_assign (stmt)\n-      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n-    {\n-      assignment_p = true;\n-      val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),\n-\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t      gimple_assign_rhs2 (stmt),\n-\t\t\t\t      stmt);\n-    }\n-  else if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t    gimple_cond_lhs (cond_stmt),\n-\t\t\t\t    gimple_cond_rhs (cond_stmt),\n-\t\t\t\t    stmt);\n-  else\n-    return false;\n-\n-  if (val)\n-    {\n-      if (assignment_p)\n-        val = fold_convert (gimple_expr_type (stmt), val);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Folding predicate \");\n-\t  print_gimple_expr (dump_file, stmt, 0);\n-\t  fprintf (dump_file, \" to \");\n-\t  print_generic_expr (dump_file, val);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      if (is_gimple_assign (stmt))\n-\tgimple_assign_set_rhs_from_tree (si, val);\n-      else\n-\t{\n-\t  gcc_assert (gimple_code (stmt) == GIMPLE_COND);\n-\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n-\t  if (integer_zerop (val))\n-\t    gimple_cond_make_false (cond_stmt);\n-\t  else if (integer_onep (val))\n-\t    gimple_cond_make_true (cond_stmt);\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Callback for substitute_and_fold folding the stmt at *SI.  */\n-\n-bool\n-vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n-{\n-  if (fold_predicate_in (si))\n-    return true;\n+      }\n \n-  return simplify_stmt_using_ranges (si);\n+  /* All other statements produce nothing of interest for VRP, so mark\n+     their outputs varying and prevent further simulation.  */\n+  vr_values.set_defs_to_varying (stmt);\n+\n+  return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n-/* Return the LHS of any ASSERT_EXPR where OP appears as the first\n-   argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n-   BB.  If no such ASSERT_EXPR is found, return OP.  */\n+/* Visit all arguments for PHI node PHI that flow through executable\n+   edges.  If a valid value range can be derived from all the incoming\n+   value ranges, set a new range for the LHS of PHI.  */\n \n-static tree\n-lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)\n+enum ssa_prop_result\n+vrp_prop::visit_phi (gphi *phi)\n {\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-\n-  if (TREE_CODE (op) == SSA_NAME)\n+  tree lhs = PHI_RESULT (phi);\n+  value_range_equiv vr_result;\n+  vr_values.extract_range_from_phi_node (phi, &vr_result);\n+  if (vr_values.update_value_range (lhs, &vr_result))\n     {\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  use_stmt = USE_STMT (use_p);\n-\t  if (use_stmt != stmt\n-\t      && gimple_assign_single_p (use_stmt)\n-\t      && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR\n-\t      && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op\n-\t      && dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))\n-\t    return gimple_assign_lhs (use_stmt);\n+\t  fprintf (dump_file, \"Found new range for \");\n+\t  print_generic_expr (dump_file, lhs);\n+\t  fprintf (dump_file, \": \");\n+\t  dump_value_range (dump_file, &vr_result);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n-    }\n-  return op;\n-}\n \n-/* A hack.  */\n-static class vr_values *x_vr_values;\n+      if (vr_result.varying_p ())\n+\treturn SSA_PROP_VARYING;\n \n-/* A trivial wrapper so that we can present the generic jump threading\n-   code with a simple API for simplifying statements.  STMT is the\n-   statement we want to simplify, WITHIN_STMT provides the location\n-   for any overflow warnings.\n+      return SSA_PROP_INTERESTING;\n+    }\n \n-   ?? This should be cleaned up.  There's a virtually identical copy\n-   of this function in tree-ssa-dom.c.  */\n+  /* Nothing changed, don't add outgoing edges.  */\n+  return SSA_PROP_NOT_INTERESTING;\n+}\n \n-static tree\n-simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n-    class avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED,\n-    basic_block bb)\n-{\n-  /* First see if the conditional is in the hash table.  */\n-  tree cached_lhs = avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n-  if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n-    return cached_lhs;\n+/* Traverse all the blocks folding conditionals with known ranges.  */\n \n-  vr_values *vr_values = x_vr_values;\n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      tree op0 = gimple_cond_lhs (cond_stmt);\n-      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n+void\n+vrp_prop::finalize ()\n+{\n+  size_t i;\n \n-      tree op1 = gimple_cond_rhs (cond_stmt);\n-      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n+  /* We have completed propagating through the lattice.  */\n+  vr_values.set_lattice_propagation_complete ();\n \n-      simplify_using_ranges simplifier (vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  op0, op1, within_stmt);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nValue ranges after VRP:\\n\\n\");\n+      vr_values.dump_all_value_ranges (dump_file);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+  /* Set value range to non pointer SSA_NAMEs.  */\n+  for (i = 0; i < num_ssa_names; i++)\n     {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n-\n-      op = lhs_of_dominating_assert (op, bb, stmt);\n+      tree name = ssa_name (i);\n+      if (!name)\n+\tcontinue;\n \n-      const value_range_equiv *vr = vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n+      const value_range_equiv *vr = vr_values.get_value_range (name);\n+      if (!name || !vr->constant_p ())\n+\tcontinue;\n \n-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  vr_values->extract_range_from_stmt (stmt, &dummy_e,\n-\t\t\t\t\t      &dummy_tree, &new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n-\t}\n+      if (POINTER_TYPE_P (TREE_TYPE (name))\n+\t  && range_includes_zero_p (vr) == 0)\n+\tset_ptr_nonnull (name);\n+      else if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+\tset_range_info (name, *vr);\n     }\n-\n-  return NULL_TREE;\n }\n \n-class vrp_dom_walker : public dom_walker\n+class vrp_jump_threader : public dom_walker\n {\n public:\n-  vrp_dom_walker (cdi_direction direction,\n-\t\t  class const_and_copies *const_and_copies,\n-\t\t  class avail_exprs_stack *avail_exprs_stack)\n+  vrp_jump_threader (cdi_direction direction,\n+\t\t     class const_and_copies *const_and_copies,\n+\t\t     class avail_exprs_stack *avail_exprs_stack)\n     : dom_walker (direction, REACHABLE_BLOCKS),\n       m_const_and_copies (const_and_copies),\n       m_avail_exprs_stack (avail_exprs_stack),\n@@ -4216,11 +4169,13 @@ class vrp_dom_walker : public dom_walker\n   class vr_values *vr_values;\n \n private:\n+  static tree simplify_stmt (gimple *stmt, gimple *within_stmt,\n+\t\t\t     avail_exprs_stack *, basic_block);\n+\n   class const_and_copies *m_const_and_copies;\n   class avail_exprs_stack *m_avail_exprs_stack;\n \n   gcond *m_dummy_cond;\n-\n };\n \n /* Called before processing dominator children of BB.  We want to look\n@@ -4231,7 +4186,7 @@ class vrp_dom_walker : public dom_walker\n    to significantly increase the jump threads we discover.  */\n \n edge\n-vrp_dom_walker::before_dom_children (basic_block bb)\n+vrp_jump_threader::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -4263,10 +4218,77 @@ vrp_dom_walker::before_dom_children (basic_block bb)\n   return NULL;\n }\n \n+/* A trivial wrapper so that we can present the generic jump threading\n+   code with a simple API for simplifying statements.  STMT is the\n+   statement we want to simplify, WITHIN_STMT provides the location\n+   for any overflow warnings.\n+\n+   ?? This should be cleaned up.  There's a virtually identical copy\n+   of this function in tree-ssa-dom.c.  */\n+\n+tree\n+vrp_jump_threader::simplify_stmt (gimple *stmt,\n+\t\t\t\t  gimple *within_stmt,\n+\t\t\t\t  avail_exprs_stack *avail_exprs_stack,\n+\t\t\t\t  basic_block bb)\n+{\n+  /* First see if the conditional is in the hash table.  */\n+  tree cached_lhs = avail_exprs_stack->lookup_avail_expr (stmt, false, true);\n+  if (cached_lhs && is_gimple_min_invariant (cached_lhs))\n+    return cached_lhs;\n+\n+  class vr_values *vr_values = x_vr_values;\n+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n+    {\n+      tree op0 = gimple_cond_lhs (cond_stmt);\n+      op0 = lhs_of_dominating_assert (op0, bb, stmt);\n+\n+      tree op1 = gimple_cond_rhs (cond_stmt);\n+      op1 = lhs_of_dominating_assert (op1, bb, stmt);\n+\n+      simplify_using_ranges simplifier (vr_values);\n+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n+\t\t\t\t\t\t  op0, op1, within_stmt);\n+    }\n+\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      op = lhs_of_dominating_assert (op, bb, stmt);\n+\n+      const value_range_equiv *vr = vr_values->get_value_range (op);\n+      return find_case_label_range (switch_stmt, vr);\n+    }\n+\n+  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign_stmt);\n+      if (TREE_CODE (lhs) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t  && stmt_interesting_for_vrp (stmt))\n+\t{\n+\t  edge dummy_e;\n+\t  tree dummy_tree;\n+\t  value_range_equiv new_vr;\n+\t  vr_values->extract_range_from_stmt (stmt, &dummy_e,\n+\t\t\t\t\t      &dummy_tree, &new_vr);\n+\t  tree singleton;\n+\t  if (new_vr.singleton_p (&singleton))\n+\t    return singleton;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Called after processing dominator children of BB.  This is where we\n    actually call into the threader.  */\n void\n-vrp_dom_walker::after_dom_children (basic_block bb)\n+vrp_jump_threader::after_dom_children (basic_block bb)\n {\n   if (!m_dummy_cond)\n     m_dummy_cond = gimple_build_cond (NE_EXPR,\n@@ -4276,7 +4298,7 @@ vrp_dom_walker::after_dom_children (basic_block bb)\n   x_vr_values = vr_values;\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack, NULL,\n-\t\t\t simplify_stmt_for_jump_threading);\n+\t\t\t simplify_stmt);\n   x_vr_values = NULL;\n \n   m_avail_exprs_stack->pop_to_marker ();\n@@ -4327,7 +4349,7 @@ identify_jump_threads (struct function *fun, class vr_values *vr_values)\n   avail_exprs_stack *avail_exprs_stack\n     = new class avail_exprs_stack (avail_exprs);\n \n-  vrp_dom_walker walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);\n+  vrp_jump_threader walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);\n   walker.vr_values = vr_values;\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n@@ -4339,62 +4361,6 @@ identify_jump_threads (struct function *fun, class vr_values *vr_values)\n   delete avail_exprs_stack;\n }\n \n-/* Traverse all the blocks folding conditionals with known ranges.  */\n-\n-void\n-vrp_prop::vrp_finalize (vrp_folder *folder, bool warn_array_bounds_p)\n-{\n-  size_t i;\n-\n-  /* We have completed propagating through the lattice.  */\n-  vr_values.set_lattice_propagation_complete ();\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nValue ranges after VRP:\\n\\n\");\n-      vr_values.dump_all_value_ranges (dump_file);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* Set value range to non pointer SSA_NAMEs.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      tree name = ssa_name (i);\n-      if (!name)\n-\tcontinue;\n-\n-      const value_range_equiv *vr = get_value_range (name);\n-      if (!name || !vr->constant_p ())\n-\tcontinue;\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (name))\n-\t  && range_includes_zero_p (vr) == 0)\n-\tset_ptr_nonnull (name);\n-      else if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-\tset_range_info (name, *vr);\n-    }\n-\n-  /* If we're checking array refs, we want to merge information on\n-     the executability of each edge between vrp_folder and the\n-     check_array_bounds_dom_walker: each can clear the\n-     EDGE_EXECUTABLE flag on edges, in different ways.\n-\n-     Hence, if we're going to call check_all_array_refs, set\n-     the flag on every edge now, rather than in\n-     check_array_bounds_dom_walker's ctor; vrp_folder may clear\n-     it from some edges.  */\n-  if (warn_array_bounds && warn_array_bounds_p)\n-    set_all_edges_as_executable (fun);\n-\n-  folder->substitute_and_fold ();\n-\n-  if (warn_array_bounds && warn_array_bounds_p)\n-    {\n-      array_bounds_checker array_checker (fun, &vr_values);\n-      array_checker.check ();\n-    }\n-}\n-\n /* STMT is a conditional at the end of a basic block.\n \n    If the conditional is of the form SSA_NAME op constant and the SSA_NAME\n@@ -4511,7 +4477,7 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   /* ???  This ends up using stale EDGE_DFS_BACK for liveness computation.\n      Inserting assertions may split edges which will invalidate\n      EDGE_DFS_BACK.  */\n-  vrp_insert assert_engine (fun);\n+  vrp_asserts assert_engine (fun);\n   assert_engine.insert_range_assertions ();\n \n   threadedge_initialize_values ();\n@@ -4520,12 +4486,33 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   mark_dfs_back_edges ();\n \n   class vrp_prop vrp_prop;\n-  vrp_prop.vrp_initialize (fun);\n+  vrp_prop.initialize (fun);\n   vrp_prop.ssa_propagate ();\n+\n   /* Instantiate the folder here, so that edge cleanups happen at the\n      end of this function.  */\n   vrp_folder folder (&vrp_prop.vr_values);\n-  vrp_prop.vrp_finalize (&folder, warn_array_bounds_p);\n+  vrp_prop.finalize ();\n+\n+  /* If we're checking array refs, we want to merge information on\n+     the executability of each edge between vrp_folder and the\n+     check_array_bounds_dom_walker: each can clear the\n+     EDGE_EXECUTABLE flag on edges, in different ways.\n+\n+     Hence, if we're going to call check_all_array_refs, set\n+     the flag on every edge now, rather than in\n+     check_array_bounds_dom_walker's ctor; vrp_folder may clear\n+     it from some edges.  */\n+  if (warn_array_bounds && warn_array_bounds_p)\n+    set_all_edges_as_executable (fun);\n+\n+  folder.substitute_and_fold ();\n+\n+  if (warn_array_bounds && warn_array_bounds_p)\n+    {\n+      array_bounds_checker array_checker (fun, &vrp_prop.vr_values);\n+      array_checker.check ();\n+    }\n \n   /* We must identify jump threading opportunities before we release\n      the datastructures built by VRP.  */"}]}