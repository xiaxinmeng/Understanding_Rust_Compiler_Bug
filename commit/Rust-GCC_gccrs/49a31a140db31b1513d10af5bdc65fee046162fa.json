{"sha": "49a31a140db31b1513d10af5bdc65fee046162fa", "node_id": "C_kwDOANBUbNoAKDQ5YTMxYTE0MGRiMzFiMTUxM2QxMGFmNWJkYzY1ZmVlMDQ2MTYyZmE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-02-07T10:44:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-12T12:38:36Z"}, "message": "[Ada] Revamp analysis of conditional expressions\n\nThe current implementation is skewed toward the first dependent\nexpression and does not look into the interpretations of the others if\nthe first one is not overloaded, which can create spurious ambiguities.\nAnd more precise error messages are now given if the types of the\ndependent expressions are not compatible.\n\ngcc/ada/\n\n\t* sem_ch4.adb (Analyze_Case_Expression): Rewrite.\n\t(Analyze_If_Expression): Likewise.\n\t(Possible_Type_For_Conditional_Expression): New function.\n\t* sem_type.adb (Specific_Type): Retur the base type in more\n\tcases.", "tree": {"sha": "c367903ecd5f0dd314399a52450a47a1819168c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c367903ecd5f0dd314399a52450a47a1819168c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49a31a140db31b1513d10af5bdc65fee046162fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a31a140db31b1513d10af5bdc65fee046162fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a31a140db31b1513d10af5bdc65fee046162fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a31a140db31b1513d10af5bdc65fee046162fa/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91d68769419b64ef9843c4c1eac5261217693b1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d68769419b64ef9843c4c1eac5261217693b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d68769419b64ef9843c4c1eac5261217693b1e"}], "stats": {"total": 489, "additions": 396, "deletions": 93}, "files": [{"sha": "d9cd78b6bae1bb4a15d7897073a9c778fb5f1b87", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 390, "deletions": 87, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a31a140db31b1513d10af5bdc65fee046162fa/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a31a140db31b1513d10af5bdc65fee046162fa/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=49a31a140db31b1513d10af5bdc65fee046162fa", "patch": "@@ -265,6 +265,22 @@ package body Sem_Ch4 is\n    --  these aspects can be achieved without larger modifications to the\n    --  two-pass resolution algorithm.\n \n+   function Possible_Type_For_Conditional_Expression\n+     (T1, T2 : Entity_Id) return Entity_Id;\n+   --  Given two types T1 and T2 that are _not_ compatible, return a type that\n+   --  may still be used as the possible type of a conditional expression whose\n+   --  dependent expressions, or part thereof, have type T1 and T2 respectively\n+   --  during the first phase of type resolution, or Empty if such a type does\n+   --  not exist.\n+\n+   --  The typical example is an if_expression whose then_expression is of a\n+   --  tagged type and whose else_expresssion is of an extension of this type:\n+   --  the types are not compatible but such an if_expression can be legal if\n+   --  its expected type is the 'Class of the tagged type, so the function will\n+   --  return the tagged type in this case. If the expected type turns out to\n+   --  be something else, including the tagged type itself, then an error will\n+   --  be given during the second phase of type resolution.\n+\n    procedure Remove_Abstract_Operations (N : Node_Id);\n    --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n    --  operation is not a candidate interpretation.\n@@ -1559,10 +1575,30 @@ package body Sem_Ch4 is\n    -----------------------------\n \n    procedure Analyze_Case_Expression (N : Node_Id) is\n+      Expr      : constant Node_Id := Expression (N);\n+      First_Alt : constant Node_Id := First (Alternatives (N));\n+\n+      First_Expr : Node_Id := Empty;\n+      --  First expression in the case where there is some type information\n+      --  available, i.e. there is not Any_Type everywhere, which can happen\n+      --  because of some error.\n+\n+      Second_Expr : Node_Id := Empty;\n+      --  Second expression as above\n+\n+      Wrong_Alt : Node_Id := Empty;\n+      --  For error reporting\n+\n       procedure Non_Static_Choice_Error (Choice : Node_Id);\n       --  Error routine invoked by the generic instantiation below when\n       --  the case expression has a non static choice.\n \n+      procedure Check_Next_Expression (T : Entity_Id; Alt : Node_Id);\n+      --  Check one interpretation of the next expression with type T\n+\n+      procedure Check_Expression_Pair (T1, T2 : Entity_Id; Alt : Node_Id);\n+      --  Check first expression with type T1 and next expression with type T2\n+\n       package Case_Choices_Analysis is new\n         Generic_Analyze_Choices\n           (Process_Associated_Node => No_OP);\n@@ -1585,23 +1621,81 @@ package body Sem_Ch4 is\n            (\"choice given in case expression is not static!\", Choice);\n       end Non_Static_Choice_Error;\n \n-      --  Local variables\n+      ---------------------------\n+      -- Check_Next_Expression --\n+      ---------------------------\n \n-      Expr      : constant Node_Id := Expression (N);\n-      Alt       : Node_Id;\n-      Exp_Type  : Entity_Id;\n-      Exp_Btype : Entity_Id;\n+      procedure Check_Next_Expression (T : Entity_Id; Alt : Node_Id) is\n+         Next_Expr : constant Node_Id := Expression (Alt);\n \n-      FirstX : Node_Id := Empty;\n-      --  First expression in the case for which there is some type information\n-      --  available, i.e. it is not Any_Type, which can happen because of some\n-      --  error, or from the use of e.g. raise Constraint_Error.\n+         I     : Interp_Index;\n+         It    : Interp;\n \n-      Others_Present : Boolean;\n-      --  Indicates if Others was present\n+      begin\n+         if Next_Expr = First_Expr then\n+            Check_Next_Expression (T, Next (Alt));\n+            return;\n+         end if;\n \n-      Wrong_Alt : Node_Id := Empty;\n-      --  For error reporting\n+         --  Loop through the interpretations of the next expression\n+\n+         if not Is_Overloaded (Next_Expr) then\n+            Check_Expression_Pair (T, Etype (Next_Expr), Alt);\n+\n+         else\n+            Get_First_Interp (Next_Expr, I, It);\n+            while Present (It.Typ) loop\n+               Check_Expression_Pair (T, It.Typ, Alt);\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end if;\n+      end Check_Next_Expression;\n+\n+      ---------------------------\n+      -- Check_Expression_Pair --\n+      ---------------------------\n+\n+      procedure Check_Expression_Pair (T1, T2 : Entity_Id; Alt : Node_Id) is\n+         Next_Expr : constant Node_Id := Expression (Alt);\n+\n+         T : Entity_Id;\n+\n+      begin\n+         if Covers (T1 => T1, T2 => T2)\n+           or else Covers (T1 => T2, T2 => T1)\n+         then\n+            T := Specific_Type (T1, T2);\n+\n+         elsif Is_User_Defined_Literal (First_Expr, T2) then\n+            T := T2;\n+\n+         elsif Is_User_Defined_Literal (Next_Expr, T1) then\n+            T := T1;\n+\n+         else\n+            T := Possible_Type_For_Conditional_Expression (T1, T2);\n+\n+            if No (T) then\n+               Wrong_Alt := Alt;\n+               return;\n+            end if;\n+         end if;\n+\n+         if Present (Next (Alt)) then\n+            Check_Next_Expression (T, Next (Alt));\n+         else\n+            Add_One_Interp (N, T, T);\n+         end if;\n+      end Check_Expression_Pair;\n+\n+      --  Local variables\n+\n+      Alt            : Node_Id;\n+      Exp_Type       : Entity_Id;\n+      Exp_Btype      : Entity_Id;\n+      I              : Interp_Index;\n+      It             : Interp;\n+      Others_Present : Boolean;\n \n    --  Start of processing for Analyze_Case_Expression\n \n@@ -1611,16 +1705,23 @@ package body Sem_Ch4 is\n       Exp_Type := Etype (Expr);\n       Exp_Btype := Base_Type (Exp_Type);\n \n-      Alt := First (Alternatives (N));\n+      Set_Etype (N, Any_Type);\n+\n+      Alt := First_Alt;\n       while Present (Alt) loop\n          if Error_Posted (Expression (Alt)) then\n             return;\n          end if;\n \n-         Analyze (Expression (Alt));\n+         Analyze_Expression (Expression (Alt));\n \n-         if No (FirstX) and then Etype (Expression (Alt)) /= Any_Type then\n-            FirstX := Expression (Alt);\n+         if Etype (Expression (Alt)) /= Any_Type then\n+            if No (First_Expr) then\n+               First_Expr := Expression (Alt);\n+\n+            elsif No (Second_Expr) then\n+               Second_Expr := Expression (Alt);\n+            end if;\n          end if;\n \n          Next (Alt);\n@@ -1629,47 +1730,33 @@ package body Sem_Ch4 is\n       --  Get our initial type from the first expression for which we got some\n       --  useful type information from the expression.\n \n-      if No (FirstX) then\n+      if No (First_Expr) then\n          return;\n       end if;\n \n-      if not Is_Overloaded (FirstX) then\n-         Set_Etype (N, Etype (FirstX));\n-\n-      else\n-         declare\n-            I  : Interp_Index;\n-            It : Interp;\n+      --  Loop through the interpretations of the first expression and check\n+      --  the other expressions if present.\n \n-         begin\n-            Set_Etype (N, Any_Type);\n-\n-            Get_First_Interp (FirstX, I, It);\n-            while Present (It.Nam) loop\n-\n-               --  For each interpretation of the first expression, we only\n-               --  add the interpretation if every other expression in the\n-               --  case expression alternatives has a compatible type.\n-\n-               Alt := Next (First (Alternatives (N)));\n-               while Present (Alt) loop\n-                  exit when not Has_Compatible_Type (Expression (Alt), It.Typ);\n-                  Next (Alt);\n-               end loop;\n+      if not Is_Overloaded (First_Expr) then\n+         if Present (Second_Expr) then\n+            Check_Next_Expression (Etype (First_Expr), First_Alt);\n+         else\n+            Set_Etype (N, Etype (First_Expr));\n+         end if;\n \n-               if No (Alt) then\n-                  Add_One_Interp (N, It.Typ, It.Typ);\n-               else\n-                  Wrong_Alt := Alt;\n-               end if;\n+      else\n+         Get_First_Interp (First_Expr, I, It);\n+         while Present (It.Typ) loop\n+            if Present (Second_Expr) then\n+               Check_Next_Expression (It.Typ, First_Alt);\n+            else\n+               Add_One_Interp (N, It.Typ, It.Typ);\n+            end if;\n \n-               Get_Next_Interp (I, It);\n-            end loop;\n-         end;\n+            Get_Next_Interp (I, It);\n+         end loop;\n       end if;\n \n-      Exp_Btype := Base_Type (Exp_Type);\n-\n       --  The expression must be of a discrete type which must be determinable\n       --  independently of the context in which the expression occurs, but\n       --  using the fact that the expression must be of a discrete type.\n@@ -1689,10 +1776,54 @@ package body Sem_Ch4 is\n          return;\n       end if;\n \n+      --  If no possible interpretation has been found, the type of the wrong\n+      --  alternative doesn't match any interpretation of the FIRST expression.\n+\n       if Etype (N) = Any_Type and then Present (Wrong_Alt) then\n-         Error_Msg_N\n-           (\"type incompatible with that of previous alternatives\",\n-            Expression (Wrong_Alt));\n+         Second_Expr := Expression (Wrong_Alt);\n+\n+         if Is_Overloaded (First_Expr) then\n+            if Is_Overloaded (Second_Expr) then\n+               Error_Msg_N\n+                 (\"no interpretation compatible with those of previous \"\n+                  & \"alternative\",\n+                  Second_Expr);\n+            else\n+               Error_Msg_N\n+                 (\"type incompatible with interpretations of previous \"\n+                  & \"alternative\",\n+                  Second_Expr);\n+               Error_Msg_NE\n+                 (\"\\this alternative has}!\",\n+                  Second_Expr,\n+                  Etype (Second_Expr));\n+            end if;\n+\n+         else\n+            if Is_Overloaded (Second_Expr) then\n+               Error_Msg_N\n+                 (\"no interpretation compatible with type of previous \"\n+                  & \"alternative\",\n+                  Second_Expr);\n+               Error_Msg_NE\n+                 (\"\\previous alternative has}!\",\n+                  Second_Expr,\n+                  Etype (First_Expr));\n+            else\n+               Error_Msg_N\n+                 (\"type incompatible with that of previous alternative\",\n+                  Second_Expr);\n+               Error_Msg_NE\n+                 (\"\\previous alternative has}!\",\n+                  Second_Expr,\n+                  Etype (First_Expr));\n+               Error_Msg_NE\n+                 (\"\\this alternative has}!\",\n+                  Second_Expr,\n+                  Etype (Second_Expr));\n+            end if;\n+         end if;\n+\n          return;\n       end if;\n \n@@ -2311,9 +2442,76 @@ package body Sem_Ch4 is\n \n    procedure Analyze_If_Expression (N : Node_Id) is\n       Condition : constant Node_Id := First (Expressions (N));\n+\n       Then_Expr : Node_Id;\n       Else_Expr : Node_Id;\n \n+      procedure Check_Else_Expression (T : Entity_Id);\n+      --  Check one interpretation of the THEN expression with type T\n+\n+      procedure Check_Expression_Pair (T1, T2 : Entity_Id);\n+      --  Check THEN expression with type T1 and ELSE expression with type T2\n+\n+      ---------------------------\n+      -- Check_Else_Expression --\n+      ---------------------------\n+\n+      procedure Check_Else_Expression (T : Entity_Id) is\n+         I    : Interp_Index;\n+         It   : Interp;\n+\n+      begin\n+         --  Loop through the interpretations of the ELSE expression\n+\n+         if not Is_Overloaded (Else_Expr) then\n+            Check_Expression_Pair (T, Etype (Else_Expr));\n+\n+         else\n+            Get_First_Interp (Else_Expr, I, It);\n+            while Present (It.Typ) loop\n+               Check_Expression_Pair (T, It.Typ);\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end if;\n+      end Check_Else_Expression;\n+\n+      ---------------------------\n+      -- Check_Expression_Pair --\n+      ---------------------------\n+\n+      procedure Check_Expression_Pair (T1, T2 : Entity_Id) is\n+         T : Entity_Id;\n+\n+      begin\n+         if Covers (T1 => T1, T2 => T2)\n+           or else Covers (T1 => T2, T2 => T1)\n+         then\n+            T := Specific_Type (T1, T2);\n+\n+         elsif Is_User_Defined_Literal (Then_Expr, T2) then\n+            T := T2;\n+\n+         elsif Is_User_Defined_Literal (Else_Expr, T1) then\n+            T := T1;\n+\n+         else\n+            T := Possible_Type_For_Conditional_Expression (T1, T2);\n+\n+            if No (T) then\n+               return;\n+            end if;\n+         end if;\n+\n+         Add_One_Interp (N, T, T);\n+      end Check_Expression_Pair;\n+\n+      --  Local variables\n+\n+      I  : Interp_Index;\n+      It : Interp;\n+\n+      --  Start of processing for Analyze_If_Expression\n+\n    begin\n       --  Defend against error of missing expressions from previous error\n \n@@ -2322,6 +2520,8 @@ package body Sem_Ch4 is\n          return;\n       end if;\n \n+      Set_Etype (N, Any_Type);\n+\n       Then_Expr := Next (Condition);\n \n       if No (Then_Expr) then\n@@ -2340,58 +2540,74 @@ package body Sem_Ch4 is\n       Analyze_Expression (Condition);\n       Resolve (Condition, Any_Boolean);\n \n-      --  Analyze THEN expression and (if present) ELSE expression. For those\n-      --  we delay resolution in the normal manner, because of overloading etc.\n+      --  Analyze the THEN expression and (if present) the ELSE expression. For\n+      --  them we delay resolution in the normal manner because of overloading.\n \n       Analyze_Expression (Then_Expr);\n \n       if Present (Else_Expr) then\n          Analyze_Expression (Else_Expr);\n       end if;\n \n-      --  If then expression not overloaded, then that decides the type\n+      --  Loop through the interpretations of the THEN expression and check the\n+      --  ELSE expression if present.\n \n       if not Is_Overloaded (Then_Expr) then\n-         Set_Etype (N, Etype (Then_Expr));\n-\n-      --  Case where then expression is overloaded\n+         if Present (Else_Expr) then\n+            Check_Else_Expression (Etype (Then_Expr));\n+         else\n+            Set_Etype (N, Etype (Then_Expr));\n+         end if;\n \n       else\n-         declare\n-            I  : Interp_Index;\n-            It : Interp;\n-\n-         begin\n-            Set_Etype (N, Any_Type);\n-\n-            --  Loop through interpretations of Then_Expr\n-\n-            Get_First_Interp (Then_Expr, I, It);\n-            while Present (It.Nam) loop\n+         Get_First_Interp (Then_Expr, I, It);\n+         while Present (It.Typ) loop\n+            if Present (Else_Expr) then\n+               Check_Else_Expression (It.Typ);\n+            else\n+               Add_One_Interp (N, It.Typ, It.Typ);\n+            end if;\n \n-               --  Add possible interpretation of Then_Expr if no Else_Expr, or\n-               --  Else_Expr is present and has a compatible type.\n+            Get_Next_Interp (I, It);\n+         end loop;\n+      end if;\n \n-               if No (Else_Expr)\n-                 or else Has_Compatible_Type (Else_Expr, It.Typ)\n-               then\n-                  Add_One_Interp (N, It.Typ, It.Typ);\n-               end if;\n+      --  If no possible interpretation has been found, the type of the\n+      --  ELSE expression does not match any interpretation of the THEN\n+      --  expression.\n \n-               Get_Next_Interp (I, It);\n-            end loop;\n-\n-            --  If no valid interpretation has been found, then the type of the\n-            --  ELSE expression does not match any interpretation of the THEN\n-            --  expression.\n+      if Etype (N) = Any_Type then\n+         if Is_Overloaded (Then_Expr) then\n+            if Is_Overloaded (Else_Expr) then\n+               Error_Msg_N\n+                 (\"no interpretation compatible with those of THEN expression\",\n+                  Else_Expr);\n+            else\n+               Error_Msg_N\n+                 (\"type of ELSE incompatible with interpretations of THEN \"\n+                  & \"expression\",\n+                  Else_Expr);\n+               Error_Msg_NE\n+                 (\"\\ELSE expression has}!\", Else_Expr, Etype (Else_Expr));\n+            end if;\n \n-            if Etype (N) = Any_Type then\n+         else\n+            if Is_Overloaded (Else_Expr) then\n                Error_Msg_N\n-                 (\"type incompatible with that of THEN expression\",\n+                 (\"no interpretation compatible with type of THEN expression\",\n                   Else_Expr);\n-               return;\n+               Error_Msg_NE\n+                 (\"\\THEN expression has}!\", Else_Expr, Etype (Then_Expr));\n+            else\n+               Error_Msg_N\n+                 (\"type of ELSE incompatible with that of THEN expression\",\n+                  Else_Expr);\n+               Error_Msg_NE\n+                 (\"\\THEN expression has}!\", Else_Expr, Etype (Then_Expr));\n+               Error_Msg_NE\n+                 (\"\\ELSE expression has}!\", Else_Expr, Etype (Else_Expr));\n             end if;\n-         end;\n+         end if;\n       end if;\n    end Analyze_If_Expression;\n \n@@ -7638,6 +7854,93 @@ package body Sem_Ch4 is\n       return Etype (N) /= Any_Type;\n    end Has_Possible_Literal_Aspects;\n \n+   ----------------------------------------------\n+   -- Possible_Type_For_Conditional_Expression --\n+   ----------------------------------------------\n+\n+   function Possible_Type_For_Conditional_Expression\n+     (T1, T2 : Entity_Id) return Entity_Id\n+   is\n+      function Is_Access_Protected_Subprogram_Attribute\n+        (T : Entity_Id) return Boolean;\n+      --  Return true if T is the type of an access-to-protected-subprogram\n+      --  attribute.\n+\n+      function Is_Access_Subprogram_Attribute (T : Entity_Id) return Boolean;\n+      --  Return true if T is the type of an access-to-subprogram attribute\n+\n+      ----------------------------------------------\n+      -- Is_Access_Protected_Subprogram_Attribute --\n+      ----------------------------------------------\n+\n+      function Is_Access_Protected_Subprogram_Attribute\n+        (T : Entity_Id) return Boolean\n+      is\n+      begin\n+         return Ekind (T) = E_Access_Protected_Subprogram_Type\n+           and then Ekind (Designated_Type (T)) /= E_Subprogram_Type;\n+      end Is_Access_Protected_Subprogram_Attribute;\n+\n+      ------------------------------------\n+      -- Is_Access_Subprogram_Attribute --\n+      ------------------------------------\n+\n+      function Is_Access_Subprogram_Attribute (T : Entity_Id) return Boolean is\n+      begin\n+         return Ekind (T) = E_Access_Subprogram_Type\n+           and then Ekind (Designated_Type (T)) /= E_Subprogram_Type;\n+      end Is_Access_Subprogram_Attribute;\n+\n+   --  Start of processing for Possible_Type_For_Conditional_Expression\n+\n+   begin\n+      --  If both types are those of similar access attributes or allocators,\n+      --  pick one of them, for example the first.\n+\n+      if Ekind (T1) in E_Access_Attribute_Type | E_Allocator_Type\n+        and then Ekind (T2) in E_Access_Attribute_Type | E_Allocator_Type\n+      then\n+         return T1;\n+\n+      elsif Is_Access_Subprogram_Attribute (T1)\n+        and then Is_Access_Subprogram_Attribute (T2)\n+      then\n+         return T1;\n+\n+      elsif Is_Access_Protected_Subprogram_Attribute (T1)\n+        and then Is_Access_Protected_Subprogram_Attribute (T2)\n+      then\n+         return T1;\n+\n+      --  The other case to be considered is a pair of tagged types\n+\n+      elsif Is_Tagged_Type (T1) and then Is_Tagged_Type (T2) then\n+         --  Covers performs the same checks when T1 or T2 are a CW type, so\n+         --  we don't need to do them again here.\n+\n+         if not Is_Class_Wide_Type (T1) and then Is_Ancestor (T1, T2) then\n+            return T1;\n+\n+         elsif not Is_Class_Wide_Type (T2) and then Is_Ancestor (T2, T1) then\n+            return T2;\n+\n+         --  Neither type is an ancestor of the other, but they may have one in\n+         --  common, so we pick the first type as above. We could perform here\n+         --  the computation of the nearest common ancestors of T1 and T2, but\n+         --  this would require a significant amount of work and the practical\n+         --  benefit would very likely be negligible.\n+\n+         else\n+            return T1;\n+         end if;\n+\n+      --  Otherwise no type is possible\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Possible_Type_For_Conditional_Expression;\n+\n    --------------------------------\n    -- Remove_Abstract_Operations --\n    --------------------------------"}, {"sha": "4476ea970e9ec7a2973833c5de3ca7a163d1e4f8", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a31a140db31b1513d10af5bdc65fee046162fa/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a31a140db31b1513d10af5bdc65fee046162fa/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=49a31a140db31b1513d10af5bdc65fee046162fa", "patch": "@@ -3361,13 +3361,13 @@ package body Sem_Type is\n         and then Is_Class_Wide_Type (T2)\n         and then Is_Interface (Etype (T2))\n       then\n-         return T1;\n+         return B1;\n \n       elsif Is_Class_Wide_Type (T2)\n         and then Is_Class_Wide_Type (T1)\n         and then Is_Interface (Etype (T1))\n       then\n-         return T2;\n+         return B2;\n \n       --  Ada 2005 (AI-251): T1 is a concrete type that implements the\n       --  class-wide interface T2, return T1, and vice versa.\n@@ -3378,25 +3378,25 @@ package body Sem_Type is\n         and then Interface_Present_In_Ancestor (Typ   => T1,\n                                                 Iface => Etype (T2))\n       then\n-         return T1;\n+         return B1;\n \n       elsif Is_Tagged_Type (T2)\n         and then Is_Class_Wide_Type (T1)\n         and then Is_Interface (Etype (T1))\n         and then Interface_Present_In_Ancestor (Typ   => T2,\n                                                 Iface => Etype (T1))\n       then\n-         return T2;\n+         return B2;\n \n       elsif Is_Class_Wide_Type (T1)\n         and then Is_Ancestor (Root_Type (T1), T2)\n       then\n-         return T1;\n+         return B1;\n \n       elsif Is_Class_Wide_Type (T2)\n         and then Is_Ancestor (Root_Type (T2), T1)\n       then\n-         return T2;\n+         return B2;\n \n       elsif Is_Access_Type (T1)\n         and then Is_Access_Type (T2)"}]}