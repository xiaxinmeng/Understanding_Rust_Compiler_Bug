{"sha": "8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyMGUzZjliZDNjZTFhYjlmZjk2OTZiZWZkZjc3Mzk2MGYyODAyYQ==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2016-12-16T22:11:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-16T22:11:28Z"}, "message": "compiler: add containing Bfunction to some backend interfaces.\n\n    \n    Change the interfaces for backend methods that create statements to\n    always pass in the enclosing Bfunction for the statement.  Having the\n    function available simplifies things if a temporary variable has to be\n    created during the construction of a statement.\n    \n    This also includes a change to the Mark_lvalue_varexprs helper\n    class to handle indirections on the left hand side of assignments\n    (e.g. \"*x.y = ...\").\n    \n    Reviewed-on: https://go-review.googlesource.com/34471\n\n\t* go-gcc.cc (Gcc_backend::expression_statement): Add Bfunction*\n\tparameter.\n\t(Gcc_backend::init_statement): Likewise.\n\t(Gcc_backend::assignment_statement): Likewise.\n\t(Gcc_backend::if_statement): Likewise.\n\nFrom-SVN: r243766", "tree": {"sha": "7be95802bcfe2fc53857c96560d39afd05204959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7be95802bcfe2fc53857c96560d39afd05204959"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5cdc4b0ef0381439be6cebd6ba8925f69e4d51d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cdc4b0ef0381439be6cebd6ba8925f69e4d51d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cdc4b0ef0381439be6cebd6ba8925f69e4d51d6"}], "stats": {"total": 203, "additions": 135, "deletions": 68}, "files": [{"sha": "2ecbf5f9344eecff3769456b56d1d9fe282f7eed", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -1,3 +1,11 @@\n+2016-12-16  Than McIntosh  <thanm@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::expression_statement): Add Bfunction*\n+\tparameter.\n+\t(Gcc_backend::init_statement): Likewise.\n+\t(Gcc_backend::assignment_statement): Likewise.\n+\t(Gcc_backend::if_statement): Likewise.\n+\n 2016-12-06  Than McIntosh  <thanm@google.com>\n \n \t* go-gcc.cc (Gcc_backend::var_expression): Add Varexpr_context"}, {"sha": "cc93667fb4da533ac1fa85243878ce9cf2892ddd", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -361,21 +361,22 @@ class Gcc_backend : public Backend\n   { return this->make_statement(error_mark_node); }\n \n   Bstatement*\n-  expression_statement(Bexpression*);\n+  expression_statement(Bfunction*, Bexpression*);\n \n   Bstatement*\n-  init_statement(Bvariable* var, Bexpression* init);\n+  init_statement(Bfunction*, Bvariable* var, Bexpression* init);\n \n   Bstatement*\n-  assignment_statement(Bexpression* lhs, Bexpression* rhs, Location);\n+  assignment_statement(Bfunction*, Bexpression* lhs, Bexpression* rhs,\n+\t\t       Location);\n \n   Bstatement*\n   return_statement(Bfunction*, const std::vector<Bexpression*>&,\n \t\t   Location);\n \n   Bstatement*\n-  if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n-\t       Location);\n+  if_statement(Bfunction*, Bexpression* condition, Bblock* then_block,\n+\t       Bblock* else_block, Location);\n \n   Bstatement*\n   switch_statement(Bfunction* function, Bexpression* value,\n@@ -1972,15 +1973,15 @@ Gcc_backend::stack_allocation_expression(int64_t size, Location location)\n // An expression as a statement.\n \n Bstatement*\n-Gcc_backend::expression_statement(Bexpression* expr)\n+Gcc_backend::expression_statement(Bfunction*, Bexpression* expr)\n {\n   return this->make_statement(expr->get_tree());\n }\n \n // Variable initialization.\n \n Bstatement*\n-Gcc_backend::init_statement(Bvariable* var, Bexpression* init)\n+Gcc_backend::init_statement(Bfunction*, Bvariable* var, Bexpression* init)\n {\n   tree var_tree = var->get_decl();\n   tree init_tree = init->get_tree();\n@@ -2013,8 +2014,8 @@ Gcc_backend::init_statement(Bvariable* var, Bexpression* init)\n // Assignment.\n \n Bstatement*\n-Gcc_backend::assignment_statement(Bexpression* lhs, Bexpression* rhs,\n-\t\t\t\t  Location location)\n+Gcc_backend::assignment_statement(Bfunction* bfn, Bexpression* lhs,\n+\t\t\t\t  Bexpression* rhs, Location location)\n {\n   tree lhs_tree = lhs->get_tree();\n   tree rhs_tree = rhs->get_tree();\n@@ -2029,8 +2030,8 @@ Gcc_backend::assignment_statement(Bexpression* lhs, Bexpression* rhs,\n   // anything anyhow.\n   if (int_size_in_bytes(TREE_TYPE(lhs_tree)) == 0\n       || int_size_in_bytes(TREE_TYPE(rhs_tree)) == 0)\n-    return this->compound_statement(this->expression_statement(lhs),\n-\t\t\t\t    this->expression_statement(rhs));\n+    return this->compound_statement(this->expression_statement(bfn, lhs),\n+\t\t\t\t    this->expression_statement(bfn, rhs));\n \n   // Sometimes the same unnamed Go type can be created multiple times\n   // and thus have multiple tree representations.  Make sure this does\n@@ -2194,8 +2195,9 @@ Gcc_backend::exception_handler_statement(Bstatement* bstat,\n // If.\n \n Bstatement*\n-Gcc_backend::if_statement(Bexpression* condition, Bblock* then_block,\n-\t\t\t  Bblock* else_block, Location location)\n+Gcc_backend::if_statement(Bfunction*, Bexpression* condition,\n+\t\t\t  Bblock* then_block, Bblock* else_block,\n+\t\t\t  Location location)\n {\n   tree cond_tree = condition->get_tree();\n   tree then_tree = then_block->get_tree();\n@@ -2700,8 +2702,9 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n   // Don't initialize VAR with BINIT, but still evaluate BINIT for\n   // its side effects.\n   if (this->type_size(btype) == 0 && init_tree != NULL_TREE)\n-    *pstatement = this->compound_statement(this->expression_statement(binit),\n-\t\t\t\t\t   *pstatement);\n+    *pstatement =\n+      this->compound_statement(this->expression_statement(function, binit),\n+\t\t\t       *pstatement);\n \n   return new Bvariable(var);\n }"}, {"sha": "33c1aef34d38b451e125b039f444d60b0c4d73c7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -1,4 +1,4 @@\n-310862eb11ec0705f21a375c0dd16f46a8d901c1\n+e6fb629c5b246bceab5fc8e8613cf2cf82b1e98f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "cad659aca3b5a5265aec69c56fb3ed2f83f1a8a3", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -389,19 +389,19 @@ class Backend\n   virtual Bstatement*\n   error_statement() = 0;\n \n-  // Create an expression statement.\n+  // Create an expression statement within the specified function.\n   virtual Bstatement*\n-  expression_statement(Bexpression*) = 0;\n+  expression_statement(Bfunction*, Bexpression*) = 0;\n \n-  // Create a variable initialization statement.  This initializes a\n-  // local variable at the point in the program flow where it is\n-  // declared.\n+  // Create a variable initialization statement in the specified\n+  // function.  This initializes a local variable at the point in the\n+  // program flow where it is declared.\n   virtual Bstatement*\n-  init_statement(Bvariable* var, Bexpression* init) = 0;\n+  init_statement(Bfunction*, Bvariable* var, Bexpression* init) = 0;\n \n-  // Create an assignment statement.\n+  // Create an assignment statement within the specified function.\n   virtual Bstatement*\n-  assignment_statement(Bexpression* lhs, Bexpression* rhs,\n+  assignment_statement(Bfunction*, Bexpression* lhs, Bexpression* rhs,\n \t\t       Location) = 0;\n \n   // Create a return statement, passing the representation of the\n@@ -410,9 +410,10 @@ class Backend\n   return_statement(Bfunction*, const std::vector<Bexpression*>&,\n \t\t   Location) = 0;\n \n-  // Create an if statement.  ELSE_BLOCK may be NULL.\n+  // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n   virtual Bstatement*\n-  if_statement(Bexpression* condition, Bblock* then_block, Bblock* else_block,\n+  if_statement(Bfunction*, Bexpression* condition,\n+               Bblock* then_block, Bblock* else_block,\n \t       Location) = 0;\n \n   // Create a switch statement where the case values are constants."}, {"sha": "02c3320330992f0b408fd5421e477e46401f68b0", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -964,8 +964,12 @@ Set_and_use_temporary_expression::do_get_backend(Translate_context* context)\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n   Bexpression* lvar_ref = gogo->backend()->var_expression(bvar, VE_rvalue, loc);\n \n+  Named_object* fn = context->function();\n+  go_assert(fn != NULL);\n+  Bfunction* bfn = fn->func_value()->get_or_make_decl(gogo, fn);\n   Bexpression* bexpr = this->expr_->get_backend(context);\n-  Bstatement* set = gogo->backend()->assignment_statement(lvar_ref, bexpr, loc);\n+  Bstatement* set = gogo->backend()->assignment_statement(bfn, lvar_ref,\n+                                                          bexpr, loc);\n   Bexpression* var_ref = gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n   Bexpression* ret = gogo->backend()->compound_expression(set, var_ref, loc);\n   return ret;\n@@ -4229,8 +4233,12 @@ Unary_expression::do_get_backend(Translate_context* context)\n               gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n           Bexpression* bval = sut->expression()->get_backend(context);\n \n+          Named_object* fn = context->function();\n+          go_assert(fn != NULL);\n+          Bfunction* bfn =\n+              fn->func_value()->get_or_make_decl(gogo, fn);\n           Bstatement* bassign =\n-              gogo->backend()->assignment_statement(bvar_expr, bval, loc);\n+              gogo->backend()->assignment_statement(bfn, bvar_expr, bval, loc);\n           Bexpression* bvar_addr =\n               gogo->backend()->address_expression(bvar_expr, loc);\n \t  return gogo->backend()->compound_expression(bassign, bvar_addr, loc);\n@@ -10197,8 +10205,10 @@ Call_expression::do_get_backend(Translate_context* context)\n       Expression* call_ref =\n           Expression::make_temporary_reference(this->call_temp_, location);\n       Bexpression* bcall_ref = call_ref->get_backend(context);\n+      Bfunction* bfunction = context->function()->func_value()->get_decl();\n       Bstatement* assn_stmt =\n-          gogo->backend()->assignment_statement(bcall_ref, call, location);\n+          gogo->backend()->assignment_statement(bfunction,\n+                                                bcall_ref, call, location);\n \n       this->call_ = this->set_results(context, bcall_ref);\n \n@@ -10235,11 +10245,13 @@ Call_expression::set_results(Translate_context* context, Bexpression* call)\n \tExpression::make_temporary_reference(temp, loc);\n       ref->set_is_lvalue();\n \n+      Bfunction* bfunction = context->function()->func_value()->get_decl();\n       Bexpression* result_ref = ref->get_backend(context);\n       Bexpression* call_result =\n           gogo->backend()->struct_field_expression(call, i, loc);\n       Bstatement* assn_stmt =\n-           gogo->backend()->assignment_statement(result_ref, call_result, loc);\n+          gogo->backend()->assignment_statement(bfunction,\n+                                                result_ref, call_result, loc);\n \n       Bexpression* result =\n           gogo->backend()->compound_expression(assn_stmt, call_result, loc);\n@@ -10248,7 +10260,8 @@ Call_expression::set_results(Translate_context* context, Bexpression* call)\n         results = result;\n       else\n         {\n-          Bstatement* expr_stmt = gogo->backend()->expression_statement(result);\n+          Bstatement* expr_stmt =\n+              gogo->backend()->expression_statement(bfunction, result);\n           results =\n               gogo->backend()->compound_expression(expr_stmt, results, loc);\n         }\n@@ -11951,7 +11964,9 @@ Interface_field_reference_expression::do_get_backend(Translate_context* context)\n \n   Bexpression* bcond =\n       gogo->backend()->conditional_expression(NULL, bnil_check, bcrash, NULL, loc);\n-  Bstatement* cond_statement = gogo->backend()->expression_statement(bcond);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  Bstatement* cond_statement =\n+      gogo->backend()->expression_statement(bfunction, bcond);\n   return gogo->backend()->compound_expression(cond_statement, bclosure, loc);\n }\n \n@@ -14151,7 +14166,8 @@ Heap_expression::do_get_backend(Translate_context* context)\n     gogo->backend()->indirect_expression(expr_btype, space, true, loc);\n \n   Bexpression* bexpr = this->expr_->get_backend(context);\n-  Bstatement* assn = gogo->backend()->assignment_statement(ref, bexpr, loc);\n+  Bstatement* assn = gogo->backend()->assignment_statement(fndecl, ref,\n+                                                           bexpr, loc);\n   decl = gogo->backend()->compound_statement(decl, assn);\n   space = gogo->backend()->var_expression(space_temp, VE_rvalue, loc);\n   return gogo->backend()->compound_expression(decl, space, loc);\n@@ -15451,7 +15467,9 @@ Compound_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Bexpression* binit = this->init_->get_backend(context);\n-  Bstatement* init_stmt = gogo->backend()->expression_statement(binit);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  Bstatement* init_stmt = gogo->backend()->expression_statement(bfunction,\n+                                                                binit);\n   Bexpression* bexpr = this->expr_->get_backend(context);\n   return gogo->backend()->compound_expression(init_stmt, bexpr,\n \t\t\t\t\t      this->location());"}, {"sha": "51de428394699c2a64c485e02b72105ab56cbafd", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -661,7 +661,7 @@ Gogo::recompute_init_priorities()\n // package.\n \n void\n-Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n+Gogo::init_imports(std::vector<Bstatement*>& init_stmts, Bfunction *bfunction)\n {\n   go_assert(this->is_main_package());\n \n@@ -703,7 +703,8 @@ Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n       Bexpression* pfunc_call =\n \tthis->backend()->call_expression(pfunc_code, empty_args,\n \t\t\t\t\t NULL, unknown_loc);\n-      init_stmts.push_back(this->backend()->expression_statement(pfunc_call));\n+      init_stmts.push_back(this->backend()->expression_statement(bfunction,\n+                                                                 pfunc_call));\n     }\n }\n \n@@ -726,7 +727,8 @@ Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n \n void\n Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n-\t\t       std::vector<Bstatement*>& init_stmts)\n+\t\t       std::vector<Bstatement*>& init_stmts,\n+                       Bfunction* init_bfn)\n {\n   if (var_gc.empty())\n     return;\n@@ -830,7 +832,7 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n \n   Translate_context context(this, NULL, NULL, NULL);\n   Bexpression* bcall = register_roots->get_backend(&context);\n-  init_stmts.push_back(this->backend()->expression_statement(bcall));\n+  init_stmts.push_back(this->backend()->expression_statement(init_bfn, bcall));\n }\n \n // Get the name to use for the import control function.  If there is a\n@@ -1253,14 +1255,19 @@ Gogo::write_globals()\n   std::vector<Bexpression*> const_decls;\n   std::vector<Bfunction*> func_decls;\n \n-  // The init function declaration, if necessary.\n+  // The init function declaration and associated Bfunction, if necessary.\n   Named_object* init_fndecl = NULL;\n+  Bfunction* init_bfn = NULL;\n \n   std::vector<Bstatement*> init_stmts;\n   std::vector<Bstatement*> var_init_stmts;\n \n   if (this->is_main_package())\n-    this->init_imports(init_stmts);\n+    {\n+      init_fndecl = this->initialization_function_decl();\n+      init_bfn = init_fndecl->func_value()->get_or_make_decl(this, init_fndecl);\n+      this->init_imports(init_stmts, init_bfn);\n+    }\n \n   // A list of variable initializations.\n   Var_inits var_inits;\n@@ -1345,7 +1352,11 @@ Gogo::write_globals()\n \t      else\n \t\t{\n \t\t  if (init_fndecl == NULL)\n-\t\t    init_fndecl = this->initialization_function_decl();\n+                    {\n+                      init_fndecl = this->initialization_function_decl();\n+                      Function* func = init_fndecl->func_value();\n+                      init_bfn = func->get_or_make_decl(this, init_fndecl);\n+                    }\n \t\t  var_init_fn = init_fndecl;\n \t\t}\n               Bexpression* var_binit = var->get_init(this, var_init_fn);\n@@ -1364,15 +1375,15 @@ Gogo::write_globals()\n \t\t}\n \t      else if (is_sink)\n \t        var_init_stmt =\n-                    this->backend()->expression_statement(var_binit);\n+                    this->backend()->expression_statement(init_bfn, var_binit);\n \t      else\n                 {\n                   Location loc = var->location();\n                   Bexpression* var_expr =\n                       this->backend()->var_expression(bvar, VE_lvalue, loc);\n                   var_init_stmt =\n-                      this->backend()->assignment_statement(var_expr, var_binit,\n-                                                            loc);\n+                      this->backend()->assignment_statement(init_bfn, var_expr,\n+                                                            var_binit, loc);\n                 }\n \t    }\n \t  else\n@@ -1402,7 +1413,7 @@ Gogo::write_globals()\n               Btype* btype = no->var_value()->type()->get_backend(this);\n               Bexpression* zero = this->backend()->zero_expression(btype);\n               Bstatement* zero_stmt =\n-                  this->backend()->expression_statement(zero);\n+                  this->backend()->expression_statement(init_bfn, zero);\n \t      var_inits.push_back(Var_init(no, zero_stmt));\n \t    }\n \n@@ -1412,7 +1423,7 @@ Gogo::write_globals()\n     }\n \n   // Register global variables with the garbage collector.\n-  this->register_gc_vars(var_gc, init_stmts);\n+  this->register_gc_vars(var_gc, init_stmts, init_bfn);\n \n   // Simple variable initializations, after all variables are\n   // registered.\n@@ -1446,7 +1457,8 @@ Gogo::write_globals()\n       Bexpression* call = this->backend()->call_expression(func_code,\n                                                            empty_args,\n \t\t\t\t\t\t\t   NULL, func_loc);\n-      init_stmts.push_back(this->backend()->expression_statement(call));\n+      Bstatement* ist = this->backend()->expression_statement(initfn, call);\n+      init_stmts.push_back(ist);\n     }\n \n   // Set up a magic function to do all the initialization actions.\n@@ -5594,7 +5606,8 @@ Function::build(Gogo* gogo, Named_object* named_function)\n       for (size_t i = 0; i < vars.size(); ++i)\n \t{\n           Bstatement* init_stmt =\n-              gogo->backend()->init_statement(vars[i], var_inits[i]);\n+              gogo->backend()->init_statement(this->fndecl_, vars[i],\n+                                              var_inits[i]);\n           init.push_back(init_stmt);\n \t}\n       if (defer_init != NULL)\n@@ -5666,7 +5679,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n \t\t\t\t\tthis->defer_stack(end_loc));\n   Translate_context context(gogo, named_function, NULL, NULL);\n   Bexpression* defer = call->get_backend(&context);\n-  stmts.push_back(gogo->backend()->expression_statement(defer));\n+  stmts.push_back(gogo->backend()->expression_statement(this->fndecl_, defer));\n \n   Bstatement* ret_bstmt = this->return_value(gogo, named_function, end_loc);\n   if (ret_bstmt != NULL)\n@@ -5705,7 +5718,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n       Bexpression* bref = ref->get_backend(&context);\n       ret = gogo->backend()->conditional_expression(NULL, bref, ret, NULL,\n                                                     end_loc);\n-      stmts.push_back(gogo->backend()->expression_statement(ret));\n+      stmts.push_back(gogo->backend()->expression_statement(this->fndecl_, ret));\n     }\n \n   go_assert(*fini == NULL);\n@@ -6547,6 +6560,8 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n \n   Translate_context context(gogo, function, NULL, NULL);\n   Bblock* bblock = this->preinit_->get_backend(&context);\n+  Bfunction* bfunction =\n+      function->func_value()->get_or_make_decl(gogo, function);\n \n   // It's possible to have pre-init statements without an initializer\n   // if the pre-init statements set the variable.\n@@ -6556,7 +6571,8 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n       if (var_decl == NULL)\n         {\n           Bexpression* init_bexpr = this->init_->get_backend(&context);\n-          decl_init = gogo->backend()->expression_statement(init_bexpr);\n+          decl_init = gogo->backend()->expression_statement(bfunction,\n+                                                            init_bexpr);\n         }\n       else\n \t{\n@@ -6566,7 +6582,8 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n           Bexpression* val = val_expr->get_backend(&context);\n           Bexpression* var_ref =\n               gogo->backend()->var_expression(var_decl, VE_lvalue, loc);\n-          decl_init = gogo->backend()->assignment_statement(var_ref, val, loc);\n+          decl_init = gogo->backend()->assignment_statement(bfunction, var_ref,\n+                                                            val, loc);\n \t}\n     }\n   Bstatement* block_stmt = gogo->backend()->block_statement(bblock);"}, {"sha": "23d1f08a59a7fb966891aa669ae00a7da682c8a2", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -773,14 +773,16 @@ class Gogo\n   Named_object*\n   create_initialization_function(Named_object* fndecl, Bstatement* code_stmt);\n \n-  // Initialize imported packages.\n+  // Initialize imported packages. BFUNCTION is the function\n+  // into which the package init calls will be placed.\n   void\n-  init_imports(std::vector<Bstatement*>&);\n+  init_imports(std::vector<Bstatement*>&, Bfunction* bfunction);\n \n   // Register variables with the garbage collector.\n   void\n   register_gc_vars(const std::vector<Named_object*>&,\n-                   std::vector<Bstatement*>&);\n+                   std::vector<Bstatement*>&,\n+                   Bfunction* init_bfunction);\n \n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;"}, {"sha": "dc226e8b21e7ccb25075f24674f506c99e312b2b", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8220e3f9bd3ce1ab9ff9696befdf773960f2802a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=8220e3f9bd3ce1ab9ff9696befdf773960f2802a", "patch": "@@ -285,6 +285,7 @@ Variable_declaration_statement::do_flatten(Gogo* gogo, Named_object* function,\n Bstatement*\n Variable_declaration_statement::do_get_backend(Translate_context* context)\n {\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n   Variable* var = this->var_->var_value();\n   Bvariable* bvar = this->var_->get_backend_variable(context->gogo(),\n \t\t\t\t\t\t     context->function());\n@@ -293,7 +294,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   if (!var->is_in_heap())\n     {\n       go_assert(binit != NULL);\n-      return context->backend()->init_statement(bvar, binit);\n+      return context->backend()->init_statement(bfunction, bvar, binit);\n     }\n \n   // Something takes the address of this variable, so the value is\n@@ -316,12 +317,12 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n       Expression* e = Expression::make_temporary_reference(temp, loc);\n       e = Expression::make_unary(OPERATOR_MULT, e, loc);\n       Bexpression* be = e->get_backend(context);\n-      set = context->backend()->assignment_statement(be, binit, loc);\n+      set = context->backend()->assignment_statement(bfunction, be, binit, loc);\n     }\n \n   Expression* ref = Expression::make_temporary_reference(temp, loc);\n   Bexpression* bref = ref->get_backend(context);\n-  Bstatement* sinit = context->backend()->init_statement(bvar, bref);\n+  Bstatement* sinit = context->backend()->init_statement(bfunction, bvar, bref);\n \n   std::vector<Bstatement*> stats;\n   stats.reserve(3);\n@@ -896,6 +897,10 @@ int Mark_lvalue_varexprs::expression(Expression** ppexpr)\n       return TRAVERSE_EXIT;\n     }\n \n+  Unary_expression* ue = e->unary_expression();\n+  if (ue && ue->op() == OPERATOR_MULT)\n+    return TRAVERSE_CONTINUE;\n+\n   return TRAVERSE_EXIT;\n }\n \n@@ -907,7 +912,8 @@ Assignment_statement::do_get_backend(Translate_context* context)\n   if (this->lhs_->is_sink_expression())\n     {\n       Bexpression* rhs = this->rhs_->get_backend(context);\n-      return context->backend()->expression_statement(rhs);\n+      Bfunction* bfunction = context->function()->func_value()->get_decl();\n+      return context->backend()->expression_statement(bfunction, rhs);\n     }\n \n   Mark_lvalue_varexprs mlve;\n@@ -918,7 +924,9 @@ Assignment_statement::do_get_backend(Translate_context* context)\n       Expression::convert_for_assignment(context->gogo(), this->lhs_->type(),\n                                          this->rhs_, this->location());\n   Bexpression* rhs = conv->get_backend(context);\n-  return context->backend()->assignment_statement(lhs, rhs, this->location());\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  return context->backend()->assignment_statement(bfunction, lhs, rhs,\n+                                                  this->location());\n }\n \n // Dump the AST representation for an assignment statement.\n@@ -1801,7 +1809,8 @@ Bstatement*\n Expression_statement::do_get_backend(Translate_context* context)\n {\n   Bexpression* bexpr = this->expr_->get_backend(context);\n-  return context->backend()->expression_statement(bexpr);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  return context->backend()->expression_statement(bfunction, bexpr);\n }\n \n // Dump the AST representation for an expression statement\n@@ -2582,7 +2591,8 @@ Go_statement::do_get_backend(Translate_context* context)\n   Expression* call = Runtime::make_call(Runtime::GO, this->location(), 2,\n \t\t\t\t\tfn, arg);\n   Bexpression* bcall = call->get_backend(context);\n-  return context->backend()->expression_statement(bcall);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  return context->backend()->expression_statement(bfunction, bcall);\n }\n \n // Dump the AST representation for go statement.\n@@ -2620,7 +2630,8 @@ Defer_statement::do_get_backend(Translate_context* context)\n   Expression* call = Runtime::make_call(Runtime::DEFERPROC, loc, 3,\n \t\t\t\t\tds, fn, arg);\n   Bexpression* bcall = call->get_backend(context);\n-  return context->backend()->expression_statement(bcall);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  return context->backend()->expression_statement(bfunction, bcall);\n }\n \n // Dump the AST representation for defer statement.\n@@ -3032,7 +3043,8 @@ Label_statement::do_get_backend(Translate_context* context)\n   if (this->label_->is_dummy_label())\n     {\n       Bexpression* bce = context->backend()->boolean_constant_expression(false);\n-      return context->backend()->expression_statement(bce);\n+      Bfunction* bfunction = context->function()->func_value()->get_decl();\n+      return context->backend()->expression_statement(bfunction, bce);\n     }\n   Blabel* blabel = this->label_->get_backend_label(context);\n   return context->backend()->label_definition_statement(blabel);\n@@ -3157,7 +3169,9 @@ If_statement::do_get_backend(Translate_context* context)\n   Bblock* else_block = (this->else_block_ == NULL\n \t\t\t? NULL\n \t\t\t: this->else_block_->get_backend(context));\n-  return context->backend()->if_statement(cond, then_block, else_block,\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  return context->backend()->if_statement(bfunction,\n+                                          cond, then_block, else_block,\n \t\t\t\t\t  this->location());\n }\n \n@@ -4478,7 +4492,8 @@ Send_statement::do_get_backend(Translate_context* context)\n \n   context->gogo()->lower_expression(context->function(), NULL, &call);\n   Bexpression* bcall = call->get_backend(context);\n-  Bstatement* s = context->backend()->expression_statement(bcall);\n+  Bfunction* bfunction = context->function()->func_value()->get_decl();\n+  Bstatement* s = context->backend()->expression_statement(bfunction, bcall);\n \n   if (btemp == NULL)\n     return s;\n@@ -4912,7 +4927,7 @@ Select_clauses::get_backend(Translate_context* context,\n       if (s == NULL)\n \tclauses[i] = g;\n       else\n-\tclauses[i] = context->backend()->compound_statement(s, g);\n+        clauses[i] = context->backend()->compound_statement(s, g);\n     }\n \n   Expression* selref = Expression::make_temporary_reference(sel, location);\n@@ -4923,7 +4938,10 @@ Select_clauses::get_backend(Translate_context* context,\n   Bexpression* bcall = call->get_backend(context);\n \n   if (count == 0)\n-    return context->backend()->expression_statement(bcall);\n+    {\n+      Bfunction* bfunction = context->function()->func_value()->get_decl();\n+      return context->backend()->expression_statement(bfunction, bcall);\n+    }\n \n   std::vector<Bstatement*> statements;\n   statements.reserve(2);"}]}