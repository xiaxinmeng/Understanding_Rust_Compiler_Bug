{"sha": "0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyMGNkOTM4MjcyOGZkYzk5ZDRjZmRjYjcyY2QwZjU1YWNhMmNlMw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-26T21:30:39Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-26T21:30:39Z"}, "message": "c++: constexpr pointer indirection with negative offset [PR100209]\n\nDuring constexpr evaluation, a base-to-derived conversion may yield an\nexpression like (Derived*)(&D.2217.D.2106 p+ -4) where D.2217 is the\nderived object and D.2106 is the base.  But cxx_fold_indirect_ref\ndoesn't know how to resolve an INDIRECT_REF thereof to just D.2217,\nbecause it doesn't handle POINTER_PLUS_EXPR of a COMPONENT_REF with\nnegative offset well: when the offset N is positive, it knows that\n'&x p+ N' is equivalent to '&x.f p+ (N - bytepos(f))', but it doesn't\nknow about the reverse transformation, that '&x.f p+ N' is equivalent\nto '&x p+ (N + bytepos(f))' when N is negative, which is important for\nresolving such base-to-derived conversions and for accessing subobjects\nbackwards.  This patch teaches cxx_fold_indirect_ref this reverse\ntransformation.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/100209\n\t* constexpr.c (cxx_fold_indirect_ref): Try to canonicalize the\n\tobject/offset pair for a POINTER_PLUS_EXPR of a COMPONENT_REF\n\twith a negative offset into one whose offset is nonnegative\n\tbefore calling cxx_fold_indirect_ref_1.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/100209\n\t* g++.dg/cpp1y/constexpr-base1.C: New test.\n\t* g++.dg/cpp1y/constexpr-ptrsub1.C: New test.", "tree": {"sha": "f24c2aca76b5e6a869254f9dd4633b83a3524fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f24c2aca76b5e6a869254f9dd4633b83a3524fec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/comments", "author": null, "committer": null, "parents": [{"sha": "bd7ebe9da745a62184052dd1b15f4dd10fbdc9f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7ebe9da745a62184052dd1b15f4dd10fbdc9f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7ebe9da745a62184052dd1b15f4dd10fbdc9f4"}], "stats": {"total": 71, "additions": 68, "deletions": 3}, "files": [{"sha": "fa7eaed945a48d282a7be448ed988fbf1f5395df", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "patch": "@@ -4894,12 +4894,26 @@ cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n \t   && tree_fits_uhwi_p (TREE_OPERAND (sub, 1)))\n     {\n       tree op00 = TREE_OPERAND (sub, 0);\n-      tree op01 = TREE_OPERAND (sub, 1);\n+      tree off = TREE_OPERAND (sub, 1);\n \n       STRIP_NOPS (op00);\n       if (TREE_CODE (op00) == ADDR_EXPR)\n-\treturn cxx_fold_indirect_ref_1 (ctx, loc, type, TREE_OPERAND (op00, 0),\n-\t\t\t\t\ttree_to_uhwi (op01), empty_base);\n+\t{\n+\t  tree obj = TREE_OPERAND (op00, 0);\n+\t  while (TREE_CODE (obj) == COMPONENT_REF\n+\t\t && tree_int_cst_sign_bit (off))\n+\t    {\n+\t      /* Canonicalize this object/offset pair by iteratively absorbing\n+\t\t the innermost component into the offset until the offset is\n+\t\t nonnegative, so that cxx_fold_indirect_ref_1 can identify\n+\t\t more folding opportunities.  */\n+\t      tree field = TREE_OPERAND (obj, 1);\n+\t      off = int_const_binop (PLUS_EXPR, off, byte_position (field));\n+\t      obj = TREE_OPERAND (obj, 0);\n+\t    }\n+\t  return cxx_fold_indirect_ref_1 (ctx, loc, type, obj,\n+\t\t\t\t\t  tree_to_uhwi (off), empty_base);\n+\t}\n     }\n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n   else if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE"}, {"sha": "3c93aa851f349210655c261862972d1987e451d6", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-base1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base1.C?ref=0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/100209\n+// { dg-do compile { target c++14 } }\n+\n+template<typename Derived>\n+struct __a_t\n+{\n+  unsigned char A = 0;\n+  constexpr Derived & SetA(const unsigned char & value) {\n+    A = value;\n+    return *static_cast<Derived *>(this);\n+  }\n+};\n+\n+template<typename Derived>\n+struct __b_t\n+{\n+  unsigned char B = 0;\n+  constexpr Derived & SetB(const unsigned char & value) {\n+    B = value;\n+    return *static_cast<Derived *>(this);\n+  }\n+};\n+\n+struct __ab_t : __a_t<__ab_t>, __b_t<__ab_t> { };\n+\n+constexpr auto AB = __ab_t().SetA(100).SetB(10);\n+static_assert(AB.A == 100, \"\");\n+static_assert(AB.B == 10, \"\");"}, {"sha": "d6cb6adb0f62d9203979532c81cf649fd141f94f", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-ptrsub1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-ptrsub1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-ptrsub1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-ptrsub1.C?ref=0120cd9382728fdc99d4cfdcb72cd0f55aca2ce3", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/100209\n+// { dg-do compile { target c++14 } }\n+\n+struct A {\n+  int x = 1;\n+};\n+\n+struct B : A {\n+  int y = 2;\n+  int z = 3;\n+  int w = 4;\n+};\n+\n+constexpr bool f() {\n+  B b;\n+  if (&b.w - &b.x != 3)\n+    /* Effectively disable this test if the layout of B isn't\n+       what we expect.  */\n+    return true;\n+  const int* w = &b.w;\n+  return *w-- == 4 && *w-- == 3 && *w-- == 2 && *w-- == 1;\n+}\n+static_assert(f(), \"\");"}]}