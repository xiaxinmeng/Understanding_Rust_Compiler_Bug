{"sha": "9d9c740d1efcd1bd597ef4734227996a8f69151d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ5Yzc0MGQxZWZjZDFiZDU5N2VmNDczNDIyNzk5NmE4ZjY5MTUxZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-07T15:42:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-07T15:42:41Z"}, "message": "hw-doloop.c: New file.\n\n\t* hw-doloop.c: New file.\n\t* hw-doloop.h: New file.\n\t* Makefile.in (OBJS): Add hw-doloop.o.\n\t(hw-doloop.o): New rule.\n\t($(obj_out_file)): Add hw-doloop.h dependency.\n\t* config/bfin/bfin.c: Include \"hw-doloop.h\".\n\t(loop_info, DEF_VEC_P for loop_info, loop_info_d): Remove.\n\t(bfin_dump_loops, bfin_bb_in_loop, bfin_scan_loop): Remove.\n\t(hwloop_optimize): Renamed from bfin_optimize_loop.  Argument\n\ttype changed to hwloop_info.  Return bool, true if the loop was\n\tsuccessfully optimized.  Remove code that was moved to\n\thw-doloop.c, and adjust other parts.\n\t(hwloop_fail): New static function, containing parts that used\n\tto be in bfin_optimize_loop.\n\t(bfin_discover_loop, bfin_discover_loops, free_loops,\n\tbfin_reorder_loops): Remove.\n\t(hwloop_pattern_reg): New static function.\n\t(bfin_doloop_hooks): New variable.\n\t(bfin_reorg_loops): Remove most code, call reorg_loops.\n\t* config/bfin/bfin.md (doloop_end splitter): Also enable if\n\tloop counter is a memory_operand.\n\nFrom-SVN: r175985", "tree": {"sha": "f9552f79c86d74255de5a691ef17a3767e4337fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9552f79c86d74255de5a691ef17a3767e4337fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d9c740d1efcd1bd597ef4734227996a8f69151d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9c740d1efcd1bd597ef4734227996a8f69151d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9c740d1efcd1bd597ef4734227996a8f69151d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9c740d1efcd1bd597ef4734227996a8f69151d/comments", "author": null, "committer": null, "parents": [{"sha": "f0ea75811ae63b50e6c06ad694a993a8182ba012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ea75811ae63b50e6c06ad694a993a8182ba012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ea75811ae63b50e6c06ad694a993a8182ba012"}], "stats": {"total": 1596, "additions": 928, "deletions": 668}, "files": [{"sha": "f840e57803d05dc34adb75e87d5ab87b2b523c73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -1,3 +1,27 @@\n+2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* hw-doloop.c: New file.\n+\t* hw-doloop.h: New file.\n+\t* Makefile.in (OBJS): Add hw-doloop.o.\n+\t(hw-doloop.o): New rule.\n+\t($(obj_out_file)): Add hw-doloop.h dependency.\n+\t* config/bfin/bfin.c: Include \"hw-doloop.h\".\n+\t(loop_info, DEF_VEC_P for loop_info, loop_info_d): Remove.\n+\t(bfin_dump_loops, bfin_bb_in_loop, bfin_scan_loop): Remove.\n+\t(hwloop_optimize): Renamed from bfin_optimize_loop.  Argument\n+\ttype changed to hwloop_info.  Return bool, true if the loop was\n+\tsuccessfully optimized.  Remove code that was moved to\n+\thw-doloop.c, and adjust other parts.\n+\t(hwloop_fail): New static function, containing parts that used\n+\tto be in bfin_optimize_loop.\n+\t(bfin_discover_loop, bfin_discover_loops, free_loops,\n+\tbfin_reorder_loops): Remove.\n+\t(hwloop_pattern_reg): New static function.\n+\t(bfin_doloop_hooks): New variable.\n+\t(bfin_reorg_loops): Remove most code, call reorg_loops.\n+\t* config/bfin/bfin.md (doloop_end splitter): Also enable if\n+\tloop counter is a memory_operand.\n+\n 2011-07-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config.gcc: Support --with-multilib-list for x86 Linux"}, {"sha": "d09423dac00cdb8a87edb3a754ebd1b572c9708b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -1300,6 +1300,7 @@ OBJS = \\\n \tgraphite-sese-to-poly.o \\\n \tgtype-desc.o \\\n \thaifa-sched.o \\\n+\thw-doloop.o \\\n \thwint.o \\\n \tifcvt.o \\\n \timplicit-zee.o \\\n@@ -3552,13 +3553,16 @@ target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) toplev.h target-globals.h \\\n    $(FLAGS_H) $(REGS_H) $(RTL_H) reload.h expmed.h $(EXPR_H) $(OPTABS_H) \\\n    $(LIBFUNCS_H) $(CFGLOOP_H) $(IRA_INT_H) builtins.h gcse.h bb-reorder.h\n-\n+hw-doloop.o : hw-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n+   $(DF_H) $(CFGLAYOUT_H) $(CFGLOOP_H) output.h $(RECOG_H) $(TARGET_H) \\\n+   $(REGS_H) hw-doloop.h\n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\\n    output.h $(INSN_ATTR_H) $(SYSTEM_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n    $(TARGET_H) $(LIBFUNCS_H) $(TARGET_DEF_H) $(FUNCTION_H) $(SCHED_INT_H) \\\n    $(TM_P_H) $(EXPR_H) langhooks.h $(GGC_H) $(OPTABS_H) $(REAL_H) \\\n-   tm-constrs.h $(GIMPLE_H) $(DF_H) cselib.h $(COMMON_TARGET_H)\n+   tm-constrs.h $(GIMPLE_H) $(DF_H) cselib.h $(COMMON_TARGET_H) hw-doloop.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n \t\t$(out_file) $(OUTPUT_OPTION)\n "}, {"sha": "f5b45dc0efb9efc8996a647efcdbbeb8586f76c7", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 68, "deletions": 665, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -56,6 +56,7 @@\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"sel-sched.h\"\n+#include \"hw-doloop.h\"\n #include \"opts.h\"\n \n /* A C structure for machine-specific, per-function data.\n@@ -3381,157 +3382,6 @@ bfin_hardware_loop (void)\n /* Maximum distance of the LSETUP instruction from the loop start.  */\n #define MAX_LSETUP_DISTANCE 30\n \n-/* We need to keep a vector of loops */\n-typedef struct loop_info_d *loop_info;\n-DEF_VEC_P (loop_info);\n-DEF_VEC_ALLOC_P (loop_info,heap);\n-\n-/* Information about a loop we have found (or are in the process of\n-   finding).  */\n-struct GTY (()) loop_info_d\n-{\n-  /* loop number, for dumps */\n-  int loop_no;\n-\n-  /* All edges that jump into and out of the loop.  */\n-  VEC(edge,gc) *incoming;\n-\n-  /* We can handle two cases: all incoming edges have the same destination\n-     block, or all incoming edges have the same source block.  These two\n-     members are set to the common source or destination we found, or NULL\n-     if different blocks were found.  If both are NULL the loop can't be\n-     optimized.  */\n-  basic_block incoming_src;\n-  basic_block incoming_dest;\n-\n-  /* First block in the loop.  This is the one branched to by the loop_end\n-     insn.  */\n-  basic_block head;\n-\n-  /* Last block in the loop (the one with the loop_end insn).  */\n-  basic_block tail;\n-\n-  /* The successor block of the loop.  This is the one the loop_end insn\n-     falls into.  */\n-  basic_block successor;\n-\n-  /* The last instruction in the tail.  */\n-  rtx last_insn;\n-\n-  /* The loop_end insn.  */\n-  rtx loop_end;\n-\n-  /* The iteration register.  */\n-  rtx iter_reg;\n-\n-  /* The new label placed at the beginning of the loop. */\n-  rtx start_label;\n-\n-  /* The new label placed at the end of the loop. */\n-  rtx end_label;\n-\n-  /* The length of the loop.  */\n-  int length;\n-\n-  /* The nesting depth of the loop.  */\n-  int depth;\n-\n-  /* Nonzero if we can't optimize this loop.  */\n-  int bad;\n-\n-  /* True if we have visited this loop.  */\n-  int visited;\n-\n-  /* True if this loop body clobbers any of LC0, LT0, or LB0.  */\n-  int clobber_loop0;\n-\n-  /* True if this loop body clobbers any of LC1, LT1, or LB1.  */\n-  int clobber_loop1;\n-\n-  /* Next loop in the graph. */\n-  struct loop_info_d *next;\n-\n-  /* Immediate outer loop of this loop.  */\n-  struct loop_info_d *outer;\n-\n-  /* Vector of blocks only within the loop, including those within\n-     inner loops.  */\n-  VEC (basic_block,heap) *blocks;\n-\n-  /* Same information in a bitmap.  */\n-  bitmap block_bitmap;\n-\n-  /* Vector of inner loops within this loop  */\n-  VEC (loop_info,heap) *loops;\n-};\n-\n-static void\n-bfin_dump_loops (loop_info loops)\n-{\n-  loop_info loop;\n-\n-  for (loop = loops; loop; loop = loop->next)\n-    {\n-      loop_info i;\n-      basic_block b;\n-      unsigned ix;\n-\n-      fprintf (dump_file, \";; loop %d: \", loop->loop_no);\n-      if (loop->bad)\n-\tfprintf (dump_file, \"(bad) \");\n-      fprintf (dump_file, \"{head:%d, depth:%d}\", loop->head->index, loop->depth);\n-\n-      fprintf (dump_file, \" blocks: [ \");\n-      FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, b)\n-\tfprintf (dump_file, \"%d \", b->index);\n-      fprintf (dump_file, \"] \");\n-\n-      fprintf (dump_file, \" inner loops: [ \");\n-      FOR_EACH_VEC_ELT (loop_info, loop->loops, ix, i)\n-\tfprintf (dump_file, \"%d \", i->loop_no);\n-      fprintf (dump_file, \"]\\n\");\n-    }\n-  fprintf (dump_file, \"\\n\");\n-}\n-\n-/* Scan the blocks of LOOP (and its inferiors) looking for basic block\n-   BB. Return true, if we find it.  */\n-\n-static bool\n-bfin_bb_in_loop (loop_info loop, basic_block bb)\n-{\n-  return bitmap_bit_p (loop->block_bitmap, bb->index);\n-}\n-\n-/* Scan the blocks of LOOP (and its inferiors) looking for uses of\n-   REG.  Return true, if we find any.  Don't count the loop's loop_end\n-   insn if it matches LOOP_END.  */\n-\n-static bool\n-bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n-{\n-  unsigned ix;\n-  basic_block bb;\n-\n-  FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, bb)\n-    {\n-      rtx insn;\n-\n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\t  if (insn == loop_end)\n-\t    continue;\n-\t  if (reg_mentioned_p (reg, PATTERN (insn)))\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n /* Estimate the length of INSN conservatively.  */\n \n static int\n@@ -3559,67 +3409,32 @@ length_for_loop (rtx insn)\n \n /* Optimize LOOP.  */\n \n-static void\n-bfin_optimize_loop (loop_info loop)\n+static bool\n+hwloop_optimize (hwloop_info loop)\n {\n   basic_block bb;\n-  loop_info inner;\n+  hwloop_info inner;\n   rtx insn, last_insn;\n   rtx loop_init, start_label, end_label;\n-  rtx reg_lc0, reg_lc1, reg_lt0, reg_lt1, reg_lb0, reg_lb1;\n   rtx iter_reg, scratchreg, scratch_init, scratch_init_insn;\n   rtx lc_reg, lt_reg, lb_reg;\n   rtx seq, seq_end;\n   int length;\n   unsigned ix;\n-  int inner_depth = 0;\n-\n-  if (loop->visited)\n-    return;\n-\n-  loop->visited = 1;\n-\n-  if (loop->bad)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; loop %d bad when found\\n\", loop->loop_no);\n-      goto bad_loop;\n-    }\n-\n-  /* Every loop contains in its list of inner loops every loop nested inside\n-     it, even if there are intermediate loops.  This works because we're doing\n-     a depth-first search here and never visit a loop more than once.  */\n-  FOR_EACH_VEC_ELT (loop_info, loop->loops, ix, inner)\n-    {\n-      bfin_optimize_loop (inner);\n-\n-      if (!inner->bad && inner_depth < inner->depth)\n-\t{\n-\t  inner_depth = inner->depth;\n+  bool clobber0, clobber1;\n \n-\t  loop->clobber_loop0 |= inner->clobber_loop0;\n-\t  loop->clobber_loop1 |= inner->clobber_loop1;\n-\t}\n-    }\n-\n-  loop->depth = inner_depth + 1;\n   if (loop->depth > MAX_LOOP_DEPTH)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d too deep\\n\", loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n \n   /* Get the loop iteration register.  */\n   iter_reg = loop->iter_reg;\n \n-  if (!REG_P (iter_reg))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \";; loop %d iteration count not in a register\\n\",\n-\t\t loop->loop_no);\n-      goto bad_loop;\n-    }\n+  gcc_assert (REG_P (iter_reg));\n+\n   scratchreg = NULL_RTX;\n   scratch_init = iter_reg;\n   scratch_init_insn = NULL_RTX;\n@@ -3680,7 +3495,7 @@ bfin_optimize_loop (loop_info loop)\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; loop %d lsetup not before loop_start\\n\",\n \t\t     loop->loop_no);\n-\t  goto bad_loop;\n+\t  return false;\n \t}\n \n       /* Account for the pop of a scratch register where necessary.  */\n@@ -3692,7 +3507,7 @@ bfin_optimize_loop (loop_info loop)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; loop %d lsetup too far away\\n\", loop->loop_no);\n-\t  goto bad_loop;\n+\t  return false;\n \t}\n     }\n \n@@ -3710,66 +3525,37 @@ bfin_optimize_loop (loop_info loop)\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n \t\t loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n \n   loop->length = length;\n   if (loop->length > MAX_LOOP_LENGTH)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d too long\\n\", loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n \n   /* Scan all the blocks to make sure they don't use iter_reg.  */\n-  if (bfin_scan_loop (loop, iter_reg, loop->loop_end))\n+  if (loop->iter_reg_used || loop->iter_reg_used_outside)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d uses iterator\\n\", loop->loop_no);\n-      goto bad_loop;\n-    }\n-\n-  /* Scan all the insns to see if the loop body clobber\n-     any hardware loop registers. */\n-\n-  reg_lc0 = gen_rtx_REG (SImode, REG_LC0);\n-  reg_lc1 = gen_rtx_REG (SImode, REG_LC1);\n-  reg_lt0 = gen_rtx_REG (SImode, REG_LT0);\n-  reg_lt1 = gen_rtx_REG (SImode, REG_LT1);\n-  reg_lb0 = gen_rtx_REG (SImode, REG_LB0);\n-  reg_lb1 = gen_rtx_REG (SImode, REG_LB1);\n-\n-  FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, bb)\n-    {\n-      rtx insn;\n-\n-      for (insn = BB_HEAD (bb);\n-\t   insn != NEXT_INSN (BB_END (bb));\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (!INSN_P (insn))\n-\t    continue;\n-\n-\t  if (reg_set_p (reg_lc0, insn)\n-\t      || reg_set_p (reg_lt0, insn)\n-\t      || reg_set_p (reg_lb0, insn))\n-\t    loop->clobber_loop0 = 1;\n-\t  \n-\t  if (reg_set_p (reg_lc1, insn)\n-\t      || reg_set_p (reg_lt1, insn)\n-\t      || reg_set_p (reg_lb1, insn))\n-\t    loop->clobber_loop1 |= 1;\n-\t}\n+      return false;\n     }\n \n-  if ((loop->clobber_loop0 && loop->clobber_loop1)\n-      || (loop->depth == MAX_LOOP_DEPTH && loop->clobber_loop0))\n+  clobber0 = (TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LC0)\n+\t      || TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LB0)\n+\t      || TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LT0));\n+  clobber1 = (TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LC1)\n+\t      || TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LB1)\n+\t      || TEST_HARD_REG_BIT (loop->regs_set_in_loop, REG_LT1));\n+  if (clobber0 && clobber1)\n     {\n-      loop->depth = MAX_LOOP_DEPTH + 1;\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d no loop reg available\\n\",\n \t\t loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n \n   /* There should be an instruction before the loop_end instruction\n@@ -3814,15 +3600,15 @@ bfin_optimize_loop (loop_info loop)\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d has no last instruction\\n\",\n \t\t loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n \n   if (JUMP_P (last_insn) && !any_condjump_p (last_insn))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d has bad last instruction\\n\",\n \t\t loop->loop_no);\n-      goto bad_loop;\n+      return false;\n     }\n   /* In all other cases, try to replace a bad last insn with a nop.  */\n   else if (JUMP_P (last_insn)\n@@ -3838,7 +3624,7 @@ bfin_optimize_loop (loop_info loop)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \";; loop %d too long\\n\", loop->loop_no);\n-\t  goto bad_loop;\n+\t  return false;\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \";; loop %d has bad last insn; replace with nop\\n\",\n@@ -3854,19 +3640,19 @@ bfin_optimize_loop (loop_info loop)\n   end_label = gen_label_rtx ();\n   iter_reg = loop->iter_reg;\n \n-  if (loop->depth == 1 && !loop->clobber_loop1)\n+  if (loop->depth == 1 && !clobber1)\n     {\n-      lc_reg = reg_lc1;\n-      lt_reg = reg_lt1;\n-      lb_reg = reg_lb1;\n-      loop->clobber_loop1 = 1;\n+      lc_reg = gen_rtx_REG (SImode, REG_LC1);\n+      lb_reg = gen_rtx_REG (SImode, REG_LB1);\n+      lt_reg = gen_rtx_REG (SImode, REG_LT1);\n+      SET_HARD_REG_BIT (loop->regs_set_in_loop, REG_LC1);\n     }\n   else\n     {\n-      lc_reg = reg_lc0;\n-      lt_reg = reg_lt0;\n-      lb_reg = reg_lb0;\n-      loop->clobber_loop0 = 1;\n+      lc_reg = gen_rtx_REG (SImode, REG_LC0);\n+      lb_reg = gen_rtx_REG (SImode, REG_LB0);\n+      lt_reg = gen_rtx_REG (SImode, REG_LT0);\n+      SET_HARD_REG_BIT (loop->regs_set_in_loop, REG_LC0);\n     }\n \n   loop->end_label = end_label;\n@@ -4009,15 +3795,17 @@ bfin_optimize_loop (loop_info loop)\n   /* Insert the loop end label before the last instruction of the loop.  */\n   emit_label_before (loop->end_label, loop->last_insn);\n \n-  return;\n-\n- bad_loop:\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n-\n-  loop->bad = 1;\n+  return true;\n+}\n \n+/* A callback for the hw-doloop pass.  Called when a loop we have discovered\n+   turns out not to be optimizable; we have to split the doloop_end pattern\n+   into a subtract and a test.  */\n+static void\n+hwloop_fail (hwloop_info loop)\n+{\n+  rtx insn = loop->loop_end;\n+  \n   if (DPREG_P (loop->iter_reg))\n     {\n       /* If loop->iter_reg is a DREG or PREG, we can split it here\n@@ -4039,369 +3827,39 @@ bfin_optimize_loop (loop_info loop)\n       LABEL_NUSES (loop->start_label)++;\n       delete_insn (loop->loop_end);\n     }\n-}\n-\n-/* Called from bfin_reorg_loops when a potential loop end is found.  LOOP is\n-   a newly set up structure describing the loop, it is this function's\n-   responsibility to fill most of it.  TAIL_BB and TAIL_INSN point to the\n-   loop_end insn and its enclosing basic block.  */\n-\n-static void\n-bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n-{\n-  unsigned dwork = 0;\n-  basic_block bb;\n-  VEC (basic_block,heap) *works = VEC_alloc (basic_block,heap,20);\n-\n-  loop->tail = tail_bb;\n-  loop->head = BRANCH_EDGE (tail_bb)->dest;\n-  loop->successor = FALLTHRU_EDGE (tail_bb)->dest;\n-  loop->loop_end = tail_insn;\n-  loop->last_insn = NULL_RTX;\n-  loop->iter_reg = SET_DEST (XVECEXP (PATTERN (tail_insn), 0, 1));\n-  loop->depth = loop->length = 0;\n-  loop->visited = 0;\n-  loop->clobber_loop0 = loop->clobber_loop1 = 0;\n-  loop->outer = NULL;\n-  loop->loops = NULL;\n-  loop->incoming = VEC_alloc (edge, gc, 2);\n-  loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail_insn), 0, 0)), 1), 0);\n-  loop->end_label = NULL_RTX;\n-  loop->bad = 0;\n-\n-  VEC_safe_push (basic_block, heap, works, loop->head);\n-\n-  while (VEC_iterate (basic_block, works, dwork++, bb))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      if (bb == EXIT_BLOCK_PTR)\n-\t{\n-\t  /* We've reached the exit block.  The loop must be bad. */\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \";; Loop is bad - reached exit block while scanning\\n\");\n-\t  loop->bad = 1;\n-\t  break;\n-\t}\n-\n-      if (!bitmap_set_bit (loop->block_bitmap, bb->index))\n-\tcontinue;\n-\n-      /* We've not seen this block before.  Add it to the loop's\n-\t list and then add each successor to the work list.  */\n-\n-      VEC_safe_push (basic_block, heap, loop->blocks, bb);\n-\n-      if (bb != tail_bb)\n-\t{\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    {\n-\t      basic_block succ = EDGE_SUCC (bb, ei.index)->dest;\n-\t      if (!REGNO_REG_SET_P (df_get_live_in (succ),\n-\t\t\t\t    REGNO (loop->iter_reg)))\n-\t\tcontinue;\n-\t      if (!VEC_space (basic_block, works, 1))\n-\t\t{\n-\t\t  if (dwork)\n-\t\t    {\n-\t\t      VEC_block_remove (basic_block, works, 0, dwork);\n-\t\t      dwork = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    VEC_reserve (basic_block, heap, works, 1);\n-\t\t}\n-\t      VEC_quick_push (basic_block, works, succ);\n-\t    }\n-\t}\n-    }\n-\n-  /* Find the predecessor, and make sure nothing else jumps into this loop.  */\n-  if (!loop->bad)\n+  else\n     {\n-      int pass, retry;\n-      FOR_EACH_VEC_ELT (basic_block, loop->blocks, dwork, bb)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    {\n-\t      basic_block pred = e->src;\n-\n-\t      if (!bfin_bb_in_loop (loop, pred))\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \";; Loop %d: incoming edge %d -> %d\\n\",\n-\t\t\t     loop->loop_no, pred->index,\n-\t\t\t     e->dest->index);\n-\t\t  VEC_safe_push (edge, gc, loop->incoming, e);\n-\t\t}\n-\t    }\n-\t}\n-\n-      for (pass = 0, retry = 1; retry && pass < 2; pass++)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  bool first = true;\n-\t  retry = 0;\n-\n-\t  FOR_EACH_EDGE (e, ei, loop->incoming)\n-\t    {\n-\t      if (first)\n-\t\t{\n-\t\t  loop->incoming_src = e->src;\n-\t\t  loop->incoming_dest = e->dest;\n-\t\t  first = false;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (e->dest != loop->incoming_dest)\n-\t\t    loop->incoming_dest = NULL;\n-\t\t  if (e->src != loop->incoming_src)\n-\t\t    loop->incoming_src = NULL;\n-\t\t}\n-\t      if (loop->incoming_src == NULL && loop->incoming_dest == NULL)\n-\t\t{\n-\t\t  if (pass == 0)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \";; retrying loop %d with forwarder blocks\\n\",\n-\t\t\t\t loop->loop_no);\n-\t\t      retry = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t  loop->bad = 1;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \";; can't find suitable entry for loop %d\\n\",\n-\t\t\t     loop->loop_no);\n-\t\t  goto out;\n-\t\t}\n-\t    }\n-\t  if (retry)\n-\t    {\n-\t      retry = 0;\n-\t      FOR_EACH_EDGE (e, ei, loop->incoming)\n-\t\t{\n-\t\t  if (forwarder_block_p (e->src))\n-\t\t    {\n-\t\t      edge e2;\n-\t\t      edge_iterator ei2;\n-\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \";; Adding forwarder block %d to loop %d and retrying\\n\",\n-\t\t\t\t e->src->index, loop->loop_no);\n-\t\t      VEC_safe_push (basic_block, heap, loop->blocks, e->src);\n-\t\t      bitmap_set_bit (loop->block_bitmap, e->src->index);\n-\t\t      FOR_EACH_EDGE (e2, ei2, e->src->preds)\n-\t\t\tVEC_safe_push (edge, gc, loop->incoming, e2);\n-\t\t      VEC_unordered_remove (edge, loop->incoming, ei.index);\n-\t\t      retry = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (!retry)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \";; No forwarder blocks found\\n\");\n-\t\t  loop->bad = 1;\n-\t\t}\n-\t    }\n-\t}\n+      splitting_loops = 1;  \n+      try_split (PATTERN (insn), insn, 1);\n+      splitting_loops = 0;\n     }\n-\n- out:\n-  VEC_free (basic_block, heap, works);\n }\n \n-/* Analyze the structure of the loops in the current function.  Use STACK\n-   for bitmap allocations.  Returns all the valid candidates for hardware\n-   loops found in this function.  */\n-static loop_info\n-bfin_discover_loops (bitmap_obstack *stack, FILE *dump_file)\n-{\n-  loop_info loops = NULL;\n-  loop_info loop;\n-  basic_block bb;\n-  bitmap tmp_bitmap;\n-  int nloops = 0;\n+/* A callback for the hw-doloop pass.  This function examines INSN; if\n+   it is a loop_end pattern we recognize, return the reg rtx for the\n+   loop counter.  Otherwise, return NULL_RTX.  */\n \n-  /* Find all the possible loop tails.  This means searching for every\n-     loop_end instruction.  For each one found, create a loop_info\n-     structure and add the head block to the work list. */\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx tail = BB_END (bb);\n-\n-      while (GET_CODE (tail) == NOTE)\n-\ttail = PREV_INSN (tail);\n-\n-      bb->aux = NULL;\n-\n-      if (INSN_P (tail) && recog_memoized (tail) == CODE_FOR_loop_end)\n-\t{\n-\t  rtx insn;\n-\t  /* A possible loop end */\n-\n-\t  /* There's a degenerate case we can handle - an empty loop consisting\n-\t     of only a back branch.  Handle that by deleting the branch.  */\n-\t  insn = BB_HEAD (BRANCH_EDGE (bb)->dest);\n-\t  if (next_real_insn (insn) == tail)\n-\t    {\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \";; degenerate loop ending at\\n\");\n-\t\t  print_rtl_single (dump_file, tail);\n-\t\t}\n-\t      delete_insn_and_edges (tail);\n-\t      continue;\n-\t    }\n-\n-\t  loop = XNEW (struct loop_info_d);\n-\t  loop->next = loops;\n-\t  loops = loop;\n-\t  loop->loop_no = nloops++;\n-\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n-\t  loop->block_bitmap = BITMAP_ALLOC (stack);\n-\t  bb->aux = loop;\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \";; potential loop %d ending at\\n\",\n-\t\t       loop->loop_no);\n-\t      print_rtl_single (dump_file, tail);\n-\t    }\n-\n-\t  bfin_discover_loop (loop, bb, tail);\n-\t}\n-    }\n-\n-  tmp_bitmap = BITMAP_ALLOC (stack);\n-  /* Compute loop nestings.  */\n-  for (loop = loops; loop; loop = loop->next)\n-    {\n-      loop_info other;\n-      if (loop->bad)\n-\tcontinue;\n-\n-      for (other = loop->next; other; other = other->next)\n-\t{\n-\t  if (other->bad)\n-\t    continue;\n-\n-\t  bitmap_and (tmp_bitmap, other->block_bitmap, loop->block_bitmap);\n-\t  if (bitmap_empty_p (tmp_bitmap))\n-\t    continue;\n-\t  if (bitmap_equal_p (tmp_bitmap, other->block_bitmap))\n-\t    {\n-\t      other->outer = loop;\n-\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n-\t    }\n-\t  else if (bitmap_equal_p (tmp_bitmap, loop->block_bitmap))\n-\t    {\n-\t      loop->outer = other;\n-\t      VEC_safe_push (loop_info, heap, other->loops, loop);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \";; can't find suitable nesting for loops %d and %d\\n\",\n-\t\t\t loop->loop_no, other->loop_no);\n-\t      loop->bad = other->bad = 1;\n-\t    }\n-\t}\n-    }\n-  BITMAP_FREE (tmp_bitmap);\n+static rtx\n+hwloop_pattern_reg (rtx insn)\n+{\n+  rtx pat, reg;\n \n-  return loops;\n-}\n+  if (!JUMP_P (insn) || recog_memoized (insn) != CODE_FOR_loop_end)\n+    return NULL_RTX;\n \n-/* Free up the loop structures in LOOPS.  */\n-static void\n-free_loops (loop_info loops)\n-{\n-  while (loops)\n-    {\n-      loop_info loop = loops;\n-      loops = loop->next;\n-      VEC_free (loop_info, heap, loop->loops);\n-      VEC_free (basic_block, heap, loop->blocks);\n-      BITMAP_FREE (loop->block_bitmap);\n-      XDELETE (loop);\n-    }\n+  pat = PATTERN (insn);\n+  reg = SET_DEST (XVECEXP (PATTERN (insn), 0, 1));\n+  if (!REG_P (reg))\n+    return NULL_RTX;\n+  return reg;\n }\n \n-#define BB_AUX_INDEX(BB) ((intptr_t)(BB)->aux)\n-\n-/* The taken-branch edge from the loop end can actually go forward.  Since the\n-   Blackfin's LSETUP instruction requires that the loop end be after the loop\n-   start, try to reorder a loop's basic blocks when we find such a case.  */\n-static void\n-bfin_reorder_loops (loop_info loops, FILE *dump_file)\n+static struct hw_doloop_hooks bfin_doloop_hooks =\n {\n-  basic_block bb;\n-  loop_info loop;\n-\n-  FOR_EACH_BB (bb)\n-    bb->aux = NULL;\n-  cfg_layout_initialize (0);\n-\n-  for (loop = loops; loop; loop = loop->next)\n-    {\n-      intptr_t index;\n-      basic_block bb;\n-      edge e;\n-      edge_iterator ei;\n-\n-      if (loop->bad)\n-\tcontinue;\n-\n-      /* Recreate an index for basic blocks that represents their order.  */\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n-\t   bb != EXIT_BLOCK_PTR;\n-\t   bb = bb->next_bb, index++)\n-\tbb->aux = (PTR) index;\n-\n-      if (BB_AUX_INDEX (loop->head) < BB_AUX_INDEX (loop->tail))\n-\tcontinue;\n-\n-      FOR_EACH_EDGE (e, ei, loop->head->succs)\n-\t{\n-\t  if (bitmap_bit_p (loop->block_bitmap, e->dest->index)\n-\t      && BB_AUX_INDEX (e->dest) < BB_AUX_INDEX (loop->tail))\n-\t    {\n-\t      basic_block start_bb = e->dest;\n-\t      basic_block start_prev_bb = start_bb->prev_bb;\n-\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \";; Moving block %d before block %d\\n\",\n-\t\t\t loop->head->index, start_bb->index);\n-\t      loop->head->prev_bb->next_bb = loop->head->next_bb;\n-\t      loop->head->next_bb->prev_bb = loop->head->prev_bb;\n-\n-\t      loop->head->prev_bb = start_prev_bb;\n-\t      loop->head->next_bb = start_bb;\n-\t      start_prev_bb->next_bb = start_bb->prev_bb = loop->head;\n-\t      break;\n-\t    }\n-\t}\n-      loops = loops->next;\n-    }\n-  \n-  FOR_EACH_BB (bb)\n-    {\n-      if (bb->next_bb != EXIT_BLOCK_PTR)\n-\tbb->aux = bb->next_bb;\n-      else\n-\tbb->aux = NULL;\n-    }\n-  cfg_layout_finalize ();\n-  df_analyze ();\n-}\n+  hwloop_pattern_reg,\n+  hwloop_optimize,\n+  hwloop_fail\n+};\n \n /* Run from machine_dependent_reorg, this pass looks for doloop_end insns\n    and tries to rewrite the RTL of these loops so that proper Blackfin\n@@ -4410,62 +3868,7 @@ bfin_reorder_loops (loop_info loops, FILE *dump_file)\n static void\n bfin_reorg_loops (FILE *dump_file)\n {\n-  loop_info loops = NULL;\n-  loop_info loop;\n-  basic_block bb;\n-  bitmap_obstack stack;\n-\n-  bitmap_obstack_initialize (&stack);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Find loops, first pass\\n\\n\");\n-\n-  loops = bfin_discover_loops (&stack, dump_file);\n-\n-  if (dump_file)\n-    bfin_dump_loops (loops);\n-\n-  bfin_reorder_loops (loops, dump_file);\n-  free_loops (loops);\n-\n-  if (dump_file)\n-    fprintf (dump_file, \";; Find loops, second pass\\n\\n\");\n-\n-  loops = bfin_discover_loops (&stack, dump_file);\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \";; All loops found:\\n\\n\");\n-      bfin_dump_loops (loops);\n-    }\n-\n-  /* Now apply the optimizations.  */\n-  for (loop = loops; loop; loop = loop->next)\n-    bfin_optimize_loop (loop);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \";; After hardware loops optimization:\\n\\n\");\n-      bfin_dump_loops (loops);\n-    }\n-\n-  free_loops (loops);\n-\n-  if (dump_file)\n-    print_rtl (dump_file, get_insns ());\n-\n-  FOR_EACH_BB (bb)\n-    bb->aux = NULL;\n-\n-  splitting_loops = 1;\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx insn = BB_END (bb);\n-      if (!JUMP_P (insn))\n-\tcontinue;\n-\n-      try_split (PATTERN (insn), insn, 1);\n-    }\n-  splitting_loops = 0;\n+  reorg_loops (true, &bfin_doloop_hooks);\n }\n \f\n /* Possibly generate a SEQUENCE out of three insns found in SLOT."}, {"sha": "8d8413de3046c6a89493ef686e1d9f37b5a1501c", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -1993,7 +1993,7 @@\n \t      (const_int -1)))\n    (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n    (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"splitting_loops\"\n+  \"memory_operand (operands[0], SImode) || splitting_loops\"\n   [(set (match_dup 2) (match_dup 0))\n    (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n    (set (match_dup 0) (match_dup 2))"}, {"sha": "3d59200a84b6ab2e0a6e51125bc55bfa210e6b23", "filename": "gcc/hw-doloop.c", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -0,0 +1,672 @@\n+/* Code to analyze doloop loops in order for targets to perform late\n+   optimizations converting doloops to other forms of hardware loops.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"expr.h\"\n+#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n+#include \"basic-block.h\"\n+#include \"tm_p.h\"\n+#include \"df.h\"\n+#include \"cfglayout.h\"\n+#include \"cfgloop.h\"\n+#include \"output.h\"\n+#include \"recog.h\"\n+#include \"target.h\"\n+#include \"hw-doloop.h\"\n+\n+#ifdef HAVE_doloop_end\n+\n+/* Dump information collected in LOOPS.  */\n+static void\n+dump_hwloops (hwloop_info loops)\n+{\n+  hwloop_info loop;\n+\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      hwloop_info i;\n+      basic_block b;\n+      unsigned ix;\n+\n+      fprintf (dump_file, \";; loop %d: \", loop->loop_no);\n+      if (loop->bad)\n+\tfprintf (dump_file, \"(bad) \");\n+      fprintf (dump_file, \"{head:%d, depth:%d, reg:%u}\",\n+\t       loop->head == NULL ? -1 : loop->head->index,\n+\t       loop->depth, REGNO (loop->iter_reg));\n+\n+      fprintf (dump_file, \" blocks: [ \");\n+      for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n+\tfprintf (dump_file, \"%d \", b->index);\n+      fprintf (dump_file, \"] \");\n+\n+      fprintf (dump_file, \" inner loops: [ \");\n+      for (ix = 0; VEC_iterate (hwloop_info, loop->loops, ix, i); ix++)\n+\tfprintf (dump_file, \"%d \", i->loop_no);\n+      fprintf (dump_file, \"]\\n\");\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Return true if BB is part of LOOP.  */\n+static bool\n+bb_in_loop_p (hwloop_info loop, basic_block bb)\n+{\n+  return bitmap_bit_p (loop->block_bitmap, bb->index);\n+}\n+\n+/* Scan the blocks of LOOP (and its inferiors), and record things such as\n+   hard registers set, jumps out of and within the loop.  */\n+static void\n+scan_loop (hwloop_info loop)\n+{\n+  unsigned ix;\n+  basic_block bb;\n+\n+  if (loop->bad)\n+    return;\n+\n+  if (REGNO_REG_SET_P (df_get_live_in (loop->successor),\n+\t\t       REGNO (loop->iter_reg)))\n+    loop->iter_reg_used_outside = true;\n+\n+  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+    {\n+      rtx insn;\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (bb != loop->tail)\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  {\n+\t    if (bb_in_loop_p (loop, e->dest))\n+\t      {\n+\t\tif (!(e->flags & EDGE_FALLTHRU))\n+\t\t  loop->jumps_within = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\tloop->jumps_outof = true;\n+\t\tif (!loop->bad)\n+\t\t  gcc_assert (!REGNO_REG_SET_P (df_get_live_in (e->dest),\n+\t\t\t\t\t\tREGNO (loop->iter_reg)));\n+\t      }\n+\t  }\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  df_ref *def_rec;\n+\t  HARD_REG_SET set_this_insn;\n+\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\n+\t  if (recog_memoized (insn) < 0\n+\t      && (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t  || asm_noperands (PATTERN (insn)) >= 0))\n+\t    loop->has_asm = true;\n+\n+\t  CLEAR_HARD_REG_SET (set_this_insn);\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    {\n+\t      rtx dreg = DF_REF_REG (*def_rec);\n+\n+\t      if (!REG_P (dreg))\n+\t\tcontinue;\n+\n+\t      add_to_hard_reg_set (&set_this_insn, GET_MODE (dreg),\n+\t\t\t\t   REGNO (dreg));\n+\t    }\n+\n+\t  if (insn == loop->loop_end)\n+\t    CLEAR_HARD_REG_BIT (set_this_insn, REGNO (loop->iter_reg));\n+\t  else if (reg_mentioned_p (loop->iter_reg, PATTERN (insn)))\n+\t    loop->iter_reg_used = true;\n+\t  IOR_HARD_REG_SET (loop->regs_set_in_loop, set_this_insn);\n+\t}\n+    }\n+}\n+\n+/* Compute the incoming_dest and incoming_src members of LOOP by\n+   identifying the edges that jump into the loop.  If there is more\n+   than one block that jumps into the loop, incoming_src will be set\n+   to NULL; likewise, if there is more than one block in the loop that\n+   is the destination of an incoming edge, incoming_dest will be NULL.\n+\n+   Return true if either of these two fields is nonnull, false\n+   otherwise.  */\n+static bool\n+process_incoming_edges (hwloop_info loop)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool first = true;\n+\n+  FOR_EACH_EDGE (e, ei, loop->incoming)\n+    {\n+      if (first)\n+\t{\n+\t  loop->incoming_src = e->src;\n+\t  loop->incoming_dest = e->dest;\n+\t  first = false;\n+\t}\n+      else\n+\t{\n+\t  if (e->dest != loop->incoming_dest)\n+\t    loop->incoming_dest = NULL;\n+\t  if (e->src != loop->incoming_src)\n+\t    loop->incoming_src = NULL;\n+\t}\n+    }\n+  if (loop->incoming_src == NULL && loop->incoming_dest == NULL)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Try to identify a forwarder block that jump into LOOP, and add it to\n+   the set of blocks in the loop, updating the vector of incoming blocks as\n+   well.  This transformation gives a second chance to loops we couldn't\n+   otherwise handle by increasing the chance that we'll end up with one\n+   incoming_src block.\n+   Return true if we made a change, false otherwise.  */\n+static bool\n+add_forwarder_blocks (hwloop_info loop)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, loop->incoming)\n+    {\n+      if (forwarder_block_p (e->src))\n+\t{\n+\t  edge e2;\n+\t  edge_iterator ei2;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \";; Adding forwarder block %d to loop %d and retrying\\n\",\n+\t\t     e->src->index, loop->loop_no);\n+\t  VEC_safe_push (basic_block, heap, loop->blocks, e->src);\n+\t  bitmap_set_bit (loop->block_bitmap, e->src->index);\n+\t  FOR_EACH_EDGE (e2, ei2, e->src->preds)\n+\t    VEC_safe_push (edge, gc, loop->incoming, e2);\n+\t  VEC_unordered_remove (edge, loop->incoming, ei.index);\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Called from reorg_loops when a potential loop end is found.  LOOP is\n+   a newly set up structure describing the loop, it is this function's\n+   responsibility to fill most of it.  TAIL_BB and TAIL_INSN point to the\n+   loop_end insn and its enclosing basic block.  REG is the loop counter\n+   register.\n+   For our purposes, a loop is defined by the set of blocks reachable from\n+   the loop head in which the loop counter register is live.  This matches\n+   the expected use; targets that call into this code usually replace the\n+   loop counter with a different special register.  */\n+static void\n+discover_loop (hwloop_info loop, basic_block tail_bb, rtx tail_insn, rtx reg)\n+{\n+  bool found_tail;\n+  unsigned dwork = 0;\n+  basic_block bb;\n+  VEC (basic_block,heap) *works;\n+\n+  loop->tail = tail_bb;\n+  loop->loop_end = tail_insn;\n+  loop->iter_reg = reg;\n+  loop->incoming = VEC_alloc (edge, gc, 2);\n+  loop->start_label = JUMP_LABEL (tail_insn);\n+\n+  if (EDGE_COUNT (tail_bb->succs) != 2)\n+    {\n+      loop->bad = true;\n+      return;\n+    }\n+  loop->head = BRANCH_EDGE (tail_bb)->dest;\n+  loop->successor = FALLTHRU_EDGE (tail_bb)->dest;\n+\n+  works = VEC_alloc (basic_block, heap, 20);\n+  VEC_safe_push (basic_block, heap, works, loop->head);\n+\n+  found_tail = false;\n+  for (dwork = 0; VEC_iterate (basic_block, works, dwork, bb); dwork++)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      if (bb == EXIT_BLOCK_PTR)\n+\t{\n+\t  /* We've reached the exit block.  The loop must be bad. */\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \";; Loop is bad - reached exit block while scanning\\n\");\n+\t  loop->bad = true;\n+\t  break;\n+\t}\n+\n+      if (bitmap_bit_p (loop->block_bitmap, bb->index))\n+\tcontinue;\n+\n+      /* We've not seen this block before.  Add it to the loop's\n+\t list and then add each successor to the work list.  */\n+\n+      VEC_safe_push (basic_block, heap, loop->blocks, bb);\n+      bitmap_set_bit (loop->block_bitmap, bb->index);\n+\n+      if (bb == tail_bb)\n+\tfound_tail = true;\n+      else\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      basic_block succ = EDGE_SUCC (bb, ei.index)->dest;\n+\t      if (REGNO_REG_SET_P (df_get_live_in (succ),\n+\t\t\t\t   REGNO (loop->iter_reg)))\n+\t\tVEC_safe_push (basic_block, heap, works, succ);\n+\t    }\n+\t}\n+    }\n+\n+  if (!found_tail)\n+    loop->bad = true;\n+  \n+  /* Find the predecessor, and make sure nothing else jumps into this loop.  */\n+  if (!loop->bad)\n+    {\n+      FOR_EACH_VEC_ELT (basic_block, loop->blocks, dwork, bb)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      basic_block pred = e->src;\n+\n+\t      if (!bb_in_loop_p (loop, pred))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \";; Loop %d: incoming edge %d -> %d\\n\",\n+\t\t\t     loop->loop_no, pred->index,\n+\t\t\t     e->dest->index);\n+\t\t  VEC_safe_push (edge, gc, loop->incoming, e);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (!process_incoming_edges (loop))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \";; retrying loop %d with forwarder blocks\\n\",\n+\t\t     loop->loop_no);\n+\t  if (!add_forwarder_blocks (loop))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \";; No forwarder blocks found\\n\");\n+\t      loop->bad = true;\n+\t    }\n+\t  else if (!process_incoming_edges (loop))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \";; can't find suitable entry for loop %d\\n\",\n+\t\t\t loop->loop_no);\n+\t    }\n+\t}\n+    }\n+\n+  VEC_free (basic_block, heap, works);\n+}\n+\n+/* Analyze the structure of the loops in the current function.  Use\n+   STACK for bitmap allocations.  Returns all the valid candidates for\n+   hardware loops found in this function.  HOOKS is the argument\n+   passed to reorg_loops, used here to find the iteration registers\n+   from a loop_end pattern.  */\n+static hwloop_info\n+discover_loops (bitmap_obstack *stack, struct hw_doloop_hooks *hooks)\n+{\n+  hwloop_info loops = NULL;\n+  hwloop_info loop;\n+  basic_block bb;\n+  int nloops = 0;\n+\n+  /* Find all the possible loop tails.  This means searching for every\n+     loop_end instruction.  For each one found, create a hwloop_info\n+     structure and add the head block to the work list. */\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx tail = BB_END (bb);\n+      rtx insn, reg;\n+\n+      while (tail && GET_CODE (tail) == NOTE && tail != BB_HEAD (bb))\n+\ttail = PREV_INSN (tail);\n+\n+      if (tail == NULL_RTX)\n+\tcontinue;\n+\n+      if (!JUMP_P (tail))\n+\tcontinue;\n+      reg = hooks->end_pattern_reg (tail);\n+      if (reg == NULL_RTX)\n+\tcontinue;\n+\n+      /* A possible loop end */\n+\n+      /* There's a degenerate case we can handle - an empty loop consisting\n+\t of only a back branch.  Handle that by deleting the branch.  */\n+      insn = JUMP_LABEL (tail);\n+      while (insn && !NONDEBUG_INSN_P (insn))\n+\tinsn = NEXT_INSN (insn);\n+      if (insn == tail)\n+\t{\n+\t  basic_block succ = FALLTHRU_EDGE (bb)->dest;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \";; degenerate loop ending at\\n\");\n+\t      print_rtl_single (dump_file, tail);\n+\t    }\n+\t  if (!REGNO_REG_SET_P (df_get_live_in (succ), REGNO (reg)))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \";; deleting it\\n\");\n+\t      delete_insn_and_edges (tail);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      loop = XCNEW (struct hwloop_info_d);\n+      loop->next = loops;\n+      loops = loop;\n+      loop->loop_no = nloops++;\n+      loop->blocks = VEC_alloc (basic_block, heap, 20);\n+      loop->block_bitmap = BITMAP_ALLOC (stack);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; potential loop %d ending at\\n\",\n+\t\t   loop->loop_no);\n+\t  print_rtl_single (dump_file, tail);\n+\t}\n+\n+      discover_loop (loop, bb, tail, reg);\n+    }\n+\n+  /* Compute loop nestings.  Given two loops A and B, either the sets\n+     of their blocks don't intersect at all, or one is the subset of\n+     the other, or the blocks don't form a good nesting structure.  */\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      hwloop_info other;\n+\n+      if (loop->bad)\n+\tcontinue;\n+\n+      for (other = loops; other; other = other->next)\n+\t{\n+\t  if (other->bad)\n+\t    continue;\n+\n+\t  if (!bitmap_intersect_p (other->block_bitmap, loop->block_bitmap))\n+\t    continue;\n+\t  if (!bitmap_intersect_compl_p (other->block_bitmap,\n+\t\t\t\t\t loop->block_bitmap))\n+\t    VEC_safe_push (hwloop_info, heap, loop->loops, other);\n+\t  else if (!bitmap_intersect_compl_p (loop->block_bitmap,\n+\t\t\t\t\t      other->block_bitmap))\n+\t    VEC_safe_push (hwloop_info, heap, other->loops, loop);\n+\t  else\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \";; can't find suitable nesting for loops %d and %d\\n\",\n+\t\t\t loop->loop_no, other->loop_no);\n+\t      loop->bad = other->bad = true;\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    dump_hwloops (loops);\n+\n+  return loops;\n+}\n+\n+/* Free up the loop structures in LOOPS.  */\n+static void\n+free_loops (hwloop_info loops)\n+{\n+  while (loops)\n+    {\n+      hwloop_info loop = loops;\n+      loops = loop->next;\n+      VEC_free (hwloop_info, heap, loop->loops);\n+      VEC_free (basic_block, heap, loop->blocks);\n+      BITMAP_FREE (loop->block_bitmap);\n+      XDELETE (loop);\n+    }\n+}\n+\n+#define BB_AUX_INDEX(BB) ((intptr_t) (BB)->aux)\n+\n+/* Initialize the aux fields to give ascending indices to basic blocks.  */\n+static void\n+set_bb_indices (void)\n+{\n+  basic_block bb;\n+  intptr_t index;\n+\n+  index = 0;\n+  FOR_EACH_BB (bb)\n+    bb->aux = (void *) index++;\n+}\n+\n+/* The taken-branch edge from the loop end can actually go forward.\n+   If the target's hardware loop support requires that the loop end be\n+   after the loop start, try to reorder a loop's basic blocks when we\n+   find such a case.\n+   This is not very aggressive; it only moves at most one block.  It\n+   does not introduce new branches into loops; it may remove them, or\n+   it may switch fallthru/jump edges.  */\n+static void\n+reorder_loops (hwloop_info loops)\n+{\n+  basic_block bb;\n+  hwloop_info loop;\n+\n+  cfg_layout_initialize (0);\n+\n+  set_bb_indices ();\n+\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (loop->bad)\n+\tcontinue;\n+\n+      if (BB_AUX_INDEX (loop->head) <= BB_AUX_INDEX (loop->tail))\n+\tcontinue;\n+\n+      FOR_EACH_EDGE (e, ei, loop->head->succs)\n+\t{\n+\t  if (bitmap_bit_p (loop->block_bitmap, e->dest->index)\n+\t      && BB_AUX_INDEX (e->dest) < BB_AUX_INDEX (loop->tail))\n+\t    {\n+\t      basic_block start_bb = e->dest;\n+\t      basic_block start_prev_bb = start_bb->prev_bb;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \";; Moving block %d before block %d\\n\",\n+\t\t\t loop->head->index, start_bb->index);\n+\t      loop->head->prev_bb->next_bb = loop->head->next_bb;\n+\t      loop->head->next_bb->prev_bb = loop->head->prev_bb;\n+\n+\t      loop->head->prev_bb = start_prev_bb;\n+\t      loop->head->next_bb = start_bb;\n+\t      start_prev_bb->next_bb = start_bb->prev_bb = loop->head;\n+\n+\t      set_bb_indices ();\n+\t      break;\n+\t    }\n+\t}\n+      loops = loops->next;\n+    }\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->next_bb != EXIT_BLOCK_PTR)\n+\tbb->aux = bb->next_bb;\n+      else\n+\tbb->aux = NULL;\n+    }\n+  cfg_layout_finalize ();\n+  clear_aux_for_blocks ();\n+  df_analyze ();\n+}\n+\n+/* Call the OPT function for LOOP and all of its sub-loops.  This is\n+   done in a depth-first search; innermost loops are visited first.\n+   OPTIMIZE and FAIL are the functions passed to reorg_loops by the\n+   target's reorg pass.  */\n+static void\n+optimize_loop (hwloop_info loop, struct hw_doloop_hooks *hooks)\n+{\n+  int ix;\n+  hwloop_info inner;\n+  int inner_depth = 0;\n+\n+  if (loop->visited)\n+    return;\n+\n+  loop->visited = 1;\n+\n+  if (loop->bad)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d bad when found\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Every loop contains in its list of inner loops every loop nested inside\n+     it, even if there are intermediate loops.  This works because we're doing\n+     a depth-first search here and never visit a loop more than once.\n+     Recursion depth is effectively limited by the number of available\n+     hardware registers.  */\n+  for (ix = 0; VEC_iterate (hwloop_info, loop->loops, ix, inner); ix++)\n+    {\n+      optimize_loop (inner, hooks);\n+\n+      if (!inner->bad && inner_depth < inner->depth)\n+\tinner_depth = inner->depth;\n+      /* The set of registers may be changed while optimizing the inner\n+\t loop.  */\n+      IOR_HARD_REG_SET (loop->regs_set_in_loop, inner->regs_set_in_loop);\n+    }\n+\n+  loop->depth = inner_depth + 1;\n+\n+  if (hooks->opt (loop))\n+    return;\n+\n+ bad_loop:\n+  if (dump_file)\n+    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n+\n+  loop->bad = true;\n+  hooks->fail (loop);\n+}\n+\n+/* This function can be used from a port's machine_dependent_reorg to\n+   find and analyze loops that end in loop_end instructions.  It uses\n+   a set of function pointers in HOOKS to call back into the\n+   target-specific functions to perform the actual machine-specific\n+   transformations.\n+\n+   Such transformations typically involve additional set-up\n+   instructions before the loop, to define loop bounds or set up a\n+   special loop counter register.\n+\n+   DO_REORDER should be set to true if we should try to use the\n+   reorder_loops function to ensure the loop end occurs after the loop\n+   start.  This is for use by targets where the loop hardware requires\n+   this condition.\n+\n+   HOOKS is used to pass in target specific hooks; see\n+   hw-doloop.h.  */\n+void\n+reorg_loops (bool do_reorder, struct hw_doloop_hooks *hooks)\n+{\n+  hwloop_info loops = NULL;\n+  hwloop_info loop;\n+  bitmap_obstack stack;\n+\n+  df_live_add_problem ();\n+  df_live_set_all_dirty ();\n+  df_analyze ();\n+\n+  bitmap_obstack_initialize (&stack);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \";; Find loops, first pass\\n\\n\");\n+\n+  loops = discover_loops (&stack, hooks);\n+\n+  if (do_reorder)\n+    {\n+      reorder_loops (loops);\n+      free_loops (loops);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Find loops, second pass\\n\\n\");\n+\n+      loops = discover_loops (&stack, hooks);\n+    }\n+\n+  for (loop = loops; loop; loop = loop->next)\n+    scan_loop (loop);\n+\n+  /* Now apply the optimizations.  */\n+  for (loop = loops; loop; loop = loop->next)\n+    optimize_loop (loop, hooks);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; After hardware loops optimization:\\n\\n\");\n+      dump_hwloops (loops);\n+    }\n+\n+  free_loops (loops);\n+\n+  if (dump_file)\n+    print_rtl (dump_file, get_insns ());\n+}\n+#endif"}, {"sha": "006b67953b2ecd8706d5cdb5c302d4057a1d7f7c", "filename": "gcc/hw-doloop.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fhw-doloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d9c740d1efcd1bd597ef4734227996a8f69151d/gcc%2Fhw-doloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.h?ref=9d9c740d1efcd1bd597ef4734227996a8f69151d", "patch": "@@ -0,0 +1,157 @@\n+/* Code to analyze doloop loops in order for targets to perform late\n+   optimizations converting doloops to other forms of hardware loops.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* We need to keep a vector of loops */\n+typedef struct hwloop_info_d *hwloop_info;\n+DEF_VEC_P (hwloop_info);\n+DEF_VEC_ALLOC_P (hwloop_info,heap);\n+\n+/* Information about a loop we have found (or are in the process of\n+   finding).  */\n+struct GTY (()) hwloop_info_d\n+{\n+  /* loop number, for dumps */\n+  int loop_no;\n+\n+  /* Next loop in the graph. */\n+  hwloop_info next;\n+\n+  /* Vector of blocks only within the loop, including those within\n+     inner loops.  */\n+  VEC (basic_block, heap) *blocks;\n+\n+  /* Same information in a bitmap.  */\n+  bitmap block_bitmap;\n+\n+  /* Vector of inner loops within this loop.  Includes loops of every\n+     nesting level.  */\n+  VEC (hwloop_info, heap) *loops;\n+\n+  /* All edges that jump into the loop.  */\n+  VEC(edge, gc) *incoming;\n+\n+  /* The ports currently using this infrastructure can typically\n+     handle two cases: all incoming edges have the same destination\n+     block, or all incoming edges have the same source block.  These\n+     two members are set to the common source or destination we found,\n+     or NULL if different blocks were found.  If both are NULL the\n+     loop can't be optimized.  */\n+  basic_block incoming_src;\n+  basic_block incoming_dest;\n+\n+  /* First block in the loop.  This is the one branched to by the loop_end\n+     insn.  */\n+  basic_block head;\n+\n+  /* Last block in the loop (the one with the loop_end insn).  */\n+  basic_block tail;\n+\n+  /* The successor block of the loop.  This is the one the loop_end insn\n+     falls into.  */\n+  basic_block successor;\n+\n+  /* The last instruction in the tail.  */\n+  rtx last_insn;\n+\n+  /* The loop_end insn.  */\n+  rtx loop_end;\n+\n+  /* The iteration register.  */\n+  rtx iter_reg;\n+\n+  /* The new label placed at the beginning of the loop. */\n+  rtx start_label;\n+\n+  /* The new label placed at the end of the loop. */\n+  rtx end_label;\n+\n+  /* The length of the loop.  */\n+  int length;\n+\n+  /* The nesting depth of the loop.  Innermost loops are given a depth\n+     of 1.  Only successfully optimized doloops are counted; if an inner\n+     loop was marked as bad, it does not increase the depth of its parent\n+     loop.\n+     This value is valid when the target's optimize function is called.  */\n+  int depth;\n+\n+  /* True if we can't optimize this loop.  */\n+  bool bad;\n+\n+  /* True if we have visited this loop during the optimization phase.  */\n+  bool visited;\n+\n+  /* The following values are collected before calling the target's optimize\n+     function and are not valid earlier.  */\n+  \n+  /* Record information about control flow: whether the loop has calls\n+     or asm statements, whether it has edges that jump out of the loop,\n+     or edges that jump within the loop.  */\n+  bool has_call;\n+  bool has_asm;\n+  bool jumps_within;\n+  bool jumps_outof;\n+\n+  /* True if there is an instruction other than the doloop_end which uses the\n+     iteration register.  */\n+  bool iter_reg_used;\n+  /* True if the iteration register lives past the doloop instruction.  */\n+  bool iter_reg_used_outside;\n+\n+  /* Hard registers set at any point in the loop, except for the loop counter\n+     register's set in the doloop_end instruction.  */\n+  HARD_REG_SET regs_set_in_loop;\n+};\n+\n+/* A set of hooks to be defined by a target that wants to use the reorg_loops\n+   functionality.\n+\n+   reorg_loops is intended to handle cases where special hardware loop\n+   setup instructions are required before the loop, for example to set\n+   up loop counter registers that are not exposed to the register\n+   allocator, or to inform the hardware about loop bounds.\n+\n+   reorg_loops performs analysis to discover loop_end patterns created\n+   by the earlier loop-doloop pass, and sets up a hwloop_info\n+   structure for each such insn it finds.  It then tries to discover\n+   the basic blocks containing the loop by tracking the lifetime of\n+   the iteration register.\n+\n+   If a valid loop can't be found, the FAIL function is called;\n+   otherwise the OPT function is called for each loop, visiting\n+   innermost loops first and ascending.  */\n+struct hw_doloop_hooks\n+{\n+  /* Examine INSN.  If it is a suitable doloop_end pattern, return the\n+     iteration register, which should be a single hard register.\n+     Otherwise, return NULL_RTX.  */\n+  rtx (*end_pattern_reg) (rtx insn);\n+  /* Optimize LOOP.  The target should perform any additional analysis\n+     (e.g. checking that the loop isn't too long), and then perform\n+     its transformations.  Return true if successful, false if the\n+     loop should be marked bad.  If it returns false, the FAIL\n+     function is called.  */\n+  bool (*opt) (hwloop_info loop);\n+  /* Handle a loop that was marked bad for any reason.  This could be\n+     used to split the doloop_end pattern.  */\n+  void (*fail) (hwloop_info loop);\n+};\n+\n+extern void reorg_loops (bool, struct hw_doloop_hooks *);"}]}