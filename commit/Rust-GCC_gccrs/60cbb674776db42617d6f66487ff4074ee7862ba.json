{"sha": "60cbb674776db42617d6f66487ff4074ee7862ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjYmI2NzQ3NzZkYjQyNjE3ZDZmNjY0ODdmZjQwNzRlZTc4NjJiYQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2016-04-15T11:49:39Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2016-04-15T11:49:39Z"}, "message": "Split out OMP constructs' SIMD clone supporting code\n\n\tgcc/\n\t* omp-low.c (simd_clone_struct_alloc, simd_clone_struct_copy)\n\t(simd_clone_vector_of_formal_parm_types)\n\t(simd_clone_clauses_extract, simd_clone_compute_base_data_type)\n\t(simd_clone_mangle, simd_clone_create)\n\t(simd_clone_adjust_return_type, create_tmp_simd_array)\n\t(simd_clone_adjust_argument_types, simd_clone_init_simd_arrays)\n\t(struct modify_stmt_info, ipa_simd_modify_stmt_ops)\n\t(ipa_simd_modify_function_body, simd_clone_linear_addend)\n\t(simd_clone_adjust, expand_simd_clones, ipa_omp_simd_clone)\n\t(pass_data_omp_simd_clone, class pass_omp_simd_clone)\n\t(pass_omp_simd_clone::gate, make_pass_omp_simd_clone): Move\n\tinto...\n\t* omp-simd-clone.c: ... this new file.\n\t(simd_clone_vector_of_formal_parm_types): Make it static.\n\t* Makefile.in (OBJS): Add omp-simd-clone.o.\n\nFrom-SVN: r235017", "tree": {"sha": "6079326408af21c42010949a5284d4023c888521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6079326408af21c42010949a5284d4023c888521"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60cbb674776db42617d6f66487ff4074ee7862ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cbb674776db42617d6f66487ff4074ee7862ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cbb674776db42617d6f66487ff4074ee7862ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cbb674776db42617d6f66487ff4074ee7862ba/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1355e62cf8eb8a84fa706f1f2beefc56ea12be2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1355e62cf8eb8a84fa706f1f2beefc56ea12be2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1355e62cf8eb8a84fa706f1f2beefc56ea12be2d"}], "stats": {"total": 3279, "additions": 1673, "deletions": 1606}, "files": [{"sha": "3173ae8e5fcb9e170ea4d3f2d2aaa164727ebcb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60cbb674776db42617d6f66487ff4074ee7862ba", "patch": "@@ -1,3 +1,21 @@\n+2016-04-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* omp-low.c (simd_clone_struct_alloc, simd_clone_struct_copy)\n+\t(simd_clone_vector_of_formal_parm_types)\n+\t(simd_clone_clauses_extract, simd_clone_compute_base_data_type)\n+\t(simd_clone_mangle, simd_clone_create)\n+\t(simd_clone_adjust_return_type, create_tmp_simd_array)\n+\t(simd_clone_adjust_argument_types, simd_clone_init_simd_arrays)\n+\t(struct modify_stmt_info, ipa_simd_modify_stmt_ops)\n+\t(ipa_simd_modify_function_body, simd_clone_linear_addend)\n+\t(simd_clone_adjust, expand_simd_clones, ipa_omp_simd_clone)\n+\t(pass_data_omp_simd_clone, class pass_omp_simd_clone)\n+\t(pass_omp_simd_clone::gate, make_pass_omp_simd_clone): Move\n+\tinto...\n+\t* omp-simd-clone.c: ... this new file.\n+\t(simd_clone_vector_of_formal_parm_types): Make it static.\n+\t* Makefile.in (OBJS): Add omp-simd-clone.o.\n+\n 2016-04-15  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \tPR target/70662"}, {"sha": "6c5adc0bb58cfce74f1fe26b1eec436bdbfb4fe0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=60cbb674776db42617d6f66487ff4074ee7862ba", "patch": "@@ -1369,6 +1369,7 @@ OBJS = \\\n \tmodulo-sched.o \\\n \tmultiple_target.o \\\n \tomp-low.o \\\n+\tomp-simd-clone.o \\\n \toptabs.o \\\n \toptabs-libfuncs.o \\\n \toptabs-query.o \\"}, {"sha": "7282cc8a3821121c927a36495dda998ca8d42fdc", "filename": "gcc/omp-low.c", "status": "modified", "additions": 0, "deletions": 1606, "changes": 1606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=60cbb674776db42617d6f66487ff4074ee7862ba", "patch": "@@ -18409,1612 +18409,6 @@ make_pass_diagnose_omp_blocks (gcc::context *ctxt)\n   return new pass_diagnose_omp_blocks (ctxt);\n }\n \f\n-/* SIMD clone supporting code.  */\n-\n-/* Allocate a fresh `simd_clone' and return it.  NARGS is the number\n-   of arguments to reserve space for.  */\n-\n-static struct cgraph_simd_clone *\n-simd_clone_struct_alloc (int nargs)\n-{\n-  struct cgraph_simd_clone *clone_info;\n-  size_t len = (sizeof (struct cgraph_simd_clone)\n-\t\t+ nargs * sizeof (struct cgraph_simd_clone_arg));\n-  clone_info = (struct cgraph_simd_clone *)\n-\t       ggc_internal_cleared_alloc (len);\n-  return clone_info;\n-}\n-\n-/* Make a copy of the `struct cgraph_simd_clone' in FROM to TO.  */\n-\n-static inline void\n-simd_clone_struct_copy (struct cgraph_simd_clone *to,\n-\t\t\tstruct cgraph_simd_clone *from)\n-{\n-  memcpy (to, from, (sizeof (struct cgraph_simd_clone)\n-\t\t     + ((from->nargs - from->inbranch)\n-\t\t\t* sizeof (struct cgraph_simd_clone_arg))));\n-}\n-\n-/* Return vector of parameter types of function FNDECL.  This uses\n-   TYPE_ARG_TYPES if available, otherwise falls back to types of\n-   DECL_ARGUMENTS types.  */\n-\n-vec<tree>\n-simd_clone_vector_of_formal_parm_types (tree fndecl)\n-{\n-  if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n-    return ipa_get_vector_of_formal_parm_types (TREE_TYPE (fndecl));\n-  vec<tree> args = ipa_get_vector_of_formal_parms (fndecl);\n-  unsigned int i;\n-  tree arg;\n-  FOR_EACH_VEC_ELT (args, i, arg)\n-    args[i] = TREE_TYPE (args[i]);\n-  return args;\n-}\n-\n-/* Given a simd function in NODE, extract the simd specific\n-   information from the OMP clauses passed in CLAUSES, and return\n-   the struct cgraph_simd_clone * if it should be cloned.  *INBRANCH_SPECIFIED\n-   is set to TRUE if the `inbranch' or `notinbranch' clause specified,\n-   otherwise set to FALSE.  */\n-\n-static struct cgraph_simd_clone *\n-simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n-\t\t\t    bool *inbranch_specified)\n-{\n-  vec<tree> args = simd_clone_vector_of_formal_parm_types (node->decl);\n-  tree t;\n-  int n;\n-  *inbranch_specified = false;\n-\n-  n = args.length ();\n-  if (n > 0 && args.last () == void_type_node)\n-    n--;\n-\n-  /* To distinguish from an OpenMP simd clone, Cilk Plus functions to\n-     be cloned have a distinctive artificial label in addition to \"omp\n-     declare simd\".  */\n-  bool cilk_clone\n-    = (flag_cilkplus\n-       && lookup_attribute (\"cilk simd function\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)));\n-\n-  /* Allocate one more than needed just in case this is an in-branch\n-     clone which will require a mask argument.  */\n-  struct cgraph_simd_clone *clone_info = simd_clone_struct_alloc (n + 1);\n-  clone_info->nargs = n;\n-  clone_info->cilk_elemental = cilk_clone;\n-\n-  if (!clauses)\n-    {\n-      args.release ();\n-      return clone_info;\n-    }\n-  clauses = TREE_VALUE (clauses);\n-  if (!clauses || TREE_CODE (clauses) != OMP_CLAUSE)\n-    return clone_info;\n-\n-  for (t = clauses; t; t = OMP_CLAUSE_CHAIN (t))\n-    {\n-      switch (OMP_CLAUSE_CODE (t))\n-\t{\n-\tcase OMP_CLAUSE_INBRANCH:\n-\t  clone_info->inbranch = 1;\n-\t  *inbranch_specified = true;\n-\t  break;\n-\tcase OMP_CLAUSE_NOTINBRANCH:\n-\t  clone_info->inbranch = 0;\n-\t  *inbranch_specified = true;\n-\t  break;\n-\tcase OMP_CLAUSE_SIMDLEN:\n-\t  clone_info->simdlen\n-\t    = TREE_INT_CST_LOW (OMP_CLAUSE_SIMDLEN_EXPR (t));\n-\t  break;\n-\tcase OMP_CLAUSE_LINEAR:\n-\t  {\n-\t    tree decl = OMP_CLAUSE_DECL (t);\n-\t    tree step = OMP_CLAUSE_LINEAR_STEP (t);\n-\t    int argno = TREE_INT_CST_LOW (decl);\n-\t    if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (t))\n-\t      {\n-\t\tenum cgraph_simd_clone_arg_type arg_type;\n-\t\tif (TREE_CODE (args[argno]) == REFERENCE_TYPE)\n-\t\t  switch (OMP_CLAUSE_LINEAR_KIND (t))\n-\t\t    {\n-\t\t    case OMP_CLAUSE_LINEAR_REF:\n-\t\t      arg_type\n-\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP;\n-\t\t      break;\n-\t\t    case OMP_CLAUSE_LINEAR_UVAL:\n-\t\t      arg_type\n-\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP;\n-\t\t      break;\n-\t\t    case OMP_CLAUSE_LINEAR_VAL:\n-\t\t    case OMP_CLAUSE_LINEAR_DEFAULT:\n-\t\t      arg_type\n-\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP;\n-\t\t      break;\n-\t\t    default:\n-\t\t      gcc_unreachable ();\n-\t\t    }\n-\t\telse\n-\t\t  arg_type = SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP;\n-\t\tclone_info->args[argno].arg_type = arg_type;\n-\t\tclone_info->args[argno].linear_step = tree_to_shwi (step);\n-\t\tgcc_assert (clone_info->args[argno].linear_step >= 0\n-\t\t\t    && clone_info->args[argno].linear_step < n);\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (POINTER_TYPE_P (args[argno]))\n-\t\t  step = fold_convert (ssizetype, step);\n-\t\tif (!tree_fits_shwi_p (step))\n-\t\t  {\n-\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n-\t\t\t\t\"ignoring large linear step\");\n-\t\t    args.release ();\n-\t\t    return NULL;\n-\t\t  }\n-\t\telse if (integer_zerop (step))\n-\t\t  {\n-\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n-\t\t\t\t\"ignoring zero linear step\");\n-\t\t    args.release ();\n-\t\t    return NULL;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    enum cgraph_simd_clone_arg_type arg_type;\n-\t\t    if (TREE_CODE (args[argno]) == REFERENCE_TYPE)\n-\t\t      switch (OMP_CLAUSE_LINEAR_KIND (t))\n-\t\t\t{\n-\t\t\tcase OMP_CLAUSE_LINEAR_REF:\n-\t\t\t  arg_type\n-\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP;\n-\t\t\t  break;\n-\t\t\tcase OMP_CLAUSE_LINEAR_UVAL:\n-\t\t\t  arg_type\n-\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP;\n-\t\t\t  break;\n-\t\t\tcase OMP_CLAUSE_LINEAR_VAL:\n-\t\t\tcase OMP_CLAUSE_LINEAR_DEFAULT:\n-\t\t\t  arg_type\n-\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP;\n-\t\t\t  break;\n-\t\t\tdefault:\n-\t\t\t  gcc_unreachable ();\n-\t\t\t}\n-\t\t    else\n-\t\t      arg_type = SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP;\n-\t\t    clone_info->args[argno].arg_type = arg_type;\n-\t\t    clone_info->args[argno].linear_step = tree_to_shwi (step);\n-\t\t  }\n-\t      }\n-\t    break;\n-\t  }\n-\tcase OMP_CLAUSE_UNIFORM:\n-\t  {\n-\t    tree decl = OMP_CLAUSE_DECL (t);\n-\t    int argno = tree_to_uhwi (decl);\n-\t    clone_info->args[argno].arg_type\n-\t      = SIMD_CLONE_ARG_TYPE_UNIFORM;\n-\t    break;\n-\t  }\n-\tcase OMP_CLAUSE_ALIGNED:\n-\t  {\n-\t    tree decl = OMP_CLAUSE_DECL (t);\n-\t    int argno = tree_to_uhwi (decl);\n-\t    clone_info->args[argno].alignment\n-\t      = TREE_INT_CST_LOW (OMP_CLAUSE_ALIGNED_ALIGNMENT (t));\n-\t    break;\n-\t  }\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  args.release ();\n-  return clone_info;\n-}\n-\n-/* Given a SIMD clone in NODE, calculate the characteristic data\n-   type and return the coresponding type.  The characteristic data\n-   type is computed as described in the Intel Vector ABI.  */\n-\n-static tree\n-simd_clone_compute_base_data_type (struct cgraph_node *node,\n-\t\t\t\t   struct cgraph_simd_clone *clone_info)\n-{\n-  tree type = integer_type_node;\n-  tree fndecl = node->decl;\n-\n-  /* a) For non-void function, the characteristic data type is the\n-        return type.  */\n-  if (TREE_CODE (TREE_TYPE (TREE_TYPE (fndecl))) != VOID_TYPE)\n-    type = TREE_TYPE (TREE_TYPE (fndecl));\n-\n-  /* b) If the function has any non-uniform, non-linear parameters,\n-        then the characteristic data type is the type of the first\n-        such parameter.  */\n-  else\n-    {\n-      vec<tree> map = simd_clone_vector_of_formal_parm_types (fndecl);\n-      for (unsigned int i = 0; i < clone_info->nargs; ++i)\n-\tif (clone_info->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n-\t  {\n-\t    type = map[i];\n-\t    break;\n-\t  }\n-      map.release ();\n-    }\n-\n-  /* c) If the characteristic data type determined by a) or b) above\n-        is struct, union, or class type which is pass-by-value (except\n-        for the type that maps to the built-in complex data type), the\n-        characteristic data type is int.  */\n-  if (RECORD_OR_UNION_TYPE_P (type)\n-      && !aggregate_value_p (type, NULL)\n-      && TREE_CODE (type) != COMPLEX_TYPE)\n-    return integer_type_node;\n-\n-  /* d) If none of the above three classes is applicable, the\n-        characteristic data type is int.  */\n-\n-  return type;\n-\n-  /* e) For Intel Xeon Phi native and offload compilation, if the\n-        resulting characteristic data type is 8-bit or 16-bit integer\n-        data type, the characteristic data type is int.  */\n-  /* Well, we don't handle Xeon Phi yet.  */\n-}\n-\n-static tree\n-simd_clone_mangle (struct cgraph_node *node,\n-\t\t   struct cgraph_simd_clone *clone_info)\n-{\n-  char vecsize_mangle = clone_info->vecsize_mangle;\n-  char mask = clone_info->inbranch ? 'M' : 'N';\n-  unsigned int simdlen = clone_info->simdlen;\n-  unsigned int n;\n-  pretty_printer pp;\n-\n-  gcc_assert (vecsize_mangle && simdlen);\n-\n-  pp_string (&pp, \"_ZGV\");\n-  pp_character (&pp, vecsize_mangle);\n-  pp_character (&pp, mask);\n-  pp_decimal_int (&pp, simdlen);\n-\n-  for (n = 0; n < clone_info->nargs; ++n)\n-    {\n-      struct cgraph_simd_clone_arg arg = clone_info->args[n];\n-\n-      switch (arg.arg_type)\n-\t{\n-\tcase SIMD_CLONE_ARG_TYPE_UNIFORM:\n-\t  pp_character (&pp, 'u');\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n-\t  pp_character (&pp, 'l');\n-\t  goto mangle_linear;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n-\t  pp_character (&pp, 'R');\n-\t  goto mangle_linear;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n-\t  pp_character (&pp, 'L');\n-\t  goto mangle_linear;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n-\t  pp_character (&pp, 'U');\n-\t  goto mangle_linear;\n-\tmangle_linear:\n-\t  gcc_assert (arg.linear_step != 0);\n-\t  if (arg.linear_step > 1)\n-\t    pp_unsigned_wide_integer (&pp, arg.linear_step);\n-\t  else if (arg.linear_step < 0)\n-\t    {\n-\t      pp_character (&pp, 'n');\n-\t      pp_unsigned_wide_integer (&pp, (-(unsigned HOST_WIDE_INT)\n-\t\t\t\t\t      arg.linear_step));\n-\t    }\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n-\t  pp_string (&pp, \"ls\");\n-\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n-\t  pp_string (&pp, \"Rs\");\n-\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n-\t  pp_string (&pp, \"Ls\");\n-\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n-\t  pp_string (&pp, \"Us\");\n-\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n-\t  break;\n-\tdefault:\n-\t  pp_character (&pp, 'v');\n-\t}\n-      if (arg.alignment)\n-\t{\n-\t  pp_character (&pp, 'a');\n-\t  pp_decimal_int (&pp, arg.alignment);\n-\t}\n-    }\n-\n-  pp_underscore (&pp);\n-  const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl));\n-  if (*str == '*')\n-    ++str;\n-  pp_string (&pp, str);\n-  str = pp_formatted_text (&pp);\n-\n-  /* If there already is a SIMD clone with the same mangled name, don't\n-     add another one.  This can happen e.g. for\n-     #pragma omp declare simd\n-     #pragma omp declare simd simdlen(8)\n-     int foo (int, int);\n-     if the simdlen is assumed to be 8 for the first one, etc.  */\n-  for (struct cgraph_node *clone = node->simd_clones; clone;\n-       clone = clone->simdclone->next_clone)\n-    if (strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (clone->decl)),\n-\t\tstr) == 0)\n-      return NULL_TREE;\n-\n-  return get_identifier (str);\n-}\n-\n-/* Create a simd clone of OLD_NODE and return it.  */\n-\n-static struct cgraph_node *\n-simd_clone_create (struct cgraph_node *old_node)\n-{\n-  struct cgraph_node *new_node;\n-  if (old_node->definition)\n-    {\n-      if (!old_node->has_gimple_body_p ())\n-\treturn NULL;\n-      old_node->get_body ();\n-      new_node = old_node->create_version_clone_with_body (vNULL, NULL, NULL,\n-\t\t\t\t\t\t\t   false, NULL, NULL,\n-\t\t\t\t\t\t\t   \"simdclone\");\n-    }\n-  else\n-    {\n-      tree old_decl = old_node->decl;\n-      tree new_decl = copy_node (old_node->decl);\n-      DECL_NAME (new_decl) = clone_function_name (old_decl, \"simdclone\");\n-      SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n-      SET_DECL_RTL (new_decl, NULL);\n-      DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n-      DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n-      new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n-      if (old_node->in_other_partition)\n-\tnew_node->in_other_partition = 1;\n-    }\n-  if (new_node == NULL)\n-    return new_node;\n-\n-  TREE_PUBLIC (new_node->decl) = TREE_PUBLIC (old_node->decl);\n-\n-  /* The function cgraph_function_versioning () will force the new\n-     symbol local.  Undo this, and inherit external visability from\n-     the old node.  */\n-  new_node->local.local = old_node->local.local;\n-  new_node->externally_visible = old_node->externally_visible;\n-\n-  return new_node;\n-}\n-\n-/* Adjust the return type of the given function to its appropriate\n-   vector counterpart.  Returns a simd array to be used throughout the\n-   function as a return value.  */\n-\n-static tree\n-simd_clone_adjust_return_type (struct cgraph_node *node)\n-{\n-  tree fndecl = node->decl;\n-  tree orig_rettype = TREE_TYPE (TREE_TYPE (fndecl));\n-  unsigned int veclen;\n-  tree t;\n-\n-  /* Adjust the function return type.  */\n-  if (orig_rettype == void_type_node)\n-    return NULL_TREE;\n-  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));\n-  t = TREE_TYPE (TREE_TYPE (fndecl));\n-  if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))\n-    veclen = node->simdclone->vecsize_int;\n-  else\n-    veclen = node->simdclone->vecsize_float;\n-  veclen /= GET_MODE_BITSIZE (TYPE_MODE (t));\n-  if (veclen > node->simdclone->simdlen)\n-    veclen = node->simdclone->simdlen;\n-  if (POINTER_TYPE_P (t))\n-    t = pointer_sized_int_node;\n-  if (veclen == node->simdclone->simdlen)\n-    t = build_vector_type (t, node->simdclone->simdlen);\n-  else\n-    {\n-      t = build_vector_type (t, veclen);\n-      t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);\n-    }\n-  TREE_TYPE (TREE_TYPE (fndecl)) = t;\n-  if (!node->definition)\n-    return NULL_TREE;\n-\n-  t = DECL_RESULT (fndecl);\n-  /* Adjust the DECL_RESULT.  */\n-  gcc_assert (TREE_TYPE (t) != void_type_node);\n-  TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (fndecl));\n-  relayout_decl (t);\n-\n-  tree atype = build_array_type_nelts (orig_rettype,\n-\t\t\t\t       node->simdclone->simdlen);\n-  if (veclen != node->simdclone->simdlen)\n-    return build1 (VIEW_CONVERT_EXPR, atype, t);\n-\n-  /* Set up a SIMD array to use as the return value.  */\n-  tree retval = create_tmp_var_raw (atype, \"retval\");\n-  gimple_add_tmp_var (retval);\n-  return retval;\n-}\n-\n-/* Each vector argument has a corresponding array to be used locally\n-   as part of the eventual loop.  Create such temporary array and\n-   return it.\n-\n-   PREFIX is the prefix to be used for the temporary.\n-\n-   TYPE is the inner element type.\n-\n-   SIMDLEN is the number of elements.  */\n-\n-static tree\n-create_tmp_simd_array (const char *prefix, tree type, int simdlen)\n-{\n-  tree atype = build_array_type_nelts (type, simdlen);\n-  tree avar = create_tmp_var_raw (atype, prefix);\n-  gimple_add_tmp_var (avar);\n-  return avar;\n-}\n-\n-/* Modify the function argument types to their corresponding vector\n-   counterparts if appropriate.  Also, create one array for each simd\n-   argument to be used locally when using the function arguments as\n-   part of the loop.\n-\n-   NODE is the function whose arguments are to be adjusted.\n-\n-   Returns an adjustment vector that will be filled describing how the\n-   argument types will be adjusted.  */\n-\n-static ipa_parm_adjustment_vec\n-simd_clone_adjust_argument_types (struct cgraph_node *node)\n-{\n-  vec<tree> args;\n-  ipa_parm_adjustment_vec adjustments;\n-\n-  if (node->definition)\n-    args = ipa_get_vector_of_formal_parms (node->decl);\n-  else\n-    args = simd_clone_vector_of_formal_parm_types (node->decl);\n-  adjustments.create (args.length ());\n-  unsigned i, j, veclen;\n-  struct ipa_parm_adjustment adj;\n-  struct cgraph_simd_clone *sc = node->simdclone;\n-\n-  for (i = 0; i < sc->nargs; ++i)\n-    {\n-      memset (&adj, 0, sizeof (adj));\n-      tree parm = args[i];\n-      tree parm_type = node->definition ? TREE_TYPE (parm) : parm;\n-      adj.base_index = i;\n-      adj.base = parm;\n-\n-      sc->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n-      sc->args[i].orig_type = parm_type;\n-\n-      switch (sc->args[i].arg_type)\n-\t{\n-\tdefault:\n-\t  /* No adjustment necessary for scalar arguments.  */\n-\t  adj.op = IPA_PARM_OP_COPY;\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n-\t  if (node->definition)\n-\t    sc->args[i].simd_array\n-\t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n-\t\t\t\t       TREE_TYPE (parm_type),\n-\t\t\t\t       sc->simdlen);\n-\t  adj.op = IPA_PARM_OP_COPY;\n-\t  break;\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n-\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n-\tcase SIMD_CLONE_ARG_TYPE_VECTOR:\n-\t  if (INTEGRAL_TYPE_P (parm_type) || POINTER_TYPE_P (parm_type))\n-\t    veclen = sc->vecsize_int;\n-\t  else\n-\t    veclen = sc->vecsize_float;\n-\t  veclen /= GET_MODE_BITSIZE (TYPE_MODE (parm_type));\n-\t  if (veclen > sc->simdlen)\n-\t    veclen = sc->simdlen;\n-\t  adj.arg_prefix = \"simd\";\n-\t  if (POINTER_TYPE_P (parm_type))\n-\t    adj.type = build_vector_type (pointer_sized_int_node, veclen);\n-\t  else\n-\t    adj.type = build_vector_type (parm_type, veclen);\n-\t  sc->args[i].vector_type = adj.type;\n-\t  for (j = veclen; j < sc->simdlen; j += veclen)\n-\t    {\n-\t      adjustments.safe_push (adj);\n-\t      if (j == veclen)\n-\t\t{\n-\t\t  memset (&adj, 0, sizeof (adj));\n-\t\t  adj.op = IPA_PARM_OP_NEW;\n-\t\t  adj.arg_prefix = \"simd\";\n-\t\t  adj.base_index = i;\n-\t\t  adj.type = sc->args[i].vector_type;\n-\t\t}\n-\t    }\n-\n-\t  if (node->definition)\n-\t    sc->args[i].simd_array\n-\t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n-\t\t\t\t       parm_type, sc->simdlen);\n-\t}\n-      adjustments.safe_push (adj);\n-    }\n-\n-  if (sc->inbranch)\n-    {\n-      tree base_type = simd_clone_compute_base_data_type (sc->origin, sc);\n-\n-      memset (&adj, 0, sizeof (adj));\n-      adj.op = IPA_PARM_OP_NEW;\n-      adj.arg_prefix = \"mask\";\n-\n-      adj.base_index = i;\n-      if (INTEGRAL_TYPE_P (base_type) || POINTER_TYPE_P (base_type))\n-\tveclen = sc->vecsize_int;\n-      else\n-\tveclen = sc->vecsize_float;\n-      veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n-      if (veclen > sc->simdlen)\n-\tveclen = sc->simdlen;\n-      if (sc->mask_mode != VOIDmode)\n-\tadj.type\n-\t  = lang_hooks.types.type_for_mode (sc->mask_mode, 1);\n-      else if (POINTER_TYPE_P (base_type))\n-\tadj.type = build_vector_type (pointer_sized_int_node, veclen);\n-      else\n-\tadj.type = build_vector_type (base_type, veclen);\n-      adjustments.safe_push (adj);\n-\n-      for (j = veclen; j < sc->simdlen; j += veclen)\n-\tadjustments.safe_push (adj);\n-\n-      /* We have previously allocated one extra entry for the mask.  Use\n-\t it and fill it.  */\n-      sc->nargs++;\n-      if (sc->mask_mode != VOIDmode)\n-\tbase_type = boolean_type_node;\n-      if (node->definition)\n-\t{\n-\t  sc->args[i].orig_arg\n-\t    = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL, base_type);\n-\t  if (sc->mask_mode == VOIDmode)\n-\t    sc->args[i].simd_array\n-\t      = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n-\t  else if (veclen < sc->simdlen)\n-\t    sc->args[i].simd_array\n-\t      = create_tmp_simd_array (\"mask\", adj.type, sc->simdlen / veclen);\n-\t  else\n-\t    sc->args[i].simd_array = NULL_TREE;\n-\t}\n-      sc->args[i].orig_type = base_type;\n-      sc->args[i].arg_type = SIMD_CLONE_ARG_TYPE_MASK;\n-    }\n-\n-  if (node->definition)\n-    ipa_modify_formal_parameters (node->decl, adjustments);\n-  else\n-    {\n-      tree new_arg_types = NULL_TREE, new_reversed;\n-      bool last_parm_void = false;\n-      if (args.length () > 0 && args.last () == void_type_node)\n-\tlast_parm_void = true;\n-\n-      gcc_assert (TYPE_ARG_TYPES (TREE_TYPE (node->decl)));\n-      j = adjustments.length ();\n-      for (i = 0; i < j; i++)\n-\t{\n-\t  struct ipa_parm_adjustment *adj = &adjustments[i];\n-\t  tree ptype;\n-\t  if (adj->op == IPA_PARM_OP_COPY)\n-\t    ptype = args[adj->base_index];\n-\t  else\n-\t    ptype = adj->type;\n-\t  new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n-\t}\n-      new_reversed = nreverse (new_arg_types);\n-      if (last_parm_void)\n-\t{\n-\t  if (new_reversed)\n-\t    TREE_CHAIN (new_arg_types) = void_list_node;\n-\t  else\n-\t    new_reversed = void_list_node;\n-\t}\n-\n-      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n-      TREE_TYPE (node->decl) = new_type;\n-\n-      adjustments.release ();\n-    }\n-  args.release ();\n-  return adjustments;\n-}\n-\n-/* Initialize and copy the function arguments in NODE to their\n-   corresponding local simd arrays.  Returns a fresh gimple_seq with\n-   the instruction sequence generated.  */\n-\n-static gimple_seq\n-simd_clone_init_simd_arrays (struct cgraph_node *node,\n-\t\t\t     ipa_parm_adjustment_vec adjustments)\n-{\n-  gimple_seq seq = NULL;\n-  unsigned i = 0, j = 0, k;\n-\n-  for (tree arg = DECL_ARGUMENTS (node->decl);\n-       arg;\n-       arg = DECL_CHAIN (arg), i++, j++)\n-    {\n-      if (adjustments[j].op == IPA_PARM_OP_COPY\n-\t  || POINTER_TYPE_P (TREE_TYPE (arg)))\n-\tcontinue;\n-\n-      node->simdclone->args[i].vector_arg = arg;\n-\n-      tree array = node->simdclone->args[i].simd_array;\n-      if (node->simdclone->mask_mode != VOIDmode\n-\t  && node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_MASK)\n-\t{\n-\t  if (array == NULL_TREE)\n-\t    continue;\n-\t  unsigned int l\n-\t    = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (array))));\n-\t  for (k = 0; k <= l; k++)\n-\t    {\n-\t      if (k)\n-\t\t{\n-\t\t  arg = DECL_CHAIN (arg);\n-\t\t  j++;\n-\t\t}\n-\t      tree t = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),\n-\t\t\t       array, size_int (k), NULL, NULL);\n-\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n-\t      gimplify_and_add (t, &seq);\n-\t    }\n-\t  continue;\n-\t}\n-      if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)) == node->simdclone->simdlen)\n-\t{\n-\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n-\t  tree ptr = build_fold_addr_expr (array);\n-\t  tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n-\t\t\t   build_int_cst (ptype, 0));\n-\t  t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n-\t  gimplify_and_add (t, &seq);\n-\t}\n-      else\n-\t{\n-\t  unsigned int simdlen = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg));\n-\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n-\t  for (k = 0; k < node->simdclone->simdlen; k += simdlen)\n-\t    {\n-\t      tree ptr = build_fold_addr_expr (array);\n-\t      int elemsize;\n-\t      if (k)\n-\t\t{\n-\t\t  arg = DECL_CHAIN (arg);\n-\t\t  j++;\n-\t\t}\n-\t      elemsize\n-\t\t= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg))));\n-\t      tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n-\t\t\t       build_int_cst (ptype, k * elemsize));\n-\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n-\t      gimplify_and_add (t, &seq);\n-\t    }\n-\t}\n-    }\n-  return seq;\n-}\n-\n-/* Callback info for ipa_simd_modify_stmt_ops below.  */\n-\n-struct modify_stmt_info {\n-  ipa_parm_adjustment_vec adjustments;\n-  gimple *stmt;\n-  /* True if the parent statement was modified by\n-     ipa_simd_modify_stmt_ops.  */\n-  bool modified;\n-};\n-\n-/* Callback for walk_gimple_op.\n-\n-   Adjust operands from a given statement as specified in the\n-   adjustments vector in the callback data.  */\n-\n-static tree\n-ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  struct modify_stmt_info *info = (struct modify_stmt_info *) wi->info;\n-  tree *orig_tp = tp;\n-  if (TREE_CODE (*tp) == ADDR_EXPR)\n-    tp = &TREE_OPERAND (*tp, 0);\n-  struct ipa_parm_adjustment *cand = NULL;\n-  if (TREE_CODE (*tp) == PARM_DECL)\n-    cand = ipa_get_adjustment_candidate (&tp, NULL, info->adjustments, true);\n-  else\n-    {\n-      if (TYPE_P (*tp))\n-\t*walk_subtrees = 0;\n-    }\n-\n-  tree repl = NULL_TREE;\n-  if (cand)\n-    repl = unshare_expr (cand->new_decl);\n-  else\n-    {\n-      if (tp != orig_tp)\n-\t{\n-\t  *walk_subtrees = 0;\n-\t  bool modified = info->modified;\n-\t  info->modified = false;\n-\t  walk_tree (tp, ipa_simd_modify_stmt_ops, wi, wi->pset);\n-\t  if (!info->modified)\n-\t    {\n-\t      info->modified = modified;\n-\t      return NULL_TREE;\n-\t    }\n-\t  info->modified = modified;\n-\t  repl = *tp;\n-\t}\n-      else\n-\treturn NULL_TREE;\n-    }\n-\n-  if (tp != orig_tp)\n-    {\n-      repl = build_fold_addr_expr (repl);\n-      gimple *stmt;\n-      if (is_gimple_debug (info->stmt))\n-\t{\n-\t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n-\t  stmt = gimple_build_debug_source_bind (vexpr, repl, NULL);\n-\t  DECL_ARTIFICIAL (vexpr) = 1;\n-\t  TREE_TYPE (vexpr) = TREE_TYPE (repl);\n-\t  DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (repl));\n-\t  repl = vexpr;\n-\t}\n-      else\n-\t{\n-\t  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);\n-\t  repl = gimple_assign_lhs (stmt);\n-\t}\n-      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-      *orig_tp = repl;\n-    }\n-  else if (!useless_type_conversion_p (TREE_TYPE (*tp), TREE_TYPE (repl)))\n-    {\n-      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*tp), repl);\n-      *tp = vce;\n-    }\n-  else\n-    *tp = repl;\n-\n-  info->modified = true;\n-  return NULL_TREE;\n-}\n-\n-/* Traverse the function body and perform all modifications as\n-   described in ADJUSTMENTS.  At function return, ADJUSTMENTS will be\n-   modified such that the replacement/reduction value will now be an\n-   offset into the corresponding simd_array.\n-\n-   This function will replace all function argument uses with their\n-   corresponding simd array elements, and ajust the return values\n-   accordingly.  */\n-\n-static void\n-ipa_simd_modify_function_body (struct cgraph_node *node,\n-\t\t\t       ipa_parm_adjustment_vec adjustments,\n-\t\t\t       tree retval_array, tree iter)\n-{\n-  basic_block bb;\n-  unsigned int i, j, l;\n-\n-  /* Re-use the adjustments array, but this time use it to replace\n-     every function argument use to an offset into the corresponding\n-     simd_array.  */\n-  for (i = 0, j = 0; i < node->simdclone->nargs; ++i, ++j)\n-    {\n-      if (!node->simdclone->args[i].vector_arg)\n-\tcontinue;\n-\n-      tree basetype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n-      tree vectype = TREE_TYPE (node->simdclone->args[i].vector_arg);\n-      adjustments[j].new_decl\n-\t= build4 (ARRAY_REF,\n-\t\t  basetype,\n-\t\t  node->simdclone->args[i].simd_array,\n-\t\t  iter,\n-\t\t  NULL_TREE, NULL_TREE);\n-      if (adjustments[j].op == IPA_PARM_OP_NONE\n-\t  && TYPE_VECTOR_SUBPARTS (vectype) < node->simdclone->simdlen)\n-\tj += node->simdclone->simdlen / TYPE_VECTOR_SUBPARTS (vectype) - 1;\n-    }\n-\n-  l = adjustments.length ();\n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree name = ssa_name (i);\n-      if (name\n-\t  && SSA_NAME_VAR (name)\n-\t  && TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL)\n-\t{\n-\t  for (j = 0; j < l; j++)\n-\t    if (SSA_NAME_VAR (name) == adjustments[j].base\n-\t\t&& adjustments[j].new_decl)\n-\t      {\n-\t\ttree base_var;\n-\t\tif (adjustments[j].new_ssa_base == NULL_TREE)\n-\t\t  {\n-\t\t    base_var\n-\t\t      = copy_var_decl (adjustments[j].base,\n-\t\t\t\t       DECL_NAME (adjustments[j].base),\n-\t\t\t\t       TREE_TYPE (adjustments[j].base));\n-\t\t    adjustments[j].new_ssa_base = base_var;\n-\t\t  }\n-\t\telse\n-\t\t  base_var = adjustments[j].new_ssa_base;\n-\t\tif (SSA_NAME_IS_DEFAULT_DEF (name))\n-\t\t  {\n-\t\t    bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\t\t    gimple_stmt_iterator gsi = gsi_after_labels (bb);\n-\t\t    tree new_decl = unshare_expr (adjustments[j].new_decl);\n-\t\t    set_ssa_default_def (cfun, adjustments[j].base, NULL_TREE);\n-\t\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n-\t\t    SSA_NAME_IS_DEFAULT_DEF (name) = 0;\n-\t\t    gimple *stmt = gimple_build_assign (name, new_decl);\n-\t\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t\t  }\n-\t\telse\n-\t\t  SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n-\t      }\n-\t}\n-    }\n-\n-  struct modify_stmt_info info;\n-  info.adjustments = adjustments;\n-\n-  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n-    {\n-      gimple_stmt_iterator gsi;\n-\n-      gsi = gsi_start_bb (bb);\n-      while (!gsi_end_p (gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  info.stmt = stmt;\n-\t  struct walk_stmt_info wi;\n-\n-\t  memset (&wi, 0, sizeof (wi));\n-\t  info.modified = false;\n-\t  wi.info = &info;\n-\t  walk_gimple_op (stmt, ipa_simd_modify_stmt_ops, &wi);\n-\n-\t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n-\t    {\n-\t      tree retval = gimple_return_retval (return_stmt);\n-\t      if (!retval)\n-\t\t{\n-\t\t  gsi_remove (&gsi, true);\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Replace `return foo' with `retval_array[iter] = foo'.  */\n-\t      tree ref = build4 (ARRAY_REF, TREE_TYPE (retval),\n-\t\t\t\t retval_array, iter, NULL, NULL);\n-\t      stmt = gimple_build_assign (ref, retval);\n-\t      gsi_replace (&gsi, stmt, true);\n-\t      info.modified = true;\n-\t    }\n-\n-\t  if (info.modified)\n-\t    {\n-\t      update_stmt (stmt);\n-\t      if (maybe_clean_eh_stmt (stmt))\n-\t\tgimple_purge_dead_eh_edges (gimple_bb (stmt));\n-\t    }\n-\t  gsi_next (&gsi);\n-\t}\n-    }\n-}\n-\n-/* Helper function of simd_clone_adjust, return linear step addend\n-   of Ith argument.  */\n-\n-static tree\n-simd_clone_linear_addend (struct cgraph_node *node, unsigned int i,\n-\t\t\t  tree addtype, basic_block entry_bb)\n-{\n-  tree ptype = NULL_TREE;\n-  switch (node->simdclone->args[i].arg_type)\n-    {\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n-      return build_int_cst (addtype, node->simdclone->args[i].linear_step);\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n-      ptype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n-      break;\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n-    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n-      ptype = TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  unsigned int idx = node->simdclone->args[i].linear_step;\n-  tree arg = node->simdclone->args[idx].orig_arg;\n-  gcc_assert (is_gimple_reg_type (TREE_TYPE (arg)));\n-  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n-  gimple *g;\n-  tree ret;\n-  if (is_gimple_reg (arg))\n-    ret = get_or_create_ssa_default_def (cfun, arg);\n-  else\n-    {\n-      g = gimple_build_assign (make_ssa_name (TREE_TYPE (arg)), arg);\n-      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-      ret = gimple_assign_lhs (g);\n-    }\n-  if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n-    {\n-      g = gimple_build_assign (make_ssa_name (TREE_TYPE (TREE_TYPE (arg))),\n-\t\t\t       build_simple_mem_ref (ret));\n-      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-      ret = gimple_assign_lhs (g);\n-    }\n-  if (!useless_type_conversion_p (addtype, TREE_TYPE (ret)))\n-    {\n-      g = gimple_build_assign (make_ssa_name (addtype), NOP_EXPR, ret);\n-      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-      ret = gimple_assign_lhs (g);\n-    }\n-  if (POINTER_TYPE_P (ptype))\n-    {\n-      tree size = TYPE_SIZE_UNIT (TREE_TYPE (ptype));\n-      if (size && TREE_CODE (size) == INTEGER_CST)\n-\t{\n-\t  g = gimple_build_assign (make_ssa_name (addtype), MULT_EXPR,\n-\t\t\t\t   ret, fold_convert (addtype, size));\n-\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\t  ret = gimple_assign_lhs (g);\n-\t}\n-    }\n-  return ret;\n-}\n-\n-/* Adjust the argument types in NODE to their appropriate vector\n-   counterparts.  */\n-\n-static void\n-simd_clone_adjust (struct cgraph_node *node)\n-{\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\n-  targetm.simd_clone.adjust (node);\n-\n-  tree retval = simd_clone_adjust_return_type (node);\n-  ipa_parm_adjustment_vec adjustments\n-    = simd_clone_adjust_argument_types (node);\n-\n-  push_gimplify_context ();\n-\n-  gimple_seq seq = simd_clone_init_simd_arrays (node, adjustments);\n-\n-  /* Adjust all uses of vector arguments accordingly.  Adjust all\n-     return values accordingly.  */\n-  tree iter = create_tmp_var (unsigned_type_node, \"iter\");\n-  tree iter1 = make_ssa_name (iter);\n-  tree iter2 = make_ssa_name (iter);\n-  ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n-\n-  /* Initialize the iteration variable.  */\n-  basic_block entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  basic_block body_bb = split_block_after_labels (entry_bb)->dest;\n-  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n-  /* Insert the SIMD array and iv initialization at function\n-     entry.  */\n-  gsi_insert_seq_before (&gsi, seq, GSI_NEW_STMT);\n-\n-  pop_gimplify_context (NULL);\n-\n-  /* Create a new BB right before the original exit BB, to hold the\n-     iteration increment and the condition/branch.  */\n-  basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n-  basic_block incr_bb = create_empty_bb (orig_exit);\n-  add_bb_to_loop (incr_bb, body_bb->loop_father);\n-  /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n-     flag.  Set it now to be a FALLTHRU_EDGE.  */\n-  gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);\n-  EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;\n-  for (unsigned i = 0;\n-       i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)\n-    {\n-      edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n-      redirect_edge_succ (e, incr_bb);\n-    }\n-  edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-  e->probability = REG_BR_PROB_BASE;\n-  gsi = gsi_last_bb (incr_bb);\n-  gimple *g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n-\t\t\t\t   build_int_cst (unsigned_type_node, 1));\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\n-  /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n-  struct loop *loop = alloc_loop ();\n-  cfun->has_force_vectorize_loops = true;\n-  loop->safelen = node->simdclone->simdlen;\n-  loop->force_vectorize = true;\n-  loop->header = body_bb;\n-\n-  /* Branch around the body if the mask applies.  */\n-  if (node->simdclone->inbranch)\n-    {\n-      gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n-      tree mask_array\n-\t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n-      tree mask;\n-      if (node->simdclone->mask_mode != VOIDmode)\n-\t{\n-\t  tree shift_cnt;\n-\t  if (mask_array == NULL_TREE)\n-\t    {\n-\t      tree arg = node->simdclone->args[node->simdclone->nargs\n-\t\t\t\t\t       - 1].vector_arg;\n-\t      mask = get_or_create_ssa_default_def (cfun, arg);\n-\t      shift_cnt = iter1;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree maskt = TREE_TYPE (mask_array);\n-\t      int c = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (maskt)));\n-\t      c = node->simdclone->simdlen / (c + 1);\n-\t      int s = exact_log2 (c);\n-\t      gcc_assert (s > 0);\n-\t      c--;\n-\t      tree idx = make_ssa_name (TREE_TYPE (iter1));\n-\t      g = gimple_build_assign (idx, RSHIFT_EXPR, iter1,\n-\t\t\t\t       build_int_cst (NULL_TREE, s));\n-\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t      mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n-\t      tree aref = build4 (ARRAY_REF,\n-\t\t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n-\t\t\t\t  mask_array, idx, NULL, NULL);\n-\t      g = gimple_build_assign (mask, aref);\n-\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t      shift_cnt = make_ssa_name (TREE_TYPE (iter1));\n-\t      g = gimple_build_assign (shift_cnt, BIT_AND_EXPR, iter1,\n-\t\t\t\t       build_int_cst (TREE_TYPE (iter1), c));\n-\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t    }\n-\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n-\t\t\t\t   RSHIFT_EXPR, mask, shift_cnt);\n-\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t  mask = gimple_assign_lhs (g);\n-\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n-\t\t\t\t   BIT_AND_EXPR, mask,\n-\t\t\t\t   build_int_cst (TREE_TYPE (mask), 1));\n-\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t  mask = gimple_assign_lhs (g);\n-\t}\n-      else\n-\t{\n-\t  mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n-\t  tree aref = build4 (ARRAY_REF,\n-\t\t\t      TREE_TYPE (TREE_TYPE (mask_array)),\n-\t\t\t      mask_array, iter1, NULL, NULL);\n-\t  g = gimple_build_assign (mask, aref);\n-\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t  int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (aref)));\n-\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (aref)))\n-\t    {\n-\t      aref = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t     build_nonstandard_integer_type (bitsize, 0),\n-\t\t\t\t\t\t\t     mask);\n-\t      mask = make_ssa_name (TREE_TYPE (aref));\n-\t      g = gimple_build_assign (mask, aref);\n-\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\t    }\n-\t}\n-\n-      g = gimple_build_cond (EQ_EXPR, mask, build_zero_cst (TREE_TYPE (mask)),\n-\t\t\t     NULL, NULL);\n-      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-      make_edge (loop->header, incr_bb, EDGE_TRUE_VALUE);\n-      FALLTHRU_EDGE (loop->header)->flags = EDGE_FALSE_VALUE;\n-    }\n-\n-  /* Generate the condition.  */\n-  g = gimple_build_cond (LT_EXPR,\n-\t\t\t iter2,\n-\t\t\t build_int_cst (unsigned_type_node,\n-\t\t\t\t\tnode->simdclone->simdlen),\n-\t\t\t NULL, NULL);\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-  e = split_block (incr_bb, gsi_stmt (gsi));\n-  basic_block latch_bb = e->dest;\n-  basic_block new_exit_bb;\n-  new_exit_bb = split_block_after_labels (latch_bb)->dest;\n-  loop->latch = latch_bb;\n-\n-  redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n-\n-  make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n-  /* The successor of incr_bb is already pointing to latch_bb; just\n-     change the flags.\n-     make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n-  FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n-\n-  gphi *phi = create_phi_node (iter1, body_bb);\n-  edge preheader_edge = find_edge (entry_bb, body_bb);\n-  edge latch_edge = single_succ_edge (latch_bb);\n-  add_phi_arg (phi, build_zero_cst (unsigned_type_node), preheader_edge,\n-\t       UNKNOWN_LOCATION);\n-  add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\n-  /* Generate the new return.  */\n-  gsi = gsi_last_bb (new_exit_bb);\n-  if (retval\n-      && TREE_CODE (retval) == VIEW_CONVERT_EXPR\n-      && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n-    retval = TREE_OPERAND (retval, 0);\n-  else if (retval)\n-    {\n-      retval = build1 (VIEW_CONVERT_EXPR,\n-\t\t       TREE_TYPE (TREE_TYPE (node->decl)),\n-\t\t       retval);\n-      retval = force_gimple_operand_gsi (&gsi, retval, true, NULL,\n-\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n-    }\n-  g = gimple_build_return (retval);\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\n-  /* Handle aligned clauses by replacing default defs of the aligned\n-     uniform args with __builtin_assume_aligned (arg_N(D), alignment)\n-     lhs.  Handle linear by adding PHIs.  */\n-  for (unsigned i = 0; i < node->simdclone->nargs; i++)\n-    if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n-\t&& (TREE_ADDRESSABLE (node->simdclone->args[i].orig_arg)\n-\t    || !is_gimple_reg_type\n-\t\t\t(TREE_TYPE (node->simdclone->args[i].orig_arg))))\n-      {\n-\ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\tif (is_gimple_reg_type (TREE_TYPE (orig_arg)))\n-\t  iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n-\telse\n-\t  {\n-\t    iter1 = create_tmp_var_raw (TREE_TYPE (orig_arg));\n-\t    gimple_add_tmp_var (iter1);\n-\t  }\n-\tgsi = gsi_after_labels (entry_bb);\n-\tg = gimple_build_assign (iter1, orig_arg);\n-\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-\tgsi = gsi_after_labels (body_bb);\n-\tg = gimple_build_assign (orig_arg, iter1);\n-\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-      }\n-    else if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n-\t     && DECL_BY_REFERENCE (node->simdclone->args[i].orig_arg)\n-\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n-\t\t== REFERENCE_TYPE\n-\t     && TREE_ADDRESSABLE\n-\t\t  (TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg))))\n-      {\n-\ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\ttree def = ssa_default_def (cfun, orig_arg);\n-\tif (def && !has_zero_uses (def))\n-\t  {\n-\t    iter1 = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (orig_arg)));\n-\t    gimple_add_tmp_var (iter1);\n-\t    gsi = gsi_after_labels (entry_bb);\n-\t    g = gimple_build_assign (iter1, build_simple_mem_ref (def));\n-\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-\t    gsi = gsi_after_labels (body_bb);\n-\t    g = gimple_build_assign (build_simple_mem_ref (def), iter1);\n-\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-\t  }\n-      }\n-    else if (node->simdclone->args[i].alignment\n-\t     && node->simdclone->args[i].arg_type\n-\t\t== SIMD_CLONE_ARG_TYPE_UNIFORM\n-\t     && (node->simdclone->args[i].alignment\n-\t\t & (node->simdclone->args[i].alignment - 1)) == 0\n-\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n-\t\t== POINTER_TYPE)\n-      {\n-\tunsigned int alignment = node->simdclone->args[i].alignment;\n-\ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\ttree def = ssa_default_def (cfun, orig_arg);\n-\tif (def && !has_zero_uses (def))\n-\t  {\n-\t    tree fn = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);\n-\t    gimple_seq seq = NULL;\n-\t    bool need_cvt = false;\n-\t    gcall *call\n-\t      = gimple_build_call (fn, 2, def, size_int (alignment));\n-\t    g = call;\n-\t    if (!useless_type_conversion_p (TREE_TYPE (orig_arg),\n-\t\t\t\t\t    ptr_type_node))\n-\t      need_cvt = true;\n-\t    tree t = make_ssa_name (need_cvt ? ptr_type_node : orig_arg);\n-\t    gimple_call_set_lhs (g, t);\n-\t    gimple_seq_add_stmt_without_update (&seq, g);\n-\t    if (need_cvt)\n-\t      {\n-\t\tt = make_ssa_name (orig_arg);\n-\t\tg = gimple_build_assign (t, NOP_EXPR, gimple_call_lhs (g));\n-\t\tgimple_seq_add_stmt_without_update (&seq, g);\n-\t      }\n-\t    gsi_insert_seq_on_edge_immediate\n-\t      (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n-\n-\t    entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\t    int freq = compute_call_stmt_bb_frequency (current_function_decl,\n-\t\t\t\t\t\t       entry_bb);\n-\t    node->create_edge (cgraph_node::get_create (fn),\n-\t\t\t       call, entry_bb->count, freq);\n-\n-\t    imm_use_iterator iter;\n-\t    use_operand_p use_p;\n-\t    gimple *use_stmt;\n-\t    tree repl = gimple_get_lhs (g);\n-\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n-\t      if (is_gimple_debug (use_stmt) || use_stmt == call)\n-\t\tcontinue;\n-\t      else\n-\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t  SET_USE (use_p, repl);\n-\t  }\n-      }\n-    else if ((node->simdclone->args[i].arg_type\n-\t      == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n-\t     || (node->simdclone->args[i].arg_type\n-\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP)\n-\t     || (node->simdclone->args[i].arg_type\n-\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP)\n-\t     || (node->simdclone->args[i].arg_type\n-\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP))\n-      {\n-\ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\tgcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n-\t\t    || POINTER_TYPE_P (TREE_TYPE (orig_arg)));\n-\ttree def = NULL_TREE;\n-\tif (TREE_ADDRESSABLE (orig_arg))\n-\t  {\n-\t    def = make_ssa_name (TREE_TYPE (orig_arg));\n-\t    iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n-\t    iter2 = make_ssa_name (TREE_TYPE (orig_arg));\n-\t    gsi = gsi_after_labels (entry_bb);\n-\t    g = gimple_build_assign (def, orig_arg);\n-\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-\t  }\n-\telse\n-\t  {\n-\t    def = ssa_default_def (cfun, orig_arg);\n-\t    if (!def || has_zero_uses (def))\n-\t      def = NULL_TREE;\n-\t    else\n-\t      {\n-\t\titer1 = make_ssa_name (orig_arg);\n-\t\titer2 = make_ssa_name (orig_arg);\n-\t      }\n-\t  }\n-\tif (def)\n-\t  {\n-\t    phi = create_phi_node (iter1, body_bb);\n-\t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n-\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n-\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n-\t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n-\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n-\t\t\t\t\t\t    entry_bb);\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\n-\t    imm_use_iterator iter;\n-\t    use_operand_p use_p;\n-\t    gimple *use_stmt;\n-\t    if (TREE_ADDRESSABLE (orig_arg))\n-\t      {\n-\t\tgsi = gsi_after_labels (body_bb);\n-\t\tg = gimple_build_assign (orig_arg, iter1);\n-\t\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-\t      }\n-\t    else\n-\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n-\t\tif (use_stmt == phi)\n-\t\t  continue;\n-\t\telse\n-\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t    SET_USE (use_p, iter1);\n-\t  }\n-      }\n-    else if (node->simdclone->args[i].arg_type\n-\t     == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP\n-\t     || (node->simdclone->args[i].arg_type\n-\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP))\n-      {\n-\ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\ttree def = ssa_default_def (cfun, orig_arg);\n-\tgcc_assert (!TREE_ADDRESSABLE (orig_arg)\n-\t\t    && TREE_CODE (TREE_TYPE (orig_arg)) == REFERENCE_TYPE);\n-\tif (def && !has_zero_uses (def))\n-\t  {\n-\t    tree rtype = TREE_TYPE (TREE_TYPE (orig_arg));\n-\t    iter1 = make_ssa_name (orig_arg);\n-\t    iter2 = make_ssa_name (orig_arg);\n-\t    tree iter3 = make_ssa_name (rtype);\n-\t    tree iter4 = make_ssa_name (rtype);\n-\t    tree iter5 = make_ssa_name (rtype);\n-\t    gsi = gsi_after_labels (entry_bb);\n-\t    gimple *load\n-\t      = gimple_build_assign (iter3, build_simple_mem_ref (def));\n-\t    gsi_insert_before (&gsi, load, GSI_NEW_STMT);\n-\n-\t    tree array = node->simdclone->args[i].simd_array;\n-\t    TREE_ADDRESSABLE (array) = 1;\n-\t    tree ptr = build_fold_addr_expr (array);\n-\t    phi = create_phi_node (iter1, body_bb);\n-\t    add_phi_arg (phi, ptr, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\t    g = gimple_build_assign (iter2, POINTER_PLUS_EXPR, iter1,\n-\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (iter3)));\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\n-\t    phi = create_phi_node (iter4, body_bb);\n-\t    add_phi_arg (phi, iter3, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter5, latch_edge, UNKNOWN_LOCATION);\n-\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n-\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n-\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n-\t\t\t   ? TREE_TYPE (iter3) : sizetype;\n-\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n-\t\t\t\t\t\t    entry_bb);\n-\t    g = gimple_build_assign (iter5, code, iter4, addcst);\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\n-\t    g = gimple_build_assign (build_simple_mem_ref (iter1), iter4);\n-\t    gsi = gsi_after_labels (body_bb);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\n-\t    imm_use_iterator iter;\n-\t    use_operand_p use_p;\n-\t    gimple *use_stmt;\n-\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n-\t      if (use_stmt == load)\n-\t\tcontinue;\n-\t      else\n-\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t  SET_USE (use_p, iter1);\n-\n-\t    if (!TYPE_READONLY (rtype))\n-\t      {\n-\t\ttree v = make_ssa_name (rtype);\n-\t\ttree aref = build4 (ARRAY_REF, rtype, array,\n-\t\t\t\t    size_zero_node, NULL_TREE,\n-\t\t\t\t    NULL_TREE);\n-\t\tgsi = gsi_after_labels (new_exit_bb);\n-\t\tg = gimple_build_assign (v, aref);\n-\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\t\tg = gimple_build_assign (build_simple_mem_ref (def), v);\n-\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-\t      }\n-\t  }\n-      }\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  add_loop (loop, loop->header->loop_father);\n-  update_ssa (TODO_update_ssa);\n-\n-  pop_cfun ();\n-}\n-\n-/* If the function in NODE is tagged as an elemental SIMD function,\n-   create the appropriate SIMD clones.  */\n-\n-static void\n-expand_simd_clones (struct cgraph_node *node)\n-{\n-  tree attr = lookup_attribute (\"omp declare simd\",\n-\t\t\t\tDECL_ATTRIBUTES (node->decl));\n-  if (attr == NULL_TREE\n-      || node->global.inlined_to\n-      || lookup_attribute (\"noclone\", DECL_ATTRIBUTES (node->decl)))\n-    return;\n-\n-  /* Ignore\n-     #pragma omp declare simd\n-     extern int foo ();\n-     in C, there we don't know the argument types at all.  */\n-  if (!node->definition\n-      && TYPE_ARG_TYPES (TREE_TYPE (node->decl)) == NULL_TREE)\n-    return;\n-\n-  /* Call this before creating clone_info, as it might ggc_collect.  */\n-  if (node->definition && node->has_gimple_body_p ())\n-    node->get_body ();\n-\n-  do\n-    {\n-      /* Start with parsing the \"omp declare simd\" attribute(s).  */\n-      bool inbranch_clause_specified;\n-      struct cgraph_simd_clone *clone_info\n-\t= simd_clone_clauses_extract (node, TREE_VALUE (attr),\n-\t\t\t\t      &inbranch_clause_specified);\n-      if (clone_info == NULL)\n-\tcontinue;\n-\n-      int orig_simdlen = clone_info->simdlen;\n-      tree base_type = simd_clone_compute_base_data_type (node, clone_info);\n-      /* The target can return 0 (no simd clones should be created),\n-\t 1 (just one ISA of simd clones should be created) or higher\n-\t count of ISA variants.  In that case, clone_info is initialized\n-\t for the first ISA variant.  */\n-      int count\n-\t= targetm.simd_clone.compute_vecsize_and_simdlen (node, clone_info,\n-\t\t\t\t\t\t\t  base_type, 0);\n-      if (count == 0)\n-\tcontinue;\n-\n-      /* Loop over all COUNT ISA variants, and if !INBRANCH_CLAUSE_SPECIFIED,\n-\t also create one inbranch and one !inbranch clone of it.  */\n-      for (int i = 0; i < count * 2; i++)\n-\t{\n-\t  struct cgraph_simd_clone *clone = clone_info;\n-\t  if (inbranch_clause_specified && (i & 1) != 0)\n-\t    continue;\n-\n-\t  if (i != 0)\n-\t    {\n-\t      clone = simd_clone_struct_alloc (clone_info->nargs\n-\t\t\t\t\t       + ((i & 1) != 0));\n-\t      simd_clone_struct_copy (clone, clone_info);\n-\t      /* Undo changes targetm.simd_clone.compute_vecsize_and_simdlen\n-\t\t and simd_clone_adjust_argument_types did to the first\n-\t\t clone's info.  */\n-\t      clone->nargs -= clone_info->inbranch;\n-\t      clone->simdlen = orig_simdlen;\n-\t      /* And call the target hook again to get the right ISA.  */\n-\t      targetm.simd_clone.compute_vecsize_and_simdlen (node, clone,\n-\t\t\t\t\t\t\t      base_type,\n-\t\t\t\t\t\t\t      i / 2);\n-\t      if ((i & 1) != 0)\n-\t\tclone->inbranch = 1;\n-\t    }\n-\n-\t  /* simd_clone_mangle might fail if such a clone has been created\n-\t     already.  */\n-\t  tree id = simd_clone_mangle (node, clone);\n-\t  if (id == NULL_TREE)\n-\t    continue;\n-\n-\t  /* Only when we are sure we want to create the clone actually\n-\t     clone the function (or definitions) or create another\n-\t     extern FUNCTION_DECL (for prototypes without definitions).  */\n-\t  struct cgraph_node *n = simd_clone_create (node);\n-\t  if (n == NULL)\n-\t    continue;\n-\n-\t  n->simdclone = clone;\n-\t  clone->origin = node;\n-\t  clone->next_clone = NULL;\n-\t  if (node->simd_clones == NULL)\n-\t    {\n-\t      clone->prev_clone = n;\n-\t      node->simd_clones = n;\n-\t    }\n-\t  else\n-\t    {\n-\t      clone->prev_clone = node->simd_clones->simdclone->prev_clone;\n-\t      clone->prev_clone->simdclone->next_clone = n;\n-\t      node->simd_clones->simdclone->prev_clone = n;\n-\t    }\n-\t  symtab->change_decl_assembler_name (n->decl, id);\n-\t  /* And finally adjust the return type, parameters and for\n-\t     definitions also function body.  */\n-\t  if (node->definition)\n-\t    simd_clone_adjust (n);\n-\t  else\n-\t    {\n-\t      simd_clone_adjust_return_type (n);\n-\t      simd_clone_adjust_argument_types (n);\n-\t    }\n-\t}\n-    }\n-  while ((attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr))));\n-}\n-\n-/* Entry point for IPA simd clone creation pass.  */\n-\n-static unsigned int\n-ipa_omp_simd_clone (void)\n-{\n-  struct cgraph_node *node;\n-  FOR_EACH_FUNCTION (node)\n-    expand_simd_clones (node);\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_omp_simd_clone =\n-{\n-  SIMPLE_IPA_PASS,\t\t/* type */\n-  \"simdclone\",\t\t\t/* name */\n-  OPTGROUP_NONE,\t\t/* optinfo_flags */\n-  TV_NONE,\t\t\t/* tv_id */\n-  ( PROP_ssa | PROP_cfg ),\t/* properties_required */\n-  0,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t/* todo_flags_finish */\n-};\n-\n-class pass_omp_simd_clone : public simple_ipa_opt_pass\n-{\n-public:\n-  pass_omp_simd_clone(gcc::context *ctxt)\n-    : simple_ipa_opt_pass(pass_data_omp_simd_clone, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *);\n-  virtual unsigned int execute (function *) { return ipa_omp_simd_clone (); }\n-};\n-\n-bool\n-pass_omp_simd_clone::gate (function *)\n-{\n-  return targetm.simd_clone.compute_vecsize_and_simdlen != NULL;\n-}\n-\n-} // anon namespace\n-\n-simple_ipa_opt_pass *\n-make_pass_omp_simd_clone (gcc::context *ctxt)\n-{\n-  return new pass_omp_simd_clone (ctxt);\n-}\n-\n /* Helper function for omp_finish_file routine.  Takes decls from V_DECLS and\n    adds their addresses and sizes to constructor-vector V_CTOR.  */\n static void"}, {"sha": "fa6ffecb4c280c7c4e1b4f26008ef4eb80ea6a86", "filename": "gcc/omp-simd-clone.c", "status": "added", "additions": 1654, "deletions": 0, "changes": 1654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cbb674776db42617d6f66487ff4074ee7862ba/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=60cbb674776db42617d6f66487ff4074ee7862ba", "patch": "@@ -0,0 +1,1654 @@\n+/* OMP constructs' SIMD clone supporting code.\n+\n+Copyright (C) 2005-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"cfghooks.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"cgraph.h\"\n+#include \"pretty-print.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"stor-layout.h\"\n+#include \"cfganal.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimplify-me.h\"\n+#include \"gimple-walk.h\"\n+#include \"langhooks.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"tree-dfa.h\"\n+#include \"cfgloop.h\"\n+#include \"symbol-summary.h\"\n+#include \"ipa-prop.h\"\n+#include \"tree-eh.h\"\n+\n+\n+/* Allocate a fresh `simd_clone' and return it.  NARGS is the number\n+   of arguments to reserve space for.  */\n+\n+static struct cgraph_simd_clone *\n+simd_clone_struct_alloc (int nargs)\n+{\n+  struct cgraph_simd_clone *clone_info;\n+  size_t len = (sizeof (struct cgraph_simd_clone)\n+\t\t+ nargs * sizeof (struct cgraph_simd_clone_arg));\n+  clone_info = (struct cgraph_simd_clone *)\n+\t       ggc_internal_cleared_alloc (len);\n+  return clone_info;\n+}\n+\n+/* Make a copy of the `struct cgraph_simd_clone' in FROM to TO.  */\n+\n+static inline void\n+simd_clone_struct_copy (struct cgraph_simd_clone *to,\n+\t\t\tstruct cgraph_simd_clone *from)\n+{\n+  memcpy (to, from, (sizeof (struct cgraph_simd_clone)\n+\t\t     + ((from->nargs - from->inbranch)\n+\t\t\t* sizeof (struct cgraph_simd_clone_arg))));\n+}\n+\n+/* Return vector of parameter types of function FNDECL.  This uses\n+   TYPE_ARG_TYPES if available, otherwise falls back to types of\n+   DECL_ARGUMENTS types.  */\n+\n+static vec<tree>\n+simd_clone_vector_of_formal_parm_types (tree fndecl)\n+{\n+  if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n+    return ipa_get_vector_of_formal_parm_types (TREE_TYPE (fndecl));\n+  vec<tree> args = ipa_get_vector_of_formal_parms (fndecl);\n+  unsigned int i;\n+  tree arg;\n+  FOR_EACH_VEC_ELT (args, i, arg)\n+    args[i] = TREE_TYPE (args[i]);\n+  return args;\n+}\n+\n+/* Given a simd function in NODE, extract the simd specific\n+   information from the OMP clauses passed in CLAUSES, and return\n+   the struct cgraph_simd_clone * if it should be cloned.  *INBRANCH_SPECIFIED\n+   is set to TRUE if the `inbranch' or `notinbranch' clause specified,\n+   otherwise set to FALSE.  */\n+\n+static struct cgraph_simd_clone *\n+simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n+\t\t\t    bool *inbranch_specified)\n+{\n+  vec<tree> args = simd_clone_vector_of_formal_parm_types (node->decl);\n+  tree t;\n+  int n;\n+  *inbranch_specified = false;\n+\n+  n = args.length ();\n+  if (n > 0 && args.last () == void_type_node)\n+    n--;\n+\n+  /* To distinguish from an OpenMP simd clone, Cilk Plus functions to\n+     be cloned have a distinctive artificial label in addition to \"omp\n+     declare simd\".  */\n+  bool cilk_clone\n+    = (flag_cilkplus\n+       && lookup_attribute (\"cilk simd function\",\n+\t\t\t    DECL_ATTRIBUTES (node->decl)));\n+\n+  /* Allocate one more than needed just in case this is an in-branch\n+     clone which will require a mask argument.  */\n+  struct cgraph_simd_clone *clone_info = simd_clone_struct_alloc (n + 1);\n+  clone_info->nargs = n;\n+  clone_info->cilk_elemental = cilk_clone;\n+\n+  if (!clauses)\n+    {\n+      args.release ();\n+      return clone_info;\n+    }\n+  clauses = TREE_VALUE (clauses);\n+  if (!clauses || TREE_CODE (clauses) != OMP_CLAUSE)\n+    return clone_info;\n+\n+  for (t = clauses; t; t = OMP_CLAUSE_CHAIN (t))\n+    {\n+      switch (OMP_CLAUSE_CODE (t))\n+\t{\n+\tcase OMP_CLAUSE_INBRANCH:\n+\t  clone_info->inbranch = 1;\n+\t  *inbranch_specified = true;\n+\t  break;\n+\tcase OMP_CLAUSE_NOTINBRANCH:\n+\t  clone_info->inbranch = 0;\n+\t  *inbranch_specified = true;\n+\t  break;\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\t  clone_info->simdlen\n+\t    = TREE_INT_CST_LOW (OMP_CLAUSE_SIMDLEN_EXPR (t));\n+\t  break;\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    tree step = OMP_CLAUSE_LINEAR_STEP (t);\n+\t    int argno = TREE_INT_CST_LOW (decl);\n+\t    if (OMP_CLAUSE_LINEAR_VARIABLE_STRIDE (t))\n+\t      {\n+\t\tenum cgraph_simd_clone_arg_type arg_type;\n+\t\tif (TREE_CODE (args[argno]) == REFERENCE_TYPE)\n+\t\t  switch (OMP_CLAUSE_LINEAR_KIND (t))\n+\t\t    {\n+\t\t    case OMP_CLAUSE_LINEAR_REF:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    case OMP_CLAUSE_LINEAR_UVAL:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    case OMP_CLAUSE_LINEAR_VAL:\n+\t\t    case OMP_CLAUSE_LINEAR_DEFAULT:\n+\t\t      arg_type\n+\t\t\t= SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP;\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n+\t\telse\n+\t\t  arg_type = SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP;\n+\t\tclone_info->args[argno].arg_type = arg_type;\n+\t\tclone_info->args[argno].linear_step = tree_to_shwi (step);\n+\t\tgcc_assert (clone_info->args[argno].linear_step >= 0\n+\t\t\t    && clone_info->args[argno].linear_step < n);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (POINTER_TYPE_P (args[argno]))\n+\t\t  step = fold_convert (ssizetype, step);\n+\t\tif (!tree_fits_shwi_p (step))\n+\t\t  {\n+\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n+\t\t\t\t\"ignoring large linear step\");\n+\t\t    args.release ();\n+\t\t    return NULL;\n+\t\t  }\n+\t\telse if (integer_zerop (step))\n+\t\t  {\n+\t\t    warning_at (OMP_CLAUSE_LOCATION (t), 0,\n+\t\t\t\t\"ignoring zero linear step\");\n+\t\t    args.release ();\n+\t\t    return NULL;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    enum cgraph_simd_clone_arg_type arg_type;\n+\t\t    if (TREE_CODE (args[argno]) == REFERENCE_TYPE)\n+\t\t      switch (OMP_CLAUSE_LINEAR_KIND (t))\n+\t\t\t{\n+\t\t\tcase OMP_CLAUSE_LINEAR_REF:\n+\t\t\t  arg_type\n+\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP;\n+\t\t\t  break;\n+\t\t\tcase OMP_CLAUSE_LINEAR_UVAL:\n+\t\t\t  arg_type\n+\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP;\n+\t\t\t  break;\n+\t\t\tcase OMP_CLAUSE_LINEAR_VAL:\n+\t\t\tcase OMP_CLAUSE_LINEAR_DEFAULT:\n+\t\t\t  arg_type\n+\t\t\t    = SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP;\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  gcc_unreachable ();\n+\t\t\t}\n+\t\t    else\n+\t\t      arg_type = SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP;\n+\t\t    clone_info->args[argno].arg_type = arg_type;\n+\t\t    clone_info->args[argno].linear_step = tree_to_shwi (step);\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n+\tcase OMP_CLAUSE_UNIFORM:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    int argno = tree_to_uhwi (decl);\n+\t    clone_info->args[argno].arg_type\n+\t      = SIMD_CLONE_ARG_TYPE_UNIFORM;\n+\t    break;\n+\t  }\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  {\n+\t    tree decl = OMP_CLAUSE_DECL (t);\n+\t    int argno = tree_to_uhwi (decl);\n+\t    clone_info->args[argno].alignment\n+\t      = TREE_INT_CST_LOW (OMP_CLAUSE_ALIGNED_ALIGNMENT (t));\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  args.release ();\n+  return clone_info;\n+}\n+\n+/* Given a SIMD clone in NODE, calculate the characteristic data\n+   type and return the coresponding type.  The characteristic data\n+   type is computed as described in the Intel Vector ABI.  */\n+\n+static tree\n+simd_clone_compute_base_data_type (struct cgraph_node *node,\n+\t\t\t\t   struct cgraph_simd_clone *clone_info)\n+{\n+  tree type = integer_type_node;\n+  tree fndecl = node->decl;\n+\n+  /* a) For non-void function, the characteristic data type is the\n+        return type.  */\n+  if (TREE_CODE (TREE_TYPE (TREE_TYPE (fndecl))) != VOID_TYPE)\n+    type = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+  /* b) If the function has any non-uniform, non-linear parameters,\n+        then the characteristic data type is the type of the first\n+        such parameter.  */\n+  else\n+    {\n+      vec<tree> map = simd_clone_vector_of_formal_parm_types (fndecl);\n+      for (unsigned int i = 0; i < clone_info->nargs; ++i)\n+\tif (clone_info->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n+\t  {\n+\t    type = map[i];\n+\t    break;\n+\t  }\n+      map.release ();\n+    }\n+\n+  /* c) If the characteristic data type determined by a) or b) above\n+        is struct, union, or class type which is pass-by-value (except\n+        for the type that maps to the built-in complex data type), the\n+        characteristic data type is int.  */\n+  if (RECORD_OR_UNION_TYPE_P (type)\n+      && !aggregate_value_p (type, NULL)\n+      && TREE_CODE (type) != COMPLEX_TYPE)\n+    return integer_type_node;\n+\n+  /* d) If none of the above three classes is applicable, the\n+        characteristic data type is int.  */\n+\n+  return type;\n+\n+  /* e) For Intel Xeon Phi native and offload compilation, if the\n+        resulting characteristic data type is 8-bit or 16-bit integer\n+        data type, the characteristic data type is int.  */\n+  /* Well, we don't handle Xeon Phi yet.  */\n+}\n+\n+static tree\n+simd_clone_mangle (struct cgraph_node *node,\n+\t\t   struct cgraph_simd_clone *clone_info)\n+{\n+  char vecsize_mangle = clone_info->vecsize_mangle;\n+  char mask = clone_info->inbranch ? 'M' : 'N';\n+  unsigned int simdlen = clone_info->simdlen;\n+  unsigned int n;\n+  pretty_printer pp;\n+\n+  gcc_assert (vecsize_mangle && simdlen);\n+\n+  pp_string (&pp, \"_ZGV\");\n+  pp_character (&pp, vecsize_mangle);\n+  pp_character (&pp, mask);\n+  pp_decimal_int (&pp, simdlen);\n+\n+  for (n = 0; n < clone_info->nargs; ++n)\n+    {\n+      struct cgraph_simd_clone_arg arg = clone_info->args[n];\n+\n+      switch (arg.arg_type)\n+\t{\n+\tcase SIMD_CLONE_ARG_TYPE_UNIFORM:\n+\t  pp_character (&pp, 'u');\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+\t  pp_character (&pp, 'l');\n+\t  goto mangle_linear;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n+\t  pp_character (&pp, 'R');\n+\t  goto mangle_linear;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+\t  pp_character (&pp, 'L');\n+\t  goto mangle_linear;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+\t  pp_character (&pp, 'U');\n+\t  goto mangle_linear;\n+\tmangle_linear:\n+\t  gcc_assert (arg.linear_step != 0);\n+\t  if (arg.linear_step > 1)\n+\t    pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  else if (arg.linear_step < 0)\n+\t    {\n+\t      pp_character (&pp, 'n');\n+\t      pp_unsigned_wide_integer (&pp, (-(unsigned HOST_WIDE_INT)\n+\t\t\t\t\t      arg.linear_step));\n+\t    }\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+\t  pp_string (&pp, \"ls\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Rs\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Ls\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n+\t  pp_string (&pp, \"Us\");\n+\t  pp_unsigned_wide_integer (&pp, arg.linear_step);\n+\t  break;\n+\tdefault:\n+\t  pp_character (&pp, 'v');\n+\t}\n+      if (arg.alignment)\n+\t{\n+\t  pp_character (&pp, 'a');\n+\t  pp_decimal_int (&pp, arg.alignment);\n+\t}\n+    }\n+\n+  pp_underscore (&pp);\n+  const char *str = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl));\n+  if (*str == '*')\n+    ++str;\n+  pp_string (&pp, str);\n+  str = pp_formatted_text (&pp);\n+\n+  /* If there already is a SIMD clone with the same mangled name, don't\n+     add another one.  This can happen e.g. for\n+     #pragma omp declare simd\n+     #pragma omp declare simd simdlen(8)\n+     int foo (int, int);\n+     if the simdlen is assumed to be 8 for the first one, etc.  */\n+  for (struct cgraph_node *clone = node->simd_clones; clone;\n+       clone = clone->simdclone->next_clone)\n+    if (strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (clone->decl)),\n+\t\tstr) == 0)\n+      return NULL_TREE;\n+\n+  return get_identifier (str);\n+}\n+\n+/* Create a simd clone of OLD_NODE and return it.  */\n+\n+static struct cgraph_node *\n+simd_clone_create (struct cgraph_node *old_node)\n+{\n+  struct cgraph_node *new_node;\n+  if (old_node->definition)\n+    {\n+      if (!old_node->has_gimple_body_p ())\n+\treturn NULL;\n+      old_node->get_body ();\n+      new_node = old_node->create_version_clone_with_body (vNULL, NULL, NULL,\n+\t\t\t\t\t\t\t   false, NULL, NULL,\n+\t\t\t\t\t\t\t   \"simdclone\");\n+    }\n+  else\n+    {\n+      tree old_decl = old_node->decl;\n+      tree new_decl = copy_node (old_node->decl);\n+      DECL_NAME (new_decl) = clone_function_name (old_decl, \"simdclone\");\n+      SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n+      SET_DECL_RTL (new_decl, NULL);\n+      DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n+      DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n+      new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n+      if (old_node->in_other_partition)\n+\tnew_node->in_other_partition = 1;\n+    }\n+  if (new_node == NULL)\n+    return new_node;\n+\n+  TREE_PUBLIC (new_node->decl) = TREE_PUBLIC (old_node->decl);\n+\n+  /* The function cgraph_function_versioning () will force the new\n+     symbol local.  Undo this, and inherit external visability from\n+     the old node.  */\n+  new_node->local.local = old_node->local.local;\n+  new_node->externally_visible = old_node->externally_visible;\n+\n+  return new_node;\n+}\n+\n+/* Adjust the return type of the given function to its appropriate\n+   vector counterpart.  Returns a simd array to be used throughout the\n+   function as a return value.  */\n+\n+static tree\n+simd_clone_adjust_return_type (struct cgraph_node *node)\n+{\n+  tree fndecl = node->decl;\n+  tree orig_rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+  unsigned int veclen;\n+  tree t;\n+\n+  /* Adjust the function return type.  */\n+  if (orig_rettype == void_type_node)\n+    return NULL_TREE;\n+  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));\n+  t = TREE_TYPE (TREE_TYPE (fndecl));\n+  if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))\n+    veclen = node->simdclone->vecsize_int;\n+  else\n+    veclen = node->simdclone->vecsize_float;\n+  veclen /= GET_MODE_BITSIZE (TYPE_MODE (t));\n+  if (veclen > node->simdclone->simdlen)\n+    veclen = node->simdclone->simdlen;\n+  if (POINTER_TYPE_P (t))\n+    t = pointer_sized_int_node;\n+  if (veclen == node->simdclone->simdlen)\n+    t = build_vector_type (t, node->simdclone->simdlen);\n+  else\n+    {\n+      t = build_vector_type (t, veclen);\n+      t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);\n+    }\n+  TREE_TYPE (TREE_TYPE (fndecl)) = t;\n+  if (!node->definition)\n+    return NULL_TREE;\n+\n+  t = DECL_RESULT (fndecl);\n+  /* Adjust the DECL_RESULT.  */\n+  gcc_assert (TREE_TYPE (t) != void_type_node);\n+  TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (fndecl));\n+  relayout_decl (t);\n+\n+  tree atype = build_array_type_nelts (orig_rettype,\n+\t\t\t\t       node->simdclone->simdlen);\n+  if (veclen != node->simdclone->simdlen)\n+    return build1 (VIEW_CONVERT_EXPR, atype, t);\n+\n+  /* Set up a SIMD array to use as the return value.  */\n+  tree retval = create_tmp_var_raw (atype, \"retval\");\n+  gimple_add_tmp_var (retval);\n+  return retval;\n+}\n+\n+/* Each vector argument has a corresponding array to be used locally\n+   as part of the eventual loop.  Create such temporary array and\n+   return it.\n+\n+   PREFIX is the prefix to be used for the temporary.\n+\n+   TYPE is the inner element type.\n+\n+   SIMDLEN is the number of elements.  */\n+\n+static tree\n+create_tmp_simd_array (const char *prefix, tree type, int simdlen)\n+{\n+  tree atype = build_array_type_nelts (type, simdlen);\n+  tree avar = create_tmp_var_raw (atype, prefix);\n+  gimple_add_tmp_var (avar);\n+  return avar;\n+}\n+\n+/* Modify the function argument types to their corresponding vector\n+   counterparts if appropriate.  Also, create one array for each simd\n+   argument to be used locally when using the function arguments as\n+   part of the loop.\n+\n+   NODE is the function whose arguments are to be adjusted.\n+\n+   Returns an adjustment vector that will be filled describing how the\n+   argument types will be adjusted.  */\n+\n+static ipa_parm_adjustment_vec\n+simd_clone_adjust_argument_types (struct cgraph_node *node)\n+{\n+  vec<tree> args;\n+  ipa_parm_adjustment_vec adjustments;\n+\n+  if (node->definition)\n+    args = ipa_get_vector_of_formal_parms (node->decl);\n+  else\n+    args = simd_clone_vector_of_formal_parm_types (node->decl);\n+  adjustments.create (args.length ());\n+  unsigned i, j, veclen;\n+  struct ipa_parm_adjustment adj;\n+  struct cgraph_simd_clone *sc = node->simdclone;\n+\n+  for (i = 0; i < sc->nargs; ++i)\n+    {\n+      memset (&adj, 0, sizeof (adj));\n+      tree parm = args[i];\n+      tree parm_type = node->definition ? TREE_TYPE (parm) : parm;\n+      adj.base_index = i;\n+      adj.base = parm;\n+\n+      sc->args[i].orig_arg = node->definition ? parm : NULL_TREE;\n+      sc->args[i].orig_type = parm_type;\n+\n+      switch (sc->args[i].arg_type)\n+\t{\n+\tdefault:\n+\t  /* No adjustment necessary for scalar arguments.  */\n+\t  adj.op = IPA_PARM_OP_COPY;\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n+\t  if (node->definition)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n+\t\t\t\t       TREE_TYPE (parm_type),\n+\t\t\t\t       sc->simdlen);\n+\t  adj.op = IPA_PARM_OP_COPY;\n+\t  break;\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+\tcase SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+\tcase SIMD_CLONE_ARG_TYPE_VECTOR:\n+\t  if (INTEGRAL_TYPE_P (parm_type) || POINTER_TYPE_P (parm_type))\n+\t    veclen = sc->vecsize_int;\n+\t  else\n+\t    veclen = sc->vecsize_float;\n+\t  veclen /= GET_MODE_BITSIZE (TYPE_MODE (parm_type));\n+\t  if (veclen > sc->simdlen)\n+\t    veclen = sc->simdlen;\n+\t  adj.arg_prefix = \"simd\";\n+\t  if (POINTER_TYPE_P (parm_type))\n+\t    adj.type = build_vector_type (pointer_sized_int_node, veclen);\n+\t  else\n+\t    adj.type = build_vector_type (parm_type, veclen);\n+\t  sc->args[i].vector_type = adj.type;\n+\t  for (j = veclen; j < sc->simdlen; j += veclen)\n+\t    {\n+\t      adjustments.safe_push (adj);\n+\t      if (j == veclen)\n+\t\t{\n+\t\t  memset (&adj, 0, sizeof (adj));\n+\t\t  adj.op = IPA_PARM_OP_NEW;\n+\t\t  adj.arg_prefix = \"simd\";\n+\t\t  adj.base_index = i;\n+\t\t  adj.type = sc->args[i].vector_type;\n+\t\t}\n+\t    }\n+\n+\t  if (node->definition)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (IDENTIFIER_POINTER (DECL_NAME (parm)),\n+\t\t\t\t       parm_type, sc->simdlen);\n+\t}\n+      adjustments.safe_push (adj);\n+    }\n+\n+  if (sc->inbranch)\n+    {\n+      tree base_type = simd_clone_compute_base_data_type (sc->origin, sc);\n+\n+      memset (&adj, 0, sizeof (adj));\n+      adj.op = IPA_PARM_OP_NEW;\n+      adj.arg_prefix = \"mask\";\n+\n+      adj.base_index = i;\n+      if (INTEGRAL_TYPE_P (base_type) || POINTER_TYPE_P (base_type))\n+\tveclen = sc->vecsize_int;\n+      else\n+\tveclen = sc->vecsize_float;\n+      veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));\n+      if (veclen > sc->simdlen)\n+\tveclen = sc->simdlen;\n+      if (sc->mask_mode != VOIDmode)\n+\tadj.type\n+\t  = lang_hooks.types.type_for_mode (sc->mask_mode, 1);\n+      else if (POINTER_TYPE_P (base_type))\n+\tadj.type = build_vector_type (pointer_sized_int_node, veclen);\n+      else\n+\tadj.type = build_vector_type (base_type, veclen);\n+      adjustments.safe_push (adj);\n+\n+      for (j = veclen; j < sc->simdlen; j += veclen)\n+\tadjustments.safe_push (adj);\n+\n+      /* We have previously allocated one extra entry for the mask.  Use\n+\t it and fill it.  */\n+      sc->nargs++;\n+      if (sc->mask_mode != VOIDmode)\n+\tbase_type = boolean_type_node;\n+      if (node->definition)\n+\t{\n+\t  sc->args[i].orig_arg\n+\t    = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL, base_type);\n+\t  if (sc->mask_mode == VOIDmode)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (\"mask\", base_type, sc->simdlen);\n+\t  else if (veclen < sc->simdlen)\n+\t    sc->args[i].simd_array\n+\t      = create_tmp_simd_array (\"mask\", adj.type, sc->simdlen / veclen);\n+\t  else\n+\t    sc->args[i].simd_array = NULL_TREE;\n+\t}\n+      sc->args[i].orig_type = base_type;\n+      sc->args[i].arg_type = SIMD_CLONE_ARG_TYPE_MASK;\n+    }\n+\n+  if (node->definition)\n+    ipa_modify_formal_parameters (node->decl, adjustments);\n+  else\n+    {\n+      tree new_arg_types = NULL_TREE, new_reversed;\n+      bool last_parm_void = false;\n+      if (args.length () > 0 && args.last () == void_type_node)\n+\tlast_parm_void = true;\n+\n+      gcc_assert (TYPE_ARG_TYPES (TREE_TYPE (node->decl)));\n+      j = adjustments.length ();\n+      for (i = 0; i < j; i++)\n+\t{\n+\t  struct ipa_parm_adjustment *adj = &adjustments[i];\n+\t  tree ptype;\n+\t  if (adj->op == IPA_PARM_OP_COPY)\n+\t    ptype = args[adj->base_index];\n+\t  else\n+\t    ptype = adj->type;\n+\t  new_arg_types = tree_cons (NULL_TREE, ptype, new_arg_types);\n+\t}\n+      new_reversed = nreverse (new_arg_types);\n+      if (last_parm_void)\n+\t{\n+\t  if (new_reversed)\n+\t    TREE_CHAIN (new_arg_types) = void_list_node;\n+\t  else\n+\t    new_reversed = void_list_node;\n+\t}\n+\n+      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+      TREE_TYPE (node->decl) = new_type;\n+\n+      adjustments.release ();\n+    }\n+  args.release ();\n+  return adjustments;\n+}\n+\n+/* Initialize and copy the function arguments in NODE to their\n+   corresponding local simd arrays.  Returns a fresh gimple_seq with\n+   the instruction sequence generated.  */\n+\n+static gimple_seq\n+simd_clone_init_simd_arrays (struct cgraph_node *node,\n+\t\t\t     ipa_parm_adjustment_vec adjustments)\n+{\n+  gimple_seq seq = NULL;\n+  unsigned i = 0, j = 0, k;\n+\n+  for (tree arg = DECL_ARGUMENTS (node->decl);\n+       arg;\n+       arg = DECL_CHAIN (arg), i++, j++)\n+    {\n+      if (adjustments[j].op == IPA_PARM_OP_COPY\n+\t  || POINTER_TYPE_P (TREE_TYPE (arg)))\n+\tcontinue;\n+\n+      node->simdclone->args[i].vector_arg = arg;\n+\n+      tree array = node->simdclone->args[i].simd_array;\n+      if (node->simdclone->mask_mode != VOIDmode\n+\t  && node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_MASK)\n+\t{\n+\t  if (array == NULL_TREE)\n+\t    continue;\n+\t  unsigned int l\n+\t    = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (array))));\n+\t  for (k = 0; k <= l; k++)\n+\t    {\n+\t      if (k)\n+\t\t{\n+\t\t  arg = DECL_CHAIN (arg);\n+\t\t  j++;\n+\t\t}\n+\t      tree t = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),\n+\t\t\t       array, size_int (k), NULL, NULL);\n+\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t      gimplify_and_add (t, &seq);\n+\t    }\n+\t  continue;\n+\t}\n+      if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)) == node->simdclone->simdlen)\n+\t{\n+\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n+\t  tree ptr = build_fold_addr_expr (array);\n+\t  tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n+\t\t\t   build_int_cst (ptype, 0));\n+\t  t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t  gimplify_and_add (t, &seq);\n+\t}\n+      else\n+\t{\n+\t  unsigned int simdlen = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg));\n+\t  tree ptype = build_pointer_type (TREE_TYPE (TREE_TYPE (array)));\n+\t  for (k = 0; k < node->simdclone->simdlen; k += simdlen)\n+\t    {\n+\t      tree ptr = build_fold_addr_expr (array);\n+\t      int elemsize;\n+\t      if (k)\n+\t\t{\n+\t\t  arg = DECL_CHAIN (arg);\n+\t\t  j++;\n+\t\t}\n+\t      elemsize\n+\t\t= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (arg))));\n+\t      tree t = build2 (MEM_REF, TREE_TYPE (arg), ptr,\n+\t\t\t       build_int_cst (ptype, k * elemsize));\n+\t      t = build2 (MODIFY_EXPR, TREE_TYPE (t), t, arg);\n+\t      gimplify_and_add (t, &seq);\n+\t    }\n+\t}\n+    }\n+  return seq;\n+}\n+\n+/* Callback info for ipa_simd_modify_stmt_ops below.  */\n+\n+struct modify_stmt_info {\n+  ipa_parm_adjustment_vec adjustments;\n+  gimple *stmt;\n+  /* True if the parent statement was modified by\n+     ipa_simd_modify_stmt_ops.  */\n+  bool modified;\n+};\n+\n+/* Callback for walk_gimple_op.\n+\n+   Adjust operands from a given statement as specified in the\n+   adjustments vector in the callback data.  */\n+\n+static tree\n+ipa_simd_modify_stmt_ops (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  struct modify_stmt_info *info = (struct modify_stmt_info *) wi->info;\n+  tree *orig_tp = tp;\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    tp = &TREE_OPERAND (*tp, 0);\n+  struct ipa_parm_adjustment *cand = NULL;\n+  if (TREE_CODE (*tp) == PARM_DECL)\n+    cand = ipa_get_adjustment_candidate (&tp, NULL, info->adjustments, true);\n+  else\n+    {\n+      if (TYPE_P (*tp))\n+\t*walk_subtrees = 0;\n+    }\n+\n+  tree repl = NULL_TREE;\n+  if (cand)\n+    repl = unshare_expr (cand->new_decl);\n+  else\n+    {\n+      if (tp != orig_tp)\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  bool modified = info->modified;\n+\t  info->modified = false;\n+\t  walk_tree (tp, ipa_simd_modify_stmt_ops, wi, wi->pset);\n+\t  if (!info->modified)\n+\t    {\n+\t      info->modified = modified;\n+\t      return NULL_TREE;\n+\t    }\n+\t  info->modified = modified;\n+\t  repl = *tp;\n+\t}\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  if (tp != orig_tp)\n+    {\n+      repl = build_fold_addr_expr (repl);\n+      gimple *stmt;\n+      if (is_gimple_debug (info->stmt))\n+\t{\n+\t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n+\t  stmt = gimple_build_debug_source_bind (vexpr, repl, NULL);\n+\t  DECL_ARTIFICIAL (vexpr) = 1;\n+\t  TREE_TYPE (vexpr) = TREE_TYPE (repl);\n+\t  DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (repl));\n+\t  repl = vexpr;\n+\t}\n+      else\n+\t{\n+\t  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);\n+\t  repl = gimple_assign_lhs (stmt);\n+\t}\n+      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);\n+      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      *orig_tp = repl;\n+    }\n+  else if (!useless_type_conversion_p (TREE_TYPE (*tp), TREE_TYPE (repl)))\n+    {\n+      tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*tp), repl);\n+      *tp = vce;\n+    }\n+  else\n+    *tp = repl;\n+\n+  info->modified = true;\n+  return NULL_TREE;\n+}\n+\n+/* Traverse the function body and perform all modifications as\n+   described in ADJUSTMENTS.  At function return, ADJUSTMENTS will be\n+   modified such that the replacement/reduction value will now be an\n+   offset into the corresponding simd_array.\n+\n+   This function will replace all function argument uses with their\n+   corresponding simd array elements, and ajust the return values\n+   accordingly.  */\n+\n+static void\n+ipa_simd_modify_function_body (struct cgraph_node *node,\n+\t\t\t       ipa_parm_adjustment_vec adjustments,\n+\t\t\t       tree retval_array, tree iter)\n+{\n+  basic_block bb;\n+  unsigned int i, j, l;\n+\n+  /* Re-use the adjustments array, but this time use it to replace\n+     every function argument use to an offset into the corresponding\n+     simd_array.  */\n+  for (i = 0, j = 0; i < node->simdclone->nargs; ++i, ++j)\n+    {\n+      if (!node->simdclone->args[i].vector_arg)\n+\tcontinue;\n+\n+      tree basetype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n+      tree vectype = TREE_TYPE (node->simdclone->args[i].vector_arg);\n+      adjustments[j].new_decl\n+\t= build4 (ARRAY_REF,\n+\t\t  basetype,\n+\t\t  node->simdclone->args[i].simd_array,\n+\t\t  iter,\n+\t\t  NULL_TREE, NULL_TREE);\n+      if (adjustments[j].op == IPA_PARM_OP_NONE\n+\t  && TYPE_VECTOR_SUBPARTS (vectype) < node->simdclone->simdlen)\n+\tj += node->simdclone->simdlen / TYPE_VECTOR_SUBPARTS (vectype) - 1;\n+    }\n+\n+  l = adjustments.length ();\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      if (name\n+\t  && SSA_NAME_VAR (name)\n+\t  && TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL)\n+\t{\n+\t  for (j = 0; j < l; j++)\n+\t    if (SSA_NAME_VAR (name) == adjustments[j].base\n+\t\t&& adjustments[j].new_decl)\n+\t      {\n+\t\ttree base_var;\n+\t\tif (adjustments[j].new_ssa_base == NULL_TREE)\n+\t\t  {\n+\t\t    base_var\n+\t\t      = copy_var_decl (adjustments[j].base,\n+\t\t\t\t       DECL_NAME (adjustments[j].base),\n+\t\t\t\t       TREE_TYPE (adjustments[j].base));\n+\t\t    adjustments[j].new_ssa_base = base_var;\n+\t\t  }\n+\t\telse\n+\t\t  base_var = adjustments[j].new_ssa_base;\n+\t\tif (SSA_NAME_IS_DEFAULT_DEF (name))\n+\t\t  {\n+\t\t    bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t\t    gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+\t\t    tree new_decl = unshare_expr (adjustments[j].new_decl);\n+\t\t    set_ssa_default_def (cfun, adjustments[j].base, NULL_TREE);\n+\t\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n+\t\t    SSA_NAME_IS_DEFAULT_DEF (name) = 0;\n+\t\t    gimple *stmt = gimple_build_assign (name, new_decl);\n+\t\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t\t  }\n+\t\telse\n+\t\t  SET_SSA_NAME_VAR_OR_IDENTIFIER (name, base_var);\n+\t      }\n+\t}\n+    }\n+\n+  struct modify_stmt_info info;\n+  info.adjustments = adjustments;\n+\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (node->decl))\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      gsi = gsi_start_bb (bb);\n+      while (!gsi_end_p (gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  info.stmt = stmt;\n+\t  struct walk_stmt_info wi;\n+\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  info.modified = false;\n+\t  wi.info = &info;\n+\t  walk_gimple_op (stmt, ipa_simd_modify_stmt_ops, &wi);\n+\n+\t  if (greturn *return_stmt = dyn_cast <greturn *> (stmt))\n+\t    {\n+\t      tree retval = gimple_return_retval (return_stmt);\n+\t      if (!retval)\n+\t\t{\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Replace `return foo' with `retval_array[iter] = foo'.  */\n+\t      tree ref = build4 (ARRAY_REF, TREE_TYPE (retval),\n+\t\t\t\t retval_array, iter, NULL, NULL);\n+\t      stmt = gimple_build_assign (ref, retval);\n+\t      gsi_replace (&gsi, stmt, true);\n+\t      info.modified = true;\n+\t    }\n+\n+\t  if (info.modified)\n+\t    {\n+\t      update_stmt (stmt);\n+\t      if (maybe_clean_eh_stmt (stmt))\n+\t\tgimple_purge_dead_eh_edges (gimple_bb (stmt));\n+\t    }\n+\t  gsi_next (&gsi);\n+\t}\n+    }\n+}\n+\n+/* Helper function of simd_clone_adjust, return linear step addend\n+   of Ith argument.  */\n+\n+static tree\n+simd_clone_linear_addend (struct cgraph_node *node, unsigned int i,\n+\t\t\t  tree addtype, basic_block entry_bb)\n+{\n+  tree ptype = NULL_TREE;\n+  switch (node->simdclone->args[i].arg_type)\n+    {\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_CONSTANT_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP:\n+      return build_int_cst (addtype, node->simdclone->args[i].linear_step);\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP:\n+      ptype = TREE_TYPE (node->simdclone->args[i].orig_arg);\n+      break;\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_VAL_VARIABLE_STEP:\n+    case SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP:\n+      ptype = TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  unsigned int idx = node->simdclone->args[i].linear_step;\n+  tree arg = node->simdclone->args[idx].orig_arg;\n+  gcc_assert (is_gimple_reg_type (TREE_TYPE (arg)));\n+  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n+  gimple *g;\n+  tree ret;\n+  if (is_gimple_reg (arg))\n+    ret = get_or_create_ssa_default_def (cfun, arg);\n+  else\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (arg)), arg);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n+    {\n+      g = gimple_build_assign (make_ssa_name (TREE_TYPE (TREE_TYPE (arg))),\n+\t\t\t       build_simple_mem_ref (ret));\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (!useless_type_conversion_p (addtype, TREE_TYPE (ret)))\n+    {\n+      g = gimple_build_assign (make_ssa_name (addtype), NOP_EXPR, ret);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      ret = gimple_assign_lhs (g);\n+    }\n+  if (POINTER_TYPE_P (ptype))\n+    {\n+      tree size = TYPE_SIZE_UNIT (TREE_TYPE (ptype));\n+      if (size && TREE_CODE (size) == INTEGER_CST)\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (addtype), MULT_EXPR,\n+\t\t\t\t   ret, fold_convert (addtype, size));\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t  ret = gimple_assign_lhs (g);\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Adjust the argument types in NODE to their appropriate vector\n+   counterparts.  */\n+\n+static void\n+simd_clone_adjust (struct cgraph_node *node)\n+{\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+  targetm.simd_clone.adjust (node);\n+\n+  tree retval = simd_clone_adjust_return_type (node);\n+  ipa_parm_adjustment_vec adjustments\n+    = simd_clone_adjust_argument_types (node);\n+\n+  push_gimplify_context ();\n+\n+  gimple_seq seq = simd_clone_init_simd_arrays (node, adjustments);\n+\n+  /* Adjust all uses of vector arguments accordingly.  Adjust all\n+     return values accordingly.  */\n+  tree iter = create_tmp_var (unsigned_type_node, \"iter\");\n+  tree iter1 = make_ssa_name (iter);\n+  tree iter2 = make_ssa_name (iter);\n+  ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n+\n+  /* Initialize the iteration variable.  */\n+  basic_block entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  basic_block body_bb = split_block_after_labels (entry_bb)->dest;\n+  gimple_stmt_iterator gsi = gsi_after_labels (entry_bb);\n+  /* Insert the SIMD array and iv initialization at function\n+     entry.  */\n+  gsi_insert_seq_before (&gsi, seq, GSI_NEW_STMT);\n+\n+  pop_gimplify_context (NULL);\n+\n+  /* Create a new BB right before the original exit BB, to hold the\n+     iteration increment and the condition/branch.  */\n+  basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n+  basic_block incr_bb = create_empty_bb (orig_exit);\n+  add_bb_to_loop (incr_bb, body_bb->loop_father);\n+  /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n+     flag.  Set it now to be a FALLTHRU_EDGE.  */\n+  gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);\n+  EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;\n+  for (unsigned i = 0;\n+       i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)\n+    {\n+      edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n+      redirect_edge_succ (e, incr_bb);\n+    }\n+  edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+  e->probability = REG_BR_PROB_BASE;\n+  gsi = gsi_last_bb (incr_bb);\n+  gimple *g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n+\t\t\t\t   build_int_cst (unsigned_type_node, 1));\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\n+  /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n+  struct loop *loop = alloc_loop ();\n+  cfun->has_force_vectorize_loops = true;\n+  loop->safelen = node->simdclone->simdlen;\n+  loop->force_vectorize = true;\n+  loop->header = body_bb;\n+\n+  /* Branch around the body if the mask applies.  */\n+  if (node->simdclone->inbranch)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n+      tree mask_array\n+\t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n+      tree mask;\n+      if (node->simdclone->mask_mode != VOIDmode)\n+\t{\n+\t  tree shift_cnt;\n+\t  if (mask_array == NULL_TREE)\n+\t    {\n+\t      tree arg = node->simdclone->args[node->simdclone->nargs\n+\t\t\t\t\t       - 1].vector_arg;\n+\t      mask = get_or_create_ssa_default_def (cfun, arg);\n+\t      shift_cnt = iter1;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree maskt = TREE_TYPE (mask_array);\n+\t      int c = tree_to_uhwi (TYPE_MAX_VALUE (TYPE_DOMAIN (maskt)));\n+\t      c = node->simdclone->simdlen / (c + 1);\n+\t      int s = exact_log2 (c);\n+\t      gcc_assert (s > 0);\n+\t      c--;\n+\t      tree idx = make_ssa_name (TREE_TYPE (iter1));\n+\t      g = gimple_build_assign (idx, RSHIFT_EXPR, iter1,\n+\t\t\t\t       build_int_cst (NULL_TREE, s));\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t      mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n+\t      tree aref = build4 (ARRAY_REF,\n+\t\t\t\t  TREE_TYPE (TREE_TYPE (mask_array)),\n+\t\t\t\t  mask_array, idx, NULL, NULL);\n+\t      g = gimple_build_assign (mask, aref);\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t      shift_cnt = make_ssa_name (TREE_TYPE (iter1));\n+\t      g = gimple_build_assign (shift_cnt, BIT_AND_EXPR, iter1,\n+\t\t\t\t       build_int_cst (TREE_TYPE (iter1), c));\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t    }\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n+\t\t\t\t   RSHIFT_EXPR, mask, shift_cnt);\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  mask = gimple_assign_lhs (g);\n+\t  g = gimple_build_assign (make_ssa_name (TREE_TYPE (mask)),\n+\t\t\t\t   BIT_AND_EXPR, mask,\n+\t\t\t\t   build_int_cst (TREE_TYPE (mask), 1));\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  mask = gimple_assign_lhs (g);\n+\t}\n+      else\n+\t{\n+\t  mask = make_ssa_name (TREE_TYPE (TREE_TYPE (mask_array)));\n+\t  tree aref = build4 (ARRAY_REF,\n+\t\t\t      TREE_TYPE (TREE_TYPE (mask_array)),\n+\t\t\t      mask_array, iter1, NULL, NULL);\n+\t  g = gimple_build_assign (mask, aref);\n+\t  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t  int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (aref)));\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (aref)))\n+\t    {\n+\t      aref = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t     build_nonstandard_integer_type (bitsize, 0),\n+\t\t\t\t\t\t\t     mask);\n+\t      mask = make_ssa_name (TREE_TYPE (aref));\n+\t      g = gimple_build_assign (mask, aref);\n+\t      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n+\n+      g = gimple_build_cond (EQ_EXPR, mask, build_zero_cst (TREE_TYPE (mask)),\n+\t\t\t     NULL, NULL);\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+      make_edge (loop->header, incr_bb, EDGE_TRUE_VALUE);\n+      FALLTHRU_EDGE (loop->header)->flags = EDGE_FALSE_VALUE;\n+    }\n+\n+  /* Generate the condition.  */\n+  g = gimple_build_cond (LT_EXPR,\n+\t\t\t iter2,\n+\t\t\t build_int_cst (unsigned_type_node,\n+\t\t\t\t\tnode->simdclone->simdlen),\n+\t\t\t NULL, NULL);\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+  e = split_block (incr_bb, gsi_stmt (gsi));\n+  basic_block latch_bb = e->dest;\n+  basic_block new_exit_bb;\n+  new_exit_bb = split_block_after_labels (latch_bb)->dest;\n+  loop->latch = latch_bb;\n+\n+  redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n+\n+  make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n+  /* The successor of incr_bb is already pointing to latch_bb; just\n+     change the flags.\n+     make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n+  FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n+\n+  gphi *phi = create_phi_node (iter1, body_bb);\n+  edge preheader_edge = find_edge (entry_bb, body_bb);\n+  edge latch_edge = single_succ_edge (latch_bb);\n+  add_phi_arg (phi, build_zero_cst (unsigned_type_node), preheader_edge,\n+\t       UNKNOWN_LOCATION);\n+  add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\n+  /* Generate the new return.  */\n+  gsi = gsi_last_bb (new_exit_bb);\n+  if (retval\n+      && TREE_CODE (retval) == VIEW_CONVERT_EXPR\n+      && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n+    retval = TREE_OPERAND (retval, 0);\n+  else if (retval)\n+    {\n+      retval = build1 (VIEW_CONVERT_EXPR,\n+\t\t       TREE_TYPE (TREE_TYPE (node->decl)),\n+\t\t       retval);\n+      retval = force_gimple_operand_gsi (&gsi, retval, true, NULL,\n+\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n+    }\n+  g = gimple_build_return (retval);\n+  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\n+  /* Handle aligned clauses by replacing default defs of the aligned\n+     uniform args with __builtin_assume_aligned (arg_N(D), alignment)\n+     lhs.  Handle linear by adding PHIs.  */\n+  for (unsigned i = 0; i < node->simdclone->nargs; i++)\n+    if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t&& (TREE_ADDRESSABLE (node->simdclone->args[i].orig_arg)\n+\t    || !is_gimple_reg_type\n+\t\t\t(TREE_TYPE (node->simdclone->args[i].orig_arg))))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\tif (is_gimple_reg_type (TREE_TYPE (orig_arg)))\n+\t  iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n+\telse\n+\t  {\n+\t    iter1 = create_tmp_var_raw (TREE_TYPE (orig_arg));\n+\t    gimple_add_tmp_var (iter1);\n+\t  }\n+\tgsi = gsi_after_labels (entry_bb);\n+\tg = gimple_build_assign (iter1, orig_arg);\n+\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\tgsi = gsi_after_labels (body_bb);\n+\tg = gimple_build_assign (orig_arg, iter1);\n+\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+      }\n+    else if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t     && DECL_BY_REFERENCE (node->simdclone->args[i].orig_arg)\n+\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n+\t\t== REFERENCE_TYPE\n+\t     && TREE_ADDRESSABLE\n+\t\t  (TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg))))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tif (def && !has_zero_uses (def))\n+\t  {\n+\t    iter1 = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (orig_arg)));\n+\t    gimple_add_tmp_var (iter1);\n+\t    gsi = gsi_after_labels (entry_bb);\n+\t    g = gimple_build_assign (iter1, build_simple_mem_ref (def));\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t    gsi = gsi_after_labels (body_bb);\n+\t    g = gimple_build_assign (build_simple_mem_ref (def), iter1);\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t  }\n+      }\n+    else if (node->simdclone->args[i].alignment\n+\t     && node->simdclone->args[i].arg_type\n+\t\t== SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t     && (node->simdclone->args[i].alignment\n+\t\t & (node->simdclone->args[i].alignment - 1)) == 0\n+\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n+\t\t== POINTER_TYPE)\n+      {\n+\tunsigned int alignment = node->simdclone->args[i].alignment;\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tif (def && !has_zero_uses (def))\n+\t  {\n+\t    tree fn = builtin_decl_explicit (BUILT_IN_ASSUME_ALIGNED);\n+\t    gimple_seq seq = NULL;\n+\t    bool need_cvt = false;\n+\t    gcall *call\n+\t      = gimple_build_call (fn, 2, def, size_int (alignment));\n+\t    g = call;\n+\t    if (!useless_type_conversion_p (TREE_TYPE (orig_arg),\n+\t\t\t\t\t    ptr_type_node))\n+\t      need_cvt = true;\n+\t    tree t = make_ssa_name (need_cvt ? ptr_type_node : orig_arg);\n+\t    gimple_call_set_lhs (g, t);\n+\t    gimple_seq_add_stmt_without_update (&seq, g);\n+\t    if (need_cvt)\n+\t      {\n+\t\tt = make_ssa_name (orig_arg);\n+\t\tg = gimple_build_assign (t, NOP_EXPR, gimple_call_lhs (g));\n+\t\tgimple_seq_add_stmt_without_update (&seq, g);\n+\t      }\n+\t    gsi_insert_seq_on_edge_immediate\n+\t      (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n+\n+\t    entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t    int freq = compute_call_stmt_bb_frequency (current_function_decl,\n+\t\t\t\t\t\t       entry_bb);\n+\t    node->create_edge (cgraph_node::get_create (fn),\n+\t\t\t       call, entry_bb->count, freq);\n+\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    gimple *use_stmt;\n+\t    tree repl = gimple_get_lhs (g);\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t      if (is_gimple_debug (use_stmt) || use_stmt == call)\n+\t\tcontinue;\n+\t      else\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t  SET_USE (use_p, repl);\n+\t  }\n+      }\n+    else if ((node->simdclone->args[i].arg_type\n+\t      == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_CONSTANT_STEP)\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_VARIABLE_STEP)\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_REF_VARIABLE_STEP))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\tgcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t    || POINTER_TYPE_P (TREE_TYPE (orig_arg)));\n+\ttree def = NULL_TREE;\n+\tif (TREE_ADDRESSABLE (orig_arg))\n+\t  {\n+\t    def = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    iter2 = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    gsi = gsi_after_labels (entry_bb);\n+\t    g = gimple_build_assign (def, orig_arg);\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t  }\n+\telse\n+\t  {\n+\t    def = ssa_default_def (cfun, orig_arg);\n+\t    if (!def || has_zero_uses (def))\n+\t      def = NULL_TREE;\n+\t    else\n+\t      {\n+\t\titer1 = make_ssa_name (orig_arg);\n+\t\titer2 = make_ssa_name (orig_arg);\n+\t      }\n+\t  }\n+\tif (def)\n+\t  {\n+\t    phi = create_phi_node (iter1, body_bb);\n+\t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n+\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n+\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n+\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t    entry_bb);\n+\t    gsi = gsi_last_bb (incr_bb);\n+\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    gimple *use_stmt;\n+\t    if (TREE_ADDRESSABLE (orig_arg))\n+\t      {\n+\t\tgsi = gsi_after_labels (body_bb);\n+\t\tg = gimple_build_assign (orig_arg, iter1);\n+\t\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t      }\n+\t    else\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t\tif (use_stmt == phi)\n+\t\t  continue;\n+\t\telse\n+\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t    SET_USE (use_p, iter1);\n+\t  }\n+      }\n+    else if (node->simdclone->args[i].arg_type\n+\t     == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_CONSTANT_STEP\n+\t     || (node->simdclone->args[i].arg_type\n+\t\t == SIMD_CLONE_ARG_TYPE_LINEAR_UVAL_VARIABLE_STEP))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tgcc_assert (!TREE_ADDRESSABLE (orig_arg)\n+\t\t    && TREE_CODE (TREE_TYPE (orig_arg)) == REFERENCE_TYPE);\n+\tif (def && !has_zero_uses (def))\n+\t  {\n+\t    tree rtype = TREE_TYPE (TREE_TYPE (orig_arg));\n+\t    iter1 = make_ssa_name (orig_arg);\n+\t    iter2 = make_ssa_name (orig_arg);\n+\t    tree iter3 = make_ssa_name (rtype);\n+\t    tree iter4 = make_ssa_name (rtype);\n+\t    tree iter5 = make_ssa_name (rtype);\n+\t    gsi = gsi_after_labels (entry_bb);\n+\t    gimple *load\n+\t      = gimple_build_assign (iter3, build_simple_mem_ref (def));\n+\t    gsi_insert_before (&gsi, load, GSI_NEW_STMT);\n+\n+\t    tree array = node->simdclone->args[i].simd_array;\n+\t    TREE_ADDRESSABLE (array) = 1;\n+\t    tree ptr = build_fold_addr_expr (array);\n+\t    phi = create_phi_node (iter1, body_bb);\n+\t    add_phi_arg (phi, ptr, preheader_edge, UNKNOWN_LOCATION);\n+\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\t    g = gimple_build_assign (iter2, POINTER_PLUS_EXPR, iter1,\n+\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (iter3)));\n+\t    gsi = gsi_last_bb (incr_bb);\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+\t    phi = create_phi_node (iter4, body_bb);\n+\t    add_phi_arg (phi, iter3, preheader_edge, UNKNOWN_LOCATION);\n+\t    add_phi_arg (phi, iter5, latch_edge, UNKNOWN_LOCATION);\n+\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n+\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n+\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n+\t\t\t   ? TREE_TYPE (iter3) : sizetype;\n+\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t    entry_bb);\n+\t    g = gimple_build_assign (iter5, code, iter4, addcst);\n+\t    gsi = gsi_last_bb (incr_bb);\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+\t    g = gimple_build_assign (build_simple_mem_ref (iter1), iter4);\n+\t    gsi = gsi_after_labels (body_bb);\n+\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    gimple *use_stmt;\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t      if (use_stmt == load)\n+\t\tcontinue;\n+\t      else\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t  SET_USE (use_p, iter1);\n+\n+\t    if (!TYPE_READONLY (rtype))\n+\t      {\n+\t\ttree v = make_ssa_name (rtype);\n+\t\ttree aref = build4 (ARRAY_REF, rtype, array,\n+\t\t\t\t    size_zero_node, NULL_TREE,\n+\t\t\t\t    NULL_TREE);\n+\t\tgsi = gsi_after_labels (new_exit_bb);\n+\t\tg = gimple_build_assign (v, aref);\n+\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t\tg = gimple_build_assign (build_simple_mem_ref (def), v);\n+\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t      }\n+\t  }\n+      }\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  add_loop (loop, loop->header->loop_father);\n+  update_ssa (TODO_update_ssa);\n+\n+  pop_cfun ();\n+}\n+\n+/* If the function in NODE is tagged as an elemental SIMD function,\n+   create the appropriate SIMD clones.  */\n+\n+static void\n+expand_simd_clones (struct cgraph_node *node)\n+{\n+  tree attr = lookup_attribute (\"omp declare simd\",\n+\t\t\t\tDECL_ATTRIBUTES (node->decl));\n+  if (attr == NULL_TREE\n+      || node->global.inlined_to\n+      || lookup_attribute (\"noclone\", DECL_ATTRIBUTES (node->decl)))\n+    return;\n+\n+  /* Ignore\n+     #pragma omp declare simd\n+     extern int foo ();\n+     in C, there we don't know the argument types at all.  */\n+  if (!node->definition\n+      && TYPE_ARG_TYPES (TREE_TYPE (node->decl)) == NULL_TREE)\n+    return;\n+\n+  /* Call this before creating clone_info, as it might ggc_collect.  */\n+  if (node->definition && node->has_gimple_body_p ())\n+    node->get_body ();\n+\n+  do\n+    {\n+      /* Start with parsing the \"omp declare simd\" attribute(s).  */\n+      bool inbranch_clause_specified;\n+      struct cgraph_simd_clone *clone_info\n+\t= simd_clone_clauses_extract (node, TREE_VALUE (attr),\n+\t\t\t\t      &inbranch_clause_specified);\n+      if (clone_info == NULL)\n+\tcontinue;\n+\n+      int orig_simdlen = clone_info->simdlen;\n+      tree base_type = simd_clone_compute_base_data_type (node, clone_info);\n+      /* The target can return 0 (no simd clones should be created),\n+\t 1 (just one ISA of simd clones should be created) or higher\n+\t count of ISA variants.  In that case, clone_info is initialized\n+\t for the first ISA variant.  */\n+      int count\n+\t= targetm.simd_clone.compute_vecsize_and_simdlen (node, clone_info,\n+\t\t\t\t\t\t\t  base_type, 0);\n+      if (count == 0)\n+\tcontinue;\n+\n+      /* Loop over all COUNT ISA variants, and if !INBRANCH_CLAUSE_SPECIFIED,\n+\t also create one inbranch and one !inbranch clone of it.  */\n+      for (int i = 0; i < count * 2; i++)\n+\t{\n+\t  struct cgraph_simd_clone *clone = clone_info;\n+\t  if (inbranch_clause_specified && (i & 1) != 0)\n+\t    continue;\n+\n+\t  if (i != 0)\n+\t    {\n+\t      clone = simd_clone_struct_alloc (clone_info->nargs\n+\t\t\t\t\t       + ((i & 1) != 0));\n+\t      simd_clone_struct_copy (clone, clone_info);\n+\t      /* Undo changes targetm.simd_clone.compute_vecsize_and_simdlen\n+\t\t and simd_clone_adjust_argument_types did to the first\n+\t\t clone's info.  */\n+\t      clone->nargs -= clone_info->inbranch;\n+\t      clone->simdlen = orig_simdlen;\n+\t      /* And call the target hook again to get the right ISA.  */\n+\t      targetm.simd_clone.compute_vecsize_and_simdlen (node, clone,\n+\t\t\t\t\t\t\t      base_type,\n+\t\t\t\t\t\t\t      i / 2);\n+\t      if ((i & 1) != 0)\n+\t\tclone->inbranch = 1;\n+\t    }\n+\n+\t  /* simd_clone_mangle might fail if such a clone has been created\n+\t     already.  */\n+\t  tree id = simd_clone_mangle (node, clone);\n+\t  if (id == NULL_TREE)\n+\t    continue;\n+\n+\t  /* Only when we are sure we want to create the clone actually\n+\t     clone the function (or definitions) or create another\n+\t     extern FUNCTION_DECL (for prototypes without definitions).  */\n+\t  struct cgraph_node *n = simd_clone_create (node);\n+\t  if (n == NULL)\n+\t    continue;\n+\n+\t  n->simdclone = clone;\n+\t  clone->origin = node;\n+\t  clone->next_clone = NULL;\n+\t  if (node->simd_clones == NULL)\n+\t    {\n+\t      clone->prev_clone = n;\n+\t      node->simd_clones = n;\n+\t    }\n+\t  else\n+\t    {\n+\t      clone->prev_clone = node->simd_clones->simdclone->prev_clone;\n+\t      clone->prev_clone->simdclone->next_clone = n;\n+\t      node->simd_clones->simdclone->prev_clone = n;\n+\t    }\n+\t  symtab->change_decl_assembler_name (n->decl, id);\n+\t  /* And finally adjust the return type, parameters and for\n+\t     definitions also function body.  */\n+\t  if (node->definition)\n+\t    simd_clone_adjust (n);\n+\t  else\n+\t    {\n+\t      simd_clone_adjust_return_type (n);\n+\t      simd_clone_adjust_argument_types (n);\n+\t    }\n+\t}\n+    }\n+  while ((attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr))));\n+}\n+\n+/* Entry point for IPA simd clone creation pass.  */\n+\n+static unsigned int\n+ipa_omp_simd_clone (void)\n+{\n+  struct cgraph_node *node;\n+  FOR_EACH_FUNCTION (node)\n+    expand_simd_clones (node);\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_omp_simd_clone =\n+{\n+  SIMPLE_IPA_PASS,\t\t/* type */\n+  \"simdclone\",\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t/* optinfo_flags */\n+  TV_NONE,\t\t\t/* tv_id */\n+  ( PROP_ssa | PROP_cfg ),\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_omp_simd_clone : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_omp_simd_clone(gcc::context *ctxt)\n+    : simple_ipa_opt_pass(pass_data_omp_simd_clone, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *) { return ipa_omp_simd_clone (); }\n+};\n+\n+bool\n+pass_omp_simd_clone::gate (function *)\n+{\n+  return targetm.simd_clone.compute_vecsize_and_simdlen != NULL;\n+}\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_omp_simd_clone (gcc::context *ctxt)\n+{\n+  return new pass_omp_simd_clone (ctxt);\n+}"}]}