{"sha": "481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxZjgzYzc4YjQxMWQ4YTk5NGEzY2NkZTU2Y2U0ZGQ0MWQ5Y2MwNQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@linux-m68k.org", "date": "2012-09-30T17:29:16Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2012-09-30T17:29:16Z"}, "message": "m68k.md: Add names to bitfield insert and extract insns.\n\n* config/m68k/m68k.md: Add names to bitfield insert and extract\ninsns.\n(*insv_8_16_reg): Remove constraints and conditions that assume\nthat operand 0 could be a MEM.\n(*extzv_8_16_reg, *extv_8_16_reg): Likewise, for operand 1.\n\nFrom-SVN: r191872", "tree": {"sha": "c06ba559d6a1c5e89873c542340d7894fe59587e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c06ba559d6a1c5e89873c542340d7894fe59587e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481f83c78b411d8a994a3ccde56ce4dd41d9cc05/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd81b13c3bf90cb49215685275985cd2b42eafec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd81b13c3bf90cb49215685275985cd2b42eafec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd81b13c3bf90cb49215685275985cd2b42eafec"}], "stats": {"total": 110, "additions": 39, "deletions": 71}, "files": [{"sha": "79160b66f7727a072ed06fdde413894b282601e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481f83c78b411d8a994a3ccde56ce4dd41d9cc05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481f83c78b411d8a994a3ccde56ce4dd41d9cc05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "patch": "@@ -1,3 +1,11 @@\n+2012-09-30  Andreas Schwab  <schwab@linux-m68k.org>\n+\n+\t* config/m68k/m68k.md: Add names to bitfield insert and extract\n+\tinsns.\n+\t(*insv_8_16_reg): Remove constraints and conditions that assume\n+\tthat operand 0 could be a MEM.\n+\t(*extzv_8_16_reg, *extv_8_16_reg): Likewise, for operand 1.\n+\n 2012-09-30  Jan Hubicka  <jh@suse.cz>\n \n \t* cfgloop.c (scale_loop_profile): Move to..."}, {"sha": "31be33edeb14749b09acfdc7fb4d0262aa2c9f2c", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 31, "deletions": 71, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/481f83c78b411d8a994a3ccde56ce4dd41d9cc05/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/481f83c78b411d8a994a3ccde56ce4dd41d9cc05/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=481f83c78b411d8a994a3ccde56ce4dd41d9cc05", "patch": "@@ -5603,7 +5603,7 @@\n ; The move is allowed to be odd byte aligned, because that's still faster\n ; than an odd byte aligned bit-field instruction.\n ;\n-(define_insn \"\"\n+(define_insn \"*insv_32_mem\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (const_int 32)\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n@@ -5619,32 +5619,17 @@\n   return \"move%.l %2,%0\";\n })\n \n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+do\")\n+(define_insn \"*insv_8_16_reg\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t(match_operand:SI 3 \"register_operand\" \"d\"))]\n   \"TARGET_68020 && TARGET_BITFIELD\n    && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n-   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n-   && (GET_CODE (operands[0]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[0], 0),\n-                                      MEM_ADDR_SPACE (operands[0])))\"\n+   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\"\n {\n-  if (REG_P (operands[0]))\n-    {\n-      if (INTVAL (operands[1]) + INTVAL (operands[2]) != 32)\n-        return \"bfins %3,%0{%b2:%b1}\";\n-    }\n-  else\n-    operands[0] = adjust_address (operands[0],\n-\t\t\t\t  INTVAL (operands[1]) == 8 ? QImode : HImode,\n-\t\t\t\t  INTVAL (operands[2]) / 8);\n-\n-  if (GET_CODE (operands[3]) == MEM)\n-    operands[3] = adjust_address (operands[3],\n-\t\t\t\t  INTVAL (operands[1]) == 8 ? QImode : HImode,\n-\t\t\t\t  (32 - INTVAL (operands[1])) / 8);\n+  if (INTVAL (operands[1]) + INTVAL (operands[2]) != 32)\n+    return \"bfins %3,%0{%b2:%b1}\";\n \n   if (INTVAL (operands[1]) == 8)\n     return \"move%.b %3,%0\";\n@@ -5659,7 +5644,7 @@\n ; The move is allowed to be odd byte aligned, because that's still faster\n ; than an odd byte aligned bit-field instruction.\n ;\n-(define_insn \"\"\n+(define_insn \"*extzv_32_mem\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(zero_extract:SI (match_operand:QI 1 \"memory_src_operand\" \"oS\")\n \t\t\t (const_int 32)\n@@ -5675,34 +5660,20 @@\n   return \"move%.l %1,%0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*extzv_8_16_reg\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&d\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"do\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[1], 0),\n-                                      MEM_ADDR_SPACE (operands[1])))\"\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n {\n   cc_status.flags |= CC_NOT_NEGATIVE;\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \"bfextu %1{%b3:%b2},%0\";\n-    }\n-  else\n-    operands[1]\n-      = adjust_address (operands[1], SImode, INTVAL (operands[3]) / 8);\n+  if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n+    return \"bfextu %1{%b3:%b2},%0\";\n \n   output_asm_insn (\"clr%.l %0\", operands);\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[0] = adjust_address (operands[0],\n-\t\t\t\t  INTVAL (operands[2]) == 8 ? QImode : HImode,\n-\t\t\t\t  (32 - INTVAL (operands[1])) / 8);\n-\n   if (INTVAL (operands[2]) == 8)\n     return \"move%.b %1,%0\";\n   return \"move%.w %1,%0\";\n@@ -5715,7 +5686,7 @@\n ; The move is allowed to be odd byte aligned, because that's still faster\n ; than an odd byte aligned bit-field instruction.\n ;\n-(define_insn \"\"\n+(define_insn \"*extv_32_mem\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(sign_extract:SI (match_operand:QI 1 \"memory_src_operand\" \"oS\")\n \t\t\t (const_int 32)\n@@ -5731,28 +5702,17 @@\n   return \"move%.l %1,%0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*extv_8_16_reg\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"do\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\n    && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[1], 0),\n-                                      MEM_ADDR_SPACE (operands[1])))\"\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n {\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \"bfexts %1{%b3:%b2},%0\";\n-    }\n-  else\n-    operands[1]\n-      = adjust_address (operands[1],\n-\t\t\tINTVAL (operands[2]) == 8 ? QImode : HImode,\n-\t\t\tINTVAL (operands[3]) / 8);\n+  if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n+    return \"bfexts %1{%b3:%b2},%0\";\n \n   if (INTVAL (operands[2]) == 8)\n     return \"move%.b %1,%0\\;extb%.l %0\";\n@@ -5771,7 +5731,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*extv_bfexts_mem\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\")\n@@ -5787,7 +5747,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*extzv_bfextu_mem\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\")\n@@ -5806,7 +5766,7 @@\n   return \"bfextu %1{%b3:%b2},%0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfchg_mem\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"dn\")\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\"))\n@@ -5821,7 +5781,7 @@\n   return \"bfchg %0{%b2:%b1}\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfclr_mem\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"dn\")\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\"))\n@@ -5832,7 +5792,7 @@\n   return \"bfclr %0{%b2:%b1}\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfset_mem\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (match_operand:SI 1 \"general_operand\" \"dn\")\n \t\t\t (match_operand:SI 2 \"general_operand\" \"dn\"))\n@@ -5851,7 +5811,7 @@\n   \"TARGET_68020 && TARGET_BITFIELD\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfins_mem\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"dn\")\n \t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dn\"))\n@@ -5862,15 +5822,15 @@\n ;; Now recognize bit-field insns that operate on registers\n ;; (or at least were intended to do so).\n \n-(define_insn \"\"\n+(define_insn \"*extv_bfexts_reg\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\"\n   \"bfexts %1{%b3:%b2},%0\")\n \n-(define_insn \"\"\n+(define_insn \"*extv_bfextu_reg\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n@@ -5889,7 +5849,7 @@\n   return \"bfextu %1{%b3:%b2},%0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfclr_reg\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n@@ -5900,7 +5860,7 @@\n   return \"bfclr %0{%b2:%b1}\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfset_reg\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n@@ -5911,7 +5871,7 @@\n   return \"bfset %0{%b2:%b1}\";\n })\n \n-(define_insn \"\"\n+(define_insn \"*insv_bfins_reg\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n@@ -5932,7 +5892,7 @@\n \f\n ;; Special patterns for optimizing bit-field instructions.\n \n-(define_insn \"\"\n+(define_insn \"*tst_bftst_mem\"\n   [(set (cc0)\n \t(compare (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n \t\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n\")\n@@ -5958,7 +5918,7 @@\n \n \n ;;; now handle the register cases\n-(define_insn \"\"\n+(define_insn \"*tst_bftst_reg\"\n   [(set (cc0)\n \t(compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n \t\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n\")"}]}