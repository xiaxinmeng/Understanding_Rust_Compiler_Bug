{"sha": "5e8586d720eb9481a09cbe07eb40590fbc86c89f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4NTg2ZDcyMGViOTQ4MWEwOWNiZTA3ZWI0MDU5MGZiYzg2Yzg5Zg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-09-23T21:13:38Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-09-23T21:13:38Z"}, "message": "rs6000.h (enum r6000_reg_class_enum): Add new constraints: wu, ww, and wy.\n\n2013-09-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add new\n\tconstraints: wu, ww, and wy.  Repurpose wv constraint added during\n\tpower8 changes.  Put wg constraint in alphabetical order.\n\n\t* config/rs6000/rs6000.opt (-mvsx-scalar-float): New debug switch\n\tfor future work to add ISA 2.07 VSX single precision support.\n\t(-mvsx-scalar-double): Change default from -1 to 1, update\n\tdocumentation comment.\n\t(-mvsx-scalar-memory): Rename debug switch to -mupper-regs-df.\n\t(-mupper-regs-df): New debug switch to control whether DF values\n\tcan go in the traditional Altivec registers.\n\t(-mupper-regs-sf): New debug switch to control whether SF values\n\tcan go in the traditional Altivec registers.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print wu, ww,\n\tand wy constraints.\n\t(rs6000_init_hard_regno_mode_ok): Use ssize_t instead of int for\n\tloop variables.  Rename -mvsx-scalar-memory to -mupper-regs-df.\n\tAdd new constraints, wu/ww/wy.  Repurpose wv constraint.\n\t(rs6000_debug_legitimate_address_p): Print if we are running\n\tbefore, during, or after reload.\n\t(rs6000_secondary_reload): Add a comment.\n\t(rs6000_opt_masks): Add -mupper-regs-df, -mupper-regs-sf.\n\n\t* config/rs6000/constraints.md (wa constraint): Sort w<x>\n\tconstraints.  Update documentation string.\n\t(wd constraint): Likewise.\n\t(wf constraint): Likewise.\n\t(wg constraint): Likewise.\n\t(wn constraint): Likewise.\n\t(ws constraint): Likewise.\n\t(wt constraint): Likewise.\n\t(wx constraint): Likewise.\n\t(wz constraint): Likewise.\n\t(wu constraint): New constraint for ISA 2.07 SFmode scalar\n\tinstructions.\n\t(ww constraint): Likewise.\n\t(wy constraint): Likewise.\n\t(wv constraint): Repurpose ISA 2.07 constraint that we not used in\n\tthe previous submissions.\n\t* doc/md.texi (PowerPC and IBM RS6000): Likewise.\n\nFrom-SVN: r202843", "tree": {"sha": "5d4e03818757bf826a6a4474a16a25e8b162cd25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d4e03818757bf826a6a4474a16a25e8b162cd25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e8586d720eb9481a09cbe07eb40590fbc86c89f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8586d720eb9481a09cbe07eb40590fbc86c89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8586d720eb9481a09cbe07eb40590fbc86c89f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8586d720eb9481a09cbe07eb40590fbc86c89f/comments", "author": null, "committer": null, "parents": [{"sha": "e5af9ddd011d07b38554d4f794470082ce5b13e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5af9ddd011d07b38554d4f794470082ce5b13e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5af9ddd011d07b38554d4f794470082ce5b13e6"}], "stats": {"total": 233, "additions": 175, "deletions": 58}, "files": [{"sha": "8865ceac67be9b2bbf52e921536208b6e1a1effd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -1,3 +1,47 @@\n+2013-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add new\n+\tconstraints: wu, ww, and wy.  Repurpose wv constraint added during\n+\tpower8 changes.  Put wg constraint in alphabetical order.\n+\n+\t* config/rs6000/rs6000.opt (-mvsx-scalar-float): New debug switch\n+\tfor future work to add ISA 2.07 VSX single precision support.\n+\t(-mvsx-scalar-double): Change default from -1 to 1, update\n+\tdocumentation comment.\n+\t(-mvsx-scalar-memory): Rename debug switch to -mupper-regs-df.\n+\t(-mupper-regs-df): New debug switch to control whether DF values\n+\tcan go in the traditional Altivec registers.\n+\t(-mupper-regs-sf): New debug switch to control whether SF values\n+\tcan go in the traditional Altivec registers.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Print wu, ww,\n+\tand wy constraints.\n+\t(rs6000_init_hard_regno_mode_ok): Use ssize_t instead of int for\n+\tloop variables.  Rename -mvsx-scalar-memory to -mupper-regs-df.\n+\tAdd new constraints, wu/ww/wy.  Repurpose wv constraint.\n+\t(rs6000_debug_legitimate_address_p): Print if we are running\n+\tbefore, during, or after reload.\n+\t(rs6000_secondary_reload): Add a comment.\n+\t(rs6000_opt_masks): Add -mupper-regs-df, -mupper-regs-sf.\n+\n+\t* config/rs6000/constraints.md (wa constraint): Sort w<x>\n+\tconstraints.  Update documentation string.\n+\t(wd constraint): Likewise.\n+\t(wf constraint): Likewise.\n+\t(wg constraint): Likewise.\n+\t(wn constraint): Likewise.\n+\t(ws constraint): Likewise.\n+\t(wt constraint): Likewise.\n+\t(wx constraint): Likewise.\n+\t(wz constraint): Likewise.\n+\t(wu constraint): New constraint for ISA 2.07 SFmode scalar\n+\tinstructions.\n+\t(ww constraint): Likewise.\n+\t(wy constraint): Likewise.\n+\t(wv constraint): Repurpose ISA 2.07 constraint that we not used in\n+\tthe previous submissions.\n+\t* doc/md.texi (PowerPC and IBM RS6000): Likewise.\n+\n 2013-09-23  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* doc/rtl.texi (REG_NOTES): Say that int_list can also be used."}, {"sha": "4467b9e3d8bfb64fa3e8f5ef6af82044d4a81930", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -52,53 +52,57 @@\n   \"@internal\")\n \n ;; Use w as a prefix to add VSX modes\n-;; vector double (V2DF)\n+;; any VSX register\n+(define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n+  \"Any VSX register if the -mvsx option was used or NO_REGS.\")\n+\n (define_register_constraint \"wd\" \"rs6000_constraints[RS6000_CONSTRAINT_wd]\"\n-  \"@internal\")\n+  \"VSX vector register to hold vector double data or NO_REGS.\")\n \n-;; vector float (V4SF)\n (define_register_constraint \"wf\" \"rs6000_constraints[RS6000_CONSTRAINT_wf]\"\n-  \"@internal\")\n-\n-;; scalar double (DF)\n-(define_register_constraint \"ws\" \"rs6000_constraints[RS6000_CONSTRAINT_ws]\"\n-  \"@internal\")\n-\n-;; TImode in VSX registers\n-(define_register_constraint \"wt\" \"rs6000_constraints[RS6000_CONSTRAINT_wt]\"\n-  \"@internal\")\n-\n-;; any VSX register\n-(define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n-  \"@internal\")\n+  \"VSX vector register to hold vector float data or NO_REGS.\")\n \n-;; Register constraints to simplify move patterns\n (define_register_constraint \"wg\" \"rs6000_constraints[RS6000_CONSTRAINT_wg]\"\n-  \"Floating point register if -mmfpgpr is used, or NO_REGS.\")\n+  \"If -mmfpgpr was used, a floating point register or NO_REGS.\")\n \n (define_register_constraint \"wl\" \"rs6000_constraints[RS6000_CONSTRAINT_wl]\"\n   \"Floating point register if the LFIWAX instruction is enabled or NO_REGS.\")\n \n (define_register_constraint \"wm\" \"rs6000_constraints[RS6000_CONSTRAINT_wm]\"\n   \"VSX register if direct move instructions are enabled, or NO_REGS.\")\n \n+;; NO_REGs register constraint, used to merge mov{sd,sf}, since movsd can use\n+;; direct move directly, and movsf can't to move between the register sets.\n+;; There is a mode_attr that resolves to wm for SDmode and wn for SFmode\n+(define_register_constraint \"wn\" \"NO_REGS\" \"No register (NO_REGS).\")\n+\n (define_register_constraint \"wr\" \"rs6000_constraints[RS6000_CONSTRAINT_wr]\"\n   \"General purpose register if 64-bit instructions are enabled or NO_REGS.\")\n \n+(define_register_constraint \"ws\" \"rs6000_constraints[RS6000_CONSTRAINT_ws]\"\n+  \"VSX vector register to hold scalar double values or NO_REGS.\")\n+\n+(define_register_constraint \"wt\" \"rs6000_constraints[RS6000_CONSTRAINT_wt]\"\n+  \"VSX vector register to hold 128 bit integer or NO_REGS.\")\n+\n+(define_register_constraint \"wu\" \"rs6000_constraints[RS6000_CONSTRAINT_wu]\"\n+  \"Altivec register to use for float/32-bit int loads/stores  or NO_REGS.\")\n+\n (define_register_constraint \"wv\" \"rs6000_constraints[RS6000_CONSTRAINT_wv]\"\n-  \"Altivec register if -mpower8-vector is used or NO_REGS.\")\n+  \"Altivec register to use for double loads/stores  or NO_REGS.\")\n+\n+(define_register_constraint \"ww\" \"rs6000_constraints[RS6000_CONSTRAINT_ww]\"\n+  \"FP or VSX register to perform float operations under -mvsx or NO_REGS.\")\n \n (define_register_constraint \"wx\" \"rs6000_constraints[RS6000_CONSTRAINT_wx]\"\n   \"Floating point register if the STFIWX instruction is enabled or NO_REGS.\")\n \n+(define_register_constraint \"wy\" \"rs6000_constraints[RS6000_CONSTRAINT_wy]\"\n+  \"VSX vector register to hold scalar float values or NO_REGS.\")\n+\n (define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n   \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")\n \n-;; NO_REGs register constraint, used to merge mov{sd,sf}, since movsd can use\n-;; direct move directly, and movsf can't to move between the register sets.\n-;; There is a mode_attr that resolves to wm for SDmode and wn for SFmode\n-(define_register_constraint \"wn\" \"NO_REGS\")\n-\n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n   \"Memory operand suitable for the load/store quad instructions\""}, {"sha": "9a335ea91670fd40ff787d627471165702dceb84", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -1891,8 +1891,11 @@ rs6000_debug_reg_global (void)\n \t   \"wr reg_class = %s\\n\"\n \t   \"ws reg_class = %s\\n\"\n \t   \"wt reg_class = %s\\n\"\n+\t   \"wu reg_class = %s\\n\"\n \t   \"wv reg_class = %s\\n\"\n+\t   \"ww reg_class = %s\\n\"\n \t   \"wx reg_class = %s\\n\"\n+\t   \"wy reg_class = %s\\n\"\n \t   \"wz reg_class = %s\\n\"\n \t   \"\\n\",\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_d]],\n@@ -1907,8 +1910,11 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ws]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wt]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wu]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wv]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_ww]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wx]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wy]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wz]]);\n \n   for (m = 0; m < NUM_MACHINE_MODES; ++m)\n@@ -2168,7 +2174,7 @@ rs6000_debug_reg_global (void)\n static void\n rs6000_init_hard_regno_mode_ok (bool global_init_p)\n {\n-  int r, m, c;\n+  ssize_t r, m, c;\n   int align64;\n   int align32;\n \n@@ -2320,7 +2326,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n     {\n       rs6000_vector_unit[DFmode] = VECTOR_VSX;\n       rs6000_vector_mem[DFmode]\n-\t= (TARGET_VSX_SCALAR_MEMORY ? VECTOR_VSX : VECTOR_NONE);\n+\t= (TARGET_UPPER_REGS_DF ? VECTOR_VSX : VECTOR_NONE);\n       rs6000_vector_align[DFmode] = align64;\n     }\n \n@@ -2334,7 +2340,34 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   /* TODO add SPE and paired floating point vector support.  */\n \n   /* Register class constraints for the constraints that depend on compile\n-     switches.  */\n+     switches. When the VSX code was added, different constraints were added\n+     based on the type (DFmode, V2DFmode, V4SFmode).  For the vector types, all\n+     of the VSX registers are used.  The register classes for scalar floating\n+     point types is set, based on whether we allow that type into the upper\n+     (Altivec) registers.  GCC has register classes to target the Altivec\n+     registers for load/store operations, to select using a VSX memory\n+     operation instead of the traditional floating point operation.  The\n+     constraints are:\n+\n+\td  - Register class to use with traditional DFmode instructions.\n+\tf  - Register class to use with traditional SFmode instructions.\n+\tv  - Altivec register.\n+\twa - Any VSX register.\n+\twd - Preferred register class for V2DFmode.\n+\twf - Preferred register class for V4SFmode.\n+\twg - Float register for power6x move insns.\n+\twl - Float register if we can do 32-bit signed int loads.\n+\twm - VSX register for ISA 2.07 direct move operations.\n+\twr - GPR if 64-bit mode is permitted.\n+\tws - Register class to do ISA 2.06 DF operations.\n+\twu - Altivec register for ISA 2.07 VSX SF/SI load/stores.\n+\twv - Altivec register for ISA 2.06 VSX DF/DI load/stores.\n+\twt - VSX register for TImode in VSX registers.\n+\tww - Register class to do SF conversions in with VSX operations.\n+\twx - Float register if we can do 32-bit int stores.\n+\twy - Register class to do ISA 2.07 SF operations.\n+\twz - Float register if we can do 32-bit unsigned int loads.  */\n+\n   if (TARGET_HARD_FLOAT && TARGET_FPRS)\n     rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\n \n@@ -2343,19 +2376,16 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n   if (TARGET_VSX)\n     {\n-      /* At present, we just use VSX_REGS, but we have different constraints\n-\t based on the use, in case we want to fine tune the default register\n-\t class used.  wa = any VSX register, wf = register class to use for\n-\t V4SF, wd = register class to use for V2DF, and ws = register classs to\n-\t use for DF scalars.  */\n       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_ws] = (TARGET_VSX_SCALAR_MEMORY\n-\t\t\t\t\t\t  ? VSX_REGS\n-\t\t\t\t\t\t  : FLOAT_REGS);\n+      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n+\n       if (TARGET_VSX_TIMODE)\n \trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\n+\n+      rs6000_constraints[RS6000_CONSTRAINT_ws]\n+\t= (TARGET_UPPER_REGS_DF) ? VSX_REGS : FLOAT_REGS;\n     }\n \n   /* Add conditional constraints based on various options, to allow us to\n@@ -2376,7 +2406,14 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n     rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;\n \n   if (TARGET_P8_VECTOR)\n-    rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wy]\n+\t= rs6000_constraints[RS6000_CONSTRAINT_ww]\n+\t= (TARGET_UPPER_REGS_SF) ? VSX_REGS : FLOAT_REGS;\n+    }\n+  else if (TARGET_VSX)\n+    rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;\n \n   if (TARGET_STFIWX)\n     rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;\n@@ -2409,7 +2446,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  rs6000_vector_reload[V4SFmode][1]  = CODE_FOR_reload_v4sf_di_load;\n \t  rs6000_vector_reload[V2DFmode][0]  = CODE_FOR_reload_v2df_di_store;\n \t  rs6000_vector_reload[V2DFmode][1]  = CODE_FOR_reload_v2df_di_load;\n-\t  if (TARGET_VSX && TARGET_VSX_SCALAR_MEMORY)\n+\t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n \t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_di_store;\n \t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_di_load;\n@@ -2472,7 +2509,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  rs6000_vector_reload[V4SFmode][1]  = CODE_FOR_reload_v4sf_si_load;\n \t  rs6000_vector_reload[V2DFmode][0]  = CODE_FOR_reload_v2df_si_store;\n \t  rs6000_vector_reload[V2DFmode][1]  = CODE_FOR_reload_v2df_si_load;\n-\t  if (TARGET_VSX && TARGET_VSX_SCALAR_MEMORY)\n+\t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n \t      rs6000_vector_reload[DFmode][0]  = CODE_FOR_reload_df_si_store;\n \t      rs6000_vector_reload[DFmode][1]  = CODE_FOR_reload_df_si_load;\n@@ -7195,10 +7232,13 @@ rs6000_debug_legitimate_address_p (enum machine_mode mode, rtx x,\n   bool ret = rs6000_legitimate_address_p (mode, x, reg_ok_strict);\n   fprintf (stderr,\n \t   \"\\nrs6000_legitimate_address_p: return = %s, mode = %s, \"\n-\t   \"strict = %d, code = %s\\n\",\n+\t   \"strict = %d, reload = %s, code = %s\\n\",\n \t   ret ? \"true\" : \"false\",\n \t   GET_MODE_NAME (mode),\n \t   reg_ok_strict,\n+\t   (reload_completed\n+\t    ? \"after\"\n+\t    : (reload_in_progress ? \"progress\" : \"before\")),\n \t   GET_RTX_NAME (GET_CODE (x)));\n   debug_rtx (x);\n \n@@ -14865,6 +14905,7 @@ rs6000_secondary_reload (bool in_p,\n \t  from_type = exchange;\n \t}\n \n+      /* Can we do a direct move of some sort?  */\n       if (rs6000_secondary_reload_move (to_type, from_type, mode, sri,\n \t\t\t\t\taltivec_p))\n \t{\n@@ -29162,6 +29203,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"recip-precision\",\t\tOPTION_MASK_RECIP_PRECISION,\tfalse, true  },\n   { \"string\",\t\t\tOPTION_MASK_STRING,\t\tfalse, true  },\n   { \"update\",\t\t\tOPTION_MASK_NO_UPDATE,\t\ttrue , true  },\n+  { \"upper-regs-df\",\t\tOPTION_MASK_UPPER_REGS_DF,\tfalse, false },\n+  { \"upper-regs-sf\",\t\tOPTION_MASK_UPPER_REGS_SF,\tfalse, false },\n   { \"vsx\",\t\t\tOPTION_MASK_VSX,\t\tfalse, true  },\n   { \"vsx-timode\",\t\tOPTION_MASK_VSX_TIMODE,\t\tfalse, true  },\n #ifdef OPTION_MASK_64BIT"}, {"sha": "34647033b8ab2e714e95bc4d236240d2565b6f74", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -1403,15 +1403,18 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_v,\t\t/* Altivec registers */\n   RS6000_CONSTRAINT_wa,\t\t/* Any VSX register */\n   RS6000_CONSTRAINT_wd,\t\t/* VSX register for V2DF */\n-  RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */\n+  RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n   RS6000_CONSTRAINT_wl,\t\t/* FPR register for LFIWAX */\n   RS6000_CONSTRAINT_wm,\t\t/* VSX register for direct move */\n   RS6000_CONSTRAINT_wr,\t\t/* GPR register if 64-bit  */\n   RS6000_CONSTRAINT_ws,\t\t/* VSX register for DF */\n   RS6000_CONSTRAINT_wt,\t\t/* VSX register for TImode */\n-  RS6000_CONSTRAINT_wv,\t\t/* Altivec register for power8 vector */\n+  RS6000_CONSTRAINT_wu,\t\t/* Altivec register for float load/stores.  */\n+  RS6000_CONSTRAINT_wv,\t\t/* Altivec register for double load/stores.  */\n+  RS6000_CONSTRAINT_ww,\t\t/* FP or VSX register for vsx float ops.  */\n   RS6000_CONSTRAINT_wx,\t\t/* FPR register for STFIWX */\n+  RS6000_CONSTRAINT_wy,\t\t/* VSX register for SF */\n   RS6000_CONSTRAINT_wz,\t\t/* FPR register for LFIWZX */\n   RS6000_CONSTRAINT_MAX\n };"}, {"sha": "eae75f57680153cbb1cc39c542a5d44def52375d", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -181,13 +181,16 @@ mvsx\n Target Report Mask(VSX) Var(rs6000_isa_flags)\n Use vector/scalar (VSX) instructions\n \n+mvsx-scalar-float\n+Target Undocumented Report Var(TARGET_VSX_SCALAR_FLOAT) Init(1)\n+; If -mpower8-vector, use VSX arithmetic instructions for SFmode (on by default)\n+\n mvsx-scalar-double\n-Target Undocumented Report Var(TARGET_VSX_SCALAR_DOUBLE) Init(-1)\n-; If -mvsx, use VSX arithmetic instructions for scalar double (on by default)\n+Target Undocumented Report Var(TARGET_VSX_SCALAR_DOUBLE) Init(1)\n+; If -mvsx, use VSX arithmetic instructions for DFmode (on by default)\n \n mvsx-scalar-memory\n-Target Undocumented Report Var(TARGET_VSX_SCALAR_MEMORY)\n-; If -mvsx, use VSX scalar memory reference instructions for scalar double (off by default)\n+Target Undocumented Report Alias(mupper-regs-df)\n \n mvsx-align-128\n Target Undocumented Report Var(TARGET_VSX_ALIGN_128)\n@@ -550,3 +553,11 @@ Generate the quad word memory instructions (lq/stq/lqarx/stqcx).\n mcompat-align-parm\n Target Report Var(rs6000_compat_align_parm) Init(0) Save\n Generate aggregate parameter passing code with at most 64-bit alignment.\n+\n+mupper-regs-df\n+Target Undocumented Mask(UPPER_REGS_DF) Var(rs6000_isa_flags)\n+Allow double variables in upper registers with -mcpu=power7 or -mvsx\n+\n+mupper-regs-sf\n+Target Undocumented Mask(UPPER_REGS_SF) Var(rs6000_isa_flags)\n+Allow float variables in upper registers with -mcpu=power8 or -mp8-vector"}, {"sha": "45ea45a4fe89f04e718734e3669a9fbefb31d7b8", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8586d720eb9481a09cbe07eb40590fbc86c89f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=5e8586d720eb9481a09cbe07eb40590fbc86c89f", "patch": "@@ -2067,40 +2067,52 @@ Floating point register (containing 32-bit value)\n Altivec vector register\n \n @item wa\n-Any VSX register\n+Any VSX register if the -mvsx option was used or NO_REGS.\n \n @item wd\n-VSX vector register to hold vector double data\n+VSX vector register to hold vector double data or NO_REGS.\n \n @item wf\n-VSX vector register to hold vector float data\n+VSX vector register to hold vector float data or NO_REGS.\n \n @item wg\n-If @option{-mmfpgpr} was used, a floating point register\n+If @option{-mmfpgpr} was used, a floating point register or NO_REGS.\n \n @item wl\n-If the LFIWAX instruction is enabled, a floating point register\n+Floating point register if the LFIWAX instruction is enabled or NO_REGS.\n \n @item wm\n-If direct moves are enabled, a VSX register.\n+VSX register if direct move instructions are enabled, or NO_REGS.\n \n @item wn\n-No register.\n+No register (NO_REGS).\n \n @item wr\n-General purpose register if 64-bit mode is used\n+General purpose register if 64-bit instructions are enabled or NO_REGS.\n \n @item ws\n-VSX vector register to hold scalar float data\n+VSX vector register to hold scalar double values or NO_REGS.\n \n @item wt\n-VSX vector register to hold 128 bit integer\n+VSX vector register to hold 128 bit integer or NO_REGS.\n+\n+@item wu\n+Altivec register to use for float/32-bit int loads/stores  or NO_REGS.\n+\n+@item wv\n+Altivec register to use for double loads/stores  or NO_REGS.\n+\n+@item ww\n+FP or VSX register to perform float operations under @option{-mvsx} or NO_REGS.\n \n @item wx\n-If the STFIWX instruction is enabled, a floating point register\n+Floating point register if the STFIWX instruction is enabled or NO_REGS.\n+\n+@item wy\n+VSX vector register to hold scalar float values or NO_REGS.\n \n @item wz\n-If the LFIWZX instruction is enabled, a floating point register\n+Floating point register if the LFIWZX instruction is enabled or NO_REGS.\n \n @item wQ\n A memory address that will work with the @code{lq} and @code{stq}"}]}