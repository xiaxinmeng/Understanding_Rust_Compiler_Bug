{"sha": "0e41a941ee11651b5805c730d2675902d64577aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU0MWE5NDFlZTExNjUxYjU4MDVjNzMwZDI2NzU5MDJkNjQ1NzdhYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T12:17:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T12:17:53Z"}, "message": "[multiple changes]\n\n2009-07-13  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-err.adb (Error_Msg): One more case where a message should be\n\tconsidered as a warning.\n\n\t* gnatcmd.adb (GNATCmd): Fix previous change, which negated a test.\n\n2009-07-13  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb (Expand_All_Calls_Remote_Subprogram_Call): Analyze\n\tcalling stubs in the (library level) scope of the RCI locator, where it\n\tis attached, not in the caller's scope.\n\n2009-07-13  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): In case of class-wide\n\tinterface object declarations we delay the generation of the equivalent\n\trecord type declarations until its expansion because there are cases in\n\twhich they are not required.            \n\n\t* sem_util.adb (Implements_Interface): Add missing support for subtypes.\n\n\t* sem_disp.adb (Check_Controlling_Formals): Minor code cleanup plus\n\taddition of assertion.\n\n\t* exp_util.adb (Expand_Subtype_From_Expr): Renamings of class-wide\n\tinterface types require no equivalent constrained type declarations\n\tbecause the expanded code only references the tag component associated\n\twith the interface.\n\t(Find_Interface_Tag): Improve management of interfaces that are\n\tancestors of tagged types.\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Improve the expansion of\n\tclass-wide object declarations to add missing support to statically\n\tdisplace the pointer to the object to reference the tag component\n\tassociated with the interface.\n\n\t* exp_disp.adb (Make_Tags) Avoid generation of internally generated\n\tauxiliary types associated with user-defined dispatching calls if the\n\ttype has no user-defined primitives.\n\nFrom-SVN: r149574", "tree": {"sha": "85a56e9c3d5c1469ea1e28e6aab324892ec6a178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a56e9c3d5c1469ea1e28e6aab324892ec6a178"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e41a941ee11651b5805c730d2675902d64577aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e41a941ee11651b5805c730d2675902d64577aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e41a941ee11651b5805c730d2675902d64577aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e41a941ee11651b5805c730d2675902d64577aa/comments", "author": null, "committer": null, "parents": [{"sha": "75069667df1ed5fafbb9e1f4532adf1233b7eeab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75069667df1ed5fafbb9e1f4532adf1233b7eeab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75069667df1ed5fafbb9e1f4532adf1233b7eeab"}], "stats": {"total": 715, "additions": 420, "deletions": 295}, "files": [{"sha": "ac910fde2ea1c8afddec8c49a50cf04ebad1f25a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -1,3 +1,44 @@\n+2009-07-13  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-err.adb (Error_Msg): One more case where a message should be\n+\tconsidered as a warning.\n+\n+\t* gnatcmd.adb (GNATCmd): Fix previous change, which negated a test.\n+\n+2009-07-13  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_dist.adb (Expand_All_Calls_Remote_Subprogram_Call): Analyze\n+\tcalling stubs in the (library level) scope of the RCI locator, where it\n+\tis attached, not in the caller's scope.\n+\n+2009-07-13  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): In case of class-wide\n+\tinterface object declarations we delay the generation of the equivalent\n+\trecord type declarations until its expansion because there are cases in\n+\twhich they are not required.            \n+\n+\t* sem_util.adb (Implements_Interface): Add missing support for subtypes.\n+\n+\t* sem_disp.adb (Check_Controlling_Formals): Minor code cleanup plus\n+\taddition of assertion.\n+\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Renamings of class-wide\n+\tinterface types require no equivalent constrained type declarations\n+\tbecause the expanded code only references the tag component associated\n+\twith the interface.\n+\t(Find_Interface_Tag): Improve management of interfaces that are\n+\tancestors of tagged types.\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Improve the expansion of\n+\tclass-wide object declarations to add missing support to statically\n+\tdisplace the pointer to the object to reference the tag component\n+\tassociated with the interface.\n+\n+\t* exp_disp.adb (Make_Tags) Avoid generation of internally generated\n+\tauxiliary types associated with user-defined dispatching calls if the\n+\ttype has no user-defined primitives.\n+\n 2009-07-13  Vasiliy Fofanov  <fofanov@adacore.com>\n \n \t* mingw32.h: Make it explicit that we need XP or later."}, {"sha": "92bcc03bdabc23fbe89cfa2ebcacf3482c786577", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 190, "deletions": 113, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -4497,6 +4497,196 @@ package body Exp_Ch3 is\n \n             return;\n \n+         --  Ada 2005 (AI-251): Rewrite the expression that initializes a\n+         --  class-wide object to ensure that we copy the full object,\n+         --  unless we are targetting a VM where interfaces are handled by\n+         --  VM itself. Note that if the root type of Typ is an ancestor\n+         --  of Expr's type, both types share the same dispatch table and\n+         --  there is no need to displace the pointer.\n+\n+         elsif Comes_From_Source (N)\n+           and then Is_Interface (Typ)\n+         then\n+            pragma Assert (Is_Class_Wide_Type (Typ));\n+\n+            if Tagged_Type_Expansion then\n+               declare\n+                  Iface    : constant Entity_Id := Root_Type (Typ);\n+                  Expr_N   : Node_Id := Expr;\n+                  Expr_Typ : Entity_Id;\n+\n+                  Decl_1   : Node_Id;\n+                  Decl_2   : Node_Id;\n+                  New_Expr : Node_Id;\n+\n+               begin\n+                  --  If the original node of the expression was a conversion\n+                  --  to this specific class-wide interface type then we\n+                  --  restore the original node to generate code that\n+                  --  statically displaces the pointer to the interface\n+                  --  component.\n+\n+                  if not Comes_From_Source (Expr_N)\n+                    and then Nkind (Expr_N) = N_Unchecked_Type_Conversion\n+                    and then Nkind (Original_Node (Expr_N)) = N_Type_Conversion\n+                    and then Etype (Original_Node (Expr_N)) = Typ\n+                  then\n+                     Rewrite (Expr_N, Original_Node (Expression (N)));\n+                  end if;\n+\n+                  --  Avoid expansion of redundant interface conversion\n+\n+                  if Is_Interface (Etype (Expr_N))\n+                    and then Nkind (Expr_N) = N_Type_Conversion\n+                    and then Etype (Expr_N) = Typ\n+                  then\n+                     Expr_N := Expression (Expr_N);\n+                     Set_Expression (N, Expr_N);\n+                  end if;\n+\n+                  Expr_Typ := Base_Type (Etype (Expr_N));\n+\n+                  if Is_Class_Wide_Type (Expr_Typ) then\n+                     Expr_Typ := Root_Type (Expr_Typ);\n+                  end if;\n+\n+                  --  Replace\n+                  --     CW : I'Class := Obj;\n+                  --  by\n+                  --     Tmp : T := Obj;\n+                  --     CW  : I'Class renames TiC!(Tmp.I_Tag);\n+\n+                  if Comes_From_Source (Expr_N)\n+                    and then Nkind (Expr_N) = N_Identifier\n+                    and then not Is_Interface (Expr_Typ)\n+                    and then (Expr_Typ = Etype (Expr_Typ)\n+                               or else not\n+                              Is_Variable_Size_Record (Etype (Expr_Typ)))\n+                  then\n+                     Decl_1 :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier =>\n+                           Make_Defining_Identifier (Loc,\n+                             New_Internal_Name ('D')),\n+                         Object_Definition =>\n+                           New_Occurrence_Of (Expr_Typ, Loc),\n+                         Expression =>\n+                           Unchecked_Convert_To (Expr_Typ,\n+                             Relocate_Node (Expr_N)));\n+\n+                     --  Statically reference the tag associated with the\n+                     --  interface\n+\n+                     Decl_2 :=\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier =>\n+                           Make_Defining_Identifier (Loc,\n+                             New_Internal_Name ('D')),\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of (Typ, Loc),\n+                         Name =>\n+                           Unchecked_Convert_To (Typ,\n+                             Make_Selected_Component (Loc,\n+                               Prefix =>\n+                                 New_Occurrence_Of\n+                                   (Defining_Identifier (Decl_1), Loc),\n+                               Selector_Name =>\n+                                 New_Reference_To\n+                                   (Find_Interface_Tag (Expr_Typ, Iface),\n+                                    Loc))));\n+\n+                  --  General case:\n+\n+                  --  Replace\n+                  --     IW : I'Class := Obj;\n+                  --  by\n+                  --     type Equiv_Record is record ... end record;\n+                  --     implicit subtype CW is <Class_Wide_Subtype>;\n+                  --     Temp : CW := CW!(Obj'Address);\n+                  --     IW : I'Class renames Displace (Temp, I'Tag);\n+\n+                  else\n+                     --  Generate the equivalent record type\n+\n+                     Expand_Subtype_From_Expr\n+                       (N             => N,\n+                        Unc_Type      => Typ,\n+                        Subtype_Indic => Object_Definition (N),\n+                        Exp           => Expression (N));\n+\n+                     if not Is_Interface (Etype (Expression (N))) then\n+                        New_Expr := Relocate_Node (Expression (N));\n+                     else\n+                        New_Expr :=\n+                          Make_Explicit_Dereference (Loc,\n+                            Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix => Relocate_Node (Expression (N)),\n+                                Attribute_Name => Name_Address)));\n+                     end if;\n+\n+                     Decl_1 :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier =>\n+                           Make_Defining_Identifier (Loc,\n+                             New_Internal_Name ('D')),\n+                         Object_Definition =>\n+                           New_Occurrence_Of\n+                            (Etype (Object_Definition (N)), Loc),\n+                         Expression =>\n+                           Unchecked_Convert_To\n+                             (Etype (Object_Definition (N)), New_Expr));\n+\n+                     Decl_2 :=\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier =>\n+                           Make_Defining_Identifier (Loc,\n+                             New_Internal_Name ('D')),\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of (Typ, Loc),\n+                         Name =>\n+                           Unchecked_Convert_To (Typ,\n+                             Make_Explicit_Dereference (Loc,\n+                               Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                                 Make_Function_Call (Loc,\n+                                   Name =>\n+                                     New_Reference_To (RTE (RE_Displace), Loc),\n+                                   Parameter_Associations => New_List (\n+                                     Make_Attribute_Reference (Loc,\n+                                       Prefix =>\n+                                         New_Occurrence_Of\n+                                          (Defining_Identifier (Decl_1), Loc),\n+                                       Attribute_Name => Name_Address),\n+\n+                                     Unchecked_Convert_To (RTE (RE_Tag),\n+                                       New_Reference_To\n+                                         (Node\n+                                           (First_Elmt\n+                                             (Access_Disp_Table (Iface))),\n+                                          Loc))))))));\n+                  end if;\n+\n+                  Insert_Action (N, Decl_1);\n+                  Rewrite (N, Decl_2);\n+                  Analyze (N);\n+\n+                  --  Replace internal identifier of Decl_2 by the identifier\n+                  --  found in the sources. We also have to exchange entities\n+                  --  containing their defining identifiers to ensure the\n+                  --  correct replacement of the object declaration by this\n+                  --  object renaming declaration (because such definings\n+                  --  identifier have been previously added by Enter_Name to\n+                  --  the current scope). We must preserve the homonym chain\n+                  --  of the source entity as well.\n+\n+                  Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n+                  Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));\n+                  Exchange_Entities (Defining_Identifier (N), Def_Id);\n+               end;\n+            end if;\n+\n+            return;\n+\n          else\n             --  In most cases, we must check that the initial value meets any\n             --  constraint imposed by the declared type. However, there is one\n@@ -4530,119 +4720,6 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            --  Ada 2005 (AI-251): Rewrite the expression that initializes a\n-            --  class-wide object to ensure that we copy the full object,\n-            --  unless we are targetting a VM where interfaces are handled by\n-            --  VM itself. Note that if the root type of Typ is an ancestor\n-            --  of Expr's type, both types share the same dispatch table and\n-            --  there is no need to displace the pointer.\n-\n-            --  Replace\n-            --     CW : I'Class := Obj;\n-            --  by\n-            --     Temp : I'Class := I'Class (Base_Address (Obj'Address));\n-            --     CW   : I'Class renames Displace (Temp, I'Tag);\n-\n-            if Is_Interface (Typ)\n-              and then Is_Class_Wide_Type (Typ)\n-              and then\n-                (Is_Class_Wide_Type (Etype (Expr))\n-                   or else\n-                     not Is_Ancestor (Root_Type (Typ), Etype (Expr)))\n-              and then Comes_From_Source (Def_Id)\n-              and then Tagged_Type_Expansion\n-            then\n-               declare\n-                  Decl_1 : Node_Id;\n-                  Decl_2 : Node_Id;\n-\n-               begin\n-                  Decl_1 :=\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          New_Internal_Name ('D')),\n-\n-                      Object_Definition =>\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            New_Occurrence_Of\n-                              (Root_Type (Etype (Def_Id)), Loc),\n-                          Attribute_Name => Name_Class),\n-\n-                      Expression =>\n-                        Unchecked_Convert_To\n-                          (Class_Wide_Type (Root_Type (Etype (Def_Id))),\n-                            Make_Explicit_Dereference (Loc,\n-                              Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                                Make_Function_Call (Loc,\n-                                  Name =>\n-                                    New_Reference_To (RTE (RE_Base_Address),\n-                                                      Loc),\n-                                  Parameter_Associations => New_List (\n-                                    Make_Attribute_Reference (Loc,\n-                                      Prefix         => Relocate_Node (Expr),\n-                                      Attribute_Name => Name_Address)))))));\n-\n-                  Insert_Action (N, Decl_1);\n-\n-                  Decl_2 :=\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          New_Internal_Name ('D')),\n-\n-                      Subtype_Mark =>\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix =>\n-                            New_Occurrence_Of\n-                              (Root_Type (Etype (Def_Id)), Loc),\n-                          Attribute_Name => Name_Class),\n-\n-                      Name =>\n-                        Unchecked_Convert_To (\n-                          Class_Wide_Type (Root_Type (Etype (Def_Id))),\n-                          Make_Explicit_Dereference (Loc,\n-                            Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                              Make_Function_Call (Loc,\n-                                Name =>\n-                                  New_Reference_To (RTE (RE_Displace), Loc),\n-\n-                                Parameter_Associations => New_List (\n-                                  Make_Attribute_Reference (Loc,\n-                                    Prefix =>\n-                                      New_Reference_To\n-                                        (Defining_Identifier (Decl_1), Loc),\n-                                    Attribute_Name => Name_Address),\n-\n-                                  Unchecked_Convert_To (RTE (RE_Tag),\n-                                    New_Reference_To\n-                                      (Node\n-                                        (First_Elmt\n-                                          (Access_Disp_Table\n-                                             (Root_Type (Typ)))),\n-                                       Loc))))))));\n-\n-                  Rewrite (N, Decl_2);\n-                  Analyze (N);\n-\n-                  --  Replace internal identifier of Decl_2 by the identifier\n-                  --  found in the sources. We also have to exchange entities\n-                  --  containing their defining identifiers to ensure the\n-                  --  correct replacement of the object declaration by this\n-                  --  object renaming declaration (because such definings\n-                  --  identifier have been previously added by Enter_Name to\n-                  --  the current scope). We must preserve the homonym chain\n-                  --  of the source entity as well.\n-\n-                  Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n-                  Set_Homonym (Defining_Identifier (N), Homonym (Def_Id));\n-                  Exchange_Entities (Defining_Identifier (N), Def_Id);\n-\n-                  return;\n-               end;\n-            end if;\n-\n             --  If the type is controlled and not inherently limited, then\n             --  the target is adjusted after the copy and attached to the\n             --  finalization list. However, no adjustment is done in the case"}, {"sha": "99f918b74774ce95cea5d1feb60d230ac250bcbc", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -6118,64 +6118,71 @@ package body Exp_Disp is\n          end loop;\n       end if;\n \n-      --  3) At the end of Access_Disp_Table we add the entity of an access\n-      --     type declaration. It is used by Build_Get_Prim_Op_Address to\n-      --     expand dispatching calls through the primary dispatch table.\n+      --  3) At the end of Access_Disp_Table, if the type has user-defined\n+      --     primitives, we add the entity of an access type declaration that\n+      --     is used by Build_Get_Prim_Op_Address to expand dispatching calls\n+      --     through the primary dispatch table.\n+\n+      if UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ))) = 0 then\n+         Analyze_List (Result);\n \n       --     Generate:\n       --       type Typ_DT is array (1 .. Nb_Prims) of Prim_Ptr;\n       --       type Typ_DT_Acc is access Typ_DT;\n \n-      declare\n-         Name_DT_Prims     : constant Name_Id :=\n-                               New_External_Name (Tname, 'G');\n-         Name_DT_Prims_Acc : constant Name_Id :=\n-                               New_External_Name (Tname, 'H');\n-         DT_Prims          : constant Entity_Id :=\n-                               Make_Defining_Identifier (Loc, Name_DT_Prims);\n-         DT_Prims_Acc      : constant Entity_Id :=\n-                               Make_Defining_Identifier (Loc,\n-                                 Name_DT_Prims_Acc);\n-      begin\n-         Append_To (Result,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => DT_Prims,\n-             Type_Definition =>\n-               Make_Constrained_Array_Definition (Loc,\n-                 Discrete_Subtype_Definitions => New_List (\n-                   Make_Range (Loc,\n-                     Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                     High_Bound => Make_Integer_Literal (Loc,\n-                                    DT_Entry_Count\n-                                      (First_Tag_Component (Typ))))),\n-                 Component_Definition =>\n-                   Make_Component_Definition (Loc,\n-                     Subtype_Indication =>\n-                       New_Reference_To (RTE (RE_Prim_Ptr), Loc)))));\n+      else\n+         declare\n+            Name_DT_Prims     : constant Name_Id :=\n+                                  New_External_Name (Tname, 'G');\n+            Name_DT_Prims_Acc : constant Name_Id :=\n+                                  New_External_Name (Tname, 'H');\n+            DT_Prims          : constant Entity_Id :=\n+                                  Make_Defining_Identifier (Loc,\n+                                    Name_DT_Prims);\n+            DT_Prims_Acc      : constant Entity_Id :=\n+                                  Make_Defining_Identifier (Loc,\n+                                    Name_DT_Prims_Acc);\n+         begin\n+            Append_To (Result,\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => DT_Prims,\n+                Type_Definition =>\n+                  Make_Constrained_Array_Definition (Loc,\n+                    Discrete_Subtype_Definitions => New_List (\n+                      Make_Range (Loc,\n+                        Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                        High_Bound => Make_Integer_Literal (Loc,\n+                                       DT_Entry_Count\n+                                         (First_Tag_Component (Typ))))),\n+                    Component_Definition =>\n+                      Make_Component_Definition (Loc,\n+                        Subtype_Indication =>\n+                          New_Reference_To (RTE (RE_Prim_Ptr), Loc)))));\n \n-         Append_To (Result,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => DT_Prims_Acc,\n-             Type_Definition =>\n-                Make_Access_To_Object_Definition (Loc,\n-                  Subtype_Indication =>\n-                    New_Occurrence_Of (DT_Prims, Loc))));\n+            Append_To (Result,\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => DT_Prims_Acc,\n+                Type_Definition =>\n+                   Make_Access_To_Object_Definition (Loc,\n+                     Subtype_Indication =>\n+                       New_Occurrence_Of (DT_Prims, Loc))));\n \n-         Append_Elmt (DT_Prims_Acc, Access_Disp_Table (Typ));\n+            Append_Elmt (DT_Prims_Acc, Access_Disp_Table (Typ));\n \n-         --  Analyze the resulting list and suppress the generation of the\n-         --  Init_Proc associated with the above array declaration because\n-         --  we never use such type in object declarations; this type is only\n-         --  used to simplify the expansion associated with dispatching calls.\n+            --  Analyze the resulting list and suppress the generation of the\n+            --  Init_Proc associated with the above array declaration because\n+            --  this type is never used in object declarations. It is only used\n+            --  to simplify the expansion associated with dispatching calls.\n \n-         Analyze_List (Result);\n-         Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n+            Analyze_List (Result);\n+            Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n \n-         --  Mark entity of dispatch table. Required by the backend to handle\n-         --  the properly.\n+            --  Mark entity of dispatch table. Required by the back end to\n+            --  handle them properly.\n \n-         Set_Is_Dispatch_Table_Entity (DT_Prims);\n-      end;\n+            Set_Is_Dispatch_Table_Entity (DT_Prims);\n+         end;\n+      end if;\n \n       Set_Ekind        (DT_Ptr, E_Constant);\n       Set_Is_Tag       (DT_Ptr);"}, {"sha": "d975657f4a1f02cbd0e9ce1caf947bdd05f3d162", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -2755,53 +2755,47 @@ package body Exp_Dist is\n    ---------------------------------------------\n \n    procedure Expand_All_Calls_Remote_Subprogram_Call (N : Node_Id) is\n+      Loc               : constant Source_Ptr := Sloc (N);\n       Called_Subprogram : constant Entity_Id  := Entity (Name (N));\n       RCI_Package       : constant Entity_Id  := Scope (Called_Subprogram);\n-      Loc               : constant Source_Ptr := Sloc (N);\n-      RCI_Locator       : Node_Id;\n-      RCI_Cache         : Entity_Id;\n+      RCI_Locator_Decl  : Node_Id;\n+      RCI_Locator       : Entity_Id;\n       Calling_Stubs     : Node_Id;\n       E_Calling_Stubs   : Entity_Id;\n \n    begin\n       E_Calling_Stubs := RCI_Calling_Stubs_Table.Get (Called_Subprogram);\n \n       if E_Calling_Stubs = Empty then\n-         RCI_Cache := RCI_Locator_Table.Get (RCI_Package);\n-\n-         if RCI_Cache = Empty then\n-            RCI_Locator :=\n-              RCI_Package_Locator\n-                (Loc, Specification (Unit_Declaration_Node (RCI_Package)));\n-            Prepend_To (Current_Sem_Unit_Declarations, RCI_Locator);\n-\n-            --  The RCI_Locator package is inserted at the top level in the\n-            --  current unit, and must appear in the proper scope, so that it\n-            --  is not prematurely removed by the GCC back-end.\n+         RCI_Locator := RCI_Locator_Table.Get (RCI_Package);\n \n-            declare\n-               Scop : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n-\n-            begin\n-               if Ekind (Scop) = E_Package_Body then\n-                  Push_Scope (Spec_Entity (Scop));\n+         --  The RCI_Locator package and calling stub are is inserted at the\n+         --  top level in the current unit, and must appear in the proper scope\n+         --  so that it is not prematurely removed by the GCC back end.\n \n-               elsif Ekind (Scop) = E_Subprogram_Body then\n-                  Push_Scope\n-                     (Corresponding_Spec (Unit_Declaration_Node (Scop)));\n-\n-               else\n-                  Push_Scope (Scop);\n-               end if;\n-\n-               Analyze (RCI_Locator);\n-               Pop_Scope;\n-            end;\n+         declare\n+            Scop : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n+         begin\n+            if Ekind (Scop) = E_Package_Body then\n+               Push_Scope (Spec_Entity (Scop));\n+            elsif Ekind (Scop) = E_Subprogram_Body then\n+               Push_Scope\n+                 (Corresponding_Spec (Unit_Declaration_Node (Scop)));\n+            else\n+               Push_Scope (Scop);\n+            end if;\n+         end;\n \n-            RCI_Cache   := Defining_Unit_Name (RCI_Locator);\n+         if RCI_Locator = Empty then\n+            RCI_Locator_Decl :=\n+              RCI_Package_Locator\n+                (Loc, Specification (Unit_Declaration_Node (RCI_Package)));\n+            Prepend_To (Current_Sem_Unit_Declarations, RCI_Locator_Decl);\n+            Analyze (RCI_Locator_Decl);\n+            RCI_Locator := Defining_Unit_Name (RCI_Locator_Decl);\n \n          else\n-            RCI_Locator := Parent (RCI_Cache);\n+            RCI_Locator_Decl := Parent (RCI_Locator);\n          end if;\n \n          Calling_Stubs := Build_Subprogram_Calling_Stubs\n@@ -2811,10 +2805,12 @@ package body Exp_Dist is\n             Asynchronous           => Nkind (N) = N_Procedure_Call_Statement\n                                         and then\n                                       Is_Asynchronous (Called_Subprogram),\n-            Locator                => RCI_Cache,\n+            Locator                => RCI_Locator,\n             New_Name               => New_Internal_Name ('S'));\n-         Insert_After (RCI_Locator, Calling_Stubs);\n+         Insert_After (RCI_Locator_Decl, Calling_Stubs);\n          Analyze (Calling_Stubs);\n+         Pop_Scope;\n+\n          E_Calling_Stubs := Defining_Unit_Name (Specification (Calling_Stubs));\n       end if;\n "}, {"sha": "e8a1fdd3dbc5e3d194a90d4028f3dfc8b087260c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -1350,6 +1350,17 @@ package body Exp_Util is\n               Make_Subtype_From_Expr (Exp, Underlying_Record_View (Unc_Type)));\n          end if;\n \n+      --  Renamings of class-wide interface types require no equivalent\n+      --  constrained type declarations because we only need to reference\n+      --  the tag component associated with the interface.\n+\n+      elsif Present (N)\n+        and then Nkind (N) = N_Object_Renaming_Declaration\n+        and then Is_Interface (Unc_Type)\n+      then\n+         pragma Assert (Is_Class_Wide_Type (Unc_Type));\n+         null;\n+\n       --  In Ada95, nothing to be done if the type of the expression is\n       --  limited, because in this case the expression cannot be copied,\n       --  and its use can only be by reference.\n@@ -1371,16 +1382,6 @@ package body Exp_Util is\n       then\n          null;\n \n-      --  For limited interfaces, nothing to be done\n-\n-      --  This branch may be redundant once the limited interface issue is\n-      --  sorted out???\n-\n-      elsif Is_Interface (Exp_Typ)\n-        and then Is_Limited_Interface (Exp_Typ)\n-      then\n-         null;\n-\n       --  For limited objects initialized with build in place function calls,\n       --  nothing to be done; otherwise we prematurely introduce an N_Reference\n       --  node in the expression initializing the object, which breaks the\n@@ -1546,15 +1547,10 @@ package body Exp_Util is\n          AI      : Node_Id;\n \n       begin\n-         --  Check if the interface is an immediate ancestor of the type and\n-         --  therefore shares the main tag.\n+         --  This routine does not handle the case in which the interface is an\n+         --  ancestor of Typ. That case is handled by the enclosing subprogram.\n \n-         if Typ = Iface then\n-            pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n-            AI_Tag := First_Tag_Component (Typ);\n-            Found  := True;\n-            return;\n-         end if;\n+         pragma Assert (Typ /= Iface);\n \n          --  Climb to the root type handling private types\n \n@@ -1632,9 +1628,20 @@ package body Exp_Util is\n          Typ := Corresponding_Record_Type (Typ);\n       end if;\n \n-      Find_Tag (Typ);\n-      pragma Assert (Found);\n-      return AI_Tag;\n+      --  If the interface is an ancestor of the type, then it shared the\n+      --  primary dispatch table.\n+\n+      if Is_Ancestor (Iface, Typ) then\n+         pragma Assert (Etype (First_Tag_Component (Typ)) = RTE (RE_Tag));\n+         return First_Tag_Component (Typ);\n+\n+      --  Otherwise we need to search for its associated tag component\n+\n+      else\n+         Find_Tag (Typ);\n+         pragma Assert (Found);\n+         return AI_Tag;\n+      end if;\n    end Find_Interface_Tag;\n \n    ------------------"}, {"sha": "c3ec70c241a135b00e4894daf414b207f77941a0", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -2117,16 +2117,16 @@ begin\n                   end if;\n                end loop;\n \n-               --  If the naming scheme of the project file is not standard,\n-               --  and if the file name ends with the spec suffix, then\n-               --  indicate to gnatstub the name of the body file with\n-               --  a -o switch.\n+               --  If the project file naming scheme is not standard, and if\n+               --  the file name ends with the spec suffix, then indicate to\n+               --  gnatstub the name of the body file with a -o switch.\n \n-               if Is_Standard_GNAT_Naming (Lang.Config.Naming_Data) then\n+               if not Is_Standard_GNAT_Naming (Lang.Config.Naming_Data) then\n                   if File_Index /= 0 then\n                      declare\n                         Spec : constant String :=\n-                          Base_Name (Last_Switches.Table (File_Index).all);\n+                                 Base_Name\n+                                   (Last_Switches.Table (File_Index).all);\n                         Last : Natural := Spec'Last;\n \n                      begin\n@@ -2193,8 +2193,7 @@ begin\n          end if;\n \n          --  For gnat check, -rules and the following switches need to be the\n-         --  last options. So, we move all these switches to table\n-         --  Rules_Switches.\n+         --  last options, so move all these switches to table Rules_Switches.\n \n          if The_Command = Check then\n             declare"}, {"sha": "c0fa09b220c33f679c1666c60a6a844966e4d5c0", "filename": "gcc/ada/prj-err.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fprj-err.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fprj-err.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-err.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -113,7 +113,9 @@ package body Prj.Err is\n       --  Let the application know there was an error\n \n       if Flags.Report_Error /= null then\n-         Flags.Report_Error (Project, Is_Warning => Msg (Msg'First) = '?');\n+         Flags.Report_Error\n+           (Project,\n+            Is_Warning => Msg (Msg'First) = '?' or Msg (Msg'First) = '<');\n       end if;\n    end Error_Msg;\n "}, {"sha": "00c40e7677b5bbba32f2fa9b7fb5329410a557d4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -590,8 +590,8 @@ package body Sem_Ch3 is\n \n    function Is_Progenitor\n      (Iface : Entity_Id;\n-      Typ   :  Entity_Id) return Boolean;\n-   --  Determine whether type Typ implements interface Iface. This requires\n+      Typ   : Entity_Id) return Boolean;\n+   --  Determine whether the interface Iface is implemented by Typ. It requires\n    --  traversing the list of abstract interfaces of the type, as well as that\n    --  of the ancestor types. The predicate is used to determine when a formal\n    --  in the signature of an inherited operation must carry the derived type.\n@@ -2725,6 +2725,13 @@ package body Sem_Ch3 is\n             then\n                Act_T := Etype (E);\n \n+            --  In case of class-wide interface object declarations we delay\n+            --  the generation of the equivalent record type declarations until\n+            --  its expansion because there are cases in they are not required.\n+\n+            elsif Is_Interface (T) then\n+               null;\n+\n             else\n                Expand_Subtype_From_Expr (N, T, Object_Definition (N), E);\n                Act_T := Find_Type_Of_Object (Object_Definition (N), N);"}, {"sha": "705f428716ac92b7c505f42d801960518c755129", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -105,15 +105,13 @@ package body Sem_Disp is\n \n    begin\n       Formal := First_Formal (Subp);\n-\n       while Present (Formal) loop\n          Ctrl_Type := Check_Controlling_Type (Etype (Formal), Subp);\n \n          if Present (Ctrl_Type) then\n \n-            --  When the controlling type is concurrent and declared within a\n-            --  generic or inside an instance, use its corresponding record\n-            --  type.\n+            --  When controlling type is concurrent and declared within a\n+            --  generic or inside an instance use corresponding record type.\n \n             if Is_Concurrent_Type (Ctrl_Type)\n               and then Present (Corresponding_Record_Type (Ctrl_Type))\n@@ -124,7 +122,7 @@ package body Sem_Disp is\n             if Ctrl_Type = Typ then\n                Set_Is_Controlling_Formal (Formal);\n \n-               --  Ada 2005 (AI-231): Anonymous access types used in\n+               --  Ada 2005 (AI-231): Anonymous access types that are used in\n                --  controlling parameters exclude null because it is necessary\n                --  to read the tag to dispatch, and null has no tag.\n \n@@ -178,7 +176,10 @@ package body Sem_Disp is\n          Next_Formal (Formal);\n       end loop;\n \n-      if Present (Etype (Subp)) then\n+      if Ekind (Subp) = E_Function\n+           or else\n+         Ekind (Subp) = E_Generic_Function\n+      then\n          Ctrl_Type := Check_Controlling_Type (Etype (Subp), Subp);\n \n          if Present (Ctrl_Type) then\n@@ -426,14 +427,12 @@ package body Sem_Disp is\n \n             else\n                Par := Parent (N);\n-\n                while Present (Par) loop\n-\n-                  if (Nkind (Par) = N_Function_Call            or else\n-                      Nkind (Par) = N_Procedure_Call_Statement or else\n-                      Nkind (Par) = N_Assignment_Statement     or else\n-                      Nkind (Par) = N_Op_Eq                    or else\n-                      Nkind (Par) = N_Op_Ne)\n+                  if Nkind_In (Par, N_Function_Call,\n+                                    N_Procedure_Call_Statement,\n+                                    N_Assignment_Statement,\n+                                    N_Op_Eq,\n+                                    N_Op_Ne)\n                     and then Is_Tagged_Type (Etype (Subp))\n                   then\n                      return;\n@@ -471,11 +470,10 @@ package body Sem_Disp is\n       --  Find a controlling argument, if any\n \n       if Present (Parameter_Associations (N)) then\n-         Actual := First_Actual (N);\n-\n          Subp_Entity := Entity (Name (N));\n-         Formal := First_Formal (Subp_Entity);\n \n+         Actual := First_Actual (N);\n+         Formal := First_Formal (Subp_Entity);\n          while Present (Actual) loop\n             Control := Find_Controlling_Arg (Actual);\n             exit when Present (Control);\n@@ -544,7 +542,6 @@ package body Sem_Disp is\n             end if;\n \n             Actual := First_Actual (N);\n-\n             while Present (Actual) loop\n                if Actual /= Control then\n \n@@ -866,7 +863,7 @@ package body Sem_Disp is\n          --  If the type is already frozen, the overriding is not allowed\n          --  except when Old_Subp is not a dispatching operation (which can\n          --  occur when Old_Subp was inherited by an untagged type). However,\n-         --  a body with no previous spec freezes the type \"after\" its\n+         --  a body with no previous spec freezes the type *after* its\n          --  declaration, and therefore is a legal overriding (unless the type\n          --  has already been frozen). Only the first such body is legal.\n \n@@ -880,7 +877,7 @@ package body Sem_Disp is\n             then\n                declare\n                   Subp_Body : constant Node_Id := Unit_Declaration_Node (Subp);\n-                  Decl_Item : Node_Id          := Next (Parent (Tagged_Type));\n+                  Decl_Item : Node_Id;\n \n                begin\n                   --  ??? The checks here for whether the type has been\n@@ -899,6 +896,7 @@ package body Sem_Disp is\n                   --  then the type has been frozen already so the overriding\n                   --  primitive is illegal.\n \n+                  Decl_Item := Next (Parent (Tagged_Type));\n                   while Present (Decl_Item)\n                     and then (Decl_Item /= Subp_Body)\n                   loop\n@@ -1166,8 +1164,10 @@ package body Sem_Disp is\n       elsif Has_Controlled_Component (Tagged_Type)\n         and then\n          (Chars (Subp) = Name_Initialize\n-           or else Chars (Subp) = Name_Adjust\n-           or else Chars (Subp) = Name_Finalize)\n+            or else\n+          Chars (Subp) = Name_Adjust\n+            or else\n+          Chars (Subp) = Name_Finalize)\n       then\n          declare\n             F_Node   : constant Node_Id := Freeze_Node (Tagged_Type);\n@@ -1187,13 +1187,13 @@ package body Sem_Disp is\n                          TSS_Deep_Finalize);\n \n          begin\n-            --  Remove previous controlled function, which was constructed\n-            --  and analyzed when the type was frozen. This requires\n-            --  removing the body of the redefined primitive, as well as\n-            --  its specification if needed (there is no spec created for\n-            --  Deep_Initialize, see exp_ch3.adb). We must also dismantle\n-            --  the exception information that may have been generated for\n-            --  it when front end zero-cost tables are enabled.\n+            --  Remove previous controlled function which was constructed and\n+            --  analyzed when the type was frozen. This requires removing the\n+            --  body of the redefined primitive, as well as its specification\n+            --  if needed (there is no spec created for Deep_Initialize, see\n+            --  exp_ch3.adb). We must also dismantle the exception information\n+            --  that may have been generated for it when front end zero-cost\n+            --  tables are enabled.\n \n             for J in D_Names'Range loop\n                Old_P := TSS (Tagged_Type, D_Names (J));\n@@ -1217,9 +1217,9 @@ package body Sem_Disp is\n \n             Build_Late_Proc (Tagged_Type, Chars (Subp));\n \n-            --  The new operation is added to the actions of the freeze\n-            --  node for the type, but this node has already been analyzed,\n-            --  so we must retrieve and analyze explicitly the new body.\n+            --  The new operation is added to the actions of the freeze node\n+            --  for the type, but this node has already been analyzed, so we\n+            --  must retrieve and analyze explicitly the new body.\n \n             if Present (F_Node)\n               and then Present (Actions (F_Node))\n@@ -1264,14 +1264,10 @@ package body Sem_Disp is\n \n          F1 := First_Formal (Proc);\n          F2 := First_Formal (Subp);\n-\n          while Present (F1) and then Present (F2) loop\n-\n             if Ekind (Etype (F1)) = E_Anonymous_Access_Type then\n-\n                if Ekind (Etype (F2)) /= E_Anonymous_Access_Type then\n                   return False;\n-\n                elsif Designated_Type (Etype (F1)) = Parent_Typ\n                  and then Designated_Type (Etype (F2)) /= Full\n                then\n@@ -1304,11 +1300,8 @@ package body Sem_Disp is\n \n       Op1 := First_Elmt (Old_Prim);\n       Op2 := First_Elmt (New_Prim);\n-\n       while Present (Op1) and then Present (Op2) loop\n-\n          if Derives_From (Node (Op1)) then\n-\n             if No (Prev) then\n \n                --  Avoid adding it to the list of primitives if already there!\n@@ -1371,6 +1364,7 @@ package body Sem_Disp is\n                then\n                   declare\n                      Formal : Entity_Id;\n+\n                   begin\n                      Formal := First_Formal (Old_Subp);\n                      while Present (Formal) loop\n@@ -1397,8 +1391,8 @@ package body Sem_Disp is\n             --  Otherwise, update its alias and other attributes.\n \n             if Present (Alias (Old_Subp))\n-              and then Nkind (Unit_Declaration_Node (Old_Subp))\n-                /= N_Subprogram_Renaming_Declaration\n+              and then Nkind (Unit_Declaration_Node (Old_Subp)) /=\n+                                        N_Subprogram_Renaming_Declaration\n             then\n                Set_Alias (Old_Subp, Alias (Subp));\n \n@@ -1461,24 +1455,22 @@ package body Sem_Disp is\n          Typ := Etype (N);\n \n          if Is_Access_Type (Typ) then\n-            --  In the case of an Access attribute, use the type of\n-            --  the prefix, since in the case of an actual for an\n-            --  access parameter, the attribute's type may be of a\n-            --  specific designated type, even though the prefix\n-            --  type is class-wide.\n+\n+            --  In the case of an Access attribute, use the type of the prefix,\n+            --  since in the case of an actual for an access parameter, the\n+            --  attribute's type may be of a specific designated type, even\n+            --  though the prefix type is class-wide.\n \n             if Nkind (N) = N_Attribute_Reference then\n                Typ := Etype (Prefix (N));\n \n-            --  An allocator is dispatching if the type of qualified\n-            --  expression is class_wide, in which case this is the\n-            --  controlling type.\n+            --  An allocator is dispatching if the type of qualified expression\n+            --  is class_wide, in which case this is the controlling type.\n \n             elsif Nkind (Orig_Node) = N_Allocator\n                and then Nkind (Expression (Orig_Node)) = N_Qualified_Expression\n             then\n                Typ := Etype (Expression (Orig_Node));\n-\n             else\n                Typ := Designated_Type (Typ);\n             end if;\n@@ -1560,6 +1552,7 @@ package body Sem_Disp is\n          end if;\n       end if;\n \n+      pragma Assert (not Is_Dispatching_Operation (Subp));\n       return Empty;\n    end Find_Dispatching_Type;\n \n@@ -1800,9 +1793,9 @@ package body Sem_Disp is\n       elsif Nkind (Actual) = N_Identifier\n         and then Nkind (Original_Node (Actual)) = N_Function_Call\n       then\n-         --  Call rewritten as object declaration when stack-checking\n-         --  is enabled. Propagate tag to expression in declaration, which\n-         --  is original call.\n+         --  Call rewritten as object declaration when stack-checking is\n+         --  enabled. Propagate tag to expression in declaration, which is\n+         --  original call.\n \n          Call_Node := Expression (Parent (Entity (Actual)));\n \n@@ -1823,8 +1816,8 @@ package body Sem_Disp is\n          Call_Node := Expression (Actual);\n       end if;\n \n-      --  Do not set the Controlling_Argument if already set. This happens\n-      --  in the special case of _Input (see Exp_Attr, case Input).\n+      --  Do not set the Controlling_Argument if already set. This happens in\n+      --  the special case of _Input (see Exp_Attr, case Input).\n \n       if No (Controlling_Argument (Call_Node)) then\n          Set_Controlling_Argument (Call_Node, Control);\n@@ -1841,8 +1834,8 @@ package body Sem_Disp is\n       end loop;\n \n       --  Expansion of dispatching calls is suppressed when VM_Target, because\n-      --  the VM back-ends directly handle the generation of dispatching\n-      --  calls and would have to undo any expansion to an indirect call.\n+      --  the VM back-ends directly handle the generation of dispatching calls\n+      --  and would have to undo any expansion to an indirect call.\n \n       if Tagged_Type_Expansion then\n          Expand_Dispatching_Call (Call_Node);"}, {"sha": "2bba1030289ff1474656ed7b9c819f62faaad6d1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e41a941ee11651b5805c730d2675902d64577aa/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=0e41a941ee11651b5805c730d2675902d64577aa", "patch": "@@ -4937,26 +4937,22 @@ package body Sem_Util is\n    is\n       Ifaces_List : Elist_Id;\n       Elmt        : Elmt_Id;\n-      Iface       : Entity_Id;\n-      Typ         : Entity_Id;\n+      Iface       : Entity_Id := Base_Type (Iface_Ent);\n+      Typ         : Entity_Id := Base_Type (Typ_Ent);\n \n    begin\n-      if Is_Class_Wide_Type (Typ_Ent) then\n-         Typ := Etype (Typ_Ent);\n-      else\n-         Typ := Typ_Ent;\n-      end if;\n-\n-      if Is_Class_Wide_Type (Iface_Ent) then\n-         Iface := Etype (Iface_Ent);\n-      else\n-         Iface := Iface_Ent;\n+      if Is_Class_Wide_Type (Typ) then\n+         Typ := Root_Type (Typ);\n       end if;\n \n       if not Has_Interfaces (Typ) then\n          return False;\n       end if;\n \n+      if Is_Class_Wide_Type (Iface) then\n+         Iface := Root_Type (Iface);\n+      end if;\n+\n       Collect_Interfaces (Typ, Ifaces_List);\n \n       Elmt := First_Elmt (Ifaces_List);"}]}