{"sha": "ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJkZmQxNjA2ZGE2YjVhYTU4NmIwY2QxNTZiNjliNjU5MjM1YzljMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-12-03T09:25:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-12-07T11:07:12Z"}, "message": "tree-optimization/98113 - vectorize a sequence of BIT_INSERT_EXPRs\n\nThis adds the capability to handle a sequence of vector BIT_INSERT_EXPRs\nto be vectorized similar as to how we vectorize vector constructors.\n\n2020-12-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/98113\n\t* tree-vectorizer.h (struct slp_root): New.\n\t(_bb_vec_info::roots): New member.\n\t* tree-vect-slp.c (vect_analyze_slp): Also walk BB info\n\troots.\n\t(_bb_vec_info::_bb_vec_info): Adjust.\n\t(_bb_vec_info::~_bb_vec_info): Likewise.\n\t(vld_cmp): New.\n\t(vect_slp_is_lane_insert): Likewise.\n\t(vect_slp_check_for_constructors): Match a series of\n\tBIT_INSERT_EXPRs as vector constructor.\n\t(vect_slp_analyze_bb_1): Continue if BB info roots is\n\tnot empty.\n\t(vect_slp_analyze_bb_1): Mark the whole BIT_INSERT_EXPR root\n\tsequence as pure_slp.\n\n\t* gcc.dg/vect/bb-slp-70.c: New testcase.", "tree": {"sha": "5a5649a6f9dd5d39848c76e182968f356e2d32c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a5649a6f9dd5d39848c76e182968f356e2d32c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcbef3c3310a14f2994982b44cb1f8e14c77232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdcbef3c3310a14f2994982b44cb1f8e14c77232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdcbef3c3310a14f2994982b44cb1f8e14c77232"}], "stats": {"total": 221, "additions": 200, "deletions": 21}, "files": [{"sha": "0eb70112bde38ecca5b317031dc0174af0cbfced", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-70.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-70.c?ref=ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-mavx512vl -mavx512vpopcntdq\" { target avx512vpopcntdq } } */\n+\n+typedef unsigned uv4si __attribute__((vector_size(16)));\n+\n+uv4si __attribute__((noinline))\n+vpopctf (uv4si a)\n+{\n+  uv4si r;\n+  r[2] = __builtin_popcount (a[2]);\n+  r[1] = __builtin_popcount (a[1]);\n+  r[0] = __builtin_popcount (a[0]);\n+  r[3] = __builtin_popcount (a[3]);\n+  return r;\n+}\n+\n+/* { dg-final { scan-tree-dump \"optimized: basic block\" \"slp2\" { target avx512vpopcntdq } } } */"}, {"sha": "2dccca02aa006498d59c2be4971418eb789bc9fa", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 171, "deletions": 21, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "patch": "@@ -2578,6 +2578,19 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\t\t       ? slp_inst_kind_store : slp_inst_kind_ctor,\n \t\t\t       max_tree_size);\n \n+  if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo))\n+    {\n+      for (unsigned i = 0; i < bb_vinfo->roots.length (); ++i)\n+\t{\n+\t  vect_location = bb_vinfo->roots[i].root->stmt;\n+\t  if (vect_build_slp_instance (bb_vinfo, bb_vinfo->roots[i].kind,\n+\t\t\t\t       bb_vinfo->roots[i].stmts,\n+\t\t\t\t       bb_vinfo->roots[i].root,\n+\t\t\t\t       max_tree_size, bst_map, NULL))\n+\t    bb_vinfo->roots[i].stmts = vNULL;\n+\t}\n+    }\n+\n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n       /* Find SLP sequences starting from reduction chains.  */\n@@ -3336,7 +3349,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n /* Initialize a bb_vec_info struct for the statements in BBS basic blocks.  */\n \n _bb_vec_info::_bb_vec_info (vec<basic_block> _bbs, vec_info_shared *shared)\n-  : vec_info (vec_info::bb, init_cost (NULL), shared), bbs (_bbs)\n+  : vec_info (vec_info::bb, init_cost (NULL), shared), bbs (_bbs), roots (vNULL)\n {\n   for (unsigned i = 0; i < bbs.length (); ++i)\n     {\n@@ -3383,6 +3396,10 @@ _bb_vec_info::~_bb_vec_info ()\n \t  gimple_set_uid (stmt, -1);\n \t}\n     }\n+\n+  for (unsigned i = 0; i < roots.length (); ++i)\n+    roots[i].stmts.release ();\n+  roots.release ();\n }\n \n /* Subroutine of vect_slp_analyze_node_operations.  Handle the root of NODE,\n@@ -4105,6 +4122,38 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n   return true;\n }\n \n+/* qsort comparator for lane defs.  */\n+\n+static int\n+vld_cmp (const void *a_, const void *b_)\n+{\n+  auto *a = (const std::pair<unsigned, tree> *)a_;\n+  auto *b = (const std::pair<unsigned, tree> *)b_;\n+  return a->first - b->first;\n+}\n+\n+/* Return true if USE_STMT is a vector lane insert into VEC and set\n+   *THIS_LANE to the lane number that is set.  */\n+\n+static bool\n+vect_slp_is_lane_insert (gimple *use_stmt, tree vec, unsigned *this_lane)\n+{\n+  gassign *use_ass = dyn_cast <gassign *> (use_stmt);\n+  if (!use_ass\n+      || gimple_assign_rhs_code (use_ass) != BIT_INSERT_EXPR\n+      || (vec\n+\t  ? gimple_assign_rhs1 (use_ass) != vec\n+\t  : ((vec = gimple_assign_rhs1 (use_ass)), false))\n+      || !useless_type_conversion_p (TREE_TYPE (TREE_TYPE (vec)),\n+\t\t\t\t     TREE_TYPE (gimple_assign_rhs2 (use_ass)))\n+      || !constant_multiple_p\n+\t    (tree_to_poly_uint64 (gimple_assign_rhs3 (use_ass)),\n+\t     tree_to_poly_uint64 (TYPE_SIZE (TREE_TYPE (TREE_TYPE (vec)))),\n+\t     this_lane))\n+    return false;\n+  return true;\n+}\n+\n /* Find any vectorizable constructors and add them to the grouped_store\n    array.  */\n \n@@ -4116,28 +4165,114 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gassign *assign = dyn_cast<gassign *> (gsi_stmt (gsi));\n-      if (!assign || gimple_assign_rhs_code (assign) != CONSTRUCTOR)\n+      if (!assign)\n \tcontinue;\n \n       tree rhs = gimple_assign_rhs1 (assign);\n-      if (!VECTOR_TYPE_P (TREE_TYPE (rhs))\n-\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)),\n-\t\t       CONSTRUCTOR_NELTS (rhs))\n-\t  || VECTOR_TYPE_P (TREE_TYPE (CONSTRUCTOR_ELT (rhs, 0)->value))\n-\t  || uniform_vector_p (rhs))\n-\tcontinue;\n+      if (gimple_assign_rhs_code (assign) == CONSTRUCTOR)\n+\t{\n+\t  if (!VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t      || maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)),\n+\t\t\t   CONSTRUCTOR_NELTS (rhs))\n+\t      || VECTOR_TYPE_P (TREE_TYPE (CONSTRUCTOR_ELT (rhs, 0)->value))\n+\t      || uniform_vector_p (rhs))\n+\t    continue;\n \n-      unsigned j;\n-      tree val;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), j, val)\n-\tif (TREE_CODE (val) != SSA_NAME\n-\t    || !bb_vinfo->lookup_def (val))\n-\t  break;\n-      if (j != CONSTRUCTOR_NELTS (rhs))\n-\tcontinue;\n+\t  unsigned j;\n+\t  tree val;\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), j, val)\n+\t      if (TREE_CODE (val) != SSA_NAME\n+\t\t  || !bb_vinfo->lookup_def (val))\n+\t\tbreak;\n+\t  if (j != CONSTRUCTOR_NELTS (rhs))\n+\t    continue;\n \n-      stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (assign);\n-      BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt_info);\n+\t  stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (assign);\n+\t  BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt_info);\n+\t}\n+      else if (gimple_assign_rhs_code (assign) == BIT_INSERT_EXPR\n+\t       && VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t       && TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)).is_constant ()\n+\t       && integer_zerop (gimple_assign_rhs3 (assign))\n+\t       && useless_type_conversion_p\n+\t\t    (TREE_TYPE (TREE_TYPE (rhs)),\n+\t\t     TREE_TYPE (gimple_assign_rhs2 (assign))))\n+\t{\n+\t  /* We start to match on insert to lane zero but since the\n+\t     inserts need not be ordered we'd have to search both\n+\t     the def and the use chains.  */\n+\t  tree vectype = TREE_TYPE (rhs);\n+\t  unsigned nlanes = TYPE_VECTOR_SUBPARTS (vectype).to_constant ();\n+\t  auto_vec<std::pair<unsigned, tree> > lane_defs (nlanes);\n+\t  auto_sbitmap lanes (nlanes);\n+\t  bitmap_clear (lanes);\n+\t  bitmap_set_bit (lanes, 0);\n+\t  tree def = gimple_assign_lhs (assign);\n+\t  lane_defs.quick_push\n+\t\t      (std::make_pair (0, gimple_assign_rhs2 (assign)));\n+\t  unsigned lanes_found = 1;\n+\t  /* Start with the use chains, the last stmt will be the root.  */\n+\t  stmt_vec_info last = bb_vinfo->lookup_stmt (assign);\n+\t  do\n+\t    {\n+\t      use_operand_p use_p;\n+\t      gimple *use_stmt;\n+\t      if (!single_imm_use (def, &use_p, &use_stmt))\n+\t\tbreak;\n+\t      unsigned this_lane;\n+\t      if (!bb_vinfo->lookup_stmt (use_stmt)\n+\t\t  || !vect_slp_is_lane_insert (use_stmt, def, &this_lane)\n+\t\t  || !bb_vinfo->lookup_def (gimple_assign_rhs2 (use_stmt)))\n+\t\tbreak;\n+\t      if (bitmap_bit_p (lanes, this_lane))\n+\t\tbreak;\n+\t      lanes_found++;\n+\t      bitmap_set_bit (lanes, this_lane);\n+\t      gassign *use_ass = as_a <gassign *> (use_stmt);\n+\t      lane_defs.quick_push (std::make_pair\n+\t\t\t\t     (this_lane, gimple_assign_rhs2 (use_ass)));\n+\t      last = bb_vinfo->lookup_stmt (use_ass);\n+\t      def = gimple_assign_lhs (use_ass);\n+\t    }\n+\t  while (lanes_found < nlanes);\n+\t  if (lanes_found < nlanes)\n+\t    {\n+\t      /* Now search the def chain.  */\n+\t      def = gimple_assign_rhs1 (assign);\n+\t      do\n+\t\t{\n+\t\t  if (!has_single_use (def))\n+\t\t    break;\n+\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (def);\n+\t\t  unsigned this_lane;\n+\t\t  if (!bb_vinfo->lookup_stmt (def_stmt)\n+\t\t      || !vect_slp_is_lane_insert (def_stmt,\n+\t\t\t\t\t\t   NULL_TREE, &this_lane)\n+\t\t      || !bb_vinfo->lookup_def (gimple_assign_rhs2 (def_stmt)))\n+\t\t    break;\n+\t\t  if (bitmap_bit_p (lanes, this_lane))\n+\t\t    break;\n+\t\t  lanes_found++;\n+\t\t  bitmap_set_bit (lanes, this_lane);\n+\t\t  lane_defs.quick_push (std::make_pair\n+\t\t\t\t\t  (this_lane,\n+\t\t\t\t\t   gimple_assign_rhs2 (def_stmt)));\n+\t\t  def = gimple_assign_rhs1 (def_stmt);\n+\t\t}\n+\t      while (lanes_found < nlanes);\n+\t    }\n+\t  if (lanes_found == nlanes)\n+\t    {\n+\t      /* Sort lane_defs after the lane index and register the root.  */\n+\t      lane_defs.qsort (vld_cmp);\n+\t      vec<stmt_vec_info> stmts;\n+\t      stmts.create (nlanes);\n+\t      for (unsigned i = 0; i < nlanes; ++i)\n+\t\tstmts.quick_push (bb_vinfo->lookup_def (lane_defs[i].second));\n+\t      bb_vinfo->roots.safe_push (slp_root (slp_inst_kind_ctor,\n+\t\t\t\t\t\t   stmts, last));\n+\t    }\n+\t}\n     }\n }\n \n@@ -4227,7 +4362,8 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n   /* If there are no grouped stores and no constructors in the region\n      there is no need to continue with pattern recog as vect_analyze_slp\n      will fail anyway.  */\n-  if (bb_vinfo->grouped_stores.is_empty ())\n+  if (bb_vinfo->grouped_stores.is_empty ()\n+      && bb_vinfo->roots.is_empty ())\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -4290,8 +4426,22 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n \t relevant.  */\n       vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance));\n       vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n-      if (SLP_INSTANCE_ROOT_STMT (instance))\n-\tSTMT_SLP_TYPE (SLP_INSTANCE_ROOT_STMT (instance)) = pure_slp;\n+      if (stmt_vec_info root = SLP_INSTANCE_ROOT_STMT (instance))\n+\t{\n+\t  STMT_SLP_TYPE (root) = pure_slp;\n+\t  if (is_gimple_assign (root->stmt)\n+\t      && gimple_assign_rhs_code (root->stmt) == BIT_INSERT_EXPR)\n+\t    {\n+\t      /* ???  We should probably record the whole vector of\n+\t\t root stmts so we do not have to back-track here...  */\n+\t      for (unsigned n = SLP_TREE_LANES (SLP_INSTANCE_TREE (instance));\n+\t\t   n != 1; --n)\n+\t\t{\n+\t\t  root = bb_vinfo->lookup_def (gimple_assign_rhs1 (root->stmt));\n+\t\t  STMT_SLP_TYPE (root) = pure_slp;\n+\t\t}\n+\t    }\n+\t}\n \n       i++;\n     }"}, {"sha": "95e8ea06a62d257f331a6e051a5d353709d41399", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebdfd1606da6b5aa586b0cd156b69b659235c9c2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ebdfd1606da6b5aa586b0cd156b69b659235c9c2", "patch": "@@ -849,6 +849,16 @@ loop_vec_info_for_loop (class loop *loop)\n   return (loop_vec_info) loop->aux;\n }\n \n+struct slp_root\n+{\n+  slp_root (slp_instance_kind kind_, vec<stmt_vec_info> stmts_,\n+\t    stmt_vec_info root_)\n+    : kind(kind_), stmts(stmts_), root(root_) {}\n+  slp_instance_kind kind;\n+  vec<stmt_vec_info> stmts;\n+  stmt_vec_info root;\n+};\n+\n typedef class _bb_vec_info : public vec_info\n {\n public:\n@@ -860,6 +870,8 @@ typedef class _bb_vec_info : public vec_info\n      entry edge to cover bbs[0] PHI nodes and have a region entry\n      insert location.  */\n   vec<basic_block> bbs;\n+\n+  vec<slp_root> roots;\n } *bb_vec_info;\n \n #define BB_VINFO_BB(B)               (B)->bb"}]}