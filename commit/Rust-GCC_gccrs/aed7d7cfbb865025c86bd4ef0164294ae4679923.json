{"sha": "aed7d7cfbb865025c86bd4ef0164294ae4679923", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVkN2Q3Y2ZiYjg2NTAyNWM4NmJkNGVmMDE2NDI5NGFlNDY3OTkyMw==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2012-09-07T02:56:17Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2012-09-07T02:56:17Z"}, "message": "Reduce memory usage for storing LTO decl resolutions\n\nWith a LTO build of a large project (>11k subfiles incrementially linked)\nstoring the LTO resolutions took over 0.5GB memory:\n\nlto/lto.c:1087 (lto_resolution_read)                      0: 0.0%  540398500           15903: 0.0%\n\nThe reason is that the declaration indexes are quite sparse, but every subfile\ngot a full continuous vector for them. Since there are so many of them the\nmany vectors add up.\n\nThis patch instead stores the resolutions initially in a compact (index, resolution)\nformat. This is only expanded into a sparse vector for fast lookup when\nthe subfile is actually read, but then immediately freed. This means only one\nvector is allocated at a time.\n\nThis brings the overhead for this down to less than 3MB for the test case:\n\nlto/lto.c:1087 (lto_resolution_read)                      0: 0.0%    2821456           42186: 0.0%\n\ngcc/:\n\n2012-09-06  Andi Kleen  <ak@linux.intel.com>\n\n\t* gcc/lto-streamer.h (res_pair): Add.\n\t(lto_file_decl_data): Replace resolutions with respairs.\n\tAdd max_index.\n\t* gcc/lto/lto.c (lto_resolution_read): Remove max_index.  Add rp.\n\tInitialize respairs.\n\t(lto_file_finalize): Set up resolutions vector lazily from respairs.\n\nFrom-SVN: r191051", "tree": {"sha": "60912414a472f915fe20ebfab483665067066d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60912414a472f915fe20ebfab483665067066d2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aed7d7cfbb865025c86bd4ef0164294ae4679923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed7d7cfbb865025c86bd4ef0164294ae4679923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed7d7cfbb865025c86bd4ef0164294ae4679923", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed7d7cfbb865025c86bd4ef0164294ae4679923/comments", "author": null, "committer": null, "parents": [{"sha": "6e85a1584edbc575a8f69bec8aa4dd4c4f977a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e85a1584edbc575a8f69bec8aa4dd4c4f977a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e85a1584edbc575a8f69bec8aa4dd4c4f977a04"}], "stats": {"total": 55, "additions": 45, "deletions": 10}, "files": [{"sha": "5aa6aa84a0890408d401b6660ba305a0a9fffbe9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aed7d7cfbb865025c86bd4ef0164294ae4679923", "patch": "@@ -1,3 +1,12 @@\n+2012-09-06  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* gcc/lto-streamer.h (res_pair): Add.\n+\t(lto_file_decl_data): Replace resolutions with respairs.\n+\tAdd max_index.\n+\t* gcc/lto/lto.c (lto_resolution_read): Remove max_index.  Add rp.\n+\tInitialize respairs.\n+\t(lto_file_finalize): Set up resolutions vector lazily from respairs.\n+\n 2012-09-06  Lawrence Crowl  <crowl@google.com>\n \n \t* double-int.h (double_int::operator &=): New."}, {"sha": "80fc19f861ad094b85bc09743ed380985f909649", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=aed7d7cfbb865025c86bd4ef0164294ae4679923", "patch": "@@ -513,6 +513,18 @@ typedef struct lto_out_decl_state *lto_out_decl_state_ptr;\n DEF_VEC_P(lto_out_decl_state_ptr);\n DEF_VEC_ALLOC_P(lto_out_decl_state_ptr, heap);\n \n+/* Compact representation of a index <-> resolution pair. Unpacked to an \n+   vector later. */\n+struct res_pair \n+{\n+  ld_plugin_symbol_resolution_t res;\n+  unsigned index;\n+};\n+typedef struct res_pair res_pair;\n+\n+DEF_VEC_O(res_pair);\n+DEF_VEC_ALLOC_O(res_pair, heap);\n+\n /* One of these is allocated for each object file that being compiled\n    by lto.  This structure contains the tables that are needed by the\n    serialized functions and ipa passes to connect themselves to the\n@@ -548,7 +560,8 @@ struct GTY(()) lto_file_decl_data\n   unsigned HOST_WIDE_INT id;\n \n   /* Symbol resolutions for this file */\n-  VEC(ld_plugin_symbol_resolution_t,heap) * GTY((skip)) resolutions;\n+  VEC(res_pair, heap) * GTY((skip)) respairs;\n+  unsigned max_index;\n \n   struct gcov_ctr_summary GTY((skip)) profile_info;\n };"}, {"sha": "5da54124f2db881f7bf51864942a22e799710397", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aed7d7cfbb865025c86bd4ef0164294ae4679923/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=aed7d7cfbb865025c86bd4ef0164294ae4679923", "patch": "@@ -1012,7 +1012,6 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n   unsigned int num_symbols;\n   unsigned int i;\n   struct lto_file_decl_data *file_data;\n-  unsigned max_index = 0;\n   splay_tree_node nd = NULL; \n \n   if (!resolution)\n@@ -1054,13 +1053,12 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n       unsigned int j;\n       unsigned int lto_resolution_str_len =\n \tsizeof (lto_resolution_str) / sizeof (char *);\n+      res_pair rp;\n \n       t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE \" %26s %*[^\\n]\\n\", \n \t\t  &index, &id, r_str);\n       if (t != 3)\n         internal_error (\"invalid line in the resolution file\");\n-      if (index > max_index)\n-\tmax_index = index;\n \n       for (j = 0; j < lto_resolution_str_len; j++)\n \t{\n@@ -1082,11 +1080,13 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n \t}\n \n       file_data = (struct lto_file_decl_data *)nd->value;\n-      VEC_safe_grow_cleared (ld_plugin_symbol_resolution_t, heap, \n-\t\t\t     file_data->resolutions,\n-\t\t\t     max_index + 1);\n-      VEC_replace (ld_plugin_symbol_resolution_t, \n-\t\t   file_data->resolutions, index, r);\n+      /* The indexes are very sparse. To save memory save them in a compact\n+         format that is only unpacked later when the subfile is processed. */\n+      rp.res = r;\n+      rp.index = index;\n+      VEC_safe_push (res_pair, heap, file_data->respairs, rp);\n+      if (file_data->max_index < index)\n+        file_data->max_index = index;\n     }\n }\n \n@@ -1166,6 +1166,18 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n {\n   const char *data;\n   size_t len;\n+  VEC(ld_plugin_symbol_resolution_t,heap) *resolutions = NULL;\n+  int i;\n+  res_pair *rp;\n+\n+  /* Create vector for fast access of resolution. We do this lazily\n+     to save memory. */ \n+  VEC_safe_grow_cleared (ld_plugin_symbol_resolution_t, heap, \n+                            resolutions,\n+                            file_data->max_index + 1);\n+  for (i = 0; VEC_iterate (res_pair, file_data->respairs, i, rp); i++)\n+    VEC_replace (ld_plugin_symbol_resolution_t, resolutions, rp->index, rp->res);\n+  VEC_free (res_pair, heap, file_data->respairs);\n \n   file_data->renaming_hash_table = lto_create_renaming_table ();\n   file_data->file_name = file->filename;\n@@ -1175,7 +1187,8 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n       internal_error (\"cannot read LTO decls from %s\", file_data->file_name);\n       return;\n     }\n-  lto_read_decls (file_data, data, file_data->resolutions);\n+  /* Frees resolutions */\n+  lto_read_decls (file_data, data, resolutions);\n   lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n }\n "}]}