{"sha": "e89065a17202234f50185ce3bf2a80efb2fef938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5MDY1YTE3MjAyMjM0ZjUwMTg1Y2UzYmYyYTgwZWZiMmZlZjkzOA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2010-06-08T18:15:53Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2010-06-08T18:15:53Z"}, "message": "re PR tree-optimization/39874 (missing VRP (submission))\n\n2010-06-08  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR tree-optimization/39874\n\tPR middle-end/28685\n\n\tgcc/\n\t* gimple.h (maybe_fold_and_comparisons, maybe_fold_or_comparisons):\n\tDeclare.\n\t* gimple-fold.c (canonicalize_bool, same_bool_comparison_p,\n\tsame_bool_result_p): New.\n\t(and_var_with_comparison, and_var_with_comparison_1,\n\tand_comparisons_1, and_comparisons, maybe_fold_and_comparisons): New.\n\t(or_var_with_comparison, or_var_with_comparison_1,\n\tor_comparisons_1, or_comparisons, maybe_fold_or_comparisons): New.\n\t* tree-ssa-reassoc.c (eliminate_redundant_comparison): Use\n\tmaybe_fold_and_comparisons or maybe_fold_or_comparisons instead\n\tof combine_comparisons.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif, ifcombine_iforif): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr39874.c: New file.\n\nFrom-SVN: r160445", "tree": {"sha": "4a855d962c105784a8cbaa9f50b09a09cba934e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a855d962c105784a8cbaa9f50b09a09cba934e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89065a17202234f50185ce3bf2a80efb2fef938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89065a17202234f50185ce3bf2a80efb2fef938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89065a17202234f50185ce3bf2a80efb2fef938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89065a17202234f50185ce3bf2a80efb2fef938/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c547eb0db1e58bbe7346705cc35ac36891fee425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c547eb0db1e58bbe7346705cc35ac36891fee425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c547eb0db1e58bbe7346705cc35ac36891fee425"}], "stats": {"total": 1176, "additions": 1137, "deletions": 39}, "files": [{"sha": "33a4071047f1b4f9e6009d4b90c21fc1187bb46b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -1,3 +1,20 @@\n+2010-06-08  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR tree-optimization/39874\n+\tPR middle-end/28685\n+\t* gimple.h (maybe_fold_and_comparisons, maybe_fold_or_comparisons):\n+\tDeclare.\n+\t* gimple-fold.c (canonicalize_bool, same_bool_comparison_p,\n+\tsame_bool_result_p): New.\n+\t(and_var_with_comparison, and_var_with_comparison_1,\n+\tand_comparisons_1, and_comparisons, maybe_fold_and_comparisons): New.\n+\t(or_var_with_comparison, or_var_with_comparison_1,\n+\tor_comparisons_1, or_comparisons, maybe_fold_or_comparisons): New.\n+\t* tree-ssa-reassoc.c (eliminate_redundant_comparison): Use\n+\tmaybe_fold_and_comparisons or maybe_fold_or_comparisons instead\n+\tof combine_comparisons.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif, ifcombine_iforif): Likewise.\n+\n 2010-06-08  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/pdp11/pdp11.h (FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE,"}, {"sha": "3479d07019e902baeff7042b9e709d65ed69b7d9", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1049, "deletions": 0, "changes": 1049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -1716,3 +1716,1052 @@ fold_stmt_inplace (gimple stmt)\n   return changed;\n }\n \n+/* Canonicalize and possibly invert the boolean EXPR; return NULL_TREE \n+   if EXPR is null or we don't know how.\n+   If non-null, the result always has boolean type.  */\n+\n+static tree\n+canonicalize_bool (tree expr, bool invert)\n+{\n+  if (!expr)\n+    return NULL_TREE;\n+  else if (invert)\n+    {\n+      if (integer_nonzerop (expr))\n+\treturn boolean_false_node;\n+      else if (integer_zerop (expr))\n+\treturn boolean_true_node;\n+      else if (TREE_CODE (expr) == SSA_NAME)\n+\treturn fold_build2 (EQ_EXPR, boolean_type_node, expr,\n+\t\t\t    build_int_cst (TREE_TYPE (expr), 0));\n+      else if (TREE_CODE_CLASS (TREE_CODE (expr)) == tcc_comparison)\n+\treturn fold_build2 (invert_tree_comparison (TREE_CODE (expr), false),\n+\t\t\t    boolean_type_node,\n+\t\t\t    TREE_OPERAND (expr, 0),\n+\t\t\t    TREE_OPERAND (expr, 1));\n+      else\n+\treturn NULL_TREE;\n+    }\n+  else\n+    {\n+      if (TREE_CODE (TREE_TYPE (expr)) == BOOLEAN_TYPE)\n+\treturn expr;\n+      if (integer_nonzerop (expr))\n+\treturn boolean_true_node;\n+      else if (integer_zerop (expr))\n+\treturn boolean_false_node;\n+      else if (TREE_CODE (expr) == SSA_NAME)\n+\treturn fold_build2 (NE_EXPR, boolean_type_node, expr,\n+\t\t\t    build_int_cst (TREE_TYPE (expr), 0));\n+      else if (TREE_CODE_CLASS (TREE_CODE (expr)) == tcc_comparison)\n+\treturn fold_build2 (TREE_CODE (expr),\n+\t\t\t    boolean_type_node,\n+\t\t\t    TREE_OPERAND (expr, 0),\n+\t\t\t    TREE_OPERAND (expr, 1));\n+      else\n+\treturn NULL_TREE;\n+    }\n+}\n+\n+/* Check to see if a boolean expression EXPR is logically equivalent to the\n+   comparison (OP1 CODE OP2).  Check for various identities involving\n+   SSA_NAMEs.  */\n+\n+static bool\n+same_bool_comparison_p (const_tree expr, enum tree_code code,\n+\t\t\tconst_tree op1, const_tree op2)\n+{\n+  gimple s;\n+\n+  /* The obvious case.  */\n+  if (TREE_CODE (expr) == code\n+      && operand_equal_p (TREE_OPERAND (expr, 0), op1, 0)\n+      && operand_equal_p (TREE_OPERAND (expr, 1), op2, 0))\n+    return true;\n+\n+  /* Check for comparing (name, name != 0) and the case where expr\n+     is an SSA_NAME with a definition matching the comparison.  */\n+  if (TREE_CODE (expr) == SSA_NAME\n+      && TREE_CODE (TREE_TYPE (expr)) == BOOLEAN_TYPE)\n+    {\n+      if (operand_equal_p (expr, op1, 0))\n+\treturn ((code == NE_EXPR && integer_zerop (op2))\n+\t\t|| (code == EQ_EXPR && integer_nonzerop (op2)));\n+      s = SSA_NAME_DEF_STMT (expr);\n+      if (is_gimple_assign (s)\n+\t  && gimple_assign_rhs_code (s) == code\n+\t  && operand_equal_p (gimple_assign_rhs1 (s), op1, 0)\n+\t  && operand_equal_p (gimple_assign_rhs2 (s), op2, 0))\n+\treturn true;\n+    }\n+\n+  /* If op1 is of the form (name != 0) or (name == 0), and the definition\n+     of name is a comparison, recurse.  */\n+  if (TREE_CODE (op1) == SSA_NAME\n+      && TREE_CODE (TREE_TYPE (op1)) == BOOLEAN_TYPE)\n+    {\n+      s = SSA_NAME_DEF_STMT (op1);\n+      if (is_gimple_assign (s)\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison)\n+\t{\n+\t  enum tree_code c = gimple_assign_rhs_code (s);\n+\t  if ((c == NE_EXPR && integer_zerop (op2))\n+\t      || (c == EQ_EXPR && integer_nonzerop (op2)))\n+\t    return same_bool_comparison_p (expr, c,\n+\t\t\t\t\t   gimple_assign_rhs1 (s),\n+\t\t\t\t\t   gimple_assign_rhs2 (s));\n+\t  if ((c == EQ_EXPR && integer_zerop (op2))\n+\t      || (c == NE_EXPR && integer_nonzerop (op2)))\n+\t    return same_bool_comparison_p (expr,\n+\t\t\t\t\t   invert_tree_comparison (c, false),\n+\t\t\t\t\t   gimple_assign_rhs1 (s),\n+\t\t\t\t\t   gimple_assign_rhs2 (s));\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Check to see if two boolean expressions OP1 and OP2 are logically\n+   equivalent.  */\n+\n+static bool\n+same_bool_result_p (const_tree op1, const_tree op2)\n+{\n+  /* Simple cases first.  */\n+  if (operand_equal_p (op1, op2, 0))\n+    return true;\n+\n+  /* Check the cases where at least one of the operands is a comparison.\n+     These are a bit smarter than operand_equal_p in that they apply some\n+     identifies on SSA_NAMEs.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (op2)) == tcc_comparison\n+      && same_bool_comparison_p (op1, TREE_CODE (op2),\n+\t\t\t\t TREE_OPERAND (op2, 0),\n+\t\t\t\t TREE_OPERAND (op2, 1)))\n+    return true;\n+  if (TREE_CODE_CLASS (TREE_CODE (op1)) == tcc_comparison\n+      && same_bool_comparison_p (op2, TREE_CODE (op1),\n+\t\t\t\t TREE_OPERAND (op1, 0),\n+\t\t\t\t TREE_OPERAND (op1, 1)))\n+    return true;\n+\n+  /* Default case.  */\n+  return false;\n+}\n+\n+/* Forward declarations for some mutually recursive functions.  */\n+\n+static tree\n+and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+\t\t   enum tree_code code2, tree op2a, tree op2b);\n+static tree\n+and_var_with_comparison (tree var, bool invert,\n+\t\t\t enum tree_code code2, tree op2a, tree op2b);\n+static tree\n+and_var_with_comparison_1 (gimple stmt, \n+\t\t\t   enum tree_code code2, tree op2a, tree op2b);\n+static tree\n+or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+\t\t  enum tree_code code2, tree op2a, tree op2b);\n+static tree\n+or_var_with_comparison (tree var, bool invert,\n+\t\t\tenum tree_code code2, tree op2a, tree op2b);\n+static tree\n+or_var_with_comparison_1 (gimple stmt, \n+\t\t\t  enum tree_code code2, tree op2a, tree op2b);\n+\n+/* Helper function for and_comparisons_1:  try to simplify the AND of the\n+   ssa variable VAR with the comparison specified by (OP2A CODE2 OP2B).\n+   If INVERT is true, invert the value of the VAR before doing the AND.\n+   Return NULL_EXPR if we can't simplify this to a single expression.  */\n+\n+static tree\n+and_var_with_comparison (tree var, bool invert,\n+\t\t\t enum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree t;\n+  gimple stmt = SSA_NAME_DEF_STMT (var);\n+\n+  /* We can only deal with variables whose definitions are assignments.  */\n+  if (!is_gimple_assign (stmt))\n+    return NULL_TREE;\n+  \n+  /* If we have an inverted comparison, apply DeMorgan's law and rewrite\n+     !var AND (op2a code2 op2b) => !(var OR !(op2a code2 op2b))\n+     Then we only have to consider the simpler non-inverted cases.  */\n+  if (invert)\n+    t = or_var_with_comparison_1 (stmt, \n+\t\t\t\t  invert_tree_comparison (code2, false),\n+\t\t\t\t  op2a, op2b);\n+  else\n+    t = and_var_with_comparison_1 (stmt, code2, op2a, op2b);\n+  return canonicalize_bool (t, invert);\n+}\n+\n+/* Try to simplify the AND of the ssa variable defined by the assignment\n+   STMT with the comparison specified by (OP2A CODE2 OP2B).\n+   Return NULL_EXPR if we can't simplify this to a single expression.  */\n+\n+static tree\n+and_var_with_comparison_1 (gimple stmt,\n+\t\t\t   enum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree var = gimple_assign_lhs (stmt);\n+  tree true_test_var = NULL_TREE;\n+  tree false_test_var = NULL_TREE;\n+  enum tree_code innercode = gimple_assign_rhs_code (stmt);\n+\n+  /* Check for identities like (var AND (var == 0)) => false.  */\n+  if (TREE_CODE (op2a) == SSA_NAME\n+      && TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE)\n+    {\n+      if ((code2 == NE_EXPR && integer_zerop (op2b))\n+\t  || (code2 == EQ_EXPR && integer_nonzerop (op2b)))\n+\t{\n+\t  true_test_var = op2a;\n+\t  if (var == true_test_var)\n+\t    return var;\n+\t}\n+      else if ((code2 == EQ_EXPR && integer_zerop (op2b))\n+\t       || (code2 == NE_EXPR && integer_nonzerop (op2b)))\n+\t{\n+\t  false_test_var = op2a;\n+\t  if (var == false_test_var)\n+\t    return boolean_false_node;\n+\t}\n+    }\n+\n+  /* If the definition is a comparison, recurse on it.  */\n+  if (TREE_CODE_CLASS (innercode) == tcc_comparison)\n+    {\n+      tree t = and_comparisons_1 (innercode,\n+\t\t\t\t  gimple_assign_rhs1 (stmt),\n+\t\t\t\t  gimple_assign_rhs2 (stmt),\n+\t\t\t\t  code2,\n+\t\t\t\t  op2a,\n+\t\t\t\t  op2b);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  /* If the definition is an AND or OR expression, we may be able to\n+     simplify by reassociating.  */\n+  if (innercode == TRUTH_AND_EXPR\n+      || innercode == TRUTH_OR_EXPR\n+      || (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n+\t  && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR)))\n+    {\n+      tree inner1 = gimple_assign_rhs1 (stmt);\n+      tree inner2 = gimple_assign_rhs2 (stmt);\n+      gimple s;\n+      tree t;\n+      tree partial = NULL_TREE;\n+      bool is_and = (innercode == TRUTH_AND_EXPR || innercode == BIT_AND_EXPR);\n+      \n+      /* Check for boolean identities that don't require recursive examination\n+\t of inner1/inner2:\n+\t inner1 AND (inner1 AND inner2) => inner1 AND inner2 => var\n+\t inner1 AND (inner1 OR inner2) => inner1\n+\t !inner1 AND (inner1 AND inner2) => false\n+\t !inner1 AND (inner1 OR inner2) => !inner1 AND inner2\n+         Likewise for similar cases involving inner2.  */\n+      if (inner1 == true_test_var)\n+\treturn (is_and ? var : inner1);\n+      else if (inner2 == true_test_var)\n+\treturn (is_and ? var : inner2);\n+      else if (inner1 == false_test_var)\n+\treturn (is_and\n+\t\t? boolean_false_node\n+\t\t: and_var_with_comparison (inner2, false, code2, op2a, op2b));\n+      else if (inner2 == false_test_var)\n+\treturn (is_and\n+\t\t? boolean_false_node\n+\t\t: and_var_with_comparison (inner1, false, code2, op2a, op2b));\n+\n+      /* Next, redistribute/reassociate the AND across the inner tests.\n+\t Compute the first partial result, (inner1 AND (op2a code op2b))  */\n+      if (TREE_CODE (inner1) == SSA_NAME\n+\t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner1))\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n+\t  && (t = maybe_fold_and_comparisons (gimple_assign_rhs_code (s),\n+\t\t\t\t\t      gimple_assign_rhs1 (s),\n+\t\t\t\t\t      gimple_assign_rhs2 (s),\n+\t\t\t\t\t      code2, op2a, op2b)))\n+\t{\n+\t  /* Handle the AND case, where we are reassociating:\n+\t     (inner1 AND inner2) AND (op2a code2 op2b)\n+\t     => (t AND inner2)\n+\t     If the partial result t is a constant, we win.  Otherwise\n+\t     continue on to try reassociating with the other inner test.  */\n+\t  if (is_and)\n+\t    {\n+\t      if (integer_onep (t))\n+\t\treturn inner2;\n+\t      else if (integer_zerop (t))\n+\t\treturn boolean_false_node;\n+\t    }\n+\n+\t  /* Handle the OR case, where we are redistributing:\n+\t     (inner1 OR inner2) AND (op2a code2 op2b)\n+\t     => (t OR (inner2 AND (op2a code2 op2b)))  */\n+\t  else\n+\t    {\n+\t      if (integer_onep (t))\n+\t\treturn boolean_true_node;\n+\t      else\n+\t\t/* Save partial result for later.  */\n+\t\tpartial = t;\n+\t    }\n+\t}\n+      \n+      /* Compute the second partial result, (inner2 AND (op2a code op2b)) */\n+      if (TREE_CODE (inner2) == SSA_NAME\n+\t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner2))\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n+\t  && (t = maybe_fold_and_comparisons (gimple_assign_rhs_code (s),\n+\t\t\t\t\t      gimple_assign_rhs1 (s),\n+\t\t\t\t\t      gimple_assign_rhs2 (s),\n+\t\t\t\t\t      code2, op2a, op2b)))\n+\t{\n+\t  /* Handle the AND case, where we are reassociating:\n+\t     (inner1 AND inner2) AND (op2a code2 op2b)\n+\t     => (inner1 AND t)  */\n+\t  if (is_and)\n+\t    {\n+\t      if (integer_onep (t))\n+\t\treturn inner1;\n+\t      else if (integer_zerop (t))\n+\t\treturn boolean_false_node;\n+\t    }\n+\n+\t  /* Handle the OR case. where we are redistributing:\n+\t     (inner1 OR inner2) AND (op2a code2 op2b)\n+\t     => (t OR (inner1 AND (op2a code2 op2b)))\n+\t     => (t OR partial)  */\n+\t  else\n+\t    {\n+\t      if (integer_onep (t))\n+\t\treturn boolean_true_node;\n+\t      else if (partial)\n+\t\t{\n+\t\t  /* We already got a simplification for the other\n+\t\t     operand to the redistributed OR expression.  The\n+\t\t     interesting case is when at least one is false.\n+\t\t     Or, if both are the same, we can apply the identity\n+\t\t     (x OR x) == x.  */\n+\t\t  if (integer_zerop (partial))\n+\t\t    return t;\n+\t\t  else if (integer_zerop (t))\n+\t\t    return partial;\n+\t\t  else if (same_bool_result_p (t, partial))\n+\t\t    return t;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Try to simplify the AND of two comparisons defined by\n+   (OP1A CODE1 OP1B) and (OP2A CODE2 OP2B), respectively.\n+   If this can be done without constructing an intermediate value,\n+   return the resulting tree; otherwise NULL_TREE is returned.\n+   This function is deliberately asymmetric as it recurses on SSA_DEFs\n+   in the first comparison but not the second.  */\n+\n+static tree\n+and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+\t\t   enum tree_code code2, tree op2a, tree op2b)\n+{\n+  /* First check for ((x CODE1 y) AND (x CODE2 y)).  */\n+  if (operand_equal_p (op1a, op2a, 0)\n+      && operand_equal_p (op1b, op2b, 0))\n+    {\n+      tree t = combine_comparisons (UNKNOWN_LOCATION,\n+\t\t\t\t    TRUTH_ANDIF_EXPR, code1, code2,\n+\t\t\t\t    boolean_type_node, op1a, op1b);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  /* Likewise the swapped case of the above.  */\n+  if (operand_equal_p (op1a, op2b, 0)\n+      && operand_equal_p (op1b, op2a, 0))\n+    {\n+      tree t = combine_comparisons (UNKNOWN_LOCATION,\n+\t\t\t\t    TRUTH_ANDIF_EXPR, code1,\n+\t\t\t\t    swap_tree_comparison (code2),\n+\t\t\t\t    boolean_type_node, op1a, op1b);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  /* If both comparisons are of the same value against constants, we might\n+     be able to merge them.  */\n+  if (operand_equal_p (op1a, op2a, 0)\n+      && TREE_CODE (op1b) == INTEGER_CST\n+      && TREE_CODE (op2b) == INTEGER_CST)\n+    {\n+      int cmp = tree_int_cst_compare (op1b, op2b);\n+\n+      /* If we have (op1a == op1b), we should either be able to\n+\t return that or FALSE, depending on whether the constant op1b\n+\t also satisfies the other comparison against op2b.  */\n+      if (code1 == EQ_EXPR)\n+\t{\n+\t  bool done = true;\n+\t  bool val;\n+\t  switch (code2)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp < 0); break;\n+\t    case GT_EXPR: val = (cmp > 0); break;\n+\t    case LE_EXPR: val = (cmp <= 0); break;\n+\t    case GE_EXPR: val = (cmp >= 0); break;\n+\t    default: done = false;\n+\t    }\n+\t  if (done)\n+\t    {\n+\t      if (val)\n+\t\treturn fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t      else\n+\t\treturn boolean_false_node;\n+\t    }\n+\t}\n+      /* Likewise if the second comparison is an == comparison.  */\n+      else if (code2 == EQ_EXPR)\n+\t{\n+\t  bool done = true;\n+\t  bool val;\n+\t  switch (code1)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp > 0); break;\n+\t    case GT_EXPR: val = (cmp < 0); break;\n+\t    case LE_EXPR: val = (cmp >= 0); break;\n+\t    case GE_EXPR: val = (cmp <= 0); break;\n+\t    default: done = false;\n+\t    }\n+\t  if (done)\n+\t    {\n+\t      if (val)\n+\t\treturn fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t      else\n+\t\treturn boolean_false_node;\n+\t    }\n+\t}\n+\n+      /* Same business with inequality tests.  */\n+      else if (code1 == NE_EXPR)\n+\t{\n+\t  bool val;\n+\t  switch (code2)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp != 0); break;\n+\t    case NE_EXPR: val = (cmp == 0); break;\n+\t    case LT_EXPR: val = (cmp >= 0); break;\n+\t    case GT_EXPR: val = (cmp <= 0); break;\n+\t    case LE_EXPR: val = (cmp > 0); break;\n+\t    case GE_EXPR: val = (cmp < 0); break;\n+\t    default:\n+\t      val = false;\n+\t    }\n+\t  if (val)\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t}\n+      else if (code2 == NE_EXPR)\n+\t{\n+\t  bool val;\n+\t  switch (code1)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp <= 0); break;\n+\t    case GT_EXPR: val = (cmp >= 0); break;\n+\t    case LE_EXPR: val = (cmp < 0); break;\n+\t    case GE_EXPR: val = (cmp > 0); break;\n+\t    default:\n+\t      val = false;\n+\t    }\n+\t  if (val)\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t}\n+\n+      /* Chose the more restrictive of two < or <= comparisons.  */\n+      else if ((code1 == LT_EXPR || code1 == LE_EXPR)\n+\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n+\t{\n+\t  if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t  else\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t}\n+\n+      /* Likewise chose the more restrictive of two > or >= comparisons.  */\n+      else if ((code1 == GT_EXPR || code1 == GE_EXPR)\n+\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n+\t{\n+\t  if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t  else\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t}\n+\n+      /* Check for singleton ranges.  */\n+      else if (cmp == 0\n+\t       && ((code1 == LE_EXPR && code2 == GE_EXPR)\n+\t\t   || (code1 == GE_EXPR && code2 == LE_EXPR)))\n+\treturn fold_build2 (EQ_EXPR, boolean_type_node, op1a, op2b);\n+\n+      /* Check for disjoint ranges. */\n+      else if (cmp <= 0\n+\t       && (code1 == LT_EXPR || code1 == LE_EXPR)\n+\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n+\treturn boolean_false_node;\n+      else if (cmp >= 0\n+\t       && (code1 == GT_EXPR || code1 == GE_EXPR)\n+\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n+\treturn boolean_false_node;\n+    }\n+\n+  /* Perhaps the first comparison is (NAME != 0) or (NAME == 1) where\n+     NAME's definition is a truth value.  See if there are any simplifications\n+     that can be done against the NAME's definition.  */\n+  if (TREE_CODE (op1a) == SSA_NAME\n+      && (code1 == NE_EXPR || code1 == EQ_EXPR)\n+      && (integer_zerop (op1b) || integer_onep (op1b)))\n+    {\n+      bool invert = ((code1 == EQ_EXPR && integer_zerop (op1b))\n+\t\t     || (code1 == NE_EXPR && integer_onep (op1b)));\n+      gimple stmt = SSA_NAME_DEF_STMT (op1a);\n+      switch (gimple_code (stmt))\n+\t{\n+\tcase GIMPLE_ASSIGN:\n+\t  /* Try to simplify by copy-propagating the definition.  */\n+\t  return and_var_with_comparison (op1a, invert, code2, op2a, op2b);\n+\n+\tcase GIMPLE_PHI:\n+\t  /* If every argument to the PHI produces the same result when\n+\t     ANDed with the second comparison, we win.\n+\t     Do not do this unless the type is bool since we need a bool\n+\t     result here anyway.  */\n+\t  if (TREE_CODE (TREE_TYPE (op1a)) == BOOLEAN_TYPE)\n+\t    {\n+\t      tree result = NULL_TREE;\n+\t      unsigned i;\n+\t      for (i = 0; i < gimple_phi_num_args (stmt); i++)\n+\t\t{\n+\t\t  tree arg = gimple_phi_arg_def (stmt, i);\n+\t\t  \n+\t\t  /* If this PHI has itself as an argument, ignore it.\n+\t\t     If all the other args produce the same result,\n+\t\t     we're still OK.  */\n+\t\t  if (arg == gimple_phi_result (stmt))\n+\t\t    continue;\n+\t\t  else if (TREE_CODE (arg) == INTEGER_CST)\n+\t\t    {\n+\t\t      if (invert ? integer_nonzerop (arg) : integer_zerop (arg))\n+\t\t\t{\n+\t\t\t  if (!result)\n+\t\t\t    result = boolean_false_node;\n+\t\t\t  else if (!integer_zerop (result))\n+\t\t\t    return NULL_TREE;\n+\t\t\t}\n+\t\t      else if (!result)\n+\t\t\tresult = fold_build2 (code2, boolean_type_node,\n+\t\t\t\t\t      op2a, op2b);\n+\t\t      else if (!same_bool_comparison_p (result,\n+\t\t\t\t\t\t\tcode2, op2a, op2b))\n+\t\t\treturn NULL_TREE;\n+\t\t    }\n+\t\t  else if (TREE_CODE (arg) == SSA_NAME)\n+\t\t    {\n+\t\t      tree temp = and_var_with_comparison (arg, invert,\n+\t\t\t\t\t\t\t   code2, op2a, op2b);\n+\t\t      if (!temp)\n+\t\t\treturn NULL_TREE;\n+\t\t      else if (!result)\n+\t\t\tresult = temp;\n+\t\t      else if (!same_bool_result_p (result, temp))\n+\t\t\treturn NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    return NULL_TREE;\n+\t\t}\n+\t      return result;\n+\t    }\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Try to simplify the AND of two comparisons, specified by\n+   (OP1A CODE1 OP1B) and (OP2B CODE2 OP2B), respectively.\n+   If this can be simplified to a single expression (without requiring\n+   introducing more SSA variables to hold intermediate values),\n+   return the resulting tree.  Otherwise return NULL_TREE.\n+   If the result expression is non-null, it has boolean type.  */\n+\n+tree\n+maybe_fold_and_comparisons (enum tree_code code1, tree op1a, tree op1b,\n+\t\t\t    enum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree t = and_comparisons_1 (code1, op1a, op1b, code2, op2a, op2b);\n+  if (t)\n+    return t;\n+  else\n+    return and_comparisons_1 (code2, op2a, op2b, code1, op1a, op1b);\n+}\n+\n+/* Helper function for or_comparisons_1:  try to simplify the OR of the\n+   ssa variable VAR with the comparison specified by (OP2A CODE2 OP2B).\n+   If INVERT is true, invert the value of VAR before doing the OR.\n+   Return NULL_EXPR if we can't simplify this to a single expression.  */\n+\n+static tree\n+or_var_with_comparison (tree var, bool invert,\n+\t\t\tenum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree t;\n+  gimple stmt = SSA_NAME_DEF_STMT (var);\n+\n+  /* We can only deal with variables whose definitions are assignments.  */\n+  if (!is_gimple_assign (stmt))\n+    return NULL_TREE;\n+  \n+  /* If we have an inverted comparison, apply DeMorgan's law and rewrite\n+     !var OR (op2a code2 op2b) => !(var AND !(op2a code2 op2b))\n+     Then we only have to consider the simpler non-inverted cases.  */\n+  if (invert)\n+    t = and_var_with_comparison_1 (stmt, \n+\t\t\t\t   invert_tree_comparison (code2, false),\n+\t\t\t\t   op2a, op2b);\n+  else\n+    t = or_var_with_comparison_1 (stmt, code2, op2a, op2b);\n+  return canonicalize_bool (t, invert);\n+}\n+\n+/* Try to simplify the OR of the ssa variable defined by the assignment\n+   STMT with the comparison specified by (OP2A CODE2 OP2B).\n+   Return NULL_EXPR if we can't simplify this to a single expression.  */\n+\n+static tree\n+or_var_with_comparison_1 (gimple stmt,\n+\t\t\t  enum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree var = gimple_assign_lhs (stmt);\n+  tree true_test_var = NULL_TREE;\n+  tree false_test_var = NULL_TREE;\n+  enum tree_code innercode = gimple_assign_rhs_code (stmt);\n+\n+  /* Check for identities like (var OR (var != 0)) => true .  */\n+  if (TREE_CODE (op2a) == SSA_NAME\n+      && TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE)\n+    {\n+      if ((code2 == NE_EXPR && integer_zerop (op2b))\n+\t  || (code2 == EQ_EXPR && integer_nonzerop (op2b)))\n+\t{\n+\t  true_test_var = op2a;\n+\t  if (var == true_test_var)\n+\t    return var;\n+\t}\n+      else if ((code2 == EQ_EXPR && integer_zerop (op2b))\n+\t       || (code2 == NE_EXPR && integer_nonzerop (op2b)))\n+\t{\n+\t  false_test_var = op2a;\n+\t  if (var == false_test_var)\n+\t    return boolean_true_node;\n+\t}\n+    }\n+\n+  /* If the definition is a comparison, recurse on it.  */\n+  if (TREE_CODE_CLASS (innercode) == tcc_comparison)\n+    {\n+      tree t = or_comparisons_1 (innercode,\n+\t\t\t\t gimple_assign_rhs1 (stmt),\n+\t\t\t\t gimple_assign_rhs2 (stmt),\n+\t\t\t\t code2,\n+\t\t\t\t op2a,\n+\t\t\t\t op2b);\n+      if (t)\n+\treturn t;\n+    }\n+  \n+  /* If the definition is an AND or OR expression, we may be able to\n+     simplify by reassociating.  */\n+  if (innercode == TRUTH_AND_EXPR\n+      || innercode == TRUTH_OR_EXPR\n+      || (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n+\t  && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR)))\n+    {\n+      tree inner1 = gimple_assign_rhs1 (stmt);\n+      tree inner2 = gimple_assign_rhs2 (stmt);\n+      gimple s;\n+      tree t;\n+      tree partial = NULL_TREE;\n+      bool is_or = (innercode == TRUTH_OR_EXPR || innercode == BIT_IOR_EXPR);\n+      \n+      /* Check for boolean identities that don't require recursive examination\n+\t of inner1/inner2:\n+\t inner1 OR (inner1 OR inner2) => inner1 OR inner2 => var\n+\t inner1 OR (inner1 AND inner2) => inner1\n+\t !inner1 OR (inner1 OR inner2) => true\n+\t !inner1 OR (inner1 AND inner2) => !inner1 OR inner2\n+      */\n+      if (inner1 == true_test_var)\n+\treturn (is_or ? var : inner1);\n+      else if (inner2 == true_test_var)\n+\treturn (is_or ? var : inner2);\n+      else if (inner1 == false_test_var)\n+\treturn (is_or\n+\t\t? boolean_true_node\n+\t\t: or_var_with_comparison (inner2, false, code2, op2a, op2b));\n+      else if (inner2 == false_test_var)\n+\treturn (is_or\n+\t\t? boolean_true_node\n+\t\t: or_var_with_comparison (inner1, false, code2, op2a, op2b));\n+      \n+      /* Next, redistribute/reassociate the OR across the inner tests.\n+\t Compute the first partial result, (inner1 OR (op2a code op2b))  */\n+      if (TREE_CODE (inner1) == SSA_NAME\n+\t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner1))\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n+\t  && (t = maybe_fold_or_comparisons (gimple_assign_rhs_code (s),\n+\t\t\t\t\t     gimple_assign_rhs1 (s),\n+\t\t\t\t\t     gimple_assign_rhs2 (s),\n+\t\t\t\t\t     code2, op2a, op2b)))\n+\t{\n+\t  /* Handle the OR case, where we are reassociating:\n+\t     (inner1 OR inner2) OR (op2a code2 op2b)\n+\t     => (t OR inner2)\n+\t     If the partial result t is a constant, we win.  Otherwise\n+\t     continue on to try reassociating with the other inner test.  */\n+\t  if (innercode == TRUTH_OR_EXPR)\n+\t    {\n+\t      if (integer_onep (t))\n+\t\treturn boolean_true_node;\n+\t      else if (integer_zerop (t))\n+\t\treturn inner2;\n+\t    }\n+\t  \n+\t  /* Handle the AND case, where we are redistributing:\n+\t     (inner1 AND inner2) OR (op2a code2 op2b)\n+\t     => (t AND (inner2 OR (op2a code op2b)))  */\n+\t  else\n+\t    {\n+\t      if (integer_zerop (t))\n+\t\treturn boolean_false_node;\n+\t      else\n+\t\t/* Save partial result for later.  */\n+\t\tpartial = t;\n+\t    }\n+\t}\n+      \n+      /* Compute the second partial result, (inner2 OR (op2a code op2b)) */\n+      if (TREE_CODE (inner2) == SSA_NAME\n+\t  && is_gimple_assign (s = SSA_NAME_DEF_STMT (inner2))\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (s)) == tcc_comparison\n+\t  && (t = maybe_fold_or_comparisons (gimple_assign_rhs_code (s),\n+\t\t\t\t\t     gimple_assign_rhs1 (s),\n+\t\t\t\t\t     gimple_assign_rhs2 (s),\n+\t\t\t\t\t     code2, op2a, op2b)))\n+\t{\n+\t  /* Handle the OR case, where we are reassociating:\n+\t     (inner1 OR inner2) OR (op2a code2 op2b)\n+\t     => (inner1 OR t)  */\n+\t  if (innercode == TRUTH_OR_EXPR)\n+\t    {\n+\t      if (integer_zerop (t))\n+\t\treturn inner1;\n+\t      else if (integer_onep (t))\n+\t\treturn boolean_true_node;\n+\t    }\n+\t  \n+\t  /* Handle the AND case, where we are redistributing:\n+\t     (inner1 AND inner2) OR (op2a code2 op2b)\n+\t     => (t AND (inner1 OR (op2a code2 op2b)))\n+\t     => (t AND partial)  */\n+\t  else \n+\t    {\n+\t      if (integer_zerop (t))\n+\t\treturn boolean_false_node;\n+\t      else if (partial)\n+\t\t{\n+\t\t  /* We already got a simplification for the other\n+\t\t     operand to the redistributed AND expression.  The\n+\t\t     interesting case is when at least one is true.\n+\t\t     Or, if both are the same, we can apply the identity\n+\t\t     (x AND x) == true.  */\n+\t\t  if (integer_onep (partial))\n+\t\t    return t;\n+\t\t  else if (integer_onep (t))\n+\t\t    return partial;\n+\t\t  else if (same_bool_result_p (t, partial))\n+\t\t    return boolean_true_node;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Try to simplify the OR of two comparisons defined by\n+   (OP1A CODE1 OP1B) and (OP2A CODE2 OP2B), respectively.\n+   If this can be done without constructing an intermediate value,\n+   return the resulting tree; otherwise NULL_TREE is returned.\n+   This function is deliberately asymmetric as it recurses on SSA_DEFs\n+   in the first comparison but not the second.  */\n+\n+static tree\n+or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n+\t\t  enum tree_code code2, tree op2a, tree op2b)\n+{\n+  /* First check for ((x CODE1 y) OR (x CODE2 y)).  */\n+  if (operand_equal_p (op1a, op2a, 0)\n+      && operand_equal_p (op1b, op2b, 0))\n+    {\n+      tree t = combine_comparisons (UNKNOWN_LOCATION,\n+\t\t\t\t    TRUTH_ORIF_EXPR, code1, code2,\n+\t\t\t\t    boolean_type_node, op1a, op1b);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  /* Likewise the swapped case of the above.  */\n+  if (operand_equal_p (op1a, op2b, 0)\n+      && operand_equal_p (op1b, op2a, 0))\n+    {\n+      tree t = combine_comparisons (UNKNOWN_LOCATION,\n+\t\t\t\t    TRUTH_ORIF_EXPR, code1,\n+\t\t\t\t    swap_tree_comparison (code2),\n+\t\t\t\t    boolean_type_node, op1a, op1b);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  /* If both comparisons are of the same value against constants, we might\n+     be able to merge them.  */\n+  if (operand_equal_p (op1a, op2a, 0)\n+      && TREE_CODE (op1b) == INTEGER_CST\n+      && TREE_CODE (op2b) == INTEGER_CST)\n+    {\n+      int cmp = tree_int_cst_compare (op1b, op2b);\n+\n+      /* If we have (op1a != op1b), we should either be able to\n+\t return that or TRUE, depending on whether the constant op1b\n+\t also satisfies the other comparison against op2b.  */\n+      if (code1 == NE_EXPR)\n+\t{\n+\t  bool done = true;\n+\t  bool val;\n+\t  switch (code2)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp < 0); break;\n+\t    case GT_EXPR: val = (cmp > 0); break;\n+\t    case LE_EXPR: val = (cmp <= 0); break;\n+\t    case GE_EXPR: val = (cmp >= 0); break;\n+\t    default: done = false;\n+\t    }\n+\t  if (done)\n+\t    {\n+\t      if (val)\n+\t\treturn boolean_true_node;\n+\t      else\n+\t\treturn fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t    }\n+\t}\n+      /* Likewise if the second comparison is a != comparison.  */\n+      else if (code2 == NE_EXPR)\n+\t{\n+\t  bool done = true;\n+\t  bool val;\n+\t  switch (code1)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp > 0); break;\n+\t    case GT_EXPR: val = (cmp < 0); break;\n+\t    case LE_EXPR: val = (cmp >= 0); break;\n+\t    case GE_EXPR: val = (cmp <= 0); break;\n+\t    default: done = false;\n+\t    }\n+\t  if (done)\n+\t    {\n+\t      if (val)\n+\t\treturn boolean_true_node;\n+\t      else\n+\t\treturn fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t    }\n+\t}\n+\n+      /* See if an equality test is redundant with the other comparison.  */\n+      else if (code1 == EQ_EXPR)\n+\t{\n+\t  bool val;\n+\t  switch (code2)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp < 0); break;\n+\t    case GT_EXPR: val = (cmp > 0); break;\n+\t    case LE_EXPR: val = (cmp <= 0); break;\n+\t    case GE_EXPR: val = (cmp >= 0); break;\n+\t    default:\n+\t      val = false;\n+\t    }\n+\t  if (val)\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t}\n+      else if (code2 == EQ_EXPR)\n+\t{\n+\t  bool val;\n+\t  switch (code1)\n+\t    {\n+\t    case EQ_EXPR: val = (cmp == 0); break;\n+\t    case NE_EXPR: val = (cmp != 0); break;\n+\t    case LT_EXPR: val = (cmp > 0); break;\n+\t    case GT_EXPR: val = (cmp < 0); break;\n+\t    case LE_EXPR: val = (cmp >= 0); break;\n+\t    case GE_EXPR: val = (cmp <= 0); break;\n+\t    default:\n+\t      val = false;\n+\t    }\n+\t  if (val)\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t}\n+\n+      /* Chose the less restrictive of two < or <= comparisons.  */\n+      else if ((code1 == LT_EXPR || code1 == LE_EXPR)\n+\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n+\t{\n+\t  if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t  else\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t}\n+\n+      /* Likewise chose the less restrictive of two > or >= comparisons.  */\n+      else if ((code1 == GT_EXPR || code1 == GE_EXPR)\n+\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n+\t{\n+\t  if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n+\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n+\t  else\n+\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n+\t}\n+\n+      /* Check for singleton ranges.  */\n+      else if (cmp == 0\n+\t       && ((code1 == LT_EXPR && code2 == GT_EXPR)\n+\t\t   || (code1 == GT_EXPR && code2 == LT_EXPR)))\n+\treturn fold_build2 (NE_EXPR, boolean_type_node, op1a, op2b);\n+\n+      /* Check for less/greater pairs that don't restrict the range at all.  */\n+      else if (cmp >= 0\n+\t       && (code1 == LT_EXPR || code1 == LE_EXPR)\n+\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n+\treturn boolean_true_node;\n+      else if (cmp <= 0\n+\t       && (code1 == GT_EXPR || code1 == GE_EXPR)\n+\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n+\treturn boolean_true_node;\n+    }\n+\n+  /* Perhaps the first comparison is (NAME != 0) or (NAME == 1) where\n+     NAME's definition is a truth value.  See if there are any simplifications\n+     that can be done against the NAME's definition.  */\n+  if (TREE_CODE (op1a) == SSA_NAME\n+      && (code1 == NE_EXPR || code1 == EQ_EXPR)\n+      && (integer_zerop (op1b) || integer_onep (op1b)))\n+    {\n+      bool invert = ((code1 == EQ_EXPR && integer_zerop (op1b))\n+\t\t     || (code1 == NE_EXPR && integer_onep (op1b)));\n+      gimple stmt = SSA_NAME_DEF_STMT (op1a);\n+      switch (gimple_code (stmt))\n+\t{\n+\tcase GIMPLE_ASSIGN:\n+\t  /* Try to simplify by copy-propagating the definition.  */\n+\t  return or_var_with_comparison (op1a, invert, code2, op2a, op2b);\n+\n+\tcase GIMPLE_PHI:\n+\t  /* If every argument to the PHI produces the same result when\n+\t     ORed with the second comparison, we win.\n+\t     Do not do this unless the type is bool since we need a bool\n+\t     result here anyway.  */\n+\t  if (TREE_CODE (TREE_TYPE (op1a)) == BOOLEAN_TYPE)\n+\t    {\n+\t      tree result = NULL_TREE;\n+\t      unsigned i;\n+\t      for (i = 0; i < gimple_phi_num_args (stmt); i++)\n+\t\t{\n+\t\t  tree arg = gimple_phi_arg_def (stmt, i);\n+\t\t  \n+\t\t  /* If this PHI has itself as an argument, ignore it.\n+\t\t     If all the other args produce the same result,\n+\t\t     we're still OK.  */\n+\t\t  if (arg == gimple_phi_result (stmt))\n+\t\t    continue;\n+\t\t  else if (TREE_CODE (arg) == INTEGER_CST)\n+\t\t    {\n+\t\t      if (invert ? integer_zerop (arg) : integer_nonzerop (arg))\n+\t\t\t{\n+\t\t\t  if (!result)\n+\t\t\t    result = boolean_true_node;\n+\t\t\t  else if (!integer_onep (result))\n+\t\t\t    return NULL_TREE;\n+\t\t\t}\n+\t\t      else if (!result)\n+\t\t\tresult = fold_build2 (code2, boolean_type_node,\n+\t\t\t\t\t      op2a, op2b);\n+\t\t      else if (!same_bool_comparison_p (result,\n+\t\t\t\t\t\t\tcode2, op2a, op2b))\n+\t\t\treturn NULL_TREE;\n+\t\t    }\n+\t\t  else if (TREE_CODE (arg) == SSA_NAME)\n+\t\t    {\n+\t\t      tree temp = or_var_with_comparison (arg, invert,\n+\t\t\t\t\t\t\t  code2, op2a, op2b);\n+\t\t      if (!temp)\n+\t\t\treturn NULL_TREE;\n+\t\t      else if (!result)\n+\t\t\tresult = temp;\n+\t\t      else if (!same_bool_result_p (result, temp))\n+\t\t\treturn NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    return NULL_TREE;\n+\t\t}\n+\t      return result;\n+\t    }\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Try to simplify the OR of two comparisons, specified by\n+   (OP1A CODE1 OP1B) and (OP2B CODE2 OP2B), respectively.\n+   If this can be simplified to a single expression (without requiring\n+   introducing more SSA variables to hold intermediate values),\n+   return the resulting tree.  Otherwise return NULL_TREE.\n+   If the result expression is non-null, it has boolean type.  */\n+\n+tree\n+maybe_fold_or_comparisons (enum tree_code code1, tree op1a, tree op1b,\n+\t\t\t   enum tree_code code2, tree op2a, tree op2b)\n+{\n+  tree t = or_comparisons_1 (code1, op1a, op1b, code2, op2a, op2b);\n+  if (t)\n+    return t;\n+  else\n+    return or_comparisons_1 (code2, op2a, op2b, code1, op1a, op1b);\n+}"}, {"sha": "c91ca49591b7ee280eace7c55cb718e5e95d46ba", "filename": "gcc/gimple.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -4812,6 +4812,9 @@ tree maybe_fold_offset_to_address (location_t, tree, tree, tree);\n tree maybe_fold_stmt_addition (location_t, tree, tree, tree);\n tree get_symbol_constant_value (tree);\n bool may_propagate_address_into_dereference (tree, tree);\n-\n+extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n+\t\t\t\t\tenum tree_code, tree, tree);\n+extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n+\t\t\t\t       enum tree_code, tree, tree);\n \n #endif  /* GCC_GIMPLE_H */"}, {"sha": "fdce8b3d3952cf13bac6fc86e19de9e4220907e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -1,3 +1,9 @@\n+2010-06-08  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR tree-optimization/39874\n+\tPR middle-end/28685\n+\t* gcc.dg/pr39874.c: New file.\n+\n 2010-06-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/ext/attr-alias-1.C: New."}, {"sha": "ca452831016dc7188d6b147a2cee0f394274e808", "filename": "gcc/testsuite/gcc.dg/pr39874.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39874.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39874.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39874.c?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" }  */\n+\n+extern void func();\n+\n+void test1(char *signature)\n+{\n+  char ch = signature[0];\n+  if (ch == 15 || ch == 3)\n+  {\n+    if (ch == 15) func();\n+  }\n+}\n+\n+\n+void test2(char *signature)\n+{\n+  char ch = signature[0];\n+  if (ch == 15 || ch == 3)\n+  {\n+    if (ch > 14) func();\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" == 15\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" == 3\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+\n+"}, {"sha": "bc551b2231c51ef2a7af28b3742954b8a212a474", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -366,21 +366,16 @@ ifcombine_ifandif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n \n   /* See if we have two comparisons that we can merge into one.  */\n   else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n-\t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison\n-\t   && operand_equal_p (gimple_cond_lhs (inner_cond),\n-\t\t\t       gimple_cond_lhs (outer_cond), 0)\n-\t   && operand_equal_p (gimple_cond_rhs (inner_cond),\n-\t\t\t       gimple_cond_rhs (outer_cond), 0))\n+\t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison)\n     {\n-      enum tree_code code1 = gimple_cond_code (inner_cond);\n-      enum tree_code code2 = gimple_cond_code (outer_cond);\n       tree t;\n \n-      if (!(t = combine_comparisons (UNKNOWN_LOCATION,\n-\t      \t\t\t     TRUTH_ANDIF_EXPR, code1, code2,\n-\t\t\t\t     boolean_type_node,\n-\t\t\t\t     gimple_cond_lhs (outer_cond),\n-\t\t\t\t     gimple_cond_rhs (outer_cond))))\n+      if (!(t = maybe_fold_and_comparisons (gimple_cond_code (inner_cond),\n+\t\t\t\t\t    gimple_cond_lhs (inner_cond),\n+\t\t\t\t\t    gimple_cond_rhs (inner_cond),\n+\t\t\t\t\t    gimple_cond_code (outer_cond),\n+\t\t\t\t\t    gimple_cond_lhs (outer_cond),\n+\t\t\t\t\t    gimple_cond_rhs (outer_cond))))\n \treturn false;\n       t = canonicalize_cond_expr_cond (t);\n       if (!t)\n@@ -518,22 +513,17 @@ ifcombine_iforif (basic_block inner_cond_bb, basic_block outer_cond_bb)\n   /* See if we have two comparisons that we can merge into one.\n      This happens for C++ operator overloading where for example\n      GE_EXPR is implemented as GT_EXPR || EQ_EXPR.  */\n-  else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n-\t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison\n-\t   && operand_equal_p (gimple_cond_lhs (inner_cond),\n-\t\t\t       gimple_cond_lhs (outer_cond), 0)\n-\t   && operand_equal_p (gimple_cond_rhs (inner_cond),\n-\t\t\t       gimple_cond_rhs (outer_cond), 0))\n+    else if (TREE_CODE_CLASS (gimple_cond_code (inner_cond)) == tcc_comparison\n+\t   && TREE_CODE_CLASS (gimple_cond_code (outer_cond)) == tcc_comparison)\n     {\n-      enum tree_code code1 = gimple_cond_code (inner_cond);\n-      enum tree_code code2 = gimple_cond_code (outer_cond);\n       tree t;\n \n-      if (!(t = combine_comparisons (UNKNOWN_LOCATION,\n-\t      \t\t\t     TRUTH_ORIF_EXPR, code1, code2,\n-\t\t\t\t     boolean_type_node,\n-\t\t\t\t     gimple_cond_lhs (outer_cond),\n-\t\t\t\t     gimple_cond_rhs (outer_cond))))\n+      if (!(t = maybe_fold_or_comparisons (gimple_cond_code (inner_cond),\n+\t\t\t\t\t   gimple_cond_lhs (inner_cond),\n+\t\t\t\t\t   gimple_cond_rhs (inner_cond),\n+\t\t\t\t\t   gimple_cond_code (outer_cond),\n+\t\t\t\t\t   gimple_cond_lhs (outer_cond),\n+\t\t\t\t\t   gimple_cond_rhs (outer_cond))))\n \treturn false;\n       t = canonicalize_cond_expr_cond (t);\n       if (!t)"}, {"sha": "caad908129bb4f260ba4187d6f344c0f3e434c09", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89065a17202234f50185ce3bf2a80efb2fef938/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=e89065a17202234f50185ce3bf2a80efb2fef938", "patch": "@@ -1261,23 +1261,27 @@ eliminate_redundant_comparison (enum tree_code opcode,\n       rcode = gimple_assign_rhs_code (def2);\n       if (TREE_CODE_CLASS (rcode) != tcc_comparison)\n \tcontinue;\n-      if (operand_equal_p (op1, gimple_assign_rhs1 (def2), 0)\n-\t  && operand_equal_p (op2, gimple_assign_rhs2 (def2), 0))\n-\t;\n-      else if (operand_equal_p (op1, gimple_assign_rhs2 (def2), 0)\n-\t       && operand_equal_p (op2, gimple_assign_rhs1 (def2), 0))\n-\trcode = swap_tree_comparison (rcode);\n-      else\n-\tcontinue;\n \n       /* If we got here, we have a match.  See if we can combine the\n \t two comparisons.  */\n-      t = combine_comparisons (UNKNOWN_LOCATION,\n-\t\t\t       (opcode == BIT_IOR_EXPR\n-\t\t\t\t? TRUTH_OR_EXPR : TRUTH_AND_EXPR),\n-\t\t\t       lcode, rcode, TREE_TYPE (curr->op), op1, op2);\n+      if (opcode == BIT_IOR_EXPR)\n+\tt = maybe_fold_or_comparisons (lcode, op1, op2,\n+\t\t\t\t       rcode, gimple_assign_rhs1 (def2),\n+\t\t\t\t       gimple_assign_rhs2 (def2));\n+      else\n+\tt = maybe_fold_and_comparisons (lcode, op1, op2,\n+\t\t\t\t\trcode, gimple_assign_rhs1 (def2),\n+\t\t\t\t\tgimple_assign_rhs2 (def2));\n       if (!t)\n \tcontinue;\n+\n+      /* maybe_fold_and_comparisons and maybe_fold_or_comparisons\n+\t always give us a boolean_type_node value back.  If the original\n+\t BIT_AND_EXPR or BIT_IOR_EXPR was of a wider integer type,\n+\t we need to convert.  */\n+      if (!useless_type_conversion_p (TREE_TYPE (curr->op), TREE_TYPE (t)))\n+\tt = fold_convert (TREE_TYPE (curr->op), t);\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Equivalence: \");\n@@ -1303,7 +1307,7 @@ eliminate_redundant_comparison (enum tree_code opcode,\n \t  VEC_ordered_remove (operand_entry_t, *ops, currindex);\n \t  add_to_ops_vec (ops, t);\n \t}\n-      else if (TREE_CODE (t) != lcode)\n+      else if (!operand_equal_p (t, curr->op, 0))\n \t{\n \t  tree tmpvar;\n \t  gimple sum;"}]}