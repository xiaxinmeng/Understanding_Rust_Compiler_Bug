{"sha": "4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyZDA1ZWYwMTQyZDI2OTk2NGUxNjVjMTRjNmY3ZmU0YmRmZDVhMw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-04T16:14:37Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-04T18:26:18Z"}, "message": "coroutines: Fix missed ramp function return copy elision [PR95346].\n\nConfusingly, \"get_return_object ()\" can do two things:\n- Firstly it can provide the return object for the ramp function (as\n  the name suggests).\n- Secondly if the type of the ramp function is different from that\n  of the get_return_object call, this is used as a single parameter\n  to a CTOR for the ramp's return type.\n\nIn the first case we can rely on finish_return_stmt () to do the\nnecessary processing for copy elision.\nIn the second case, we should have passed a prvalue to the CTOR as\nper the standard comment, but I had omitted the rvalue () call.  Fixed\nthus.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95346\n\t* coroutines.cc (morph_fn_to_coro): Ensure that the get-\n\treturn-object is constructed correctly; When it is not the\n\tfinal return value, pass it to the CTOR of the return type\n\tas an rvalue, per the standard comment.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95346\n\t* g++.dg/coroutines/pr95346.C: New test.", "tree": {"sha": "5daf10eeceaa56efd48462880df814b2fdc81e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5daf10eeceaa56efd48462880df814b2fdc81e2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7ef9a40cd0c688cd331bc26224d1fbe360c1fe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ef9a40cd0c688cd331bc26224d1fbe360c1fe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ef9a40cd0c688cd331bc26224d1fbe360c1fe6"}], "stats": {"total": 98, "additions": 73, "deletions": 25}, "files": [{"sha": "e86b3d42a7fb2b6f9a8d03ed1739d59b68196499", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "patch": "@@ -4284,7 +4284,8 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     }\n \n   tree gro_context_body = push_stmt_list ();\n-  bool gro_is_void_p = VOID_TYPE_P (TREE_TYPE (get_ro));\n+  tree gro_type = TREE_TYPE (get_ro);\n+  bool gro_is_void_p = VOID_TYPE_P (gro_type);\n \n   tree gro = NULL_TREE;\n   tree gro_bind_vars = NULL_TREE;\n@@ -4294,17 +4295,23 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     finish_expr_stmt (get_ro);\n   else\n     {\n-      gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"),\n-\t\t\t      TREE_TYPE (get_ro));\n+      gro = build_lang_decl (VAR_DECL, get_identifier (\"coro.gro\"), gro_type);\n       DECL_CONTEXT (gro) = current_scope ();\n       DECL_ARTIFICIAL (gro) = true;\n       DECL_IGNORED_P (gro) = true;\n       add_decl_expr (gro);\n       gro_bind_vars = gro;\n-\n-      r = build2_loc (fn_start, INIT_EXPR, TREE_TYPE (gro), gro, get_ro);\n-      r = coro_build_cvt_void_expr_stmt (r, fn_start);\n-      add_stmt (r);\n+      if (TYPE_NEEDS_CONSTRUCTING (gro_type))\n+\t{\n+\t  vec<tree, va_gc> *arg = make_tree_vector_single (get_ro);\n+\t  r = build_special_member_call (gro, complete_ctor_identifier,\n+\t\t\t\t\t &arg, gro_type, LOOKUP_NORMAL,\n+\t\t\t\t\t tf_warning_or_error);\n+\t  release_tree_vector (arg);\n+\t}\n+      else\n+\tr = build2_loc (fn_start, INIT_EXPR, gro_type, gro, get_ro);\n+      finish_expr_stmt (r);\n     }\n \n   /* Initialize the resume_idx_name to 0, meaning \"not started\".  */\n@@ -4338,28 +4345,43 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Switch to using 'input_location' as the loc, since we're now more\n      logically doing things related to the end of the function.  */\n \n-  /* The ramp is done, we just need the return value.  */\n-  if (!same_type_p (TREE_TYPE (get_ro), fn_return_type))\n+  /* The ramp is done, we just need the return value.\n+     [dcl.fct.def.coroutine] / 7\n+     The expression promise.get_return_object() is used to initialize the\n+     glvalue result or prvalue result object of a call to a coroutine.\n+\n+     If the 'get return object' is non-void, then we built it before the\n+     promise was constructed.  We now supply a reference to that var,\n+     either as the return value (if it's the same type) or to the CTOR\n+     for an object of the return type.  */\n+  if (gro_is_void_p)\n+    r = NULL_TREE;\n+  else\n+    r = rvalue (gro);\n+\n+  if (!same_type_p (gro_type, fn_return_type))\n     {\n-      /* construct the return value with a single GRO param, if it's not\n-\t void.  */\n-      vec<tree, va_gc> *args = NULL;\n-      vec<tree, va_gc> **arglist = NULL;\n-      if (!gro_is_void_p)\n+      /* The return object is , even if the gro is void.  */\n+      if (CLASS_TYPE_P (fn_return_type))\n \t{\n-\t  args = make_tree_vector_single (gro);\n-\t  arglist = &args;\n+\t  vec<tree, va_gc> *args = NULL;\n+\t  vec<tree, va_gc> **arglist = NULL;\n+\t  if (!gro_is_void_p)\n+\t    {\n+\t      args = make_tree_vector_single (r);\n+\t      arglist = &args;\n+\t    }\n+\t  r = build_special_member_call (NULL_TREE,\n+\t\t\t\t\t complete_ctor_identifier, arglist,\n+\t\t\t\t\t fn_return_type, LOOKUP_NORMAL,\n+\t\t\t\t\t tf_warning_or_error);\n+\t  r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n+\t  if (args)\n+\t    release_tree_vector (args);\n \t}\n-      r = build_special_member_call (NULL_TREE,\n-\t\t\t\t     complete_ctor_identifier, arglist,\n-\t\t\t\t     fn_return_type, LOOKUP_NORMAL,\n-\t\t\t\t     tf_warning_or_error);\n-      r = build_cplus_new (fn_return_type, r, tf_warning_or_error);\n+      else /* ??? suppose we have non-class return and void gro?  */\n+\tr = build1_loc (input_location, CONVERT_EXPR, fn_return_type, r);\n     }\n-  else if (!gro_is_void_p)\n-    r = rvalue (gro); /* The GRO is the return value.  */\n-  else\n-    r = NULL_TREE;\n \n   finish_return_stmt (r);\n "}, {"sha": "8505a7322e1ef90474a3e188416e08a0abd13e07", "filename": "gcc/testsuite/g++.dg/coroutines/pr95346.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95346.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95346.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95346.C?ref=4f2d05ef0142d269964e165c14c6f7fe4bdfd5a3", "patch": "@@ -0,0 +1,26 @@\n+#if __has_include(<coroutine>)\n+#include <coroutine>\n+#elif defined (__clang__) && __has_include (<experimental/coroutine>)\n+#include <experimental/coroutine>\n+namespace std { using namespace experimental; }\n+#endif\n+#include <utility>\n+\n+struct task {\n+    struct promise_type {\n+        task get_return_object();\n+        void return_void();\n+        void unhandled_exception();\n+        std::suspend_always initial_suspend() noexcept;\n+        std::suspend_always final_suspend() noexcept;\n+    };\n+};\n+\n+struct wrapper {\n+    using promise_type = task::promise_type;\n+    wrapper(task&&);\n+};\n+\n+wrapper f() {\n+    co_return;\n+}"}]}