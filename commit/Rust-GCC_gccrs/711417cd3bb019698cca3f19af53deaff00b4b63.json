{"sha": "711417cd3bb019698cca3f19af53deaff00b4b63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExNDE3Y2QzYmIwMTk2OThjY2EzZjE5YWY1M2RlYWZmMDBiNGI2Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-29T13:54:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-29T13:54:16Z"}, "message": "cgraph.h (cgraph_materialize_all_clones): Remove.\n\n2012-03-29  Richard Guenther  <rguenther@suse.de>\n\n\t* cgraph.h (cgraph_materialize_all_clones): Remove.\n\t(reset_inline_failed): Likewise.\n\t* cgraphunit.c (cgraph_materialize_all_clones): Make static.\n\t* cgraphbuild.c (reset_inline_failed): Remove.\n\t* rtl.h (cse_main): Remove.\n\t(extended_count): Likewise.\n\t* cse.c (dump_class): Mark as DEBUG_FUNCTION.\n\t(cse_main): Make static.\n\t* combine.c (extended_count): Remove.\n\t(dump_combine_stats): Mark as DEBUG_FUNCTION.\n\t* basic-block.h (reorder_basic_blocks): Remove.\n\t* bb-reorder.c (reorder_basic_blocks): Make static.\n\t* Makefile.in (dse.o): Remove dse.h dependency.\n\t* dse.h: Remove.\n\t* dse.c (gate_dse): Remove.\n\t(clear_alias_mode_eq): Likewise.\n\t(clear_alias_mode_hash): Likewise.\n\t(dse_record_singleton_alias_set): Likewise.\n\t(dse_invalidate_singleton_alias_set): Likewise.\n\nFrom-SVN: r185962", "tree": {"sha": "8c4bc366977cd86d3613a3d1f2e4e63e47551318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c4bc366977cd86d3613a3d1f2e4e63e47551318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711417cd3bb019698cca3f19af53deaff00b4b63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711417cd3bb019698cca3f19af53deaff00b4b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711417cd3bb019698cca3f19af53deaff00b4b63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711417cd3bb019698cca3f19af53deaff00b4b63/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1ecc15c2130165320af7555339eba5438116e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ecc15c2130165320af7555339eba5438116e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ecc15c2130165320af7555339eba5438116e38"}], "stats": {"total": 564, "additions": 202, "deletions": 362}, "files": [{"sha": "fc2ec36d9926a384217fa83220f2a95901c58461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -1,3 +1,25 @@\n+2012-03-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* cgraph.h (cgraph_materialize_all_clones): Remove.\n+\t(reset_inline_failed): Likewise.\n+\t* cgraphunit.c (cgraph_materialize_all_clones): Make static.\n+\t* cgraphbuild.c (reset_inline_failed): Remove.\n+\t* rtl.h (cse_main): Remove.\n+\t(extended_count): Likewise.\n+\t* cse.c (dump_class): Mark as DEBUG_FUNCTION.\n+\t(cse_main): Make static.\n+\t* combine.c (extended_count): Remove.\n+\t(dump_combine_stats): Mark as DEBUG_FUNCTION.\n+\t* basic-block.h (reorder_basic_blocks): Remove.\n+\t* bb-reorder.c (reorder_basic_blocks): Make static.\n+\t* Makefile.in (dse.o): Remove dse.h dependency.\n+\t* dse.h: Remove.\n+\t* dse.c (gate_dse): Remove.\n+\t(clear_alias_mode_eq): Likewise.\n+\t(clear_alias_mode_hash): Likewise.\n+\t(dse_record_singleton_alias_set): Likewise.\n+\t(dse_invalidate_singleton_alias_set): Likewise.\n+\n 2012-03-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/linux-android.h (ANDROID_STARTFILE_SPEC): Use"}, {"sha": "f5fa0c3b6c29e2d7eba51f4bf4c7c8bea70906b5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -3011,7 +3011,7 @@ dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) $(TIMEVAR_H) \\\n-   $(TREE_PASS_H) alloc-pool.h $(ALIAS_H) dse.h $(OPTABS_H) $(TARGET_H) \\\n+   $(TREE_PASS_H) alloc-pool.h $(ALIAS_H) $(OPTABS_H) $(TARGET_H) \\\n    $(BITMAP_H) $(PARAMS_H)\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\"}, {"sha": "f8cdea0085d6d6e5f937e273c1209c692a08ffd5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -830,9 +830,6 @@ extern bool inside_basic_block_p (const_rtx);\n extern bool control_flow_insn_p (const_rtx);\n extern rtx get_last_bb_insn (basic_block);\n \n-/* In bb-reorder.c */\n-extern void reorder_basic_blocks (void);\n-\n /* In dominance.c */\n \n enum cdi_direction"}, {"sha": "c7f9c920d761311c4aaa96b578693704cec31c02", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -1903,7 +1903,7 @@ verify_hot_cold_block_grouping (void)\n /* Reorder basic blocks.  The main entry point to this file.  FLAGS is\n    the set of flags to pass to cfg_layout_initialize().  */\n \n-void\n+static void\n reorder_basic_blocks (void)\n {\n   int n_traces;"}, {"sha": "726285989fcb8d8006b0d6df4facc069b8619f15", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -613,13 +613,11 @@ struct cgraph_2edge_hook_list *cgraph_add_edge_duplication_hook (cgraph_2edge_ho\n void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n-void cgraph_materialize_all_clones (void);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n void cgraph_rebuild_references (void);\n-void reset_inline_failed (struct cgraph_node *);\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n \n /* In ipa.c  */"}, {"sha": "d7ef7f9d99daec7d59296e10c0b0739761f483f7", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -200,20 +200,6 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n     }\n }\n \n-/* Reset inlining information of all incoming call edges of NODE.  */\n-\n-void\n-reset_inline_failed (struct cgraph_node *node)\n-{\n-  struct cgraph_edge *e;\n-\n-  for (e = node->callers; e; e = e->next_caller)\n-    {\n-      e->callee->global.inlined_to = NULL;\n-      initialize_inline_failed (e);\n-    }\n-}\n-\n /* Computes the frequency of the call statement so that it can be stored in\n    cgraph_edge.  BB is the basic block of the call statement.  */\n int"}, {"sha": "9e5820fc9013ede3207535bb199e8940fff8b830", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 175, "deletions": 172, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -1294,59 +1294,6 @@ handle_alias_pairs (void)\n }\n \n \n-/* Analyze the whole compilation unit once it is parsed completely.  */\n-\n-void\n-cgraph_finalize_compilation_unit (void)\n-{\n-  timevar_push (TV_CGRAPH);\n-\n-  /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n-  if (flag_lto)\n-    lto_streamer_hooks_init ();\n-\n-  /* If we're here there's no current function anymore.  Some frontends\n-     are lazy in clearing these.  */\n-  current_function_decl = NULL;\n-  set_cfun (NULL);\n-\n-  /* Do not skip analyzing the functions if there were errors, we\n-     miss diagnostics for following functions otherwise.  */\n-\n-  /* Emit size functions we didn't inline.  */\n-  finalize_size_functions ();\n-\n-  /* Mark alias targets necessary and emit diagnostics.  */\n-  finish_aliases_1 ();\n-  handle_alias_pairs ();\n-\n-  if (!quiet_flag)\n-    {\n-      fprintf (stderr, \"\\nAnalyzing compilation unit\\n\");\n-      fflush (stderr);\n-    }\n-\n-  if (flag_dump_passes)\n-    dump_passes ();\n-\n-  /* Gimplify and lower all functions, compute reachability and\n-     remove unreachable nodes.  */\n-  cgraph_analyze_functions ();\n-\n-  /* Mark alias targets necessary and emit diagnostics.  */\n-  finish_aliases_1 ();\n-  handle_alias_pairs ();\n-\n-  /* Gimplify and lower thunks.  */\n-  cgraph_analyze_functions ();\n-\n-  /* Finally drive the pass manager.  */\n-  cgraph_optimize ();\n-\n-  timevar_pop (TV_CGRAPH);\n-}\n-\n-\n /* Figure out what functions we want to assemble.  */\n \n static void\n@@ -2134,124 +2081,6 @@ output_weakrefs (void)\n }\n \n \n-/* Perform simple optimizations based on callgraph.  */\n-\n-void\n-cgraph_optimize (void)\n-{\n-  if (seen_error ())\n-    return;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-#endif\n-\n-  /* Frontend may output common variables after the unit has been finalized.\n-     It is safe to deal with them here as they are always zero initialized.  */\n-  varpool_analyze_pending_decls ();\n-\n-  timevar_push (TV_CGRAPHOPT);\n-  if (pre_ipa_mem_report)\n-    {\n-      fprintf (stderr, \"Memory consumption before IPA\\n\");\n-      dump_memory_report (false);\n-    }\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n-  cgraph_state = CGRAPH_STATE_IPA;\n-\n-  /* Don't run the IPA passes if there was any error or sorry messages.  */\n-  if (!seen_error ())\n-    ipa_passes ();\n-\n-  /* Do nothing else if any IPA pass found errors or if we are just streaming LTO.  */\n-  if (seen_error ()\n-      || (!in_lto_p && flag_lto && !flag_fat_lto_objects))\n-    {\n-      timevar_pop (TV_CGRAPHOPT);\n-      return;\n-    }\n-\n-  /* This pass remove bodies of extern inline functions we never inlined.\n-     Do this later so other IPA passes see what is really going on.  */\n-  cgraph_remove_unreachable_nodes (false, dump_file);\n-  cgraph_global_info_ready = true;\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"Optimized \");\n-      dump_cgraph (cgraph_dump_file);\n-      dump_varpool (cgraph_dump_file);\n-    }\n-  if (post_ipa_mem_report)\n-    {\n-      fprintf (stderr, \"Memory consumption after IPA\\n\");\n-      dump_memory_report (false);\n-    }\n-  timevar_pop (TV_CGRAPHOPT);\n-\n-  /* Output everything.  */\n-  (*debug_hooks->assembly_start) ();\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Assembling functions:\\n\");\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-#endif\n-\n-  cgraph_materialize_all_clones ();\n-  bitmap_obstack_initialize (NULL);\n-  execute_ipa_pass_list (all_late_ipa_passes);\n-  cgraph_remove_unreachable_nodes (true, dump_file);\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-#endif\n-  bitmap_obstack_release (NULL);\n-  cgraph_mark_functions_to_output ();\n-  output_weakrefs ();\n-\n-  cgraph_state = CGRAPH_STATE_EXPANSION;\n-  if (!flag_toplevel_reorder)\n-    cgraph_output_in_order ();\n-  else\n-    {\n-      cgraph_output_pending_asms ();\n-\n-      cgraph_expand_all_functions ();\n-      varpool_remove_unreferenced_decls ();\n-\n-      varpool_assemble_pending_decls ();\n-    }\n-\n-  cgraph_process_new_functions ();\n-  cgraph_state = CGRAPH_STATE_FINISHED;\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"\\nFinal \");\n-      dump_cgraph (cgraph_dump_file);\n-      dump_varpool (cgraph_dump_file);\n-    }\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-  /* Double check that all inline clones are gone and that all\n-     function bodies have been released from memory.  */\n-  if (!seen_error ())\n-    {\n-      struct cgraph_node *node;\n-      bool error_found = false;\n-\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->analyzed\n-\t    && (node->global.inlined_to\n-\t\t|| gimple_has_body_p (node->decl)))\n-\t  {\n-\t    error_found = true;\n-\t    dump_cgraph_node (stderr, node);\n-\t  }\n-      if (error_found)\n-\tinternal_error (\"nodes with unreleased memory found\");\n-    }\n-#endif\n-}\n \n void\n init_cgraph (void)\n@@ -2549,7 +2378,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n    bring all functions to memory prior compilation, but current WHOPR\n    implementation does that and it is is bit easier to keep everything right in\n    this order.  */\n-void\n+static void\n cgraph_materialize_all_clones (void)\n {\n   struct cgraph_node *node;\n@@ -2628,4 +2457,178 @@ cgraph_materialize_all_clones (void)\n   cgraph_remove_unreachable_nodes (false, cgraph_dump_file);\n }\n \n+\n+/* Perform simple optimizations based on callgraph.  */\n+\n+void\n+cgraph_optimize (void)\n+{\n+  if (seen_error ())\n+    return;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+\n+  /* Frontend may output common variables after the unit has been finalized.\n+     It is safe to deal with them here as they are always zero initialized.  */\n+  varpool_analyze_pending_decls ();\n+\n+  timevar_push (TV_CGRAPHOPT);\n+  if (pre_ipa_mem_report)\n+    {\n+      fprintf (stderr, \"Memory consumption before IPA\\n\");\n+      dump_memory_report (false);\n+    }\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n+  cgraph_state = CGRAPH_STATE_IPA;\n+\n+  /* Don't run the IPA passes if there was any error or sorry messages.  */\n+  if (!seen_error ())\n+    ipa_passes ();\n+\n+  /* Do nothing else if any IPA pass found errors or if we are just streaming LTO.  */\n+  if (seen_error ()\n+      || (!in_lto_p && flag_lto && !flag_fat_lto_objects))\n+    {\n+      timevar_pop (TV_CGRAPHOPT);\n+      return;\n+    }\n+\n+  /* This pass remove bodies of extern inline functions we never inlined.\n+     Do this later so other IPA passes see what is really going on.  */\n+  cgraph_remove_unreachable_nodes (false, dump_file);\n+  cgraph_global_info_ready = true;\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"Optimized \");\n+      dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n+    }\n+  if (post_ipa_mem_report)\n+    {\n+      fprintf (stderr, \"Memory consumption after IPA\\n\");\n+      dump_memory_report (false);\n+    }\n+  timevar_pop (TV_CGRAPHOPT);\n+\n+  /* Output everything.  */\n+  (*debug_hooks->assembly_start) ();\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Assembling functions:\\n\");\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+\n+  cgraph_materialize_all_clones ();\n+  bitmap_obstack_initialize (NULL);\n+  execute_ipa_pass_list (all_late_ipa_passes);\n+  cgraph_remove_unreachable_nodes (true, dump_file);\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+  bitmap_obstack_release (NULL);\n+  cgraph_mark_functions_to_output ();\n+  output_weakrefs ();\n+\n+  cgraph_state = CGRAPH_STATE_EXPANSION;\n+  if (!flag_toplevel_reorder)\n+    cgraph_output_in_order ();\n+  else\n+    {\n+      cgraph_output_pending_asms ();\n+\n+      cgraph_expand_all_functions ();\n+      varpool_remove_unreferenced_decls ();\n+\n+      varpool_assemble_pending_decls ();\n+    }\n+\n+  cgraph_process_new_functions ();\n+  cgraph_state = CGRAPH_STATE_FINISHED;\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"\\nFinal \");\n+      dump_cgraph (cgraph_dump_file);\n+      dump_varpool (cgraph_dump_file);\n+    }\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+  /* Double check that all inline clones are gone and that all\n+     function bodies have been released from memory.  */\n+  if (!seen_error ())\n+    {\n+      struct cgraph_node *node;\n+      bool error_found = false;\n+\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->analyzed\n+\t    && (node->global.inlined_to\n+\t\t|| gimple_has_body_p (node->decl)))\n+\t  {\n+\t    error_found = true;\n+\t    dump_cgraph_node (stderr, node);\n+\t  }\n+      if (error_found)\n+\tinternal_error (\"nodes with unreleased memory found\");\n+    }\n+#endif\n+}\n+\n+\n+/* Analyze the whole compilation unit once it is parsed completely.  */\n+\n+void\n+cgraph_finalize_compilation_unit (void)\n+{\n+  timevar_push (TV_CGRAPH);\n+\n+  /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n+  if (flag_lto)\n+    lto_streamer_hooks_init ();\n+\n+  /* If we're here there's no current function anymore.  Some frontends\n+     are lazy in clearing these.  */\n+  current_function_decl = NULL;\n+  set_cfun (NULL);\n+\n+  /* Do not skip analyzing the functions if there were errors, we\n+     miss diagnostics for following functions otherwise.  */\n+\n+  /* Emit size functions we didn't inline.  */\n+  finalize_size_functions ();\n+\n+  /* Mark alias targets necessary and emit diagnostics.  */\n+  finish_aliases_1 ();\n+  handle_alias_pairs ();\n+\n+  if (!quiet_flag)\n+    {\n+      fprintf (stderr, \"\\nAnalyzing compilation unit\\n\");\n+      fflush (stderr);\n+    }\n+\n+  if (flag_dump_passes)\n+    dump_passes ();\n+\n+  /* Gimplify and lower all functions, compute reachability and\n+     remove unreachable nodes.  */\n+  cgraph_analyze_functions ();\n+\n+  /* Mark alias targets necessary and emit diagnostics.  */\n+  finish_aliases_1 ();\n+  handle_alias_pairs ();\n+\n+  /* Gimplify and lower thunks.  */\n+  cgraph_analyze_functions ();\n+\n+  /* Finally drive the pass manager.  */\n+  cgraph_optimize ();\n+\n+  timevar_pop (TV_CGRAPH);\n+}\n+\n+\n #include \"gt-cgraphunit.h\""}, {"sha": "de3afccb44605c16951bc6d9b456ace04a92653d", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -9674,31 +9674,6 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, enum machine_mode mode,\n   return NULL;\n }\n \f\n-/* Return the number of \"extended\" bits there are in X, when interpreted\n-   as a quantity in MODE whose signedness is indicated by UNSIGNEDP.  For\n-   unsigned quantities, this is the number of high-order zero bits.\n-   For signed quantities, this is the number of copies of the sign bit\n-   minus 1.  In both case, this function returns the number of \"spare\"\n-   bits.  For example, if two quantities for which this function returns\n-   at least 1 are added, the addition is known not to overflow.\n-\n-   This function will always return 0 unless called during combine, which\n-   implies that it must be called from a define_split.  */\n-\n-unsigned int\n-extended_count (const_rtx x, enum machine_mode mode, int unsignedp)\n-{\n-  if (nonzero_sign_valid == 0)\n-    return 0;\n-\n-  return (unsignedp\n-\t  ? (HWI_COMPUTABLE_MODE_P (mode)\n-\t     ? (unsigned int) (GET_MODE_PRECISION (mode) - 1\n-\t\t\t       - floor_log2 (nonzero_bits (x, mode)))\n-\t     : 0)\n-\t  : num_sign_bit_copies (x, mode) - 1);\n-}\n-\f\n /* This function is called from `simplify_shift_const' to merge two\n    outer operations.  Specifically, we have already found that we need\n    to perform operation *POP0 with constant *PCONST0 at the outermost\n@@ -13912,7 +13887,7 @@ unmentioned_reg_p (rtx equiv, rtx expr)\n   return for_each_rtx (&equiv, unmentioned_reg_p_1, expr);\n }\n \f\n-void\n+DEBUG_FUNCTION void\n dump_combine_stats (FILE *file)\n {\n   fprintf"}, {"sha": "5c32336c5963cc318a566f68cc76adfee6a5e335", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -653,7 +653,7 @@ fixed_base_plus_p (rtx x)\n \n /* Dump the expressions in the equivalence class indicated by CLASSP.\n    This function is used only for debugging.  */\n-void\n+DEBUG_FUNCTION void\n dump_class (struct table_elt *classp)\n {\n   struct table_elt *elt;\n@@ -6519,7 +6519,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n    Return 1 if the CFG should be cleaned up because it has been modified.\n    Return 0 otherwise.  */\n \n-int\n+static int\n cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n {\n   struct cse_basic_block_data ebb_data;"}, {"sha": "d6c8de7fad8629cbc9abc6c2152c92340918c621", "filename": "gcc/dse.c", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -44,7 +44,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-config.h\"\n #include \"expr.h\"\n #include \"recog.h\"\n-#include \"dse.h\"\n #include \"optabs.h\"\n #include \"dbgcnt.h\"\n #include \"target.h\"\n@@ -614,7 +613,6 @@ static bitmap kill_on_calls;\n static unsigned int current_position;\n \n \n-static bool gate_dse (void);\n static bool gate_dse1 (void);\n static bool gate_dse2 (void);\n \n@@ -625,28 +623,6 @@ static bool gate_dse2 (void);\n    Initialization.\n ----------------------------------------------------------------------------*/\n \n-/* Hashtable callbacks for maintaining the \"bases\" field of\n-   store_group_info, given that the addresses are function invariants.  */\n-\n-static int\n-clear_alias_mode_eq (const void *p1, const void *p2)\n-{\n-  const struct clear_alias_mode_holder * h1\n-    = (const struct clear_alias_mode_holder *) p1;\n-  const struct clear_alias_mode_holder * h2\n-    = (const struct clear_alias_mode_holder *) p2;\n-  return h1->alias_set == h2->alias_set;\n-}\n-\n-\n-static hashval_t\n-clear_alias_mode_hash (const void *p)\n-{\n-  const struct clear_alias_mode_holder *holder\n-    = (const struct clear_alias_mode_holder *) p;\n-  return holder->alias_set;\n-}\n-\n \n /* Find the entry associated with ALIAS_SET.  */\n \n@@ -3044,85 +3020,6 @@ dse_step2_spill (void)\n ----------------------------------------------------------------------------*/\n \n \n-/* Note that this is NOT a general purpose function.  Any mem that has\n-   an alias set registered here expected to be COMPLETELY unaliased:\n-   i.e it's addresses are not and need not be examined.\n-\n-   It is known that all references to this address will have this\n-   alias set and there are NO other references to this address in the\n-   function.\n-\n-   Currently the only place that is known to be clean enough to use\n-   this interface is the code that assigns the spill locations.\n-\n-   All of the mems that have alias_sets registered are subjected to a\n-   very powerful form of dse where function calls, volatile reads and\n-   writes, and reads from random location are not taken into account.\n-\n-   It is also assumed that these locations go dead when the function\n-   returns.  This assumption could be relaxed if there were found to\n-   be places that this assumption was not correct.\n-\n-   The MODE is passed in and saved.  The mode of each load or store to\n-   a mem with ALIAS_SET is checked against MEM.  If the size of that\n-   load or store is different from MODE, processing is halted on this\n-   alias set.  For the vast majority of aliases sets, all of the loads\n-   and stores will use the same mode.  But vectors are treated\n-   differently: the alias set is established for the entire vector,\n-   but reload will insert loads and stores for individual elements and\n-   we do not necessarily have the information to track those separate\n-   elements.  So when we see a mode mismatch, we just bail.  */\n-\n-\n-void\n-dse_record_singleton_alias_set (alias_set_type alias_set,\n-\t\t\t\tenum machine_mode mode)\n-{\n-  struct clear_alias_mode_holder tmp_holder;\n-  struct clear_alias_mode_holder *entry;\n-  void **slot;\n-\n-  /* If we are not going to run dse, we need to return now or there\n-     will be problems with allocating the bitmaps.  */\n-  if ((!gate_dse()) || !alias_set)\n-    return;\n-\n-  if (!clear_alias_sets)\n-    {\n-      clear_alias_sets = BITMAP_ALLOC (NULL);\n-      disqualified_clear_alias_sets = BITMAP_ALLOC (NULL);\n-      clear_alias_mode_table = htab_create (11, clear_alias_mode_hash,\n-\t\t\t\t\t    clear_alias_mode_eq, NULL);\n-      clear_alias_mode_pool = create_alloc_pool (\"clear_alias_mode_pool\",\n-\t\t\t\t\t\t sizeof (struct clear_alias_mode_holder), 100);\n-    }\n-\n-  bitmap_set_bit (clear_alias_sets, alias_set);\n-\n-  tmp_holder.alias_set = alias_set;\n-\n-  slot = htab_find_slot (clear_alias_mode_table, &tmp_holder, INSERT);\n-  gcc_assert (*slot == NULL);\n-\n-  *slot = entry =\n-    (struct clear_alias_mode_holder *) pool_alloc (clear_alias_mode_pool);\n-  entry->alias_set = alias_set;\n-  entry->mode = mode;\n-}\n-\n-\n-/* Remove ALIAS_SET from the sets of stack slots being considered.  */\n-\n-void\n-dse_invalidate_singleton_alias_set (alias_set_type alias_set)\n-{\n-  if ((!gate_dse()) || !alias_set)\n-    return;\n-\n-  bitmap_clear_bit (clear_alias_sets, alias_set);\n-}\n-\n-\n /* Look up the bitmap index for OFFSET in GROUP_INFO.  If it is not\n    there, return 0.  */\n \n@@ -4014,12 +3911,6 @@ rest_of_handle_dse (void)\n   return 0;\n }\n \n-static bool\n-gate_dse (void)\n-{\n-  return gate_dse1 () || gate_dse2 ();\n-}\n-\n static bool\n gate_dse1 (void)\n {"}, {"sha": "dca6ea04f9b2961880df3641db8229646a945562", "filename": "gcc/dse.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ecc15c2130165320af7555339eba5438116e38/gcc%2Fdse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ecc15c2130165320af7555339eba5438116e38/gcc%2Fdse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.h?ref=a1ecc15c2130165320af7555339eba5438116e38", "patch": "@@ -1,30 +0,0 @@\n-/* RTL dead store elimination.\n-   Copyright (C) 2007, 2010 Free Software Foundation, Inc.\n-\n-   Contributed by Richard Sandiford <rsandifor@codesourcery.com>\n-   and Kenneth Zadeck <zadeck@naturalbridge.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_DSE_H\n-#define GCC_DSE_H\n-\n-extern void dse_record_singleton_alias_set (alias_set_type, enum machine_mode);\n-extern void dse_invalidate_singleton_alias_set (alias_set_type);\n-\n-#endif /* GCC_DSE_H */\n-"}, {"sha": "bfb0cf998039ef7fb38bf6f79cdd155f16fc2a61", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711417cd3bb019698cca3f19af53deaff00b4b63/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=711417cd3bb019698cca3f19af53deaff00b4b63", "patch": "@@ -2373,7 +2373,6 @@ extern int rtx_to_tree_code (enum rtx_code);\n \n /* In cse.c */\n extern int delete_trivially_dead_insns (rtx, int);\n-extern int cse_main (rtx, int);\n extern int exp_equiv_p (const_rtx, const_rtx, int, bool);\n extern unsigned hash_rtx (const_rtx x, enum machine_mode, int *, int *, bool);\n \n@@ -2456,7 +2455,6 @@ extern bool validate_subreg (enum machine_mode, enum machine_mode,\n \t\t\t     const_rtx, unsigned int);\n \n /* In combine.c  */\n-extern unsigned int extended_count (const_rtx, enum machine_mode, int);\n extern rtx remove_death (unsigned int, rtx);\n extern void dump_combine_stats (FILE *);\n extern void dump_combine_total_stats (FILE *);"}]}