{"sha": "c166b8981f366dfe1ec292221548b05e69c6c384", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2NmI4OTgxZjM2NmRmZTFlYzI5MjIyMTU0OGIwNWU2OWM2YzM4NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-05-21T05:58:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-05-21T05:58:39Z"}, "message": "tree.c (build_tree_list_vec_stat): New function.\n\n./:\t* tree.c (build_tree_list_vec_stat): New function.\n\t(ctor_to_vec): New function.\n\t(build_nt_call_vec): New function.\n\t(build_call_array): Change args to be a const pointer.\n\t(build_call_vec): New function.\n\t* tree.h (build_nt_call_vec): Declare.\n\t(build_tree_list_vec_stat): Declare.\n\t(build_tree_list_vec): Define.\n\t(build_call_array): Update declaration.\n\t(build_call_vec): Declare.\n\t(ctor_to_vec): Declare.\n\t* c-common.c (tree_vector_cache): New static variable.\n\t(make_tree_vector): New function.\n\t(release_tree_vector): New function.\n\t(make_tree_vector_single): New function.\n\t(make_tree_vector_copy): New function.\n\t* c-common.h (tree_vector_cache, make_tree_vector): Declare.\n\t(make_tree_vector_single, make_tree_vector_copy): Declare.\n\t* c-parser.c (cached_expr_list_1, cached_expr_list_2): Remove.\n\t(c_parser_expr_list): Don't manage cache here, instead call\n\tmake_tree_vector.\n\t(c_parser_release_expr_list): Remove static function.\n\t(c_parser_vec_to_tree_list): Remove static function.\n\t(c_parser_attributes): Call build_tree_list_vec instead of\n\tc_parser_vec_to_tree_list.  Call release_tree_vector instead of\n\tc_parser_release_expr_list.\n\t(c_parser_postfix_expression_after_primary): Likewise.\n\t(c_parser_objc_keywordexpr): Likewise.\ncp/:\n\t* parser.c (cp_parser_postfix_expression): Change args to a vec.\n\tRelease it when done.\n\t(tree_vector): Define typedef.  Define VEC functions.\n\t(cp_parser_parenthesized_expression_list): Change return type to\n\tvec.  Change all callers.\n\t(cp_parser_new_expression): Change placement and initializer to\n\tvecs.  Release them when done.\n\t(cp_parser_new_placement): Change return type to vec.  Change all\n\tcallers.\n\t(cp_parser_new_initializer): Likewise.\n\t* typeck.c (build_function_call_vec): Just call\n\tcp_build_function_call_vec.\n\t(cp_build_function_call): Just build a vec and call\n\tcp_build_function_call_vec.\n\t(cp_build_function_call_vec): New function based on old\n\tcp_build_function_call.\n\t(convert_arguments): Remove nargs and argarray parameters.  Change\n\tvalues to a vec.  Change caller.\n\t(build_x_compound_expr_from_vec): New function.\n\t(cp_build_modify_expr): Build vec to pass to\n\tbuild_special_member_call.\n\t* call.c (struct z_candidate): Add first_arg field.  Change args\n\tfield to vec.\n\t(convert_class_to_reference): Handle first argument separately.\n\t(add_candidate): Add first_arg parameter.  Change args parameter\n\tto vec.  Change all callers.\n\t(add_function_candidate, add_conv_candidate): Likewise.\n\t(add_template_candidate_real, add_template_candidate): Likewise.\n\t(add_template_conv_candidate): Likewise.\n\t(build_user_type_conversion_1): Handle first argument separately.\n\t(resolve_args): Change return type and parameter type to vecs.\n\tChange all callers.\n\t(perform_overload_resolution): Change args parameter to vec.\n\tChange all callers.\n\t(build_new_function_call, build_operator_new_call): Likewise.\n\t(add_candidates): Likewise.\n\t(build_op_call): New globally visible function, built from and\n\treplacing static function build_object_call.\n\t(build_new_op): Don't handle CALL_EXPR.  Build vec, not tree_list,\n\tof arguments.\n\t(build_op_delete_call): Build vec to pass to\n\tcp_build_function_call_vec.\n\t(build_temp): Build vec to pass to build_special_member_call.\n\t(convert_like_real): Likewise.\n\t(perform_direct_initialization_if_possible): Likewise.\n\t(build_over_call): Handle first_arg field.  Use build_call_array\n\trather than build_call_list.\n\t(build_special_member_call): Change args parameter to vec.  Change\n\tall callers.\n\t(build_new_method_call): Likewise.\n\t* init.c (expand_default_init): Change parms to vec.\n\t(build_raw_new_expr): Change placement and init to vecs.  Change\n\tall callers.\n\t(build_new_1, build_new): Likewise.\n\t* class.c (resolve_address_of_overloaded_function): Build array to\n\tpass to fn_type_unification.\n\t* pt.c (tsubst_copy_and_build): For NEW_EXPR build vecs to pass to\n\tbuild_new.  For CALL_EXPR create a vec rather than a tree_list;\n\texpand a pack if necessary.\n\t(fn_type_unification): Change args parameter to const tree *.  Add\n\tnargs parameter.  Change all callers.\n\t(type_unification_real): Likewise.\n\t(unify): Build array to pass to type_unification_real.\n\t(get_bindings): Build array to pass to fn_type_unification.\n\t(any_type_dependent_arguments_p): Change args parameter to a vec.\n\tChange all callers.\n\t(make_args_non_dependent): Renamed from build_non_dependent_args.\n\tChange return type to void.  Change parameter type to vec.  Change\n\tall callers.\n\t(do_auto_deduction): Pass an array to type_unification_real.\n\t* semantics.c (perform_koenig_lookup): Change args to vec.  Change\n\tall callers.\n\t(finish_call_expr): Change args to vec.  Change all callers.  Call\n\tbuild_op_call instead of passing CALL_EXPR to build_new_op.\n\t(cxx_omp_create_clause_info): Allocate vec to pass to\n\tbuild_special_member_call.\n\t* decl2.c (build_offset_ref_call_from_tree): Change args parameter\n\tto vec.  Change all callers.\n\t* name-lookup.c (lookup_function_nonclass): Likewise.\n\t(struct arg_lookup): Change args to vec.\n\t(arg_assoc_namespace): Handle args as a vec.\n\t(arg_assoc_args_vec): New static function.\n\t(lookup_arg_dependent): Change args parameter to vec.  Change all\n\tcallers.\n\t* method.c (do_build_assign_ref): Allocate vec to pass to\n\tbuild_special_member_call.\n\t* except.c (build_throw): Likewise.\n\t* typeck2.c (build_functional_cast): Likewise.\n\t* cvt.c (ocp_convert): Likewise.\n\t* tree.c (build_min_non_dep_call_vec): Change last parameter to\n\tvec.  Change all callers.\n\t* cp-tree.h: Update declarations.\n\t* name-lookup.h: Update declarations.\nobjc/:\n\t* objc-act.c (objc_generate_cxx_ctor_or_dtor): Pass NULL rather\n\tthan NULL_TREE to build_special_member_call.\n\nFrom-SVN: r147759", "tree": {"sha": "a25b2f396979fd0a56ba8a76180aba734398019a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a25b2f396979fd0a56ba8a76180aba734398019a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c166b8981f366dfe1ec292221548b05e69c6c384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c166b8981f366dfe1ec292221548b05e69c6c384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c166b8981f366dfe1ec292221548b05e69c6c384", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c166b8981f366dfe1ec292221548b05e69c6c384/comments", "author": null, "committer": null, "parents": [{"sha": "40449a90d7701eb70b5ccecb0f05290d442983e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40449a90d7701eb70b5ccecb0f05290d442983e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40449a90d7701eb70b5ccecb0f05290d442983e9"}], "stats": {"total": 2132, "additions": 1408, "deletions": 724}, "files": [{"sha": "08543b8ac0b7a9e090daa7dd74cbf59007c7b7fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,3 +1,34 @@\n+2009-05-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* tree.c (build_tree_list_vec_stat): New function.\n+\t(ctor_to_vec): New function.\n+\t(build_nt_call_vec): New function.\n+\t(build_call_array): Change args to be a const pointer.\n+\t(build_call_vec): New function.\n+\t* tree.h (build_nt_call_vec): Declare.\n+\t(build_tree_list_vec_stat): Declare.\n+\t(build_tree_list_vec): Define.\n+\t(build_call_array): Update declaration.\n+\t(build_call_vec): Declare.\n+\t(ctor_to_vec): Declare.\n+\t* c-common.c (tree_vector_cache): New static variable.\n+\t(make_tree_vector): New function.\n+\t(release_tree_vector): New function.\n+\t(make_tree_vector_single): New function.\n+\t(make_tree_vector_copy): New function.\n+\t* c-common.h (tree_vector_cache, make_tree_vector): Declare.\n+\t(make_tree_vector_single, make_tree_vector_copy): Declare.\n+\t* c-parser.c (cached_expr_list_1, cached_expr_list_2): Remove.\n+\t(c_parser_expr_list): Don't manage cache here, instead call\n+\tmake_tree_vector.\n+\t(c_parser_release_expr_list): Remove static function.\n+\t(c_parser_vec_to_tree_list): Remove static function.\n+\t(c_parser_attributes): Call build_tree_list_vec instead of\n+\tc_parser_vec_to_tree_list.  Call release_tree_vector instead of\n+\tc_parser_release_expr_list.\n+\t(c_parser_postfix_expression_after_primary): Likewise.\n+\t(c_parser_objc_keywordexpr): Likewise.\n+\n 2009-05-20  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/tm.texi (Misc): Document TARGET_INVALID_PARAMETER_TYPE,"}, {"sha": "45b4192d446b1bea78b92cfad3f0766dd69df1dd", "filename": "gcc/c-common.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -9132,4 +9132,69 @@ is_typedef_decl (tree x)\n           && DECL_ORIGINAL_TYPE (x) != NULL_TREE);\n }\n \n+/* The C and C++ parsers both use vectors to hold function arguments.\n+   For efficiency, we keep a cache of unused vectors.  This is the\n+   cache.  */\n+\n+typedef VEC(tree,gc)* tree_gc_vec;\n+DEF_VEC_P(tree_gc_vec);\n+DEF_VEC_ALLOC_P(tree_gc_vec,gc);\n+static GTY((deletable)) VEC(tree_gc_vec,gc) *tree_vector_cache;\n+\n+/* Return a new vector from the cache.  If the cache is empty,\n+   allocate a new vector.  These vectors are GC'ed, so it is OK if the\n+   pointer is not released..  */\n+\n+VEC(tree,gc) *\n+make_tree_vector (void)\n+{\n+  if (!VEC_empty (tree_gc_vec, tree_vector_cache))\n+    return VEC_pop (tree_gc_vec, tree_vector_cache);\n+  else\n+    {\n+      /* Passing 0 to VEC_alloc returns NULL, and our callers require\n+\t that we always return a non-NULL value.  The vector code uses\n+\t 4 when growing a NULL vector, so we do too.  */\n+      return VEC_alloc (tree, gc, 4);\n+    }\n+}\n+\n+/* Release a vector of trees back to the cache.  */\n+\n+void\n+release_tree_vector (VEC(tree,gc) *vec)\n+{\n+  if (vec != NULL)\n+    {\n+      VEC_truncate (tree, vec, 0);\n+      VEC_safe_push (tree_gc_vec, gc, tree_vector_cache, vec);\n+    }\n+}\n+\n+/* Get a new tree vector holding a single tree.  */\n+\n+VEC(tree,gc) *\n+make_tree_vector_single (tree t)\n+{\n+  VEC(tree,gc) *ret = make_tree_vector ();\n+  VEC_quick_push (tree, ret, t);\n+  return ret;\n+}\n+\n+/* Get a new tree vector which is a copy of an existing one.  */\n+\n+VEC(tree,gc) *\n+make_tree_vector_copy (const VEC(tree,gc) *orig)\n+{\n+  VEC(tree,gc) *ret;\n+  unsigned int ix;\n+  tree t;\n+\n+  ret = make_tree_vector ();\n+  VEC_reserve (tree, gc, ret, VEC_length (tree, orig));\n+  for (ix = 0; VEC_iterate (tree, orig, ix, t); ++ix)\n+    VEC_quick_push (tree, ret, t);\n+  return ret;\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "b17020a027e52d2640835abba37f8acc7e591162", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1013,6 +1013,10 @@ extern void warn_for_sign_compare (location_t,\n \t\t\t\t   enum tree_code resultcode);\n extern void set_underlying_type (tree x);\n extern bool is_typedef_decl (tree x);\n+extern VEC(tree,gc) *make_tree_vector (void);\n+extern void release_tree_vector (VEC(tree,gc) *);\n+extern VEC(tree,gc) *make_tree_vector_single (tree);\n+extern VEC(tree,gc) *make_tree_vector_copy (const VEC(tree,gc) *);\n \n /* In c-gimplify.c  */\n extern void c_genericize (tree);"}, {"sha": "0320feece40b77083dddb89edd29e4c09d2cb649", "filename": "gcc/c-parser.c", "status": "modified", "additions": 10, "deletions": 70, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -921,8 +921,6 @@ static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n \t\t\t\t\t VEC(tree,gc) **);\n-static void c_parser_release_expr_list (VEC(tree,gc) *);\n-static tree c_parser_vec_to_tree_list (VEC(tree,gc) *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n@@ -2889,9 +2887,9 @@ c_parser_attributes (c_parser *parser)\n \t\t  tree tree_list;\n \t\t  c_parser_consume_token (parser);\n \t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n-\t\t  tree_list = c_parser_vec_to_tree_list (expr_list);\n+\t\t  tree_list = build_tree_list_vec (expr_list);\n \t\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n-\t\t  c_parser_release_expr_list (expr_list);\n+\t\t  release_tree_vector (expr_list);\n \t\t}\n \t    }\n \t  else\n@@ -2901,8 +2899,8 @@ c_parser_attributes (c_parser *parser)\n \t      else\n \t\t{\n \t\t  expr_list = c_parser_expr_list (parser, false, true, NULL);\n-\t\t  attr_args = c_parser_vec_to_tree_list (expr_list);\n-\t\t  c_parser_release_expr_list (expr_list);\n+\t\t  attr_args = build_tree_list_vec (expr_list);\n+\t\t  release_tree_vector (expr_list);\n \t\t}\n \t    }\n \t  attr = build_tree_list (attr_name, attr_args);\n@@ -5719,8 +5717,8 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  expr.original_type = NULL;\n \t  if (exprlist != NULL)\n \t    {\n-\t      c_parser_release_expr_list (exprlist);\n-\t      c_parser_release_expr_list (origtypes);\n+\t      release_tree_vector (exprlist);\n+\t      release_tree_vector (origtypes);\n \t    }\n \t  break;\n \tcase CPP_DOT:\n@@ -5853,10 +5851,6 @@ c_parser_expression_conv (c_parser *parser)\n      nonempty-expr-list , assignment-expression\n */\n \n-/* We cache two vectors, to save most allocation and deallocation.  */\n-static GTY((deletable)) VEC(tree,gc) *cached_expr_list_1;\n-static GTY((deletable)) VEC(tree,gc) *cached_expr_list_2;\n-\n static VEC(tree,gc) *\n c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \t\t    VEC(tree,gc) **p_orig_types)\n@@ -5865,34 +5859,11 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n   VEC(tree,gc) *orig_types;\n   struct c_expr expr;\n \n-  if (cached_expr_list_1 != NULL)\n-    {\n-      ret = cached_expr_list_1;\n-      cached_expr_list_1 = NULL;\n-      VEC_truncate (tree, ret, 0);\n-    }\n-  else if (cached_expr_list_2 != NULL)\n-    {\n-      ret = cached_expr_list_2;\n-      cached_expr_list_2 = NULL;\n-      VEC_truncate (tree, ret, 0);\n-    }\n-  else\n-    ret = VEC_alloc (tree, gc, 16);\n-\n+  ret = make_tree_vector ();\n   if (p_orig_types == NULL)\n     orig_types = NULL;\n   else\n-    {\n-      if (cached_expr_list_2 != NULL)\n-\t{\n-\t  orig_types = cached_expr_list_2;\n-\t  cached_expr_list_2 = NULL;\n-\t  VEC_truncate (tree, orig_types, 0);\n-\t}\n-      else\n-\torig_types = VEC_alloc (tree, gc, 16);\n-    }\n+    orig_types = make_tree_vector ();\n \n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n@@ -5918,37 +5889,6 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n     *p_orig_types = orig_types;\n   return ret;\n }\n-\n-/* Release a vector returned by c_parser_expr_list.  */\n-\n-static void\n-c_parser_release_expr_list (VEC(tree,gc) *vec)\n-{\n-  if (cached_expr_list_1 == NULL)\n-    cached_expr_list_1 = vec;\n-  else if (cached_expr_list_2 == NULL)\n-    cached_expr_list_2 = vec;\n-  else\n-    VEC_free (tree, gc, vec);\n-}\n-\n-/* Convert a vector, as returned by c_parser_expr_list, to a\n-   tree_list.  */\n-\n-static tree\n-c_parser_vec_to_tree_list (VEC(tree,gc) *vec)\n-{\n-  tree ret = NULL_TREE;\n-  tree *pp = &ret;\n-  unsigned int i;\n-  tree t;\n-  for (i = 0; VEC_iterate (tree, vec, i, t); ++i)\n-    {\n-      *pp = build_tree_list (NULL, t);\n-      pp = &TREE_CHAIN (*pp);\n-    }\n-  return ret;\n-}\n \f\n /* Parse Objective-C-specific constructs.  */\n \n@@ -6830,9 +6770,9 @@ c_parser_objc_keywordexpr (c_parser *parser)\n   else\n     {\n       /* We have a comma expression, we will collapse later.  */\n-      ret = c_parser_vec_to_tree_list (expr_list);\n+      ret = build_tree_list_vec (expr_list);\n     }\n-  c_parser_release_expr_list (expr_list);\n+  release_tree_vector (expr_list);\n   return ret;\n }\n "}, {"sha": "57dcb5484bfebcae5a1cc274b55eeadb55e4fa02", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,3 +1,99 @@\n+2009-05-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* parser.c (cp_parser_postfix_expression): Change args to a vec.\n+\tRelease it when done.\n+\t(tree_vector): Define typedef.  Define VEC functions.\n+\t(cp_parser_parenthesized_expression_list): Change return type to\n+\tvec.  Change all callers.\n+\t(cp_parser_new_expression): Change placement and initializer to\n+\tvecs.  Release them when done.\n+\t(cp_parser_new_placement): Change return type to vec.  Change all\n+\tcallers.\n+\t(cp_parser_new_initializer): Likewise.\n+\t* typeck.c (build_function_call_vec): Just call\n+\tcp_build_function_call_vec.\n+\t(cp_build_function_call): Just build a vec and call\n+\tcp_build_function_call_vec.\n+\t(cp_build_function_call_vec): New function based on old\n+\tcp_build_function_call.\n+\t(convert_arguments): Remove nargs and argarray parameters.  Change\n+\tvalues to a vec.  Change caller.\n+\t(build_x_compound_expr_from_vec): New function.\n+\t(cp_build_modify_expr): Build vec to pass to\n+\tbuild_special_member_call.\n+\t* call.c (struct z_candidate): Add first_arg field.  Change args\n+\tfield to vec.\n+\t(convert_class_to_reference): Handle first argument separately.\n+\t(add_candidate): Add first_arg parameter.  Change args parameter\n+\tto vec.  Change all callers.\n+\t(add_function_candidate, add_conv_candidate): Likewise.\n+\t(add_template_candidate_real, add_template_candidate): Likewise.\n+\t(add_template_conv_candidate): Likewise.\n+\t(build_user_type_conversion_1): Handle first argument separately.\n+\t(resolve_args): Change return type and parameter type to vecs.\n+\tChange all callers.\n+\t(perform_overload_resolution): Change args parameter to vec.\n+\tChange all callers.\n+\t(build_new_function_call, build_operator_new_call): Likewise.\n+\t(add_candidates): Likewise.\n+\t(build_op_call): New globally visible function, built from and\n+\treplacing static function build_object_call.\n+\t(build_new_op): Don't handle CALL_EXPR.  Build vec, not tree_list,\n+\tof arguments.\n+\t(build_op_delete_call): Build vec to pass to\n+\tcp_build_function_call_vec.\n+\t(build_temp): Build vec to pass to build_special_member_call.\n+\t(convert_like_real): Likewise.\n+\t(perform_direct_initialization_if_possible): Likewise.\n+\t(build_over_call): Handle first_arg field.  Use build_call_array\n+\trather than build_call_list.\n+\t(build_special_member_call): Change args parameter to vec.  Change\n+\tall callers.\n+\t(build_new_method_call): Likewise.\n+\t* init.c (expand_default_init): Change parms to vec.\n+\t(build_raw_new_expr): Change placement and init to vecs.  Change\n+\tall callers.\n+\t(build_new_1, build_new): Likewise.\n+\t* class.c (resolve_address_of_overloaded_function): Build array to\n+\tpass to fn_type_unification.\n+\t* pt.c (tsubst_copy_and_build): For NEW_EXPR build vecs to pass to\n+\tbuild_new.  For CALL_EXPR create a vec rather than a tree_list;\n+\texpand a pack if necessary.\n+\t(fn_type_unification): Change args parameter to const tree *.  Add\n+\tnargs parameter.  Change all callers.\n+\t(type_unification_real): Likewise.\n+\t(unify): Build array to pass to type_unification_real.\n+\t(get_bindings): Build array to pass to fn_type_unification.\n+\t(any_type_dependent_arguments_p): Change args parameter to a vec.\n+\tChange all callers.\n+\t(make_args_non_dependent): Renamed from build_non_dependent_args.\n+\tChange return type to void.  Change parameter type to vec.  Change\n+\tall callers.\n+\t(do_auto_deduction): Pass an array to type_unification_real.\n+\t* semantics.c (perform_koenig_lookup): Change args to vec.  Change\n+\tall callers.\n+\t(finish_call_expr): Change args to vec.  Change all callers.  Call\n+\tbuild_op_call instead of passing CALL_EXPR to build_new_op.\n+\t(cxx_omp_create_clause_info): Allocate vec to pass to\n+\tbuild_special_member_call.\n+\t* decl2.c (build_offset_ref_call_from_tree): Change args parameter\n+\tto vec.  Change all callers.\n+\t* name-lookup.c (lookup_function_nonclass): Likewise.\n+\t(struct arg_lookup): Change args to vec.\n+\t(arg_assoc_namespace): Handle args as a vec.\n+\t(arg_assoc_args_vec): New static function.\n+\t(lookup_arg_dependent): Change args parameter to vec.  Change all\n+\tcallers.\n+\t* method.c (do_build_assign_ref): Allocate vec to pass to\n+\tbuild_special_member_call.\n+\t* except.c (build_throw): Likewise.\n+\t* typeck2.c (build_functional_cast): Likewise.\n+\t* cvt.c (ocp_convert): Likewise.\n+\t* tree.c (build_min_non_dep_call_vec): Change last parameter to\n+\tvec.  Change all callers.\n+\t* cp-tree.h: Update declarations.\n+\t* name-lookup.h: Update declarations.\n+\n 2009-05-20  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* typeck.c (default_conversion): Check targetm.promoted_type."}, {"sha": "0d5ae6a6c6574e9243e103acd9dfa16f75f7628b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 438, "deletions": 252, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -145,22 +145,22 @@ static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n \t\t\t       bool, tsubst_flags_t);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t      tree, const char *);\n-static tree build_object_call (tree, tree, tsubst_flags_t);\n-static tree resolve_args (tree);\n+static VEC(tree,gc) *resolve_args (VEC(tree,gc) *);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n static void print_z_candidate (const char *, struct z_candidate *);\n static void print_z_candidates (struct z_candidate *);\n static tree build_this (tree);\n static struct z_candidate *splice_viable (struct z_candidate *, bool, bool *);\n static bool any_strictly_viable (struct z_candidate *);\n static struct z_candidate *add_template_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree, tree,\n-\t tree, tree, int, unification_kind_t);\n+\t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n+\t tree, tree, tree, int, unification_kind_t);\n static struct z_candidate *add_template_candidate_real\n-\t(struct z_candidate **, tree, tree, tree, tree, tree,\n-\t tree, tree, int, tree, unification_kind_t);\n+\t(struct z_candidate **, tree, tree, tree, tree, const VEC(tree,gc) *,\n+\t tree, tree, tree, int, tree, unification_kind_t);\n static struct z_candidate *add_template_conv_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree, tree, tree);\n+\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n+\t tree, tree);\n static void add_builtin_candidates\n \t(struct z_candidate **, enum tree_code, enum tree_code,\n \t tree, tree *, int);\n@@ -172,9 +172,11 @@ static void build_builtin_candidate\n \t(struct z_candidate **, tree, tree, tree, tree *, tree *,\n \t int);\n static struct z_candidate *add_conv_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree, tree);\n+\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n+\t tree);\n static struct z_candidate *add_function_candidate\n-\t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n+\t(struct z_candidate **, tree, tree, tree, const VEC(tree,gc) *, tree,\n+\t tree, int);\n static conversion *implicit_conversion (tree, tree, tree, bool, int);\n static conversion *standard_conversion (tree, tree, tree, bool, int);\n static conversion *reference_binding (tree, tree, tree, bool, int);\n@@ -184,7 +186,7 @@ static bool is_subseq (conversion *, conversion *);\n static conversion *maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n static struct z_candidate *add_candidate\n-\t(struct z_candidate **, tree, tree, size_t,\n+\t(struct z_candidate **, tree, tree, const VEC(tree,gc) *, size_t,\n \t conversion **, tree, tree, int);\n static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n@@ -197,7 +199,7 @@ static conversion *conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n-static void add_candidates (tree, tree, tree, bool, tree, tree,\n+static void add_candidates (tree, const VEC(tree,gc) *, tree, bool, tree, tree,\n \t\t\t    int, struct z_candidate **);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n@@ -413,8 +415,13 @@ struct z_candidate {\n   /* The FUNCTION_DECL that will be called if this candidate is\n      selected by overload resolution.  */\n   tree fn;\n-  /* The arguments to use when calling this function.  */\n-  tree args;\n+  /* If not NULL_TREE, the first argument to use when calling this\n+     function.  */\n+  tree first_arg;\n+  /* The rest of the arguments to use when calling this function.  If\n+     there are no further arguments this may be NULL or it may be an\n+     empty vector.  */\n+  const VEC(tree,gc) *args;\n   /* The implicit conversion sequences for each of the arguments to\n      FN.  */\n   conversion **convs;\n@@ -996,7 +1003,7 @@ static conversion *\n convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n {\n   tree conversions;\n-  tree arglist;\n+  tree first_arg;\n   conversion *conv;\n   tree t;\n   struct z_candidate *candidates;\n@@ -1029,8 +1036,7 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n      error messages, which we should not issue now because we are just\n      trying to find a conversion operator.  Therefore, we use NULL,\n      cast to the appropriate type.  */\n-  arglist = build_int_cst (build_pointer_type (s), 0);\n-  arglist = build_tree_list (NULL_TREE, arglist);\n+  first_arg = build_int_cst (build_pointer_type (s), 0);\n \n   t = TREE_TYPE (reference_type);\n \n@@ -1056,7 +1062,8 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n \t      cand = add_template_candidate (&candidates,\n \t\t\t\t\t     f, s,\n \t\t\t\t\t     NULL_TREE,\n-\t\t\t\t\t     arglist,\n+\t\t\t\t\t     first_arg,\n+\t\t\t\t\t     NULL,\n \t\t\t\t\t     reference_type,\n \t\t\t\t\t     TYPE_BINFO (s),\n \t\t\t\t\t     TREE_PURPOSE (conversions),\n@@ -1081,8 +1088,8 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n \t    }\n \t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n \t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n-\t    cand = add_function_candidate (&candidates, f, s, arglist,\n-\t\t\t\t\t   TYPE_BINFO (s),\n+\t    cand = add_function_candidate (&candidates, f, s, first_arg,\n+\t\t\t\t\t   NULL, TYPE_BINFO (s),\n \t\t\t\t\t   TREE_PURPOSE (conversions),\n \t\t\t\t\t   LOOKUP_NORMAL);\n \n@@ -1119,9 +1126,9 @@ convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n \n   /* Now that we know that this is the function we're going to use fix\n      the dummy first argument.  */\n-  cand->args = tree_cons (NULL_TREE,\n-\t\t\t  build_this (expr),\n-\t\t\t  TREE_CHAIN (cand->args));\n+  gcc_assert (cand->first_arg == NULL_TREE\n+\t      || integer_zerop (cand->first_arg));\n+  cand->first_arg = build_this (expr);\n \n   /* Build a user-defined conversion sequence representing the\n      conversion.  */\n@@ -1424,11 +1431,12 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n }\n \n /* Add a new entry to the list of candidates.  Used by the add_*_candidate\n-   functions.  */\n+   functions.  ARGS will not be changed until a single candidate is\n+   selected.  */\n \n static struct z_candidate *\n add_candidate (struct z_candidate **candidates,\n-\t       tree fn, tree args,\n+\t       tree fn, tree first_arg, const VEC(tree,gc) *args,\n \t       size_t num_convs, conversion **convs,\n \t       tree access_path, tree conversion_path,\n \t       int viable)\n@@ -1437,6 +1445,7 @@ add_candidate (struct z_candidate **candidates,\n     conversion_obstack_alloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n+  cand->first_arg = first_arg;\n   cand->args = args;\n   cand->convs = convs;\n   cand->num_convs = num_convs;\n@@ -1449,24 +1458,27 @@ add_candidate (struct z_candidate **candidates,\n   return cand;\n }\n \n-/* Create an overload candidate for the function or method FN called with\n-   the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n-   to implicit_conversion.\n+/* Create an overload candidate for the function or method FN called\n+   with the argument list FIRST_ARG/ARGS and add it to CANDIDATES.\n+   FLAGS is passed on to implicit_conversion.\n+\n+   This does not change ARGS.\n \n    CTYPE, if non-NULL, is the type we want to pretend this function\n    comes from for purposes of overload resolution.  */\n \n static struct z_candidate *\n add_function_candidate (struct z_candidate **candidates,\n-\t\t\ttree fn, tree ctype, tree arglist,\n-\t\t\ttree access_path, tree conversion_path,\n-\t\t\tint flags)\n+\t\t\ttree fn, tree ctype, tree first_arg,\n+\t\t\tconst VEC(tree,gc) *args, tree access_path,\n+\t\t\ttree conversion_path, int flags)\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int i, len;\n   conversion **convs;\n-  tree parmnode, argnode;\n-  tree orig_arglist;\n+  tree parmnode;\n+  tree orig_first_arg = first_arg;\n+  int skip;\n   int viable = 1;\n \n   /* At this point we should not see any functions which haven't been\n@@ -1479,13 +1491,17 @@ add_function_candidate (struct z_candidate **candidates,\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n       parmlist = skip_artificial_parms_for (fn, parmlist);\n-      orig_arglist = arglist;\n-      arglist = skip_artificial_parms_for (fn, arglist);\n+      skip = num_artificial_parms_for (fn);\n+      if (skip > 0 && first_arg != NULL_TREE)\n+\t{\n+\t  --skip;\n+\t  first_arg = NULL_TREE;\n+\t}\n     }\n   else\n-    orig_arglist = arglist;\n+    skip = 0;\n \n-  len = list_length (arglist);\n+  len = VEC_length (tree, args) - skip + (first_arg != NULL_TREE ? 1 : 0);\n   convs = alloc_conversions (len);\n \n   /* 13.3.2 - Viable functions [over.match.viable]\n@@ -1518,18 +1534,23 @@ add_function_candidate (struct z_candidate **candidates,\n      to the corresponding parameter of F.  */\n \n   parmnode = parmlist;\n-  argnode = arglist;\n \n   for (i = 0; i < len; ++i)\n     {\n-      tree arg = TREE_VALUE (argnode);\n-      tree argtype = lvalue_type (arg);\n+      tree arg, argtype;\n       conversion *t;\n       int is_this;\n \n       if (parmnode == void_list_node)\n \tbreak;\n \n+      if (i == 0 && first_arg != NULL_TREE)\n+\targ = first_arg;\n+      else\n+\targ = VEC_index (tree, args,\n+\t\t\t i + skip - (first_arg != NULL_TREE ? 1 : 0));\n+      argtype = lvalue_type (arg);\n+\n       is_this = (i == 0 && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n \t\t && ! DECL_CONSTRUCTOR_P (fn));\n \n@@ -1591,18 +1612,18 @@ add_function_candidate (struct z_candidate **candidates,\n \n       if (parmnode)\n \tparmnode = TREE_CHAIN (parmnode);\n-      argnode = TREE_CHAIN (argnode);\n     }\n \n  out:\n-  return add_candidate (candidates, fn, orig_arglist, len, convs,\n+  return add_candidate (candidates, fn, orig_first_arg, args, len, convs,\n \t\t\taccess_path, conversion_path, viable);\n }\n \n /* Create an overload candidate for the conversion function FN which will\n    be invoked for expression OBJ, producing a pointer-to-function which\n-   will in turn be called with the argument list ARGLIST, and add it to\n-   CANDIDATES.  FLAGS is passed on to implicit_conversion.\n+   will in turn be called with the argument list FIRST_ARG/ARGLIST,\n+   and add it to CANDIDATES.  This does not change ARGLIST.  FLAGS is\n+   passed on to implicit_conversion.\n \n    Actually, we don't really care about FN; we care about the type it\n    converts to.  There may be multiple conversion functions that will\n@@ -1612,21 +1633,21 @@ add_function_candidate (struct z_candidate **candidates,\n \n static struct z_candidate *\n add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n-\t\t    tree arglist, tree access_path, tree conversion_path)\n+\t\t    tree first_arg, const VEC(tree,gc) *arglist,\n+\t\t    tree access_path, tree conversion_path)\n {\n   tree totype = TREE_TYPE (TREE_TYPE (fn));\n   int i, len, viable, flags;\n-  tree parmlist, parmnode, argnode;\n+  tree parmlist, parmnode;\n   conversion **convs;\n \n   for (parmlist = totype; TREE_CODE (parmlist) != FUNCTION_TYPE; )\n     parmlist = TREE_TYPE (parmlist);\n   parmlist = TYPE_ARG_TYPES (parmlist);\n \n-  len = list_length (arglist) + 1;\n+  len = VEC_length (tree, arglist) + (first_arg != NULL_TREE ? 1 : 0) + 1;\n   convs = alloc_conversions (len);\n   parmnode = parmlist;\n-  argnode = arglist;\n   viable = 1;\n   flags = LOOKUP_IMPLICIT;\n \n@@ -1636,10 +1657,18 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \n   for (i = 0; i < len; ++i)\n     {\n-      tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n-      tree argtype = lvalue_type (arg);\n+      tree arg, argtype;\n       conversion *t;\n \n+      if (i == 0)\n+\targ = obj;\n+      else if (i == 1 && first_arg != NULL_TREE)\n+\targ = first_arg;\n+      else\n+\targ = VEC_index (tree, arglist,\n+\t\t\t i - (first_arg != NULL_TREE ? 1 : 0) - 1);\n+      argtype = lvalue_type (arg);\n+\n       if (i == 0)\n \tt = implicit_conversion (totype, argtype, arg, /*c_cast_p=*/false,\n \t\t\t\t flags);\n@@ -1666,7 +1695,6 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n \n       if (parmnode)\n \tparmnode = TREE_CHAIN (parmnode);\n-      argnode = TREE_CHAIN (argnode);\n     }\n \n   if (i < len)\n@@ -1675,7 +1703,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n   if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n-  return add_candidate (candidates, totype, arglist, len, convs,\n+  return add_candidate (candidates, totype, first_arg, arglist, len, convs,\n \t\t\taccess_path, conversion_path, viable);\n }\n \n@@ -1728,7 +1756,7 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \tviable = 0;\n     }\n \n-  add_candidate (candidates, fnname, /*args=*/NULL_TREE,\n+  add_candidate (candidates, fnname, /*first_arg=*/NULL_TREE, /*args=*/NULL,\n \t\t num_convs, convs,\n \t\t /*access_path=*/NULL_TREE,\n \t\t /*conversion_path=*/NULL_TREE,\n@@ -2349,37 +2377,79 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \n    TMPL is the template.  EXPLICIT_TARGS are any explicit template\n    arguments.  ARGLIST is the arguments provided at the call-site.\n-   The RETURN_TYPE is the desired type for conversion operators.  If\n-   OBJ is NULL_TREE, FLAGS and CTYPE are as for add_function_candidate.\n-   If an OBJ is supplied, FLAGS and CTYPE are ignored, and OBJ is as for\n-   add_conv_candidate.  */\n+   This does not change ARGLIST.  The RETURN_TYPE is the desired type\n+   for conversion operators.  If OBJ is NULL_TREE, FLAGS and CTYPE are\n+   as for add_function_candidate.  If an OBJ is supplied, FLAGS and\n+   CTYPE are ignored, and OBJ is as for add_conv_candidate.  */\n \n static struct z_candidate*\n add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n-\t\t\t     tree ctype, tree explicit_targs, tree arglist,\n-\t\t\t     tree return_type, tree access_path,\n-\t\t\t     tree conversion_path, int flags, tree obj,\n-\t\t\t     unification_kind_t strict)\n+\t\t\t     tree ctype, tree explicit_targs, tree first_arg,\n+\t\t\t     const VEC(tree,gc) *arglist, tree return_type,\n+\t\t\t     tree access_path, tree conversion_path,\n+\t\t\t     int flags, tree obj, unification_kind_t strict)\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_tree_vec (ntparms);\n-  tree args_without_in_chrg = arglist;\n+  unsigned int nargs;\n+  int skip_without_in_chrg;\n+  tree first_arg_without_in_chrg;\n+  tree *args_without_in_chrg;\n+  unsigned int nargs_without_in_chrg;\n+  unsigned int ia, ix;\n+  tree arg;\n   struct z_candidate *cand;\n   int i;\n   tree fn;\n \n+  nargs = (first_arg == NULL_TREE ? 0 : 1) + VEC_length (tree, arglist);\n+\n+  skip_without_in_chrg = 0;\n+\n+  first_arg_without_in_chrg = first_arg;\n+\n   /* We don't do deduction on the in-charge parameter, the VTT\n      parameter or 'this'.  */\n   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (tmpl))\n-    args_without_in_chrg = TREE_CHAIN (args_without_in_chrg);\n+    {\n+      if (first_arg_without_in_chrg != NULL_TREE)\n+\tfirst_arg_without_in_chrg = NULL_TREE;\n+      else\n+\t++skip_without_in_chrg;\n+    }\n \n   if ((DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (tmpl)\n        || DECL_BASE_CONSTRUCTOR_P (tmpl))\n       && CLASSTYPE_VBASECLASSES (DECL_CONTEXT (tmpl)))\n-    args_without_in_chrg = TREE_CHAIN (args_without_in_chrg);\n+    {\n+      if (first_arg_without_in_chrg != NULL_TREE)\n+\tfirst_arg_without_in_chrg = NULL_TREE;\n+      else\n+\t++skip_without_in_chrg;\n+    }\n+\n+  nargs_without_in_chrg = ((first_arg_without_in_chrg != NULL_TREE ? 1 : 0)\n+\t\t\t   + (VEC_length (tree, arglist)\n+\t\t\t      - skip_without_in_chrg));\n+  args_without_in_chrg = XALLOCAVEC (tree, nargs_without_in_chrg);\n+  ia = 0;\n+  if (first_arg_without_in_chrg != NULL_TREE)\n+    {\n+      args_without_in_chrg[ia] = first_arg_without_in_chrg;\n+      ++ia;\n+    }\n+  for (ix = skip_without_in_chrg;\n+       VEC_iterate (tree, arglist, ix, arg);\n+       ++ix)\n+    {\n+      args_without_in_chrg[ia] = arg;\n+      ++ia;\n+    }\n+  gcc_assert (ia == nargs_without_in_chrg);\n \n   i = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t   args_without_in_chrg,\n+\t\t\t   nargs_without_in_chrg,\n \t\t\t   return_type, strict, flags);\n \n   if (i != 0)\n@@ -2411,7 +2481,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n      class type, and a logical interpretation is that the intent was\n      to forbid the instantiation of member templates which would then\n      have that form.  */\n-  if (DECL_CONSTRUCTOR_P (fn) && list_length (arglist) == 2)\n+  if (DECL_CONSTRUCTOR_P (fn) && nargs == 2)\n     {\n       tree arg_types = FUNCTION_FIRST_USER_PARMTYPE (fn);\n       if (arg_types && same_type_p (TYPE_MAIN_VARIANT (TREE_VALUE (arg_types)),\n@@ -2421,11 +2491,11 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n   if (obj != NULL_TREE)\n     /* Aha, this is a conversion function.  */\n-    cand = add_conv_candidate (candidates, fn, obj, access_path,\n-\t\t\t       conversion_path, arglist);\n+    cand = add_conv_candidate (candidates, fn, obj, first_arg, arglist,\n+\t\t\t       access_path, conversion_path);\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n-\t\t\t\t   arglist, access_path,\n+\t\t\t\t   first_arg, arglist, access_path,\n \t\t\t\t   conversion_path, flags);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n@@ -2455,26 +2525,29 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n static struct z_candidate *\n add_template_candidate (struct z_candidate **candidates, tree tmpl, tree ctype,\n-\t\t\ttree explicit_targs, tree arglist, tree return_type,\n+\t\t\ttree explicit_targs, tree first_arg,\n+\t\t\tconst VEC(tree,gc) *arglist, tree return_type,\n \t\t\ttree access_path, tree conversion_path, int flags,\n \t\t\tunification_kind_t strict)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, ctype,\n-\t\t\t\t explicit_targs, arglist, return_type,\n-\t\t\t\t access_path, conversion_path,\n+\t\t\t\t explicit_targs, first_arg, arglist,\n+\t\t\t\t return_type, access_path, conversion_path,\n \t\t\t\t flags, NULL_TREE, strict);\n }\n \n \n static struct z_candidate *\n add_template_conv_candidate (struct z_candidate **candidates, tree tmpl,\n-\t\t\t     tree obj, tree arglist, tree return_type,\n-\t\t\t     tree access_path, tree conversion_path)\n+\t\t\t     tree obj, tree first_arg,\n+\t\t\t     const VEC(tree,gc) *arglist,\n+\t\t\t     tree return_type, tree access_path,\n+\t\t\t     tree conversion_path)\n {\n   return\n     add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n-\t\t\t\t arglist, return_type, access_path,\n+\t\t\t\t first_arg, arglist, return_type, access_path,\n \t\t\t\t conversion_path, 0, obj, DEDUCE_CONV);\n }\n \n@@ -2681,7 +2754,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   tree ctors = NULL_TREE;\n   tree conv_fns = NULL_TREE;\n   conversion *conv = NULL;\n-  tree args = NULL_TREE;\n+  tree first_arg = NULL_TREE;\n+  VEC(tree,gc) *args = NULL;\n   bool any_viable_p;\n   int convflags;\n \n@@ -2721,28 +2795,26 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n   if (ctors)\n     {\n-      tree t;\n-\n       ctors = BASELINK_FUNCTIONS (ctors);\n \n-      t = build_int_cst (build_pointer_type (totype), 0);\n+      first_arg = build_int_cst (build_pointer_type (totype), 0);\n       if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n \t  && !TYPE_HAS_LIST_CTOR (totype))\n \t{\n-\t  args = ctor_to_list (expr);\n+\t  args = ctor_to_vec (expr);\n \t  /* We still allow more conversions within an init-list.  */\n \t  flags = ((flags & ~LOOKUP_NO_CONVERSION)\n \t\t   /* But not for the copy ctor.  */\n \t\t   |LOOKUP_NO_COPY_CTOR_CONVERSION\n \t\t   |LOOKUP_NO_NARROWING);\n \t}\n       else\n-\targs = build_tree_list (NULL_TREE, expr);\n+\targs = make_tree_vector_single (expr);\n+\n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n \t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n-      args = tree_cons (NULL_TREE, t, args);\n     }\n   for (; ctors; ctors = OVL_NEXT (ctors))\n     {\n@@ -2753,14 +2825,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n       if (TREE_CODE (ctor) == TEMPLATE_DECL)\n \tcand = add_template_candidate (&candidates, ctor, totype,\n-\t\t\t\t       NULL_TREE, args, NULL_TREE,\n+\t\t\t\t       NULL_TREE, first_arg, args, NULL_TREE,\n \t\t\t\t       TYPE_BINFO (totype),\n \t\t\t\t       TYPE_BINFO (totype),\n \t\t\t\t       flags,\n \t\t\t\t       DEDUCE_CALL);\n       else\n \tcand = add_function_candidate (&candidates, ctor, totype,\n-\t\t\t\t       args, TYPE_BINFO (totype),\n+\t\t\t\t       first_arg, args, TYPE_BINFO (totype),\n \t\t\t\t       TYPE_BINFO (totype),\n \t\t\t\t       flags);\n \n@@ -2784,7 +2856,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n     }\n \n   if (conv_fns)\n-    args = build_tree_list (NULL_TREE, build_this (expr));\n+    first_arg = build_this (expr);\n \n   for (; conv_fns; conv_fns = TREE_CHAIN (conv_fns))\n     {\n@@ -2816,14 +2888,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    cand = add_template_candidate (&candidates, fn, fromtype,\n \t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   args, totype,\n+\t\t\t\t\t   first_arg, NULL, totype,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags,\n \t\t\t\t\t   DEDUCE_CONV);\n \t  else\n \t    cand = add_function_candidate (&candidates, fn, fromtype,\n-\t\t\t\t\t   args,\n+\t\t\t\t\t   first_arg, NULL,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags);\n@@ -2926,23 +2998,23 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n \n /* Do any initial processing on the arguments to a function call.  */\n \n-static tree\n-resolve_args (tree args)\n+static VEC(tree,gc) *\n+resolve_args (VEC(tree,gc) *args)\n {\n-  tree t;\n-  for (t = args; t; t = TREE_CHAIN (t))\n-    {\n-      tree arg = TREE_VALUE (t);\n+  unsigned int ix;\n+  tree arg;\n \n+  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+    {\n       if (error_operand_p (arg))\n-\treturn error_mark_node;\n+\treturn NULL;\n       else if (VOID_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  error (\"invalid use of void expression\");\n-\t  return error_mark_node;\n+\t  return NULL;\n \t}\n       else if (invalid_nonstatic_memfn_p (arg, tf_warning_or_error))\n-\treturn error_mark_node;\n+\treturn NULL;\n     }\n   return args;\n }\n@@ -2961,7 +3033,7 @@ resolve_args (tree args)\n \n static struct z_candidate *\n perform_overload_resolution (tree fn,\n-\t\t\t     tree args,\n+\t\t\t     const VEC(tree,gc) *args,\n \t\t\t     struct z_candidate **candidates,\n \t\t\t     bool *any_viable_p)\n {\n@@ -2972,12 +3044,11 @@ perform_overload_resolution (tree fn,\n   *candidates = NULL;\n   *any_viable_p = true;\n \n-  /* Check FN and ARGS.  */\n+  /* Check FN.  */\n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n \t      || TREE_CODE (fn) == TEMPLATE_DECL\n \t      || TREE_CODE (fn) == OVERLOAD\n \t      || TREE_CODE (fn) == TEMPLATE_ID_EXPR);\n-  gcc_assert (!args || TREE_CODE (args) == TREE_LIST);\n \n   if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n     {\n@@ -3002,20 +3073,24 @@ perform_overload_resolution (tree fn,\n }\n \n /* Return an expression for a call to FN (a namespace-scope function,\n-   or a static member function) with the ARGS.  */\n+   or a static member function) with the ARGS.  This may change\n+   ARGS.  */\n \n tree\n-build_new_function_call (tree fn, tree args, bool koenig_p, \n+build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p, \n \t\t\t tsubst_flags_t complain)\n {\n   struct z_candidate *candidates, *cand;\n   bool any_viable_p;\n   void *p;\n   tree result;\n \n-  args = resolve_args (args);\n-  if (args == error_mark_node)\n-    return error_mark_node;\n+  if (args != NULL && *args != NULL)\n+    {\n+      *args = resolve_args (*args);\n+      if (*args == NULL)\n+\treturn error_mark_node;\n+    }\n \n   /* If this function was found without using argument dependent\n      lookup, then we want to ignore any undeclared friend\n@@ -3029,30 +3104,31 @@ build_new_function_call (tree fn, tree args, bool koenig_p,\n \t{\n \t  if (complain & tf_error)\n \t    error (\"no matching function for call to %<%D(%A)%>\",\n-\t\t   DECL_NAME (OVL_CURRENT (orig_fn)), args);\n+\t\t   DECL_NAME (OVL_CURRENT (orig_fn)),\n+\t\t   build_tree_list_vec (*args));\n \t  return error_mark_node;\n \t}\n     }\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  cand = perform_overload_resolution (fn, args, &candidates, &any_viable_p);\n+  cand = perform_overload_resolution (fn, *args, &candidates, &any_viable_p);\n \n   if (!cand)\n     {\n       if (complain & tf_error)\n \t{\n \t  if (!any_viable_p && candidates && ! candidates->next)\n-\t    return cp_build_function_call (candidates->fn, args, complain);\n+\t    return cp_build_function_call_vec (candidates->fn, args, complain);\n \t  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n \t    fn = TREE_OPERAND (fn, 0);\n \t  if (!any_viable_p)\n \t    error (\"no matching function for call to %<%D(%A)%>\",\n-\t\t   DECL_NAME (OVL_CURRENT (fn)), args);\n+\t\t   DECL_NAME (OVL_CURRENT (fn)), build_tree_list_vec (*args));\n \t  else\n \t    error (\"call of overloaded %<%D(%A)%> is ambiguous\",\n-\t\t   DECL_NAME (OVL_CURRENT (fn)), args);\n+\t\t   DECL_NAME (OVL_CURRENT (fn)), build_tree_list_vec (*args));\n \t  if (candidates)\n \t    print_z_candidates (candidates);\n \t}\n@@ -3069,15 +3145,16 @@ build_new_function_call (tree fn, tree args, bool koenig_p,\n \n /* Build a call to a global operator new.  FNNAME is the name of the\n    operator (either \"operator new\" or \"operator new[]\") and ARGS are\n-   the arguments provided.  *SIZE points to the total number of bytes\n-   required by the allocation, and is updated if that is changed here.\n-   *COOKIE_SIZE is non-NULL if a cookie should be used.  If this\n-   function determines that no cookie should be used, after all,\n-   *COOKIE_SIZE is set to NULL_TREE.  If FN is non-NULL, it will be\n-   set, upon return, to the allocation function called.  */\n+   the arguments provided.  This may change ARGS.  *SIZE points to the\n+   total number of bytes required by the allocation, and is updated if\n+   that is changed here.  *COOKIE_SIZE is non-NULL if a cookie should\n+   be used.  If this function determines that no cookie should be\n+   used, after all, *COOKIE_SIZE is set to NULL_TREE.  If FN is\n+   non-NULL, it will be set, upon return, to the allocation function\n+   called.  */\n \n tree\n-build_operator_new_call (tree fnname, tree args,\n+build_operator_new_call (tree fnname, VEC(tree,gc) **args,\n \t\t\t tree *size, tree *cookie_size,\n \t\t\t tree *fn)\n {\n@@ -3088,10 +3165,10 @@ build_operator_new_call (tree fnname, tree args,\n \n   if (fn)\n     *fn = NULL_TREE;\n-  args = tree_cons (NULL_TREE, *size, args);\n-  args = resolve_args (args);\n-  if (args == error_mark_node)\n-    return args;\n+  VEC_safe_insert (tree, gc, *args, 0, *size);\n+  *args = resolve_args (*args);\n+  if (*args == NULL)\n+    return error_mark_node;\n \n   /* Based on:\n \n@@ -3102,21 +3179,21 @@ build_operator_new_call (tree fnname, tree args,\n        up in the global scope.\n \n      we disregard block-scope declarations of \"operator new\".  */\n-  fns = lookup_function_nonclass (fnname, args, /*block_p=*/false);\n+  fns = lookup_function_nonclass (fnname, *args, /*block_p=*/false);\n \n   /* Figure out what function is being called.  */\n-  cand = perform_overload_resolution (fns, args, &candidates, &any_viable_p);\n+  cand = perform_overload_resolution (fns, *args, &candidates, &any_viable_p);\n \n   /* If no suitable function could be found, issue an error message\n      and give up.  */\n   if (!cand)\n     {\n       if (!any_viable_p)\n \terror (\"no matching function for call to %<%D(%A)%>\",\n-\t       DECL_NAME (OVL_CURRENT (fns)), args);\n+\t       DECL_NAME (OVL_CURRENT (fns)), build_tree_list_vec (*args));\n       else\n \terror (\"call of overloaded %<%D(%A)%> is ambiguous\",\n-\t       DECL_NAME (OVL_CURRENT (fns)), args);\n+\t       DECL_NAME (OVL_CURRENT (fns)), build_tree_list_vec (*args));\n       if (candidates)\n \tprint_z_candidates (candidates);\n       return error_mark_node;\n@@ -3130,12 +3207,11 @@ build_operator_new_call (tree fnname, tree args,\n        bool use_cookie = true;\n        if (!abi_version_at_least (2))\n \t {\n-\t   tree placement = TREE_CHAIN (args);\n \t   /* In G++ 3.2, the check was implemented incorrectly; it\n \t      looked at the placement expression, rather than the\n \t      type of the function.  */\n-\t   if (placement && !TREE_CHAIN (placement)\n-\t       && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n+\t   if (VEC_length (tree, *args) == 2\n+\t       && same_type_p (TREE_TYPE (VEC_index (tree, *args, 1)),\n \t\t\t       ptr_type_node))\n \t     use_cookie = false;\n \t }\n@@ -3159,7 +3235,7 @@ build_operator_new_call (tree fnname, tree args,\n \t   /* Update the total size.  */\n \t   *size = size_binop (PLUS_EXPR, *size, *cookie_size);\n \t   /* Update the argument list to reflect the adjusted size.  */\n-\t   TREE_VALUE (args) = *size;\n+\t   VEC_replace (tree, *args, 0, *size);\n \t }\n        else\n \t *cookie_size = NULL_TREE;\n@@ -3173,16 +3249,23 @@ build_operator_new_call (tree fnname, tree args,\n    return build_over_call (cand, LOOKUP_NORMAL, tf_warning_or_error);\n }\n \n-static tree\n-build_object_call (tree obj, tree args, tsubst_flags_t complain)\n+/* Build a new call to operator().  This may change ARGS.  */\n+\n+tree\n+build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, convs, mem_args = NULL_TREE;\n+  tree fns, convs, first_mem_arg = NULL_TREE;\n   tree type = TREE_TYPE (obj);\n   bool any_viable_p;\n   tree result = NULL_TREE;\n   void *p;\n \n+  if (error_operand_p (obj))\n+    return error_mark_node;\n+\n+  obj = prep_operand (obj);\n+\n   if (TYPE_PTRMEMFUNC_P (type))\n     {\n       if (complain & tf_error)\n@@ -3201,31 +3284,33 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n   else\n     fns = NULL_TREE;\n \n-  args = resolve_args (args);\n-\n-  if (args == error_mark_node)\n-    return error_mark_node;\n+  if (args != NULL && *args != NULL)\n+    {\n+      *args = resolve_args (*args);\n+      if (*args == NULL)\n+\treturn error_mark_node;\n+    }\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n   if (fns)\n     {\n       tree base = BINFO_TYPE (BASELINK_BINFO (fns));\n-      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n+      first_mem_arg = build_this (obj);\n \n       for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n-\t\t\t\t    mem_args, NULL_TREE,\n+\t\t\t\t    first_mem_arg, *args, NULL_TREE,\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n \t  else\n \t    add_function_candidate\n-\t      (&candidates, fn, base, mem_args, TYPE_BINFO (type),\n+\t      (&candidates, fn, base, first_mem_arg, *args, TYPE_BINFO (type),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL);\n \t}\n     }\n@@ -3253,12 +3338,12 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n \n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t      add_template_conv_candidate\n-\t\t(&candidates, fn, obj, args, totype,\n+\t\t(&candidates, fn, obj, NULL_TREE, *args, totype,\n \t\t /*access_path=*/NULL_TREE,\n \t\t /*conversion_path=*/NULL_TREE);\n \t    else\n-\t      add_conv_candidate (&candidates, fn, obj, args,\n-\t\t\t\t  /*conversion_path=*/NULL_TREE,\n+\t      add_conv_candidate (&candidates, fn, obj, NULL_TREE,\n+\t\t\t\t  *args, /*conversion_path=*/NULL_TREE,\n \t\t\t\t  /*access_path=*/NULL_TREE);\n \t  }\n     }\n@@ -3268,7 +3353,8 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n     {\n       if (complain & tf_error)\n         {\n-          error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj), args);\n+          error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj),\n+\t\t build_tree_list_vec (*args));\n           print_z_candidates (candidates);\n         }\n       result = error_mark_node;\n@@ -3281,7 +3367,7 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n           if (complain & tf_error)\n             {\n               error (\"call of %<(%T) (%A)%> is ambiguous\", \n-                     TREE_TYPE (obj), args);\n+                     TREE_TYPE (obj), build_tree_list_vec (*args));\n               print_z_candidates (candidates);\n             }\n \t  result = error_mark_node;\n@@ -3297,7 +3383,7 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n \t  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1,\n \t\t\t\t\t   complain);\n \t  obj = convert_from_reference (obj);\n-\t  result = cp_build_function_call (obj, args, complain);\n+\t  result = cp_build_function_call_vec (obj, args, complain);\n \t}\n     }\n \n@@ -3849,51 +3935,68 @@ prep_operand (tree operand)\n /* Add each of the viable functions in FNS (a FUNCTION_DECL or\n    OVERLOAD) to the CANDIDATES, returning an updated list of\n    CANDIDATES.  The ARGS are the arguments provided to the call,\n-   without any implicit object parameter.  The EXPLICIT_TARGS are\n-   explicit template arguments provided.  TEMPLATE_ONLY is true if\n-   only template functions should be considered.  CONVERSION_PATH,\n-   ACCESS_PATH, and FLAGS are as for add_function_candidate.  */\n+   without any implicit object parameter.  This may change ARGS.  The\n+   EXPLICIT_TARGS are explicit template arguments provided.\n+   TEMPLATE_ONLY is true if only template functions should be\n+   considered.  CONVERSION_PATH, ACCESS_PATH, and FLAGS are as for\n+   add_function_candidate.  */\n \n static void\n-add_candidates (tree fns, tree args,\n+add_candidates (tree fns, const VEC(tree,gc) *args,\n \t\ttree explicit_targs, bool template_only,\n \t\ttree conversion_path, tree access_path,\n \t\tint flags,\n \t\tstruct z_candidate **candidates)\n {\n   tree ctype;\n-  tree non_static_args;\n+  VEC(tree,gc) *non_static_args;\n+  tree first_arg;\n \n   ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n   /* Delay creating the implicit this parameter until it is needed.  */\n-  non_static_args = NULL_TREE;\n+  non_static_args = NULL;\n+  first_arg = NULL_TREE;\n \n   while (fns)\n     {\n       tree fn;\n-      tree fn_args;\n+      tree fn_first_arg;\n+      const VEC(tree,gc) *fn_args;\n \n       fn = OVL_CURRENT (fns);\n       /* Figure out which set of arguments to use.  */\n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n \t{\n \t  /* If this function is a non-static member, prepend the implicit\n \t     object parameter.  */\n-\t  if (!non_static_args)\n-\t    non_static_args = tree_cons (NULL_TREE,\n-\t\t\t\t\t build_this (TREE_VALUE (args)),\n-\t\t\t\t\t TREE_CHAIN (args));\n+\t  if (non_static_args == NULL)\n+\t    {\n+\t      unsigned int ix;\n+\t      tree arg;\n+\n+\t      non_static_args = VEC_alloc (tree, gc,\n+\t\t\t\t\t   VEC_length (tree, args) - 1);\n+\t      for (ix = 1; VEC_iterate (tree, args, ix, arg); ++ix)\n+\t\tVEC_quick_push (tree, non_static_args, arg);\n+\t    }\n+\t  if (first_arg == NULL_TREE)\n+\t    first_arg = build_this (VEC_index (tree, args, 0));\n+\t  fn_first_arg = first_arg;\n \t  fn_args = non_static_args;\n \t}\n       else\n-\t/* Otherwise, just use the list of arguments provided.  */\n-\tfn_args = args;\n+\t{\n+\t  /* Otherwise, just use the list of arguments provided.  */\n+\t  fn_first_arg = NULL_TREE;\n+\t  fn_args = args;\n+\t}\n \n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n \tadd_template_candidate (candidates,\n \t\t\t\tfn,\n \t\t\t\tctype,\n \t\t\t\texplicit_targs,\n+\t\t\t\tfn_first_arg, \n \t\t\t\tfn_args,\n \t\t\t\tNULL_TREE,\n \t\t\t\taccess_path,\n@@ -3904,6 +4007,7 @@ add_candidates (tree fns, tree args,\n \tadd_function_candidate (candidates,\n \t\t\t\tfn,\n \t\t\t\tctype,\n+\t\t\t\tfn_first_arg,\n \t\t\t\tfn_args,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n@@ -3917,7 +4021,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      bool *overloaded_p, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree arglist, fnname;\n+  VEC(tree,gc) *arglist;\n+  tree fnname;\n   tree args[3];\n   tree result = NULL_TREE;\n   bool result_valid_p = false;\n@@ -3955,7 +4060,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       gcc_unreachable ();\n \n     case CALL_EXPR:\n-      return build_object_call (arg1, arg2, complain);\n+      /* Use build_op_call instead.  */\n+      gcc_unreachable ();\n \n     case TRUTH_ORIF_EXPR:\n     case TRUTH_ANDIF_EXPR:\n@@ -3988,12 +4094,12 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n     arg2 = integer_zero_node;\n \n-  arglist = NULL_TREE;\n-  if (arg3)\n-    arglist = tree_cons (NULL_TREE, arg3, arglist);\n-  if (arg2)\n-    arglist = tree_cons (NULL_TREE, arg2, arglist);\n-  arglist = tree_cons (NULL_TREE, arg1, arglist);\n+  arglist = VEC_alloc (tree, gc, 3);\n+  VEC_quick_push (tree, arglist, arg1);\n+  if (arg2 != NULL_TREE)\n+    VEC_quick_push (tree, arglist, arg2);\n+  if (arg3 != NULL_TREE)\n+    VEC_quick_push (tree, arglist, arg3);\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n@@ -4133,7 +4239,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  if (overloaded_p)\n \t    *overloaded_p = true;\n \n-\t  if (resolve_args (arglist) == error_mark_node)\n+\t  if (resolve_args (arglist) == NULL)\n \t    result = error_mark_node;\n \t  else\n \t    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n@@ -4434,13 +4540,14 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t}\n       else\n \t{\n-\t  tree args;\n-\t  if (pass == 0)\n-\t    args = tree_cons (NULL_TREE, addr, NULL_TREE);\n-\t  else\n-\t    args = tree_cons (NULL_TREE, addr,\n-\t\t\t      build_tree_list (NULL_TREE, size));\n-\t  return cp_build_function_call (fn, args, tf_warning_or_error);\n+\t  tree ret;\n+\t  VEC(tree,gc) *args = VEC_alloc (tree, gc, 2);\n+\t  VEC_quick_push (tree, args, addr);\n+\t  if (pass != 0)\n+\t    VEC_quick_push (tree, args, size);\n+\t  ret = cp_build_function_call_vec (fn, &args, tf_warning_or_error);\n+\t  VEC_free (tree, gc, args);\n+\t  return ret;\n \t}\n     }\n \n@@ -4498,12 +4605,13 @@ build_temp (tree expr, tree type, int flags,\n \t    diagnostic_t *diagnostic_kind)\n {\n   int savew, savee;\n+  VEC(tree,gc) *args;\n \n   savew = warningcount, savee = errorcount;\n-  expr = build_special_member_call (NULL_TREE,\n-\t\t\t\t    complete_ctor_identifier,\n-\t\t\t\t    build_tree_list (NULL_TREE, expr),\n-\t\t\t\t    type, flags, tf_warning_or_error);\n+  args = make_tree_vector_single (expr);\n+  expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t    &args, type, flags, tf_warning_or_error);\n+  release_tree_vector (args);\n   if (warningcount > savew)\n     *diagnostic_kind = DK_WARNING;\n   else if (errorcount > savee)\n@@ -4665,7 +4773,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \ttree elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (totype), 0);\n \ttree new_ctor = build_constructor (init_list_type_node, NULL);\n \tunsigned len = CONSTRUCTOR_NELTS (expr);\n-\ttree array, parms, val;\n+\ttree array, val;\n+\tVEC(tree,gc) *parms;\n \tunsigned ix;\n \n \t/* Convert all the elements.  */\n@@ -4684,12 +4793,14 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tarray = build_array_of_n_type (elttype, len);\n \tarray = finish_compound_literal (array, new_ctor);\n \n-\tparms = build_tree_list (NULL_TREE, size_int (len));\n-\tparms = tree_cons (NULL_TREE, decay_conversion (array), parms);\n+\tparms = make_tree_vector ();\n+\tVEC_safe_push (tree, gc, parms, decay_conversion (array));\n+\tVEC_safe_push (tree, gc, parms, size_int (len));\n \t/* Call the private constructor.  */\n \tpush_deferring_access_checks (dk_no_check);\n \tnew_ctor = build_special_member_call\n-\t  (NULL_TREE, complete_ctor_identifier, parms, totype, 0, complain);\n+\t  (NULL_TREE, complete_ctor_identifier, &parms, totype, 0, complain);\n+\trelease_tree_vector (parms);\n \tpop_deferring_access_checks ();\n \treturn build_cplus_new (totype, new_ctor);\n       }\n@@ -5146,14 +5257,16 @@ static tree\n build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n {\n   tree fn = cand->fn;\n-  tree args = cand->args;\n+  const VEC(tree,gc) *args = cand->args;\n+  tree first_arg = cand->first_arg;\n   conversion **convs = cand->convs;\n   conversion *conv;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int parmlen;\n-  tree arg, val;\n+  tree val;\n   int i = 0;\n   int j = 0;\n+  unsigned int arg_index = 0;\n   int is_method = 0;\n   int nargs;\n   tree *argarray;\n@@ -5167,8 +5280,28 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     {\n       tree expr;\n       tree return_type;\n+      const tree *argarray;\n+      unsigned int nargs;\n+\n       return_type = TREE_TYPE (TREE_TYPE (fn));\n-      expr = build_call_list (return_type, build_addr_func (fn), args);\n+      nargs = VEC_length (tree, args);\n+      if (first_arg == NULL_TREE)\n+\targarray = VEC_address (tree, CONST_CAST (VEC(tree,gc) *, args));\n+      else\n+\t{\n+\t  tree *alcarray;\n+\t  unsigned int ix;\n+\t  tree arg;\n+\n+\t  ++nargs;\n+\t  alcarray = XALLOCAVEC (tree, nargs);\n+\t  alcarray[0] = first_arg;\n+\t  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+\t    alcarray[ix + 1] = arg;\n+\t  argarray = alcarray;\n+\t}\n+      expr = build_call_array (return_type, build_addr_func (fn), nargs,\n+\t\t\t       argarray);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n       if (!VOID_TYPE_P (return_type))\n@@ -5223,13 +5356,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \tperform_or_defer_access_check (cand->access_path, fn, fn);\n     }\n \n-  if (args && TREE_CODE (args) != TREE_LIST)\n-    args = build_tree_list (NULL_TREE, args);\n-  arg = args;\n-\n   /* Find maximum size of vector to hold converted arguments.  */\n   parmlen = list_length (parm);\n-  nargs = list_length (args);\n+  nargs = VEC_length (tree, args) + (first_arg != NULL_TREE ? 1 : 0);\n   if (parmlen > nargs)\n     nargs = parmlen;\n   argarray = (tree *) alloca (nargs * sizeof (tree));\n@@ -5238,24 +5367,35 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n      resolution, and must be of the proper type.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n-      argarray[j++] = TREE_VALUE (arg);\n-      arg = TREE_CHAIN (arg);\n+      if (first_arg != NULL_TREE)\n+\t{\n+\t  argarray[j++] = first_arg;\n+\t  first_arg = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  argarray[j++] = VEC_index (tree, args, arg_index);\n+\t  ++arg_index;\n+\t}\n       parm = TREE_CHAIN (parm);\n       /* We should never try to call the abstract constructor.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (fn));\n \n       if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n-\t  argarray[j++] = TREE_VALUE (arg);\n-\t  arg = TREE_CHAIN (arg);\n+\t  argarray[j++] = VEC_index (tree, args, arg_index);\n+\t  ++arg_index;\n \t  parm = TREE_CHAIN (parm);\n \t}\n     }\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n     {\n       tree parmtype = TREE_VALUE (parm);\n-      tree argtype = TREE_TYPE (TREE_VALUE (arg));\n+      tree arg = (first_arg != NULL_TREE\n+\t\t  ? first_arg\n+\t\t  : VEC_index (tree, args, arg_index));\n+      tree argtype = TREE_TYPE (arg);\n       tree converted_arg;\n       tree base_binfo;\n \n@@ -5278,7 +5418,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       /* Convert to the base in which the function was declared.  */\n       gcc_assert (cand->conversion_path != NULL_TREE);\n       converted_arg = build_base_path (PLUS_EXPR,\n-\t\t\t\t       TREE_VALUE (arg),\n+\t\t\t\t       arg,\n \t\t\t\t       cand->conversion_path,\n \t\t\t\t       1);\n       /* Check that the base class is accessible.  */\n@@ -5297,13 +5437,17 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \n       argarray[j++] = converted_arg;\n       parm = TREE_CHAIN (parm);\n-      arg = TREE_CHAIN (arg);\n+      if (first_arg != NULL_TREE)\n+\tfirst_arg = NULL_TREE;\n+      else\n+\t++arg_index;\n       ++i;\n       is_method = 1;\n     }\n \n-  for (; arg && parm;\n-       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n+  gcc_assert (first_arg == NULL_TREE);\n+  for (; arg_index < VEC_length (tree, args) && parm;\n+       parm = TREE_CHAIN (parm), ++arg_index, ++i)\n     {\n       tree type = TREE_VALUE (parm);\n \n@@ -5316,7 +5460,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \tconv = conv->u.next;\n \n       val = convert_like_with_context\n-\t(conv, TREE_VALUE (arg), fn, i - is_method, complain);\n+\t(conv, VEC_index (tree, args, arg_index), fn, i - is_method,\n+\t complain);\n \n       val = convert_for_arg_passing (type, val);\n       if (val == error_mark_node)\n@@ -5331,9 +5476,9 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t\t\t\t TREE_PURPOSE (parm),\n \t\t\t\t\t fn, i - is_method);\n   /* Ellipsis */\n-  for (; arg; arg = TREE_CHAIN (arg))\n+  for (; arg_index < VEC_length (tree, args); ++arg_index)\n     {\n-      tree a = TREE_VALUE (arg);\n+      tree a = VEC_index (tree, args, arg_index);\n       if (magic_varargs_p (fn))\n \t/* Do no conversions for magic varargs.  */;\n       else\n@@ -5357,7 +5502,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n                || DECL_MOVE_CONSTRUCTOR_P (fn)))\n     {\n       tree targ;\n-      arg = argarray[num_artificial_parms_for (fn)];\n+      tree arg = argarray[num_artificial_parms_for (fn)];\n+      tree fa;\n \n       /* Pull out the real argument, disregarding const-correctness.  */\n       targ = arg;\n@@ -5398,7 +5544,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t INIT_EXPR to collapse the temp into our target.  Otherwise, if the\n \t ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a\n \t temp or an INIT_EXPR otherwise.  */\n-      if (integer_zerop (TREE_VALUE (args)))\n+      fa = (cand->first_arg != NULL_TREE\n+\t    ? cand->first_arg\n+\t    : VEC_index (tree, args, 0));\n+      if (integer_zerop (fa))\n \t{\n \t  if (TREE_CODE (arg) == TARGET_EXPR)\n \t    return arg;\n@@ -5409,8 +5558,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t       || (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn))\n \t\t   && !move_fn_p (fn)))\n \t{\n-\t  tree to = stabilize_reference\n-\t    (cp_build_indirect_ref (TREE_VALUE (args), 0, complain));\n+\t  tree to = stabilize_reference (cp_build_indirect_ref (fa, 0,\n+\t\t\t\t\t\t\t\tcomplain));\n \n \t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  return val;\n@@ -5424,8 +5573,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t(cp_build_indirect_ref (argarray[0], 0, complain));\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n+      tree arg = argarray[1];\n \n-      arg = argarray[1];\n       if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n \t{\n \t  arg = cp_build_indirect_ref (arg, 0, complain);\n@@ -5631,9 +5780,10 @@ in_charge_arg_for_name (tree name)\n \n /* Build a call to a constructor, destructor, or an assignment\n    operator for INSTANCE, an expression with class type.  NAME\n-   indicates the special member function to call; ARGS are the\n-   arguments.  BINFO indicates the base of INSTANCE that is to be\n-   passed as the `this' parameter to the member function called.\n+   indicates the special member function to call; *ARGS are the\n+   arguments.  ARGS may be NULL.  This may change ARGS.  BINFO\n+   indicates the base of INSTANCE that is to be passed as the `this'\n+   parameter to the member function called.\n \n    FLAGS are the LOOKUP_* flags to use when processing the call.\n \n@@ -5642,12 +5792,14 @@ in_charge_arg_for_name (tree name)\n    store the newly constructed object into a VAR_DECL.  */\n \n tree\n-build_special_member_call (tree instance, tree name, tree args,\n+build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n \t\t\t   tree binfo, int flags, tsubst_flags_t complain)\n {\n   tree fns;\n   /* The type of the subobject to be constructed or destroyed.  */\n   tree class_type;\n+  VEC(tree,gc) *allocated = NULL;\n+  tree ret;\n \n   gcc_assert (name == complete_ctor_identifier\n \t      || name == base_ctor_identifier\n@@ -5679,7 +5831,7 @@ build_special_member_call (tree instance, tree name, tree args,\n       if (name == complete_dtor_identifier\n \t  || name == base_dtor_identifier\n \t  || name == deleting_dtor_identifier)\n-\tgcc_assert (args == NULL_TREE);\n+\tgcc_assert (args == NULL || VEC_empty (tree, *args));\n \n       /* Convert to the base class, if necessary.  */\n       if (!same_type_ignoring_top_level_qualifiers_p\n@@ -5728,13 +5880,24 @@ build_special_member_call (tree instance, tree name, tree args,\n       sub_vtt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtt), vtt,\n \t\t\tBINFO_SUBVTT_INDEX (binfo));\n \n-      args = tree_cons (NULL_TREE, sub_vtt, args);\n+      if (args == NULL)\n+\t{\n+\t  allocated = make_tree_vector ();\n+\t  args = &allocated;\n+\t}\n+\n+      VEC_safe_insert (tree, gc, *args, 0, sub_vtt);\n     }\n \n-  return build_new_method_call (instance, fns, args,\n-\t\t\t\tTYPE_BINFO (BINFO_TYPE (binfo)),\n-\t\t\t\tflags, /*fn=*/NULL,\n-\t\t\t\tcomplain);\n+  ret = build_new_method_call (instance, fns, args,\n+\t\t\t       TYPE_BINFO (BINFO_TYPE (binfo)),\n+\t\t\t       flags, /*fn=*/NULL,\n+\t\t\t       complain);\n+\n+  if (allocated != NULL)\n+    release_tree_vector (allocated);\n+\n+  return ret;\n }\n \n /* Return the NAME, as a C string.  The NAME indicates a function that\n@@ -5783,10 +5946,11 @@ name_as_c_string (tree name, tree type, bool *free_p)\n }\n \n /* Build a call to \"INSTANCE.FN (ARGS)\".  If FN_P is non-NULL, it will\n-   be set, upon return, to the function called.  */\n+   be set, upon return, to the function called.  ARGS may be NULL.\n+   This may change ARGS.  */\n \n tree\n-build_new_method_call (tree instance, tree fns, tree args,\n+build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n \t\t       tree conversion_path, int flags,\n \t\t       tree *fn_p, tsubst_flags_t complain)\n {\n@@ -5795,17 +5959,19 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree basetype = NULL_TREE;\n   tree access_binfo;\n   tree optype;\n-  tree mem_args = NULL_TREE, instance_ptr;\n+  tree first_mem_arg = NULL_TREE;\n+  tree instance_ptr;\n   tree name;\n-  tree user_args;\n+  bool skip_first_for_error;\n+  VEC(tree,gc) *user_args;\n   tree call;\n   tree fn;\n   tree class_type;\n   int template_only = 0;\n   bool any_viable_p;\n   tree orig_instance;\n   tree orig_fns;\n-  tree orig_args;\n+  VEC(tree,gc) *orig_args = NULL;\n   void *p;\n \n   gcc_assert (instance != NULL_TREE);\n@@ -5815,8 +5981,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n     *fn_p = NULL_TREE;\n \n   if (error_operand_p (instance)\n-      || error_operand_p (fns)\n-      || args == error_mark_node)\n+      || error_operand_p (fns))\n     return error_mark_node;\n \n   if (!BASELINK_P (fns))\n@@ -5828,7 +5993,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   orig_instance = instance;\n   orig_fns = fns;\n-  orig_args = args;\n \n   /* Dismantle the baselink to collect all the information we need.  */\n   if (!conversion_path)\n@@ -5853,16 +6017,20 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   if (processing_template_decl)\n     {\n+      orig_args = args == NULL ? NULL : make_tree_vector_copy (*args);\n       instance = build_non_dependent_expr (instance);\n-      args = build_non_dependent_args (orig_args);\n-    }\n-\n-  /* The USER_ARGS are the arguments we will display to users if an\n-     error occurs.  The USER_ARGS should not include any\n-     compiler-generated arguments.  The \"this\" pointer hasn't been\n-     added yet.  However, we must remove the VTT pointer if this is a\n-     call to a base-class constructor or destructor.  */\n-  user_args = args;\n+      if (args != NULL)\n+\tmake_args_non_dependent (*args);\n+    }\n+\n+  /* Figure out whether to skip the first argument for the error\n+     message we will display to users if an error occurs.  We don't\n+     want to display any compiler-generated arguments.  The \"this\"\n+     pointer hasn't been added yet.  However, we must remove the VTT\n+     pointer if this is a call to a base-class constructor or\n+     destructor.  */\n+  skip_first_for_error = false;\n+  user_args = args == NULL ? NULL : *args;\n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n       /* Callers should explicitly indicate whether they want to construct\n@@ -5873,13 +6041,16 @@ build_new_method_call (tree instance, tree fns, tree args,\n       /* Remove the VTT pointer, if present.  */\n       if ((name == base_ctor_identifier || name == base_dtor_identifier)\n \t  && CLASSTYPE_VBASECLASSES (basetype))\n-\tuser_args = TREE_CHAIN (user_args);\n+\tskip_first_for_error = true;\n     }\n \n   /* Process the argument list.  */\n-  args = resolve_args (args);\n-  if (args == error_mark_node)\n-    return error_mark_node;\n+  if (args != NULL && *args != NULL)\n+    {\n+      *args = resolve_args (*args);\n+      if (*args == NULL)\n+\treturn error_mark_node;\n+    }\n \n   instance_ptr = build_this (instance);\n \n@@ -5899,50 +6070,53 @@ build_new_method_call (tree instance, tree fns, tree args,\n   /* If CONSTRUCTOR_IS_DIRECT_INIT is set, this was a T{ } form\n      initializer, not T({ }).  If the type doesn't have a list ctor,\n      break apart the list into separate ctor args.  */\n-  if (DECL_CONSTRUCTOR_P (fn) && args\n-      && BRACE_ENCLOSED_INITIALIZER_P (TREE_VALUE (args))\n-      && CONSTRUCTOR_IS_DIRECT_INIT (TREE_VALUE (args))\n+  if (DECL_CONSTRUCTOR_P (fn) && args != NULL && !VEC_empty (tree, *args)\n+      && BRACE_ENCLOSED_INITIALIZER_P (VEC_index (tree, *args, 0))\n+      && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *args, 0))\n       && !TYPE_HAS_LIST_CTOR (basetype))\n     {\n-      gcc_assert (TREE_CHAIN (args) == NULL_TREE);\n-      args = ctor_to_list (TREE_VALUE (args));\n+      gcc_assert (VEC_length (tree, *args) == 1);\n+      *args = ctor_to_vec (VEC_index (tree, *args, 0));\n     }\n \n   class_type = (conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE);\n-  mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n+  first_mem_arg = instance_ptr;\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n   for (fn = fns; fn; fn = OVL_NEXT (fn))\n     {\n       tree t = OVL_CURRENT (fn);\n-      tree this_arglist;\n+      tree this_first_arg;\n \n       /* We can end up here for copy-init of same or base class.  */\n       if ((flags & LOOKUP_ONLYCONVERTING)\n \t  && DECL_NONCONVERTING_P (t))\n \tcontinue;\n \n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n-\tthis_arglist = mem_args;\n+\tthis_first_arg = first_mem_arg;\n       else\n-\tthis_arglist = args;\n+\tthis_first_arg = NULL_TREE;\n \n       if (TREE_CODE (t) == TEMPLATE_DECL)\n \t/* A member template.  */\n \tadd_template_candidate (&candidates, t,\n \t\t\t\tclass_type,\n \t\t\t\texplicit_targs,\n-\t\t\t\tthis_arglist, optype,\n+\t\t\t\tthis_first_arg,\n+\t\t\t\targs == NULL ? NULL : *args,\n+\t\t\t\toptype,\n \t\t\t\taccess_binfo,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n \t\t\t\tDEDUCE_CALL);\n       else if (! template_only)\n \tadd_function_candidate (&candidates, t,\n \t\t\t\tclass_type,\n-\t\t\t\tthis_arglist,\n+\t\t\t\tthis_first_arg,\n+\t\t\t\targs == NULL ? NULL : *args,\n \t\t\t\taccess_binfo,\n \t\t\t\tconversion_path,\n \t\t\t\tflags);\n@@ -5959,10 +6133,14 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t    {\n \t      char *pretty_name;\n \t      bool free_p;\n+\t      tree arglist;\n \n \t      pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t      arglist = build_tree_list_vec (user_args);\n+\t      if (skip_first_for_error)\n+\t\targlist = TREE_CHAIN (arglist);\n \t      error (\"no matching function for call to %<%T::%s(%A)%#V%>\",\n-\t\t     basetype, pretty_name, user_args,\n+\t\t     basetype, pretty_name, arglist,\n \t\t     TREE_TYPE (TREE_TYPE (instance_ptr)));\n \t      if (free_p)\n \t\tfree (pretty_name);\n@@ -5978,12 +6156,16 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t{\n \t  char *pretty_name;\n \t  bool free_p;\n+\t  tree arglist;\n \n \t  if (complain & tf_error)\n \t    {\n \t      pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t      arglist = build_tree_list_vec (user_args);\n+\t      if (skip_first_for_error)\n+\t\targlist = TREE_CHAIN (arglist);\n \t      error (\"call of overloaded %<%s(%A)%> is ambiguous\", pretty_name,\n-\t\t     user_args);\n+\t\t     arglist);\n \t      print_z_candidates (candidates);\n \t      if (free_p)\n \t\tfree (pretty_name);\n@@ -6064,7 +6246,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t}\n       if (TREE_CODE (call) == INDIRECT_REF)\n \tcall = TREE_OPERAND (call, 0);\n-      call = (build_min_non_dep_call_list\n+      call = (build_min_non_dep_call_vec\n \t      (call,\n \t       build_min (COMPONENT_REF, TREE_TYPE (CALL_EXPR_FN (call)),\n \t\t\t  orig_instance, orig_fns, NULL_TREE),\n@@ -6077,6 +6259,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n  /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n \n+  if (orig_args != NULL)\n+    release_tree_vector (orig_args);\n+\n   return call;\n }\n \n@@ -7132,9 +7317,10 @@ perform_direct_initialization_if_possible (tree type,\n      ill-formed.  */\n   if (CLASS_TYPE_P (type))\n     {\n+      VEC(tree,gc) *args = make_tree_vector_single (expr);\n       expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n-\t\t\t\t\ttype, LOOKUP_NORMAL, complain);\n+\t\t\t\t\t&args, type, LOOKUP_NORMAL, complain);\n+      release_tree_vector (args);\n       return build_cplus_new (type, expr);\n     }\n "}, {"sha": "049e980c7b70620ae03be38b40a834cd67f91624", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -6072,6 +6072,9 @@ resolve_address_of_overloaded_function (tree target_type,\n       tree target_arg_types;\n       tree target_ret_type;\n       tree fns;\n+      tree *args;\n+      unsigned int nargs, ia;\n+      tree arg;\n \n       if (is_ptrmem)\n \ttarget_fn_type\n@@ -6085,6 +6088,14 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (TREE_CODE (target_fn_type) == METHOD_TYPE)\n \ttarget_arg_types = TREE_CHAIN (target_arg_types);\n \n+      nargs = list_length (target_arg_types);\n+      args = XALLOCAVEC (tree, nargs);\n+      for (arg = target_arg_types, ia = 0;\n+\t   arg != NULL_TREE && arg != void_list_node;\n+\t   arg = TREE_CHAIN (arg), ++ia)\n+\targs[ia] = TREE_VALUE (arg);\n+      nargs = ia;\n+\n       for (fns = overload; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n@@ -6104,9 +6115,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \n \t  /* Try to do argument deduction.  */\n \t  targs = make_tree_vec (DECL_NTPARMS (fn));\n-\t  if (fn_type_unification (fn, explicit_targs, targs,\n-\t\t\t\t   target_arg_types, target_ret_type,\n-\t\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL))\n+\t  if (fn_type_unification (fn, explicit_targs, targs, args, nargs,\n+\t\t\t\t   target_ret_type, DEDUCE_EXACT,\n+\t\t\t\t   LOOKUP_NORMAL))\n \t    /* Argument deduction failed.  */\n \t    continue;\n "}, {"sha": "5a32a90b312167ddb88bae7319fd391adbfa55c1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -4176,17 +4176,20 @@ extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int);\n-extern tree build_new_function_call\t\t(tree, tree, bool, \n+extern tree build_new_function_call\t\t(tree, VEC(tree,gc) **, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *,\n-\t\t\t\t\t\t tree *);\n-extern tree build_new_method_call\t\t(tree, tree, tree, tree, int,\n-\t\t\t\t\t\t tree *, tsubst_flags_t);\n-extern tree build_special_member_call\t\t(tree, tree, tree, tree, int,\n-                                                 tsubst_flags_t);\n+extern tree build_operator_new_call\t\t(tree, VEC(tree,gc) **, tree *,\n+\t\t\t\t\t\t tree *, tree *);\n+extern tree build_new_method_call\t\t(tree, tree, VEC(tree,gc) **,\n+\t\t\t\t\t\t tree, int, tree *,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_special_member_call\t\t(tree, tree, VEC(tree,gc) **,\n+\t\t\t\t\t\t tree, int, tsubst_flags_t);\n extern tree build_new_op\t\t\t(enum tree_code, int, tree, \n \t\t\t\t\t\t tree, tree, bool *,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_op_call\t\t\t(tree, VEC(tree,gc) **,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree, tree);\n extern bool can_convert\t\t\t\t(tree, tree);\n extern bool can_convert_arg\t\t\t(tree, tree, tree, int);\n@@ -4408,7 +4411,7 @@ extern void determine_visibility\t\t(tree);\n extern void constrain_class_visibility\t\t(tree);\n extern void import_export_decl\t\t\t(tree);\n extern tree build_cleanup\t\t\t(tree);\n-extern tree build_offset_ref_call_from_tree\t(tree, tree);\n+extern tree build_offset_ref_call_from_tree\t(tree, VEC(tree,gc) **);\n extern void check_default_args\t\t\t(tree);\n extern void mark_used\t\t\t\t(tree);\n extern void finish_static_data_member_decl\t(tree, tree, bool, tree, int);\n@@ -4472,7 +4475,8 @@ extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree);\n extern tree build_value_init_noctor\t\t(tree);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n-extern tree build_new\t\t\t\t(tree, tree, tree, tree, int,\n+extern tree build_new\t\t\t\t(VEC(tree,gc) **, tree, tree,\n+\t\t\t\t\t\t VEC(tree,gc) **, int,\n                                                  tsubst_flags_t);\n extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n                                                  tsubst_flags_t);\n@@ -4554,7 +4558,8 @@ extern int uses_template_parms\t\t\t(tree);\n extern int uses_template_parms_level\t\t(tree, int);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n-extern int fn_type_unification\t\t\t(tree, tree, tree, tree,\n+extern int fn_type_unification\t\t\t(tree, tree, tree,\n+\t\t\t\t\t\t const tree *, unsigned int,\n \t\t\t\t\t\t tree, unification_kind_t, int);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);\n@@ -4592,15 +4597,15 @@ extern bool any_dependent_template_arguments_p  (const_tree);\n extern bool dependent_template_p\t\t(tree);\n extern bool dependent_template_id_p\t\t(tree, tree);\n extern bool type_dependent_expression_p\t\t(tree);\n-extern bool any_type_dependent_arguments_p      (const_tree);\n+extern bool any_type_dependent_arguments_p      (const VEC(tree,gc) *);\n extern bool type_dependent_expression_p_push\t(tree);\n extern bool value_dependent_expression_p\t(tree);\n extern bool any_value_dependent_elements_p      (const_tree);\n extern bool dependent_omp_for_p\t\t\t(tree, tree, tree, tree);\n extern tree resolve_typename_type\t\t(tree, bool);\n extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);\n-extern tree build_non_dependent_args\t\t(tree);\n+extern void make_args_non_dependent\t\t(VEC(tree,gc) *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n extern tree fold_non_dependent_expr\t\t(tree);\n extern bool explicit_class_specialization_p     (tree);\n@@ -4748,9 +4753,9 @@ extern tree begin_stmt_expr\t\t\t(void);\n extern tree finish_stmt_expr_expr\t\t(tree, tree);\n extern tree finish_stmt_expr\t\t\t(tree, bool);\n extern tree stmt_expr_value_expr\t\t(tree);\n-extern tree perform_koenig_lookup\t\t(tree, tree);\n-extern tree finish_call_expr\t\t\t(tree, tree, bool, bool, \n-\t\t\t\t\t\t tsubst_flags_t);\n+extern tree perform_koenig_lookup\t\t(tree, VEC(tree,gc) *);\n+extern tree finish_call_expr\t\t\t(tree, VEC(tree,gc) **, bool,\n+\t\t\t\t\t\t bool, tsubst_flags_t);\n extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n@@ -4832,7 +4837,7 @@ extern bool builtin_valid_in_constant_expr_p    (const_tree);\n extern tree build_min\t\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_nt\t\t\t(enum tree_code, ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n-extern tree build_min_non_dep_call_list\t\t(tree, tree, tree);\n+extern tree build_min_non_dep_call_vec\t\t(tree, tree, VEC(tree,gc) *);\n extern tree build_cplus_new\t\t\t(tree, tree);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);\n@@ -4932,6 +4937,8 @@ extern tree cp_build_indirect_ref\t\t(tree, const char *,\n extern tree build_array_ref\t\t\t(tree, tree, location_t);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n extern tree cp_build_function_call              (tree, tree, tsubst_flags_t);\n+extern tree cp_build_function_call_vec\t\t(tree, VEC(tree,gc) **,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_binary_op\t\t\t(enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, bool *,\n@@ -4945,6 +4952,7 @@ extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree, \n                                                  tsubst_flags_t);\n extern tree build_x_compound_expr_from_list\t(tree, const char *);\n+extern tree build_x_compound_expr_from_vec\t(VEC(tree,gc) *, const char *);\n extern tree build_x_compound_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree build_compound_expr                 (tree, tree);\n extern tree cp_build_compound_expr\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "3220fe676bcf35ff502b92d5c90074f608a75268", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,6 +1,6 @@\n /* Language-level data type conversion for GNU C++.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -755,11 +755,15 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t   the target with the temp (see [dcl.init]).  */\n \tctor = build_user_type_conversion (type, ctor, flags);\n       else\n-\tctor = build_special_member_call (NULL_TREE,\n-\t\t\t\t\t  complete_ctor_identifier,\n-\t\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n-\t\t\t\t\t  type, flags,\n-                                          tf_warning_or_error);\n+\t{\n+\t  VEC(tree,gc) *ctor_vec = make_tree_vector_single (ctor);\n+\t  ctor = build_special_member_call (NULL_TREE,\n+\t\t\t\t\t    complete_ctor_identifier,\n+\t\t\t\t\t    &ctor_vec,\n+\t\t\t\t\t    type, flags,\n+\t\t\t\t\t    tf_warning_or_error);\n+\t  release_tree_vector (ctor_vec);\n+\t}\n       if (ctor)\n \treturn build_cplus_new (type, ctor);\n     }"}, {"sha": "3f753d18bd43ec46f259481833d383821fc324fe", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -3680,36 +3680,38 @@ cp_write_global_declarations (void)\n /* FN is an OFFSET_REF, DOTSTAR_EXPR or MEMBER_REF indicating the\n    function to call in parse-tree form; it has not yet been\n    semantically analyzed.  ARGS are the arguments to the function.\n-   They have already been semantically analyzed.  */\n+   They have already been semantically analyzed.  This may change\n+   ARGS.  */\n \n tree\n-build_offset_ref_call_from_tree (tree fn, tree args)\n+build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args)\n {\n   tree orig_fn;\n-  tree orig_args;\n+  VEC(tree,gc) *orig_args = NULL;\n   tree expr;\n   tree object;\n \n   orig_fn = fn;\n-  orig_args = args;\n   object = TREE_OPERAND (fn, 0);\n \n   if (processing_template_decl)\n     {\n       gcc_assert (TREE_CODE (fn) == DOTSTAR_EXPR\n \t\t  || TREE_CODE (fn) == MEMBER_REF);\n       if (type_dependent_expression_p (fn)\n-\t  || any_type_dependent_arguments_p (args))\n-\treturn build_nt_call_list (fn, args);\n+\t  || any_type_dependent_arguments_p (*args))\n+\treturn build_nt_call_vec (fn, *args);\n+\n+      orig_args = make_tree_vector_copy (*args);\n \n       /* Transform the arguments and add the implicit \"this\"\n \t parameter.  That must be done before the FN is transformed\n \t because we depend on the form of FN.  */\n-      args = build_non_dependent_args (args);\n+      make_args_non_dependent (*args);\n       object = build_non_dependent_expr (object);\n       if (TREE_CODE (fn) == DOTSTAR_EXPR)\n \tobject = cp_build_unary_op (ADDR_EXPR, object, 0, tf_warning_or_error);\n-      args = tree_cons (NULL_TREE, object, args);\n+      VEC_safe_insert (tree, gc, *args, 0, object);\n       /* Now that the arguments are done, transform FN.  */\n       fn = build_non_dependent_expr (fn);\n     }\n@@ -3726,12 +3728,16 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n                                          tf_warning_or_error);\n       fn = TREE_OPERAND (fn, 1);\n       fn = get_member_function_from_ptrfunc (&object_addr, fn);\n-      args = tree_cons (NULL_TREE, object_addr, args);\n+      VEC_safe_insert (tree, gc, *args, 0, object_addr);\n     }\n \n-  expr = cp_build_function_call (fn, args, tf_warning_or_error);\n+  expr = cp_build_function_call_vec (fn, args, tf_warning_or_error);\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep_call_list (expr, orig_fn, orig_args);\n+    expr = build_min_non_dep_call_vec (expr, orig_fn, orig_args);\n+\n+  if (orig_args != NULL)\n+    release_tree_vector (orig_args);\n+\n   return expr;\n }\n "}, {"sha": "99c703610459fdffd857dde30179eccb334fcb14", "filename": "gcc/cp/except.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,6 +1,6 @@\n /* Handle exceptional things in C++.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann <tiemann@cygnus.com>\n    Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n@@ -736,6 +736,7 @@ build_throw (tree exp)\n       if (CLASS_TYPE_P (temp_type))\n \t{\n \t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n+\t  VEC(tree,gc) *exp_vec;\n \n \t  /* Under C++0x [12.8/16 class.copy], a thrown lvalue is sometimes\n \t     treated as an rvalue for the purposes of overload resolution\n@@ -749,11 +750,11 @@ build_throw (tree exp)\n \t    flags = flags | LOOKUP_PREFER_RVALUE;\n \n \t  /* Call the copy constructor.  */\n+\t  exp_vec = make_tree_vector_single (exp);\n \t  exp = (build_special_member_call\n-\t\t (object, complete_ctor_identifier,\n-\t\t  build_tree_list (NULL_TREE, exp),\n-\t\t  TREE_TYPE (object),\n-\t\t  flags, tf_warning_or_error));\n+\t\t (object, complete_ctor_identifier, &exp_vec,\n+\t\t  TREE_TYPE (object), flags, tf_warning_or_error));\n+\t  release_tree_vector (exp_vec);\n \t  if (exp == error_mark_node)\n \t    {\n \t      error (\"  in thrown expression\");"}, {"sha": "fd0d587b81f5e2b5f0da8fd80f09cd20c51d94a9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 109, "deletions": 82, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -302,7 +302,7 @@ build_value_init (tree type)\n \treturn build_aggr_init_expr\n \t  (type,\n \t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t      NULL_TREE, type, LOOKUP_NORMAL,\n+\t\t\t\t      NULL, type, LOOKUP_NORMAL,\n \t\t\t\t      tf_warning_or_error));\n       else if (TREE_CODE (type) != UNION_TYPE && TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n@@ -312,7 +312,7 @@ build_value_init (tree type)\n \t     This will be handled in simplify_aggr_init_expr.  */\n \t  tree ctor = build_special_member_call\n \t    (NULL_TREE, complete_ctor_identifier,\n-\t     NULL_TREE, type, LOOKUP_NORMAL, tf_warning_or_error);\n+\t     NULL, type, LOOKUP_NORMAL, tf_warning_or_error);\n \n \t  ctor = build_aggr_init_expr (type, ctor);\n \t  AGGR_INIT_ZERO_FIRST (ctor) = 1;\n@@ -951,7 +951,7 @@ expand_cleanup_for_base (tree binfo, tree flag)\n   /* Call the destructor.  */\n   expr = build_special_member_call (current_class_ref,\n \t\t\t\t    base_dtor_identifier,\n-\t\t\t\t    NULL_TREE,\n+\t\t\t\t    NULL,\n \t\t\t\t    binfo,\n \t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n                                     tf_warning_or_error);\n@@ -1285,7 +1285,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n      followed by initialization by X.  If neither of these work\n      out, then look hard.  */\n   tree rval;\n-  tree parms;\n+  VEC(tree,gc) *parms;\n \n   if (init && TREE_CODE (init) != TREE_LIST\n       && (flags & LOOKUP_ONLYCONVERTING))\n@@ -1325,23 +1325,28 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n       return;\n     }\n \n-  if (init == NULL_TREE\n-      || (TREE_CODE (init) == TREE_LIST && ! TREE_TYPE (init)))\n+  if (init == NULL_TREE)\n+    parms = NULL;\n+  else if (TREE_CODE (init) == TREE_LIST && !TREE_TYPE (init))\n     {\n-      parms = init;\n-      if (parms)\n-\tinit = TREE_VALUE (parms);\n+      parms = make_tree_vector ();\n+      for (; init != NULL_TREE; init = TREE_CHAIN (init))\n+\tVEC_safe_push (tree, gc, parms, TREE_VALUE (init));\n     }\n   else\n-    parms = build_tree_list (NULL_TREE, init);\n+    parms = make_tree_vector_single (init);\n \n   if (true_exp == exp)\n     ctor_name = complete_ctor_identifier;\n   else\n     ctor_name = base_ctor_identifier;\n \n-  rval = build_special_member_call (exp, ctor_name, parms, binfo, flags,\n+  rval = build_special_member_call (exp, ctor_name, &parms, binfo, flags,\n                                     complain);\n+\n+  if (parms != NULL)\n+    release_tree_vector (parms);\n+\n   if (TREE_SIDE_EFFECTS (rval))\n     finish_expr_stmt (convert_to_void (rval, NULL, complain));\n }\n@@ -1706,18 +1711,31 @@ build_builtin_delete_call (tree addr)\n    the type of the object being allocated; otherwise, it's just TYPE.\n    INIT is the initializer, if any.  USE_GLOBAL_NEW is true if the\n    user explicitly wrote \"::operator new\".  PLACEMENT, if non-NULL, is\n-   the TREE_LIST of arguments to be provided as arguments to a\n-   placement new operator.  This routine performs no semantic checks;\n-   it just creates and returns a NEW_EXPR.  */\n+   a vector of arguments to be provided as arguments to a placement\n+   new operator.  This routine performs no semantic checks; it just\n+   creates and returns a NEW_EXPR.  */\n \n static tree\n-build_raw_new_expr (tree placement, tree type, tree nelts, tree init,\n-\t\t    int use_global_new)\n+build_raw_new_expr (VEC(tree,gc) *placement, tree type, tree nelts,\n+\t\t    VEC(tree,gc) *init, int use_global_new)\n {\n+  tree init_list;\n   tree new_expr;\n \n-  new_expr = build4 (NEW_EXPR, build_pointer_type (type), placement, type,\n-\t\t     nelts, init);\n+  /* If INIT is NULL, the we want to store NULL_TREE in the NEW_EXPR.\n+     If INIT is not NULL, then we want to store VOID_ZERO_NODE.  This\n+     permits us to distinguish the case of a missing initializer \"new\n+     int\" from an empty initializer \"new int()\".  */\n+  if (init == NULL)\n+    init_list = NULL_TREE;\n+  else if (VEC_empty (tree, init))\n+    init_list = void_zero_node;\n+  else\n+    init_list = build_tree_list_vec (init);\n+\n+  new_expr = build4 (NEW_EXPR, build_pointer_type (type),\n+\t\t     build_tree_list_vec (placement), type, nelts,\n+\t\t     init_list);\n   NEW_EXPR_USE_GLOBAL (new_expr) = use_global_new;\n   TREE_SIDE_EFFECTS (new_expr) = 1;\n \n@@ -1776,11 +1794,12 @@ avoid_placement_new_aliasing (tree t, tree placement)\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n-   build_raw_new_expr.  */\n+   build_raw_new_expr.  This may change PLACEMENT and INIT.  */\n \n static tree\n-build_new_1 (tree placement, tree type, tree nelts, tree init,\n-\t     bool globally_qualified_p, tsubst_flags_t complain)\n+build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n+\t     VEC(tree,gc) **init, bool globally_qualified_p,\n+\t     tsubst_flags_t complain)\n {\n   tree size, rval;\n   /* True iff this is a call to \"operator new[]\" instead of just\n@@ -1807,11 +1826,12 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n+  bool have_placement;\n+  tree placement_first;\n   tree placement_expr = NULL_TREE;\n   /* True if the function we are calling is a placement allocation\n      function.  */\n   bool placement_allocation_fn_p;\n-  tree args = NULL_TREE;\n   /* True if the storage must be initialized, either by a constructor\n      or due to an explicit new-initializer.  */\n   bool is_initialized;\n@@ -1855,9 +1875,9 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   if (abstract_virtuals_error (NULL_TREE, elt_type))\n     return error_mark_node;\n \n-  is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || init);\n+  is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || *init != NULL);\n \n-  if (CP_TYPE_CONST_P (elt_type) && !init\n+  if (CP_TYPE_CONST_P (elt_type) && *init == NULL\n       && !type_has_user_provided_default_constructor (elt_type))\n     {\n       if (complain & tf_error)\n@@ -1871,8 +1891,18 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   alloc_fn = NULL_TREE;\n \n+  /* If PLACEMENT is a single simple pointer type not passed by\n+     reference, prepare to capture it in a temporary variable.  Do\n+     this now, since PLACEMENT will change in the calls below.  */\n+  have_placement = !VEC_empty (tree, *placement);\n+  placement_first = NULL_TREE;\n+  if (VEC_length (tree, *placement) == 1\n+      && (TREE_CODE (TREE_TYPE (VEC_index (tree, *placement, 0)))\n+\t  == POINTER_TYPE))\n+    placement_first = VEC_index (tree, *placement, 0);\n+\n   /* Allocate the object.  */\n-  if (! placement && TYPE_FOR_JAVA (elt_type))\n+  if (VEC_empty (tree, *placement) && TYPE_FOR_JAVA (elt_type))\n     {\n       tree class_addr;\n       tree class_decl = build_java_class_ref (elt_type);\n@@ -1928,7 +1958,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t      size = size_binop (PLUS_EXPR, size, cookie_size);\n \t    }\n \t  /* Create the argument list.  */\n-\t  args = tree_cons (NULL_TREE, size, placement);\n+\t  VEC_safe_insert (tree, gc, *placement, 0, size);\n \t  /* Do name-lookup to find the appropriate operator.  */\n \t  fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n \t  if (fns == NULL_TREE)\n@@ -1947,7 +1977,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t      return error_mark_node;\n \t    }\n \t  alloc_call = build_new_method_call (build_dummy_object (elt_type),\n-\t\t\t\t\t      fns, args,\n+\t\t\t\t\t      fns, placement,\n \t\t\t\t\t      /*conversion_path=*/NULL_TREE,\n \t\t\t\t\t      LOOKUP_NORMAL,\n \t\t\t\t\t      &alloc_fn,\n@@ -1973,12 +2003,10 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n   gcc_assert (alloc_fn != NULL_TREE);\n \n-  /* If PLACEMENT is a simple pointer type and is not passed by reference,\n-     then copy it into PLACEMENT_EXPR.  */\n+  /* If we found a simple case of PLACEMENT_EXPR above, then copy it\n+     into a temporary variable.  */\n   if (!processing_template_decl\n-      && placement != NULL_TREE\n-      && TREE_CHAIN (placement) == NULL_TREE\n-      && TREE_CODE (TREE_TYPE (TREE_VALUE (placement))) == POINTER_TYPE\n+      && placement_first != NULL_TREE\n       && TREE_CODE (alloc_call) == CALL_EXPR\n       && call_expr_nargs (alloc_call) == 2\n       && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 0))) == INTEGER_TYPE\n@@ -1989,7 +2017,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg)))\n \t  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg))))\n \t{\n-\t  placement_expr = get_target_expr (TREE_VALUE (placement));\n+\t  placement_expr = get_target_expr (placement_first);\n \t  CALL_EXPR_ARG (alloc_call, 1)\n \t    = convert (TREE_TYPE (placement_arg), placement_expr);\n \t}\n@@ -2000,7 +2028,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   if (!cookie_size && !is_initialized)\n     {\n       rval = build_nop (pointer_type, alloc_call);\n-      if (placement != NULL)\n+      if (have_placement)\n \trval = avoid_placement_new_aliasing (rval, placement_expr);\n       return rval;\n     }\n@@ -2109,15 +2137,15 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       bool stable;\n       bool explicit_value_init_p = false;\n \n-      if (init == void_zero_node)\n+      if (*init != NULL && VEC_empty (tree, *init))\n \t{\n-\t  init = NULL_TREE;\n+\t  *init = NULL;\n \t  explicit_value_init_p = true;\n \t}\n \n       if (array_p)\n \t{\n-\t  if (init)\n+\t  if (*init)\n             {\n               if (complain & tf_error)\n                 permerror (input_location, \"ISO C++ forbids initialization in array new\");\n@@ -2130,7 +2158,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\t\t\t\t\t  MINUS_EXPR, outer_nelts,\n \t\t\t\t\t\t  integer_one_node,\n \t\t\t\t\t\t  complain),\n-\t\t\t      init,\n+\t\t\t      build_tree_list_vec (*init),\n \t\t\t      explicit_value_init_p,\n \t\t\t      /*from_array=*/0,\n                               complain);\n@@ -2160,17 +2188,13 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t    }\n \t  else\n \t    {\n+\t      tree ie;\n+\n \t      /* We are processing something like `new int (10)', which\n \t\t means allocate an int, and initialize it with 10.  */\n \n-\t      if (TREE_CODE (init) == TREE_LIST)\n-\t\tinit = build_x_compound_expr_from_list (init,\n-\t\t\t\t\t\t\t\"new initializer\");\n-\t      else\n-\t\tgcc_assert (TREE_CODE (init) != CONSTRUCTOR\n-\t\t\t    || TREE_TYPE (init) != NULL_TREE);\n-\n-\t      init_expr = cp_build_modify_expr (init_expr, INIT_EXPR, init,\n+\t      ie = build_x_compound_expr_from_vec (*init, \"new initializer\");\n+\t      init_expr = cp_build_modify_expr (init_expr, INIT_EXPR, ie,\n \t\t\t\t\t\tcomplain);\n \t    }\n \t  stable = stabilize_init (init_expr, &init_preeval_expr);\n@@ -2283,60 +2307,58 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   /* A new-expression is never an lvalue.  */\n   gcc_assert (!lvalue_p (rval));\n \n-  if (placement != NULL)\n+  if (have_placement)\n     rval = avoid_placement_new_aliasing (rval, placement_expr);\n \n   return rval;\n }\n \n-/* Generate a representation for a C++ \"new\" expression.  PLACEMENT is\n-   a TREE_LIST of placement-new arguments (or NULL_TREE if none).  If\n-   NELTS is NULL, TYPE is the type of the storage to be allocated.  If\n-   NELTS is not NULL, then this is an array-new allocation; TYPE is\n-   the type of the elements in the array and NELTS is the number of\n-   elements in the array.  INIT, if non-NULL, is the initializer for\n-   the new object, or void_zero_node to indicate an initializer of\n-   \"()\".  If USE_GLOBAL_NEW is true, then the user explicitly wrote\n-   \"::new\" rather than just \"new\".  */\n+/* Generate a representation for a C++ \"new\" expression.  *PLACEMENT\n+   is a vector of placement-new arguments (or NULL if none).  If NELTS\n+   is NULL, TYPE is the type of the storage to be allocated.  If NELTS\n+   is not NULL, then this is an array-new allocation; TYPE is the type\n+   of the elements in the array and NELTS is the number of elements in\n+   the array.  *INIT, if non-NULL, is the initializer for the new\n+   object, or an empty vector to indicate an initializer of \"()\".  If\n+   USE_GLOBAL_NEW is true, then the user explicitly wrote \"::new\"\n+   rather than just \"new\".  This may change PLACEMENT and INIT.  */\n \n tree\n-build_new (tree placement, tree type, tree nelts, tree init,\n-\t   int use_global_new, tsubst_flags_t complain)\n+build_new (VEC(tree,gc) **placement, tree type, tree nelts,\n+\t   VEC(tree,gc) **init, int use_global_new, tsubst_flags_t complain)\n {\n   tree rval;\n-  tree orig_placement;\n-  tree orig_nelts;\n-  tree orig_init;\n+  VEC(tree,gc) *orig_placement = NULL;\n+  tree orig_nelts = NULL_TREE;\n+  VEC(tree,gc) *orig_init = NULL;\n \n-  if (placement == error_mark_node || type == error_mark_node\n-      || init == error_mark_node)\n+  if (type == error_mark_node)\n     return error_mark_node;\n \n-  orig_placement = placement;\n-  orig_nelts = nelts;\n-  orig_init = init;\n-\n-  if (nelts == NULL_TREE && init != void_zero_node && list_length (init) == 1)\n+  if (nelts == NULL_TREE && VEC_length (tree, *init) == 1)\n     {\n       tree auto_node = type_uses_auto (type);\n-      if (auto_node && describable_type (TREE_VALUE (init)))\n-\ttype = do_auto_deduction (type, TREE_VALUE (init), auto_node);\n+      if (auto_node && describable_type (VEC_index (tree, *init, 0)))\n+\ttype = do_auto_deduction (type, VEC_index (tree, *init, 0), auto_node);\n     }\n \n   if (processing_template_decl)\n     {\n       if (dependent_type_p (type)\n-\t  || any_type_dependent_arguments_p (placement)\n+\t  || any_type_dependent_arguments_p (*placement)\n \t  || (nelts && type_dependent_expression_p (nelts))\n-\t  || (init != void_zero_node\n-\t      && any_type_dependent_arguments_p (init)))\n-\treturn build_raw_new_expr (placement, type, nelts, init,\n+\t  || any_type_dependent_arguments_p (*init))\n+\treturn build_raw_new_expr (*placement, type, nelts, *init,\n \t\t\t\t   use_global_new);\n-      placement = build_non_dependent_args (placement);\n+\n+      orig_placement = make_tree_vector_copy (*placement);\n+      orig_nelts = nelts;\n+      orig_init = make_tree_vector_copy (*init);\n+\n+      make_args_non_dependent (*placement);\n       if (nelts)\n \tnelts = build_non_dependent_expr (nelts);\n-      if (init != void_zero_node)\n-\tinit = build_non_dependent_args (init);\n+      make_args_non_dependent (*init);\n     }\n \n   if (nelts)\n@@ -2381,8 +2403,13 @@ build_new (tree placement, tree type, tree nelts, tree init,\n     return error_mark_node;\n \n   if (processing_template_decl)\n-    return build_raw_new_expr (orig_placement, type, orig_nelts, orig_init,\n-\t\t\t       use_global_new);\n+    {\n+      tree ret = build_raw_new_expr (orig_placement, type, orig_nelts,\n+\t\t\t\t     orig_init, use_global_new);\n+      release_tree_vector (orig_placement);\n+      release_tree_vector (orig_init);\n+      return ret;\n+    }\n \n   /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n   rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n@@ -2954,7 +2981,7 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n     }\n   fn = lookup_fnfields (TREE_TYPE (exp), name, /*protect=*/2);\n   return build_new_method_call (exp, fn,\n-\t\t\t\t/*args=*/NULL_TREE,\n+\t\t\t\t/*args=*/NULL,\n \t\t\t\t/*conversion_path=*/NULL_TREE,\n \t\t\t\tflags,\n \t\t\t\t/*fn_p=*/NULL,\n@@ -3172,7 +3199,7 @@ push_base_cleanups (void)\n \t    {\n \t      expr = build_special_member_call (current_class_ref,\n \t\t\t\t\t\tbase_dtor_identifier,\n-\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\tNULL,\n \t\t\t\t\t\tbase_binfo,\n \t\t\t\t\t\t(LOOKUP_NORMAL\n \t\t\t\t\t\t | LOOKUP_NONVIRTUAL),\n@@ -3194,7 +3221,7 @@ push_base_cleanups (void)\n \n       expr = build_special_member_call (current_class_ref,\n \t\t\t\t\tbase_dtor_identifier,\n-\t\t\t\t\tNULL_TREE, base_binfo,\n+\t\t\t\t\tNULL, base_binfo,\n \t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n                                         tf_warning_or_error);\n       finish_decl_cleanup (NULL_TREE, expr);"}, {"sha": "410503d05e163b9333d02f69bed1e0c646aca314", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,7 +1,7 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -661,19 +661,21 @@ do_build_assign_ref (tree fndecl)\n \t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t{\n \t  tree converted_parm;\n+\t  VEC(tree,gc) *parmvec;\n \n \t  /* We must convert PARM directly to the base class\n \t     explicitly since the base class may be ambiguous.  */\n \t  converted_parm = build_base_path (PLUS_EXPR, parm, base_binfo, 1);\n \t  /* Call the base class assignment operator.  */\n+\t  parmvec = make_tree_vector_single (converted_parm);\n \t  finish_expr_stmt\n \t    (build_special_member_call (current_class_ref,\n \t\t\t\t\tansi_assopname (NOP_EXPR),\n-\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t converted_parm),\n+\t\t\t\t\t&parmvec,\n \t\t\t\t\tbase_binfo,\n \t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n                                         tf_warning_or_error));\n+\t  release_tree_vector (parmvec);\n \t}\n \n       /* Assign to each of the non-static data members.  */"}, {"sha": "215750f5b402a9f4057a9d205ca90758414bca89", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -4235,7 +4235,7 @@ lookup_name_nonclass (tree name)\n }\n \n tree\n-lookup_function_nonclass (tree name, tree args, bool block_p)\n+lookup_function_nonclass (tree name, VEC(tree,gc) *args, bool block_p)\n {\n   return\n     lookup_arg_dependent (name,\n@@ -4427,14 +4427,15 @@ lookup_type_current_level (tree name)\n struct arg_lookup\n {\n   tree name;\n-  tree args;\n+  VEC(tree,gc) *args;\n   tree namespaces;\n   tree classes;\n   tree functions;\n };\n \n static bool arg_assoc (struct arg_lookup*, tree);\n static bool arg_assoc_args (struct arg_lookup*, tree);\n+static bool arg_assoc_args_vec (struct arg_lookup*, VEC(tree,gc) *);\n static bool arg_assoc_type (struct arg_lookup*, tree);\n static bool add_function (struct arg_lookup *, tree);\n static bool arg_assoc_namespace (struct arg_lookup *, tree);\n@@ -4589,13 +4590,13 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n \t classes.  */\n       if (hidden_name_p (OVL_CURRENT (value)))\n \t{\n-\t  tree args;\n+\t  unsigned int ix;\n+\t  tree arg;\n \n-\t  for (args = k->args; args; args = TREE_CHAIN (args))\n-\t    if (friend_of_associated_class_p (TREE_VALUE (args),\n-\t\t\t\t\t      OVL_CURRENT (value)))\n+\t  for (ix = 0; VEC_iterate (tree, k->args, ix, arg); ++ix)\n+\t    if (friend_of_associated_class_p (arg, OVL_CURRENT (value)))\n \t      break;\n-\t  if (!args)\n+\t  if (ix >= VEC_length (tree, k->args))\n \t    continue;\n \t}\n \n@@ -4805,6 +4806,21 @@ arg_assoc_args (struct arg_lookup *k, tree args)\n   return false;\n }\n \n+/* Adds everything associated with an argument vector.  Returns true\n+   on error.  */\n+\n+static bool\n+arg_assoc_args_vec (struct arg_lookup *k, VEC(tree,gc) *args)\n+{\n+  unsigned int ix;\n+  tree arg;\n+\n+  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+    if (arg_assoc (k, arg))\n+      return true;\n+  return false;\n+}\n+\n /* Adds everything associated with a given tree_node.  Returns 1 on error.  */\n \n static bool\n@@ -4884,7 +4900,7 @@ arg_assoc (struct arg_lookup *k, tree n)\n    are the functions found in normal lookup.  */\n \n tree\n-lookup_arg_dependent (tree name, tree fns, tree args)\n+lookup_arg_dependent (tree name, tree fns, VEC(tree,gc) *args)\n {\n   struct arg_lookup k;\n \n@@ -4907,7 +4923,7 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n      picking up later definitions) in the second stage. */\n   k.namespaces = NULL_TREE;\n \n-  arg_assoc_args (&k, args);\n+  arg_assoc_args_vec (&k, args);\n \n   fns = k.functions;\n   "}, {"sha": "2203a8400bfaef23a15ba93ea498f24e4cfd65bb", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,5 +1,6 @@\n /* Declarations for C++ name lookup routines.\n-   Copyright (C) 2003, 2004, 2005, 2007, 2008  Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -317,7 +318,7 @@ extern tree remove_hidden_names (tree);\n extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n extern tree lookup_name_innermost_nonclass_level (tree);\n-extern tree lookup_function_nonclass (tree, tree, bool);\n+extern tree lookup_function_nonclass (tree, VEC(tree,gc) *, bool);\n extern void push_local_binding (tree, tree, int);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree, bool);\n@@ -332,7 +333,7 @@ extern void do_toplevel_using_decl (tree, tree, tree);\n extern void do_local_using_decl (tree, tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n-extern tree lookup_arg_dependent (tree, tree, tree);\n+extern tree lookup_arg_dependent (tree, tree, VEC(tree,gc) *);\n extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n extern tree innermost_non_namespace_value (tree);"}, {"sha": "e7d2e7da1de84515ed68c5ae7cd526e057fec027", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 112, "deletions": 67, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1584,7 +1584,7 @@ static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n-static tree cp_parser_parenthesized_expression_list\n+static VEC(tree,gc) *cp_parser_parenthesized_expression_list\n   (cp_parser *, bool, bool, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n@@ -1594,15 +1594,15 @@ static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n static tree cp_parser_new_expression\n   (cp_parser *);\n-static tree cp_parser_new_placement\n+static VEC(tree,gc) *cp_parser_new_placement\n   (cp_parser *);\n static tree cp_parser_new_type_id\n   (cp_parser *, tree *);\n static cp_declarator *cp_parser_new_declarator_opt\n   (cp_parser *);\n static cp_declarator *cp_parser_direct_new_declarator\n   (cp_parser *);\n-static tree cp_parser_new_initializer\n+static VEC(tree,gc) *cp_parser_new_initializer\n   (cp_parser *);\n static tree cp_parser_delete_expression\n   (cp_parser *);\n@@ -4685,7 +4685,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    bool is_builtin_constant_p;\n \t    bool saved_integral_constant_expression_p = false;\n \t    bool saved_non_integral_constant_expression_p = false;\n-\t    tree args;\n+\t    VEC(tree,gc) *args;\n \n             is_member_access = false;\n \n@@ -4713,7 +4713,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t  = saved_non_integral_constant_expression_p;\n \t      }\n \n-\t    if (args == error_mark_node)\n+\t    if (args == NULL)\n \t      {\n \t\tpostfix_expression = error_mark_node;\n \t\tbreak;\n@@ -4726,6 +4726,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t\t\t\t\t       \"a function call\"))\n \t      {\n \t\tpostfix_expression = error_mark_node;\n+\t\trelease_tree_vector (args);\n \t\tbreak;\n \t      }\n \n@@ -4735,7 +4736,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      {\n \t\tif (TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n \t\t  {\n-\t\t    if (args)\n+\t\t    if (!VEC_empty (tree, args))\n \t\t      {\n \t\t\tkoenig_p = true;\n \t\t\tif (!any_type_dependent_arguments_p (args))\n@@ -4749,7 +4750,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t/* We do not perform argument-dependent lookup if\n \t\t   normal lookup finds a non-function, in accordance\n \t\t   with the expected resolution of DR 218.  */\n-\t\telse if (args && is_overloaded_fn (postfix_expression))\n+\t\telse if (!VEC_empty (tree, args)\n+\t\t\t && is_overloaded_fn (postfix_expression))\n \t\t  {\n \t\t    tree fn = get_first_fn (postfix_expression);\n \n@@ -4782,23 +4784,24 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t|| any_type_dependent_arguments_p (args)))\n \t\t  {\n \t\t    postfix_expression\n-\t\t      = build_nt_call_list (postfix_expression, args);\n+\t\t      = build_nt_call_vec (postfix_expression, args);\n+\t\t    release_tree_vector (args);\n \t\t    break;\n \t\t  }\n \n \t\tif (BASELINK_P (fn))\n \t\t  {\n \t\t  postfix_expression\n \t\t    = (build_new_method_call\n-\t\t       (instance, fn, args, NULL_TREE,\n+\t\t       (instance, fn, &args, NULL_TREE,\n \t\t\t(idk == CP_ID_KIND_QUALIFIED\n \t\t\t ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL),\n \t\t\t/*fn_p=*/NULL,\n \t\t\ttf_warning_or_error));\n \t\t  }\n \t\telse\n \t\t  postfix_expression\n-\t\t    = finish_call_expr (postfix_expression, args,\n+\t\t    = finish_call_expr (postfix_expression, &args,\n \t\t\t\t\t/*disallow_virtual=*/false,\n \t\t\t\t\t/*koenig_p=*/false,\n \t\t\t\t\ttf_warning_or_error);\n@@ -4807,25 +4810,27 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t     || TREE_CODE (postfix_expression) == MEMBER_REF\n \t\t     || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)\n \t      postfix_expression = (build_offset_ref_call_from_tree\n-\t\t\t\t    (postfix_expression, args));\n+\t\t\t\t    (postfix_expression, &args));\n \t    else if (idk == CP_ID_KIND_QUALIFIED)\n \t      /* A call to a static class member, or a namespace-scope\n \t\t function.  */\n \t      postfix_expression\n-\t\t= finish_call_expr (postfix_expression, args,\n+\t\t= finish_call_expr (postfix_expression, &args,\n \t\t\t\t    /*disallow_virtual=*/true,\n \t\t\t\t    koenig_p,\n \t\t\t\t    tf_warning_or_error);\n \t    else\n \t      /* All other function calls.  */\n \t      postfix_expression\n-\t\t= finish_call_expr (postfix_expression, args,\n+\t\t= finish_call_expr (postfix_expression, &args,\n \t\t\t\t    /*disallow_virtual=*/false,\n \t\t\t\t    koenig_p,\n \t\t\t\t    tf_warning_or_error);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n \t    idk = CP_ID_KIND_NONE;\n+\n+\t    release_tree_vector (args);\n \t  }\n \t  break;\n \n@@ -5132,24 +5137,22 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n    ALLOW_EXPANSION_P is true if this expression allows expansion of an\n    argument pack.\n \n-   Returns a TREE_LIST.  The TREE_VALUE of each node is a\n-   representation of an assignment-expression.  Note that a TREE_LIST\n-   is returned even if there is only a single expression in the list.\n-   error_mark_node is returned if the ( and or ) are\n-   missing. NULL_TREE is returned on no expressions. The parentheses\n-   are eaten. IS_ATTRIBUTE_LIST is true if this is really an attribute\n-   list being parsed.  If NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P\n-   indicates whether or not all of the expressions in the list were\n-   constant.  */\n+   Returns a vector of trees.  Each element is a representation of an\n+   assignment-expression.  NULL is returned if the ( and or ) are\n+   missing.  An empty, but allocated, vector is returned on no\n+   expressions.  The parentheses are eaten.  IS_ATTRIBUTE_LIST is true\n+   if this is really an attribute list being parsed.  If\n+   NON_CONSTANT_P is non-NULL, *NON_CONSTANT_P indicates whether or\n+   not all of the expressions in the list were constant.  */\n \n-static tree\n+static VEC(tree,gc) *\n cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool is_attribute_list,\n \t\t\t\t\t bool cast_p,\n                                          bool allow_expansion_p,\n \t\t\t\t\t bool *non_constant_p)\n {\n-  tree expression_list = NULL_TREE;\n+  VEC(tree,gc) *expression_list;\n   bool fold_expr_p = is_attribute_list;\n   tree identifier = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n@@ -5159,7 +5162,9 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n     *non_constant_p = false;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n-    return error_mark_node;\n+    return NULL;\n+\n+  expression_list = make_tree_vector ();\n \n   /* Within a parenthesized expression, a `>' token is always\n      the greater-than operator.  */\n@@ -5228,7 +5233,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\texpressions to the list, so that we can still tell if\n \t\tthe correct form for a parenthesized expression-list\n \t\tis found. That gives better errors.  */\n-\t    expression_list = tree_cons (NULL_TREE, expr, expression_list);\n+\t    VEC_safe_push (tree, gc, expression_list, expr);\n \n \t    if (expr == error_mark_node)\n \t      goto skip_comma;\n@@ -5264,17 +5269,15 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t{\n \t  parser->greater_than_is_operator_p\n \t    = saved_greater_than_is_operator_p;\n-\t  return error_mark_node;\n+\t  return NULL;\n \t}\n     }\n \n   parser->greater_than_is_operator_p\n     = saved_greater_than_is_operator_p;\n \n-  /* We built up the list in reverse order so we must reverse it now.  */\n-  expression_list = nreverse (expression_list);\n   if (identifier)\n-    expression_list = tree_cons (NULL_TREE, identifier, expression_list);\n+    VEC_safe_insert (tree, gc, expression_list, 0, identifier);\n \n   return expression_list;\n }\n@@ -5618,10 +5621,11 @@ static tree\n cp_parser_new_expression (cp_parser* parser)\n {\n   bool global_scope_p;\n-  tree placement;\n+  VEC(tree,gc) *placement;\n   tree type;\n-  tree initializer;\n+  VEC(tree,gc) *initializer;\n   tree nelts;\n+  tree ret;\n \n   /* Look for the optional `::' operator.  */\n   global_scope_p\n@@ -5637,7 +5641,11 @@ cp_parser_new_expression (cp_parser* parser)\n   placement = cp_parser_new_placement (parser);\n   /* If that didn't work out, there's no new-placement.  */\n   if (!cp_parser_parse_definitely (parser))\n-    placement = NULL_TREE;\n+    {\n+      if (placement != NULL)\n+\trelease_tree_vector (placement);\n+      placement = NULL;\n+    }\n \n   /* If the next token is a `(', then we have a parenthesized\n      type-id.  */\n@@ -5673,16 +5681,25 @@ cp_parser_new_expression (cp_parser* parser)\n       || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     initializer = cp_parser_new_initializer (parser);\n   else\n-    initializer = NULL_TREE;\n+    initializer = NULL;\n \n   /* A new-expression may not appear in an integral constant\n      expression.  */\n   if (cp_parser_non_integral_constant_expression (parser, \"%<new%>\"))\n-    return error_mark_node;\n+    ret = error_mark_node;\n+  else\n+    {\n+      /* Create a representation of the new-expression.  */\n+      ret = build_new (&placement, type, nelts, &initializer, global_scope_p,\n+\t\t       tf_warning_or_error);\n+    }\n \n-  /* Create a representation of the new-expression.  */\n-  return build_new (placement, type, nelts, initializer, global_scope_p,\n-                    tf_warning_or_error);\n+  if (placement != NULL)\n+    release_tree_vector (placement);\n+  if (initializer != NULL)\n+    release_tree_vector (initializer);\n+\n+  return ret;\n }\n \n /* Parse a new-placement.\n@@ -5692,10 +5709,10 @@ cp_parser_new_expression (cp_parser* parser)\n \n    Returns the same representation as for an expression-list.  */\n \n-static tree\n+static VEC(tree,gc) *\n cp_parser_new_placement (cp_parser* parser)\n {\n-  tree expression_list;\n+  VEC(tree,gc) *expression_list;\n \n   /* Parse the expression-list.  */\n   expression_list = (cp_parser_parenthesized_expression_list\n@@ -5885,28 +5902,26 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n      ( expression-list [opt] )\n      braced-init-list\n \n-   Returns a representation of the expression-list.  If there is no\n-   expression-list, VOID_ZERO_NODE is returned.  */\n+   Returns a representation of the expression-list.  */\n \n-static tree\n+static VEC(tree,gc) *\n cp_parser_new_initializer (cp_parser* parser)\n {\n-  tree expression_list;\n+  VEC(tree,gc) *expression_list;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n+      tree t;\n       bool expr_non_constant_p;\n       maybe_warn_cpp0x (\"extended initializer lists\");\n-      expression_list = cp_parser_braced_list (parser, &expr_non_constant_p);\n-      CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;\n-      expression_list = build_tree_list (NULL_TREE, expression_list);\n+      t = cp_parser_braced_list (parser, &expr_non_constant_p);\n+      CONSTRUCTOR_IS_DIRECT_INIT (t) = 1;\n+      expression_list = make_tree_vector_single (t);\n     }\n   else\n     expression_list = (cp_parser_parenthesized_expression_list\n \t\t       (parser, false, /*cast_p=*/false, /*allow_expansion_p=*/true,\n \t\t\t/*non_constant_p=*/NULL));\n-  if (!expression_list)\n-    expression_list = void_zero_node;\n \n   return expression_list;\n }\n@@ -9225,11 +9240,18 @@ cp_parser_mem_initializer (cp_parser* parser)\n       expression_list = build_tree_list (NULL_TREE, expression_list);\n     }\n   else\n-    expression_list\n-      = cp_parser_parenthesized_expression_list (parser, false,\n-\t\t\t\t\t\t /*cast_p=*/false,\n-\t\t\t\t\t\t /*allow_expansion_p=*/true,\n-\t\t\t\t\t\t /*non_constant_p=*/NULL);\n+    {\n+      VEC(tree,gc)* vec;\n+      vec = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t     /*cast_p=*/false,\n+\t\t\t\t\t\t     /*allow_expansion_p=*/true,\n+\t\t\t\t\t\t     /*non_constant_p=*/NULL);\n+      if (vec == NULL)\n+\treturn error_mark_node;\n+      expression_list = build_tree_list_vec (vec);\n+      release_tree_vector (vec);\n+    }\n+\n   if (expression_list == error_mark_node)\n     return error_mark_node;\n   if (!expression_list)\n@@ -14585,10 +14607,17 @@ cp_parser_initializer (cp_parser* parser, bool* is_direct_init,\n       init = cp_parser_initializer_clause (parser, non_constant_p);\n     }\n   else if (token->type == CPP_OPEN_PAREN)\n-    init = cp_parser_parenthesized_expression_list (parser, false,\n-\t\t\t\t\t\t    /*cast_p=*/false,\n-                                                    /*allow_expansion_p=*/true,\n-\t\t\t\t\t\t    non_constant_p);\n+    {\n+      VEC(tree,gc) *vec;\n+      vec = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t     /*cast_p=*/false,\n+\t\t\t\t\t\t     /*allow_expansion_p=*/true,\n+\t\t\t\t\t\t     non_constant_p);\n+      if (vec == NULL)\n+\treturn error_mark_node;\n+      init = build_tree_list_vec (vec);\n+      release_tree_vector (vec);\n+    }\n   else if (token->type == CPP_OPEN_BRACE)\n     {\n       maybe_warn_cpp0x (\"extended initializer lists\");\n@@ -16850,10 +16879,18 @@ cp_parser_attribute_list (cp_parser* parser)\n \t  /* If it's an `(', then parse the attribute arguments.  */\n \t  if (token->type == CPP_OPEN_PAREN)\n \t    {\n-\t      arguments = cp_parser_parenthesized_expression_list\n-\t\t\t  (parser, true, /*cast_p=*/false,\n-                           /*allow_expansion_p=*/false,\n-\t\t\t   /*non_constant_p=*/NULL);\n+\t      VEC(tree,gc) *vec;\n+\t      vec = cp_parser_parenthesized_expression_list\n+\t\t    (parser, true, /*cast_p=*/false,\n+\t\t     /*allow_expansion_p=*/false,\n+\t\t     /*non_constant_p=*/NULL);\n+\t      if (vec == NULL)\n+\t\targuments = error_mark_node;\n+\t      else\n+\t\t{\n+\t\t  arguments = build_tree_list_vec (vec);\n+\t\t  release_tree_vector (vec);\n+\t\t}\n \t      /* Save the arguments away.  */\n \t      TREE_VALUE (attribute) = arguments;\n \t    }\n@@ -17981,6 +18018,7 @@ cp_parser_simple_cast_expression (cp_parser *parser)\n static tree\n cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n+  VEC(tree,gc) *vec;\n   tree expression_list;\n   tree cast;\n   bool nonconst_p;\n@@ -17995,11 +18033,18 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n       return finish_compound_literal (type, expression_list);\n     }\n \n-  expression_list\n-    = cp_parser_parenthesized_expression_list (parser, false,\n-\t\t\t\t\t       /*cast_p=*/true,\n-\t\t\t\t\t       /*allow_expansion_p=*/true,\n-\t\t\t\t\t       /*non_constant_p=*/NULL);\n+\n+  vec = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t /*cast_p=*/true,\n+\t\t\t\t\t\t /*allow_expansion_p=*/true,\n+\t\t\t\t\t\t /*non_constant_p=*/NULL);\n+  if (vec == NULL)\n+    expression_list = error_mark_node;\n+  else\n+    {\n+      expression_list = build_tree_list_vec (vec);\n+      release_tree_vector (vec);\n+    }\n \n   cast = build_functional_cast (type, expression_list,\n                                 tf_warning_or_error);"}, {"sha": "ed6b03161e24609a28f2040ce3b162740a73ae4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 200, "deletions": 100, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -118,8 +118,8 @@ static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*,\n \t\t\t\t\t     tree);\n-static int  type_unification_real (tree, tree, tree, tree,\n-\t\t\t\t   int, unification_kind_t, int);\n+static int type_unification_real (tree, tree, tree, const tree *,\n+\t\t\t\t  unsigned int, int, unification_kind_t, int);\n static void note_template_header (int);\n static tree convert_nontype_argument_function (tree, tree);\n static tree convert_nontype_argument (tree, tree);\n@@ -11430,24 +11430,54 @@ tsubst_copy_and_build (tree t,\n \n     case NEW_EXPR:\n       {\n+\ttree placement = RECUR (TREE_OPERAND (t, 0));\n \ttree init = RECUR (TREE_OPERAND (t, 3));\n+\tVEC(tree,gc) *placement_vec;\n+\tVEC(tree,gc) *init_vec;\n+\ttree ret;\n \n-\tif (TREE_OPERAND (t, 3) && !init)\n-\t  /* If there was an initializer in the original tree, but\n-\t     it instantiated to an empty list, then we should pass on\n-\t     VOID_ZERO_NODE to tell build_new that it was an empty\n-\t     initializer () rather than no initializer.  This can only\n-\t     happen when the initializer is a pack expansion whose\n-\t     parameter packs are of length zero.  */\n-\t  init = void_zero_node;\n+\tif (placement == NULL_TREE)\n+\t  placement_vec = NULL;\n+\telse\n+\t  {\n+\t    placement_vec = make_tree_vector ();\n+\t    for (; placement != NULL_TREE; placement = TREE_CHAIN (placement))\n+\t      VEC_safe_push (tree, gc, placement_vec, TREE_VALUE (placement));\n+\t  }\n \n-\treturn build_new\n-\t  (RECUR (TREE_OPERAND (t, 0)),\n-\t   RECUR (TREE_OPERAND (t, 1)),\n-\t   RECUR (TREE_OPERAND (t, 2)),\n-\t   init,\n-\t   NEW_EXPR_USE_GLOBAL (t),\n-           complain);\n+\t/* If there was an initializer in the original tree, but it\n+\t   instantiated to an empty list, then we should pass a\n+\t   non-NULL empty vector to tell build_new that it was an\n+\t   empty initializer() rather than no initializer.  This can\n+\t   only happen when the initializer is a pack expansion whose\n+\t   parameter packs are of length zero.  */\n+\tif (init == NULL_TREE && TREE_OPERAND (t, 3) == NULL_TREE)\n+\t  init_vec = NULL;\n+\telse\n+\t  {\n+\t    init_vec = make_tree_vector ();\n+\t    if (init == void_zero_node)\n+\t      gcc_assert (init_vec != NULL);\n+\t    else\n+\t      {\n+\t\tfor (; init != NULL_TREE; init = TREE_CHAIN (init))\n+\t\t  VEC_safe_push (tree, gc, init_vec, TREE_VALUE (init));\n+\t      }\n+\t  }\n+\n+\tret = build_new (&placement_vec,\n+\t\t\t RECUR (TREE_OPERAND (t, 1)),\n+\t\t\t RECUR (TREE_OPERAND (t, 2)),\n+\t\t\t &init_vec,\n+\t\t\t NEW_EXPR_USE_GLOBAL (t),\n+\t\t\t complain);\n+\n+\tif (placement_vec != NULL)\n+\t  release_tree_vector (placement_vec);\n+\tif (init_vec != NULL)\n+\t  release_tree_vector (init_vec);\n+\n+\treturn ret;\n       }\n \n     case DELETE_EXPR:\n@@ -11465,9 +11495,11 @@ tsubst_copy_and_build (tree t,\n     case CALL_EXPR:\n       {\n \ttree function;\n-\ttree call_args;\n+\tVEC(tree,gc) *call_args;\n+\tunsigned int nargs, i;\n \tbool qualified_p;\n \tbool koenig_p;\n+\ttree ret;\n \n \tfunction = CALL_EXPR_FN (t);\n \t/* When we parsed the expression,  we determined whether or\n@@ -11502,8 +11534,40 @@ tsubst_copy_and_build (tree t,\n \t      qualified_p = true;\n \t  }\n \n-\t/* FIXME:  Rewrite this so as not to construct an arglist.  */\n-\tcall_args = RECUR (CALL_EXPR_ARGS (t));\n+\tnargs = call_expr_nargs (t);\n+\tcall_args = make_tree_vector ();\n+\tfor (i = 0; i < nargs; ++i)\n+\t  {\n+\t    tree arg = CALL_EXPR_ARG (t, i);\n+\n+\t    if (!PACK_EXPANSION_P (arg))\n+\t      VEC_safe_push (tree, gc, call_args,\n+\t\t\t     RECUR (CALL_EXPR_ARG (t, i)));\n+\t    else\n+\t      {\n+\t\t/* Expand the pack expansion and push each entry onto\n+\t\t   CALL_ARGS.  */\n+\t\targ = tsubst_pack_expansion (arg, args, complain, in_decl);\n+\t\tif (TREE_CODE (arg) == TREE_VEC)\n+\t\t  {\n+\t\t    unsigned int len, j;\n+\n+\t\t    len = TREE_VEC_LENGTH (arg);\n+\t\t    for (j = 0; j < len; ++j)\n+\t\t      {\n+\t\t\ttree value = TREE_VEC_ELT (arg, j);\n+\t\t\tif (value != NULL_TREE)\n+\t\t\t  value = convert_from_reference (value);\n+\t\t\tVEC_safe_push (tree, gc, call_args, value);\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* A partial substitution.  Add one entry.  */\n+\t\t    VEC_safe_push (tree, gc, call_args, arg);\n+\t\t  }\n+\t      }\n+\t  }\n \n \t/* We do not perform argument-dependent lookup if normal\n \t   lookup finds a non-function, in accordance with the\n@@ -11524,6 +11588,7 @@ tsubst_copy_and_build (tree t,\n \tif (TREE_CODE (function) == IDENTIFIER_NODE)\n \t  {\n \t    unqualified_name_lookup_error (function);\n+\t    release_tree_vector (call_args);\n \t    return error_mark_node;\n \t  }\n \n@@ -11532,27 +11597,32 @@ tsubst_copy_and_build (tree t,\n \t  mark_used (function);\n \n \tif (TREE_CODE (function) == OFFSET_REF)\n-\t  return build_offset_ref_call_from_tree (function, call_args);\n-\tif (TREE_CODE (function) == COMPONENT_REF)\n+\t  ret = build_offset_ref_call_from_tree (function, &call_args);\n+\telse if (TREE_CODE (function) == COMPONENT_REF)\n \t  {\n \t    if (!BASELINK_P (TREE_OPERAND (function, 1)))\n-\t      return finish_call_expr (function, call_args,\n+\t      ret = finish_call_expr (function, &call_args,\n \t\t\t\t       /*disallow_virtual=*/false,\n \t\t\t\t       /*koenig_p=*/false,\n \t\t\t\t       complain);\n \t    else\n-\t      return (build_new_method_call\n+\t      ret = (build_new_method_call\n \t\t      (TREE_OPERAND (function, 0),\n \t\t       TREE_OPERAND (function, 1),\n-\t\t       call_args, NULL_TREE,\n+\t\t       &call_args, NULL_TREE,\n \t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL,\n \t\t       /*fn_p=*/NULL,\n \t\t       complain));\n \t  }\n-\treturn finish_call_expr (function, call_args,\n-\t\t\t\t /*disallow_virtual=*/qualified_p,\n-\t\t\t\t koenig_p,\n-\t\t\t\t complain);\n+\telse\n+\t  ret = finish_call_expr (function, &call_args,\n+\t\t\t\t  /*disallow_virtual=*/qualified_p,\n+\t\t\t\t  koenig_p,\n+\t\t\t\t  complain);\n+\n+\trelease_tree_vector (call_args);\n+\n+\treturn ret;\n       }\n \n     case COND_EXPR:\n@@ -12112,9 +12182,10 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   return fndecl;\n }\n \n-/* The FN is a TEMPLATE_DECL for a function.  The ARGS are the\n-   arguments that are being used when calling it.  TARGS is a vector\n-   into which the deduced template arguments are placed.\n+/* The FN is a TEMPLATE_DECL for a function.  ARGS is an array with\n+   NARGS elements of the arguments that are being used when calling\n+   it.  TARGS is a vector into which the deduced template arguments\n+   are placed.\n \n    Return zero for success, 2 for an incomplete match that doesn't resolve\n    all the types, and 1 for complete failure.  An error message will be\n@@ -12146,7 +12217,8 @@ int\n fn_type_unification (tree fn,\n \t\t     tree explicit_targs,\n \t\t     tree targs,\n-\t\t     tree args,\n+\t\t     const tree *args,\n+\t\t     unsigned int nargs,\n \t\t     tree return_type,\n \t\t     unification_kind_t strict,\n \t\t     int flags)\n@@ -12263,16 +12335,22 @@ fn_type_unification (tree fn,\n \n   if (return_type)\n     {\n+      tree *new_args;\n+\n       parms = tree_cons (NULL_TREE, TREE_TYPE (fntype), parms);\n-      args = tree_cons (NULL_TREE, return_type, args);\n+      new_args = XALLOCAVEC (tree, nargs + 1);\n+      new_args[0] = return_type;\n+      memcpy (new_args + 1, args, nargs * sizeof (tree));\n+      args = new_args;\n+      ++nargs;\n     }\n \n   /* We allow incomplete unification without an error message here\n      because the standard doesn't seem to explicitly prohibit it.  Our\n      callers must be ready to deal with unification failures in any\n      event.  */\n   result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n-\t\t\t\t  targs, parms, args, /*subr=*/0,\n+\t\t\t\t  targs, parms, args, nargs, /*subr=*/0,\n \t\t\t\t  strict, flags);\n \n   if (result == 0 && incomplete_argument_packs_p)\n@@ -12337,14 +12415,14 @@ fn_type_unification (tree fn,\n \t parameters are used in non-deduced contexts.  */\n       if (strict == DEDUCE_EXACT)\n \t{\n+\t  unsigned int i;\n+\n \t  tree sarg\n \t    = skip_artificial_parms_for (fn, TYPE_ARG_TYPES (substed));\n-\t  tree arg = args;\n \t  if (return_type)\n \t    sarg = tree_cons (NULL_TREE, TREE_TYPE (substed), sarg);\n-\t  for (; arg && sarg;\n-\t       arg = TREE_CHAIN (arg), sarg = TREE_CHAIN (sarg))\n-\t    if (!same_type_p (TREE_VALUE (arg), TREE_VALUE (sarg)))\n+\t  for (i = 0; i < nargs && sarg; ++i, sarg = TREE_CHAIN (sarg))\n+\t    if (!same_type_p (args[i], TREE_VALUE (sarg)))\n \t      return 1;\n \t}\n     }\n@@ -12459,7 +12537,8 @@ static int\n type_unification_real (tree tparms,\n \t\t       tree targs,\n \t\t       tree xparms,\n-\t\t       tree xargs,\n+\t\t       const tree *xargs,\n+\t\t       unsigned int xnargs,\n \t\t       int subr,\n \t\t       unification_kind_t strict,\n \t\t       int flags)\n@@ -12469,11 +12548,13 @@ type_unification_real (tree tparms,\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   int sub_strict;\n   int saw_undeduced = 0;\n-  tree parms, args;\n+  tree parms;\n+  const tree *args;\n+  unsigned int nargs;\n+  unsigned int ia;\n \n   gcc_assert (TREE_CODE (tparms) == TREE_VEC);\n   gcc_assert (xparms == NULL_TREE || TREE_CODE (xparms) == TREE_LIST);\n-  gcc_assert (!xargs || TREE_CODE (xargs) == TREE_LIST);\n   gcc_assert (ntparms > 0);\n \n   switch (strict)\n@@ -12498,17 +12579,19 @@ type_unification_real (tree tparms,\n  again:\n   parms = xparms;\n   args = xargs;\n+  nargs = xnargs;\n \n+  ia = 0;\n   while (parms && parms != void_list_node\n-\t && args && args != void_list_node)\n+\t && ia < nargs)\n     {\n       if (TREE_CODE (TREE_VALUE (parms)) == TYPE_PACK_EXPANSION)\n         break;\n \n       parm = TREE_VALUE (parms);\n       parms = TREE_CHAIN (parms);\n-      arg = TREE_VALUE (args);\n-      args = TREE_CHAIN (args);\n+      arg = args[ia];\n+      ++ia;\n       arg_expr = NULL;\n \n       if (arg == error_mark_node)\n@@ -12587,20 +12670,11 @@ type_unification_real (tree tparms,\n       /* Unify the remaining arguments with the pack expansion type.  */\n       tree argvec;\n       tree parmvec = make_tree_vec (1);\n-      int len = 0;\n-      tree t;\n \n-      /* Count the number of arguments that remain.  */\n-      for (t = args; t && t != void_list_node; t = TREE_CHAIN (t))\n-        len++;\n-        \n       /* Allocate a TREE_VEC and copy in all of the arguments */ \n-      argvec = make_tree_vec (len);\n-      for (i = 0; args && args != void_list_node; args = TREE_CHAIN (args))\n-        {\n-          TREE_VEC_ELT (argvec, i) = TREE_VALUE (args);\n-          ++i;\n-        }\n+      argvec = make_tree_vec (nargs - ia);\n+      for (i = 0; ia < nargs; ++ia, ++i)\n+\tTREE_VEC_ELT (argvec, i) = args[ia];\n \n       /* Copy the parameter into parmvec.  */\n       TREE_VEC_ELT (parmvec, 0) = TREE_VALUE (parms);\n@@ -12614,7 +12688,7 @@ type_unification_real (tree tparms,\n \n   /* Fail if we've reached the end of the parm list, and more args\n      are present, and the parm list isn't variadic.  */\n-  if (args && args != void_list_node && parms == void_list_node)\n+  if (ia < nargs && parms == void_list_node)\n     return 1;\n   /* Fail if parms are left and they don't have default values.  */\n   if (parms && parms != void_list_node\n@@ -13896,26 +13970,42 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n-      if (TREE_CODE (arg) != TREE_CODE (parm))\n-\treturn 1;\n+      {\n+\tunsigned int nargs;\n+\ttree *args;\n+\ttree a;\n+\tunsigned int i;\n \n-      /* CV qualifications for methods can never be deduced, they must\n-\t match exactly.  We need to check them explicitly here,\n-\t because type_unification_real treats them as any other\n-\t cv-qualified parameter.  */\n-      if (TREE_CODE (parm) == METHOD_TYPE\n-\t  && (!check_cv_quals_for_unify\n-\t      (UNIFY_ALLOW_NONE,\n-\t       TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (arg))),\n-\t       TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (parm))))))\n-\treturn 1;\n+\tif (TREE_CODE (arg) != TREE_CODE (parm))\n+\t  return 1;\n \n-      if (unify (tparms, targs, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE))\n-\treturn 1;\n-      return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t\t    TYPE_ARG_TYPES (arg), 1, DEDUCE_EXACT,\n-\t\t\t\t    LOOKUP_NORMAL);\n+\t/* CV qualifications for methods can never be deduced, they must\n+\t   match exactly.  We need to check them explicitly here,\n+\t   because type_unification_real treats them as any other\n+\t   cv-qualified parameter.  */\n+\tif (TREE_CODE (parm) == METHOD_TYPE\n+\t    && (!check_cv_quals_for_unify\n+\t\t(UNIFY_ALLOW_NONE,\n+\t\t TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (arg))),\n+\t\t TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (parm))))))\n+\t  return 1;\n+\n+\tif (unify (tparms, targs, TREE_TYPE (parm),\n+\t\t   TREE_TYPE (arg), UNIFY_ALLOW_NONE))\n+\t  return 1;\n+\n+\tnargs = list_length (TYPE_ARG_TYPES (arg));\n+\targs = XALLOCAVEC (tree, nargs);\n+\tfor (a = TYPE_ARG_TYPES (arg), i = 0;\n+\t     a != NULL_TREE && a != void_list_node;\n+\t     a = TREE_CHAIN (a), ++i)\n+\t  args[i] = TREE_VALUE (a);\n+\tnargs = i;\n+\n+\treturn type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n+\t\t\t\t      args, nargs, 1, DEDUCE_EXACT,\n+\t\t\t\t      LOOKUP_NORMAL);\n+      }\n \n     case OFFSET_TYPE:\n       /* Unify a pointer to member with a pointer to member function, which\n@@ -14469,6 +14559,9 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n   tree targs = make_tree_vec (ntparms);\n   tree decl_type;\n   tree decl_arg_types;\n+  tree *args;\n+  unsigned int nargs, ix;\n+  tree arg;\n \n   /* Substitute the explicit template arguments into the type of DECL.\n      The call to fn_type_unification will handle substitution into the\n@@ -14503,8 +14596,15 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n   decl_arg_types = skip_artificial_parms_for (decl, \n \t\t\t\t\t      TYPE_ARG_TYPES (decl_type));\n \n+  nargs = list_length (decl_arg_types);\n+  args = XALLOCAVEC (tree, nargs);\n+  for (arg = decl_arg_types, ix = 0;\n+       arg != NULL_TREE && arg != void_list_node;\n+       arg = TREE_CHAIN (arg), ++ix)\n+    args[ix] = TREE_VALUE (arg);\n+\n   if (fn_type_unification (fn, explicit_args, targs,\n-\t\t\t   decl_arg_types,\n+\t\t\t   args, ix,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t\t\t    ? TREE_TYPE (decl_type) : NULL_TREE),\n \t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL))\n@@ -16580,19 +16680,18 @@ type_dependent_expression_p_push (tree expr)\n   return b;\n }\n \n-/* Returns TRUE if ARGS (a TREE_LIST of arguments to a function call)\n-   contains a type-dependent expression.  */\n+/* Returns TRUE if ARGS contains a type-dependent expression.  */\n \n bool\n-any_type_dependent_arguments_p (const_tree args)\n+any_type_dependent_arguments_p (const VEC(tree,gc) *args)\n {\n-  while (args)\n-    {\n-      tree arg = TREE_VALUE (args);\n+  unsigned int i;\n+  tree arg;\n \n+  for (i = 0; VEC_iterate (tree, args, i, arg); ++i)\n+    {\n       if (type_dependent_expression_p (arg))\n \treturn true;\n-      args = TREE_CHAIN (args);\n     }\n   return false;\n }\n@@ -17012,22 +17111,22 @@ build_non_dependent_expr (tree expr)\n   return build1 (NON_DEPENDENT_EXPR, non_reference (TREE_TYPE (expr)), expr);\n }\n \n-/* ARGS is a TREE_LIST of expressions as arguments to a function call.\n-   Return a new TREE_LIST with the various arguments replaced with\n-   equivalent non-dependent expressions.  */\n+/* ARGS is a vector of expressions as arguments to a function call.\n+   Replace the arguments with equivalent non-dependent expressions.\n+   This modifies ARGS in place.  */\n \n-tree\n-build_non_dependent_args (tree args)\n+void\n+make_args_non_dependent (VEC(tree,gc) *args)\n {\n-  tree a;\n-  tree new_args;\n+  unsigned int ix;\n+  tree arg;\n \n-  new_args = NULL_TREE;\n-  for (a = args; a; a = TREE_CHAIN (a))\n-    new_args = tree_cons (NULL_TREE,\n-\t\t\t  build_non_dependent_expr (TREE_VALUE (a)),\n-\t\t\t  new_args);\n-  return nreverse (new_args);\n+  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+    {\n+      tree newarg = build_non_dependent_expr (arg);\n+      if (newarg != arg)\n+\tVEC_replace (tree, args, ix, newarg);\n+    }\n }\n \n /* Returns a type which represents 'auto'.  We use a TEMPLATE_TYPE_PARM\n@@ -17084,7 +17183,8 @@ listify_autos (tree type, tree auto_node)\n tree\n do_auto_deduction (tree type, tree init, tree auto_node)\n {\n-  tree parms, args, tparms, targs;\n+  tree parms, tparms, targs;\n+  tree args[1];\n   int val;\n \n   /* [dcl.spec.auto]: Obtain P from T by replacing the occurrences of auto\n@@ -17095,12 +17195,12 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n     type = listify_autos (type, auto_node);\n \n   parms = build_tree_list (NULL_TREE, type);\n-  args = build_tree_list (NULL_TREE, init);\n+  args[0] = init;\n   tparms = make_tree_vec (1);\n   targs = make_tree_vec (1);\n   TREE_VEC_ELT (tparms, 0)\n     = build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n-  val = type_unification_real (tparms, targs, parms, args, 0,\n+  val = type_unification_real (tparms, targs, parms, args, 1, 0,\n \t\t\t       DEDUCE_CALL, LOOKUP_NORMAL);\n   if (val > 0)\n     {"}, {"sha": "2b12448eefd86af946a679122cad64ad29cfbd8e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1820,7 +1820,7 @@ stmt_expr_value_expr (tree stmt_expr)\n    resolution.  */\n \n tree\n-perform_koenig_lookup (tree fn, tree args)\n+perform_koenig_lookup (tree fn, VEC(tree,gc) *args)\n {\n   tree identifier = NULL_TREE;\n   tree functions = NULL_TREE;\n@@ -1865,7 +1865,8 @@ perform_koenig_lookup (tree fn, tree args)\n   return fn;\n }\n \n-/* Generate an expression for `FN (ARGS)'.\n+/* Generate an expression for `FN (ARGS)'.  This may change the\n+   contents of ARGS.\n \n    If DISALLOW_VIRTUAL is true, the call to FN will be not generated\n    as a virtual call, even if FN is virtual.  (This flag is set when\n@@ -1876,29 +1877,26 @@ perform_koenig_lookup (tree fn, tree args)\n    Returns code for the call.  */\n \n tree\n-finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n-\t\t  tsubst_flags_t complain)\n+finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n+\t\t  bool koenig_p, tsubst_flags_t complain)\n {\n   tree result;\n   tree orig_fn;\n-  tree orig_args;\n+  VEC(tree,gc) *orig_args = NULL;\n \n-  if (fn == error_mark_node || args == error_mark_node)\n+  if (fn == error_mark_node)\n     return error_mark_node;\n \n-  /* ARGS should be a list of arguments.  */\n-  gcc_assert (!args || TREE_CODE (args) == TREE_LIST);\n   gcc_assert (!TYPE_P (fn));\n \n   orig_fn = fn;\n-  orig_args = args;\n \n   if (processing_template_decl)\n     {\n       if (type_dependent_expression_p (fn)\n-\t  || any_type_dependent_arguments_p (args))\n+\t  || any_type_dependent_arguments_p (*args))\n \t{\n-\t  result = build_nt_call_list (fn, args);\n+\t  result = build_nt_call_vec (fn, *args);\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  if (cfun)\n \t    {\n@@ -1916,11 +1914,12 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n \t    }\n \t  return result;\n \t}\n+      orig_args = make_tree_vector_copy (*args);\n       if (!BASELINK_P (fn)\n \t  && TREE_CODE (fn) != PSEUDO_DTOR_EXPR\n \t  && TREE_TYPE (fn) != unknown_type_node)\n \tfn = build_non_dependent_expr (fn);\n-      args = build_non_dependent_args (orig_args);\n+      make_args_non_dependent (*args);\n     }\n \n   if (is_overloaded_fn (fn))\n@@ -1969,7 +1968,11 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n       if (processing_template_decl)\n \t{\n \t  if (type_dependent_expression_p (object))\n-\t    return build_nt_call_list (orig_fn, orig_args);\n+\t    {\n+\t      tree ret = build_nt_call_vec (orig_fn, orig_args);\n+\t      release_tree_vector (orig_args);\n+\t      return ret;\n+\t    }\n \t  object = build_non_dependent_expr (object);\n \t}\n \n@@ -1985,23 +1988,15 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && (DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL\n \t      || DECL_BUILT_IN_CLASS (fn) == BUILT_IN_MD))\n-\t{\n-\t  VEC(tree,gc)* vec = VEC_alloc (tree, gc, list_length (args));\n-\t  tree p;\n-\n-\t  for (p = args; p != NULL_TREE; p = TREE_CHAIN (p))\n-\t    VEC_quick_push (tree, vec, TREE_VALUE (p));\n-\t  result = resolve_overloaded_builtin (fn, vec);\n-\t  VEC_free (tree, gc, vec);\n-\t}\n+\tresult = resolve_overloaded_builtin (fn, *args);\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n \tresult = build_new_function_call (fn, args, koenig_p, complain);\n     }\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {\n-      if (args)\n+      if (!VEC_empty (tree, *args))\n \terror (\"arguments to destructor are not allowed\");\n       /* Mark the pseudo-destructor call as having side-effects so\n \t that we do not issue warnings about its use.  */\n@@ -2013,18 +2008,19 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n   else if (CLASS_TYPE_P (TREE_TYPE (fn)))\n     /* If the \"function\" is really an object of class type, it might\n        have an overloaded `operator ()'.  */\n-    result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE,\n-\t\t\t   /*overloaded_p=*/NULL, complain);\n+    result = build_op_call (fn, args, complain);\n \n   if (!result)\n     /* A call where the function is unknown.  */\n-    result = cp_build_function_call (fn, args, complain);\n+    result = cp_build_function_call_vec (fn, args, complain);\n \n   if (processing_template_decl)\n     {\n-      result = build_call_list (TREE_TYPE (result), orig_fn, orig_args);\n+      result = build_call_vec (TREE_TYPE (result), orig_fn, orig_args);\n       KOENIG_LOOKUP_P (result) = koenig_p;\n+      release_tree_vector (orig_args);\n     }\n+\n   return result;\n }\n \n@@ -3423,18 +3419,23 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n   if (need_default_ctor\n       || (need_copy_ctor && !TYPE_HAS_TRIVIAL_INIT_REF (type)))\n     {\n+      VEC(tree,gc) *vec;\n+\n       if (need_default_ctor)\n-\tt = NULL;\n+\tvec = NULL;\n       else\n \t{\n \t  t = build_int_cst (build_pointer_type (type), 0);\n \t  t = build1 (INDIRECT_REF, type, t);\n-\t  t = build_tree_list (NULL, t);\n+\t  vec = make_tree_vector_single (t);\n \t}\n       t = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t     t, type, LOOKUP_NORMAL,\n+\t\t\t\t     &vec, type, LOOKUP_NORMAL,\n \t\t\t\t     tf_warning_or_error);\n \n+      if (vec != NULL)\n+\trelease_tree_vector (vec);\n+\n       if (targetm.cxx.cdtor_returns_this () || errorcount)\n \t/* Because constructors and destructors return this,\n \t   the call will have been cast to \"void\".  Remove the\n@@ -3472,12 +3473,15 @@ cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n \n   if (need_copy_assignment && !TYPE_HAS_TRIVIAL_ASSIGN_REF (type))\n     {\n+      VEC(tree,gc) *vec;\n+\n       t = build_int_cst (build_pointer_type (type), 0);\n       t = build1 (INDIRECT_REF, type, t);\n+      vec = make_tree_vector_single (t);\n       t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n-\t\t\t\t     build_tree_list (NULL, t),\n-\t\t\t\t     type, LOOKUP_NORMAL,\n+\t\t\t\t     &vec, type, LOOKUP_NORMAL,\n \t\t\t\t     tf_warning_or_error);\n+      release_tree_vector (vec);\n \n       /* We'll have called convert_from_reference on the call, which\n \t may well have added an indirect_ref.  It's unneeded here,\n@@ -4433,23 +4437,29 @@ void\n finish_omp_barrier (void)\n {\n   tree fn = built_in_decls[BUILT_IN_GOMP_BARRIER];\n-  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n+  VEC(tree,gc) *vec = make_tree_vector ();\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n }\n \n void\n finish_omp_flush (void)\n {\n   tree fn = built_in_decls[BUILT_IN_SYNCHRONIZE];\n-  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n+  VEC(tree,gc) *vec = make_tree_vector ();\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n }\n \n void\n finish_omp_taskwait (void)\n {\n   tree fn = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n-  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n+  VEC(tree,gc) *vec = make_tree_vector ();\n+  tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);\n+  release_tree_vector (vec);\n   finish_expr_stmt (stmt);\n }\n \f"}, {"sha": "8c51e0b6e3c2257b65ee73d59bd87b67ace243cd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1719,9 +1719,9 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n    built.  */\n \n tree\n-build_min_non_dep_call_list (tree non_dep, tree fn, tree arglist)\n+build_min_non_dep_call_vec (tree non_dep, tree fn, VEC(tree,gc) *argvec)\n {\n-  tree t = build_nt_call_list (fn, arglist);\n+  tree t = build_nt_call_vec (fn, argvec);\n   TREE_TYPE (t) = TREE_TYPE (non_dep);\n   TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (non_dep);\n   return t;"}, {"sha": "074d619ca13e91e1beb7c7d710dbff964d4c0a97", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 100, "deletions": 55, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -61,7 +61,7 @@ static void casts_away_constness_r (tree *, tree *);\n static bool casts_away_constness (tree, tree);\n static void maybe_warn_about_returning_address_of_local (tree);\n static tree lookup_destructor (tree, tree, tree);\n-static int convert_arguments (int, tree *, tree, tree, tree, int,\n+static int convert_arguments (tree, VEC(tree,gc) **, tree, int,\n                               tsubst_flags_t);\n \n /* Do `exp = require_complete_type (exp);' to make sure exp\n@@ -2866,38 +2866,57 @@ tree\n build_function_call_vec (tree function, VEC(tree,gc) *params,\n \t\t\t VEC(tree,gc) *origtypes ATTRIBUTE_UNUSED)\n {\n-  tree p;\n-  tree *pp;\n-  unsigned int i;\n-  tree t;\n+  VEC(tree,gc) *orig_params = params;\n+  tree ret = cp_build_function_call_vec (function, &params,\n+\t\t\t\t\t tf_warning_or_error);\n \n-  /* FIXME: Should just change cp_build_function_call to use a\n-     VEC.  */\n-  p = NULL_TREE;\n-  pp = &p;\n-  for (i = 0; VEC_iterate (tree, params, i, t); ++i)\n-    {\n-      *pp = build_tree_list (NULL, t);\n-      pp = &TREE_CHAIN (*pp);\n-    }\n-  return cp_build_function_call (function, p, tf_warning_or_error);\n+  /* cp_build_function_call_vec can reallocate PARAMS by adding\n+     default arguments.  That should never happen here.  Verify\n+     that.  */\n+  gcc_assert (params == orig_params);\n+\n+  return ret;\n }\n \n+/* Build a function call using a tree list of arguments.  */\n+\n tree\n cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n+{\n+  VEC(tree,gc) *vec;\n+  tree ret;\n+\n+  vec = make_tree_vector ();\n+  for (; params != NULL_TREE; params = TREE_CHAIN (params))\n+    VEC_safe_push (tree, gc, vec, TREE_VALUE (params));\n+  ret = cp_build_function_call_vec (function, &vec, complain);\n+  release_tree_vector (vec);\n+  return ret;\n+}\n+\n+/* Build a function call using a vector of arguments.  PARAMS may be\n+   NULL if there are no parameters.  This changes the contents of\n+   PARAMS.  */\n+\n+tree\n+cp_build_function_call_vec (tree function, VEC(tree,gc) **params,\n+\t\t\t    tsubst_flags_t complain)\n {\n   tree fntype, fndecl;\n   tree name = NULL_TREE;\n   int is_method;\n   tree original = function;\n-  int nargs, parm_types_len;\n+  int nargs;\n   tree *argarray;\n   tree parm_types;\n+  VEC(tree,gc) *allocated = NULL;\n+  tree ret;\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n-  if (params != NULL_TREE)\n-    function = objc_rewrite_function_call (function, TREE_VALUE (params));\n+  if (params != NULL && !VEC_empty (tree, *params))\n+    function = objc_rewrite_function_call (function,\n+\t\t\t\t\t   VEC_index (tree, *params, 0));\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */\n@@ -2957,57 +2976,55 @@ cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n   fntype = TREE_TYPE (fntype);\n   parm_types = TYPE_ARG_TYPES (fntype);\n \n-  /* Allocate storage for converted arguments.  */\n-  parm_types_len = list_length (parm_types);\n-  nargs = list_length (params);\n-  if (parm_types_len > nargs)\n-    nargs = parm_types_len;\n-  argarray = (tree *) alloca (nargs * sizeof (tree));\n-\n-  /* Convert the parameters to the types declared in the\n-     function prototype, or apply default promotions.  */\n-  nargs = convert_arguments (nargs, argarray, parm_types,\n-\t\t\t     params, fndecl, LOOKUP_NORMAL,\n-                             complain);\n+  if (params == NULL)\n+    {\n+      allocated = make_tree_vector ();\n+      params = &allocated;\n+    }\n+\n+  nargs = convert_arguments (parm_types, params, fndecl, LOOKUP_NORMAL,\n+\t\t\t     complain);\n   if (nargs < 0)\n     return error_mark_node;\n \n+  argarray = VEC_address (tree, *params);\n+\n   /* Check for errors in format strings and inappropriately\n      null parameters.  */\n   check_function_arguments (TYPE_ATTRIBUTES (fntype), nargs, argarray,\n \t\t\t    parm_types);\n \n-  return build_cxx_call (function, nargs, argarray);\n+  ret = build_cxx_call (function, nargs, argarray);\n+\n+  if (allocated != NULL)\n+    release_tree_vector (allocated);\n+\n+  return ret;\n }\n \f\n-/* Convert the actual parameter expressions in the list VALUES\n-   to the types in the list TYPELIST.\n+/* Convert the actual parameter expressions in the list VALUES to the\n+   types in the list TYPELIST.  The converted expressions are stored\n+   back in the VALUES vector.\n    If parmdecls is exhausted, or when an element has NULL as its type,\n    perform the default conversions.\n \n-   Store the converted arguments in ARGARRAY.  NARGS is the size of this array.\n-\n    NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.\n \n    This is also where warnings about wrong number of args are generated.\n \n    Returns the actual number of arguments processed (which might be less\n-   than NARGS), or -1 on error.\n-\n-   VALUES is a chain of TREE_LIST nodes with the elements of the list\n-   in the TREE_VALUE slots of those nodes.\n+   than the length of the vector), or -1 on error.\n \n    In C++, unspecified trailing parameters can be filled in with their\n    default arguments, if such were specified.  Do so here.  */\n \n static int\n-convert_arguments (int nargs, tree *argarray,\n-\t\t   tree typelist, tree values, tree fndecl, int flags,\n-                   tsubst_flags_t complain)\n+convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n+\t\t   int flags, tsubst_flags_t complain)\n {\n-  tree typetail, valtail;\n+  tree typetail;\n   const char *called_thing = 0;\n-  int i = 0;\n+  unsigned int i;\n \n   /* Argument passing is always copy-initialization.  */\n   flags |= LOOKUP_ONLYCONVERTING;\n@@ -3026,12 +3043,12 @@ convert_arguments (int nargs, tree *argarray,\n \tcalled_thing = \"function\";\n     }\n \n-  for (valtail = values, typetail = typelist;\n-       valtail;\n-       valtail = TREE_CHAIN (valtail), i++)\n+  for (i = 0, typetail = typelist;\n+       i < VEC_length (tree, *values);\n+       i++)\n     {\n       tree type = typetail ? TREE_VALUE (typetail) : 0;\n-      tree val = TREE_VALUE (valtail);\n+      tree val = VEC_index (tree, *values, i);\n \n       if (val == error_mark_node || type == error_mark_node)\n \treturn -1;\n@@ -3100,7 +3117,7 @@ convert_arguments (int nargs, tree *argarray,\n \t  if (parmval == error_mark_node)\n \t    return -1;\n \n-\t  argarray[i] = parmval;\n+\t  VEC_replace (tree, *values, i, parmval);\n \t}\n       else\n \t{\n@@ -3113,7 +3130,7 @@ convert_arguments (int nargs, tree *argarray,\n \t  else\n \t    val = convert_arg_to_ellipsis (val);\n \n-\t  argarray[i] = val;\n+\t  VEC_replace (tree, *values, i, val);\n \t}\n \n       if (typetail)\n@@ -3142,7 +3159,7 @@ convert_arguments (int nargs, tree *argarray,\n \t      if (parmval == error_mark_node)\n \t\treturn -1;\n \n-\t      argarray[i] = parmval;\n+\t      VEC_safe_push (tree, gc, *values, parmval);\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n \t      if (typetail == NULL_TREE)\n@@ -3166,8 +3183,7 @@ convert_arguments (int nargs, tree *argarray,\n \t}\n     }\n \n-  gcc_assert (i <= nargs);\n-  return i;\n+  return (int) i;\n }\n \f\n /* Build a binary-operation expression, after performing default\n@@ -4994,6 +5010,34 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n   return expr;\n }\n \n+/* Like build_x_compound_expr_from_list, but using a VEC.  */\n+\n+tree\n+build_x_compound_expr_from_vec (VEC(tree,gc) *vec, const char *msg)\n+{\n+  if (VEC_empty (tree, vec))\n+    return NULL_TREE;\n+  else if (VEC_length (tree, vec) == 1)\n+    return VEC_index (tree, vec, 0);\n+  else\n+    {\n+      tree expr;\n+      unsigned int ix;\n+      tree t;\n+\n+      if (msg != NULL)\n+\tpermerror (input_location,\n+\t\t   \"%s expression list treated as compound expression\",\n+\t\t   msg);\n+\n+      expr = VEC_index (tree, vec, 0);\n+      for (ix = 1; VEC_iterate (tree, vec, ix, t); ++ix)\n+\texpr = build_x_compound_expr (expr, t, tf_warning_or_error);\n+\n+      return expr;\n+    }\n+}\n+\n /* Handle overloading of the ',' operator when needed.  */\n \n tree\n@@ -6038,10 +6082,11 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t/* Do the default thing.  */;\n       else\n \t{\n+\t  VEC(tree,gc) *rhs_vec = make_tree_vector_single (rhs);\n \t  result = build_special_member_call (lhs, complete_ctor_identifier,\n-\t\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t\t      lhstype, LOOKUP_NORMAL,\n+\t\t\t\t\t      &rhs_vec, lhstype, LOOKUP_NORMAL,\n                                               complain);\n+\t  release_tree_vector (rhs_vec);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n \t  return result;"}, {"sha": "e66842733a08c48563fe23369ecbaf3e637b6b2a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1442,6 +1442,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n \n   /* The type to which we are casting.  */\n   tree type;\n+  VEC(tree,gc) *parmvec;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n     return error_mark_node;\n@@ -1512,8 +1513,12 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n     }\n \n   /* Call the constructor.  */\n-  exp = build_special_member_call (NULL_TREE, complete_ctor_identifier, parms,\n-\t\t\t\t   type, LOOKUP_NORMAL, complain);\n+  parmvec = make_tree_vector ();\n+  for (; parms != NULL_TREE; parms = TREE_CHAIN (parms))\n+    VEC_safe_push (tree, gc, parmvec, TREE_VALUE (parms));\n+  exp = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t   &parmvec, type, LOOKUP_NORMAL, complain);\n+  release_tree_vector (parmvec);\n \n   if (exp == error_mark_node)\n     return error_mark_node;"}, {"sha": "f65fa9696eec6475030b54c4cb5827fee71a58da", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1,3 +1,8 @@\n+2009-05-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_generate_cxx_ctor_or_dtor): Pass NULL rather\n+\tthan NULL_TREE to build_special_member_call.\n+\n 2009-05-10  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_building_struct): New static variable."}, {"sha": "d4624bb5439d2635aa38c9b3d868ac081c08fbae", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -4538,7 +4538,7 @@ objc_generate_cxx_ctor_or_dtor (bool dtor)\n \t     (build_special_member_call\n \t      (build_ivar_reference (DECL_NAME (ivar)),\n \t       dtor ? complete_dtor_identifier : complete_ctor_identifier,\n-\t       NULL_TREE, type, LOOKUP_NORMAL, tf_warning_or_error));\n+\t       NULL, type, LOOKUP_NORMAL, tf_warning_or_error));\n \t}\n     }\n "}, {"sha": "b1ab5a5d66c5add41a55d91367d094a974dc0b3f", "filename": "gcc/tree.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -1827,6 +1827,23 @@ build_tree_list_stat (tree parm, tree value MEM_STAT_DECL)\n   return t;\n }\n \n+/* Build a chain of TREE_LIST nodes from a vector.  */\n+\n+tree\n+build_tree_list_vec_stat (const VEC(tree,gc) *vec MEM_STAT_DECL)\n+{\n+  tree ret = NULL_TREE;\n+  tree *pp = &ret;\n+  unsigned int i;\n+  tree t;\n+  for (i = 0; VEC_iterate (tree, vec, i, t); ++i)\n+    {\n+      *pp = build_tree_list_stat (NULL, t PASS_MEM_STAT);\n+      pp = &TREE_CHAIN (*pp);\n+    }\n+  return ret;\n+}\n+\n /* Return a newly created TREE_LIST node whose\n    purpose and value fields are PURPOSE and VALUE\n    and whose TREE_CHAIN is CHAIN.  */\n@@ -1870,6 +1887,22 @@ ctor_to_list (tree ctor)\n \n   return list;\n }\n+\n+/* Return the values of the elements of a CONSTRUCTOR as a vector of\n+   trees.  */\n+\n+VEC(tree,gc) *\n+ctor_to_vec (tree ctor)\n+{\n+  VEC(tree, gc) *vec = VEC_alloc (tree, gc, CONSTRUCTOR_NELTS (ctor));\n+  unsigned int ix;\n+  tree val;\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (ctor), ix, val)\n+    VEC_quick_push (tree, vec, val);\n+\n+  return vec;\n+}\n \f\n /* Return the size nominally occupied by an object of type TYPE\n    when it resides in memory.  The value is measured in units of bytes,\n@@ -3483,6 +3516,23 @@ build_nt_call_list (tree fn, tree arglist)\n     CALL_EXPR_ARG (t, i) = TREE_VALUE (arglist);\n   return t;\n }\n+\n+/* Similar to build_nt, but for creating a CALL_EXPR object with a\n+   tree VEC.  */\n+\n+tree\n+build_nt_call_vec (tree fn, VEC(tree,gc) *args)\n+{\n+  tree ret, t;\n+  unsigned int ix;\n+\n+  ret = build_vl_exp (CALL_EXPR, VEC_length (tree, args) + 3);\n+  CALL_EXPR_FN (ret) = fn;\n+  CALL_EXPR_STATIC_CHAIN (ret) = NULL_TREE;\n+  for (ix = 0; VEC_iterate (tree, args, ix, t); ++ix)\n+    CALL_EXPR_ARG (ret, ix) = t;\n+  return ret;\n+}\n \f\n /* Create a DECL_... node of code CODE, name NAME and data type TYPE.\n    We do NOT enter this node in any sort of symbol table.\n@@ -8240,7 +8290,7 @@ build_call_valist (tree return_type, tree fn, int nargs, va_list args)\n    which are specified as a tree array ARGS.  */\n \n tree\n-build_call_array (tree return_type, tree fn, int nargs, tree *args)\n+build_call_array (tree return_type, tree fn, int nargs, const tree *args)\n {\n   tree t;\n   int i;\n@@ -8255,6 +8305,24 @@ build_call_array (tree return_type, tree fn, int nargs, tree *args)\n   return t;\n }\n \n+/* Like build_call_array, but takes a VEC.  */\n+\n+tree\n+build_call_vec (tree return_type, tree fn, VEC(tree,gc) *args)\n+{\n+  tree ret, t;\n+  unsigned int ix;\n+\n+  ret = build_vl_exp (CALL_EXPR, VEC_length (tree, args) + 3);\n+  TREE_TYPE (ret) = return_type;\n+  CALL_EXPR_FN (ret) = fn;\n+  CALL_EXPR_STATIC_CHAIN (ret) = NULL_TREE;\n+  for (ix = 0; VEC_iterate (tree, args, ix, t); ++ix)\n+    CALL_EXPR_ARG (ret, ix) = t;\n+  process_call_operands (ret);\n+  return ret;\n+}\n+\n \n /* Returns true if it is possible to prove that the index of\n    an array access REF (an ARRAY_REF expression) falls into the"}, {"sha": "cdabb3ece374d3a8786c3264a5bfae7fde879927", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166b8981f366dfe1ec292221548b05e69c6c384/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c166b8981f366dfe1ec292221548b05e69c6c384", "patch": "@@ -3833,6 +3833,7 @@ extern tree maybe_get_identifier (const char *);\n \n extern tree build_nt (enum tree_code, ...);\n extern tree build_nt_call_list (tree, tree);\n+extern tree build_nt_call_vec (tree, VEC(tree,gc) *);\n \n extern tree build0_stat (enum tree_code, tree MEM_STAT_DECL);\n #define build0(c,t) build0_stat (c,t MEM_STAT_INFO)\n@@ -3870,6 +3871,8 @@ extern tree build_one_cst (tree);\n extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n #define build_tree_list(t,q) build_tree_list_stat(t,q MEM_STAT_INFO)\n+extern tree build_tree_list_vec_stat (const VEC(tree,gc) * MEM_STAT_DECL);\n+#define build_tree_list_vec(v) build_tree_list_vec_stat (v MEM_STAT_INFO)\n extern tree build_decl_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n extern tree build_fn_decl (const char *, tree);\n #define build_decl(c,t,q) build_decl_stat (c,t,q MEM_STAT_INFO)\n@@ -3883,7 +3886,8 @@ extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n extern tree build_call_list (tree, tree, tree);\n extern tree build_call_nary (tree, tree, int, ...);\n extern tree build_call_valist (tree, tree, int, va_list);\n-extern tree build_call_array (tree, tree, int, tree*);\n+extern tree build_call_array (tree, tree, int, const tree *);\n+extern tree build_call_vec (tree, tree, VEC(tree,gc) *);\n \n /* Construct various nodes representing data types.  */\n \n@@ -4310,6 +4314,10 @@ extern bool initializer_zerop (const_tree);\n \n extern tree ctor_to_list (tree);\n \n+/* Given a CONSTRUCTOR CTOR, return the element values as a vector.  */\n+\n+extern VEC(tree,gc) *ctor_to_vec (tree);\n+\n /* Examine CTOR to discover:\n    * how many scalar fields are set to nonzero values,\n      and place it in *P_NZ_ELTS;"}]}