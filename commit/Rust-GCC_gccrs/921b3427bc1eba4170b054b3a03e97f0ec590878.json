{"sha": "921b3427bc1eba4170b054b3a03e97f0ec590878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIxYjM0MjdiYzFlYmE0MTcwYjA1NGIzYTAzZTk3ZjBlYzU5MDg3OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:17:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-08-02T17:17:17Z"}, "message": "(expand_builtin, case BUILT_IN_AGGREGATE_INCOMING_ADDRESS): New case.\n\n(expand_assignment, expand_expr, emit_push_insn, store_expr):\nInsert calls to chkr_check_addr, chkr_set_right, and chkr_copy_bitmap\nwhen -fcheck-memory-usage.\n(get_push_address, get_memory_usage_from_modifier): New functions.\n\nFrom-SVN: r14611", "tree": {"sha": "dc15a800f6421764a65afdba2755303b60b6d3ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc15a800f6421764a65afdba2755303b60b6d3ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/921b3427bc1eba4170b054b3a03e97f0ec590878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921b3427bc1eba4170b054b3a03e97f0ec590878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/921b3427bc1eba4170b054b3a03e97f0ec590878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/921b3427bc1eba4170b054b3a03e97f0ec590878/comments", "author": null, "committer": null, "parents": [{"sha": "8fbea4dc1aa8cbad0c1ba09cac1654ab26f26569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbea4dc1aa8cbad0c1ba09cac1654ab26f26569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fbea4dc1aa8cbad0c1ba09cac1654ab26f26569"}], "stats": {"total": 323, "additions": 283, "deletions": 40}, "files": [{"sha": "6937437bbaf55652157a3491f96c83962714d2f8", "filename": "gcc/expr.c", "status": "modified", "additions": 283, "deletions": 40, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/921b3427bc1eba4170b054b3a03e97f0ec590878/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/921b3427bc1eba4170b054b3a03e97f0ec590878/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=921b3427bc1eba4170b054b3a03e97f0ec590878", "patch": "@@ -147,6 +147,7 @@ struct clear_by_pieces\n    as well as depth of arithmetic stack. (Notice that variables are\n    stored on the machine's stack, not the arithmetic stack.) */\n \n+static rtx get_push_address\tPROTO ((int));\n extern int local_vars_size;\n extern int stack_depth;\n extern int max_stack_depth;\n@@ -2368,6 +2369,25 @@ gen_push_operand ()\n   return gen_rtx (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n }\n \n+/* Return an rtx for the address of the beginning of a as-if-it-was-pushed\n+   block of SIZE bytes.  */\n+\n+static rtx\n+get_push_address (size)\n+\tint size;\n+{\n+  register rtx temp;\n+\n+  if (STACK_PUSH_CODE == POST_DEC)\n+    temp = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (size));\n+  else if (STACK_PUSH_CODE == POST_INC)\n+    temp = gen_rtx (MINUS, Pmode, stack_pointer_rtx, GEN_INT (size));\n+  else\n+    temp = stack_pointer_rtx;\n+\n+  return force_operand (temp, NULL_RTX);\n+}\n+\n /* Generate code to push X onto the stack, assuming it has mode MODE and\n    type TYPE.\n    MODE is redundant except when X is a CONST_INT (since they don't\n@@ -2487,6 +2507,25 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n \t  move_by_pieces (gen_rtx (MEM, BLKmode, gen_push_operand ()), xinner,\n \t\t\t  INTVAL (size) - used, align);\n+\n+\t  if (flag_check_memory_usage)\n+\t    {\n+\t      rtx temp;\n+\t      \n+\t      temp = get_push_address (INTVAL(size) - used);\n+\t      if (GET_CODE (x) == MEM && AGGREGATE_TYPE_P (type))\n+\t\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t   temp, ptr_mode,\n+\t\t\t\t   XEXP (xinner, 0), ptr_mode,\n+\t\t\t\t   GEN_INT (INTVAL(size) - used),\n+\t\t\t\t   TYPE_MODE (sizetype));\n+\t      else\n+\t\temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t   temp, ptr_mode,\n+\t\t\t \t   GEN_INT (INTVAL(size) - used),\n+\t\t\t\t   TYPE_MODE (sizetype),\n+\t\t\t\t   GEN_INT (MEMORY_USE_RW), QImode);\n+\t    }\n \t}\n       else\n #endif /* PUSH_ROUNDING */\n@@ -2522,6 +2561,22 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\t   plus_constant (gen_rtx (PLUS, Pmode,\n \t\t\t\t\t\t\t   args_addr, args_so_far),\n \t\t\t\t\t\t  skip));\n+\t  if (flag_check_memory_usage)\n+\t    {\n+\t      rtx target;\n+\t      \n+\t      target = copy_to_reg (temp);\n+\t      if (GET_CODE (x) == MEM && AGGREGATE_TYPE_P (type))\n+\t\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t   target, ptr_mode,\n+\t\t\t\t   XEXP (xinner, 0), ptr_mode,\n+\t\t\t\t   size, TYPE_MODE (sizetype));\n+\t      else\n+\t        emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t   target, ptr_mode,\n+\t\t\t \t   size, TYPE_MODE (sizetype),\n+\t\t\t\t   GEN_INT (MEMORY_USE_RW), QImode);\n+\t    }\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n \t  if (GET_CODE (size) == CONST_INT\n@@ -2687,6 +2742,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n   else\n     {\n       rtx addr;\n+      rtx target = NULL_RTX;\n \n       /* Push padding now if padding above and stack grows down,\n \t or if padding below and stack grows up.\n@@ -2700,15 +2756,38 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \taddr = gen_push_operand ();\n       else\n #endif\n-\tif (GET_CODE (args_so_far) == CONST_INT)\n-\t  addr\n-\t    = memory_address (mode,\n-\t\t\t      plus_constant (args_addr, INTVAL (args_so_far)));\n-      else\n-\taddr = memory_address (mode, gen_rtx (PLUS, Pmode, args_addr,\n-\t\t\t\t\t      args_so_far));\n+\t{\n+\t  if (GET_CODE (args_so_far) == CONST_INT)\n+\t    addr\n+\t      = memory_address (mode,\n+\t\t\t\tplus_constant (args_addr, \n+\t\t\t\t\t       INTVAL (args_so_far)));\n+          else\n+\t    addr = memory_address (mode, gen_rtx (PLUS, Pmode, args_addr,\n+\t\t\t\t\t\t  args_so_far));\n+\t  target = addr;\n+\t}\n \n       emit_move_insn (gen_rtx (MEM, mode, addr), x);\n+\n+      if (flag_check_memory_usage)\n+\t{\n+\t  if (target == 0)\n+\t    target = get_push_address (GET_MODE_SIZE (mode));\n+\n+\t  if (GET_CODE (x) == MEM && AGGREGATE_TYPE_P (type))\n+\t    emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t       target, ptr_mode,\n+\t\t\t       XEXP (x, 0), ptr_mode,\n+\t\t\t       GEN_INT (GET_MODE_SIZE (mode)),\n+\t\t\t       TYPE_MODE (sizetype));\n+\t  else\n+\t    emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n+\t\t\t       target, ptr_mode,\n+\t\t\t       GEN_INT (GET_MODE_SIZE (mode)),\n+\t\t\t       TYPE_MODE (sizetype),\n+\t\t\t       GEN_INT (MEMORY_USE_RW), QImode);\n+\t}\n     }\n \n  ret:\n@@ -2801,7 +2880,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n+      to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_DONT);\n       if (offset != 0)\n \t{\n \t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n@@ -2832,6 +2911,31 @@ expand_assignment (to, from, want_value, suggest_reg)\n #endif\n \t}\n \n+      /* Check the access.  */\n+      if (flag_check_memory_usage && GET_CODE (to_rtx) == MEM)\n+\t{\n+\t  rtx to_addr;\n+\t  int size;\n+\t  int best_mode_size;\n+\t  enum machine_mode best_mode;\n+\n+\t  best_mode = get_best_mode (bitsize, bitpos,\n+\t  \t\t\t     TYPE_ALIGN (TREE_TYPE (tem)),\n+\t  \t\t\t     mode1, volatilep);\n+\t  if (best_mode == VOIDmode)\n+\t    best_mode = QImode;\n+\n+\t  best_mode_size = GET_MODE_BITSIZE (best_mode);\n+\t  to_addr = plus_constant (XEXP (to_rtx, 0), (bitpos / BITS_PER_UNIT));\n+\t  size = CEIL ((bitpos % best_mode_size) + bitsize, best_mode_size);\n+\t  size *= GET_MODE_SIZE (best_mode);\n+\n+\t  /* Check the access right of the pointer.  */\n+\t  emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3, to_addr,\n+\t\t\t     ptr_mode, GEN_INT (size), TYPE_MODE (sizetype),\n+\t\t\t     GEN_INT (MEMORY_USE_WO), QImode);\n+\t}\n+\n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n \t\t\t    (want_value\n \t\t\t     /* Spurious cast makes HPUX compiler happy.  */\n@@ -2873,7 +2977,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       push_temp_slots ();\n       value = expand_expr (from, NULL_RTX, VOIDmode, 0);\n       if (to_rtx == 0)\n-\tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, 0);\n+\tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n \n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n@@ -2894,7 +2998,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n \n   if (to_rtx == 0)\n-    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, 0);\n+    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_WO);\n \n   /* Don't move directly into a return register.  */\n   if (TREE_CODE (to) == RESULT_DECL && GET_CODE (to_rtx) == REG)\n@@ -2921,7 +3025,17 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       push_temp_slots ();\n       size = expr_size (from);\n-      from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n+      from_rtx = expand_expr (from, NULL_RTX, VOIDmode,\n+\t\t\t      EXPAND_MEMORY_USE_DONT);\n+\n+      /* Copy the rights of the bitmap.  */\n+      if (flag_check_memory_usage)\n+\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (to_rtx, 0), ptr_mode,\n+\t\t\t   XEXP (from_rtx, 0), ptr_mode,\n+\t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n+\t\t\t\t\t    size, TREE_UNSIGNED (sizetype)),\n+\t\t\t   TYPE_MODE (sizetype));\n \n #ifdef TARGET_MEM_FUNCTIONS\n       emit_library_call (memcpy_libfunc, 0,\n@@ -3137,6 +3251,22 @@ store_expr (exp, target, want_value)\n     temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n \n+  if (flag_check_memory_usage\n+      && GET_CODE (target) == MEM\n+      && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+    {\n+      if (GET_CODE (temp) == MEM)\n+        emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (target, 0), ptr_mode,\n+\t\t\t   XEXP (temp, 0), ptr_mode,\n+\t\t\t   expr_size (exp), TYPE_MODE (sizetype));\n+      else\n+        emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (target, 0), ptr_mode, \n+\t\t\t   expr_size (exp), TYPE_MODE (sizetype),\n+\t\t\t   GEN_INT (MEMORY_USE_WO), QImode);\n+    }\n+\n   /* If value was not generated in the target, store it there.\n      Convert the value to TARGET's type first if nec.  */\n \n@@ -3220,6 +3350,12 @@ store_expr (exp, target, want_value)\n \n \t      if (size != const0_rtx)\n \t\t{\n+\t\t  /* Be sure we can write on ADDR.  */\n+\t\t  if (flag_check_memory_usage)\n+\t\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t       addr, ptr_mode,\n+\t\t\t\t       size, TYPE_MODE (sizetype),\n+ \t\t\t\t       GEN_INT (MEMORY_USE_WO), QImode);\n #ifdef TARGET_MEM_FUNCTIONS\n \t\t  emit_library_call (memset_libfunc, 0, VOIDmode, 3,\n \t\t\t\t     addr, ptr_mode,\n@@ -4260,6 +4396,33 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   *palignment = alignment / BITS_PER_UNIT;\n   return exp;\n }\n+\n+/* Subroutine of expand_exp: compute memory_usage from modifier.  */\n+static enum memory_use_mode\n+get_memory_usage_from_modifier (modifier)\n+     enum expand_modifier modifier;\n+{\n+  switch (modifier)\n+    {\n+    case EXPAND_NORMAL:\n+      return MEMORY_USE_RO;\n+      break;\n+    case EXPAND_MEMORY_USE_WO:\n+      return MEMORY_USE_WO;\n+      break;\n+    case EXPAND_MEMORY_USE_RW:\n+      return MEMORY_USE_RW;\n+      break;\n+    case EXPAND_INITIALIZER:\n+    case EXPAND_MEMORY_USE_DONT:\n+    case EXPAND_SUM:\n+    case EXPAND_CONST_ADDRESS:\n+      return MEMORY_USE_DONT;\n+    case EXPAND_MEMORY_USE_BAD:\n+    default:\n+      abort ();\n+    }\n+}\n \f\n /* Given an rtx VALUE that may contain additions and multiplications,\n    return an equivalent value that just refers to a register or memory.\n@@ -4656,7 +4819,15 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     || code == COND_EXPR)\n \t\t    && TREE_CODE (type) == VOID_TYPE));\n   tree context;\n+  /* Used by check-memory-usage to make modifier read only.  */\n+  enum expand_modifier ro_modifier;\n \n+  /* Make a read-only version of the modifier.  */\n+  if (modifier == EXPAND_NORMAL || modifier == EXPAND_SUM\n+      || modifier == EXPAND_CONST_ADDRESS || modifier == EXPAND_INITIALIZER)\n+    ro_modifier = modifier;\n+  else\n+    ro_modifier = EXPAND_NORMAL;\n \n   if (output_bytecode && modifier != EXPAND_INITIALIZER)\n     {\n@@ -4689,28 +4860,28 @@ expand_expr (exp, target, tmode, modifier)\n \t  && TREE_CODE (exp) != FUNCTION_DECL\n \t  && mode != VOIDmode && mode != BLKmode)\n \t{\n-\t  temp = expand_expr (exp, NULL_RTX, VOIDmode, modifier);\n+\t  temp = expand_expr (exp, NULL_RTX, VOIDmode, ro_modifier);\n \t  if (GET_CODE (temp) == MEM)\n \t    temp = copy_to_reg (temp);\n \t  return const0_rtx;\n \t}\n \n       if (TREE_CODE_CLASS (code) == '1')\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n-\t\t\t    VOIDmode, modifier);\n+\t\t\t    VOIDmode, ro_modifier);\n       else if (TREE_CODE_CLASS (code) == '2'\n \t       || TREE_CODE_CLASS (code) == '<')\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n \t  return const0_rtx;\n \t}\n       else if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n \t       && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \t/* If the second operand has no side effects, just evaluate\n \t   the first.  */\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n-\t\t\t    VOIDmode, modifier);\n+\t\t\t    VOIDmode, ro_modifier);\n \n       target = 0;\n     }\n@@ -4776,6 +4947,26 @@ expand_expr (exp, target, tmode, modifier)\n \t  pop_obstacks ();\n \t}\n \n+      /* Only check automatic variables.  Currently, function arguments are\n+         not checked (this can be done at compile-time with prototypes).\n+         Aggregates are not checked.  */\n+      if (flag_check_memory_usage && code == VAR_DECL\n+\t  && GET_CODE (DECL_RTL (exp)) == MEM\n+\t  && DECL_CONTEXT (exp) != NULL_TREE\n+\t  && ! TREE_STATIC (exp)\n+\t  && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+\t{\n+\t  enum memory_use_mode memory_usage;\n+\t  memory_usage = get_memory_usage_from_modifier (modifier);\n+\n+\t  if (memory_usage != MEMORY_USE_DONT)\n+\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t       XEXP (DECL_RTL (exp), 0), ptr_mode,\n+\t\t\t       GEN_INT (int_size_in_bytes (type)),\n+\t\t\t       TYPE_MODE (sizetype),\n+\t\t\t       GEN_INT (memory_usage), QImode);\n+\t}\n+\n       /* ... fall through ...  */\n \n     case FUNCTION_DECL:\n@@ -4889,7 +5080,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t mode);\n \n     case CONST_DECL:\n-      return expand_expr (DECL_INITIAL (exp), target, VOIDmode, 0);\n+      return expand_expr (DECL_INITIAL (exp), target, VOIDmode,\n+      \t\t\t  EXPAND_MEMORY_USE_BAD);\n \n     case REAL_CST:\n       /* If optimized, generate immediate CONST_DOUBLE\n@@ -4982,7 +5174,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    }\n \n \t  if (temp == const0_rtx)\n-\t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n+\t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t\t EXPAND_MEMORY_USE_BAD);\n \t  else\n \t    store_expr (TREE_OPERAND (exp, 0), temp, 0);\n \t}\n@@ -5053,7 +5246,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t In that case, we want to translate it using subsequent\n \t\t entries.  */\n \t      placeholder_list = TREE_CHAIN (placeholder_list);\n-\t      temp = expand_expr (object, original_target, tmode, modifier);\n+\t      temp = expand_expr (object, original_target, tmode, ro_modifier);\n \t      placeholder_list = old_list;\n \t      return temp;\n \t    }\n@@ -5068,7 +5261,7 @@ expand_expr (exp, target, tmode, modifier)\n       placeholder_list = tree_cons (TREE_OPERAND (exp, 1), NULL_TREE,\n \t\t\t\t    placeholder_list);\n       target = expand_expr (TREE_OPERAND (exp, 0), original_target,\n-\t\t\t    tmode, modifier);\n+\t\t\t    tmode, ro_modifier);\n       placeholder_list = TREE_CHAIN (placeholder_list);\n       return target;\n \n@@ -5112,7 +5305,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    vars = TREE_CHAIN (vars);\n \t  }\n \n-\ttemp = expand_expr (TREE_OPERAND (exp, 1), target, tmode, modifier);\n+\ttemp = expand_expr (TREE_OPERAND (exp, 1), target, tmode, ro_modifier);\n \n \texpand_end_bindings (TREE_OPERAND (exp, 0), 0, 0);\n \n@@ -5138,7 +5331,8 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  tree elt;\n \t  for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n-\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode, 0);\n+\t    expand_expr (TREE_VALUE (elt), const0_rtx, VOIDmode,\n+\t    \t\t EXPAND_MEMORY_USE_BAD);\n \t  return const0_rtx;\n \t}\n \n@@ -5207,6 +5401,19 @@ expand_expr (exp, target, tmode, modifier)\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n \n+\tif (flag_check_memory_usage && !AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+\t  {\n+\t    enum memory_use_mode memory_usage;\n+\t    memory_usage = get_memory_usage_from_modifier (modifier);\n+\n+            if (memory_usage != MEMORY_USE_DONT)\n+\t      emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t op0, ptr_mode,\n+\t\t\t\t GEN_INT (int_size_in_bytes (type)),\n+\t\t\t\t TYPE_MODE (sizetype),\n+\t\t\t\t GEN_INT (memory_usage), QImode);\n+\t  }\n+\n \ttemp = gen_rtx (MEM, mode, op0);\n \t/* If address was computed by addition,\n \t   mark this as an element of an aggregate.  */\n@@ -5286,7 +5493,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t  elem = TREE_CHAIN (elem);\n \t\tif (elem)\n \t\t  return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t      tmode, modifier);\n+\t\t\t\t      tmode, ro_modifier);\n \t      }\n \t  }\n \t  \n@@ -5309,7 +5516,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t      elem = TREE_CHAIN (elem);\n \t\t    if (elem)\n \t\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t\t  tmode, modifier);\n+\t\t\t\t\t  tmode, ro_modifier);\n \t\t  }\n \t\telse if (TREE_CODE (init) == STRING_CST\n \t\t\t && TREE_INT_CST_HIGH (index) == 0\n@@ -5438,6 +5645,29 @@ expand_expr (exp, target, tmode, modifier)\n \t    MEM_VOLATILE_P (op0) = 1;\n \t  }\n \n+\t/* Check the access.  */\n+\tif (flag_check_memory_usage && GET_CODE (op0) == MEM)\n+          {\n+\t    enum memory_use_mode memory_usage;\n+\t    memory_usage = get_memory_usage_from_modifier (modifier);\n+\n+\t    if (memory_usage != MEMORY_USE_DONT)\n+\t      {\n+\t\trtx to;\n+\t\tint size;\n+\n+\t\tto = plus_constant (XEXP (op0, 0), (bitpos / BITS_PER_UNIT));\n+\t\tsize = (bitpos % BITS_PER_UNIT) + bitsize + BITS_PER_UNIT - 1;\n+\n+        \t/* Check the access right of the pointer.  */\n+\t\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t\t   to, ptr_mode,\n+\t\t\t\t   GEN_INT (size / BITS_PER_UNIT),\n+\t\t\t\t   TYPE_MODE (sizetype),\n+\t\t\t\t   GEN_INT (memory_usage), QImode);\n+\t      }\n+\t  }\n+\n \t/* In cases where an aligned union has an unaligned object\n \t   as a field, we might be extracting a BLKmode value from\n \t   an integer-mode (e.g., SImode) object.  Handle this case\n@@ -5671,7 +5901,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (RTL_EXPR_RTL (exp) == 0)\n \t{\n \t  RTL_EXPR_RTL (exp)\n-\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n+\t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, ro_modifier);\n \t  expand_decl_cleanup (NULL_TREE, TREE_OPERAND (exp, 2));\n \n \t  /* That's it for this cleanup.  */\n@@ -5688,7 +5918,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \ttarget_temp_slot_level = temp_slot_level;\n \n-\top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), target, tmode, ro_modifier);\n \t/* If we're going to use this value, load it up now.  */\n \tif (! ignore)\n \t  op0 = force_not_mem (op0);\n@@ -5748,7 +5978,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (mode == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \t{\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode,\n-\t\t\t     modifier);\n+\t\t\t     ro_modifier);\n \n \t  /* If the signedness of the conversion differs and OP0 is\n \t     a promoted SUBREG, clear that indication since we now\n@@ -5870,8 +6100,8 @@ expand_expr (exp, target, tmode, modifier)\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n \tsubtarget = 0;\n \n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, modifier);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, ro_modifier);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, ro_modifier);\n \n     both_summands:\n       /* Make sure any term that's a sum with a constant comes last.  */\n@@ -5931,9 +6161,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  && really_constant_p (TREE_OPERAND (exp, 1)))\n \t{\n \t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX,\n-\t\t\t\t VOIDmode, modifier);\n+\t\t\t\t VOIDmode, ro_modifier);\n \t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n-\t\t\t\t VOIDmode, modifier);\n+\t\t\t\t VOIDmode, ro_modifier);\n \n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n@@ -5961,7 +6191,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\treturn expand_expr (convert (type, \n \t\t\t\t\t     build (PLUS_EXPR, newtype,\n \t\t\t\t\t\t    newop0, newneg)),\n-\t\t\t\t    target, tmode, modifier);\n+\t\t\t\t    target, tmode, ro_modifier);\n \t    }\n \t  else\n \t    {\n@@ -5991,7 +6221,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, EXPAND_SUM);\n+\t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n+\t\t\t     EXPAND_SUM);\n \n \t  /* Apply distributive law if OP0 is x+c.  */\n \t  if (GET_CODE (op0) == PLUS\n@@ -6415,11 +6646,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (ignore)\n \t      {\n \t\texpand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n-\t\t\t     modifier);\n+\t\t\t     ro_modifier);\n \t\treturn const0_rtx;\n \t      }\n \n-\t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, modifier);\n+\t    op0 = expand_expr (TREE_OPERAND (exp, 0), target, mode, ro_modifier);\n \t    if (GET_MODE (op0) == mode)\n \t      return op0;\n \n@@ -8278,7 +8509,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \tTREE_STATIC (result) = 1;\n \tresult = build (INDIRECT_REF, build_pointer_type (type), result);\n \tTREE_CONSTANT (result) = 1;\n-\treturn expand_expr (result, NULL_RTX, VOIDmode, 0);\n+\treturn expand_expr (result, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD);\n #endif\n       }\n \n@@ -8422,6 +8653,16 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  return tem;\n \t}\n \n+    /* Returns the address of the area where the structure is returned.\n+       0 otherwise.  */\n+    case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n+      if (arglist != 0\n+          || ! AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl)))\n+          || GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) != MEM)\n+        return const0_rtx;\n+      else\n+        return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n+\n     case BUILT_IN_ALLOCA:\n       if (arglist == 0\n \t  /* Arg could be non-integer if user redeclared this fcn wrong.  */\n@@ -8477,7 +8718,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \t  /* If the length is known, just return it.  */\n \t  if (len != 0)\n-\t    return expand_expr (len, target, mode, 0);\n+\t    return expand_expr (len, target, mode, EXPAND_MEMORY_USE_BAD);\n \n \t  /* If SRC is not a pointer type, don't do this operation inline.  */\n \t  if (align == 0)\n@@ -9427,7 +9668,7 @@ expand_increment (exp, post, ignore)\n      and insns were generated in computing it.   */\n \n   temp = get_last_insn ();\n-  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, 0);\n+  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_RW);\n \n   /* If OP0 is a SUBREG made for a promoted variable, we cannot increment\n      in place but instead must do sign- or zero-extension during assignment,\n@@ -9458,7 +9699,8 @@ expand_increment (exp, post, ignore)\n \n   op0_is_copy = ((GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n \t\t && temp != get_last_insn ());\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode,\n+\t\t     EXPAND_MEMORY_USE_BAD);\n \n   /* Decide whether incrementing or decrementing.  */\n   if (TREE_CODE (exp) == POSTDECREMENT_EXPR\n@@ -9574,7 +9816,8 @@ expand_increment (exp, post, ignore)\n     temp = copy_rtx (value = op0);\n \n   /* Increment however we can.  */\n-  op1 = expand_binop (mode, this_optab, value, op1, op0,\n+  op1 = expand_binop (mode, this_optab, value, op1,\n+  \t\t      flag_check_memory_usage ? NULL_RTX : op0,\n \t\t      TREE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n   /* Make sure the value is stored into OP0.  */\n   if (op1 != op0)"}]}