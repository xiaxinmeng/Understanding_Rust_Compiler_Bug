{"sha": "7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I1MmVlZGVlZGIyMjQ3YmVlMDAxOGEyZDFhODFmMDBjZWIzNTBjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-01-08T11:20:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-01-08T11:20:23Z"}, "message": "i386.md (adddi3_carry_rex64, [...]): Name pattern.\n\n\t* i386.md (adddi3_carry_rex64, subdi3_carry_rex64): Name pattern.\n\t(addhi3_carry, addqi3_carry, subhi3_carry, subqi3_carry): New patterns.\n\t(add??cc): New expanders.\n\t* i386.c (expand_int_addcc): New function.\n\t* i386-protos.h (expand_int_addcc): Declare.\n\n\t* alias.c (memory_modified_1): New static function.\n\t(memory_modified): New static varaible.\n\t(memory_modified_in_insn_p): New global function.\n\t* rtl.h (memory_modified_in_insn_p): Declare.\n\t* rtlanal.c (modified_between_p, modified_in_p): Be smart about memory\n\treferences.\n\n\t* expr.h (emit_conditional_add): Declare.\n\nFrom-SVN: r61038", "tree": {"sha": "72953eb3d0de3ae4394f101ee93b8dd54f346543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72953eb3d0de3ae4394f101ee93b8dd54f346543"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/comments", "author": null, "committer": null, "parents": [{"sha": "67d96a1661226e6f32b9e7512fe7d01befd579ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d96a1661226e6f32b9e7512fe7d01befd579ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67d96a1661226e6f32b9e7512fe7d01befd579ee"}], "stats": {"total": 230, "additions": 220, "deletions": 10}, "files": [{"sha": "bf91b4b9fa9a38a3e86f65530ba59258bc352351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -1,3 +1,20 @@\n+Wed Jan  8 12:10:57 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (adddi3_carry_rex64, subdi3_carry_rex64): Name pattern.\n+\t(addhi3_carry, addqi3_carry, subhi3_carry, subqi3_carry): New patterns.\n+\t(add??cc): New expanders.\n+\t* i386.c (expand_int_addcc): New function.\n+\t* i386-protos.h (expand_int_addcc): Declare.\n+\n+\t* alias.c (memory_modified_1): New static function.\n+\t(memory_modified): New static varaible.\n+\t(memory_modified_in_insn_p): New global function.\n+\t* rtl.h (memory_modified_in_insn_p): Declare.\n+\t* rtlanal.c (modified_between_p, modified_in_p): Be smart about memory\n+\treferences.\n+\n+\t* expr.h (emit_conditional_add): Declare.\n+\n 2003-01-07  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR other/8947"}, {"sha": "ffd4991a2c68838ef10d4e98cbf10e54032a3798", "filename": "gcc/alias.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -119,6 +119,7 @@ static int nonlocal_referenced_p_1      PARAMS ((rtx *, void *));\n static int nonlocal_referenced_p        PARAMS ((rtx));\n static int nonlocal_set_p_1             PARAMS ((rtx *, void *));\n static int nonlocal_set_p               PARAMS ((rtx));\n+static void memory_modified_1\t\tPARAMS ((rtx, rtx, void *));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -2703,6 +2704,35 @@ init_alias_once ()\n   alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);\n }\n \n+/* Set MEMORY_MODIFIED when X modifies DATA (that is assumed\n+   to be memory reference.  */\n+static bool memory_modified;\n+static void\n+memory_modified_1 (x, pat, data)\n+\trtx x, pat ATTRIBUTE_UNUSED;\n+\tvoid *data;\n+{\n+  if (GET_CODE (x) == MEM)\n+    {\n+      if (anti_dependence (x, (rtx)data) || output_dependence (x, (rtx)data))\n+\tmemory_modified = true;\n+    }\n+}\n+\n+\n+/* Return true when INSN possibly modify memory contents of MEM\n+   (ie address can be modified).  */\n+bool\n+memory_modified_in_insn_p (mem, insn)\n+     rtx mem, insn;\n+{\n+  if (!INSN_P (insn))\n+    return false;\n+  memory_modified = false;\n+  note_stores (PATTERN (insn), memory_modified_1, mem);\n+  return memory_modified;\n+}\n+\n /* Initialize the aliasing machinery.  Initialize the REG_KNOWN_VALUE\n    array.  */\n "}, {"sha": "01fc203377f819c456a9a56e341728742a7794a4", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -141,6 +141,7 @@ extern void ix86_expand_branch PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_setcc PARAMS ((enum rtx_code, rtx));\n extern int ix86_expand_int_movcc PARAMS ((rtx[]));\n extern int ix86_expand_fp_movcc PARAMS ((rtx[]));\n+extern int ix86_expand_int_addcc PARAMS ((rtx[]));\n extern void ix86_expand_call PARAMS ((rtx, rtx, rtx, rtx, rtx, int));\n extern void x86_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern rtx ix86_zero_extend_to_Pmode PARAMS ((rtx));"}, {"sha": "db361d9791604e2689a494268d6cc9c3c43f9917", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -9981,6 +9981,69 @@ ix86_expand_fp_movcc (operands)\n   return 1;\n }\n \n+/* Expand conditional increment or decrement using adb/sbb instructions.\n+   The default case using setcc followed by the conditional move can be\n+   done by generic code.  */\n+int\n+ix86_expand_int_addcc (operands)\n+     rtx operands[];\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx compare_op;\n+  rtx val = const0_rtx;\n+\n+  if (operands[3] != const1_rtx\n+      && operands[3] != constm1_rtx)\n+    return 0;\n+  if (!ix86_expand_carry_flag_compare (code, ix86_compare_op0,\n+\t\t\t\t       ix86_compare_op1, &compare_op))\n+     return 0;\n+  if (GET_CODE (compare_op) != LTU)\n+    val = operands[3] == const1_rtx ? constm1_rtx : const1_rtx;\n+  if ((GET_CODE (compare_op) == LTU) == (operands[3] == constm1_rtx))\n+    {\n+      switch (GET_MODE (operands[0]))\n+\t{\n+\t  case QImode:\n+            emit_insn (gen_subqi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case HImode:\n+            emit_insn (gen_subhi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case SImode:\n+            emit_insn (gen_subsi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case DImode:\n+            emit_insn (gen_subdi3_carry_rex64 (operands[0], operands[2], val));\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_MODE (operands[0]))\n+\t{\n+\t  case QImode:\n+            emit_insn (gen_addqi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case HImode:\n+            emit_insn (gen_addhi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case SImode:\n+            emit_insn (gen_addsi3_carry (operands[0], operands[2], val));\n+\t    break;\n+\t  case DImode:\n+            emit_insn (gen_adddi3_carry_rex64 (operands[0], operands[2], val));\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t}\n+    }\n+  return 1; /* DONE */\n+}\n+\n+\n /* Split operands 0 and 1 into SImode parts.  Similar to split_di, but\n    works for floating pointer parameters and nonoffsetable memories.\n    For pushes, it returns just stack offsets; the values will be saved"}, {"sha": "a364729301a836c91ab94fb05fd5a0b6fbd52f03", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -4951,7 +4951,7 @@\n    split_di (operands+1, 1, operands+1, operands+4);\n    split_di (operands+2, 1, operands+2, operands+5);\")\n \n-(define_insn \"*adddi3_carry_rex64\"\n+(define_insn \"adddi3_carry_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (plus:DI (plus:DI (ltu:DI (reg:CC 17) (const_int 0))\n \t\t\t    (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\"))\n@@ -4976,7 +4976,33 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"*addsi3_carry\"\n+(define_insn \"addqi3_carry\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (plus:QI (plus:QI (ltu:QI (reg:CC 17) (const_int 0))\n+\t\t\t    (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\"))\n+\t\t   (match_operand:QI 2 \"general_operand\" \"ri,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (PLUS, QImode, operands)\"\n+  \"adc{b}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"mode\" \"QI\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"addhi3_carry\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (plus:HI (plus:HI (ltu:HI (reg:CC 17) (const_int 0))\n+\t\t\t    (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\"))\n+\t\t   (match_operand:HI 2 \"general_operand\" \"ri,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"adc{w}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"mode\" \"HI\")\n+   (set_attr \"ppro_uops\" \"few\")])\n+\n+(define_insn \"addsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (plus:SI (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n \t\t\t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\"))\n@@ -6653,6 +6679,31 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"subqi3_carry\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (minus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n+\t    (plus:QI (ltu:QI (reg:CC 17) (const_int 0))\n+\t       (match_operand:QI 2 \"general_operand\" \"ri,rm\"))))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (MINUS, QImode, operands)\"\n+  \"sbb{b}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"subhi3_carry\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t  (minus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n+\t    (plus:HI (ltu:HI (reg:CC 17) (const_int 0))\n+\t       (match_operand:HI 2 \"general_operand\" \"ri,rm\"))))\n+   (clobber (reg:CC 17))]\n+  \"ix86_binary_operator_ok (MINUS, HImode, operands)\"\n+  \"sbb{w}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"pent_pair\" \"pu\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"mode\" \"HI\")])\n \n (define_insn \"subsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -16459,6 +16510,39 @@\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))])\n \n+;; Conditional addition patterns\n+(define_expand \"addqicc\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:QI 2 \"register_operand\" \"\")\n+   (match_operand:QI 3 \"const_int_operand\" \"\")]\n+  \"\"\n+  \"if (!ix86_expand_int_addcc (operands)) FAIL; DONE;\")\n+\n+(define_expand \"addhicc\"\n+  [(match_operand:HI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:HI 2 \"register_operand\" \"\")\n+   (match_operand:HI 3 \"const_int_operand\" \"\")]\n+  \"\"\n+  \"if (!ix86_expand_int_addcc (operands)) FAIL; DONE;\")\n+\n+(define_expand \"addsicc\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:SI 2 \"register_operand\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"\"\n+  \"if (!ix86_expand_int_addcc (operands)) FAIL; DONE;\")\n+\n+(define_expand \"adddicc\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand 1 \"comparison_operator\" \"\")\n+   (match_operand:DI 2 \"register_operand\" \"\")\n+   (match_operand:DI 3 \"const_int_operand\" \"\")]\n+  \"TARGET_64BIT\"\n+  \"if (!ix86_expand_int_addcc (operands)) FAIL; DONE;\")\n+\n ;; We can't represent the LT test directly.  Do this by swapping the operands.\n \n (define_split"}, {"sha": "7fe3c1be071f86c96377f5009f74f942840ac3b2", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -307,6 +307,9 @@ rtx emit_conditional_move PARAMS ((rtx, enum rtx_code, rtx, rtx,\n int can_conditionally_move_p PARAMS ((enum machine_mode mode));\n \n #endif\n+rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx,\n+\t\t\t  enum machine_mode, rtx, rtx,\n+\t\t\t  enum machine_mode, int);\n \n \f\n /* Functions from expmed.c:  */"}, {"sha": "a2c7514a8989bf26a4031b9eb7a9853660d080f8", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -2251,6 +2251,7 @@ extern void init_alias_once\t\tPARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n+extern bool memory_modified_in_insn_p\tPARAMS ((rtx, rtx));\n \n /* In sibcall.c */\n typedef enum {"}, {"sha": "63d7feb60351cb60da46fd0e1c9fe47433a392fc", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b52eedeedb2247bee0018a2d1a81f00ceb350c0/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=7b52eedeedb2247bee0018a2d1a81f00ceb350c0", "patch": "@@ -1037,7 +1037,7 @@ regs_set_between_p (x, start, end)\n \n /* Similar to reg_set_between_p, but check all registers in X.  Return 0\n    only if none of them are modified between START and END.  Return 1 if\n-   X contains a MEM; this routine does not perform any memory aliasing.  */\n+   X contains a MEM; this routine does usememory aliasing.  */\n \n int\n modified_between_p (x, start, end)\n@@ -1047,6 +1047,10 @@ modified_between_p (x, start, end)\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n   int i, j;\n+  rtx insn;\n+\n+  if (start == end)\n+    return 0;\n \n   switch (code)\n     {\n@@ -1063,10 +1067,14 @@ modified_between_p (x, start, end)\n       return 1;\n \n     case MEM:\n-      /* If the memory is not constant, assume it is modified.  If it is\n-\t constant, we still have to check the address.  */\n-      if (! RTX_UNCHANGING_P (x))\n+      if (RTX_UNCHANGING_P (x))\n+\treturn 0;\n+      if (modified_between_p (XEXP (x, 0), start, end))\n \treturn 1;\n+      for (insn = NEXT_INSN (start); insn != end; insn = NEXT_INSN (insn))\n+\tif (memory_modified_in_insn_p (x, insn))\n+\t  return 1;\n+      return 0;\n       break;\n \n     case REG:\n@@ -1093,7 +1101,7 @@ modified_between_p (x, start, end)\n \n /* Similar to reg_set_p, but check all registers in X.  Return 0 only if none\n    of them are modified in INSN.  Return 1 if X contains a MEM; this routine\n-   does not perform any memory aliasing.  */\n+   does use memory aliasing.  */\n \n int\n modified_in_p (x, insn)\n@@ -1119,10 +1127,13 @@ modified_in_p (x, insn)\n       return 1;\n \n     case MEM:\n-      /* If the memory is not constant, assume it is modified.  If it is\n-\t constant, we still have to check the address.  */\n-      if (! RTX_UNCHANGING_P (x))\n+      if (RTX_UNCHANGING_P (x))\n+\treturn 0;\n+      if (modified_in_p (XEXP (x, 0), insn))\n \treturn 1;\n+      if (memory_modified_in_insn_p (x, insn))\n+\treturn 1;\n+      return 0;\n       break;\n \n     case REG:"}]}