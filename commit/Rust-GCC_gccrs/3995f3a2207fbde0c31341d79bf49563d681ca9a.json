{"sha": "3995f3a2207fbde0c31341d79bf49563d681ca9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5NWYzYTIyMDdmYmRlMGMzMTM0MWQ3OWJmNDk1NjNkNjgxY2E5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-04T18:55:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-04T18:55:08Z"}, "message": "i386.c (make_resolver_func): Update.\n\n2017-05-23  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* config/i386/i386.c (make_resolver_func): Update.\n\t* Makefile.in: Add profile-count.h and profile-count.o\n\t* auto-profile.c (afdo_indirect_call): Update to new API.\n\t(afdo_set_bb_count): Update.\n\t(afdo_propagate_edge): Update.\n\t(afdo_propagate_circuit): Update.\n\t(afdo_calculate_branch_prob): Update.\n\t(afdo_annotate_cfg): Update.\n\t* basic-block.h: Include profile-count.h\n\t(struct edge_def): Turn count to profile_count.\n\t(struct basic_block_def): Likewie.\n\t(REG_BR_PROB_BASE): Move to profile-count.h\n\t(RDIV): Move to profile-count.h\n\t* bb-reorder.c (max_entry_count): Turn to profile_count.\n\t(find_traces): Update.\n\t(rotate_loop):Update.\n\t(connect_traces):Update.\n\t(sanitize_hot_paths):Update.\n\t* bt-load.c (migrate_btr_defs): Update.\n\t* cfg.c (RDIV): Remove.\n\t(init_flow): Use alloc_block.\n\t(alloc_block): Uninitialize count.\n\t(unchecked_make_edge): Uninitialize count.\n\t(check_bb_profile): Update.\n\t(dump_edge_info): Update.\n\t(dump_bb_info): Update.\n\t(update_bb_profile_for_threading): Update.\n\t(scale_bbs_frequencies_int): Update.\n\t(scale_bbs_frequencies_gcov_type): Update.\n\t(scale_bbs_frequencies_profile_count): New.\n\t* cfg.h (update_bb_profile_for_threading): Update.\n\t(scale_bbs_frequencies_profile_count): Declare.\n\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n\t(find_many_sub_basic_blocks): Update.\n\t* cfgcleanup.c (try_forward_edges): Update.\n\t(try_crossjump_to_edge): Update.\n\t* cfgexpand.c (expand_gimple_tailcall): Update.\n\t(construct_exit_block): Update.\n\t* cfghooks.c (verify_flow_info): Update.\n\t(dump_bb_for_graph): Update.\n\t(split_edge): Update.\n\t(make_forwarder_block): Update.\n\t(duplicate_block): Update.\n\t(account_profile_record): Update.\n\t* cfgloop.c (find_subloop_latch_edge_by_profile): Update.\n\t(get_estimated_loop_iterations): Update.\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): Update.\n\t(single_likely_exit): Update.\n\t* cfgloopmanip.c (scale_loop_profile): Update.\n\t(loopify): Update.\n\t(set_zero_probability): Update.\n\t(lv_adjust_loop_entry_edge): Update.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Update.\n\t(purge_dead_edges): Update.\n\t(rtl_account_profile_record): Update.\n\t* cgraph.c (cgraph_node::create): Uninitialize count.\n\t(symbol_table::create_edge): Uninitialize count.\n\t(cgraph_update_edges_for_call_stmt_node): Update.\n\t(cgraph_edge::dump_edge_flags): Update.\n\t(cgraph_node::dump): Update.\n\t(cgraph_edge::maybe_hot_p): Update.\n\t* cgraph.h: Include profile-count.h\n\t(create_clone), create_edge, create_indirect_edge): Update.\n\t(cgraph_node): Turn count to profile_count.\n\t(cgraph_edge0: Likewise.\n\t(make_speculative, clone): Update.\n\t(create_edge): Update.\n\t(init_lowered_empty_function): Update.\n\t* cgraphclones.c (cgraph_edge::clone): Update.\n\t(duplicate_thunk_for_node): Update.\n\t(cgraph_node::create_clone): Update.\n\t* cgraphunit.c (cgraph_node::analyze): Update.\n\t(cgraph_node::expand_thunk): Update.\n\t* final.c (dump_basic_block_info): Update.\n\t* gimple-streamer-in.c (input_bb): Update.\n\t* gimple-streamer-out.c (output_bb): Update.\n\t* graphite.c (print_global_statistics): Update.\n\t(print_graphite_scop_statistics): Update.\n\t* hsa-brig.c: Include basic-block.h.\n\t* hsa-dump.c: Include basic-block.h.\n\t* hsa-gen.c (T sum_slice): Update.\n\t(convert_switch_statements):Update.\n\t* hsa-regalloc.c: Include basic-block.h.\n\t* ipa-chkp.c (chkp_produce_thunks): Update.\n\t* ipa-cp.c (struct caller_statistics): Update.\n\t(init_caller_stats): Update.\n\t(gather_caller_stats): Update.\n\t(ipcp_cloning_candidate_p): Update.\n\t(good_cloning_opportunity_p): Update.\n\t(get_info_about_necessary_edges): Update.\n\t(dump_profile_updates): Update.\n\t(update_profiling_info): Update.\n\t(update_specialized_profile): Update.\n\t(perhaps_add_new_callers): Update.\n\t(decide_about_value): Update.\n\t(ipa_cp_c_finalize): Update.\n\t* ipa-devirt.c (struct odr_type_warn_count): Update.\n\t(struct decl_warn_count): Update.\n\t(struct final_warning_record): Update.\n\t(possible_polymorphic_call_targets): Update.\n\t(ipa_devirt): Update.\n\t* ipa-fnsummary.c (redirect_to_unreachable): Update.\n\t* ipa-icf.c (sem_function::merge): Update.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Update.\n\t* ipa-inline.c (compute_uninlined_call_time): Update.\n\t(compute_inlined_call_time): Update.\n\t(want_inline_small_function_p): Update.\n\t(want_inline_self_recursive_call_p): Update.\n\t(edge_badness): Update.\n\t(lookup_recursive_calls): Update.\n\t(recursive_inlining): Update.\n\t(inline_small_functions): Update.\n\t(dump_overall_stats): Update.\n\t(dump_inline_stats): Update.\n\t* ipa-profile.c (ipa_profile_generate_summary): Update.\n\t(ipa_propagate_frequency): Update.\n\t(ipa_profile): Update.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n\t* ipa-utils.c (ipa_merge_profiles): Update.\n\t* loop-doloop.c (doloop_modify): Update.\n\t* loop-unroll.c (report_unroll): Update.\n\t(unroll_loop_runtime_iterations): Update.\n\t* lto-cgraph.c (lto_output_edge): Update.\n\t(lto_output_node): Update.\n\t(input_node): Update.\n\t(input_edge): Update.\n\t(merge_profile_summaries): Update.\n\t* lto-streamer-in.c (input_cfg): Update.\n\t* lto-streamer-out.c (output_cfg): Update.\n\t* mcf.c (create_fixup_graph): Update.\n\t(adjust_cfg_counts): Update.\n\t(sum_edge_counts): Update.\n\t* modulo-sched.c (sms_schedule): Update.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Update.\n\t* predict.c (maybe_hot_count_p): Update.\n\t(probably_never_executed): Update.\n\t(dump_prediction): Update.\n\t(combine_predictions_for_bb): Update.\n\t(propagate_freq): Update.\n\t(handle_missing_profiles): Update.\n\t(counts_to_freqs): Update.\n\t(rebuild_frequencies): Update.\n\t(force_edge_cold): Update.\n\t* predict.h: Include profile-count.h\n\t(maybe_hot_count_p, counts_to_freqs): UPdate.\n\t* print-rtl-function.c: Do not include cfg.h\n\t* print-rtl.c: Include basic-block.h\n\t* profile-count.c: New file.\n\t* profile-count.h: New file.\n\t* profile.c (is_edge_inconsistent): Update.\n\t(correct_negative_edge_counts): Update.\n\t(is_inconsistent): Update.\n\t(set_bb_counts): Update.\n\t(read_profile_edge_counts): Update.\n\t(compute_frequency_overlap): Update.\n\t(compute_branch_probabilities): Update; Initialize and deinitialize\n\tgcov_count tables.\n\t(branch_prob): Update.\n\t* profile.h (bb_gcov_counts, edge_gcov_counts): New.\n\t(edge_gcov_count): New.\n\t(bb_gcov_count): New.\n\t* shrink-wrap.c (try_shrink_wrapping): Update.\n\t* tracer.c (better_p): Update.\n\t* trans-mem.c (expand_transaction): Update.\n\t(ipa_tm_insert_irr_call): Update.\n\t(ipa_tm_insert_gettmclone_call): Update.\n\t* tree-call-cdce.c: Update.\n\t* tree-cfg.c (gimple_duplicate_sese_region): Update.\n\t(gimple_duplicate_sese_tail): Update.\n\t(gimple_account_profile_record): Update.\n\t(execute_fixup_cfg): Update.\n\t* tree-inline.c (copy_bb): Update.\n\t(copy_edges_for_bb): Update.\n\t(initialize_cfun): Update.\n\t(freqs_to_counts): Update.\n\t(copy_cfg_body): Update.\n\t(expand_call_inline): Update.\n\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n\t* tree-ssa-loop-ivcanon.c (unloop_loops): Update.\n\t(try_unroll_loop_completely): Update.\n\t(try_peel_loop): Update.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop): Update.\n\t* tree-ssa-loop-split.c (connect_loops): Update.\n\t* tree-ssa-loop-unswitch.c (hoist_guard): Update.\n\t* tree-ssa-reassoc.c (branch_fixup): Update.\n\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n\t* tree-ssa-threadupdate.c (create_block_for_threading): Update.\n\t(compute_path_counts): Update.\n\t(update_profile): Update.\n\t(recompute_probabilities): Update.\n\t(update_joiner_offpath_counts): Update.\n\t(estimated_freqs_path): Update.\n\t(freqs_to_counts_path): Update.\n\t(clear_counts_path): Update.\n\t(ssa_fix_duplicate_block_edges): Update.\n\t(duplicate_thread_path): Update.\n\t* tree-switch-conversion.c (case_bit_test_cmp): Update.\n\t(struct switch_conv_info): Update.\n\t* tree-tailcall.c (decrease_profile): Update.\n\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n\t* value-prof.c (check_counter): Update.\n\t(gimple_divmod_fixed_value): Update.\n\t(gimple_mod_pow2): Update.\n\t(gimple_mod_subtract): Update.\n\t(gimple_ic_transform): Update.\n\t(gimple_stringop_fixed_value): Update.\n\t* value-prof.h (gimple_ic): Update.\n\n\t* gcc.dg/tree-ssa/attr-hotcold-2.c: Update template.\n\nFrom-SVN: r248863", "tree": {"sha": "51458cb1039eb15cb224e5b7de48d9e17703b737", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51458cb1039eb15cb224e5b7de48d9e17703b737"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3995f3a2207fbde0c31341d79bf49563d681ca9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3995f3a2207fbde0c31341d79bf49563d681ca9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3995f3a2207fbde0c31341d79bf49563d681ca9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3995f3a2207fbde0c31341d79bf49563d681ca9a/comments", "author": null, "committer": null, "parents": [{"sha": "a7e8f816bd09adc24013b5fd3a43128778f6581b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e8f816bd09adc24013b5fd3a43128778f6581b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e8f816bd09adc24013b5fd3a43128778f6581b"}], "stats": {"total": 2415, "additions": 1578, "deletions": 837}, "files": [{"sha": "037168e20c61e648880971921dfec714c7583919", "filename": "gcc/ChangeLog", "status": "modified", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1,3 +1,215 @@\n+2017-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* config/i386/i386.c (make_resolver_func): Update.\n+\t* Makefile.in: Add profile-count.h and profile-count.o\n+\t* auto-profile.c (afdo_indirect_call): Update to new API.\n+\t(afdo_set_bb_count): Update.\n+\t(afdo_propagate_edge): Update.\n+\t(afdo_propagate_circuit): Update.\n+\t(afdo_calculate_branch_prob): Update.\n+\t(afdo_annotate_cfg): Update.\n+\t* basic-block.h: Include profile-count.h\n+\t(struct edge_def): Turn count to profile_count.\n+\t(struct basic_block_def): Likewie.\n+\t(REG_BR_PROB_BASE): Move to profile-count.h\n+\t(RDIV): Move to profile-count.h\n+\t* bb-reorder.c (max_entry_count): Turn to profile_count.\n+\t(find_traces): Update.\n+\t(rotate_loop):Update.\n+\t(connect_traces):Update.\n+\t(sanitize_hot_paths):Update.\n+\t* bt-load.c (migrate_btr_defs): Update.\n+\t* cfg.c (RDIV): Remove.\n+\t(init_flow): Use alloc_block.\n+\t(alloc_block): Uninitialize count.\n+\t(unchecked_make_edge): Uninitialize count.\n+\t(check_bb_profile): Update.\n+\t(dump_edge_info): Update.\n+\t(dump_bb_info): Update.\n+\t(update_bb_profile_for_threading): Update.\n+\t(scale_bbs_frequencies_int): Update.\n+\t(scale_bbs_frequencies_gcov_type): Update.\n+\t(scale_bbs_frequencies_profile_count): New.\n+\t* cfg.h (update_bb_profile_for_threading): Update.\n+\t(scale_bbs_frequencies_profile_count): Declare.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Update.\n+\t(find_many_sub_basic_blocks): Update.\n+\t* cfgcleanup.c (try_forward_edges): Update.\n+\t(try_crossjump_to_edge): Update.\n+\t* cfgexpand.c (expand_gimple_tailcall): Update.\n+\t(construct_exit_block): Update.\n+\t* cfghooks.c (verify_flow_info): Update.\n+\t(dump_bb_for_graph): Update.\n+\t(split_edge): Update.\n+\t(make_forwarder_block): Update.\n+\t(duplicate_block): Update.\n+\t(account_profile_record): Update.\n+\t* cfgloop.c (find_subloop_latch_edge_by_profile): Update.\n+\t(get_estimated_loop_iterations): Update.\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): Update.\n+\t(single_likely_exit): Update.\n+\t* cfgloopmanip.c (scale_loop_profile): Update.\n+\t(loopify): Update.\n+\t(set_zero_probability): Update.\n+\t(lv_adjust_loop_entry_edge): Update.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Update.\n+\t(purge_dead_edges): Update.\n+\t(rtl_account_profile_record): Update.\n+\t* cgraph.c (cgraph_node::create): Uninitialize count.\n+\t(symbol_table::create_edge): Uninitialize count.\n+\t(cgraph_update_edges_for_call_stmt_node): Update.\n+\t(cgraph_edge::dump_edge_flags): Update.\n+\t(cgraph_node::dump): Update.\n+\t(cgraph_edge::maybe_hot_p): Update.\n+\t* cgraph.h: Include profile-count.h\n+\t(create_clone), create_edge, create_indirect_edge): Update.\n+\t(cgraph_node): Turn count to profile_count.\n+\t(cgraph_edge0: Likewise.\n+\t(make_speculative, clone): Update.\n+\t(create_edge): Update.\n+\t(init_lowered_empty_function): Update.\n+\t* cgraphclones.c (cgraph_edge::clone): Update.\n+\t(duplicate_thunk_for_node): Update.\n+\t(cgraph_node::create_clone): Update.\n+\t* cgraphunit.c (cgraph_node::analyze): Update.\n+\t(cgraph_node::expand_thunk): Update.\n+\t* final.c (dump_basic_block_info): Update.\n+\t* gimple-streamer-in.c (input_bb): Update.\n+\t* gimple-streamer-out.c (output_bb): Update.\n+\t* graphite.c (print_global_statistics): Update.\n+\t(print_graphite_scop_statistics): Update.\n+\t* hsa-brig.c: Include basic-block.h.\n+\t* hsa-dump.c: Include basic-block.h.\n+\t* hsa-gen.c (T sum_slice): Update.\n+\t(convert_switch_statements):Update.\n+\t* hsa-regalloc.c: Include basic-block.h.\n+\t* ipa-chkp.c (chkp_produce_thunks): Update.\n+\t* ipa-cp.c (struct caller_statistics): Update.\n+\t(init_caller_stats): Update.\n+\t(gather_caller_stats): Update.\n+\t(ipcp_cloning_candidate_p): Update.\n+\t(good_cloning_opportunity_p): Update.\n+\t(get_info_about_necessary_edges): Update.\n+\t(dump_profile_updates): Update.\n+\t(update_profiling_info): Update.\n+\t(update_specialized_profile): Update.\n+\t(perhaps_add_new_callers): Update.\n+\t(decide_about_value): Update.\n+\t(ipa_cp_c_finalize): Update.\n+\t* ipa-devirt.c (struct odr_type_warn_count): Update.\n+\t(struct decl_warn_count): Update.\n+\t(struct final_warning_record): Update.\n+\t(possible_polymorphic_call_targets): Update.\n+\t(ipa_devirt): Update.\n+\t* ipa-fnsummary.c (redirect_to_unreachable): Update.\n+\t* ipa-icf.c (sem_function::merge): Update.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Update.\n+\t* ipa-inline.c (compute_uninlined_call_time): Update.\n+\t(compute_inlined_call_time): Update.\n+\t(want_inline_small_function_p): Update.\n+\t(want_inline_self_recursive_call_p): Update.\n+\t(edge_badness): Update.\n+\t(lookup_recursive_calls): Update.\n+\t(recursive_inlining): Update.\n+\t(inline_small_functions): Update.\n+\t(dump_overall_stats): Update.\n+\t(dump_inline_stats): Update.\n+\t* ipa-profile.c (ipa_profile_generate_summary): Update.\n+\t(ipa_propagate_frequency): Update.\n+\t(ipa_profile): Update.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n+\t* ipa-utils.c (ipa_merge_profiles): Update.\n+\t* loop-doloop.c (doloop_modify): Update.\n+\t* loop-unroll.c (report_unroll): Update.\n+\t(unroll_loop_runtime_iterations): Update.\n+\t* lto-cgraph.c (lto_output_edge): Update.\n+\t(lto_output_node): Update.\n+\t(input_node): Update.\n+\t(input_edge): Update.\n+\t(merge_profile_summaries): Update.\n+\t* lto-streamer-in.c (input_cfg): Update.\n+\t* lto-streamer-out.c (output_cfg): Update.\n+\t* mcf.c (create_fixup_graph): Update.\n+\t(adjust_cfg_counts): Update.\n+\t(sum_edge_counts): Update.\n+\t* modulo-sched.c (sms_schedule): Update.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Update.\n+\t* predict.c (maybe_hot_count_p): Update.\n+\t(probably_never_executed): Update.\n+\t(dump_prediction): Update.\n+\t(combine_predictions_for_bb): Update.\n+\t(propagate_freq): Update.\n+\t(handle_missing_profiles): Update.\n+\t(counts_to_freqs): Update.\n+\t(rebuild_frequencies): Update.\n+\t(force_edge_cold): Update.\n+\t* predict.h: Include profile-count.h\n+\t(maybe_hot_count_p, counts_to_freqs): UPdate.\n+\t* print-rtl-function.c: Do not include cfg.h\n+\t* print-rtl.c: Include basic-block.h\n+\t* profile-count.c: New file.\n+\t* profile-count.h: New file.\n+\t* profile.c (is_edge_inconsistent): Update.\n+\t(correct_negative_edge_counts): Update.\n+\t(is_inconsistent): Update.\n+\t(set_bb_counts): Update.\n+\t(read_profile_edge_counts): Update.\n+\t(compute_frequency_overlap): Update.\n+\t(compute_branch_probabilities): Update; Initialize and deinitialize\n+\tgcov_count tables.\n+\t(branch_prob): Update.\n+\t* profile.h (bb_gcov_counts, edge_gcov_counts): New.\n+\t(edge_gcov_count): New.\n+\t(bb_gcov_count): New.\n+\t* shrink-wrap.c (try_shrink_wrapping): Update.\n+\t* tracer.c (better_p): Update.\n+\t* trans-mem.c (expand_transaction): Update.\n+\t(ipa_tm_insert_irr_call): Update.\n+\t(ipa_tm_insert_gettmclone_call): Update.\n+\t* tree-call-cdce.c: Update.\n+\t* tree-cfg.c (gimple_duplicate_sese_region): Update.\n+\t(gimple_duplicate_sese_tail): Update.\n+\t(gimple_account_profile_record): Update.\n+\t(execute_fixup_cfg): Update.\n+\t* tree-inline.c (copy_bb): Update.\n+\t(copy_edges_for_bb): Update.\n+\t(initialize_cfun): Update.\n+\t(freqs_to_counts): Update.\n+\t(copy_cfg_body): Update.\n+\t(expand_call_inline): Update.\n+\t* tree-ssa-ifcombine.c (update_profile_after_ifcombine): Update.\n+\t* tree-ssa-loop-ivcanon.c (unloop_loops): Update.\n+\t(try_unroll_loop_completely): Update.\n+\t(try_peel_loop): Update.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop): Update.\n+\t* tree-ssa-loop-niter.c (estimate_numbers_of_iterations_loop): Update.\n+\t* tree-ssa-loop-split.c (connect_loops): Update.\n+\t* tree-ssa-loop-unswitch.c (hoist_guard): Update.\n+\t* tree-ssa-reassoc.c (branch_fixup): Update.\n+\t* tree-ssa-tail-merge.c (replace_block_by): Update.\n+\t* tree-ssa-threadupdate.c (create_block_for_threading): Update.\n+\t(compute_path_counts): Update.\n+\t(update_profile): Update.\n+\t(recompute_probabilities): Update.\n+\t(update_joiner_offpath_counts): Update.\n+\t(estimated_freqs_path): Update.\n+\t(freqs_to_counts_path): Update.\n+\t(clear_counts_path): Update.\n+\t(ssa_fix_duplicate_block_edges): Update.\n+\t(duplicate_thread_path): Update.\n+\t* tree-switch-conversion.c (case_bit_test_cmp): Update.\n+\t(struct switch_conv_info): Update.\n+\t* tree-tailcall.c (decrease_profile): Update.\n+\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Update.\n+\t* tree-vect-loop.c (scale_profile_for_vect_loop): Update.\n+\t* value-prof.c (check_counter): Update.\n+\t(gimple_divmod_fixed_value): Update.\n+\t(gimple_mod_pow2): Update.\n+\t(gimple_mod_subtract): Update.\n+\t(gimple_ic_transform): Update.\n+\t(gimple_stringop_fixed_value): Update.\n+\t* value-prof.h (gimple_ic): Update.\n+\n 2017-06-02  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c: Add support for built-in functions"}, {"sha": "da98c8e864a374c032b750912dfd93fbaa0ce603", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -928,7 +928,7 @@ TREE_CORE_H = tree-core.h coretypes.h all-tree.def tree.def \\\n TREE_H = tree.h $(TREE_CORE_H)  tree-check.h\n REGSET_H = regset.h $(BITMAP_H) hard-reg-set.h\n BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n-\tcfg-flags.def cfghooks.h\n+\tcfg-flags.def cfghooks.h profile-count.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def $(VEC_H) \\\n \t$(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n \ttree-ssa-alias.h $(INTERNAL_FN_H) $(HASH_TABLE_H) is-a.h\n@@ -1417,6 +1417,7 @@ OBJS = \\\n \tprint-rtl-function.o \\\n \tprint-tree.o \\\n \tprofile.o \\\n+\tprofile-count.o \\\n \tread-md.o \\\n \tread-rtl.o \\\n \tread-rtl-function.o \\\n@@ -2459,7 +2460,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n-  $(srcdir)/output.h $(srcdir)/cfgloop.h $(srcdir)/cfg.h \\\n+  $(srcdir)/output.h $(srcdir)/cfgloop.h $(srcdir)/cfg.h $(srcdir)/profile-count.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\"}, {"sha": "973d7af37ff17f433e7bb8f44e14c37a6636b6a7", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1058,8 +1058,10 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  /* FIXME: Count should be initialized.  */\n   struct cgraph_edge *new_edge\n-      = indirect_edge->make_speculative (direct_call, 0, 0);\n+      = indirect_edge->make_speculative (direct_call,\n+\t\t\t\t\t profile_count::uninitialized (), 0);\n   new_edge->redirect_call_stmt_to_callee ();\n   gimple_remove_histogram_value (cfun, stmt, hist);\n   inline_call (new_edge, true, NULL, NULL, false);\n@@ -1149,7 +1151,7 @@ afdo_set_bb_count (basic_block bb, const stmt_set &promoted)\n   FOR_EACH_EDGE (e, ei, bb->succs)\n   afdo_source_profile->mark_annotated (e->goto_locus);\n \n-  bb->count = max_count;\n+  bb->count = profile_count::from_gcov_type (max_count);\n   return true;\n }\n \n@@ -1226,7 +1228,7 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n     edge e, unknown_edge = NULL;\n     edge_iterator ei;\n     int num_unknown_edge = 0;\n-    gcov_type total_known_count = 0;\n+    profile_count total_known_count = profile_count::zero ();\n \n     FOR_EACH_EDGE (e, ei, is_succ ? bb->succs : bb->preds)\n       if (!is_edge_annotated (e, *annotated_edge))\n@@ -1249,10 +1251,7 @@ afdo_propagate_edge (bool is_succ, bb_set *annotated_bb,\n       }\n     else if (num_unknown_edge == 1 && is_bb_annotated (bb, *annotated_bb))\n       {\n-        if (bb->count >= total_known_count)\n-          unknown_edge->count = bb->count - total_known_count;\n-        else\n-          unknown_edge->count = 0;\n+        unknown_edge->count = bb->count - total_known_count;\n         set_edge_annotated (unknown_edge, annotated_edge);\n         changed = true;\n       }\n@@ -1350,7 +1349,7 @@ afdo_propagate_circuit (const bb_set &annotated_bb, edge_set *annotated_edge)\n           if (e->probability == 0 && !is_edge_annotated (ep, *annotated_edge))\n             {\n               ep->probability = 0;\n-              ep->count = 0;\n+              ep->count = profile_count::zero ();\n               set_edge_annotated (ep, annotated_edge);\n             }\n         }\n@@ -1404,7 +1403,7 @@ afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n \n   FOR_EACH_BB_FN (bb, cfun)\n   {\n-    if (bb->count > 0)\n+    if (bb->count > profile_count::zero ())\n       {\n \thas_sample = true;\n \tbreak;\n@@ -1426,7 +1425,7 @@ afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n     edge e;\n     edge_iterator ei;\n     int num_unknown_succ = 0;\n-    gcov_type total_count = 0;\n+    profile_count total_count = profile_count::zero ();\n \n     FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -1435,10 +1434,10 @@ afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n       else\n         total_count += e->count;\n     }\n-    if (num_unknown_succ == 0 && total_count > 0)\n+    if (num_unknown_succ == 0 && total_count > profile_count::zero ())\n       {\n         FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->probability = (double)e->count * REG_BR_PROB_BASE / total_count;\n+        e->probability = e->count.probability_in (total_count);\n       }\n   }\n   FOR_ALL_BB_FN (bb, cfun)\n@@ -1447,7 +1446,7 @@ afdo_calculate_branch_prob (bb_set *annotated_bb, edge_set *annotated_edge)\n     edge_iterator ei;\n \n     FOR_EACH_EDGE (e, ei, bb->succs)\n-      e->count = (double)bb->count * e->probability / REG_BR_PROB_BASE;\n+      e->count = bb->count.apply_probability (e->probability);\n     bb->aux = NULL;\n   }\n \n@@ -1536,18 +1535,20 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n \n   if (s == NULL)\n     return;\n-  cgraph_node::get (current_function_decl)->count = s->head_count ();\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = s->head_count ();\n-  gcov_type max_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+  cgraph_node::get (current_function_decl)->count\n+     = profile_count::from_gcov_type (s->head_count ());\n+  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count\n+     = profile_count::from_gcov_type (s->head_count ());\n+  profile_count max_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n   FOR_EACH_BB_FN (bb, cfun)\n   {\n     edge e;\n     edge_iterator ei;\n \n-    bb->count = 0;\n+    bb->count = profile_count::uninitialized ();\n     FOR_EACH_EDGE (e, ei, bb->succs)\n-      e->count = 0;\n+      e->count = profile_count::uninitialized ();\n \n     if (afdo_set_bb_count (bb, promoted_stmts))\n       set_bb_annotated (bb, &annotated_bb);\n@@ -1572,7 +1573,7 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n       DECL_SOURCE_LOCATION (current_function_decl));\n   afdo_source_profile->mark_annotated (cfun->function_start_locus);\n   afdo_source_profile->mark_annotated (cfun->function_end_locus);\n-  if (max_count > 0)\n+  if (max_count > profile_count::zero ())\n     {\n       afdo_calculate_branch_prob (&annotated_bb, &annotated_edge);\n       counts_to_freqs ();\n@@ -1721,7 +1722,7 @@ afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)\n       /* At early inline stage, profile_info is not set yet. We need to\n          temporarily set it to afdo_profile_info to calculate hotness.  */\n       profile_info = autofdo::afdo_profile_info;\n-      is_hot = maybe_hot_count_p (NULL, count);\n+      is_hot = maybe_hot_count_p (NULL, profile_count::from_gcov_type (count));\n       profile_info = saved_profile_info;\n       return is_hot;\n     }"}, {"sha": "b08a14a151b17c89cce3e4a88657e79858d9da1a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -20,12 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_BASIC_BLOCK_H\n #define GCC_BASIC_BLOCK_H\n \n-\n-/* Use gcov_type to hold basic block counters.  Should be at least\n-   64bit.  Although a counter cannot be negative, we use a signed\n-   type, because erroneous negative counts can be generated when the\n-   flow graph is manipulated by various optimizations.  A signed type\n-   makes those easy to detect.  */\n+#include <profile-count.h>\n \n /* Control flow edge information.  */\n struct GTY((user)) edge_def {\n@@ -51,7 +46,7 @@ struct GTY((user)) edge_def {\n \n   int flags;\t\t\t/* see cfg-flags.def */\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n-  gcov_type count;\t\t/* Expected number of executions calculated\n+  profile_count count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n };\n \n@@ -150,7 +145,7 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n   int index;\n \n   /* Expected number of executions: calculated in profile.c.  */\n-  gcov_type count;\n+  profile_count count;\n \n   /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n   int frequency;\n@@ -278,9 +273,6 @@ enum cfg_bb_flags\n /* The two blocks that are always in the cfg.  */\n #define NUM_FIXED_BLOCKS (2)\n \n-/* The base value for branch probability notes and edge probabilities.  */\n-#define REG_BR_PROB_BASE  10000\n-\n /* This is the value which indicates no edge is present.  */\n #define EDGE_INDEX_NO_EDGE\t-1\n \n@@ -307,7 +299,6 @@ enum cfg_bb_flags\n #define BRANCH_EDGE(bb)\t\t\t(EDGE_SUCC ((bb), 0)->flags & EDGE_FALLTHRU \\\n \t\t\t\t\t ? EDGE_SUCC ((bb), 1) : EDGE_SUCC ((bb), 0))\n \n-#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n /* Return expected execution frequency of the edge E.  */\n #define EDGE_FREQUENCY(e)\t\tRDIV ((e)->src->frequency * (e)->probability, \\\n \t\t\t\t\t      REG_BR_PROB_BASE)"}, {"sha": "c0386f4b37a504822a4f97afe715faa00ef1c02b", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -196,7 +196,7 @@ struct trace\n \n /* Maximum frequency and count of one of the entry blocks.  */\n static int max_entry_frequency;\n-static gcov_type max_entry_count;\n+static profile_count max_entry_count;\n \n /* Local function prototypes.  */\n static void find_traces (int *, struct trace *);\n@@ -286,14 +286,14 @@ find_traces (int *n_traces, struct trace *traces)\n \n   /* Insert entry points of function into heap.  */\n   max_entry_frequency = 0;\n-  max_entry_count = 0;\n+  max_entry_count = profile_count::zero ();\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       bbd[e->dest->index].heap = heap;\n       bbd[e->dest->index].node = heap->insert (bb_to_key (e->dest), e->dest);\n       if (e->dest->frequency > max_entry_frequency)\n \tmax_entry_frequency = e->dest->frequency;\n-      if (e->dest->count > max_entry_count)\n+      if (e->dest->count.initialized_p () && e->dest->count > max_entry_count)\n \tmax_entry_count = e->dest->count;\n     }\n \n@@ -306,9 +306,9 @@ find_traces (int *n_traces, struct trace *traces)\n \tfprintf (dump_file, \"STC - round %d\\n\", i + 1);\n \n       if (max_entry_count < INT_MAX / 1000)\n-\tcount_threshold = max_entry_count * exec_threshold[i] / 1000;\n+\tcount_threshold = max_entry_count.to_gcov_type () * exec_threshold[i] / 1000;\n       else\n-\tcount_threshold = max_entry_count / 1000 * exec_threshold[i];\n+\tcount_threshold = max_entry_count.to_gcov_type () / 1000 * exec_threshold[i];\n \n       find_traces_1_round (REG_BR_PROB_BASE * branch_threshold[i] / 1000,\n \t\t\t   max_entry_frequency * exec_threshold[i] / 1000,\n@@ -346,7 +346,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n   basic_block best_bb = NULL;\n   edge best_edge = NULL;\n   int best_freq = -1;\n-  gcov_type best_count = -1;\n+  profile_count best_count = profile_count::uninitialized ();\n   /* The best edge is preferred when its destination is not visited yet\n      or is a start block of some trace.  */\n   bool is_preferred = false;\n@@ -375,7 +375,8 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t  if (freq > best_freq || e->count > best_count)\n \t\t    {\n \t\t      best_freq = freq;\n-\t\t      best_count = e->count;\n+\t\t      if (e->count.initialized_p ())\n+\t\t        best_count = e->count;\n \t\t      best_edge = e;\n \t\t      best_bb = bb;\n \t\t    }\n@@ -1068,10 +1069,10 @@ connect_traces (int n_traces, struct trace *traces)\n   bool for_size = optimize_function_for_size_p (cfun);\n \n   freq_threshold = max_entry_frequency * DUPLICATION_THRESHOLD / 1000;\n-  if (max_entry_count < INT_MAX / 1000)\n-    count_threshold = max_entry_count * DUPLICATION_THRESHOLD / 1000;\n+  if (max_entry_count.to_gcov_type () < INT_MAX / 1000)\n+    count_threshold = max_entry_count.to_gcov_type () * DUPLICATION_THRESHOLD / 1000;\n   else\n-    count_threshold = max_entry_count / 1000 * DUPLICATION_THRESHOLD;\n+    count_threshold = max_entry_count.to_gcov_type () / 1000 * DUPLICATION_THRESHOLD;\n \n   connected = XCNEWVEC (bool, n_traces);\n   last_trace = -1;\n@@ -1495,7 +1496,7 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n       edge_iterator ei;\n       int highest_probability = 0;\n       int highest_freq = 0;\n-      gcov_type highest_count = 0;\n+      profile_count highest_count = profile_count::uninitialized ();\n       bool found = false;\n \n       /* Walk the preds/succs and check if there is at least one already\n@@ -1540,7 +1541,7 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n           /* Select the hottest edge using the edge count, if it is non-zero,\n              then fallback to the edge frequency and finally the edge\n              probability.  */\n-          if (highest_count)\n+          if (highest_count > 0)\n             {\n               if (e->count < highest_count)\n                 continue;"}, {"sha": "1da0ad62f1e5f24184709abe46502ec2f7d9ac5a", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1391,10 +1391,10 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n       for (i = NUM_FIXED_BLOCKS; i < last_basic_block_for_fn (cfun); i++)\n \t{\n \t  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-\t  fprintf (dump_file,\n-\t\t   \"Basic block %d: count = %\" PRId64\n-\t\t   \" loop-depth = %d idom = %d\\n\",\n-\t\t   i, (int64_t) bb->count, bb_loop_depth (bb),\n+\t  fprintf (dump_file, \"Basic block %d: count = \", i);\n+\t  bb->count.dump (dump_file);\n+\t  fprintf (dump_file, \" loop-depth = %d idom = %d\\n\",\n+\t\t   bb_loop_depth (bb),\n \t\t   get_immediate_dominator (CDI_DOMINATORS, bb)->index);\n \t}\n     }"}, {"sha": "3cbe684b743a53a4d047aef4decb1e88a797dff9", "filename": "gcc/cfg.c", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -59,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n \n \f\n-#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n /* Called once at initialization time.  */\n \n@@ -70,10 +69,10 @@ init_flow (struct function *the_fun)\n     the_fun->cfg = ggc_cleared_alloc<control_flow_graph> ();\n   n_edges_for_fn (the_fun) = 0;\n   ENTRY_BLOCK_PTR_FOR_FN (the_fun)\n-    = ggc_cleared_alloc<basic_block_def> ();\n+    = alloc_block ();\n   ENTRY_BLOCK_PTR_FOR_FN (the_fun)->index = ENTRY_BLOCK;\n   EXIT_BLOCK_PTR_FOR_FN (the_fun)\n-    = ggc_cleared_alloc<basic_block_def> ();\n+    = alloc_block ();\n   EXIT_BLOCK_PTR_FOR_FN (the_fun)->index = EXIT_BLOCK;\n   ENTRY_BLOCK_PTR_FOR_FN (the_fun)->next_bb\n     = EXIT_BLOCK_PTR_FOR_FN (the_fun);\n@@ -123,6 +122,7 @@ alloc_block (void)\n {\n   basic_block bb;\n   bb = ggc_cleared_alloc<basic_block_def> ();\n+  bb->count = profile_count::uninitialized ();\n   return bb;\n }\n \n@@ -263,6 +263,7 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n   e = ggc_cleared_alloc<edge_def> ();\n   n_edges_for_fn (cfun)++;\n \n+  e->count = profile_count::uninitialized ();\n   e->src = src;\n   e->dest = dst;\n   e->flags = flags;\n@@ -400,7 +401,6 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n {\n   edge e;\n   int sum = 0;\n-  gcov_type lsum;\n   edge_iterator ei;\n   struct function *fun = DECL_STRUCT_FUNCTION (current_function_decl);\n   char *s_indent = (char *) alloca ((size_t) indent + 1);\n@@ -428,14 +428,18 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n \t    fprintf (file,\n \t\t     \";; %sInvalid sum of outgoing probabilities %.1f%%\\n\",\n \t\t     s_indent, sum * 100.0 / REG_BR_PROB_BASE);\n-\t  lsum = 0;\n+\t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    lsum += e->count;\n-\t  if (EDGE_COUNT (bb->succs)\n-\t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n-\t    fprintf (file,\n-\t\t     \";; %sInvalid sum of outgoing counts %i, should be %i\\n\",\n-\t\t     s_indent, (int) lsum, (int) bb->count);\n+\t  if (EDGE_COUNT (bb->succs) && lsum.differs_from_p (bb->count))\n+\t    {\n+\t      fprintf (file, \";; %sInvalid sum of outgoing counts \",\n+\t\t       s_indent);\n+\t      lsum.dump (file);\n+\t      fprintf (file, \", should be \");\n+\t      bb->count.dump (file);\n+\t      fprintf (file, \"\\n\");\n+\t    }\n \t}\n     }\n     if (bb != ENTRY_BLOCK_PTR_FOR_FN (fun))\n@@ -447,12 +451,18 @@ check_bb_profile (basic_block bb, FILE * file, int indent)\n \tfprintf (file,\n \t\t \";; %sInvalid sum of incoming frequencies %i, should be %i\\n\",\n \t\t s_indent, sum, bb->frequency);\n-      lsum = 0;\n+      profile_count lsum = profile_count::zero ();\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tlsum += e->count;\n-      if (lsum - bb->count > 100 || lsum - bb->count < -100)\n-\tfprintf (file, \";; %sInvalid sum of incoming counts %i, should be %i\\n\",\n-\t\t s_indent, (int) lsum, (int) bb->count);\n+      if (lsum.differs_from_p (bb->count))\n+\t{\n+\t  fprintf (file, \";; %sInvalid sum of incoming counts \",\n+\t\t   s_indent);\n+\t  lsum.dump (file);\n+\t  fprintf (file, \", should be \");\n+\t  bb->count.dump (file);\n+\t  fprintf (file, \"\\n\");\n+\t}\n     }\n   if (BB_PARTITION (bb) == BB_COLD_PARTITION)\n     {\n@@ -491,10 +501,10 @@ dump_edge_info (FILE *file, edge e, dump_flags_t flags, int do_succ)\n   if (e->probability && do_details)\n     fprintf (file, \" [%.1f%%] \", e->probability * 100.0 / REG_BR_PROB_BASE);\n \n-  if (e->count && do_details)\n+  if (e->count.initialized_p () && do_details)\n     {\n       fputs (\" count:\", file);\n-      fprintf (file, \"%\" PRId64, e->count);\n+      e->count.dump (file);\n     }\n \n   if (e->flags && do_details)\n@@ -741,8 +751,11 @@ dump_bb_info (FILE *outf, basic_block bb, int indent, dump_flags_t flags,\n       if (flags & TDF_DETAILS)\n \t{\n \t  struct function *fun = DECL_STRUCT_FUNCTION (current_function_decl);\n-\t  fprintf (outf, \", count \" \"%\" PRId64,\n-\t\t   (int64_t) bb->count);\n+\t  if (bb->count.initialized_p ())\n+\t    {\n+\t      fputs (\", count \", outf);\n+\t      bb->count.dump (outf);\n+\t    }\n \t  fprintf (outf, \", freq %i\", bb->frequency);\n \t  if (maybe_hot_bb_p (fun, bb))\n \t    fputs (\", maybe hot\", outf);\n@@ -844,20 +857,19 @@ brief_dump_cfg (FILE *file, dump_flags_t flags)\n    respectively.  */\n void\n update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n-\t\t\t\t gcov_type count, edge taken_edge)\n+\t\t\t\t profile_count count, edge taken_edge)\n {\n   edge c;\n   int prob;\n   edge_iterator ei;\n \n-  bb->count -= count;\n-  if (bb->count < 0)\n+  if (bb->count < count)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"bb %i count became negative after threading\",\n \t\t bb->index);\n-      bb->count = 0;\n     }\n+  bb->count -= count;\n \n   bb->frequency -= edge_frequency;\n   if (bb->frequency < 0)\n@@ -913,14 +925,13 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n     }\n \n   gcc_assert (bb == taken_edge->src);\n-  taken_edge->count -= count;\n-  if (taken_edge->count < 0)\n+  if (taken_edge->count < count)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"edge %i->%i count became negative after threading\",\n \t\t taken_edge->src->index, taken_edge->dest->index);\n-      taken_edge->count = 0;\n     }\n+  taken_edge->count -= count;\n }\n \n /* Multiply all frequencies of basic blocks in array BBS of length NBBS\n@@ -954,9 +965,9 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n       /* Make sure the frequencies do not grow over BB_FREQ_MAX.  */\n       if (bbs[i]->frequency > BB_FREQ_MAX)\n \tbbs[i]->frequency = BB_FREQ_MAX;\n-      bbs[i]->count = RDIV (bbs[i]->count * num, den);\n+      bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n       FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\te->count = RDIV (e->count * num, den);\n+\te->count = e->count.apply_scale (num, den);\n     }\n }\n \n@@ -983,14 +994,14 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n \tedge_iterator ei;\n \tbbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n \tif (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n-\t  bbs[i]->count = RDIV (bbs[i]->count * num, den);\n+\t  bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n \telse\n-\t  bbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);\n+\t  bbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n \tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n \t  if (bbs[i]->count <= MAX_SAFE_MULTIPLIER)\n-\t    e->count = RDIV (e->count * num, den);\n+\t    e->count =  e->count.apply_scale (num, den);\n \t  else\n-\t    e->count = RDIV (e->count * fraction, 65536);\n+\t    e->count = e->count.apply_scale (fraction, 65536);\n       }\n    else\n     for (i = 0; i < nbbs; i++)\n@@ -1000,12 +1011,33 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n \t  bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n \telse\n \t  bbs[i]->frequency = RDIV (bbs[i]->frequency * fraction, 65536);\n-\tbbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);\n+\tbbs[i]->count = bbs[i]->count.apply_scale (fraction, 65536);\n \tFOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\t  e->count = RDIV (e->count * fraction, 65536);\n+\t  e->count = e->count.apply_scale (fraction, 65536);\n       }\n }\n \n+/* Multiply all frequencies of basic blocks in array BBS of length NBBS\n+   by NUM/DEN, in profile_count arithmetic.  More accurate than previous\n+   function but considerably slower.  */\n+void\n+scale_bbs_frequencies_profile_count (basic_block *bbs, int nbbs,\n+\t\t\t\t     profile_count num, profile_count den)\n+{\n+  int i;\n+  edge e;\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      edge_iterator ei;\n+      bbs[i]->frequency = RDIV (bbs[i]->frequency * num.to_gcov_type (),\n+\t\t\t\tden.to_gcov_type ());\n+      bbs[i]->count = bbs[i]->count.apply_scale (num, den);\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\te->count =  e->count.apply_scale (num, den);\n+    }\n+}\n+\n /* Helper types for hash tables.  */\n \n struct htab_bb_copy_original_entry"}, {"sha": "365a580a0db822dc4acf8518ca23ebfeeab2d434", "filename": "gcc/cfg.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -103,10 +103,12 @@ extern void debug_bb (basic_block);\n extern basic_block debug_bb_n (int);\n extern void dump_bb_info (FILE *, basic_block, int, dump_flags_t, bool, bool);\n extern void brief_dump_cfg (FILE *, dump_flags_t);\n-extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n+extern void update_bb_profile_for_threading (basic_block, int, profile_count, edge);\n extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n \t\t\t\t\t     gcov_type);\n+extern void scale_bbs_frequencies_profile_count (basic_block *, int,\n+\t\t\t\t\t     profile_count, profile_count);\n extern void initialize_original_copy_tables (void);\n extern void reset_original_copy_tables (void);\n extern void free_original_copy_tables (void);"}, {"sha": "a4004f87e939e33c5999dee9c7a0fcb05a0479b2", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -542,7 +542,7 @@ compute_outgoing_frequencies (basic_block b)\n \t  probability = XINT (note, 0);\n \t  e = BRANCH_EDGE (b);\n \t  e->probability = probability;\n-\t  e->count = apply_probability (b->count, probability);\n+\t  e->count = b->count.apply_probability (probability);\n \t  f = FALLTHRU_EDGE (b);\n \t  f->probability = REG_BR_PROB_BASE - probability;\n \t  f->count = b->count - e->count;\n@@ -577,9 +577,9 @@ compute_outgoing_frequencies (basic_block b)\n         guess_outgoing_edge_probabilities (b);\n     }\n \n-  if (b->count)\n+  if (b->count > profile_count::zero ())\n     FOR_EACH_EDGE (e, ei, b->succs)\n-      e->count = apply_probability (b->count, e->probability);\n+      e->count = b->count.apply_probability (e->probability);\n }\n \n /* Assume that some pass has inserted labels or control flow\n@@ -624,7 +624,7 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \t  continue;\n \tif (STATE (bb) == BLOCK_NEW)\n \t  {\n-\t    bb->count = 0;\n+\t    bb->count = profile_count::zero ();\n \t    bb->frequency = 0;\n \t    FOR_EACH_EDGE (e, ei, bb->preds)\n \t      {"}, {"sha": "1201148fa88d728019e0768424d878365b26d19b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -558,7 +558,7 @@ try_forward_edges (int mode, basic_block b)\n       else\n \t{\n \t  /* Save the values now, as the edge may get removed.  */\n-\t  gcov_type edge_count = e->count;\n+\t  profile_count edge_count = e->count;\n \t  int edge_probability = e->probability;\n \t  int edge_frequency;\n \t  int n = 0;\n@@ -603,8 +603,6 @@ try_forward_edges (int mode, basic_block b)\n \t      else\n \t\t{\n \t\t  first->count -= edge_count;\n-\t\t  if (first->count < 0)\n-\t\t    first->count = 0;\n \t\t  first->frequency -= edge_frequency;\n \t\t  if (first->frequency < 0)\n \t\t    first->frequency = 0;\n@@ -619,8 +617,6 @@ try_forward_edges (int mode, basic_block b)\n \t\t}\n \n \t      t->count -= edge_count;\n-\t      if (t->count < 0)\n-\t\tt->count = 0;\n \t      first = t->dest;\n \t    }\n \t  while (first != target);\n@@ -2146,14 +2142,10 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n       if (FORWARDER_BLOCK_P (s2->dest))\n \t{\n \t  single_succ_edge (s2->dest)->count -= s2->count;\n-\t  if (single_succ_edge (s2->dest)->count < 0)\n-\t    single_succ_edge (s2->dest)->count = 0;\n \t  s2->dest->count -= s2->count;\n \t  s2->dest->frequency -= EDGE_FREQUENCY (s);\n \t  if (s2->dest->frequency < 0)\n \t    s2->dest->frequency = 0;\n-\t  if (s2->dest->count < 0)\n-\t    s2->dest->count = 0;\n \t}\n \n       if (!redirect_edges_to->frequency && !src1->frequency)"}, {"sha": "3261fce8843c62f80efaf4b0529bdd77ea3e40be", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -3783,7 +3783,6 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n   edge e;\n   edge_iterator ei;\n   int probability;\n-  gcov_type count;\n \n   last2 = last = expand_gimple_stmt (stmt);\n \n@@ -3809,7 +3808,7 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n      the exit block.  */\n \n   probability = 0;\n-  count = 0;\n+  profile_count count = profile_count::zero ();\n \n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n@@ -3819,8 +3818,6 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n \t    {\n \t      e->dest->count -= e->count;\n \t      e->dest->frequency -= EDGE_FREQUENCY (e);\n-\t      if (e->dest->count < 0)\n-\t\te->dest->count = 0;\n \t      if (e->dest->frequency < 0)\n \t\te->dest->frequency = 0;\n \t    }\n@@ -5931,10 +5928,6 @@ construct_exit_block (void)\n \texit_block->count -= e2->count;\n \texit_block->frequency -= EDGE_FREQUENCY (e2);\n       }\n-  if (e->count < 0)\n-    e->count = 0;\n-  if (exit_block->count < 0)\n-    exit_block->count = 0;\n   if (exit_block->frequency < 0)\n     exit_block->frequency = 0;\n   update_bb_for_insn (exit_block);"}, {"sha": "1b3f2695b3905780c623bc60963dd394d7c9a91f", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -141,10 +141,9 @@ verify_flow_info (void)\n \t  err = 1;\n \t}\n \n-      if (bb->count < 0)\n+      if (!bb->count.verify ())\n \t{\n-\t  error (\"verify_flow_info: Wrong count of block %i %i\",\n-\t\t bb->index, (int)bb->count);\n+\t  error (\"verify_flow_info: Wrong count of block %i\", bb->index);\n \t  err = 1;\n \t}\n       if (bb->frequency < 0)\n@@ -167,10 +166,10 @@ verify_flow_info (void)\n \t\t     e->src->index, e->dest->index, e->probability);\n \t      err = 1;\n \t    }\n-\t  if (e->count < 0)\n+\t  if (!e->count.verify ())\n \t    {\n-\t      error (\"verify_flow_info: Wrong count of edge %i->%i %i\",\n-\t\t     e->src->index, e->dest->index, (int)e->count);\n+\t      error (\"verify_flow_info: Wrong count of edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n \t      err = 1;\n \t    }\n \n@@ -309,8 +308,9 @@ dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n   if (!cfg_hooks->dump_bb_for_graph)\n     internal_error (\"%s does not support dump_bb_for_graph\",\n \t\t    cfg_hooks->name);\n-  if (bb->count)\n-    pp_printf (pp, \"COUNT:\" \"%\" PRId64, bb->count);\n+  /* TODO: Add pretty printer for counter.  */\n+  if (bb->count.initialized_p ())\n+    pp_printf (pp, \"COUNT:\" \"%\" PRId64, bb->count.to_gcov_type ());\n   pp_printf (pp, \" FREQ:%i |\", bb->frequency);\n   pp_write_text_to_stream (pp);\n   if (!(dump_flags & TDF_SLIM))\n@@ -624,7 +624,7 @@ basic_block\n split_edge (edge e)\n {\n   basic_block ret;\n-  gcov_type count = e->count;\n+  profile_count count = e->count;\n   int freq = EDGE_FREQUENCY (e);\n   edge f;\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n@@ -868,9 +868,9 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \n   fallthru = split_block_after_labels (bb);\n   dummy = fallthru->src;\n-  dummy->count = 0;\n+  dummy->count = profile_count::zero ();\n   dummy->frequency = 0;\n-  fallthru->count = 0;\n+  fallthru->count = profile_count::zero ();\n   bb = fallthru->dest;\n \n   /* Redirect back edges we want to keep.  */\n@@ -1071,7 +1071,7 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n {\n   edge s, n;\n   basic_block new_bb;\n-  gcov_type new_count = e ? e->count : 0;\n+  profile_count new_count = e ? e->count : profile_count::uninitialized ();\n   edge_iterator ei;\n \n   if (!cfg_hooks->duplicate_block)\n@@ -1095,10 +1095,9 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n \t is no need to actually check for duplicated edges.  */\n       n = unchecked_make_edge (new_bb, s->dest, s->flags);\n       n->probability = s->probability;\n-      if (e && bb->count)\n+      if (e && bb->count > profile_count::zero ())\n \t{\n-\t  /* Take care for overflows!  */\n-\t  n->count = s->count * (new_count * 10000 / bb->count) / 10000;\n+\t  n->count = s->count.apply_scale (new_count, bb->count);\n \t  s->count -= n->count;\n \t}\n       else\n@@ -1116,8 +1115,6 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n \n       redirect_edge_and_branch_force (e, new_bb);\n \n-      if (bb->count < 0)\n-\tbb->count = 0;\n       if (bb->frequency < 0)\n \tbb->frequency = 0;\n     }\n@@ -1448,7 +1445,6 @@ account_profile_record (struct profile_record *record, int after_pass)\n   edge_iterator ei;\n   edge e;\n   int sum;\n-  gcov_type lsum;\n \n   FOR_ALL_BB_FN (bb, cfun)\n    {\n@@ -1460,11 +1456,10 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t    sum += e->probability;\n \t  if (EDGE_COUNT (bb->succs) && abs (sum - REG_BR_PROB_BASE) > 100)\n \t    record->num_mismatched_freq_out[after_pass]++;\n-\t  lsum = 0;\n+\t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    lsum += e->count;\n-\t  if (EDGE_COUNT (bb->succs)\n-\t      && (lsum - bb->count > 100 || lsum - bb->count < -100))\n+\t  if (EDGE_COUNT (bb->succs) && (lsum.differs_from_p (bb->count)))\n \t    record->num_mismatched_count_out[after_pass]++;\n \t}\n       if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n@@ -1477,10 +1472,10 @@ account_profile_record (struct profile_record *record, int after_pass)\n \t      || (MAX (sum, bb->frequency) > 10\n \t\t  && abs ((sum - bb->frequency) * 100 / (MAX (sum, bb->frequency) + 1)) > 10))\n \t    record->num_mismatched_freq_in[after_pass]++;\n-\t  lsum = 0;\n+\t  profile_count lsum = profile_count::zero ();\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    lsum += e->count;\n-\t  if (lsum - bb->count > 100 || lsum - bb->count < -100)\n+\t  if (lsum.differs_from_p (bb->count))\n \t    record->num_mismatched_count_in[after_pass]++;\n \t}\n       if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)"}, {"sha": "a1e778b85865569f813b28be414bca24ff13cf1c", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -543,7 +543,7 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n {\n   unsigned i;\n   edge e, me = NULL;\n-  gcov_type mcount = 0, tcount = 0;\n+  profile_count mcount = profile_count::zero (), tcount = profile_count::zero ();\n \n   FOR_EACH_VEC_ELT (latches, i, e)\n     {\n@@ -555,8 +555,8 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n       tcount += e->count;\n     }\n \n-  if (tcount < HEAVY_EDGE_MIN_SAMPLES\n-      || (tcount - mcount) * HEAVY_EDGE_RATIO > tcount)\n+  if (!tcount.initialized_p () || tcount < HEAVY_EDGE_MIN_SAMPLES\n+      || (tcount - mcount).apply_scale (HEAVY_EDGE_RATIO, 1) > tcount)\n     return NULL;\n \n   if (dump_file)\n@@ -1899,7 +1899,7 @@ get_estimated_loop_iterations (struct loop *loop, widest_int *nit)\n      profile.  */\n   if (!loop->any_estimate)\n     {\n-      if (loop->header->count)\n+      if (loop->header->count.reliable_p ())\n \t{\n           *nit = gcov_type_to_wide_int\n \t\t   (expected_loop_iterations_unbounded (loop) + 1);"}, {"sha": "a9537637115c280cb686b3b986bf3b3a5d08e8b0", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -237,37 +237,39 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n {\n   edge e;\n   edge_iterator ei;\n-  gcov_type expected;\n+  gcov_type expected = -1;\n   \n   if (read_profile_p)\n     *read_profile_p = false;\n \n   /* If we have no profile at all, use AVG_LOOP_NITER.  */\n   if (profile_status_for_fn (cfun) == PROFILE_ABSENT)\n     expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n-  else if (loop->latch && (loop->latch->count || loop->header->count))\n+  else if (loop->latch && (loop->latch->count.reliable_p ()\n+\t\t\t   || loop->header->count.reliable_p ()))\n     {\n-      gcov_type count_in, count_latch;\n-\n-      count_in = 0;\n-      count_latch = 0;\n+      profile_count count_in = profile_count::zero (),\n+\t\t    count_latch = profile_count::zero ();\n \n       FOR_EACH_EDGE (e, ei, loop->header->preds)\n \tif (e->src == loop->latch)\n \t  count_latch = e->count;\n \telse\n \t  count_in += e->count;\n \n-      if (count_in == 0)\n-\texpected = count_latch * 2;\n+      if (!count_latch.initialized_p ())\n+\t;\n+      else if (!(count_in > profile_count::zero ()))\n+\texpected = count_latch.to_gcov_type () * 2;\n       else\n \t{\n-\t  expected = (count_latch + count_in - 1) / count_in;\n+\t  expected = (count_latch.to_gcov_type () + count_in.to_gcov_type ()\n+\t\t      - 1) / count_in.to_gcov_type ();\n \t  if (read_profile_p)\n \t    *read_profile_p = true;\n \t}\n     }\n-  else\n+  if (expected == -1)\n     {\n       int freq_in, freq_latch;\n \n@@ -472,9 +474,11 @@ single_likely_exit (struct loop *loop)\n       /* The constant of 5 is set in a way so noreturn calls are\n \t ruled out by this test.  The static branch prediction algorithm\n          will not assign such a low probability to conditionals for usual\n-         reasons.  */\n-      if (profile_status_for_fn (cfun) != PROFILE_ABSENT\n-\t  && ex->probability < 5 && !ex->count)\n+         reasons.\n+\t FIXME: Turn to likely_never_executed  */\n+      if ((profile_status_for_fn (cfun) != PROFILE_ABSENT\n+\t   && ex->probability < 5)\n+\t  || ex->count == profile_count::zero ())\n \tcontinue;\n       if (!found)\n \tfound = ex;"}, {"sha": "d764ab9a8c7d83e9857b32508b199b2a0ec1958a", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -533,7 +533,7 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \t{\n \t  edge other_e;\n \t  int freq_delta;\n-\t  gcov_type count_delta;\n+\t  profile_count count_delta;\n \n           FOR_EACH_EDGE (other_e, ei, e->src->succs)\n \t    if (!(other_e->flags & (EDGE_ABNORMAL | EDGE_FAKE))\n@@ -548,8 +548,8 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \n \t  /* Adjust counts accordingly.  */\n \t  count_delta = e->count;\n-\t  e->count = apply_probability (e->src->count, e->probability);\n-\t  other_e->count = apply_probability (e->src->count, other_e->probability);\n+\t  e->count = e->src->count.apply_probability (e->probability);\n+\t  other_e->count = e->src->count.apply_probability (other_e->probability);\n \t  count_delta -= e->count;\n \n \t  /* If latch exists, change its frequency and count, since we changed\n@@ -562,28 +562,32 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \t      if (loop->latch->frequency < 0)\n \t\tloop->latch->frequency = 0;\n \t      loop->latch->count += count_delta;\n-\t      if (loop->latch->count < 0)\n-\t\tloop->latch->count = 0;\n \t    }\n \t}\n \n       /* Roughly speaking we want to reduce the loop body profile by the\n \t difference of loop iterations.  We however can do better if\n \t we look at the actual profile, if it is available.  */\n       scale = RDIV (iteration_bound * scale, iterations);\n-      if (loop->header->count)\n+\n+      bool determined = false;\n+      if (loop->header->count.initialized_p ())\n \t{\n-\t  gcov_type count_in = 0;\n+\t  profile_count count_in = profile_count::zero ();\n \n \t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n \t    if (e->src != loop->latch)\n \t      count_in += e->count;\n \n-\t  if (count_in != 0)\n-\t    scale = GCOV_COMPUTE_SCALE (count_in * iteration_bound,\n-                                        loop->header->count);\n+\t  if (count_in > profile_count::zero () )\n+\t    {\n+\t      scale = GCOV_COMPUTE_SCALE (count_in.to_gcov_type ()\n+\t\t\t\t\t  * iteration_bound,\n+                                          loop->header->count.to_gcov_type ());\n+\t      determined = true;\n+\t    }\n \t}\n-      else if (loop->header->frequency)\n+      if (!determined)\n \t{\n \t  int freq_in = 0;\n \n@@ -864,7 +868,7 @@ loopify (edge latch_edge, edge header_edge,\n   struct loop *loop = alloc_loop ();\n   struct loop *outer = loop_outer (succ_bb->loop_father);\n   int freq;\n-  gcov_type cnt;\n+  profile_count cnt;\n   edge e;\n   edge_iterator ei;\n \n@@ -907,7 +911,7 @@ loopify (edge latch_edge, edge header_edge,\n       switch_bb->count = cnt;\n       FOR_EACH_EDGE (e, ei, switch_bb->succs)\n \t{\n-\t  e->count = apply_probability (switch_bb->count, e->probability);\n+\t  e->count = switch_bb->count.apply_probability (e->probability);\n \t}\n     }\n   scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);\n@@ -1107,11 +1111,11 @@ set_zero_probability (edge e)\n   edge_iterator ei;\n   edge ae, last = NULL;\n   unsigned n = EDGE_COUNT (bb->succs);\n-  gcov_type cnt = e->count, cnt1;\n+  profile_count cnt = e->count, cnt1;\n   unsigned prob = e->probability, prob1;\n \n   gcc_assert (n > 1);\n-  cnt1 = cnt / (n - 1);\n+  cnt1 = cnt.apply_scale (1, (n - 1));\n   prob1 = prob / (n - 1);\n \n   FOR_EACH_EDGE (ae, ei, bb->succs)\n@@ -1126,10 +1130,12 @@ set_zero_probability (edge e)\n \n   /* Move the rest to one of the edges.  */\n   last->probability += prob % (n - 1);\n-  last->count += cnt % (n - 1);\n+  /* TODO: Remove once we have fractional counts.  */\n+  if (cnt.initialized_p ())\n+    last->count += profile_count::from_gcov_type (cnt.to_gcov_type () % (n - 1));\n \n   e->probability = 0;\n-  e->count = 0;\n+  e->count = profile_count::zero ();\n }\n \n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n@@ -1672,8 +1678,8 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n \t\t  current_ir_type () == IR_GIMPLE ? EDGE_TRUE_VALUE : 0);\n   e1->probability = then_prob;\n   e->probability = else_prob;\n-  e1->count = apply_probability (e->count, e1->probability);\n-  e->count = apply_probability (e->count, e->probability);\n+  e1->count = e->count.apply_probability (e1->probability);\n+  e->count = e->count.apply_probability (e->probability);\n \n   set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n   set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);"}, {"sha": "4e303a61d787369628190bba70bb36c6eb3afd81", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1505,14 +1505,11 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t  int prob = XINT (note, 0);\n \n \t  b->probability = prob;\n-          /* Update this to use GCOV_COMPUTE_SCALE.  */\n-\t  b->count = e->count * prob / REG_BR_PROB_BASE;\n+\t  b->count = e->count.apply_probability (prob);\n \t  e->probability -= e->probability;\n \t  e->count -= b->count;\n \t  if (e->probability < 0)\n \t    e->probability = 0;\n-\t  if (e->count < 0)\n-\t    e->count = 0;\n \t}\n     }\n \n@@ -1620,7 +1617,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n   if (EDGE_COUNT (e->src->succs) >= 2 || abnormal_edge_flags || asm_goto_edge)\n     {\n       rtx_insn *new_head;\n-      gcov_type count = e->count;\n+      profile_count count = e->count;\n       int probability = e->probability;\n       /* Create the new structures.  */\n \n@@ -1660,13 +1657,13 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n       if (asm_goto_edge)\n \t{\n \t  new_edge->probability /= 2;\n-\t  new_edge->count /= 2;\n-\t  jump_block->count /= 2;\n+\t  new_edge->count = new_edge->count.apply_scale (1, 2);\n+\t  jump_block->count = jump_block->count.apply_scale (1, 2);\n \t  jump_block->frequency /= 2;\n-\t  new_edge = make_edge (new_edge->src, target,\n-\t\t\t\te->flags & ~EDGE_FALLTHRU);\n-\t  new_edge->probability = probability - probability / 2;\n-\t  new_edge->count = count - count / 2;\n+\t  edge new_edge2 = make_edge (new_edge->src, target,\n+\t\t\t\t      e->flags & ~EDGE_FALLTHRU);\n+\t  new_edge2->probability = probability - new_edge->probability;\n+\t  new_edge2->count = count - new_edge->count;\n \t}\n \n       new_bb = jump_block;\n@@ -3159,9 +3156,8 @@ purge_dead_edges (basic_block bb)\n \t  f = FALLTHRU_EDGE (bb);\n \t  b->probability = XINT (note, 0);\n \t  f->probability = REG_BR_PROB_BASE - b->probability;\n-          /* Update these to use GCOV_COMPUTE_SCALE.  */\n-\t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n-\t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n+\t  b->count = bb->count.apply_probability (b->probability);\n+\t  f->count = bb->count.apply_probability (f->probability);\n \t}\n \n       return purged;\n@@ -5030,9 +5026,9 @@ rtl_account_profile_record (basic_block bb, int after_pass,\n       {\n \trecord->size[after_pass]\n \t  += insn_rtx_cost (PATTERN (insn), false);\n-\tif (profile_status_for_fn (cfun) == PROFILE_READ)\n+\tif (bb->count.initialized_p ())\n \t  record->time[after_pass]\n-\t    += insn_rtx_cost (PATTERN (insn), true) * bb->count;\n+\t    += insn_rtx_cost (PATTERN (insn), true) * bb->count.to_gcov_type ();\n \telse if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n \t  record->time[after_pass]\n \t    += insn_rtx_cost (PATTERN (insn), true) * bb->frequency;"}, {"sha": "2cbacc774d39bdf9daf1cfbcf359e59e188c2573", "filename": "gcc/cgraph.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -500,6 +500,8 @@ cgraph_node::create (tree decl)\n \n   node->decl = decl;\n \n+  node->count = profile_count::uninitialized ();\n+\n   if ((flag_openacc || flag_openmp)\n       && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n     {\n@@ -808,7 +810,7 @@ cgraph_edge::set_call_stmt (gcall *new_stmt, bool update_speculative)\n \n cgraph_edge *\n symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t   gcall *call_stmt, gcov_type count, int freq,\n+\t\t\t   gcall *call_stmt, profile_count count, int freq,\n \t\t\t   bool indir_unknown_callee)\n {\n   cgraph_edge *edge;\n@@ -849,10 +851,9 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->lto_stmt_uid = 0;\n \n   edge->count = count;\n-  gcc_assert (count >= 0);\n   edge->frequency = freq;\n-  gcc_assert (freq >= 0);\n-  gcc_assert (freq <= CGRAPH_FREQ_MAX);\n+  gcc_checking_assert (freq >= 0);\n+  gcc_checking_assert (freq <= CGRAPH_FREQ_MAX);\n \n   edge->call_stmt = call_stmt;\n   push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n@@ -894,7 +895,7 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n \n cgraph_edge *\n cgraph_node::create_edge (cgraph_node *callee,\n-\t\t\t  gcall *call_stmt, gcov_type count, int freq)\n+\t\t\t  gcall *call_stmt, profile_count count, int freq)\n {\n   cgraph_edge *edge = symtab->create_edge (this, callee, call_stmt, count,\n \t\t\t\t\t   freq, false);\n@@ -931,7 +932,7 @@ cgraph_allocate_init_indirect_info (void)\n \n cgraph_edge *\n cgraph_node::create_indirect_edge (gcall *call_stmt, int ecf_flags,\n-\t\t\t\t   gcov_type count, int freq,\n+\t\t\t\t   profile_count count, int freq,\n \t\t\t\t   bool compute_indirect_info)\n {\n   cgraph_edge *edge = symtab->create_edge (this, NULL, call_stmt,\n@@ -1047,7 +1048,7 @@ cgraph_edge::remove (void)\n    Return direct edge created.  */\n \n cgraph_edge *\n-cgraph_edge::make_speculative (cgraph_node *n2, gcov_type direct_count,\n+cgraph_edge::make_speculative (cgraph_node *n2, profile_count direct_count,\n \t\t\t       int direct_frequency)\n {\n   cgraph_node *n = caller;\n@@ -1303,19 +1304,21 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n       else\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Expanding speculative call of %s -> %s count: \"\n-\t\t     \"%\" PRId64\"\\n\",\n-\t\t     e->caller->dump_name (),\n-\t\t     e->callee->dump_name (),\n-\t\t     (int64_t)e->count);\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"Expanding speculative call of %s -> %s count: \",\n+\t\t       e->caller->dump_name (),\n+\t\t       e->callee->dump_name ());\n+\t      e->count.dump (dump_file);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n \t  gcc_assert (e2->speculative);\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n \t  new_stmt = gimple_ic (e->call_stmt,\n \t\t\t\tdyn_cast<cgraph_node *> (ref->referred),\n-\t\t\t\te->count || e2->count\n-\t\t\t\t?  RDIV (e->count * REG_BR_PROB_BASE,\n-\t\t\t\t\t e->count + e2->count)\n+\t\t\t\te->count > profile_count::zero ()\n+\t\t\t\t|| e2->count > profile_count::zero ()\n+\t\t\t\t? e->count.probability_in (e->count + e2->count)\n \t\t\t\t: e->frequency || e2->frequency\n \t\t\t\t? RDIV (e->frequency * REG_BR_PROB_BASE,\n \t\t\t\t\te->frequency + e2->frequency)\n@@ -1591,7 +1594,7 @@ cgraph_update_edges_for_call_stmt_node (cgraph_node *node,\n     {\n       cgraph_edge *e = node->get_edge (old_stmt);\n       cgraph_edge *ne = NULL;\n-      gcov_type count;\n+      profile_count count;\n       int frequency;\n \n       if (e)\n@@ -2033,8 +2036,12 @@ cgraph_edge::dump_edge_flags (FILE *f)\n     fprintf (f, \"(call_stmt_cannot_inline_p) \");\n   if (indirect_inlining_edge)\n     fprintf (f, \"(indirect_inlining) \");\n-  if (count)\n-    fprintf (f, \"(%\" PRId64\"x) \", (int64_t)count);\n+  if (count.initialized_p ())\n+    {\n+      fprintf (f, \"(\");\n+      count.dump (f);\n+      fprintf (f, \")\");\n+    }\n   if (frequency)\n     fprintf (f, \"(%.2f per call) \", frequency / (double)CGRAPH_FREQ_BASE);\n   if (can_throw_external)\n@@ -2085,9 +2092,11 @@ cgraph_node::dump (FILE *f)\n       fprintf (f, \"\\n\");\n     }\n   fprintf (f, \"  Function flags:\");\n-  if (count)\n-    fprintf (f, \" executed %\" PRId64\"x\",\n-\t     (int64_t)count);\n+  if (count.initialized_p ())\n+    {\n+      fprintf (f, \" profile_count \");\n+      count.dump (f);\n+    }\n   if (origin)\n     fprintf (f, \" nested in: %s\", origin->asm_name ());\n   if (gimple_has_body_p (decl))\n@@ -2737,6 +2746,10 @@ cgraph_edge::maybe_hot_p (void)\n     return false;\n   if (caller->frequency == NODE_FREQUENCY_HOT)\n     return true;\n+  /* If profile is now known yet, be conservative.\n+     FIXME: this predicate is used by early inliner and can do better there.  */\n+  if (symtab->state < IPA_SSA)\n+    return true;\n   if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n       && frequency < CGRAPH_FREQ_BASE * 3 / 2)\n     return false;"}, {"sha": "82a84eabdd9403320dc7953a99e51c1a494d2c25", "filename": "gcc/cgraph.h", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n \n+#include \"profile-count.h\"\n #include \"ipa-ref.h\"\n #include \"plugin-api.h\"\n \n@@ -910,7 +911,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      All hooks will see this in node's global.inlined_to, when invoked.\n      Can be NULL if the node is not inlined.  SUFFIX is string that is appended\n      to the original name.  */\n-  cgraph_node *create_clone (tree decl, gcov_type count, int freq,\n+  cgraph_node *create_clone (tree decl, profile_count count, int freq,\n \t\t\t     bool update_original,\n \t\t\t     vec<cgraph_edge *> redirect_callers,\n \t\t\t     bool call_duplication_hook,\n@@ -1078,22 +1079,22 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Create edge from a given function to CALLEE in the cgraph.  */\n   cgraph_edge *create_edge (cgraph_node *callee,\n-\t\t\t    gcall *call_stmt, gcov_type count,\n+\t\t\t    gcall *call_stmt, profile_count count,\n \t\t\t    int freq);\n \n   /* Create an indirect edge with a yet-undetermined callee where the call\n      statement destination is a formal parameter of the caller with index\n      PARAM_INDEX. */\n   cgraph_edge *create_indirect_edge (gcall *call_stmt, int ecf_flags,\n-\t\t\t\t     gcov_type count, int freq,\n+\t\t\t\t     profile_count count, int freq,\n \t\t\t\t     bool compute_indirect_info = true);\n \n   /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n    same function body.  If clones already have edge for OLD_STMT; only\n    update the edge same way as cgraph_set_call_stmt_including_clones does.  */\n   void create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t     gimple *old_stmt, gcall *stmt,\n-\t\t\t\t     gcov_type count,\n+\t\t\t\t     profile_count count,\n \t\t\t\t     int freq,\n \t\t\t\t     cgraph_inline_failed_t reason);\n \n@@ -1356,7 +1357,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   cgraph_thunk_info thunk;\n \n   /* Expected number of executions: calculated in profile.c.  */\n-  gcov_type count;\n+  profile_count count;\n   /* How to scale counts at materialization time; used to merge\n      LTO units with different number of profile runs.  */\n   int count_materialization_scale;\n@@ -1629,7 +1630,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Turn edge into speculative call calling N2. Update\n      the profile so the direct call is taken COUNT times\n      with FREQUENCY.  */\n-  cgraph_edge *make_speculative (cgraph_node *n2, gcov_type direct_count,\n+  cgraph_edge *make_speculative (cgraph_node *n2, profile_count direct_count,\n \t\t\t\t int direct_frequency);\n \n    /* Given speculative call edge, return all three components.  */\n@@ -1648,7 +1649,8 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   /* Create clone of edge in the node N represented\n      by CALL_EXPR the callgraph.  */\n   cgraph_edge * clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n-\t\t       gcov_type count_scale, int freq_scale, bool update_original);\n+\t\t       gcov_type count_scale, int freq_scale,\n+\t\t       bool update_original);\n \n   /* Verify edge count and frequency.  */\n   bool verify_count_and_frequency ();\n@@ -1673,7 +1675,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n   static void rebuild_references (void);\n \n   /* Expected number of executions: calculated in profile.c.  */\n-  gcov_type count;\n+  profile_count count;\n   cgraph_node *caller;\n   cgraph_node *callee;\n   cgraph_edge *prev_caller;\n@@ -2250,7 +2252,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n      parameters of which only CALLEE can be NULL (when creating an indirect call\n      edge).  */\n   cgraph_edge *create_edge (cgraph_node *caller, cgraph_node *callee,\n-\t\t\t    gcall *call_stmt, gcov_type count, int freq,\n+\t\t\t    gcall *call_stmt, profile_count count, int freq,\n \t\t\t    bool indir_unknown_callee);\n \n   /* Put the edge onto the free list.  */\n@@ -2321,7 +2323,7 @@ void cgraphunit_c_finalize (void);\n \n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n-basic_block init_lowered_empty_function (tree, bool, gcov_type);\n+basic_block init_lowered_empty_function (tree, bool, profile_count);\n \n tree thunk_adjust (gimple_stmt_iterator *, tree, bool, HOST_WIDE_INT, tree);\n /* In cgraphclones.c  */"}, {"sha": "e6026dc5c2fea9b7907fdf6a929dc6e0938a31e5", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -89,7 +89,7 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n \t\t    gcov_type count_scale, int freq_scale, bool update_original)\n {\n   cgraph_edge *new_edge;\n-  gcov_type gcov_count = apply_probability (count, count_scale);\n+  profile_count gcov_count = count.apply_scale (count_scale, REG_BR_PROB_BASE);\n   gcov_type freq;\n \n   /* We do not want to ignore loop nest after frequency drops to 0.  */\n@@ -142,8 +142,6 @@ cgraph_edge::clone (cgraph_node *n, gcall *call_stmt, unsigned stmt_uid,\n   if (update_original)\n     {\n       count -= new_edge->count;\n-      if (count < 0)\n-\tcount = 0;\n     }\n   symtab->call_edge_duplication_hooks (this, new_edge);\n   return new_edge;\n@@ -336,7 +334,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->clone.args_to_skip = node->clone.args_to_skip;\n   new_thunk->clone.combined_args_to_skip = node->clone.combined_args_to_skip;\n \n-  cgraph_edge *e = new_thunk->create_edge (node, NULL, 0,\n+  cgraph_edge *e = new_thunk->create_edge (node, NULL, new_thunk->count,\n \t\t\t\t\t\t  CGRAPH_FREQ_BASE);\n   symtab->call_edge_duplication_hooks (thunk->callees, e);\n   symtab->call_cgraph_duplication_hooks (thunk, new_thunk);\n@@ -421,7 +419,7 @@ dump_callgraph_transformation (const cgraph_node *original,\n    node is not inlined.  */\n \n cgraph_node *\n-cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n+cgraph_node::create_clone (tree new_decl, profile_count prof_count, int freq,\n \t\t\t   bool update_original,\n \t\t\t   vec<cgraph_edge *> redirect_callers,\n \t\t\t   bool call_duplication_hook,\n@@ -436,6 +434,7 @@ cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n   if (new_inlined_to)\n     dump_callgraph_transformation (this, new_inlined_to, \"inlining to\");\n \n+  new_node->count = prof_count;\n   new_node->decl = new_decl;\n   new_node->register_symbol ();\n   new_node->origin = origin;\n@@ -476,21 +475,17 @@ cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n \n-  if (count)\n+  if (count.initialized_p ())\n     {\n       if (new_node->count > count)\n         count_scale = REG_BR_PROB_BASE;\n       else\n-\tcount_scale = GCOV_COMPUTE_SCALE (new_node->count, count);\n+\tcount_scale = new_node->count.probability_in (count);\n     }\n   else\n     count_scale = 0;\n   if (update_original)\n-    {\n-      count -= gcov_count;\n-      if (count < 0)\n-\tcount = 0;\n-    }\n+    count -= prof_count;\n \n   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n     {\n@@ -785,7 +780,7 @@ cgraph_node::set_call_stmt_including_clones (gimple *old_stmt,\n void\n cgraph_node::create_edge_including_clones (cgraph_node *callee,\n \t\t\t\t\t   gimple *old_stmt, gcall *stmt,\n-\t\t\t\t\t   gcov_type count,\n+\t\t\t\t\t   profile_count count,\n \t\t\t\t\t   int freq,\n \t\t\t\t\t   cgraph_inline_failed_t reason)\n {"}, {"sha": "77209046d9a92155cec50920d144fb92c8edbfe7", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -615,7 +615,7 @@ cgraph_node::analyze (void)\n     {\n       cgraph_node *t = cgraph_node::get (thunk.alias);\n \n-      create_edge (t, NULL, 0, CGRAPH_FREQ_BASE);\n+      create_edge (t, NULL, t->count, CGRAPH_FREQ_BASE);\n       callees->can_throw_external = !TREE_NOTHROW (t->decl);\n       /* Target code in expand_thunk may need the thunk's target\n \t to be analyzed, so recurse here.  */\n@@ -1475,7 +1475,7 @@ mark_functions_to_output (void)\n    return basic block in the function body.  */\n \n basic_block\n-init_lowered_empty_function (tree decl, bool in_ssa, gcov_type count)\n+init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n {\n   basic_block bb;\n   edge e;\n@@ -1873,13 +1873,13 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t     adjustment, because that's why we're emitting a\n \t\t     thunk.  */\n \t\t  then_bb = create_basic_block (NULL, bb);\n-\t\t  then_bb->count = count - count / 16;\n+\t\t  then_bb->count = count - count.apply_scale (1, 16);\n \t\t  then_bb->frequency = BB_FREQ_MAX - BB_FREQ_MAX / 16;\n \t\t  return_bb = create_basic_block (NULL, then_bb);\n \t\t  return_bb->count = count;\n \t\t  return_bb->frequency = BB_FREQ_MAX;\n \t\t  else_bb = create_basic_block (NULL, else_bb);\n-\t\t  then_bb->count = count / 16;\n+\t\t  then_bb->count = count.apply_scale (1, 16);\n \t\t  then_bb->frequency = BB_FREQ_MAX / 16;\n \t\t  add_bb_to_loop (then_bb, bb->loop_father);\n \t\t  add_bb_to_loop (return_bb, bb->loop_father);\n@@ -1892,19 +1892,19 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n \t\t  e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n \t\t  e->probability = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 16;\n-\t\t  e->count = count - count / 16;\n+\t\t  e->count = count - count.apply_scale (1, 16);\n \t\t  e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n \t\t  e->probability = REG_BR_PROB_BASE / 16;\n-\t\t  e->count = count / 16;\n+\t\t  e->count = count.apply_scale (1, 16);\n \t\t  e = make_edge (return_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n \t\t  e->probability = REG_BR_PROB_BASE;\n \t\t  e->count = count;\n \t\t  e = make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n \t\t  e->probability = REG_BR_PROB_BASE;\n-\t\t  e->count = count - count / 16;\n+\t\t  e->count = count - count.apply_scale (1, 16);\n \t\t  e = make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n \t\t  e->probability = REG_BR_PROB_BASE;\n-\t\t  e->count = count / 16;\n+\t\t  e->count = count.apply_scale (1, 16);\n \t\t  bsi = gsi_last_bb (then_bb);\n \t\t}\n \n@@ -1940,7 +1940,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \n       cfun->gimple_df->in_ssa_p = true;\n       profile_status_for_fn (cfun)\n-        = count ? PROFILE_READ : PROFILE_GUESSED;\n+        = count.initialized_p () ? PROFILE_READ : PROFILE_GUESSED;\n       /* FIXME: C++ FE should stop setting TREE_ASM_WRITTEN on thunks.  */\n       TREE_ASM_WRITTEN (thunk_fndecl) = false;\n       delete_unreachable_blocks ();"}, {"sha": "1ad329cdab4ffc8a1d647cf148a2abf4480cd85a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -33846,7 +33846,8 @@ make_resolver_func (const tree default_decl,\n \n   gimplify_function_tree (decl);\n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n-  *empty_bb = init_lowered_empty_function (decl, false, 0);\n+  *empty_bb = init_lowered_empty_function (decl, false,\n+\t\t\t\t\t   profile_count::uninitialized ());\n \n   cgraph_node::add_new_function (decl, true);\n   symtab->call_cgraph_insertion_hooks (cgraph_node::get_create (decl));"}, {"sha": "356c923c4cd7294a2a2d7ec51b354d78105a6111", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1951,9 +1951,11 @@ dump_basic_block_info (FILE *file, rtx_insn *insn, basic_block *start_to_bb,\n       fprintf (file, \"%s BLOCK %d\", ASM_COMMENT_START, bb->index);\n       if (bb->frequency)\n         fprintf (file, \" freq:%d\", bb->frequency);\n-      if (bb->count)\n-        fprintf (file, \" count:%\" PRId64,\n-                 bb->count);\n+      if (bb->count.initialized_p ())\n+\t{\n+          fprintf (file, \", count:\");\n+\t  bb->count.dump (file);\n+\t}\n       fprintf (file, \" seq:%d\", (*bb_seqn)++);\n       fprintf (file, \"\\n%s PRED:\", ASM_COMMENT_START);\n       FOR_EACH_EDGE (e, ei, bb->preds)"}, {"sha": "d19e2fdde44c0b1f65f2ec0108e74bc4bb5c0e1a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1948,7 +1948,7 @@ scalarize_intrinsic_call (gfc_expr *e)\n {\n   gfc_actual_arglist *a, *b;\n   gfc_constructor_base ctor;\n-  gfc_constructor *args[5];\n+  gfc_constructor *args[5] = {};  /* Avoid uninitialized warnings.  */\n   gfc_constructor *ci, *new_ctor;\n   gfc_expr *expr, *old;\n   int n, i, rank[5], array_arg;"}, {"sha": "23cf692e321ee98daf5470093c709c8d7380ce73", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -264,8 +264,8 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   index = streamer_read_uhwi (ib);\n   bb = BASIC_BLOCK_FOR_FN (fn, index);\n \n-  bb->count = apply_scale (streamer_read_gcov_count (ib),\n-                           count_materialization_scale);\n+  bb->count = profile_count::stream_in (ib).apply_scale\n+\t\t (count_materialization_scale, REG_BR_PROB_BASE);\n   bb->frequency = streamer_read_hwi (ib);\n   bb->flags = streamer_read_hwi (ib);\n "}, {"sha": "cdd775388e183edd237d8e3c5a0ddd6a5473b99f", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -209,7 +209,7 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n \t\t\t\t: LTO_bb0);\n \n   streamer_write_uhwi (ob, bb->index);\n-  streamer_write_gcov_count (ob, bb->count);\n+  bb->count.stream_out (ob);\n   streamer_write_hwi (ob, bb->frequency);\n   streamer_write_hwi (ob, bb->flags);\n "}, {"sha": "af336da5ad4489641dd507918688b757838f461f", "filename": "gcc/graphite.c", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -64,10 +64,10 @@ print_global_statistics (FILE* file)\n   long n_loops = 0;\n   long n_stmts = 0;\n   long n_conditions = 0;\n-  long n_p_bbs = 0;\n-  long n_p_loops = 0;\n-  long n_p_stmts = 0;\n-  long n_p_conditions = 0;\n+  profile_count n_p_bbs = profile_count::zero ();\n+  profile_count n_p_loops = profile_count::zero ();\n+  profile_count n_p_stmts = profile_count::zero ();\n+  profile_count n_p_conditions = profile_count::zero ();\n \n   basic_block bb;\n \n@@ -76,7 +76,8 @@ print_global_statistics (FILE* file)\n       gimple_stmt_iterator psi;\n \n       n_bbs++;\n-      n_p_bbs += bb->count;\n+      if (bb->count.initialized_p ())\n+        n_p_bbs += bb->count;\n \n       /* Ignore artificial surrounding loop.  */\n       if (bb == bb->loop_father->header\n@@ -89,13 +90,15 @@ print_global_statistics (FILE* file)\n       if (EDGE_COUNT (bb->succs) > 1)\n \t{\n \t  n_conditions++;\n-\t  n_p_conditions += bb->count;\n+\t  if (bb->count.initialized_p ())\n+\t    n_p_conditions += bb->count;\n \t}\n \n       for (psi = gsi_start_bb (bb); !gsi_end_p (psi); gsi_next (&psi))\n \t{\n \t  n_stmts++;\n-\t  n_p_stmts += bb->count;\n+\t  if (bb->count.initialized_p ())\n+\t    n_p_stmts += bb->count;\n \t}\n     }\n \n@@ -105,10 +108,15 @@ print_global_statistics (FILE* file)\n   fprintf (file, \"CONDITIONS:%ld, \", n_conditions);\n   fprintf (file, \"STMTS:%ld)\\n\", n_stmts);\n   fprintf (file, \"\\nGlobal profiling statistics (\");\n-  fprintf (file, \"BBS:%ld, \", n_p_bbs);\n-  fprintf (file, \"LOOPS:%ld, \", n_p_loops);\n-  fprintf (file, \"CONDITIONS:%ld, \", n_p_conditions);\n-  fprintf (file, \"STMTS:%ld)\\n\", n_p_stmts);\n+  fprintf (file, \"BBS:\");\n+  n_p_bbs.dump (file);\n+  fprintf (file, \", LOOPS:\");\n+  n_p_loops.dump (file);\n+  fprintf (file, \", CONDITIONS:\");\n+  n_p_conditions.dump (file);\n+  fprintf (file, \", STMTS:\");\n+  n_p_stmts.dump (file);\n+  fprintf (file, \")\\n\");\n }\n \n /* Print statistics for SCOP to FILE.  */\n@@ -120,10 +128,10 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n   long n_loops = 0;\n   long n_stmts = 0;\n   long n_conditions = 0;\n-  long n_p_bbs = 0;\n-  long n_p_loops = 0;\n-  long n_p_stmts = 0;\n-  long n_p_conditions = 0;\n+  profile_count n_p_bbs = profile_count::zero ();\n+  profile_count n_p_loops = profile_count::zero ();\n+  profile_count n_p_stmts = profile_count::zero ();\n+  profile_count n_p_conditions = profile_count::zero ();\n \n   basic_block bb;\n \n@@ -136,7 +144,8 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n \tcontinue;\n \n       n_bbs++;\n-      n_p_bbs += bb->count;\n+      if (bb->count.initialized_p ())\n+        n_p_bbs += bb->count;\n \n       if (EDGE_COUNT (bb->succs) > 1)\n \t{\n@@ -173,10 +182,15 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n   fprintf (file, \"CONDITIONS:%ld, \", n_conditions);\n   fprintf (file, \"STMTS:%ld)\\n\", n_stmts);\n   fprintf (file, \"\\nSCoP profiling statistics (\");\n-  fprintf (file, \"BBS:%ld, \", n_p_bbs);\n-  fprintf (file, \"LOOPS:%ld, \", n_p_loops);\n-  fprintf (file, \"CONDITIONS:%ld, \", n_p_conditions);\n-  fprintf (file, \"STMTS:%ld)\\n\", n_p_stmts);\n+  fprintf (file, \"BBS:\");\n+  n_p_bbs.dump (file);\n+  fprintf (file, \", LOOPS:\");\n+  n_p_loops.dump (file);\n+  fprintf (file, \", CONDITIONS:\");\n+  n_p_conditions.dump (file);\n+  fprintf (file, \", STMTS:\");\n+  n_p_stmts.dump (file);\n+  fprintf (file, \")\\n\");\n }\n \n /* Print statistics for SCOPS to FILE.  */"}, {"sha": "6eed014049288323e2bd08d1257f7bfa3935be94", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"stor-layout.h\"\n #include \"output.h\"\n+#include \"basic-block.h\"\n #include \"cfg.h\"\n #include \"function.h\"\n #include \"fold-const.h\""}, {"sha": "01bff2f972436a8dbe5fde66faa3aae106b88d39", "filename": "gcc/hsa-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"is-a.h\"\n #include \"vec.h\"\n #include \"tree.h\"\n+#include \"basic-block.h\"\n #include \"cfg.h\"\n #include \"function.h\"\n #include \"dumpfile.h\""}, {"sha": "80298b2b2fe46abb41ba3526195f8bf934c31727", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -29,9 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"tree.h\"\n #include \"tree-pass.h\"\n-#include \"cfg.h\"\n #include \"function.h\"\n #include \"basic-block.h\"\n+#include \"cfg.h\"\n #include \"fold-const.h\"\n #include \"gimple.h\"\n #include \"gimple-iterator.h\"\n@@ -6047,9 +6047,10 @@ struct phi_definition\n \n template <typename T>\n static\n-T sum_slice (const auto_vec <T> &v, unsigned start, unsigned end)\n+T sum_slice (const auto_vec <T> &v, unsigned start, unsigned end,\n+\t     T zero)\n {\n-  T s = 0;\n+  T s = zero;\n \n   for (unsigned i = start; i < end; i++)\n     s += v[i];\n@@ -6137,7 +6138,7 @@ convert_switch_statements (void)\n \n \tauto_vec <edge> new_edges;\n \tauto_vec <phi_definition *> phi_todo_list;\n-\tauto_vec <gcov_type> edge_counts;\n+\tauto_vec <profile_count> edge_counts;\n \tauto_vec <int> edge_probabilities;\n \n \t/* Investigate all labels that and PHI nodes in these edges which\n@@ -6230,7 +6231,7 @@ convert_switch_statements (void)\n \t    basic_block label_bb\n \t      = label_to_block_fn (func, CASE_LABEL (label));\n \t    edge new_edge = make_edge (cur_bb, label_bb, EDGE_TRUE_VALUE);\n-\t    int prob_sum = sum_slice <int> (edge_probabilities, i, labels) +\n+\t    int prob_sum = sum_slice <int> (edge_probabilities, i, labels, 0) +\n \t       edge_probabilities[0];\n \n \t    if (prob_sum)\n@@ -6255,7 +6256,8 @@ convert_switch_statements (void)\n \t\tnext_edge->probability\n \t\t  = inverse_probability (new_edge->probability);\n \t\tnext_edge->count = edge_counts[0]\n-\t\t  + sum_slice <gcov_type> (edge_counts, i, labels);\n+\t\t  + sum_slice <profile_count> (edge_counts, i, labels,\n+\t\t\t\t\t       profile_count::zero ());\n \t\tnext_bb->frequency = EDGE_FREQUENCY (next_edge);\n \t\tcur_bb = next_bb;\n \t      }"}, {"sha": "2a17254c3b26be4ae53bae967c159b3c0433d123", "filename": "gcc/hsa-regalloc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-regalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fhsa-regalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-regalloc.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"tree.h\"\n #include \"dominance.h\"\n+#include \"basic-block.h\"\n #include \"cfg.h\"\n #include \"cfganal.h\"\n #include \"function.h\""}, {"sha": "753673c8f66845a9ab12ecdacdd3aa361554dc1d", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -715,7 +715,7 @@ chkp_produce_thunks (bool early)\n \t  node->thunk.thunk_p = true;\n \t  node->thunk.add_pointer_bounds_args = true;\n \t  node->create_edge (node->instrumented_version, NULL,\n-\t\t\t     0, CGRAPH_FREQ_BASE);\n+\t\t\t     node->count, CGRAPH_FREQ_BASE);\n \t  node->create_reference (node->instrumented_version,\n \t\t\t       IPA_REF_CHKP, NULL);\n \t  /* Thunk shouldn't be a cdtor.  */"}, {"sha": "3c9c3f29ee0eb8895e295a1371448bf3a184e028", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 80, "deletions": 68, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -360,7 +360,7 @@ object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool\n \n /* Maximal count found in program.  */\n \n-static gcov_type max_count;\n+static profile_count max_count;\n \n /* Original overall size of the program.  */\n \n@@ -640,7 +640,7 @@ ipcp_versionable_function_p (struct cgraph_node *node)\n \n struct caller_statistics\n {\n-  gcov_type count_sum;\n+  profile_count count_sum;\n   int n_calls, n_hot_calls, freq_sum;\n };\n \n@@ -649,7 +649,7 @@ struct caller_statistics\n static inline void\n init_caller_stats (struct caller_statistics *stats)\n {\n-  stats->count_sum = 0;\n+  stats->count_sum = profile_count::zero ();\n   stats->n_calls = 0;\n   stats->n_hot_calls = 0;\n   stats->freq_sum = 0;\n@@ -667,7 +667,8 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (!cs->caller->thunk.thunk_p)\n       {\n-\tstats->count_sum += cs->count;\n+        if (cs->count.initialized_p ())\n+\t  stats->count_sum += cs->count;\n \tstats->freq_sum += cs->frequency;\n \tstats->n_calls++;\n \tif (cs->maybe_hot_p ())\n@@ -718,9 +719,9 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   /* When profile is available and function is hot, propagate into it even if\n      calls seems cold; constant propagation can improve function's speed\n      significantly.  */\n-  if (max_count)\n+  if (max_count > profile_count::zero ())\n     {\n-      if (stats.count_sum > node->count * 90 / 100)\n+      if (stats.count_sum > node->count.apply_scale (90, 100))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Considering %s for cloning; \"\n@@ -2611,7 +2612,7 @@ incorporate_penalties (ipa_node_params *info, int64_t evaluation)\n \n static bool\n good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n-\t\t\t    int freq_sum, gcov_type count_sum, int size_cost)\n+\t\t\t    int freq_sum, profile_count count_sum, int size_cost)\n {\n   if (time_benefit == 0\n       || !opt_for_fn (node->decl, flag_ipa_cp_clone)\n@@ -2621,22 +2622,25 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n   gcc_assert (size_cost > 0);\n \n   struct ipa_node_params *info = IPA_NODE_REF (node);\n-  if (max_count)\n+  if (max_count > profile_count::zero ())\n     {\n-      int factor = (count_sum * 1000) / max_count;\n+      int factor = RDIV (count_sum.probability_in (max_count)\n+\t\t         * 1000, REG_BR_PROB_BASE);\n       int64_t evaluation = (((int64_t) time_benefit * factor)\n \t\t\t\t    / size_cost);\n       evaluation = incorporate_penalties (info, evaluation);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n-\t\t \"size: %i, count_sum: \" HOST_WIDE_INT_PRINT_DEC\n-\t\t \"%s%s) -> evaluation: \" \"%\" PRId64\n+\t{\n+\t  fprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n+\t\t   \"size: %i, count_sum: \", time_benefit, size_cost);\n+\t  count_sum.dump (dump_file);\n+\t  fprintf (dump_file, \"%s%s) -> evaluation: \" \"%\" PRId64\n \t\t \", threshold: %i\\n\",\n-\t\t time_benefit, size_cost, (HOST_WIDE_INT) count_sum,\n \t\t info->node_within_scc ? \", scc\" : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n \t\t evaluation, PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n+\t}\n \n       return evaluation >= PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD);\n     }\n@@ -3520,11 +3524,11 @@ template <typename valtype>\n static bool\n get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n \t\t\t\tint *freq_sum,\n-\t\t\t\tgcov_type *count_sum, int *caller_count)\n+\t\t\t\tprofile_count *count_sum, int *caller_count)\n {\n   ipcp_value_source<valtype> *src;\n   int freq = 0, count = 0;\n-  gcov_type cnt = 0;\n+  profile_count cnt = profile_count::zero ();\n   bool hot = false;\n \n   for (src = val->sources; src; src = src->next)\n@@ -3536,7 +3540,8 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n \t    {\n \t      count++;\n \t      freq += cs->frequency;\n-\t      cnt += cs->count;\n+\t      if (cs->count.initialized_p ())\n+\t        cnt += cs->count;\n \t      hot |= cs->maybe_hot_p ();\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n@@ -3611,19 +3616,27 @@ dump_profile_updates (struct cgraph_node *orig_node,\n {\n   struct cgraph_edge *cs;\n \n-  fprintf (dump_file, \"    setting count of the specialized node to \"\n-\t   HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) new_node->count);\n+  fprintf (dump_file, \"    setting count of the specialized node to \");\n+  new_node->count.dump (dump_file);\n+  fprintf (dump_file, \"\\n\");\n   for (cs = new_node->callees; cs; cs = cs->next_callee)\n-    fprintf (dump_file, \"      edge to %s has count \"\n-\t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n+    {\n+      fprintf (dump_file, \"      edge to %s has count \",\n+\t       cs->callee->name ());\n+      cs->count.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n-  fprintf (dump_file, \"    setting count of the original node to \"\n-\t   HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) orig_node->count);\n+  fprintf (dump_file, \"    setting count of the original node to \");\n+  orig_node->count.dump (dump_file);\n+  fprintf (dump_file, \"\\n\");\n   for (cs = orig_node->callees; cs; cs = cs->next_callee)\n-    fprintf (dump_file, \"      edge to %s is left with \"\n-\t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n+    {\n+      fprintf (dump_file, \"      edge to %s is left with \",\n+\t       cs->callee->name ());\n+      cs->count.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n }\n \n /* After a specialized NEW_NODE version of ORIG_NODE has been created, update\n@@ -3635,10 +3648,10 @@ update_profiling_info (struct cgraph_node *orig_node,\n {\n   struct cgraph_edge *cs;\n   struct caller_statistics stats;\n-  gcov_type new_sum, orig_sum;\n-  gcov_type remainder, orig_node_count = orig_node->count;\n+  profile_count new_sum, orig_sum;\n+  profile_count remainder, orig_node_count = orig_node->count;\n \n-  if (orig_node_count == 0)\n+  if (!(orig_node_count > profile_count::zero ()))\n     return;\n \n   init_caller_stats (&stats);\n@@ -3653,36 +3666,37 @@ update_profiling_info (struct cgraph_node *orig_node,\n   if (orig_node_count < orig_sum + new_sum)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"    Problem: node %s has too low count \"\n-\t\t HOST_WIDE_INT_PRINT_DEC \" while the sum of incoming \"\n-\t\t \"counts is \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t orig_node->dump_name (),\n-\t\t (HOST_WIDE_INT) orig_node_count,\n-\t\t (HOST_WIDE_INT) (orig_sum + new_sum));\n-\n-      orig_node_count = (orig_sum + new_sum) * 12 / 10;\n+\t{\n+\t  fprintf (dump_file, \"    Problem: node %s has too low count \",\n+\t\t   orig_node->dump_name ());\n+\t  orig_node_count.dump (dump_file);\n+\t  fprintf (dump_file, \"while the sum of incoming count is \");\n+\t  (orig_sum + new_sum).dump (dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      orig_node_count = (orig_sum + new_sum).apply_scale (12, 10);\n       if (dump_file)\n-\tfprintf (dump_file, \"      proceeding by pretending it was \"\n-\t\t HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t (HOST_WIDE_INT) orig_node_count);\n+\t{\n+\t  fprintf (dump_file, \"      proceeding by pretending it was \");\n+\t  orig_node_count.dump (dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n \n   new_node->count = new_sum;\n   remainder = orig_node_count - new_sum;\n   orig_node->count = remainder;\n \n   for (cs = new_node->callees; cs; cs = cs->next_callee)\n+    /* FIXME: why we care about non-zero frequency here?  */\n     if (cs->frequency)\n-      cs->count = apply_probability (cs->count,\n-\t\t\t\t     GCOV_COMPUTE_SCALE (new_sum,\n-\t\t\t\t\t\t\t orig_node_count));\n+      cs->count = cs->count.apply_scale (new_sum, orig_node_count);\n     else\n-      cs->count = 0;\n+      cs->count = profile_count::zero ();\n \n   for (cs = orig_node->callees; cs; cs = cs->next_callee)\n-    cs->count = apply_probability (cs->count,\n-\t\t\t\t   GCOV_COMPUTE_SCALE (remainder,\n-\t\t\t\t\t\t       orig_node_count));\n+    cs->count = cs->count.apply_scale (remainder, orig_node_count);\n \n   if (dump_file)\n     dump_profile_updates (orig_node, new_node);\n@@ -3695,15 +3709,18 @@ update_profiling_info (struct cgraph_node *orig_node,\n static void\n update_specialized_profile (struct cgraph_node *new_node,\n \t\t\t    struct cgraph_node *orig_node,\n-\t\t\t    gcov_type redirected_sum)\n+\t\t\t    profile_count redirected_sum)\n {\n   struct cgraph_edge *cs;\n-  gcov_type new_node_count, orig_node_count = orig_node->count;\n+  profile_count new_node_count, orig_node_count = orig_node->count;\n \n   if (dump_file)\n-    fprintf (dump_file, \"    the sum of counts of redirected  edges is \"\n-\t     HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) redirected_sum);\n-  if (orig_node_count == 0)\n+    {\n+      fprintf (dump_file, \"    the sum of counts of redirected  edges is \");\n+      redirected_sum.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  if (!(orig_node_count > profile_count::zero ()))\n     return;\n \n   gcc_assert (orig_node_count >= redirected_sum);\n@@ -3714,21 +3731,15 @@ update_specialized_profile (struct cgraph_node *new_node,\n \n   for (cs = new_node->callees; cs; cs = cs->next_callee)\n     if (cs->frequency)\n-      cs->count += apply_probability (cs->count,\n-\t\t\t\t      GCOV_COMPUTE_SCALE (redirected_sum,\n-\t\t\t\t\t\t\t  new_node_count));\n+      cs->count += cs->count.apply_scale (redirected_sum, new_node_count);\n     else\n-      cs->count = 0;\n+      cs->count = profile_count::zero ();\n \n   for (cs = orig_node->callees; cs; cs = cs->next_callee)\n     {\n-      gcov_type dec = apply_probability (cs->count,\n-\t\t\t\t\t GCOV_COMPUTE_SCALE (redirected_sum,\n-\t\t\t\t\t\t\t     orig_node_count));\n-      if (dec < cs->count)\n-\tcs->count -= dec;\n-      else\n-\tcs->count = 0;\n+      profile_count dec = cs->count.apply_scale (redirected_sum,\n+\t\t\t\t\t\t orig_node_count);\n+      cs->count -= dec;\n     }\n \n   if (dump_file)\n@@ -4423,7 +4434,7 @@ static void\n perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n {\n   ipcp_value_source<valtype> *src;\n-  gcov_type redirected_sum = 0;\n+  profile_count redirected_sum = profile_count::zero ();\n \n   for (src = val->sources; src; src = src->next)\n     {\n@@ -4441,13 +4452,14 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n \n \t      cs->redirect_callee_duplicating_thunks (val->spec_node);\n \t      val->spec_node->expand_all_artificial_thunks ();\n-\t      redirected_sum += cs->count;\n+\t      if (cs->count.initialized_p ())\n+\t        redirected_sum = redirected_sum + cs->count;\n \t    }\n \t  cs = get_next_cgraph_edge_clone (cs);\n \t}\n     }\n \n-  if (redirected_sum)\n+  if (redirected_sum > profile_count::zero ())\n     update_specialized_profile (val->spec_node, node, redirected_sum);\n }\n \n@@ -4550,7 +4562,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n {\n   struct ipa_agg_replacement_value *aggvals;\n   int freq_sum, caller_count;\n-  gcov_type count_sum;\n+  profile_count count_sum;\n   vec<cgraph_edge *> callers;\n \n   if (val->spec_node)\n@@ -5103,7 +5115,7 @@ make_pass_ipa_cp (gcc::context *ctxt)\n void\n ipa_cp_c_finalize (void)\n {\n-  max_count = 0;\n+  max_count = profile_count::zero ();\n   overall_size = 0;\n   max_new_size = 0;\n }"}, {"sha": "cee3c3d89d7a95ce1850713ca15e198441b05ef6", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -2939,7 +2939,7 @@ struct odr_type_warn_count\n {\n   tree type;\n   int count;\n-  gcov_type dyn_count;\n+  profile_count dyn_count;\n };\n \n /* Record about how many calls would benefit from given method to be final.  */\n@@ -2948,14 +2948,14 @@ struct decl_warn_count\n {\n   tree decl;\n   int count;\n-  gcov_type dyn_count;\n+  profile_count dyn_count;\n };\n \n /* Information about type and decl warnings.  */\n \n struct final_warning_record\n {\n-  gcov_type dyn_count;\n+  profile_count dyn_count;\n   auto_vec<odr_type_warn_count> type_warnings;\n   hash_map<tree, decl_warn_count> decl_warnings;\n };\n@@ -3093,15 +3093,22 @@ possible_polymorphic_call_targets (tree otr_type,\n       if ((*slot)->type_warning && final_warning_records)\n \t{\n \t  final_warning_records->type_warnings[(*slot)->type_warning - 1].count++;\n-\t  final_warning_records->type_warnings[(*slot)->type_warning - 1].dyn_count\n-\t    += final_warning_records->dyn_count;\n+\t  if (!final_warning_records->type_warnings\n+\t\t[(*slot)->type_warning - 1].dyn_count.initialized_p ())\n+\t    final_warning_records->type_warnings\n+\t\t[(*slot)->type_warning - 1].dyn_count = profile_count::zero ();\n+\t  if (final_warning_records->dyn_count > 0)\n+\t    final_warning_records->type_warnings[(*slot)->type_warning - 1].dyn_count\n+\t      = final_warning_records->type_warnings[(*slot)->type_warning - 1].dyn_count\n+\t        + final_warning_records->dyn_count;\n \t}\n       if (!speculative && (*slot)->decl_warning && final_warning_records)\n \t{\n \t  struct decl_warn_count *c =\n \t     final_warning_records->decl_warnings.get ((*slot)->decl_warning);\n \t  c->count++;\n-\t  c->dyn_count += final_warning_records->dyn_count;\n+\t  if (final_warning_records->dyn_count > 0)\n+\t    c->dyn_count += final_warning_records->dyn_count;\n \t}\n       return (*slot)->targets;\n     }\n@@ -3227,6 +3234,10 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\tfinal_warning_records->type_warnings.safe_grow_cleared\n \t\t\t  (odr_types.length ());\n \t\t      final_warning_records->type_warnings[outer_type->id].count++;\n+\t\t      if (!final_warning_records->type_warnings\n+\t\t\t\t[outer_type->id].dyn_count.initialized_p ())\n+\t\t\tfinal_warning_records->type_warnings\n+\t\t\t   [outer_type->id].dyn_count = profile_count::zero ();\n \t\t      final_warning_records->type_warnings[outer_type->id].dyn_count\n \t\t\t+= final_warning_records->dyn_count;\n \t\t      final_warning_records->type_warnings[outer_type->id].type\n@@ -3587,7 +3598,9 @@ ipa_devirt (void)\n   if (warn_suggest_final_methods || warn_suggest_final_types)\n     {\n       final_warning_records = new (final_warning_record);\n-      final_warning_records->type_warnings.safe_grow_cleared (odr_types.length ());\n+      final_warning_records->dyn_count = profile_count::zero ();\n+      final_warning_records->type_warnings.safe_grow_cleared\n+\t\t\t\t\t\t (odr_types.length ());\n       free_polymorphic_call_targets_hash ();\n     }\n \n@@ -3768,7 +3781,8 @@ ipa_devirt (void)\n \t\tnconverted++;\n \t\tupdate = true;\n \t\te->make_speculative\n-\t\t  (likely_target, e->count * 8 / 10, e->frequency * 8 / 10);\n+\t\t  (likely_target, e->count.apply_scale (8, 10),\n+\t\t   e->frequency * 8 / 10);\n \t      }\n \t  }\n       if (update)\n@@ -3785,10 +3799,10 @@ ipa_devirt (void)\n \t      {\n \t        tree type = final_warning_records->type_warnings[i].type;\n \t        int count = final_warning_records->type_warnings[i].count;\n-\t        long long dyn_count\n+\t        profile_count dyn_count\n \t\t  = final_warning_records->type_warnings[i].dyn_count;\n \n-\t\tif (!dyn_count)\n+\t\tif (!(dyn_count > 0))\n \t\t  warning_n (DECL_SOURCE_LOCATION (TYPE_NAME (type)),\n \t\t\t     OPT_Wsuggest_final_types, count,\n \t\t\t     \"Declaring type %qD final \"\n@@ -3808,7 +3822,7 @@ ipa_devirt (void)\n \t\t\t     \"executed %lli times\",\n \t\t\t     type,\n \t\t\t     count,\n-\t\t\t     dyn_count);\n+\t\t\t     (long long) dyn_count.to_gcov_type ());\n \t      }\n \t}\n \n@@ -3823,9 +3837,10 @@ ipa_devirt (void)\n \t    {\n \t      tree decl = decl_warnings_vec[i]->decl;\n \t      int count = decl_warnings_vec[i]->count;\n-\t      long long dyn_count = decl_warnings_vec[i]->dyn_count;\n+\t      profile_count dyn_count\n+\t\t  = decl_warnings_vec[i]->dyn_count;\n \n-\t      if (!dyn_count)\n+\t      if (!(dyn_count > 0))\n \t\tif (DECL_CXX_DESTRUCTOR_P (decl))\n \t\t  warning_n (DECL_SOURCE_LOCATION (decl),\n \t\t\t      OPT_Wsuggest_final_methods, count,\n@@ -3851,7 +3866,8 @@ ipa_devirt (void)\n \t\t\t      \"Declaring virtual destructor of %qD final \"\n \t\t\t      \"would enable devirtualization of %i calls \"\n \t\t\t      \"executed %lli times\",\n-\t\t\t      DECL_CONTEXT (decl), count, dyn_count);\n+\t\t\t      DECL_CONTEXT (decl), count,\n+\t\t\t      (long long)dyn_count.to_gcov_type ());\n \t\telse\n \t\t  warning_n (DECL_SOURCE_LOCATION (decl),\n \t\t\t      OPT_Wsuggest_final_methods, count,\n@@ -3861,7 +3877,8 @@ ipa_devirt (void)\n \t\t\t      \"Declaring method %qD final \"\n \t\t\t      \"would enable devirtualization of %i calls \"\n \t\t\t      \"executed %lli times\",\n-\t\t\t      decl, count, dyn_count);\n+\t\t\t      decl, count,\n+\t\t\t      (long long)dyn_count.to_gcov_type ());\n \t    }\n \t}\n "}, {"sha": "878f9a891f361a7feb3417d16a861c426e4f5af7", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -243,7 +243,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n   struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   e->inline_failed = CIF_UNREACHABLE;\n   e->frequency = 0;\n-  e->count = 0;\n+  e->count = profile_count::zero ();\n   es->call_stmt_size = 0;\n   es->call_stmt_time = 0;\n   if (callee)"}, {"sha": "4d152ceab1e03241526b6068bec78d9e85b9e186", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1328,7 +1328,8 @@ sem_function::merge (sem_item *alias_item)\n       alias->icf_merged = true;\n       local_original->icf_merged = true;\n \n-      ipa_merge_profiles (local_original, alias, true);\n+      /* FIXME update local_original counts.  */\n+      ipa_merge_profiles (original, alias, true);\n       alias->create_wrapper (local_original);\n \n       if (dump_file)"}, {"sha": "1d79ec41097cbb5d64db35cae3e1ab0aeeddde7a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -175,10 +175,11 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n      edges and for those we disable size limits.  Don't do that when\n      probability that caller will call the callee is low however, since it\n      may hurt optimization of the caller's hot path.  */\n-  if (edge->count && edge->maybe_hot_p ()\n-      && (edge->count * 2\n+  if (edge->count.initialized_p () && edge->maybe_hot_p ()\n+      && (edge->count.apply_scale (2, 1)\n           > (edge->caller->global.inlined_to\n-\t     ? edge->caller->global.inlined_to->count : edge->caller->count)))\n+\t     ? edge->caller->global.inlined_to->count\n+\t     : edge->caller->count)))\n     hints |= INLINE_HINT_known_hot;\n \n   known_vals.release ();"}, {"sha": "8900556ef10d891c9f26a4c9aac894a7c483de99", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -123,8 +123,8 @@ typedef fibonacci_node <sreal, cgraph_edge> edge_heap_node_t;\n \n /* Statistics we collect about inlining algorithm.  */\n static int overall_size;\n-static gcov_type max_count;\n-static gcov_type spec_rem;\n+static profile_count max_count;\n+static profile_count spec_rem;\n \n /* Pre-computed constants 1/CGRAPH_FREQ_BASE and 1/100. */\n static sreal cgraph_freq_base_rec, percent_rec;\n@@ -637,8 +637,10 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n \n-  if (edge->count && caller->count)\n-    uninlined_call_time *= (sreal)edge->count / caller->count;\n+  if (edge->count > profile_count::zero ()\n+      && caller->count > profile_count::zero ())\n+    uninlined_call_time *= (sreal)edge->count.to_gcov_type ()\n+\t\t\t   / caller->count.to_gcov_type ();\n   if (edge->frequency)\n     uninlined_call_time *= cgraph_freq_base_rec * edge->frequency;\n   else\n@@ -660,8 +662,9 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n \t\t\t : edge->caller);\n   sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n-  if (edge->count && caller->count)\n-    time *= (sreal)edge->count / caller->count;\n+  if (edge->count > profile_count::zero ()\n+      && caller->count > profile_count::zero ())\n+    time *= (sreal)edge->count.to_gcov_type () / caller->count.to_gcov_type ();\n   if (edge->frequency)\n     time *= cgraph_freq_base_rec * edge->frequency;\n   else\n@@ -718,15 +721,16 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      promote non-inline functions to inline and we increase\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n-\t   && (!e->count || !e->maybe_hot_p ()))\n+\t   && (!e->count.initialized_p () || !e->maybe_hot_p ()))\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n-  else if ((DECL_DECLARED_INLINE_P (callee->decl) || e->count)\n+  else if ((DECL_DECLARED_INLINE_P (callee->decl)\n+\t    || e->count > profile_count::zero ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n@@ -836,7 +840,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       reason = \"recursive call is cold\";\n       want_inline = false;\n     }\n-  else if (max_count && !outer_node->count)\n+  else if (outer_node->count == profile_count::zero ())\n     {\n       reason = \"not executed in profile\";\n       want_inline = false;\n@@ -874,14 +878,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       int i;\n       for (i = 1; i < depth; i++)\n \tmax_prob = max_prob * max_prob / CGRAPH_FREQ_BASE;\n-      if (max_count\n-\t  && (edge->count * CGRAPH_FREQ_BASE / outer_node->count\n+      if (max_count > profile_count::zero () && edge->count > profile_count::zero ()\n+\t  && (edge->count.to_gcov_type () * CGRAPH_FREQ_BASE\n+\t      / outer_node->count.to_gcov_type ()\n \t      >= max_prob))\n \t{\n \t  reason = \"profile of recursive call is too large\";\n \t  want_inline = false;\n \t}\n-      if (!max_count\n+      if (max_count == profile_count::zero ()\n \t  && (edge->frequency * CGRAPH_FREQ_BASE / caller_freq\n \t      >= max_prob))\n \t{\n@@ -907,14 +912,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n      methods.  */\n   else\n     {\n-      if (max_count\n-\t  && (edge->count * 100 / outer_node->count\n+      if (max_count > profile_count::zero ()\n+\t  && (edge->count.to_gcov_type () * 100\n+\t      / outer_node->count.to_gcov_type ()\n \t      <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n \t  reason = \"profile of recursive call is too small\";\n \t  want_inline = false;\n \t}\n-      else if (!max_count\n+      else if (max_count == profile_count::zero ()\n \t       && (edge->frequency * 100 / caller_freq\n \t           <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n@@ -1058,7 +1064,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n      Again use negative value to make calls with profile appear hotter\n      then calls without.\n   */\n-  else if (opt_for_fn (caller->decl, flag_guess_branch_prob) || caller->count)\n+  else if (opt_for_fn (caller->decl, flag_guess_branch_prob)\n+\t   || caller->count > profile_count::zero ())\n     {\n       sreal numerator, denominator;\n       int overall_growth;\n@@ -1068,8 +1075,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   - inlined_time);\n       if (numerator == 0)\n \tnumerator = ((sreal) 1 >> 8);\n-      if (caller->count)\n-\tnumerator *= caller->count;\n+      if (caller->count > profile_count::zero ())\n+\tnumerator *= caller->count.to_gcov_type ();\n       else if (opt_for_fn (caller->decl, flag_branch_probabilities))\n \tnumerator = numerator >> 11;\n       denominator = growth;\n@@ -1155,7 +1162,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" %i (compensated)\\n\",\n \t\t   badness.to_double (),\n \t\t  (double)edge->frequency / CGRAPH_FREQ_BASE,\n-\t\t   edge->count, caller->count,\n+\t\t   edge->count.initialized_p () ? edge->count.to_gcov_type () : -1,\n+\t\t   caller->count.initialized_p () ? caller->count.to_gcov_type () : -1,\n \t\t   compute_uninlined_call_time (edge,\n \t\t\t\t\t\tunspec_edge_time).to_double (),\n \t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n@@ -1417,8 +1425,10 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n       {\n \t/* When profile feedback is available, prioritize by expected number\n \t   of calls.  */\n-        heap->insert (!max_count ? -e->frequency\n-\t\t      : -(e->count / ((max_count + (1<<24) - 1) / (1<<24))),\n+        heap->insert (!(max_count > 0) || !e->count.initialized_p () ? -e->frequency\n+\t\t      : -(e->count.to_gcov_type ()\n+\t\t\t/ ((max_count.to_gcov_type () + (1<<24) - 1)\n+\t\t\t   / (1<<24))),\n \t\t      e);\n       }\n   for (e = where->callees; e; e = e->next_callee)\n@@ -1506,10 +1516,11 @@ recursive_inlining (struct cgraph_edge *edge,\n \t{\n \t  fprintf (dump_file,\n \t\t   \"   Inlining call of depth %i\", depth);\n-\t  if (node->count)\n+\t  if (node->count > profile_count::zero ())\n \t    {\n \t      fprintf (dump_file, \" called approx. %.2f times per call\",\n-\t\t       (double)curr->count / node->count);\n+\t\t       (double)curr->count.to_gcov_type ()\n+\t\t       / node->count.to_gcov_type ());\n \t    }\n \t  fprintf (dump_file, \"\\n\");\n \t}\n@@ -1731,7 +1742,7 @@ inline_small_functions (void)\n   /* Compute overall unit size and other global parameters used by badness\n      metrics.  */\n \n-  max_count = 0;\n+  max_count = profile_count::uninitialized ();\n   ipa_reduced_postorder (order, true, true, NULL);\n   free (order);\n \n@@ -1771,7 +1782,7 @@ inline_small_functions (void)\n \t  }\n \n \tfor (edge = node->callers; edge; edge = edge->next_caller)\n-\t  if (max_count < edge->count)\n+\t  if (!(max_count >= edge->count))\n \t    max_count = edge->count;\n       }\n   ipa_free_postorder_info ();\n@@ -1835,7 +1846,7 @@ inline_small_functions (void)\n     }\n \n   gcc_assert (in_lto_p\n-\t      || !max_count\n+\t      || !(max_count > 0)\n \t      || (profile_info && flag_branch_probabilities));\n \n   while (!edge_heap.empty ())\n@@ -1880,9 +1891,7 @@ inline_small_functions (void)\n \t Increases of badness are handled lazilly; when we see key with out\n \t of date value on it, we re-insert it now.  */\n       current_badness = edge_badness (edge, false);\n-      /* Disable checking for profile because roundoff errors may cause slight\n-         deviations in the order.  */\n-      gcc_assert (max_count || cached_badness == current_badness);\n+      gcc_assert (cached_badness == current_badness);\n       gcc_assert (current_badness >= badness);\n #else\n       current_badness = edge_badness (edge, false);\n@@ -1927,9 +1936,12 @@ inline_small_functions (void)\n \t\t   : -1,\n \t\t   badness.to_double (),\n \t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n-\t  if (edge->count)\n-\t    fprintf (dump_file,\" Called %\" PRId64\"x\\n\",\n-\t\t     edge->count);\n+\t  if (edge->count.initialized_p ())\n+\t    {\n+\t      fprintf (dump_file, \" Called \");\n+\t      edge->count.dump (dump_file);\n+\t      fprintf (dump_file, \"times\\n\");\n+            }\n \t  if (dump_flags & TDF_DETAILS)\n \t    edge_badness (edge, true);\n \t}\n@@ -2027,7 +2039,7 @@ inline_small_functions (void)\n       update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n       /* Offline copy count has possibly changed, recompute if profile is\n \t available.  */\n-      if (max_count)\n+      if (max_count > profile_count::zero ())\n         {\n \t  struct cgraph_node *n = cgraph_node::get (edge->callee->decl);\n \t  if (n != edge->callee && n->analyzed)\n@@ -2233,7 +2245,8 @@ dump_overall_stats (void)\n       {\n \tsreal time = ipa_fn_summaries->get (node)->time;\n \tsum += time;\n-\tsum_weighted += time * node->count;\n+\tif (node->count.initialized_p ())\n+\t  sum_weighted += time * node->count.to_gcov_type ();\n       }\n   fprintf (dump_file, \"Overall time estimate: \"\n \t   \"%f weighted by profile: \"\n@@ -2263,56 +2276,59 @@ dump_inline_stats (void)\n       {\n \tif (e->inline_failed)\n \t  {\n-\t    reason[(int) e->inline_failed][0] += e->count;\n+\t    if (e->count.initialized_p ())\n+\t      reason[(int) e->inline_failed][0] += e->count.to_gcov_type ();\n \t    reason[(int) e->inline_failed][1] += e->frequency;\n \t    reason[(int) e->inline_failed][2] ++;\n-\t    if (DECL_VIRTUAL_P (e->callee->decl))\n+\t    if (DECL_VIRTUAL_P (e->callee->decl)\n+\t\t&& e->count.initialized_p ())\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  noninlined_virt_indir_cnt += e->count;\n+\t\t  noninlined_virt_indir_cnt += e->count.to_gcov_type ();\n \t\telse\n-\t\t  noninlined_virt_cnt += e->count;\n+\t\t  noninlined_virt_cnt += e->count.to_gcov_type ();\n \t      }\n-\t    else\n+\t    else if (e->count.initialized_p ())\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  noninlined_indir_cnt += e->count;\n+\t\t  noninlined_indir_cnt += e->count.to_gcov_type ();\n \t\telse\n-\t\t  noninlined_cnt += e->count;\n+\t\t  noninlined_cnt += e->count.to_gcov_type ();\n \t      }\n \t  }\n-\telse\n+\telse if (e->count.initialized_p ())\n \t  {\n \t    if (e->speculative)\n \t      {\n \t\tif (DECL_VIRTUAL_P (e->callee->decl))\n-\t\t  inlined_speculative_ply += e->count;\n+\t\t  inlined_speculative_ply += e->count.to_gcov_type ();\n \t\telse\n-\t\t  inlined_speculative += e->count;\n+\t\t  inlined_speculative += e->count.to_gcov_type ();\n \t      }\n \t    else if (DECL_VIRTUAL_P (e->callee->decl))\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  inlined_virt_indir_cnt += e->count;\n+\t\t  inlined_virt_indir_cnt += e->count.to_gcov_type ();\n \t\telse\n-\t\t  inlined_virt_cnt += e->count;\n+\t\t  inlined_virt_cnt += e->count.to_gcov_type ();\n \t      }\n \t    else\n \t      {\n \t\tif (e->indirect_inlining_edge)\n-\t\t  inlined_indir_cnt += e->count;\n+\t\t  inlined_indir_cnt += e->count.to_gcov_type ();\n \t\telse\n-\t\t  inlined_cnt += e->count;\n+\t\t  inlined_cnt += e->count.to_gcov_type ();\n \t      }\n \t  }\n       }\n     for (e = node->indirect_calls; e; e = e->next_callee)\n-      if (e->indirect_info->polymorphic)\n-\tindirect_poly_cnt += e->count;\n-      else\n-\tindirect_cnt += e->count;\n+      if (e->indirect_info->polymorphic\n+\t  & e->count.initialized_p ())\n+\tindirect_poly_cnt += e->count.to_gcov_type ();\n+      else if (e->count.initialized_p ())\n+\tindirect_cnt += e->count.to_gcov_type ();\n   }\n-  if (max_count)\n+  if (max_count.initialized_p ())\n     {\n       fprintf (dump_file,\n \t       \"Inlined %\" PRId64 \" + speculative \"\n@@ -2331,9 +2347,9 @@ dump_inline_stats (void)\n \t       inlined_indir_cnt, inlined_virt_cnt, inlined_virt_indir_cnt,\n \t       noninlined_cnt, noninlined_indir_cnt, noninlined_virt_cnt,\n \t       noninlined_virt_indir_cnt, indirect_cnt, indirect_poly_cnt);\n-      fprintf (dump_file,\n-\t       \"Removed speculations %\" PRId64 \"\\n\",\n-\t       spec_rem);\n+      fprintf (dump_file, \"Removed speculations \");\n+      spec_rem.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n     }\n   dump_overall_stats ();\n   fprintf (dump_file, \"\\nWhy inlining failed?\\n\");"}, {"sha": "05cad3f85b177429d90edb6870c0eb552885c4a4", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -222,7 +222,9 @@ ipa_profile_generate_summary (void)\n \t    time += estimate_num_insns (stmt, &eni_time_weights);\n \t    size += estimate_num_insns (stmt, &eni_size_weights);\n \t  }\n-\taccount_time_size (&hashtable, histogram, bb->count, time, size);\n+\tif (bb->count.initialized_p ())\n+\t  account_time_size (&hashtable, histogram, bb->count.to_gcov_type (),\n+\t\t\t     time, size);\n       }\n   histogram.qsort (cmp_counts);\n }\n@@ -428,10 +430,11 @@ ipa_propagate_frequency (struct cgraph_node *node)\n     }\n \n   /* With profile we can decide on hot/normal based on count.  */\n-  if (node->count)\n+  if (node->count.initialized_p ())\n     {\n       bool hot = false;\n-      if (node->count >= get_hot_bb_threshold ())\n+      if (!(node->count == profile_count::zero ())\n+\t  && node->count >= get_hot_bb_threshold ())\n \thot = true;\n       if (!hot)\n \thot |= contains_hot_call_p (node);\n@@ -576,7 +579,7 @@ ipa_profile (void)\n \n       for (e = n->indirect_calls; e; e = e->next_callee)\n \t{\n-\t  if (n->count)\n+\t  if (n->count.initialized_p ())\n \t    nindirect++;\n \t  if (e->indirect_info->common_target_id)\n \t    {\n@@ -662,8 +665,8 @@ ipa_profile (void)\n \t\t      nconverted++;\n \t\t      e->make_speculative\n \t\t\t(n2,\n-\t\t\t apply_scale (e->count,\n-\t\t\t\t      e->indirect_info->common_target_probability),\n+\t\t\t e->count.apply_probability\n+\t\t\t\t     (e->indirect_info->common_target_probability),\n \t\t\t apply_scale (e->frequency,\n \t\t\t\t      e->indirect_info->common_target_probability));\n \t\t      update = true;"}, {"sha": "c73ffd7b5866015d1e233c7aef1311376c53b526", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -2982,7 +2982,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t}\n       /* make_speculative will update ie's cost to direct call cost. */\n       ie = ie->make_speculative\n-\t     (callee, ie->count * 8 / 10, ie->frequency * 8 / 10);\n+\t     (callee, ie->count.apply_scale (8, 10), ie->frequency * 8 / 10);\n     }\n \n   return ie;"}, {"sha": "731512482349448fbc77fc48681e4593b01b8124", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -402,7 +402,9 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (src->profile_id && !dst->profile_id)\n     dst->profile_id = src->profile_id;\n \n-  if (!dst->count)\n+  /* FIXME when we merge in unknown profile, we ought to set counts as\n+     unsafe.  */\n+  if (!dst->count.initialized_p ())\n     return;\n   if (symtab->dump_file)\n     {\n@@ -543,7 +545,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       for (e = dst->indirect_calls, e2 = src->indirect_calls; e;\n \t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n-\t  gcov_type count = gimple_bb (e->call_stmt)->count;\n+\t  profile_count count = gimple_bb (e->call_stmt)->count;\n \t  int freq = compute_call_stmt_bb_frequency\n \t\t\t(dst->decl,\n \t\t\t gimple_bb (e->call_stmt));\n@@ -561,7 +563,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      gcc_assert (e == indirect);\n \t      if (e2 && e2->speculative)\n \t        e2->speculative_call_info (direct2, indirect2, ref);\n-\t      if (indirect->count || direct->count)\n+\t      if (indirect->count > profile_count::zero ()\n+\t\t  || direct->count > profile_count::zero ())\n \t\t{\n \t\t  /* We should mismatch earlier if there is no matching\n \t\t     indirect edge.  */\n@@ -594,8 +597,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t   indirect->count += indirect2->count;\n \t\t\t}\n \t\t    }\n-\t\t  int  prob = RDIV (direct->count * REG_BR_PROB_BASE ,\n-\t\t\t\t    direct->count + indirect->count);\n+\t\t  int  prob = direct->count.probability_in (direct->count\n+\t\t\t\t\t\t\t    + indirect->count);\n \t\t  direct->frequency = RDIV (freq * prob, REG_BR_PROB_BASE);\n \t\t  indirect->frequency = RDIV (freq * (REG_BR_PROB_BASE - prob),\n \t\t\t\t\t      REG_BR_PROB_BASE);\n@@ -613,7 +616,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t      e2->speculative_call_info (direct, indirect, ref);\n \t      e->count = count;\n \t      e->frequency = freq;\n-\t      int prob = RDIV (direct->count * REG_BR_PROB_BASE, e->count);\n+\t      int prob = direct->count.probability_in (e->count);\n \t      e->make_speculative (direct->callee, direct->count,\n \t\t\t\t   RDIV (freq * prob, REG_BR_PROB_BASE));\n \t    }"}, {"sha": "05daabb22fba2e484b5c6a8882f910689a7edb08", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -506,7 +506,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n       redirect_edge_and_branch_force (single_succ_edge (preheader), new_preheader);\n       set_immediate_dominator (CDI_DOMINATORS, new_preheader, preheader);\n \n-      set_zero->count = 0;\n+      set_zero->count = profile_count::uninitialized ();\n       set_zero->frequency = 0;\n \n       te = single_succ_edge (preheader);"}, {"sha": "e39766c2a79f2528ec7a465d07d622ea60310349", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -202,10 +202,10 @@ report_unroll (struct loop *loop, location_t locus)\n   dump_printf_loc (report_flags, locus,\n                    \"loop unrolled %d times\",\n                    loop->lpt_decision.times);\n-  if (profile_info)\n+  if (profile_info && loop->header->count.initialized_p ())\n     dump_printf (report_flags,\n                  \" (header execution count %d)\",\n-                 (int)loop->header->count);\n+                 (int)loop->header->count.to_gcov_type ());\n \n   dump_printf (report_flags, \"\\n\");\n }\n@@ -860,7 +860,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   unsigned i, j, p;\n   basic_block preheader, *body, swtch, ezc_swtch = NULL;\n   int may_exit_copy, iter_freq, new_freq;\n-  gcov_type iter_count, new_count;\n+  profile_count iter_count, new_count;\n   unsigned n_peel;\n   edge e;\n   bool extra_zero_check, last_may_exit;\n@@ -970,7 +970,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n      innermost switch block.  Switch blocks and peeled loop copies are built\n      from innermost outward.  */\n   iter_freq = new_freq = swtch->frequency / (max_unroll + 1);\n-  iter_count = new_count = swtch->count / (max_unroll + 1);\n+  iter_count = new_count = swtch->count.apply_scale (1, max_unroll + 1);\n   swtch->frequency = new_freq;\n   swtch->count = new_count;\n   single_succ_edge (swtch)->count = new_count;\n@@ -1027,7 +1027,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       /* Recompute frequency/count adjustments since initial peel copy may\n \t have exited and reduced those values that were computed above.  */\n       iter_freq = swtch->frequency / (max_unroll + 1);\n-      iter_count = swtch->count / (max_unroll + 1);\n+      iter_count = swtch->count.apply_scale (1, max_unroll + 1);\n       /* Add in frequency/count of edge from switch block.  */\n       preheader->frequency += iter_freq;\n       preheader->count += iter_count;"}, {"sha": "e2680277bb5f2ccfcb8b695578ad8b3381c9e615", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -256,7 +256,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  streamer_write_gcov_count_stream (ob->main_stream, edge->count);\n+  edge->count.stream_out (ob->main_stream);\n \n   bp = bitpack_create (ob->main_stream);\n   uid = (!gimple_has_body_p (edge->caller->decl) || edge->caller->thunk.thunk_p\n@@ -458,7 +458,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n \n   lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n-  streamer_write_gcov_count_stream (ob->main_stream, node->count);\n+  node->count.stream_out (ob->main_stream);\n   streamer_write_hwi_stream (ob->main_stream, node->count_materialization_scale);\n \n   streamer_write_hwi_stream (ob->main_stream,\n@@ -1246,7 +1246,7 @@ input_node (struct lto_file_decl_data *file_data,\n   if (clone_ref != LCC_NOT_FOUND)\n     {\n       node = dyn_cast<cgraph_node *> (nodes[clone_ref])->create_clone (fn_decl,\n-\t0, CGRAPH_FREQ_BASE, false,\n+\tprofile_count::uninitialized (), CGRAPH_FREQ_BASE, false,\n \tvNULL, false, NULL, NULL);\n     }\n   else\n@@ -1263,7 +1263,7 @@ input_node (struct lto_file_decl_data *file_data,\n   if (order >= symtab->order)\n     symtab->order = order + 1;\n \n-  node->count = streamer_read_gcov_count (ib);\n+  node->count = profile_count::stream_in (ib);\n   node->count_materialization_scale = streamer_read_hwi (ib);\n \n   count = streamer_read_hwi (ib);\n@@ -1461,7 +1461,7 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   struct cgraph_node *caller, *callee;\n   struct cgraph_edge *edge;\n   unsigned int stmt_id;\n-  gcov_type count;\n+  profile_count count;\n   int freq;\n   cgraph_inline_failed_t inline_failed;\n   struct bitpack_d bp;\n@@ -1480,7 +1480,7 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   else\n     callee = NULL;\n \n-  count = streamer_read_gcov_count (ib);\n+  count = profile_count::stream_in (ib);\n \n   bp = streamer_read_bitpack (ib);\n   inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_t, CIF_N_REASONS);\n@@ -1821,8 +1821,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n \tif (scale == REG_BR_PROB_BASE)\n \t  continue;\n \tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  edge->count = apply_scale (edge->count, scale);\n-\tnode->count = apply_scale (node->count, scale);\n+\t  edge->count = edge->count.apply_scale (scale, REG_BR_PROB_BASE);\n+\tnode->count = node->count.apply_scale (scale, REG_BR_PROB_BASE);\n       }\n }\n "}, {"sha": "ccc8cf602df0b1abbce52aa3b4a92cd0508fc0f5", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -755,13 +755,13 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \t  unsigned int edge_flags;\n \t  basic_block dest;\n \t  int probability;\n-\t  gcov_type count;\n+\t  profile_count count;\n \t  edge e;\n \n \t  dest_index = streamer_read_uhwi (ib);\n \t  probability = (int) streamer_read_hwi (ib);\n-\t  count = apply_scale ((gcov_type) streamer_read_gcov_count (ib),\n-                               count_materialization_scale);\n+\t  count = profile_count::stream_in (ib).apply_scale\n+\t\t\t (count_materialization_scale, REG_BR_PROB_BASE);\n \t  edge_flags = streamer_read_uhwi (ib);\n \n \t  dest = BASIC_BLOCK_FOR_FN (fn, dest_index);"}, {"sha": "9378d5cf7b42f51a80116f8dff2c4eef61c3e7e3", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1861,7 +1861,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n \t{\n \t  streamer_write_uhwi (ob, e->dest->index);\n \t  streamer_write_hwi (ob, e->probability);\n-\t  streamer_write_gcov_count (ob, e->count);\n+\t  e->count.stream_out (ob);\n \t  streamer_write_uhwi (ob, e->flags);\n \t}\n     }"}, {"sha": "bb4b4f9ef76e5560598dbf5bb4e3927a7a9ae51b", "filename": "gcc/mcf.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -508,7 +508,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n   /* Compute constants b, k_pos, k_neg used in the cost function calculation.\n      b = sqrt(avg_vertex_weight(cfg)); k_pos = b; k_neg = 50b.  */\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    total_vertex_weight += bb->count;\n+    total_vertex_weight += bb_gcov_count (bb);\n \n   sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight /\n \t\t\t\t     n_basic_blocks_for_fn (cfun));\n@@ -526,8 +526,8 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n   {\n     /* v'->v'': index1->(index1+1).  */\n     i = 2 * bb->index;\n-    fcost = (gcov_type) COST (k_pos, bb->count);\n-    add_fixup_edge (fixup_graph, i, i + 1, VERTEX_SPLIT_EDGE, bb->count,\n+    fcost = (gcov_type) COST (k_pos, bb_gcov_count (bb));\n+    add_fixup_edge (fixup_graph, i, i + 1, VERTEX_SPLIT_EDGE, bb_gcov_count (bb),\n                     fcost, CAP_INFINITY);\n     fixup_graph->num_vertices++;\n \n@@ -538,9 +538,9 @@ create_fixup_graph (fixup_graph_type *fixup_graph)\n       if (EDGE_INFO (e) && EDGE_INFO (e)->ignore)\n         continue;\n       j = 2 * e->dest->index;\n-      fcost = (gcov_type) COST (k_pos, e->count);\n-      add_fixup_edge (fixup_graph, i + 1, j, REDIRECT_EDGE, e->count, fcost,\n-                      CAP_INFINITY);\n+      fcost = (gcov_type) COST (k_pos, edge_gcov_count (e));\n+      add_fixup_edge (fixup_graph, i + 1, j, REDIRECT_EDGE, edge_gcov_count (e),\n+\t\t      fcost, CAP_INFINITY);\n     }\n   }\n \n@@ -1132,12 +1132,12 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n       /* Fixup BB.  */\n       if (dump_file)\n         fprintf (dump_file,\n-                 \"BB%d: %\" PRId64 \"\", bb->index, bb->count);\n+                 \"BB%d: %\" PRId64 \"\", bb->index, bb_gcov_count (bb));\n \n       pfedge = find_fixup_edge (fixup_graph, i, i + 1);\n       if (pfedge->flow)\n         {\n-          bb->count += pfedge->flow;\n+          bb_gcov_count (bb) += pfedge->flow;\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \" + %\" PRId64 \"(\",\n@@ -1152,7 +1152,7 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n       /* Deduct flow from normalized reverse edge.  */\n       if (pfedge->norm_vertex_index && pfedge_n->flow)\n         {\n-          bb->count -= pfedge_n->flow;\n+          bb_gcov_count (bb) -= pfedge_n->flow;\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \" - %\" PRId64 \"(\",\n@@ -1163,7 +1163,7 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t    }\n         }\n       if (dump_file)\n-        fprintf (dump_file, \" = %\" PRId64 \"\\n\", bb->count);\n+        fprintf (dump_file, \" = %\" PRId64 \"\\n\", bb_gcov_count (bb));\n \n       /* Fixup edge.  */\n       FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1175,7 +1175,7 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n           j = 2 * e->dest->index;\n           if (dump_file)\n \t    fprintf (dump_file, \"%d->%d: %\" PRId64 \"\",\n-\t\t     bb->index, e->dest->index, e->count);\n+\t\t     bb->index, e->dest->index, edge_gcov_count (e));\n \n           pfedge = find_fixup_edge (fixup_graph, i + 1, j);\n \n@@ -1184,7 +1184,7 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t      /* Non-self edge.  */\n \t      if (pfedge->flow)\n \t        {\n-\t          e->count += pfedge->flow;\n+\t          edge_gcov_count (e) += pfedge->flow;\n \t          if (dump_file)\n \t\t    {\n \t\t      fprintf (dump_file, \" + %\" PRId64 \"(\",\n@@ -1199,7 +1199,7 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t      /* Deduct flow from normalized reverse edge.  */\n \t      if (pfedge->norm_vertex_index && pfedge_n->flow)\n \t        {\n-\t          e->count -= pfedge_n->flow;\n+\t          edge_gcov_count (e) -= pfedge_n->flow;\n \t          if (dump_file)\n \t\t    {\n \t\t      fprintf (dump_file, \" - %\" PRId64 \"(\",\n@@ -1217,8 +1217,8 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t      pfedge = find_fixup_edge (fixup_graph, j, i + 1);\n \t      pfedge_n =\n \t        find_fixup_edge (fixup_graph, i + 1, pfedge->norm_vertex_index);\n-\t      e->count += pfedge_n->flow;\n-\t      bb->count += pfedge_n->flow;\n+\t      edge_gcov_count (e) += pfedge_n->flow;\n+\t      bb_gcov_count (bb) += pfedge_n->flow;\n \t      if (dump_file)\n \t        {\n \t          fprintf (dump_file, \"(self edge)\");\n@@ -1230,26 +1230,29 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t        }\n \t    }\n \n-          if (bb->count)\n-\t    e->probability = REG_BR_PROB_BASE * e->count / bb->count;\n+          if (bb_gcov_count (bb))\n+\t    e->probability = RDIV (REG_BR_PROB_BASE * edge_gcov_count (e),\n+\t\t\t           bb_gcov_count (bb));\n           if (dump_file)\n \t    fprintf (dump_file, \" = %\" PRId64 \"\\t(%.1f%%)\\n\",\n-\t\t     e->count, e->probability * 100.0 / REG_BR_PROB_BASE);\n+\t\t     edge_gcov_count (e),\n+\t\t     e->probability * 100.0 / REG_BR_PROB_BASE);\n         }\n     }\n \n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+  bb_gcov_count (ENTRY_BLOCK_PTR_FOR_FN (cfun)) =\n \t\t     sum_edge_counts (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+  bb_gcov_count (EXIT_BLOCK_PTR_FOR_FN (cfun)) =\n \t\t     sum_edge_counts (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n   /* Compute edge probabilities.  */\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-      if (bb->count)\n+      if (bb_gcov_count (bb))\n         {\n           FOR_EACH_EDGE (e, ei, bb->succs)\n-            e->probability = REG_BR_PROB_BASE * e->count / bb->count;\n+            e->probability = RDIV (REG_BR_PROB_BASE * edge_gcov_count (e),\n+\t\t\t\t   bb_gcov_count (bb));\n         }\n       else\n         {\n@@ -1282,15 +1285,15 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)\n \t       current_function_name ());\n       FOR_EACH_BB_FN (bb, cfun)\n         {\n-          if ((bb->count != sum_edge_counts (bb->preds))\n-               || (bb->count != sum_edge_counts (bb->succs)))\n+          if ((bb_gcov_count (bb) != sum_edge_counts (bb->preds))\n+               || (bb_gcov_count (bb) != sum_edge_counts (bb->succs)))\n             {\n               fprintf (dump_file,\n                        \"BB%d(%\" PRId64 \")  **INVALID**: \",\n-                       bb->index, bb->count);\n+                       bb->index, bb_gcov_count (bb));\n               fprintf (stderr,\n                        \"******** BB%d(%\" PRId64\n-                       \")  **INVALID**: \\n\", bb->index, bb->count);\n+                       \")  **INVALID**: \\n\", bb->index, bb_gcov_count (bb));\n               fprintf (dump_file, \"in_edges=%\" PRId64 \" \",\n                        sum_edge_counts (bb->preds));\n               fprintf (dump_file, \"out_edges=%\" PRId64 \"\\n\",\n@@ -1378,7 +1381,7 @@ sum_edge_counts (vec<edge, va_gc> *to_edges)\n     {\n       if (EDGE_INFO (e) && EDGE_INFO (e)->ignore)\n         continue;\n-      sum += e->count;\n+      sum += edge_gcov_count (e);\n     }\n   return sum;\n }"}, {"sha": "005c6e596ad526bc0dc7cdbac1ae224417403d1a", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1422,13 +1422,16 @@ sms_schedule (void)\n       get_ebb_head_tail (bb, bb, &head, &tail);\n       latch_edge = loop_latch_edge (loop);\n       gcc_assert (single_exit (loop));\n-      if (single_exit (loop)->count)\n-\ttrip_count = latch_edge->count / single_exit (loop)->count;\n+      if (single_exit (loop)->count > profile_count::zero ())\n+\ttrip_count = latch_edge->count.to_gcov_type ()\n+\t\t     / single_exit (loop)->count.to_gcov_type ();\n \n       /* Perform SMS only on loops that their average count is above threshold.  */\n \n-      if ( latch_edge->count\n-          && (latch_edge->count < single_exit (loop)->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n+      if ( latch_edge->count > profile_count::zero ()\n+          && (latch_edge->count\n+\t      < single_exit (loop)->count.apply_scale\n+\t\t\t\t (SMS_LOOP_AVERAGE_COUNT_THRESHOLD, 1)))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1438,7 +1441,7 @@ sms_schedule (void)\n \t    \t{\n \t      \t  fprintf (dump_file, \"SMS loop-count \");\n \t      \t  fprintf (dump_file, \"%\" PRId64,\n-\t             \t   (int64_t) bb->count);\n+\t             \t   (int64_t) bb->count.to_gcov_type ());\n \t      \t  fprintf (dump_file, \"\\n\");\n                   fprintf (dump_file, \"SMS trip-count \");\n                   fprintf (dump_file, \"%\" PRId64,\n@@ -1549,8 +1552,9 @@ sms_schedule (void)\n \n       latch_edge = loop_latch_edge (loop);\n       gcc_assert (single_exit (loop));\n-      if (single_exit (loop)->count)\n-\ttrip_count = latch_edge->count / single_exit (loop)->count;\n+      if (single_exit (loop)->count > profile_count::zero ())\n+\ttrip_count = latch_edge->count.to_gcov_type ()\n+\t\t     / single_exit (loop)->count.to_gcov_type ();\n \n       if (dump_file)\n \t{\n@@ -1560,7 +1564,7 @@ sms_schedule (void)\n \t    {\n \t      fprintf (dump_file, \"SMS loop-count \");\n \t      fprintf (dump_file, \"%\" PRId64,\n-\t               (int64_t) bb->count);\n+\t               (int64_t) bb->count.to_gcov_type ());\n \t      fprintf (dump_file, \"\\n\");\n \t      fprintf (dump_file, \"SMS profile-sum-max \");\n \t      fprintf (dump_file, \"%\" PRId64,"}, {"sha": "e3632a26f66ffd3366c5f392c290a6372c99e2ef", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1045,14 +1045,16 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n   struct unoccr *occr, *avail_occrs = NULL;\n   struct unoccr *unoccr, *unavail_occrs = NULL, *rollback_unoccr = NULL;\n   int npred_ok = 0;\n-  gcov_type ok_count = 0; /* Redundant load execution count.  */\n-  gcov_type critical_count = 0; /* Execution count of critical edges.  */\n+  profile_count ok_count = profile_count::zero ();\n+\t\t /* Redundant load execution count.  */\n+  profile_count critical_count = profile_count::zero ();\n+\t\t /* Execution count of critical edges.  */\n   edge_iterator ei;\n   bool critical_edge_split = false;\n \n   /* The execution count of the loads to be added to make the\n      load fully redundant.  */\n-  gcov_type not_ok_count = 0;\n+  profile_count not_ok_count = profile_count::zero ();\n   basic_block pred_bb;\n \n   pat = PATTERN (insn);\n@@ -1106,13 +1108,14 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t    avail_insn = NULL;\n \t}\n \n-      if (EDGE_CRITICAL_P (pred))\n+      if (EDGE_CRITICAL_P (pred) && pred->count.initialized_p ())\n \tcritical_count += pred->count;\n \n       if (avail_insn != NULL_RTX)\n \t{\n \t  npred_ok++;\n-\t  ok_count += pred->count;\n+\t  if (pred->count.initialized_p ())\n+\t    ok_count = ok_count + pred->count;\n \t  if (! set_noop_p (PATTERN (gen_move_insn (copy_rtx (dest),\n \t\t\t\t\t\t    copy_rtx (avail_reg)))))\n \t    {\n@@ -1136,7 +1139,8 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t  /* Adding a load on a critical edge will cause a split.  */\n \t  if (EDGE_CRITICAL_P (pred))\n \t    critical_edge_split = true;\n-\t  not_ok_count += pred->count;\n+\t  if (pred->count.initialized_p ())\n+\t    not_ok_count = not_ok_count + pred->count;\n \t  unoccr = (struct unoccr *) obstack_alloc (&unoccr_obstack,\n \t\t\t\t\t\t    sizeof (struct unoccr));\n \t  unoccr->insn = NULL;\n@@ -1160,9 +1164,11 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n     goto cleanup;\n \n   /* Check if it's worth applying the partial redundancy elimination.  */\n-  if (ok_count < GCSE_AFTER_RELOAD_PARTIAL_FRACTION * not_ok_count)\n+  if (ok_count.to_gcov_type ()\n+      < GCSE_AFTER_RELOAD_PARTIAL_FRACTION * not_ok_count.to_gcov_type ())\n     goto cleanup;\n-  if (ok_count < GCSE_AFTER_RELOAD_CRITICAL_FRACTION * critical_count)\n+  if (ok_count.to_gcov_type ()\n+      < GCSE_AFTER_RELOAD_CRITICAL_FRACTION * critical_count.to_gcov_type ())\n     goto cleanup;\n \n   /* Generate moves to the loaded register from where"}, {"sha": "8eb28634b2feaf83197328b07f93b5869c9768c0", "filename": "gcc/predict.c", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -172,14 +172,14 @@ set_hot_bb_threshold (gcov_type min)\n /* Return TRUE if frequency FREQ is considered to be hot.  */\n \n bool\n-maybe_hot_count_p (struct function *fun, gcov_type count)\n+maybe_hot_count_p (struct function *, profile_count count)\n {\n-  if (fun && profile_status_for_fn (fun) != PROFILE_READ)\n+  if (!count.initialized_p ())\n     return true;\n   /* Code executed at most once is not hot.  */\n-  if (profile_info->runs >= count)\n+  if (count <= MAX (profile_info ? profile_info->runs : 1, 1))\n     return false;\n-  return (count >= get_hot_bb_threshold ());\n+  return (count.to_gcov_type () >= get_hot_bb_threshold ());\n }\n \n /* Return true in case BB can be CPU intensive and should be optimized\n@@ -210,42 +210,17 @@ maybe_hot_edge_p (edge e)\n    \n static bool\n probably_never_executed (struct function *fun,\n-                         gcov_type count, int frequency)\n+                         profile_count count, int)\n {\n   gcc_checking_assert (fun);\n-  if (profile_status_for_fn (fun) == PROFILE_READ)\n+  if (count.initialized_p () && profile_status_for_fn (fun) == PROFILE_READ)\n     {\n-      int unlikely_count_fraction = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n-      if (count * unlikely_count_fraction >= profile_info->runs)\n-\treturn false;\n-      if (!frequency)\n+      if (count == profile_count::zero ())\n \treturn true;\n-      if (!ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency)\n+\n+      int unlikely_count_fraction = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n+      if (count.apply_scale (unlikely_count_fraction, 1) >= profile_info->runs)\n \treturn false;\n-      if (ENTRY_BLOCK_PTR_FOR_FN (fun)->count)\n-\t{\n-          gcov_type computed_count;\n-          /* Check for possibility of overflow, in which case entry bb count\n-             is large enough to do the division first without losing much\n-             precision.  */\n-\t  if (ENTRY_BLOCK_PTR_FOR_FN (fun)->count < REG_BR_PROB_BASE *\n-\t      REG_BR_PROB_BASE)\n-            {\n-              gcov_type scaled_count\n-\t\t  = frequency * ENTRY_BLOCK_PTR_FOR_FN (fun)->count *\n-\t     unlikely_count_fraction;\n-\t      computed_count = RDIV (scaled_count,\n-\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency);\n-            }\n-          else\n-            {\n-\t      computed_count = RDIV (ENTRY_BLOCK_PTR_FOR_FN (fun)->count,\n-\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency);\n-              computed_count *= frequency * unlikely_count_fraction;\n-            }\n-          if (computed_count >= profile_info->runs)\n-            return false;\n-\t}\n       return true;\n     }\n   if ((!profile_info || !(opt_for_fn (fun->decl, flag_branch_probabilities)))\n@@ -772,13 +747,16 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n \t   edge_info_str, reason_messages[reason],\n \t   probability * 100.0 / REG_BR_PROB_BASE);\n \n-  if (bb->count)\n+  if (bb->count.initialized_p ())\n     {\n-      fprintf (file, \"  exec %\" PRId64, bb->count);\n+      fprintf (file, \"  exec \");\n+      bb->count.dump (file);\n       if (e)\n \t{\n-\t  fprintf (file, \" hit %\" PRId64, e->count);\n-\t  fprintf (file, \" (%.1f%%)\", e->count * 100.0 / bb->count);\n+\t  fprintf (file, \" hit \");\n+\t  e->count.dump (file);\n+\t  fprintf (file, \" (%.1f%%)\", e->count.to_gcov_type() * 100.0\n+\t\t   / bb->count.to_gcov_type ());\n \t}\n     }\n \n@@ -1113,7 +1091,7 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n \t  if (pred->ep_probability <= PROB_VERY_UNLIKELY)\n \t    unlikely_edges.add (pred->ep_edge);\n \n-      if (!bb->count && !dry_run)\n+      if (!bb->count.initialized_p () && !dry_run)\n \tset_even_probabilities (bb, &unlikely_edges);\n       clear_bb_predictions (bb);\n       if (dump_file)\n@@ -1239,7 +1217,7 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n     }\n   clear_bb_predictions (bb);\n \n-  if (!bb->count && !dry_run)\n+  if (!bb->count.initialized_p () && !dry_run)\n     {\n       first->probability = combined_probability;\n       second->probability = REG_BR_PROB_BASE - combined_probability;\n@@ -3011,7 +2989,10 @@ propagate_freq (basic_block head, bitmap tovisit)\n       BLOCK_INFO (bb)->npredecessors = count;\n       /* When function never returns, we will never process exit block.  */\n       if (!count && bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\tbb->count = bb->frequency = 0;\n+\t{\n+\t  bb->count = profile_count::zero ();\n+\t  bb->frequency = 0;\n+\t}\n     }\n \n   BLOCK_INFO (head)->frequency = 1;\n@@ -3152,7 +3133,7 @@ estimate_loops (void)\n    whether it is expected to be hot given the CALL_COUNT.  */\n \n static void\n-drop_profile (struct cgraph_node *node, gcov_type call_count)\n+drop_profile (struct cgraph_node *node, profile_count call_count)\n {\n   struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n   /* In the case where this was called by another function with a\n@@ -3220,28 +3201,31 @@ handle_missing_profiles (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n       struct cgraph_edge *e;\n-      gcov_type call_count = 0;\n+      profile_count call_count = profile_count::zero ();\n       gcov_type max_tp_first_run = 0;\n       struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n \n-      if (node->count)\n+      if (!(node->count == profile_count::zero ()))\n         continue;\n       for (e = node->callers; e; e = e->next_caller)\n       {\n-        call_count += e->count;\n+\tif (e->count.initialized_p () > 0)\n+\t  {\n+            call_count = call_count + e->count;\n \n-\tif (e->caller->tp_first_run > max_tp_first_run)\n-\t  max_tp_first_run = e->caller->tp_first_run;\n+\t    if (e->caller->tp_first_run > max_tp_first_run)\n+\t      max_tp_first_run = e->caller->tp_first_run;\n+\t  }\n       }\n \n       /* If time profile is missing, let assign the maximum that comes from\n \t caller functions.  */\n       if (!node->tp_first_run && max_tp_first_run)\n \tnode->tp_first_run = max_tp_first_run + 1;\n \n-      if (call_count\n+      if (call_count > 0\n           && fn && fn->cfg\n-          && (call_count * unlikely_count_fraction >= profile_info->runs))\n+          && (call_count.apply_scale (unlikely_count_fraction, 1) >= profile_info->runs))\n         {\n           drop_profile (node, call_count);\n           worklist.safe_push (node);\n@@ -3265,7 +3249,7 @@ handle_missing_profiles (void)\n           if (DECL_COMDAT (callee->decl) && fn && fn->cfg\n               && profile_status_for_fn (fn) == PROFILE_READ)\n             {\n-              drop_profile (node, 0);\n+              drop_profile (node, profile_count::zero ());\n               worklist.safe_push (callee);\n             }\n         }\n@@ -3275,26 +3259,31 @@ handle_missing_profiles (void)\n /* Convert counts measured by profile driven feedback to frequencies.\n    Return nonzero iff there was any nonzero execution count.  */\n \n-int\n+bool\n counts_to_freqs (void)\n {\n-  gcov_type count_max, true_count_max = 0;\n+  gcov_type count_max;\n+  profile_count true_count_max = profile_count::zero ();\n   basic_block bb;\n \n   /* Don't overwrite the estimated frequencies when the profile for\n      the function is missing.  We may drop this function PROFILE_GUESSED\n      later in drop_profile ().  */\n-  if (!flag_auto_profile && !ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n+  if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.initialized_p ()\n+      || ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ())\n     return 0;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    true_count_max = MAX (bb->count, true_count_max);\n+    if (bb->count > true_count_max)\n+      true_count_max = bb->count;\n+\n+  count_max = MAX (true_count_max.to_gcov_type (), 1);\n \n-  count_max = MAX (true_count_max, 1);\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n+    if (bb->count.initialized_p ())\n+      bb->frequency = RDIV (bb->count.to_gcov_type () * BB_FREQ_MAX, count_max);\n \n-  return true_count_max;\n+  return !(true_count_max == profile_count::zero ());\n }\n \n /* Return true if function is likely to be expensive, so there is no point to\n@@ -3657,14 +3646,15 @@ rebuild_frequencies (void)\n      which may also lead to frequencies incorrectly reduced to 0. There\n      is less precision in the probabilities, so we only do this for small\n      max counts.  */\n-  gcov_type count_max = 0;\n+  profile_count count_max = profile_count::zero ();\n   basic_block bb;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    count_max = MAX (bb->count, count_max);\n+    if (bb->count > count_max)\n+      count_max = bb->count;\n \n   if (profile_status_for_fn (cfun) == PROFILE_GUESSED\n       || (!flag_auto_profile && profile_status_for_fn (cfun) == PROFILE_READ\n-\t  && count_max < REG_BR_PROB_BASE/10))\n+\t  && count_max < REG_BR_PROB_BASE / 10))\n     {\n       loop_optimizer_init (0);\n       add_noreturn_fake_exit_edges ();\n@@ -3725,23 +3715,23 @@ report_predictor_hitrates (void)\n void\n force_edge_cold (edge e, bool impossible)\n {\n-  gcov_type count_sum = 0;\n+  profile_count count_sum = profile_count::zero ();\n   int prob_sum = 0;\n   edge_iterator ei;\n   edge e2;\n-  gcov_type old_count = e->count;\n+  profile_count old_count = e->count;\n   int old_probability = e->probability;\n-  gcov_type gcov_scale = REG_BR_PROB_BASE;\n   int prob_scale = REG_BR_PROB_BASE;\n \n   /* If edge is already improbably or cold, just return.  */\n   if (e->probability <= (impossible ? PROB_VERY_UNLIKELY : 0)\n-      && (!impossible || !e->count))\n+      && (!impossible || e->count == profile_count::zero ()))\n     return;\n   FOR_EACH_EDGE (e2, ei, e->src->succs)\n     if (e2 != e)\n       {\n-\tcount_sum += e2->count;\n+\tif (e2->count.initialized_p ())\n+\t  count_sum += e2->count;\n \tprob_sum += e2->probability;\n       }\n \n@@ -3751,25 +3741,26 @@ force_edge_cold (edge e, bool impossible)\n     {\n       e->probability\n \t = MIN (e->probability, impossible ? 0 : PROB_VERY_UNLIKELY);\n+      if (impossible)\n+\te->count = profile_count::zero ();\n       if (old_probability)\n-\te->count = RDIV (e->count * e->probability, old_probability);\n+\te->count = e->count.apply_scale (e->probability, old_probability);\n       else\n-        e->count = MIN (e->count, impossible ? 0 : 1);\n+        e->count = e->count.apply_scale (1, REG_BR_PROB_BASE);\n \n-      if (count_sum)\n-\tgcov_scale = RDIV ((count_sum + old_count - e->count) * REG_BR_PROB_BASE,\n-\t\t\t   count_sum);\n       prob_scale = RDIV ((REG_BR_PROB_BASE - e->probability) * REG_BR_PROB_BASE,\n \t\t\t prob_sum);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Making edge %i->%i %s by redistributing \"\n \t\t \"probability to other edges.\\n\",\n \t\t e->src->index, e->dest->index,\n \t\t impossible ? \"impossible\" : \"cold\");\n+      profile_count count_sum2 = count_sum + old_count - e->count;\n       FOR_EACH_EDGE (e2, ei, e->src->succs)\n \tif (e2 != e)\n \t  {\n-\t    e2->count = RDIV (e2->count * gcov_scale, REG_BR_PROB_BASE);\n+\t    if (count_sum > 0)\n+\t      e2->count.apply_scale (count_sum2, count_sum);\n \t    e2->probability = RDIV (e2->probability * prob_scale,\n \t\t\t\t    REG_BR_PROB_BASE);\n \t  }\n@@ -3785,16 +3776,19 @@ force_edge_cold (edge e, bool impossible)\n \t This in general is difficult task to do, but handle special case when\n \t BB has only one predecestor.  This is common case when we are updating\n \t after loop transforms.  */\n-      if (!prob_sum && !count_sum && single_pred_p (e->src)\n-\t  && e->src->frequency > (impossible ? 0 : 1))\n+      if (!prob_sum && count_sum == profile_count::zero ()\n+\t  && single_pred_p (e->src) && e->src->frequency > (impossible ? 0 : 1))\n \t{\n \t  int old_frequency = e->src->frequency;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Making bb %i %s.\\n\", e->src->index,\n \t\t     impossible ? \"impossible\" : \"cold\");\n \t  e->src->frequency = MIN (e->src->frequency, impossible ? 0 : 1);\n-\t  e->src->count = e->count = RDIV (e->src->count * e->src->frequency,\n-\t\t\t\t\t   old_frequency);\n+\t  if (impossible)\n+\t    e->src->count = e->count = profile_count::zero ();\n+\t  else\n+\t    e->src->count = e->count = e->count.apply_scale (e->src->frequency,\n+\t\t\t\t\t\t\t     old_frequency);\n \t  force_edge_cold (single_pred_edge (e->src), impossible);\n \t}\n       else if (dump_file && (dump_flags & TDF_DETAILS)"}, {"sha": "d8ef0ab6c42727e2c181b39cd2310fef0f7b1d53", "filename": "gcc/predict.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PREDICT_H\n #define GCC_PREDICT_H\n \n+#include \"profile-count.h\"\n+\n /* Random guesstimation given names.\n    PROB_VERY_UNLIKELY should be small enough so basic block predicted\n    by it gets below HOT_BB_FREQUENCY_FRACTION.  */\n@@ -47,7 +49,7 @@ enum prediction\n \n extern gcov_type get_hot_bb_threshold (void);\n extern void set_hot_bb_threshold (gcov_type);\n-extern bool maybe_hot_count_p (struct function *, gcov_type);\n+extern bool maybe_hot_count_p (struct function *, profile_count);\n extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n extern bool maybe_hot_edge_p (edge);\n extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n@@ -83,7 +85,7 @@ extern void invert_br_probabilities (rtx);\n extern void guess_outgoing_edge_probabilities (basic_block);\n extern void tree_estimate_probability (bool);\n extern void handle_missing_profiles (void);\n-extern int counts_to_freqs (void);\n+extern bool counts_to_freqs (void);\n extern bool expensive_function_p (int);\n extern void estimate_bb_frequencies (bool);\n extern void compute_function_frequency (void);"}, {"sha": "ac8963ec6bb4ee6618c2b0e1765e22efef6fc0ed", "filename": "gcc/print-rtl-function.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprint-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprint-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl-function.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -24,7 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"alias.h\"\n #include \"tree.h\"\n-#include \"cfg.h\"\n #include \"flags.h\"\n #include \"predict.h\"\n #include \"function.h\""}, {"sha": "dc8d9800de578097b4d87f8546af5a9fecf2ae8b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GENERATOR_FILE\n #include \"alias.h\"\n #include \"tree.h\"\n+#include \"basic-block.h\"\n #include \"cfg.h\"\n #include \"print-tree.h\"\n #include \"flags.h\""}, {"sha": "5ad7178c15978be2d53e547cf1ccdfa505c87f92", "filename": "gcc/profile-count.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -0,0 +1,80 @@\n+/* Profile counter container type.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"profile-count.h\"\n+#include \"options.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"cfg.h\"\n+#include \"function.h\"\n+#include \"gimple.h\"\n+#include \"data-streamer.h\"\n+#include \"cgraph.h\"\n+\n+void\n+profile_count::dump (FILE *f) const\n+{\n+  if (!initialized_p ())\n+    fprintf (f, \"uninitialized\");\n+  else\n+    fprintf (f, \"%\" PRId64, m_val);\n+}\n+\n+void\n+profile_count::debug () const\n+{\n+  dump (stderr);\n+}\n+\n+bool\n+profile_count::differs_from_p (profile_count other) const\n+{\n+  if (!initialized_p () || !other.initialized_p ())\n+    return false;\n+  if (m_val - other.m_val < 100 && other.m_val - m_val < 100)\n+    return false;\n+  if (!other.m_val)\n+    return true;\n+  int64_t ratio = m_val * 100 / other.m_val;\n+  return ratio < 99 || ratio > 101;\n+}\n+\n+profile_count\n+profile_count::stream_in (struct lto_input_block *ib)\n+{\n+  profile_count ret;\n+  ret.m_val = streamer_read_gcov_count (ib);\n+  return ret;\n+}\n+\n+void\n+profile_count::stream_out (struct output_block *ob)\n+{\n+  streamer_write_gcov_count (ob, m_val);\n+}\n+\n+void\n+profile_count::stream_out (struct lto_output_stream *ob)\n+{\n+  streamer_write_gcov_count_stream (ob, m_val);\n+}"}, {"sha": "2ac7f32278d0c9b99cf419dded447e9fadaffd46", "filename": "gcc/profile-count.h", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -0,0 +1,290 @@\n+/* Profile counter container type.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_PROFILE_COUNT_H\n+#define GCC_PROFILE_COUNT_H\n+\n+\n+/* The base value for branch probability notes and edge probabilities.  */\n+#define REG_BR_PROB_BASE  10000\n+\n+#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n+\n+/* Main data type to hold profile counters in GCC.  In most cases profile\n+   counts originate from profile feedback. They are 64bit integers\n+   representing number of executions during the train run.\n+   As the profile is maintained during the compilation, many adjustments are\n+   made.  Not all transformations can be made precisely, most importantly\n+   when code is being duplicated.  It also may happen that part of CFG has\n+   profile counts known while other do not - for example when LTO optimizing\n+   partly profiled program or when profile was lost due to COMDAT merging.\n+\n+   For this information profile_count tracks more information than\n+   just unsigned integer and it is also ready for profile mismatches.\n+   The API of this data type represent operations that are natural\n+   on profile counts - sum, difference and operation with scales and\n+   probabilities.  All operations are safe by never getting negative counts\n+   and they do end up in uninitialized scale if any of the parameters is\n+   uninitialized.\n+\n+   All comparsions that are three state and handling of probabilities.  Thus\n+   a < b is not equal to !(a >= b).\n+\n+   The following pre-defined counts are available:\n+\n+   profile_count::zero ()  for code that is known to execute zero times at\n+      runtime (this can be detected statically i.e. for paths leading to\n+      abort ();\n+   profile_count::one () for code that is known to execute once (such as\n+      main () function\n+   profile_count::uninitialized ()  for unknown execution count.\n+\n+ */\n+\n+\n+class GTY(()) profile_count\n+{\n+  /* Use int64_t to hold basic block counters.  Should be at least\n+     64bit.  Although a counter cannot be negative, we use a signed\n+     type to hold various extra stages.  */\n+\n+  int64_t m_val;\n+\n+  /* Assume numbers smaller than this to multiply.  This is set to make\n+     testsuite pass, in future we may implement precise multiples in higer\n+     rangers.  */\n+  static const int64_t max_safe_multiplier = 131072;\n+public:\n+\n+  /* Used for counters which are expected to be never executed.  */\n+  static profile_count zero ()\n+    {\n+      return from_gcov_type (0);\n+    }\n+  static profile_count one ()\n+    {\n+      return from_gcov_type (1);\n+    }\n+  /* Value of counters which has not been initialized. Either because\n+     initialization did not happen yet or because profile is unknown.  */\n+  static profile_count uninitialized ()\n+    {\n+      profile_count c;\n+      c.m_val = -1;\n+      return c;\n+    }\n+\n+  /* The profiling runtime uses gcov_type, which is usually 64bit integer.\n+     Conversions back and forth are used to read the coverage and get it\n+     into internal representation.  */\n+  static profile_count from_gcov_type (gcov_type v)\n+    {\n+      profile_count ret;\n+      gcc_checking_assert (v>=0);\n+      ret.m_val = v;\n+      return ret;\n+    }\n+\n+  /* Conversion to gcov_type is lossy.  */\n+  gcov_type to_gcov_type () const\n+    {\n+      gcc_checking_assert (initialized_p ());\n+      return m_val;\n+    }\n+\n+  /* Return true if value has been initialized.  */\n+  bool initialized_p () const\n+    {\n+      return m_val != -1;\n+    }\n+  /* Return true if value can be trusted.  */\n+  bool reliable_p () const\n+    {\n+      return initialized_p ();\n+    }\n+\n+  /* Basic operations.  */\n+  bool operator== (const profile_count &other) const\n+    {\n+      return m_val == other.m_val;\n+    }\n+  profile_count operator+ (const profile_count &other) const\n+    {\n+      if (other == profile_count::zero ())\n+\treturn *this;\n+      if (*this == profile_count::zero ())\n+\treturn other;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_count::uninitialized ();\n+\n+      profile_count ret;\n+      ret.m_val = m_val + other.m_val;\n+      return ret;\n+    }\n+  profile_count &operator+= (const profile_count &other)\n+    {\n+      if (other == profile_count::zero ())\n+\treturn *this;\n+      if (*this == profile_count::zero ())\n+\t{\n+\t  *this = other;\n+\t  return *this;\n+\t}\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_count::uninitialized ();\n+      else\n+\tm_val += other.m_val;\n+      return *this;\n+    }\n+  profile_count operator- (const profile_count &other) const\n+    {\n+      if (*this == profile_count::zero () || other == profile_count::zero ())\n+\treturn *this;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn profile_count::uninitialized ();\n+      profile_count ret;\n+      ret.m_val = MAX (m_val - other.m_val, 0);\n+      return ret;\n+    }\n+  profile_count &operator-= (const profile_count &other)\n+    {\n+      if (*this == profile_count::zero () || other == profile_count::zero ())\n+\treturn *this;\n+      if (!initialized_p () || !other.initialized_p ())\n+\treturn *this = profile_count::uninitialized ();\n+      else\n+\tm_val = MAX (m_val - other.m_val, 0);\n+      return *this;\n+    }\n+\n+  /* Return false if profile_count is bogus.  */\n+  bool verify () const\n+    {\n+      return m_val >= -1;\n+    }\n+\n+  /* Comparsions are three-state and conservative.  False is returned if\n+     the inequality can not be decided.  */\n+  bool operator< (const profile_count &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val < other.m_val;\n+    }\n+  bool operator> (const profile_count &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val > other.m_val;\n+    }\n+  bool operator< (const gcov_type other) const\n+    {\n+      return initialized_p () && m_val < other;\n+    }\n+  bool operator> (const gcov_type other) const\n+    {\n+      return initialized_p () && m_val > other;\n+    }\n+\n+  bool operator<= (const profile_count &other) const\n+    {\n+      return initialized_p () && other.initialized_p () && m_val <= other.m_val;\n+    }\n+  bool operator>= (const profile_count &other) const\n+    {\n+      return initialized_p () && m_val >= other.m_val;\n+    }\n+  bool operator<= (const gcov_type other) const\n+    {\n+      return initialized_p () && m_val <= other;\n+    }\n+  bool operator>= (const gcov_type other) const\n+    {\n+      return initialized_p () && m_val >= other;\n+    }\n+\n+  /* PROB is a probability in scale 0...REG_BR_PROB_BASE.  Scale counter\n+     accordingly.  */\n+  profile_count apply_probability (int prob) const\n+    {\n+      gcc_checking_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n+      if (!initialized_p ())\n+\treturn profile_count::uninitialized ();\n+      profile_count ret;\n+      ret.m_val = RDIV (m_val * prob, REG_BR_PROB_BASE);\n+      return ret;\n+    }\n+  /* Return *THIS * NUM / DEN.  */\n+  profile_count apply_scale (int64_t num, int64_t den) const\n+    {\n+      if (!initialized_p ())\n+\treturn profile_count::uninitialized ();\n+      profile_count ret;\n+      /* FIXME: shrink wrapping violates this sanity check.  */\n+      gcc_checking_assert ((num >= 0\n+\t\t\t    && (num <= REG_BR_PROB_BASE\n+\t\t\t        || den <= REG_BR_PROB_BASE)\n+\t\t\t    && den > 0) || 1);\n+      ret.m_val = RDIV (m_val * num, den);\n+      return ret;\n+    }\n+  profile_count apply_scale (profile_count num, profile_count den) const\n+    {\n+      if (*this == profile_count::zero ())\n+\treturn profile_count::zero ();\n+      if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n+\treturn profile_count::uninitialized ();\n+      profile_count ret;\n+      gcc_checking_assert (den > 0);\n+      /* Take care for overflows!  */\n+      if (num.m_val < max_safe_multiplier || m_val < max_safe_multiplier)\n+        ret.m_val = RDIV (m_val * num.m_val, den.m_val);\n+      else\n+        ret.m_val = RDIV (m_val * RDIV (num.m_val * max_safe_multiplier,\n+\t\t\t\t\tden.m_val), max_safe_multiplier);\n+      return ret;\n+    }\n+\n+  /* Return probability of event with counter THIS within event with counter\n+     OVERALL.  */\n+  int probability_in (profile_count overall)\n+    {\n+      if (*this == profile_count::zero ())\n+\treturn 0;\n+      if (!initialized_p () || !overall.initialized_p ())\n+\treturn REG_BR_PROB_BASE / 2;\n+      if (overall < *this)\n+\treturn REG_BR_PROB_BASE;\n+      if (!overall.m_val)\n+\treturn REG_BR_PROB_BASE / 2;\n+      return RDIV (m_val * REG_BR_PROB_BASE, overall.m_val);\n+    }\n+\n+  /* Output THIS to F.  */\n+  void dump (FILE *f) const;\n+\n+  /* Print THIS to stderr.  */\n+  void debug () const;\n+\n+  /* Return true if THIS is known to differ significantly from OTHER.  */\n+  bool differs_from_p (profile_count other) const;\n+\n+  /* LTO streaming support.  */\n+  static profile_count stream_in (struct lto_input_block *);\n+  void stream_out (struct output_block *);\n+  void stream_out (struct lto_output_stream *);\n+};\n+#endif"}, {"sha": "aca5c67465a16150dc4ba9429b3bddff4c3c4fd2", "filename": "gcc/profile.c", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -67,6 +67,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"profile.h\"\n \n+/* Map from BBs/edges to gcov counters.  */\n+vec<gcov_type> bb_gcov_counts;\n+hash_map<edge,gcov_type> edge_gcov_counts;\n+\n struct bb_profile_info {\n   unsigned int count_valid : 1;\n \n@@ -303,15 +307,15 @@ is_edge_inconsistent (vec<edge, va_gc> *edges)\n     {\n       if (!EDGE_INFO (e)->ignore)\n         {\n-          if (e->count < 0\n+          if (edge_gcov_count (e) < 0\n \t      && (!(e->flags & EDGE_FAKE)\n \t          || !block_ends_with_call_p (e->src)))\n \t    {\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file,\n \t\t  \t   \"Edge %i->%i is inconsistent, count%\" PRId64,\n-\t\t\t   e->src->index, e->dest->index, e->count);\n+\t\t\t   e->src->index, e->dest->index, edge_gcov_count (e));\n \t\t  dump_bb (dump_file, e->src, 0, TDF_DETAILS);\n \t\t  dump_bb (dump_file, e->dest, 0, TDF_DETAILS);\n \t\t}\n@@ -333,8 +337,8 @@ correct_negative_edge_counts (void)\n     {\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         {\n-           if (e->count < 0)\n-             e->count = 0;\n+           if (edge_gcov_count (e) < 0)\n+             edge_gcov_count (e) = 0;\n         }\n     }\n }\n@@ -354,32 +358,32 @@ is_inconsistent (void)\n       inconsistent |= is_edge_inconsistent (bb->succs);\n       if (!dump_file && inconsistent)\n \treturn true;\n-      if (bb->count < 0)\n+      if (bb_gcov_count (bb) < 0)\n         {\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"BB %i count is negative \"\n \t\t       \"%\" PRId64,\n \t\t       bb->index,\n-\t\t       bb->count);\n+\t\t       bb_gcov_count (bb));\n \t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n \t  inconsistent = true;\n \t}\n-      if (bb->count != sum_edge_counts (bb->preds))\n+      if (bb_gcov_count (bb) != sum_edge_counts (bb->preds))\n         {\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"BB %i count does not match sum of incoming edges \"\n \t\t       \"%\" PRId64\" should be %\" PRId64,\n \t\t       bb->index,\n-\t\t       bb->count,\n+\t\t       bb_gcov_count (bb),\n \t\t       sum_edge_counts (bb->preds));\n \t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n \t  inconsistent = true;\n \t}\n-      if (bb->count != sum_edge_counts (bb->succs) &&\n+      if (bb_gcov_count (bb) != sum_edge_counts (bb->succs) &&\n \t  ! (find_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun)) != NULL\n \t     && block_ends_with_call_p (bb)))\n \t{\n@@ -388,7 +392,7 @@ is_inconsistent (void)\n \t      fprintf (dump_file, \"BB %i count does not match sum of outgoing edges \"\n \t\t       \"%\" PRId64\" should be %\" PRId64,\n \t\t       bb->index,\n-\t\t       bb->count,\n+\t\t       bb_gcov_count (bb),\n \t\t       sum_edge_counts (bb->succs));\n \t      dump_bb (dump_file, bb, 0, TDF_DETAILS);\n \t    }\n@@ -408,8 +412,8 @@ set_bb_counts (void)\n   basic_block bb;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n-      bb->count = sum_edge_counts (bb->succs);\n-      gcc_assert (bb->count >= 0);\n+      bb_gcov_count (bb) = sum_edge_counts (bb->succs);\n+      gcc_assert (bb_gcov_count (bb) >= 0);\n     }\n }\n \n@@ -436,8 +440,8 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t    num_edges++;\n \t    if (exec_counts)\n \t      {\n-\t\te->count = exec_counts[exec_counts_pos++];\n-\t\tif (e->count > profile_info->sum_max)\n+\t\tedge_gcov_count (e) = exec_counts[exec_counts_pos++];\n+\t\tif (edge_gcov_count (e) > profile_info->sum_max)\n \t\t  {\n \t\t    if (flag_profile_correction)\n \t\t      {\n@@ -454,7 +458,7 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t\t  }\n \t      }\n \t    else\n-\t      e->count = 0;\n+\t      edge_gcov_count (e) = 0;\n \n \t    EDGE_INFO (e)->count_valid = 1;\n \t    BB_INFO (bb)->succ_count--;\n@@ -464,7 +468,7 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t\tfprintf (dump_file, \"\\nRead edge from %i to %i, count:\",\n \t\t\t bb->index, e->dest->index);\n \t\tfprintf (dump_file, \"%\" PRId64,\n-\t\t\t (int64_t) e->count);\n+\t\t\t (int64_t) edge_gcov_count (e));\n \t      }\n \t  }\n     }\n@@ -491,15 +495,15 @@ compute_frequency_overlap (void)\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n     {\n-      count_total += bb->count;\n+      count_total += bb_gcov_count (bb);\n       freq_total += bb->frequency;\n     }\n \n   if (count_total == 0 || freq_total == 0)\n     return 0;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    overlap += MIN (bb->count * OVERLAP_BASE / count_total,\n+    overlap += MIN (bb_gcov_count (bb) * OVERLAP_BASE / count_total,\n \t\t    bb->frequency * OVERLAP_BASE / freq_total);\n \n   return overlap;\n@@ -527,6 +531,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n   if (!profile_info)\n     return;\n \n+  bb_gcov_counts.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+\n   if (profile_info->sum_all < profile_info->sum_max)\n     {\n       error (\"corrupted profile info: sum_all is smaller than sum_max\");\n@@ -592,8 +598,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t\t  gcov_type total = 0;\n \n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t    total += e->count;\n-\t\t  bb->count = total;\n+\t\t    total += edge_gcov_count (e);\n+\t\t  bb_gcov_count (bb) = total;\n \t\t  bi->count_valid = 1;\n \t\t  changes = 1;\n \t\t}\n@@ -604,8 +610,8 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t\t  gcov_type total = 0;\n \n \t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t    total += e->count;\n-\t\t  bb->count = total;\n+\t\t    total += edge_gcov_count (e);\n+\t\t  bb_gcov_count (bb) = total;\n \t\t  bi->count_valid = 1;\n \t\t  changes = 1;\n \t\t}\n@@ -621,19 +627,19 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t    total += e->count;\n+\t\t    total += edge_gcov_count (e);\n \n \t\t  /* Search for the invalid edge, and set its count.  */\n \t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n \t\t      break;\n \n \t\t  /* Calculate count for remaining edge by conservation.  */\n-\t\t  total = bb->count - total;\n+\t\t  total = bb_gcov_count (bb) - total;\n \n \t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n-\t\t  e->count = total;\n+\t\t  edge_gcov_count (e) = total;\n \t\t  bi->succ_count--;\n \n \t\t  BB_INFO (e->dest)->pred_count--;\n@@ -648,19 +654,19 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t\t  /* One of the counts will be invalid, but it is zero,\n \t\t     so adding it in also doesn't hurt.  */\n \t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\t    total += e->count;\n+\t\t    total += edge_gcov_count (e);\n \n \t\t  /* Search for the invalid edge, and set its count.  */\n \t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t\t    if (!EDGE_INFO (e)->count_valid && !EDGE_INFO (e)->ignore)\n \t\t      break;\n \n \t\t  /* Calculate count for remaining edge by conservation.  */\n-\t\t  total = bb->count - total + e->count;\n+\t\t  total = bb_gcov_count (bb) - total + edge_gcov_count (e);\n \n \t\t  gcc_assert (e);\n \t\t  EDGE_INFO (e)->count_valid = 1;\n-\t\t  e->count = total;\n+\t\t  edge_gcov_count (e) = total;\n \t\t  bi->pred_count--;\n \n \t\t  BB_INFO (e->src)->succ_count--;\n@@ -727,11 +733,11 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n       edge e;\n       edge_iterator ei;\n \n-      if (bb->count < 0)\n+      if (bb_gcov_count (bb) < 0)\n \t{\n \t  error (\"corrupted profile info: number of iterations for basic block %d thought to be %i\",\n-\t\t bb->index, (int)bb->count);\n-\t  bb->count = 0;\n+\t\t bb->index, (int)bb_gcov_count (bb));\n+\t  bb_gcov_count (bb) = 0;\n \t}\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n@@ -740,26 +746,29 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t     edge from the entry, since extra edge from the exit is\n \t     already present.  We get negative frequency from the entry\n \t     point.  */\n-\t  if ((e->count < 0\n+\t  if ((edge_gcov_count (e) < 0\n \t       && e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t      || (e->count > bb->count\n+\t      || (edge_gcov_count (e) > bb_gcov_count (bb)\n \t\t  && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)))\n \t    {\n \t      if (block_ends_with_call_p (bb))\n-\t\te->count = e->count < 0 ? 0 : bb->count;\n+\t\tedge_gcov_count (e) = edge_gcov_count (e) < 0\n+\t\t\t\t      ? 0 : bb_gcov_count (bb);\n \t    }\n-\t  if (e->count < 0 || e->count > bb->count)\n+\t  if (edge_gcov_count (e) < 0\n+\t      || edge_gcov_count (e) > bb_gcov_count (bb))\n \t    {\n \t      error (\"corrupted profile info: number of executions for edge %d-%d thought to be %i\",\n \t\t     e->src->index, e->dest->index,\n-\t\t     (int)e->count);\n-\t      e->count = bb->count / 2;\n+\t\t     (int)edge_gcov_count (e));\n+\t      edge_gcov_count (e) = bb_gcov_count (bb) / 2;\n \t    }\n \t}\n-      if (bb->count)\n+      if (bb_gcov_count (bb))\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    e->probability = GCOV_COMPUTE_SCALE (e->count, bb->count);\n+\t    e->probability = GCOV_COMPUTE_SCALE (edge_gcov_count (e),\n+\t\t\t\t\t\t bb_gcov_count (bb));\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)\n@@ -816,6 +825,19 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \t    num_branches++;\n \t}\n     }\n+\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      bb->count = profile_count::from_gcov_type (bb_gcov_count (bb));\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        e->count = profile_count::from_gcov_type (edge_gcov_count (e));\n+    }\n+  bb_gcov_counts.release ();\n+  edge_gcov_counts.empty ();\n+\n   counts_to_freqs ();\n \n   if (dump_file)\n@@ -1125,7 +1147,7 @@ branch_prob (void)\n   for (i = 0 ; i < num_edges ; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      e->count = 0;\n+      edge_gcov_count (e) = 0;\n \n       /* Mark edges we've replaced by fake edges above as ignored.  */\n       if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n@@ -1323,7 +1345,7 @@ branch_prob (void)\n       /* At this moment we have precise loop iteration count estimates.\n \t Record them to loop structure before the profile gets out of date. */\n       FOR_EACH_LOOP (loop, 0)\n-\tif (loop->header->count)\n+\tif (loop->header->count > 0)\n \t  {\n \t    gcov_type nit = expected_loop_iterations_unbounded (loop);\n \t    widest_int bound = gcov_type_to_wide_int (nit);"}, {"sha": "5ff806e5535d77977c197152690feafd5069477b", "filename": "gcc/profile.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -37,6 +37,27 @@ struct edge_profile_info\n \n #define EDGE_INFO(e)  ((struct edge_profile_info *) (e)->aux)\n \n+/* Helpers annotating edges/basic blocks to GCOV counts.  */\n+\n+extern vec<gcov_type> bb_gcov_counts;\n+extern hash_map<edge,gcov_type> edge_gcov_counts;\n+\n+inline gcov_type &\n+edge_gcov_count (edge e)\n+{\n+  bool existed;\n+  gcov_type &c = edge_gcov_counts.get_or_insert (e, &existed);\n+  if (!existed)\n+    c = 0;\n+  return c;\n+}\n+\n+inline gcov_type &\n+bb_gcov_count (basic_block bb)\n+{\n+  return bb_gcov_counts[bb->index];\n+}\n+\n typedef struct gcov_working_set_info gcov_working_set_t;\n extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n extern void add_working_set (gcov_working_set_t *);"}, {"sha": "eaa1522bb0db28ce90905f9434e28175b09b74cf", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -921,7 +921,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \n \tbb->frequency = RDIV (num * bb->frequency, den);\n \tdup->frequency -= bb->frequency;\n-\tbb->count = RDIV (num * bb->count, den);\n+\tbb->count = bb->count.apply_scale (num, den);\n \tdup->count -= bb->count;\n       }\n \n@@ -993,7 +993,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n \t  continue;\n \t}\n \n-      new_bb->count += RDIV (e->src->count * e->probability, REG_BR_PROB_BASE);\n+      new_bb->count += e->src->count.apply_probability (e->probability);\n       new_bb->frequency += EDGE_FREQUENCY (e);\n \n       redirect_edge_and_branch_force (e, new_bb);"}, {"sha": "6246d22fb37d650bea341d9b4e8ffdfe3e22b939", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1,3 +1,7 @@\n+2017-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/attr-hotcold-2.c: Update template.\n+\n 2017-06-04  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \t* lib/fortran-modules.exp (igrep): New procedure, case insensitive\n@@ -77,6 +81,7 @@\n \t* gfortran.dg/warn_unused_function.f90: Likewise.\n \t* gfortran.dg/warn_unused_function_2.f90: Likewise.\n \t* gfortran.dg/ieee/ieee_8.f90: Likewise.\n+\n 2017-06-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/80919"}, {"sha": "f7a5098709b8a1c5f26c5583098aec0dc03f8f5e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/attr-hotcold-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-hotcold-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-hotcold-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-hotcold-2.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -20,9 +20,9 @@ void f(int x, int y)\n \n /* { dg-final { scan-tree-dump-times \"hot label heuristics\" 1 \"profile_estimate\" } } */\n /* { dg-final { scan-tree-dump-times \"cold label heuristics\" 1 \"profile_estimate\" } } */\n-/* { dg-final { scan-tree-dump-times \"block 4, loop depth 0, count 0, freq \\[1-4\\]\\[^0-9\\]\" 3 \"profile_estimate\" } } */\n+/* { dg-final { scan-tree-dump-times \"block 4, loop depth 0, freq \\[1-4\\]\\[^0-9\\]\" 3 \"profile_estimate\" } } */\n \n /* Note: we're attempting to match some number > 6000, i.e. > 60%.\n    The exact number ought to be tweekable without having to juggle\n    the testcase around too much.  */\n-/* { dg-final { scan-tree-dump-times \"block 5, loop depth 0, count 0, freq \\[6-9\\]\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 3 \"profile_estimate\" } } */\n+/* { dg-final { scan-tree-dump-times \"block 5, loop depth 0, freq \\[6-9\\]\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 3 \"profile_estimate\" } } */"}, {"sha": "bb44673142057107e047a07a2e2cf4f46159771f", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -132,7 +132,8 @@ count_insns (basic_block bb)\n static bool\n better_p (const_edge e1, const_edge e2)\n {\n-  if (e1->count != e2->count)\n+  if (e1->count.initialized_p () && e2->count.initialized_p ()\n+      && !(e1->count == e2->count))\n     return e1->count > e2->count;\n   if (e1->src->frequency * e1->probability !=\n       e2->src->frequency * e2->probability)"}, {"sha": "f66abfc88354d8feaf695960c7d34e9c5c590acb", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -2937,8 +2937,8 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       ei->probability = PROB_ALWAYS;\n       et->probability = PROB_LIKELY;\n       ef->probability = PROB_UNLIKELY;\n-      et->count = apply_probability (test_bb->count, et->probability);\n-      ef->count = apply_probability (test_bb->count, ef->probability);\n+      et->count = test_bb->count.apply_probability (et->probability);\n+      ef->count = test_bb->count.apply_probability (ef->probability);\n \n       code_bb->count = et->count;\n       code_bb->frequency = EDGE_FREQUENCY (et);\n@@ -2974,15 +2974,15 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       redirect_edge_pred (fallthru_edge, test_bb);\n       fallthru_edge->flags = EDGE_FALSE_VALUE;\n       fallthru_edge->probability = PROB_VERY_LIKELY;\n-      fallthru_edge->count\n-\t= apply_probability (test_bb->count, fallthru_edge->probability);\n+      fallthru_edge->count = test_bb->count.apply_probability\n+\t\t\t\t(fallthru_edge->probability);\n \n       // Abort/over edge.\n       redirect_edge_pred (abort_edge, test_bb);\n       abort_edge->flags = EDGE_TRUE_VALUE;\n       abort_edge->probability = PROB_VERY_UNLIKELY;\n-      abort_edge->count\n-\t= apply_probability (test_bb->count, abort_edge->probability);\n+      abort_edge->count = test_bb->count.apply_probability\n+\t\t\t\t(abort_edge->probability);\n \n       transaction_bb = test_bb;\n     }\n@@ -3022,13 +3022,13 @@ expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n       inst_edge->flags = EDGE_FALSE_VALUE;\n       inst_edge->probability = REG_BR_PROB_BASE / 2;\n       inst_edge->count\n-\t= apply_probability (test_bb->count, inst_edge->probability);\n+\t= test_bb->count.apply_probability (inst_edge->probability);\n \n       redirect_edge_pred (uninst_edge, test_bb);\n       uninst_edge->flags = EDGE_TRUE_VALUE;\n       uninst_edge->probability = REG_BR_PROB_BASE / 2;\n       uninst_edge->count\n-\t= apply_probability (test_bb->count, uninst_edge->probability);\n+\t= test_bb->count.apply_probability (uninst_edge->probability);\n     }\n \n   // If we have no previous special cases, and we have PHIs at the beginning\n@@ -5076,7 +5076,7 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n \n   node->create_edge (cgraph_node::get_create\n \t\t       (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n-\t\t     g, 0,\n+\t\t     g, gimple_bb (g)->count,\n \t\t     compute_call_stmt_bb_frequency (node->decl,\n \t\t\t\t\t\t     gimple_bb (g)));\n }\n@@ -5127,7 +5127,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n-  node->create_edge (cgraph_node::get_create (gettm_fn), g, 0,\n+  node->create_edge (cgraph_node::get_create (gettm_fn), g, gimple_bb (g)->count,\n \t\t     compute_call_stmt_bb_frequency (node->decl,\n \t\t\t\t\t\t     gimple_bb (g)));\n "}, {"sha": "69d3207696d6f9c848ea349f3819853ee8228536", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -906,7 +906,7 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n \n      Here we take the second approach because it's slightly simpler\n      and because it's easy to see that it doesn't lose profile counts.  */\n-  bi_call_bb->count = 0;\n+  bi_call_bb->count = profile_count::zero ();\n   bi_call_bb->frequency = 0;\n   while (!edges.is_empty ())\n     {\n@@ -917,8 +917,8 @@ shrink_wrap_one_built_in_call_with_conds (gcall *bi_call, vec <gimple *> conds,\n       gcc_assert (src_bb == nocall_edge->src);\n \n       call_edge->probability = REG_BR_PROB_BASE * ERR_PROB;\n-      call_edge->count = apply_probability (src_bb->count,\n-\t\t\t\t\t    call_edge->probability);\n+      call_edge->count\n+\t = src_bb->count.apply_probability (call_edge->probability);\n       nocall_edge->probability = inverse_probability (call_edge->probability);\n       nocall_edge->count = src_bb->count - call_edge->count;\n "}, {"sha": "286cc79647adeb0b083d699fd800cee87fe3bb01", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -6200,7 +6200,8 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n   vec<basic_block> doms;\n   edge redirected;\n   int total_freq = 0, entry_freq = 0;\n-  gcov_type total_count = 0, entry_count = 0;\n+  profile_count total_count = profile_count::uninitialized ();\n+  profile_count entry_count = profile_count::uninitialized ();\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -6257,7 +6258,7 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n       doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n     }\n \n-  if (entry->dest->count)\n+  if (entry->dest->count.initialized_p ())\n     {\n       total_count = entry->dest->count;\n       entry_count = entry->count;\n@@ -6266,7 +6267,7 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n       if (entry_count > total_count)\n \tentry_count = total_count;\n     }\n-  else\n+  if (!(total_count > 0) || !(entry_count > 0))\n     {\n       total_freq = entry->dest->frequency;\n       entry_freq = EDGE_FREQUENCY (entry);\n@@ -6280,13 +6281,13 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n \n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n \t    split_edge_bb_loc (entry), update_dominance);\n-  if (total_count)\n+  if (total_count > 0 && entry_count > 0)\n     {\n-      scale_bbs_frequencies_gcov_type (region, n_region,\n-\t\t\t\t       total_count - entry_count,\n-\t\t\t\t       total_count);\n-      scale_bbs_frequencies_gcov_type (region_copy, n_region, entry_count,\n-\t\t\t\t       total_count);\n+      scale_bbs_frequencies_profile_count (region, n_region,\n+\t\t\t\t           total_count - entry_count,\n+\t\t\t\t           total_count);\n+      scale_bbs_frequencies_profile_count (region_copy, n_region, entry_count,\n+\t\t\t\t           total_count);\n     }\n   else\n     {\n@@ -6383,7 +6384,8 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   basic_block switch_bb, entry_bb, nentry_bb;\n   vec<basic_block> doms;\n   int total_freq = 0, exit_freq = 0;\n-  gcov_type total_count = 0, exit_count = 0;\n+  profile_count total_count = profile_count::uninitialized (),\n+\t\texit_count = profile_count::uninitialized ();\n   edge exits[2], nexits[2], e;\n   gimple_stmt_iterator gsi;\n   gimple *cond_stmt;\n@@ -6426,7 +6428,7 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n      inside.  */\n   doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region);\n \n-  if (exit->src->count)\n+  if (exit->src->count > 0)\n     {\n       total_count = exit->src->count;\n       exit_count = exit->count;\n@@ -6449,13 +6451,13 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n \n   copy_bbs (region, n_region, region_copy, exits, 2, nexits, orig_loop,\n \t    split_edge_bb_loc (exit), true);\n-  if (total_count)\n+  if (total_count.initialized_p ())\n     {\n-      scale_bbs_frequencies_gcov_type (region, n_region,\n-\t\t\t\t       total_count - exit_count,\n-\t\t\t\t       total_count);\n-      scale_bbs_frequencies_gcov_type (region_copy, n_region, exit_count,\n-\t\t\t\t       total_count);\n+      scale_bbs_frequencies_profile_count (region, n_region,\n+\t\t\t\t           total_count - exit_count,\n+\t\t\t\t           total_count);\n+      scale_bbs_frequencies_profile_count (region_copy, n_region, exit_count,\n+\t\t\t\t           total_count);\n     }\n   else\n     {\n@@ -8522,10 +8524,10 @@ gimple_account_profile_record (basic_block bb, int after_pass,\n     {\n       record->size[after_pass]\n \t+= estimate_num_insns (gsi_stmt (i), &eni_size_weights);\n-      if (profile_status_for_fn (cfun) == PROFILE_READ)\n+      if (bb->count.initialized_p ())\n \trecord->time[after_pass]\n \t  += estimate_num_insns (gsi_stmt (i),\n-\t\t\t\t &eni_time_weights) * bb->count;\n+\t\t\t\t &eni_time_weights) * bb->count.to_gcov_type ();\n       else if (profile_status_for_fn (cfun) == PROFILE_GUESSED)\n \trecord->time[after_pass]\n \t  += estimate_num_insns (gsi_stmt (i),\n@@ -9053,24 +9055,27 @@ execute_fixup_cfg (void)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   int todo = 0;\n-  gcov_type count_scale;\n   edge e;\n   edge_iterator ei;\n   cgraph_node *node = cgraph_node::get (current_function_decl);\n+  profile_count num = node->count;\n+  profile_count den = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n+  bool scale = num.initialized_p () && den.initialized_p () && !(num == den);\n \n-  count_scale\n-    = GCOV_COMPUTE_SCALE (node->count, ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n-\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->count\n-    = apply_scale (EXIT_BLOCK_PTR_FOR_FN (cfun)->count, count_scale);\n+  if (scale)\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n+      EXIT_BLOCK_PTR_FOR_FN (cfun)->count\n+        = EXIT_BLOCK_PTR_FOR_FN (cfun)->count.apply_scale (num, den);\n \n-  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n-    e->count = apply_scale (e->count, count_scale);\n+      FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n+\te->count = e->count.apply_scale (num, den);\n+    }\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      bb->count = apply_scale (bb->count, count_scale);\n+      if (scale)\n+        bb->count = bb->count.apply_scale (num, den);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -9139,8 +9144,9 @@ execute_fixup_cfg (void)\n \t  gsi_next (&gsi);\n \t}\n \n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = apply_scale (e->count, count_scale);\n+      if (scale)\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  e->count = e->count.apply_scale (num, den);\n \n       /* If we have a basic block with no successors that does not\n \t end with a control statement or a noreturn call end it with\n@@ -9172,7 +9178,7 @@ execute_fixup_cfg (void)\n \t    }\n \t}\n     }\n-  if (count_scale != REG_BR_PROB_BASE)\n+  if (scale)\n     compute_function_frequency ();\n \n   if (current_loops"}, {"sha": "7f20cdc7f8e0211a3092a0593b9c851c43fee669", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1756,13 +1756,14 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \n static basic_block\n copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n-         gcov_type count_scale)\n+         profile_count num, profile_count den)\n {\n   gimple_stmt_iterator gsi, copy_gsi, seq_gsi;\n   basic_block copy_basic_block;\n   tree decl;\n   gcov_type freq;\n   basic_block prev;\n+  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n \n   /* Search for previous copied basic block.  */\n   prev = bb->prev_bb;\n@@ -1772,7 +1773,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   /* create_basic_block() will append every new block to\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (basic_block) prev->aux);\n-  copy_basic_block->count = apply_scale (bb->count, count_scale);\n+  if (scale)\n+    copy_basic_block->count = bb->count.apply_scale (num, den);\n \n   /* We are going to rebuild frequencies from scratch.  These values\n      have just small importance to drive canonicalize_loop_headers.  */\n@@ -2200,15 +2202,16 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n    debug stmts are left after a statement that must end the basic block.  */\n \n static bool\n-copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n-\t\t   basic_block abnormal_goto_dest)\n+copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n+\t\t   basic_block ret_bb, basic_block abnormal_goto_dest)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n   edge old_edge;\n   gimple_stmt_iterator si;\n   int flags;\n   bool need_debug_cleanup = false;\n+  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n \n   /* Use the indices from the original blocks to create edges for the\n      new ones.  */\n@@ -2225,7 +2228,8 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n-\tnew_edge->count = apply_scale (old_edge->count, count_scale);\n+\tif (scale)\n+\t  new_edge->count = old_edge->count.apply_scale (num, den);\n \tnew_edge->probability = old_edge->probability;\n       }\n \n@@ -2422,23 +2426,15 @@ remap_decl_1 (tree decl, void *data)\n    the cfun to the function of new_fndecl (and current_function_decl too).  */\n \n static void\n-initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n+initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)\n {\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n-  gcov_type count_scale;\n \n   if (!DECL_ARGUMENTS (new_fndecl))\n     DECL_ARGUMENTS (new_fndecl) = DECL_ARGUMENTS (callee_fndecl);\n   if (!DECL_RESULT (new_fndecl))\n     DECL_RESULT (new_fndecl) = DECL_RESULT (callee_fndecl);\n \n-  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count)\n-    count_scale\n-        = GCOV_COMPUTE_SCALE (count,\n-                              ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n-  else\n-    count_scale = REG_BR_PROB_BASE;\n-\n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n \n@@ -2471,14 +2467,22 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   init_empty_tree_cfg ();\n \n   profile_status_for_fn (cfun) = profile_status_for_fn (src_cfun);\n-  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n-    (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count * count_scale /\n-     REG_BR_PROB_BASE);\n+\n+  /* FIXME: When all counts are known to be zero, scaling is also meaningful.\n+   */\n+  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ()\n+      && count.initialized_p ()\n+      && ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count > 0)\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n+\tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n+\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n+      EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n+\tEXIT_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n+\t\t\t\t    ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n+    }\n   ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency\n     = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n-  EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n-    (EXIT_BLOCK_PTR_FOR_FN (src_cfun)->count * count_scale /\n-     REG_BR_PROB_BASE);\n   EXIT_BLOCK_PTR_FOR_FN (cfun)->frequency =\n     EXIT_BLOCK_PTR_FOR_FN (src_cfun)->frequency;\n   if (src_cfun->eh)\n@@ -2644,7 +2648,7 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n    when this can happen for COMDATs.  */\n \n void\n-freqs_to_counts (struct cgraph_node *node, gcov_type count)\n+freqs_to_counts (struct cgraph_node *node, profile_count count)\n {\n   basic_block bb;\n   edge_iterator ei;\n@@ -2653,18 +2657,17 @@ freqs_to_counts (struct cgraph_node *node, gcov_type count)\n \n   FOR_ALL_BB_FN(bb, fn)\n     {\n-      bb->count = apply_scale (count,\n-                               GCOV_COMPUTE_SCALE (bb->frequency, BB_FREQ_MAX));\n+      bb->count = count.apply_scale (bb->frequency, BB_FREQ_MAX);\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = apply_probability (e->src->count, e->probability);\n+        e->count = e->src->count.apply_probability (e->probability);\n     }\n }\n \n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n static tree\n-copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n+copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n \t       basic_block entry_block_map, basic_block exit_block_map,\n \t       basic_block new_entry)\n {\n@@ -2675,36 +2678,32 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   basic_block bb;\n   tree new_fndecl = NULL;\n   bool need_debug_cleanup = false;\n-  gcov_type count_scale;\n   int last;\n   int incoming_frequency = 0;\n-  gcov_type incoming_count = 0;\n+  profile_count incoming_count = profile_count::zero ();\n+  profile_count num = count;\n+  profile_count den = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n+  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n \n   /* This can happen for COMDAT routines that end up with 0 counts\n      despite being called (see the comments for handle_missing_profiles()\n      in predict.c as to why). Apply counts to the blocks in the callee\n      before inlining, using the guessed edge frequencies, so that we don't\n      end up with a 0-count inline body which can confuse downstream\n      optimizations such as function splitting.  */\n-  if (!ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count && count)\n+  if (!(ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count > 0) && count > 0)\n     {\n       /* Apply the larger of the call bb count and the total incoming\n          call edge count to the callee.  */\n-      gcov_type in_count = 0;\n+      profile_count in_count = profile_count::zero ();\n       struct cgraph_edge *in_edge;\n       for (in_edge = id->src_node->callers; in_edge;\n            in_edge = in_edge->next_caller)\n-        in_count += in_edge->count;\n+\tif (in_edge->count.initialized_p ())\n+          in_count += in_edge->count;\n       freqs_to_counts (id->src_node, count > in_count ? count : in_count);\n     }\n \n-  if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count)\n-    count_scale\n-        = GCOV_COMPUTE_SCALE (count,\n-                              ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count);\n-  else\n-    count_scale = REG_BR_PROB_BASE;\n-\n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n \n@@ -2724,7 +2723,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t    incoming_frequency += EDGE_FREQUENCY (e);\n \t    incoming_count += e->count;\n \t  }\n-      incoming_count = apply_scale (incoming_count, count_scale);\n+      if (scale)\n+        incoming_count = incoming_count.apply_scale (num, den);\n+      else\n+\tincoming_count = profile_count::uninitialized ();\n       incoming_frequency\n \t= apply_scale ((gcov_type)incoming_frequency, frequency_scale);\n       ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = incoming_count;\n@@ -2751,7 +2753,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy || bitmap_bit_p (id->blocks_to_copy, bb->index))\n       {\n-\tbasic_block new_bb = copy_bb (id, bb, frequency_scale, count_scale);\n+\tbasic_block new_bb = copy_bb (id, bb, frequency_scale, num, den);\n \tbb->aux = new_bb;\n \tnew_bb->aux = bb;\n \tnew_bb->loop_father = entry_block_map->loop_father;\n@@ -2774,7 +2776,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy\n \t|| (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n-      need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map,\n+      need_debug_cleanup |= copy_edges_for_bb (bb, num, den, exit_block_map,\n \t\t\t\t\t       abnormal_goto_dest);\n \n   if (new_entry)\n@@ -2979,7 +2981,7 @@ copy_tree_body (copy_body_data *id)\n    another function.  */\n \n static tree\n-copy_body (copy_body_data *id, gcov_type count, int frequency_scale,\n+copy_body (copy_body_data *id, profile_count count, int frequency_scale,\n \t   basic_block entry_block_map, basic_block exit_block_map,\n \t   basic_block new_entry)\n {\n@@ -4497,7 +4499,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n       cgraph_edge *edge;\n       tree virtual_offset = NULL;\n       int freq = cg_edge->frequency;\n-      gcov_type count = cg_edge->count;\n+      profile_count count = cg_edge->count;\n       tree op;\n       gimple_stmt_iterator iter = gsi_for_stmt (stmt);\n "}, {"sha": "904befa980852af80df81aea36a73496e97a4910", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -361,7 +361,7 @@ update_profile_after_ifcombine (basic_block inner_cond_bb,\n   outer_to_inner->count = outer_cond_bb->count;\n   inner_cond_bb->count = outer_cond_bb->count;\n   inner_taken->count += outer2->count;\n-  outer2->count = 0;\n+  outer2->count = profile_count::zero ();\n \n   inner_taken->probability = outer2->probability\n \t\t\t     + RDIV (outer_to_inner->probability"}, {"sha": "91787af257cd308dd6a2f4960f09a0d777ebb32d", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -641,12 +641,12 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n       stmt = gimple_build_call (builtin_decl_implicit (BUILT_IN_UNREACHABLE), 0);\n       latch_edge = make_edge (latch, create_basic_block (NULL, NULL, latch), flags);\n       latch_edge->probability = 0;\n-      latch_edge->count = 0;\n+      latch_edge->count = profile_count::zero ();\n       latch_edge->flags |= flags;\n       latch_edge->goto_locus = locus;\n \n       add_bb_to_loop (latch_edge->dest, current_loops->tree_root);\n-      latch_edge->dest->count = 0;\n+      latch_edge->dest->count = profile_count::zero ();\n       latch_edge->dest->frequency = 0;\n       set_immediate_dominator (CDI_DOMINATORS, latch_edge->dest, latch_edge->src);\n \n@@ -916,10 +916,10 @@ try_unroll_loop_completely (struct loop *loop,\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, locus,\n                            \"loop with %d iterations completely unrolled\",\n \t\t\t   (int) (n_unroll + 1));\n-          if (profile_info)\n+          if (loop->header->count.initialized_p ())\n             dump_printf (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS,\n                          \" (header execution count %d)\",\n-                         (int)loop->header->count);\n+                         (int)loop->header->count.to_gcov_type ());\n           dump_printf (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS, \"\\n\");\n         }\n     }\n@@ -1088,21 +1088,22 @@ try_peel_loop (struct loop *loop,\n \t  loop->nb_iterations_likely_upper_bound = 0;\n \t}\n     }\n-  gcov_type entry_count = 0;\n+  profile_count entry_count = profile_count::zero ();\n   int entry_freq = 0;\n \n   edge e;\n   edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n     if (e->src != loop->latch)\n       {\n-\tentry_count += e->src->count;\n+\tif (e->src->count.initialized_p ())\n+\t  entry_count = e->src->count + e->src->count;\n \tentry_freq += e->src->frequency;\n \tgcc_assert (!flow_bb_inside_loop_p (loop, e->src));\n       }\n   int scale = 1;\n-  if (loop->header->count)\n-    scale = RDIV (entry_count * REG_BR_PROB_BASE, loop->header->count);\n+  if (loop->header->count > 0)\n+    scale = entry_count.probability_in (loop->header->count);\n   else if (loop->header->frequency)\n     scale = RDIV (entry_freq * REG_BR_PROB_BASE, loop->header->frequency);\n   scale_loop_profile (loop, scale, 0);"}, {"sha": "18ed4f6268602ced3bb5e3728ba0c71416f83e05", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1213,7 +1213,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   use_operand_p op;\n   bool ok;\n   unsigned i, prob, prob_entry, scale_unrolled, scale_rest;\n-  gcov_type freq_e, freq_h;\n+  profile_count freq_e, freq_h;\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, factor);\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n   auto_vec<edge> to_remove;\n@@ -1281,8 +1281,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   new_nonexit->probability = REG_BR_PROB_BASE - exit->probability;\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n   new_nonexit->count -= exit->count;\n-  if (new_nonexit->count < 0)\n-    new_nonexit->count = 0;\n   scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n \t\t\t     REG_BR_PROB_BASE);\n \n@@ -1356,19 +1354,21 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   freq_h = loop->header->count;\n   freq_e = (loop_preheader_edge (loop))->count;\n   /* Use frequency only if counts are zero.  */\n-  if (freq_h == 0 && freq_e == 0)\n+  if (!(freq_h > 0) && !(freq_e > 0))\n     {\n-      freq_h = loop->header->frequency;\n-      freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n+      freq_h = profile_count::from_gcov_type (loop->header->frequency);\n+      freq_e = profile_count::from_gcov_type\n+\t\t (EDGE_FREQUENCY (loop_preheader_edge (loop)));\n     }\n-  if (freq_h != 0)\n+  if (freq_h > 0)\n     {\n       gcov_type scale;\n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n-      freq_e = MAX (freq_e, 1);\n+      if (freq_e == profile_count::zero ())\n+        freq_e = profile_count::from_gcov_type (1);\n       /* This should not overflow.  */\n-      scale = GCOV_COMPUTE_SCALE (freq_e * (new_est_niter + 1), freq_h);\n+      scale = freq_e.probability_in (freq_h);\n       scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n     }\n \n@@ -1384,8 +1384,6 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   prob = new_nonexit->probability;\n   new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n   new_nonexit->count = exit_bb->count - new_exit->count;\n-  if (new_nonexit->count < 0)\n-    new_nonexit->count = 0;\n   if (prob > 0)\n     scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n \t\t\t       prob);"}, {"sha": "b1f14078b4fa071a8f4648798b3017650d6c9cd3", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -3815,8 +3815,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n      recomputing iteration bounds later in the compilation process will just\n      introduce random roundoff errors.  */\n   if (!loop->any_estimate\n-      && loop->header->count != 0\n-      && profile_status_for_fn (cfun) >= PROFILE_READ)\n+      && loop->header->count > 0)\n     {\n       gcov_type nit = expected_loop_iterations_unbounded (loop);\n       bound = gcov_type_to_wide_int (nit);"}, {"sha": "e77f2bfd1b521fc27b92b017d47af28195f3ca2c", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -355,7 +355,7 @@ connect_loops (struct loop *loop1, struct loop *loop2)\n \n   new_e->count = skip_bb->count;\n   new_e->probability = PROB_LIKELY;\n-  new_e->count = apply_probability (skip_e->count, PROB_LIKELY);\n+  new_e->count = skip_e->count.apply_probability (PROB_LIKELY);\n   skip_e->count -= new_e->count;\n   skip_e->probability = inverse_probability (PROB_LIKELY);\n "}, {"sha": "12bf640d3f840d8dff464218415667e42fde23f8", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -842,9 +842,10 @@ hoist_guard (struct loop *loop, edge guard)\n   /* Determine the probability that we skip the loop.  Assume that loop has\n      same average number of iterations regardless outcome of guard.  */\n   new_edge->probability = guard->probability;\n-  int skip_count = guard->src->count\n-\t\t   ? RDIV (guard->count * pre_header->count, guard->src->count)\n-\t\t   : apply_probability (guard->count, new_edge->probability);\n+  profile_count skip_count = guard->src->count > 0\n+\t\t   ? guard->count.apply_scale (pre_header->count,\n+\t\t\t\t\t       guard->src->count)\n+\t\t   : guard->count.apply_probability (new_edge->probability);\n \n   if (skip_count > e->count)\n     {\n@@ -868,7 +869,7 @@ hoist_guard (struct loop *loop, edge guard)\n   /* ... now update profile to represent that original guard will be optimized\n      away ...  */\n   guard->probability = 0;\n-  guard->count = 0;\n+  guard->count = profile_count::zero ();\n   not_guard->probability = REG_BR_PROB_BASE;\n   /* This count is wrong (frequency of not_guard does not change),\n      but will be scaled later.  */"}, {"sha": "6831f4474515a427839004a53f4685403800e551", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -5827,7 +5827,7 @@ branch_fixup (void)\n \n       edge etrue = make_edge (cond_bb, merge_bb, EDGE_TRUE_VALUE);\n       etrue->probability = REG_BR_PROB_BASE / 2;\n-      etrue->count = cond_bb->count / 2;\n+      etrue->count = cond_bb->count.apply_scale (1, 2);\n       edge efalse = find_edge (cond_bb, then_bb);\n       efalse->flags = EDGE_FALSE_VALUE;\n       efalse->probability -= etrue->probability;"}, {"sha": "c86148bc83269cfa165ec7fc356f499dbd8f1b00", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -1562,7 +1562,7 @@ replace_block_by (basic_block bb1, basic_block bb2)\n   bb2->count += bb1->count;\n \n   /* Merge the outgoing edge counts from bb1 onto bb2.  */\n-  gcov_type out_sum = 0;\n+  profile_count out_sum = profile_count::zero ();\n   FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n       e2 = find_edge (bb2, e1->dest);\n@@ -1576,7 +1576,7 @@ replace_block_by (basic_block bb1, basic_block bb2)\n      making the bb count inconsistent with the edge weights.  */\n   FOR_EACH_EDGE (e2, ei, bb2->succs)\n     {\n-      e2->probability = GCOV_COMPUTE_SCALE (e2->count, out_sum);\n+      e2->probability = e2->count.probability_in (out_sum);\n     }\n \n   /* Move over any user labels from bb1 after the bb2 labels.  */"}, {"sha": "a77c279b41b1cf3c4f286cc319e908442704060f", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -341,7 +341,7 @@ create_block_for_threading (basic_block bb,\n \n   /* Zero out the profile, since the block is unreachable for now.  */\n   rd->dup_blocks[count]->frequency = 0;\n-  rd->dup_blocks[count]->count = 0;\n+  rd->dup_blocks[count]->count = profile_count::uninitialized ();\n   if (duplicate_blocks)\n     bitmap_set_bit (*duplicate_blocks, rd->dup_blocks[count]->index);\n }\n@@ -694,16 +694,16 @@ any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n static bool\n compute_path_counts (struct redirection_data *rd,\n \t\t     ssa_local_info_t *local_info,\n-\t\t     gcov_type *path_in_count_ptr,\n-\t\t     gcov_type *path_out_count_ptr,\n+\t\t     profile_count *path_in_count_ptr,\n+\t\t     profile_count *path_out_count_ptr,\n \t\t     int *path_in_freq_ptr)\n {\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n   edge elast = path->last ()->e;\n-  gcov_type nonpath_count = 0;\n+  profile_count nonpath_count = profile_count::zero ();\n   bool has_joiner = false;\n-  gcov_type path_in_count = 0;\n+  profile_count path_in_count = profile_count::zero ();\n   int path_in_freq = 0;\n \n   /* Start by accumulating incoming edge counts to the path's first bb\n@@ -761,11 +761,11 @@ compute_path_counts (struct redirection_data *rd,\n \n   /* Now compute the fraction of the total count coming into the first\n      path bb that is from the current threading path.  */\n-  gcov_type total_count = e->dest->count;\n+  profile_count total_count = e->dest->count;\n   /* Handle incoming profile insanities.  */\n   if (total_count < path_in_count)\n     path_in_count = total_count;\n-  int onpath_scale = GCOV_COMPUTE_SCALE (path_in_count, total_count);\n+  int onpath_scale = path_in_count.probability_in (total_count);\n \n   /* Walk the entire path to do some more computation in order to estimate\n      how much of the path_in_count will flow out of the duplicated threading\n@@ -786,16 +786,16 @@ compute_path_counts (struct redirection_data *rd,\n      nonpath_count with any additional counts coming into the path.  Other\n      blocks along the path may have additional predecessors from outside\n      the path.  */\n-  gcov_type path_out_count = path_in_count;\n-  gcov_type min_path_count = path_in_count;\n+  profile_count path_out_count = path_in_count;\n+  profile_count min_path_count = path_in_count;\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n-      gcov_type cur_count = epath->count;\n+      profile_count cur_count = epath->count;\n       if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n \t{\n \t  has_joiner = true;\n-\t  cur_count = apply_probability (cur_count, onpath_scale);\n+\t  cur_count = cur_count.apply_probability (onpath_scale);\n \t}\n       /* In the joiner case we need to update nonpath_count for any edges\n \t coming into the path that will contribute to the count flowing\n@@ -857,15 +857,15 @@ compute_path_counts (struct redirection_data *rd,\n    will get a count/frequency of PATH_IN_COUNT and PATH_IN_FREQ,\n    and the duplicate edge EDUP will have a count of PATH_OUT_COUNT.  */\n static void\n-update_profile (edge epath, edge edup, gcov_type path_in_count,\n-\t\tgcov_type path_out_count, int path_in_freq)\n+update_profile (edge epath, edge edup, profile_count path_in_count,\n+\t\tprofile_count path_out_count, int path_in_freq)\n {\n \n   /* First update the duplicated block's count / frequency.  */\n   if (edup)\n     {\n       basic_block dup_block = edup->src;\n-      gcc_assert (dup_block->count == 0);\n+      gcc_assert (!dup_block->count.initialized_p ());\n       gcc_assert (dup_block->frequency == 0);\n       dup_block->count = path_in_count;\n       dup_block->frequency = path_in_freq;\n@@ -876,8 +876,6 @@ update_profile (edge epath, edge edup, gcov_type path_in_count,\n      into the duplicated block.  Handle underflow due to precision/\n      rounding issues.  */\n   epath->src->count -= path_in_count;\n-  if (epath->src->count < 0)\n-    epath->src->count = 0;\n   epath->src->frequency -= path_in_freq;\n   if (epath->src->frequency < 0)\n     epath->src->frequency = 0;\n@@ -890,7 +888,7 @@ update_profile (edge epath, edge edup, gcov_type path_in_count,\n   if (edup)\n     edup->count = path_out_count;\n   epath->count -= path_out_count;\n-  gcc_assert (epath->count >= 0);\n+  /* FIXME: can epath->count be legally uninitialized here?  */\n }\n \n \n@@ -906,13 +904,12 @@ recompute_probabilities (basic_block bb)\n   edge_iterator ei;\n   FOR_EACH_EDGE (esucc, ei, bb->succs)\n     {\n-      if (!bb->count)\n+      if (!(bb->count > 0))\n \tcontinue;\n \n       /* Prevent overflow computation due to insane profiles.  */\n       if (esucc->count < bb->count)\n-\tesucc->probability = GCOV_COMPUTE_SCALE (esucc->count,\n-\t\t\t\t\t\t bb->count);\n+\tesucc->probability = esucc->count.probability_in (bb->count);\n       else\n \t/* Can happen with missing/guessed probabilities, since we\n \t   may determine that more is flowing along duplicated\n@@ -935,8 +932,8 @@ recompute_probabilities (basic_block bb)\n \n static void\n update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n-\t\t\t      gcov_type path_in_count,\n-\t\t\t      gcov_type path_out_count)\n+\t\t\t      profile_count path_in_count,\n+\t\t\t      profile_count path_out_count)\n {\n   /* Compute the count that currently flows off path from the joiner.\n      In other words, the total count of joiner's out edges other than\n@@ -945,7 +942,7 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n      are sometimes slight insanities where the total out edge count is\n      larger than the bb count (possibly due to rounding/truncation\n      errors).  */\n-  gcov_type total_orig_off_path_count = 0;\n+  profile_count total_orig_off_path_count = profile_count::zero ();\n   edge enonpath;\n   edge_iterator ei;\n   FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n@@ -960,7 +957,7 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n      path's cumulative in count and the portion of that count we\n      estimated above as flowing from the joiner along the duplicated\n      path.  */\n-  gcov_type total_dup_off_path_count = path_in_count - path_out_count;\n+  profile_count total_dup_off_path_count = path_in_count - path_out_count;\n \n   /* Now do the actual updates of the off-path edges.  */\n   FOR_EACH_EDGE (enonpath, ei, epath->src->succs)\n@@ -981,17 +978,13 @@ update_joiner_offpath_counts (edge epath, basic_block dup_bb,\n \t among the duplicated off-path edges based on their original\n \t ratio to the full off-path count (total_orig_off_path_count).\n \t */\n-      int scale = GCOV_COMPUTE_SCALE (enonpath->count,\n-\t\t\t\t      total_orig_off_path_count);\n+      int scale = enonpath->count.probability_in (total_orig_off_path_count);\n       /* Give the duplicated offpath edge a portion of the duplicated\n \t total.  */\n-      enonpathdup->count = apply_scale (scale,\n-\t\t\t\t\ttotal_dup_off_path_count);\n+      enonpathdup->count = total_dup_off_path_count.apply_probability (scale);\n       /* Now update the original offpath edge count, handling underflow\n \t due to rounding errors.  */\n       enonpath->count -= enonpathdup->count;\n-      if (enonpath->count < 0)\n-\tenonpath->count = 0;\n     }\n }\n \n@@ -1010,21 +1003,21 @@ estimated_freqs_path (struct redirection_data *rd)\n   bool non_zero_freq = false;\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n     {\n-      if (ein->count)\n+      if (ein->count > 0)\n \treturn false;\n       non_zero_freq |= ein->src->frequency != 0;\n     }\n \n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n-      if (epath->src->count)\n+      if (epath->src->count > 0)\n \treturn false;\n       non_zero_freq |= epath->src->frequency != 0;\n       edge esucc;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n \t{\n-\t  if (esucc->count)\n+\t  if (esucc->count > 0)\n \t    return false;\n \t  non_zero_freq |= esucc->src->frequency != 0;\n \t}\n@@ -1055,8 +1048,9 @@ freqs_to_counts_path (struct redirection_data *rd)\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n \t errors applying the probability when the frequencies are very\n \t small.  */\n-      ein->count = apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n-\t\t\t\t      ein->probability);\n+      ein->count = profile_count::from_gcov_type\n+\t\t(apply_probability (ein->src->frequency * REG_BR_PROB_BASE,\n+\t\t\t\t      ein->probability));\n     }\n \n   for (unsigned int i = 1; i < path->length (); i++)\n@@ -1066,10 +1060,12 @@ freqs_to_counts_path (struct redirection_data *rd)\n       /* Scale up the frequency by REG_BR_PROB_BASE, to avoid rounding\n \t errors applying the edge probability when the frequencies are very\n \t small.  */\n-      epath->src->count = epath->src->frequency * REG_BR_PROB_BASE;\n+      epath->src->count = \n+\tprofile_count::from_gcov_type\n+\t  (epath->src->frequency * REG_BR_PROB_BASE);\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\tesucc->count = apply_probability (esucc->src->count,\n-\t\t\t\t\t  esucc->probability);\n+\tesucc->count = \n+\t   esucc->src->count.apply_probability (esucc->probability);\n     }\n }\n \n@@ -1089,15 +1085,15 @@ clear_counts_path (struct redirection_data *rd)\n   edge ein, esucc;\n   edge_iterator ei;\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    ein->count = 0;\n+    ein->count = profile_count::uninitialized ();\n \n   /* First clear counts along original path.  */\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\tesucc->count = 0;\n-      epath->src->count = 0;\n+\tesucc->count = profile_count::uninitialized ();\n+      epath->src->count = profile_count::uninitialized ();\n     }\n   /* Also need to clear the counts along duplicated path.  */\n   for (unsigned int i = 0; i < 2; i++)\n@@ -1106,8 +1102,8 @@ clear_counts_path (struct redirection_data *rd)\n       if (!dup)\n \tcontinue;\n       FOR_EACH_EDGE (esucc, ei, dup->succs)\n-\tesucc->count = 0;\n-      dup->count = 0;\n+\tesucc->count = profile_count::uninitialized ();\n+      dup->count = profile_count::uninitialized ();\n     }\n }\n \n@@ -1122,8 +1118,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n   edge elast = path->last ()->e;\n-  gcov_type path_in_count = 0;\n-  gcov_type path_out_count = 0;\n+  profile_count path_in_count = profile_count::zero ();\n+  profile_count path_out_count = profile_count::zero ();\n   int path_in_freq = 0;\n \n   /* This routine updates profile counts, frequencies, and probabilities\n@@ -2217,7 +2213,7 @@ duplicate_thread_path (edge entry, edge exit,\n   edge exit_copy;\n   edge redirected;\n   int curr_freq;\n-  gcov_type curr_count;\n+  profile_count curr_count;\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -2268,21 +2264,21 @@ duplicate_thread_path (edge entry, edge exit,\n       if (curr_freq > region[i]->frequency)\n \tcurr_freq = region[i]->frequency;\n       /* Scale current BB.  */\n-      if (region[i]->count)\n+      if (region[i]->count > 0 && curr_count.initialized_p ())\n \t{\n \t  /* In the middle of the path we only scale the frequencies.\n \t     In last BB we need to update probabilities of outgoing edges\n \t     because we know which one is taken at the threaded path.  */\n \t  if (i + 1 != n_region)\n-\t    scale_bbs_frequencies_gcov_type (region + i, 1,\n-\t\t\t\t\t     region[i]->count - curr_count,\n-\t\t\t\t\t     region[i]->count);\n+\t    scale_bbs_frequencies_profile_count (region + i, 1,\n+\t\t\t\t\t         region[i]->count - curr_count,\n+\t\t\t\t\t         region[i]->count);\n \t  else\n \t    update_bb_profile_for_threading (region[i],\n \t\t\t\t\t     curr_freq, curr_count,\n \t\t\t\t\t     exit);\n-\t  scale_bbs_frequencies_gcov_type (region_copy + i, 1, curr_count,\n-\t\t\t\t\t   region_copy[i]->count);\n+\t  scale_bbs_frequencies_profile_count (region_copy + i, 1, curr_count,\n+\t\t\t\t\t       region_copy[i]->count);\n \t}\n       else if (region[i]->frequency)\n \t{"}, {"sha": "66db20fe7bc6fa4afe25e094de522fc232faae86", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -236,8 +236,10 @@ case_bit_test_cmp (const void *p1, const void *p2)\n   const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n   const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n \n-  if (d2->target_edge->count != d1->target_edge->count)\n-    return d2->target_edge->count - d1->target_edge->count;\n+  if (d2->target_edge->count < d1->target_edge->count)\n+    return -1;\n+  if (d2->target_edge->count > d1->target_edge->count)\n+    return 1;\n   if (d2->bits != d1->bits)\n     return d2->bits - d1->bits;\n \n@@ -559,10 +561,10 @@ struct switch_conv_info\n   int default_prob;\n \n   /* The count of the default edge in the replaced switch.  */\n-  gcov_type default_count;\n+  profile_count default_count;\n \n   /* Combined count of all other (non-default) edges in the replaced switch.  */\n-  gcov_type other_count;\n+  profile_count other_count;\n \n   /* Number of phi nodes in the final bb (that we'll be replacing).  */\n   int phi_count;"}, {"sha": "b7053387e91925c0c7678ea48d61c4442acdce85", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -799,12 +799,10 @@ adjust_return_value (basic_block bb, tree m, tree a)\n /* Subtract COUNT and FREQUENCY from the basic block and it's\n    outgoing edge.  */\n static void\n-decrease_profile (basic_block bb, gcov_type count, int frequency)\n+decrease_profile (basic_block bb, profile_count count, int frequency)\n {\n   edge e;\n-  bb->count -= count;\n-  if (bb->count < 0)\n-    bb->count = 0;\n+  bb->count = bb->count - count;\n   bb->frequency -= frequency;\n   if (bb->frequency < 0)\n     bb->frequency = 0;\n@@ -815,8 +813,6 @@ decrease_profile (basic_block bb, gcov_type count, int frequency)\n     }\n   e = single_succ_edge (bb);\n   e->count -= count;\n-  if (e->count < 0)\n-    e->count = 0;\n }\n \n /* Returns true if argument PARAM of the tail recursive call needs to be copied"}, {"sha": "2a7fdca5690483cf987ba5e9c333452405708bc6", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -566,7 +566,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n \n   new_e->count = guard_bb->count;\n   new_e->probability = probability;\n-  new_e->count = apply_probability (enter_e->count, probability);\n+  new_e->count = enter_e->count.apply_probability (probability);\n   if (irreducible_p)\n     new_e->flags |= EDGE_IRREDUCIBLE_LOOP;\n "}, {"sha": "28f4349a3c842d14b0e0c7970e22d12a9e5909d3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -6666,23 +6666,24 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n   edge preheader = loop_preheader_edge (loop);\n   /* Reduce loop iterations by the vectorization factor.  */\n   gcov_type new_est_niter = niter_for_unrolled_loop (loop, vf);\n-  gcov_type freq_h = loop->header->count, freq_e = preheader->count;\n+  profile_count freq_h = loop->header->count, freq_e = preheader->count;\n \n   /* Use frequency only if counts are zero.  */\n-  if (freq_h == 0 && freq_e == 0)\n+  if (!(freq_h > 0) && !(freq_e > 0))\n     {\n-      freq_h = loop->header->frequency;\n-      freq_e = EDGE_FREQUENCY (preheader);\n+      freq_h = profile_count::from_gcov_type (loop->header->frequency);\n+      freq_e = profile_count::from_gcov_type (EDGE_FREQUENCY (preheader));\n     }\n-  if (freq_h != 0)\n+  if (freq_h > 0)\n     {\n       gcov_type scale;\n \n       /* Avoid dropping loop body profile counter to 0 because of zero count\n \t in loop's preheader.  */\n-      freq_e = MAX (freq_e, 1);\n+      if (!(freq_e > profile_count::from_gcov_type (1)))\n+       freq_e = profile_count::from_gcov_type (1);\n       /* This should not overflow.  */\n-      scale = GCOV_COMPUTE_SCALE (freq_e * (new_est_niter + 1), freq_h);\n+      scale = freq_e.apply_scale (new_est_niter + 1, 1).probability_in (freq_h);\n       scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n     }\n \n@@ -6695,8 +6696,6 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n   int prob = exit_l->probability;\n   exit_l->probability = REG_BR_PROB_BASE - exit_e->probability;\n   exit_l->count = exit_bb->count - exit_e->count;\n-  if (exit_l->count < 0)\n-    exit_l->count = 0;\n   if (prob > 0)\n     scale_bbs_frequencies_int (&loop->latch, 1, exit_l->probability, prob);\n }"}, {"sha": "56ec9fe570bd21c887a9be63efed683f9008acf6", "filename": "gcc/value-prof.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -588,8 +588,9 @@ free_histograms (struct function *fn)\n \n static bool\n check_counter (gimple *stmt, const char * name,\n-\t       gcov_type *count, gcov_type *all, gcov_type bb_count)\n+\t       gcov_type *count, gcov_type *all, profile_count bb_count_d)\n {\n+  gcov_type bb_count = bb_count_d.to_gcov_type ();\n   if (*all != bb_count || *count > *all)\n     {\n       location_t locus;\n@@ -740,31 +741,31 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, int prob,\n   /* Edge e23 connects bb2 to bb3, etc. */\n   e12 = split_block (bb, bb1end);\n   bb2 = e12->dest;\n-  bb2->count = count;\n+  bb2->count = profile_count::from_gcov_type (count);\n   e23 = split_block (bb2, bb2end);\n   bb3 = e23->dest;\n-  bb3->count = all - count;\n+  bb3->count = profile_count::from_gcov_type (all - count);\n   e34 = split_block (bb3, bb3end);\n   bb4 = e34->dest;\n-  bb4->count = all;\n+  bb4->count = profile_count::from_gcov_type (all);\n \n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = prob;\n-  e12->count = count;\n+  e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n   e13->probability = REG_BR_PROB_BASE - prob;\n-  e13->count = all - count;\n+  e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n   e24->probability = REG_BR_PROB_BASE;\n-  e24->count = count;\n+  e24->count = profile_count::from_gcov_type (count);\n \n   e34->probability = REG_BR_PROB_BASE;\n-  e34->count = all - count;\n+  e34->count = profile_count::from_gcov_type (all - count);\n \n   return tmp2;\n }\n@@ -905,31 +906,31 @@ gimple_mod_pow2 (gassign *stmt, int prob, gcov_type count, gcov_type all)\n   /* Edge e23 connects bb2 to bb3, etc. */\n   e12 = split_block (bb, bb1end);\n   bb2 = e12->dest;\n-  bb2->count = count;\n+  bb2->count = profile_count::from_gcov_type (count);\n   e23 = split_block (bb2, bb2end);\n   bb3 = e23->dest;\n-  bb3->count = all - count;\n+  bb3->count = profile_count::from_gcov_type (all - count);\n   e34 = split_block (bb3, bb3end);\n   bb4 = e34->dest;\n-  bb4->count = all;\n+  bb4->count = profile_count::from_gcov_type (all);\n \n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = prob;\n-  e12->count = count;\n+  e12->count = profile_count::from_gcov_type (count);\n \n   e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n   e13->probability = REG_BR_PROB_BASE - prob;\n-  e13->count = all - count;\n+  e13->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e23);\n \n   e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n   e24->probability = REG_BR_PROB_BASE;\n-  e24->count = count;\n+  e24->count = profile_count::from_gcov_type (count);\n \n   e34->probability = REG_BR_PROB_BASE;\n-  e34->count = all - count;\n+  e34->count = profile_count::from_gcov_type (all - count);\n \n   return result;\n }\n@@ -1065,42 +1066,42 @@ gimple_mod_subtract (gassign *stmt, int prob1, int prob2, int ncounts,\n      to 3 really refer to block 2. */\n   e12 = split_block (bb, bb1end);\n   bb2 = e12->dest;\n-  bb2->count = all - count1;\n+  bb2->count = profile_count::from_gcov_type (all - count1);\n \n   if (ncounts)\t/* Assumed to be 0 or 1.  */\n     {\n       e23 = split_block (bb2, bb2end);\n       bb3 = e23->dest;\n-      bb3->count = all - count1 - count2;\n+      bb3->count = profile_count::from_gcov_type (all - count1 - count2);\n     }\n \n   e34 = split_block (ncounts ? bb3 : bb2, bb3end);\n   bb4 = e34->dest;\n-  bb4->count = all;\n+  bb4->count = profile_count::from_gcov_type (all);\n \n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = REG_BR_PROB_BASE - prob1;\n-  e12->count = all - count1;\n+  e12->count = profile_count::from_gcov_type (all - count1);\n \n   e14 = make_edge (bb, bb4, EDGE_TRUE_VALUE);\n   e14->probability = prob1;\n-  e14->count = count1;\n+  e14->count = profile_count::from_gcov_type (count1);\n \n   if (ncounts)  /* Assumed to be 0 or 1.  */\n     {\n       e23->flags &= ~EDGE_FALLTHRU;\n       e23->flags |= EDGE_FALSE_VALUE;\n-      e23->count = all - count1 - count2;\n+      e23->count = profile_count::from_gcov_type (all - count1 - count2);\n       e23->probability = REG_BR_PROB_BASE - prob2;\n \n       e24 = make_edge (bb2, bb4, EDGE_TRUE_VALUE);\n       e24->probability = prob2;\n-      e24->count = count2;\n+      e24->count = profile_count::from_gcov_type (count2);\n     }\n \n   e34->probability = REG_BR_PROB_BASE;\n-  e34->count = all - count1 - count2;\n+  e34->count = profile_count::from_gcov_type (all - count1 - count2);\n \n   return result;\n }\n@@ -1317,7 +1318,7 @@ check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n \n gcall *\n gimple_ic (gcall *icall_stmt, struct cgraph_node *direct_call,\n-\t   int prob, gcov_type count, gcov_type all)\n+\t   int prob, profile_count count, profile_count all)\n {\n   gcall *dcall_stmt;\n   gassign *load_stmt;\n@@ -1543,12 +1544,13 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n   count = histogram->hvalue.counters [1];\n   all = histogram->hvalue.counters [2];\n \n-  bb_all = gimple_bb (stmt)->count;\n+  bb_all = gimple_bb (stmt)->count.to_gcov_type ();\n   /* The order of CHECK_COUNTER calls is important -\n      since check_counter can correct the third parameter\n      and we want to make count <= all <= bb_all. */\n-  if ( check_counter (stmt, \"ic\", &all, &bb_all, bb_all)\n-      || check_counter (stmt, \"ic\", &count, &all, all))\n+  if (check_counter (stmt, \"ic\", &all, &bb_all, gimple_bb (stmt)->count)\n+      || check_counter (stmt, \"ic\", &count, &all,\n+\t\t        profile_count::from_gcov_type (all)))\n     {\n       gimple_remove_histogram_value (cfun, stmt, histogram);\n       return false;\n@@ -1694,32 +1696,32 @@ gimple_stringop_fixed_value (gcall *vcall_stmt, tree icall_size, int prob,\n   /* Edge e_ci connects cond_bb to icall_bb, etc. */\n   e_ci = split_block (cond_bb, cond_stmt);\n   icall_bb = e_ci->dest;\n-  icall_bb->count = count;\n+  icall_bb->count = profile_count::from_gcov_type (count);\n \n   e_iv = split_block (icall_bb, icall_stmt);\n   vcall_bb = e_iv->dest;\n-  vcall_bb->count = all - count;\n+  vcall_bb->count = profile_count::from_gcov_type (all - count);\n \n   e_vj = split_block (vcall_bb, vcall_stmt);\n   join_bb = e_vj->dest;\n-  join_bb->count = all;\n+  join_bb->count = profile_count::from_gcov_type (all);\n \n   e_ci->flags = (e_ci->flags & ~EDGE_FALLTHRU) | EDGE_TRUE_VALUE;\n   e_ci->probability = prob;\n-  e_ci->count = count;\n+  e_ci->count = profile_count::from_gcov_type (count);\n \n   e_cv = make_edge (cond_bb, vcall_bb, EDGE_FALSE_VALUE);\n   e_cv->probability = REG_BR_PROB_BASE - prob;\n-  e_cv->count = all - count;\n+  e_cv->count = profile_count::from_gcov_type (all - count);\n \n   remove_edge (e_iv);\n \n   e_ij = make_edge (icall_bb, join_bb, EDGE_FALLTHRU);\n   e_ij->probability = REG_BR_PROB_BASE;\n-  e_ij->count = count;\n+  e_ij->count = profile_count::from_gcov_type (count);\n \n   e_vj->probability = REG_BR_PROB_BASE;\n-  e_vj->count = all - count;\n+  e_vj->count = profile_count::from_gcov_type (all - count);\n \n   /* Insert PHI node for the call result if necessary.  */\n   if (gimple_call_lhs (vcall_stmt)"}, {"sha": "92649ecd322efe992164333c2808a49490e9c4c0", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3995f3a2207fbde0c31341d79bf49563d681ca9a/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=3995f3a2207fbde0c31341d79bf49563d681ca9a", "patch": "@@ -90,8 +90,8 @@ void gimple_move_stmt_histograms (struct function *, gimple *, gimple *);\n void verify_histograms (void);\n void free_histograms (function *);\n void stringop_block_profile (gimple *, unsigned int *, HOST_WIDE_INT *);\n-gcall *gimple_ic (gcall *, struct cgraph_node *, int, gcov_type,\n-\t\t  gcov_type);\n+gcall *gimple_ic (gcall *, struct cgraph_node *, int, profile_count,\n+\t\t  profile_count);\n bool check_ic_target (gcall *, struct cgraph_node *);\n \n "}]}