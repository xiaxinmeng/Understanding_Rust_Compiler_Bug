{"sha": "a9d07d6e65f690431a892903c89404a9ed291000", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkMDdkNmU2NWY2OTA0MzFhODkyOTAzYzg5NDA0YTllZDI5MTAwMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-18T19:08:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-18T19:08:26Z"}, "message": "(const_hash): Treat NON_LVALUE_EXPR like CONVERT_EXPR.\n\n(compare_constant_1, copy_constant, bc_assemble_integer): Likewise.\n(const_hash, compare_constant_1): Use switch, not if-then-else.\n\nFrom-SVN: r13507", "tree": {"sha": "9ec3c5d4da10a2a92e4a2000ca70a645fca039ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ec3c5d4da10a2a92e4a2000ca70a645fca039ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9d07d6e65f690431a892903c89404a9ed291000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d07d6e65f690431a892903c89404a9ed291000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9d07d6e65f690431a892903c89404a9ed291000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d07d6e65f690431a892903c89404a9ed291000/comments", "author": null, "committer": null, "parents": [{"sha": "19b38e0407fec8b68a4d5d14bb8ad2340df8d53a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b38e0407fec8b68a4d5d14bb8ad2340df8d53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b38e0407fec8b68a4d5d14bb8ad2340df8d53a"}], "stats": {"total": 328, "additions": 188, "deletions": 140}, "files": [{"sha": "7595f48b5a1810533240e1afbf0d380e484e6c4c", "filename": "gcc/varasm.c", "status": "modified", "additions": 188, "deletions": 140, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d07d6e65f690431a892903c89404a9ed291000/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d07d6e65f690431a892903c89404a9ed291000/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a9d07d6e65f690431a892903c89404a9ed291000", "patch": "@@ -2344,75 +2344,95 @@ const_hash (exp)\n   register int len, hi, i;\n   register enum tree_code code = TREE_CODE (exp);\n \n-  if (code == INTEGER_CST)\n+  /* Either set P and LEN to the address and len of something to hash and\n+     exit the switch or return a value.  */\n+\n+  switch (code)\n     {\n+    case INTEGER_CST:\n       p = (char *) &TREE_INT_CST_LOW (exp);\n       len = 2 * sizeof TREE_INT_CST_LOW (exp);\n-    }\n-  else if (code == REAL_CST)\n-    {\n+      break;\n+\n+    case REAL_CST:\n       p = (char *) &TREE_REAL_CST (exp);\n       len = sizeof TREE_REAL_CST (exp);\n-    }\n-  else if (code == STRING_CST)\n-    p = TREE_STRING_POINTER (exp), len = TREE_STRING_LENGTH (exp);\n-  else if (code == COMPLEX_CST)\n-    return const_hash (TREE_REALPART (exp)) * 5\n-      + const_hash (TREE_IMAGPART (exp));\n-  else if (code == CONSTRUCTOR && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-    {\n-      len = int_size_in_bytes (TREE_TYPE (exp));\n-      p = (char *) alloca (len);\n-      get_set_constructor_bytes (exp, (unsigned char *) p, len);\n-    }\n-  else if (code == CONSTRUCTOR)\n-    {\n-      register tree link;\n-\n-      /* For record type, include the type in the hashing.\n-\t We do not do so for array types\n-\t because (1) the sizes of the elements are sufficient\n-\t and (2) distinct array types can have the same constructor.\n-\t Instead, we include the array size because the constructor could\n-\t be shorter.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-\thi = ((HOST_WIDE_INT) TREE_TYPE (exp) & ((1 << HASHBITS) - 1))\n-\t  % MAX_HASH_TABLE;\n-      else\n-\thi = ((5 + int_size_in_bytes (TREE_TYPE (exp)))\n-\t       & ((1 << HASHBITS) - 1)) % MAX_HASH_TABLE;\n+      break;\n \n-      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n-\tif (TREE_VALUE (link))\n-\t  hi = (hi * 603 + const_hash (TREE_VALUE (link))) % MAX_HASH_TABLE;\n+    case STRING_CST:\n+      p = TREE_STRING_POINTER (exp);\n+      len = TREE_STRING_LENGTH (exp);\n+      break;\n \n-      return hi;\n-    }\n-  else if (code == ADDR_EXPR)\n-    {\n-      struct addr_const value;\n-      decode_addr_const (exp, &value);\n-      if (GET_CODE (value.base) == SYMBOL_REF)\n+    case COMPLEX_CST:\n+      return (const_hash (TREE_REALPART (exp)) * 5\n+\t      + const_hash (TREE_IMAGPART (exp)));\n+\n+    case CONSTRUCTOR:\n+      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n \t{\n-\t  /* Don't hash the address of the SYMBOL_REF;\n-\t     only use the offset and the symbol name.  */\n-\t  hi = value.offset;\n-\t  p = XSTR (value.base, 0);\n-\t  for (i = 0; p[i] != 0; i++)\n-\t    hi = ((hi * 613) + (unsigned) (p[i]));\n+\t  len = int_size_in_bytes (TREE_TYPE (exp));\n+\t  p = (char *) alloca (len);\n+\t  get_set_constructor_bytes (exp, (unsigned char *) p, len);\n+\t  break;\n \t}\n-      else if (GET_CODE (value.base) == LABEL_REF)\n-\thi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n+      else\n+\t{\n+\t  register tree link;\n \n-      hi &= (1 << HASHBITS) - 1;\n-      hi %= MAX_HASH_TABLE;\n+\t  /* For record type, include the type in the hashing.\n+\t     We do not do so for array types\n+\t     because (1) the sizes of the elements are sufficient\n+\t     and (2) distinct array types can have the same constructor.\n+\t     Instead, we include the array size because the constructor could\n+\t     be shorter.  */\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\t    hi = ((HOST_WIDE_INT) TREE_TYPE (exp) & ((1 << HASHBITS) - 1))\n+\t      % MAX_HASH_TABLE;\n+\t  else\n+\t    hi = ((5 + int_size_in_bytes (TREE_TYPE (exp)))\n+\t\t  & ((1 << HASHBITS) - 1)) % MAX_HASH_TABLE;\n+\n+\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t    if (TREE_VALUE (link))\n+\t      hi\n+\t\t= (hi * 603 + const_hash (TREE_VALUE (link))) % MAX_HASH_TABLE;\n+\n+\t  return hi;\n+\t}\n+\n+    case ADDR_EXPR:\n+      {\n+\tstruct addr_const value;\n+\n+\tdecode_addr_const (exp, &value);\n+\tif (GET_CODE (value.base) == SYMBOL_REF)\n+\t  {\n+\t    /* Don't hash the address of the SYMBOL_REF;\n+\t       only use the offset and the symbol name.  */\n+\t    hi = value.offset;\n+\t    p = XSTR (value.base, 0);\n+\t    for (i = 0; p[i] != 0; i++)\n+\t      hi = ((hi * 613) + (unsigned) (p[i]));\n+\t  }\n+\telse if (GET_CODE (value.base) == LABEL_REF)\n+\t  hi = value.offset + CODE_LABEL_NUMBER (XEXP (value.base, 0)) * 13;\n+\n+\thi &= (1 << HASHBITS) - 1;\n+\thi %= MAX_HASH_TABLE;\n+      }\n       return hi;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      return (const_hash (TREE_OPERAND (exp, 0)) * 9\n+\t      + const_hash (TREE_OPERAND (exp, 1)));\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;\n     }\n-  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n-    return const_hash (TREE_OPERAND (exp, 0)) * 9\n-      +  const_hash (TREE_OPERAND (exp, 1));\n-  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n-    return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;\n \n   /* Compute hashing function */\n   hi = len;\n@@ -2456,122 +2476,146 @@ compare_constant_1 (exp, p)\n   if (code != (enum tree_code) *p++)\n     return 0;\n \n-  if (code == INTEGER_CST)\n+  /* Either set STRP, P and LEN to pointers and length to compare and exit the\n+     switch, or return the result of the comparison.  */\n+\n+  switch (code)\n     {\n+    case INTEGER_CST:\n       /* Integer constants are the same only if the same width of type.  */\n       if (*p++ != TYPE_PRECISION (TREE_TYPE (exp)))\n \treturn 0;\n+\n       strp = (char *) &TREE_INT_CST_LOW (exp);\n       len = 2 * sizeof TREE_INT_CST_LOW (exp);\n-    }\n-  else if (code == REAL_CST)\n-    {\n+      break;\n+\n+    case REAL_CST:\n       /* Real constants are the same only if the same width of type.  */\n       if (*p++ != TYPE_PRECISION (TREE_TYPE (exp)))\n \treturn 0;\n+\n       strp = (char *) &TREE_REAL_CST (exp);\n       len = sizeof TREE_REAL_CST (exp);\n-    }\n-  else if (code == STRING_CST)\n-    {\n+      break;\n+\n+    case STRING_CST:\n       if (flag_writable_strings)\n \treturn 0;\n+\n       strp = TREE_STRING_POINTER (exp);\n       len = TREE_STRING_LENGTH (exp);\n       if (bcmp ((char *) &TREE_STRING_LENGTH (exp), p,\n \t\tsizeof TREE_STRING_LENGTH (exp)))\n \treturn 0;\n+\n       p += sizeof TREE_STRING_LENGTH (exp);\n-    }\n-  else if (code == COMPLEX_CST)\n-    {\n-      p = compare_constant_1 (TREE_REALPART (exp), p);\n-      if (p == 0) return 0;\n-      p = compare_constant_1 (TREE_IMAGPART (exp), p);\n-      return p;\n-    }\n-  else if (code == CONSTRUCTOR && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n-    {\n-      int xlen = len = int_size_in_bytes (TREE_TYPE (exp));\n-      strp = (char *) alloca (len);\n-      get_set_constructor_bytes (exp, (unsigned char *) strp, len);\n-      if (bcmp ((char *) &xlen, p, sizeof xlen))\n-\treturn 0;\n-      p += sizeof xlen;\n-    }\n-  else if (code == CONSTRUCTOR)\n-    {\n-      register tree link;\n-      int length = list_length (CONSTRUCTOR_ELTS (exp));\n-      tree type;\n+      break;\n \n-      if (bcmp ((char *) &length, p, sizeof length))\n+    case COMPLEX_CST:\n+      p = compare_constant_1 (TREE_REALPART (exp), p);\n+      if (p == 0)\n \treturn 0;\n-      p += sizeof length;\n \n-      /* For record constructors, insist that the types match.\n-\t For arrays, just verify both constructors are for arrays.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n-\ttype = TREE_TYPE (exp);\n-      else\n-\ttype = 0;\n-      if (bcmp ((char *) &type, p, sizeof type))\n-\treturn 0;\n-      p += sizeof type;\n+      return compare_constant_1 (TREE_IMAGPART (exp), p);\n \n-      /* For arrays, insist that the size in bytes match.  */\n-      if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n+    case CONSTRUCTOR:\n+      if (TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n \t{\n-\t  int size = int_size_in_bytes (TREE_TYPE (exp));\n-\t  if (bcmp ((char *) &size, p, sizeof size))\n+\t  int xlen = len = int_size_in_bytes (TREE_TYPE (exp));\n+\n+\t  strp = (char *) alloca (len);\n+\t  get_set_constructor_bytes (exp, (unsigned char *) strp, len);\n+\t  if (bcmp ((char *) &xlen, p, sizeof xlen))\n \t    return 0;\n-\t  p += sizeof size;\n-\t}\n \n-      for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n+\t  p += sizeof xlen;\n+\t  break;\n+\t}\n+      else\n \t{\n-\t  if (TREE_VALUE (link))\n+\t  register tree link;\n+\t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n+\t  tree type;\n+\n+\t  if (bcmp ((char *) &length, p, sizeof length))\n+\t    return 0;\n+\n+\t  p += sizeof length;\n+\n+\t  /* For record constructors, insist that the types match.\n+\t     For arrays, just verify both constructors are for arrays.  */\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n+\t    type = TREE_TYPE (exp);\n+\t  else\n+\t    type = 0;\n+\n+\t  if (bcmp ((char *) &type, p, sizeof type))\n+\t    return 0;\n+\n+\t  p += sizeof type;\n+\n+\t  /* For arrays, insist that the size in bytes match.  */\n+\t  if (TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n \t    {\n-\t      if ((p = compare_constant_1 (TREE_VALUE (link), p)) == 0)\n+\t      int size = int_size_in_bytes (TREE_TYPE (exp));\n+\t      if (bcmp ((char *) &size, p, sizeof size))\n \t\treturn 0;\n+\n+\t      p += sizeof size;\n \t    }\n-\t  else\n+\n+\t  for (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n \t    {\n-\t      tree zero = 0;\n+\t      if (TREE_VALUE (link))\n+\t\t{\n+\t\t  if ((p = compare_constant_1 (TREE_VALUE (link), p)) == 0)\n+\t\t    return 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree zero = 0;\n \n-\t      if (bcmp ((char *) &zero, p, sizeof zero))\n-\t\treturn 0;\n-\t      p += sizeof zero;\n+\t\t  if (bcmp ((char *) &zero, p, sizeof zero))\n+\t\t    return 0;\n+\n+\t\t  p += sizeof zero;\n+\t\t}\n \t    }\n+\n+\t  return p;\n \t}\n \n-      return p;\n-    }\n-  else if (code == ADDR_EXPR)\n-    {\n-      struct addr_const value;\n-      decode_addr_const (exp, &value);\n-      strp = (char *) &value.offset;\n-      len = sizeof value.offset;\n-      /* Compare the offset.  */\n-      while (--len >= 0)\n-\tif (*p++ != *strp++)\n-\t  return 0;\n-      /* Compare symbol name.  */\n-      strp = XSTR (value.base, 0);\n-      len = strlen (strp) + 1;\n-    }\n-  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n-    {\n-      p = compare_constant_1 (TREE_OPERAND (exp, 0), p);\n-      if (p == 0) return 0;\n-      p = compare_constant_1 (TREE_OPERAND (exp, 1), p);\n-      return p;\n-    }\n-  else if (code == NOP_EXPR || code == CONVERT_EXPR)\n-    {\n+    case ADDR_EXPR:\n+      {\n+\tstruct addr_const value;\n+\n+\tdecode_addr_const (exp, &value);\n+\tstrp = (char *) &value.offset;\n+\tlen = sizeof value.offset;\n+\t/* Compare the offset.  */\n+\twhile (--len >= 0)\n+\t  if (*p++ != *strp++)\n+\t    return 0;\n+\n+\t/* Compare symbol name.  */\n+\tstrp = XSTR (value.base, 0);\n+\tlen = strlen (strp) + 1;\n+      }\n+      break;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n       p = compare_constant_1 (TREE_OPERAND (exp, 0), p);\n-      return p;\n+      if (p == 0)\n+\treturn 0;\n+\n+      return compare_constant_1 (TREE_OPERAND (exp, 1), p);\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return compare_constant_1 (TREE_OPERAND (exp, 0), p);\n     }\n \n   /* Compare constant contents.  */\n@@ -2834,6 +2878,7 @@ copy_constant (exp)\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n       return build1 (TREE_CODE (exp), TREE_TYPE (exp),\n \t\t     copy_constant (TREE_OPERAND (exp, 0)));\n \n@@ -3833,7 +3878,8 @@ bc_assemble_integer (exp, size)\n   \n   exp = fold (exp);\n   \n-  while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR)\n+  while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR\n+\t || TREE_CODE (exp) == NON_LVALUE_EXPR)\n     exp = TREE_OPERAND (exp, 0);\n   if (TREE_CODE (exp) == INTEGER_CST)\n     {\n@@ -3844,11 +3890,13 @@ bc_assemble_integer (exp, size)\n     {\n       const_part = TREE_OPERAND (exp, 0);\n       while (TREE_CODE (const_part) == NOP_EXPR\n-\t     || TREE_CODE (const_part) == CONVERT_EXPR)\n+\t     || TREE_CODE (const_part) == CONVERT_EXPR\n+\t     || TREE_CODE (const_part) == NON_LVALUE_EXPR)\n \tconst_part = TREE_OPERAND (const_part, 0);\n       addr_part = TREE_OPERAND (exp, 1);\n       while (TREE_CODE (addr_part) == NOP_EXPR\n-\t     || TREE_CODE (addr_part) == CONVERT_EXPR)\n+\t     || TREE_CODE (addr_part) == CONVERT_EXPR\n+\t     || TREE_CODE (addr_part) == NON_LVALUE_EXPR)\n \taddr_part = TREE_OPERAND (addr_part, 0);\n       if (TREE_CODE (const_part) != INTEGER_CST)\n \ttmp = const_part, const_part = addr_part, addr_part = tmp;"}]}