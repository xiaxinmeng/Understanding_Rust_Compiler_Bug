{"sha": "8a49a499a558ea71160ccfa5330f6c65af92cf80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE0OWE0OTlhNTU4ZWE3MTE2MGNjZmE1MzMwZjZjNjVhZjkyY2Y4MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T11:07:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T11:07:26Z"}, "message": "[multiple changes]\n\n2012-05-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Expand_With_Clause): In the context of a generic\n\tpackage declaration, a private with-clause on a child unit implies\n\tthat the implicit with clauses on its parents are private as well.\n\n2012-05-15  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch6.adb (Is_Interface_Conformant): Add missing call to\n\tBase_Type to handle subtypes.\n\t* exp_ch6.adb (Expand_Call): For calls located in thunks handle\n\tunchecked conversions of access types found in actuals.\n\t* exp_disp.adb (Expand_Interface_Thunk): Add missing unchecked\n\tconversion to actuals whose type is an access type. Done to\n\tavoid reporting spurious errors.\n\n2012-05-15  Vincent Celier  <celier@adacore.com>\n\n\t* prj-env.adb (Create_Mapping): Ignore sources that are\n\tsuppressed (Create_Mapping_File.Process): Ditto\n\t* prj-nmsc.adb (Add_Source): Update to take into\n\taccount suppressed files that may hide inherited sources.\n\t(Mark_Excluded_Sources): Mark excluded sources of the current\n\tproject as suppressed.\n\t* prj.ads (Source_Data): New Boolean component Suppressed,\n\tdefaulted to False\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_intr.adb: Minor reformatting.\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_rm.texi: Document attribute Scalar_Storage_Order.\n\n2012-05-15  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Build_Offset_To_Top): Modify the\n\texpansion of the offset_to_top functions to ensure that their\n\tprofile is conformant with the profile specified in Ada.Tags. No\n\tchange in functionality.\n\n2012-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb (Subp_Info): Remove Count and Next_Nopred\n\tcomponents, add Processed component and move around Next component.\n\t(Add_Call): Reverse meaning of Successors table to the natural one.\n\t(Add_Inlined_Body): Do not inline a package if it is in the main unit.\n\t(Add_Inlined_Subprogram): Do not add the subprogram to the list if the\n\tpackage is in the main unit. Do not recurse on the successors.\n\t(Add_Subp): Adjust to new contents of Subp_Info.\n\t(Analyze_Inlined_Bodies): Do not attempt\n\tto compute a topological order on the list of inlined subprograms,\n\tbut compute the transitive closure from the main unit instead.\n\t(Get_Code_Unit_Entity): Always return the spec for a package.\n\nFrom-SVN: r187526", "tree": {"sha": "ee46c275077e0468b6aa9a87ff59ebcb6c1876a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee46c275077e0468b6aa9a87ff59ebcb6c1876a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a49a499a558ea71160ccfa5330f6c65af92cf80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a49a499a558ea71160ccfa5330f6c65af92cf80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a49a499a558ea71160ccfa5330f6c65af92cf80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a49a499a558ea71160ccfa5330f6c65af92cf80/comments", "author": null, "committer": null, "parents": [{"sha": "8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c5b2819fa3377dec06665fe8dfded5e3c638bc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c5b2819fa3377dec06665fe8dfded5e3c638bc9"}], "stats": {"total": 418, "additions": 280, "deletions": 138}, "files": [{"sha": "26bf104730091dfc81f9217adce46b10c018dc9a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -1,3 +1,59 @@\n+2012-05-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Expand_With_Clause): In the context of a generic\n+\tpackage declaration, a private with-clause on a child unit implies\n+\tthat the implicit with clauses on its parents are private as well.\n+\n+2012-05-15  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch6.adb (Is_Interface_Conformant): Add missing call to\n+\tBase_Type to handle subtypes.\n+\t* exp_ch6.adb (Expand_Call): For calls located in thunks handle\n+\tunchecked conversions of access types found in actuals.\n+\t* exp_disp.adb (Expand_Interface_Thunk): Add missing unchecked\n+\tconversion to actuals whose type is an access type. Done to\n+\tavoid reporting spurious errors.\n+\n+2012-05-15  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-env.adb (Create_Mapping): Ignore sources that are\n+\tsuppressed (Create_Mapping_File.Process): Ditto\n+\t* prj-nmsc.adb (Add_Source): Update to take into\n+\taccount suppressed files that may hide inherited sources.\n+\t(Mark_Excluded_Sources): Mark excluded sources of the current\n+\tproject as suppressed.\n+\t* prj.ads (Source_Data): New Boolean component Suppressed,\n+\tdefaulted to False\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_intr.adb: Minor reformatting.\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_rm.texi: Document attribute Scalar_Storage_Order.\n+\n+2012-05-15  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Offset_To_Top): Modify the\n+\texpansion of the offset_to_top functions to ensure that their\n+\tprofile is conformant with the profile specified in Ada.Tags. No\n+\tchange in functionality.\n+\n+2012-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* inline.adb (Subp_Info): Remove Count and Next_Nopred\n+\tcomponents, add Processed component and move around Next component.\n+\t(Add_Call): Reverse meaning of Successors table to the natural one.\n+\t(Add_Inlined_Body): Do not inline a package if it is in the main unit.\n+\t(Add_Inlined_Subprogram): Do not add the subprogram to the list if the\n+\tpackage is in the main unit. Do not recurse on the successors.\n+\t(Add_Subp): Adjust to new contents of Subp_Info.\n+\t(Analyze_Inlined_Bodies): Do not attempt\n+\tto compute a topological order on the list of inlined subprograms,\n+\tbut compute the transitive closure from the main unit instead.\n+\t(Get_Code_Unit_Entity): Always return the spec for a package.\n+\n 2012-05-15  Yannick Moy  <moy@adacore.com>\n \n \t* aspects.ads: Minor addition of comments to provide info on"}, {"sha": "ecc5a1c5a45fb914e79308413709a9e368e7a5a1", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -1883,9 +1883,10 @@ package body Exp_Ch3 is\n \n          procedure Build_Offset_To_Top_Function (Iface_Comp : Entity_Id);\n          --  Generate:\n-         --    function Fxx (O : in Rec_Typ) return Storage_Offset is\n+         --    function Fxx (O : Address) return Storage_Offset is\n+         --       type Acc is access all <Typ>;\n          --    begin\n-         --       return O.Iface_Comp'Position;\n+         --       return Acc!(O).Iface_Comp'Position;\n          --    end Fxx;\n \n          ----------------------------------\n@@ -1896,6 +1897,7 @@ package body Exp_Ch3 is\n             Body_Node : Node_Id;\n             Func_Id   : Entity_Id;\n             Spec_Node : Node_Id;\n+            Acc_Type  : Entity_Id;\n \n          begin\n             Func_Id := Make_Temporary (Loc, 'F');\n@@ -1912,7 +1914,7 @@ package body Exp_Ch3 is\n                   Make_Defining_Identifier (Loc, Name_uO),\n                 In_Present          => True,\n                 Parameter_Type      =>\n-                  New_Reference_To (Rec_Type, Loc))));\n+                  New_Reference_To (RTE (RE_Address), Loc))));\n             Set_Result_Definition (Spec_Node,\n               New_Reference_To (RTE (RE_Storage_Offset), Loc));\n \n@@ -1924,7 +1926,19 @@ package body Exp_Ch3 is\n \n             Body_Node := New_Node (N_Subprogram_Body, Loc);\n             Set_Specification (Body_Node, Spec_Node);\n-            Set_Declarations (Body_Node, New_List);\n+\n+            Acc_Type := Make_Temporary (Loc, 'T');\n+            Set_Declarations (Body_Node, New_List (\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Acc_Type,\n+                Type_Definition =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present            => True,\n+                    Null_Exclusion_Present => False,\n+                    Constant_Present       => False,\n+                    Subtype_Indication     =>\n+                      New_Reference_To (Rec_Type, Loc)))));\n+\n             Set_Handled_Statement_Sequence (Body_Node,\n               Make_Handled_Sequence_Of_Statements (Loc,\n                 Statements     => New_List (\n@@ -1933,7 +1947,9 @@ package body Exp_Ch3 is\n                       Make_Attribute_Reference (Loc,\n                         Prefix         =>\n                           Make_Selected_Component (Loc,\n-                            Prefix        => Make_Identifier (Loc, Name_uO),\n+                            Prefix        =>\n+                              Unchecked_Convert_To (Acc_Type,\n+                                 Make_Identifier (Loc, Name_uO)),\n                             Selector_Name =>\n                               New_Reference_To (Iface_Comp, Loc)),\n                         Attribute_Name => Name_Position)))));"}, {"sha": "ab27d231113b6532de8ce08b4fa4a9a5de0a5bd3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -2711,6 +2711,14 @@ package body Exp_Ch6 is\n                         Next_Entity (Parm_Ent);\n                      end loop;\n \n+                  --  Handle unchecked conversion of access types generated\n+                  --  in thunks (cf. Expand_Interface_Thunk)\n+\n+                  elsif Is_Access_Type (Etype (Actual))\n+                    and then Nkind (Actual) = N_Unchecked_Type_Conversion\n+                  then\n+                     Parm_Ent := Entity (Expression (Actual));\n+\n                   else pragma Assert (Is_Entity_Name (Actual));\n                      Parm_Ent := Entity (Actual);\n                   end if;"}, {"sha": "fd175bd02c3f6bcf27ee89d6dca7c88ebe4c3fc6", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -1829,6 +1829,14 @@ package body Exp_Disp is\n                  Make_Explicit_Dereference (Loc,\n                    New_Reference_To (Defining_Identifier (Decl_2), Loc))));\n \n+         --  Ensure proper matching of access types. Required to avoid\n+         --  reporting spurious errors.\n+\n+         elsif Is_Access_Type (Etype (Target_Formal)) then\n+            Append_To (Actuals,\n+              Unchecked_Convert_To (Base_Type (Etype (Target_Formal)),\n+                New_Reference_To (Defining_Identifier (Formal), Loc)));\n+\n          --  No special management required for this actual\n \n          else"}, {"sha": "6617cc0066ddf8d539f4bd65e3e9e1f7e440335f", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -564,16 +564,15 @@ package body Exp_Intr is\n          --  conventions and this has already been checked.\n \n       elsif Present (Alias (E)) then\n-         Expand_Intrinsic_Call (N,  Alias (E));\n+         Expand_Intrinsic_Call (N, Alias (E));\n \n       elsif Nkind (N) in N_Binary_Op then\n          Expand_Binary_Operator_Call (N);\n \n-         --  The only other case is where an external name was specified,\n-         --  since this is the only way that an otherwise unrecognized\n-         --  name could escape the checking in Sem_Prag. Nothing needs\n-         --  to be done in such a case, since we pass such a call to the\n-         --  back end unchanged.\n+         --  The only other case is where an external name was specified, since\n+         --  this is the only way that an otherwise unrecognized name could\n+         --  escape the checking in Sem_Prag. Nothing needs to be done in such\n+         --  a case, since we pass such a call to the back end unchanged.\n \n       else\n          null;"}, {"sha": "db0101f9870d67d6f6740384198dfeeda34a9353", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -272,6 +272,7 @@ Implementation Defined Attributes\n * Result::\n * Safe_Emax::\n * Safe_Large::\n+* Scalar_Storage_Order::\n * Simple_Storage_Pool::\n * Small::\n * Storage_Unit::\n@@ -6023,6 +6024,7 @@ consideration, you should minimize the use of these attributes.\n * Result::\n * Safe_Emax::\n * Safe_Large::\n+* Scalar_Storage_Order::\n * Simple_Storage_Pool::\n * Small::\n * Storage_Unit::\n@@ -6750,6 +6752,54 @@ The @code{Safe_Large} attribute is provided for compatibility with Ada 83.  See\n the Ada 83 reference manual for an exact description of the semantics of\n this attribute.\n \n+@node Scalar_Storage_Order\n+@unnumberedsec Scalar_Storage_Order\n+@cindex Endianness\n+@cindex Scalar storage order\n+@findex Scalar_Storage_Order\n+@noindent\n+For every record subtype @var{S}, the representation attribute\n+@code{Scalar_Storage_Order} denotes the order in which storage elements\n+that make up scalar components are ordered within S. Other properties are\n+as for standard representation attribute @code{Bit_Order}, as defined by\n+Ada RM 13.5.3(4). The default is @code{System.Default_Bit_Order}.\n+\n+If @code{@var{S}'Scalar_Storage_Order} is specified explicitly, it shall be\n+equal to @code{@var{S}'Bit_Order}. Note: This means that if a\n+@code{Scalar_Storage_Order} attribute definition clause is not confirming,\n+then the type's @code{Bit_Order} shall be specified explicitly and set to\n+the same value.\n+\n+A confirming @code{Scalar_Storage_Order} attribute definition clause (i.e.\n+with a value equal to @code{System.Default_Bit_Order}) has no effect.\n+\n+If the opposite storage order is specified, then whenever the\n+value of a scalar component of S is read, the storage elements of the\n+enclosing machine scalar are first reversed (before retrieving the\n+component value, possibly applying some shift and mask operatings on the\n+enclosing machine scalar), and the opposite operation is done for\n+writes.\n+\n+In that case, the restrictions set forth in 10.3/2 for scalar components\n+are relaxed. Instead, the following rules apply:\n+\n+@itemize @bullet\n+@item the underlying storage elements are those at positions\n+  @code{(position + first_bit / storage_element_size) ..\n+        (position + (last_bit + storage_element_size - 1) /\n+                    storage_element_size)}\n+@item the sequence of underlying storage elements shall have\n+        a size no greater than the largest machine scalar\n+@item the enclosing machine scalar is defined as the smallest machine\n+        scalar starting at a position no greater than\n+        @code{position + first_bit / storage_element_size} and covering\n+        storage elements at least up to @code{position + (last_bit +\n+        storage_element_size - 1) / storage_element_size}\n+@item the position of the component is interpreted relative to that machine\n+ scalar.\n+\n+@end itemize\n+\n @node Simple_Storage_Pool\n @unnumberedsec Simple_Storage_Pool\n @cindex Storage pool, simple\n@@ -15452,7 +15502,7 @@ sequences for various UCS input formats.\n @section @code{GNAT.Byte_Swapping} (@file{g-bytswa.ads})\n @cindex @code{GNAT.Byte_Swapping} (@file{g-bytswa.ads})\n @cindex Byte swapping\n-@cindex Endian\n+@cindex Endianness\n \n @noindent\n General routines for swapping the bytes in 2-, 4-, and 8-byte quantities."}, {"sha": "86d2fdf4d2e0554052061490e9633fef72955fb5", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 71, "deletions": 95, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -70,15 +70,12 @@ package body Inline is\n    -----------------------\n \n    --  For each call to an inlined subprogram, we make entries in a table\n-   --  that stores caller and callee, and indicates a prerequisite from\n+   --  that stores caller and callee, and indicates the call direction from\n    --  one to the other. We also record the compilation unit that contains\n    --  the callee. After analyzing the bodies of all such compilation units,\n-   --  we produce a list of subprograms in  topological order, for use by the\n-   --  back-end. If P2 is a prerequisite of P1, then P1 calls P2, and for\n-   --  proper inlining the back-end must analyze the body of P2 before that of\n-   --  P1. The code below guarantees that the transitive closure of inlined\n-   --  subprograms called from the main compilation unit is made available to\n-   --  the code generator.\n+   --  we compute the transitive closure of inlined subprograms called from\n+   --  the main compilation unit and make it available to the code generator\n+   --  in no particular order, thus allowing cycles in the call graph.\n \n    Last_Inlined : Entity_Id := Empty;\n \n@@ -117,12 +114,11 @@ package body Inline is\n \n    type Subp_Info is record\n       Name        : Entity_Id  := Empty;\n+      Next        : Subp_Index := No_Subp;\n       First_Succ  : Succ_Index := No_Succ;\n-      Count       : Integer    := 0;\n       Listed      : Boolean    := False;\n       Main_Call   : Boolean    := False;\n-      Next        : Subp_Index := No_Subp;\n-      Next_Nopred : Subp_Index := No_Subp;\n+      Processed   : Boolean    := False;\n    end record;\n \n    package Inlined is new Table.Table (\n@@ -139,7 +135,8 @@ package body Inline is\n \n    function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id;\n    pragma Inline (Get_Code_Unit_Entity);\n-   --  Return the entity node for the unit containing E\n+   --  Return the entity node for the unit containing E. Always return\n+   --  the spec for a package.\n \n    function Scope_In_Main_Unit (Scop : Entity_Id) return Boolean;\n    --  Return True if Scop is in the main unit or its spec\n@@ -166,9 +163,7 @@ package body Inline is\n    --  example, an initialization procedure).\n \n    procedure Add_Inlined_Subprogram (Index : Subp_Index);\n-   --  Add subprogram to Inlined List once all of its predecessors have been\n-   --  placed on the list. Decrement the count of all its successors, and\n-   --  add them to list (recursively) if count drops to zero.\n+   --  Add the subprogram to the list of inlined subprogram for the unit\n \n    ------------------------------\n    -- Deferred Cleanup Actions --\n@@ -203,29 +198,26 @@ package body Inline is\n       if Present (Caller) then\n          P2 := Add_Subp (Caller);\n \n-         --  Add P2 to the list of successors of P1, if not already there.\n+         --  Add P1 to the list of successors of P2, if not already there.\n          --  Note that P2 may contain more than one call to P1, and only\n          --  one needs to be recorded.\n \n-         J := Inlined.Table (P1).First_Succ;\n+         J := Inlined.Table (P2).First_Succ;\n          while J /= No_Succ loop\n-            if Successors.Table (J).Subp = P2 then\n+            if Successors.Table (J).Subp = P1 then\n                return;\n             end if;\n \n             J := Successors.Table (J).Next;\n          end loop;\n \n-         --  On exit, make a successor entry for P2\n+         --  On exit, make a successor entry for P1\n \n          Successors.Increment_Last;\n-         Successors.Table (Successors.Last).Subp := P2;\n+         Successors.Table (Successors.Last).Subp := P1;\n          Successors.Table (Successors.Last).Next :=\n-                             Inlined.Table (P1).First_Succ;\n-         Inlined.Table (P1).First_Succ := Successors.Last;\n-\n-         Inlined.Table (P2).Count := Inlined.Table (P2).Count + 1;\n-\n+                             Inlined.Table (P2).First_Succ;\n+         Inlined.Table (P2).First_Succ := Successors.Last;\n       else\n          Inlined.Table (P1).Main_Call := True;\n       end if;\n@@ -345,9 +337,11 @@ package body Inline is\n                --  or other internally generated subprogram, because in that\n                --  case the subprogram body appears in the same unit that\n                --  declares the type, and that body is visible to the back end.\n+               --  Do not inline it either if it is in the main unit.\n \n                elsif not Is_Inlined (Pack)\n                  and then Comes_From_Source (E)\n+                 and then not Scope_In_Main_Unit (Pack)\n                then\n                   Set_Is_Inlined (Pack);\n                   Inlined_Bodies.Increment_Last;\n@@ -365,8 +359,6 @@ package body Inline is\n    procedure Add_Inlined_Subprogram (Index : Subp_Index) is\n       E    : constant Entity_Id := Inlined.Table (Index).Name;\n       Pack : constant Entity_Id := Get_Code_Unit_Entity (E);\n-      Succ : Succ_Index;\n-      Subp : Subp_Index;\n \n       function Back_End_Cannot_Inline (Subp : Entity_Id) return Boolean;\n       --  There are various conditions under which back-end inlining cannot\n@@ -441,7 +433,7 @@ package body Inline is\n         and then (Is_Inlined (Pack)\n                     or else Is_Generic_Instance (Pack)\n                     or else Is_Internal (E))\n-        and then not Scope_In_Main_Unit (E)\n+        and then not Scope_In_Main_Unit (Pack)\n         and then not Is_Nested (E)\n         and then not Has_Initialized_Type (E)\n       then\n@@ -460,27 +452,6 @@ package body Inline is\n       end if;\n \n       Inlined.Table (Index).Listed := True;\n-\n-      --  Now add to the list those callers of the current subprogram that\n-      --  are themselves called. They may appear on the graph as callers\n-      --  of the current one, even if they are themselves not called, and\n-      --  there is no point in including them in the list for the backend.\n-      --  Furthermore, they might not even be public, in which case the\n-      --  back-end cannot handle them at all.\n-\n-      Succ := Inlined.Table (Index).First_Succ;\n-      while Succ /= No_Succ loop\n-         Subp := Successors.Table (Succ).Subp;\n-         Inlined.Table (Subp).Count := Inlined.Table (Subp).Count - 1;\n-\n-         if Inlined.Table (Subp).Count = 0\n-           and then Is_Called (Inlined.Table (Subp).Name)\n-         then\n-            Add_Inlined_Subprogram (Subp);\n-         end if;\n-\n-         Succ := Successors.Table (Succ).Next;\n-      end loop;\n    end Add_Inlined_Subprogram;\n \n    ------------------------\n@@ -545,12 +516,11 @@ package body Inline is\n       begin\n          Inlined.Increment_Last;\n          Inlined.Table (Inlined.Last).Name        := E;\n+         Inlined.Table (Inlined.Last).Next        := No_Subp;\n          Inlined.Table (Inlined.Last).First_Succ  := No_Succ;\n-         Inlined.Table (Inlined.Last).Count       := 0;\n          Inlined.Table (Inlined.Last).Listed      := False;\n          Inlined.Table (Inlined.Last).Main_Call   := False;\n-         Inlined.Table (Inlined.Last).Next        := No_Subp;\n-         Inlined.Table (Inlined.Last).Next_Nopred := No_Subp;\n+         Inlined.Table (Inlined.Last).Processed   := False;\n       end New_Entry;\n \n    --  Start of processing for Add_Subp\n@@ -589,8 +559,20 @@ package body Inline is\n       Comp_Unit : Node_Id;\n       J         : Int;\n       Pack      : Entity_Id;\n+      Subp      : Subp_Index;\n       S         : Succ_Index;\n \n+      type Pending_Index is new Nat;\n+\n+      package Pending_Inlined is new Table.Table (\n+         Table_Component_Type => Subp_Index,\n+         Table_Index_Type     => Pending_Index,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => Alloc.Inlined_Initial,\n+         Table_Increment      => Alloc.Inlined_Increment,\n+         Table_Name           => \"Pending_Inlined\");\n+      --  The workpile used to compute the transitive closure\n+\n       function Is_Ancestor_Of_Main\n         (U_Name : Entity_Id;\n          Nam    : Node_Id) return Boolean;\n@@ -757,64 +739,54 @@ package body Inline is\n          --  as part of an inlined package, but are not themselves called. An\n          --  accurate computation of just those subprograms that are needed\n          --  requires that we perform a transitive closure over the call graph,\n-         --  starting from calls in the main program. Here we do one step of\n-         --  the inverse transitive closure, and reset the Is_Called flag on\n-         --  subprograms all of whose callers are not.\n+         --  starting from calls in the main program.\n \n          for Index in Inlined.First .. Inlined.Last loop\n-            S := Inlined.Table (Index).First_Succ;\n+            if not Is_Called (Inlined.Table (Index).Name) then\n+               --  This means that Add_Inlined_Body added the subprogram to the\n+               --  table but wasn't able to handle its code unit. Do nothing.\n \n-            if S /= No_Succ\n-              and then not Inlined.Table (Index).Main_Call\n-            then\n+               null;\n+            elsif Inlined.Table (Index).Main_Call then\n+               Pending_Inlined.Increment_Last;\n+               Pending_Inlined.Table (Pending_Inlined.Last) := Index;\n+               Inlined.Table (Index).Processed := True;\n+            else\n                Set_Is_Called (Inlined.Table (Index).Name, False);\n-\n-               while S /= No_Succ loop\n-                  if Is_Called\n-                    (Inlined.Table (Successors.Table (S).Subp).Name)\n-                   or else Inlined.Table (Successors.Table (S).Subp).Main_Call\n-                  then\n-                     Set_Is_Called (Inlined.Table (Index).Name);\n-                     exit;\n-                  end if;\n-\n-                  S := Successors.Table (S).Next;\n-               end loop;\n             end if;\n          end loop;\n \n-         --  Now that the units are compiled, chain the subprograms within\n-         --  that are called and inlined. Produce list of inlined subprograms\n-         --  sorted in  topological order. Start with all subprograms that\n-         --  have no prerequisites, i.e. inlined subprograms that do not call\n-         --  other inlined subprograms.\n+         --  Iterate over the workpile until it is emptied, propagating the\n+         --  Is_Called flag to the successors of the processed subprogram.\n \n-         for Index in Inlined.First .. Inlined.Last loop\n+         while Pending_Inlined.Last >= Pending_Inlined.First loop\n+            Subp := Pending_Inlined.Table (Pending_Inlined.Last);\n+            Pending_Inlined.Decrement_Last;\n \n-            if Is_Called (Inlined.Table (Index).Name)\n-              and then Inlined.Table (Index).Count = 0\n-              and then not Inlined.Table (Index).Listed\n-            then\n-               Add_Inlined_Subprogram (Index);\n-            end if;\n+            S := Inlined.Table (Subp).First_Succ;\n+\n+            while S /= No_Succ loop\n+               Subp := Successors.Table (S).Subp;\n+               Set_Is_Called (Inlined.Table (Subp).Name);\n+\n+               if not Inlined.Table (Subp).Processed then\n+                  Pending_Inlined.Increment_Last;\n+                  Pending_Inlined.Table (Pending_Inlined.Last) := Subp;\n+                  Inlined.Table (Subp).Processed := True;\n+               end if;\n+\n+               S := Successors.Table (S).Next;\n+            end loop;\n          end loop;\n \n-         --  Because Add_Inlined_Subprogram treats recursively nodes that have\n-         --  no prerequisites left, at the end of the loop all subprograms\n-         --  must have been listed. If there are any unlisted subprograms\n-         --  left, there must be some recursive chains that cannot be inlined.\n+         --  Finally add the called subprograms to the list of inlined\n+         --  subprograms for the unit.\n \n          for Index in Inlined.First .. Inlined.Last loop\n             if Is_Called (Inlined.Table (Index).Name)\n-              and then Inlined.Table (Index).Count /= 0\n-              and then not Is_Predefined_File_Name\n-                (Unit_File_Name\n-                  (Get_Source_Unit (Inlined.Table (Index).Name)))\n+              and then not Inlined.Table (Index).Listed\n             then\n-               Error_Msg_N\n-                 (\"& cannot be inlined?\", Inlined.Table (Index).Name);\n-\n-               --  A warning on the first one might be sufficient ???\n+               Add_Inlined_Subprogram (Index);\n             end if;\n          end loop;\n \n@@ -994,8 +966,12 @@ package body Inline is\n    --------------------------\n \n    function Get_Code_Unit_Entity (E : Entity_Id) return Entity_Id is\n+      Unit : Entity_Id := Cunit_Entity (Get_Code_Unit (E));\n    begin\n-      return Cunit_Entity (Get_Code_Unit (E));\n+      if Ekind (Unit) = E_Package_Body then\n+         Unit := Spec_Entity (Unit);\n+      end if;\n+      return Unit;\n    end Get_Code_Unit_Entity;\n \n    --------------------------"}, {"sha": "ae0fd181590384b0f4d3cc7bbf10f617106adb75", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -754,7 +754,7 @@ package body Prj.Env is\n          exit when Data = No_Source;\n \n          if Data.Unit /= No_Unit_Index then\n-            if Data.Locally_Removed then\n+            if Data.Locally_Removed and then (not Data.Suppressed) then\n                Fmap.Add_Forbidden_File_Name (Data.File);\n             else\n                Fmap.Add_To_File_Map\n@@ -829,7 +829,8 @@ package body Prj.Env is\n             Source := Prj.Element (Iter);\n             exit when Source = No_Source;\n \n-            if Source.Replaced_By = No_Source\n+            if (not Source.Suppressed)\n+              and then Source.Replaced_By = No_Source\n               and then Source.Path.Name /= No_Path\n               and then (Source.Language.Config.Kind = File_Based\n                          or else Source.Unit /= No_Unit_Index)"}, {"sha": "cd62bc9bf44f57d85a7aaaa70103dc8ef4e8d6bb", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -642,32 +642,45 @@ package body Prj.Nmsc is\n \n       Add_Src := True;\n \n-      --  Always add the source if it is locally removed, to avoid incorrect\n-      --  duplicate checks.\n+      if Unit /= No_Name then\n+         Prev_Unit := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n+      end if;\n \n-      if not Locally_Removed then\n-         if Unit /= No_Name then\n-            Prev_Unit := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n-         end if;\n+      if Prev_Unit /= No_Unit_Index\n+        and then (Kind = Impl or else Kind = Spec)\n+        and then Prev_Unit.File_Names (Kind) /= null\n+      then\n+         --  Suspicious, we need to check later whether this is authorized\n \n-         if Prev_Unit /= No_Unit_Index\n-           and then (Kind = Impl or else Kind = Spec)\n-           and then Prev_Unit.File_Names (Kind) /= null\n-         then\n-            --  Suspicious, we need to check later whether this is authorized\n+         Add_Src := False;\n+         Source := Prev_Unit.File_Names (Kind);\n \n+      else\n+         Source := Source_Files_Htable.Get\n+           (Data.Tree.Source_Files_HT, File_Name);\n+\n+         if Source /= No_Source and then Source.Index = Index then\n             Add_Src := False;\n-            Source := Prev_Unit.File_Names (Kind);\n+         end if;\n+      end if;\n \n-         else\n-            Source := Source_Files_Htable.Get\n-              (Data.Tree.Source_Files_HT, File_Name);\n+      --  Always add the source if it is locally removed, to avoid incorrect\n+      --  duplicate checks.\n \n-            if Source /= No_Source and then Source.Index = Index then\n-               Add_Src := False;\n-            end if;\n+      if Locally_Removed then\n+         Add_Src := True;\n+\n+         --  A locally removed source may first replace a source in a project\n+         --  being extended.\n+\n+         if Source /= No_Source\n+           and then Is_Extending (Project, Source.Project)\n+           and then Naming_Exception /= Inherited\n+         then\n+            Source_To_Replace := Source;\n          end if;\n \n+      else\n          --  Duplication of file/unit in same project is allowed if order of\n          --  source directories is known, or if there is no compiler for the\n          --  language.\n@@ -725,14 +738,15 @@ package body Prj.Nmsc is\n \n             elsif Is_Extending (Project, Source.Project) then\n                if not Locally_Removed\n-                  and then Naming_Exception /= Inherited\n+                 and then Naming_Exception /= Inherited\n                then\n                   Source_To_Replace := Source;\n                end if;\n \n             elsif Prev_Unit /= No_Unit_Index\n               and then Prev_Unit.File_Names (Kind) /= null\n               and then not Source.Locally_Removed\n+              and then Source.Replaced_By = No_Source\n               and then not Data.In_Aggregate_Lib\n             then\n                --  Path is set if this is a source we found on the disk, in\n@@ -768,6 +782,7 @@ package body Prj.Nmsc is\n                Add_Src := False;\n \n             elsif not Source.Locally_Removed\n+              and then Source.Replaced_By /= No_Source\n               and then not Data.Flags.Allow_Duplicate_Basenames\n               and then Lang_Id.Config.Kind = Unit_Based\n               and then Source.Language.Config.Kind = Unit_Based\n@@ -785,10 +800,10 @@ package body Prj.Nmsc is\n                Add_Src := True;\n             end if;\n          end if;\n+      end if;\n \n-         if not Add_Src then\n-            return;\n-         end if;\n+      if not Add_Src then\n+         return;\n       end if;\n \n       --  Add the new file\n@@ -868,7 +883,7 @@ package body Prj.Nmsc is\n \n          --  Note that this updates Unit information as well\n \n-         if Naming_Exception /= Inherited then\n+         if Naming_Exception /= Inherited and then not Locally_Removed then\n             Override_Kind (Id, Kind);\n          end if;\n       end if;\n@@ -7799,8 +7814,12 @@ package body Prj.Nmsc is\n                     (Project.Excluded, Source.File);\n \n                   if Excluded /= No_File_Found then\n-                     Source.Locally_Removed := True;\n                      Source.In_Interfaces   := False;\n+                     Source.Locally_Removed := True;\n+\n+                     if Proj = Project.Project then\n+                        Source.Suppressed := True;\n+                     end if;\n \n                      if Current_Verbosity = High then\n                         Debug_Indent;"}, {"sha": "93e06646c4b682bc84097d7c02e88e5244555a06", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -783,8 +783,13 @@ package Prj is\n       Locally_Removed : Boolean := False;\n       --  True if the source has been \"excluded\"\n \n+      Suppressed : Boolean := False;\n+      --  True if the source is a locally removed direct source of the project.\n+      --  These sources should not be put in the mapping file.\n+\n       Replaced_By : Source_Id := No_Source;\n-      --  Missing comment ???\n+      --  Indicate the source in an extending project that replaces the current\n+      --  source.\n \n       File : File_Name_Type := No_File;\n       --  Canonical file name of the source\n@@ -866,6 +871,7 @@ package Prj is\n                        Unit                   => No_Unit_Index,\n                        Index                  => 0,\n                        Locally_Removed        => False,\n+                       Suppressed             => False,\n                        Compilable             => Unknown,\n                        In_The_Queue           => False,\n                        Replaced_By            => No_Source,"}, {"sha": "3334d1da166d1044a5ca27afa1a77bc48f4a206a", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -2987,10 +2987,13 @@ package body Sem_Ch10 is\n       Set_First_Name         (Withn, True);\n       Set_Implicit_With      (Withn, True);\n \n-      --  If the unit is a package declaration, a private_with_clause on a\n-      --  child unit implies the implicit with on the parent is also private.\n+      --  If the unit is a package or generic package  declaration, a private_\n+      --  with_clause on a child unit implies that the implicit with on the\n+      --  parent is also private.\n \n-      if Nkind (Unit (N)) = N_Package_Declaration then\n+      if Nkind_In\n+         (Unit (N), N_Package_Declaration, N_Generic_Package_Declaration)\n+      then\n          Set_Private_Present (Withn, Private_Present (Item));\n       end if;\n "}, {"sha": "2b27ca47745f6c0565ca5317c9b1323521c75359", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a49a499a558ea71160ccfa5330f6c65af92cf80/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8a49a499a558ea71160ccfa5330f6c65af92cf80", "patch": "@@ -8934,7 +8934,7 @@ package body Sem_Ch6 is\n         or else not Is_Dispatching_Operation (Prim)\n         or else Scope (Prim) /= Scope (Tagged_Type)\n         or else No (Typ)\n-        or else Base_Type (Typ) /= Tagged_Type\n+        or else Base_Type (Typ) /= Base_Type (Tagged_Type)\n         or else not Primitive_Names_Match (Iface_Prim, Prim)\n       then\n          return False;"}]}