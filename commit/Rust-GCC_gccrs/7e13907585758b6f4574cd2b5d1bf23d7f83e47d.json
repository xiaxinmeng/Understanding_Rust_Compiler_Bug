{"sha": "7e13907585758b6f4574cd2b5d1bf23d7f83e47d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UxMzkwNzU4NTc1OGI2ZjQ1NzRjZDJiNWQxYmYyM2Q3ZjgzZTQ3ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-07T13:51:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-07T13:51:14Z"}, "message": "(fold, case CONVERT_EXPR): Don't remove an integer conversion when outer is FP unless it doesn't change signedness...\n\n(fold, case CONVERT_EXPR): Don't remove an integer conversion when\nouter is FP unless it doesn't change signedness; rework code in this\narea to be clearer.\n\nFrom-SVN: r8724", "tree": {"sha": "a8ae4518f34ba98a9fac20e975a444b463832558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8ae4518f34ba98a9fac20e975a444b463832558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e13907585758b6f4574cd2b5d1bf23d7f83e47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e13907585758b6f4574cd2b5d1bf23d7f83e47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e13907585758b6f4574cd2b5d1bf23d7f83e47d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e13907585758b6f4574cd2b5d1bf23d7f83e47d/comments", "author": null, "committer": null, "parents": [{"sha": "c47decad97eca23beacfc3a58006b86ef747fe66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47decad97eca23beacfc3a58006b86ef747fe66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47decad97eca23beacfc3a58006b86ef747fe66"}], "stats": {"total": 118, "additions": 64, "deletions": 54}, "files": [{"sha": "6b12c42e24b2de8e12a0dd336d8d24d4a6ef95ce", "filename": "gcc/fold-const.c", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e13907585758b6f4574cd2b5d1bf23d7f83e47d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e13907585758b6f4574cd2b5d1bf23d7f83e47d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7e13907585758b6f4574cd2b5d1bf23d7f83e47d", "patch": "@@ -1,5 +1,5 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 1988, 1992, 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92, 93, 94, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -3358,59 +3358,69 @@ fold (expr)\n       if (TREE_TYPE (TREE_OPERAND (t, 0)) == TREE_TYPE (t))\n \treturn TREE_OPERAND (t, 0);\n \n-      /* In addition to the cases of two conversions in a row \n-\t handled below, if we are converting something to its own\n-\t type via an object of identical or wider precision, neither\n-\t conversion is needed.  */\n-      if ((TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t   || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n-\t  && TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == TREE_TYPE (t)\n-\t  && ((INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t       && INTEGRAL_TYPE_P (TREE_TYPE (t)))\n-\t      || (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t  && FLOAT_TYPE_P (TREE_TYPE (t))))\n-\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t      >= TYPE_PRECISION (TREE_TYPE (t))))\n-\treturn TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-\n-      /* Two conversions in a row are not needed unless:\n-\t - the intermediate type is narrower than both initial and final, or\n-\t - the intermediate type and innermost type differ in signedness,\n-\t   and the outermost type is wider than the intermediate, or\n-\t - the initial type is a pointer type and the precisions of the\n-\t   intermediate and final types differ, or\n-\t - the final type is a pointer type and the precisions of the \n-\t  initial and intermediate types differ.  */\n-      if ((TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t   || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n-\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t      > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t      ||\n-\t      TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t      > TYPE_PRECISION (TREE_TYPE (t)))\n-\t  && ! ((TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t\t == INTEGER_TYPE)\n-\t\t&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t    == INTEGER_TYPE)\n-\t\t&& (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t    != TREE_UNSIGNED (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t\t&& (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t    < TYPE_PRECISION (TREE_TYPE (t))))\n-\t  && ((TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t       && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t   > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))))\n-\t      ==\n-\t      (TREE_UNSIGNED (TREE_TYPE (t))\n-\t       && (TYPE_PRECISION (TREE_TYPE (t))\n-\t\t   > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0))))))\n-\t  && ! ((TREE_CODE (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t\t == POINTER_TYPE)\n-\t\t&& (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t    != TYPE_PRECISION (TREE_TYPE (t))))\n-\t  && ! (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n-\t\t&& (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n-\t\t    != TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0))))))\n-\treturn convert (TREE_TYPE (t), TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+      /* Handle cases of two conversions in a row.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR)\n+\t{\n+\t  tree inside_type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t  tree inter_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t  tree final_type = TREE_TYPE (t);\n+\t  int inside_int = INTEGRAL_TYPE_P (inside_type);\n+\t  int inside_ptr = TREE_CODE (inside_type) == POINTER_TYPE;\n+\t  int inside_float = FLOAT_TYPE_P (inside_type);\n+\t  int inside_prec = TYPE_PRECISION (inside_type);\n+\t  int inside_unsignedp = TREE_UNSIGNED (inside_type);\n+\t  int inter_int = INTEGRAL_TYPE_P (inter_type);\n+\t  int inter_ptr = TREE_CODE (inter_type) == POINTER_TYPE;\n+\t  int inter_float = FLOAT_TYPE_P (inter_type);\n+\t  int inter_prec = TYPE_PRECISION (inter_type);\n+\t  int inter_unsignedp = TREE_UNSIGNED (inter_type);\n+\t  int final_int = INTEGRAL_TYPE_P (final_type);\n+\t  int final_ptr = TREE_CODE (final_type) == POINTER_TYPE;\n+\t  int final_float = FLOAT_TYPE_P (final_type);\n+\t  int final_prec = TYPE_PRECISION (final_type);\n+\t  int final_unsignedp = TREE_UNSIGNED (final_type);\n+\n+\t  /* In addition to the cases of two conversions in a row \n+\t     handled below, if we are converting something to its own\n+\t     type via an object of identical or wider precision, neither\n+\t     conversion is needed.  */\n+\t  if (inside_type == final_type\n+\t      && ((inter_int && final_int) || (inter_float && final_float))\n+\t      && inter_prec >= final_prec)\n+\t    return TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\n+\t  /* Likewise, if the intermediate and final types are either both\n+\t     float or both integer, we don't need the middle conversion if\n+\t     it is wider than the final type and doesn't change the signedness\n+\t     (for integers).  */\n+\t  if ((((inter_int || inter_ptr) && (inside_int || inside_ptr))\n+\t       || (inter_float && inside_float))\n+\t      && inter_prec >= inside_prec\n+\t      && (inter_float || inter_unsignedp == inside_unsignedp))\n+\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\n+\t  /* Two conversions in a row are not needed unless:\n+\t     - some conversion is floating-point (overstrict for now), or\n+\t     - the intermediate type is narrower than both initial and\n+\t       final, or\n+\t     - the intermediate type and innermost type differ in signedness,\n+\t       and the outermost type is wider than the intermediate, or\n+\t     - the initial type is a pointer type and the precisions of the\n+\t       intermediate and final types differ, or\n+\t     - the final type is a pointer type and the precisions of the \n+\t       initial and intermediate types differ.  */\n+\t  if (! inside_float && ! inter_float && ! final_float\n+\t      && (inter_prec > inside_prec || inter_prec > final_prec)\n+\t      && ! (inside_int && inter_int\n+\t\t    && inter_unsignedp != inside_unsignedp\n+\t\t    && inter_prec < final_prec)\n+\t      && ((inter_unsignedp && inter_prec > inside_prec)\n+\t\t  == (final_unsignedp && final_prec > inter_prec))\n+\t      && ! (inside_ptr && inter_prec != final_prec)\n+\t      && ! (final_ptr && inside_prec != inter_prec))\n+\t    return convert (final_type, TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+\t}\n \n       if (TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR\n \t  && TREE_CONSTANT (TREE_OPERAND (TREE_OPERAND (t, 0), 1))"}]}