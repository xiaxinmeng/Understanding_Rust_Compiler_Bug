{"sha": "1934ceca8c3e283f28a36778cd4259f3c90abf48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzNGNlY2E4YzNlMjgzZjI4YTM2Nzc4Y2Q0MjU5ZjNjOTBhYmY0OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-25T21:30:06Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-25T21:30:06Z"}, "message": "(mem_aligned_8): Delete ifdefed out code.\n\n(mem_aligned_8): Delete ifdefed out code.  Add support\nfor TARGET_UNALIGNED_DOUBLES.\n\nFrom-SVN: r4224", "tree": {"sha": "bcf5cba423e6b55a94bd1d6f0bdad5f4b84157c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf5cba423e6b55a94bd1d6f0bdad5f4b84157c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1934ceca8c3e283f28a36778cd4259f3c90abf48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1934ceca8c3e283f28a36778cd4259f3c90abf48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1934ceca8c3e283f28a36778cd4259f3c90abf48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1934ceca8c3e283f28a36778cd4259f3c90abf48/comments", "author": null, "committer": null, "parents": [{"sha": "95dea81f454d14bff6cd13adad4108d7ababdc5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dea81f454d14bff6cd13adad4108d7ababdc5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95dea81f454d14bff6cd13adad4108d7ababdc5e"}], "stats": {"total": 54, "additions": 10, "deletions": 44}, "files": [{"sha": "7574426d6316cf6ffc890207c15a7f1562ba377e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1934ceca8c3e283f28a36778cd4259f3c90abf48/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1934ceca8c3e283f28a36778cd4259f3c90abf48/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1934ceca8c3e283f28a36778cd4259f3c90abf48", "patch": "@@ -999,9 +999,11 @@ mem_aligned_8 (mem)\n \n   addr = XEXP (mem, 0);\n \n-#if 1\n   /* Now that all misaligned double parms are copied on function entry,\n-     we can assume any 64-bit object is 64-bit aligned.  */\n+     we can assume any 64-bit object is 64-bit aligned except those which\n+     are at unaligned offsets from the stack or frame pointer.  If the\n+     TARGET_UNALIGNED_DOUBLES switch is given, we do not make this\n+     assumption.  */\n \n   /* See what register we use in the address.  */\n   base = 0;\n@@ -1029,50 +1031,14 @@ mem_aligned_8 (mem)\n       if ((INTVAL (offset) & 0x7) == 0)\n \treturn 1;\n     }\n-  else\n-    /* Anything else, we know is properly aligned.  */\n-    return 1;\n-#else\n-  /* If the operand is known to have been allocated in static storage, then\n-     it must be aligned.  */\n-\n-  if (CONSTANT_P (addr) || GET_CODE (addr) == LO_SUM)\n+  /* Anything else we know is properly aligned unless TARGET_UNALIGNED_DOUBLES\n+     is true, in which case we can only assume that an access is aligned if\n+     it is to an aggregate, it is to a constant address, or the address\n+     involves a LO_SUM.  */\n+  else if (! TARGET_UNALIGNED_DOUBLES || MEM_IN_STRUCT_P (mem)\n+\t   || CONSTANT_P (addr) || GET_CODE (addr) == LO_SUM)\n     return 1;\n \n-  base = 0;\n-  if (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG\n-          && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-        {\n-          base = XEXP (addr, 0);\n-          offset = XEXP (addr, 1);\n-        }\n-    }\n-  else if (GET_CODE (addr) == REG)\n-    {\n-      base = addr;\n-      offset = const0_rtx;\n-    }\n-\n-  /* Trust round enough offsets from the stack or frame pointer.\n-     If TARGET_HOPE_ALIGN, trust round enough offset from any register.\n-     If it is obviously unaligned, don't ever return true.  */\n-  if (base\n-      && (REGNO (base) == FRAME_POINTER_REGNUM\n-          || REGNO (base) == STACK_POINTER_REGNUM\n-\t  || TARGET_HOPE_ALIGN))\n-    {\n-      if ((INTVAL (offset) & 0x7) == 0)\n-\treturn 1;\n-    }\n-  /* Otherwise, we can assume that an access is aligned if it is to an\n-     aggregate.  Also, if TARGET_HOPE_ALIGN, then assume everything that isn't\n-     obviously unaligned is aligned.  */\n-  else if (MEM_IN_STRUCT_P (mem) || TARGET_HOPE_ALIGN)\n-    return 1;\n-#endif\n-\n   /* An obviously unaligned address.  */\n   return 0;\n }"}]}