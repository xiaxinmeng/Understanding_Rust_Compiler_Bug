{"sha": "74b2e20222cf4fb24b90561ddb6f0989738bb722", "node_id": "C_kwDOANBUbNoAKDc0YjJlMjAyMjJjZjRmYjI0YjkwNTYxZGRiNmYwOTg5NzM4YmI3MjI", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-14T12:16:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-04-14T18:51:49Z"}, "message": "c++: lambda and the current instantiation [PR82980]\n\nWhen a captured variable is type-dependent, we've expressed the type of the\ncapture field and proxy with a decltype variant.  But if the type is \"the\ncurrent instantiation\", we need to be able to see that so that we can do\nlookup inside it just like we could with the captured variable itself.\n\nI also tried looking through lambda capture in\ncp_parser_postfix_dot_deref_expression, but this way seems cleaner.  I plan\nto treat more types as deducible in stage 1.\n\nI considered also using this in do_auto_deduction, but think that would be\nwrong: [temp.dep.expr] says an id-expression is type-dependent if it is\n\"associated by name lookup with a variable declared with a type that\ncontains a placeholder type where the initializer is type-dependent\".  That\ndoesn't clearly exclude deducing a dependent type from the initializer, but\nit seems like a barrier, and other implementations agree.\n\n\tPR c++/82980\n\ngcc/cp/ChangeLog:\n\n\t* lambda.cc (type_deducible_expression_p): New.\n\t(lambda_capture_field_type): Check it.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/lambda/lambda-current-inst1.C: New test.", "tree": {"sha": "4497f32f6a794c993200be3df9b3b86cc504e3a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4497f32f6a794c993200be3df9b3b86cc504e3a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74b2e20222cf4fb24b90561ddb6f0989738bb722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b2e20222cf4fb24b90561ddb6f0989738bb722", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b2e20222cf4fb24b90561ddb6f0989738bb722", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b2e20222cf4fb24b90561ddb6f0989738bb722/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d634c5d7c78c6ec0fa39d96984460475564519c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d634c5d7c78c6ec0fa39d96984460475564519c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d634c5d7c78c6ec0fa39d96984460475564519c8"}], "stats": {"total": 38, "additions": 37, "deletions": 1}, "files": [{"sha": "65579edc316d91e217551edcaaa13ae55add40a1", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b2e20222cf4fb24b90561ddb6f0989738bb722/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b2e20222cf4fb24b90561ddb6f0989738bb722/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=74b2e20222cf4fb24b90561ddb6f0989738bb722", "patch": "@@ -183,6 +183,24 @@ lambda_function (tree lambda)\n   return lambda;\n }\n \n+/* True if EXPR is an expression whose type can be used directly in lambda\n+   capture.  Not to be used for 'auto'.  */\n+\n+static bool\n+type_deducible_expression_p (tree expr)\n+{\n+  if (!type_dependent_expression_p (expr))\n+    return true;\n+  if (BRACE_ENCLOSED_INITIALIZER_P (expr)\n+      || TREE_CODE (expr) == EXPR_PACK_EXPANSION)\n+    return false;\n+  tree t = non_reference (TREE_TYPE (expr));\n+  if (!t) return false;\n+  while (TREE_CODE (t) == POINTER_TYPE)\n+    t = TREE_TYPE (t);\n+  return currently_open_class (t);\n+}\n+\n /* Returns the type to use for the FIELD_DECL corresponding to the\n    capture of EXPR.  EXPLICIT_INIT_P indicates whether this is a\n    C++14 init capture, and BY_REFERENCE_P indicates whether we're\n@@ -211,7 +229,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n       else\n \ttype = do_auto_deduction (type, expr, auto_node);\n     }\n-  else if (type_dependent_expression_p (expr))\n+  else if (!type_deducible_expression_p (expr))\n     {\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;"}, {"sha": "a6631c5ca99c3b306847d12aabcfc248f7a0c3b7", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74b2e20222cf4fb24b90561ddb6f0989738bb722/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-current-inst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74b2e20222cf4fb24b90561ddb6f0989738bb722/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-current-inst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-current-inst1.C?ref=74b2e20222cf4fb24b90561ddb6f0989738bb722", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/82980\n+// { dg-do compile { target c++11 } }\n+\n+template <class T>\n+struct Outer\n+{\n+  template <class U>\n+  void f();\n+\n+  void bar(Outer outer) {\n+    [outer](){ outer.f<int>(); };\n+  }\n+  void baz(Outer *p) {\n+    [&](){ p->f<int>(); };\n+  }\n+};\n+\n+int main() { }"}]}