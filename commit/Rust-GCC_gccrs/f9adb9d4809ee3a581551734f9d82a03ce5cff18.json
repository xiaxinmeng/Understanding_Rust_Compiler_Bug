{"sha": "f9adb9d4809ee3a581551734f9d82a03ce5cff18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlhZGI5ZDQ4MDllZTNhNTgxNTUxNzM0ZjlkODJhMDNjZTVjZmYxOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T15:30:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T15:30:55Z"}, "message": "[multiple changes]\n\n2011-08-02  Vincent Celier  <celier@adacore.com>\n\n\t* link.c: Only import \"auto-host.h\" when building the gnattools.\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* sem_util.adb: Inter-unit inlining does not work for a subprogram\n\twhich calls a local subprogram, so extract subprogram\n\tfrom Mark_Non_ALFA_Subprogram_Body.\n\n2011-08-02  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch9.adb\n\t(Extract_Dispatching_Call): If the type of the dispatching object is an\n\taccess type then return an explicit dereference in the Object out-mode\n\tparameter.\n\n2011-08-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Generate range\n\tcompatibility checks for all indexes of an array subtype, not just the\n\tfirst. Reset Has_Dynamic_Range_Check on the subtype before each\n\tpotential check to ensure that Insert_Range_Checks will not elide any\n\tof the dynamic checks.\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* par-prag.ad (Process_Restrictions_Or_Restriction_Warnings): recognize\n\tSPARK restriction at parsing time.\n\t* scng.adb (Scan): Generate a token Tok_SPARK_Hide for a SPARK HIDE\n\tdirective only if the SPARK restriction is set for this unit.\n\nFrom-SVN: r177183", "tree": {"sha": "dca6bc667fec0d4019625565da962cad56295847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dca6bc667fec0d4019625565da962cad56295847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9adb9d4809ee3a581551734f9d82a03ce5cff18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9adb9d4809ee3a581551734f9d82a03ce5cff18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9adb9d4809ee3a581551734f9d82a03ce5cff18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9adb9d4809ee3a581551734f9d82a03ce5cff18/comments", "author": null, "committer": null, "parents": [{"sha": "83f331504ee98ff8a88d47bb91ea0feafd3f97b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f331504ee98ff8a88d47bb91ea0feafd3f97b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f331504ee98ff8a88d47bb91ea0feafd3f97b2"}], "stats": {"total": 203, "additions": 147, "deletions": 56}, "files": [{"sha": "cabcec110d347d8dbdfab8e9cc555a9a894285a4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -1,3 +1,35 @@\n+2011-08-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* link.c: Only import \"auto-host.h\" when building the gnattools.\n+\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_util.adb: Inter-unit inlining does not work for a subprogram\n+\twhich calls a local subprogram, so extract subprogram\n+\tfrom Mark_Non_ALFA_Subprogram_Body.\n+\n+2011-08-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch9.adb\n+\t(Extract_Dispatching_Call): If the type of the dispatching object is an\n+\taccess type then return an explicit dereference in the Object out-mode\n+\tparameter.\n+\n+2011-08-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Generate range\n+\tcompatibility checks for all indexes of an array subtype, not just the\n+\tfirst. Reset Has_Dynamic_Range_Check on the subtype before each\n+\tpotential check to ensure that Insert_Range_Checks will not elide any\n+\tof the dynamic checks.\n+\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* par-prag.ad (Process_Restrictions_Or_Restriction_Warnings): recognize\n+\tSPARK restriction at parsing time.\n+\t* scng.adb (Scan): Generate a token Tok_SPARK_Hide for a SPARK HIDE\n+\tdirective only if the SPARK restriction is set for this unit.\n+\n 2011-08-02  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch3.adb, sem_ch5.adb, sem_ch9.adb, sem_util.adb, sem_util.ads,"}, {"sha": "ae92522f874c5724d872e7bc6ea9210cede3bcbf", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -341,8 +341,10 @@ package body Exp_Ch9 is\n       Actuals  : out List_Id;\n       Formals  : out List_Id);\n    --  Given a dispatching call, extract the entity of the name of the call,\n-   --  its object parameter, its actual parameters and the formal parameters\n-   --  of the overridden interface-level version.\n+   --  its actual dispatching object, its actual parameters and the formal\n+   --  parameters of the overridden interface-level version. If the type of\n+   --  the dispatching object is an access type then an explicit dereference\n+   --  is returned in Object.\n \n    procedure Extract_Entry\n      (N       : Node_Id;\n@@ -11512,6 +11514,14 @@ package body Exp_Ch9 is\n       if Present (Original_Node (Object)) then\n          Object := Original_Node (Object);\n       end if;\n+\n+      --  If the type of the dispatching object is an access type then return\n+      --  an explicit dereference\n+\n+      if Is_Access_Type (Etype (Object)) then\n+         Object := Make_Explicit_Dereference (Sloc (N), Object);\n+         Analyze (Object);\n+      end if;\n    end Extract_Dispatching_Call;\n \n    -------------------"}, {"sha": "b8fd835c2d8e509e581ee65963ddd60b38ac0ed5", "filename": "gcc/ada/link.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -37,7 +37,10 @@ extern \"C\" {\n #endif\n \n #include <string.h>\n+\n+#ifdef IN_GCC\n #include \"auto-host.h\"\n+#endif\n \n /*  objlist_file_supported is set to 1 when the system linker allows        */\n /*  response file, that is a file that contains the list of object files.   */"}, {"sha": "6b5318f338530c5c16bc5fd086a99684a7118fcc", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -89,11 +89,13 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n \n    procedure Process_Restrictions_Or_Restriction_Warnings;\n    --  Common processing for Restrictions and Restriction_Warnings pragmas.\n-   --  This routine only processes the case of No_Obsolescent_Features, which\n-   --  is the only restriction that has syntactic effects. No general error\n-   --  checking is done, since this will be done in Sem_Prag. The other case\n-   --  processed is pragma Restrictions No_Dependence, since otherwise this is\n-   --  done too late.\n+   --  This routine processes the cases of No_Obsolescent_Features and SPARK,\n+   --  which are the only restriction that have syntactic effects. In the case\n+   --  of SPARK, it controls whether the scanner generates a token\n+   --  Tok_SPARK_Hide for HIDE directives formatted as Ada comments. No general\n+   --  error checking is done, since this will be done in Sem_Prag. The other\n+   --  case processed is pragma Restrictions No_Dependence, since otherwise\n+   --  this is done too late.\n \n    ----------\n    -- Arg1 --\n@@ -230,6 +232,10 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n                   Set_Restriction (No_Obsolescent_Features, Pragma_Node);\n                   Restriction_Warnings (No_Obsolescent_Features) :=\n                     Prag_Id = Pragma_Restriction_Warnings;\n+               when SPARK =>\n+                  Set_Restriction (SPARK, Pragma_Node);\n+                  Restriction_Warnings (SPARK) :=\n+                    Prag_Id = Pragma_Restriction_Warnings;\n                when others =>\n                   null;\n             end case;"}, {"sha": "73b8f393dca7eba89070ae919ab5905f240a5381", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -28,6 +28,8 @@ with Err_Vars; use Err_Vars;\n with Hostparm; use Hostparm;\n with Namet;    use Namet;\n with Opt;      use Opt;\n+with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Scans;    use Scans;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -1762,7 +1764,12 @@ package body Scng is\n                   return;\n                end if;\n \n-               if Source (Start_Of_Comment) = '#' then\n+               --  Generate a token Tok_SPARK_Hide for a SPARK HIDE directive\n+               --  only if the SPARK restriction is set for this unit.\n+\n+               if Restriction_Check_Required (SPARK)\n+                 and then Source (Start_Of_Comment) = '#'\n+               then\n                   declare\n                      Scan_SPARK_Ptr : Source_Ptr;\n "}, {"sha": "2f5bb0244c8f2bc2c725d7a7a59846971166e714", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -4396,9 +4396,9 @@ package body Sem_Ch3 is\n          Conditional_Delay (Id, T);\n       end if;\n \n-      --  Check that constraint_error is raised for a scalar subtype\n-      --  indication when the lower or upper bound of a non-null range\n-      --  lies outside the range of the type mark.\n+      --  Check that Constraint_Error is raised for a scalar subtype indication\n+      --  when the lower or upper bound of a non-null range lies outside the\n+      --  range of the type mark.\n \n       if Nkind (Subtype_Indication (N)) = N_Subtype_Indication then\n          if Is_Scalar_Type (Etype (Id))\n@@ -4410,38 +4410,69 @@ package body Sem_Ch3 is\n               (Scalar_Range (Id),\n                Etype (Subtype_Mark (Subtype_Indication (N))));\n \n+         --  In the array case, check compatibility for each index\n+\n          elsif Is_Array_Type (Etype (Id))\n            and then Present (First_Index (Id))\n          then\n             --  This really should be a subprogram that finds the indications\n             --  to check???\n \n-            if ((Nkind (First_Index (Id)) = N_Identifier\n-                   and then Ekind (Entity (First_Index (Id))) in Scalar_Kind)\n-                 or else Nkind (First_Index (Id)) = N_Subtype_Indication)\n-              and then\n-                Nkind (Scalar_Range (Etype (First_Index (Id)))) = N_Range\n-            then\n-               declare\n-                  Target_Typ : constant Entity_Id :=\n-                                 Etype\n-                                   (First_Index (Etype\n-                                     (Subtype_Mark (Subtype_Indication (N)))));\n-               begin\n-                  R_Checks :=\n-                    Get_Range_Checks\n-                      (Scalar_Range (Etype (First_Index (Id))),\n-                       Target_Typ,\n-                       Etype (First_Index (Id)),\n-                       Defining_Identifier (N));\n-\n-                  Insert_Range_Checks\n-                    (R_Checks,\n-                     N,\n-                     Target_Typ,\n-                     Sloc (Defining_Identifier (N)));\n-               end;\n-            end if;\n+            declare\n+               Subt_Index   : Node_Id := First_Index (Id);\n+               Target_Index : Node_Id :=\n+                                First_Index (Etype\n+                                  (Subtype_Mark (Subtype_Indication (N))));\n+               Has_Dyn_Chk  : Boolean := Has_Dynamic_Range_Check (N);\n+\n+            begin\n+               while Present (Subt_Index) loop\n+                  if ((Nkind (Subt_Index) = N_Identifier\n+                         and then Ekind (Entity (Subt_Index)) in Scalar_Kind)\n+                       or else Nkind (Subt_Index) = N_Subtype_Indication)\n+                    and then\n+                      Nkind (Scalar_Range (Etype (Subt_Index))) = N_Range\n+                  then\n+                     declare\n+                        Target_Typ : constant Entity_Id :=\n+                                       Etype (Target_Index);\n+                     begin\n+                        R_Checks :=\n+                          Get_Range_Checks\n+                            (Scalar_Range (Etype (Subt_Index)),\n+                             Target_Typ,\n+                             Etype (Subt_Index),\n+                             Defining_Identifier (N));\n+\n+                        --  Reset Has_Dynamic_Range_Check on the subtype to\n+                        --  prevent elision of the index check due to a dynamic\n+                        --  check generated for a preceding index (needed since\n+                        --  Insert_Range_Checks tries to avoid generating\n+                        --  redundant checks on a given declaration).\n+\n+                        Set_Has_Dynamic_Range_Check (N, False);\n+\n+                        Insert_Range_Checks\n+                          (R_Checks,\n+                           N,\n+                           Target_Typ,\n+                           Sloc (Defining_Identifier (N)));\n+\n+                        --  Record whether this index involved a dynamic check\n+\n+                        Has_Dyn_Chk :=\n+                          Has_Dyn_Chk or else Has_Dynamic_Range_Check (N);\n+                     end;\n+                  end if;\n+\n+                  Next_Index (Subt_Index);\n+                  Next_Index (Target_Index);\n+               end loop;\n+\n+               --  Finally, mark whether the subtype involves dynamic checks\n+\n+               Set_Has_Dynamic_Range_Check (N, Has_Dyn_Chk);\n+            end;\n          end if;\n       end if;\n "}, {"sha": "397784676ded77b33d0f2ac492c66c90e907f368", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adb9d4809ee3a581551734f9d82a03ce5cff18/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f9adb9d4809ee3a581551734f9d82a03ce5cff18", "patch": "@@ -141,6 +141,10 @@ package body Sem_Util is\n    --  T is a derived tagged type. Check whether the type extension is null.\n    --  If the parent type is fully initialized, T can be treated as such.\n \n+   procedure Mark_Non_ALFA_Subprogram_Body_Unconditional;\n+   --  Perform the action for Mark_Non_ALFA_Subprogram_Body, which allows the\n+   --  latter to be small and inlined.\n+\n    ------------------------------\n    --  Abstract_Interface_List --\n    ------------------------------\n@@ -2316,31 +2320,29 @@ package body Sem_Util is\n    -----------------------------------\n \n    procedure Mark_Non_ALFA_Subprogram_Body is\n-\n-      procedure Unconditional_Mark;\n+   begin\n       --  Isolate marking of the current subprogram body so that the body of\n       --  Mark_Non_ALFA_Subprogram_Body is small and inlined.\n \n-      ------------------------\n-      -- Unconditional_Mark --\n-      ------------------------\n+      if ALFA_Mode then\n+         Mark_Non_ALFA_Subprogram_Body_Unconditional;\n+      end if;\n+   end Mark_Non_ALFA_Subprogram_Body;\n \n-      procedure Unconditional_Mark is\n-         Cur_Subp : constant Entity_Id := Current_Subprogram;\n-      begin\n-         if Present (Cur_Subp)\n-           and then (Is_Subprogram (Cur_Subp)\n-                      or else Is_Generic_Subprogram (Cur_Subp))\n-         then\n-            Set_Body_Is_In_ALFA (Cur_Subp, False);\n-         end if;\n-      end Unconditional_Mark;\n+   -------------------------------------------------\n+   -- Mark_Non_ALFA_Subprogram_Body_Unconditional --\n+   -------------------------------------------------\n \n+   procedure Mark_Non_ALFA_Subprogram_Body_Unconditional is\n+      Cur_Subp : constant Entity_Id := Current_Subprogram;\n    begin\n-      if ALFA_Mode then\n-         Unconditional_Mark;\n+      if Present (Cur_Subp)\n+        and then (Is_Subprogram (Cur_Subp)\n+                   or else Is_Generic_Subprogram (Cur_Subp))\n+      then\n+         Set_Body_Is_In_ALFA (Cur_Subp, False);\n       end if;\n-   end Mark_Non_ALFA_Subprogram_Body;\n+   end Mark_Non_ALFA_Subprogram_Body_Unconditional;\n \n    ---------------------\n    -- Defining_Entity --"}]}