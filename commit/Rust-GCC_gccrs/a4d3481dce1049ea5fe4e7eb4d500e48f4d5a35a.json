{"sha": "a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkMzQ4MWRjZTEwNDllYTVmZTRlN2ViNGQ1MDBlNDhmNGQ1YTM1YQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-03-15T05:30:02Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-03-15T05:30:02Z"}, "message": "fold-const.c (exact_real_inverse): Move variable `float_error' into the scope where it is used.\n\n        * fold-const.c (exact_real_inverse): Move variable `float_error'\n        into the scope where it is used.\n        (const_binop_1): New static function.\n        (cb_args): New struct.\n        (const_binop): Use them in call to `do_float_handler'.\n        (fold_convert_1): New static function.\n        (fc_args): New struct.\n        (fold_convert): Use them in call to `do_float_handler'.\n\nFrom-SVN: r25776", "tree": {"sha": "769704963dfcad27564126b092997d8ad32082bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/769704963dfcad27564126b092997d8ad32082bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a/comments", "author": null, "committer": null, "parents": [{"sha": "c83857f92f5ea4efd54b6d75de003bbefa7a2aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83857f92f5ea4efd54b6d75de003bbefa7a2aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83857f92f5ea4efd54b6d75de003bbefa7a2aa6"}], "stats": {"total": 182, "additions": 123, "deletions": 59}, "files": [{"sha": "88e3bd261713749dd5ab08c06dbe96b5e5de9ab5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "patch": "@@ -1,3 +1,14 @@\n+Mon Mar 15 08:24:17 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+        * fold-const.c (exact_real_inverse): Move variable `float_error'\n+\tinto the scope where it is used.\n+\t(const_binop_1): New static function.\n+\t(cb_args): New struct.\n+\t(const_binop): Use them in call to `do_float_handler'.\n+\t(fold_convert_1): New static function.\n+\t(fc_args): New struct.\n+\t(fold_convert): Use them in call to `do_float_handler'.\n+\n Mon Mar 15 22:50:18 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* rtlanal.c (auto_inc_p): New function."}, {"sha": "492f1b80ee4af60f5284e38ebe17af137f3fa2a7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 112, "deletions": 59, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a4d3481dce1049ea5fe4e7eb4d500e48f4d5a35a", "patch": "@@ -50,9 +50,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"toplev.h\"\n \n-/* Handle floating overflow for `const_binop'.  */\n-static jmp_buf float_error;\n-\n static void encode\t\tPROTO((HOST_WIDE_INT *,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n static void decode\t\tPROTO((HOST_WIDE_INT *,\n@@ -97,6 +94,8 @@ static tree strip_compound_expr PROTO((tree, tree));\n static int multiple_of_p\tPROTO((tree, tree, tree));\n static tree constant_boolean_node PROTO((int, tree));\n static int count_cond\t\tPROTO((tree, int));\n+static void const_binop_1\tPROTO((PTR));\n+static void fold_convert_1\tPROTO((PTR));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n@@ -886,6 +885,7 @@ exact_real_inverse (mode, r)\n      enum machine_mode mode;\n      REAL_VALUE_TYPE *r;\n {\n+  jmp_buf float_error;\n   union\n     {\n       double d;\n@@ -1478,6 +1478,67 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n   return t;\n }\n \n+struct cb_args\n+{\n+  /* Input */\n+  tree arg1;\n+  REAL_VALUE_TYPE d1, d2;\n+  enum tree_code code;\n+  /* Output */\n+  tree t;\n+};\n+\n+static void\n+const_binop_1 (data)\n+  PTR data;\n+{\n+  struct cb_args * args = (struct cb_args *) data;\n+  REAL_VALUE_TYPE value;\n+\n+#ifdef REAL_ARITHMETIC\n+  REAL_ARITHMETIC (value, args->code, args->d1, args->d2);\n+#else\n+  switch (args->code)\n+    {\n+    case PLUS_EXPR:\n+      value = args->d1 + args->d2;\n+      break;\n+      \n+    case MINUS_EXPR:\n+      value = args->d1 - args->d2;\n+      break;\n+      \n+    case MULT_EXPR:\n+      value = args->d1 * args->d2;\n+      break;\n+      \n+    case RDIV_EXPR:\n+#ifndef REAL_INFINITY\n+      if (args->d2 == 0)\n+\tabort ();\n+#endif\n+      \n+      value = args->d1 / args->d2;\n+      break;\n+      \n+    case MIN_EXPR:\n+      value = MIN (args->d1, args->d2);\n+      break;\n+      \n+    case MAX_EXPR:\n+      value = MAX (args->d1, args->d2);\n+      break;\n+      \n+    default:\n+      abort ();\n+    }\n+#endif /* no REAL_ARITHMETIC */\n+  args->t =\n+    build_real (TREE_TYPE (args->arg1),\n+\t\treal_value_truncate (TYPE_MODE (TREE_TYPE (args->arg1)),\n+\t\t\t\t     value));\n+}\n+\n /* Combine two constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.\n    We assume ARG1 and ARG2 have the same data type,\n@@ -1502,8 +1563,8 @@ const_binop (code, arg1, arg2, notrunc)\n       REAL_VALUE_TYPE d1;\n       REAL_VALUE_TYPE d2;\n       int overflow = 0;\n-      REAL_VALUE_TYPE value;\n       tree t;\n+      struct cb_args args;\n \n       d1 = TREE_REAL_CST (arg1);\n       d2 = TREE_REAL_CST (arg2);\n@@ -1514,57 +1575,24 @@ const_binop (code, arg1, arg2, notrunc)\n \treturn arg1;\n       else if (REAL_VALUE_ISNAN (d2))\n \treturn arg2;\n-      else if (setjmp (float_error))\n+\n+      /* Setup input for const_binop_1() */\n+      args.arg1 = arg1;\n+      args.d1 = d1;\n+      args.d2 = d2;\n+      args.code = code;\n+      \n+      if (do_float_handler (const_binop_1, (PTR) &args))\n \t{\n-\t  t = copy_node (arg1);\n-\t  overflow = 1;\n-\t  goto got_float;\n+\t  /* Receive output from const_binop_1() */\n+\t  t = args.t;\n \t}\n-\n-      set_float_handler (float_error);\n-\n-#ifdef REAL_ARITHMETIC\n-      REAL_ARITHMETIC (value, code, d1, d2);\n-#else\n-      switch (code)\n+      else\n \t{\n-\tcase PLUS_EXPR:\n-\t  value = d1 + d2;\n-\t  break;\n-\n-\tcase MINUS_EXPR:\n-\t  value = d1 - d2;\n-\t  break;\n-\n-\tcase MULT_EXPR:\n-\t  value = d1 * d2;\n-\t  break;\n-\n-\tcase RDIV_EXPR:\n-#ifndef REAL_INFINITY\n-\t  if (d2 == 0)\n-\t    abort ();\n-#endif\n-\n-\t  value = d1 / d2;\n-\t  break;\n-\n-\tcase MIN_EXPR:\n-\t  value = MIN (d1, d2);\n-\t  break;\n-\n-\tcase MAX_EXPR:\n-\t  value = MAX (d1, d2);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n+\t  /* We got an exception from const_binop_1() */\n+\t  t = copy_node (arg1);\n+\t  overflow = 1;\n \t}\n-#endif /* no REAL_ARITHMETIC */\n-      t = build_real (TREE_TYPE (arg1),\n-\t\t      real_value_truncate (TYPE_MODE (TREE_TYPE (arg1)), value));\n-    got_float:\n-      set_float_handler (NULL_PTR);\n \n       TREE_OVERFLOW (t)\n \t= (force_fit_type (t, overflow)\n@@ -1755,6 +1783,25 @@ ssize_binop (code, arg0, arg1)\n   return fold (build (code, ssizetype, arg0, arg1));\n }\n \f\n+struct fc_args\n+{\n+  /* Input */\n+  tree arg1, type;\n+  /* Output */\n+  tree t;\n+};\n+\n+static void\n+fold_convert_1 (data)\n+  PTR data;\n+{\n+  struct fc_args * args = (struct fc_args *) data;\n+\n+  args->t = build_real (args->type,\n+\t\t\treal_value_truncate (TYPE_MODE (args->type),\n+\t\t\t\t\t     TREE_REAL_CST (args->arg1)));\n+}\n+\n /* Given T, a tree representing type conversion of ARG1, a constant,\n    return a constant tree representing the result of conversion.  */\n \n@@ -1880,25 +1927,31 @@ fold_convert (t, arg1)\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n+\t  struct fc_args args;\n+\t  \n \t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n \t    {\n \t      t = arg1;\n \t      TREE_TYPE (arg1) = type;\n \t      return t;\n \t    }\n-\t  else if (setjmp (float_error))\n+\n+\t  /* Setup input for fold_convert_1() */\n+\t  args.arg1 = arg1;\n+\t  args.type = type;\n+\t  \n+\t  if (do_float_handler (fold_convert_1, (PTR) &args))\n+\t    {\n+\t      /* Receive output from fold_convert_1() */\n+\t      t = args.t;\n+\t    }\n+\t  else\n \t    {\n+\t      /* We got an exception from fold_convert_1() */\n \t      overflow = 1;\n \t      t = copy_node (arg1);\n-\t      goto got_it;\n \t    }\n-\t  set_float_handler (float_error);\n-\n-\t  t = build_real (type, real_value_truncate (TYPE_MODE (type),\n-\t\t\t\t\t\t     TREE_REAL_CST (arg1)));\n-\t  set_float_handler (NULL_PTR);\n \n-\tgot_it:\n \t  TREE_OVERFLOW (t)\n \t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n \t  TREE_CONSTANT_OVERFLOW (t)"}]}