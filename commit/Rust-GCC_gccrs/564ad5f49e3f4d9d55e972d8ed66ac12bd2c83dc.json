{"sha": "564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY0YWQ1ZjQ5ZTNmNGQ5ZDU1ZTk3MmQ4ZWQ2NmFjMTJiZDJjODNkYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-02-10T00:26:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-02-10T00:26:47Z"}, "message": "cpphash.c (macarg): Hoist all the flag diddling out of the function...\n\n\t* cpphash.c (macarg): Hoist all the flag diddling out of the\n\tfunction...\n\t(macroexpand): ... and out of the loop that calls macarg.\n\tSkip over the initial paren before macro arguments with\n\tcpp_get_non_space_token; point may be some distance before\n\tthat paren.  Abort if it's not there.\n\n\t* cpplib.c (parse_clear_mark): Delete function.\n\t(parse_set_mark, parse_goto_mark): Make static.\n\t(ACTIVE_MARK_P): New macro.\n\t(skip_block_comment, skip_line_comment): Do not bump the line\n\tif ACTIVE_MARK_P is true.\n\t(cpp_pop_buffer): The buffer to be popped may not have an\n\tactive mark.\n\t(cpp_get_token): When looking for the initial paren before\n\tmacro arguments, only set a mark in a file buffer, Always\n\treturn to that mark before proceeding to call macroexpand or\n\treturn a NAME token.\n\n\t* cpplib.h: Remove prototypes of parse_set_mark,\n\tparse_clear_mark, parse_goto_mark.\n\t(struct cpp_options): Rename 'put_out_comments' to\n\t'discard_comments' and invert its sense.\n\t* cppinit.c, cpphash.c, cpplib.c: All users of\n\tput_out_comments changed to use discard_comments, with\n\topposite sense.\n\nFrom-SVN: r31879", "tree": {"sha": "b97b41fd2091f08d292e94d18de3493399ff1087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b97b41fd2091f08d292e94d18de3493399ff1087"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/comments", "author": null, "committer": null, "parents": [{"sha": "3a75e42e813997b8144619d6031b729690639922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a75e42e813997b8144619d6031b729690639922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a75e42e813997b8144619d6031b729690639922"}], "stats": {"total": 266, "additions": 172, "deletions": 94}, "files": [{"sha": "3e6a9a544fbc55fa56becc4dee2e86b022a2de89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -1,3 +1,32 @@\n+2000-02-09  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c (macarg): Hoist all the flag diddling out of the\n+\tfunction...\n+\t(macroexpand): ... and out of the loop that calls macarg.\n+\tSkip over the initial paren before macro arguments with\n+\tcpp_get_non_space_token; point may be some distance before\n+\tthat paren.  Abort if it's not there.\n+\n+\t* cpplib.c (parse_clear_mark): Delete function.\n+\t(parse_set_mark, parse_goto_mark): Make static.\n+\t(ACTIVE_MARK_P): New macro.\n+\t(skip_block_comment, skip_line_comment): Do not bump the line\n+\tif ACTIVE_MARK_P is true.\n+\t(cpp_pop_buffer): The buffer to be popped may not have an\n+\tactive mark.\n+\t(cpp_get_token): When looking for the initial paren before\n+\tmacro arguments, only set a mark in a file buffer, Always\n+\treturn to that mark before proceeding to call macroexpand or\n+\treturn a NAME token.\n+\n+\t* cpplib.h: Remove prototypes of parse_set_mark,\n+\tparse_clear_mark, parse_goto_mark.\n+\t(struct cpp_options): Rename 'put_out_comments' to\n+\t'discard_comments' and invert its sense.\n+\t* cppinit.c, cpphash.c, cpplib.c: All users of\n+\tput_out_comments changed to use discard_comments, with\n+\topposite sense.\n+\n 2000-02-09  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* function.c (thread_prologue_and_epilogue_insns): Don't delete"}, {"sha": "8a178f3e6709fa1353294e949bea3ceb12614d0e", "filename": "gcc/cpphash.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -773,27 +773,22 @@ macarg (pfile, rest_args)\n {\n   int paren = 0;\n   enum cpp_token token;\n-  char save_put_out_comments = CPP_OPTIONS (pfile)->put_out_comments;\n-  CPP_OPTIONS (pfile)->put_out_comments = 0;\n \n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n-  pfile->no_macro_expand++;\n-  pfile->no_directives++;\n-  CPP_OPTIONS (pfile)->no_line_commands++;\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n       switch (token)\n \t{\n \tcase CPP_EOF:\n-\t  goto done;\n+\t  return token;\n \tcase CPP_POP:\n \t  /* If we've hit end of file, it's an error (reported by caller).\n \t     Ditto if it's the end of cpp_expand_to_buffer text.\n \t     If we've hit end of macro, just continue.  */\n \t  if (!CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t    goto done;\n+\t    return token;\n \t  break;\n \tcase CPP_LPAREN:\n \t  paren++;\n@@ -811,18 +806,10 @@ macarg (pfile, rest_args)\n \tfound:\n \t  /* Remove ',' or ')' from argument buffer.  */\n \t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t  goto done;\n+\t  return token;\n \tdefault:;\n \t}\n     }\n-\n-done:\n-  CPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n-  CPP_OPTIONS (pfile)->no_line_commands--;\n-  pfile->no_macro_expand--;\n-  pfile->no_directives--;\n-\n-  return token;\n }\n \f\n \n@@ -1023,7 +1010,7 @@ macroexpand (pfile, hp)\n \n   if (nargs >= 0)\n     {\n-      enum cpp_token token = CPP_EOF;\n+      enum cpp_token token;\n \n       args = (struct argdata *) alloca ((nargs + 1) * sizeof (struct argdata));\n \n@@ -1040,8 +1027,20 @@ macroexpand (pfile, hp)\n          macarg absorbed the rest of the args.  */\n       i = 0;\n       rest_args = 0;\n-      rest_args = 0;\n-      FORWARD (1);\t/* Discard open-parenthesis before first arg.  */\n+\n+      /* Skip over the opening parenthesis.  */\n+      CPP_OPTIONS (pfile)->discard_comments++;\n+      CPP_OPTIONS (pfile)->no_line_commands++;\n+      pfile->no_macro_expand++;\n+      pfile->no_directives++;\n+\n+      token = cpp_get_non_space_token (pfile);\n+      if (token != CPP_LPAREN)\n+\tcpp_ice (pfile, \"macroexpand: unexpected token %d (wanted LPAREN)\",\n+\t\t token);\n+      CPP_ADJUST_WRITTEN (pfile, -1);\n+\n+      token = CPP_EOF;\n       do\n \t{\n \t  if (rest_args)\n@@ -1058,14 +1057,17 @@ macroexpand (pfile, hp)\n \t  else\n \t    token = macarg (pfile, 0);\n \t  if (token == CPP_EOF || token == CPP_POP)\n-\t    {\n-\t      cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t\t   \"unterminated macro call\");\n-\t      return;\n-\t    }\n+\t    cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t\t \"unterminated macro call\");\n \t  i++;\n \t}\n       while (token == CPP_COMMA);\n+      CPP_OPTIONS (pfile)->discard_comments--;\n+      CPP_OPTIONS (pfile)->no_line_commands--;\n+      pfile->no_macro_expand--;\n+      pfile->no_directives--;\n+      if (token != CPP_RPAREN)\n+\treturn;\n \n       /* If we got one arg but it was just whitespace, call that 0 args.  */\n       if (i == 1)"}, {"sha": "fa67ee282cf4d3e213d68d81c4cd43a800cb8d1f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -408,6 +408,7 @@ cpp_options_init (opts)\n   opts->dollars_in_ident = 1;\n   opts->cplusplus_comments = 1;\n   opts->warn_import = 1;\n+  opts->discard_comments = 1;\n \n   opts->pending =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n@@ -1600,7 +1601,7 @@ cpp_handle_option (pfile, argc, argv)\n \tbreak;\n       \n       case 'C':\n-\topts->put_out_comments = 1;\n+\topts->discard_comments = 0;\n \tbreak;\n       \n       case 'E':\t\t\t/* -E comes from cc -E; ignore it.  */"}, {"sha": "7abb331e08b31da1eedd08877d760685db529bbf", "filename": "gcc/cpplib.c", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -35,6 +35,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    (Note that it is false while we're expanding macro *arguments*.) */\n #define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n \n+/* ACTIVE_MARK_P is true if there's a live mark in the buffer, in which\n+   case CPP_BUMP_LINE must not be called.  */\n+#define ACTIVE_MARK_P() (CPP_BUFFER (pfile)->mark != -1)\n+\n /* External declarations.  */\n \n extern HOST_WIDEST_INT cpp_parse_expr PARAMS ((cpp_reader *));\n@@ -100,6 +104,8 @@ static int consider_directive_while_skipping PARAMS ((cpp_reader *,\n \t\t\t\t\t\t      IF_STACK_FRAME *));\n static void skip_block_comment\t\tPARAMS ((cpp_reader *));\n static void skip_line_comment\t\tPARAMS ((cpp_reader *));\n+static void parse_set_mark\t\tPARAMS ((cpp_reader *));\n+static void parse_goto_mark\t\tPARAMS ((cpp_reader *));\n \n /* Here is the actual list of #-directives.\n    This table is ordered by frequency of occurrence; the numbers\n@@ -282,8 +288,11 @@ skip_block_comment (pfile)\n \t  return;\n \t}\n       else if (c == '\\n' || c == '\\r')\n-\t/* \\r cannot be a macro escape marker here. */\n-\tCPP_BUMP_LINE (pfile);\n+\t{\n+\t  /* \\r cannot be a macro escape marker here. */\n+\t  if (!ACTIVE_MARK_P())\n+\t    CPP_BUMP_LINE (pfile);\n+\t}\n       else if (c == '/' && prev_c == '*')\n \treturn;\n       else if (c == '*' && prev_c == '/'\n@@ -315,7 +324,8 @@ skip_line_comment (pfile)\n       else if (c == '\\r')\n \t{\n \t  /* \\r cannot be a macro escape marker here. */\n-\t  CPP_BUMP_LINE (pfile);\n+\t  if (!ACTIVE_MARK_P())\n+\t    CPP_BUMP_LINE (pfile);\n \t  if (CPP_OPTIONS (pfile)->warn_comments)\n \t    cpp_warning (pfile, \"backslash-newline within line comment\");\n \t}\n@@ -376,7 +386,7 @@ skip_comment (pfile, m)\n }\n \n /* Identical to skip_comment except that it copies the comment into the\n-   token_buffer.  This is used if put_out_comments.  */\n+   token_buffer.  This is used if !discard_comments.  */\n static int\n copy_comment (pfile, m)\n      cpp_reader *pfile;\n@@ -764,6 +774,8 @@ cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buf = CPP_BUFFER (pfile);\n+  if (ACTIVE_MARK_P())\n+    cpp_ice (pfile, \"mark active in cpp_pop_buffer\");\n   (*buf->cleanup) (buf, pfile);\n   CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n   free (buf);\n@@ -2337,16 +2349,16 @@ cpp_get_token (pfile)\n \t    goto op2;\n \n \tcomment:\n-\t  if (opts->put_out_comments)\n-\t    c = copy_comment (pfile, c);\n-\t  else\n+\t  if (opts->discard_comments)\n \t    c = skip_comment (pfile, c);\n+\t  else\n+\t    c = copy_comment (pfile, c);\n \t  if (c != ' ')\n \t    goto randomchar;\n \t  \n \t  /* Comments are equivalent to spaces.\n \t     For -traditional, a comment is equivalent to nothing.  */\n-\t  if (opts->traditional || opts->put_out_comments)\n+\t  if (opts->traditional || !opts->discard_comments)\n \t    return CPP_COMMENT;\n \t  else\n \t    {\n@@ -2629,50 +2641,50 @@ cpp_get_token (pfile)\n \t       decide this is not a macro call and leave things that way.  */\n \t    if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n \t    {\n-\t      int is_macro_call, macbuf_whitespace = 0;\n+\t      int macbuf_whitespace = 0;\n+\n+\t      while (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t\t{\n+\t\t  U_CHAR *point = CPP_BUFFER (pfile)->cur;\n+\t\t  for (;;)\n+\t\t    {\n+\t\t      cpp_skip_hspace (pfile);\n+\t\t      c = PEEKC ();\n+\t\t      if (c == '\\n')\n+\t\t\tFORWARD(1);\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (point != CPP_BUFFER (pfile)->cur)\n+\t\t    macbuf_whitespace = 1;\n+\t\t  if (c == '(')\n+\t\t    goto is_macro_call;\n+\t\t  else if (c != EOF)\n+\t\t    goto not_macro_call;\n+\t\t  cpp_pop_buffer (pfile);\n+\t\t}\n \n \t      parse_set_mark (pfile);\n \t      for (;;)\n \t\t{\n \t\t  cpp_skip_hspace (pfile);\n \t\t  c = PEEKC ();\n-\t\t  is_macro_call = c == '(';\n-\t\t  if (c != EOF)\n-\t\t    {\n-\t\t      if (c != '\\n')\n-\t\t        break;\n-\t\t      CPP_BUMP_LINE (pfile);\n-\t\t      FORWARD (1);\n-\t\t    }\n-                  else\n-                    {\n-                      if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-                        {\n-                          if (CPP_BUFFER (pfile)->mark !=\n-                              (CPP_BUFFER (pfile)->cur\n-                               - CPP_BUFFER (pfile)->buf))\n-                             macbuf_whitespace = 1;\n-\n-\t\t\t  /* The mark goes away automatically when\n-\t\t\t     the buffer is popped. */\n-                          cpp_pop_buffer (pfile);\n-                          parse_set_mark (pfile);\n-                        }\n-                      else\n-                        break;\n-                    }\n+\t\t  if (c == '\\n')\n+\t\t    FORWARD(1);\n+\t\t  else\n+\t\t    break;\n \t\t}\n-\t      if (!is_macro_call)\n-                {\n-                  parse_goto_mark (pfile);\n-                  if (macbuf_whitespace)\n-                    CPP_PUTC (pfile, ' ');\n-                }\n-\t      else\n-\t\tparse_clear_mark (pfile);\n-\t      if (!is_macro_call)\n-\t\treturn CPP_NAME;\n+\t      parse_goto_mark (pfile);\n+\n+\t      if (c == '(')\n+\t\tgoto is_macro_call;\n+\n+\t    not_macro_call:\n+\t      if (macbuf_whitespace)\n+\t\tCPP_PUTC (pfile, ' ');\n+\t      return CPP_NAME;\n \t    }\n+\t  is_macro_call:\n \t    /* This is now known to be a macro call.\n \t       Expand the macro, reading arguments as needed,\n \t       and push the expansion on the input stack.  */\n@@ -3142,40 +3154,27 @@ cpp_read_check_assertion (pfile)\n \n /* Remember the current position of PFILE.  */\n \n-void\n+static void\n parse_set_mark (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  if (ip->mark != -1)\n-      cpp_ice (pfile, \"ip->mark != -1 in parse_set_mark\");\n+  if (ACTIVE_MARK_P())\n+      cpp_ice (pfile, \"mark active in parse_set_mark\");\n \n   ip->mark = ip->cur - ip->buf;\n }\n \n-/* Clear the current mark - we no longer need it.  */\n-\n-void\n-parse_clear_mark (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-  if (ip->mark == -1)\n-      cpp_ice (pfile, \"ip->mark == -1 in parse_clear_mark\");\n-\n-  ip->mark = -1;\n-}\n-\n /* Backup the current position of PFILE to that saved in its mark,\n    and clear the mark.  */\n \n-void\n+static void\n parse_goto_mark (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  if (ip->mark == -1)\n-      cpp_ice (pfile, \"ip->mark == -1 in parse_goto_mark\");\n+  if (!ACTIVE_MARK_P())\n+      cpp_ice (pfile, \"mark not active in parse_goto_mark\");\n \n   ip->cur = ip->buf + ip->mark;\n   ip->mark = -1;"}, {"sha": "e0bf7ae8405277e8d1f0fce17ddd8f51ab3594bd", "filename": "gcc/cpplib.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -59,10 +59,6 @@ enum cpp_token {\n typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n-extern void parse_set_mark\tPARAMS ((cpp_reader *));\n-extern void parse_clear_mark\tPARAMS ((cpp_reader *));\n-extern void parse_goto_mark\tPARAMS ((cpp_reader *));\n-\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n@@ -356,9 +352,9 @@ struct cpp_options {\n \n   char chill;\n \n-  /* Nonzero means copy comments into the output file.  */\n+  /* Nonzero means don't copy comments into the output file.  */\n \n-  char put_out_comments;\n+  char discard_comments;\n \n   /* Nonzero means process the ANSI trigraph sequences.  */\n "}, {"sha": "fe7105857e4c808a08722f872b9f33b989c7c54f", "filename": "gcc/testsuite/gcc.dg/20000209-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-1.c?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do preprocess } */\n+\n+/* Tests for line numbering around function-like macro calls.\n+   Bug found by Mark Mitchell.  */\n+\n+#define f(x) x\n+#define g f\n+\n+f (3);\n+#error here\t/* { dg-error \"here\" \"case 0\" } */\n+\n+f\n+  (3);\n+#error here\t/* { dg-error \"here\" \"case 1\" } */\n+\n+(f\n+  )(3);\n+#error here\t/* { dg-error \"here\" \"case 2\" } */\n+\n+g\n+  (3);\n+#error here\t/* { dg-error \"here\" \"case 3\" } */\n+\n+(g\n+  )(3);\n+#error here\t/* { dg-error \"here\" \"case 4\" } */\n+\n+f /* some\n+     text */  (3);\n+#error here\t/* { dg-error \"here\" \"case 5\" } */\n+\n+(g /* some\n+      text */ )(3);\n+#error here\t/* { dg-error \"here\" \"case 6\" } */"}, {"sha": "621a00b364fe0781127675db7c758eeea0e6ceae", "filename": "gcc/testsuite/gcc.dg/20000209-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c?ref=564ad5f49e3f4d9d55e972d8ed66ac12bd2c83dc", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* Distilled from glibc sources.  Tests preprocessor corner cases.  */\n+\n+#define NO_PAREN(rest...) rest\n+#define DEFINE_CATEGORY(category, items) \\\n+const int _nl_value_type_##category[] = { NO_PAREN items }\n+\n+DEFINE_CATEGORY\n+(\n+ LC_COLLATE,\n+ (\n+   1,\n+   2,\n+   3,\n+  ));\n+\n+DEFINE_CATEGORY(LC_CTYPE, (1, 2, 3));"}]}