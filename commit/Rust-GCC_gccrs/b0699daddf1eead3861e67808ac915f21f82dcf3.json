{"sha": "b0699daddf1eead3861e67808ac915f21f82dcf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2OTlkYWRkZjFlZWFkMzg2MWU2NzgwOGFjOTE1ZjIxZjgyZGNmMw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-07T20:58:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-07T20:58:47Z"}, "message": "cppfiles.c (_cpp_find_include_file): Make sure ih->name is initialized.\n\n\t* cppfiles.c (_cpp_find_include_file): Make sure ih->name is\n\tinitialized.\n\t* cppinit.c (cpp_cleanup): Free imp->nshort also.\n\n\t* cpperror.c (cpp_print_containing_files,\n\tcpp_print_file_and_line, v_cpp_message): Rename to\n\tprint_containing_files, print_file_and_line, and v_message.\n\t* cppexp.c (cpp_parse_expr, cpp_parse_escape, cpp_lex): Rename\n\tto _cpp_parse_expr, parse_escape, and lex.\n\t(parse_charconst): Remove broken multibyte support.\n\t* cppfiles.c (include_hash): Make static.\n\t(cpp_included): New function.\n\t(merge_include_chains, find_include_file, finclude,\n\tsimplify_pathname): Rename to _cpp_merge_include_chains,\n\t_cpp_find_include_file, _cpp_read_include_file, and\n\t_cpp_simplify_pathname.\n\t* cpphash.c (cpp_lookup, free_definition, delete_macro,\n\tcpp_install, create_definition, macroexpand, compare_defs,\n\tdump_definition): Rename to _cpp_lookup, _cpp_free_definition,\n\t_cpp_delete_macro, _cpp_install, _cpp_create_definition,\n\t_cpp_macroexpand, _cpp_compare_defs, and _cpp_dump_definition.\n\t* cppinit.c (cpp_handle_option): Rename to handle_option, make\n\tstatic.\n\t* cpplib.c: Remove extern prototype of cpp_parse_expr.\n\n\t* cpphash.h: Update prototypes.\n\t* cpplib.h: Likewise.  Prototype _cpp_parse_expr here.\n\nFrom-SVN: r32390", "tree": {"sha": "1a0ac2a2bf6f6751175dddcf0bf7464c1266fe1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a0ac2a2bf6f6751175dddcf0bf7464c1266fe1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0699daddf1eead3861e67808ac915f21f82dcf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0699daddf1eead3861e67808ac915f21f82dcf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0699daddf1eead3861e67808ac915f21f82dcf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0699daddf1eead3861e67808ac915f21f82dcf3/comments", "author": null, "committer": null, "parents": [{"sha": "79e69af0254238d0b5fa1940c5f7ecfce9e11bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79e69af0254238d0b5fa1940c5f7ecfce9e11bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79e69af0254238d0b5fa1940c5f7ecfce9e11bcd"}], "stats": {"total": 317, "additions": 176, "deletions": 141}, "files": [{"sha": "f26f2e0f004b84ba5269fbe1fdf08d4bbddbb32f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -1,3 +1,33 @@\n+2000-03-07  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (_cpp_find_include_file): Make sure ih->name is\n+\tinitialized.\n+\t* cppinit.c (cpp_cleanup): Free imp->nshort also.\n+\n+\t* cpperror.c (cpp_print_containing_files,\n+\tcpp_print_file_and_line, v_cpp_message): Rename to\n+\tprint_containing_files, print_file_and_line, and v_message.\n+\t* cppexp.c (cpp_parse_expr, cpp_parse_escape, cpp_lex): Rename\n+\tto _cpp_parse_expr, parse_escape, and lex.\n+\t(parse_charconst): Remove broken multibyte support.\n+\t* cppfiles.c (include_hash): Make static.\n+\t(cpp_included): New function.\n+\t(merge_include_chains, find_include_file, finclude,\n+\tsimplify_pathname): Rename to _cpp_merge_include_chains,\n+\t_cpp_find_include_file, _cpp_read_include_file, and\n+\t_cpp_simplify_pathname.\n+\t* cpphash.c (cpp_lookup, free_definition, delete_macro,\n+\tcpp_install, create_definition, macroexpand, compare_defs,\n+\tdump_definition): Rename to _cpp_lookup, _cpp_free_definition,\n+\t_cpp_delete_macro, _cpp_install, _cpp_create_definition,\n+\t_cpp_macroexpand, _cpp_compare_defs, and _cpp_dump_definition.\n+\t* cppinit.c (cpp_handle_option): Rename to handle_option, make\n+\tstatic.\n+\t* cpplib.c: Remove extern prototype of cpp_parse_expr.\n+\n+\t* cpphash.h: Update prototypes.\n+\t* cpplib.h: Likewise.  Prototype _cpp_parse_expr here.\n+\n 2000-03-07  Andrew Haley  <aph@cygnus.com>\n \n \t* config/mips/mips.h (PTRDIFF_TYPE): Revert broken change;"}, {"sha": "577840b3e9743aa6cc47e4fdad89993a33f64428", "filename": "gcc/cpperror.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -28,17 +28,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n-static void cpp_print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));\n-static void cpp_print_file_and_line\tPARAMS ((const char *, long, long));\n-static void v_cpp_message\t\tPARAMS ((cpp_reader *, int,\n+static void print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));\n+static void print_file_and_line\t\tPARAMS ((const char *, long, long));\n+static void v_message\t\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t\t const char *, long, long,\n \t\t\t\t\t\t const char *, va_list));\n \n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n \n static void\n-cpp_print_containing_files (pfile, ip)\n+print_containing_files (pfile, ip)\n      cpp_reader *pfile;\n      cpp_buffer *ip;\n {\n@@ -86,7 +86,7 @@ cpp_print_containing_files (pfile, ip)\n }\n \n static void\n-cpp_print_file_and_line (filename, line, column)\n+print_file_and_line (filename, line, column)\n      const char *filename;\n      long line, column;\n {\n@@ -104,7 +104,7 @@ cpp_print_file_and_line (filename, line, column)\n    1 for error, 0 for warning.  */\n \n static void\n-v_cpp_message (pfile, is_error, file, line, col, msg, ap)\n+v_message (pfile, is_error, file, line, col, msg, ap)\n      cpp_reader *pfile;\n      int is_error;\n      const char *file;\n@@ -122,8 +122,8 @@ v_cpp_message (pfile, is_error, file, line, col, msg, ap)\n       if (line == -1)\n \tcpp_buf_line_and_col (ip, &line, &col);\n \n-      cpp_print_containing_files (pfile, ip);\n-      cpp_print_file_and_line (file, line, col);\n+      print_containing_files (pfile, ip);\n+      print_file_and_line (file, line, col);\n     }\n   else\n     fprintf (stderr, \"%s: \", progname);\n@@ -145,7 +145,7 @@ v_cpp_message (pfile, is_error, file, line, col, msg, ap)\n       pfile->errors = CPP_FATAL_LIMIT;\n       break;\n     default:\n-      cpp_ice (pfile, \"bad is_error(%d) in v_cpp_message\", is_error);\n+      cpp_ice (pfile, \"bad is_error(%d) in v_message\", is_error);\n     }\n \n   vfprintf (stderr, _(msg), ap);\n@@ -173,7 +173,7 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_message (pfile, 3, NULL, -1, -1, msgid, ap);\n+  v_message (pfile, 3, NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n \n@@ -199,7 +199,7 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_message (pfile, 2, NULL, -1, -1, msgid, ap);\n+  v_message (pfile, 2, NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n \n@@ -222,7 +222,7 @@ cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   if (CPP_OPTIONS (pfile)->inhibit_errors)\n     return;\n \n-  v_cpp_message (pfile, 1, NULL, -1, -1, msgid, ap);\n+  v_message (pfile, 1, NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n \n@@ -250,7 +250,7 @@ cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n   if (CPP_OPTIONS (pfile)->inhibit_errors)\n     return;\n \n-  v_cpp_message (pfile, 1, NULL, line, column, msgid, ap);\n+  v_message (pfile, 1, NULL, line, column, msgid, ap);\n   va_end(ap);\n }\n \n@@ -282,7 +282,7 @@ cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   if (CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n \n-  v_cpp_message (pfile, 0, NULL, -1, -1, msgid, ap);\n+  v_message (pfile, 0, NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n \n@@ -310,7 +310,7 @@ cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   if (CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n \n-  v_cpp_message (pfile, 0, NULL, line, column, msgid, ap);\n+  v_message (pfile, 0, NULL, line, column, msgid, ap);\n   va_end(ap);\n }\n \n@@ -335,7 +335,7 @@ cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n       : CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n \n-  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+  v_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n \t\t NULL, -1, -1, msgid, ap);\n   va_end(ap);\n }\n@@ -366,7 +366,7 @@ cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n       : CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n \n-  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+  v_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n \t\t NULL, line, column, msgid, ap);\n   va_end(ap);\n }\n@@ -403,7 +403,7 @@ cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile,\n       : CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n \n-  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+  v_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n \t\t file, line, col, msgid, ap);\n   va_end(ap);\n }"}, {"sha": "e3c1bdf1430fd1498fb113e1490dbe870c643754", "filename": "gcc/cppexp.c", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -1,4 +1,4 @@\n-/* Parse C expressions for CCCP.\n+/* Parse C expressions for cpplib.\n    Copyright (C) 1987, 92, 94, 95, 97, 98, 1999, 2000 Free Software Foundation.\n \n This program is free software; you can redistribute it and/or modify it\n@@ -65,26 +65,31 @@ Written by Per Bothner 1994.  */\n #endif\n \n #define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n-\t\t\t    ? (~ (~ (HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n+\t\t\t    ? (~(~(HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n \t\t\t    : ~ (HOST_WIDEST_INT) 0)\n \n #define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n-\t\t\t     ? ~ (~ (HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n+\t\t\t     ? ~(~(HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n \t\t\t     : ~ (HOST_WIDEST_INT) 0)\n \n /* Yield nonzero if adding two numbers with A's and B's signs can yield a\n    number with SUM's sign, where A, B, and SUM are all C integers.  */\n #define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n \n static void integer_overflow PARAMS ((cpp_reader *));\n-static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT, int, unsigned HOST_WIDEST_INT));\n-static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT, int, unsigned HOST_WIDEST_INT));\n-static struct operation parse_number PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *));\n-static struct operation parse_charconst PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *));\n+static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n+\t\t\t\t\t   int, unsigned HOST_WIDEST_INT));\n+static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n+\t\t\t\t\t    int, unsigned HOST_WIDEST_INT));\n+static struct operation parse_number PARAMS ((cpp_reader *, U_CHAR *,\n+\t\t\t\t\t      U_CHAR *));\n+static struct operation parse_charconst PARAMS ((cpp_reader *, U_CHAR *,\n+\t\t\t\t\t\t U_CHAR *));\n static struct operation parse_defined PARAMS ((cpp_reader *));\n-static struct operation cpp_lex PARAMS ((cpp_reader *, int));\n-extern HOST_WIDEST_INT cpp_parse_expr PARAMS ((cpp_reader *));\n-static HOST_WIDEST_INT cpp_parse_escape PARAMS ((cpp_reader *, U_CHAR **, HOST_WIDEST_INT));\n+static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, U_CHAR **,\n+\t\t\t\t\t     HOST_WIDEST_INT));\n+static struct operation lex PARAMS ((cpp_reader *, int));\n+\n \n #define ERROR 299\n #define OROR 300\n@@ -107,12 +112,13 @@ static HOST_WIDEST_INT cpp_parse_escape PARAMS ((cpp_reader *, U_CHAR **, HOST_W\n #define SKIP_OPERAND 8\n /*#define UNSIGNEDP 16*/\n \n-struct operation {\n-    short op;\n-    char rprio; /* Priority of op (relative to it right operand).  */\n-    char flags;\n-    char unsignedp;    /* true if value should be treated as unsigned */\n-    HOST_WIDEST_INT value;        /* The value logically \"right\" of op.  */\n+struct operation\n+{\n+  short op;\n+  char rprio; /* Priority of op (relative to it right operand).  */\n+  char flags;\n+  char unsignedp;    /* true if value should be treated as unsigned */\n+  HOST_WIDEST_INT value;        /* The value logically \"right\" of op.  */\n };\n \n /* Parse and convert an integer for #if.  Accepts decimal, hex, or octal\n@@ -258,13 +264,7 @@ parse_charconst (pfile, start, end)\n   int max_chars;\n   U_CHAR *ptr = start;\n \n-  /* FIXME: Should use reentrant multibyte functions.  */\n-#ifdef MULTIBYTE_CHARS\n-  wchar_t c = (wchar_t)-1;\n-  (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n-#else\n   int c = -1;\n-#endif\n \n   if (*ptr == 'L')\n     {\n@@ -277,22 +277,12 @@ parse_charconst (pfile, start, end)\n \n   while (ptr < end)\n     {\n-#ifndef MULTIBYTE_CHARS\n       c = *ptr++;\n-#else\n-      ptr += mbtowc (&c, ptr, end - ptr);\n-#endif\n       if (c == '\\'' || c == '\\0')\n \tbreak;\n       else if (c == '\\\\')\n \t{\n-\t  /* Hopefully valid assumption: if mbtowc returns a backslash,\n-\t     we are in initial shift state.  No valid escape-sequence\n-\t     character can take us out of initial shift state or begin\n-\t     an unshifted multibyte char, so cpp_parse_escape doesn't\n-\t     need to know about multibyte chars.  */\n-\n-\t  c = cpp_parse_escape (pfile, &ptr, mask);\n+\t  c = parse_escape (pfile, &ptr, mask);\n \t  if (width < HOST_BITS_PER_INT\n \t      && (unsigned int) c >= (unsigned int)(1 << width))\n \t    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n@@ -420,7 +410,7 @@ static const struct token tokentab2[] = {\n /* Read one token.  */\n \n static struct operation\n-cpp_lex (pfile, skip_evaluation)\n+lex (pfile, skip_evaluation)\n      cpp_reader *pfile;\n      int skip_evaluation;\n {\n@@ -510,7 +500,7 @@ cpp_lex (pfile, skip_evaluation)\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n static HOST_WIDEST_INT\n-cpp_parse_escape (pfile, string_ptr, result_mask)\n+parse_escape (pfile, string_ptr, result_mask)\n      cpp_reader *pfile;\n      U_CHAR **string_ptr;\n      HOST_WIDEST_INT result_mask;\n@@ -681,7 +671,7 @@ right_shift (pfile, a, unsignedp, b)\n    Returns the value of the expression.  */\n \n HOST_WIDEST_INT\n-cpp_parse_expr (pfile)\n+_cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n {\n   /* The implementation is an operator precedence parser,\n@@ -710,7 +700,7 @@ cpp_parse_expr (pfile)\n       char flags = 0;\n \n       /* Read a token */\n-      op =  cpp_lex (pfile, skip_evaluation);\n+      op =  lex (pfile, skip_evaluation);\n \n       /* See if the token is an operand, in which case go to set_value.\n \t If the token is an operator, figure out its left and right\n@@ -719,7 +709,7 @@ cpp_parse_expr (pfile)\n       switch (op.op)\n \t{\n \tcase NAME:\n-\t  cpp_ice (pfile, \"cpp_lex returns a NAME\");\n+\t  cpp_ice (pfile, \"lex returns a NAME\");\n \t  goto syntax_error;\n \tcase INT:  case CHAR:\n \t  goto set_value;\n@@ -1027,7 +1017,7 @@ cpp_parse_expr (pfile)\n \t  else\n \t    {\n \t      new_stack = (struct operation *) xmalloc (new_size);\n-\t      bcopy ((char *) stack, (char *) new_stack, old_size);\n+\t      memcpy (new_stack, stack, old_size);\n \t    }\n \t  stack = new_stack;\n \t  top = (struct operation *) ((char *) new_stack + old_size);"}, {"sha": "dc56b24ada5c4300050d4920962c510592427697", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -29,11 +29,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"intl.h\"\n \n-/* The entry points to this file are: find_include_file,\n-   cpp_read_file, finclude, include_hash, append_include_chain, and\n-   file_cleanup.  file_cleanup is only called through\n-   CPP_BUFFER(pfile)->cleanup, so it's static anyway. */\n-\n+static struct include_hash *include_hash PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t  const char *, int));\n static struct include_hash *redundant_include_p\n \t\t\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct include_hash *,\n@@ -83,7 +80,7 @@ static void hack_vms_include_specification PARAMS ((char *));\n    how?) and possibly preload the include hash. */\n \n void\n-merge_include_chains (opts)\n+_cpp_merge_include_chains (opts)\n      struct cpp_options *opts;\n {\n   struct file_name_list *prev, *cur, *other;\n@@ -208,7 +205,7 @@ merge_include_chains (opts)\n  #include name (there are at least three ways this can happen).  The\n  hash function could probably be improved a bit. */\n \n-struct include_hash *\n+static struct include_hash *\n include_hash (pfile, fname, add)\n      cpp_reader *pfile;\n      const char *fname;\n@@ -293,6 +290,19 @@ redundant_include_p (pfile, ihash, ilist)\n   return 0;\n }\n \n+/* Return 1 if the file named by FNAME has been included before in\n+   any context, 0 otherwise.  */\n+int\n+cpp_included (pfile, fname)\n+     cpp_reader *pfile;\n+     const char *fname;\n+{\n+  struct include_hash *ptr;\n+\n+  ptr = include_hash (pfile, fname, 0);\n+  return (ptr != NULL);\n+}\n+\n static int\n file_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n@@ -316,7 +326,7 @@ file_cleanup (pbuf, pfile)\n    *BEFORE is 1 if the file was included before (but needs to be read\n    again). */\n int\n-find_include_file (pfile, fname, search_start, ihash, before)\n+_cpp_find_include_file (pfile, fname, search_start, ihash, before)\n      cpp_reader *pfile;\n      const char *fname;\n      struct file_name_list *search_start;\n@@ -362,6 +372,7 @@ find_include_file (pfile, fname, search_start, ihash, before)\n     }\n   *before = 0;\n   *ihash = ih;\n+  ih->name = NULL;\n   ih->nshort = xstrdup (fname);\n   ih->control_macro = NULL;\n   \n@@ -383,7 +394,7 @@ find_include_file (pfile, fname, search_start, ihash, before)\n       bcopy (l->name, name, l->nlen);\n       name[l->nlen] = '/';\n       strcpy (&name[l->nlen+1], fname);\n-      simplify_pathname (name);\n+      _cpp_simplify_pathname (name);\n       if (CPP_OPTIONS (pfile)->remap)\n \tname = remap_filename (pfile, name, l);\n \n@@ -626,10 +637,11 @@ cpp_read_file (pfile, fname)\n     }\n \n   /* Open the file in nonblocking mode, so we don't get stuck if\n-     someone clever has asked cpp to process /dev/rmt0.  finclude()\n-     will check that we have a real file to work with.  Also take\n-     care not to acquire a controlling terminal by mistake (this can't\n-     happen on sane systems, but paranoia is a virtue).  */\n+     someone clever has asked cpp to process /dev/rmt0.\n+     _cpp_read_include_file will check that we have a real file to\n+     work with.  Also take care not to acquire a controlling terminal\n+     by mistake (this can't happen on sane systems, but paranoia is a\n+     virtue).  */\n   else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n     {\n       cpp_notice_from_errno (pfile, fname);\n@@ -651,7 +663,7 @@ cpp_read_file (pfile, fname)\n   ih_fake->control_macro = 0;\n   ih_fake->buf = (char *)-1;\n   ih_fake->limit = 0;\n-  if (!finclude (pfile, f, ih_fake))\n+  if (!_cpp_read_include_file (pfile, f, ih_fake))\n     goto failed_finclude;\n \n   return 1;\n@@ -672,7 +684,7 @@ cpp_read_file (pfile, fname)\n    The caller is responsible for the cpp_push_buffer.  */\n \n int\n-finclude (pfile, fd, ihash)\n+_cpp_read_include_file (pfile, fd, ihash)\n      cpp_reader *pfile;\n      int fd;\n      struct include_hash *ihash;\n@@ -1245,7 +1257,7 @@ initialize_input_buffer (pfile, fd, st)\n    of the string.\n  */\n void\n-simplify_pathname (path)\n+_cpp_simplify_pathname (path)\n     char *path;\n {\n     char *from, *to;"}, {"sha": "e5c4c713812286be1e9b66ad0cbbadea856d7843", "filename": "gcc/cpphash.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -116,7 +116,7 @@ hashf (s, len)\n    Otherwise, compute the length by scanning the entire name.  */\n \n HASHNODE *\n-cpp_lookup (pfile, name, len)\n+_cpp_lookup (pfile, name, len)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n      int len;\n@@ -147,7 +147,7 @@ cpp_lookup (pfile, name, len)\n    do_define when redefining macros.  */\n \n void\n-free_definition (d)\n+_cpp_free_definition (d)\n      DEFINITION *d;\n {\n   struct reflist *ap, *nextap;\n@@ -169,7 +169,7 @@ free_definition (d)\n  */\n \n void\n-delete_macro (hp)\n+_cpp_delete_macro (hp)\n      HASHNODE *hp;\n {\n   if (hp->prev != NULL)\n@@ -183,7 +183,7 @@ delete_macro (hp)\n     *hp->bucket_hdr = hp->next;\n \n   if (hp->type == T_MACRO)\n-    free_definition (hp->value.defn);\n+    _cpp_free_definition (hp->value.defn);\n \n   free (hp);\n }\n@@ -202,7 +202,7 @@ delete_macro (hp)\n    Otherwise, compute the hash code.  */\n \n HASHNODE *\n-cpp_install (pfile, name, len, type, value)\n+_cpp_install (pfile, name, len, type, value)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n      int len;\n@@ -698,7 +698,7 @@ collect_formal_parameters (pfile)\n    macro.  */\n \n DEFINITION *\n-create_definition (pfile, funlike)\n+_cpp_create_definition (pfile, funlike)\n      cpp_reader *pfile;\n      int funlike;\n {\n@@ -959,7 +959,7 @@ special_symbol (hp, pfile)\n    an argument list follows; arguments come from the input stack.  */\n \n void\n-macroexpand (pfile, hp)\n+_cpp_macroexpand (pfile, hp)\n      cpp_reader *pfile;\n      HASHNODE *hp;\n {\n@@ -1484,7 +1484,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n /* Return zero if two DEFINITIONs are isomorphic.  */\n \n int\n-compare_defs (pfile, d1, d2)\n+_cpp_compare_defs (pfile, d1, d2)\n      cpp_reader *pfile;\n      DEFINITION *d1, *d2;\n {\n@@ -1576,7 +1576,7 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n    to be read back in again. */\n \n void\n-dump_definition (pfile, sym, len, defn)\n+_cpp_dump_definition (pfile, sym, len, defn)\n      cpp_reader *pfile;\n      const U_CHAR *sym;\n      long len;"}, {"sha": "53af56510b191cf501bc42fbd477f061db734953", "filename": "gcc/cpphash.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -92,17 +92,18 @@ struct hashnode {\n   union hashval value;\t\t/* pointer to expansion, or whatever */\n };\n \n-extern HASHNODE *cpp_install\t  PARAMS ((cpp_reader *, const U_CHAR *, int,\n+extern HASHNODE *_cpp_install\t  PARAMS ((cpp_reader *, const U_CHAR *, int,\n \t\t\t\t\t   enum node_type, const char *));\n-extern HASHNODE *cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n-extern void free_definition\t  PARAMS ((DEFINITION *));\n-extern void delete_macro\t  PARAMS ((HASHNODE *));\n+extern HASHNODE *_cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n+extern void _cpp_free_definition  PARAMS ((DEFINITION *));\n+extern void _cpp_delete_macro\t  PARAMS ((HASHNODE *));\n \n-extern DEFINITION *create_definition PARAMS ((cpp_reader *, int));\n-extern int compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n+extern DEFINITION *_cpp_create_definition\n+\t\t\t\t  PARAMS ((cpp_reader *, int));\n+extern int _cpp_compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n \t\t\t\t\t   DEFINITION *));\n-extern void macroexpand\t\t  PARAMS ((cpp_reader *, HASHNODE *));\n-extern void dump_definition\t  PARAMS ((cpp_reader *, const U_CHAR *, long,\n+extern void _cpp_macroexpand\t  PARAMS ((cpp_reader *, HASHNODE *));\n+extern void _cpp_dump_definition  PARAMS ((cpp_reader *, const U_CHAR *, long,\n \t\t\t\t\t   DEFINITION *));\n \n #endif"}, {"sha": "0991a950fa387662ffda4878296f3a97633f29fc", "filename": "gcc/cppinit.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -183,6 +183,7 @@ static void initialize_dependency_output PARAMS ((cpp_reader *));\n static void initialize_standard_includes PARAMS ((cpp_reader *));\n static void new_pending_define\t\tPARAMS ((struct cpp_options *,\n \t\t\t\t\t\t const char *));\n+static int handle_option\t\tPARAMS ((cpp_reader *, int, char **));\n \n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n@@ -293,7 +294,7 @@ append_include_chain (pfile, pend, dir, path, cxx_aware)\n   struct stat st;\n   unsigned int len;\n \n-  simplify_pathname (dir);\n+  _cpp_simplify_pathname (dir);\n   if (stat (dir, &st))\n     {\n       /* Dirs that don't exist are silently ignored. */\n@@ -428,6 +429,7 @@ cpp_cleanup (pfile)\n \t  struct include_hash *next = imp->next;\n \n \t  free ((PTR) imp->name);\n+\t  free ((PTR) imp->nshort);\n \t  free (imp);\n \t  imp = next;\n \t}\n@@ -437,7 +439,7 @@ cpp_cleanup (pfile)\n   for (i = HASHSIZE; --i >= 0;)\n     {\n       while (pfile->hashtab[i])\n-\tdelete_macro (pfile->hashtab[i]);\n+\t_cpp_delete_macro (pfile->hashtab[i]);\n     }\n   free (pfile->hashtab);\n }\n@@ -507,7 +509,7 @@ initialize_builtins (pfile)\n       val = (b->flags & ULP) ? user_label_prefix : b->value;\n       len = strlen (b->name);\n \n-      cpp_install (pfile, b->name, len, b->type, val);\n+      _cpp_install (pfile, b->name, len, b->type, val);\n       if ((b->flags & DUMP) && CPP_OPTIONS (pfile)->debug_output)\n \tdump_special_to_buffer (pfile, b->name);\n     }\n@@ -719,7 +721,7 @@ cpp_start_read (pfile, fname)\n   if (! opts->no_standard_includes)\n     initialize_standard_includes (pfile);\n \n-  merge_include_chains (opts);\n+  _cpp_merge_include_chains (opts);\n \n   /* With -v, print the list of dirs to search.  */\n   if (opts->verbose)\n@@ -876,7 +878,8 @@ cpp_finish (pfile)\n \t  for (h = pfile->hashtab[i]; h; h = h->next)\n \t    if (h->type == T_MACRO)\n \t      {\n-\t\tdump_definition (pfile, h->name, h->length, h->value.defn);\n+\t\t_cpp_dump_definition (pfile, h->name, h->length,\n+\t\t\t\t      h->value.defn);\n \t\tCPP_PUTC (pfile, '\\n');\n \t      }\n \t}\n@@ -901,8 +904,8 @@ new_pending_define (opts, text)\n    Can be called multiple times, to handle multiple sets of options.\n    Returns number of strings consumed.  */\n \n-int\n-cpp_handle_option (pfile, argc, argv)\n+static int\n+handle_option (pfile, argc, argv)\n      cpp_reader *pfile;\n      int argc;\n      char **argv;\n@@ -1493,7 +1496,7 @@ cpp_handle_options (pfile, argc, argv)\n   int strings_processed;\n   for (i = 0; i < argc; i += strings_processed)\n     {\n-      strings_processed = cpp_handle_option (pfile, argc - i, argv + i);\n+      strings_processed = handle_option (pfile, argc - i, argv + i);\n       if (strings_processed == 0)\n \tbreak;\n     }"}, {"sha": "c97af568c8fc4fd14d59ac45fd395d1f96c9ed6c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -41,10 +41,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    case CPP_BUMP_LINE must not be called.  */\n #define ACTIVE_MARK_P() (CPP_BUFFER (pfile)->mark != -1)\n \n-/* External declarations.  */\n-\n-extern HOST_WIDEST_INT cpp_parse_expr PARAMS ((cpp_reader *));\n-\n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n struct directive\n@@ -259,7 +255,7 @@ cpp_defined (pfile, id, len)\n      const U_CHAR *id;\n      int len;\n {\n-  HASHNODE *hp = cpp_lookup (pfile, id, len);\n+  HASHNODE *hp = _cpp_lookup (pfile, id, len);\n   if (hp && hp->type == T_POISON)\n     {\n       cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);\n@@ -686,17 +682,17 @@ do_define (pfile, keyword)\n        as an object-like macro if this happens, with a warning.  */\n     cpp_pedwarn (pfile, \"missing white space after `#define %.*s'\", len, sym);\n \n-  def = create_definition (pfile, funlike);\n+  def = _cpp_create_definition (pfile, funlike);\n   if (def == 0)\n     return 0;\n \n-  if ((hp = cpp_lookup (pfile, sym, len)) != NULL)\n+  if ((hp = _cpp_lookup (pfile, sym, len)) != NULL)\n     {\n       int ok;\n \n       /* Redefining a macro is ok if the definitions are the same.  */\n       if (hp->type == T_MACRO)\n-\tok = ! compare_defs (pfile, def, hp->value.defn);\n+\tok = ! _cpp_compare_defs (pfile, def, hp->value.defn);\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST || hp->type == T_STDC)\n         ok = ! CPP_OPTIONS (pfile)->done_initializing;\n@@ -721,17 +717,17 @@ do_define (pfile, keyword)\n \t{\n \t  /* Replace the old definition.  */\n \t  if (hp->type == T_MACRO)\n-\t    free_definition (hp->value.defn);\n+\t    _cpp_free_definition (hp->value.defn);\n \t  hp->type = T_MACRO;\n \t  hp->value.defn = def;\n \t}\n     }\n   else\n-    cpp_install (pfile, sym, len, T_MACRO, (char *) def);\n+    _cpp_install (pfile, sym, len, T_MACRO, (char *) def);\n \n   if (CPP_OPTIONS (pfile)->debug_output\n       || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n-    dump_definition (pfile, sym, len, def);\n+    _cpp_dump_definition (pfile, sym, len, def);\n   else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n     pass_thru_directive (sym, len, pfile, keyword);\n \n@@ -1201,7 +1197,7 @@ do_include (pfile, keyword)\n       return 0;\n     }\n \n-  fd = find_include_file (pfile, ftok, search_start, &ihash, &before);\n+  fd = _cpp_find_include_file (pfile, ftok, search_start, &ihash, &before);\n \n   if (fd == -2)\n     return 0;\n@@ -1280,7 +1276,7 @@ do_include (pfile, keyword)\n   if (angle_brackets)\n     pfile->system_include_depth++;   /* Decremented in file_cleanup. */\n \n-  if (finclude (pfile, fd, ihash))\n+  if (_cpp_read_include_file (pfile, fd, ihash))\n     {\n       output_line_command (pfile, enter_file);\n       pfile->only_seen_white = 2;\n@@ -1479,7 +1475,7 @@ do_undef (pfile, keyword)\n   }\n   CPP_SET_WRITTEN (pfile, here);\n \n-  while ((hp = cpp_lookup (pfile, name, len)) != NULL)\n+  while ((hp = _cpp_lookup (pfile, name, len)) != NULL)\n     {\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n@@ -1491,7 +1487,7 @@ do_undef (pfile, keyword)\n \t{\n \t  if (hp->type != T_MACRO)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n-\t  delete_macro (hp);\n+\t  _cpp_delete_macro (hp);\n \t}\n     }\n \n@@ -1705,7 +1701,6 @@ do_pragma_implementation (pfile)\n {\n   /* Be quiet about `#pragma implementation' for a file only if it hasn't\n      been included yet.  */\n-  struct include_hash *ptr;\n   enum cpp_token token;\n   long written = CPP_WRITTEN (pfile);\n   U_CHAR *name;\n@@ -1723,9 +1718,8 @@ do_pragma_implementation (pfile)\n   name = pfile->token_buffer + written + 1;\n   copy = xstrdup (name);\n   copy[strlen(copy)] = '\\0';  /* trim trailing quote */\n-  \n-  ptr = include_hash (pfile, copy, 0);\n-  if (ptr)\n+\n+  if (cpp_included (pfile, copy))\n     cpp_warning (pfile,\n \t \"`#pragma implementation' for `%s' appears after file is included\",\n \t\t copy);\n@@ -1766,18 +1760,19 @@ do_pragma_poison (pfile)\n \n       p = pfile->token_buffer + written;\n       len = strlen (p);\n-      if ((hp = cpp_lookup (pfile, p, len)))\n+      if ((hp = _cpp_lookup (pfile, p, len)))\n \t{\n \t  if (hp->type != T_POISON)\n \t    {\n \t      cpp_warning (pfile, \"poisoning existing macro `%s'\", p);\n-\t      free_definition (hp->value.defn);\n+\t      if (hp->type == T_MACRO)\n+\t\t_cpp_free_definition (hp->value.defn);\n \t      hp->value.defn = 0;\n \t      hp->type = T_POISON;\n \t    }\n \t}\n       else\n-\tcpp_install (pfile, p, len, T_POISON, 0);\n+\t_cpp_install (pfile, p, len, T_POISON, 0);\n       if (writeit)\n \tCPP_PUTC (pfile, ' ');\n     }\n@@ -1952,7 +1947,7 @@ eval_if_expression (pfile)\n   long old_written = CPP_WRITTEN (pfile);\n \n   pfile->parsing_if_directive++;\n-  value = cpp_parse_expr (pfile);\n+  value = _cpp_parse_expr (pfile);\n   pfile->parsing_if_directive--;\n \n   skip_rest_of_line (pfile);\n@@ -2683,7 +2678,7 @@ cpp_get_token (pfile)\n \t      return CPP_NAME;\n \t    ident = pfile->token_buffer + before_name_written;\n \t    ident_len = CPP_PWRITTEN (pfile) - ident;\n-\t    hp = cpp_lookup (pfile, ident, ident_len);\n+\t    hp = _cpp_lookup (pfile, ident, ident_len);\n \t    if (!hp)\n \t      return CPP_NAME;\n \t    if (hp->type == T_DISABLED)\n@@ -2751,7 +2746,7 @@ cpp_get_token (pfile)\n \t    /* This is now known to be a macro call.\n \t       Expand the macro, reading arguments as needed,\n \t       and push the expansion on the input stack.  */\n-\t    macroexpand (pfile, hp);\n+\t    _cpp_macroexpand (pfile, hp);\n \t    CPP_SET_WRITTEN (pfile, before_name_written);\n \t  }\n \t  goto get_next;\n@@ -3085,24 +3080,24 @@ do_assert (pfile, keyword)\n \n   thislen = strlen (sym);\n   baselen = index (sym, '(') - sym;\n-  this = cpp_lookup (pfile, sym, thislen);\n+  this = _cpp_lookup (pfile, sym, thislen);\n   if (this)\n     {\n       cpp_warning (pfile, \"`%s' re-asserted\", sym);\n       goto error;\n     }\n \n-  base = cpp_lookup (pfile, sym, baselen);\n+  base = _cpp_lookup (pfile, sym, baselen);\n   if (! base)\n-    base = cpp_install (pfile, sym, baselen, T_ASSERT, 0);\n+    base = _cpp_install (pfile, sym, baselen, T_ASSERT, 0);\n   else if (base->type != T_ASSERT)\n   {\n     /* Token clash - but with what?! */\n     cpp_ice (pfile, \"base->type != T_ASSERT in do_assert\");\n     goto error;\n   }\n \n-  this = cpp_install (pfile, sym, thislen, T_ASSERT,\n+  this = _cpp_install (pfile, sym, thislen, T_ASSERT,\n \t\t      (char *)base->value.aschain);\n   base->value.aschain = this;\n   \n@@ -3143,7 +3138,7 @@ do_unassert (pfile, keyword)\n   thislen = strlen (sym);\n   if (ret == 1)\n     {\n-      base = cpp_lookup (pfile, sym, thislen);\n+      base = _cpp_lookup (pfile, sym, thislen);\n       if (! base)\n \tgoto error;  /* It isn't an error to #undef what isn't #defined,\n \t\t\tso it isn't an error to #unassert what isn't\n@@ -3152,27 +3147,27 @@ do_unassert (pfile, keyword)\n       for (this = base->value.aschain; this; this = next)\n         {\n \t  next = this->value.aschain;\n-\t  delete_macro (this);\n+\t  _cpp_delete_macro (this);\n \t}\n-      delete_macro (base);\n+      _cpp_delete_macro (base);\n     }\n   else\n     {\n       baselen = index (sym, '(') - sym;\n-      base = cpp_lookup (pfile, sym, baselen);\n+      base = _cpp_lookup (pfile, sym, baselen);\n       if (! base) goto error;\n-      this = cpp_lookup (pfile, sym, thislen);\n+      this = _cpp_lookup (pfile, sym, thislen);\n       if (! this) goto error;\n \n       next = base;\n       while (next->value.aschain != this)\n \tnext = next->value.aschain;\n \n       next->value.aschain = this->value.aschain;\n-      delete_macro (this);\n+      _cpp_delete_macro (this);\n \n       if (base->value.aschain == NULL)\n-\tdelete_macro (base);  /* Last answer for this predicate deleted. */\n+\t_cpp_delete_macro (base);  /* Last answer for this predicate deleted. */\n     }\n   \n   pfile->limit = (unsigned char *) sym; /* Pop */"}, {"sha": "bb098c2b6d57f02273d285ce5989648fb843f6cb", "filename": "gcc/cpplib.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0699daddf1eead3861e67808ac915f21f82dcf3/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=b0699daddf1eead3861e67808ac915f21f82dcf3", "patch": "@@ -64,7 +64,6 @@ enum cpp_token\n typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n-extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_token cpp_get_token PARAMS ((cpp_reader *));\n extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n@@ -694,16 +693,21 @@ extern void output_line_command\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t enum file_change_code));\n \n /* In cppfiles.c */\n-extern void simplify_pathname\t\tPARAMS ((char *));\n-extern void merge_include_chains\tPARAMS ((struct cpp_options *));\n-extern int find_include_file\t\tPARAMS ((cpp_reader *, const char *,\n+extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));\n+extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n+\n+extern void _cpp_simplify_pathname\tPARAMS ((char *));\n+extern void _cpp_merge_include_chains\tPARAMS ((struct cpp_options *));\n+extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t\tstruct file_name_list *,\n \t\t\t\t\t\tstruct include_hash **,\n \t\t\t\t\t\tint *));\n-extern int finclude\t\t\tPARAMS ((cpp_reader *, int,\n+extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t        struct include_hash *));\n-extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern struct include_hash *include_hash PARAMS ((cpp_reader *, const char *, int));\n+\n+/* In cppexp.c */\n+extern HOST_WIDEST_INT _cpp_parse_expr\tPARAMS ((cpp_reader *));\n+\n \n #ifdef __cplusplus\n }"}]}