{"sha": "ec62c3731d43ad68536a6ce262df34a3f08e36a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2MmMzNzMxZDQzYWQ2ODUzNmE2Y2UyNjJkZjM0YTNmMDhlMzZhMw==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-09-11T19:50:41Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-09-11T19:50:41Z"}, "message": "Refactor optimize isl\n\nRefactor graphite-optimize-isl.c. Renamed function name, variable names etc.,\nand indented the source according to gcc style guidelines.  Modified comments\naccordingly. No functional change intended.\n\nPasses regtest and bootstap on x86_64.\n\ngcc/ChangeLog:\n\n2015-09-10  Aditya Kumar  <aditya.k7@samsung.com>\n\n        * graphite-optimize-isl.c (get_tile_map): Refactor.\n        (get_schedule_for_band): Same.\n        (getScheduleForBand): Same.\n        (get_prevector_map): Same.\n        (get_schedule_for_band_list): Same.\n        (get_schedule_map): Same.\n        (get_single_map): Same.\n        (apply_schedule_map_to_scop): Same.\n        (optimize_isl): Same.\n\nFrom-SVN: r227695", "tree": {"sha": "7f0dec952ef22f13b27e7f959f16db510f8c6cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f0dec952ef22f13b27e7f959f16db510f8c6cd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec62c3731d43ad68536a6ce262df34a3f08e36a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec62c3731d43ad68536a6ce262df34a3f08e36a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec62c3731d43ad68536a6ce262df34a3f08e36a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec62c3731d43ad68536a6ce262df34a3f08e36a3/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc002444204734e542b81dd8dd51c899bc62fada", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc002444204734e542b81dd8dd51c899bc62fada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc002444204734e542b81dd8dd51c899bc62fada"}], "stats": {"total": 426, "additions": 221, "deletions": 205}, "files": [{"sha": "43258d4eb93109a13bbd564f0e7cdf4a19ec219f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec62c3731d43ad68536a6ce262df34a3f08e36a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec62c3731d43ad68536a6ce262df34a3f08e36a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec62c3731d43ad68536a6ce262df34a3f08e36a3", "patch": "@@ -1,3 +1,15 @@\n+2015-09-11  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+        * graphite-optimize-isl.c (get_tile_map): Refactor.\n+        (get_schedule_for_band): Same.\n+        (getScheduleForBand): Same.\n+        (get_prevector_map): Same.\n+        (get_schedule_for_band_list): Same.\n+        (get_schedule_map): Same.\n+        (get_single_map): Same.\n+        (apply_schedule_map_to_scop): Same.\n+        (optimize_isl): Same.\n+\n 2015-09-10  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/63304"}, {"sha": "ea77fc7a163f806ce84d29eb82ee0d98759df83c", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 209, "deletions": 205, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec62c3731d43ad68536a6ce262df34a3f08e36a3/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec62c3731d43ad68536a6ce262df34a3f08e36a3/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=ec62c3731d43ad68536a6ce262df34a3f08e36a3", "patch": "@@ -50,6 +50,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"dumpfile.h\"\n \n+/* Set this to true to disable tiling of nested loops.  */\n+static bool disable_tiling = false;\n+\n static isl_union_set *\n scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n {\n@@ -64,163 +67,164 @@ scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n   return res;\n }\n \n-/* getTileMap - Create a map that describes a n-dimensonal tiling.\n-  \n-   getTileMap creates a map from a n-dimensional scattering space into an\n+/* get_tile_map - Create a map that describes a n-dimensonal tiling.\n+\n+   get_tile_map creates a map from a n-dimensional scattering space into an\n    2*n-dimensional scattering space. The map describes a rectangular tiling.\n-  \n+\n    Example:\n-     scheduleDimensions = 2, parameterDimensions = 1, tileSize = 32\n- \n-    tileMap := [p0] -> {[s0, s1] -> [t0, t1, s0, s1]:\n-                         t0 % 32 = 0 and t0 <= s0 < t0 + 32 and\n-                         t1 % 32 = 0 and t1 <= s1 < t1 + 32}\n- \n+     SCHEDULE_DIMENSIONS = 2, PARAMETER_DIMENSIONS = 1, TILE_SIZE = 32\n+\n+    tile_map := [p0] -> {[s0, s1] -> [t0, t1, s0, s1]:\n+\t\t\t t0 % 32 = 0 and t0 <= s0 < t0 + 32 and\n+\t\t\t t1 % 32 = 0 and t1 <= s1 < t1 + 32}\n+\n    Before tiling:\n- \n+\n    for (i = 0; i < N; i++)\n      for (j = 0; j < M; j++)\n- \tS(i,j)\n- \n+\tS(i,j)\n+\n    After tiling:\n- \n+\n    for (t_i = 0; t_i < N; i+=32)\n      for (t_j = 0; t_j < M; j+=32)\n- \tfor (i = t_i; i < min(t_i + 32, N); i++)  | Unknown that N % 32 = 0\n- \t  for (j = t_j; j < t_j + 32; j++)        |   Known that M % 32 = 0\n- \t    S(i,j)\n-   */\n- \n+\tfor (i = t_i; i < min(t_i + 32, N); i++)  | Unknown that N % 32 = 0\n+\t  for (j = t_j; j < t_j + 32; j++)        |   Known that M % 32 = 0\n+\t    S(i,j)\n+  */\n+\n static isl_basic_map *\n-getTileMap (isl_ctx *ctx, int scheduleDimensions, int tileSize)\n+get_tile_map (isl_ctx *ctx, int schedule_dimensions, int tile_size)\n {\n-  int x;\n   /* We construct\n \n-     tileMap := [p0] -> {[s0, s1] -> [t0, t1, p0, p1, a0, a1]:\n-    \t                s0 = a0 * 32 and s0 = p0 and t0 <= p0 < t0 + 32 and\n-    \t                s1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}\n+     tile_map := [p0] -> {[s0, s1] -> [t0, t1, p0, p1, a0, a1]:\n+\t\t\ts0 = a0 * 32 and s0 = p0 and t0 <= p0 < t0 + 32 and\n+\t\t\ts1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}\n \n      and project out the auxilary dimensions a0 and a1.  */\n-  isl_space *Space = isl_space_alloc (ctx, 0, scheduleDimensions,\n-\t\t\t\t      scheduleDimensions * 3);\n-  isl_basic_map *tileMap = isl_basic_map_universe (isl_space_copy (Space));\n+  isl_space *space\n+    = isl_space_alloc (ctx, 0, schedule_dimensions, schedule_dimensions * 3);\n+  isl_basic_map *tile_map = isl_basic_map_universe (isl_space_copy (space));\n \n-  isl_local_space *LocalSpace = isl_local_space_from_space (Space);\n+  isl_local_space *local_space = isl_local_space_from_space (space);\n \n-  for (x = 0; x < scheduleDimensions; x++)\n+  for (int x = 0; x < schedule_dimensions; x++)\n     {\n       int sX = x;\n       int tX = x;\n-      int pX = scheduleDimensions + x;\n-      int aX = 2 * scheduleDimensions + x;\n+      int pX = schedule_dimensions + x;\n+      int aX = 2 * schedule_dimensions + x;\n \n       isl_constraint *c;\n \n-      /* sX = aX * tileSize; */\n-      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      /* sX = aX * tile_size; */\n+      c = isl_equality_alloc (isl_local_space_copy (local_space));\n       isl_constraint_set_coefficient_si (c, isl_dim_out, sX, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, aX, -tileSize);\n-      tileMap = isl_basic_map_add_constraint (tileMap, c);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, aX, -tile_size);\n+      tile_map = isl_basic_map_add_constraint (tile_map, c);\n \n       /* pX = sX; */\n-      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      c = isl_equality_alloc (isl_local_space_copy (local_space));\n       isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n       isl_constraint_set_coefficient_si (c, isl_dim_in, sX, -1);\n-      tileMap = isl_basic_map_add_constraint (tileMap, c);\n+      tile_map = isl_basic_map_add_constraint (tile_map, c);\n \n       /* tX <= pX */\n-      c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+      c = isl_inequality_alloc (isl_local_space_copy (local_space));\n       isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n       isl_constraint_set_coefficient_si (c, isl_dim_out, tX, -1);\n-      tileMap = isl_basic_map_add_constraint (tileMap, c);\n+      tile_map = isl_basic_map_add_constraint (tile_map, c);\n \n-      /* pX <= tX + (tileSize - 1) */\n-      c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+      /* pX <= tX + (tile_size - 1) */\n+      c = isl_inequality_alloc (isl_local_space_copy (local_space));\n       isl_constraint_set_coefficient_si (c, isl_dim_out, tX, 1);\n       isl_constraint_set_coefficient_si (c, isl_dim_out, pX, -1);\n-      isl_constraint_set_constant_si (c, tileSize - 1);\n-      tileMap = isl_basic_map_add_constraint (tileMap, c);\n+      isl_constraint_set_constant_si (c, tile_size - 1);\n+      tile_map = isl_basic_map_add_constraint (tile_map, c);\n     }\n \n   /* Project out auxiliary dimensions.\n \n-     The auxiliary dimensions are transformed into existentially quantified ones.\n-     This reduces the number of visible scattering dimensions and allows Cloog\n+     The auxiliary dimensions are transformed into existentially quantified\n+     ones.\n+     This reduces the number of visible scattering dimensions and allows isl\n      to produces better code.  */\n-  tileMap = isl_basic_map_project_out (tileMap, isl_dim_out,\n-\t\t\t\t       2 * scheduleDimensions,\n-\t\t\t\t       scheduleDimensions);\n-  isl_local_space_free (LocalSpace);\n-  return tileMap;\n+  tile_map =\n+      isl_basic_map_project_out (tile_map, isl_dim_out,\n+\t\t\t\t 2 * schedule_dimensions, schedule_dimensions);\n+  isl_local_space_free (local_space);\n+  return tile_map;\n }\n \n-/* getScheduleForBand - Get the schedule for this band.\n-  \n-   Polly applies transformations like tiling on top of the isl calculated value.\n+/* get_schedule_for_band - Get the schedule for this BAND.\n+\n+   Polly applies transformations like tiling on top of the isl calculated\n+   value.\n    This can influence the number of scheduling dimension. The number of\n-   schedule dimensions is returned in the parameter 'Dimension'.  */\n-static bool DisableTiling = false;\n+   schedule dimensions is returned in DIMENSIONS.  */\n \n static isl_union_map *\n-getScheduleForBand (isl_band *Band, int *Dimensions)\n+get_schedule_for_band (isl_band *band, int *dimensions)\n {\n-  isl_union_map *PartialSchedule;\n+  isl_union_map *partial_schedule;\n   isl_ctx *ctx;\n-  isl_space *Space;\n-  isl_basic_map *TileMap;\n-  isl_union_map *TileUMap;\n+  isl_space *space;\n+  isl_basic_map *tile_map;\n+  isl_union_map *tile_umap;\n \n-  PartialSchedule = isl_band_get_partial_schedule (Band);\n-  *Dimensions = isl_band_n_member (Band);\n+  partial_schedule = isl_band_get_partial_schedule (band);\n+  *dimensions = isl_band_n_member (band);\n \n-  if (DisableTiling)\n-    return PartialSchedule;\n+  if (disable_tiling)\n+    return partial_schedule;\n \n   /* It does not make any sense to tile a band with just one dimension.  */\n-  if (*Dimensions == 1)\n+  if (*dimensions == 1)\n     {\n       if (dump_file && dump_flags)\n \tfprintf (dump_file, \"not tiled\\n\");\n-      return PartialSchedule;\n+      return partial_schedule;\n     }\n \n   if (dump_file && dump_flags)\n     fprintf (dump_file, \"tiled by %d\\n\",\n \t     PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n \n-  ctx = isl_union_map_get_ctx (PartialSchedule);\n-  Space = isl_union_map_get_space (PartialSchedule);\n+  ctx = isl_union_map_get_ctx (partial_schedule);\n+  space = isl_union_map_get_space (partial_schedule);\n \n-  TileMap = getTileMap (ctx, *Dimensions,\n-\t\t\tPARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n-  TileUMap = isl_union_map_from_map (isl_map_from_basic_map (TileMap));\n-  TileUMap = isl_union_map_align_params (TileUMap, Space);\n-  *Dimensions = 2 * *Dimensions;\n+  tile_map = get_tile_map (ctx, *dimensions,\n+\t\t\t   PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n+  tile_umap = isl_union_map_from_map (isl_map_from_basic_map (tile_map));\n+  tile_umap = isl_union_map_align_params (tile_umap, space);\n+  *dimensions = 2 * *dimensions;\n \n-  return isl_union_map_apply_range (PartialSchedule, TileUMap);\n+  return isl_union_map_apply_range (partial_schedule, tile_umap);\n }\n \n /* Create a map that pre-vectorizes one scheduling dimension.\n-  \n-   getPrevectorMap creates a map that maps each input dimension to the same\n-   output dimension, except for the dimension DimToVectorize. DimToVectorize is\n-   strip mined by 'VectorWidth' and the newly created point loop of\n-   DimToVectorize is moved to the innermost level.\n-  \n-   Example (DimToVectorize=0, ScheduleDimensions=2, VectorWidth=4):\n-  \n+\n+   get_prevector_map creates a map that maps each input dimension to the same\n+   output dimension, except for the dimension DIM_TO_VECTORIZE.\n+   DIM_TO_VECTORIZE is\n+   strip mined by 'VECTOR_WIDTH' and the newly created point loop of\n+   DIM_TO_VECTORIZE is moved to the innermost level.\n+\n+   Example (DIM_TO_VECTORIZE=0, SCHEDULE_DIMENSIONS=2,VECTOR_WIDTH=4):\n+\n    | Before transformation\n    |\n    | A[i,j] -> [i,j]\n    |\n    | for (i = 0; i < 128; i++)\n    |    for (j = 0; j < 128; j++)\n    |      A(i,j);\n-  \n+\n      Prevector map:\n      [i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n-  \n+\n    | After transformation:\n    |\n    | A[i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and i = ip\n@@ -229,170 +233,171 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n    |    for (j = 0; j < 128; j++)\n    |      for (ip = max(0,it); ip < min(128, it + 3); ip++)\n    |        A(ip,j);\n-  \n+\n    The goal of this transformation is to create a trivially vectorizable loop.\n    This means a parallel loop at the innermost level that has a constant number\n    of iterations corresponding to the target vector width.\n-  \n+\n    This transformation creates a loop at the innermost level. The loop has a\n    constant number of iterations, if the number of loop iterations at\n-   DimToVectorize can be devided by VectorWidth. The default VectorWidth is\n-   currently constant and not yet target specific. This function does not reason\n-   about parallelism.  */\n+   DIM_TO_VECTORIZE can be devided by VECTOR_WIDTH. The default VECTOR_WIDTH is\n+   currently constant and not yet target specific. This function does not\n+   reason about parallelism.  */\n static isl_map *\n-getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n-\t\t int ScheduleDimensions,\n-\t\t int VectorWidth)\n+get_prevector_map (isl_ctx *ctx, int dim_to_vectorize, int schedule_dimensions,\n+\t\t   int vector_width)\n {\n-  isl_space *Space;\n-  isl_local_space *LocalSpace, *LocalSpaceRange;\n-  isl_set *Modulo;\n-  isl_map *TilingMap;\n+  isl_space *space;\n+  isl_local_space *local_space, *local_space_range;\n+  isl_set *modulo;\n+  isl_map *tiling_map;\n   isl_constraint *c;\n-  isl_aff *Aff;\n-  int PointDimension; /* ip */\n-  int TileDimension;  /* it */\n-  isl_val *VectorWidthMP;\n+  isl_aff *aff;\n+  int point_dimension; /* ip */\n+  int tile_dimension;  /* it */\n+  isl_val *vector_widthMP;\n   int i;\n \n   /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n \n-  Space = isl_space_alloc (ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n-  TilingMap = isl_map_universe (isl_space_copy (Space));\n-  LocalSpace = isl_local_space_from_space (Space);\n-  PointDimension = ScheduleDimensions;\n-  TileDimension = DimToVectorize;\n+  space\n+    = isl_space_alloc (ctx, 0, schedule_dimensions, schedule_dimensions + 1);\n+  tiling_map = isl_map_universe (isl_space_copy (space));\n+  local_space = isl_local_space_from_space (space);\n+  point_dimension = schedule_dimensions;\n+  tile_dimension = dim_to_vectorize;\n \n   /* Create an identity map for everything except DimToVectorize and map\n      DimToVectorize to the point loop at the innermost dimension.  */\n-  for (i = 0; i < ScheduleDimensions; i++)\n+  for (i = 0; i < schedule_dimensions; i++)\n     {\n-      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+      c = isl_equality_alloc (isl_local_space_copy (local_space));\n       isl_constraint_set_coefficient_si (c, isl_dim_in, i, -1);\n \n-      if (i == DimToVectorize)\n-\tisl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n+      if (i == dim_to_vectorize)\n+\tisl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, 1);\n       else\n \tisl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n \n-      TilingMap = isl_map_add_constraint (TilingMap, c);\n+      tiling_map = isl_map_add_constraint (tiling_map, c);\n     }\n \n   /* it % 'VectorWidth' = 0  */\n-  LocalSpaceRange = isl_local_space_range (isl_local_space_copy (LocalSpace));\n-  Aff = isl_aff_zero_on_domain (LocalSpaceRange);\n-  Aff = isl_aff_set_constant_si (Aff, VectorWidth);\n-  Aff = isl_aff_set_coefficient_si (Aff, isl_dim_in, TileDimension, 1);\n+  local_space_range\n+    = isl_local_space_range (isl_local_space_copy (local_space));\n+  aff = isl_aff_zero_on_domain (local_space_range);\n+  aff = isl_aff_set_constant_si (aff, vector_width);\n+  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, tile_dimension, 1);\n \n-  VectorWidthMP = isl_val_int_from_si (ctx, VectorWidth);\n-  Aff = isl_aff_mod_val (Aff, VectorWidthMP);\n-  Modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (Aff));\n-  TilingMap = isl_map_intersect_range (TilingMap, Modulo);\n+  vector_widthMP = isl_val_int_from_si (ctx, vector_width);\n+  aff = isl_aff_mod_val (aff, vector_widthMP);\n+  modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (aff));\n+  tiling_map = isl_map_intersect_range (tiling_map, modulo);\n \n   /* it <= ip */\n-  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, -1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n+  c = isl_inequality_alloc (isl_local_space_copy (local_space));\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, tile_dimension, -1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, 1);\n+  tiling_map = isl_map_add_constraint (tiling_map, c);\n \n   /* ip <= it + ('VectorWidth' - 1) */\n-  c = isl_inequality_alloc (LocalSpace);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, 1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, -1);\n-  isl_constraint_set_constant_si (c, VectorWidth - 1);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n+  c = isl_inequality_alloc (local_space);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, tile_dimension, 1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, point_dimension, -1);\n+  isl_constraint_set_constant_si (c, vector_width - 1);\n+  tiling_map = isl_map_add_constraint (tiling_map, c);\n \n-  return TilingMap;\n+  return tiling_map;\n }\n \n-static bool EnablePollyVector = false;\n+static bool enable_polly_vector = false;\n \n-/* getScheduleForBandList - Get the scheduling map for a list of bands.\n+/* get_schedule_for_band_list - Get the scheduling map for a list of bands.\n \n    We walk recursively the forest of bands to combine the schedules of the\n-   individual bands to the overall schedule. In case tiling is requested,\n+   individual bands to the overall schedule.  In case tiling is requested,\n    the individual bands are tiled.  */\n static isl_union_map *\n-getScheduleForBandList (isl_band_list *BandList)\n+get_schedule_for_band_list (isl_band_list *band_list)\n {\n-  int NumBands, i;\n-  isl_union_map *Schedule;\n+  int num_bands, i;\n+  isl_union_map *schedule;\n   isl_ctx *ctx;\n \n-  ctx = isl_band_list_get_ctx (BandList);\n-  NumBands = isl_band_list_n_band (BandList);\n-  Schedule = isl_union_map_empty (isl_space_params_alloc (ctx, 0));\n+  ctx = isl_band_list_get_ctx (band_list);\n+  num_bands = isl_band_list_n_band (band_list);\n+  schedule = isl_union_map_empty (isl_space_params_alloc (ctx, 0));\n \n-  for (i = 0; i < NumBands; i++)\n+  for (i = 0; i < num_bands; i++)\n     {\n-      isl_band *Band;\n-      isl_union_map *PartialSchedule;\n-      int ScheduleDimensions;\n-      isl_space *Space;\n+      isl_band *band;\n+      isl_union_map *partial_schedule;\n+      int schedule_dimensions;\n+      isl_space *space;\n \n-      Band = isl_band_list_get_band (BandList, i);\n-      PartialSchedule = getScheduleForBand (Band, &ScheduleDimensions);\n-      Space = isl_union_map_get_space (PartialSchedule);\n+      band = isl_band_list_get_band (band_list, i);\n+      partial_schedule = get_schedule_for_band (band, &schedule_dimensions);\n+      space = isl_union_map_get_space (partial_schedule);\n \n-      if (isl_band_has_children (Band))\n+      if (isl_band_has_children (band))\n \t{\n-\t  isl_band_list *Children;\n-\t  isl_union_map *SuffixSchedule;\n-\n-\t  Children = isl_band_get_children (Band);\n-\t  SuffixSchedule = getScheduleForBandList (Children);\n-\t  PartialSchedule = isl_union_map_flat_range_product (PartialSchedule,\n-\t\t\t\t\t\t\t      SuffixSchedule);\n-\t  isl_band_list_free (Children);\n+\t  isl_band_list *children = isl_band_get_children (band);\n+\t  isl_union_map *suffixSchedule\n+\t    = get_schedule_for_band_list (children);\n+\t  partial_schedule\n+\t    = isl_union_map_flat_range_product (partial_schedule,\n+\t\t\t\t\t\tsuffixSchedule);\n+\t  isl_band_list_free (children);\n \t}\n-      else if (EnablePollyVector)\n+      else if (enable_polly_vector)\n \t{\n-\t  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)\n+\t  for (i = schedule_dimensions - 1; i >= 0; i--)\n \t    {\n #ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE\n-\t      if (isl_band_member_is_coincident (Band, i))\n+\t      if (isl_band_member_is_coincident (band, i))\n #else\n-\t      if (isl_band_member_is_zero_distance (Band, i))\n+\t      if (isl_band_member_is_zero_distance (band, i))\n #endif\n \t\t{\n-\t\t  isl_map *TileMap;\n-\t\t  isl_union_map *TileUMap;\n-\n-\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, 4);\n-\t\t  TileUMap = isl_union_map_from_map (TileMap);\n-\t\t  TileUMap = isl_union_map_align_params\n-\t\t    (TileUMap, isl_space_copy (Space));\n-\t\t  PartialSchedule = isl_union_map_apply_range\n-\t\t    (PartialSchedule, TileUMap);\n+\t\t  /* FIXME: The default VECTOR_WIDTH is currently constant and\n+\t\t   * not yet target specific.  */\n+\t\t  isl_map *tile_map\n+\t\t    = get_prevector_map (ctx, i, schedule_dimensions, 4);\n+\t\t  isl_union_map *tile_umap = isl_union_map_from_map (tile_map);\n+\t\t  tile_umap\n+\t\t    = isl_union_map_align_params (tile_umap,\n+\t\t\t\t\t\t  isl_space_copy (space));\n+\t\t  partial_schedule\n+\t\t    = isl_union_map_apply_range (partial_schedule,\n+\t\t\t\t\t\t tile_umap);\n \t\t  break;\n-\t\t}\t\n+\t\t}\n \t    }\n \t}\n \n-      Schedule = isl_union_map_union (Schedule, PartialSchedule);\n+      schedule = isl_union_map_union (schedule, partial_schedule);\n \n-      isl_band_free (Band);\n-      isl_space_free (Space);\n+      isl_band_free (band);\n+      isl_space_free (space);\n     }\n \n-  return Schedule;\n+  return schedule;\n }\n \n static isl_union_map *\n-getScheduleMap (isl_schedule *Schedule)\n+get_schedule_map (isl_schedule *schedule)\n {\n-  isl_band_list *BandList = isl_schedule_get_band_forest (Schedule);\n-  isl_union_map *ScheduleMap = getScheduleForBandList (BandList);\n-  isl_band_list_free (BandList);\n-  return ScheduleMap;\n+  isl_band_list *bandList = isl_schedule_get_band_forest (schedule);\n+  isl_union_map *schedule_map = get_schedule_for_band_list (bandList);\n+  isl_band_list_free (bandList);\n+  return schedule_map;\n }\n \n static isl_stat\n-getSingleMap (__isl_take isl_map *map, void *user)\n+get_single_map (__isl_take isl_map *map, void *user)\n {\n-  isl_map **singleMap = (isl_map **) user;\n-  *singleMap = map;\n-\n+  isl_map **single_map = (isl_map **)user;\n+  *single_map = map;\n   return isl_stat_ok;\n }\n \n@@ -405,16 +410,15 @@ apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n   FOR_EACH_VEC_ELT (scop->bbs, i, pbb)\n     {\n       isl_set *domain = isl_set_copy (pbb->domain);\n-      isl_union_map *stmtBand;\n-      isl_map *stmtSchedule;\n+      isl_map *stmt_schedule;\n \n-      stmtBand = isl_union_map_intersect_domain\n-\t(isl_union_map_copy (schedule_map),\n-\t isl_union_set_from_set (domain));\n-      isl_union_map_foreach_map (stmtBand, getSingleMap, &stmtSchedule);\n+      isl_union_map *stmt_band\n+\t= isl_union_map_intersect_domain (isl_union_map_copy (schedule_map),\n+\t\t\t\t\t  isl_union_set_from_set (domain));\n+      isl_union_map_foreach_map (stmt_band, get_single_map, &stmt_schedule);\n       isl_map_free (pbb->transformed);\n-      pbb->transformed = stmtSchedule;\n-      isl_union_map_free (stmtBand);\n+      pbb->transformed = stmt_schedule;\n+      isl_union_map_free (stmt_band);\n     }\n }\n \n@@ -424,34 +428,34 @@ bool\n optimize_isl (scop_p scop)\n {\n #ifdef HAVE_ISL_CTX_MAX_OPERATIONS\n-  int old_max_operations = isl_ctx_get_max_operations(scop->ctx);\n+  int old_max_operations = isl_ctx_get_max_operations (scop->ctx);\n   int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n   if (max_operations)\n-    isl_ctx_set_max_operations(scop->ctx, max_operations);\n+    isl_ctx_set_max_operations (scop->ctx, max_operations);\n #endif\n   isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_CONTINUE);\n \n   isl_union_set *domain = scop_get_domains (scop);\n   isl_union_map *dependences = scop_get_dependences (scop);\n-  dependences = isl_union_map_gist_domain (dependences,\n-\t\t\t\t\t   isl_union_set_copy (domain));\n-  dependences = isl_union_map_gist_range (dependences,\n-\t\t\t\t\t  isl_union_set_copy (domain));\n+  dependences\n+    = isl_union_map_gist_domain (dependences, isl_union_set_copy (domain));\n+  dependences\n+    = isl_union_map_gist_range (dependences, isl_union_set_copy (domain));\n   isl_union_map *validity = dependences;\n   isl_union_map *proximity = isl_union_map_copy (validity);\n \n #ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE\n   isl_schedule_constraints *schedule_constraints;\n   schedule_constraints = isl_schedule_constraints_on_domain (domain);\n   schedule_constraints\n-\t= isl_schedule_constraints_set_proximity (schedule_constraints,\n-\t\t\t\t\t\t  proximity);\n+    = isl_schedule_constraints_set_proximity (schedule_constraints,\n+\t\t\t\t\t      proximity);\n   schedule_constraints\n-\t= isl_schedule_constraints_set_validity (schedule_constraints,\n-\t\t\t\t\t\t isl_union_map_copy (validity));\n+    = isl_schedule_constraints_set_validity (schedule_constraints,\n+\t\t\t\t\t     isl_union_map_copy (validity));\n   schedule_constraints\n-\t= isl_schedule_constraints_set_coincidence (schedule_constraints,\n-\t\t\t\t\t\t    validity);\n+    = isl_schedule_constraints_set_coincidence (schedule_constraints,\n+\t\t\t\t\t\tvalidity);\n #endif\n \n   isl_options_set_schedule_max_constant_term (scop->ctx, CONSTANT_BOUND);\n@@ -473,8 +477,8 @@ optimize_isl (scop_p scop)\n   isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_ABORT);\n \n #ifdef HAVE_ISL_CTX_MAX_OPERATIONS\n-  isl_ctx_reset_operations(scop->ctx);\n-  isl_ctx_set_max_operations(scop->ctx, old_max_operations);\n+  isl_ctx_reset_operations (scop->ctx);\n+  isl_ctx_set_max_operations (scop->ctx, old_max_operations);\n   if (!schedule || isl_ctx_last_error (scop->ctx) == isl_error_quota)\n     {\n       if (dump_file && dump_flags)\n@@ -489,12 +493,12 @@ optimize_isl (scop_p scop)\n     return false;\n #endif\n \n-  isl_union_map *schedule_map = getScheduleMap (schedule);\n+  isl_union_map *schedule_map = get_schedule_map (schedule);\n   apply_schedule_map_to_scop (scop, schedule_map);\n \n   isl_schedule_free (schedule);\n   isl_union_map_free (schedule_map);\n   return true;\n }\n \n-#endif  /* HAVE_isl */\n+#endif /* HAVE_isl */"}]}