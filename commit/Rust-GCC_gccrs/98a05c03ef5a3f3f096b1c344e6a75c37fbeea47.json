{"sha": "98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThhMDVjMDNlZjVhM2YzZjA5NmIxYzM0NGU2YTc1YzM3ZmJlZWE0Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-08T13:50:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-08T13:50:16Z"}, "message": "Simplify LRA lowpart subreg fix\n\nr257177 made the else arms equivalent to the if arms.\n\n2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* lra-constraints.c (match_reload): Unconditionally use\n\tgen_lowpart_SUBREG, rather than selecting between that\n\tand equivalent gen_rtx_SUBREG code.\n\nFrom-SVN: r257488", "tree": {"sha": "0f6138e84d1f358923093b678c93c6701a28dcf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f6138e84d1f358923093b678c93c6701a28dcf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47/comments", "author": null, "committer": null, "parents": [{"sha": "24db2556253540529a7b11ed42683b2ea9bb8989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24db2556253540529a7b11ed42683b2ea9bb8989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24db2556253540529a7b11ed42683b2ea9bb8989"}], "stats": {"total": 22, "additions": 8, "deletions": 14}, "files": [{"sha": "803e0305c2a9f8ea4605ec6033559251ce659f92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "patch": "@@ -1,3 +1,9 @@\n+2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lra-constraints.c (match_reload): Unconditionally use\n+\tgen_lowpart_SUBREG, rather than selecting between that\n+\tand equivalent gen_rtx_SUBREG code.\n+\n 2018-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84233"}, {"sha": "125bbb6c02b6a809370231aa6d78a7d459316f1a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "patch": "@@ -942,13 +942,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t  reg = new_in_reg\n \t    = lra_create_new_reg_with_unique_value (inmode, in_rtx,\n \t\t\t\t\t\t    goal_class, \"\");\n-\t  if (SCALAR_INT_MODE_P (inmode))\n-\t    new_out_reg = gen_lowpart_SUBREG (outmode, reg);\n-\t  else\n-\t    {\n-\t      poly_uint64 offset = subreg_lowpart_offset (outmode, inmode);\n-\t      new_out_reg = gen_rtx_SUBREG (outmode, reg, offset);\n-\t    }\n+\t  new_out_reg = gen_lowpart_SUBREG (outmode, reg);\n \t  LRA_SUBREG_P (new_out_reg) = 1;\n \t  /* If the input reg is dying here, we can use the same hard\n \t     register for REG and IN_RTX.  We do it only for original\n@@ -965,13 +959,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t  reg = new_out_reg\n \t    = lra_create_new_reg_with_unique_value (outmode, out_rtx,\n \t\t\t\t\t\t    goal_class, \"\");\n-\t  if (SCALAR_INT_MODE_P (outmode))\n-\t    new_in_reg = gen_lowpart_SUBREG (inmode, reg);\n-\t  else\n-\t    {\n-\t      poly_uint64 offset = subreg_lowpart_offset (inmode, outmode);\n-\t      new_in_reg = gen_rtx_SUBREG (inmode, reg, offset);\n-\t    }\n+\t  new_in_reg = gen_lowpart_SUBREG (inmode, reg);\n \t  /* NEW_IN_REG is non-paradoxical subreg.  We don't want\n \t     NEW_OUT_REG living above.  We add clobber clause for\n \t     this.  This is just a temporary clobber.  We can remove"}]}