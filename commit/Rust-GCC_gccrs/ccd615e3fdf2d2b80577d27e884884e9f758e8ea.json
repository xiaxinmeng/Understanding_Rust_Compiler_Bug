{"sha": "ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NkNjE1ZTNmZGYyZDJiODA1NzdkMjdlODg0ODg0ZTlmNzU4ZThlYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-10-31T20:49:40Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-10-31T20:49:40Z"}, "message": "Make std::vector<bool> meet C++11 allocator requirements.\n\n\t* include/bits/stl_bvector.h (_Bvector_base): Use allocator_traits.\n\t(_Bvector_base::_Bvector_impl): Use allocator's pointer type.\n\t(_Bvector_base::_M_end_addr()): Convert to raw pointer.\n\t(vector<bool>): Use allocator_traits and _M_end_addr. Add allocator\n\textended constructors.\n\t* include/bits/vector.tcc (vector<bool>): Use allocator_traits and\n\t_M_end_addr.\n\t* testsuite/23_containers/vector/bool/allocator/copy.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/minimal.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/move.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/swap.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/ext_ptr.cc: New.\n\t* testsuite/23_containers/vector/bool/allocator/move_assign.cc: New.\n\nFrom-SVN: r216988", "tree": {"sha": "b2e6ecad35b86d5807204670bcf8e10569378ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2e6ecad35b86d5807204670bcf8e10569378ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ccb17b4c47e4c43367cc78059d5deac32672de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccb17b4c47e4c43367cc78059d5deac32672de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccb17b4c47e4c43367cc78059d5deac32672de8"}], "stats": {"total": 703, "additions": 650, "deletions": 53}, "files": [{"sha": "d24f3a3e9a589465e0e7a5994fe306f234ccf2b1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -1,3 +1,21 @@\n+2014-10-31  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/stl_bvector.h (_Bvector_base): Use allocator_traits.\n+\t(_Bvector_base::_Bvector_impl): Use allocator's pointer type.\n+\t(_Bvector_base::_M_end_addr()): Convert to raw pointer.\n+\t(vector<bool>): Use allocator_traits and _M_end_addr. Add allocator\n+\textended constructors.\n+\t* include/bits/vector.tcc (vector<bool>): Use allocator_traits and\n+\t_M_end_addr.\n+\t* testsuite/23_containers/vector/bool/allocator/copy.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/move.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/swap.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/ext_ptr.cc: New.\n+\t* testsuite/23_containers/vector/bool/allocator/move_assign.cc: New.\n+\n 2014-10-30  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure.host (aix5+): New stanza."}, {"sha": "c93b96c864f9d1596d387b89d512433973c8c94e", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 117, "deletions": 36, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -410,30 +410,41 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Alloc>\n     struct _Bvector_base\n     {\n-      typedef typename _Alloc::template rebind<_Bit_type>::other\n-        _Bit_alloc_type;\n-      \n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+        rebind<_Bit_type>::other _Bit_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>\n+\t_Bit_alloc_traits;\n+      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;\n+\n       struct _Bvector_impl\n       : public _Bit_alloc_type\n       {\n \t_Bit_iterator \t_M_start;\n \t_Bit_iterator \t_M_finish;\n-\t_Bit_type* \t_M_end_of_storage;\n+\t_Bit_pointer \t_M_end_of_storage;\n \n \t_Bvector_impl()\n-\t: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)\n+\t: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n  \n \t_Bvector_impl(const _Bit_alloc_type& __a)\n-\t: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)\n+\t: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n \t_Bvector_impl(_Bit_alloc_type&& __a)\n \t: _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),\n-\t  _M_end_of_storage(0)\n+\t  _M_end_of_storage()\n \t{ }\n #endif\n+\n+\t_Bit_type*\n+\t_M_end_addr() const _GLIBCXX_NOEXCEPT\n+\t{\n+\t  if (_M_end_of_storage)\n+\t    return std::__addressof(_M_end_of_storage[-1]) + 1;\n+\t  return 0;\n+\t}\n       };\n \n     public:\n@@ -466,7 +477,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tthis->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n \t__x._M_impl._M_start = _Bit_iterator();\n \t__x._M_impl._M_finish = _Bit_iterator();\n-\t__x._M_impl._M_end_of_storage = 0;\n+\t__x._M_impl._M_end_of_storage = nullptr;\n       }\n #endif\n \n@@ -476,16 +487,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     protected:\n       _Bvector_impl _M_impl;\n \n-      _Bit_type*\n+      _Bit_pointer\n       _M_allocate(size_t __n)\n-      { return _M_impl.allocate(_S_nword(__n)); }\n+      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }\n \n       void\n       _M_deallocate()\n       {\n \tif (_M_impl._M_start._M_p)\n-\t  _M_impl.deallocate(_M_impl._M_start._M_p,\n-\t\t\t     _M_impl._M_end_of_storage - _M_impl._M_start._M_p);\n+\t  {\n+\t    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;\n+\t    _Bit_alloc_traits::deallocate(_M_impl,\n+\t\t\t\t\t  _M_impl._M_end_of_storage - __n,\n+\t\t\t\t\t  __n);\n+\t  }\n       }\n \n       static size_t\n@@ -526,6 +541,8 @@ template<typename _Alloc>\n   class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>\n   {\n     typedef _Bvector_base<_Alloc>\t\t\t _Base;\n+    typedef typename _Base::_Bit_pointer\t\t _Bit_pointer;\n+    typedef typename _Base::_Bit_alloc_traits\t\t _Bit_alloc_traits;\n \n #if __cplusplus >= 201103L\n     template<typename> friend struct hash;\n@@ -573,7 +590,7 @@ template<typename _Alloc>\n     : _Base(__a)\n     {\n       _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, \n+      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),\n \t\t__value ? ~0 : 0);\n     }\n #else\n@@ -583,13 +600,13 @@ template<typename _Alloc>\n     : _Base(__a)\n     {\n       _M_initialize(__n);\n-      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, \n+      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),\n \t\t__value ? ~0 : 0);\n     }\n #endif\n \n     vector(const vector& __x)\n-    : _Base(__x._M_get_Bit_allocator())\n+    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))\n     {\n       _M_initialize(__x.size());\n       _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n@@ -599,6 +616,34 @@ template<typename _Alloc>\n     vector(vector&& __x) noexcept\n     : _Base(std::move(__x)) { }\n \n+    vector(vector&& __x, const allocator_type& __a)\n+    noexcept(_Bit_alloc_traits::_S_always_equal())\n+    : _Base(__a)\n+    {\n+      if (__x.get_allocator() == __a)\n+\t{\n+\t  this->_M_impl._M_start = __x._M_impl._M_start;\n+\t  this->_M_impl._M_finish = __x._M_impl._M_finish;\n+\t  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n+\t  __x._M_impl._M_start = _Bit_iterator();\n+\t  __x._M_impl._M_finish = _Bit_iterator();\n+\t  __x._M_impl._M_end_of_storage = nullptr;\n+\t}\n+      else\n+\t{\n+\t  _M_initialize(__x.size());\n+\t  _M_copy_aligned(__x.begin(), __x.end(), begin());\n+\t  __x.clear();\n+\t}\n+    }\n+\n+    vector(const vector& __x, const allocator_type& __a)\n+    : _Base(__a)\n+    {\n+      _M_initialize(__x.size());\n+      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);\n+    }\n+\n     vector(initializer_list<bool> __l,\n \t   const allocator_type& __a = allocator_type())\n     : _Base(__a)\n@@ -633,6 +678,21 @@ template<typename _Alloc>\n     {\n       if (&__x == this)\n \treturn *this;\n+#if __cplusplus >= 201103L\n+      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())\n+\t{\n+\t  if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())\n+\t    {\n+\t      this->_M_deallocate();\n+\t      std::__alloc_on_copy(_M_get_Bit_allocator(),\n+\t\t\t\t   __x._M_get_Bit_allocator());\n+\t      _M_initialize(__x.size());\n+\t    }\n+\t  else\n+\t    std::__alloc_on_copy(_M_get_Bit_allocator(),\n+\t\t\t\t __x._M_get_Bit_allocator());\n+\t}\n+#endif\n       if (__x.size() > capacity())\n \t{\n \t  this->_M_deallocate();\n@@ -645,12 +705,32 @@ template<typename _Alloc>\n \n #if __cplusplus >= 201103L\n     vector&\n-    operator=(vector&& __x)\n+    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())\n     {\n-      // NB: DR 1204.\n-      // NB: DR 675.\n-      this->clear();\n-      this->swap(__x); \n+      if (_Bit_alloc_traits::_S_propagate_on_move_assign()\n+\t  || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())\n+\t{\n+\t  this->_M_deallocate();\n+\t  this->_M_impl._M_start = __x._M_impl._M_start;\n+\t  this->_M_impl._M_finish = __x._M_impl._M_finish;\n+\t  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;\n+\t  __x._M_impl._M_start = _Bit_iterator();\n+\t  __x._M_impl._M_finish = _Bit_iterator();\n+\t  __x._M_impl._M_end_of_storage = nullptr;\n+\t  std::__alloc_on_move(_M_get_Bit_allocator(),\n+\t\t\t       __x._M_get_Bit_allocator());\n+\t}\n+      else\n+\t{\n+\t  if (__x.size() > capacity())\n+\t    {\n+\t      this->_M_deallocate();\n+\t      _M_initialize(__x.size());\n+\t    }\n+\t  this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),\n+\t\t\t\t\t\t    begin());\n+\t  __x.clear();\n+\t}\n       return *this;\n     }\n \n@@ -752,14 +832,15 @@ template<typename _Alloc>\n       const size_type __isize =\n \t__gnu_cxx::__numeric_traits<difference_type>::__max\n \t- int(_S_word_bit) + 1;\n-      const size_type __asize = _M_get_Bit_allocator().max_size();\n+      const size_type __asize\n+\t= _Bit_alloc_traits::max_size(_M_get_Bit_allocator());\n       return (__asize <= __isize / int(_S_word_bit)\n \t      ? __asize * int(_S_word_bit) : __isize);\n     }\n \n     size_type\n     capacity() const _GLIBCXX_NOEXCEPT\n-    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)\n+    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)\n \t\t       - begin()); }\n \n     bool\n@@ -836,24 +917,24 @@ template<typename _Alloc>\n     void\n     push_back(bool __x)\n     {\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n         *this->_M_impl._M_finish++ = __x;\n       else\n         _M_insert_aux(end(), __x);\n     }\n \n     void\n     swap(vector& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Bit_alloc_traits::_S_nothrow_swap())\n+#endif\n     {\n       std::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n       std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n       std::swap(this->_M_impl._M_end_of_storage, \n \t\t__x._M_impl._M_end_of_storage);\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 431. Swapping containers with unequal allocators.\n-      std::__alloc_swap<typename _Base::_Bit_alloc_type>::\n-\t_S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());\n+      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),\n+\t\t\t\t    __x._M_get_Bit_allocator());\n     }\n \n     // [23.2.5]/1, third-to-last entry in synopsis listing\n@@ -873,7 +954,7 @@ template<typename _Alloc>\n #endif\n     {\n       const difference_type __n = __position - begin();\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()\n \t  && __position == end())\n         *this->_M_impl._M_finish++ = __x;\n       else\n@@ -962,8 +1043,8 @@ template<typename _Alloc>\n     void\n     flip() _GLIBCXX_NOEXCEPT\n     {\n-      for (_Bit_type * __p = this->_M_impl._M_start._M_p;\n-\t   __p != this->_M_impl._M_end_of_storage; ++__p)\n+      _Bit_type * const __end = this->_M_impl._M_end_addr();\n+      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)\n         *__p = ~*__p;\n     }\n \n@@ -997,9 +1078,9 @@ template<typename _Alloc>\n     void\n     _M_initialize(size_type __n)\n     {\n-      _Bit_type* __q = this->_M_allocate(__n);\n+      _Bit_pointer __q = this->_M_allocate(__n);\n       this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n-      this->_M_impl._M_start = iterator(__q, 0);\n+      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);\n       this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);\n     }\n \n@@ -1021,7 +1102,7 @@ template<typename _Alloc>\n       {\n \t_M_initialize(static_cast<size_type>(__n));\n \tstd::fill(this->_M_impl._M_start._M_p, \n-\t\t  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+\t\t  this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n       }\n \n     template<typename _InputIterator>\n@@ -1069,14 +1150,14 @@ template<typename _Alloc>\n       if (__n > size())\n \t{\n \t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+\t\t    this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n \t  insert(end(), __n - size(), __x);\n \t}\n       else\n \t{\n \t  _M_erase_at_end(begin() + __n);\n \t  std::fill(this->_M_impl._M_start._M_p, \n-\t\t    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);\n+\t\t    this->_M_impl._M_end_addr(), __x ? ~0 : 0);\n \t}\n     }\n "}, {"sha": "229fa6d6822b83398adde204d1e3ea20c9dc3255", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -699,11 +699,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     vector<bool, _Alloc>::\n     _M_reallocate(size_type __n)\n     {\n-      _Bit_type* __q = this->_M_allocate(__n);\n-      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),\n-\t\t\t\t\t\titerator(__q, 0));\n+      _Bit_pointer __q = this->_M_allocate(__n);\n+      iterator __start(std::__addressof(*__q), 0);\n+      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);\n       this->_M_deallocate();\n-      this->_M_impl._M_start = iterator(__q, 0);\n+      this->_M_impl._M_start = __start;\n       this->_M_impl._M_end_of_storage = __q + _S_nword(__n);\n     }\n \n@@ -725,15 +725,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t{\n \t  const size_type __len = \n \t    _M_check_len(__n, \"vector<bool>::_M_fill_insert\");\n-\t  _Bit_type * __q = this->_M_allocate(__len);\n-\t  iterator __i = _M_copy_aligned(begin(), __position,\n-\t\t\t\t\t iterator(__q, 0));\n+\t  _Bit_pointer __q = this->_M_allocate(__len);\n+\t  iterator __start(std::__addressof(*__q), 0);\n+\t  iterator __i = _M_copy_aligned(begin(), __position, __start);\n \t  std::fill(__i, __i + difference_type(__n), __x);\n \t  this->_M_impl._M_finish = std::copy(__position, end(),\n \t\t\t\t\t      __i + difference_type(__n));\n \t  this->_M_deallocate();\n \t  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);\n-\t  this->_M_impl._M_start = iterator(__q, 0);\n+\t  this->_M_impl._M_start = __start;\n \t}\n     }\n \n@@ -759,14 +759,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t      {\n \t\tconst size_type __len =\n \t\t  _M_check_len(__n, \"vector<bool>::_M_insert_range\");\n-\t\t_Bit_type * __q = this->_M_allocate(__len);\n-\t\titerator __i = _M_copy_aligned(begin(), __position,\n-\t\t\t\t\t       iterator(__q, 0));\n+\t\t_Bit_pointer __q = this->_M_allocate(__len);\n+\t\titerator __start(std::__addressof(*__q), 0);\n+\t\titerator __i = _M_copy_aligned(begin(), __position, __start);\n \t\t__i = std::copy(__first, __last, __i);\n \t\tthis->_M_impl._M_finish = std::copy(__position, end(), __i);\n \t\tthis->_M_deallocate();\n \t\tthis->_M_impl._M_end_of_storage = __q + _S_nword(__len);\n-\t\tthis->_M_impl._M_start = iterator(__q, 0);\n+\t\tthis->_M_impl._M_start = __start;\n \t      }\n \t  }\n       }\n@@ -776,7 +776,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     vector<bool, _Alloc>::\n     _M_insert_aux(iterator __position, bool __x)\n     {\n-      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)\n+      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())\n \t{\n \t  std::copy_backward(__position, this->_M_impl._M_finish, \n \t\t\t     this->_M_impl._M_finish + 1);\n@@ -787,14 +787,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t{\n \t  const size_type __len =\n \t    _M_check_len(size_type(1), \"vector<bool>::_M_insert_aux\");\n-\t  _Bit_type * __q = this->_M_allocate(__len);\n-\t  iterator __i = _M_copy_aligned(begin(), __position,\n-\t\t\t\t\t iterator(__q, 0));\n+\t  _Bit_pointer __q = this->_M_allocate(__len);\n+\t  iterator __start(std::__addressof(*__q), 0);\n+\t  iterator __i = _M_copy_aligned(begin(), __position, __start);\n \t  *__i++ = __x;\n \t  this->_M_impl._M_finish = std::copy(__position, end(), __i);\n \t  this->_M_deallocate();\n \t  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);\n-\t  this->_M_impl._M_start = iterator(__q, 0);\n+\t  this->_M_impl._M_start = __start;\n \t}\n     }\n "}, {"sha": "7bd0b9898cdf06f1386a64381d59be93f90dd089", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/copy.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "eac6b431c9fe89447984b9854de0ed7e8ea418f7", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/copy_assign.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fcopy_assign.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "94087be95bf64e6cd72a66f5c1920ed39a25c7ca", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/ext_ptr.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fext_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fext_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fext_ptr.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::CustomPointerAlloc;\n+\n+template class std::vector<T, CustomPointerAlloc<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef CustomPointerAlloc<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v;\n+  v.push_back(T());\n+  VERIFY( ++v.begin() == v.end() );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "56d88b08142a552ece3a922470935e210e5c6f35", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/minimal.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fminimal.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <vector>\n+#include <memory>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::vector<T, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.push_back(T());\n+}"}, {"sha": "c6afcd318da4dc158875278873b18c71231a1737", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/move.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  auto it = v1.begin();\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "da95498f9a221c2a5c103744431553b42704aa82", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/move_assign.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fmove_assign.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  auto it = v1.begin();\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  v2 = std::move(v1);\n+  VERIFY( it == v2.begin() );\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  auto it = v1.begin();\n+  test_type v2(alloc_type(1));\n+  v2.push_back(T());\n+  v2 = std::move(v1);\n+  VERIFY( it == v2.begin() );\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "e86e6b205b8267b7e309014ffbb3935513313987", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/noexcept.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fnoexcept.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+namespace __gnu_test\n+{\n+  template<typename U>\n+    inline void\n+    swap(propagating_allocator<U, true>& l, propagating_allocator<U, true>& r)\n+    noexcept(false)\n+    { }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}"}, {"sha": "cedb24f5ab28a4800f334aee334985153cdf168c", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/allocator/swap.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccd615e3fdf2d2b80577d27e884884e9f758e8ea/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fallocator%2Fswap.cc?ref=ccd615e3fdf2d2b80577d27e884884e9f758e8ea", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using T = bool;\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_back(T());\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}