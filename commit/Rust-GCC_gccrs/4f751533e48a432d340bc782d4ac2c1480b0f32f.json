{"sha": "4f751533e48a432d340bc782d4ac2c1480b0f32f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY3NTE1MzNlNDhhNDMyZDM0MGJjNzgyZDRhYzJjMTQ4MGIwZjMyZg==", "commit": {"author": {"name": "Ziga Mahkovec", "email": "ziga.mahkovec@klika.si", "date": "2005-05-16T19:01:52Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-05-16T19:01:52Z"}, "message": "re PR libgcj/20504 (java.util.regex implementation doesn't support quoting constructs)\n\n2005-05-16  Ziga Mahkovec  <ziga.mahkovec@klika.si>\n\n\tPR libgcj/20504\n\tgnu/regexp/RE.java: Add support for quoting constructs.\n\nFrom-SVN: r99789", "tree": {"sha": "ddebf04c18f258d53ea87dcadcea6961becbdfc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddebf04c18f258d53ea87dcadcea6961becbdfc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f751533e48a432d340bc782d4ac2c1480b0f32f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f751533e48a432d340bc782d4ac2c1480b0f32f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f751533e48a432d340bc782d4ac2c1480b0f32f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f751533e48a432d340bc782d4ac2c1480b0f32f/comments", "author": null, "committer": null, "parents": [{"sha": "bbf6f1cf02a65c8f2d9fdca2c04025f46190eaa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf6f1cf02a65c8f2d9fdca2c04025f46190eaa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf6f1cf02a65c8f2d9fdca2c04025f46190eaa2"}], "stats": {"total": 59, "additions": 38, "deletions": 21}, "files": [{"sha": "1b35743c61ee643a01eb20e0a978812de7bb9781", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f751533e48a432d340bc782d4ac2c1480b0f32f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f751533e48a432d340bc782d4ac2c1480b0f32f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4f751533e48a432d340bc782d4ac2c1480b0f32f", "patch": "@@ -1,3 +1,8 @@\n+2005-05-16  Ziga Mahkovec  <ziga.mahkovec@klika.si>\n+\n+\tPR libgcj/20504\n+\tgnu/regexp/RE.java: Add support for quoting constructs.\n+\n 2005-05-15  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/String.java (startsWith): Fixed javadoc."}, {"sha": "c8c8a3eb9ff0dc700e226648ec6a9bd783ea9b03", "filename": "libjava/gnu/regexp/RE.java", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f751533e48a432d340bc782d4ac2c1480b0f32f/libjava%2Fgnu%2Fregexp%2FRE.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f751533e48a432d340bc782d4ac2c1480b0f32f/libjava%2Fgnu%2Fregexp%2FRE.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fregexp%2FRE.java?ref=4f751533e48a432d340bc782d4ac2c1480b0f32f", "patch": "@@ -331,19 +331,31 @@ protected void initialize(Object patternObj, int cflags, RESyntax syntax, int my\n     // Buffer a token so we can create a TokenRepeated, etc.\n     REToken currentToken = null;\n     char ch;\n+    boolean quot = false;\n \n     while (index < pLength) {\n       // read the next character unit (including backslash escapes)\n-      index = getCharUnit(pattern,index,unit);\n+      index = getCharUnit(pattern,index,unit,quot);\n+\n+      if (unit.bk)\n+        if (unit.ch == 'Q') {\n+          quot = true;\n+          continue;\n+        } else if (unit.ch == 'E') {\n+          quot = false;\n+          continue;\n+        }\n+      if (quot)\n+      \tunit.bk = false;\n \n       // ALTERNATION OPERATOR\n       //  \\| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)\n       //  not available if RE_LIMITED_OPS is set\n \n       // TODO: the '\\n' literal here should be a test against REToken.newline,\n       // which unfortunately may be more than a single character.\n-      if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ unit.bk))\n-\t     || (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\\n') && !unit.bk) )\n+      if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ (unit.bk || quot)))\n+\t     || (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\\n') && !(unit.bk || quot)) )\n \t   && !syntax.get(RESyntax.RE_LIMITED_OPS)) {\n \t// make everything up to here be a branch. create vector if nec.\n \taddToken(currentToken);\n@@ -363,7 +375,7 @@ protected void initialize(Object patternObj, int cflags, RESyntax syntax, int my\n       // OPEN QUESTION: \n       //  what is proper interpretation of '{' at start of string?\n \n-      else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)) {\n+      else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ (unit.bk || quot))) {\n \tint newIndex = getMinMax(pattern,index,minMax,syntax);\n         if (newIndex > index) {\n           if (minMax.first > minMax.second)\n@@ -388,7 +400,7 @@ else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RE\n       // LIST OPERATOR:\n       //  [...] | [^...]\n \n-      else if ((unit.ch == '[') && !unit.bk) {\n+      else if ((unit.ch == '[') && !(unit.bk || quot)) {\n \tVector options = new Vector();\n \tboolean negative = false;\n \tchar lastChar = 0;\n@@ -490,7 +502,7 @@ else if (\"nrt\".indexOf(pattern[index]) != -1) {\n       // SUBEXPRESSIONS\n       //  (...) | \\(...\\) depending on RE_NO_BK_PARENS\n \n-      else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {\n+      else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot))) {\n \tboolean pure = false;\n \tboolean comment = false;\n         boolean lookAhead = false;\n@@ -537,13 +549,13 @@ else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {\n \tint nextIndex = index;\n \tint nested = 0;\n \n-\twhile ( ((nextIndex = getCharUnit(pattern,endIndex,unit)) > 0)\n-\t\t&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) )\n+\twhile ( ((nextIndex = getCharUnit(pattern,endIndex,unit,false)) > 0)\n+\t\t&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot))) )\n \t  if ((endIndex = nextIndex) >= pLength)\n \t    throw new REException(getLocalizedMessage(\"subexpr.no.end\"),REException.REG_ESUBREG,nextIndex);\n-\t  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))\n+\t  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot)))\n \t    nested++;\n-\t  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))\n+\t  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot)))\n \t    nested--;\n \n \t// endIndex is now position at a ')','\\)' \n@@ -572,14 +584,14 @@ else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))\n       // UNMATCHED RIGHT PAREN\n       // ) or \\) throw exception if\n       // !syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)\n-      else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))) {\n+      else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ (unit.bk || quot)))) {\n \tthrow new REException(getLocalizedMessage(\"unmatched.paren\"),REException.REG_EPAREN,index);\n       }\n \n       // START OF LINE OPERATOR\n       //  ^\n \n-      else if ((unit.ch == '^') && !unit.bk) {\n+      else if ((unit.ch == '^') && !(unit.bk || quot)) {\n \taddToken(currentToken);\n \tcurrentToken = null;\n \taddToken(new RETokenStart(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));\n@@ -588,7 +600,7 @@ else if ((unit.ch == '^') && !unit.bk) {\n       // END OF LINE OPERATOR\n       //  $\n \n-      else if ((unit.ch == '$') && !unit.bk) {\n+      else if ((unit.ch == '$') && !(unit.bk || quot)) {\n \taddToken(currentToken);\n \tcurrentToken = null;\n \taddToken(new RETokenEnd(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));\n@@ -597,15 +609,15 @@ else if ((unit.ch == '$') && !unit.bk) {\n       // MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)\n       //  .\n \n-      else if ((unit.ch == '.') && !unit.bk) {\n+      else if ((unit.ch == '.') && !(unit.bk || quot)) {\n \taddToken(currentToken);\n \tcurrentToken = new RETokenAny(subIndex,syntax.get(RESyntax.RE_DOT_NEWLINE) || ((cflags & REG_DOT_NEWLINE) > 0),syntax.get(RESyntax.RE_DOT_NOT_NULL));\n       }\n \n       // ZERO-OR-MORE REPEAT OPERATOR\n       //  *\n \n-      else if ((unit.ch == '*') && !unit.bk) {\n+      else if ((unit.ch == '*') && !(unit.bk || quot)) {\n \tif (currentToken == null)\n           throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n \tif (currentToken instanceof RETokenRepeated)\n@@ -621,7 +633,7 @@ else if ((unit.ch == '*') && !unit.bk) {\n       //  + | \\+ depending on RE_BK_PLUS_QM\n       //  not available if RE_LIMITED_OPS is set\n \n-      else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {\n+      else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ (unit.bk || quot))) {\n \tif (currentToken == null)\n           throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n \tif (currentToken instanceof RETokenRepeated)\n@@ -638,7 +650,7 @@ else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.ge\n       //  not available if RE_LIMITED_OPS is set\n       //  stingy matching if RE_STINGY_OPS is set and it follows a quantifier\n \n-      else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {\n+      else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ (unit.bk || quot))) {\n \tif (currentToken == null) throw new REException(getLocalizedMessage(\"repeat.no.token\"),REException.REG_BADRPT,index);\n \n \t// Check for stingy matching on RETokenRepeated\n@@ -805,9 +817,9 @@ else if (unit.bk && (unit.ch == 'Z') && syntax.get(RESyntax.RE_STRING_ANCHORS))\n \n   }\n \n-  private static int getCharUnit(char[] input, int index, CharUnit unit) throws REException {\n+  private static int getCharUnit(char[] input, int index, CharUnit unit, boolean quot) throws REException {\n     unit.ch = input[index++];\n-    if (unit.bk = (unit.ch == '\\\\'))\n+    if (unit.bk = (unit.ch == '\\\\' && (!quot || index >= input.length || input[index] == 'E')))\n       if (index < input.length)\n \tunit.ch = input[index++];\n       else throw new REException(getLocalizedMessage(\"ends.with.backslash\"),REException.REG_ESCAPE,index);\n@@ -1281,7 +1293,7 @@ private int getMinMax(char[] input,int index,IntPair minMax,RESyntax syntax) thr\n     \n     // Read string of digits\n     do {\n-      index = getCharUnit(input,index,unit);\n+      index = getCharUnit(input,index,unit,false);\n       if (Character.isDigit(unit.ch))\n         buf.append(unit.ch);\n     } while ((index != input.length) && Character.isDigit(unit.ch));\n@@ -1306,7 +1318,7 @@ else if (index == input.length)\n     else if ((unit.ch == ',') && !unit.bk) {\n       buf = new StringBuffer();\n       // Read string of digits\n-      while (((index = getCharUnit(input,index,unit)) != input.length) && Character.isDigit(unit.ch))\n+      while (((index = getCharUnit(input,index,unit,false)) != input.length) && Character.isDigit(unit.ch))\n \tbuf.append(unit.ch);\n \n       if (!((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)))"}]}