{"sha": "f3e9edff6a370713067611836309c614a7a6b66a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNlOWVkZmY2YTM3MDcxMzA2NzYxMTgzNjMwOWM2MTRhN2E2YjY2YQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-02-04T15:51:18Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-02-04T15:51:18Z"}, "message": "s390-protos.h (legitimize_la_operand, [...]): Add prototypes.\n\n\t* config/s390/s390-protos.h (legitimize_la_operand,\n\ts390_secondary_input_reload_class, s390_plus_operand,\n\ts390_expand_plus_operand): Add prototypes.\n\n\tconfig/s390/s390.c (s390_secondary_input_reload_class,\n\ts390_plus_operand, s390_expand_plus_operand): New functions.\n\n\t(struct s390_address): New member 'pointer'.\n\t(s390_decompose_address): Compute it.\n\t(legitimate_la_operand_p): Use it.\n\t(legitimize_la_operand): New function.\n\t(movti, movdi, movdf splitters): Call it.\n\n\tconfig/s390/s390.h (SECONDARY_INPUT_RELOAD_CLASS): Define.\n\t(PREDICATE_CODES): Add s390_plus_operand.\n\n\tconfig/s390/s390.md (adddi3_inv_64, addaddr_ccclobber): Delete.\n\t(la_ccclobber): Allow GENERAL_REGS as output operand.\n\n\t(reload_load_address, *reload_load_address_reg_0, *la, *do_la_reg_0,\n\t*reload_la_64, *reload_la_31 and splitters): Delete, replace by ...\n\t(*la_64, *la_31, reload_indi, reload_insi): ... these.\n\nFrom-SVN: r49476", "tree": {"sha": "7b439dbd1120cc295cc4e3e8cbffe9eac9defac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b439dbd1120cc295cc4e3e8cbffe9eac9defac0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3e9edff6a370713067611836309c614a7a6b66a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e9edff6a370713067611836309c614a7a6b66a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e9edff6a370713067611836309c614a7a6b66a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e9edff6a370713067611836309c614a7a6b66a/comments", "author": null, "committer": null, "parents": [{"sha": "3c9a08ec8e37707e3e973bfc419067937ebb9a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9a08ec8e37707e3e973bfc419067937ebb9a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9a08ec8e37707e3e973bfc419067937ebb9a20"}], "stats": {"total": 375, "additions": 217, "deletions": 158}, "files": [{"sha": "19dd6394a4c97efb5080683d9e1b27357e6c8303", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3e9edff6a370713067611836309c614a7a6b66a", "patch": "@@ -1,3 +1,28 @@\n+2002-02-04  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (legitimize_la_operand,\n+\ts390_secondary_input_reload_class, s390_plus_operand,\n+\ts390_expand_plus_operand): Add prototypes.\n+\n+\tconfig/s390/s390.c (s390_secondary_input_reload_class,\n+\ts390_plus_operand, s390_expand_plus_operand): New functions.\n+\n+\t(struct s390_address): New member 'pointer'.\n+\t(s390_decompose_address): Compute it.\n+\t(legitimate_la_operand_p): Use it.\n+\t(legitimize_la_operand): New function.\n+\t(movti, movdi, movdf splitters): Call it.\n+\n+\tconfig/s390/s390.h (SECONDARY_INPUT_RELOAD_CLASS): Define.\n+\t(PREDICATE_CODES): Add s390_plus_operand.\n+\n+\tconfig/s390/s390.md (adddi3_inv_64, addaddr_ccclobber): Delete.\n+\t(la_ccclobber): Allow GENERAL_REGS as output operand.\n+\n+\t(reload_load_address, *reload_load_address_reg_0, *la, *do_la_reg_0,\n+\t*reload_la_64, *reload_la_31 and splitters): Delete, replace by ...\n+\t(*la_64, *la_31, reload_indi, reload_insi): ... these.\n+\n 2002-02-04  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* gcc/config/s390/s390.h (CRT_CALL_STATIC_FUNCTION): Fixed"}, {"sha": "2ab387a59cc062b399d9f3e8d94eb0f801f25818", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=f3e9edff6a370713067611836309c614a7a6b66a", "patch": "@@ -48,13 +48,17 @@ extern int s390_match_ccmode PARAMS ((rtx, enum machine_mode));\n extern enum machine_mode s390_select_ccmode PARAMS ((enum rtx_code, rtx, rtx));\n extern int symbolic_reference_mentioned_p PARAMS ((rtx));\n extern int legitimate_la_operand_p PARAMS ((rtx));\n+extern rtx legitimize_la_operand PARAMS ((rtx));\n extern int legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_constant_p PARAMS ((rtx));\n extern int legitimate_reload_constant_p PARAMS ((rtx));\n extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern enum reg_class s390_preferred_reload_class PARAMS ((rtx, enum reg_class));\n+extern enum reg_class s390_secondary_input_reload_class PARAMS ((enum reg_class, enum machine_mode, rtx));\n+extern int s390_plus_operand PARAMS ((rtx, enum machine_mode));\n+extern void s390_expand_plus_operand PARAMS ((rtx, rtx, rtx));\n extern void emit_pic_move PARAMS ((rtx *, enum machine_mode));\n \n extern void s390_output_symbolic_const PARAMS ((FILE *, rtx));"}, {"sha": "0167ab821e3898455b60a284da9b0284b708adf4", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 158, "deletions": 17, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f3e9edff6a370713067611836309c614a7a6b66a", "patch": "@@ -103,6 +103,7 @@ struct s390_address\n   rtx base;\n   rtx indx;\n   rtx disp;\n+  int pointer;\n };\n \n /* Structure containing information for prologue and epilogue.  */ \n@@ -1125,6 +1126,107 @@ s390_preferred_reload_class (op, class)\n   return class;\n }\n \n+/* Return the register class of a scratch register needed to\n+   load IN into a register of class CLASS in MODE.\n+\n+   We need a temporary when loading a PLUS expression which\n+   is not a legitimate operand of the LOAD ADDRESS instruction.  */\n+\n+enum reg_class\n+s390_secondary_input_reload_class (class, mode, in)\n+     enum reg_class class ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  if (s390_plus_operand (in, mode))\n+    return ADDR_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Return true if OP is a PLUS that is not a legitimate\n+   operand for the LA instruction. \n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+s390_plus_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (!check_mode (op, &mode) || mode != Pmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != PLUS)\n+    return FALSE;\n+\n+  if (legitimate_la_operand_p (op))\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n+/* Generate code to load SRC, which is PLUS that is not a\n+   legitimate operand for the LA instruction, into TARGET.\n+   SCRATCH may be used as scratch register.  */\n+\n+void\n+s390_expand_plus_operand (target, src, scratch)\n+     register rtx target;\n+     register rtx src;\n+     register rtx scratch;\n+{\n+  /* src must be a PLUS; get its two operands.  */\n+  rtx sum1, sum2;\n+\n+  if (GET_CODE (src) != PLUS || GET_MODE (src) != Pmode)\n+    abort ();\n+\n+  sum1 = XEXP (src, 0);\n+  sum2 = XEXP (src, 1);\n+\n+  /* If one of the two operands is equal to the target,\n+     make it the first one.  */\n+  if (rtx_equal_p (target, sum2))\n+    {\n+      sum2 = XEXP (src, 0);\n+      sum1 = XEXP (src, 1);\n+    }\n+\n+  /* If the first operand is not an address register,\n+     we reload it into the target.  */\n+  if (true_regnum (sum1) < 1 || true_regnum (sum1) > 15)\n+    {\n+      emit_move_insn (target, sum1);\n+      sum1 = target;\n+    }\n+\n+  /* Likewise for the second operand.  However, take\n+     care not to clobber the target if we already used\n+     it for the first operand.  Use the scratch instead.  */\n+  if (true_regnum (sum2) < 1 || true_regnum (sum2) > 15)\n+    {\n+      if (!rtx_equal_p (target, sum1))\n+        {\n+          emit_move_insn (target, sum2);\n+          sum2 = target;\n+        }\n+      else\n+        {\n+          emit_move_insn (scratch, sum2);\n+          sum2 = scratch;\n+        }\n+    }\n+\n+  /* Emit the LOAD ADDRESS pattern.  Note that reload of PLUS\n+     is only ever performed on addresses, so we can mark the\n+     sum as legitimate for LA in any case.  */\n+  src = gen_rtx_PLUS (Pmode, sum1, sum2);\n+  src = legitimize_la_operand (src);\n+  emit_insn (gen_rtx_SET (VOIDmode, target, src));\n+}\n+\n+\n /* Decompose a RTL expression ADDR for a memory address into\n    its components, returned in OUT.  The boolean STRICT \n    specifies whether strict register checking applies.\n@@ -1145,6 +1247,7 @@ s390_decompose_address (addr, out, strict)\n   rtx base = NULL_RTX;\n   rtx indx = NULL_RTX;\n   rtx disp = NULL_RTX;\n+  int pointer = FALSE;\n \n   /* Decompose address into base + index + displacement.  */\n \n@@ -1198,6 +1301,7 @@ s390_decompose_address (addr, out, strict)\n           if (XVECLEN (base, 0) != 1 || XINT (base, 1) != 101)\n \t      return FALSE;\n \t  base = XVECEXP (base, 0, 0);\n+\t  pointer = TRUE;\n \t}\n \n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n@@ -1206,6 +1310,16 @@ s390_decompose_address (addr, out, strict)\n       if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n \t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n \t  return FALSE;\n+    \n+      if (REGNO (base) == BASE_REGISTER\n+\t  || REGNO (base) == STACK_POINTER_REGNUM\n+\t  || REGNO (base) == FRAME_POINTER_REGNUM\n+\t  || ((reload_completed || reload_in_progress)\n+\t      && frame_pointer_needed\n+\t      && REGNO (base) == HARD_FRAME_POINTER_REGNUM)\n+          || (flag_pic\n+              && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n+        pointer = TRUE;\n     }\n \n   /* Validate index register.  */\n@@ -1216,6 +1330,7 @@ s390_decompose_address (addr, out, strict)\n           if (XVECLEN (indx, 0) != 1 || XINT (indx, 1) != 101)\n \t      return FALSE;\n \t  indx = XVECEXP (indx, 0, 0);\n+\t  pointer = TRUE;\n \t}\n \n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n@@ -1224,6 +1339,16 @@ s390_decompose_address (addr, out, strict)\n       if ((strict && ! REG_OK_FOR_BASE_STRICT_P (indx))\n \t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (indx)))\n \t  return FALSE;\n+    \n+      if (REGNO (indx) == BASE_REGISTER\n+\t  || REGNO (indx) == STACK_POINTER_REGNUM\n+\t  || REGNO (indx) == FRAME_POINTER_REGNUM\n+\t  || ((reload_completed || reload_in_progress)\n+\t      && frame_pointer_needed\n+\t      && REGNO (indx) == HARD_FRAME_POINTER_REGNUM)\n+          || (flag_pic\n+              && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n+        pointer = TRUE;\n     }\n \n   /* Validate displacement.  */\n@@ -1244,6 +1369,8 @@ s390_decompose_address (addr, out, strict)\n         {\n           if (flag_pic != 1)\n             return FALSE;\n+\n+\t  pointer = TRUE;\n         }\n \n       /* We can convert literal pool addresses to \n@@ -1295,14 +1422,20 @@ s390_decompose_address (addr, out, strict)\n \n           if (offset)\n             disp = plus_constant (disp, offset);\n+\n+\t  pointer = TRUE;\n         }\n     }\n \n+  if (!base && !indx)\n+    pointer = TRUE;\n+   \n   if (out)\n     {\n       out->base = base;\n       out->indx = indx;\n       out->disp = disp;\n+      out->pointer = pointer;\n     }\n \n   return TRUE;\n@@ -1332,28 +1465,36 @@ legitimate_la_operand_p (op)\n   if (!s390_decompose_address (op, &addr, FALSE))\n     return FALSE;\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT || addr.pointer)\n     return TRUE;\n \n-  /* Use of the base or stack pointer implies address.  */\n+  return FALSE;\n+}\n \n-  if (addr.base && GET_CODE (addr.base) == REG)\n-    {\n-      if (REGNO (addr.base) == BASE_REGISTER\n-\t  || REGNO (addr.base) == STACK_POINTER_REGNUM\n-\t  || REGNO (addr.base) == FRAME_POINTER_REGNUM)\n-        return TRUE;\n-    }\n+/* Return a modified variant of OP that is guaranteed to\n+   be accepted by legitimate_la_operand_p.  */\n \n-  if (addr.indx && GET_CODE (addr.indx) == REG)\n-    {\n-      if (REGNO (addr.indx) == BASE_REGISTER\n-          || REGNO (addr.indx) == STACK_POINTER_REGNUM\n-\t  || REGNO (addr.base) == FRAME_POINTER_REGNUM)\n-        return TRUE;\n-    }\n+rtx\n+legitimize_la_operand (op)\n+     register rtx op;\n+{\n+  struct s390_address addr;\n+  if (!s390_decompose_address (op, &addr, FALSE))\n+    abort ();\n \n-  return FALSE;\n+  if (TARGET_64BIT || addr.pointer)\n+    return op;\n+\n+  if (!addr.base)\n+    abort ();\n+\n+  op = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr.base), 101);\n+  if (addr.indx)\n+    op = gen_rtx_PLUS (Pmode, op, addr.indx);\n+  if (addr.disp)\n+    op = gen_rtx_PLUS (Pmode, op, addr.disp);\n+\n+  return op; \n }\n \n /* Return a legitimate reference for ORIG (an address) using the"}, {"sha": "f64850526eccc44683351d0ee4bf997d84e17b06", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f3e9edff6a370713067611836309c614a7a6b66a", "patch": "@@ -577,6 +577,12 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smalled class cont\n       (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT ? 2 : 1) :  \t\t\\\n       (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+/* We need a secondary reload when loading a PLUS which is \n+   not a valid operand for LOAD ADDRESS.  */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\\\n+\ts390_secondary_input_reload_class ((CLASS), (MODE), (IN))\n+\n /* If we are copying between FP registers and anything else, we need a memory\n    location.  */\n \n@@ -1293,7 +1299,8 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n   {\"larl_operand\",    { SYMBOL_REF, CONST, CONST_INT, CONST_DOUBLE }},\t\\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t        \\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t        \\\n-  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\n+  {\"const0_operand\",  { CONST_INT, CONST_DOUBLE }},\t\t\t\\\n+  {\"s390_plus_operand\", { PLUS }},\n \n \n /* S/390 constant pool breaks the devices in crtstuff.c to control section"}, {"sha": "905092befa5ed4ca5bec863d7df8e24fd33a12ca", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 22, "deletions": 140, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e9edff6a370713067611836309c614a7a6b66a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f3e9edff6a370713067611836309c614a7a6b66a", "patch": "@@ -867,7 +867,7 @@\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0) (mem:TI (match_dup 2)))]\n   \"operands[2] = operand_subword (operands[0], 1, 0, TImode);\n-   operands[3] = XEXP (operands[1], 0);\")\n+   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n \n ;\n ; movdi instruction pattern(s).\n@@ -1022,7 +1022,7 @@\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0) (mem:DI (match_dup 2)))]\n   \"operands[2] = operand_subword (operands[0], 1, 0, DImode);\n-   operands[3] = XEXP (operands[1], 0);\")\n+   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n \n ;\n ; movsi instruction pattern(s).\n@@ -1305,7 +1305,7 @@\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0) (mem:DI (match_dup 2)))]\n   \"operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n-   operands[3] = XEXP (operands[1], 0);\")\n+   operands[3] = legitimize_la_operand (XEXP (operands[1], 0));\")\n \n ;\n ; movsf instruction pattern(s).\n@@ -3093,23 +3093,6 @@\n   [(set_attr \"op_type\"  \"RRE,RI,RXE\")\n    (set_attr \"atype\"    \"reg,reg,mem\")])\n \n-;\n-; For weakness of reload, need (set (reg x) (plus (reg y) (reg x)))\n-;\n-\n-(define_insn \"adddi3_inv_64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-        (plus:DI (match_operand:DI 1 \"general_operand\" \"%d,K,m\")\n-                 (match_operand:DI 2 \"register_operand\" \"0,0,0\") ) )\n-   (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   agr\\\\t%0,%1\n-   aghi\\\\t%0,%h1\n-   ag\\\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RI,RXE\")\n-   (set_attr \"atype\"   \"reg,reg,mem\")])\n-\n (define_insn \"adddi3_31\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n         (plus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n@@ -3156,74 +3139,33 @@\n   DONE;\t\t\n }\")\n \n-(define_insn \"reload_load_address\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+(define_insn \"*la_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (match_operand:QI 1 \"address_operand\" \"p\"))]\n   \"TARGET_64BIT\"\n   \"la\\\\t%0,%a1\"      \n   [(set_attr \"op_type\" \"RX\")\n    (set_attr \"atype\"   \"mem\")\n    (set_attr \"type\"    \"la\")])\n \n-(define_insn \"*reload_load_address_reg_0\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-                 (match_operand:DI 2 \"register_operand\" \"d\")))]\n+(define_expand \"reload_indi\"\n+  [(parallel [(match_operand:DI 0 \"register_operand\" \"=a\")\n+              (match_operand:DI 1 \"s390_plus_operand\" \"\")\n+              (match_operand:DI 2 \"register_operand\" \"=&a\")])]\n   \"TARGET_64BIT\"\n-  \"brxlg\\\\t%0,%2,.+6\"\n-  [(set_attr \"op_type\" \"RIE\")\n-   (set_attr \"atype\"   \"reg\")])\n-\n-(define_insn \"*reload_la_64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (plus:DI (match_operand:DI 1 \"general_operand\" \"g\")\n-                 (match_operand:DI 2 \"general_operand\" \"g\")))]\n-  \"TARGET_64BIT && reload_in_progress\n-   && !address_operand (gen_rtx_PLUS (DImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-        (plus:DI (match_operand:DI 1 \"general_operand\" \"\")\n-                 (match_operand:DI 2 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT && reload_completed\n-   && !address_operand (gen_rtx_PLUS (DImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 2)))]\n   \"\n {\n-  if (CONSTANT_P (operands[1]) \n-      && !legitimate_reload_constant_p (operands[1]))\n-    operands[1] = force_const_mem (DImode, operands[1]);\n+  s390_expand_plus_operand (operands[0], operands[1], operands[2]);\n+  DONE;\n }\")\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-        (plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n-                 (match_operand:DI 2 \"general_operand\" \"\")))]\n-  \"TARGET_64BIT && reload_completed\n-   && !address_operand (gen_rtx_PLUS (DImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 1)))]\n-  \"\n-{\n-  if (CONSTANT_P (operands[2]) \n-      && !legitimate_reload_constant_p (operands[2]))\n-    operands[2] = force_const_mem (DImode, operands[2]);\n-}\")\n  \n ;\n ; addsi3 instruction pattern(s).\n ;\n \n (define_insn \"*la_ccclobber\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:QI 1 \"address_operand\"  \"p\"))\n    (clobber (reg:CC 33))]\n   \"legitimate_la_operand_p (operands[1])\"\n@@ -3232,23 +3174,6 @@\n     (set_attr \"atype\"    \"mem\")\n     (set_attr \"type\"     \"la\")])\n \n-(define_insn \"*addaddr_ccclobber\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"%a,a\")\n-                 (match_operand:SI 2 \"nonmemory_operand\" \"J,a\")))\n-   (clobber (reg:CC 33))]\n-  \"(((REGNO (operands[1]) == STACK_POINTER_REGNUM ) ||\n-     (REGNO (operands[1]) == FRAME_POINTER_REGNUM ) ||\t\n-     (REGNO (operands[1]) == BASE_REGISTER)) && \n-        (GET_CODE (operands[2]) == REG ||\n-\t CONST_OK_FOR_LETTER_P (INTVAL (operands[2]),'J')))\"\n-  \"@\n-   la\\\\t%0,%c2(,%1)\n-   la\\\\t%0,0(%1,%2)\"\n-  [(set_attr \"op_type\"  \"RX\")\n-   (set_attr \"atype\"    \"mem\")\n-   (set_attr \"type\"     \"la\")])\n-\n (define_insn \"*addsi3_cc\"\n   [(set (reg 33) \n         (compare (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n@@ -3301,67 +3226,24 @@\n   [(set_attr \"op_type\"  \"RR,RI,RX\")\n    (set_attr \"atype\"    \"reg,reg,mem\")])\n \n-(define_insn \"*la\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+(define_insn \"*la_31\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:QI 1 \"address_operand\" \"p\"))]\n-  \"reload_in_progress || reload_completed\n-   || legitimate_la_operand_p (operands[1])\"\n+  \"legitimate_la_operand_p (operands[1])\"\n   \"la\\\\t%0,%a1\"\n   [(set_attr \"op_type\"  \"RX\")\n    (set_attr \"atype\"    \"mem\")\n    (set_attr \"type\"     \"la\")])\n \n-(define_insn \"*do_la_reg_0\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-                 (match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"reload_in_progress || reload_completed\"\n-  \"brxle\\\\t%0,%2,.+4\"\n-  [(set_attr \"op_type\" \"RSI\")\n-   (set_attr \"atype\"   \"reg\")])\n-\n-(define_insn \"*reload_la_31\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n-                 (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"reload_in_progress\n-   && !address_operand (gen_rtx_PLUS (SImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (plus:SI (match_operand:SI 1 \"general_operand\" \"\")\n-                 (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"reload_completed\n-   && !address_operand (gen_rtx_PLUS (SImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))]\n-  \"\n-{\n-  if (CONSTANT_P (operands[1]) \n-      && !legitimate_reload_constant_p (operands[1]))\n-    operands[1] = force_const_mem (SImode, operands[1]);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-                 (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"reload_completed\n-   && !address_operand (gen_rtx_PLUS (SImode, operands[1], operands[2]), QImode)\n-   && !rtx_equal_p (operands[0], operands[1])\n-   && !rtx_equal_p (operands[0], operands[2])\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))]\n+(define_expand \"reload_insi\"\n+  [(parallel [(match_operand:SI 0 \"register_operand\" \"=a\")\n+              (match_operand:SI 1 \"s390_plus_operand\" \"\")\n+              (match_operand:SI 2 \"register_operand\" \"=&a\")])]\n+  \"!TARGET_64BIT\"\n   \"\n {\n-  if (CONSTANT_P (operands[2]) \n-      && !legitimate_reload_constant_p (operands[2]))\n-    operands[2] = force_const_mem (SImode, operands[2]);\n+  s390_expand_plus_operand (operands[0], operands[1], operands[2]);\n+  DONE;\n }\")\n \n "}]}