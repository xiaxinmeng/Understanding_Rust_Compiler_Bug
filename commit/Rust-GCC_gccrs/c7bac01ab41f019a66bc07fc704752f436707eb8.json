{"sha": "c7bac01ab41f019a66bc07fc704752f436707eb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiYWMwMWFiNDFmMDE5YTY2YmMwN2ZjNzA0NzUyZjQzNjcwN2ViOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-15T17:56:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-15T17:58:31Z"}, "message": "Optimize assignment to volatile aggregate variable\n\ngimplify_modify_expr_rhs has an optimization whereby the assignment to\nan aggregate variable from a read-only object with a DECL_INITIAL is\noptimized into the direct assignment of the DECL_INITIAL, provided that\nno temporary is created in the process.\n\nThe optimization is blocked if the read-only object is volatile, which\nis OK as per the semantics of volatile, but also if the target variable\nis volatile, on the grounds that the modified assignment might end up\nbeing done on a per field basis, which is also OK.  But this latter\nrestriction is enforced a priori and there are cases where the modified\nassignment would be OK, for example if there is only one field or the\nDECL_INITIAL is equivalent to the empty CONSTRUCTOR, i.e. all zeros.\n\nSo, in the latter case, the patch changes gimplify_modify_expr_rhs to ask\ngimplify_init_constructor whether the assignment would be done as a block,\nwhich is easy because gimplify_init_constructor knows that it must create\na temporary if the LHS is volatile and this would not be the case, so it's\njust a matter of completing the NOTIFY_TEMP_CREATION mechanism.\n\ngcc/ChangeLog\n\t* gimplify.c (gimplify_init_constructor) <AGGREGATE_TYPE>: Declare\n\tnew ENSURE_SINGLE_ACCESS constant and move variables down.  If it is\n\ttrue and all elements are zero, then always clear.  Return GS_ERROR\n\tif a temporary would be created for it and NOTIFY_TEMP_CREATION set.\n\t(gimplify_modify_expr_rhs) <VAR_DECL>: If the target is volatile but\n\tthe type is aggregate non-addressable, ask gimplify_init_constructor\n\twhether it can generate a single access to the target.\n\ngcc/testsuite/ChangeLog\n\t* gnat.dg/aggr30.ads, gnat.dg/aggr30.adb: New test.", "tree": {"sha": "6262e09a4b849ae56d10e87e20c65fd6f8099681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6262e09a4b849ae56d10e87e20c65fd6f8099681"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7bac01ab41f019a66bc07fc704752f436707eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bac01ab41f019a66bc07fc704752f436707eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7bac01ab41f019a66bc07fc704752f436707eb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bac01ab41f019a66bc07fc704752f436707eb8/comments", "author": null, "committer": null, "parents": [{"sha": "fb149ebdfee8995ed091f17cd64355ff54e9fb30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb149ebdfee8995ed091f17cd64355ff54e9fb30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb149ebdfee8995ed091f17cd64355ff54e9fb30"}], "stats": {"total": 98, "additions": 81, "deletions": 17}, "files": [{"sha": "9851edfc4dbf37140b040c2fbb766d76db3eb500", "filename": "gcc/gimplify.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c7bac01ab41f019a66bc07fc704752f436707eb8", "patch": "@@ -4865,17 +4865,24 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     case QUAL_UNION_TYPE:\n     case ARRAY_TYPE:\n       {\n-\tstruct gimplify_init_ctor_preeval_data preeval_data;\n-\tHOST_WIDE_INT num_ctor_elements, num_nonzero_elements;\n-\tHOST_WIDE_INT num_unique_nonzero_elements;\n-\tbool cleared, complete_p, valid_const_initializer;\n \t/* Use readonly data for initializers of this or smaller size\n \t   regardless of the num_nonzero_elements / num_unique_nonzero_elements\n \t   ratio.  */\n \tconst HOST_WIDE_INT min_unique_size = 64;\n \t/* If num_nonzero_elements / num_unique_nonzero_elements ratio\n \t   is smaller than this, use readonly data.  */\n \tconst int unique_nonzero_ratio = 8;\n+\t/* True if a single access of the object must be ensured.  This is the\n+\t   case if the target is volatile, the type is non-addressable and more\n+\t   than one field need to be assigned.  */\n+\tconst bool ensure_single_access\n+\t  = TREE_THIS_VOLATILE (object)\n+\t    && !TREE_ADDRESSABLE (type)\n+\t    && vec_safe_length (elts) > 1;\n+\tstruct gimplify_init_ctor_preeval_data preeval_data;\n+\tHOST_WIDE_INT num_ctor_elements, num_nonzero_elements;\n+\tHOST_WIDE_INT num_unique_nonzero_elements;\n+\tbool cleared, complete_p, valid_const_initializer;\n \n \t/* Aggregate types must lower constructors to initialization of\n \t   individual elements.  The exception is that a CONSTRUCTOR node\n@@ -4914,6 +4921,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  {\n \t    if (notify_temp_creation)\n \t      return GS_ERROR;\n+\n \t    DECL_INITIAL (object) = ctor;\n \t    TREE_STATIC (object) = 1;\n \t    if (!DECL_NAME (object))\n@@ -4961,6 +4969,10 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  /* If there are \"lots\" of zeros, it's more efficient to clear\n \t     the memory and then set the nonzero elements.  */\n \t  cleared = true;\n+\telse if (ensure_single_access && num_nonzero_elements == 0)\n+\t  /* If a single access to the target must be ensured and all elements\n+\t     are zero, then it's optimal to clear whatever their number.  */\n+\t  cleared = true;\n \telse\n \t  cleared = false;\n \n@@ -5029,13 +5041,14 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      }\n \t  }\n \n-\t/* If the target is volatile, we have non-zero elements and more than\n-\t   one field to assign, initialize the target from a temporary.  */\n-\tif (TREE_THIS_VOLATILE (object)\n-\t    && !TREE_ADDRESSABLE (type)\n-\t    && (num_nonzero_elements > 0 || !cleared)\n-\t    && vec_safe_length (elts) > 1)\n+\t/* If a single access to the target must be ensured and there are\n+\t   nonzero elements or the zero elements are not assigned en masse,\n+\t   initialize the target from a temporary.  */\n+\tif (ensure_single_access && (num_nonzero_elements > 0 || !cleared))\n \t  {\n+\t    if (notify_temp_creation)\n+\t      return GS_ERROR;\n+\n \t    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type));\n \t    TREE_OPERAND (*expr_p, 0) = temp;\n \t    *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),\n@@ -5243,14 +5256,20 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t{\n \tcase VAR_DECL:\n \t  /* If we're assigning from a read-only variable initialized with\n-\t     a constructor, do the direct assignment from the constructor,\n-\t     but only if neither source nor target are volatile since this\n-\t     latter assignment might end up being done on a per-field basis.  */\n-\t  if (DECL_INITIAL (*from_p)\n-\t      && TREE_READONLY (*from_p)\n+\t     a constructor and not volatile, do the direct assignment from\n+\t     the constructor, but only if the target is not volatile either\n+\t     since this latter assignment might end up being done on a per\n+\t     field basis.  However, if the target is volatile and the type\n+\t     is aggregate and non-addressable, gimplify_init_constructor\n+\t     knows that it needs to ensure a single access to the target\n+\t     and it will return GS_OK only in this case.  */\n+\t  if (TREE_READONLY (*from_p)\n+\t      && DECL_INITIAL (*from_p)\n+\t      && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR\n \t      && !TREE_THIS_VOLATILE (*from_p)\n-\t      && !TREE_THIS_VOLATILE (*to_p)\n-\t      && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)\n+\t      && (!TREE_THIS_VOLATILE (*to_p)\n+\t\t  || (AGGREGATE_TYPE_P (TREE_TYPE (*to_p))\n+\t\t      && !TREE_ADDRESSABLE (TREE_TYPE (*to_p)))))\n \t    {\n \t      tree old_from = *from_p;\n \t      enum gimplify_status subret;"}, {"sha": "a69c8b651ead4df1b92ea7f8f40adc87c1a1389d", "filename": "gcc/testsuite/gnat.dg/aggr30.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.adb?ref=c7bac01ab41f019a66bc07fc704752f436707eb8", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+package body Aggr30 is\n+\n+   Null_Constant : constant Rec := (Data => (others => 0),\n+                                    Padding => (others => 0));\n+   procedure Init is\n+   begin\n+      Instance := Null_Constant;\n+   end;\n+\n+   procedure Init_Volatile is\n+   begin\n+      Instance_Volatile := Null_Constant;\n+   end;\n+\n+end Aggr30;\n+\n+-- { dg-final { scan-tree-dump-times \"= {}\" 2 \"gimple\"} }"}, {"sha": "998403487e7c6a9ddb719b4968f12dc353a41e35", "filename": "gcc/testsuite/gnat.dg/aggr30.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bac01ab41f019a66bc07fc704752f436707eb8/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faggr30.ads?ref=c7bac01ab41f019a66bc07fc704752f436707eb8", "patch": "@@ -0,0 +1,25 @@\n+with Interfaces;\n+\n+package Aggr30 is\n+\n+   type Data_Type is array (1 .. 4) of Interfaces.Unsigned_8;\n+\n+   type Padding_Type is array (5 .. 4096) of Interfaces.Unsigned_8;\n+\n+   type Rec is record\n+      Data    : Data_Type;\n+      Padding : Padding_Type;\n+   end record;\n+\n+   procedure Init;\n+\n+   procedure Init_Volatile;\n+\n+private\n+\n+   Instance : Rec;\n+\n+   Instance_Volatile : Rec;\n+   pragma Volatile (Instance_Volatile);\n+\n+end Aggr30;"}]}