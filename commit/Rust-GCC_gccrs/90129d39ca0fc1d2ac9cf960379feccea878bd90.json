{"sha": "90129d39ca0fc1d2ac9cf960379feccea878bd90", "node_id": "C_kwDOANBUbNoAKDkwMTI5ZDM5Y2EwZmMxZDJhYzljZjk2MDM3OWZlY2NlYTg3OGJkOTA", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-07-01T07:59:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-07-01T08:01:12Z"}, "message": "Amend fix for PR middle-end/105874\n\nThe original fix is very likely too big a hammer.\n\ngcc/\n\tPR middle-end/105874\n\t* expr.cc (expand_expr_real_1) <normal_inner_ref>: Force\n\tEXPAND_MEMORY for the expansion of the inner reference only\n\tin the usual cases where a memory reference is required.", "tree": {"sha": "11357ee909e3f0475a950ff83664a8336a7c120c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11357ee909e3f0475a950ff83664a8336a7c120c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90129d39ca0fc1d2ac9cf960379feccea878bd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90129d39ca0fc1d2ac9cf960379feccea878bd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90129d39ca0fc1d2ac9cf960379feccea878bd90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90129d39ca0fc1d2ac9cf960379feccea878bd90/comments", "author": null, "committer": null, "parents": [{"sha": "51debf7f857dddfb4dd2493867d2648041e7d8de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51debf7f857dddfb4dd2493867d2648041e7d8de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51debf7f857dddfb4dd2493867d2648041e7d8de"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "53af027a4d0ca1a55e66f9c752d5a9e4f6929b1c", "filename": "gcc/expr.cc", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90129d39ca0fc1d2ac9cf960379feccea878bd90/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90129d39ca0fc1d2ac9cf960379feccea878bd90/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=90129d39ca0fc1d2ac9cf960379feccea878bd90", "patch": "@@ -11186,37 +11186,58 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmachine_mode mode1, mode2;\n \tpoly_int64 bitsize, bitpos, bytepos;\n \ttree offset;\n-\tint reversep, volatilep = 0, must_force_mem;\n+\tint reversep, volatilep = 0;\n \ttree tem\n \t  = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode1,\n \t\t\t\t &unsignedp, &reversep, &volatilep);\n \trtx orig_op0, memloc;\n \tbool clear_mem_expr = false;\n+\tbool must_force_mem;\n \n \t/* If we got back the original object, something is wrong.  Perhaps\n \t   we are evaluating an expression too early.  In any event, don't\n \t   infinitely recurse.  */\n \tgcc_assert (tem != exp);\n \n-\t/* If tem is a VAR_DECL, we need a memory reference.  */\n-\tenum expand_modifier tem_modifier = modifier;\n-\tif (tem_modifier == EXPAND_SUM)\n-\t  tem_modifier = EXPAND_NORMAL;\n-\tif (TREE_CODE (tem) == VAR_DECL)\n-\t  tem_modifier = EXPAND_MEMORY;\n+\t/* Make sure bitpos is not negative, this can wreak havoc later.  */\n+\tif (maybe_lt (bitpos, 0))\n+\t  {\n+\t    gcc_checking_assert (offset == NULL_TREE);\n+\t    offset = size_int (bits_to_bytes_round_down (bitpos));\n+\t    bitpos = num_trailing_bits (bitpos);\n+\t  }\n+\n+\t/* If we have either an offset, a BLKmode result, or a reference\n+\t   outside the underlying object, we must force it to memory.\n+\t   Such a case can occur in Ada if we have unchecked conversion\n+\t   of an expression from a scalar type to an aggregate type or\n+\t   for an ARRAY_RANGE_REF whose type is BLKmode, or if we were\n+\t   passed a partially uninitialized object or a view-conversion\n+\t   to a larger size.  */\n+\tmust_force_mem = offset != NULL_TREE\n+\t\t\t || mode1 == BLKmode\n+\t\t\t || (mode == BLKmode\n+\t\t\t     && !int_mode_for_size (bitsize, 1).exists ());\n+\n+\tconst enum expand_modifier tem_modifier\n+\t  = must_force_mem\n+\t    ? EXPAND_MEMORY\n+\t    : modifier == EXPAND_SUM ? EXPAND_NORMAL : modifier;\n \n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n+\tconst rtx tem_target\n+\t  = TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n+\t    && COMPLETE_TYPE_P (TREE_TYPE (tem))\n+\t    && TREE_CODE (TYPE_SIZE (TREE_TYPE (tem))) != INTEGER_CST\n+\t    && modifier != EXPAND_STACK_PARM\n+\t    ? target\n+\t    : NULL_RTX;\n+\n \torig_op0 = op0\n-\t  = expand_expr_real (tem,\n-\t\t\t      (TREE_CODE (TREE_TYPE (tem)) == UNION_TYPE\n-\t\t\t       && COMPLETE_TYPE_P (TREE_TYPE (tem))\n-\t\t\t       && (TREE_CODE (TYPE_SIZE (TREE_TYPE (tem)))\n-\t\t\t\t   != INTEGER_CST)\n-\t\t\t       && modifier != EXPAND_STACK_PARM\n-\t\t\t       ? target : NULL_RTX),\n-\t\t\t      VOIDmode, tem_modifier, NULL, true);\n+\t  = expand_expr_real (tem, tem_target, VOIDmode, tem_modifier, NULL,\n+\t\t\t      true);\n \n \t/* If the field has a mode, we want to access it in the\n \t   field's mode, not the computed mode.\n@@ -11233,27 +11254,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \tmode2\n \t  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);\n \n-\t/* Make sure bitpos is not negative, it can wreak havoc later.  */\n-\tif (maybe_lt (bitpos, 0))\n-\t  {\n-\t    gcc_checking_assert (offset == NULL_TREE);\n-\t    offset = size_int (bits_to_bytes_round_down (bitpos));\n-\t    bitpos = num_trailing_bits (bitpos);\n-\t  }\n-\n-\t/* If we have either an offset, a BLKmode result, or a reference\n-\t   outside the underlying object, we must force it to memory.\n-\t   Such a case can occur in Ada if we have unchecked conversion\n-\t   of an expression from a scalar type to an aggregate type or\n-\t   for an ARRAY_RANGE_REF whose type is BLKmode, or if we were\n-\t   passed a partially uninitialized object or a view-conversion\n-\t   to a larger size.  */\n-\tmust_force_mem = (offset\n-\t\t\t  || mode1 == BLKmode\n-\t\t\t  || (mode == BLKmode\n-\t\t\t      && !int_mode_for_size (bitsize, 1).exists ())\n-\t\t\t  || maybe_gt (bitpos + bitsize,\n-\t\t\t\t       GET_MODE_BITSIZE (mode2)));\n+\t/* See above for the rationale.  */\n+\tif (maybe_gt (bitpos + bitsize, GET_MODE_BITSIZE (mode2)))\n+\t  must_force_mem = true;\n \n \t/* Handle CONCAT first.  */\n \tif (GET_CODE (op0) == CONCAT && !must_force_mem)\n@@ -11311,7 +11314,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      }\n \t    else\n \t      /* Otherwise force into memory.  */\n-\t      must_force_mem = 1;\n+\t      must_force_mem = true;\n \t  }\n \n \t/* If this is a constant, put it in a register if it is a legitimate"}]}