{"sha": "0ec74a1ee358ee14658ea251d5d885863764c4a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjNzRhMWVlMzU4ZWUxNDY1OGVhMjUxZDVkODg1ODYzNzY0YzRhOQ==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:20:38Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:20:38Z"}, "message": "[AArch64] Unify vector and core register save/restore code.\n\nFrom-SVN: r212955", "tree": {"sha": "f5b615bedce9e0756acf03c4020c68ec4c586eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5b615bedce9e0756acf03c4020c68ec4c586eaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ec74a1ee358ee14658ea251d5d885863764c4a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec74a1ee358ee14658ea251d5d885863764c4a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec74a1ee358ee14658ea251d5d885863764c4a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec74a1ee358ee14658ea251d5d885863764c4a9/comments", "author": null, "committer": null, "parents": [{"sha": "72df5c1f6212b258f2daef128db4e74723001dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72df5c1f6212b258f2daef128db4e74723001dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72df5c1f6212b258f2daef128db4e74723001dde"}], "stats": {"total": 106, "additions": 30, "deletions": 76}, "files": [{"sha": "940a327a1f7f8fd60fa5db5a0e2b4974f2d743b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec74a1ee358ee14658ea251d5d885863764c4a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec74a1ee358ee14658ea251d5d885863764c4a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ec74a1ee358ee14658ea251d5d885863764c4a9", "patch": "@@ -1,3 +1,9 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_save_or_restore_fprs): Deleted.\n+\t(aarch64_save_callee_saves): New function to handle reg save\n+\tfor both core and vectore regs.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_gen_load_pair)"}, {"sha": "e3a0c570b762ae216c13efc721574a0a20b387e4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 24, "deletions": 76, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ec74a1ee358ee14658ea251d5d885863764c4a9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ec74a1ee358ee14658ea251d5d885863764c4a9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0ec74a1ee358ee14658ea251d5d885863764c4a9", "patch": "@@ -1950,93 +1950,32 @@ aarch64_gen_load_pair (enum machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n     }\n }\n \n-static void\n-aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n-{\n-  unsigned regno;\n-  unsigned regno2;\n-  rtx insn;\n-  rtx (*gen_mem_ref) (enum machine_mode, rtx)\n-    = frame_pointer_needed ? gen_frame_mem : gen_rtx_MEM;\n-\n-\n-  for (regno = aarch64_next_callee_save (V0_REGNUM, V31_REGNUM);\n-       regno <= V31_REGNUM;\n-       regno = aarch64_next_callee_save (regno + 1, V31_REGNUM))\n-    {\n-      rtx reg = gen_rtx_REG (DFmode, regno);\n-      rtx mem;\n-\n-      HOST_WIDE_INT offset = start_offset\n-\t\t\t     + cfun->machine->frame.reg_offset[regno];\n-      mem = gen_mem_ref (DFmode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\toffset));\n-\n-      regno2 = aarch64_next_callee_save (regno + 1, V31_REGNUM);\n-\n-      if (regno2 <= V31_REGNUM)\n-\t{\n-\t  rtx reg2 = gen_rtx_REG (DFmode, regno2);\n-\t  rtx mem2;\n-\n-\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t  mem2 = gen_mem_ref (DFmode,\n-\t\t\t      plus_constant (Pmode, stack_pointer_rtx, offset));\n-\t  if (restore == false)\n-\t    insn = emit_insn (aarch64_gen_store_pair (DFmode, mem, reg, mem2, reg2));\n-\t  else\n-\t    {\n-\t      insn = emit_insn (aarch64_gen_load_pair (DFmode, reg, mem, reg2, mem2));\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg2);\n-\t    }\n-\n-\t  /* The first part of a frame-related parallel insn is\n-\t     always assumed to be relevant to the frame\n-\t     calculations; subsequent parts, are only\n-\t     frame-related if explicitly marked.  */\n-\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n-\t  regno = regno2;\n-\t}\n-      else\n-\t{\n-\t  if (restore == false)\n-\t    insn = emit_move_insn (mem, reg);\n-\t  else\n-\t    {\n-\t      insn = emit_move_insn (reg, mem);\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t    }\n-\t}\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-    }\n-}\n-\n \n /* offset from the stack pointer of where the saves and\n    restore's have to happen.  */\n static void\n-aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n-\t\t\t\t\t       bool restore)\n+aarch64_save_or_restore_callee_saves (enum machine_mode mode,\n+\t\t\t\t      HOST_WIDE_INT start_offset,\n+\t\t\t\t      unsigned start, unsigned limit,\n+\t\t\t\t      bool restore)\n {\n   rtx insn;\n   rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n \t\t\t\t\t\t ? gen_frame_mem : gen_rtx_MEM);\n-  unsigned limit = frame_pointer_needed ? R28_REGNUM : R30_REGNUM;\n   unsigned regno;\n   unsigned regno2;\n \n-  for (regno = aarch64_next_callee_save (R0_REGNUM, limit);\n+  for (regno = aarch64_next_callee_save (start, limit);\n        regno <= limit;\n        regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n-      rtx reg = gen_rtx_REG (DImode, regno);\n+      rtx reg = gen_rtx_REG (mode, regno);\n       rtx mem;\n \n       HOST_WIDE_INT offset = start_offset\n \t\t\t     + cfun->machine->frame.reg_offset[regno];\n-      mem = gen_mem_ref (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t       offset));\n+      mem = gen_mem_ref (mode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      offset));\n \n       regno2 = aarch64_next_callee_save (regno + 1, limit);\n \n@@ -2045,17 +1984,19 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t      == cfun->machine->frame.reg_offset[regno2]))\n \n \t{\n-\t  rtx reg2 = gen_rtx_REG (DImode, regno2);\n+\t  rtx reg2 = gen_rtx_REG (mode, regno2);\n \t  rtx mem2;\n \n \t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t  mem2 = gen_mem_ref (Pmode,\n+\t  mem2 = gen_mem_ref (mode,\n \t\t\t      plus_constant (Pmode, stack_pointer_rtx, offset));\n \t  if (restore == false)\n-\t    insn = emit_insn (aarch64_gen_store_pair (DImode, mem, reg, mem2, reg2));\n+\t    insn = emit_insn (aarch64_gen_store_pair (mode, mem, reg, mem2,\n+\t\t\t\t\t\t      reg2));\n \t  else\n \t    {\n-\t      insn = emit_insn (aarch64_gen_load_pair (DImode, reg, mem, reg2, mem2));\n+\t      insn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2,\n+\t\t\t\t\t\t       mem2));\n \t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n \t      add_reg_note (insn, REG_CFA_RESTORE, reg2);\n \t    }\n@@ -2079,7 +2020,6 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n \t}\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-  aarch64_save_or_restore_fprs (start_offset, restore);\n }\n \n /* AArch64 stack frames generated by this compiler look like:\n@@ -2272,7 +2212,11 @@ aarch64_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n-      aarch64_save_or_restore_callee_save_registers (fp_offset, 0);\n+      aarch64_save_or_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t\t    frame_pointer_needed\n+\t\t\t\t\t    ? R28_REGNUM : R30_REGNUM, false);\n+      aarch64_save_or_restore_callee_saves (DFmode, fp_offset, V0_REGNUM,\n+\t\t\t\t\t    V31_REGNUM, false);\n     }\n \n   /* when offset >= 512,\n@@ -2343,7 +2287,11 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfa_reg = stack_pointer_rtx;\n     }\n \n-  aarch64_save_or_restore_callee_save_registers (fp_offset, 1);\n+  aarch64_save_or_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t\tframe_pointer_needed\n+\t\t\t\t\t? R28_REGNUM : R30_REGNUM, true);\n+  aarch64_save_or_restore_callee_saves (DFmode, fp_offset, V0_REGNUM,\n+\t\t\t\t\tV31_REGNUM, true);\n \n   /* Restore the frame pointer and lr if the frame pointer is needed.  */\n   if (offset > 0)"}]}