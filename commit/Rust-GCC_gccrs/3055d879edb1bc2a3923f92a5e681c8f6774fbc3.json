{"sha": "3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1NWQ4NzllZGIxYmMyYTM5MjNmOTJhNWU2ODFjOGY2Nzc0ZmJjMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-07-19T10:23:43Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-07-19T10:23:43Z"}, "message": "Fix handling of implicit_pure by checking if non-pure procedures are called.\n\nProcedures are marked as implicit_pure if they fulfill the criteria of\npure procedures.  In this case, a procedure was not marked as not being\nimplicit_pure which called another procedure, which had not yet been\nmarked as not being implicit_impure.\n\nFixed by iterating over all procedures, setting callers of procedures\nwhich are non-pure and non-implicit_pure as non-implicit_pure and\ndoing this until no more procedure has been changed.\n\ngcc/fortran/ChangeLog:\n\n2020-07-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/96018\n\t* frontend-passes.c (gfc_check_externals): Adjust formatting.\n\t(implicit_pure_call): New function.\n\t(implicit_pure_expr): New function.\n\t(gfc_fix_implicit_pure): New function.\n\t* gfortran.h (gfc_fix_implicit_pure): New prototype.\n\t* parse.c (translate_all_program_units): Call gfc_fix_implicit_pure.", "tree": {"sha": "cbf5f39d4ecacf95398c417ad6f369b8ba71f01d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbf5f39d4ecacf95398c417ad6f369b8ba71f01d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/comments", "author": null, "committer": null, "parents": [{"sha": "7cc34b761cff2fd3b54fedec94aa1bddb59ac85e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc34b761cff2fd3b54fedec94aa1bddb59ac85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc34b761cff2fd3b54fedec94aa1bddb59ac85e"}], "stats": {"total": 169, "additions": 168, "deletions": 1}, "files": [{"sha": "cdeed8943b0eba83356efbae6e2479af0b00279d", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "patch": "@@ -5551,7 +5551,8 @@ gfc_check_externals0 (gfc_namespace *ns)\n \n /* Called routine.  */\n \n-void gfc_check_externals (gfc_namespace *ns)\n+void\n+gfc_check_externals (gfc_namespace *ns)\n {\n   gfc_clear_error ();\n \n@@ -5566,3 +5567,76 @@ void gfc_check_externals (gfc_namespace *ns)\n   gfc_errors_to_warnings (false);\n }\n \n+/* Callback function. If there is a call to a subroutine which is\n+   neither pure nor implicit_pure, unset the implicit_pure flag for\n+   the caller and return -1.  */\n+\n+static int\n+implicit_pure_call (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *sym_data)\n+{\n+  gfc_code *co = *c;\n+  gfc_symbol *caller_sym;\n+  symbol_attribute *a;\n+\n+  if (co->op != EXEC_CALL || co->resolved_sym == NULL)\n+    return 0;\n+\n+  a = &co->resolved_sym->attr;\n+  if (a->intrinsic || a->pure || a->implicit_pure)\n+    return 0;\n+\n+  caller_sym = (gfc_symbol *) sym_data;\n+  gfc_unset_implicit_pure (caller_sym);\n+  return 1;\n+}\n+\n+/* Callback function. If there is a call to a function which is\n+   neither pure nor implicit_pure, unset the implicit_pure flag for\n+   the caller and return 1.  */\n+\n+static int\n+implicit_pure_expr (gfc_expr **e, int *walk ATTRIBUTE_UNUSED, void *sym_data)\n+{\n+  gfc_expr *expr = *e;\n+  gfc_symbol *caller_sym;\n+  gfc_symbol *sym;\n+  symbol_attribute *a;\n+\n+  if (expr->expr_type != EXPR_FUNCTION || expr->value.function.isym)\n+    return 0;\n+\n+  sym = expr->symtree->n.sym;\n+  a = &sym->attr;\n+  if (a->pure || a->implicit_pure)\n+    return 0;\n+\n+  caller_sym = (gfc_symbol *) sym_data;\n+  gfc_unset_implicit_pure (caller_sym);\n+  return 1;\n+}\n+\n+/* Go through all procedures in the namespace and unset the\n+   implicit_pure attribute for any procedure that calls something not\n+   pure or implicit pure.  */\n+\n+bool\n+gfc_fix_implicit_pure (gfc_namespace *ns)\n+{\n+  bool changed = false;\n+  gfc_symbol *proc = ns->proc_name;\n+\n+  if (proc && proc->attr.flavor == FL_PROCEDURE && proc->attr.implicit_pure\n+      && ns->code\n+      && gfc_code_walker (&ns->code, implicit_pure_call, implicit_pure_expr,\n+\t\t\t  (void *) ns->proc_name))\n+    changed = true;\n+\n+  for (ns = ns->contained; ns; ns = ns->sibling)\n+    {\n+      if (gfc_fix_implicit_pure (ns))\n+\tchanged = true;\n+    }\n+\n+  return changed;\n+}"}, {"sha": "264822ef9f81171f456e8868013f62718c290bf9", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "patch": "@@ -3623,6 +3623,7 @@ int gfc_expr_walker (gfc_expr **, walk_expr_fn_t, void *);\n int gfc_code_walker (gfc_code **, walk_code_fn_t, walk_expr_fn_t, void *);\n bool gfc_has_dimen_vector_ref (gfc_expr *e);\n void gfc_check_externals (gfc_namespace *);\n+bool gfc_fix_implicit_pure (gfc_namespace *);\n \n /* simplify.c */\n "}, {"sha": "d30208febb15356ced57453efa01fa32ec438d17", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "patch": "@@ -6447,6 +6447,11 @@ gfc_parse_file (void)\n \n   gfc_resolve (gfc_current_ns);\n \n+  /* Fix the implicit_pure attribute for those procedures who should\n+     not have it.  */\n+  while (gfc_fix_implicit_pure (gfc_current_ns))\n+    ;\n+\n   /* Dump the parse tree if requested.  */\n   if (flag_dump_fortran_original)\n     gfc_dump_parse_tree (gfc_current_ns, stdout);\n@@ -6492,6 +6497,23 @@ gfc_parse_file (void)\n   /* Do the resolution.  */\n   resolve_all_program_units (gfc_global_ns_list);\n \n+  /* Go through all top-level namespaces and unset the implicit_pure\n+     attribute for any procedures that call something not pure or\n+     implicit_pure.  Because the a procedure marked as not implicit_pure\n+     in one sweep may be called by another routine, we repeat this\n+     process until there are no more changes.  */\n+  bool changed;\n+  do\n+    {\n+      changed = false;\n+      for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;\n+\t   gfc_current_ns = gfc_current_ns->sibling)\n+\t{\n+\t  if (gfc_fix_implicit_pure (gfc_current_ns))\n+\t    changed = true;\n+\t}\n+    }\n+  while (changed);\n \n   /* Fixup for external procedures.  */\n   for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;"}, {"sha": "67a6d9ca45ebda0fc9a30eaf3b7321923377b624", "filename": "gcc/testsuite/gfortran.dg/implicit_pure_5.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.c?ref=3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "patch": "@@ -0,0 +1,7 @@\n+#include <stdio.h>\n+\n+extern int num_calls;\n+int side_effect_c()\n+{\n+  num_calls ++;\n+}"}, {"sha": "7f1c887e3f9cf7df1663dba5cb9ff4dd465ac1ca", "filename": "gcc/testsuite/gfortran.dg/implicit_pure_5.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3055d879edb1bc2a3923f92a5e681c8f6774fbc3/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplicit_pure_5.f90?ref=3055d879edb1bc2a3923f92a5e681c8f6774fbc3", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+! { dg-additional-sources implicit_pure_5.c }\n+! PR fortran/96018 - a wrongly marked implicit_pure\n+! function caused wrong code.\n+module wrapper\n+  use, intrinsic :: iso_c_binding, only : c_int\n+  implicit none\n+  integer(kind=c_int), bind(C) :: num_calls\n+contains\n+\n+  integer function call_side_effect() result(ierr)\n+    call side_effect(ierr)\n+  end function call_side_effect\n+\n+  integer function inner_3d(array) result(ierr)\n+    real, intent(in) :: array(:,:,:)\n+    integer dimensions(3)\n+    dimensions = shape(array)\n+    ierr = call_side_effect()\n+  end function inner_3d\n+\n+  integer function inner_4d(array) result(ierr)\n+    real, intent(in) :: array(:,:,:,:)\n+    integer dimensions(4)\n+    dimensions = shape(array)\n+    ierr = call_side_effect()\n+  end function inner_4d\n+\n+  subroutine write_3d()\n+    real :: array(1,1,1)\n+    integer ierr\n+    ierr = inner_3d(array)\n+    ierr = call_side_effect()\n+  end subroutine write_3d\n+\n+  subroutine write_4d()\n+    real array(1,1,1,1)\n+    integer ierr\n+    ierr = inner_4d(array)\n+    ierr = call_side_effect()\n+  end subroutine write_4d\n+\n+  subroutine side_effect(ierr)\n+    integer, intent(out) :: ierr        ! Error code\n+    interface\n+       integer(c_int) function side_effect_c() bind(C,name='side_effect_c')\n+         use, intrinsic :: iso_c_binding, only: c_int\n+       end function side_effect_c\n+    end interface\n+    ierr = side_effect_c()\n+  end subroutine side_effect\n+\n+end module wrapper\n+\n+program self_contained\n+  use wrapper\n+  implicit none\n+  call write_3d()\n+  if (num_calls /= 2) stop 1\n+  call write_4d()\n+  if (num_calls /= 4) stop 2\n+end program self_contained\n+"}]}