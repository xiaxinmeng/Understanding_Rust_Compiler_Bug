{"sha": "2598550fa6d3583ce066a9aaf5abfa4acd186077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5ODU1MGZhNmQzNTgzY2UwNjZhOWFhZjVhYmZhNGFjZDE4NjA3Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-08-01T00:36:53Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-08-01T00:36:53Z"}, "message": "fold-const.c (fold <MULT_EXPR>): Optimize both x*pow(x,c) and pow(x,c)*x as pow(x,c+1) for constant values c.\n\n\n\t* fold-const.c (fold <MULT_EXPR>): Optimize both x*pow(x,c) and\n\tpow(x,c)*x as pow(x,c+1) for constant values c.  Optimize x*x\n\tas pow(x,2.0) when the latter will be expanded back into x*x.\n\t(fold <RDIV_EXPR>): Optimize pow(x,c)/x as pow(x,c-1).\n\t* builtins.c (expand_builtin_pow): Ignore flag_errno_math as\n\tpow can never set errno when used with an integer exponent.\n\tAlways use expand_powi when exponent is -1, 0, 1 or 2.\n\t(fold_builtin): Don't rewrite pow(x,2.0) as x*x nor pow(x,-2.0)\n\tas 1.0/(x*x).  This avoids unbounded recursion as we now prefer\n\tthe pow forms of these expressions.\n\n\t* gcc.dg/builtins-27.c: New test case.\n\nFrom-SVN: r70030", "tree": {"sha": "a842e3f3e11953156cef321cf6510aeed77635b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a842e3f3e11953156cef321cf6510aeed77635b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2598550fa6d3583ce066a9aaf5abfa4acd186077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2598550fa6d3583ce066a9aaf5abfa4acd186077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2598550fa6d3583ce066a9aaf5abfa4acd186077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2598550fa6d3583ce066a9aaf5abfa4acd186077/comments", "author": null, "committer": null, "parents": [{"sha": "e3da5a9a50524344c9b80ee1b8f2a8639493dd46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3da5a9a50524344c9b80ee1b8f2a8639493dd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3da5a9a50524344c9b80ee1b8f2a8639493dd46"}], "stats": {"total": 209, "additions": 177, "deletions": 32}, "files": [{"sha": "7590ddd24441e04a026bbf47edcf2b66d6753d34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2598550fa6d3583ce066a9aaf5abfa4acd186077", "patch": "@@ -1,3 +1,16 @@\n+2003-07-31  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold <MULT_EXPR>): Optimize both x*pow(x,c) and\n+\tpow(x,c)*x as pow(x,c+1) for constant values c.  Optimize x*x\n+\tas pow(x,2.0) when the latter will be expanded back into x*x.\n+\t(fold <RDIV_EXPR>): Optimize pow(x,c)/x as pow(x,c-1).\n+\t* builtins.c (expand_builtin_pow): Ignore flag_errno_math as\n+\tpow can never set errno when used with an integer exponent.\n+\tAlways use expand_powi when exponent is -1, 0, 1 or 2.\n+\t(fold_builtin): Don't rewrite pow(x,2.0) as x*x nor pow(x,-2.0)\n+\tas 1.0/(x*x).  This avoids unbounded recursion as we now prefer\n+\tthe pow forms of these expressions.\n+\n 2003-07-31  Geoffrey Keating  <geoffk@apple.com>\n \n \t* Makefile.in (libexecdir): New."}, {"sha": "535b84cb09d7c03c16c3cfc540f2b07a84b8e26b", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2598550fa6d3583ce066a9aaf5abfa4acd186077", "patch": "@@ -2170,10 +2170,7 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n \n-  if (flag_unsafe_math_optimizations\n-      && ! flag_errno_math\n-      && ! optimize_size\n-      && TREE_CODE (arg1) == REAL_CST\n+  if (TREE_CODE (arg1) == REAL_CST\n       && ! TREE_CONSTANT_OVERFLOW (arg1))\n     {\n       REAL_VALUE_TYPE cint;\n@@ -2183,13 +2180,21 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n       c = TREE_REAL_CST (arg1);\n       n = real_to_integer (&c);\n       real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n-      if (real_identical (&c, &cint)\n-\t  && powi_cost (n) <= POWI_MAX_MULTS)\n+      if (real_identical (&c, &cint))\n \t{\n-          enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-          rtx op = expand_expr (arg0, subtarget, VOIDmode, 0);\n-          op = force_reg (mode, op);\n-          return expand_powi (op, mode, n);\n+\t  /* If the exponent is -1, 0, 1 or 2, then expand_powi is exact.\n+\t     Otherwise, check the number of multiplications required.\n+\t     Note that pow never sets errno for an integer exponent.  */\n+\t  if ((n >= -1 && n <= 2)\n+\t      || (flag_unsafe_math_optimizations\n+\t\t  && ! optimize_size\n+\t\t  && powi_cost (n) <= POWI_MAX_MULTS))\n+\t    {\n+\t      enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+\t      rtx op = expand_expr (arg0, subtarget, VOIDmode, 0);\n+\t      op = force_reg (mode, op);\n+\t      return expand_powi (op, mode, n);\n+\t    }\n \t}\n     }\n   return expand_builtin_mathfn_2 (exp, target, NULL_RTX);\n@@ -6245,28 +6250,6 @@ fold_builtin (tree exp)\n \t\t\t\t    build_real (type, dconst1),\n \t\t\t\t    arg0));\n \n-\t      /* Optimize pow(x,2.0) = x*x.  */\n-\t      if (REAL_VALUES_EQUAL (c, dconst2)\n-\t\t  && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n-\t\t{\n-\t\t  arg0 = save_expr (arg0);\n-\t\t  return fold (build (MULT_EXPR, type, arg0, arg0));\n-\t\t}\n-\n-\t      /* Optimize pow(x,-2.0) = 1.0/(x*x).  */\n-\t      if (flag_unsafe_math_optimizations\n-\t\t  && REAL_VALUES_EQUAL (c, dconstm2)\n-\t\t  && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t\t  && ! CONTAINS_PLACEHOLDER_P (arg0))\n-\t\t{\n-\t\t  arg0 = save_expr (arg0);\n-\t\t  return fold (build (RDIV_EXPR, type,\n-\t\t\t\t      build_real (type, dconst1),\n-\t\t\t\t      fold (build (MULT_EXPR, type,\n-\t\t\t\t\t\t   arg0, arg0))));\n-\t\t}\n-\n \t      /* Optimize pow(x,0.5) = sqrt(x).  */\n \t      if (flag_unsafe_math_optimizations\n \t\t  && REAL_VALUES_EQUAL (c, dconsthalf))"}, {"sha": "c4faf075d0d77584feb547538b32092e959d91b2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2598550fa6d3583ce066a9aaf5abfa4acd186077", "patch": "@@ -6071,6 +6071,80 @@ fold (tree expr)\n \t\t    return build_function_call_expr (sinfn,\n \t\t\t\t\t\t     TREE_OPERAND (arg0, 1));\n \t\t}\n+\n+\t      /* Optimize x*pow(x,c) as pow(x,c+1).  */\n+\t      if (fcode1 == BUILT_IN_POW\n+\t\t  || fcode1 == BUILT_IN_POWF\n+\t\t  || fcode1 == BUILT_IN_POWL)\n+\t\t{\n+\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n+\t\t\t\t\t\t\t\t     1)));\n+\t\t  if (TREE_CODE (arg11) == REAL_CST\n+\t\t      && ! TREE_CONSTANT_OVERFLOW (arg11)\n+\t\t      && operand_equal_p (arg0, arg10, 0))\n+\t\t    {\n+\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n+\t\t      REAL_VALUE_TYPE c;\n+\t\t      tree arg, arglist;\n+\n+\t\t      c = TREE_REAL_CST (arg11);\n+\t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n+\t\t      arg = build_real (type, c);\n+\t\t      arglist = build_tree_list (NULL_TREE, arg);\n+\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n+\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t    }\n+\t\t}\n+\n+\t      /* Optimize pow(x,c)*x as pow(x,c+1).  */\n+\t      if (fcode0 == BUILT_IN_POW\n+\t\t  || fcode0 == BUILT_IN_POWF\n+\t\t  || fcode0 == BUILT_IN_POWL)\n+\t\t{\n+\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n+\t\t\t\t\t\t\t\t     1)));\n+\t\t  if (TREE_CODE (arg01) == REAL_CST\n+\t\t      && ! TREE_CONSTANT_OVERFLOW (arg01)\n+\t\t      && operand_equal_p (arg1, arg00, 0))\n+\t\t    {\n+\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      REAL_VALUE_TYPE c;\n+\t\t      tree arg, arglist;\n+\n+\t\t      c = TREE_REAL_CST (arg01);\n+\t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n+\t\t      arg = build_real (type, c);\n+\t\t      arglist = build_tree_list (NULL_TREE, arg);\n+\t\t      arglist = tree_cons (NULL_TREE, arg1, arglist);\n+\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t    }\n+\t\t}\n+\n+\t      /* Optimize x*x as pow(x,2.0), which is expanded as x*x.  */\n+\t      if (! optimize_size\n+\t\t  && operand_equal_p (arg0, arg1, 0))\n+\t\t{\n+\t\t  tree powfn;\n+\n+\t\t  if (type == double_type_node)\n+\t\t    powfn = implicit_built_in_decls[BUILT_IN_POW];\n+\t\t  else if (type == float_type_node)\n+\t\t    powfn = implicit_built_in_decls[BUILT_IN_POWF];\n+\t\t  else if (type == long_double_type_node)\n+\t\t    powfn = implicit_built_in_decls[BUILT_IN_POWL];\n+\t\t  else\n+\t\t    powfn = NULL_TREE;\n+\n+\t\t  if (powfn)\n+\t\t    {\n+\t\t      tree arg = build_real (type, dconst2);\n+\t\t      tree arglist = build_tree_list (NULL_TREE, arg);\n+\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n+\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n       goto associate;\n@@ -6328,6 +6402,30 @@ fold (tree expr)\n \t\t\t\t      tmp));\n \t\t}\n \t    }\n+\n+\t  /* Optimize pow(x,c)/x as pow(x,c-1).  */\n+\t  if (fcode0 == BUILT_IN_POW\n+\t      || fcode0 == BUILT_IN_POWF\n+\t      || fcode0 == BUILT_IN_POWL)\n+\t    {\n+\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n+\t      if (TREE_CODE (arg01) == REAL_CST\n+\t\t  && ! TREE_CONSTANT_OVERFLOW (arg01)\n+\t\t  && operand_equal_p (arg1, arg00, 0))\n+\t\t{\n+\t\t  tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t  REAL_VALUE_TYPE c;\n+\t\t  tree arg, arglist;\n+\n+\t\t  c = TREE_REAL_CST (arg01);\n+\t\t  real_arithmetic (&c, MINUS_EXPR, &c, &dconst1);\n+\t\t  arg = build_real (type, c);\n+\t\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t\t  arglist = tree_cons (NULL_TREE, arg1, arglist);\n+\t\t  return build_function_call_expr (powfn, arglist);\n+\t\t}\n+\t    }\n \t}\n       goto binary;\n "}, {"sha": "26e44a3bfbe9dd75fd43deaff785a462dc595754", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2598550fa6d3583ce066a9aaf5abfa4acd186077", "patch": "@@ -1,3 +1,7 @@\n+2003-07-31  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-27.c: New test case.\n+\n 2003-07-31  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/tls/opt-7.c: New test."}, {"sha": "69d8f994481c3a4256e38985c30edaf4ac22755c", "filename": "gcc/testsuite/gcc.dg/builtins-27.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2598550fa6d3583ce066a9aaf5abfa4acd186077/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-27.c?ref=2598550fa6d3583ce066a9aaf5abfa4acd186077", "patch": "@@ -0,0 +1,47 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of built-in math functions doesn't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 29th July 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern void link_error(void);\n+\n+extern double pow(double,double);\n+\n+void test(double x)\n+{\n+  if (pow(x,2.0) != x*x)\n+    link_error ();\n+\n+  if (x*pow(x,2.0) != pow(x,3.0))\n+    link_error ();\n+\n+  if (pow(x,2.0)*x != pow(x,3.0))\n+    link_error ();\n+\n+  if (pow(x,3.0) != x*x*x)\n+    link_error ();\n+\n+  if (pow(x,2.0)*x != x*x*x)\n+    link_error ();\n+\n+  if (x*pow(x,2.0) != x*x*x)\n+    link_error ();\n+\n+  if (pow(x,3.0)/x != pow(x,2.0))\n+    link_error ();\n+\n+  if (pow(x,3.0)/x != x*x)\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  test (2.0);\n+  return 0;\n+}\n+"}]}