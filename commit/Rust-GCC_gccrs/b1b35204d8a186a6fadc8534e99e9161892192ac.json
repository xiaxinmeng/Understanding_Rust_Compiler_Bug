{"sha": "b1b35204d8a186a6fadc8534e99e9161892192ac", "node_id": "C_kwDOANBUbNoAKGIxYjM1MjA0ZDhhMTg2YTZmYWRjODUzNGU5OWU5MTYxODkyMTkyYWM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-23T15:31:17Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add unsafe checks for Rust\n\nThe UnsafeChecker visitor verifies that unsafe actions are only performed\nin unsafe contexts. Otherwise, an error should be reported to the user and\nthe compilation pipeline should be halted. These contexts, which include\nunsafe blocks or unsafe functions, are allowed to perform more actions\nthan regular safe Rust code. These actions currently include:\n\n- Dereferencing raw pointers\n- Calls to unsafe functions\n- Use of inline assembly\n- Use of mutable static\n- Use of extern static\n- Access to a union's field\n- Call to functions with #[target(feature)] attribute\n- Initializing type with rustc_layout_scalar_valid_range attribute\n- Mutation of layout constrained field\n- Borrow of layout constrained field\n\n\tgcc/rust/\n\t* checks/errors/rust-unsafe-checker.cc: New.\n\t* checks/errors/rust-unsafe-checker.h: New.", "tree": {"sha": "cf4c292fb42affbd0293c30229fb6cb510a5a059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf4c292fb42affbd0293c30229fb6cb510a5a059"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1b35204d8a186a6fadc8534e99e9161892192ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b35204d8a186a6fadc8534e99e9161892192ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1b35204d8a186a6fadc8534e99e9161892192ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1b35204d8a186a6fadc8534e99e9161892192ac/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06688fe40a249a406634d3307f662e2fe2e0c517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06688fe40a249a406634d3307f662e2fe2e0c517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06688fe40a249a406634d3307f662e2fe2e0c517"}], "stats": {"total": 1154, "additions": 1154, "deletions": 0}, "files": [{"sha": "e3f325395628092b2381b16c4a1e5fb3823ef6c2", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.cc", "status": "added", "additions": 963, "deletions": 0, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b35204d8a186a6fadc8534e99e9161892192ac/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b35204d8a186a6fadc8534e99e9161892192ac/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.cc?ref=b1b35204d8a186a6fadc8534e99e9161892192ac", "patch": "@@ -0,0 +1,963 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-unsafe-checker.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+UnsafeChecker::UnsafeChecker ()\n+  : context (*Resolver::TypeCheckContext::get ()),\n+    resolver (*Resolver::Resolver::get ()),\n+    mappings (*Analysis::Mappings::get ())\n+{}\n+\n+void\n+UnsafeChecker::go (HIR::Crate &crate)\n+{\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+static void\n+check_static_mut (HIR::Item *maybe_static, Location locus)\n+{\n+  if (maybe_static->get_hir_kind () == Node::BaseKind::VIS_ITEM)\n+    {\n+      auto item = static_cast<Item *> (maybe_static);\n+      if (item->get_item_kind () == Item::ItemKind::Static)\n+\t{\n+\t  auto static_item = static_cast<StaticItem *> (item);\n+\t  if (static_item->is_mut ())\n+\t    rust_error_at (\n+\t      locus, \"use of mutable static requires unsafe function or block\");\n+\t}\n+    }\n+}\n+\n+static void\n+check_extern_static (HIR::ExternalItem *maybe_static, Location locus)\n+{\n+  if (maybe_static->get_extern_kind () == ExternalItem::ExternKind::Static)\n+    rust_error_at (locus,\n+\t\t   \"use of extern static requires unsafe function or block\");\n+}\n+\n+void\n+UnsafeChecker::check_use_of_static (HirId node_id, Location locus)\n+{\n+  if (unsafe_context.is_in_context ())\n+    return;\n+\n+  auto maybe_static_mut = mappings.lookup_hir_item (node_id);\n+\n+  HirId extern_block;\n+  auto maybe_extern_static\n+    = mappings.lookup_hir_extern_item (node_id, &extern_block);\n+\n+  if (maybe_static_mut)\n+    check_static_mut (maybe_static_mut, locus);\n+\n+  if (maybe_extern_static)\n+    check_extern_static (static_cast<ExternalItem *> (maybe_extern_static),\n+\t\t\t locus);\n+}\n+\n+static void\n+check_unsafe_call (HIR::Function *fn, Location locus, const std::string &kind)\n+{\n+  if (fn->get_qualifiers ().is_unsafe ())\n+    rust_error_at (locus, \"call to unsafe %s requires unsafe function or block\",\n+\t\t   kind.c_str ());\n+}\n+\n+static bool\n+is_safe_intrinsic (const std::string &fn_name)\n+{\n+  static const std::unordered_set<std::string> safe_intrinsics = {\n+    \"abort\",\n+    \"size_of\",\n+    \"min_align_of\",\n+    \"needs_drop\",\n+    \"caller_location\",\n+    \"add_with_overflow\",\n+    \"sub_with_overflow\",\n+    \"mul_with_overflow\",\n+    \"wrapping_add\",\n+    \"wrapping_sub\",\n+    \"wrapping_mul\",\n+    \"saturating_add\",\n+    \"saturating_sub\",\n+    \"rotate_left\",\n+    \"rotate_right\",\n+    \"ctpop\",\n+    \"ctlz\",\n+    \"cttz\",\n+    \"bswap\",\n+    \"bitreverse\",\n+    \"discriminant_value\",\n+    \"type_id\",\n+    \"likely\",\n+    \"unlikely\",\n+    \"ptr_guaranteed_eq\",\n+    \"ptr_guaranteed_ne\",\n+    \"minnumf32\",\n+    \"minnumf64\",\n+    \"maxnumf32\",\n+    \"rustc_peek\",\n+    \"maxnumf64\",\n+    \"type_name\",\n+    \"forget\",\n+    \"black_box\",\n+    \"variant_count\",\n+  };\n+\n+  return safe_intrinsics.find (fn_name) != safe_intrinsics.end ();\n+}\n+\n+static void\n+check_extern_call (HIR::ExternalItem *maybe_fn, HIR::ExternBlock *parent_block,\n+\t\t   Location locus)\n+{\n+  // We have multiple operations to perform here\n+  //     1. Is the item an actual function we're calling\n+  //     2. Is the block it's defined in an FFI block or an `extern crate` block\n+  //\n+  // It is not unsafe to call into other crates, so items defined in an `extern\n+  // crate` must be callable without being in an unsafe context. On the other\n+  // hand, any function defined in a block with a specific ABI (even `extern\n+  // \"Rust\"` blocks) is unsafe to call\n+\n+  if (maybe_fn->get_extern_kind () != ExternalItem::ExternKind::Function)\n+    return;\n+\n+  // Some intrinsics are safe to call\n+  if (parent_block->get_abi () == Rust::ABI::INTRINSIC\n+      && is_safe_intrinsic (maybe_fn->get_item_name ()))\n+    return;\n+\n+  rust_error_at (locus,\n+\t\t \"call to extern function requires unsafe function or block\");\n+}\n+\n+void\n+UnsafeChecker::check_function_call (HirId node_id, Location locus)\n+{\n+  if (unsafe_context.is_in_context ())\n+    return;\n+\n+  HirId parent_extern_block;\n+  auto maybe_fn = mappings.lookup_hir_item (node_id);\n+  auto maybe_extern\n+    = mappings.lookup_hir_extern_item (node_id, &parent_extern_block);\n+\n+  if (maybe_fn && maybe_fn->get_item_kind () == Item::ItemKind::Function)\n+    check_unsafe_call (static_cast<Function *> (maybe_fn), locus, \"function\");\n+\n+  if (maybe_extern)\n+    check_extern_call (static_cast<ExternalItem *> (maybe_extern),\n+\t\t       mappings.lookup_hir_extern_block (parent_extern_block),\n+\t\t       locus);\n+}\n+\n+void\n+UnsafeChecker::visit (Lifetime &lifetime)\n+{}\n+\n+void\n+UnsafeChecker::visit (LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+UnsafeChecker::visit (PathInExpression &path)\n+{\n+  NodeId ast_node_id = path.get_mappings ().get_nodeid ();\n+  NodeId ref_node_id;\n+  HirId definition_id;\n+\n+  if (!resolver.lookup_resolved_name (ast_node_id, &ref_node_id))\n+    return;\n+\n+  rust_assert (mappings.lookup_node_to_hir (ref_node_id, &definition_id));\n+\n+  check_use_of_static (definition_id, path.get_locus ());\n+}\n+\n+void\n+UnsafeChecker::visit (TypePathSegment &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypePath &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (QualifiedPathInExpression &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (QualifiedPathInType &path)\n+{}\n+\n+void\n+UnsafeChecker::visit (LiteralExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BorrowExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (DereferenceExpr &expr)\n+{\n+  TyTy::BaseType *to_deref_type;\n+  auto to_deref = expr.get_expr ()->get_mappings ().get_hirid ();\n+\n+  rust_assert (context.lookup_type (to_deref, &to_deref_type));\n+\n+  if (to_deref_type->get_kind () == TyTy::TypeKind::POINTER\n+      && !unsafe_context.is_in_context ())\n+    rust_error_at (expr.get_locus (), \"dereference of raw pointer requires \"\n+\t\t\t\t      \"unsafe function or block\");\n+}\n+\n+void\n+UnsafeChecker::visit (ErrorPropagationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (NegationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArithmeticOrLogicalExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ComparisonExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (LazyBooleanExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TypeCastExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (AssignmentExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (CompoundAssignmentExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (GroupedExpr &expr)\n+{\n+  expr.get_expr_in_parens ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    elem->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayElemsCopied &elems)\n+{\n+  elems.get_elem_to_copy ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayExpr &expr)\n+{\n+  expr.get_internal_elements ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ArrayIndexExpr &expr)\n+{\n+  expr.get_array_expr ()->accept_vis (*this);\n+  expr.get_index_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TupleExpr &expr)\n+{\n+  for (auto &elem : expr.get_tuple_elems ())\n+    elem->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TupleIndexExpr &expr)\n+{\n+  expr.get_tuple_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStruct &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIdentifierValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprFieldIndexValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStructFields &expr)\n+{\n+  for (auto &field : expr.get_fields ())\n+    field->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StructExprStructBase &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (CallExpr &expr)\n+{\n+  auto fn = expr.get_fnexpr ();\n+  if (!fn)\n+    return;\n+\n+  NodeId ast_node_id = fn->get_mappings ().get_nodeid ();\n+  NodeId ref_node_id;\n+  HirId definition_id;\n+\n+  // There are no unsafe types, and functions are defined in the name resolver.\n+  // If we can't find the name, then we're dealing with a type and should return\n+  // early.\n+  if (!resolver.lookup_resolved_name (ast_node_id, &ref_node_id))\n+    return;\n+\n+  rust_assert (mappings.lookup_node_to_hir (ref_node_id, &definition_id));\n+\n+  // At this point we have the function's HIR Id. There are two checks we\n+  // must perform:\n+  //     1. The function is an unsafe one\n+  //     2. The function is an extern one\n+  check_function_call (definition_id, expr.get_locus ());\n+\n+  if (expr.has_params ())\n+    for (auto &arg : expr.get_arguments ())\n+      arg->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (MethodCallExpr &expr)\n+{\n+  TyTy::BaseType *method_type;\n+  context.lookup_type (expr.get_method_name ().get_mappings ().get_hirid (),\n+\t\t       &method_type);\n+\n+  auto fn = *static_cast<TyTy::FnType *> (method_type);\n+  auto method = mappings.lookup_hir_implitem (fn.get_ref (), nullptr);\n+\n+  if (!unsafe_context.is_in_context () && method)\n+    check_unsafe_call (static_cast<Function *> (method), expr.get_locus (),\n+\t\t       \"method\");\n+\n+  expr.get_receiver ()->accept_vis (*this);\n+\n+  for (auto &arg : expr.get_arguments ())\n+    arg->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (FieldAccessExpr &expr)\n+{\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+\n+  if (unsafe_context.is_in_context ())\n+    return;\n+\n+  TyTy::BaseType *receiver_ty;\n+  auto ok = context.lookup_type (\n+    expr.get_receiver_expr ()->get_mappings ().get_hirid (), &receiver_ty);\n+  rust_assert (ok);\n+\n+  if (receiver_ty->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      auto maybe_union = static_cast<TyTy::ADTType *> (receiver_ty);\n+      if (maybe_union->is_union ())\n+\trust_error_at (\n+\t  expr.get_locus (),\n+\t  \"access to union field requires unsafe function or block\");\n+    }\n+}\n+\n+void\n+UnsafeChecker::visit (ClosureExprInner &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BlockExpr &expr)\n+{\n+  for (auto &stmt : expr.get_statements ())\n+    stmt->accept_vis (*this);\n+\n+  if (expr.has_expr ())\n+    expr.get_final_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (ContinueExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (BreakExpr &expr)\n+{\n+  if (expr.has_break_expr ())\n+    expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFromToExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFromExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeToExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeFullExpr &expr)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangeFromToInclExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (RangeToInclExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ReturnExpr &expr)\n+{\n+  if (expr.has_return_expr ())\n+    expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (UnsafeBlockExpr &expr)\n+{\n+  unsafe_context.enter (expr.get_mappings ().get_hirid ());\n+\n+  expr.get_block_expr ()->accept_vis (*this);\n+\n+  unsafe_context.exit ();\n+}\n+\n+void\n+UnsafeChecker::visit (LoopExpr &expr)\n+{\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (WhileLoopExpr &expr)\n+{\n+  expr.get_predicate_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (WhileLetLoopExpr &expr)\n+{\n+  expr.get_cond ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ForLoopExpr &expr)\n+{\n+  expr.get_iterator_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExpr &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqElse &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_else_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqIf &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfExprConseqIfLet &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit conseq if let expression\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqElse &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit else expression\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqIf &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (IfLetExprConseqIfLet &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: Visit conseq if let expression\n+}\n+\n+void\n+UnsafeChecker::visit (MatchExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+\n+  for (auto &match_arm : expr.get_match_cases ())\n+    match_arm.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (AwaitExpr &expr)\n+{\n+  // TODO: Visit expression\n+}\n+\n+void\n+UnsafeChecker::visit (AsyncBlockExpr &expr)\n+{\n+  // TODO: Visit block expression\n+}\n+\n+void\n+UnsafeChecker::visit (TypeParam &param)\n+{}\n+\n+void\n+UnsafeChecker::visit (ConstGenericParam &param)\n+{}\n+\n+void\n+UnsafeChecker::visit (LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExternCrate &crate)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeGlob &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeList &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseTreeRebind &use_tree)\n+{}\n+\n+void\n+UnsafeChecker::visit (UseDeclaration &use_decl)\n+{}\n+\n+void\n+UnsafeChecker::visit (Function &function)\n+{\n+  auto is_unsafe_fn = function.get_qualifiers ().is_unsafe ();\n+\n+  if (is_unsafe_fn)\n+    unsafe_context.enter (function.get_mappings ().get_hirid ());\n+\n+  function.get_definition ()->accept_vis (*this);\n+\n+  if (is_unsafe_fn)\n+    unsafe_context.exit ();\n+}\n+\n+void\n+UnsafeChecker::visit (TypeAlias &type_alias)\n+{\n+  // FIXME: What do we need to do to handle type aliasing? Is it possible to\n+  // have unsafe types? Type aliases on unsafe functions?\n+}\n+\n+void\n+UnsafeChecker::visit (StructStruct &struct_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStruct &tuple_struct)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemTuple &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemStruct &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (EnumItemDiscriminant &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Enum &enum_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Union &union_item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ConstantItem &const_item)\n+{\n+  const_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (StaticItem &static_item)\n+{\n+  static_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemFunc &item)\n+{\n+  if (item.has_block_defined ())\n+    item.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemConst &item)\n+{\n+  if (item.has_expr ())\n+    item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitItemType &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (Trait &trait)\n+{\n+  // FIXME: Handle unsafe traits\n+  for (auto &item : trait.get_trait_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ImplBlock &impl)\n+{\n+  // FIXME: Handle unsafe impls\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExternalStaticItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ExternalFunctionItem &item)\n+{}\n+\n+void\n+UnsafeChecker::visit (ExternBlock &block)\n+{\n+  // FIXME: Do we need to do this?\n+  for (auto &item : block.get_extern_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (LiteralPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (IdentifierPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (WildcardPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundPath &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (RangePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (ReferencePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPatternFieldIdent &field)\n+{}\n+\n+void\n+UnsafeChecker::visit (StructPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleStructPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+UnsafeChecker::visit (TuplePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (GroupedPattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (SlicePattern &pattern)\n+{}\n+\n+void\n+UnsafeChecker::visit (EmptyStmt &stmt)\n+{}\n+\n+void\n+UnsafeChecker::visit (LetStmt &stmt)\n+{\n+  if (stmt.has_init_expr ())\n+    stmt.get_init_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExprStmtWithoutBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (ExprStmtWithBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+UnsafeChecker::visit (TraitBound &bound)\n+{}\n+\n+void\n+UnsafeChecker::visit (ImplTraitType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (TraitObjectType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ParenthesisedType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (TupleType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (NeverType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (RawPointerType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ReferenceType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (ArrayType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (SliceType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (InferredType &type)\n+{}\n+\n+void\n+UnsafeChecker::visit (BareFunctionType &type)\n+{}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "ae1eb509d781a2154b94bb706b5d0a67cf8ea3f4", "filename": "gcc/rust/checks/errors/rust-unsafe-checker.h", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1b35204d8a186a6fadc8534e99e9161892192ac/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1b35204d8a186a6fadc8534e99e9161892192ac/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-unsafe-checker.h?ref=b1b35204d8a186a6fadc8534e99e9161892192ac", "patch": "@@ -0,0 +1,191 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_UNSAFE_CHECKER_H\n+#define RUST_UNSAFE_CHECKER_H\n+\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-stacked-contexts.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+class UnsafeChecker : public HIRFullVisitor\n+{\n+public:\n+  UnsafeChecker ();\n+\n+  void go (HIR::Crate &crate);\n+\n+private:\n+  /**\n+   * Check if a mutable static or external static item is used outside of an\n+   * unsafe context\n+   */\n+  void check_use_of_static (HirId node_id, Location locus);\n+\n+  /**\n+   * Check if a call to an unsafe or external function is outside of an unsafe\n+   * context\n+   */\n+  void check_function_call (HirId node_id, Location locus);\n+\n+  StackedContexts<HirId> unsafe_context;\n+\n+  Resolver::TypeCheckContext &context;\n+  Resolver::Resolver &resolver;\n+  Analysis::Mappings &mappings;\n+\n+  virtual void visit (Lifetime &lifetime) override;\n+  virtual void visit (LifetimeParam &lifetime_param) override;\n+  virtual void visit (PathInExpression &path) override;\n+  virtual void visit (TypePathSegment &segment) override;\n+  virtual void visit (TypePathSegmentGeneric &segment) override;\n+  virtual void visit (TypePathSegmentFunction &segment) override;\n+  virtual void visit (TypePath &path) override;\n+  virtual void visit (QualifiedPathInExpression &path) override;\n+  virtual void visit (QualifiedPathInType &path) override;\n+  virtual void visit (LiteralExpr &expr) override;\n+  virtual void visit (BorrowExpr &expr) override;\n+  virtual void visit (DereferenceExpr &expr) override;\n+  virtual void visit (ErrorPropagationExpr &expr) override;\n+  virtual void visit (NegationExpr &expr) override;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) override;\n+  virtual void visit (ComparisonExpr &expr) override;\n+  virtual void visit (LazyBooleanExpr &expr) override;\n+  virtual void visit (TypeCastExpr &expr) override;\n+  virtual void visit (AssignmentExpr &expr) override;\n+  virtual void visit (CompoundAssignmentExpr &expr) override;\n+  virtual void visit (GroupedExpr &expr) override;\n+  virtual void visit (ArrayElemsValues &elems) override;\n+  virtual void visit (ArrayElemsCopied &elems) override;\n+  virtual void visit (ArrayExpr &expr) override;\n+  virtual void visit (ArrayIndexExpr &expr) override;\n+  virtual void visit (TupleExpr &expr) override;\n+  virtual void visit (TupleIndexExpr &expr) override;\n+  virtual void visit (StructExprStruct &expr) override;\n+  virtual void visit (StructExprFieldIdentifier &field) override;\n+  virtual void visit (StructExprFieldIdentifierValue &field) override;\n+  virtual void visit (StructExprFieldIndexValue &field) override;\n+  virtual void visit (StructExprStructFields &expr) override;\n+  virtual void visit (StructExprStructBase &expr) override;\n+  virtual void visit (CallExpr &expr) override;\n+  virtual void visit (MethodCallExpr &expr) override;\n+  virtual void visit (FieldAccessExpr &expr) override;\n+  virtual void visit (ClosureExprInner &expr) override;\n+  virtual void visit (BlockExpr &expr) override;\n+  virtual void visit (ClosureExprInnerTyped &expr) override;\n+  virtual void visit (ContinueExpr &expr) override;\n+  virtual void visit (BreakExpr &expr) override;\n+  virtual void visit (RangeFromToExpr &expr) override;\n+  virtual void visit (RangeFromExpr &expr) override;\n+  virtual void visit (RangeToExpr &expr) override;\n+  virtual void visit (RangeFullExpr &expr) override;\n+  virtual void visit (RangeFromToInclExpr &expr) override;\n+  virtual void visit (RangeToInclExpr &expr) override;\n+  virtual void visit (ReturnExpr &expr) override;\n+  virtual void visit (UnsafeBlockExpr &expr) override;\n+  virtual void visit (LoopExpr &expr) override;\n+  virtual void visit (WhileLoopExpr &expr) override;\n+  virtual void visit (WhileLetLoopExpr &expr) override;\n+  virtual void visit (ForLoopExpr &expr) override;\n+  virtual void visit (IfExpr &expr) override;\n+  virtual void visit (IfExprConseqElse &expr) override;\n+  virtual void visit (IfExprConseqIf &expr) override;\n+  virtual void visit (IfExprConseqIfLet &expr) override;\n+  virtual void visit (IfLetExpr &expr) override;\n+  virtual void visit (IfLetExprConseqElse &expr) override;\n+  virtual void visit (IfLetExprConseqIf &expr) override;\n+  virtual void visit (IfLetExprConseqIfLet &expr) override;\n+  virtual void visit (MatchExpr &expr) override;\n+  virtual void visit (AwaitExpr &expr) override;\n+  virtual void visit (AsyncBlockExpr &expr) override;\n+  virtual void visit (TypeParam &param) override;\n+  virtual void visit (ConstGenericParam &param) override;\n+  virtual void visit (LifetimeWhereClauseItem &item) override;\n+  virtual void visit (TypeBoundWhereClauseItem &item) override;\n+  virtual void visit (Module &module) override;\n+  virtual void visit (ExternCrate &crate) override;\n+  virtual void visit (UseTreeGlob &use_tree) override;\n+  virtual void visit (UseTreeList &use_tree) override;\n+  virtual void visit (UseTreeRebind &use_tree) override;\n+  virtual void visit (UseDeclaration &use_decl) override;\n+  virtual void visit (Function &function) override;\n+  virtual void visit (TypeAlias &type_alias) override;\n+  virtual void visit (StructStruct &struct_item) override;\n+  virtual void visit (TupleStruct &tuple_struct) override;\n+  virtual void visit (EnumItem &item) override;\n+  virtual void visit (EnumItemTuple &item) override;\n+  virtual void visit (EnumItemStruct &item) override;\n+  virtual void visit (EnumItemDiscriminant &item) override;\n+  virtual void visit (Enum &enum_item) override;\n+  virtual void visit (Union &union_item) override;\n+  virtual void visit (ConstantItem &const_item) override;\n+  virtual void visit (StaticItem &static_item) override;\n+  virtual void visit (TraitItemFunc &item) override;\n+  virtual void visit (TraitItemConst &item) override;\n+  virtual void visit (TraitItemType &item) override;\n+  virtual void visit (Trait &trait) override;\n+  virtual void visit (ImplBlock &impl) override;\n+  virtual void visit (ExternalStaticItem &item) override;\n+  virtual void visit (ExternalFunctionItem &item) override;\n+  virtual void visit (ExternBlock &block) override;\n+  virtual void visit (LiteralPattern &pattern) override;\n+  virtual void visit (IdentifierPattern &pattern) override;\n+  virtual void visit (WildcardPattern &pattern) override;\n+  virtual void visit (RangePatternBoundLiteral &bound) override;\n+  virtual void visit (RangePatternBoundPath &bound) override;\n+  virtual void visit (RangePatternBoundQualPath &bound) override;\n+  virtual void visit (RangePattern &pattern) override;\n+  virtual void visit (ReferencePattern &pattern) override;\n+  virtual void visit (StructPatternFieldTuplePat &field) override;\n+  virtual void visit (StructPatternFieldIdentPat &field) override;\n+  virtual void visit (StructPatternFieldIdent &field) override;\n+  virtual void visit (StructPattern &pattern) override;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) override;\n+  virtual void visit (TupleStructItemsRange &tuple_items) override;\n+  virtual void visit (TupleStructPattern &pattern) override;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) override;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) override;\n+  virtual void visit (TuplePattern &pattern) override;\n+  virtual void visit (GroupedPattern &pattern) override;\n+  virtual void visit (SlicePattern &pattern) override;\n+  virtual void visit (EmptyStmt &stmt) override;\n+  virtual void visit (LetStmt &stmt) override;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) override;\n+  virtual void visit (ExprStmtWithBlock &stmt) override;\n+  virtual void visit (TraitBound &bound) override;\n+  virtual void visit (ImplTraitType &type) override;\n+  virtual void visit (TraitObjectType &type) override;\n+  virtual void visit (ParenthesisedType &type) override;\n+  virtual void visit (ImplTraitTypeOneBound &type) override;\n+  virtual void visit (TupleType &type) override;\n+  virtual void visit (NeverType &type) override;\n+  virtual void visit (RawPointerType &type) override;\n+  virtual void visit (ReferenceType &type) override;\n+  virtual void visit (ArrayType &type) override;\n+  virtual void visit (SliceType &type) override;\n+  virtual void visit (InferredType &type) override;\n+  virtual void visit (BareFunctionType &type) override;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif /* !RUST_UNSAFE_CHECKER_H */"}]}