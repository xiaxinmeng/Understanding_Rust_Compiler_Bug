{"sha": "e5837c07d54b3775b6f3d61dd336de854f9c8490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU4MzdjMDdkNTRiMzc3NWI2ZjNkNjFkZDMzNmRlODU0ZjljODQ5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-10-30T15:01:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-10-30T15:01:50Z"}, "message": "alias.c: Fix comment formatting.\n\n\t* alias.c: Fix comment formatting.\n\t* recog.c: Likewise.\n\t* config/cris/cris.c: Likewise.\n\t* config/cris/cris.h: Likewise.\n\t* config/i960/i960.c: Likewise.\n\t* config/i960/i960.h: Likewise.\n\nFrom-SVN: r46640", "tree": {"sha": "88772e687778f4d1fe3e287ac33fc97a5dcd47f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88772e687778f4d1fe3e287ac33fc97a5dcd47f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5837c07d54b3775b6f3d61dd336de854f9c8490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5837c07d54b3775b6f3d61dd336de854f9c8490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5837c07d54b3775b6f3d61dd336de854f9c8490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5837c07d54b3775b6f3d61dd336de854f9c8490/comments", "author": null, "committer": null, "parents": [{"sha": "bc70506b60ee7e3b7bc3eff279188d389755a60f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc70506b60ee7e3b7bc3eff279188d389755a60f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc70506b60ee7e3b7bc3eff279188d389755a60f"}], "stats": {"total": 111, "additions": 60, "deletions": 51}, "files": [{"sha": "3cc08b9baefa539a4205bc540db0f2e97e0a5664", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -1,3 +1,12 @@\n+2001-10-30  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* alias.c: Fix comment formatting.\n+\t* recog.c: Likewise.\n+\t* config/cris/cris.c: Likewise.\n+\t* config/cris/cris.h: Likewise.\n+\t* config/i960/i960.c: Likewise.\n+\t* config/i960/i960.h: Likewise.\n+\n 2001-10-30  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/arm/arm.c: Fix a comment typo."}, {"sha": "2581b2acb1d074de95c2c835bc196701a8713967", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -510,7 +510,7 @@ get_alias_set (t)\n \n \t  if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n \t    {\n-\t      /* If we haven't computed the actual alias set, do it now. */\n+\t      /* If we haven't computed the actual alias set, do it now.  */\n \t      if (DECL_POINTER_ALIAS_SET (decl) == -2)\n \t\t{\n \t\t  /* No two restricted pointers can point at the same thing."}, {"sha": "71bdeda2c6e9713437c375d838cef5a7db7e0bd2", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -665,7 +665,7 @@ cris_target_asm_function_prologue (file, size)\n   cfa_write_offset -= size;\n \n   /* Get a contiguous sequence of registers, starting with r0, that need\n-     to be saved. */\n+     to be saved.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n       if ((((regs_ever_live[regno]\n@@ -774,7 +774,7 @@ cris_target_asm_function_prologue (file, size)\n       else\n \t{\n \t  /* Avoid printing multiple subsequent sub:s for sp.  FIXME:\n-\t     Clean up the conditional expression. */\n+\t     Clean up the conditional expression.  */\n \t  fprintf (file, \"\\tsub%s %d,$sp\\n\",\n \t\t   ADDITIVE_SIZE_MODIFIER ((last_movem_reg + 1) * 4 + size),\n \t\t   (last_movem_reg + 1) * 4 + size);\n@@ -849,7 +849,7 @@ saved_regs_mentioned (x)\n   const char *fmt;\n   RTX_CODE code;\n \n-  /* Mainly stolen from refers_to_regno_p in rtlanal.c. */\n+  /* Mainly stolen from refers_to_regno_p in rtlanal.c.  */\n \n   code = GET_CODE (x);\n \n@@ -1166,7 +1166,7 @@ cris_target_asm_function_epilogue (file, size)\n      them.  */\n   if (pretend)\n     {\n-      /* Since srp is stored on the way, we need to restore it first. */\n+      /* Since srp is stored on the way, we need to restore it first.  */\n       if (return_address_on_stack)\n \t{\n \t  if (*save_last && file)\n@@ -1184,7 +1184,7 @@ cris_target_asm_function_epilogue (file, size)\n \t       ADDITIVE_SIZE_MODIFIER (pretend), pretend);\n     }\n \n-  /* Here's where we have a delay-slot we need to fill. */\n+  /* Here's where we have a delay-slot we need to fill.  */\n   if (file && current_function_epilogue_delay_list)\n     {\n       /* If gcc has allocated an insn for the epilogue delay slot, but\n@@ -1442,7 +1442,7 @@ cris_print_operand (file, x, code)\n       return;\n \n     case 0:\n-      /* No code, print as usual. */\n+      /* No code, print as usual.  */\n       break;\n \n     default:\n@@ -1454,7 +1454,7 @@ cris_print_operand (file, x, code)\n       }\n     }\n \n-  /* Print an operand as without a modifier letter. */\n+  /* Print an operand as without a modifier letter.  */\n   switch (GET_CODE (operand))\n     {\n     case REG:\n@@ -1675,7 +1675,7 @@ cris_initial_elimination_offset (fromreg, toreg)\n       && toreg == STACK_POINTER_REGNUM)\n     return fp_sp_offset;\n \n-  /* We need to balance out the frame pointer here. */\n+  /* We need to balance out the frame pointer here.  */\n   if (fromreg == ARG_POINTER_REGNUM\n       && toreg == STACK_POINTER_REGNUM)\n     return ap_fp_offset + fp_sp_offset - 4;\n@@ -1779,13 +1779,13 @@ cris_notice_update_cc (exp, insn)\n \t    return;\n \n \t  /* Record CC0 changes, so we do not have to output multiple\n-\t     test insns. */\n+\t     test insns.  */\n \t  if (SET_DEST (exp) == cc0_rtx)\n \t    {\n \t      cc_status.value1 = SET_SRC (exp);\n \t      cc_status.value2 = 0;\n \n-\t      /* Handle flags for the special btstq on one bit. */\n+\t      /* Handle flags for the special btstq on one bit.  */\n \t      if (GET_CODE (SET_SRC (exp)) == ZERO_EXTRACT\n \t\t  && XEXP (SET_SRC (exp), 1) == const1_rtx)\n \t\t{\n@@ -1805,7 +1805,7 @@ cris_notice_update_cc (exp, insn)\n \t\t      && XEXP (SET_SRC (exp), 1) != const0_rtx)\n \t\t    /* For some reason gcc will not canonicalize compare\n \t\t       operations, reversing the sign by itself if\n-\t\t       operands are in wrong order. */\n+\t\t       operands are in wrong order.  */\n \t\t    /* (But NOT inverted; eq is still eq.) */\n \t\t    cc_status.flags = CC_REVERSED;\n \n@@ -1823,14 +1823,14 @@ cris_notice_update_cc (exp, insn)\n \t\t       && REG_P (XEXP (SET_DEST (exp), 0))))\n \t    {\n \t      /* A register is set; normally CC is set to show that no\n-\t\t test insn is needed.  Catch the exceptions. */\n+\t\t test insn is needed.  Catch the exceptions.  */\n \n \t      /* If not to cc0, then no \"set\"s in non-natural mode give\n \t\t ok cc0...  */\n \t      if (GET_MODE_SIZE (GET_MODE (SET_DEST (exp))) > UNITS_PER_WORD\n \t\t  || GET_MODE_CLASS (GET_MODE (SET_DEST (exp))) == MODE_FLOAT)\n \t\t{\n-\t\t  /* ... except add:s and sub:s in DImode. */\n+\t\t  /* ... except add:s and sub:s in DImode.  */\n \t\t  if (GET_MODE (SET_DEST (exp)) == DImode\n \t\t      && (GET_CODE (SET_SRC (exp)) == PLUS\n \t\t\t  || GET_CODE (SET_SRC (exp)) == MINUS))"}, {"sha": "07591fa92a9c318ea9c1fadf5502c7b845f37de1", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -264,7 +264,7 @@ extern int target_flags;\n \n /* If to use condition-codes generated by insns other than the\n    immediately preceding compare/test insn.\n-    Used to check for errors in notice_update_cc. */\n+    Used to check for errors in notice_update_cc.  */\n #define TARGET_MASK_CCINIT 2\n #define TARGET_CCINIT (target_flags & TARGET_MASK_CCINIT)\n \n@@ -519,11 +519,11 @@ extern int target_flags;\n #define FUNCTION_BOUNDARY 16\n \n /* Do not change BIGGEST_ALIGNMENT (when optimizing), as it will affect\n-   strange places, at least in 2.1. */\n+   strange places, at least in 2.1.  */\n #define BIGGEST_ALIGNMENT 8\n \n /* If -m16bit,\t-m16-bit, -malign or -mdata-align,\n-   align everything to 16 bit. */\n+   align everything to 16 bit.  */\n #define DATA_ALIGNMENT(TYPE, BASIC_ALIGN)\t\t\t\\\n  (TARGET_DATA_ALIGN\t\t\t\t\t\t\\\n   ? (TARGET_ALIGN_BY_32\t\t\t\t\t\t\\\n@@ -735,7 +735,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n   0)\n \n /* It is really simple to make up a 0.0; it is the same as int-0 in\n-   IEEE754. */\n+   IEEE754.  */\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n  ((C) == 'G' && ((VALUE) == CONST0_RTX (DFmode)\t\t\t\\\n \t\t || (VALUE) == CONST0_RTX (SFmode)))\n@@ -873,7 +873,7 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n #define STACK_POINTER_REGNUM 14\n \n /* Register used for frame pointer.  This is also the last of the saved\n-   registers, when a frame pointer is not used. */\n+   registers, when a frame pointer is not used.  */\n #define FRAME_POINTER_REGNUM 8\n \n /* Faked register, is always eliminated.  We need it to eliminate\n@@ -1078,7 +1078,7 @@ struct cum_args {int regs;};\n    Anyway, trampolines are rare enough that we can cope with this\n    somewhat lack of elegance.\n     (Do not be tempted to \"straighten up\" whitespace in the asms; the\n-   assembler #NO_APP state mandates strict spacing). */\n+   assembler #NO_APP state mandates strict spacing).  */\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n@@ -1099,7 +1099,7 @@ struct cum_args {int regs;};\n /* CRIS wants instructions on word-boundary.\n    Note that due to a bug (reported) in 2.7.2 and earlier, this is\n    actually treated as alignment in _bytes_, not _bits_.  (Obviously\n-   this is not fatal, only a slight waste of stack space). */\n+   this is not fatal, only a slight waste of stack space).  */\n #define TRAMPOLINE_ALIGNMENT 16\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\\\n@@ -1296,7 +1296,7 @@ struct cum_args {int regs;};\n \t\t\t\t\t\t\t\t\t\\\n \t  if (REGNO (XEXP (X, 1)) >= FIRST_PSEUDO_REGISTER)\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      /* Second reg is pseudo, reload it. */\t\t\t\\\n+\t      /* Second reg is pseudo, reload it.  */\t\t\t\\\n \t      push_reload (XEXP (X, 1), NULL_RTX, &XEXP (X, 1), \t\\\n \t\t\t   NULL,\t\t\t\t\t\\\n \t\t\t   GENERAL_REGS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n@@ -1308,7 +1308,7 @@ struct cum_args {int regs;};\n \t      && (REGNO (XEXP (XEXP (X, 0), 0))\t\t\t\t\\\n \t\t  >= FIRST_PSEUDO_REGISTER))\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      /* First one is a pseudo - reload that. */\t\t\\\n+\t      /* First one is a pseudo - reload that.  */\t\t\\\n \t      push_reload (XEXP (XEXP (X, 0), 0), NULL_RTX,\t\t\\\n \t\t\t   &XEXP (XEXP (X, 0), 0), NULL, \t\t\\\n \t\t\t   GENERAL_REGS,\t\t\t\t\\\n@@ -1543,7 +1543,7 @@ struct cum_args {int regs;};\n   while (0)\n \n /* This is what is used by gcc for 64-bit floats,\n-   not the \"long double\" one. */\n+   not the \"long double\" one.  */\n #define ASM_OUTPUT_DOUBLE(FILE, VALUE) \\\n  ASM_OUTPUT_LONG_DOUBLE (FILE, VALUE)\n \n@@ -1585,7 +1585,7 @@ struct cum_args {int regs;};\n \n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) (C) == '@'\n \n-/* FIXME: These are undocumented. */\n+/* FIXME: These are undocumented.  */\n /* We need to define these, since the 2byte, 4byte, 8byte op:s are only\n    available in ELF.  These \"normal\" pseudos do not have any alignment\n    constraints or side-effects.  */\n@@ -1812,7 +1812,7 @@ struct cum_args {int regs;};\n \n /* Node: DBX Options */\n \n-/* Is this correct? Check later. */\n+/* Is this correct? Check later.  */\n #define DBX_NO_XREFS\n \n #define DBX_CONTIN_LENGTH 0"}, {"sha": "fe8f0da4964e97c57b7718c2825a67a6f6a2f128", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -507,7 +507,7 @@ i960_address_cost (x)\n \n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally. */\n+   normally.  */\n \n int\n emit_move_sequence (operands, mode)\n@@ -520,7 +520,7 @@ emit_move_sequence (operands, mode)\n       && (operands[1] != const0_rtx || current_function_args_size\n \t  || current_function_varargs || current_function_stdarg\n \t  || rtx_equal_function_value_matters))\n-    /* Here we use the same test as movsi+1 pattern -- see i960.md. */\n+    /* Here we use the same test as movsi+1 pattern -- see i960.md.  */\n     operands[1] = force_reg (mode, operands[1]);\n \n   /* Storing multi-word values in unaligned hard registers to memory may\n@@ -1031,7 +1031,7 @@ i960_function_name_declare (file, name, fndecl)\n       leaf_proc_ok = 0;\n     }\n       \n-  /* See if caller passes in an address to return value. */\n+  /* See if caller passes in an address to return value.  */\n \n   if (aggregate_value_p (DECL_RESULT (fndecl)))\n     {\n@@ -1173,7 +1173,7 @@ compute_frame_size (size)\n }\n \n /* Here register group is range of registers which can be moved by\n-   one i960 instruction. */\n+   one i960 instruction.  */\n \n struct reg_group\n {\n@@ -1189,7 +1189,7 @@ static void i960_arg_size_and_align PARAMS ((enum machine_mode, tree, int *, int\n /* The following functions forms the biggest as possible register\n    groups with registers in STATE.  REGS contain states of the\n    registers in range [start, finish_reg).  The function returns the\n-   number of groups formed. */\n+   number of groups formed.  */\n static int\n i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n      int start_reg;\n@@ -1223,7 +1223,7 @@ i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n   return nw;\n }\n \n-/* We sort register winodws in descending order by length. */\n+/* We sort register winodws in descending order by length.  */\n static int\n i960_reg_group_compare (group1, group2)\n      const void *group1;\n@@ -1242,7 +1242,7 @@ i960_reg_group_compare (group1, group2)\n \n /* Split the first register group in REG_GROUPS on subgroups one of\n    which will contain SUBGROUP_LENGTH registers.  The function\n-   returns new number of winodws. */\n+   returns new number of winodws.  */\n static int\n i960_split_reg_group (reg_groups, nw, subgroup_length)\n      struct reg_group *reg_groups;\n@@ -1253,11 +1253,11 @@ i960_split_reg_group (reg_groups, nw, subgroup_length)\n     /* This guarantees correct alignments of the two subgroups for\n        i960 (see spliting for the group length 2, 3, 4).  More\n        generalized algorithm would require splitting the group more\n-       two subgroups. */\n+       two subgroups.  */\n     subgroup_length = reg_groups->length - subgroup_length;\n   /* More generalized algorithm would require to try merging\n      subgroups here.  But in case i960 it always results in failure\n-     because of register group alignment. */\n+     because of register group alignment.  */\n   reg_groups[nw].length = reg_groups->length - subgroup_length;\n   reg_groups[nw].start_reg = reg_groups->start_reg + subgroup_length;\n   nw++;\n@@ -1284,9 +1284,9 @@ i960_output_function_prologue (file, size)\n   /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n      somewhere.  */\n   int regs[FIRST_PSEUDO_REGISTER];\n-  /* All global registers (which must be saved) divided by groups. */\n+  /* All global registers (which must be saved) divided by groups.  */\n   struct reg_group global_reg_groups [16];\n-  /* All local registers (which are available) divided by groups. */\n+  /* All local registers (which are available) divided by groups.  */\n   struct reg_group local_reg_groups [16];\n \n \n@@ -2132,7 +2132,7 @@ legitimize_address (x, oldx, mode)\n \f\n #if 0\n /* Return the most stringent alignment that we are willing to consider\n-   objects of size SIZE and known alignment ALIGN as having. */\n+   objects of size SIZE and known alignment ALIGN as having.  */\n    \n int\n i960_alignment (size, align)\n@@ -2244,7 +2244,7 @@ i960_expr_alignment (x, size)\n \n     case SYMBOL_REF:\n       /* If this is a valid program, objects are guaranteed to be\n-\t correctly aligned for whatever size the reference actually is. */\n+\t correctly aligned for whatever size the reference actually is.  */\n       align = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n       break;\n \n@@ -2556,7 +2556,7 @@ i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \n      If there are no stack arguments but there are exactly NPARM_REGS\n      registers, either there were no extra arguments or the caller\n-     allocated an argument block. */\n+     allocated an argument block.  */\n \n   if (cum->ca_nstackparms == 0 && first_reg < NPARM_REGS && !no_rtl)\n     {"}, {"sha": "2dfc88b2e7048ebfce2e0a11b6bc475c767886b2", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -100,7 +100,7 @@ Boston, MA 02111-1307, USA.  */\n    that -O means FP elimination.  Addressing through sp requires\n    negative offset and more one word addressing in the most cases\n    (offsets except for 0-4095 require one more word).  Therefore we've\n-   not defined the macro. */\n+   not defined the macro.  */\n /*#define CAN_DEBUG_WITHOUT_FP*/\n \n /* Do leaf procedure and tail call optimizations for -O2 and higher.  */\n@@ -154,7 +154,7 @@ extern int i960_last_maxbitalignment;\n \n /* The following three are mainly used to provide a little sanity checking\n    against the -mARCH flags given. The Jx series, for the purposes of\n-   gcc, is a Kx with a data cache. */\n+   gcc, is a Kx with a data cache.  */\n \n /* Nonzero if we should generate code for the KA and similar processors.\n    No FPU, no microcode instructions.  */\n@@ -422,7 +422,7 @@ extern int target_flags;\n #define POINTER_SIZE 32\n \n /* Width in bits of a long double.  Define to 96, and let\n-   ROUND_TYPE_ALIGN adjust the alignment for speed. */\n+   ROUND_TYPE_ALIGN adjust the alignment for speed.  */\n #define\tLONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_64 ? 64 : 96)\n \n /* ??? This must be a constant, because real.c and real.h test it with #if.  */\n@@ -634,7 +634,7 @@ extern int target_flags;\n    This is an array of structures.  Each structure initializes one pair\n    of eliminable registers.  The \"from\" register number is given first,\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.. */\n+   in order of preference..  */\n \n #define ELIMINABLE_REGS\t {{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n@@ -1118,7 +1118,7 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n \n \tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n \n-/* Returns 1 if the scale factor of an index term is valid. */\n+/* Returns 1 if the scale factor of an index term is valid.  */\n #define SCALE_TERM_P(X)\t\t\t\t\t\t\t\\\n   (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n    && (INTVAL (X) == 1 || INTVAL (X) == 2 || INTVAL (X) == 4 \t\t\\\n@@ -1167,7 +1167,7 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n-   Do not define this if the table should contain absolute addresses. */\n+   Do not define this if the table should contain absolute addresses.  */\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n@@ -1198,7 +1198,7 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n \n /* Nonzero if access to memory by bytes is no faster than for words.\n    Value changed to 1 after reports of poor bitfield code with g++.\n-   Indications are that code is usually as good, sometimes better. */   \n+   Indications are that code is usually as good, sometimes better.  */   \n \n #define SLOW_BYTE_ACCESS 1\n \n@@ -1213,7 +1213,7 @@ struct cum_args { int ca_nregparms; int ca_nstackparms; };\n #define STORE_FLAG_VALUE 1\n \n /* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits. */\n+   few bits.  */\n #define SHIFT_COUNT_TRUNCATED 0\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n@@ -1345,7 +1345,7 @@ extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n #define DBX_CONTIN_LENGTH 1500\n \n /* This is how to output a note to DBX telling it the line number\n-   to which the following sequence of instructions corresponds. */\n+   to which the following sequence of instructions corresponds.  */\n \n #define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)\t\t\t\\\n { if (write_symbols == SDB_DEBUG) {\t\t\t\t\\\n@@ -1370,7 +1370,7 @@ extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n   assemble_name (FILE, NAME);\t\t\t\\\n   fputs (\"\\n\", FILE); }\n \n-/* The prefix to add to user-visible assembler symbols. */\n+/* The prefix to add to user-visible assembler symbols.  */\n \n #define USER_LABEL_PREFIX \"_\"\n "}, {"sha": "265ce3ffbd24370aeff1be07ce82dff9229cf43e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5837c07d54b3775b6f3d61dd336de854f9c8490/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=e5837c07d54b3775b6f3d61dd336de854f9c8490", "patch": "@@ -3121,7 +3121,7 @@ peephole2_optimize (dump_file)\n \t\t\t\t\t\t   XEXP (note, 0),\n \t\t\t\t\t\t   REG_NOTES (new_insn));\n \t\t\t  default:\n-\t\t\t    /* Discard all other reg notes. */\n+\t\t\t    /* Discard all other reg notes.  */\n \t\t\t    break;\n \t\t\t  }\n "}]}