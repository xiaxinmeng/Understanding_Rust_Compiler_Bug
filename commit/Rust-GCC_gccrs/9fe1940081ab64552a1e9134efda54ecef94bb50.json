{"sha": "9fe1940081ab64552a1e9134efda54ecef94bb50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlMTk0MDA4MWFiNjQ1NTJhMWU5MTM0ZWZkYTU0ZWNlZjk0YmI1MA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2019-04-24T13:40:38Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2019-04-24T13:40:38Z"}, "message": "S/390: Fix PR89952 incorrect CFI\n\nThis patch fixes a cases where inconsistent CFI is generated.\n\nAfter restoring the hard frame pointer (r11) from an FPR we have to\nset the CFA register.  In order to be able to set it back to the stack\npointer (r15) we have to make sure that r15 has been restored already.\n\nThe patch also adds a scheduler dependency to prevent the instruction\nscheduler from swapping the r11 and r15 restore again.\n\ngcc/ChangeLog:\n\n2019-04-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\tPR target/89952\n\t* config/s390/s390.c (s390_restore_gprs_from_fprs): Restore GPRs\n    \tfrom FPRs in reverse order.  Generate REG_CFA_DEF_CFA note also\n    \tfor restored hard frame pointer.\n\t(s390_sched_dependencies_evaluation): Implement new target hook.\n\t(TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK): New macro definition.\n\ngcc/testsuite/ChangeLog:\n\n2019-04-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\tPR target/89952\n\t* gcc.target/s390/pr89952.c: New test.\n\nFrom-SVN: r270544", "tree": {"sha": "1bba624feb096678c8fff276eaf2ead17b6dac8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bba624feb096678c8fff276eaf2ead17b6dac8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fe1940081ab64552a1e9134efda54ecef94bb50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe1940081ab64552a1e9134efda54ecef94bb50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe1940081ab64552a1e9134efda54ecef94bb50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe1940081ab64552a1e9134efda54ecef94bb50/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "972206e0c20a36d6b5a85e3842b52879330f5783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972206e0c20a36d6b5a85e3842b52879330f5783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/972206e0c20a36d6b5a85e3842b52879330f5783"}], "stats": {"total": 88, "additions": 86, "deletions": 2}, "files": [{"sha": "6d09649c1d01671e049d5e76c06af60cea3a9ae8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fe1940081ab64552a1e9134efda54ecef94bb50", "patch": "@@ -1,3 +1,12 @@\n+2019-04-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\tPR target/89952\n+\t* config/s390/s390.c (s390_restore_gprs_from_fprs): Restore GPRs\n+    \tfrom FPRs in reverse order.  Generate REG_CFA_DEF_CFA note also\n+    \tfor restored hard frame pointer.\n+\t(s390_sched_dependencies_evaluation): Implement new target hook.\n+\t(TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK): New macro definition.\n+\n 2019-04-24  Claudiu Zissulescu  <claziss@sysnopsys.com>\n \n \t* config/arc/arc-options.def: Fix typos and spelling mistakes."}, {"sha": "fc4571d0d0c2326cd1bbce96662c21100e5a6f00", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9fe1940081ab64552a1e9134efda54ecef94bb50", "patch": "@@ -10685,7 +10685,11 @@ s390_restore_gprs_from_fprs (void)\n   if (!TARGET_Z10 || !TARGET_HARD_FLOAT || !crtl->is_leaf)\n     return;\n \n-  for (i = 6; i < 16; i++)\n+  /* Restore the GPRs starting with the stack pointer.  That way the\n+     stack pointer already has its original value when it comes to\n+     restoring the hard frame pointer.  So we can set the cfa reg back\n+     to the stack pointer.  */\n+  for (i = STACK_POINTER_REGNUM; i >= 6; i--)\n     {\n       rtx_insn *insn;\n \n@@ -10701,7 +10705,13 @@ s390_restore_gprs_from_fprs (void)\n \n       df_set_regs_ever_live (i, true);\n       add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (DImode, i));\n-      if (i == STACK_POINTER_REGNUM)\n+\n+      /* If either the stack pointer or the frame pointer get restored\n+\t set the CFA value to its value at function start.  Doing this\n+\t for the frame pointer results in .cfi_def_cfa_register 15\n+\t what is ok since if the stack pointer got modified it has\n+\t been restored already.  */\n+      if (i == STACK_POINTER_REGNUM || i == HARD_FRAME_POINTER_REGNUM)\n \tadd_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t      plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t     STACK_POINTER_OFFSET));\n@@ -16294,6 +16304,49 @@ s390_case_values_threshold (void)\n   return default_case_values_threshold ();\n }\n \n+/* Evaluate the insns between HEAD and TAIL and do back-end to install\n+   back-end specific dependencies.\n+\n+   Establish an ANTI dependency between r11 and r15 restores from FPRs\n+   to prevent the instructions scheduler from reordering them since\n+   this would break CFI.  No further handling in the sched_reorder\n+   hook is required since the r11 and r15 restore will never appear in\n+   the same ready list with that change.  */\n+void\n+s390_sched_dependencies_evaluation (rtx_insn *head, rtx_insn *tail)\n+{\n+  if (!frame_pointer_needed || !epilogue_completed)\n+    return;\n+\n+  while (head != tail && DEBUG_INSN_P (head))\n+    head = NEXT_INSN (head);\n+\n+  rtx_insn *r15_restore = NULL, *r11_restore = NULL;\n+\n+  for (rtx_insn *insn = tail; insn != head; insn = PREV_INSN (insn))\n+    {\n+      rtx set = single_set (insn);\n+      if (!INSN_P (insn)\n+\t  || !RTX_FRAME_RELATED_P (insn)\n+\t  || set == NULL_RTX\n+\t  || !REG_P (SET_DEST (set))\n+\t  || !FP_REG_P (SET_SRC (set)))\n+\tcontinue;\n+\n+      if (REGNO (SET_DEST (set)) == HARD_FRAME_POINTER_REGNUM)\n+\tr11_restore = insn;\n+\n+      if (REGNO (SET_DEST (set)) == STACK_POINTER_REGNUM)\n+\tr15_restore = insn;\n+    }\n+\n+  if (r11_restore == NULL || r15_restore == NULL)\n+    return;\n+  add_dependence (r11_restore, r15_restore, REG_DEP_ANTI);\n+}\n+\n+\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -16585,6 +16638,11 @@ s390_case_values_threshold (void)\n #undef TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD s390_case_values_threshold\n \n+#undef TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK\n+#define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK \\\n+  s390_sched_dependencies_evaluation\n+\n+\n /* Use only short displacement, since long displacement is not available for\n    the floating point instructions.  */\n #undef TARGET_MAX_ANCHOR_OFFSET"}, {"sha": "6a34f20da3af65b8c1258f0ebbe3f3b44b8bae95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fe1940081ab64552a1e9134efda54ecef94bb50", "patch": "@@ -1,3 +1,8 @@\n+2019-04-24  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\tPR target/89952\n+\t* gcc.target/s390/pr89952.c: New test.\n+\n 2019-04-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/90187"}, {"sha": "9f48e0848a07624d8a1b43b5d801d2024dc76e57", "filename": "gcc/testsuite/gcc.target/s390/pr89952.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr89952.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fe1940081ab64552a1e9134efda54ecef94bb50/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr89952.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr89952.c?ref=9fe1940081ab64552a1e9134efda54ecef94bb50", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=zEC12 -fno-omit-frame-pointer -Os\" } */\n+\n+\n+extern void j(int);\n+\n+void\n+d(int e, long f, int g, int h, int i) {\n+  if (h == 5 && i >= 4 && i <= 7)\n+    h = e;\n+  j(h);\n+}"}]}