{"sha": "543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzYTliY2QyMTZkOWE5ZmIzNzdiN2Y4NDc2NmNkY2M4NThjMjFjMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-26T09:29:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-26T09:29:26Z"}, "message": "Move int rounding folds to match.pd\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* builtins.c (do_real_to_int_conversion): New function.\n\t(fold_fixed_mathfn, fold_builtin_int_roundingfn): Delete.\n\t(fold_builtin_1): Handle constant {i,l,ll}{ceil,floor,round}{f,,l}\n\targuments here.\n\t* match.pd: Add rules previously handled by fold_fixed_mathfn\n\tand fold_builtin_int_roundingfn.\n\ngcc/testsuite/\n\t* gcc.dg/torture/builtin-minmax-1.c: Don't run at -O0.\n\nFrom-SVN: r229311", "tree": {"sha": "66e60349762aaae2db7fc91e21bb08474e8cd4b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66e60349762aaae2db7fc91e21bb08474e8cd4b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "257aecb4a57670a5d0aa7b023faca4438a7c1ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/257aecb4a57670a5d0aa7b023faca4438a7c1ae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/257aecb4a57670a5d0aa7b023faca4438a7c1ae1"}], "stats": {"total": 319, "additions": 138, "deletions": 181}, "files": [{"sha": "3285ca4ee41bfe2ddbe9e6639eda81b96cd236f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "patch": "@@ -1,3 +1,12 @@\n+2015-10-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* builtins.c (do_real_to_int_conversion): New function.\n+\t(fold_fixed_mathfn, fold_builtin_int_roundingfn): Delete.\n+\t(fold_builtin_1): Handle constant {i,l,ll}{ceil,floor,round}{f,,l}\n+\targuments here.\n+\t* match.pd: Add rules previously handled by fold_fixed_mathfn\n+\tand fold_builtin_int_roundingfn.\n+\n 2015-10-26  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* match.pd: Use macros to define built-in operator lists."}, {"sha": "f947f1e415b9e4268d17bdbee6706bd556e2c1bf", "filename": "gcc/builtins.c", "status": "modified", "additions": 36, "deletions": 177, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "patch": "@@ -158,7 +158,6 @@ static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_signbit (tree, rtx);\n static tree fold_builtin_pow (location_t, tree, tree, tree, tree);\n static tree fold_builtin_powi (location_t, tree, tree, tree, tree);\n-static tree fold_builtin_int_roundingfn (location_t, tree, tree);\n static tree fold_builtin_bitop (tree, tree);\n static tree fold_builtin_strchr (location_t, tree, tree, tree);\n static tree fold_builtin_memchr (location_t, tree, tree, tree, tree);\n@@ -7273,6 +7272,35 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n     }\n }\n \n+/* If ARG is a foldable constant real, use FN to round it to an integer\n+   value and try to represent the result in integer type ITYPE.  Return\n+   the value on success, otherwise return null.  */\n+\n+static tree\n+do_real_to_int_conversion (tree itype, tree arg,\n+\t\t\t   void (*fn) (REAL_VALUE_TYPE *, machine_mode,\n+\t\t\t\t       const REAL_VALUE_TYPE *))\n+{\n+  if (TREE_CODE (arg) != REAL_CST || TREE_OVERFLOW (arg))\n+    return NULL_TREE;\n+\n+  const REAL_VALUE_TYPE *value = TREE_REAL_CST_PTR (arg);\n+  if (!real_isfinite (value))\n+    return NULL_TREE;\n+\n+  tree ftype = TREE_TYPE (arg);\n+  REAL_VALUE_TYPE rounded;\n+  fn (&rounded, TYPE_MODE (ftype), value);\n+\n+  bool fail = false;\n+  wide_int ival = real_to_integer (&rounded, &fail, TYPE_PRECISION (itype));\n+  if (fail)\n+    return NULL_TREE;\n+\n+  return wide_int_to_tree (itype, ival);\n+}\n+\n+\n /* Fold a call to __builtin_inf or __builtin_huge_val.  */\n \n static tree\n@@ -7314,112 +7342,6 @@ fold_builtin_nan (tree arg, tree type, int quiet)\n   return build_real (type, real);\n }\n \n-/* FNDECL is assumed to be builtin which can narrow the FP type of\n-   the argument, for instance lround((double)f) -> lroundf (f).\n-   Do the transformation for a call with argument ARG.  */\n-\n-static tree\n-fold_fixed_mathfn (location_t loc, tree fndecl, tree arg)\n-{\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* If argument is already integer valued, and we don't need to worry\n-     about setting errno, there's no need to perform rounding.  */\n-  if (! flag_errno_math && integer_valued_real_p (arg))\n-    return fold_build1_loc (loc, FIX_TRUNC_EXPR,\n-\t\t\tTREE_TYPE (TREE_TYPE (fndecl)), arg);\n-\n-  if (optimize)\n-    {\n-      tree ftype = TREE_TYPE (arg);\n-      tree arg0 = strip_float_extensions (arg);\n-      tree newtype = TREE_TYPE (arg0);\n-      tree decl;\n-\n-      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (ftype)\n-\t  && (decl = mathfn_built_in (newtype, fcode)))\n-\treturn build_call_expr_loc (loc, decl, 1,\n-\t\t\t\tfold_convert_loc (loc, newtype, arg0));\n-    }\n-\n-  /* Canonicalize iround (x) to lround (x) on ILP32 targets where\n-     sizeof (int) == sizeof (long).  */\n-  if (TYPE_PRECISION (integer_type_node)\n-      == TYPE_PRECISION (long_integer_type_node))\n-    {\n-      tree newfn = NULL_TREE;\n-      switch (fcode)\n-\t{\n-\tCASE_FLT_FN (BUILT_IN_ICEIL):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LCEIL);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_IFLOOR):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LFLOOR);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_IROUND):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LROUND);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_IRINT):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LRINT);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if (newfn)\n-\t{\n-\t  tree newcall = build_call_expr_loc (loc, newfn, 1, arg);\n-\t  return fold_convert_loc (loc,\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (fndecl)), newcall);\n-\t}\n-    }\n-\n-  /* Canonicalize llround (x) to lround (x) on LP64 targets where\n-     sizeof (long long) == sizeof (long).  */\n-  if (TYPE_PRECISION (long_long_integer_type_node)\n-      == TYPE_PRECISION (long_integer_type_node))\n-    {\n-      tree newfn = NULL_TREE;\n-      switch (fcode)\n-\t{\n-\tCASE_FLT_FN (BUILT_IN_LLCEIL):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LCEIL);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_LLFLOOR):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LFLOOR);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_LLROUND):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LROUND);\n-\t  break;\n-\n-\tCASE_FLT_FN (BUILT_IN_LLRINT):\n-\t  newfn = mathfn_built_in (TREE_TYPE (arg), BUILT_IN_LRINT);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if (newfn)\n-\t{\n-\t  tree newcall = build_call_expr_loc (loc, newfn, 1, arg);\n-\t  return fold_convert_loc (loc,\n-\t\t\t\t   TREE_TYPE (TREE_TYPE (fndecl)), newcall);\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold function call to builtin sincos, sincosf, or sincosl.  Return\n    NULL_TREE if no simplification can be made.  */\n \n@@ -7460,74 +7382,6 @@ fold_builtin_sincos (location_t loc,\n \t\t\t build1 (REALPART_EXPR, type, call)));\n }\n \n-/* Fold function call to builtin lround, lroundf or lroundl (or the\n-   corresponding long long versions) and other rounding functions.  ARG\n-   is the argument to the call.  Return NULL_TREE if no simplification\n-   can be made.  */\n-\n-static tree\n-fold_builtin_int_roundingfn (location_t loc, tree fndecl, tree arg)\n-{\n-  if (!validate_arg (arg, REAL_TYPE))\n-    return NULL_TREE;\n-\n-  /* Optimize lround of constant value.  */\n-  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n-    {\n-      const REAL_VALUE_TYPE x = TREE_REAL_CST (arg);\n-\n-      if (real_isfinite (&x))\n-\t{\n-\t  tree itype = TREE_TYPE (TREE_TYPE (fndecl));\n-\t  tree ftype = TREE_TYPE (arg);\n-\t  REAL_VALUE_TYPE r;\n-\t  bool fail = false;\n-\n-\t  switch (DECL_FUNCTION_CODE (fndecl))\n-\t    {\n-\t    CASE_FLT_FN (BUILT_IN_IFLOOR):\n-\t    CASE_FLT_FN (BUILT_IN_LFLOOR):\n-\t    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n-\t      real_floor (&r, TYPE_MODE (ftype), &x);\n-\t      break;\n-\n-\t    CASE_FLT_FN (BUILT_IN_ICEIL):\n-\t    CASE_FLT_FN (BUILT_IN_LCEIL):\n-\t    CASE_FLT_FN (BUILT_IN_LLCEIL):\n-\t      real_ceil (&r, TYPE_MODE (ftype), &x);\n-\t      break;\n-\n-\t    CASE_FLT_FN (BUILT_IN_IROUND):\n-\t    CASE_FLT_FN (BUILT_IN_LROUND):\n-\t    CASE_FLT_FN (BUILT_IN_LLROUND):\n-\t      real_round (&r, TYPE_MODE (ftype), &x);\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\n-\t  wide_int val = real_to_integer (&r, &fail, TYPE_PRECISION (itype));\n-\t  if (!fail)\n-\t    return wide_int_to_tree (itype, val);\n-\t}\n-    }\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    CASE_FLT_FN (BUILT_IN_LFLOOR):\n-    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n-      /* Fold lfloor (x) where x is nonnegative to FIX_TRUNC (x).  */\n-      if (tree_expr_nonnegative_p (arg))\n-\treturn fold_build1_loc (loc, FIX_TRUNC_EXPR,\n-\t\t\t    TREE_TYPE (TREE_TYPE (fndecl)), arg);\n-      break;\n-    default:;\n-    }\n-\n-  return fold_fixed_mathfn (loc, fndecl, arg);\n-}\n-\n /* Fold function call to builtin ffs, clz, ctz, popcount and parity\n    and their long and long long variants (i.e. ffsl and ffsll).  ARG is\n    the argument to the call.  Return NULL_TREE if no simplification can\n@@ -9453,18 +9307,23 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n     CASE_FLT_FN (BUILT_IN_ICEIL):\n     CASE_FLT_FN (BUILT_IN_LCEIL):\n     CASE_FLT_FN (BUILT_IN_LLCEIL):\n+      return do_real_to_int_conversion (type, arg0, real_ceil);\n+\n     CASE_FLT_FN (BUILT_IN_LFLOOR):\n     CASE_FLT_FN (BUILT_IN_IFLOOR):\n     CASE_FLT_FN (BUILT_IN_LLFLOOR):\n+      return do_real_to_int_conversion (type, arg0, real_floor);\n+\n     CASE_FLT_FN (BUILT_IN_IROUND):\n     CASE_FLT_FN (BUILT_IN_LROUND):\n     CASE_FLT_FN (BUILT_IN_LLROUND):\n-      return fold_builtin_int_roundingfn (loc, fndecl, arg0);\n+      return do_real_to_int_conversion (type, arg0, real_round);\n \n     CASE_FLT_FN (BUILT_IN_IRINT):\n     CASE_FLT_FN (BUILT_IN_LRINT):\n     CASE_FLT_FN (BUILT_IN_LLRINT):\n-      return fold_fixed_mathfn (loc, fndecl, arg0);\n+      /* Not yet folded to a constant.  */\n+      return NULL_TREE;\n \n     case BUILT_IN_BSWAP16:\n     case BUILT_IN_BSWAP32:"}, {"sha": "00c6e7c1abc8964fee6cd8e4f3b25814761d13a7", "filename": "gcc/match.pd", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "patch": "@@ -52,6 +52,30 @@ along with GCC; see the file COPYING3.  If not see\n #define DEFINE_MATH_FN(FN) \\\n   (define_operator_list FN BUILT_IN_##FN##F BUILT_IN_##FN BUILT_IN_##FN##L)\n \n+/* Define operand lists for math rounding functions {,i,l,ll}FN,\n+   where the versions prefixed with \"i\" return an int, those prefixed with\n+   \"l\" return a long and those prefixed with \"ll\" return a long long.\n+\n+   Also define operand lists:\n+\n+     X<FN>F for all float functions, in the order i, l, ll\n+     X<FN> for all double functions, in the same order\n+     X<FN>L for all long double functions, in the same order.  */\n+#define DEFINE_INT_AND_FLOAT_ROUND_FN(FN) \\\n+  DEFINE_MATH_FN (FN) \\\n+  DEFINE_MATH_FN (I##FN) \\\n+  DEFINE_MATH_FN (L##FN) \\\n+  DEFINE_MATH_FN (LL##FN) \\\n+  (define_operator_list X##FN##F BUILT_IN_I##FN##F \\\n+\t\t\t\t BUILT_IN_L##FN##F \\\n+\t\t\t\t BUILT_IN_LL##FN##F) \\\n+  (define_operator_list X##FN BUILT_IN_I##FN \\\n+\t\t\t      BUILT_IN_L##FN \\\n+\t\t\t      BUILT_IN_LL##FN) \\\n+  (define_operator_list X##FN##L BUILT_IN_I##FN##L \\\n+\t\t\t\t BUILT_IN_L##FN##L \\\n+\t\t\t\t BUILT_IN_LL##FN##L)\n+\n DEFINE_MATH_FN (LOG)\n DEFINE_MATH_FN (EXP)\n DEFINE_MATH_FN (LOG2)\n@@ -76,11 +100,12 @@ DEFINE_MATH_FN (HYPOT)\n DEFINE_MATH_FN (COPYSIGN)\n DEFINE_MATH_FN (CABS)\n DEFINE_MATH_FN (TRUNC)\n-DEFINE_MATH_FN (FLOOR)\n-DEFINE_MATH_FN (CEIL)\n-DEFINE_MATH_FN (ROUND)\n DEFINE_MATH_FN (NEARBYINT)\n-DEFINE_MATH_FN (RINT)\n+\n+DEFINE_INT_AND_FLOAT_ROUND_FN (FLOOR)\n+DEFINE_INT_AND_FLOAT_ROUND_FN (CEIL)\n+DEFINE_INT_AND_FLOAT_ROUND_FN (ROUND)\n+DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* Simplifications of operations with one constant operand and\n    simplifications to constants or single values.  */\n@@ -2655,6 +2680,65 @@ DEFINE_MATH_FN (RINT)\n    (froms (convert float_value_p@0))\n    (convert (tos @0)))))\n \n+(for froms (XFLOORL XCEILL XROUNDL XRINTL)\n+     tos (XFLOOR XCEIL XROUND XRINT)\n+ /* llfloorl(extend(x)) -> llfloor(x), etc., if x is a double.  */\n+ (if (optimize && canonicalize_math_p ())\n+  (simplify\n+   (froms (convert double_value_p@0))\n+   (tos @0))))\n+\n+(for froms (XFLOORL XCEILL XROUNDL XRINTL\n+\t    XFLOOR XCEIL XROUND XRINT)\n+     tos (XFLOORF XCEILF XROUNDF XRINTF)\n+ /* llfloorl(extend(x)) and llfloor(extend(x)) -> llfloorf(x), etc.,\n+    if x is a float.  */\n+ (if (optimize && canonicalize_math_p ())\n+  (simplify\n+   (froms (convert float_value_p@0))\n+   (tos @0))))\n+\n+(if (canonicalize_math_p ())\n+ /* xfloor(x) -> fix_trunc(x) if x is nonnegative.  */\n+ (for floors (IFLOOR LFLOOR LLFLOOR)\n+  (simplify\n+   (floors tree_expr_nonnegative_p@0)\n+   (fix_trunc @0))))\n+\n+(if (canonicalize_math_p ())\n+ /* xfloor(x) -> fix_trunc(x), etc., if x is integer valued.  */\n+ (for fns (IFLOOR LFLOOR LLFLOOR\n+\t   ICEIL LCEIL LLCEIL\n+\t   IROUND LROUND LLROUND)\n+  (simplify\n+   (fns integer_valued_real_p@0)\n+   (fix_trunc @0)))\n+ (if (!flag_errno_math)\n+  /* xrint(x) -> fix_trunc(x), etc., if x is integer valued.  */\n+  (for rints (IRINT LRINT LLRINT)\n+   (simplify\n+    (rints integer_valued_real_p@0)\n+    (fix_trunc @0)))))\n+\n+(if (canonicalize_math_p ())\n+ (for ifn (IFLOOR ICEIL IROUND IRINT)\n+      lfn (LFLOOR LCEIL LROUND LRINT)\n+      llfn (LLFLOOR LLCEIL LLROUND LLRINT)\n+  /* Canonicalize iround (x) to lround (x) on ILP32 targets where\n+     sizeof (int) == sizeof (long).  */\n+  (if (TYPE_PRECISION (integer_type_node)\n+       == TYPE_PRECISION (long_integer_type_node))\n+   (simplify\n+    (ifn @0)\n+    (lfn:long_integer_type_node @0)))\n+  /* Canonicalize llround (x) to lround (x) on LP64 targets where\n+     sizeof (long long) == sizeof (long).  */\n+  (if (TYPE_PRECISION (long_long_integer_type_node)\n+       == TYPE_PRECISION (long_integer_type_node))\n+   (simplify\n+    (llfn @0)\n+    (lfn:long_integer_type_node @0)))))\n+\n /* cproj(x) -> x if we're ignoring infinities.  */\n (simplify\n  (CPROJ @0)"}, {"sha": "45dc22ec2556999dee8819e85a08be45ae8a81d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "patch": "@@ -1,3 +1,7 @@\n+2015-10-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/torture/builtin-minmax-1.c: Don't run at -O0.\n+\n 2015-01-25  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/67171"}, {"sha": "a7c05b6dbbe803e9e67f3c1242c852e1903b6816", "filename": "gcc/testsuite/gcc.dg/torture/builtin-minmax-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-minmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a9bcd216d9a9fb377b7f84766cdcc858c21c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-minmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-minmax-1.c?ref=543a9bcd216d9a9fb377b7f84766cdcc858c21c0", "patch": "@@ -7,6 +7,7 @@\n \n /* { dg-do link } */\n /* { dg-options \"-fno-math-errno\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n \n /* All references to link_error should go away at compile-time.  */\n extern void link_error(int);"}]}