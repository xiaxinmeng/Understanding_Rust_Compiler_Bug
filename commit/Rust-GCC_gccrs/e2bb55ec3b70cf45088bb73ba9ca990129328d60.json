{"sha": "e2bb55ec3b70cf45088bb73ba9ca990129328d60", "node_id": "C_kwDOANBUbNoAKGUyYmI1NWVjM2I3MGNmNDUwODhiYjczYmE5Y2E5OTAxMjkzMjhkNjA", "commit": {"author": {"name": "niXman", "email": "i.nixman@autistici.org", "date": "2023-02-11T06:18:10Z"}, "committer": {"name": "Jonathan Yong", "email": "10walls@gmail.com", "date": "2023-02-11T06:29:43Z"}, "message": "libiberty: fix lrealpath on Windows NTFS symlinks\n\ngcc computes the wrong prefix if invoked through an NTFS\nsymlink. Try to resolve it if possible.\n\nPR/108350\n\nlibiberty/ChangeLog:\n\n\t* lrealpath.c (lrealpath): try to resolve symlink and\n\tuse UNC paths where applicable.\n\nSigned-off-by: Jonathan Yong <10walls@gmail.com>", "tree": {"sha": "c5ca0b21fca896fa2e7366899d0ac91c3d7bfb92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5ca0b21fca896fa2e7366899d0ac91c3d7bfb92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2bb55ec3b70cf45088bb73ba9ca990129328d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bb55ec3b70cf45088bb73ba9ca990129328d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2bb55ec3b70cf45088bb73ba9ca990129328d60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bb55ec3b70cf45088bb73ba9ca990129328d60/comments", "author": {"login": "niXman", "id": 518474, "node_id": "MDQ6VXNlcjUxODQ3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/518474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niXman", "html_url": "https://github.com/niXman", "followers_url": "https://api.github.com/users/niXman/followers", "following_url": "https://api.github.com/users/niXman/following{/other_user}", "gists_url": "https://api.github.com/users/niXman/gists{/gist_id}", "starred_url": "https://api.github.com/users/niXman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niXman/subscriptions", "organizations_url": "https://api.github.com/users/niXman/orgs", "repos_url": "https://api.github.com/users/niXman/repos", "events_url": "https://api.github.com/users/niXman/events{/privacy}", "received_events_url": "https://api.github.com/users/niXman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jon-y", "id": 4688224, "node_id": "MDQ6VXNlcjQ2ODgyMjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4688224?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jon-y", "html_url": "https://github.com/jon-y", "followers_url": "https://api.github.com/users/jon-y/followers", "following_url": "https://api.github.com/users/jon-y/following{/other_user}", "gists_url": "https://api.github.com/users/jon-y/gists{/gist_id}", "starred_url": "https://api.github.com/users/jon-y/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jon-y/subscriptions", "organizations_url": "https://api.github.com/users/jon-y/orgs", "repos_url": "https://api.github.com/users/jon-y/repos", "events_url": "https://api.github.com/users/jon-y/events{/privacy}", "received_events_url": "https://api.github.com/users/jon-y/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a47ed17ad9cddb7b8f2184204814e7554ffc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a47ed17ad9cddb7b8f2184204814e7554ffc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a47ed17ad9cddb7b8f2184204814e7554ffc2f"}], "stats": {"total": 199, "additions": 174, "deletions": 25}, "files": [{"sha": "2578288e8acef49d0f4ac624fdc81dfbff7befce", "filename": "libiberty/lrealpath.c", "status": "modified", "additions": 174, "deletions": 25, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2bb55ec3b70cf45088bb73ba9ca990129328d60/libiberty%2Flrealpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2bb55ec3b70cf45088bb73ba9ca990129328d60/libiberty%2Flrealpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Flrealpath.c?ref=e2bb55ec3b70cf45088bb73ba9ca990129328d60", "patch": "@@ -68,8 +68,135 @@ extern char *canonicalize_file_name (const char *);\n   /* cygwin has realpath, so it won't get here.  */ \n # if defined (_WIN32)\n #  define WIN32_LEAN_AND_MEAN\n-#  include <windows.h> /* for GetFullPathName */\n-# endif\n+#  include <windows.h> /* for GetFullPathName/GetFinalPathNameByHandle/\n+                          CreateFile/CloseHandle */\n+#  define WIN32_REPLACE_SLASHES(_ptr, _len) \\\n+     for (unsigned i = 0; i != (_len); ++i) \\\n+       if ((_ptr)[i] == '\\\\') (_ptr)[i] = '/';\n+\n+#  define WIN32_UNC_PREFIX \"//?/UNC/\"\n+#  define WIN32_UNC_PREFIX_LEN (sizeof(WIN32_UNC_PREFIX)-1)\n+#  define WIN32_IS_UNC_PREFIX(ptr) \\\n+  (0 == memcmp(ptr, WIN32_UNC_PREFIX, WIN32_UNC_PREFIX_LEN))\n+\n+#  define WIN32_NON_UNC_PREFIX \"//?/\"\n+#  define WIN32_NON_UNC_PREFIX_LEN (sizeof(WIN32_NON_UNC_PREFIX)-1)\n+#  define WIN32_IS_NON_UNC_PREFIX(ptr) \\\n+  (0 == memcmp(ptr, WIN32_NON_UNC_PREFIX, WIN32_NON_UNC_PREFIX_LEN))\n+\n+/* Get full path name without symlinks resolution.\n+   It also converts all forward slashes to back slashes.\n+*/\n+char* get_full_path_name(const char *filename) {\n+  DWORD len;\n+  char *buf, *ptr, *res;\n+\n+  /* determining the required buffer size.\n+     from the man: `If the lpBuffer buffer is too small to contain\n+     the path, the return value is the size, in TCHARs, of the buffer\n+     that is required to hold the path _and_the_terminating_null_character_`\n+  */\n+  len = GetFullPathName(filename, 0, NULL, NULL);\n+\n+  if ( len == 0 )\n+    return strdup(filename);\n+\n+  buf = (char *)malloc(len);\n+\n+  /* no point to check the result again */\n+  len = GetFullPathName(filename, len, buf, NULL);\n+  buf[len] = 0;\n+\n+  /* replace slashes */\n+  WIN32_REPLACE_SLASHES(buf, len);\n+\n+  /* calculate offset based on prefix type */\n+  len = WIN32_IS_UNC_PREFIX(buf)\n+    ? (WIN32_UNC_PREFIX_LEN - 2)\n+    : WIN32_IS_NON_UNC_PREFIX(buf)\n+      ? WIN32_NON_UNC_PREFIX_LEN\n+      : 0\n+  ;\n+\n+  ptr = buf + len;\n+  if ( WIN32_IS_UNC_PREFIX(buf) ) {\n+    ptr[0] = '/';\n+    ptr[1] = '/';\n+  }\n+\n+  res = strdup(ptr);\n+\n+  free(buf);\n+\n+  return res;\n+}\n+\n+# if _WIN32_WINNT >= 0x0600\n+\n+/* Get full path name WITH symlinks resolution.\n+   It also converts all forward slashes to back slashes.\n+*/\n+char* get_final_path_name(HANDLE fh) {\n+  DWORD len;\n+  char *buf, *ptr, *res;\n+\n+  /* determining the required buffer size.\n+     from the  man: `If the function fails because lpszFilePath is too\n+     small to hold the string plus the terminating null character,\n+     the return value is the required buffer size, in TCHARs. This\n+     value _includes_the_size_of_the_terminating_null_character_`.\n+     but in my testcase I have path with 26 chars, the function\n+     returns 26 also, ie without the trailing zero-char...\n+  */\n+  len = GetFinalPathNameByHandle(\n+     fh\n+    ,NULL\n+    ,0\n+    ,FILE_NAME_NORMALIZED | VOLUME_NAME_DOS\n+  );\n+\n+  if ( len == 0 )\n+    return NULL;\n+\n+  len += 1; /* for zero-char */\n+  buf = (char *)malloc(len);\n+\n+  /* no point to check the result again */\n+  len = GetFinalPathNameByHandle(\n+     fh\n+    ,buf\n+    ,len\n+    ,FILE_NAME_NORMALIZED | VOLUME_NAME_DOS\n+  );\n+  buf[len] = 0;\n+\n+  /* replace slashes */\n+  WIN32_REPLACE_SLASHES(buf, len);\n+\n+  /* calculate offset based on prefix type */\n+  len = WIN32_IS_UNC_PREFIX(buf)\n+    ? (WIN32_UNC_PREFIX_LEN - 2)\n+    : WIN32_IS_NON_UNC_PREFIX(buf)\n+      ? WIN32_NON_UNC_PREFIX_LEN\n+      : 0\n+  ;\n+\n+  ptr = buf + len;\n+  if ( WIN32_IS_UNC_PREFIX(buf) ) {\n+    ptr[0] = '/';\n+    ptr[1] = '/';\n+  }\n+\n+  res = strdup(ptr);\n+\n+  free(buf);\n+\n+  return res;\n+}\n+\n+# endif // _WIN32_WINNT >= 0x0600\n+\n+# endif // _WIN32\n #endif\n \n char *\n@@ -128,30 +255,52 @@ lrealpath (const char *filename)\n   }\n #endif\n \n-  /* The MS Windows method.  If we don't have realpath, we assume we\n-     don't have symlinks and just canonicalize to a Windows absolute\n-     path.  GetFullPath converts ../ and ./ in relative paths to\n-     absolute paths, filling in current drive if one is not given\n-     or using the current directory of a specified drive (eg, \"E:foo\").\n-     It also converts all forward slashes to back slashes.  */\n+  /* The MS Windows method */\n #if defined (_WIN32)\n   {\n-    char buf[MAX_PATH];\n-    char* basename;\n-    DWORD len = GetFullPathName (filename, MAX_PATH, buf, &basename);\n-    if (len == 0 || len > MAX_PATH - 1)\n-      return strdup (filename);\n-    else\n-      {\n-\t/* The file system is case-preserving but case-insensitive,\n-\t   Canonicalize to lowercase, using the codepage associated\n-\t   with the process locale.  */\n-        CharLowerBuff (buf, len);\n-        return strdup (buf);\n-      }\n-  }\n-#endif\n+    char *res;\n+\n+    /* For Windows Vista and greater */\n+#if _WIN32_WINNT >= 0x0600\n+\n+    /* For some reason the function receives just empty `filename`, but not NULL.\n+       What should we do in that case?\n+       According to `strdup()` implementation\n+         (https://elixir.bootlin.com/glibc/latest/source/string/strdup.c)\n+       it will alloc 1 byte even for empty but non NULL string.\n+       OK, will use `strdup()` for that case.\n+    */\n+    if ( 0 == strlen(filename) )\n+      return strdup(filename);\n+\n+    HANDLE fh = CreateFile(\n+       filename\n+      ,FILE_READ_ATTRIBUTES\n+      ,FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE\n+      ,NULL\n+      ,OPEN_EXISTING\n+      ,FILE_FLAG_BACKUP_SEMANTICS\n+      ,NULL\n+    );\n+\n+    if ( fh == INVALID_HANDLE_VALUE ) {\n+      res = get_full_path_name(filename);\n+    } else {\n+      res = get_final_path_name(fh);\n+      CloseHandle(fh);\n \n-  /* This system is a lost cause, just duplicate the filename.  */\n-  return strdup (filename);\n+      if ( !res )\n+        res = get_full_path_name(filename);\n+    }\n+\n+#else\n+\n+    /* For Windows XP */\n+    res = get_full_path_name(filename);\n+\n+#endif // _WIN32_WINNT >= 0x0600\n+\n+    return res;\n+  }\n+#endif // _WIN32\n }"}]}