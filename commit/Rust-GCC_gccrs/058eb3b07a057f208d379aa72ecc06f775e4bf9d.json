{"sha": "058eb3b07a057f208d379aa72ecc06f775e4bf9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4ZWIzYjA3YTA1N2YyMDhkMzc5YWE3MmVjYzA2Zjc3NWU0YmY5ZA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-04-22T00:44:37Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-22T00:44:37Z"}, "message": "make some HAVE_cc0 code always compiled\n\ngcc/ChangeLog:\n\n2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* cfgrtl.c (rtl_merge_blocks): Change #if HAVE_cc0 to if (HAVE_cc0)\n\t(try_redirect_by_replacing_jump): Likewise.\n\t(rtl_tidy_fallthru_edge): Likewise.\n\t* combine.c (insn_a_feeds_b): Likewise.\n\t(find_split_point): Likewise.\n\t(simplify_set): Likewise.\n\t* cprop.c (cprop_jump): Likewise.\n\t* cse.c (cse_extended_basic_block): Likewise.\n\t* df-problems.c (can_move_insns_across): Likewise.\n\t* function.c (emit_use_return_register_into_block): Likewise.\n\t* haifa-sched.c (sched_init): Likewise.\n\t* ira.c (find_moveable_pseudos): Likewise.\n\t* loop-invariant.c (find_invariant_insn): Likewise.\n\t* lra-constraints.c (curr_insn_transform): Likewise.\n\t* postreload.c (reload_combine_recognize_const_pattern):\n\t* Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* reorg.c (delete_scheduled_jump): Likewise.\n\t(steal_delay_list_from_target): Likewise.\n\t(steal_delay_list_from_fallthrough): Likewise.\n\t(redundant_insn): Likewise.\n\t(fill_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(delete_computation): Likewise.\n\t* sched-rgn.c (add_branch_dependences): Likewise.\n\nFrom-SVN: r222297", "tree": {"sha": "10084d55f5fd868d958de40b14d205b2dd6521aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10084d55f5fd868d958de40b14d205b2dd6521aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058eb3b07a057f208d379aa72ecc06f775e4bf9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058eb3b07a057f208d379aa72ecc06f775e4bf9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058eb3b07a057f208d379aa72ecc06f775e4bf9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058eb3b07a057f208d379aa72ecc06f775e4bf9d/comments", "author": null, "committer": null, "parents": [{"sha": "f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1e52ed6b2a91ff953156a63a5c4af70e17fb6a8"}], "stats": {"total": 135, "additions": 57, "deletions": 78}, "files": [{"sha": "7b7729ac05e849176f1931e1c86ea7c07282a968", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -1,3 +1,31 @@\n+2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* cfgrtl.c (rtl_merge_blocks): Change #if HAVE_cc0 to if (HAVE_cc0)\n+\t(try_redirect_by_replacing_jump): Likewise.\n+\t(rtl_tidy_fallthru_edge): Likewise.\n+\t* combine.c (insn_a_feeds_b): Likewise.\n+\t(find_split_point): Likewise.\n+\t(simplify_set): Likewise.\n+\t* cprop.c (cprop_jump): Likewise.\n+\t* cse.c (cse_extended_basic_block): Likewise.\n+\t* df-problems.c (can_move_insns_across): Likewise.\n+\t* function.c (emit_use_return_register_into_block): Likewise.\n+\t* haifa-sched.c (sched_init): Likewise.\n+\t* ira.c (find_moveable_pseudos): Likewise.\n+\t* loop-invariant.c (find_invariant_insn): Likewise.\n+\t* lra-constraints.c (curr_insn_transform): Likewise.\n+\t* postreload.c (reload_combine_recognize_const_pattern):\n+\t* Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reorg.c (delete_scheduled_jump): Likewise.\n+\t(steal_delay_list_from_target): Likewise.\n+\t(steal_delay_list_from_fallthrough): Likewise.\n+\t(redundant_insn): Likewise.\n+\t(fill_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t(delete_computation): Likewise.\n+\t* sched-rgn.c (add_branch_dependences): Likewise.\n+\n 2015-04-21  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* genconfig.c (main): Always define HAVE_cc0."}, {"sha": "322d1a9431b644ec7b161d1cc7ff9331744beba4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -893,10 +893,9 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n       del_first = a_end;\n \n-#if HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n-      if (only_sets_cc0_p (prev))\n+      if (HAVE_cc0 && only_sets_cc0_p (prev))\n \t{\n \t  rtx_insn *tmp = prev;\n \n@@ -905,7 +904,6 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \t    prev = BB_HEAD (a);\n \t  del_first = tmp;\n \t}\n-#endif\n \n       a_end = PREV_INSN (del_first);\n     }\n@@ -1064,11 +1062,9 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   /* In case we zap a conditional jump, we'll need to kill\n      the cc0 setter too.  */\n   kill_from = insn;\n-#if HAVE_cc0\n-  if (reg_mentioned_p (cc0_rtx, PATTERN (insn))\n+  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, PATTERN (insn))\n       && only_sets_cc0_p (PREV_INSN (insn)))\n     kill_from = PREV_INSN (insn);\n-#endif\n \n   /* See if we can create the fallthru edge.  */\n   if (in_cfglayout || can_fallthru (src, target))\n@@ -1825,12 +1821,10 @@ rtl_tidy_fallthru_edge (edge e)\n \t  delete_insn (table);\n \t}\n \n-#if HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n-      if (any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))\n+      if (HAVE_cc0 && any_condjump_p (q) && only_sets_cc0_p (PREV_INSN (q)))\n \tq = PREV_INSN (q);\n-#endif\n \n       q = PREV_INSN (q);\n     }"}, {"sha": "d71f863934345b19dd41482b5ac77477168c9157", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -1141,10 +1141,8 @@ insn_a_feeds_b (rtx_insn *a, rtx_insn *b)\n   FOR_EACH_LOG_LINK (links, b)\n     if (links->insn == a)\n       return true;\n-#if HAVE_cc0\n-  if (sets_cc0_p (a))\n+  if (HAVE_cc0 && sets_cc0_p (a))\n     return true;\n-#endif\n   return false;\n }\n \f\n@@ -4816,7 +4814,6 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n       break;\n \n     case SET:\n-#if HAVE_cc0\n       /* If SET_DEST is CC0 and SET_SRC is not an operand, a COMPARE, or a\n \t ZERO_EXTRACT, the most likely reason why this doesn't match is that\n \t we need to put the operand into a register.  So split at that\n@@ -4829,7 +4826,6 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  && ! (GET_CODE (SET_SRC (x)) == SUBREG\n \t\t&& OBJECT_P (SUBREG_REG (SET_SRC (x)))))\n \treturn &SET_SRC (x);\n-#endif\n \n       /* See if we can split SET_SRC as it stands.  */\n       split = find_split_point (&SET_SRC (x), insn, true);\n@@ -6582,13 +6578,12 @@ simplify_set (rtx x)\n       else\n \tcompare_mode = SELECT_CC_MODE (new_code, op0, op1);\n \n-#if !HAVE_cc0\n       /* If the mode changed, we have to change SET_DEST, the mode in the\n \t compare, and the mode in the place SET_DEST is used.  If SET_DEST is\n \t a hard register, just build new versions with the proper mode.  If it\n \t is a pseudo, we lose unless it is only time we set the pseudo, in\n \t which case we can safely change its mode.  */\n-      if (compare_mode != GET_MODE (dest))\n+      if (!HAVE_cc0 && compare_mode != GET_MODE (dest))\n \t{\n \t  if (can_change_dest_mode (dest, 0, compare_mode))\n \t    {\n@@ -6610,7 +6605,6 @@ simplify_set (rtx x)\n \t      dest = new_dest;\n \t    }\n \t}\n-#endif  /* cc0 */\n #endif  /* SELECT_CC_MODE */\n \n       /* If the code changed, we have to build a new comparison in"}, {"sha": "0103686563881f1c45ff763f5ae8f6b23468d358", "filename": "gcc/cprop.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -965,11 +965,9 @@ cprop_jump (basic_block bb, rtx_insn *setcc, rtx_insn *jump, rtx from, rtx src)\n \tremove_note (jump, note);\n      }\n \n-#if HAVE_cc0\n   /* Delete the cc0 setter.  */\n-  if (setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n+  if (HAVE_cc0 && setcc != NULL && CC0_P (SET_DEST (single_set (setcc))))\n     delete_insn (setcc);\n-#endif\n \n   global_const_prop_count++;\n   if (dump_file != NULL)"}, {"sha": "88a15e4b39ba050c0ebc9249196ca2daa3bbcae8", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -6524,8 +6524,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t  && check_for_label_ref (insn))\n \t\trecorded_label_ref = true;\n \n-#if HAVE_cc0\n-\t      if (NONDEBUG_INSN_P (insn))\n+\t      if (HAVE_cc0 && NONDEBUG_INSN_P (insn))\n \t\t{\n \t\t  /* If the previous insn sets CC0 and this insn no\n \t\t     longer references CC0, delete the previous insn.\n@@ -6552,7 +6551,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t      prev_insn_cc0_mode = this_insn_cc0_mode;\n \t\t    }\n \t\t}\n-#endif\n \t    }\n \t}\n "}, {"sha": "22fcfa6f6e06bb20fecb40e69ab6d2e51db2f534", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -3820,9 +3820,7 @@ can_move_insns_across (rtx_insn *from, rtx_insn *to,\n \t  if (bitmap_intersect_p (merge_set, test_use)\n \t      || bitmap_intersect_p (merge_use, test_set))\n \t    break;\n-#if HAVE_cc0\n-\t  if (!sets_cc0_p (insn))\n-#endif\n+\t  if (!HAVE_cc0 || !sets_cc0_p (insn))\n \t    max_to = insn;\n \t}\n       next = NEXT_INSN (insn);"}, {"sha": "9077c912f854626a74c50156f2cda0f061eedf3a", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -5661,10 +5661,9 @@ emit_use_return_register_into_block (basic_block bb)\n   seq = get_insns ();\n   end_sequence ();\n   insn = BB_END (bb);\n-#if HAVE_cc0\n-  if (reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n+  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n     insn = prev_cc0_setter (insn);\n-#endif\n+\n   emit_insn_before (seq, insn);\n }\n "}, {"sha": "d202fd806c1d225644dafbeb55a4ff4d2af4d8d4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -7184,9 +7184,8 @@ void\n sched_init (void)\n {\n   /* Disable speculative loads in their presence if cc0 defined.  */\n-#if HAVE_cc0\n+  if (HAVE_cc0)\n   flag_schedule_speculative_load = 0;\n-#endif\n \n   if (targetm.sched.dispatch (NULL, IS_DISPATCH_ON))\n     targetm.sched.dispatch_do (NULL, DISPATCH_INIT);"}, {"sha": "0750d11bbf62afa03e3b4d172924a367c1159f9f", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -4641,15 +4641,14 @@ find_moveable_pseudos (void)\n \t\t\t   ? \" (no unique first use)\" : \"\");\n \t\tcontinue;\n \t      }\n-#if HAVE_cc0\n-\t    if (reg_referenced_p (cc0_rtx, PATTERN (closest_use)))\n+\t    if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (closest_use)))\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Reg %d: closest user uses cc0\\n\",\n \t\t\t   regno);\n \t\tcontinue;\n \t      }\n-#endif\n+\n \t    bitmap_set_bit (&interesting, regno);\n \t    /* If we get here, we know closest_use is a non-NULL insn\n \t       (as opposed to const_0_rtx).  */"}, {"sha": "e3b560d683cd254039299596ed96a6ff354e10c3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -923,11 +923,9 @@ find_invariant_insn (rtx_insn *insn, bool always_reached, bool always_executed)\n   bool simple = true;\n   struct invariant *inv;\n \n-#if HAVE_cc0\n   /* We can't move a CC0 setter without the user.  */\n-  if (sets_cc0_p (insn))\n+  if (HAVE_cc0 && sets_cc0_p (insn))\n     return;\n-#endif\n \n   set = single_set (insn);\n   if (!set)"}, {"sha": "a65a12fa0543afccfdfb8643fe1ae6fe2d7efa8c", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -3354,12 +3354,10 @@ curr_insn_transform (bool check_only_p)\n   if (JUMP_P (curr_insn) || CALL_P (curr_insn))\n     no_output_reloads_p = true;\n \n-#if HAVE_cc0\n-  if (reg_referenced_p (cc0_rtx, PATTERN (curr_insn)))\n+  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (curr_insn)))\n     no_input_reloads_p = true;\n-  if (reg_set_p (cc0_rtx, PATTERN (curr_insn)))\n+  if (HAVE_cc0 && reg_set_p (cc0_rtx, PATTERN (curr_insn)))\n     no_output_reloads_p = true;\n-#endif\n \n   n_operands = curr_static_id->n_operands;\n   n_alternatives = curr_static_id->n_alternatives;"}, {"sha": "948fcbd8e0ceda6a39ef6a61430ae726a6404e8c", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -1032,11 +1032,9 @@ reload_combine_recognize_const_pattern (rtx_insn *insn)\n \t      && reg_state[clobbered_regno].real_store_ruid >= use_ruid)\n \t    break;\n \n-#if HAVE_cc0\n \t  /* Do not separate cc0 setter and cc0 user on HAVE_cc0 targets.  */\n-\t  if (must_move_add && sets_cc0_p (PATTERN (use_insn)))\n+\t  if (HAVE_cc0 && must_move_add && sets_cc0_p (PATTERN (use_insn)))\n \t    break;\n-#endif\n \n \t  gcc_assert (reg_state[regno].store_ruid <= use_ruid);\n \t  /* Avoid moving a use of ADDREG past a point where it is stored.  */"}, {"sha": "bb5dae7634f081bb30d7a29ac322859f3152bcd2", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -2706,12 +2706,10 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n   if (JUMP_P (insn) || CALL_P (insn))\n     no_output_reloads = 1;\n \n-#if HAVE_cc0\n-  if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n+  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     no_input_reloads = 1;\n-  if (reg_set_p (cc0_rtx, PATTERN (insn)))\n+  if (HAVE_cc0 && reg_set_p (cc0_rtx, PATTERN (insn)))\n     no_output_reloads = 1;\n-#endif\n \n #ifdef SECONDARY_MEMORY_NEEDED\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n@@ -4579,16 +4577,14 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t    rld[j].in = 0;\n \t  }\n \n-#if HAVE_cc0\n   /* If we made any reloads for addresses, see if they violate a\n      \"no input reloads\" requirement for this insn.  But loads that we\n      do after the insn (such as for output addresses) are fine.  */\n-  if (no_input_reloads)\n+  if (HAVE_cc0 && no_input_reloads)\n     for (i = 0; i < n_reloads; i++)\n       gcc_assert (rld[i].in == 0\n \t\t  || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS\n \t\t  || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS);\n-#endif\n \n   /* Compute reload_mode and reload_nregs.  */\n   for (i = 0; i < n_reloads; i++)"}, {"sha": "16dfa5e1f2359328cd4d664fabcb9a422fd6066b", "filename": "gcc/reorg.c", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -182,7 +182,6 @@ skip_consecutive_labels (rtx label_or_return)\n   return label;\n }\n \n-#if HAVE_cc0\n /* INSN uses CC0 and is being moved into a delay slot.  Set up REG_CC_SETTER\n    and REG_CC_USER notes so we can find it.  */\n \n@@ -197,7 +196,6 @@ link_cc0_insns (rtx insn)\n   add_reg_note (user, REG_CC_SETTER, insn);\n   add_reg_note (insn, REG_CC_USER, user);\n }\n-#endif\n \f\n /* Insns which have delay slots that have not yet been filled.  */\n \n@@ -699,8 +697,7 @@ delete_scheduled_jump (rtx_insn *insn)\n      be other insns that became dead anyway, which we wouldn't know to\n      delete.  */\n \n-#if HAVE_cc0\n-  if (reg_mentioned_p (cc0_rtx, insn))\n+  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, insn))\n     {\n       rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \n@@ -730,7 +727,6 @@ delete_scheduled_jump (rtx_insn *insn)\n \t    delete_from_delay_slot (trial);\n \t}\n     }\n-#endif\n \n   delete_related_insns (insn);\n }\n@@ -1171,11 +1167,9 @@ steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n \t  || insn_sets_resource_p (trial, sets, false)\n-#if HAVE_cc0\n \t  /* If TRIAL sets CC0, we can't copy it, so we can't steal this\n \t     delay list.  */\n-\t  || find_reg_note (trial, REG_CC_USER, NULL_RTX)\n-#endif\n+\t  || (HAVE_cc0 && find_reg_note (trial, REG_CC_USER, NULL_RTX))\n \t  /* If TRIAL is from the fallthrough code of an annulled branch insn\n \t     in SEQ, we cannot use it.  */\n \t  || (INSN_ANNULLED_BRANCH_P (seq->insn (0))\n@@ -1279,10 +1273,7 @@ steal_delay_list_from_fallthrough (rtx_insn *insn, rtx condition,\n       if (insn_references_resource_p (trial, sets, false)\n \t  || insn_sets_resource_p (trial, needed, false)\n \t  || insn_sets_resource_p (trial, sets, false)\n-#if HAVE_cc0\n-\t  || sets_cc0_p (PATTERN (trial))\n-#endif\n-\t  )\n+\t  || (HAVE_cc0 && sets_cc0_p (PATTERN (trial))))\n \n \tbreak;\n \n@@ -1629,9 +1620,7 @@ redundant_insn (rtx insn, rtx_insn *target, rtx delay_list)\n     target_main = XVECEXP (PATTERN (target), 0, 0);\n \n   if (resource_conflicts_p (&needed, &set)\n-#if HAVE_cc0\n-      || reg_mentioned_p (cc0_rtx, ipat)\n-#endif\n+      || (HAVE_cc0 && reg_mentioned_p (cc0_rtx, ipat))\n       /* The insn requiring the delay may not set anything needed or set by\n \t INSN.  */\n       || insn_sets_resource_p (target_main, &needed, true)\n@@ -2270,10 +2259,9 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t{\n \t\t  next_trial = next_nonnote_insn (trial);\n \t\t  delay_list = add_to_delay_list (trial, delay_list);\n-#if HAVE_cc0\n-\t\t  if (reg_mentioned_p (cc0_rtx, pat))\n+\t\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, pat))\n \t\t    link_cc0_insns (trial);\n-#endif\n+\n \t\t  delete_related_insns (trial);\n \t\t  if (slots_to_fill == ++slots_filled)\n \t\t    break;\n@@ -2605,10 +2593,8 @@ fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n \t\t  must_annul = 1;\n \t\twinner:\n \n-#if HAVE_cc0\n-\t\t  if (reg_mentioned_p (cc0_rtx, pat))\n+\t\t  if (HAVE_cc0 && reg_mentioned_p (cc0_rtx, pat))\n \t\t    link_cc0_insns (trial);\n-#endif\n \n \t\t  /* If we own this thread, delete the insn.  If this is the\n \t\t     destination of a branch, show that a basic block status\n@@ -3161,8 +3147,7 @@ delete_computation (rtx insn)\n {\n   rtx note, next;\n \n-#if HAVE_cc0\n-  if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n+  if (HAVE_cc0 && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     {\n       rtx prev = prev_nonnote_insn (insn);\n       /* We assume that at this stage\n@@ -3182,7 +3167,6 @@ delete_computation (rtx insn)\n \t    add_reg_note (prev, REG_UNUSED, cc0_rtx);\n \t}\n     }\n-#endif\n \n   for (note = REG_NOTES (insn); note; note = next)\n     {"}, {"sha": "7efd4add2363cd64ed914cbe1ed6abb20f2640d0", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058eb3b07a057f208d379aa72ecc06f775e4bf9d/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=058eb3b07a057f208d379aa72ecc06f775e4bf9d", "patch": "@@ -2487,9 +2487,7 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t || can_throw_internal (insn)\n-#if HAVE_cc0\n-\t\t || sets_cc0_p (PATTERN (insn))\n-#endif\n+\t\t || (HAVE_cc0 && sets_cc0_p (PATTERN (insn)))\n \t\t || (!reload_completed\n \t\t     && sets_likely_spilled (PATTERN (insn)))))\n \t || NOTE_P (insn)"}]}