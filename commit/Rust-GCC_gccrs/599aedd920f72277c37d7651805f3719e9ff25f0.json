{"sha": "599aedd920f72277c37d7651805f3719e9ff25f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5YWVkZDkyMGY3MjI3N2MzN2Q3NjUxODA1ZjM3MTllOWZmMjVmMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-03-13T09:02:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-03-13T09:02:51Z"}, "message": "emit-rtl.c (try_split): Handle 1-1 splits of call insns properly.\n\n        * emit-rtl.c (try_split): Handle 1-1 splits of call insns properly.\n\n        * config/ia64/ia64.c (TARGET_FUNCTION_OK_FOR_SIBCALL): New.\n        (ia64_gp_save_reg): Remove.\n        (struct ia64_frame_info): Move to the beginning of the file;\n        add reg_save_gp.\n        (ia64_expand_call): Rearrange for new call patterns.\n        (ia64_reload_gp): New.\n        (ia64_split_call): New.\n        (ia64_compute_frame_size): Allocate reg_save_gp.\n        (ia64_expand_prologue): Save reg_save_gp.\n        (ia64_expand_epilogue): Don't restore gp.\n        (ia64_hard_regno_rename_ok): Remove R4 hack.\n        (ia64_function_ok_for_sibcall): New.\n        (ia64_output_mi_thunk): Set reload_completed, no_new_pseudos;\n        call try_split on sibcall pattern.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/ia64.md (call_nogp, call_value_nogp, sibcall_nogp):\n        Rename from nopic versions.  Confiscate 2nd argument to call as\n        a marker.\n        (call_pic, call_value_pic, sibcall_pic): Remove.\n        (call_gp, call_value_gp, sibcall_gp): New.\n        (builtin_setjmp_setup): Remove.\n        (builtin_setjmp_receiver): Call ia64_reload_gp.\n\nFrom-SVN: r64303", "tree": {"sha": "6924a196edd1c1f5127f1d9ebb210b51d1624930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6924a196edd1c1f5127f1d9ebb210b51d1624930"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599aedd920f72277c37d7651805f3719e9ff25f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599aedd920f72277c37d7651805f3719e9ff25f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599aedd920f72277c37d7651805f3719e9ff25f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599aedd920f72277c37d7651805f3719e9ff25f0/comments", "author": null, "committer": null, "parents": [{"sha": "7e38bf41d90bf207f36d53a5b07f635f93cce2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e38bf41d90bf207f36d53a5b07f635f93cce2e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e38bf41d90bf207f36d53a5b07f635f93cce2e7"}], "stats": {"total": 779, "additions": 469, "deletions": 310}, "files": [{"sha": "d38b71b23ad74d2a4a5964f036248d74f749c3c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=599aedd920f72277c37d7651805f3719e9ff25f0", "patch": "@@ -1,3 +1,30 @@\n+2003-03-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* emit-rtl.c (try_split): Handle 1-1 splits of call insns properly.\n+\n+\t* config/ia64/ia64.c (TARGET_FUNCTION_OK_FOR_SIBCALL): New.\n+\t(ia64_gp_save_reg): Remove.\n+\t(struct ia64_frame_info): Move to the beginning of the file;\n+\tadd reg_save_gp.\n+\t(ia64_expand_call): Rearrange for new call patterns.\n+\t(ia64_reload_gp): New.\n+\t(ia64_split_call): New.\n+\t(ia64_compute_frame_size): Allocate reg_save_gp.\n+\t(ia64_expand_prologue): Save reg_save_gp.\n+\t(ia64_expand_epilogue): Don't restore gp.\n+\t(ia64_hard_regno_rename_ok): Remove R4 hack.\n+\t(ia64_function_ok_for_sibcall): New.\n+\t(ia64_output_mi_thunk): Set reload_completed, no_new_pseudos; \n+\tcall try_split on sibcall pattern.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.md (call_nogp, call_value_nogp, sibcall_nogp):\n+\tRename from nopic versions.  Confiscate 2nd argument to call as\n+\ta marker.\n+\t(call_pic, call_value_pic, sibcall_pic): Remove.\n+\t(call_gp, call_value_gp, sibcall_gp): New.\n+\t(builtin_setjmp_setup): Remove.\n+\t(builtin_setjmp_receiver): Call ia64_reload_gp.\n+\n 2003-03-12  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* config/dsp16xx/dsp16xx-protos.h, config/dsp16xx/dsp16xx.c, "}, {"sha": "a7caee2f6096bbaf4c1d2bc6acccae5027bcbdf1", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=599aedd920f72277c37d7651805f3719e9ff25f0", "patch": "@@ -77,11 +77,12 @@ extern int basereg_operand PARAMS((rtx, enum machine_mode));\n extern rtx ia64_expand_move PARAMS ((rtx, rtx));\n extern int ia64_move_ok PARAMS((rtx, rtx));\n extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n-extern rtx ia64_gp_save_reg PARAMS((int));\n extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n extern rtx spill_tfmode_operand PARAMS((rtx, int));\n extern rtx ia64_expand_compare PARAMS((enum rtx_code, enum machine_mode));\n extern void ia64_expand_call PARAMS((rtx, rtx, rtx, int));\n+extern void ia64_split_call PARAMS((rtx, rtx, rtx, rtx, rtx, int, int));\n+extern void ia64_reload_gp PARAMS((void));\n \n extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n extern void ia64_expand_prologue PARAMS((void));"}, {"sha": "384d636517ce290421192de72d73356afbcf2851", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 214, "deletions": 116, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=599aedd920f72277c37d7651805f3719e9ff25f0", "patch": "@@ -123,6 +123,38 @@ unsigned int ia64_section_threshold;\n    TRUE if we do insn bundling instead of insn scheduling.  */\n int bundling_p = 0;\n \n+/* Structure to be filled in by ia64_compute_frame_size with register\n+   save masks and offsets for the current function.  */\n+\n+struct ia64_frame_info\n+{\n+  HOST_WIDE_INT total_size;\t/* size of the stack frame, not including\n+\t\t\t\t   the caller's scratch area.  */\n+  HOST_WIDE_INT spill_cfa_off;\t/* top of the reg spill area from the cfa.  */\n+  HOST_WIDE_INT spill_size;\t/* size of the gr/br/fr spill area.  */\n+  HOST_WIDE_INT extra_spill_size;  /* size of spill area for others.  */\n+  HARD_REG_SET mask;\t\t/* mask of saved registers.  */\n+  unsigned int gr_used_mask;\t/* mask of registers in use as gr spill \n+\t\t\t\t   registers or long-term scratches.  */\n+  int n_spilled;\t\t/* number of spilled registers.  */\n+  int reg_fp;\t\t\t/* register for fp.  */\n+  int reg_save_b0;\t\t/* save register for b0.  */\n+  int reg_save_pr;\t\t/* save register for prs.  */\n+  int reg_save_ar_pfs;\t\t/* save register for ar.pfs.  */\n+  int reg_save_ar_unat;\t\t/* save register for ar.unat.  */\n+  int reg_save_ar_lc;\t\t/* save register for ar.lc.  */\n+  int reg_save_gp;\t\t/* save register for gp.  */\n+  int n_input_regs;\t\t/* number of input registers used.  */\n+  int n_local_regs;\t\t/* number of local registers used.  */\n+  int n_output_regs;\t\t/* number of output registers used.  */\n+  int n_rotate_regs;\t\t/* number of rotating registers used.  */\n+\n+  char need_regstk;\t\t/* true if a .regstk directive needed.  */\n+  char initialized;\t\t/* true if the data is finalized.  */\n+};\n+\n+/* Current frame information calculated by ia64_compute_frame_size.  */\n+static struct ia64_frame_info current_frame_info;\n \f\n static int ia64_use_dfa_pipeline_interface PARAMS ((void));\n static int ia64_first_cycle_multipass_dfa_lookahead PARAMS ((void));\n@@ -147,6 +179,7 @@ static rtx gen_fr_spill_x PARAMS ((rtx, rtx, rtx));\n static rtx gen_fr_restore_x PARAMS ((rtx, rtx, rtx));\n \n static enum machine_mode hfa_element_mode PARAMS ((tree, int));\n+static bool ia64_function_ok_for_sibcall PARAMS ((tree, tree));\n static bool ia64_rtx_costs PARAMS ((rtx, int, int, int *));\n static void fix_range PARAMS ((const char *));\n static struct machine_function * ia64_init_machine_status PARAMS ((void));\n@@ -313,6 +346,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_HAVE_TLS true\n #endif\n \n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL ia64_function_ok_for_sibcall\n+\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK ia64_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -1317,46 +1353,6 @@ ia64_expand_move (op0, op1)\n   return op1;\n }\n \n-rtx\n-ia64_gp_save_reg (setjmp_p)\n-     int setjmp_p;\n-{\n-  rtx save = cfun->machine->ia64_gp_save;\n-\n-  if (save != NULL)\n-    {\n-      /* We can't save GP in a pseudo if we are calling setjmp, because\n-\t pseudos won't be restored by longjmp.  For now, we save it in r4.  */\n-      /* ??? It would be more efficient to save this directly into a stack\n-\t slot.  Unfortunately, the stack slot address gets cse'd across\n-\t the setjmp call because the NOTE_INSN_SETJMP note is in the wrong\n-\t place.  */\n-\n-      /* ??? Get the barf bag, Virginia.  We've got to replace this thing\n-         in place, since this rtx is used in exception handling receivers.\n-         Moreover, we must get this rtx out of regno_reg_rtx or reload\n-         will do the wrong thing.  */\n-      unsigned int old_regno = REGNO (save);\n-      if (setjmp_p && old_regno != GR_REG (4))\n-        {\n-          REGNO (save) = GR_REG (4);\n-          regno_reg_rtx[old_regno] = gen_rtx_raw_REG (DImode, old_regno);\n-        }\n-    }\n-  else\n-    {\n-      if (setjmp_p)\n-\tsave = gen_rtx_REG (DImode, GR_REG (4));\n-      else if (! optimize)\n-\tsave = gen_rtx_REG (DImode, LOC_REG (0));\n-      else\n-\tsave = gen_reg_rtx (DImode);\n-      cfun->machine->ia64_gp_save = save;\n-    }\n-\n-  return save;\n-}\n-\n /* Split a post-reload TImode reference into two DImode components.  */\n \n rtx\n@@ -1494,67 +1490,148 @@ void\n ia64_expand_call (retval, addr, nextarg, sibcall_p)\n      rtx retval;\n      rtx addr;\n-     rtx nextarg;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n      int sibcall_p;\n {\n-  rtx insn, b0, pfs, gp_save, narg_rtx, dest;\n-  bool indirect_p;\n-  int narg;\n+  rtx insn, b0;\n \n   addr = XEXP (addr, 0);\n   b0 = gen_rtx_REG (DImode, R_BR (0));\n-  pfs = gen_rtx_REG (DImode, AR_PFS_REGNUM);\n-\n-  if (! nextarg)\n-    narg = 0;\n-  else if (IN_REGNO_P (REGNO (nextarg)))\n-    narg = REGNO (nextarg) - IN_REG (0);\n-  else\n-    narg = REGNO (nextarg) - OUT_REG (0);\n-  narg_rtx = GEN_INT (narg);\n \n+  /* ??? Should do this for functions known to bind local too.  */\n   if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n     {\n       if (sibcall_p)\n-\tinsn = gen_sibcall_nopic (addr, narg_rtx, b0, pfs);\n+\tinsn = gen_sibcall_nogp (addr);\n       else if (! retval)\n-\tinsn = gen_call_nopic (addr, narg_rtx, b0);\n+\tinsn = gen_call_nogp (addr, b0);\n       else\n-\tinsn = gen_call_value_nopic (retval, addr, narg_rtx, b0);\n-      emit_call_insn (insn);\n-      return;\n+\tinsn = gen_call_value_nogp (retval, addr, b0);\n+      insn = emit_call_insn (insn);\n     }\n-\n-  indirect_p = ! symbolic_operand (addr, VOIDmode);\n-\n-  if (sibcall_p || (TARGET_CONST_GP && !indirect_p))\n-    gp_save = NULL_RTX;\n   else\n-    gp_save = ia64_gp_save_reg (setjmp_operand (addr, VOIDmode));\n+    {\n+      if (sibcall_p)\n+\tinsn = gen_sibcall_gp (addr);\n+      else if (! retval)\n+\tinsn = gen_call_gp (addr, b0);\n+      else\n+\tinsn = gen_call_value_gp (retval, addr, b0);\n+      insn = emit_call_insn (insn);\n \n-  if (gp_save)\n-    emit_move_insn (gp_save, pic_offset_table_rtx);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+    }\n \n-  /* If this is an indirect call, then we have the address of a descriptor.  */\n-  if (indirect_p)\n+  if (sibcall_p)\n     {\n-      dest = force_reg (DImode, gen_rtx_MEM (DImode, addr));\n-      emit_move_insn (pic_offset_table_rtx,\n-\t\t      gen_rtx_MEM (DImode, plus_constant (addr, 8)));\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), b0);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t       gen_rtx_REG (DImode, AR_PFS_REGNUM));\n     }\n+}\n+\n+void\n+ia64_reload_gp ()\n+{\n+  rtx tmp;\n+\n+  if (current_frame_info.reg_save_gp)\n+    tmp = gen_rtx_REG (DImode, current_frame_info.reg_save_gp);\n   else\n-    dest = addr;\n+    {\n+      HOST_WIDE_INT offset;\n+\n+      offset = (current_frame_info.spill_cfa_off\n+\t        + current_frame_info.spill_size);\n+      if (frame_pointer_needed)\n+        {\n+          tmp = hard_frame_pointer_rtx;\n+          offset = -offset;\n+        }\n+      else\n+        {\n+          tmp = stack_pointer_rtx;\n+          offset = current_frame_info.total_size - offset;\n+        }\n+\n+      if (CONST_OK_FOR_I (offset))\n+        emit_insn (gen_adddi3 (pic_offset_table_rtx,\n+\t\t\t       tmp, GEN_INT (offset)));\n+      else\n+        {\n+          emit_move_insn (pic_offset_table_rtx, GEN_INT (offset));\n+          emit_insn (gen_adddi3 (pic_offset_table_rtx,\n+\t\t\t         pic_offset_table_rtx, tmp));\n+        }\n+\n+      tmp = gen_rtx_MEM (DImode, pic_offset_table_rtx);\n+    }\n+\n+  emit_move_insn (pic_offset_table_rtx, tmp);\n+}\n+\n+void\n+ia64_split_call (retval, addr, retaddr, scratch_r, scratch_b,\n+\t\t noreturn_p, sibcall_p)\n+     rtx retval, addr, retaddr, scratch_r, scratch_b;\n+     int noreturn_p, sibcall_p;\n+{\n+  rtx insn;\n+  bool is_desc = false;\n+\n+  /* If we find we're calling through a register, then we're actually\n+     calling through a descriptor, so load up the values.  */\n+  if (REG_P (addr))\n+    {\n+      rtx tmp;\n+      bool addr_dead_p;\n+\n+      /* ??? We are currently constrained to *not* use peep2, because\n+\t we can legitimiately change the global lifetime of the GP\n+\t (in the form of killing where previously live).  This is \n+\t because a call through a descriptor doesn't use the previous\n+\t value of the GP, while a direct call does, and we do not\n+\t commit to either form until the split here.\n+\n+\t That said, this means that we lack precise life info for\n+\t whether ADDR is dead after this call.  This is not terribly\n+\t important, since we can fix things up essentially for free\n+\t with the POST_DEC below, but it's nice to not use it when we\n+\t can immediately tell it's not necessary.  */\n+      addr_dead_p = ((noreturn_p || sibcall_p\n+\t\t      || TEST_HARD_REG_BIT (regs_invalidated_by_call,\n+\t\t\t\t\t    REGNO (addr)))\n+\t\t     && !FUNCTION_ARG_REGNO_P (REGNO (addr)));\n+\n+      /* Load the code address into scratch_b.  */\n+      tmp = gen_rtx_POST_INC (Pmode, addr);\n+      tmp = gen_rtx_MEM (Pmode, tmp);\n+      emit_move_insn (scratch_r, tmp);\n+      emit_move_insn (scratch_b, scratch_r);\n+\n+      /* Load the GP address.  If ADDR is not dead here, then we must\n+\t revert the change made above via the POST_INCREMENT.  */\n+      if (!addr_dead_p)\n+\ttmp = gen_rtx_POST_DEC (Pmode, addr);\n+      else\n+\ttmp = addr;\n+      tmp = gen_rtx_MEM (Pmode, tmp);\n+      emit_move_insn (pic_offset_table_rtx, tmp);\n+\n+      is_desc = true;\n+      addr = scratch_b;\n+    }\n \n   if (sibcall_p)\n-    insn = gen_sibcall_pic (dest, narg_rtx, b0, pfs);\n-  else if (! retval)\n-    insn = gen_call_pic (dest, narg_rtx, b0);\n+    insn = gen_sibcall_nogp (addr);\n+  else if (retval)\n+    insn = gen_call_value_nogp (retval, addr, retaddr);\n   else\n-    insn = gen_call_value_pic (retval, dest, narg_rtx, b0);\n+    insn = gen_call_nogp (addr, retaddr);\n   emit_call_insn (insn);\n \n-  if (gp_save)\n-    emit_move_insn (pic_offset_table_rtx, gp_save);\n+  if ((!TARGET_CONST_GP || is_desc) && !noreturn_p && !sibcall_p)\n+    ia64_reload_gp ();\n }\n \f\n /* Begin the assembly file.  */\n@@ -1593,39 +1670,6 @@ emit_safe_across_calls (f)\n     fputc ('\\n', f);\n }\n \n-\n-/* Structure to be filled in by ia64_compute_frame_size with register\n-   save masks and offsets for the current function.  */\n-\n-struct ia64_frame_info\n-{\n-  HOST_WIDE_INT total_size;\t/* size of the stack frame, not including\n-\t\t\t\t   the caller's scratch area.  */\n-  HOST_WIDE_INT spill_cfa_off;\t/* top of the reg spill area from the cfa.  */\n-  HOST_WIDE_INT spill_size;\t/* size of the gr/br/fr spill area.  */\n-  HOST_WIDE_INT extra_spill_size;  /* size of spill area for others.  */\n-  HARD_REG_SET mask;\t\t/* mask of saved registers.  */\n-  unsigned int gr_used_mask;\t/* mask of registers in use as gr spill \n-\t\t\t\t   registers or long-term scratches.  */\n-  int n_spilled;\t\t/* number of spilled registers.  */\n-  int reg_fp;\t\t\t/* register for fp.  */\n-  int reg_save_b0;\t\t/* save register for b0.  */\n-  int reg_save_pr;\t\t/* save register for prs.  */\n-  int reg_save_ar_pfs;\t\t/* save register for ar.pfs.  */\n-  int reg_save_ar_unat;\t\t/* save register for ar.unat.  */\n-  int reg_save_ar_lc;\t\t/* save register for ar.lc.  */\n-  int n_input_regs;\t\t/* number of input registers used.  */\n-  int n_local_regs;\t\t/* number of local registers used.  */\n-  int n_output_regs;\t\t/* number of output registers used.  */\n-  int n_rotate_regs;\t\t/* number of rotating registers used.  */\n-\n-  char need_regstk;\t\t/* true if a .regstk directive needed.  */\n-  char initialized;\t\t/* true if the data is finalized.  */\n-};\n-\n-/* Current frame information calculated by ia64_compute_frame_size.  */\n-static struct ia64_frame_info current_frame_info;\n-\n /* Helper function for ia64_compute_frame_size: find an appropriate general\n    register to spill some special register to.  SPECIAL_SPILL_MASK contains\n    bits in GR0 to GR31 that have already been allocated by this routine.\n@@ -1867,6 +1911,17 @@ ia64_compute_frame_size (size)\n \t  extra_spill_size += 8;\n \t  n_spilled += 1;\n \t}\n+\n+      /* Similarly for gp.  Note that if we're calling setjmp, the stacked\n+\t registers are clobbered, so we fall back to the stack.  */\n+      current_frame_info.reg_save_gp\n+\t= (current_function_calls_setjmp ? 0 : find_gr_spill (1));\n+      if (current_frame_info.reg_save_gp == 0)\n+\t{\n+\t  SET_HARD_REG_BIT (mask, GR_REG (1));\n+\t  spill_size += 8;\n+\t  n_spilled += 1;\n+\t}\n     }\n   else\n     {\n@@ -2570,6 +2625,19 @@ ia64_expand_prologue ()\n \t}\n     }\n \n+  if (current_frame_info.reg_save_gp)\n+    {\n+      insn = emit_move_insn (gen_rtx_REG (DImode,\n+\t\t\t\t\t  current_frame_info.reg_save_gp),\n+\t\t\t     pic_offset_table_rtx);\n+      /* We don't know for sure yet if this is actually needed, since\n+\t we've not split the PIC call patterns.  If all of the calls\n+\t are indirect, and not followed by any uses of the gp, then\n+\t this save is dead.  Allow it to go away.  */\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, REG_NOTES (insn));\n+    }\n+\n   /* We should now be at the base of the gr/br/fr spill area.  */\n   if (cfa_off != (current_frame_info.spill_cfa_off\n \t\t  + current_frame_info.spill_size))\n@@ -2751,8 +2819,13 @@ ia64_expand_epilogue (sibcall_p)\n \t\t  + current_frame_info.spill_size))\n     abort ();\n \n+  /* The GP may be stored on the stack in the prologue, but it's\n+     never restored in the epilogue.  Skip the stack slot.  */\n+  if (TEST_HARD_REG_BIT (current_frame_info.mask, GR_REG (1)))\n+    cfa_off -= 8;\n+\n   /* Restore all general registers.  */\n-  for (regno = GR_REG (1); regno <= GR_REG (31); ++regno)\n+  for (regno = GR_REG (2); regno <= GR_REG (31); ++regno)\n     if (TEST_HARD_REG_BIT (current_frame_info.mask, regno))\n       {\n \treg = gen_rtx_REG (DImode, regno);\n@@ -2940,10 +3013,6 @@ ia64_hard_regno_rename_ok (from, to)\n   if (PR_REGNO_P (from) && PR_REGNO_P (to))\n     return (from & 1) == (to & 1);\n \n-  /* Reg 4 contains the saved gp; we can't reliably rename this.  */\n-  if (from == GR_REG (4) && current_function_calls_setjmp)\n-    return 0;\n-\n   return 1;\n }\n \n@@ -3572,6 +3641,23 @@ ia64_function_arg_pass_by_reference (cum, mode, type, named)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n }\n+\n+/* True if it is OK to do sibling call optimization for the specified\n+   call expression EXP.  DECL will be the called function, or NULL if\n+   this is an indirect call.  */\n+static bool\n+ia64_function_ok_for_sibcall (decl, exp)\n+     tree decl, exp;\n+{\n+  /* Direct calls are always ok.  */\n+  if (decl)\n+    return true;\n+\n+  /* If TARGET_CONST_GP is in effect, then our caller expects us to\n+     return with our current GP.  This means that we'll always have\n+     a GP reload after an indirect call.  */\n+  return !ia64_epilogue_uses (R_GR (1));\n+}\n \f\n \n /* Implement va_arg.  */\n@@ -8419,6 +8505,9 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n {\n   rtx this, insn, funexp;\n \n+  reload_completed = 1;\n+  no_new_pseudos = 1;\n+\n   /* Set things up as ia64_expand_prologue might.  */\n   last_scratch_gr_reg = 15;\n \n@@ -8481,18 +8570,27 @@ ia64_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n   ia64_expand_call (NULL_RTX, funexp, NULL_RTX, 1);\n   insn = get_last_insn ();\n   SIBLING_CALL_P (insn) = 1;\n+\n+  /* Code generation for calls relies on splitting.  */\n+  reload_completed = 1;\n+  try_split (PATTERN (insn), insn, 0);\n+\n   emit_barrier ();\n \n   /* Run just enough of rest_of_compilation to get the insns emitted.\n      There's not really enough bulk here to make other passes such as\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n+\n   insn = get_insns ();\n   emit_all_insn_group_barriers (NULL, insn);\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1, 0);\n   final_end_function ();\n+\n+  reload_completed = 0;\n+  no_new_pseudos = 0;\n }\n \n #include \"gt-ia64.h\""}, {"sha": "fad3ee3b9e98639743341b304d17b433393c9481", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 105, "deletions": 49, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=599aedd920f72277c37d7651805f3719e9ff25f0", "patch": "@@ -4671,7 +4671,7 @@\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n {\n-  ia64_expand_call (NULL_RTX, operands[0], operands[2], 0);\n+  ia64_expand_call (NULL_RTX, operands[0], operands[2], false);\n   DONE;\n })\n \n@@ -4682,7 +4682,7 @@\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n {\n-  ia64_expand_call (NULL_RTX, operands[0], operands[2], 1);\n+  ia64_expand_call (NULL_RTX, operands[0], operands[2], true);\n   DONE;\n })\n \n@@ -4701,7 +4701,7 @@\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n {\n-  ia64_expand_call (operands[0], operands[1], operands[3], 0);\n+  ia64_expand_call (operands[0], operands[1], operands[3], false);\n   DONE;\n })\n \n@@ -4713,7 +4713,7 @@\n    (use (match_operand 4 \"\" \"\"))]\n   \"\"\n {\n-  ia64_expand_call (operands[0], operands[1], operands[3], 1);\n+  ia64_expand_call (operands[0], operands[1], operands[3], true);\n   DONE;\n })\n \n@@ -4745,59 +4745,125 @@\n   DONE;\n })\n \n-(define_insn \"call_nopic\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"b,i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=b,b\"))]\n+(define_insn \"call_nogp\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"?b,i\"))\n+\t (const_int 0))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"=b,b\"))]\n   \"\"\n-  \"br.call%+.many %2 = %0\"\n+  \"br.call%+.many %1 = %0\"\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n-(define_insn \"call_value_nopic\"\n+(define_insn \"call_value_nogp\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"b,i\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=b,b\"))]\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"?b,i\"))\n+\t      (const_int 0)))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=b,b\"))]\n   \"\"\n-  \"br.call%+.many %3 = %1\"\n+  \"br.call%+.many %2 = %1\"\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n-(define_insn \"sibcall_nopic\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"b,i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"=b,b\"))\n-   (use (match_operand:DI 3 \"ar_pfs_reg_operand\" \"\"))]\n+(define_insn \"sibcall_nogp\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"?b,i\"))\n+\t (const_int 0))]\n   \"\"\n   \"br%+.many %0\"\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n-(define_insn \"call_pic\"\n-  [(call (mem (match_operand 0 \"call_operand\" \"b,i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (unspec [(reg:DI 1)] UNSPEC_PIC_CALL))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=b,b\"))]\n+(define_insn \"call_gp\"\n+  [(call (mem (match_operand 0 \"call_operand\" \"?r,i\"))\n+\t (const_int 1))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"=b,b\"))\n+   (clobber (match_scratch:DI 2 \"=&r,X\"))\n+   (clobber (match_scratch:DI 3 \"=b,X\"))]\n   \"\"\n-  \"br.call%+.many %2 = %0\"\n+  \"#\"\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n-(define_insn \"call_value_pic\"\n+;; Irritatingly, we don't have access to INSN within the split body.\n+;; See commentary in ia64_split_call as to why these aren't peep2.\n+(define_split\n+  [(call (mem (match_operand 0 \"call_operand\" \"\"))\n+\t (const_int 1))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n+   (clobber (match_scratch:DI 2 \"\"))\n+   (clobber (match_scratch:DI 3 \"\"))]\n+  \"reload_completed && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(const_int 0)]\n+{\n+  ia64_split_call (NULL_RTX, operands[0], operands[1], operands[2],\n+\t\t   operands[3], true, false);\n+  DONE;\n+})\n+\n+(define_split\n+  [(call (mem (match_operand 0 \"call_operand\" \"\"))\n+\t (const_int 1))\n+   (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n+   (clobber (match_scratch:DI 2 \"\"))\n+   (clobber (match_scratch:DI 3 \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  ia64_split_call (NULL_RTX, operands[0], operands[1], operands[2],\n+\t\t   operands[3], false, false);\n+  DONE;\n+})\n+\n+(define_insn \"call_value_gp\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"b,i\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (unspec [(reg:DI 1)] UNSPEC_PIC_CALL))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=b,b\"))]\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"?r,i\"))\n+\t      (const_int 1)))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=b,b\"))\n+   (clobber (match_scratch:DI 3 \"=&r,X\"))\n+   (clobber (match_scratch:DI 4 \"=b,X\"))]\n   \"\"\n-  \"br.call%+.many %3 = %1\"\n+  \"#\"\n   [(set_attr \"itanium_class\" \"br,scall\")])\n \n-(define_insn \"sibcall_pic\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"bi\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (unspec [(reg:DI 1)] UNSPEC_PIC_CALL))\n-   (use (match_operand:DI 2 \"register_operand\" \"=b\"))\n-   (use (match_operand:DI 3 \"ar_pfs_reg_operand\" \"\"))]\n+(define_split\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"\"))\n+\t      (const_int 1)))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"\"))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (match_scratch:DI 4 \"\"))]\n+  \"reload_completed && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(const_int 0)]\n+{\n+  ia64_split_call (operands[0], operands[1], operands[2], operands[3],\n+\t\t   operands[4], true, false);\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"\"))\n+\t      (const_int 1)))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"\"))\n+   (clobber (match_scratch:DI 3 \"\"))\n+   (clobber (match_scratch:DI 4 \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  ia64_split_call (operands[0], operands[1], operands[2], operands[3],\n+\t\t   operands[4], false, false);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"sibcall_gp\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"?r,i\"))\n+\t (const_int 1))\n+   (clobber (match_scratch:DI 1 \"=&r,X\"))\n+   (clobber (match_scratch:DI 2 \"=b,X\"))]\n   \"\"\n-  \"br%+.many %0\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  ia64_split_call (NULL_RTX, operands[0], NULL_RTX, operands[1],\n+\t\t   operands[2], true, true);\n+  DONE;\n+}\n   [(set_attr \"itanium_class\" \"br\")])\n \n (define_insn \"return_internal\"\n@@ -5263,21 +5329,11 @@\n   DONE;\n })\n \n-;; The rest of the setjmp processing happens with the nonlocal_goto expander.\n-;; ??? This is not tested.\n-(define_expand \"builtin_setjmp_setup\"\n-  [(use (match_operand:DI 0 \"\" \"\"))]\n-  \"\"\n-{\n-  emit_move_insn (ia64_gp_save_reg (0), gen_rtx_REG (DImode, GR_REG (1)));\n-  DONE;\n-})\n-\n (define_expand \"builtin_setjmp_receiver\"\n   [(use (match_operand:DI 0 \"\" \"\"))]\n   \"\"\n {\n-  emit_move_insn (gen_rtx_REG (DImode, GR_REG (1)), ia64_gp_save_reg (0));\n+  ia64_reload_gp ();\n   DONE;\n })\n "}, {"sha": "ad30637ee0a705a66d716a6429d28c243cfc3e1d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 121, "deletions": 144, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599aedd920f72277c37d7651805f3719e9ff25f0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=599aedd920f72277c37d7651805f3719e9ff25f0", "patch": "@@ -3375,6 +3375,8 @@ try_split (pat, trial, last)\n   rtx tem;\n   rtx note, seq;\n   int probability;\n+  rtx insn_last, insn;\n+  int njumps = 0;\n \n   if (any_condjump_p (trial)\n       && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n@@ -3393,172 +3395,147 @@ try_split (pat, trial, last)\n       after = NEXT_INSN (after);\n     }\n \n-  if (seq)\n+  if (!seq)\n+    return trial;\n+\n+  /* Avoid infinite loop if any insn of the result matches\n+     the original pattern.  */\n+  insn_last = seq;\n+  while (1)\n     {\n-      /* Sometimes there will be only one insn in that list, this case will\n-\t normally arise only when we want it in turn to be split (SFmode on\n-\t the 29k is an example).  */\n-      if (NEXT_INSN (seq) != NULL_RTX)\n-\t{\n-\t  rtx insn_last, insn;\n-\t  int njumps = 0;\n+      if (INSN_P (insn_last)\n+\t  && rtx_equal_p (PATTERN (insn_last), pat))\n+\treturn trial;\n+      if (!NEXT_INSN (insn_last))\n+\tbreak;\n+      insn_last = NEXT_INSN (insn_last);\n+    }\n \n-\t  /* Avoid infinite loop if any insn of the result matches\n-\t     the original pattern.  */\n-\t  insn_last = seq;\n-\t  while (1)\n+  /* Mark labels.  */\n+  for (insn = insn_last; insn ; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  mark_jump_label (PATTERN (insn), insn, 0);\n+\t  njumps++;\n+\t  if (probability != -1\n+\t      && any_condjump_p (insn)\n+\t      && !find_reg_note (insn, REG_BR_PROB, 0))\n \t    {\n-\t      if (INSN_P (insn_last)\n-\t\t  && rtx_equal_p (PATTERN (insn_last), pat))\n-\t\treturn trial;\n-\t      if (NEXT_INSN (insn_last) == NULL_RTX)\n-\t\tbreak;\n-\t      insn_last = NEXT_INSN (insn_last);\n+\t      /* We can preserve the REG_BR_PROB notes only if exactly\n+\t\t one jump is created, otherwise the machine description\n+\t\t is responsible for this step using\n+\t\t split_branch_probability variable.  */\n+\t      if (njumps != 1)\n+\t\tabort ();\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t     GEN_INT (probability),\n+\t\t\t\t     REG_NOTES (insn));\n \t    }\n+\t}\n+    }\n \n-\t  /* Mark labels.  */\n+  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n+     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */\n+  if (GET_CODE (trial) == CALL_INSN)\n+    {\n+      for (insn = insn_last; insn ; insn = PREV_INSN (insn))\n+\tif (GET_CODE (insn) == CALL_INSN)\n+\t  {\n+\t    CALL_INSN_FUNCTION_USAGE (insn)\n+\t      = CALL_INSN_FUNCTION_USAGE (trial);\n+\t    SIBLING_CALL_P (insn) = SIBLING_CALL_P (trial);\n+\t  }\n+    }\n+\n+  /* Copy notes, particularly those related to the CFG.  */\n+  for (note = REG_NOTES (trial); note; note = XEXP (note, 1))\n+    {\n+      switch (REG_NOTE_KIND (note))\n+\t{\n+\tcase REG_EH_REGION:\n \t  insn = insn_last;\n \t  while (insn != NULL_RTX)\n \t    {\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\t{\n-\t\t  mark_jump_label (PATTERN (insn), insn, 0);\n-\t\t  njumps++;\n-\t\t  if (probability != -1\n-\t\t      && any_condjump_p (insn)\n-\t\t      && !find_reg_note (insn, REG_BR_PROB, 0))\n-\t\t    {\n-\t\t      /* We can preserve the REG_BR_PROB notes only if exactly\n-\t\t\t one jump is created, otherwise the machine description\n-\t\t\t is responsible for this step using\n-\t\t\t split_branch_probability variable.  */\n-\t\t      if (njumps != 1)\n-\t\t\tabort ();\n-\t\t      REG_NOTES (insn)\n-\t\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB,\n-\t\t\t\t\t     GEN_INT (probability),\n-\t\t\t\t\t     REG_NOTES (insn));\n-\t\t    }\n-\t\t}\n-\n+\t      if (GET_CODE (insn) == CALL_INSN\n+\t\t  || (flag_non_call_exceptions\n+\t\t      && may_trap_p (PATTERN (insn))))\n+\t\tREG_NOTES (insn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_EH_REGION,\n+\t\t\t\t       XEXP (note, 0),\n+\t\t\t\t       REG_NOTES (insn));\n \t      insn = PREV_INSN (insn);\n \t    }\n+\t  break;\n \n-\t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n-\t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */\n-\t  if (GET_CODE (trial) == CALL_INSN)\n-\t    {\n-\t      insn = insn_last;\n-\t      while (insn != NULL_RTX)\n-\t\t{\n-\t\t  if (GET_CODE (insn) == CALL_INSN)\n-\t\t    CALL_INSN_FUNCTION_USAGE (insn)\n-\t\t      = CALL_INSN_FUNCTION_USAGE (trial);\n-\n-\t\t  insn = PREV_INSN (insn);\n-\t\t}\n-\t    }\n-\n-\t  /* Copy notes, particularly those related to the CFG.  */\n-\t  for (note = REG_NOTES (trial); note; note = XEXP (note, 1))\n+\tcase REG_NORETURN:\n+\tcase REG_SETJMP:\n+\tcase REG_ALWAYS_RETURN:\n+\t  insn = insn_last;\n+\t  while (insn != NULL_RTX)\n \t    {\n-\t      switch (REG_NOTE_KIND (note))\n-\t\t{\n-\t\tcase REG_EH_REGION:\n-\t\t  insn = insn_last;\n-\t\t  while (insn != NULL_RTX)\n-\t\t    {\n-\t\t      if (GET_CODE (insn) == CALL_INSN\n-\t\t\t  || (flag_non_call_exceptions\n-\t\t\t      && may_trap_p (PATTERN (insn))))\n-\t\t\tREG_NOTES (insn)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_EH_REGION,\n-\t\t\t\t\t       XEXP (note, 0),\n-\t\t\t\t\t       REG_NOTES (insn));\n-\t\t      insn = PREV_INSN (insn);\n-\t\t    }\n-\t\t  break;\n-\n-\t\tcase REG_NORETURN:\n-\t\tcase REG_SETJMP:\n-\t\tcase REG_ALWAYS_RETURN:\n-\t\t  insn = insn_last;\n-\t\t  while (insn != NULL_RTX)\n-\t\t    {\n-\t\t      if (GET_CODE (insn) == CALL_INSN)\n-\t\t\tREG_NOTES (insn)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n-\t\t\t\t\t       XEXP (note, 0),\n-\t\t\t\t\t       REG_NOTES (insn));\n-\t\t      insn = PREV_INSN (insn);\n-\t\t    }\n-\t\t  break;\n-\n-\t\tcase REG_NON_LOCAL_GOTO:\n-\t\t  insn = insn_last;\n-\t\t  while (insn != NULL_RTX)\n-\t\t    {\n-\t\t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\t\tREG_NOTES (insn)\n-\t\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n-\t\t\t\t\t       XEXP (note, 0),\n-\t\t\t\t\t       REG_NOTES (insn));\n-\t\t      insn = PREV_INSN (insn);\n-\t\t    }\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\tREG_NOTES (insn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n+\t\t\t\t       XEXP (note, 0),\n+\t\t\t\t       REG_NOTES (insn));\n+\t      insn = PREV_INSN (insn);\n \t    }\n+\t  break;\n \n-\t  /* If there are LABELS inside the split insns increment the\n-\t     usage count so we don't delete the label.  */\n-\t  if (GET_CODE (trial) == INSN)\n+\tcase REG_NON_LOCAL_GOTO:\n+\t  insn = insn_last;\n+\t  while (insn != NULL_RTX)\n \t    {\n-\t      insn = insn_last;\n-\t      while (insn != NULL_RTX)\n-\t\t{\n-\t\t  if (GET_CODE (insn) == INSN)\n-\t\t    mark_label_nuses (PATTERN (insn));\n-\n-\t\t  insn = PREV_INSN (insn);\n-\t\t}\n+\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t\tREG_NOTES (insn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n+\t\t\t\t       XEXP (note, 0),\n+\t\t\t\t       REG_NOTES (insn));\n+\t      insn = PREV_INSN (insn);\n \t    }\n+\t  break;\n \n-\t  tem = emit_insn_after_scope (seq, trial, INSN_SCOPE (trial));\n-\n-\t  delete_insn (trial);\n-\t  if (has_barrier)\n-\t    emit_barrier_after (tem);\n-\n-\t  /* Recursively call try_split for each new insn created; by the\n-\t     time control returns here that insn will be fully split, so\n-\t     set LAST and continue from the insn after the one returned.\n-\t     We can't use next_active_insn here since AFTER may be a note.\n-\t     Ignore deleted insns, which can be occur if not optimizing.  */\n-\t  for (tem = NEXT_INSN (before); tem != after; tem = NEXT_INSN (tem))\n-\t    if (! INSN_DELETED_P (tem) && INSN_P (tem))\n-\t      tem = try_split (PATTERN (tem), tem, 1);\n+\tdefault:\n+\t  break;\n \t}\n-      /* Avoid infinite loop if the result matches the original pattern.  */\n-      else if (rtx_equal_p (PATTERN (seq), pat))\n-\treturn trial;\n-      else\n+    }\n+\n+  /* If there are LABELS inside the split insns increment the\n+     usage count so we don't delete the label.  */\n+  if (GET_CODE (trial) == INSN)\n+    {\n+      insn = insn_last;\n+      while (insn != NULL_RTX)\n \t{\n-\t  PATTERN (trial) = PATTERN (seq);\n-\t  INSN_CODE (trial) = -1;\n-\t  try_split (PATTERN (trial), trial, last);\n-\t}\n+\t  if (GET_CODE (insn) == INSN)\n+\t    mark_label_nuses (PATTERN (insn));\n \n-      /* Return either the first or the last insn, depending on which was\n-\t requested.  */\n-      return last\n-\t\t? (after ? PREV_INSN (after) : last_insn)\n-\t\t: NEXT_INSN (before);\n+\t  insn = PREV_INSN (insn);\n+\t}\n     }\n \n-  return trial;\n+  tem = emit_insn_after_scope (seq, trial, INSN_SCOPE (trial));\n+\n+  delete_insn (trial);\n+  if (has_barrier)\n+    emit_barrier_after (tem);\n+\n+  /* Recursively call try_split for each new insn created; by the\n+     time control returns here that insn will be fully split, so\n+     set LAST and continue from the insn after the one returned.\n+     We can't use next_active_insn here since AFTER may be a note.\n+     Ignore deleted insns, which can be occur if not optimizing.  */\n+  for (tem = NEXT_INSN (before); tem != after; tem = NEXT_INSN (tem))\n+    if (! INSN_DELETED_P (tem) && INSN_P (tem))\n+      tem = try_split (PATTERN (tem), tem, 1);\n+\n+  /* Return either the first or the last insn, depending on which was\n+     requested.  */\n+  return last\n+    ? (after ? PREV_INSN (after) : last_insn)\n+    : NEXT_INSN (before);\n }\n \f\n /* Make and return an INSN rtx, initializing all its slots."}]}