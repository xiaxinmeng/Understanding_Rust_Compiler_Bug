{"sha": "987bbe48bb03e04810e6c97f292549f11b5b2126", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg3YmJlNDhiYjAzZTA0ODEwZTZjOTdmMjkyNTQ5ZjExYjViMjEyNg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-03-01T13:50:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-03-01T13:50:36Z"}, "message": "C++2a Utility functions to implement uses-allocator construction (P0591R4)\n\n\t* include/std/memory (uses_allocator_construction_args): New set of\n\toverloaded functions.\n\t(make_obj_using_allocator, uninitialized_construct_using_allocator):\n\tNew functions.\n\t* include/std/memory_resource (polymorphic_allocator::construct)\n\t[__cplusplus > 201703l]: Replace all overloads with a single function\n\tusing uses_allocator_construction_args.\n\t* testsuite/20_util/polymorphic_allocator/construct_c++2a.cc: New\n\ttest.\n\t* testsuite/20_util/uses_allocator/make_obj.cc: New test.\n\nFrom-SVN: r269311", "tree": {"sha": "434cccf6919aafcdf2743a74aa2c7bde2393a2c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/434cccf6919aafcdf2743a74aa2c7bde2393a2c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/987bbe48bb03e04810e6c97f292549f11b5b2126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987bbe48bb03e04810e6c97f292549f11b5b2126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/987bbe48bb03e04810e6c97f292549f11b5b2126", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987bbe48bb03e04810e6c97f292549f11b5b2126/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ccd8493516548e4da242b1093754aad323cd400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccd8493516548e4da242b1093754aad323cd400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccd8493516548e4da242b1093754aad323cd400"}], "stats": {"total": 745, "additions": 745, "deletions": 0}, "files": [{"sha": "67249de5bf5a1cd6b3d44e1ed78c08756dc0e2c7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=987bbe48bb03e04810e6c97f292549f11b5b2126", "patch": "@@ -1,3 +1,16 @@\n+2019-03-01  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/memory (uses_allocator_construction_args): New set of\n+\toverloaded functions.\n+\t(make_obj_using_allocator, uninitialized_construct_using_allocator):\n+\tNew functions.\n+\t* include/std/memory_resource (polymorphic_allocator::construct)\n+\t[__cplusplus > 201703l]: Replace all overloads with a single function\n+\tusing uses_allocator_construction_args.\n+\t* testsuite/20_util/polymorphic_allocator/construct_c++2a.cc: New\n+\ttest.\n+\t* testsuite/20_util/uses_allocator/make_obj.cc: New test.\n+\n 2019-02-27  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/89466"}, {"sha": "00a85eef25e13aa1a05045ed709d0a25a97021ea", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=987bbe48bb03e04810e6c97f292549f11b5b2126", "patch": "@@ -91,6 +91,8 @@\n #include <cstdint>\n #if __cplusplus > 201703L\n # include <bit>\t\t\t// for ispow2\n+# include <new>\t\t\t// for placement operator new\n+# include <tuple>\t\t// for tuple, make_tuple, make_from_tuple\n #endif\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -166,6 +168,197 @@ get_pointer_safety() noexcept { return pointer_safety::relaxed; }\n     }\n #endif // C++2a\n \n+#if __cplusplus > 201703L\n+  template<typename _Tp>\n+    struct __is_pair : false_type { };\n+  template<typename _Tp, typename _Up>\n+    struct __is_pair<pair<_Tp, _Up>> : true_type { };\n+  template<typename _Tp, typename _Up>\n+    struct __is_pair<const pair<_Tp, _Up>> : true_type { };\n+\n+  template<typename _Tp, typename __ = _Require<__not_<__is_pair<_Tp>>>,\n+\t   typename _Alloc, typename... _Args>\n+    constexpr auto\n+    __uses_alloc_args(const _Alloc& __a, _Args&&... __args) noexcept\n+    {\n+      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)\n+\t{\n+\t  if constexpr (is_constructible_v<_Tp, allocator_arg_t,\n+\t\t\t\t\t   const _Alloc&, _Args...>)\n+\t    {\n+\t      return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(\n+\t\t  allocator_arg, __a, std::forward<_Args>(__args)...);\n+\t    }\n+\t  else\n+\t    {\n+\t      static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>);\n+\n+\t      return tuple<_Args&&..., const _Alloc&>(\n+\t\t  std::forward<_Args>(__args)..., __a);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  static_assert(is_constructible_v<_Tp, _Args...>);\n+\n+\t  return tuple<_Args&&...>(std::forward<_Args>(__args)...);\n+\t}\n+    }\n+\n+#if __cpp_concepts\n+  template<typename _Tp>\n+    concept bool _Std_pair = __is_pair<_Tp>::value;\n+#endif\n+\n+// This is a temporary workaround until -fconcepts is implied by -std=gnu++2a\n+#if __cpp_concepts\n+# define _GLIBCXX_STD_PAIR_CONSTRAINT(T) _Std_pair T\n+# define _GLIBCXX_STD_PAIR_CONSTRAINT_(T) _Std_pair T\n+#else\n+# define _GLIBCXX_STD_PAIR_CONSTRAINT(T) \\\n+      typename T, typename __ = _Require<__is_pair<T>>\n+# define _GLIBCXX_STD_PAIR_CONSTRAINT_(T) typename T, typename\n+#endif\n+\n+  template<typename _Tp,\n+#if ! __cpp_concepts\n+\t   typename __ = _Require<__not_<__is_pair<_Tp>>>,\n+#endif\n+\t   typename _Alloc, typename... _Args>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     _Args&&... __args) noexcept\n+#if __cpp_concepts\n+    requires ! _Std_pair<_Tp>\n+#endif\n+    {\n+      return std::__uses_alloc_args<_Tp>(__a, std::forward<_Args>(__args)...);\n+    }\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n+\t   typename _Tuple1, typename _Tuple2>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n+\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept;\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&) noexcept;\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&,\n+\t\t\t\t     const pair<_Up, _Vp>&) noexcept;\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n+\t   typename _Tuple1, typename _Tuple2>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n+\t\t\t\t     _Tuple1&& __x, _Tuple2&& __y) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::apply([&__a](auto&&... __args1) {\n+\t      return std::uses_allocator_construction_args<_Tp1>(\n+\t\t  __a, std::forward<decltype(__args1)>(__args1)...);\n+\t  }, std::forward<_Tuple1>(__x)),\n+\t  std::apply([&__a](auto&&... __args2) {\n+\t      return std::uses_allocator_construction_args<_Tp2>(\n+\t\t  __a, std::forward<decltype(__args2)>(__args2)...);\n+\t  }, std::forward<_Tuple2>(__y)));\n+    }\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a));\n+    }\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)\n+      noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a,\n+\t    std::forward<_Up>(__u)),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a,\n+\t    std::forward<_Vp>(__v)));\n+    }\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     const pair<_Up, _Vp>& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));\n+    }\n+\n+  template<_GLIBCXX_STD_PAIR_CONSTRAINT_(_Tp), typename _Alloc,\n+\t   typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     pair<_Up, _Vp>&& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a,\n+\t    std::move(__pr).first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a,\n+\t    std::move(__pr).second));\n+    }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline _Tp\n+    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)\n+    {\n+      return std::make_from_tuple<_Tp>(uses_allocator_construction_args<_Tp>(\n+\t    __a, std::forward<_Args>(__args)...));\n+    }\n+\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline _Tp*\n+    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,\n+\t\t\t\t\t    _Args&&... __args)\n+    {\n+      void* __vp = const_cast<void*>(static_cast<const volatile void*>(__p));\n+      return ::new(__vp) _Tp(std::make_obj_using_allocator<_Tp>(__a,\n+\t    std::forward<_Args>(__args)...));\n+    }\n+\n+#endif // C++2a\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n #endif // C++11"}, {"sha": "a212bccc9b18347951f63c7062c3864e95580067", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=987bbe48bb03e04810e6c97f292549f11b5b2126", "patch": "@@ -170,6 +170,7 @@ namespace pmr\n       __attribute__((__nonnull__))\n       { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }\n \n+#if __cplusplus <= 201703L\n       template<typename _Tp1, typename... _Args>\n \t__attribute__((__nonnull__))\n \ttypename __not_pair<_Tp1>::type\n@@ -242,6 +243,16 @@ namespace pmr\n \t\t\t  forward_as_tuple(std::forward<_Up>(__pr.first)),\n \t\t\t  forward_as_tuple(std::forward<_Vp>(__pr.second)));\n \t}\n+#else\n+      template<typename _Tp1, typename... _Args>\n+\t__attribute__((__nonnull__))\n+\tvoid\n+\tconstruct(_Tp1* __p, _Args&&... __args)\n+\t{\n+\t  std::uninitialized_construct_using_allocator(__p, *this,\n+\t      std::forward<_Args>(__args)...);\n+\t}\n+#endif\n \n       template<typename _Up>\n \t__attribute__((__nonnull__))"}, {"sha": "9048ca196ffeada79ef911cc86d71efc63818623", "filename": "libstdc++-v3/testsuite/20_util/polymorphic_allocator/construct_c++2a.cc", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fconstruct_c%2B%2B2a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fconstruct_c%2B%2B2a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpolymorphic_allocator%2Fconstruct_c%2B%2B2a.cc?ref=987bbe48bb03e04810e6c97f292549f11b5b2126", "patch": "@@ -0,0 +1,125 @@\n+// Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <memory_resource>\n+#include <utility>\n+#include <tuple>\n+\n+struct do_not_copy {\n+  do_not_copy() = default;\n+  do_not_copy(const do_not_copy&) { throw 1; }\n+};\n+\n+void\n+test01()\n+{\n+  struct X {\n+    X(do_not_copy&&) { }\n+  };\n+\n+  using pair = std::pair<X, int>;\n+  std::pmr::polymorphic_allocator<pair> a;\n+  auto ptr = a.allocate(1);\n+  a.construct(ptr, std::piecewise_construct,\n+      std::tuple<do_not_copy>{}, std::make_tuple(1));\n+  a.deallocate(ptr, 1);\n+}\n+\n+void\n+test02()\n+{\n+  struct X {\n+    using allocator_type = std::pmr::polymorphic_allocator<int>;\n+    X(do_not_copy&&, const allocator_type&) { }\n+  };\n+\n+  using pair = std::pair<X, int>;\n+  std::pmr::polymorphic_allocator<pair> a;\n+  auto ptr = a.allocate(1);\n+  a.construct(ptr, std::piecewise_construct,\n+      std::tuple<do_not_copy>{}, std::make_tuple(1));\n+  a.deallocate(ptr, 1);\n+}\n+\n+void\n+test03()\n+{\n+  struct X {\n+    using allocator_type = std::pmr::polymorphic_allocator<int>;\n+    X(std::allocator_arg_t, const allocator_type&, do_not_copy&&) { }\n+  };\n+\n+  using pair = std::pair<X, int>;\n+  std::pmr::polymorphic_allocator<pair> a;\n+  auto ptr = a.allocate(1);\n+  a.construct(ptr, std::piecewise_construct,\n+      std::tuple<do_not_copy>{}, std::make_tuple(1));\n+  a.deallocate(ptr, 1);\n+}\n+\n+void\n+test04()\n+{\n+  struct X\n+  {\n+    using allocator_type = std::pmr::polymorphic_allocator<int>;\n+    X() = default;\n+    X(const X&) { throw 1; }\n+    X(const X&, const allocator_type&) { }\n+  };\n+\n+  struct Y\n+  {\n+    using allocator_type = std::pmr::polymorphic_allocator<int>;\n+    Y() = default;\n+    Y(const Y&) = delete;\n+    Y(std::allocator_arg_t, const allocator_type&, const Y&) { }\n+  };\n+\n+  using pair_type = std::pair<X, Y>;\n+  std::pmr::polymorphic_allocator<pair_type> a;\n+  auto ptr = a.allocate(1);\n+  /* not const */ pair_type p;\n+  a.construct(ptr, p); // LWG 2975\n+  a.deallocate(ptr, 1);\n+}\n+\n+void\n+test05()\n+{\n+  struct X {\n+    using allocator_type = std::pmr::polymorphic_allocator<char>;\n+    X(int);\n+    X(int, const allocator_type&) { }\n+  };\n+  std::pmr::polymorphic_allocator<X> a;\n+  auto ptr = a.allocate(1);\n+  a.construct(ptr, 1);\n+  a.deallocate(ptr, 1);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "670c59afb332dc0e9a2332202ffda6bc7d6a4d2b", "filename": "libstdc++-v3/testsuite/20_util/uses_allocator/make_obj.cc", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fmake_obj.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987bbe48bb03e04810e6c97f292549f11b5b2126/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fmake_obj.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fuses_allocator%2Fmake_obj.cc?ref=987bbe48bb03e04810e6c97f292549f11b5b2126", "patch": "@@ -0,0 +1,403 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using test_allocator = __gnu_test::uneq_allocator<int>;\n+\n+struct Arg { };\n+\n+struct A\n+{\n+  A() : nargs(0) { }\n+  A(float&) : nargs(1) { }\n+  A(int, void*) : nargs(2) { }\n+\n+  // These should not be used:\n+  A(const test_allocator& a);\n+  A(float&, const test_allocator& a);\n+  A(int, void*, const test_allocator& a);\n+\n+  const int nargs;\n+  const int alloc_id = -1;\n+\n+  // std::uses_allocator<A, test_allocator> should be false:\n+  using allocator_type = void*();\n+};\n+\n+struct B\n+{\n+  // This means std::uses_allocator<B, test_allocator> is true:\n+  using allocator_type = test_allocator;\n+\n+  B() : nargs(0) { }\n+  B(float&) : nargs(1) { }\n+  B(int, void*) : nargs(2) { }\n+\n+  B(std::allocator_arg_t, const test_allocator& a)\n+  : nargs(0), alloc_id(a.get_personality()) { }\n+  B(std::allocator_arg_t, const test_allocator& a, float&)\n+  : nargs(1), alloc_id(a.get_personality()) { }\n+  B(std::allocator_arg_t, const test_allocator& a, int, void*)\n+  : nargs(2), alloc_id(a.get_personality()) { }\n+  B(std::allocator_arg_t, const test_allocator& a, B&& b)\n+  : nargs(b.nargs), alloc_id(a.get_personality()) { }\n+\n+  // These should not be used:\n+  B(const test_allocator&);\n+  B(float&, const test_allocator&, float&);\n+  B(int, void*, const test_allocator&);\n+  B(const test_allocator&, float&);\n+  B(const test_allocator&, int, void*);\n+  B(B&&);\n+  B(B&&, const test_allocator&);\n+\n+  const int nargs;\n+  const int alloc_id = -1;\n+};\n+\n+struct C\n+{\n+  C() : nargs(0) { }\n+  C(float&) : nargs(1) { }\n+  C(int, void*) : nargs(2) { }\n+\n+  C(const test_allocator& a)\n+  : nargs(0), alloc_id(a.get_personality()) { }\n+  C(float&, const test_allocator& a)\n+  : nargs(1), alloc_id(a.get_personality()) { }\n+  C(int, void*, const test_allocator& a)\n+  : nargs(2), alloc_id(a.get_personality()) { }\n+  C(C&& c, const test_allocator& a)\n+  : nargs(c.nargs), alloc_id(a.get_personality()) { }\n+\n+  C(C&&);\n+\n+  const int nargs;\n+  const int alloc_id = -1;\n+};\n+\n+namespace std {\n+  // This means std::uses_allocator<C, test_allocator> is true:\n+  template<> struct uses_allocator<C, test_allocator> : std::true_type { };\n+}\n+\n+test_allocator alloc1(1);\n+test_allocator alloc2(2);\n+\n+void\n+test01()\n+{\n+  auto i0 = std::make_obj_using_allocator<int>(alloc1, 2);\n+  VERIFY( i0 == 2 );\n+\n+  float f = 0.0f;\n+\n+  auto a0 = std::make_obj_using_allocator<A>(alloc1);\n+  VERIFY( a0.nargs == 0 );\n+  VERIFY( a0.alloc_id == -1 );\n+  auto a1 = std::make_obj_using_allocator<A>(alloc1, f);\n+  VERIFY( a1.nargs == 1 );\n+  VERIFY( a1.alloc_id == -1 );\n+  auto a2 = std::make_obj_using_allocator<A>(alloc1, 123, nullptr);\n+  VERIFY( a2.nargs == 2 );\n+  VERIFY( a2.alloc_id == -1 );\n+\n+  auto b0 = std::make_obj_using_allocator<B>(alloc1);\n+  VERIFY( b0.nargs == 0 );\n+  VERIFY( b0.alloc_id == 1 );\n+  auto b1 = std::make_obj_using_allocator<B>(alloc2, f);\n+  VERIFY( b1.nargs == 1 );\n+  VERIFY( b1.alloc_id == 2 );\n+  auto b2 = std::make_obj_using_allocator<B>(alloc1, 123, nullptr);\n+  VERIFY( b2.nargs == 2 );\n+  VERIFY( b2.alloc_id == 1 );\n+\n+  auto c0 = std::make_obj_using_allocator<C>(alloc1);\n+  VERIFY( c0.nargs == 0 );\n+  VERIFY( c0.alloc_id == 1 );\n+  auto c1 = std::make_obj_using_allocator<C>(alloc2, f);\n+  VERIFY( c1.nargs == 1 );\n+  VERIFY( c1.alloc_id == 2 );\n+  auto c2 = std::make_obj_using_allocator<C>(alloc1, 123, nullptr);\n+  VERIFY( c2.nargs == 2 );\n+  VERIFY( c2.alloc_id == 1 );\n+}\n+\n+void \n+test02()\n+{\n+  decltype(auto) b\n+    = std::make_obj_using_allocator<const B>(alloc1, 123, nullptr);\n+  static_assert( std::is_const_v<decltype(b)> );\n+  VERIFY( b.nargs == 2 );\n+  VERIFY( b.alloc_id == 1 );\n+\n+  decltype(auto) c = std::make_obj_using_allocator<const C>(alloc1);\n+  static_assert( std::is_const_v<decltype(c)> );\n+  VERIFY( c.nargs == 0 );\n+  VERIFY( c.alloc_id == 1 );\n+}\n+\n+void\n+test03()\n+{\n+  B b;\n+  decltype(auto) ref = std::make_obj_using_allocator<B&>(alloc1, b);\n+  static_assert( std::is_same_v<decltype(ref), B&> );\n+  VERIFY( &ref == &b );\n+  VERIFY( ref.nargs == 0 );\n+  VERIFY( ref.alloc_id == -1 );\n+  const B& cref = std::make_obj_using_allocator<const B&>(alloc1, b);\n+  static_assert( std::is_same_v<decltype(cref), const B&> );\n+  VERIFY( &cref == &b );\n+  VERIFY( cref.nargs == 0 );\n+  VERIFY( cref.alloc_id == -1 );\n+}\n+\n+void\n+test04()\n+{\n+  struct D\n+  {\n+    D(std::allocator_arg_t) { }\n+    D(std::allocator_arg_t, int) { }\n+\n+    // These should not be used:\n+    D(std::allocator_arg_t, const test_allocator&);\n+    D(std::allocator_arg_t, const test_allocator&, int);\n+\n+    ~D() { }\n+  };\n+\n+  D d1 = std::make_obj_using_allocator<D>(alloc1, std::allocator_arg);\n+\n+  struct E\n+  {\n+    using allocator_type = test_allocator;\n+\n+    E(std::allocator_arg_t, const test_allocator&) { }\n+    E(std::allocator_arg_t, int, const test_allocator&) { }\n+\n+    // These should not be used:\n+    E(std::allocator_arg_t);\n+    E(std::allocator_arg_t, int);\n+\n+    ~E() { }\n+  };\n+\n+  E e1 = std::make_obj_using_allocator<E>(alloc1, std::allocator_arg);\n+  E e2 = std::make_obj_using_allocator<E>(alloc2, std::allocator_arg, 2);\n+}\n+\n+void\n+test05()\n+{\n+  using std::pair;\n+  std::piecewise_construct_t p;\n+  std::tuple<> t0;\n+  float f = 0.0f;\n+  std::tuple<float&> t1(f);\n+  std::tuple<int, void*> t2{};\n+\n+  auto aa00 = std::make_obj_using_allocator<pair<A, A>>(alloc1, p, t0, t0);\n+  VERIFY( aa00.first.nargs == 0 );\n+  VERIFY( aa00.first.alloc_id == -1 );\n+  VERIFY( aa00.second.nargs == 0 );\n+  VERIFY( aa00.second.alloc_id == -1 );\n+  auto ab00 = std::make_obj_using_allocator<pair<A, B>>(alloc1, p, t0, t0);\n+  VERIFY( ab00.first.nargs == 0 );\n+  VERIFY( ab00.first.alloc_id == -1 );\n+  VERIFY( ab00.second.nargs == 0 );\n+  VERIFY( ab00.second.alloc_id == 1 );\n+  auto bc00 = std::make_obj_using_allocator<pair<B, C>>(alloc2, p, t0, t0);\n+  VERIFY( bc00.first.nargs == 0 );\n+  VERIFY( bc00.first.alloc_id == 2 );\n+  VERIFY( bc00.second.nargs == 0 );\n+  VERIFY( bc00.second.alloc_id == 2 );\n+  auto cb00 = std::make_obj_using_allocator<pair<C, B>>(alloc2, p, t0, t0);\n+  VERIFY( cb00.first.nargs == 0 );\n+  VERIFY( cb00.first.alloc_id == 2 );\n+  VERIFY( cb00.second.nargs == 0 );\n+  VERIFY( cb00.second.alloc_id == 2 );\n+  auto cc00\n+    = std::make_obj_using_allocator<pair<C, const C>>(alloc1, p, t0, t0);\n+  VERIFY( cc00.first.nargs == 0 );\n+  VERIFY( cc00.first.alloc_id == 1 );\n+  VERIFY( cc00.second.nargs == 0 );\n+  VERIFY( cc00.second.alloc_id == 1 );\n+\n+  auto aa21 = std::make_obj_using_allocator<pair<A, A>>(alloc1, p, t2, t1);\n+  VERIFY( aa21.first.nargs == 2 );\n+  VERIFY( aa21.first.alloc_id == -1 );\n+  VERIFY( aa21.second.nargs == 1 );\n+  VERIFY( aa21.second.alloc_id == -1 );\n+  auto ab21 = std::make_obj_using_allocator<pair<A, B>>(alloc1, p, t2, t1);\n+  VERIFY( ab21.first.nargs == 2 );\n+  VERIFY( ab21.first.alloc_id == -1 );\n+  VERIFY( ab21.second.nargs == 1 );\n+  VERIFY( ab21.second.alloc_id == 1 );\n+  auto bc11 = std::make_obj_using_allocator<pair<B, C>>(alloc2, p, t1, t1);\n+  VERIFY( bc11.first.nargs == 1 );\n+  VERIFY( bc11.first.alloc_id == 2 );\n+  VERIFY( bc11.second.nargs == 1 );\n+  VERIFY( bc11.second.alloc_id == 2 );\n+  auto cb12 = std::make_obj_using_allocator<pair<C, B>>(alloc2, p, t1, t2);\n+  VERIFY( cb12.first.nargs == 1 );\n+  VERIFY( cb12.first.alloc_id == 2 );\n+  VERIFY( cb12.second.nargs == 2 );\n+  VERIFY( cb12.second.alloc_id == 2 );\n+  auto cc22\n+    = std::make_obj_using_allocator<pair<C, const C>>(alloc1, p, t2, t1);\n+  VERIFY( cc22.first.nargs == 2 );\n+  VERIFY( cc22.first.alloc_id == 1 );\n+  VERIFY( cc22.second.nargs == 1 );\n+  VERIFY( cc22.second.alloc_id == 1 );\n+}\n+\n+void\n+test06()\n+{\n+  using std::pair;\n+  float f = 0.0f;\n+\n+  auto aa00 = std::make_obj_using_allocator<pair<A, A>>(alloc1);\n+  VERIFY( aa00.first.nargs == 0 );\n+  VERIFY( aa00.first.alloc_id == -1 );\n+  VERIFY( aa00.second.nargs == 0 );\n+  VERIFY( aa00.second.alloc_id == -1 );\n+  auto ab00 = std::make_obj_using_allocator<pair<A, B>>(alloc1);\n+  VERIFY( ab00.first.nargs == 0 );\n+  VERIFY( ab00.first.alloc_id == -1 );\n+  VERIFY( ab00.second.nargs == 0 );\n+  VERIFY( ab00.second.alloc_id == 1 );\n+  auto bc00 = std::make_obj_using_allocator<pair<B, C>>(alloc2);\n+  VERIFY( bc00.first.nargs == 0 );\n+  VERIFY( bc00.first.alloc_id == 2 );\n+  VERIFY( bc00.second.nargs == 0 );\n+  VERIFY( bc00.second.alloc_id == 2 );\n+  auto cb00 = std::make_obj_using_allocator<pair<C, B>>(alloc2);\n+  VERIFY( cb00.first.nargs == 0 );\n+  VERIFY( cb00.first.alloc_id == 2 );\n+  VERIFY( cb00.second.nargs == 0 );\n+  VERIFY( cb00.second.alloc_id == 2 );\n+  auto cc00 = std::make_obj_using_allocator<pair<C, const C>>(alloc1);\n+  VERIFY( cc00.first.nargs == 0 );\n+  VERIFY( cc00.first.alloc_id == 1 );\n+  VERIFY( cc00.second.nargs == 0 );\n+  VERIFY( cc00.second.alloc_id == 1 );\n+\n+  auto aa11 = std::make_obj_using_allocator<pair<A, A>>(alloc1, f, f);\n+  VERIFY( aa11.first.nargs == 1 );\n+  VERIFY( aa11.first.alloc_id == -1 );\n+  VERIFY( aa11.second.nargs == 1 );\n+  VERIFY( aa11.second.alloc_id == -1 );\n+  auto aba1 = std::make_obj_using_allocator<pair<A, B>>(alloc1, A{}, f);\n+  VERIFY( aba1.first.nargs == 0 );\n+  VERIFY( aba1.first.alloc_id == -1 );\n+  VERIFY( aba1.second.nargs == 1 );\n+  VERIFY( aba1.second.alloc_id == 1 );\n+  auto bc11 = std::make_obj_using_allocator<pair<B, C>>(alloc2, f, f);\n+  VERIFY( bc11.first.nargs == 1 );\n+  VERIFY( bc11.first.alloc_id == 2 );\n+  VERIFY( bc11.second.nargs == 1 );\n+  VERIFY( bc11.second.alloc_id == 2 );\n+  auto cb1b = std::make_obj_using_allocator<pair<C, B>>(alloc2, f, B{});\n+  VERIFY( cb1b.first.nargs == 1 );\n+  VERIFY( cb1b.first.alloc_id == 2 );\n+  VERIFY( cb1b.second.nargs == 0 );\n+  VERIFY( cb1b.second.alloc_id == 2 );\n+  auto cccc\n+    = std::make_obj_using_allocator<pair<C, const C>>(alloc1, C{}, C{});\n+  VERIFY( cccc.first.nargs == 0 );\n+  VERIFY( cccc.first.alloc_id == 1 );\n+  VERIFY( cccc.second.nargs == 0 );\n+  VERIFY( cccc.second.alloc_id == 1 );\n+\n+  pair<float&, A> p1a(f, A{});\n+  pair<float&, float&> p11(f, f);\n+  auto aa1a = std::make_obj_using_allocator<pair<A, A>>(alloc1, p1a);\n+  VERIFY( aa1a.first.nargs == 1 );\n+  VERIFY( aa1a.first.alloc_id == -1 );\n+  VERIFY( aa1a.second.nargs == 0 );\n+  VERIFY( aa1a.second.alloc_id == -1 );\n+  auto ab11 = std::make_obj_using_allocator<pair<A, B>>(alloc1, p11);\n+  VERIFY( ab11.first.nargs == 1 );\n+  VERIFY( ab11.first.alloc_id == -1 );\n+  VERIFY( ab11.second.nargs == 1 );\n+  VERIFY( ab11.second.alloc_id == 1 );\n+  auto cb11 = std::make_obj_using_allocator<pair<C, B>>(alloc2, p11);\n+  VERIFY( cb11.first.nargs == 1 );\n+  VERIFY( cb11.first.alloc_id == 2 );\n+  VERIFY( cb11.second.nargs == 1 );\n+  VERIFY( cb11.second.alloc_id == 2 );\n+\n+  auto bcbc = std::make_obj_using_allocator<pair<B, C>>(alloc2, pair<B, C>());\n+  VERIFY( bcbc.first.nargs == 0 );\n+  VERIFY( bcbc.first.alloc_id == 2 );\n+  VERIFY( bcbc.second.nargs == 0 );\n+  VERIFY( bcbc.second.alloc_id == 2 );\n+\n+  auto cc11 = std::make_obj_using_allocator<pair<C, B>>(alloc2, std::move(p11));\n+  VERIFY( cc11.first.nargs == 1 );\n+  VERIFY( cc11.first.alloc_id == 2 );\n+  VERIFY( cc11.second.nargs == 1 );\n+  VERIFY( cc11.second.alloc_id == 2 );\n+}\n+\n+void\n+test07()\n+{\n+  using nested_pair = std::pair<const std::pair<B, const B>, C>;\n+  auto p = std::make_obj_using_allocator<const nested_pair>(alloc1);\n+  VERIFY( p.first.first.alloc_id == 1 );\n+  VERIFY( p.first.second.alloc_id == 1 );\n+  VERIFY( p.second.alloc_id == 1 );\n+}\n+\n+void\n+test08()\n+{\n+  // LWG DR 3187.\n+  // P0591R4 reverted DR 2586 fixes to scoped_allocator_adaptor::construct()\n+\n+  struct X {\n+    using allocator_type = std::allocator<X>;\n+    X(std::allocator_arg_t, allocator_type&&) { }\n+    X(const allocator_type&) { }\n+  };\n+\n+  std::allocator<X> a;\n+  std::make_obj_using_allocator<X>(a);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+}"}]}