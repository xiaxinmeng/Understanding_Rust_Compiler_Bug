{"sha": "a269a03c80a4920f09cf0c065a636f6cedf92490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI2OWEwM2M4MGE0OTIwZjA5Y2YwYzA2NWE2MzZmNmNlZGY5MjQ5MA==", "commit": {"author": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-09-06T05:52:08Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-09-06T05:52:08Z"}, "message": "final.c (final): If a label is reached only from a single jump...\n\n(\n\t* final.c (final): If a label is reached only from a single jump,\n\tcall NOTICE_UPDATE_CC on the jump and its predecessor before\n\temitting the insn after the label.\n\t* i386.h: Add AMD K6 support.\n\tChange TARGET_* macros to use table lookup.\n\t(INITIALIZE_TRAMPOLINE): Improve trampoline code.\n\t(ADJUST_COST): Change definition to call function in i386.c.\n\t(ISSUE_RATE): Define as 2 for anything newer than an 80486.\n\t* i386.c: Add AMD K6 support.\n\tAdd constants for feature tests used by TARGET_* macros.\n\t(split_di): If before reload, call gen_lowpart and gen_highpart.\n\t(x86_adjust_cost): New function.\n\t(put_jump_code): New function.\n\t(print_operand): New codes 'D' and 'd'.\n\t* i386.md: New insn types.  New insn attribute \"memory\".\n\tRedefine scheduling parameters to use new types and add AMD K6\n\tsupport.  Explicitly set type of most insns.\n\t(move insns): K6 prefers movl $0,reg to xorl reg,reg.  Pentium\n\tPro and K6 prefer movl $1,reg to incl reg.\n\t(adddi3, subdi3): Set cc_status.\n\t(DImode shift patterns): Change label counters from HOST_WIDE_INT\n\tto int; x86 can't have more than 2^31 DImode shifts per\tfile.\n\t(setcc): Combine all setcc patterns.  Allow writing memory.\n\tCombine all jump patterns using match_operator.\n\t(*bzero): Name pattern.  Emit mutliple stos instructions when that\n\tis faster than rep stos.\n\t(xordi3, anddi3, iordi3): Simplify DImode logical patterns and\n\tadd define_split.\n\t* ch/Make-lang.in: Comment ^L characters.  Sun make doesn't like them.\n\nFrom-SVN: r22292", "tree": {"sha": "c62f6e2a1d92a133be181e52cf0f6be0b8b402b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c62f6e2a1d92a133be181e52cf0f6be0b8b402b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a269a03c80a4920f09cf0c065a636f6cedf92490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a269a03c80a4920f09cf0c065a636f6cedf92490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a269a03c80a4920f09cf0c065a636f6cedf92490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a269a03c80a4920f09cf0c065a636f6cedf92490/comments", "author": null, "committer": null, "parents": [{"sha": "f429f2c549af467352419e0468efe172f014c289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f429f2c549af467352419e0468efe172f014c289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f429f2c549af467352419e0468efe172f014c289"}], "stats": {"total": 1474, "additions": 748, "deletions": 726}, "files": [{"sha": "2194741a4f02d91b6f3de4e7c970755f01c14499", "filename": "gcc/ch/Make-lang.in", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fch%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fch%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMake-lang.in?ref=a269a03c80a4920f09cf0c065a636f6cedf92490", "patch": "@@ -34,7 +34,7 @@\n # - making any compiler driver (eg: g++)\n # - the compiler proper (eg: cc1plus)\n # - define the names for selecting the language in LANGUAGES.\n-\f\n+#\f\n # define version of GNUCHILL compiler. Note: maybe we have to change the\n # mechanism\n GNUCHILL_VERSION = 1.5.2\n@@ -62,7 +62,7 @@ CHILL_FLAGS_TO_PASS = \\\n \t\"CHILL_LIB=$(CHILL_LIB)\" \\\n \t\"CC=$(CC)\" \\\n \t\"GNUCHILL_VERSION=$(GNUCHILL_VERSION)\"\n-\f\n+#\f\n # Define the names for selecting languages in LANGUAGES.\n CHILL: chill cc1chill chill-runtime\n \n@@ -105,7 +105,7 @@ chill-runtime: stmp-headers $(GCC_PASSES)\n \t\t   cd ch/runtime; $(MAKE) $(FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) GCC_FOR_TARGET=\"$${thisdir1}/xgcc -B$${thisdir1}/\" all ; \\\n \t\t else true; fi ;; \\\n \tesac\n-\f\n+#\f\n # Build hooks:\n \n CHILL.all.build: chill\n@@ -123,7 +123,7 @@ chill.dvi: $(srcdir)/ch/chill.texi $(srcdir)/extend.texi $(srcdir)/invoke.texi $\n \tTEXINPUTS=${texidir}:$(srcdir):$$TEXINPUTS tex chill.texi\n # FIXME: Not sure languages should do this.\n \tcp ch/chill.dvi chill.dvi\n-\f\n+#\f\n # Install hooks:\n # cc1chill is installed elsewhere as part of $(COMPILERS).\n \n@@ -166,7 +166,7 @@ CHILL.install-man:\n CHILL.uninstall:\n \t-rm -rf $(bindir)/$(CHILL_INSTALL_NAME)\n \t-rm -rf $(bindir)/$(CHILL_CROSS_NAME)\n-\f\n+#\f\n # Clean hooks:\n # A lot of the ancillary files are deleted by the main makefile.\n # We just have to delete files specific to us.\n@@ -183,7 +183,7 @@ CHILL.maintainer-clean:\n \t-rm -f ch/chill.info* ch/chill.dvi ch/chill.??s ch/chill.*aux\n # CYGNUS LOCAL: Delete locally created file.\n \t-rm -f ch/hash.h\n-\f\n+#\f\n # Stage hooks:\n # The main makefile has already created stage?/ch.\n \n@@ -195,7 +195,7 @@ CHILL.stage3:\n \t-mv ch/*.o stage3/ch\n CHILL.stage4:\n \t-mv ch/*.o stage4/ch\n-\f\n+#\f\n # Maintenance hooks:\n \n # This target creates the files that can be rebuilt, but go in the"}, {"sha": "fc8edbd64d1e85a5199ae431d269e84b9f06d07a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 224, "deletions": 6, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a269a03c80a4920f09cf0c065a636f6cedf92490", "patch": "@@ -100,8 +100,37 @@ struct processor_costs pentiumpro_cost = {\n   17\t\t\t\t\t/* cost of a divide/mod */\n };\n \n+struct processor_costs k6_cost = {\n+  1,\t\t\t\t\t/* cost of an add instruction */\n+  1,\t\t\t\t\t/* cost of a lea instruction */\n+  1,\t\t\t\t\t/* variable shift costs */\n+  1,\t\t\t\t\t/* constant shift costs */\n+  2,\t\t\t\t\t/* cost of starting a multiply */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  18\t\t\t\t\t/* cost of a divide/mod */\n+};\n+\n struct processor_costs *ix86_cost = &pentium_cost;\n \n+/* Processor feature/optimization bitmasks.  */\n+#define m_386 (1<<PROCESSOR_I386)\n+#define m_486 (1<<PROCESSOR_I486)\n+#define m_PENT (1<<PROCESSOR_PENTIUM)\n+#define m_PPRO (1<<PROCESSOR_PENTIUMPRO)\n+#define m_K6  (1<<PROCESSOR_K6)\n+\n+const int x86_use_leave = m_386 | m_K6;\n+const int x86_push_memory = m_386 | m_K6;\n+const int x86_zero_extend_with_and = m_486 | m_PENT;\n+const int x86_movx = m_386 | m_PPRO | m_K6;\n+const int x86_double_with_add = ~m_386;\n+const int x86_use_bit_test = m_386;\n+const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO;\n+const int x86_use_q_reg = m_PENT | m_PPRO | m_K6;\n+const int x86_use_any_reg = m_486;\n+const int x86_cmove = m_PPRO;\n+const int x86_deep_branch = m_PPRO| m_K6;\n+\n #define AT_BP(mode) (gen_rtx_MEM ((mode), frame_pointer_rtx))\n \n extern FILE *asm_out_file;\n@@ -213,7 +242,8 @@ override_options ()\n \t   {PROCESSOR_I686_STRING, PROCESSOR_PENTIUMPRO, &pentiumpro_cost,\n \t      0, 0},\n \t   {PROCESSOR_PENTIUMPRO_STRING, PROCESSOR_PENTIUMPRO,\n-\t      &pentiumpro_cost, 0, 0}};\n+\t      &pentiumpro_cost, 0, 0},\n+      \t   {PROCESSOR_K6_STRING, PROCESSOR_K6, &k6_cost, 0, 0}};\n \n   int ptt_size = sizeof (processor_target_table) / sizeof (struct ptt);\n \n@@ -279,7 +309,7 @@ override_options ()\n       {\n \tix86_cpu = processor_target_table[j].processor;\n \tix86_cost = processor_target_table[j].cost;\n-\tif (i > j && (int) ix86_arch >= (int) PROCESSOR_PENTIUMPRO)\n+\tif (i > j && (int) ix86_arch >= (int) PROCESSOR_K6)\n \t  error (\"-mcpu=%s does not support -march=%s\",\n \t\t ix86_cpu_string, ix86_arch_string);\n \n@@ -1586,6 +1616,7 @@ standard_80387_constant_p (x)\n   /* Note that on the 80387, other constants, such as pi,\n      are much slower to load as standard constants\n      than to load from doubles in memory!  */\n+  /* ??? Not true on K6: all constants are equal cost.  */\n #endif\n \n   return 0;\n@@ -2933,8 +2964,8 @@ legitimize_address (x, oldx, mode)\n       && (log = (unsigned)exact_log2 (INTVAL (XEXP (x, 1)))) < 4)\n     {\n       changed = 1;\n-      x = gen_rtx (MULT, Pmode, force_reg (Pmode, XEXP (x, 0)),\n-\t\t   GEN_INT (1 << log));\n+      x = gen_rtx_MULT (Pmode, force_reg (Pmode, XEXP (x, 0)),\n+\t\t\tGEN_INT (1 << log));\n     }\n \n   if (GET_CODE (x) == PLUS)\n@@ -3185,6 +3216,114 @@ output_pic_addr_const (file, x, code)\n     }\n }\n \f\n+static void\n+put_jump_code (code, reverse, file)\n+     enum rtx_code code;\n+     int reverse;\n+     FILE *file;\n+{\n+  int flags = cc_prev_status.flags;\n+  int ieee = (TARGET_IEEE_FP && (flags & CC_IN_80387));\n+  const char *suffix;\n+\n+  if (flags & CC_Z_IN_NOT_C)\n+    switch (code)\n+      {\n+      case EQ:\n+\tfputs (reverse ? \"c\" : \"nc\", file);\n+\treturn;\n+\n+      case NE:\n+\tfputs (reverse ? \"nc\" : \"c\", file);\n+\treturn;\n+\n+      default:\n+\tabort ();\n+      }\n+  if (ieee)\n+    {\n+      switch (code)\n+\t{\n+\tcase LE:\n+\t  suffix = reverse ? \"ae\" : \"b\";\n+\t  break;\n+\tcase GT:\n+\tcase LT:\n+\tcase GE:\n+\t  suffix = reverse ? \"ne\" : \"e\";\n+\t  break;\n+\tcase EQ:\n+\t  suffix = reverse ? \"ne\" : \"e\";\n+\t  break;\n+\tcase NE:\n+\t  suffix = reverse ? \"e\" : \"ne\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      fputs (suffix, file);\n+      return;\n+    }\n+  if (flags & CC_TEST_AX)\n+    abort();\n+  if ((flags & CC_NO_OVERFLOW) && (code == LE || code == GT))\n+    abort ();\n+  if (reverse)\n+    code = reverse_condition (code);\n+  switch (code)\n+    {\n+    case EQ:\n+      suffix = \"e\";\n+      break;\n+\n+    case NE:\n+      suffix = \"ne\";\n+      break;\n+\n+    case GT:\n+      suffix = flags & CC_IN_80387 ? \"a\" : \"g\";\n+      break;\n+\n+    case GTU:\n+      suffix = \"a\";\n+      break;\n+\n+    case LT:\n+      if (flags & CC_NO_OVERFLOW)\n+\tsuffix = \"s\";\n+      else\n+\tsuffix = flags & CC_IN_80387 ? \"b\" : \"l\";\n+      break;\n+\n+    case LTU:\n+      suffix = \"b\";\n+      break;\n+\n+    case GE:\n+      if (flags & CC_NO_OVERFLOW)\n+\tsuffix = \"ns\";\n+      else\n+\tsuffix = flags & CC_IN_80387 ? \"ae\" : \"ge\";\n+      break;\n+\n+    case GEU:\n+      suffix = \"ae\";\n+      break;\n+\n+    case LE:\n+      suffix = flags & CC_IN_80387 ? \"be\" : \"le\";\n+      break;\n+\n+    case LEU:\n+      suffix = \"be\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+  fputs (suffix, file);\n+}\n+\n /* Append the correct conditional move suffix which corresponds to CODE.  */\n \n static void\n@@ -3301,7 +3440,9 @@ put_condition_code (code, reverse_cc, mode, file)\n    C -- print opcode suffix for set/cmov insn.\n    c -- like C, but print reversed condition\n    F -- print opcode suffix for fcmov insn.\n-   f -- like C, but print reversed condition\n+   f -- like F, but print reversed condition\n+   D -- print the opcode suffix for a jump\n+   d -- like D, but print reversed condition\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    * -- print a star (in certain assembler syntax)\n@@ -3443,6 +3584,14 @@ print_operand (file, x, code)\n \n \t  return;\n \n+\tcase 'D':\n+\t  put_jump_code (GET_CODE (x), 0, file);\n+\t  return;\n+\n+\tcase 'd':\n+\t  put_jump_code (GET_CODE (x), 1, file);\n+\t  return;\n+\n \t  /* This is used by the conditional move instructions.  */\n \tcase 'C':\n \t  put_condition_code (GET_CODE (x), 0, MODE_INT, file);\n@@ -3851,7 +4000,12 @@ split_di (operands, num, lo_half, hi_half)\n   while (num--)\n     {\n       rtx op = operands[num];\n-      if (GET_CODE (op) == REG)\n+      if (! reload_completed)\n+\t{\n+\t  lo_half[num] = gen_lowpart (SImode, op);\n+\t  hi_half[num] = gen_highpart (SImode, op);\n+\t}\n+      else if (GET_CODE (op) == REG)\n \t{\n \t  lo_half[num] = gen_rtx_REG (SImode, REGNO (op));\n \t  hi_half[num] = gen_rtx_REG (SImode, REGNO (op) + 1);\n@@ -5360,3 +5514,67 @@ output_int_conditional_move (which_alternative, operands)\n \n   return \"\";\n }\n+\n+int\n+x86_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn, link, dep_insn;\n+     int cost;\n+{\n+  rtx next_inst;\n+\n+  if (GET_CODE (dep_insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n+    return 0;\n+\n+  if (GET_CODE (dep_insn) == INSN\n+      && GET_CODE (PATTERN (dep_insn)) == SET\n+      && GET_CODE (SET_DEST (PATTERN (dep_insn))) == REG\n+      && GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET\n+      && !reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\n+\t\t\t\t   SET_SRC (PATTERN (insn))))\n+    return 0;\t/* ??? */\n+\n+\n+  switch (ix86_cpu)\n+    {\n+    case PROCESSOR_PENTIUM:\n+      if (cost != 0 && is_fp_insn (insn) && is_fp_insn (dep_insn)\n+\t  && !is_fp_dest (dep_insn))\n+\treturn 0;\n+\n+      if (agi_dependent (insn, dep_insn))\n+\treturn 3;\n+\n+      if (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && SET_DEST (PATTERN (insn)) == cc0_rtx\n+\t  && (next_inst = next_nonnote_insn (insn))\n+\t  && GET_CODE (next_inst) == JUMP_INSN)\n+\t/* compare probably paired with jump */\n+\treturn 0;\n+      break;\n+\n+    case PROCESSOR_K6:\n+    default:\n+      if (!is_fp_dest (dep_insn))\n+\t{\n+\t  if(!agi_dependent (insn, dep_insn))\n+\t    return 0;\n+\t  if (TARGET_486)\n+\t    return 2;\n+\t}\n+      else\n+\tif (is_fp_store (insn) && is_fp_insn (dep_insn)\n+\t    && NEXT_INSN (insn) && NEXT_INSN (NEXT_INSN (insn))\n+\t    && NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))\n+\t    && (GET_CODE (NEXT_INSN (insn)) == INSN)\n+\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (insn))) == JUMP_INSN)\n+\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))) == NOTE)\n+\t    && (NOTE_LINE_NUMBER (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn))))\n+\t\t== NOTE_INSN_LOOP_END))\n+\t  return 3;\n+      break;\n+    }\n+\n+  return cost;\n+}"}, {"sha": "2042a6b15650ca6f2b5b2817ee37e044a62f6418", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 44, "deletions": 108, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a269a03c80a4920f09cf0c065a636f6cedf92490", "patch": "@@ -155,18 +155,25 @@ extern int target_flags;\n #define TARGET_486 (ix86_cpu == PROCESSOR_I486)\n #define TARGET_PENTIUM (ix86_cpu == PROCESSOR_PENTIUM)\n #define TARGET_PENTIUMPRO (ix86_cpu == PROCESSOR_PENTIUMPRO)\n-#define TARGET_USE_LEAVE (ix86_cpu == PROCESSOR_I386)\n-#define TARGET_PUSH_MEMORY (ix86_cpu == PROCESSOR_I386)\n-#define TARGET_ZERO_EXTEND_WITH_AND (ix86_cpu != PROCESSOR_I386 \\\n-\t\t\t\t     && ix86_cpu != PROCESSOR_PENTIUMPRO)\n-#define TARGET_DOUBLE_WITH_ADD (ix86_cpu != PROCESSOR_I386)\n-#define TARGET_USE_BIT_TEST (ix86_cpu == PROCESSOR_I386)\n-#define TARGET_UNROLL_STRLEN (ix86_cpu != PROCESSOR_I386)\n-#define TARGET_USE_Q_REG (ix86_cpu == PROCESSOR_PENTIUM \\\n-\t\t\t  || ix86_cpu == PROCESSOR_PENTIUMPRO)\n-#define TARGET_USE_ANY_REG (ix86_cpu == PROCESSOR_I486)\n-#define TARGET_CMOVE (ix86_arch == PROCESSOR_PENTIUMPRO)\n-#define TARGET_DEEP_BRANCH_PREDICTION (ix86_cpu == PROCESSOR_PENTIUMPRO)\n+#define TARGET_K6 (ix86_cpu == PROCESSOR_K6)\n+\n+#define CPUMASK (1 << ix86_cpu)\n+extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n+extern const int x86_use_bit_test, x86_cmove, x86_deep_branch;\n+extern const int x86_unroll_strlen, x86_use_q_reg, x86_use_any_reg;\n+extern const int x86_double_with_add;\n+\n+#define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n+#define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n+#define TARGET_ZERO_EXTEND_WITH_AND (x86_zero_extend_with_and & CPUMASK)\n+#define TARGET_USE_BIT_TEST (x86_use_bit_test & CPUMASK)\n+#define TARGET_UNROLL_STRLEN (x86_unroll_strlen & CPUMASK)\n+#define TARGET_USE_Q_REG (x86_use_q_reg & CPUMASK)\n+#define TARGET_USE_ANY_REG (x86_use_any_reg & CPUMASK)\n+#define TARGET_CMOVE (x86_cmove & (1 << ix86_arch))\n+#define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & CPUMASK)\n+#define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & CPUMASK)\n+\n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n@@ -219,36 +226,29 @@ enum processor_type\n  {PROCESSOR_I386,\t\t\t/* 80386 */\n   PROCESSOR_I486,\t\t\t/* 80486DX, 80486SX, 80486DX[24] */\n   PROCESSOR_PENTIUM,\n-  PROCESSOR_PENTIUMPRO};\n+  PROCESSOR_PENTIUMPRO,\n+  PROCESSOR_K6};\n \n #define PROCESSOR_I386_STRING \"i386\"\n #define PROCESSOR_I486_STRING \"i486\"\n #define PROCESSOR_I586_STRING \"i586\"\n #define PROCESSOR_PENTIUM_STRING \"pentium\"\n #define PROCESSOR_I686_STRING \"i686\"\n #define PROCESSOR_PENTIUMPRO_STRING \"pentiumpro\"\n+#define PROCESSOR_K6_STRING \"k6\"\n \n extern enum processor_type ix86_cpu;\n \n extern int ix86_arch;\n \n /* Define the default processor.  This is overridden by other tm.h files.  */\n-#define PROCESSOR_DEFAULT \\\n-  ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_I486) \\\n-\t\t\t \t\t     ? PROCESSOR_I486  \\\n-  : ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_PENTIUM) \\\n-\t\t\t\t\t       ? PROCESSOR_PENTIUM  \\\n-  : ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_PENTIUMPRO) \\\n-\t\t\t\t\t       ? PROCESSOR_PENTIUMPRO  \\\n-  : PROCESSOR_I386\n+#define PROCESSOR_DEFAULT (enum processor_type) TARGET_CPU_DEFAULT\n #define PROCESSOR_DEFAULT_STRING \\\n-  ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_I486) \\\n-\t\t\t \t\t     ? PROCESSOR_I486_STRING  \\\n-  : ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_PENTIUM) \\\n-\t\t\t\t\t       ? PROCESSOR_PENTIUM_STRING  \\\n-  : ((enum processor_type) TARGET_CPU_DEFAULT == PROCESSOR_PENTIUMPRO) \\\n-\t\t\t\t\t       ? PROCESSOR_PENTIUMPRO_STRING  \\\n-  : PROCESSOR_I386_STRING\n+  (PROCESSOR_DEFAULT == PROCESSOR_I486 ? PROCESSOR_I486_STRING  \\\n+  : PROCESSOR_DEFAULT == PROCESSOR_PENTIUM ? PROCESSOR_PENTIUM_STRING  \\\n+  : PROCESSOR_DEFAULT == PROCESSOR_PENTIUMPRO ? PROCESSOR_PENTIUMPRO_STRING  \\\n+  : PROCESSOR_DEFAULT == PROCESSOR_K6 ? PROCESSOR_K6_STRING  \\\n+  : PROCESSOR_I386_STRING)\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n@@ -1533,34 +1533,31 @@ do {\t\t\t\t\t\t\\\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n-/* On the 386, the trampoline contains three instructions:\n+/* On the 386, the trampoline contains two instructions:\n      mov #STATIC,ecx\n-     mov #FUNCTION,eax\n-     jmp @eax  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xb9));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xb8));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xff));\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xe0));\t\t\\\n-}\n+     jmp FUNCTION\n+   The trampoline is generated entirely at runtime.  The operand of JMP\n+   is the address of FUNCTION relative to the instruction following the\n+   JMP (which is 5 bytes long).  */\n \n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE 12\n+#define TRAMPOLINE_SIZE 10\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n \n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  /* Compute offset from the end of the jmp to the target function.  */\t\\\n+  rtx disp = expand_binop (SImode, sub_optab, FNADDR,\t\t\t\\\n+\t\t\t   plus_constant (TRAMP, 10),\t\t\t\\\n+\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (QImode, TRAMP), GEN_INT (0xb9));\t\t\\\n   emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 1)), CXT); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 6)), FNADDR); \\\n+  emit_move_insn (gen_rtx_MEM (QImode, plus_constant (TRAMP, 5)), GEN_INT (0xe9));\\\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 6)), disp); \\\n }\n \f\n /* Definitions for register eliminations.\n@@ -2243,70 +2240,7 @@ while (0)\n    the same cost as a data-dependence.  */\n \n #define ADJUST_COST(insn,link,dep_insn,cost)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    rtx next_inst;\t\t\t\t\t\t\t\\\n-    if (GET_CODE (dep_insn) == CALL_INSN)\t\t\t\t\\\n-      (cost) = 0;\t\t\t\t\t\t\t\\\n-   \t\t\t\t\t\t\t\t\t\\\n-    else if (GET_CODE (dep_insn) == INSN\t\t\t\t\\\n-\t&& GET_CODE (PATTERN (dep_insn)) == SET\t\t\t\t\\\n-\t&& GET_CODE (SET_DEST (PATTERN (dep_insn))) == REG\t\t\\\n-\t&& GET_CODE (insn) == INSN\t\t\t\t\t\\\n-\t&& GET_CODE (PATTERN (insn)) == SET\t\t\t\t\\\n-\t&& !reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\t\\\n-\t\t\t\t     SET_SRC (PATTERN (insn))))\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t(cost) = 0;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    else if (GET_CODE (insn) == JUMP_INSN)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        (cost) = 0;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_PENTIUM)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        if (cost !=0 && is_fp_insn (insn) && is_fp_insn (dep_insn)\t\\\n-            && !is_fp_dest (dep_insn))\t\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-            (cost) = 0;\t\t\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        if (agi_dependent (insn, dep_insn))\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-            (cost) = 3;\t\t\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-        else if (GET_CODE (insn) == INSN\t\t\t\t\\\n-                 && GET_CODE (PATTERN (insn)) == SET\t\t\t\\\n-                 && SET_DEST (PATTERN (insn)) == cc0_rtx\t\t\\\n-                 && (next_inst = next_nonnote_insn (insn))\t\t\\\n-                 && GET_CODE (next_inst) == JUMP_INSN)\t\t\t\\\n-          { /* compare probably paired with jump */\t\t\t\\\n-            (cost) = 0;\t\t\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      if (!is_fp_dest (dep_insn))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if(!agi_dependent (insn, dep_insn))\t\t\t\t\\\n-\t    (cost) = 0;\t\t\t\t\t\t\t\\\n-\t  else if (TARGET_486)\t\t\t\t\t\t\\\n-\t    (cost) = 2;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tif (is_fp_store (insn) && is_fp_insn (dep_insn)\t\t\t\\\n-\t    && NEXT_INSN (insn) && NEXT_INSN (NEXT_INSN (insn))\t\t\\\n-\t    && NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))\t\t\t\\\n-\t    && (GET_CODE (NEXT_INSN (insn)) == INSN)\t\t\t\\\n-\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (insn))) == JUMP_INSN)\t\\\n-\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))) == NOTE) \\\n-\t    && (NOTE_LINE_NUMBER (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))) \\\n-\t\t== NOTE_INSN_LOOP_END))\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    (cost) = 3;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-  }\n-\n+     (cost) = x86_adjust_cost(insn, link, dep_insn, cost)\n \n #define ADJUST_BLOCKAGE(last_insn,insn,blockage)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -2323,6 +2257,8 @@ while (0)\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+#define ISSUE_RATE ((int)ix86_cpu > (int)PROCESSOR_I486 ? 2 : 1)\n+\n \f\n /* Add any extra modes needed to represent the condition code.\n "}, {"sha": "434ba1f8bbe7659efacb08267c8118719db7cd5a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 473, "deletions": 605, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a269a03c80a4920f09cf0c065a636f6cedf92490/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a269a03c80a4920f09cf0c065a636f6cedf92490", "patch": "@@ -71,9 +71,43 @@\n ;; This shadows the processor_type enumeration, so changes must be made\n ;; to i386.h at the same time.\n \n-(define_attr \"type\" \"integer,idiv,imul,fld,fpop,fpdiv,fpmul\"\n+(define_attr \"type\"\n+  \"integer,binary,memory,test,compare,fcompare,idiv,imul,lea,fld,fpop,fpdiv,fpmul\"\n   (const_string \"integer\"))\n \n+(define_attr \"memory\" \"none,load,store\"\n+  (cond [(eq_attr \"type\" \"idiv,lea\")\n+\t (const_string \"none\")\n+\n+\t (eq_attr \"type\" \"fld\")\n+\t (const_string \"load\")\n+\n+\t (eq_attr \"type\" \"test\")\n+\t (if_then_else (match_operand 0 \"memory_operand\" \"\")\n+\t\t       (const_string \"load\")\n+\t\t       (const_string \"none\"))\n+\n+\t (eq_attr \"type\" \"compare,fcompare\")\n+\t (if_then_else (ior (match_operand 0 \"memory_operand\" \"\")\n+\t\t\t    (match_operand 1 \"memory_operand\" \"\"))\n+\t\t       (const_string \"load\")\n+\t\t       (const_string \"none\"))\n+\n+\t (and (eq_attr \"type\" \"integer,memory,fpop\")\n+\t      (match_operand 0 \"memory_operand\" \"\"))\n+\t (const_string \"store\")\n+\n+\t (and (eq_attr \"type\" \"integer,memory,fpop\")\n+\t      (match_operand 1 \"memory_operand\" \"\"))\n+\t (const_string \"load\")\n+\n+\t (and (eq_attr \"type\" \"binary,imul,fpmul,fpdiv\")\n+\t      (ior (match_operand 1 \"memory_operand\" \"\")\n+\t\t   (match_operand 2 \"memory_operand\" \"\")))\n+\t (const_string \"load\")]\n+\n+\t(const_string \"none\")))\n+\n ;; Functional units\n \n ; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n@@ -92,11 +126,11 @@\n ;; Floating point\n \n (define_function_unit \"fp\" 1 0\n- (and (eq_attr \"type\" \"fpop\") (eq_attr \"cpu\" \"i386,i486\"))\n+ (and (eq_attr \"type\" \"fpop,fcompare\") (eq_attr \"cpu\" \"i386,i486\"))\n  5 5)\n \n (define_function_unit \"fp\" 1 0\n- (and (eq_attr \"type\" \"fpop\") (eq_attr \"cpu\" \"pentium,pentiumpro\")) \n+ (and (eq_attr \"type\" \"fpop,fcompare\") (eq_attr \"cpu\" \"pentium,pentiumpro\")) \n  3 0)\n \n (define_function_unit \"fp\" 1 0\n@@ -120,12 +154,69 @@\n  10 10)\n \n (define_function_unit \"fp\" 1 0\n- (eq_attr \"type\" \"fld\") \n+  (and (eq_attr \"type\" \"fld\") (eq_attr \"cpu\" \"!pentiumpro,k6\"))\n  1 0)\n \n-(define_function_unit \"integer\" 1 0\n-  (and (eq_attr \"type\" \"integer\") (eq_attr \"cpu\" \"!i386\"))\n- 2 0)\n+;; K6 FPU is not pipelined.\n+(define_function_unit \"fp\" 1 0\n+  (and (eq_attr \"type\" \"fpop,fpmul,fcompare\") (eq_attr \"cpu\" \"k6\"))\n+ 2 2)\n+\n+;; i386 and i486 have one integer unit, which need not be modeled\n+\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"type\" \"integer,binary,test,compare,lea\") (eq_attr \"cpu\" \"pentium,pentiumpro\"))\n+ 1 0)\n+\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"integer,binary,test,compare\")\n+\t    (eq_attr \"memory\" \"!load\")))\n+  1 0)\n+\n+;; Internally, K6 converts REG OP MEM instructions into a load (2 cycles)\n+;; and a register operation (1 cycle).\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"integer,binary,test,compare\")\n+\t    (eq_attr \"memory\" \"load\")))\n+  3 0)\n+\n+;; Multiplies use one of the integer units\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"pentium\") (eq_attr \"type\" \"imul\"))\n+  11 11)\n+\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\") (eq_attr \"type\" \"imul\"))\n+  2 2)\n+\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"pentium\") (eq_attr \"type\" \"idiv\"))\n+  25 25)\n+\n+(define_function_unit \"integer\" 2 0\n+  (and (eq_attr \"cpu\" \"k6\") (eq_attr \"type\" \"idiv\"))\n+  17 17)\n+\n+;; Pentium Pro and K6 have a separate load unit.\n+(define_function_unit \"load\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro\") (eq_attr \"memory\" \"load\"))\n+  3 0)\n+\n+(define_function_unit \"load\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\") (eq_attr \"memory\" \"load\"))\n+  2 0)\n+\n+;; Pentium Pro and K6 have a separate store unit.\n+(define_function_unit \"store\" 1 0\n+  (and (eq_attr \"cpu\" \"pentiumpro,k6\") (eq_attr \"memory\" \"store\"))\n+  1 0)\n+\n+;; lea executes in the K6 store unit with 1 cycle latency\n+(define_function_unit \"store\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\") (eq_attr \"type\" \"lea\"))\n+  1 0)\n \n \f\n ;; \"movl MEM,REG / testl REG,REG\" is faster on a 486 than \"cmpl $0,MEM\".\n@@ -143,7 +234,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in i386.h.\n \n-(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro\"\n+(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,k6\"\n   (const (symbol_ref \"ix86_cpu\")))\n \n (define_insn \"tstsi_1\"\n@@ -157,7 +248,8 @@\n \n   operands[1] = const0_rtx;\n   return AS2 (cmp%L0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n (define_expand \"tstsi\"\n   [(set (cc0)\n@@ -182,7 +274,8 @@\n \n   operands[1] = const0_rtx;\n   return AS2 (cmp%W0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n (define_expand \"tsthi\"\n   [(set (cc0)\n@@ -207,7 +300,8 @@\n \n   operands[1] = const0_rtx;\n   return AS2 (cmp%B0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n (define_expand \"tstqi\"\n   [(set (cc0)\n@@ -237,7 +331,8 @@\n     output_asm_insn (AS1 (fstp,%y0), operands);\n \n   return output_fp_cc0_set (insn);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n ;; Don't generate tstsf if generating IEEE code, since the `ftst' opcode\n ;; isn't IEEE compliant.\n@@ -271,7 +366,8 @@\n     output_asm_insn (AS1 (fstp,%y0), operands);\n \n   return output_fp_cc0_set (insn);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n ;; Don't generate tstdf if generating IEEE code, since the `ftst' opcode\n ;; isn't IEEE compliant.\n@@ -305,7 +401,8 @@\n     output_asm_insn (AS1 (fstp,%y0), operands);\n \n   return output_fp_cc0_set (insn);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"test\")])\n \n ;; Don't generate tstxf if generating IEEE code, since the `ftst' opcode\n ;; isn't IEEE compliant.\n@@ -331,7 +428,8 @@\n \t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"mr,r\")\n \t\t (match_operand:SI 1 \"general_operand\" \"ri,mr\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"* return AS2 (cmp%L0,%1,%0);\")\n+  \"* return AS2 (cmp%L0,%1,%0);\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_expand \"cmpsi\"\n   [(set (cc0)\n@@ -354,7 +452,8 @@\n \t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"mr,r\")\n \t\t (match_operand:HI 1 \"general_operand\" \"ri,mr\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"* return AS2 (cmp%W0,%1,%0);\")\n+  \"* return AS2 (cmp%W0,%1,%0);\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_expand \"cmphi\"\n   [(set (cc0)\n@@ -377,7 +476,8 @@\n \t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"q,mq\")\n \t\t (match_operand:QI 1 \"general_operand\" \"qm,nq\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"* return AS2 (cmp%B0,%1,%0);\")\n+  \"* return AS2 (cmp%B0,%1,%0);\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_expand \"cmpqi\"\n   [(set (cc0)\n@@ -406,7 +506,8 @@\n \t\t\t (match_operand:XF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -416,7 +517,8 @@\n \t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -426,7 +528,8 @@\n \t\t\t (match_operand:XF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -436,7 +539,8 @@\n \t\t\t  (match_operand:DF 1 \"nonimmediate_operand\" \"fm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -446,7 +550,8 @@\n \t\t\t (match_operand:XF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -456,7 +561,8 @@\n \t\t\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -466,15 +572,17 @@\n \t\t\t (match_operand:XF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n \t(compare:CCFPEQ (match_operand:XF 0 \"register_operand\" \"f\")\n \t\t\t(match_operand:XF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -484,7 +592,8 @@\n    (clobber (match_scratch:HI 3 \"=a,a\"))]\n   \"TARGET_80387\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -494,7 +603,8 @@\n \t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -504,7 +614,8 @@\n \t\t\t (match_operand:DF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -514,7 +625,8 @@\n \t\t\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -524,7 +636,8 @@\n \t\t\t (match_operand:DF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -534,15 +647,17 @@\n \t\t\t (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n \t(compare:CCFPEQ (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t\t(match_operand:DF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n ;; These two insns will never be generated by combine due to the mode of\n ;; the COMPARE.\n@@ -564,15 +679,16 @@\n ;  \"TARGET_80387\"\n ;  \"* return output_float_compare (insn, operands);\")\n \n-(define_insn \"cmpsf_cc_1\"\n+(define_insn \"*cmpsf_cc_1\"\n   [(set (cc0)\n \t(match_operator 2 \"VOIDmode_compare_op\"\n \t\t\t[(match_operand:SF 0 \"nonimmediate_operand\" \"f,fm\")\n \t\t\t (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")]))\n    (clobber (match_scratch:HI 3 \"=a,a\"))]\n   \"TARGET_80387\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -582,7 +698,8 @@\n \t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -592,15 +709,17 @@\n \t\t\t (match_operand:SF 1 \"register_operand\" \"f\")]))\n    (clobber (match_scratch:HI 3 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n \t(compare:CCFPEQ (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t\t(match_operand:SF 1 \"register_operand\" \"f\")))\n    (clobber (match_scratch:HI 2 \"=a\"))]\n   \"TARGET_80387\"\n-  \"* return output_float_compare (insn, operands);\")\n+  \"* return output_float_compare (insn, operands);\"\n+  [(set_attr \"type\" \"fcompare\")])\n \n (define_expand \"cmpxf\"\n   [(set (cc0)\n@@ -760,7 +879,8 @@\n     return AS2 (test%L0,%1,%0);\n \n   return AS2 (test%L1,%0,%1);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -808,7 +928,8 @@\n     return AS2 (test%W0,%1,%0);\n \n   return AS2 (test%W1,%0,%1);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_insn \"\"\n   [(set (cc0)\n@@ -821,7 +942,8 @@\n     return AS2 (test%B0,%1,%0);\n \n   return AS2 (test%B1,%0,%1);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"compare\")])\n \f\n ;; move instructions.\n ;; There is one for each machine mode,\n@@ -832,21 +954,25 @@\n   [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n \t(match_operand:SI 1 \"nonmemory_operand\" \"rn\"))]\n   \"flag_pic\"\n-  \"* return AS1 (push%L0,%1);\")\n+  \"* return AS1 (push%L0,%1);\"\n+  [(set_attr \"memory\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n \t(match_operand:SI 1 \"nonmemory_operand\" \"ri\"))]\n   \"!flag_pic\"\n-  \"* return AS1 (push%L0,%1);\")\n+  \"* return AS1 (push%L0,%1);\"\n+  [(set_attr \"memory\" \"store\")])\n \n ;; On a 386, it is faster to push MEM directly.\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n \t(match_operand:SI 1 \"memory_operand\" \"m\"))]\n   \"TARGET_PUSH_MEMORY\"\n-  \"* return AS1 (push%L0,%1);\")\n+  \"* return AS1 (push%L0,%1);\"\n+  [(set_attr \"type\" \"memory\")\n+   (set_attr \"memory\" \"load\")])\n \n ;; General case of fullword move.\n \n@@ -877,18 +1003,24 @@\n ;; On i486, incl reg is faster than movl $1,reg.\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g,r\")\n-\t(match_operand:SI 1 \"general_operand\" \"rn,im\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,r,r\")\n+\t(match_operand:SI 1 \"general_operand\" \"rn,i,m\"))]\n   \"((!TARGET_MOVE || GET_CODE (operands[0]) != MEM)\n     || (GET_CODE (operands[1]) != MEM))\n    && flag_pic\"\n   \"*\n {\n   rtx link;\n-  if (operands[1] == const0_rtx && REG_P (operands[0]))\n+\n+  /* K6: mov reg,0 is slightly faster than xor reg,reg but is 3 bytes\n+     longer.  */\n+  if ((ix86_cpu != PROCESSOR_K6 || optimize_size)\n+      && operands[1] == const0_rtx && REG_P (operands[0]))\n     return AS2 (xor%L0,%0,%0);\n \n   if (operands[1] == const1_rtx\n+      /* PPRO and K6 prefer mov to inc to reduce dependencies.  */\n+      && (optimize_size || (int)ix86_cpu < (int)PROCESSOR_PENTIUMPRO)\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -904,7 +1036,9 @@\n     return AS2 (lea%L0,%a1,%0);\n \n   return AS2 (mov%L0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"integer,integer,memory\")\n+   (set_attr \"memory\" \"*,*,load\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g,r\")\n@@ -915,10 +1049,13 @@\n   \"*\n {\n   rtx link;\n-  if (operands[1] == const0_rtx && REG_P (operands[0]))\n+  if ((ix86_cpu != PROCESSOR_K6 || optimize_size)\n+      && operands[1] == const0_rtx && REG_P (operands[0]))\n     return AS2 (xor%L0,%0,%0);\n \n   if (operands[1] == const1_rtx\n+      /* PPRO and K6 prefer mov to inc to reduce dependencies.  */\n+      && (optimize_size || (int)ix86_cpu < (int)PROCESSOR_PENTIUMPRO)\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -931,19 +1068,25 @@\n     return AS1 (inc%L0,%0);\n \n   return AS2 (mov%L0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"integer,memory\")\n+   (set_attr \"memory\" \"*,load\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n \t(match_operand:HI 1 \"nonmemory_operand\" \"ri\"))]\n   \"\"\n-  \"* return AS1 (push%W0,%1);\")\n+  \"* return AS1 (push%W0,%1);\"\n+  [(set_attr \"type\" \"memory\")\n+   (set_attr \"memory\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n \t(match_operand:HI 1 \"memory_operand\" \"m\"))]\n   \"TARGET_PUSH_MEMORY\"\n-  \"* return AS1 (push%W0,%1);\")\n+  \"* return AS1 (push%W0,%1);\"\n+  [(set_attr \"type\" \"memory\")\n+   (set_attr \"memory\" \"load\")])\n \n ;; On i486, an incl and movl are both faster than incw and movw.\n \n@@ -974,6 +1117,8 @@\n     return AS2 (xor%L0,%k0,%k0);\n \n   if (REG_P (operands[0]) && operands[1] == const1_rtx \n+      /* PPRO and K6 prefer mov to inc to reduce dependencies.  */\n+      && (optimize_size || (int)ix86_cpu < (int)PROCESSOR_PENTIUMPRO)\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -992,7 +1137,7 @@\n \t  operands[1] = i386_sext16_if_const (operands[1]);\n \t  return AS2 (mov%L0,%k1,%k0);\n \t}\n-      if (TARGET_PENTIUMPRO)\n+      if (! TARGET_ZERO_EXTEND_WITH_AND)\n \t{\n \t  /* movzwl is faster than movw on the Pentium Pro,\n \t   * although not as fast as an aligned movl. */\n@@ -1005,7 +1150,9 @@\n     }\n \n   return AS2 (mov%W0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"integer,memory\")\n+   (set_attr \"memory\" \"*,load\")])\n \n (define_expand \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"\"))\n@@ -1030,10 +1177,13 @@\n   \"*\n {\n   rtx link;\n-  if (operands[1] == const0_rtx && REG_P (operands[0]))\n+  if ((ix86_cpu != PROCESSOR_K6 || optimize_size)\n+      && operands[1] == const0_rtx && REG_P (operands[0]))\n     return AS2 (xor%W0,%0,%0);\n \n   if (operands[1] == const1_rtx\n+      /* PPRO and K6 prefer mov to inc to reduce dependencies.  */\n+      && (optimize_size || (int)ix86_cpu < (int)PROCESSOR_PENTIUMPRO)\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -1046,7 +1196,8 @@\n     return AS1 (inc%W0,%0);\n \n   return AS2 (mov%W0,%1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"integer,memory\")])\n \n ;; emit_push_insn when it calls move_by_pieces\n ;; requires an insn to \"push a byte\".\n@@ -1096,10 +1247,12 @@\n   \"*\n {\n   rtx link;\n-  if (operands[1] == const0_rtx && REG_P (operands[0]))\n-    return AS2 (xor%L0,%k0,%k0);\n+\n+  /* movb $0,reg8 is 2 bytes, the same as xorl reg8,reg8.\n+     It is at least as fast as xor on any processor except a Pentium. */\n \n   if (operands[1] == const1_rtx\n+      && ix86_cpu == PROCESSOR_PENTIUM\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n       && ! INSN_DELETED_P (XEXP (link, 0))\n@@ -1156,10 +1309,11 @@\n   \"*\n {\n   rtx link;\n-  if (operands[1] == const0_rtx && REG_P (operands[0]))\n-    return AS2 (xor%B0,%0,%0);\n+\n+  /* movb $0,reg8 is 2 bytes, the same as xorl reg8,reg8.  */\n \n   if (operands[1] == const1_rtx\n+      && ix86_cpu == PROCESSOR_PENTIUM\n       && ! NON_QI_REG_P (operands[0])\n       && (link = find_reg_note (insn, REG_WAS_0, 0))\n       /* Make sure the insn that stored the 0 is still present.  */\n@@ -1624,7 +1778,9 @@\n \t(match_operand:DI 1 \"general_operand\" \"riF,m\"))]\n   \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM)\n    || (GET_CODE (operands[1]) != MEM)\"\n-  \"* return output_move_double (operands);\")\n+  \"* return output_move_double (operands);\"\n+  [(set_attr \"type\" \"integer,memory\")\n+   (set_attr \"memory\" \"*,load\")])\n \n \f\n ;;- conversion instructions\n@@ -2625,7 +2781,7 @@\n \f\n ;;- add instructions\n \n-(define_insn \"addsidi3_1\"\n+(define_insn \"*addsidi3_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,!&r,!r,o,!o\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,o,riF,riF,o\")\n \t\t (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"o,ri,ri,roi,roi,ri,ri\"))))\n@@ -2670,8 +2826,11 @@\n \n   output_asm_insn (AS2 (add%L0,%2,%0), low);\n   output_asm_insn (AS2 (adc%L0,%2,%0), high);\n+  cc_status.value1 = high[0];\n+  cc_status.flags = CC_NO_OVERFLOW;\n   RET;\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"addsidi3_2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,&r,!&r,&r,o,o,!o\")\n@@ -2748,8 +2907,11 @@\n \n   output_asm_insn (AS2 (add%L0,%2,%0), low);\n   output_asm_insn (AS2 (adc%L0,%2,%0), high);\n+  cc_status.value1 = high[0];\n+  cc_status.flags = CC_NO_OVERFLOW;\n   RET;\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n@@ -2798,6 +2960,9 @@\n \t}\n     }\n \n+  cc_status.value1 = high[0];\n+  cc_status.flags = CC_NO_OVERFLOW;\n+\n   if (GET_CODE (operands[3]) == REG && GET_CODE (operands[2]) != REG)\n     {\n       xops[0] = high[0];\n@@ -2822,7 +2987,8 @@\n     output_asm_insn (AS2 (add%L0,%2,%0), high);\n \n   RET;\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n ;; On a 486, it is faster to do movl/addl than to do a single leal if\n ;; operands[1] and operands[2] are both registers.\n@@ -2887,7 +3053,8 @@\n     }\n \n   return AS2 (add%L0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n ;; addsi3 is faster, so put this after.\n \n@@ -2916,7 +3083,8 @@\n \n   CC_STATUS_INIT;\n   return AS2 (lea%L0,%a1,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"lea\")])\n \n ;; ??? `lea' here, for three operand add?  If leaw is used, only %bx,\n ;; %si and %di can appear in SET_SRC, and output_asm_insn might not be\n@@ -2986,7 +3154,8 @@\n     return AS1 (dec%W0,%0);\n \n   return AS2 (add%W0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_expand \"addqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -3011,7 +3180,8 @@\n     return AS1 (dec%B0,%0);\n \n   return AS2 (add%B0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n ;Lennart Augustsson <augustss@cs.chalmers.se>\n ;says this pattern just makes slower code:\n@@ -3108,8 +3278,12 @@\n \n   output_asm_insn (AS2 (sub%L0,%2,%0), low);\n   output_asm_insn (AS2 (sbb%L0,%2,%0), high);\n+  cc_status.value1 = high[0];\n+  cc_status.flags = CC_NO_OVERFLOW;\n+\n   RET;\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,o,o,!&r,!o\")\n@@ -3152,6 +3326,9 @@\n \t}\n     }\n \n+  cc_status.value1 = high[0];\n+  cc_status.flags = CC_NO_OVERFLOW;\n+\n   if (GET_CODE (operands[3]) == REG)\n     {\n       xops[0] = high[0];\n@@ -3173,10 +3350,12 @@\n     }\n \n   else\n-    output_asm_insn (AS2 (sub%L0,%2,%0), high);\n+      output_asm_insn (AS2 (sub%L0,%2,%0), high);\n+\n \n   RET;\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -3190,7 +3369,8 @@\n \t(minus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n \t\t  (match_operand:SI 2 \"general_operand\" \"ri,rm\")))]\n   \"ix86_binary_operator_ok (MINUS, SImode, operands)\"\n-  \"* return AS2 (sub%L0,%2,%0);\")\n+  \"* return AS2 (sub%L0,%2,%0);\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_expand \"subhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -3215,7 +3395,8 @@\n       return AS2 (sub%L0,%k2,%k0);\n     }\n  return AS2 (sub%W0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_expand \"subqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -3229,7 +3410,8 @@\n \t(minus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n \t\t  (match_operand:QI 2 \"general_operand\" \"qn,qmn\")))]\n   \"ix86_binary_operator_ok (MINUS, QImode, operands)\"\n-  \"* return AS2 (sub%B0,%2,%0);\")\n+  \"* return AS2 (sub%B0,%2,%0);\"\n+  [(set_attr \"type\" \"binary\")])\n \n ;; The patterns that match these are at the end of this file.\n \n@@ -3655,7 +3837,8 @@ word_zero_and_operation:\n     }\n \n   return AS2 (and%L0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -3733,14 +3916,16 @@ word_zero_and_operation:\n     }\n \n   return AS2 (and%W0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"andqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q\")\n \t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn\")))]\n   \"\"\n-  \"* return AS2 (and%B0,%2,%0);\")\n+  \"* return AS2 (and%B0,%2,%0);\"\n+  [(set_attr \"type\" \"binary\")])\n \n /* I am nervous about these two.. add them later..\n ;I presume this means that we have something in say op0= eax which is small\n@@ -3856,7 +4041,8 @@ byte_or_operation:\n     }\n \n   return AS2 (or%L0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -3940,14 +4126,16 @@ byte_or_operation:\n     }\n \n   return AS2 (or%W0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"iorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"general_operand\" \"qn,qmn\")))]\n   \"\"\n-  \"* return AS2 (or%B0,%2,%0);\")\n+  \"* return AS2 (or%B0,%2,%0);\"\n+  [(set_attr \"type\" \"binary\")])\n \f\n ;;- xor instructions\n \n@@ -4035,7 +4223,8 @@ byte_xor_operation:\n     }\n \n   return AS2 (xor%L0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -4096,115 +4285,55 @@ byte_xor_operation:\n     }\n \n   return AS2 (xor%W0,%2,%0);\n-}\")\n+}\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_insn \"xorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q\")\n \t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"general_operand\" \"qn,qm\")))]\n   \"\"\n-  \"* return AS2 (xor%B0,%2,%0);\")\n+  \"* return AS2 (xor%B0,%2,%0);\"\n+  [(set_attr \"type\" \"binary\")])\n \f\n ;; logical operations for DImode\n \n-\n (define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n-\t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro\")\n+\t(and:DI (match_operand:DI 1 \"general_operand\" \"0,0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"oriF,riF\")))]\n   \"\"\n-  \"#\")\n+  \"#\"\n+  [(set_attr \"type\" \"binary\")])\n+\n \n (define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n-\t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro\")\n+\t(ior:DI (match_operand:DI 1 \"general_operand\" \"0,0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"oriF,riF\")))]\n   \"\"\n-  \"#\")\n-  \n+  \"#\"\n+  [(set_attr \"type\" \"binary\")])\n+\n (define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n-\t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n-\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro\")\n+\t(xor:DI (match_operand:DI 1 \"general_operand\" \"0,0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"oriF,riF\")))]\n   \"\"\n-  \"#\")\n+  \"#\"\n+  [(set_attr \"type\" \"binary\")])\n \n (define_split\n-  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n-\t(match_operator:DI 4 \"ix86_logical_operator\"\n-\t  [(match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n-\t   (match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")]))\n-   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n-  \"reload_completed\"\n-  [(const_int 0)]\n-  \"\n-{\n-  rtx low[3], high[3], xops[7], temp;\n-  rtx (*genfunc)() = (GET_CODE (operands[4]) == AND ? gen_andsi3\n-\t\t      : GET_CODE (operands[4]) == IOR ? gen_iorsi3\n-\t\t      : GET_CODE (operands[4]) == XOR ? gen_xorsi3\n-\t\t      : 0);\n-\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    {\n-      temp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = temp;\n-    }\n-\n-  split_di (operands, 3, low, high);\n-  if (!rtx_equal_p (operands[0], operands[1]))\n-    {\n-      xops[0] = high[0];\n-      xops[1] = low[0];\n-      xops[2] = high[1];\n-      xops[3] = low[1];\n-\n-      if (GET_CODE (operands[0]) != MEM)\n-\t{\n-\t  emit_insn (gen_movsi (xops[1], xops[3]));\n-\t  emit_insn (gen_movsi (xops[0], xops[2]));\n-\t}\n-      else\n-\t{\n-\t  xops[4] = high[2];\n-\t  xops[5] = low[2];\n-\t  xops[6] = operands[3];\n-\t  emit_insn (gen_movsi (xops[6], xops[3]));\n-\t  emit_insn ((*genfunc) (xops[6], xops[6], xops[5]));\n-\t  emit_insn (gen_movsi (xops[1], xops[6]));\n-\t  emit_insn (gen_movsi (xops[6], xops[2]));\n-\t  emit_insn ((*genfunc) (xops[6], xops[6], xops[4]));\n-\t  emit_insn (gen_movsi (xops[0], xops[6]));\n-\t  DONE;\n-\t}\n-    }\n-\n-  if (GET_CODE (operands[3]) == REG && GET_CODE (operands[2]) != REG)\n-    {\n-      xops[0] = high[0];\n-      xops[1] = low[0];\n-      xops[2] = high[2];\n-      xops[3] = low[2];\n-      xops[4] = operands[3];\n-\n-      emit_insn (gen_movsi (xops[4], xops[3]));\n-      emit_insn ((*genfunc) (xops[1], xops[1], xops[4]));\n-      emit_insn (gen_movsi (xops[4], xops[2]));\n-      emit_insn ((*genfunc) (xops[0], xops[0], xops[4]));\n-    }\n-\n-  else\n-    {\n-      emit_insn ((*genfunc) (low[0], low[0], low[2]));\n-      emit_insn ((*genfunc) (high[0], high[0], high[2]));\n-    }\n-\n-  DONE;\n-}\")\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operator:DI 3 \"ix86_logical_operator\"\n+\t  [(match_operand:DI 1 \"general_operand\" \"\")\n+\t   (match_operand:DI 2 \"general_operand\" \"\")]))]\n+  \"\"\n+  [(set (match_dup 4) (match_op_dup:SI 3 [(match_dup 6) (match_dup 8)]))\n+   (set (match_dup 5) (match_op_dup:SI 3 [(match_dup 7) (match_dup 9)]))]\n+  \"split_di (&operands[0], 1, &operands[4], &operands[5]);\n+   split_di (&operands[1], 1, &operands[6], &operands[7]);\n+   split_di (&operands[2], 1, &operands[8], &operands[9]);\")\n \n ;;- negation instructions\n \n@@ -4512,7 +4641,7 @@ byte_xor_operation:\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n-  static HOST_WIDE_INT ashldi_label_number;\n+  static int ashldi_label_number;\n \n   CC_STATUS_INIT;\n \n@@ -4700,7 +4829,7 @@ byte_xor_operation:\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n-  static HOST_WIDE_INT ashrdi_label_number;\n+  static int ashrdi_label_number;\n \n   CC_STATUS_INIT;\n \n@@ -4855,7 +4984,7 @@ byte_xor_operation:\n   \"*\n {\n   rtx xops[4], low[1], high[1];\n-  static HOST_WIDE_INT lshrdi_label_number;\n+  static int lshrdi_label_number;\n \n   CC_STATUS_INIT;\n \n@@ -5228,10 +5357,6 @@ byte_xor_operation:\n ;; For all sCOND expanders, also expand the compare or test insn that\n ;; generates cc0.  Generate an equality comparison if `seq' or `sne'.\n \n-;; The 386 sCOND opcodes can write to memory.  But a gcc sCOND insn may\n-;; not have any input reloads.  A MEM write might need an input reload\n-;; for the address of the MEM.  So don't allow MEM as the SET_DEST.\n-\n (define_expand \"seq\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n@@ -5246,18 +5371,6 @@ byte_xor_operation:\n     operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(eq:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return AS1 (setnb,%0);\n-  else\n-    return AS1 (sete,%0);\n-}\")\n-\n (define_expand \"sne\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n@@ -5272,150 +5385,117 @@ byte_xor_operation:\n     operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(ne:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return AS1 (setb,%0);\n-  else\n-    return AS1 (setne,%0);\n-}\n-\")\n-\n (define_expand \"sgt\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(gt:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (sete,%0);\n-\n-  OUTPUT_JUMP (\\\"setg %0\\\", \\\"seta %0\\\", NULL_PTR);\n-}\")\n-\n (define_expand \"sgtu\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(gtu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(gtu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* return \\\"seta %0\\\"; \")\n-\n (define_expand \"slt\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(lt:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (sete,%0);\n-\n-  OUTPUT_JUMP (\\\"setl %0\\\", \\\"setb %0\\\", \\\"sets %0\\\");\n-}\")\n-\n (define_expand \"sltu\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ltu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(ltu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* return \\\"setb %0\\\"; \")\n-\n (define_expand \"sge\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(ge:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (sete,%0);\n-\n-  OUTPUT_JUMP (\\\"setge %0\\\", \\\"setae %0\\\", \\\"setns %0\\\");\n-}\")\n-\n (define_expand \"sgeu\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(geu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(geu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* return \\\"setae %0\\\"; \")\n-\n (define_expand \"sle\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(le:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (setb,%0);\n-\n-  OUTPUT_JUMP (\\\"setle %0\\\", \\\"setbe %0\\\", NULL_PTR);\n-}\")\n-\n (define_expand \"sleu\"\n   [(match_dup 1)\n    (set (match_operand:QI 0 \"register_operand\" \"\")\n \t(leu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=q\")\n-\t(leu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* return \\\"setbe %0\\\"; \")\n+;; The 386 sCOND opcodes can write to memory.  But a gcc sCOND insn may\n+;; not have any input reloads.  A MEM write might need an input reload\n+;; for the address of the MEM.  So don't allow MEM as the SET_DEST.\n+\n+(define_insn \"*setcc\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n+\t(match_operator:QI 1 \"comparison_operator\" [(cc0) (const_int 0)]))]\n+  \"reload_completed || register_operand (operands[0], QImode)\"\n+  \"*\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  if (cc_prev_status.flags & CC_TEST_AX)\n+    {\n+      int eq;\n+      HOST_WIDE_INT c;\n+      operands[2] = gen_rtx_REG (SImode, 0);\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  c = 0x4000;\n+\t  eq = 0;\n+\t  break;\n+\tcase NE:\n+\t  c = 0x4000;\n+\t  eq = 1;\n+\t  break;\n+\tcase GT:\n+\t  c = 0x4100;\n+\t  eq = 1;\n+\t  break;\n+\tcase LT:\n+\t  c = 0x100;\n+\t  eq = 0;\n+\t  break;\n+\tcase GE:\n+\t  c = 0x100;\n+\t  eq = 1;\n+\t  break;\n+\tcase LE:\n+\t  c = 0x4100;\n+\t  eq = 0;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      operands[3] = GEN_INT (c);\n+      output_asm_insn (AS2 (testl,%3,%2), operands);\n+      return eq ? AS1 (sete,%0) : AS1 (setne, %0);\n+    }\n+\n+  if ((cc_status.flags & CC_NO_OVERFLOW) && (code == LE || code == GT))\n+    return (char *)0;\n+  return AS1(set%D1,%0);\n+}\")\n+\n \f\n ;; Basic conditional jump instructions.\n ;; We ignore the overflow flag for signed branch instructions.\n@@ -5440,29 +5520,6 @@ byte_xor_operation:\n     operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return \\\"jnc %l0\\\";\n-  else\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4000);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n-    }\n-\n-    return \\\"je %l0\\\";\n-}\")\n-\n (define_expand \"bne\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5480,28 +5537,6 @@ byte_xor_operation:\n     operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\n }\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return \\\"jc %l0\\\";\n-  else\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4000);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n-    }\n-\n-    return \\\"jne %l0\\\";\n-}\")\n \n (define_expand \"bgt\"\n   [(match_dup 1)\n@@ -5513,29 +5548,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (je,%l0);\n-\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n-    }\n-  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", NULL_PTR);\n-}\")\n-\n (define_expand \"bgtu\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5546,15 +5558,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"ja %l0\")\n-\n (define_expand \"blt\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5565,28 +5568,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (je,%l0);\n-\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n-    }\n-  OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\");\n-}\")\n \n (define_expand \"bltu\"\n   [(match_dup 1)\n@@ -5598,15 +5579,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jb %l0\")\n-\n (define_expand \"bge\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5617,28 +5589,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (je,%l0);\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n-    }\n-  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\");\n-}\")\n-\n (define_expand \"bgeu\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5649,15 +5599,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jae %l0\")\n-\n (define_expand \"ble\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5668,29 +5609,6 @@ byte_xor_operation:\n   \"\"\n   \"operands[1] = (*i386_compare_gen)(i386_compare_op0, i386_compare_op1);\")\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (jb,%l0);\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n-    }\n-\n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", NULL_PTR);\n-}\")\n-\n (define_expand \"bleu\"\n   [(match_dup 1)\n    (set (pc)\n@@ -5703,184 +5621,111 @@ byte_xor_operation:\n \n (define_insn \"\"\n   [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"jbe %l0\")\n-\f\n-;; Negated conditional jump instructions.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n   \"*\n {\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return \\\"jc %l0\\\";\n-  else\n+  enum rtx_code code = GET_CODE (operands[0]);\n   if (cc_prev_status.flags & CC_TEST_AX)\n     {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4000);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n-    }\n-    return \\\"jne %l0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n-    return \\\"jnc %l0\\\";\n-  else\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4000);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n-    }\n-    return \\\"je %l0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (jne,%l0);\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n-    }\n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"jbe %l0\\\", NULL_PTR);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jbe %l0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (jne,%l0);\n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n+      int eq;\n+      HOST_WIDE_INT c;\n+      operands[2] = gen_rtx_REG (SImode, 0);\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  c = 0x4000;\n+\t  eq = 0;\n+\t  break;\n+\tcase NE:\n+\t  c = 0x4000;\n+\t  eq = 1;\n+\t  break;\n+\tcase GT:\n+\t  c = 0x4100;\n+\t  eq = 1;\n+\t  break;\n+\tcase LT:\n+\t  c = 0x100;\n+\t  eq = 0;\n+\t  break;\n+\tcase GE:\n+\t  c = 0x100;\n+\t  eq = 1;\n+\t  break;\n+\tcase LE:\n+\t  c = 0x4100;\n+\t  eq = 0;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      operands[3] = GEN_INT (c);\n+      output_asm_insn (AS2 (testl,%3,%2), operands);\n+      return eq ? AS1 (je,%l1) : AS1 (jne, %l1);\n     }\n+  if ((cc_status.flags & CC_NO_OVERFLOW) && (code == LE || code == GT))\n+    return (char *)0;\n \n-  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"jae %l0\\\", \\\"jns %l0\\\");\n+  return AS1(j%D0,%l1);\n }\")\n \n (define_insn \"\"\n   [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jae %l0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n \t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n   \"\"\n   \"*\n {\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (jne,%l0);\n+  enum rtx_code code = GET_CODE (operands[0]);\n   if (cc_prev_status.flags & CC_TEST_AX)\n     {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (jne,%l0);\n+      int eq;\n+      HOST_WIDE_INT c;\n+      operands[2] = gen_rtx_REG (SImode, 0);\n+      switch (code)\n+\t{\n+\tcase EQ:\n+\t  c = 0x4000;\n+\t  eq = 1;\n+\t  break;\n+\tcase NE:\n+\t  c = 0x4000;\n+\t  eq = 0;\n+\t  break;\n+\tcase GT:\n+\t  c = 0x4100;\n+\t  eq = 0;\n+\t  break;\n+\tcase LT:\n+\t  c = 0x100;\n+\t  eq = 1;\n+\t  break;\n+\tcase GE:\n+\t  c = 0x100;\n+\t  eq = 0;\n+\t  break;\n+\tcase LE:\n+\t  c = 0x4100;\n+\t  eq = 1;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      operands[3] = GEN_INT (c);\n+      output_asm_insn (AS2 (testl,%3,%2), operands);\n+      return eq ? AS1 (je,%l1) : AS1 (jne, %l1);\n     }\n-  OUTPUT_JUMP (\\\"jl %l0\\\", \\\"jb %l0\\\", \\\"js %l0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"jb %l0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_IEEE_FP && (cc_prev_status.flags & CC_IN_80387)\n-      && ! (cc_prev_status.flags & CC_FCOMI))\n-    return AS1 (jae,%l0);\n+  if ((cc_status.flags & CC_NO_OVERFLOW) && (code == LE || code == GT))\n+    return (char *)0;\n \n-  if (cc_prev_status.flags & CC_TEST_AX)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, 0);\n-      operands[2] = GEN_INT (0x4100);\n-      output_asm_insn (AS2 (testl,%2,%1), operands);\n-      return AS1 (je,%l0);\n-    }\n-  OUTPUT_JUMP (\\\"jg %l0\\\", \\\"ja %l0\\\", NULL_PTR);\n+  return AS1(j%d0,%l1);\n }\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"ja %l0\")\n \f\n ;; Unconditional and other jump instructions\n \n@@ -5919,7 +5764,7 @@ byte_xor_operation:\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"arithmetic_comparison_operator\"\n-\t\t\t\t      [(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"+r,m\")\n+\t\t\t\t      [(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"+c*r,m\")\n \t\t\t\t\t\t(match_operand:SI 2 \"general_operand\" \"rmi,ri\"))\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n@@ -5931,6 +5776,11 @@ byte_xor_operation:\n   \"*\n {\n   CC_STATUS_INIT;\n+\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[2]) == 2 &&\n+      operands[2] == constm1_rtx && ix86_cpu == PROCESSOR_K6)\n+    return \\\"loop %l3\\\";\n+\n   if (operands[2] == constm1_rtx)\n     output_asm_insn (AS1 (dec%L1,%1), operands);\n \n@@ -6682,7 +6532,7 @@ byte_xor_operation:\n ;; But strength reduction might offset the MEM expression.  So we let\n ;; reload put the address into %edi.\n \n-(define_insn \"\"\n+(define_insn \"*bzero\"\n   [(set (mem:BLK (match_operand:SI 0 \"address_operand\" \"D\"))\n \t(const_int 0))\n    (use (match_operand:SI 1 \"const_int_operand\" \"n\"))\n@@ -6698,17 +6548,35 @@ byte_xor_operation:\n   output_asm_insn (\\\"cld\\\", operands);\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-      if (INTVAL (operands[1]) & ~0x03)\n+      unsigned int count = INTVAL (operands[1]) & 0xffffffff;\n+      if (count & ~0x03)\n \t{\n-\t  xops[0] = GEN_INT ((INTVAL (operands[1]) >> 2) & 0x3fffffff);\n+\t  xops[0] = GEN_INT (count / 4);\n \t  xops[1] = operands[4];\n \n-\t  output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n+\t  /* K6: stos takes 1 cycle, rep stos takes 8 + %ecx cycles.\n+\t     80386: 4/5+5n (+2 for set of ecx)\n+\t     80486: 5/7+5n (+1 for set of ecx)\n+\t     */\n+\t  if (count / 4 < ((int) ix86_cpu < (int)PROCESSOR_PENTIUM ? 4 : 6))\n+\t    {\n+\t      do\n #ifdef INTEL_SYNTAX\n-\t  output_asm_insn (\\\"rep stosd\\\", xops);\n+\t\toutput_asm_insn (\\\"stosd\\\", xops);\n #else\n-\t  output_asm_insn (\\\"rep\\;stosl\\\", xops);\n+\t\toutput_asm_insn (\\\"stosl\\\", xops);\n #endif\n+\t      while ((count -= 4) > 3);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n+#ifdef INTEL_SYNTAX\n+\t      output_asm_insn (\\\"rep stosd\\\", xops);\n+#else\n+\t      output_asm_insn (\\\"rep\\;stosl\\\", xops);\n+#endif\n+\t    }\n \t}\n       if (INTVAL (operands[1]) & 0x02)\n \toutput_asm_insn (\\\"stosw\\\", operands);"}]}