{"sha": "683af98c7f55ab61e4764a97b749ef00fc9dfedd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzYWY5OGM3ZjU1YWI2MWU0NzY0YTk3Yjc0OWVmMDBmYzlkZmVkZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:31:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T13:31:09Z"}, "message": "[multiple changes]\n\n2017-09-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_aggr.adb (Expand_Array_Aggregate): Use New_Copy_Tree instead\n\tof New_Copy because the latter leaves the syntactic structure of\n\tthe tree inconsistent (a child is accessible through two parents)\n\tand prevents proper replication of itypes by subsequent calls\n\tto New_Copy_Tree.\n\t* exp_ch4.adb (Expand_Concatenate): Use New_Copy_Tree instead of\n\tNew_Copy because the latter leaves the syntactic structure of the\n\ttree inconsistent (a child is accessible through two parents)\n\tand prevents proper replication of itypes by subsequent calls\n\tto New_Copy_Tree.\n\t* sem_util.adb (In_Subtree): New routine.\n\t(New_Copy_Tree): Reimplemented.\n\t* sem_util.ads (In_Subtree): New routine.\n\t(New_Copy_Tree): Reimplemented.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Resolve_Aspect_Expressions): The expression\n\tfor aspect Default_Value is a static scalar value, but it does\n\tnot freeze the type. Yhis allows for subsequent representation\n\tclauses for the type.\n\n2017-09-08  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch8.adb (Find_Direct_Name.Undefined): Do\n\tnot add entries into the undefined reference table when we are\n\tcompiling with errors ignored.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Check_Formal_Packages): Do not apply conformance\n\tcheck if the instance is within an enclosing instance body. The\n\tformal package was legal in the enclosing generic, and is\n\tlegal in the enclosing instantiation.  This optimisation may be\n\tapplicable elsewhere, and it also removes spurious errors that\n\tmay arise with on-the-fly processing  of instantiations that\n\tcontain Inline_Always subprograms.\n\n2017-09-08  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: Disregard empty argument of GNAT driver.\n\n2017-09-08  Justin Squirek  <squirek@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Manually decorate\n\tthe generated temporary for range valdity checks.\n\n2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* usage.adb (Usage): Document new -gnatw.q/-gnatw.Q switches.\n\n2017-09-08  Justin Squirek  <squirek@adacore.com>\n\n\t* switch-c.adb (Scan_Front_End_Switches): Add new warning switch\n\tcase to handle underscore flags.\n\t* warnsw.adb, warnsw.ads (Set_Underscore_Warning_Switch): Create\n\tnew procedure to handle underscores.\n\nFrom-SVN: r251893", "tree": {"sha": "aa1dd0856276c98b24dda4c5d89cd081965c6579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa1dd0856276c98b24dda4c5d89cd081965c6579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683af98c7f55ab61e4764a97b749ef00fc9dfedd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683af98c7f55ab61e4764a97b749ef00fc9dfedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683af98c7f55ab61e4764a97b749ef00fc9dfedd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683af98c7f55ab61e4764a97b749ef00fc9dfedd/comments", "author": null, "committer": null, "parents": [{"sha": "8223b65461fbeeb58f4753c23748b64daa84c10e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8223b65461fbeeb58f4753c23748b64daa84c10e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8223b65461fbeeb58f4753c23748b64daa84c10e"}], "stats": {"total": 2226, "additions": 1489, "deletions": 737}, "files": [{"sha": "84672140951323de9c12b058d61f618d7795aa1b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -1,3 +1,63 @@\n+2017-09-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Expand_Array_Aggregate): Use New_Copy_Tree instead\n+\tof New_Copy because the latter leaves the syntactic structure of\n+\tthe tree inconsistent (a child is accessible through two parents)\n+\tand prevents proper replication of itypes by subsequent calls\n+\tto New_Copy_Tree.\n+\t* exp_ch4.adb (Expand_Concatenate): Use New_Copy_Tree instead of\n+\tNew_Copy because the latter leaves the syntactic structure of the\n+\ttree inconsistent (a child is accessible through two parents)\n+\tand prevents proper replication of itypes by subsequent calls\n+\tto New_Copy_Tree.\n+\t* sem_util.adb (In_Subtree): New routine.\n+\t(New_Copy_Tree): Reimplemented.\n+\t* sem_util.ads (In_Subtree): New routine.\n+\t(New_Copy_Tree): Reimplemented.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Resolve_Aspect_Expressions): The expression\n+\tfor aspect Default_Value is a static scalar value, but it does\n+\tnot freeze the type. Yhis allows for subsequent representation\n+\tclauses for the type.\n+\n+2017-09-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Direct_Name.Undefined): Do\n+\tnot add entries into the undefined reference table when we are\n+\tcompiling with errors ignored.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Check_Formal_Packages): Do not apply conformance\n+\tcheck if the instance is within an enclosing instance body. The\n+\tformal package was legal in the enclosing generic, and is\n+\tlegal in the enclosing instantiation.  This optimisation may be\n+\tapplicable elsewhere, and it also removes spurious errors that\n+\tmay arise with on-the-fly processing  of instantiations that\n+\tcontain Inline_Always subprograms.\n+\n+2017-09-08  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: Disregard empty argument of GNAT driver.\n+\n+2017-09-08  Justin Squirek  <squirek@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Manually decorate\n+\tthe generated temporary for range valdity checks.\n+\n+2017-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* usage.adb (Usage): Document new -gnatw.q/-gnatw.Q switches.\n+\n+2017-09-08  Justin Squirek  <squirek@adacore.com>\n+\n+\t* switch-c.adb (Scan_Front_End_Switches): Add new warning switch\n+\tcase to handle underscore flags.\n+\t* warnsw.adb, warnsw.ads (Set_Underscore_Warning_Switch): Create\n+\tnew procedure to handle underscores.\n+\n 2017-09-08  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Op_Divide): Reordering code that handles"}, {"sha": "322f9915f6e63018dbea60d2d6a01ee1b51bcc51", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -647,11 +647,13 @@ package body Ada.Tags is\n       Res : Tag := null;\n \n    begin\n-      --  Raise Tag_Error for empty strings, and for absurdly long strings.\n-      --  This is to make T'Class'Input robust in the case of bad data, for\n-      --  example a String(123456789..1234). The limit of 10,000 characters is\n-      --  arbitrary, but is unlikely to be exceeded by legitimate external tag\n-      --  names.\n+      --  Raise Tag_Error for empty strings and very long strings. This makes\n+      --  T'Class'Input robust in the case of bad data, for example\n+      --\n+      --    String (123456789..1234)\n+      --\n+      --  The limit of 10,000 characters is arbitrary, but is unlikely to be\n+      --  exceeded by legitimate external tag names.\n \n       if External'Length not in 1 .. 10_000 then\n          raise Tag_Error;"}, {"sha": "8a542ad34dd4d5e0581687d1b362e09a074dbb7c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -7393,6 +7393,13 @@ package body Checks is\n          if Is_Variable (Exp) then\n             Var_Id := Make_Temporary (Loc, 'T', Exp);\n \n+            --  Because we could be dealing with a transient scope which would\n+            --  cause our object declaration to remain unanalyzed we must do\n+            --  some manual decoration.\n+\n+            Set_Ekind (Var_Id, E_Variable);\n+            Set_Etype (Var_Id, Typ);\n+\n             Insert_Action (Exp,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Var_Id,"}, {"sha": "61c6240965db10910ca7a7170da08b40b627d468", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -6275,7 +6275,7 @@ package body Exp_Aggr is\n               New_List (\n                 Make_Assignment_Statement (Loc,\n                   Name       => Target,\n-                  Expression => New_Copy (N)));\n+                  Expression => New_Copy_Tree (N)));\n \n          else\n             Aggr_Code :="}, {"sha": "9afb23be02eb31c7789b941b0a8ac0ddc7181189", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -3868,14 +3868,16 @@ package body Exp_Attr is\n                         New_Occurrence_Of (RTE (RE_Descendant_Tag), Loc),\n                       Parameter_Associations => New_List (\n                         Make_Function_Call (Loc,\n-                          Name =>\n+                          Name                   =>\n                             New_Occurrence_Of\n                               (RTE (RE_String_Input_Tag), Loc),\n                           Parameter_Associations => New_List (\n                             Relocate_Node (Duplicate_Subexpr (Strm)))),\n+\n                         Make_Attribute_Reference (Loc,\n                           Prefix         => New_Occurrence_Of (P_Type, Loc),\n                           Attribute_Name => Name_Tag)));\n+\n                   Set_Etype (Expr, RTE (RE_Tag));\n \n                   --  Now we need to get the entity for the call, and construct"}, {"sha": "61d00aa68d375e6937ebea8b4e7ff285c930eddb", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -3194,7 +3194,7 @@ package body Exp_Ch4 is\n                 Object_Definition   => New_Occurrence_Of (Artyp, Loc),\n                 Expression          =>\n                   Make_Op_Add (Loc,\n-                    Left_Opnd  => New_Copy (Aggr_Length (NN - 1)),\n+                    Left_Opnd  => New_Copy_Tree (Aggr_Length (NN - 1)),\n                     Right_Opnd => Clen)));\n \n             Aggr_Length (NN) := Make_Identifier (Loc, Chars => Chars (Ent));\n@@ -3275,7 +3275,7 @@ package body Exp_Ch4 is\n             function Get_Known_Bound (J : Nat) return Node_Id is\n             begin\n                if Is_Fixed_Length (J) or else J = NN then\n-                  return New_Copy (Opnd_Low_Bound (J));\n+                  return New_Copy_Tree (Opnd_Low_Bound (J));\n \n                else\n                   return\n@@ -3288,7 +3288,7 @@ package body Exp_Ch4 is\n                           Right_Opnd =>\n                             Make_Integer_Literal (Loc, 0)),\n \n-                        New_Copy (Opnd_Low_Bound (J)),\n+                        New_Copy_Tree (Opnd_Low_Bound (J)),\n                         Get_Known_Bound (J + 1)));\n                end if;\n             end Get_Known_Bound;\n@@ -3313,10 +3313,10 @@ package body Exp_Ch4 is\n       High_Bound :=\n         To_Ityp\n           (Make_Op_Add (Loc,\n-             Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n+             Left_Opnd  => To_Artyp (New_Copy_Tree (Low_Bound)),\n              Right_Opnd =>\n                Make_Op_Subtract (Loc,\n-                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                 Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n                  Right_Opnd => Make_Artyp_Literal (1))));\n \n       --  Note that calculation of the high bound may cause overflow in some\n@@ -3341,7 +3341,7 @@ package body Exp_Ch4 is\n            Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n-                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                 Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n                  Right_Opnd => Make_Artyp_Literal (0)),\n                Last_Opnd_Low_Bound,\n                Low_Bound));\n@@ -3350,7 +3350,7 @@ package body Exp_Ch4 is\n            Make_If_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n-                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                 Left_Opnd  => New_Copy_Tree (Aggr_Length (NN)),\n                  Right_Opnd => Make_Artyp_Literal (0)),\n                Last_Opnd_High_Bound,\n                High_Bound));\n@@ -3488,12 +3488,12 @@ package body Exp_Ch4 is\n          declare\n             Lo : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n+                     Left_Opnd  => To_Artyp (New_Copy_Tree (Low_Bound)),\n                      Right_Opnd => Aggr_Length (J - 1));\n \n             Hi : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n+                     Left_Opnd  => To_Artyp (New_Copy_Tree (Low_Bound)),\n                      Right_Opnd =>\n                        Make_Op_Subtract (Loc,\n                          Left_Opnd  => Aggr_Length (J),\n@@ -7015,7 +7015,7 @@ package body Exp_Ch4 is\n \n          if Debug_Flag_Dot_H then\n             declare\n-               Cnod : constant Node_Id   := Relocate_Node (Cnode);\n+               Cnod : constant Node_Id   := New_Copy_Tree (Cnode);\n                Typ  : constant Entity_Id := Base_Type (Etype (Cnode));\n \n             begin\n@@ -11232,9 +11232,9 @@ package body Exp_Ch4 is\n          --  Apply an accessibility check when the conversion operand is an\n          --  access parameter (or a renaming thereof), unless conversion was\n          --  expanded from an Unchecked_ or Unrestricted_Access attribute,\n-         --  or for the actual of a class-wide interface parameter.\n-         --  Note that other checks may still need to be applied below (such\n-         --  as tagged type checks).\n+         --  or for the actual of a class-wide interface parameter. Note that\n+         --  other checks may still need to be applied below (such as tagged\n+         --  type checks).\n \n          elsif Is_Entity_Name (Operand)\n            and then Has_Extra_Accessibility (Entity (Operand))\n@@ -11243,9 +11243,8 @@ package body Exp_Ch4 is\n                       or else Attribute_Name (Original_Node (N)) = Name_Access)\n          then\n             if not Comes_From_Source (N)\n-              and then Nkind_In (Parent (N),\n-                N_Function_Call,\n-                N_Procedure_Call_Statement)\n+              and then Nkind_In (Parent (N), N_Function_Call,\n+                                             N_Procedure_Call_Statement)\n               and then Is_Interface (Designated_Type (Target_Type))\n               and then Is_Class_Wide_Type (Designated_Type (Target_Type))\n             then"}, {"sha": "c2edde696f7d87bd7ecc43ba282566861551117c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -2857,7 +2857,8 @@ package body Exp_Ch6 is\n             Thunk_Formal  := Extra_Formals (Current_Scope);\n             while Present (Target_Formal) loop\n                Add_Extra_Actual\n-                 (New_Occurrence_Of (Thunk_Formal, Loc), Thunk_Formal);\n+                 (Expr => New_Occurrence_Of (Thunk_Formal, Loc),\n+                  EF   => Thunk_Formal);\n \n                Target_Formal := Extra_Formal (Target_Formal);\n                Thunk_Formal  := Extra_Formal (Thunk_Formal);\n@@ -2922,15 +2923,15 @@ package body Exp_Ch6 is\n               and then not Has_Discriminants (Base_Type (Etype (Prev)))\n             then\n                Add_Extra_Actual\n-                 (New_Occurrence_Of (Standard_False, Loc),\n-                  Extra_Constrained (Formal));\n+                 (Expr => New_Occurrence_Of (Standard_False, Loc),\n+                  EF   => Extra_Constrained (Formal));\n \n             elsif Is_Constrained (Etype (Formal))\n               or else not Has_Discriminants (Etype (Prev))\n             then\n                Add_Extra_Actual\n-                 (New_Occurrence_Of (Standard_True, Loc),\n-                  Extra_Constrained (Formal));\n+                 (Expr => New_Occurrence_Of (Standard_True, Loc),\n+                  EF   => Extra_Constrained (Formal));\n \n             --  Do not produce extra actuals for Unchecked_Union parameters.\n             --  Jump directly to the end of the loop.\n@@ -2967,17 +2968,18 @@ package body Exp_Ch6 is\n                     and then Nkind (Act_Prev) = N_Explicit_Dereference\n                   then\n                      Add_Extra_Actual\n-                       (New_Occurrence_Of (Standard_False, Loc),\n-                        Extra_Constrained (Formal));\n+                       (Expr => New_Occurrence_Of (Standard_False, Loc),\n+                        EF   => Extra_Constrained (Formal));\n \n                   else\n                      Add_Extra_Actual\n-                       (Make_Attribute_Reference (Sloc (Prev),\n-                        Prefix =>\n-                          Duplicate_Subexpr_No_Checks\n-                            (Act_Prev, Name_Req => True),\n-                        Attribute_Name => Name_Constrained),\n-                        Extra_Constrained (Formal));\n+                       (Expr =>\n+                          Make_Attribute_Reference (Sloc (Prev),\n+                            Prefix         =>\n+                              Duplicate_Subexpr_No_Checks\n+                                (Act_Prev, Name_Req => True),\n+                            Attribute_Name => Name_Constrained),\n+                        EF   => Extra_Constrained (Formal));\n                   end if;\n                end;\n             end if;\n@@ -3046,8 +3048,9 @@ package body Exp_Ch6 is\n                   end if;\n \n                   Add_Extra_Actual\n-                    (New_Occurrence_Of (Extra_Accessibility (Parm_Ent), Loc),\n-                     Extra_Accessibility (Formal));\n+                    (Expr =>\n+                       New_Occurrence_Of (Extra_Accessibility (Parm_Ent), Loc),\n+                     EF   => Extra_Accessibility (Formal));\n                end;\n \n             elsif Is_Entity_Name (Prev_Orig) then\n@@ -3078,9 +3081,10 @@ package body Exp_Ch6 is\n \n                      if Present (Extra_Accessibility (Parm_Ent)) then\n                         Add_Extra_Actual\n-                          (New_Occurrence_Of\n-                             (Extra_Accessibility (Parm_Ent), Loc),\n-                           Extra_Accessibility (Formal));\n+                          (Expr =>\n+                             New_Occurrence_Of\n+                               (Extra_Accessibility (Parm_Ent), Loc),\n+                           EF   => Extra_Accessibility (Formal));\n \n                      --  If the actual access parameter does not have an\n                      --  associated extra formal providing its scope level,\n@@ -3089,9 +3093,10 @@ package body Exp_Ch6 is\n \n                      else\n                         Add_Extra_Actual\n-                          (Make_Integer_Literal (Loc,\n-                             Intval => Scope_Depth (Standard_Standard)),\n-                           Extra_Accessibility (Formal));\n+                          (Expr =>\n+                             Make_Integer_Literal (Loc,\n+                               Intval => Scope_Depth (Standard_Standard)),\n+                           EF   => Extra_Accessibility (Formal));\n                      end if;\n                   end;\n \n@@ -3100,8 +3105,8 @@ package body Exp_Ch6 is\n \n                else\n                   Add_Extra_Actual\n-                    (Dynamic_Accessibility_Level (Prev_Orig),\n-                     Extra_Accessibility (Formal));\n+                    (Expr => Dynamic_Accessibility_Level (Prev_Orig),\n+                     EF   => Extra_Accessibility (Formal));\n                end if;\n \n             --  If the actual is an access discriminant, then pass the level\n@@ -3114,9 +3119,10 @@ package body Exp_Ch6 is\n                                                        E_Anonymous_Access_Type\n             then\n                Add_Extra_Actual\n-                 (Make_Integer_Literal (Loc,\n-                    Intval => Object_Access_Level (Prefix (Prev_Orig))),\n-                  Extra_Accessibility (Formal));\n+                 (Expr =>\n+                    Make_Integer_Literal (Loc,\n+                      Intval => Object_Access_Level (Prefix (Prev_Orig))),\n+                  EF   => Extra_Accessibility (Formal));\n \n             --  All other cases\n \n@@ -3129,19 +3135,18 @@ package body Exp_Ch6 is\n \n                         when Attribute_Access =>\n \n-                           --  Accessibility level of S'Access is that of A.\n+                           --  Accessibility level of S'Access is that of A\n \n                            Prev_Orig := Prefix (Prev_Orig);\n \n-                           --  If the expression is a view conversion,\n-                           --  the accessibility level is that of the\n-                           --  expression.\n+                           --  If the expression is a view conversion, the\n+                           --  accessibility level is that of the expression.\n \n-                           if Nkind (Original_Node (Prev_Orig))\n-                             = N_Type_Conversion\n+                           if Nkind (Original_Node (Prev_Orig)) =\n+                                N_Type_Conversion\n                              and then\n-                               Nkind (Expression (Original_Node (Prev_Orig)))\n-                                  = N_Explicit_Dereference\n+                               Nkind (Expression (Original_Node (Prev_Orig))) =\n+                                 N_Explicit_Dereference\n                            then\n                               Prev_Orig :=\n                                 Expression (Original_Node (Prev_Orig));\n@@ -3171,8 +3176,7 @@ package body Exp_Ch6 is\n                               Pref_Entity := Entity (Prev_Orig);\n \n                            elsif Nkind (Prev_Orig) = N_Explicit_Dereference\n-                           and then\n-                              Is_Entity_Name (Prefix (Prev_Orig))\n+                             and then Is_Entity_Name (Prefix (Prev_Orig))\n                            then\n                               Pref_Entity := Entity (Prefix ((Prev_Orig)));\n \n@@ -3184,28 +3188,31 @@ package body Exp_Ch6 is\n                              and then Is_Type (Entity (Prev_Orig))\n                            then\n                               Add_Extra_Actual\n-                                (Make_Integer_Literal (Loc,\n-                                   Intval => Type_Access_Level (Pref_Entity)),\n-                                 Extra_Accessibility (Formal));\n+                                (Expr =>\n+                                   Make_Integer_Literal (Loc,\n+                                     Intval =>\n+                                       Type_Access_Level (Pref_Entity)),\n+                                 EF   => Extra_Accessibility (Formal));\n \n                            elsif Nkind (Prev_Orig) = N_Explicit_Dereference\n                              and then Present (Pref_Entity)\n                              and then Is_Formal (Pref_Entity)\n                              and then Present\n-                               (Extra_Accessibility (Pref_Entity))\n+                                        (Extra_Accessibility (Pref_Entity))\n                            then\n-                              Add_Extra_Actual (\n-                                New_Occurrence_Of\n-                                 (Extra_Accessibility (Pref_Entity), Loc),\n-                                 Extra_Accessibility (Formal));\n+                              Add_Extra_Actual\n+                                (Expr =>\n+                                   New_Occurrence_Of\n+                                     (Extra_Accessibility (Pref_Entity), Loc),\n+                                 EF   => Extra_Accessibility (Formal));\n \n                            else\n                               Add_Extra_Actual\n-                                (Make_Integer_Literal (Loc,\n-                                   Intval =>\n-                                     Object_Access_Level\n-                                       (Prev_Orig)),\n-                                 Extra_Accessibility (Formal));\n+                                (Expr =>\n+                                   Make_Integer_Literal (Loc,\n+                                     Intval =>\n+                                       Object_Access_Level (Prev_Orig)),\n+                                 EF   => Extra_Accessibility (Formal));\n                            end if;\n \n                         --  Treat the unchecked attributes as library-level\n@@ -3214,9 +3221,10 @@ package body Exp_Ch6 is\n                            | Attribute_Unrestricted_Access\n                         =>\n                            Add_Extra_Actual\n-                             (Make_Integer_Literal (Loc,\n-                                Intval => Scope_Depth (Standard_Standard)),\n-                              Extra_Accessibility (Formal));\n+                             (Expr =>\n+                                Make_Integer_Literal (Loc,\n+                                  Intval => Scope_Depth (Standard_Standard)),\n+                              EF   => Extra_Accessibility (Formal));\n \n                         --  No other cases of attributes returning access\n                         --  values that can be passed to access parameters.\n@@ -3232,9 +3240,10 @@ package body Exp_Ch6 is\n \n                   when N_Allocator =>\n                      Add_Extra_Actual\n-                       (Make_Integer_Literal (Loc,\n-                          Intval => Scope_Depth (Current_Scope) + 1),\n-                        Extra_Accessibility (Formal));\n+                       (Expr =>\n+                          Make_Integer_Literal (Loc,\n+                            Intval => Scope_Depth (Current_Scope) + 1),\n+                        EF   => Extra_Accessibility (Formal));\n \n                   --  For most other cases we simply pass the level of the\n                   --  actual's access type. The type is retrieved from\n@@ -3244,8 +3253,8 @@ package body Exp_Ch6 is\n \n                   when others =>\n                      Add_Extra_Actual\n-                       (Dynamic_Accessibility_Level (Prev),\n-                        Extra_Accessibility (Formal));\n+                       (Expr => Dynamic_Accessibility_Level (Prev),\n+                        EF   => Extra_Accessibility (Formal));\n                end case;\n             end if;\n          end if;\n@@ -3572,8 +3581,9 @@ package body Exp_Ch6 is\n                end if;\n \n                Add_Extra_Actual\n-                 (Level,\n-                  Extra_Accessibility_Of_Result (Ultimate_Alias (Subp)));\n+                 (Expr => Level,\n+                  EF   =>\n+                    Extra_Accessibility_Of_Result (Ultimate_Alias (Subp)));\n             end if;\n          end;\n       end if;"}, {"sha": "8dadc9c355dc94f967a9de96e6c3eeec253f274d", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -394,7 +394,7 @@ begin\n       begin\n          --  Check if an argument file is specified\n \n-         if The_Arg (The_Arg'First) = '@' then\n+         if The_Arg'Length > 0 and then The_Arg (The_Arg'First) = '@' then\n             declare\n                Arg_File : Ada.Text_IO.File_Type;\n                Line     : String (1 .. 256);\n@@ -432,7 +432,7 @@ begin\n                Close (Arg_File);\n             end;\n \n-         else\n+         elsif The_Arg'Length > 0 then\n             --  It is not an argument file; just put the argument in\n             --  the Last_Switches table.\n "}, {"sha": "ea020653e970aca895b0f4f58cd91b27f032f74f", "filename": "gcc/ada/s-ststop.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fs-ststop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fs-ststop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-ststop.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -133,9 +133,10 @@ package body System.Strings.Stream_Ops is\n          Max_Length : Long_Integer := Long_Integer'Last) return Array_Type\n       is\n          pragma Unsuppress (All_Checks);\n-         --  To make T'Class'Input robust in the case of bad data. The\n+         --  The above makes T'Class'Input robust in the case of bad data. The\n          --  declaration of Item below could raise Storage_Error if the length\n-         --  is huge.\n+         --  is too big.\n+\n       begin\n          if Strm = null then\n             raise Constraint_Error;"}, {"sha": "9022bae3c553fc0913f53c666eb9a0b567fde62a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -6419,7 +6419,18 @@ package body Sem_Ch12 is\n \n                else\n                   Formal_P := Next_Entity (E);\n-                  Check_Formal_Package_Instance (Formal_P, E);\n+\n+                  --  If the instance is within an enclosing instance body\n+                  --  there is no need to vertify the legqlity of current\n+                  --  formsl psckages because they were legal in the generic\n+                  --  body. This optimixation may be applicable elsewhere,\n+                  --  and it also removes spurious errors that may arise with\n+                  --  on-the-fly inlining and confusion between private and\n+                  --  full views.\n+\n+                  if not In_Instance_Body then\n+                     Check_Formal_Package_Instance (Formal_P, E);\n+                  end if;\n \n                   --  After checking, remove the internal validating package.\n                   --  It is only needed for semantic checks, and as it may"}, {"sha": "a263c1f7a5985d52cba9cc152173edda8fbeddf8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -12800,6 +12800,15 @@ package body Sem_Ch13 is\n                         end;\n                      end if;\n \n+                  --  The expression for Default_Value is a static expression\n+                  --  of the type, but this expression does not freeze the\n+                  --  type, so it can still appear in a representation clause\n+                  --  before the actual freeze point.\n+\n+                  when Aspect_Default_Value =>\n+                     Set_Must_Not_Freeze (Expr);\n+                     Preanalyze_Spec_Expression (Expr, E);\n+\n                   when others =>\n                      if Present (Expr) then\n                         case Aspect_Argument (A_Id) is"}, {"sha": "f6ddc7f5edbbca4039953022ab1d39123a0b690a", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -5328,9 +5328,10 @@ package body Sem_Ch8 is\n          --  Make entry in undefined references table unless the full errors\n          --  switch is set, in which case by refraining from generating the\n          --  table entry, we guarantee that we get an error message for every\n-         --  undefined reference.\n+         --  undefined reference. The entry is not added if we are ignoring\n+         --  errors.\n \n-         if not All_Errors_Mode then\n+         if not All_Errors_Mode and then Ignore_Errors_Enable = 0 then\n             Urefs.Append (\n               (Node => N,\n                Err  => Emsg,"}, {"sha": "668b76087662dd936f7470bbe5cbcb48d9f31da2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -3425,7 +3425,7 @@ package body Sem_Prag is\n             if No (N) then\n                declare\n                   Pack : constant Node_Id :=\n-                    Parent (Declaration_Node (Encap_Id));\n+                           Parent (Declaration_Node (Encap_Id));\n                begin\n                   if Nkind (Pack) = N_Package_Specification\n                     and then not In_Private_Part (Encap_Id)"}, {"sha": "7e2dbe24757c537b32636c2bcf01814000597a3c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1187, "deletions": 610, "changes": 1797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -11715,6 +11715,26 @@ package body Sem_Util is\n       end loop;\n    end In_Subprogram_Or_Concurrent_Unit;\n \n+   ----------------\n+   -- In_Subtree --\n+   ----------------\n+\n+   function In_Subtree (Root : Node_Id; N : Node_Id) return Boolean is\n+      Curr : Node_Id;\n+\n+   begin\n+      Curr := N;\n+      while Present (Curr) loop\n+         if Curr = Root then\n+            return True;\n+         end if;\n+\n+         Curr := Parent (Curr);\n+      end loop;\n+\n+      return False;\n+   end In_Subtree;\n+\n    ---------------------\n    -- In_Visible_Part --\n    ---------------------\n@@ -17278,72 +17298,70 @@ package body Sem_Util is\n       end if;\n    end New_Copy_List_Tree;\n \n-   --------------------------------------------------\n-   -- New_Copy_Tree Auxiliary Data and Subprograms --\n-   --------------------------------------------------\n-\n-   use Atree.Unchecked_Access;\n-   use Atree_Private_Part;\n+   -------------------\n+   -- New_Copy_Tree --\n+   -------------------\n \n-   --  Our approach here requires a two pass traversal of the tree. The\n-   --  first pass visits all nodes that eventually will be copied looking\n-   --  for defining Itypes. If any defining Itypes are found, then they are\n-   --  copied, and an entry is added to the replacement map. In the second\n-   --  phase, the tree is copied, using the replacement map to replace any\n-   --  Itype references within the copied tree.\n+   --  The following tables play a key role in replicating entities and Itypes.\n+   --  They are intentionally declared at the library level rather than within\n+   --  New_Copy_Tree to avoid elaborating them on each call. This performance\n+   --  optimization saves up to 2% of the entire compilation time spent in the\n+   --  front end. Care should be taken to reset the tables on each new call to\n+   --  New_Copy_Tree.\n \n-   --  The following hash tables are used to speed up access to the map. They\n-   --  are declared at library level to avoid elaborating them for every call\n-   --  to New_Copy_Tree. This can save up to 2% of the entire compilation time\n-   --  spent in the front end.\n+   NCT_Table_Max : constant := 511;\n \n-   subtype NCT_Header_Num is Int range 0 .. 511;\n-   --  Defines range of headers in hash tables (512 headers)\n+   subtype NCT_Table_Index is Nat range 0 .. NCT_Table_Max - 1;\n \n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n-   --  Hash function used for hash operations\n+   function NCT_Table_Hash (Key : Node_Or_Entity_Id) return NCT_Table_Index;\n+   --  Obtain the hash value of node or entity Key\n \n-   -------------------\n-   -- New_Copy_Hash --\n-   -------------------\n+   --------------------\n+   -- NCT_Table_Hash --\n+   --------------------\n \n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n+   function NCT_Table_Hash (Key : Node_Or_Entity_Id) return NCT_Table_Index is\n    begin\n-      return Nat (E) mod (NCT_Header_Num'Last + 1);\n-   end New_Copy_Hash;\n+      return NCT_Table_Index (Key mod NCT_Table_Max);\n+   end NCT_Table_Hash;\n \n-   ---------------\n-   -- NCT_Assoc --\n-   ---------------\n+   ----------------------\n+   -- NCT_New_Entities --\n+   ----------------------\n \n-   --  The hash table NCT_Assoc associates old entities in the table with their\n-   --  corresponding new entities (i.e. the pairs of entries presented in the\n-   --  original Map argument are Key-Element pairs).\n+   --  The following table maps old entities and Itypes to their corresponding\n+   --  new entities and Itypes.\n \n-   package NCT_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n+   --    Aaa -> Xxx\n+\n+   package NCT_New_Entities is new Simple_HTable (\n+     Header_Num => NCT_Table_Index,\n      Element    => Entity_Id,\n      No_Element => Empty,\n      Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n+     Hash       => NCT_Table_Hash,\n+     Equal      => \"=\");\n \n-   ---------------------\n-   -- NCT_Itype_Assoc --\n-   ---------------------\n+   ------------------------\n+   -- NCT_Pending_Itypes --\n+   ------------------------\n \n-   --  The hash table NCT_Itype_Assoc contains entries only for those old\n-   --  nodes which have a non-empty Associated_Node_For_Itype set. The key\n-   --  is the associated node, and the element is the new node itself (NOT\n-   --  the associated node for the new node).\n+   --  The following table maps old Associated_Node_For_Itype nodes to a set of\n+   --  new itypes. Given a set of old Itypes Aaa, Bbb, and Ccc, where all three\n+   --  have the same Associated_Node_For_Itype Ppp, and their corresponding new\n+   --  Itypes Xxx, Yyy, Zzz, the table contains the following mapping:\n \n-   package NCT_Itype_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n-     Element    => Node_Or_Entity_Id,\n-     No_Element => Empty,\n-     Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n+   --    Ppp -> (Xxx, Yyy, Zzz)\n+\n+   --  The set is expressed as an Elist\n+\n+   package NCT_Pending_Itypes is new Simple_HTable (\n+     Header_Num => NCT_Table_Index,\n+     Element    => Elist_Id,\n+     No_Element => No_Elist,\n+     Key        => Node_Id,\n+     Hash       => NCT_Table_Hash,\n+     Equal      => \"=\");\n \n    -------------------\n    -- New_Copy_Tree --\n@@ -17355,527 +17373,910 @@ package body Sem_Util is\n       New_Sloc  : Source_Ptr := No_Location;\n       New_Scope : Entity_Id  := Empty) return Node_Id\n    is\n+      --  This routine performs low-level tree manipulations and needs access\n+      --  to the internals of the tree.\n+\n+      use Atree.Unchecked_Access;\n+      use Atree_Private_Part;\n+\n       EWA_Level : Nat := 0;\n-      --  By default, copying of defining identifiers is prohibited because\n-      --  this would introduce an entirely new entity into the tree. The\n-      --  exception to this general rule is declaration of constants and\n-      --  variables located in Expression_With_Action nodes.\n+      --  This counter keeps track of how many N_Expression_With_Actions nodes\n+      --  are encountered during a depth-first traversal of the subtree. These\n+      --  nodes may define new entities in their Actions lists and thus require\n+      --  special processing.\n \n       EWA_Inner_Scope_Level : Nat := 0;\n-      --  Level of internal scope of defined in EWAs. Used to avoid creating\n-      --  variables for declarations located in blocks or subprograms defined\n-      --  in Expression_With_Action nodes.\n-\n-      NCT_Hash_Tables_Used : Boolean := False;\n-      --  Set to True if hash tables are in use. It is intended to speed up the\n-      --  common case, which is no hash tables in use. This can save up to 8%\n-      --  of the entire compilation time spent in the front end.\n+      --  This counter keeps track of how many scoping constructs appear within\n+      --  an N_Expression_With_Actions node.\n+\n+      NCT_Tables_In_Use : Boolean := False;\n+      --  This flag keeps track of whether the two tables NCT_New_Entities and\n+      --  NCT_Pending_Itypes are in use. The flag is part of an optimization\n+      --  where certain operations are not performed if the tables are not in\n+      --  use. This saves up to 8% of the entire compilation time spent in the\n+      --  front end.\n+\n+      procedure Add_New_Entity (Old_Id : Entity_Id; New_Id : Entity_Id);\n+      pragma Inline (Add_New_Entity);\n+      --  Add an entry in the NCT_New_Entities table which maps key Old_Id to\n+      --  value New_Id. Old_Id is an entity which appears within the Actions\n+      --  list of an N_Expression_With_Actions node, or within an entity map.\n+      --  New_Id is the corresponding new entity generated during Phase 1.\n+\n+      procedure Add_Pending_Itype (Assoc_Nod : Node_Id; Itype : Entity_Id);\n+      pragma Inline (Add_New_Entity);\n+      --  Add an entry in the NCT_Pending_Itypes which maps key Assoc_Nod to\n+      --  value Itype. Assoc_Nod is the associated node of an itype. Itype is\n+      --  an itype.\n+\n+      procedure Build_NCT_Tables (Entity_Map : Elist_Id);\n+      pragma Inline (Build_NCT_Tables);\n+      --  Populate tables NCT_New_Entities and NCT_Pending_Itypes with the\n+      --  information supplied in entity map Entity_Map. The format of the\n+      --  entity map must be as follows:\n+      --\n+      --    Old_Id1, New_Id1, Old_Id2, New_Id2, .., Old_IdN, New_IdN\n \n-      function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n-      --  Called during second phase to map entities into their corresponding\n-      --  copies using the hash table. If the argument is not an entity, or is\n-      --  not in the hash table, then it is returned unchanged.\n+      function Copy_Any_Node_With_Replacement\n+        (N : Node_Or_Entity_Id) return Node_Or_Entity_Id;\n+      pragma Inline (Copy_Any_Node_With_Replacement);\n+      --  Replicate entity or node N by invoking one of the following routines:\n+      --\n+      --    Copy_Node_With_Replacement\n+      --    Corresponding_Entity\n+\n+      function Copy_Elist_With_Replacement (List : Elist_Id) return Elist_Id;\n+      --  Replicate the elements of entity list List\n+\n+      function Copy_Field_With_Replacement\n+        (Field    : Union_Id;\n+         Old_Par  : Node_Id := Empty;\n+         New_Par  : Node_Id := Empty;\n+         Semantic : Boolean := False) return Union_Id;\n+      --  Replicate field Field by invoking one of the following routines:\n+      --\n+      --    Copy_Elist_With_Replacement\n+      --    Copy_List_With_Replacement\n+      --    Copy_Node_With_Replacement\n+      --    Corresponding_Entity\n+      --\n+      --  If the field is not an entity list, entity, itype, syntactic list,\n+      --  or node, then the field is returned unchanged. The routine always\n+      --  replicates entities, itypes, and valid syntactic fields. Old_Par is\n+      --  the expected parent of a syntactic field. New_Par is the new parent\n+      --  associated with a replicated syntactic field. Flag Semantic should\n+      --  be set when the input is a semantic field.\n+\n+      function Copy_List_With_Replacement (List : List_Id) return List_Id;\n+      --  Replicate the elements of syntactic list List\n+\n+      function Copy_Node_With_Replacement (N : Node_Id) return Node_Id;\n+      --  Replicate node N\n+\n+      function Corresponding_Entity (Id : Entity_Id) return Entity_Id;\n+      pragma Inline (Corresponding_Entity);\n+      --  Return the corresponding new entity of Id generated during Phase 1.\n+      --  If there is no such entity, return Id.\n+\n+      function In_Entity_Map\n+        (Id         : Entity_Id;\n+         Entity_Map : Elist_Id) return Boolean;\n+      pragma Inline (In_Entity_Map);\n+      --  Determine whether entity Id is one of the old ids specified in entity\n+      --  map Entity_Map. The format of the entity map must be as follows:\n+      --\n+      --    Old_Id1, New_Id1, Old_Id2, New_Id2, .., Old_IdN, New_IdN\n+\n+      procedure Update_CFS_Sloc (N : Node_Or_Entity_Id);\n+      pragma Inline (Update_CFS_Sloc);\n+      --  Update the Comes_From_Source and Sloc attributes of node or entity N\n+\n+      procedure Update_First_Real_Statement\n+        (Old_HSS : Node_Id;\n+         New_HSS : Node_Id);\n+      pragma Inline (Update_First_Real_Statement);\n+      --  Update semantic attribute First_Real_Statement of handled sequence of\n+      --  statements New_HSS based on handled sequence of statements Old_HSS.\n+\n+      procedure Update_Named_Associations\n+        (Old_Call : Node_Id;\n+         New_Call : Node_Id);\n+      pragma Inline (Update_Named_Associations);\n+      --  Update semantic chain First/Next_Named_Association of call New_call\n+      --  based on call Old_Call.\n+\n+      procedure Update_New_Entities (Entity_Map : Elist_Id);\n+      pragma Inline (Update_New_Entities);\n+      --  Update the semantic attributes of all new entities generated during\n+      --  Phase 1 that do not appear in entity map Entity_Map. The format of\n+      --  the entity map must be as follows:\n+      --\n+      --    Old_Id1, New_Id1, Old_Id2, New_Id2, .., Old_IdN, New_IdN\n+\n+      procedure Update_Pending_Itypes\n+        (Old_Assoc : Node_Id;\n+         New_Assoc : Node_Id);\n+      pragma Inline (Update_Pending_Itypes);\n+      --  Update semantic attribute Associated_Node_For_Itype to refer to node\n+      --  New_Assoc for all itypes whose associated node is Old_Assoc.\n+\n+      procedure Update_Semantic_Fields (Id : Entity_Id);\n+      pragma Inline (Update_Semantic_Fields);\n+      --  Subsidiary to Update_New_Entities. Update semantic fields of entity\n+      --  or itype Id.\n+\n+      procedure Visit_Any_Node (N : Node_Or_Entity_Id);\n+      pragma Inline (Visit_Any_Node);\n+      --  Visit entity of node N by invoking one of the following routines:\n+      --\n+      --    Visit_Entity\n+      --    Visit_Itype\n+      --    Visit_Node\n+\n+      procedure Visit_Elist (List : Elist_Id);\n+      --  Visit the elements of entity list List\n+\n+      procedure Visit_Entity (Id : Entity_Id);\n+      --  Visit entity Id. This action may create a new entity of Id and save\n+      --  it in table NCT_New_Entities.\n+\n+      procedure Visit_Field\n+        (Field    : Union_Id;\n+         Par_Nod  : Node_Id := Empty;\n+         Semantic : Boolean := False);\n+      --  Visit field Field by invoking one of the following routines:\n+      --\n+      --    Visit_Elist\n+      --    Visit_Entity\n+      --    Visit_Itype\n+      --    Visit_List\n+      --    Visit_Node\n+      --\n+      --  If the field is not an entity list, entity, itype, syntactic list,\n+      --  or node, then the field is not visited. The routine always visits\n+      --  valid syntactic fields. Par_Nod is the expected parent of the\n+      --  syntactic field. Flag Semantic should be set when the input is a\n+      --  semantic field.\n \n-      procedure Build_NCT_Hash_Tables;\n-      --  Builds hash tables\n+      procedure Visit_Itype (Itype : Entity_Id);\n+      --  Visit itype Itype. This action may create a new entity for Itype and\n+      --  save it in table NCT_New_Entities. In addition, the routine may map\n+      --  the associated node of Itype to the new itype in NCT_Pending_Itypes.\n \n-      function Copy_Elist_With_Replacement\n-        (Old_Elist : Elist_Id) return Elist_Id;\n-      --  Called during second phase to copy element list doing replacements\n+      procedure Visit_List (List : List_Id);\n+      --  Visit the elements of syntactic list List\n \n-      procedure Copy_Entity_With_Replacement (New_Entity : Entity_Id);\n-      --  Called during the second phase to process a copied Entity. The actual\n-      --  copy happened during the first phase (so that we could make the entry\n-      --  in the mapping), but we still have to deal with the descendants of\n-      --  the copied Entity and copy them where necessary.\n+      procedure Visit_Node (N : Node_Id);\n+      --  Visit node N\n \n-      function Copy_List_With_Replacement (Old_List : List_Id) return List_Id;\n-      --  Called during second phase to copy list doing replacements\n+      procedure Visit_Semantic_Fields (Id : Entity_Id);\n+      pragma Inline (Visit_Semantic_Fields);\n+      --  Subsidiary to Visit_Entity and Visit_Itype. Visit common semantic\n+      --  fields of entity or itype Id.\n \n-      function Copy_Node_With_Replacement (Old_Node : Node_Id) return Node_Id;\n-      --  Called during second phase to copy node doing replacements\n+      --------------------\n+      -- Add_New_Entity --\n+      --------------------\n \n-      function In_Map (E : Entity_Id) return Boolean;\n-      --  Return True if E is one of the old entities specified in the set of\n-      --  mappings to be applied to entities in the tree (i.e. Map).\n+      procedure Add_New_Entity (Old_Id : Entity_Id; New_Id : Entity_Id) is\n+      begin\n+         pragma Assert (Present (Old_Id));\n+         pragma Assert (Present (New_Id));\n+         pragma Assert (Nkind (Old_Id) in N_Entity);\n+         pragma Assert (Nkind (New_Id) in N_Entity);\n \n-      procedure Visit_Elist (E : Elist_Id);\n-      --  Called during first phase to visit all elements of an Elist\n+         NCT_Tables_In_Use := True;\n \n-      procedure Visit_Entity (Old_Entity : Entity_Id);\n-      --  Called during first phase to visit subsidiary fields of a defining\n-      --  entity which is not an itype, and also create a copy and make an\n-      --  entry in the replacement map for the new copy.\n+         --  Sanity check the NCT_New_Entities table. No previous mapping with\n+         --  key Old_Id should exist.\n \n-      procedure Visit_Field (F : Union_Id; N : Node_Id);\n-      --  Visit a single field, recursing to call Visit_Node or Visit_List if\n-      --  the field is a syntactic descendant of the current node (i.e. its\n-      --  parent is Node N).\n+         pragma Assert (No (NCT_New_Entities.Get (Old_Id)));\n \n-      procedure Visit_Itype (Old_Itype : Entity_Id);\n-      --  Called during first phase to visit subsidiary fields of a defining\n-      --  Itype, and also create a copy and make an entry in the replacement\n-      --  map for the new copy.\n+         --  Establish the mapping\n \n-      procedure Visit_List (L : List_Id);\n-      --  Called during first phase to visit all elements of a List\n+         --    Old_Id -> New_Id\n \n-      procedure Visit_Node (N : Node_Or_Entity_Id);\n-      --  Called during first phase to visit a node and all its subtrees\n+         NCT_New_Entities.Set (Old_Id, New_Id);\n+      end Add_New_Entity;\n \n-      -----------\n-      -- Assoc --\n-      -----------\n+      -----------------------\n+      -- Add_Pending_Itype --\n+      -----------------------\n \n-      function Assoc (N : Node_Or_Entity_Id) return Node_Id is\n-         Ent : Entity_Id;\n+      procedure Add_Pending_Itype (Assoc_Nod : Node_Id; Itype : Entity_Id) is\n+         Itypes : Elist_Id;\n \n       begin\n-         if Nkind (N) not in N_Entity or else not NCT_Hash_Tables_Used then\n-            return N;\n+         pragma Assert (Present (Assoc_Nod));\n+         pragma Assert (Present (Itype));\n+         pragma Assert (Nkind (Itype) in N_Entity);\n+         pragma Assert (Is_Itype (Itype));\n \n-         else\n-            Ent := NCT_Assoc.Get (Entity_Id (N));\n+         NCT_Tables_In_Use := True;\n \n-            if Present (Ent) then\n-               return Ent;\n-            end if;\n+         --  It is not possible to sanity check the NCT_Pendint_Itypes table\n+         --  directly because a single node may act as the associated node for\n+         --  multiple itypes.\n+\n+         Itypes := NCT_Pending_Itypes.Get (Assoc_Nod);\n+\n+         if No (Itypes) then\n+            Itypes := New_Elmt_List;\n+            NCT_Pending_Itypes.Set (Assoc_Nod, Itypes);\n          end if;\n \n-         return N;\n-      end Assoc;\n+         --  Establish the mapping\n \n-      ---------------------------\n-      -- Build_NCT_Hash_Tables --\n-      ---------------------------\n+         --    Assoc_Nod -> (Itype, ...)\n+\n+         --  Avoid inserting the same itype multiple times. This involves a\n+         --  linear search, however the set of itypes with the same associated\n+         --  node is very small.\n \n-      procedure Build_NCT_Hash_Tables is\n-         Assoc : Entity_Id;\n-         Elmt  : Elmt_Id;\n-         Key   : Entity_Id;\n-         Value : Entity_Id;\n+         Append_Unique_Elmt (Itype, Itypes);\n+      end Add_Pending_Itype;\n+\n+      ----------------------\n+      -- Build_NCT_Tables --\n+      ----------------------\n+\n+      procedure Build_NCT_Tables (Entity_Map : Elist_Id) is\n+         Elmt   : Elmt_Id;\n+         Old_Id : Entity_Id;\n+         New_Id : Entity_Id;\n \n       begin\n-         if No (Map) then\n+         --  Nothing to do when there is no entity map\n+\n+         if No (Entity_Map) then\n             return;\n          end if;\n \n-         --  Clear both hash tables associated with entry replication since\n-         --  multiple calls to New_Copy_Tree could cause multiple collisions\n-         --  and produce long linked lists in individual buckets.\n-\n-         NCT_Assoc.Reset;\n-         NCT_Itype_Assoc.Reset;\n-\n-         Elmt := First_Elmt (Map);\n+         Elmt := First_Elmt (Entity_Map);\n          while Present (Elmt) loop\n \n-            --  Extract a (key, value) pair from the map\n+            --  Extract the (Old_Id, New_Id) pair from the entity map\n \n-            Key := Node (Elmt);\n+            Old_Id := Node (Elmt);\n             Next_Elmt (Elmt);\n-            Value := Node (Elmt);\n \n-            --  Add the pair in the association hash table\n+            New_Id := Node (Elmt);\n+            Next_Elmt (Elmt);\n \n-            NCT_Assoc.Set (Key, Value);\n+            --  Establish the following mapping within table NCT_New_Entities\n \n-            --  Add a link between the associated node of the old Itype and the\n-            --  new Itype, for updating later when node is copied.\n+            --    Old_Id -> New_Id\n \n-            if Is_Type (Key) then\n-               Assoc := Associated_Node_For_Itype (Key);\n+            Add_New_Entity (Old_Id, New_Id);\n \n-               if Present (Assoc) then\n-                  NCT_Itype_Assoc.Set (Assoc, Value);\n-               end if;\n-            end if;\n+            --  Establish the following mapping within table NCT_Pending_Itypes\n+            --  when the new entity is an itype.\n \n-            Next_Elmt (Elmt);\n+            --    Assoc_Nod -> (New_Id, ...)\n+\n+            --  IMPORTANT: the associated node is that of the old itype because\n+            --  the node will be replicated in Phase 2.\n+\n+            if Is_Itype (Old_Id) then\n+               Add_Pending_Itype\n+                 (Assoc_Nod => Associated_Node_For_Itype (Old_Id),\n+                  Itype     => New_Id);\n+            end if;\n          end loop;\n+      end Build_NCT_Tables;\n \n-         NCT_Hash_Tables_Used := True;\n-      end Build_NCT_Hash_Tables;\n+      ------------------------------------\n+      -- Copy_Any_Node_With_Replacement --\n+      ------------------------------------\n+\n+      function Copy_Any_Node_With_Replacement\n+        (N : Node_Or_Entity_Id) return Node_Or_Entity_Id\n+      is\n+      begin\n+         if Nkind (N) in N_Entity then\n+            return Corresponding_Entity (N);\n+         else\n+            return Copy_Node_With_Replacement (N);\n+         end if;\n+      end Copy_Any_Node_With_Replacement;\n \n       ---------------------------------\n       -- Copy_Elist_With_Replacement --\n       ---------------------------------\n \n-      function Copy_Elist_With_Replacement\n-        (Old_Elist : Elist_Id) return Elist_Id\n-      is\n-         M         : Elmt_Id;\n-         New_Elist : Elist_Id;\n+      function Copy_Elist_With_Replacement (List : Elist_Id) return Elist_Id is\n+         Elmt   : Elmt_Id;\n+         Result : Elist_Id;\n \n       begin\n-         if No (Old_Elist) then\n-            return No_Elist;\n+         --  Copy the contents of the old list. Note that the list itself may\n+         --  be empty, in which case the routine returns a new empty list. This\n+         --  avoids sharing lists between subtrees. The element of an entity\n+         --  list could be an entity or a node, hence the invocation of routine\n+         --  Copy_Any_Node_With_Replacement.\n \n-         else\n-            New_Elist := New_Elmt_List;\n+         if Present (List) then\n+            Result := New_Elmt_List;\n \n-            M := First_Elmt (Old_Elist);\n-            while Present (M) loop\n-               Append_Elmt (Copy_Node_With_Replacement (Node (M)), New_Elist);\n-               Next_Elmt (M);\n+            Elmt := First_Elmt (List);\n+            while Present (Elmt) loop\n+               Append_Elmt\n+                 (Copy_Any_Node_With_Replacement (Node (Elmt)), Result);\n+\n+               Next_Elmt (Elmt);\n             end loop;\n+\n+         --  Otherwise the list does not exist\n+\n+         else\n+            Result := No_Elist;\n          end if;\n \n-         return New_Elist;\n+         return Result;\n       end Copy_Elist_With_Replacement;\n \n-      ----------------------------------\n-      -- Copy_Entity_With_Replacement --\n-      ----------------------------------\n-\n-      --  This routine exactly parallels its phase one analog Visit_Itype\n+      ---------------------------------\n+      -- Copy_Field_With_Replacement --\n+      ---------------------------------\n \n-      procedure Copy_Entity_With_Replacement (New_Entity : Entity_Id) is\n+      function Copy_Field_With_Replacement\n+        (Field    : Union_Id;\n+         Old_Par  : Node_Id := Empty;\n+         New_Par  : Node_Id := Empty;\n+         Semantic : Boolean := False) return Union_Id\n+      is\n       begin\n-         --  Translate Next_Entity, Scope, and Etype fields, in case they\n-         --  reference entities that have been mapped into copies.\n+         --  The field is empty\n \n-         Set_Next_Entity (New_Entity, Assoc (Next_Entity (New_Entity)));\n-         Set_Etype       (New_Entity, Assoc (Etype       (New_Entity)));\n+         if Field = Union_Id (Empty) then\n+            return Field;\n \n-         if Present (New_Scope) then\n-            Set_Scope    (New_Entity, New_Scope);\n-         else\n-            Set_Scope    (New_Entity, Assoc (Scope       (New_Entity)));\n-         end if;\n+         --  The field is an entity/itype/node\n+\n+         elsif Field in Node_Range then\n+            declare\n+               Old_N     : constant Node_Id := Node_Id (Field);\n+               Syntactic : constant Boolean := Parent (Old_N) = Old_Par;\n \n-         --  Copy referenced fields\n+               New_N : Node_Id;\n \n-         if Is_Discrete_Type (New_Entity) then\n-            Set_Scalar_Range (New_Entity,\n-              Copy_Node_With_Replacement (Scalar_Range (New_Entity)));\n+            begin\n+               --  The field is an entity/itype\n \n-         elsif Has_Discriminants (Base_Type (New_Entity)) then\n-            Set_Discriminant_Constraint (New_Entity,\n-              Copy_Elist_With_Replacement\n-                (Discriminant_Constraint (New_Entity)));\n+               if Nkind (Old_N) in N_Entity then\n \n-         elsif Is_Array_Type (New_Entity) then\n-            if Present (First_Index (New_Entity)) then\n-               Set_First_Index (New_Entity,\n-                 First (Copy_List_With_Replacement\n-                         (List_Containing (First_Index (New_Entity)))));\n-            end if;\n+                  --  An entity/itype is always replicated\n \n-            if Is_Packed (New_Entity) then\n-               Set_Packed_Array_Impl_Type (New_Entity,\n-                 Copy_Node_With_Replacement\n-                   (Packed_Array_Impl_Type (New_Entity)));\n-            end if;\n+                  New_N := Corresponding_Entity (Old_N);\n+\n+                  --  Update the parent pointer when the entity is a syntactic\n+                  --  field. Note that itypes do not have parent pointers.\n+\n+                  if Syntactic and then New_N /= Old_N then\n+                     Set_Parent (New_N, New_Par);\n+                  end if;\n+\n+               --  The field is a node\n+\n+               else\n+                  --  A node is replicated when it is either a syntactic field\n+                  --  or when the caller treats it as a semantic attribute.\n+\n+                  if Syntactic or else Semantic then\n+                     New_N := Copy_Node_With_Replacement (Old_N);\n+\n+                     --  Update the parent pointer when the node is a syntactic\n+                     --  field.\n+\n+                     if Syntactic and then New_N /= Old_N then\n+                        Set_Parent (New_N, New_Par);\n+                     end if;\n+\n+                  --  Otherwise the node is returned unchanged\n+\n+                  else\n+                     New_N := Old_N;\n+                  end if;\n+               end if;\n+\n+               return Union_Id (New_N);\n+            end;\n+\n+         --  The field is an entity list\n+\n+         elsif Field in Elist_Range then\n+            return Union_Id (Copy_Elist_With_Replacement (Elist_Id (Field)));\n+\n+         --  The field is a syntactic list\n+\n+         elsif Field in List_Range then\n+            declare\n+               Old_List  : constant List_Id := List_Id (Field);\n+               Syntactic : constant Boolean := Parent (Old_List) = Old_Par;\n+\n+               New_List : List_Id;\n+\n+            begin\n+               --  A list is replicated when it is either a syntactic field or\n+               --  when the caller treats it as a semantic attribute.\n+\n+               if Syntactic or else Semantic then\n+                  New_List := Copy_List_With_Replacement (Old_List);\n+\n+                  --  Update the parent pointer when the list is a syntactic\n+                  --  field.\n+\n+                  if Syntactic and then New_List /= Old_List then\n+                     Set_Parent (New_List, New_Par);\n+                  end if;\n+\n+               --  Otherwise the list is returned unchanged\n+\n+               else\n+                  New_List := Old_List;\n+               end if;\n+\n+               return Union_Id (New_List);\n+            end;\n+\n+         --  Otherwise the field denotes an attribute that does not need to be\n+         --  replicated (Chars, literals, etc).\n+\n+         else\n+            return Field;\n          end if;\n-      end Copy_Entity_With_Replacement;\n+      end Copy_Field_With_Replacement;\n \n       --------------------------------\n       -- Copy_List_With_Replacement --\n       --------------------------------\n \n-      function Copy_List_With_Replacement\n-        (Old_List : List_Id) return List_Id\n-      is\n-         New_List : List_Id;\n-         E        : Node_Id;\n+      function Copy_List_With_Replacement (List : List_Id) return List_Id is\n+         Elmt   : Node_Id;\n+         Result : List_Id;\n \n       begin\n-         if Old_List = No_List then\n-            return No_List;\n+         --  Copy the contents of the old list. Note that the list itself may\n+         --  be empty, in which case the routine returns a new empty list. This\n+         --  avoids sharing lists between subtrees. The element of a syntactic\n+         --  list is always a node, never an entity or itype, hence the call to\n+         --  routine Copy_Node_With_Replacement.\n \n-         else\n-            New_List := Empty_List;\n+         if Present (List) then\n+            Result := New_List;\n+\n+            Elmt := First (List);\n+            while Present (Elmt) loop\n+               Append (Copy_Node_With_Replacement (Elmt), Result);\n \n-            E := First (Old_List);\n-            while Present (E) loop\n-               Append (Copy_Node_With_Replacement (E), New_List);\n-               Next (E);\n+               Next (Elmt);\n             end loop;\n \n-            return New_List;\n+         --  Otherwise the list does not exist\n+\n+         else\n+            Result := No_List;\n          end if;\n+\n+         return Result;\n       end Copy_List_With_Replacement;\n \n       --------------------------------\n       -- Copy_Node_With_Replacement --\n       --------------------------------\n \n-      function Copy_Node_With_Replacement\n-        (Old_Node : Node_Id) return Node_Id\n-      is\n-         New_Node : Node_Id;\n-\n-         procedure Adjust_Named_Associations\n-           (Old_Node : Node_Id;\n-            New_Node : Node_Id);\n-         --  If a call node has named associations, these are chained through\n-         --  the First_Named_Actual, Next_Named_Actual links. These must be\n-         --  propagated separately to the new parameter list, because these\n-         --  are not syntactic fields.\n-\n-         function Copy_Field_With_Replacement\n-           (Field : Union_Id) return Union_Id;\n-         --  Given Field, which is a field of Old_Node, return a copy of it\n-         --  if it is a syntactic field (i.e. its parent is Node), setting\n-         --  the parent of the copy to poit to New_Node. Otherwise returns\n-         --  the field (possibly mapped if it is an entity).\n-\n-         -------------------------------\n-         -- Adjust_Named_Associations --\n-         -------------------------------\n-\n-         procedure Adjust_Named_Associations\n-           (Old_Node : Node_Id;\n-            New_Node : Node_Id)\n-         is\n-            Old_E : Node_Id;\n-            New_E : Node_Id;\n+      function Copy_Node_With_Replacement (N : Node_Id) return Node_Id is\n+         Result : Node_Id;\n \n-            Old_Next : Node_Id;\n-            New_Next : Node_Id;\n+      begin\n+         --  Assume that the node must be returned unchanged\n+\n+         Result := N;\n+\n+         if N > Empty_Or_Error then\n+            pragma Assert (Nkind (N) not in N_Entity);\n+\n+            Result := New_Copy (N);\n+\n+            Set_Field1 (Result,\n+              Copy_Field_With_Replacement\n+                (Field   => Field1 (Result),\n+                 Old_Par => N,\n+                 New_Par => Result));\n+\n+            Set_Field2 (Result,\n+              Copy_Field_With_Replacement\n+                (Field   => Field2 (Result),\n+                 Old_Par => N,\n+                 New_Par => Result));\n+\n+            Set_Field3 (Result,\n+              Copy_Field_With_Replacement\n+                (Field   => Field3 (Result),\n+                 Old_Par => N,\n+                 New_Par => Result));\n+\n+            Set_Field4 (Result,\n+              Copy_Field_With_Replacement\n+                (Field   => Field4 (Result),\n+                 Old_Par => N,\n+                 New_Par => Result));\n+\n+            Set_Field5 (Result,\n+              Copy_Field_With_Replacement\n+                (Field   => Field5 (Result),\n+                 Old_Par => N,\n+                 New_Par => Result));\n+\n+            --  Update the Comes_From_Source and Sloc attributes of the node\n+            --  in case the caller has supplied new values.\n+\n+            Update_CFS_Sloc (Result);\n+\n+            --  Update the Associated_Node_For_Itype attribute of all itypes\n+            --  created during Phase 1 whose associated node is N. As a result\n+            --  the Associated_Node_For_Itype refers to the replicated node.\n+            --  No action needs to be taken when the Associated_Node_For_Itype\n+            --  refers to an entity because this was already handled during\n+            --  Phase 1, in Visit_Itype.\n+\n+            Update_Pending_Itypes\n+              (Old_Assoc => N,\n+               New_Assoc => Result);\n+\n+            --  Update the First/Next_Named_Association chain for a replicated\n+            --  call.\n+\n+            if Nkind_In (N, N_Entry_Call_Statement,\n+                            N_Function_Call,\n+                            N_Procedure_Call_Statement)\n+            then\n+               Update_Named_Associations\n+                 (Old_Call => N,\n+                  New_Call => Result);\n \n-         begin\n-            Old_E := First (Parameter_Associations (Old_Node));\n-            New_E := First (Parameter_Associations (New_Node));\n-            while Present (Old_E) loop\n-               if Nkind (Old_E) = N_Parameter_Association\n-                 and then Present (Next_Named_Actual (Old_E))\n-               then\n-                  if First_Named_Actual (Old_Node) =\n-                       Explicit_Actual_Parameter (Old_E)\n-                  then\n-                     Set_First_Named_Actual\n-                       (New_Node, Explicit_Actual_Parameter (New_E));\n-                  end if;\n+            --  Update the Renamed_Object attribute of a replicated object\n+            --  declaration.\n \n-                  --  Now scan parameter list from the beginning, to locate\n-                  --  next named actual, which can be out of order.\n-\n-                  Old_Next := First (Parameter_Associations (Old_Node));\n-                  New_Next := First (Parameter_Associations (New_Node));\n-                  while Nkind (Old_Next) /= N_Parameter_Association\n-                    or else Explicit_Actual_Parameter (Old_Next) /=\n-                                              Next_Named_Actual (Old_E)\n-                  loop\n-                     Next (Old_Next);\n-                     Next (New_Next);\n-                  end loop;\n+            elsif Nkind (N) = N_Object_Renaming_Declaration then\n+               Set_Renamed_Object (Defining_Entity (Result), Name (Result));\n \n-                  Set_Next_Named_Actual\n-                    (New_E, Explicit_Actual_Parameter (New_Next));\n-               end if;\n+            --  Update the First_Real_Statement attribute of a replicated\n+            --  handled sequence of statements.\n \n-               Next (Old_E);\n-               Next (New_E);\n-            end loop;\n-         end Adjust_Named_Associations;\n+            elsif Nkind (N) = N_Handled_Sequence_Of_Statements then\n+               Update_First_Real_Statement\n+                 (Old_HSS => N,\n+                  New_HSS => Result);\n+            end if;\n+         end if;\n \n-         ---------------------------------\n-         -- Copy_Field_With_Replacement --\n-         ---------------------------------\n+         return Result;\n+      end Copy_Node_With_Replacement;\n \n-         function Copy_Field_With_Replacement\n-           (Field : Union_Id) return Union_Id\n-         is\n-         begin\n-            if Field = Union_Id (Empty) then\n-               return Field;\n+      --------------------------\n+      -- Corresponding_Entity --\n+      --------------------------\n \n-            elsif Field in Node_Range then\n-               declare\n-                  Old_N : constant Node_Id := Node_Id (Field);\n-                  New_N : Node_Id;\n+      function Corresponding_Entity (Id : Entity_Id) return Entity_Id is\n+         New_Id : Entity_Id;\n+         Result : Entity_Id;\n \n-               begin\n-                  --  If syntactic field, as indicated by the parent pointer\n-                  --  being set, then copy the referenced node recursively.\n+      begin\n+         --  Assume that the entity must be returned unchanged\n \n-                  if Parent (Old_N) = Old_Node then\n-                     New_N := Copy_Node_With_Replacement (Old_N);\n+         Result := Id;\n \n-                     if New_N /= Old_N then\n-                        Set_Parent (New_N, New_Node);\n-                     end if;\n+         if Id > Empty_Or_Error then\n+            pragma Assert (Nkind (Id) in N_Entity);\n \n-                  --  For semantic fields, update possible entity reference\n-                  --  from the replacement map.\n+            --  Determine whether the entity has a corresponding new entity\n+            --  generated during Phase 1 and if it does, use it.\n \n-                  else\n-                     New_N := Assoc (Old_N);\n-                  end if;\n+            if NCT_Tables_In_Use then\n+               New_Id := NCT_New_Entities.Get (Id);\n \n-                  return Union_Id (New_N);\n-               end;\n+               if Present (New_Id) then\n+                  Result := New_Id;\n+               end if;\n+            end if;\n+         end if;\n \n-            elsif Field in List_Range then\n-               declare\n-                  Old_L : constant List_Id := List_Id (Field);\n-                  New_L : List_Id;\n+         return Result;\n+      end Corresponding_Entity;\n \n-               begin\n-                  --  If syntactic field, as indicated by the parent pointer,\n-                  --  then recursively copy the entire referenced list.\n+      -------------------\n+      -- In_Entity_Map --\n+      -------------------\n \n-                  if Parent (Old_L) = Old_Node then\n-                     New_L := Copy_List_With_Replacement (Old_L);\n-                     Set_Parent (New_L, New_Node);\n+      function In_Entity_Map\n+        (Id         : Entity_Id;\n+         Entity_Map : Elist_Id) return Boolean\n+      is\n+         Elmt   : Elmt_Id;\n+         Old_Id : Entity_Id;\n \n-                  --  For semantic list, just returned unchanged\n+      begin\n+         --  The entity map contains pairs (Old_Id, New_Id). The advancement\n+         --  step always skips the New_Id portion of the pair.\n \n-                  else\n-                     New_L := Old_L;\n-                  end if;\n+         if Present (Entity_Map) then\n+            Elmt := First_Elmt (Entity_Map);\n+            while Present (Elmt) loop\n+               Old_Id := Node (Elmt);\n \n-                  return Union_Id (New_L);\n-               end;\n+               if Old_Id = Id then\n+                  return True;\n+               end if;\n \n-            --  Anything other than a list or a node is returned unchanged\n+               Next_Elmt (Elmt);\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n \n-            else\n-               return Field;\n-            end if;\n-         end Copy_Field_With_Replacement;\n+         return False;\n+      end In_Entity_Map;\n \n-      --  Start of processing for Copy_Node_With_Replacement\n+      ---------------------\n+      -- Update_CFS_Sloc --\n+      ---------------------\n \n+      procedure Update_CFS_Sloc (N : Node_Or_Entity_Id) is\n       begin\n-         if Old_Node <= Empty_Or_Error then\n-            return Old_Node;\n+         --  A new source location defaults the Comes_From_Source attribute\n+\n+         if New_Sloc /= No_Location then\n+            Set_Comes_From_Source (N, Default_Node.Comes_From_Source);\n+            Set_Sloc              (N, New_Sloc);\n+         end if;\n+      end Update_CFS_Sloc;\n \n-         elsif Nkind (Old_Node) in N_Entity then\n-            return Assoc (Old_Node);\n+      ---------------------------------\n+      -- Update_First_Real_Statement --\n+      ---------------------------------\n \n-         else\n-            New_Node := New_Copy (Old_Node);\n+      procedure Update_First_Real_Statement\n+        (Old_HSS : Node_Id;\n+         New_HSS : Node_Id)\n+      is\n+         Old_First_Stmt : constant Node_Id := First_Real_Statement (Old_HSS);\n \n-            --  If the node we are copying is the associated node of a\n-            --  previously copied Itype, then adjust the associated node\n-            --  of the copy of that Itype accordingly.\n+         New_Stmt : Node_Id;\n+         Old_Stmt : Node_Id;\n \n-            declare\n-               Ent : constant Entity_Id := NCT_Itype_Assoc.Get (Old_Node);\n+      begin\n+         --  Recreate the First_Real_Statement attribute of a handled sequence\n+         --  of statements by traversing the statement lists of both sequences\n+         --  in parallel.\n+\n+         if Present (Old_First_Stmt) then\n+            New_Stmt := First (Statements (New_HSS));\n+            Old_Stmt := First (Statements (Old_HSS));\n+            while Present (Old_Stmt) and then Old_Stmt /= Old_First_Stmt loop\n+               Next (New_Stmt);\n+               Next (Old_Stmt);\n+            end loop;\n \n-            begin\n-               if Present (Ent) then\n-                  Set_Associated_Node_For_Itype (Ent, New_Node);\n-               end if;\n-            end;\n+            pragma Assert (Present (New_Stmt));\n+            pragma Assert (Present (Old_Stmt));\n \n-            --  Recursively copy descendants\n+            Set_First_Real_Statement (New_HSS, New_Stmt);\n+         end if;\n+      end Update_First_Real_Statement;\n+\n+      -------------------------------\n+      -- Update_Named_Associations --\n+      -------------------------------\n \n-            Set_Field1\n-              (New_Node, Copy_Field_With_Replacement (Field1 (New_Node)));\n-            Set_Field2\n-              (New_Node, Copy_Field_With_Replacement (Field2 (New_Node)));\n-            Set_Field3\n-              (New_Node, Copy_Field_With_Replacement (Field3 (New_Node)));\n-            Set_Field4\n-              (New_Node, Copy_Field_With_Replacement (Field4 (New_Node)));\n-            Set_Field5\n-              (New_Node, Copy_Field_With_Replacement (Field5 (New_Node)));\n+      procedure Update_Named_Associations\n+        (Old_Call : Node_Id;\n+         New_Call : Node_Id)\n+      is\n+         New_Act  : Node_Id;\n+         New_Next : Node_Id;\n+         Old_Act  : Node_Id;\n+         Old_Next : Node_Id;\n \n-            --  Adjust Sloc of new node if necessary\n+      begin\n+         --  Recreate the First/Next_Named_Actual chain of a call by traversing\n+         --  the chains of both the old and new calls in parallel.\n+\n+         New_Act := First (Parameter_Associations (New_Call));\n+         Old_Act := First (Parameter_Associations (Old_Call));\n+         while Present (Old_Act) loop\n+            if Nkind (Old_Act) = N_Parameter_Association\n+              and then Present (Next_Named_Actual (Old_Act))\n+            then\n+               if First_Named_Actual (Old_Call) =\n+                    Explicit_Actual_Parameter (Old_Act)\n+               then\n+                  Set_First_Named_Actual (New_Call,\n+                    Explicit_Actual_Parameter (New_Act));\n+               end if;\n \n-            if New_Sloc /= No_Location then\n-               Set_Sloc (New_Node, New_Sloc);\n+               --  Scan the actual parameter list to find the next suitable\n+               --  named actual. Note that the list may be out of order.\n \n-               --  If we adjust the Sloc, then we are essentially making a\n-               --  completely new node, so the Comes_From_Source flag should\n-               --  be reset to the proper default value.\n+               New_Next := First (Parameter_Associations (New_Call));\n+               Old_Next := First (Parameter_Associations (Old_Call));\n+               while Nkind (Old_Next) /= N_Parameter_Association\n+                 or else Explicit_Actual_Parameter (Old_Next) /=\n+                           Next_Named_Actual (Old_Act)\n+               loop\n+                  Next (New_Next);\n+                  Next (Old_Next);\n+               end loop;\n \n-               Set_Comes_From_Source\n-                 (New_Node, Default_Node.Comes_From_Source);\n+               Set_Next_Named_Actual (New_Act,\n+                 Explicit_Actual_Parameter (New_Next));\n             end if;\n \n-            --  Update the named association links for calls to mention the\n-            --  copied actual parameters.\n+            Next (New_Act);\n+            Next (Old_Act);\n+         end loop;\n+      end Update_Named_Associations;\n \n-            if Nkind_In (Old_Node, N_Entry_Call_Statement,\n-                                   N_Function_Call,\n-                                   N_Procedure_Call_Statement)\n-              and then Present (First_Named_Actual (Old_Node))\n-            then\n-               Adjust_Named_Associations (Old_Node, New_Node);\n+      -------------------------\n+      -- Update_New_Entities --\n+      -------------------------\n+\n+      procedure Update_New_Entities (Entity_Map : Elist_Id) is\n+         New_Id : Entity_Id := Empty;\n+         Old_Id : Entity_Id := Empty;\n+\n+      begin\n+         if NCT_Tables_In_Use then\n+            NCT_New_Entities.Get_First (Old_Id, New_Id);\n+\n+            --  Update the semantic fields of all new entities created during\n+            --  Phase 1 which were not supplied via an entity map.\n+            --  ??? Is there a better way of distinguishing those?\n+\n+            while Present (Old_Id) and then Present (New_Id) loop\n+               if not (Present (Entity_Map)\n+                        and then In_Entity_Map (Old_Id, Entity_Map))\n+               then\n+                  Update_Semantic_Fields (New_Id);\n+               end if;\n+\n+               NCT_New_Entities.Get_Next (Old_Id, New_Id);\n+            end loop;\n+         end if;\n+      end Update_New_Entities;\n+\n+      ---------------------------\n+      -- Update_Pending_Itypes --\n+      ---------------------------\n+\n+      procedure Update_Pending_Itypes\n+        (Old_Assoc : Node_Id;\n+         New_Assoc : Node_Id)\n+      is\n+         Item   : Elmt_Id;\n+         Itypes : Elist_Id;\n+\n+      begin\n+         if NCT_Tables_In_Use then\n+            Itypes := NCT_Pending_Itypes.Get (Old_Assoc);\n \n-            --  Update the Renamed_Object attribute of an object renaming\n-            --  declaration to mention the replicated name.\n+            --  Update the Associated_Node_For_Itype attribute for all itypes\n+            --  which originally refer to Old_Assoc to designate New_Assoc.\n \n-            elsif Nkind (Old_Node) = N_Object_Renaming_Declaration then\n-               Set_Renamed_Object\n-                 (Defining_Entity (New_Node), Name (New_Node));\n+            if Present (Itypes) then\n+               Item := First_Elmt (Itypes);\n+               while Present (Item) loop\n+                  Set_Associated_Node_For_Itype (Node (Item), New_Assoc);\n+\n+                  Next_Elmt (Item);\n+               end loop;\n             end if;\n+         end if;\n+      end Update_Pending_Itypes;\n \n-            --  Reset First_Real_Statement for Handled_Sequence_Of_Statements.\n-            --  The replacement mechanism applies to entities, and is not used\n-            --  here. Eventually we may need a more general graph-copying\n-            --  routine. For now, do a sequential search to find desired node.\n+      ----------------------------\n+      -- Update_Semantic_Fields --\n+      ----------------------------\n \n-            if Nkind (Old_Node) = N_Handled_Sequence_Of_Statements\n-              and then Present (First_Real_Statement (Old_Node))\n-            then\n-               declare\n-                  Old_F : constant Node_Id := First_Real_Statement (Old_Node);\n-                  N1    : Node_Id;\n-                  N2    : Node_Id;\n+      procedure Update_Semantic_Fields (Id : Entity_Id) is\n+      begin\n+         --  Discriminant_Constraint\n \n-               begin\n-                  N1 := First (Statements (Old_Node));\n-                  N2 := First (Statements (New_Node));\n+         if Has_Discriminants (Base_Type (Id)) then\n+            Set_Discriminant_Constraint (Id, Elist_Id (\n+              Copy_Field_With_Replacement\n+                (Field    => Union_Id (Discriminant_Constraint (Id)),\n+                 Semantic => True)));\n+         end if;\n \n-                  while N1 /= Old_F loop\n-                     Next (N1);\n-                     Next (N2);\n-                  end loop;\n+         --  Etype\n \n-                  Set_First_Real_Statement (New_Node, N2);\n-               end;\n+         Set_Etype (Id, Node_Id (\n+           Copy_Field_With_Replacement\n+             (Field    => Union_Id (Etype (Id)),\n+              Semantic => True)));\n+\n+         --  First_Index\n+         --  Packed_Array_Impl_Type\n+\n+         if Is_Array_Type (Id) then\n+            if Present (First_Index (Id)) then\n+               Set_First_Index (Id, First (List_Id (\n+                 Copy_Field_With_Replacement\n+                   (Field    => Union_Id (List_Containing (First_Index (Id))),\n+                    Semantic => True))));\n+            end if;\n+\n+            if Is_Packed (Id) then\n+               Set_Packed_Array_Impl_Type (Id, Node_Id (\n+                 Copy_Field_With_Replacement\n+                   (Field    => Union_Id (Packed_Array_Impl_Type (Id)),\n+                    Semantic => True)));\n             end if;\n          end if;\n \n-         --  All done, return copied node\n+         --  Next_Entity\n \n-         return New_Node;\n-      end Copy_Node_With_Replacement;\n+         Set_Next_Entity (Id, Node_Id (\n+           Copy_Field_With_Replacement\n+             (Field    => Union_Id (Next_Entity (Id)),\n+              Semantic => True)));\n \n-      ------------\n-      -- In_Map --\n-      ------------\n+         --  Scalar_Range\n \n-      function In_Map (E : Entity_Id) return Boolean is\n-         Elmt : Elmt_Id;\n-         Ent  : Entity_Id;\n+         if Is_Discrete_Type (Id) then\n+            Set_Scalar_Range (Id, Node_Id (\n+              Copy_Field_With_Replacement\n+                (Field    => Union_Id (Scalar_Range (Id)),\n+                 Semantic => True)));\n+         end if;\n \n-      begin\n-         if Present (Map) then\n-            Elmt := First_Elmt (Map);\n-            while Present (Elmt) loop\n-               Ent := Node (Elmt);\n+         --  Scope\n \n-               if Ent = E then\n-                  return True;\n-               end if;\n+         --  Update the scope when the caller specified an explicit one\n \n-               Next_Elmt (Elmt);\n-               Next_Elmt (Elmt);\n-            end loop;\n+         if Present (New_Scope) then\n+            Set_Scope (Id, New_Scope);\n+         else\n+            Set_Scope (Id, Node_Id (\n+              Copy_Field_With_Replacement\n+                (Field    => Union_Id (Scope (Id)),\n+                 Semantic => True)));\n          end if;\n+      end Update_Semantic_Fields;\n \n-         return False;\n-      end In_Map;\n+      --------------------\n+      -- Visit_Any_Node --\n+      --------------------\n+\n+      procedure Visit_Any_Node (N : Node_Or_Entity_Id) is\n+      begin\n+         if Nkind (N) in N_Entity then\n+            if Is_Itype (N) then\n+               Visit_Itype (N);\n+            else\n+               Visit_Entity (N);\n+            end if;\n+         else\n+            Visit_Node (N);\n+         end if;\n+      end Visit_Any_Node;\n \n       -----------------\n       -- Visit_Elist --\n       -----------------\n \n-      procedure Visit_Elist (E : Elist_Id) is\n+      procedure Visit_Elist (List : Elist_Id) is\n          Elmt : Elmt_Id;\n+\n       begin\n-         if Present (E) then\n-            Elmt := First_Elmt (E);\n+         --  The element of an entity list could be an entity, itype, or a\n+         --  node, hence the call to Visit_Any_Node.\n+\n+         if Present (List) then\n+            Elmt := First_Elmt (List);\n+            while Present (Elmt) loop\n+               Visit_Any_Node (Node (Elmt));\n \n-            while Elmt /= No_Elmt loop\n-               Visit_Node (Node (Elmt));\n                Next_Elmt (Elmt);\n             end loop;\n          end if;\n@@ -17885,219 +18286,293 @@ package body Sem_Util is\n       -- Visit_Entity --\n       ------------------\n \n-      procedure Visit_Entity (Old_Entity : Entity_Id) is\n-         New_E : Entity_Id;\n+      procedure Visit_Entity (Id : Entity_Id) is\n+         New_Id : Entity_Id;\n \n       begin\n-         pragma Assert (not Is_Itype (Old_Entity));\n-         pragma Assert (Nkind (Old_Entity) in N_Entity);\n+         pragma Assert (Nkind (Id) in N_Entity);\n+         pragma Assert (not Is_Itype (Id));\n \n-         --  Do not duplicate an entity when it is declared within an inner\n-         --  scope enclosed by an expression with actions.\n+         --  Nothing to do if the entity is not defined in the Actions list of\n+         --  an N_Expression_With_Actions node.\n \n-         if EWA_Inner_Scope_Level > 0 then\n+         if EWA_Level = 0 then\n             return;\n \n-         --  Entity duplication is currently performed only for objects and\n-         --  types. Relaxing this restriction leads to a performance penalty.\n+         --  Nothing to do if the entity is defined within a scoping construct\n+         --  of an N_Expression_With_Actions node.\n \n-         elsif Ekind_In (Old_Entity, E_Constant, E_Variable) then\n-            null;\n+         elsif EWA_Inner_Scope_Level > 0 then\n+            return;\n \n-         elsif Is_Type (Old_Entity) then\n-            null;\n+         --  Nothing to do if the entity is not an object or a type. Relaxing\n+         --  this restriction leads to a performance penalty.\n \n-         else\n+         elsif not Ekind_In (Id, E_Constant, E_Variable)\n+           and then not Is_Type (Id)\n+         then\n+            return;\n+\n+         --  Nothing to do if the entity was already visited\n+\n+         elsif NCT_Tables_In_Use\n+           and then Present (NCT_New_Entities.Get (Id))\n+         then\n+            return;\n+\n+         --  Nothing to do if the declaration node of the entity is not within\n+         --  the subtree being replicated.\n+\n+         elsif not In_Subtree\n+                     (Root => Source,\n+                      N    => Declaration_Node (Id))\n+         then\n             return;\n          end if;\n \n-         New_E := New_Copy (Old_Entity);\n+         --  Create a new entity by directly copying the old entity. This\n+         --  action causes all attributes of the old entity to be inherited.\n+\n+         New_Id := New_Copy (Id);\n+\n+         --  Create a new name for the new entity because the back end needs\n+         --  distinct names for debugging purposes.\n \n-         --  The new entity has all the attributes of the old one, however it\n-         --  requires a new name for debugging purposes.\n+         Set_Chars (New_Id, New_Internal_Name ('T'));\n \n-         Set_Chars (New_E, New_Internal_Name ('T'));\n+         --  Update the Comes_From_Source and Sloc attributes of the entity in\n+         --  case the caller has supplied new values.\n \n-         --  Add new association to map\n+         Update_CFS_Sloc (New_Id);\n \n-         NCT_Assoc.Set (Old_Entity, New_E);\n-         NCT_Hash_Tables_Used := True;\n+         --  Establish the following mapping within table NCT_New_Entities:\n \n-         --  Visit descendants that eventually get copied\n+         --    Id -> New_Id\n \n-         Visit_Field (Union_Id (Etype (Old_Entity)), Old_Entity);\n+         Add_New_Entity (Id, New_Id);\n+\n+         --  Deal with the semantic fields of entities. The fields are visited\n+         --  because they may mention entities which reside within the subtree\n+         --  being copied.\n+\n+         Visit_Semantic_Fields (Id);\n       end Visit_Entity;\n \n       -----------------\n       -- Visit_Field --\n       -----------------\n \n-      procedure Visit_Field (F : Union_Id; N : Node_Id) is\n+      procedure Visit_Field\n+        (Field    : Union_Id;\n+         Par_Nod  : Node_Id := Empty;\n+         Semantic : Boolean := False)\n+      is\n       begin\n-         if F = Union_Id (Empty) then\n+         --  The field is empty\n+\n+         if Field = Union_Id (Empty) then\n             return;\n \n-         elsif F in Node_Range then\n+         --  The field is an entity/itype/node\n \n-            --  Copy node if it is syntactic, i.e. its parent pointer is\n-            --  set to point to the field that referenced it (certain\n-            --  Itypes will also meet this criterion, which is fine, since\n-            --  these are clearly Itypes that do need to be copied, since\n-            --  we are copying their parent.)\n+         elsif Field in Node_Range then\n+            declare\n+               N : constant Node_Id := Node_Id (Field);\n \n-            if Parent (Node_Id (F)) = N then\n-               Visit_Node (Node_Id (F));\n-               return;\n+            begin\n+               --  The field is an entity/itype\n \n-            --  Another case, if we are pointing to an Itype, then we want\n-            --  to copy it if its associated node is somewhere in the tree\n-            --  being copied.\n+               if Nkind (N) in N_Entity then\n \n-            --  Note: the exclusion of self-referential copies is just an\n-            --  optimization, since the search of the already copied list\n-            --  would catch it, but it is a common case (Etype pointing to\n-            --  itself for an Itype that is a base type).\n+                  --  Itypes are always visited\n \n-            elsif Nkind (Node_Id (F)) in N_Entity\n-              and then Is_Itype (Entity_Id (F))\n-              and then Node_Id (F) /= N\n-            then\n-               declare\n-                  P : Node_Id;\n+                  if Is_Itype (N) then\n+                     Visit_Itype (N);\n \n-               begin\n-                  P := Associated_Node_For_Itype (Node_Id (F));\n-                  while Present (P) loop\n-                     if P = Source then\n-                        Visit_Node (Node_Id (F));\n-                        return;\n-                     else\n-                        P := Parent (P);\n-                     end if;\n-                  end loop;\n+                  --  An entity is visited when it is either a syntactic field\n+                  --  or when the caller treats it as a semantic attribute.\n \n-                  --  An Itype whose parent is not being copied definitely\n-                  --  should NOT be copied, since it does not belong in any\n-                  --  sense to the copied subtree.\n+                  elsif Parent (N) = Par_Nod or else Semantic then\n+                     Visit_Entity (N);\n+                  end if;\n \n-                  return;\n-               end;\n-            end if;\n+               --  The field is a node\n \n-         elsif F in List_Range and then Parent (List_Id (F)) = N then\n-            Visit_List (List_Id (F));\n-            return;\n+               else\n+                  --  A node is visited when it is either a syntactic field or\n+                  --  when the caller treats it as a semantic attribute.\n+\n+                  if Parent (N) = Par_Nod or else Semantic then\n+                     Visit_Node (N);\n+                  end if;\n+               end if;\n+            end;\n+\n+         --  The field is an entity list\n+\n+         elsif Field in Elist_Range then\n+            Visit_Elist (Elist_Id (Field));\n+\n+         --  The field is a syntax list\n+\n+         elsif Field in List_Range then\n+            declare\n+               List : constant List_Id := List_Id (Field);\n+\n+            begin\n+               --  A syntax list is visited when it is either a syntactic field\n+               --  or when the caller treats it as a semantic attribute.\n+\n+               if Parent (List) = Par_Nod or else Semantic then\n+                  Visit_List (List);\n+               end if;\n+            end;\n+\n+         --  Otherwise the field denotes information which does not need to be\n+         --  visited (chars, literals, etc.).\n+\n+         else\n+            null;\n          end if;\n       end Visit_Field;\n \n       -----------------\n       -- Visit_Itype --\n       -----------------\n \n-      procedure Visit_Itype (Old_Itype : Entity_Id) is\n+      procedure Visit_Itype (Itype : Entity_Id) is\n+         New_Assoc : Node_Id;\n          New_Itype : Entity_Id;\n-         Ent       : Entity_Id;\n+         Old_Assoc : Node_Id;\n \n       begin\n+         pragma Assert (Nkind (Itype) in N_Entity);\n+         pragma Assert (Is_Itype (Itype));\n+\n          --  Itypes that describe the designated type of access to subprograms\n          --  have the structure of subprogram declarations, with signatures,\n          --  etc. Either we duplicate the signatures completely, or choose to\n          --  share such itypes, which is fine because their elaboration will\n          --  have no side effects.\n \n-         if Ekind (Old_Itype) = E_Subprogram_Type then\n+         if Ekind (Itype) = E_Subprogram_Type then\n+            return;\n+\n+         --  Nothing to do if the itype was already visited\n+\n+         elsif NCT_Tables_In_Use\n+           and then Present (NCT_New_Entities.Get (Itype))\n+         then\n+            return;\n+\n+         --  Nothing to do if the associated node of the itype is not within\n+         --  the subtree being replicated.\n+\n+         elsif not In_Subtree\n+                     (Root => Source,\n+                      N    => Associated_Node_For_Itype (Itype))\n+         then\n             return;\n          end if;\n \n-         New_Itype := New_Copy (Old_Itype);\n+         --  Create a new itype by directly copying the old itype. This action\n+         --  causes all attributes of the old itype to be inherited.\n \n-         --  The new Itype has all the attributes of the old one, and we\n-         --  just copy the contents of the entity. However, the back-end\n-         --  needs different names for debugging purposes, so we create a\n-         --  new internal name for it in all cases.\n+         New_Itype := New_Copy (Itype);\n \n-         Set_Chars (New_Itype, New_Internal_Name ('T'));\n+         --  Create a new name for the new itype because the back end requires\n+         --  distinct names for debugging purposes.\n \n-         --  If our associated node is an entity that has already been copied,\n-         --  then set the associated node of the copy to point to the right\n-         --  copy. If we have copied an Itype that is itself the associated\n-         --  node of some previously copied Itype, then we set the right\n-         --  pointer in the other direction.\n+         Set_Chars (New_Itype, New_Internal_Name ('T'));\n \n-         Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n+         --  Update the Comes_From_Source and Sloc attributes of the itype in\n+         --  case the caller has supplied new values.\n \n-         if Present (Ent) then\n-            Set_Associated_Node_For_Itype (New_Itype, Ent);\n-         end if;\n+         Update_CFS_Sloc (New_Itype);\n \n-         Ent := NCT_Itype_Assoc.Get (Old_Itype);\n+         --  Establish the following mapping within table NCT_New_Entities:\n \n-         if Present (Ent) then\n-            Set_Associated_Node_For_Itype (Ent, New_Itype);\n+         --    Itype -> New_Itype\n \n-         --  If the hash table has no association for this Itype and its\n-         --  associated node, enter one now.\n+         Add_New_Entity (Itype, New_Itype);\n \n-         else\n-            NCT_Itype_Assoc.Set\n-              (Associated_Node_For_Itype (Old_Itype), New_Itype);\n-         end if;\n+         --  The new itype must be unfrozen because the resulting subtree may\n+         --  be inserted anywhere and cause an earlier or later freezing.\n \n          if Present (Freeze_Node (New_Itype)) then\n-            Set_Is_Frozen (New_Itype, False);\n             Set_Freeze_Node (New_Itype, Empty);\n+            Set_Is_Frozen   (New_Itype, False);\n          end if;\n \n-         --  Add new association to map\n-\n-         NCT_Assoc.Set (Old_Itype, New_Itype);\n-         NCT_Hash_Tables_Used := True;\n-\n          --  If a record subtype is simply copied, the entity list will be\n          --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n+         --  ??? What does this do?\n \n-         if Ekind_In (Old_Itype, E_Class_Wide_Subtype, E_Record_Subtype) then\n-            Set_Cloned_Subtype (New_Itype, Old_Itype);\n+         if Ekind_In (Itype, E_Class_Wide_Subtype, E_Record_Subtype) then\n+            Set_Cloned_Subtype (New_Itype, Itype);\n          end if;\n \n-         --  Visit descendants that eventually get copied\n+         --  The associated node may denote an entity, in which case it may\n+         --  already have a new corresponding entity created during a prior\n+         --  call to Visit_Entity or Visit_Itype for the same subtree.\n \n-         Visit_Field (Union_Id (Etype (Old_Itype)), Old_Itype);\n+         --    Given\n+         --       Old_Assoc ---------> New_Assoc\n \n-         if Is_Discrete_Type (Old_Itype) then\n-            Visit_Field (Union_Id (Scalar_Range (Old_Itype)), Old_Itype);\n+         --    Created by Visit_Itype\n+         --       Itype -------------> New_Itype\n+         --       ANFI = Old_Assoc     ANFI = Old_Assoc  <  must be updated\n \n-         elsif Has_Discriminants (Base_Type (Old_Itype)) then\n-            --  ??? This should involve call to Visit_Field\n-            Visit_Elist (Discriminant_Constraint (Old_Itype));\n+         --  In the example above, Old_Assoc is an arbitrary entity that was\n+         --  already visited for the same subtree and has a corresponding new\n+         --  entity New_Assoc. Old_Assoc was inherited by New_Itype by virtue\n+         --  of copying entities, however it must be updated to New_Assoc.\n \n-         elsif Is_Array_Type (Old_Itype) then\n-            if Present (First_Index (Old_Itype)) then\n-               Visit_Field\n-                 (Union_Id (List_Containing (First_Index (Old_Itype))),\n-                  Old_Itype);\n-            end if;\n+         Old_Assoc := Associated_Node_For_Itype (Itype);\n \n-            if Is_Packed (Old_Itype) then\n-               Visit_Field\n-                 (Union_Id (Packed_Array_Impl_Type (Old_Itype)), Old_Itype);\n+         if Nkind (Old_Assoc) in N_Entity then\n+            if NCT_Tables_In_Use then\n+               New_Assoc := NCT_New_Entities.Get (Old_Assoc);\n+\n+               if Present (New_Assoc) then\n+                  Set_Associated_Node_For_Itype (New_Itype, New_Assoc);\n+               end if;\n             end if;\n+\n+         --  Otherwise the associated node denotes a node. Postpone the update\n+         --  until Phase 2 when the node is replicated. Establish the following\n+         --  mapping within table NCT_Pending_Itypes:\n+\n+         --    Old_Assoc -> (New_Type, ...)\n+\n+         else\n+            Add_Pending_Itype (Old_Assoc, New_Itype);\n          end if;\n+\n+         --  Deal with the semantic fields of itypes. The fields are visited\n+         --  because they may mention entities that reside within the subtree\n+         --  being copied.\n+\n+         Visit_Semantic_Fields (Itype);\n       end Visit_Itype;\n \n       ----------------\n       -- Visit_List --\n       ----------------\n \n-      procedure Visit_List (L : List_Id) is\n-         N : Node_Id;\n+      procedure Visit_List (List : List_Id) is\n+         Elmt : Node_Id;\n+\n       begin\n-         if L /= No_List then\n-            N := First (L);\n+         --  Note that the element of a syntactic list is always a node, never\n+         --  an entity or itype, hence the call to Visit_Node.\n+\n+         if Present (List) then\n+            Elmt := First (List);\n+            while Present (Elmt) loop\n+               Visit_Node (Elmt);\n \n-            while Present (N) loop\n-               Visit_Node (N);\n-               Next (N);\n+               Next (Elmt);\n             end loop;\n          end if;\n       end Visit_List;\n@@ -18108,6 +18583,8 @@ package body Sem_Util is\n \n       procedure Visit_Node (N : Node_Or_Entity_Id) is\n       begin\n+         pragma Assert (Nkind (N) not in N_Entity);\n+\n          if Nkind (N) = N_Expression_With_Actions then\n             EWA_Level := EWA_Level + 1;\n \n@@ -18117,41 +18594,27 @@ package body Sem_Util is\n                                  N_Subprogram_Declaration)\n          then\n             EWA_Inner_Scope_Level := EWA_Inner_Scope_Level + 1;\n+         end if;\n \n-         --  Handle case of an Itype, which must be copied\n-\n-         elsif Nkind (N) in N_Entity and then Is_Itype (N) then\n-\n-            --  Nothing to do if already in the list. This can happen with an\n-            --  Itype entity that appears more than once in the tree. Note that\n-            --  we do not want to visit descendants in this case.\n-\n-            if Present (NCT_Assoc.Get (Entity_Id (N))) then\n-               return;\n-            end if;\n-\n-            Visit_Itype (N);\n-\n-         --  Handle defining entities in Expression_With_Action nodes\n+         Visit_Field\n+          (Field   => Field1 (N),\n+           Par_Nod => N);\n \n-         elsif Nkind (N) in N_Entity and then EWA_Level > 0 then\n+         Visit_Field\n+          (Field   => Field2 (N),\n+           Par_Nod => N);\n \n-            --  Nothing to do if already in the hash table\n+         Visit_Field\n+          (Field   => Field3 (N),\n+           Par_Nod => N);\n \n-            if Present (NCT_Assoc.Get (Entity_Id (N))) then\n-               return;\n-            end if;\n-\n-            Visit_Entity (N);\n-         end if;\n+         Visit_Field\n+          (Field   => Field4 (N),\n+           Par_Nod => N);\n \n-         --  Visit descendants\n-\n-         Visit_Field (Field1 (N), N);\n-         Visit_Field (Field2 (N), N);\n-         Visit_Field (Field3 (N), N);\n-         Visit_Field (Field4 (N), N);\n-         Visit_Field (Field5 (N), N);\n+         Visit_Field\n+          (Field   => Field5 (N),\n+           Par_Nod => N);\n \n          if EWA_Level > 0\n            and then Nkind_In (N, N_Block_Statement,\n@@ -18165,57 +18628,171 @@ package body Sem_Util is\n          end if;\n       end Visit_Node;\n \n+      ---------------------------\n+      -- Visit_Semantic_Fields --\n+      ---------------------------\n+\n+      procedure Visit_Semantic_Fields (Id : Entity_Id) is\n+      begin\n+         pragma Assert (Nkind (Id) in N_Entity);\n+\n+         --  Discriminant_Constraint\n+\n+         if Has_Discriminants (Base_Type (Id)) then\n+            Visit_Field\n+              (Field    => Union_Id (Discriminant_Constraint (Id)),\n+               Semantic => True);\n+         end if;\n+\n+         --  Etype\n+\n+         Visit_Field\n+           (Field    => Union_Id (Etype (Id)),\n+            Semantic => True);\n+\n+         --  First_Index\n+         --  Packed_Array_Impl_Type\n+\n+         if Is_Array_Type (Id) then\n+            if Present (First_Index (Id)) then\n+               Visit_Field\n+                 (Field    => Union_Id (List_Containing (First_Index (Id))),\n+                  Semantic => True);\n+            end if;\n+\n+            if Is_Packed (Id) then\n+               Visit_Field\n+                 (Field    => Union_Id (Packed_Array_Impl_Type (Id)),\n+                  Semantic => True);\n+            end if;\n+         end if;\n+\n+         --  Scalar_Range\n+\n+         if Is_Discrete_Type (Id) then\n+            Visit_Field\n+              (Field    => Union_Id (Scalar_Range (Id)),\n+               Semantic => True);\n+         end if;\n+      end Visit_Semantic_Fields;\n+\n    --  Start of processing for New_Copy_Tree\n \n    begin\n-      Build_NCT_Hash_Tables;\n+      --  Routine New_Copy_Tree performs a deep copy of a subtree by creating\n+      --  shallow copies for each node within, and then updating the child and\n+      --  parent pointers accordingly. This process is straightforward, however\n+      --  the routine must deal with the following complications:\n \n-      --  Hash table set up if required, now start phase one by visiting top\n-      --  node (we will recursively visit the descendants).\n+      --    * Entities defined within N_Expression_With_Actions nodes must be\n+      --      replicated rather than shared to avoid introducing two identical\n+      --      symbols within the same scope. Note that no other expression can\n+      --      currently define entities.\n \n-      Visit_Node (Source);\n+      --        do\n+      --           Source_Low  : ...;\n+      --           Source_High : ...;\n \n-      --  Now the second phase of the copy can start. First we process all the\n-      --  mapped entities, copying their descendants.\n+      --           <reference to Source_Low>\n+      --           <reference to Source_High>\n+      --        in ... end;\n \n-      if NCT_Hash_Tables_Used then\n-         declare\n-            Old_E : Entity_Id := Empty;\n-            New_E : Entity_Id;\n+      --      New_Copy_Tree handles this case by first creating new entities\n+      --      and then updating all existing references to point to these new\n+      --      entities.\n \n-         begin\n-            NCT_Assoc.Get_First (Old_E, New_E);\n-            while Present (New_E) loop\n+      --        do\n+      --           New_Low  : ...;\n+      --           New_High : ...;\n \n-               --  Skip entities that were not created in the first phase\n-               --  (that is, old entities specified by the caller in the set of\n-               --  mappings to be applied to the tree).\n+      --           <reference to New_Low>\n+      --           <reference to New_High>\n+      --        in ... end;\n \n-               if Is_Itype (New_E)\n-                 or else No (Map)\n-                 or else not In_Map (Old_E)\n-               then\n-                  Copy_Entity_With_Replacement (New_E);\n-               end if;\n+      --    * Itypes defined within the subtree must be replicated to avoid any\n+      --      dependencies on invalid or inaccessible data.\n \n-               NCT_Assoc.Get_Next (Old_E, New_E);\n-            end loop;\n-         end;\n-      end if;\n+      --        subtype Source_Itype is ... range Source_Low .. Source_High;\n \n-      --  Now we can copy the actual tree\n+      --      New_Copy_Tree handles this case by first creating a new itype in\n+      --      the same fashion as entities, and then updating various relevant\n+      --      constraints.\n \n-      declare\n-         Result : constant Node_Id := Copy_Node_With_Replacement (Source);\n+      --        subtype New_Itype is ... range New_Low .. New_High;\n \n-      begin\n-         if NCT_Hash_Tables_Used then\n-            NCT_Assoc.Reset;\n-            NCT_Itype_Assoc.Reset;\n-         end if;\n+      --    * The Associated_Node_For_Itype field of itypes must be updated to\n+      --      reference the proper replicated entity or node.\n \n-         return Result;\n-      end;\n+      --    * Semantic fields of entities such as Etype and Scope must be\n+      --      updated to reference the proper replicated entities.\n+\n+      --    * Semantic fields of nodes such as First_Real_Statement must be\n+      --      updated to reference the proper replicated nodes.\n+\n+      --  To meet all these demands, routine New_Copy_Tree is split into two\n+      --  phases.\n+\n+      --  Phase 1 traverses the tree in order to locate entities and itypes\n+      --  defined within the subtree. New entities are generated and saved in\n+      --  table NCT_New_Entities. The semantic fields of all new entities and\n+      --  itypes are then updated accordingly.\n+\n+      --  Phase 2 traverses the tree in order to replicate each node. Various\n+      --  semantic fields of nodes and entities are updated accordingly.\n+\n+      --  Preparatory phase. Clear the contents of tables NCT_New_Entities and\n+      --  NCT_Pending_Itypes in case a previous call to New_Copy_Tree left some\n+      --  data inside.\n+\n+      NCT_New_Entities.Reset;\n+      NCT_Pending_Itypes.Reset;\n+\n+      --  Populate tables NCT_New_Entities and NCT_Pending_Itypes with data\n+      --  supplied by a linear entity map. The tables offer faster access to\n+      --  the same data.\n+\n+      Build_NCT_Tables (Map);\n+\n+      --  Execute Phase 1. Traverse the subtree and generate new entities for\n+      --  the following cases:\n+\n+      --    * An entity defined within an N_Expression_With_Actions node\n+\n+      --    * An itype referenced within the subtree where the associated node\n+      --      is also in the subtree.\n+\n+      --  All new entities are accessible via table NCT_New_Entities, which\n+      --  contains mappings of the form:\n+\n+      --    Old_Entity -> New_Entity\n+      --    Old_Itype  -> New_Itype\n+\n+      --  In addition, the associated nodes of all new itypes are mapped in\n+      --  table NCT_Pending_Itypes:\n+\n+      --    Assoc_Nod -> (New_Itype1, New_Itype2, .., New_ItypeN)\n+\n+      Visit_Any_Node (Source);\n+\n+      --  Update the semantic attributes of all new entities generated during\n+      --  Phase 1 before starting Phase 2. The updates could be performed in\n+      --  routine Corresponding_Entity, however this may cause the same entity\n+      --  to be updated multiple times, effectively generating useless nodes.\n+      --  Keeping the updates separates from Phase 2 ensures that only one set\n+      --  of attributes is generated for an entity at any one time.\n+\n+      Update_New_Entities (Map);\n+\n+      --  Execute Phase 2. Replicate the source subtree one node at a time.\n+      --  The following transformations take place:\n+\n+      --    * References to entities and itypes are updated to refer to the\n+      --      new entities and itypes generated during Phase 1.\n+\n+      --    * All Associated_Node_For_Itype attributes of itypes are updated\n+      --      to refer to the new replicated Associated_Node_For_Itype.\n+\n+      return Copy_Node_With_Replacement (Source);\n    end New_Copy_Tree;\n \n    -------------------------"}, {"sha": "fab85f062da079abbf46feeee90641a17245a801", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -1371,6 +1371,9 @@ package Sem_Util is\n    --  appearing anywhere within such a construct (that is it does not need\n    --  to be directly within).\n \n+   function In_Subtree (Root : Node_Id; N : Node_Id) return Boolean;\n+   --  Determine whether node N is within the subtree rooted at Root\n+\n    function In_Visible_Part (Scope_Id : Entity_Id) return Boolean;\n    --  Determine whether a declaration occurs within the visible part of a\n    --  package specification. The package must be on the scope stack, and the\n@@ -2057,46 +2060,75 @@ package Sem_Util is\n       Map       : Elist_Id   := No_Elist;\n       New_Sloc  : Source_Ptr := No_Location;\n       New_Scope : Entity_Id  := Empty) return Node_Id;\n-   --  Given a node that is the root of a subtree, New_Copy_Tree copies the\n-   --  entire syntactic subtree, including recursively any descendants whose\n-   --  parent field references a copied node (descendants not linked to a\n-   --  copied node by the parent field are not copied, instead the copied tree\n-   --  references the same descendant as the original in this case, which is\n-   --  appropriate for non-syntactic fields such as Etype). The parent pointers\n-   --  in the copy are properly set. New_Copy_Tree (Empty/Error) returns\n-   --  Empty/Error. The one exception to the rule of not copying semantic\n-   --  fields is that any implicit types attached to the subtree are\n-   --  duplicated, so that the copy contains a distinct set of implicit type\n-   --  entities. Thus this function is used when it is necessary to duplicate\n-   --  an analyzed tree, declared in the same or some other compilation unit.\n-   --  This function is declared here rather than in atree because it uses\n-   --  semantic information in particular concerning the structure of itypes\n-   --  and the generation of public symbols.\n-\n-   --  The Map argument, if set to a non-empty Elist, specifies a set of\n-   --  mappings to be applied to entities in the tree. The map has the form:\n+   --  Perform a deep copy of the subtree rooted at Source. Entities, itypes,\n+   --  and nodes are handled separately as follows:\n+   --\n+   --    * A node is replicated by first creating a shallow copy, then copying\n+   --      its syntactic fields, where all Parent pointers of the fields are\n+   --      updated to refer to the copy. In addition, the following semantic\n+   --      fields are recreated after the replication takes place.\n+   --\n+   --        First_Named_Actual\n+   --        First_Real_Statement\n+   --        Next_Named_Actual\n+   --\n+   --      If applicable, the Etype field (if any) is updated to refer to a\n+   --      local itype or type (see below).\n+   --\n+   --    * An entity defined within an N_Expression_With_Actions node in the\n+   --      subtree is given a new entity, and all references to the original\n+   --      entity are updated to refer to the new entity. In addition, the\n+   --      following semantic fields are replicated and/or updated to refer\n+   --      to a local entity or itype.\n+   --\n+   --        Discriminant_Constraint\n+   --        Etype\n+   --        First_Index\n+   --        Next_Entity\n+   --        Packed_Array_Impl_Type\n+   --        Scalar_Range\n+   --        Scope\n+   --\n+   --      Note that currently no other expression can define entities.\n+   --\n+   --    * An itype whose Associated_Node_For_Itype node is in the subtree\n+   --      is given a new entity, and all references to the original itype\n+   --      are updated to refer to the new itype. In addition, the following\n+   --      semantic fields are replicated and/or updated to refer to a local\n+   --      entity or itype.\n+   --\n+   --        Discriminant_Constraint\n+   --        Etype\n+   --        First_Index\n+   --        Next_Entity\n+   --        Packed_Array_Impl_Type\n+   --        Scalar_Range\n+   --        Scope\n+   --\n+   --      The Associated_Node_For_Itype is updated to refer to a replicated\n+   --      node.\n+   --\n+   --  The routine can replicate both analyzed and unanalyzed trees. Copying an\n+   --  Empty or Error node yields the same node.\n    --\n-   --     old entity 1\n-   --     new entity to replace references to entity 1\n-   --     old entity 2\n-   --     new entity to replace references to entity 2\n-   --     ...\n+   --  Parameter Map may be used to specify a set of mappings between entities.\n+   --  These mappings are then taken into account when replicating entities.\n+   --  The format of Map must be as follows:\n    --\n-   --  The call destroys the contents of Map in this case\n+   --    old entity 1\n+   --    new entity to replace references to entity 1\n+   --    old entity 2\n+   --    new entity to replace references to entity 2\n+   --    ...\n    --\n-   --  The parameter New_Sloc, if set to a value other than No_Location, is\n-   --  used as the Sloc value for all nodes in the new copy. If New_Sloc is\n-   --  set to its default value No_Location, then the Sloc values of the\n-   --  nodes in the copy are simply copied from the corresponding original.\n+   --  Map and its contents are left unchanged.\n    --\n-   --  The Comes_From_Source indication is unchanged if New_Sloc is set to\n-   --  the default No_Location value, but is reset if New_Sloc is given, since\n-   --  in this case the result clearly is neither a source node or an exact\n-   --  copy of a source node.\n+   --  Parameter New_Sloc may be used to specify a new source location for all\n+   --  replicated entities, itypes, and nodes. The Comes_From_Source indicator\n+   --  is defaulted if a new source location is provided.\n    --\n-   --  The parameter New_Scope, if set to a value other than Empty, is the\n-   --  value to use as the Scope for any Itypes that are copied. The most\n-   --  typical value for this parameter, if given, is Current_Scope.\n+   --  Parameter New_Scope may be used to specify a new scope for all copied\n+   --  entities and itypes.\n \n    function New_External_Entity\n      (Kind         : Entity_Kind;\n@@ -2177,7 +2209,7 @@ package Sem_Util is\n    --  allowed as actuals for this function.\n \n    function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id;\n-   --  Retrieve the name of aspect or pragma N taking into account a possible\n+   --  Retrieve the name of aspect or pragma N, taking into account a possible\n    --  rewrite and whether the pragma is generated from an aspect as the names\n    --  may be different. The routine also deals with 'Class in which case it\n    --  returns the following values:"}, {"sha": "cd6b2006e220a47f84e381a5b9cba23027103995", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -1268,7 +1268,19 @@ package body Switch.C is\n                         Bad_Switch (\"-gnatw.\" & Switch_Chars (Ptr .. Max));\n                      end if;\n \n-                     --  Normal case, no dot\n+                  --  Case of underscore switch\n+\n+                  elsif C = '_' and then Ptr < Max then\n+                     Ptr := Ptr + 1;\n+                     C := Switch_Chars (Ptr);\n+\n+                     if Set_Underscore_Warning_Switch (C) then\n+                        Store_Compilation_Switch (\"-gnatw_\" & C);\n+                     else\n+                        Bad_Switch (\"-gnatw_\" & Switch_Chars (Ptr .. Max));\n+                     end if;\n+\n+                  --  Normal case, no dot\n \n                   else\n                      if Set_Warning_Switch (C) then"}, {"sha": "bb712ccacbe98fdca6ecb73f0bfcf01b48cf581a", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -549,6 +549,10 @@ begin\n                                                   \"missing parenthesis\");\n    Write_Line (\"        Q    turn off warnings for questionable \" &\n                                                   \"missing parenthesis\");\n+   Write_Line (\"        .q+  turn on warnings for questionable layout of \" &\n+                                                  \"record types\");\n+   Write_Line (\"        .Q*  turn off warnings for questionable layout of \" &\n+                                                  \"record types\");\n    Write_Line (\"        r+   turn on warnings for redundant construct\");\n    Write_Line (\"        R*   turn off warnings for redundant construct\");\n    Write_Line (\"        .r+  turn on warnings for object renaming function\");"}, {"sha": "c1b91f151b88c52c15fb84cb3eb9ee6462588bd4", "filename": "gcc/ada/warnsw.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fwarnsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fwarnsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.adb?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -471,6 +471,24 @@ package body Warnsw is\n       return True;\n    end Set_Dot_Warning_Switch;\n \n+   -----------------------------------\n+   -- Set_Underscore_Warning_Switch --\n+   -----------------------------------\n+\n+   function Set_Underscore_Warning_Switch (C : Character) return Boolean is\n+   begin\n+      case C is\n+         when others =>\n+            if Ignore_Unrecognized_VWY_Switches then\n+               Write_Line (\"unrecognized switch -gnatw_\" & C & \" ignored\");\n+            else\n+               return False;\n+            end if;\n+      end case;\n+\n+      return True;\n+   end Set_Underscore_Warning_Switch;\n+\n    ----------------------------\n    -- Set_GNAT_Mode_Warnings --\n    ----------------------------"}, {"sha": "af9defbc57c5bcb92e8d42d7d54271400a84f764", "filename": "gcc/ada/warnsw.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fwarnsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683af98c7f55ab61e4764a97b749ef00fc9dfedd/gcc%2Fada%2Fwarnsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.ads?ref=683af98c7f55ab61e4764a97b749ef00fc9dfedd", "patch": "@@ -147,6 +147,13 @@ package Warnsw is\n    --  the command line or .C in a string literal in pragma Warnings. Returns\n    --  True for valid warning character C, False for invalid character.\n \n+   function Set_Underscore_Warning_Switch (C : Character) return Boolean;\n+   --  This function sets the warning switch or switches corresponding to the\n+   --  given character preceded by an underscore. Used to process a -gnatw_\n+   --  switch on the command line or _C in a string literal in pragma Warnings.\n+   --  Returns True for valid warnings character C, False for invalid\n+   --  character.\n+\n    procedure Set_GNAT_Mode_Warnings;\n    --  This is called in -gnatg mode to set the warnings for gnat mode. It is\n    --  also used to set the proper warning statuses for -gnatw.g. Note that"}]}