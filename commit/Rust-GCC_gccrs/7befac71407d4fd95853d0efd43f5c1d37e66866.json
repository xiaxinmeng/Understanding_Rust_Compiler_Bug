{"sha": "7befac71407d4fd95853d0efd43f5c1d37e66866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlZmFjNzE0MDdkNGZkOTU4NTNkMGVmZDQzZjVjMWQzN2U2Njg2Ng==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-10-17T15:22:03Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-10-17T15:22:03Z"}, "message": "mt_allocator.h (__pool::_M_get_align): New.\n\n\n2004-10-17  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/mt_allocator.h (__pool::_M_get_align): New.\n\t(__mt_alloc::allocate): Use it.\n\t* src/mt_allocator.cc (__pool::_M_reclaim_block): Use it.\n\t(__pool::_M_reserve_block): Simplify block allocation.\n\nFrom-SVN: r89171", "tree": {"sha": "e552abb6f5cc931e88759b81d1278e93aa6faa6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e552abb6f5cc931e88759b81d1278e93aa6faa6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7befac71407d4fd95853d0efd43f5c1d37e66866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7befac71407d4fd95853d0efd43f5c1d37e66866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7befac71407d4fd95853d0efd43f5c1d37e66866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7befac71407d4fd95853d0efd43f5c1d37e66866/comments", "author": null, "committer": null, "parents": [{"sha": "a815571193ab94a7821e6c9615af311f060bce2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a815571193ab94a7821e6c9615af311f060bce2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a815571193ab94a7821e6c9615af311f060bce2f"}], "stats": {"total": 114, "additions": 63, "deletions": 51}, "files": [{"sha": "479da1dbe64c637f11a0125f645a987e62facb38", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7befac71407d4fd95853d0efd43f5c1d37e66866", "patch": "@@ -1,3 +1,10 @@\n+2004-10-17  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/mt_allocator.h (__pool::_M_get_align): New.\n+\t(__mt_alloc::allocate): Use it.\n+\t* src/mt_allocator.cc (__pool::_M_reclaim_block): Use it.\n+\t(__pool::_M_reserve_block): Simplify block allocation.\n+\t\n 2004-10-17  Dhruv Matani  <dhruvbird@gmx.net>\n \t    Paolo Carlini  <pcarlini@suse.de>\n \t\t"}, {"sha": "5e587ad43da5a1ce52553e5e5add386f22927c73", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=7befac71407d4fd95853d0efd43f5c1d37e66866", "patch": "@@ -169,6 +169,10 @@ namespace __gnu_cxx\n     _M_get_binmap(size_t __bytes)\n     { return _M_binmap[__bytes]; }\n \n+    const size_t\n+    _M_get_align()\n+    { return _M_options._M_align; }\n+\n     explicit __pool_base() \n     : _M_options(_Tune()), _M_binmap(NULL), _M_init(false) { }\n \n@@ -708,8 +712,7 @@ namespace __gnu_cxx\n \t  __bin._M_first[__thread_id] = __block->_M_next;\n \t  \n \t  __pool._M_adjust_freelist(__bin, __block, __thread_id);\n-\t  const __pool_base::_Tune& __options = __pool._M_get_options();\n-\t  __c = reinterpret_cast<char*>(__block) + __options._M_align;\n+\t  __c = reinterpret_cast<char*>(__block) + __pool._M_get_align();\n \t}\n       else\n \t{"}, {"sha": "bb6ab899cafe5d910b97803bb414007025f9ac77", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7befac71407d4fd95853d0efd43f5c1d37e66866/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=7befac71407d4fd95853d0efd43f5c1d37e66866", "patch": "@@ -58,7 +58,6 @@ namespace __gnu_cxx\n \t      {\n \t\t_Block_address* __tmp = __bin._M_address->_M_next;\n \t\t::operator delete(__bin._M_address->_M_initial);\n-\t\tdelete __bin._M_address;\n \t\t__bin._M_address = __tmp;\n \t      }\n \t    ::operator delete(__bin._M_first);\n@@ -75,8 +74,7 @@ namespace __gnu_cxx\n     const size_t __which = _M_binmap[__bytes];\n     _Bin_record& __bin = _M_bin[__which];\n \n-    const _Tune& __options = _M_get_options();\n-    char* __c = __p - __options._M_align;\n+    char* __c = __p - _M_get_align();\n     _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n       \n     // Single threaded application - return to global pool.\n@@ -91,27 +89,29 @@ namespace __gnu_cxx\n     const size_t __which = _M_binmap[__bytes];\n     _Bin_record& __bin = _M_bin[__which];\n     const _Tune& __options = _M_get_options();\n-    const size_t __bin_size = ((__options._M_min_bin << __which) \n-\t\t\t       + __options._M_align);\n-    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n+    const size_t __bin_size = (__options._M_min_bin << __which) \n+\t\t\t       + __options._M_align;\n+    size_t __block_count = __options._M_chunk_size - sizeof(_Block_address);\n+    __block_count /= __bin_size;\t  \n \n     // Get a new block dynamically, set it up for use.\n     void* __v = ::operator new(__options._M_chunk_size);\n-    _Block_record* __block = static_cast<_Block_record*>(__v);\n+    _Block_address* __address = static_cast<_Block_address*>(__v);\n+    __address->_M_initial = __v;\n+    __address->_M_next = __bin._M_address;\n+    __bin._M_address = __address;\n+\n+    char* __c = static_cast<char*>(__v) + sizeof(_Block_address);\n+    _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n     __bin._M_first[__thread_id] = __block;\n     while (--__block_count > 0)\n       {\n-\tchar* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t__c += __bin_size;\n \t__block->_M_next = reinterpret_cast<_Block_record*>(__c);\n \t__block = __block->_M_next;\n       }\n     __block->_M_next = NULL;\n \n-    _Block_address* __address = new _Block_address;\n-    __address->_M_initial = __v;\n-    __address->_M_next = __bin._M_address;\n-    __bin._M_address = __address;\n-\n     __block = __bin._M_first[__thread_id];\n     __bin._M_first[__thread_id] = __block->_M_next;\n \n@@ -187,7 +187,6 @@ namespace __gnu_cxx\n \t\t  {\n \t\t    _Block_address* __tmp = __bin._M_address->_M_next;\n \t\t    ::operator delete(__bin._M_address->_M_initial);\n-\t\t    delete __bin._M_address;\n \t\t    __bin._M_address = __tmp;\n \t\t  }\n \t\t::operator delete(__bin._M_first);\n@@ -206,7 +205,6 @@ namespace __gnu_cxx\n \t\t  {\n \t\t    _Block_address* __tmp = __bin._M_address->_M_next;\n \t\t    ::operator delete(__bin._M_address->_M_initial);\n-\t\t    delete __bin._M_address;\n \t\t    __bin._M_address = __tmp;\n \t\t  }\n \t\t::operator delete(__bin._M_first);\n@@ -224,27 +222,31 @@ namespace __gnu_cxx\n     const size_t __which = _M_binmap[__bytes];\n     const _Bin_record& __bin = _M_bin[__which];\n \n-    const _Tune& __options = _M_get_options();\n-    char* __c = __p - __options._M_align;\n+    // Know __p not null, assume valid block.\n+    char* __c = __p - _M_get_align();\n     _Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n     if (__gthread_active_p())\n       {\n \t// Calculate the number of records to remove from our freelist:\n \t// in order to avoid too much contention we wait until the\n \t// number of records is \"high enough\".\n \tconst size_t __thread_id = _M_get_thread_id();\n-\t\n-\tlong __remove = ((__bin._M_free[__thread_id] \n-\t\t\t  * __options._M_freelist_headroom)\n-\t\t\t - __bin._M_used[__thread_id]);\n-\tif (__remove > static_cast<long>(100 * (_M_bin_size - __which)\n-\t\t\t\t\t * __options._M_freelist_headroom)\n-\t    && __remove > static_cast<long>(__bin._M_free[__thread_id]))\n+\tconst _Tune& __options = _M_get_options();\t\n+\tconst unsigned long __limit = 100 * (_M_bin_size - __which)\n+\t\t                      * __options._M_freelist_headroom;\n+\n+\tunsigned long __remove = __bin._M_free[__thread_id];\n+\t__remove *= __options._M_freelist_headroom;\n+\tif (__remove >= __bin._M_used[__thread_id])\n+\t  __remove -= __bin._M_used[__thread_id];\n+\telse\n+\t  __remove = 0;\n+\tif (__remove > __limit && __remove > __bin._M_free[__thread_id])\n \t  {\n-\t    _Block_record* __tmp = __bin._M_first[__thread_id];\n-\t    _Block_record* __first = __tmp;\n+\t    _Block_record* __first = __bin._M_first[__thread_id];\n+\t    _Block_record* __tmp = __first;\n \t    __remove /= __options._M_freelist_headroom;\n-\t    const long __removed = __remove;\n+\t    const unsigned long __removed = __remove;\n \t    while (--__remove > 0)\n \t      __tmp = __tmp->_M_next;\n \t    __bin._M_first[__thread_id] = __tmp->_M_next;\n@@ -256,7 +258,7 @@ namespace __gnu_cxx\n \t    __bin._M_free[0] += __removed;\n \t    __gthread_mutex_unlock(__bin._M_mutex);\n \t  }\n-\t\n+\n \t// Return this block to our list and update counters and\n \t// owner id as needed.\n \t--__bin._M_used[__block->_M_thread_id];\n@@ -283,7 +285,8 @@ namespace __gnu_cxx\n     const _Tune& __options = _M_get_options();\n     const size_t __bin_size = ((__options._M_min_bin << __which)\n \t\t\t       + __options._M_align);\n-    size_t __block_count = __options._M_chunk_size / __bin_size;\t  \n+    size_t __block_count = __options._M_chunk_size - sizeof(_Block_address);\n+    __block_count /= __bin_size;\t  \n     \n     // Are we using threads?\n     // - Yes, check if there are free blocks on the global\n@@ -302,28 +305,26 @@ namespace __gnu_cxx\n \t__gthread_mutex_lock(__bin._M_mutex);\n \tif (__bin._M_first[0] == NULL)\n \t  {\n-\t    // No need to hold the lock when we are adding a whole\n-\t    // chunk to our own list.\n+\t    void* __v = ::operator new(__options._M_chunk_size);\n+\t    _Block_address* __address = static_cast<_Block_address*>(__v);\n+\t    __address->_M_initial = __v;\n+\t    __address->_M_next = __bin._M_address;\n+\t    __bin._M_address = __address;\n \t    __gthread_mutex_unlock(__bin._M_mutex);\n \n-\t    void* __v = ::operator new(__options._M_chunk_size);\n-\t    __block = static_cast<_Block_record*>(__v);\n+\t    // No need to hold the lock when we are adding a whole\n+\t    // chunk to our own list.\n+\t    char* __c = static_cast<char*>(__v) + sizeof(_Block_address);\n+\t    __block = reinterpret_cast<_Block_record*>(__c);\n \t    __bin._M_free[__thread_id] = __block_count;\n \t    __bin._M_first[__thread_id] = __block;\n \t    while (--__block_count > 0)\n \t      {\n-\t\tchar* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t\t__c += __bin_size;\n \t\t__block->_M_next = reinterpret_cast<_Block_record*>(__c);\n \t\t__block = __block->_M_next;\n \t      }\n \t    __block->_M_next = NULL;\n-\n-\t    __gthread_mutex_lock(__bin._M_mutex);\n-\t    _Block_address* __address = new _Block_address;\n-\t    __address->_M_initial = __v;\n-\t    __address->_M_next = __bin._M_address;\n-\t    __bin._M_address = __address;\n-\t    __gthread_mutex_unlock(__bin._M_mutex);\n \t  }\n \telse\n \t  {\n@@ -353,20 +354,21 @@ namespace __gnu_cxx\n     else\n       {\n \tvoid* __v = ::operator new(__options._M_chunk_size);\n-\t__block = static_cast<_Block_record*>(__v);\n-\t__bin._M_first[0] = __block;\n+\t_Block_address* __address = static_cast<_Block_address*>(__v);\n+\t__address->_M_initial = __v;\n+\t__address->_M_next = __bin._M_address;\n+\t__bin._M_address = __address;\n+\n+\tchar* __c = static_cast<char*>(__v) + sizeof(_Block_address);\n+\t_Block_record* __block = reinterpret_cast<_Block_record*>(__c);\n+ \t__bin._M_first[0] = __block;\n \twhile (--__block_count > 0)\n \t  {\n-\t    char* __c = reinterpret_cast<char*>(__block) + __bin_size;\n+\t    __c += __bin_size;\n \t    __block->_M_next = reinterpret_cast<_Block_record*>(__c);\n \t    __block = __block->_M_next;\n \t  }\n \t__block->_M_next = NULL;\n-\n-\t_Block_address* __address = new _Block_address;\n-\t__address->_M_initial = __v;\n-\t__address->_M_next = __bin._M_address;\n-\t__bin._M_address = __address;\n       }\n       \n     __block = __bin._M_first[__thread_id];"}]}