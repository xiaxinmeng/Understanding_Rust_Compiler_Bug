{"sha": "dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlMTJmY2QxMTc2NGQzYTFjMmY1ZjZmOGQwMGEyYjE3ZjExMTllYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-25T20:15:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-25T20:15:10Z"}, "message": "decl.c (gnat_to_gnu_entity): Use XNEW instead of xmalloc.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Subtype>: Use\n\tXNEW instead of xmalloc.  Do not build useless pointer type.\n\t<E_Anonymous_Access_Subprogram_Type>: Use XNEW instead of xmalloc.\n\t* gcc-interface/trans.c (gnat_to_gnu) <N_Raise_Constraint_Error>: Tidy.\n\t* gcc-interface/utils2.c (build_unary_op): Remove local variable.\n\nFrom-SVN: r179168", "tree": {"sha": "135262bbdf17968f20151428c4863f4df55757d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/135262bbdf17968f20151428c4863f4df55757d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/comments", "author": null, "committer": null, "parents": [{"sha": "dea976c48066580dff56c1055027d7398072bfc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea976c48066580dff56c1055027d7398072bfc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea976c48066580dff56c1055027d7398072bfc9"}], "stats": {"total": 142, "additions": 67, "deletions": 75}, "files": [{"sha": "34f6f1dd89d6bffcbfaab0b5b59cea330ebcf345", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "patch": "@@ -1,3 +1,11 @@\n+2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Subtype>: Use\n+\tXNEW instead of xmalloc.  Do not build useless pointer type.\n+\t<E_Anonymous_Access_Subprogram_Type>: Use XNEW instead of xmalloc.\n+\t* gcc-interface/trans.c (gnat_to_gnu) <N_Raise_Constraint_Error>: Tidy.\n+\t* gcc-interface/utils2.c (build_unary_op): Remove local variable.\n+\n 2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Do not promote"}, {"sha": "fb552ae0e50ef03bdf358aee362f72f4637a0431", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "patch": "@@ -3512,8 +3512,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t fill it in later.  */\n       if (!definition && defer_incomplete_level != 0)\n \t{\n-\t  struct incomplete *p\n-\t    = (struct incomplete *) xmalloc (sizeof (struct incomplete));\n+\t  struct incomplete *p = XNEW (struct incomplete);\n \n \t  gnu_type\n \t    = build_pointer_type\n@@ -3838,15 +3837,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Access_Subtype:\n \n       /* We treat this as identical to its base type; any constraint is\n-\t meaningful only to the front end.\n+\t meaningful only to the front-end.\n \n \t The designated type must be elaborated as well, if it does\n \t not have its own freeze node.  Designated (sub)types created\n \t for constrained components of records with discriminants are\n-\t not frozen by the front end and thus not elaborated by gigi,\n+\t not frozen by the front-end and thus not elaborated by gigi,\n \t because their use may appear before the base type is frozen,\n \t and because it is not clear that they are needed anywhere in\n-\t Gigi.  With the current model, there is no correct place where\n+\t gigi.  With the current model, there is no correct place where\n \t they could be elaborated.  */\n \n       gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n@@ -3860,20 +3859,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     elaborate it later.  */\n \t  if (!definition && defer_incomplete_level != 0)\n \t    {\n-\t      struct incomplete *p\n-\t\t= (struct incomplete *) xmalloc (sizeof (struct incomplete));\n-\t      tree gnu_ptr_type\n-\t\t= build_pointer_type\n-\t\t  (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n+\t      struct incomplete *p = XNEW (struct incomplete);\n \n-\t      p->old_type = TREE_TYPE (gnu_ptr_type);\n+\t      p->old_type\n+\t\t= make_dummy_type (Directly_Designated_Type (gnat_entity));\n \t      p->full_type = Directly_Designated_Type (gnat_entity);\n \t      p->next = defer_incomplete_list;\n \t      defer_incomplete_list = p;\n \t    }\n \t  else if (!IN (Ekind (Base_Type\n-\t\t\t      (Directly_Designated_Type (gnat_entity))),\n-\t\t       Incomplete_Or_Private_Kind))\n+\t\t\t       (Directly_Designated_Type (gnat_entity))),\n+\t\t        Incomplete_Or_Private_Kind))\n \t    gnat_to_gnu_entity (Directly_Designated_Type (gnat_entity),\n \t\t\t\tNULL_TREE, 0);\n \t}"}, {"sha": "8a8fef8dc35f96ce36784baa1e1a45c5c3729300", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "patch": "@@ -5794,7 +5794,6 @@ gnat_to_gnu (Node_Id gnat_node)\n       {\n \tconst int reason = UI_To_Int (Reason (gnat_node));\n \tconst Node_Id cond = Condition (gnat_node);\n-\tbool handled = false;\n \n \tif (type_annotate_only)\n \t  {\n@@ -5807,65 +5806,58 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (Exception_Extra_Info\n \t    && !No_Exception_Handlers_Set ()\n \t    && !get_exception_label (kind)\n-\t    && TREE_CODE (gnu_result_type) == VOID_TYPE\n+\t    && VOID_TYPE_P (gnu_result_type)\n \t    && Present (cond))\n-\t  {\n-\t    if (reason == CE_Access_Check_Failed)\n-\t      {\n-\t\tgnu_result = build_call_raise_column (reason, gnat_node);\n-\t\thandled = true;\n-\t      }\n-\t    else if ((reason == CE_Index_Check_Failed\n-\t\t      || reason == CE_Range_Check_Failed\n-\t\t      || reason == CE_Invalid_Data)\n-\t\t     && Nkind (cond) == N_Op_Not\n-\t\t     && Nkind (Right_Opnd (cond)) == N_In\n-\t\t     && Nkind (Right_Opnd (Right_Opnd (cond))) == N_Range)\n-\t      {\n-\t\tNode_Id op = Right_Opnd (cond);  /* N_In node */\n-\t\tNode_Id index = Left_Opnd (op);\n-\t\tNode_Id type = Etype (index);\n+\t  switch (reason)\n+\t    {\n+\t    case CE_Access_Check_Failed:\n+\t      gnu_result = build_call_raise_column (reason, gnat_node);\n+\t      break;\n \n-\t\tif (Is_Type (type)\n-\t\t    && Known_Esize (type)\n-\t\t    && UI_To_Int (Esize (type)) <= 32)\n-\t\t  {\n-\t\t    Node_Id right_op = Right_Opnd (op);\n+\t    case CE_Index_Check_Failed:\n+\t    case CE_Range_Check_Failed:\n+\t    case CE_Invalid_Data:\n+\t      if (Nkind (cond) == N_Op_Not\n+\t\t  && Nkind (Right_Opnd (cond)) == N_In\n+\t\t  && Nkind (Right_Opnd (Right_Opnd (cond))) == N_Range)\n+\t\t{\n+\t\t  Node_Id op = Right_Opnd (cond);  /* N_In node */\n+\t\t  Node_Id index = Left_Opnd (op);\n+\t\t  Node_Id range = Right_Opnd (op);\n+\t\t  Node_Id type = Etype (index);\n+\t\t  if (Is_Type (type)\n+\t\t      && Known_Esize (type)\n+\t\t      && UI_To_Int (Esize (type)) <= 32)\n \t\t    gnu_result\n-\t\t      = build_call_raise_range\n-\t\t        (reason, gnat_node,\n-\t\t         gnat_to_gnu (index),                  /* index */\n-\t\t         gnat_to_gnu (Low_Bound (right_op)),   /* first */\n-\t\t         gnat_to_gnu (High_Bound (right_op))); /* last  */\n-\t\t    handled = true;\n-\t\t  }\n-\t      }\n+\t\t      = build_call_raise_range (reason, gnat_node,\n+\t\t\t\t\t\tgnat_to_gnu (index),\n+\t\t\t\t\t\tgnat_to_gnu\n+\t\t\t\t\t\t(Low_Bound (range)),\n+\t\t\t\t\t\tgnat_to_gnu\n+\t\t\t\t\t\t(High_Bound (range)));\n+\t        }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n \t  }\n \n-\tif (handled)\n+\tif (gnu_result == error_mark_node)\n+\t  gnu_result = build_call_raise (reason, gnat_node, kind);\n+\n+\tset_expr_location_from_node (gnu_result, gnat_node);\n+\n+\t/* If the type is VOID, this is a statement, so we need to generate\n+\t   the code for the call.  Handle a condition, if there is one.  */\n+\tif (VOID_TYPE_P (gnu_result_type))\n \t  {\n-\t    set_expr_location_from_node (gnu_result, gnat_node);\n-\t    gnu_result = build3 (COND_EXPR, void_type_node,\n-\t\t\t\t gnat_to_gnu (cond),\n-\t\t\t\t gnu_result, alloc_stmt_list ());\n+\t    if (Present (cond))\n+\t      gnu_result\n+\t\t= build3 (COND_EXPR, void_type_node, gnat_to_gnu (cond),\n+\t\t\t  gnu_result, alloc_stmt_list ());\n \t  }\n \telse\n-\t  {\n-\t    gnu_result = build_call_raise (reason, gnat_node, kind);\n-\n-\t    /* If the type is VOID, this is a statement, so we need to generate\n-\t       the code for the call.  Handle a Condition, if there is one.  */\n-\t    if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n-\t      {\n-\t\tset_expr_location_from_node (gnu_result, gnat_node);\n-\t\tif (Present (cond))\n-\t\t  gnu_result = build3 (COND_EXPR, void_type_node,\n-\t\t\t\t       gnat_to_gnu (cond),\n-\t\t\t\t       gnu_result, alloc_stmt_list ());\n-\t      }\n-\t    else\n-\t      gnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);\n-\t  }\n+\t  gnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);\n       }\n       break;\n "}, {"sha": "0849508f4066e3550c421db08364687497803ce4", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "patch": "@@ -1000,7 +1000,6 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n   tree base_type = get_base_type (type);\n   tree operation_type = result_type;\n   tree result;\n-  bool side_effects = false;\n \n   if (operation_type\n       && TREE_CODE (operation_type) == RECORD_TYPE\n@@ -1235,8 +1234,12 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n \t}\n \n-      side_effects\n-\t= (!TYPE_IS_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n+      if (!TYPE_IS_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)))\n+\t{\n+\t  TREE_SIDE_EFFECTS (result) = 1;\n+\t  if (TREE_CODE (result) == INDIRECT_REF)\n+\t    TREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n+\t}\n       break;\n \n     case NEGATE_EXPR:\n@@ -1322,13 +1325,6 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t\t    convert (operation_type, operand));\n     }\n \n-  if (side_effects)\n-    {\n-      TREE_SIDE_EFFECTS (result) = 1;\n-      if (TREE_CODE (result) == INDIRECT_REF)\n-\tTREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n-    }\n-\n   if (result_type && TREE_TYPE (result) != result_type)\n     result = convert (result_type, result);\n "}]}