{"sha": "8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYzMzA0ZDAxOWJkMWY5YThlYjA4YjlkYmEzYTQzMGE1OWY1Mjk5NA==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2016-02-16T14:11:24Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2016-02-16T14:11:24Z"}, "message": "[ARC] Add single/double IEEE precission FPU support.\n\ngcc/\n2016-02-16  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-modes.def (CC_FPU, CC_FPU_UNEQ): New modes.\n\t* config/arc/arc-opts.h (FPU_SP, FPU_SF, FPU_SC, FPU_SD, FPU_DP)\n\t(FPU_DF, FPU_DC, FPU_DD, FXP_DP): Define.\n\t* config/arc/arc.c (arc_init): Check FPU options.\n\t(get_arc_condition_code): Handle new CC_FPU* modes.\n\t(arc_select_cc_mode): Likewise.\n\t(arc_conditional_register_usage): Allow 64 bit datum into even-odd\n\tregister pair only. Allow access for ARCv2 accumulator.\n\t(gen_compare_reg): Whenever we have FPU support use FPU compare\n\tinstructions.\n\t(arc_reorg): Don't generate brcc insns when FPU compare\n\tinstructions are involved.\n\t* config/arc/arc.h (TARGET_DPFP): Add TARGET_FP_DPAX condition.\n\t(TARGET_OPTFPE): Add condition when ARC EM can use optimized\n\tfloating point emulation.\n\t(ACC_REG_FIRST, ACC_REG_LAST, ACCL_REGNO, ACCH_REGNO): Define.\n\t(REVERSE_CONDITION): Add new CC_FPU* modes.\n\t(TARGET_FP_SP_BASE): Define.\n\t(TARGET_FP_DP_BASE): Likewise.\n\t(TARGET_FP_SP_FUSED): Likewise.\n\t(TARGET_FP_DP_FUSED): Likewise.\n\t(TARGET_FP_SP_CONV): Likewise.\n\t(TARGET_FP_DP_CONV): Likewise.\n\t(TARGET_FP_SP_SQRT): Likewise.\n\t(TARGET_FP_DP_SQRT): Likewise.\n\t(TARGET_FP_DP_AX): Likewise.\n\t* config/arc/arc.md (ARCV2_ACC): New constant.\n\t(type): New fpu type attribute.\n\t(SDF): Conditional iterator.\n\t(cstore<mode>, cbranch<mode>): Change expand condition.\n\t(addsf3, subsf3, mulsf3, adddf3, subdf3, muldf3): New expands,\n\thandles FPU/FPX cases as well.\n\t* config/arc/arc.opt (mfpu): New option.\n\t* config/arc/fpx.md (addsf3_fpx, subsf3_fpx, mulsf3_fpx):\n\tRenamed.\n\t(adddf3, muldf3, subdf3): Removed.\n\t* config/arc/predicates.md (proper_comparison_operator): Recognize\n\tCC_FPU* modes.\n\t* config/arc/fpu.md: New file.\n\t* doc/invoke.texi (ARC Options): Document mfpu option.\n\nFrom-SVN: r233451", "tree": {"sha": "da942afd8cfd2f846b537d732131dfa2f973eb74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da942afd8cfd2f846b537d732131dfa2f973eb74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d5b1a52eec591a9a995e47880c87333b42ebb870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b1a52eec591a9a995e47880c87333b42ebb870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b1a52eec591a9a995e47880c87333b42ebb870"}], "stats": {"total": 1207, "additions": 1103, "deletions": 104}, "files": [{"sha": "d41547a2da020cf85381c47d6b33e7415a90b1cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -1,3 +1,46 @@\n+2016-02-16  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-modes.def (CC_FPU, CC_FPU_UNEQ): New modes.\n+\t* config/arc/arc-opts.h (FPU_SP, FPU_SF, FPU_SC, FPU_SD, FPU_DP)\n+\t(FPU_DF, FPU_DC, FPU_DD, FXP_DP): Define.\n+\t* config/arc/arc.c (arc_init): Check FPU options.\n+\t(get_arc_condition_code): Handle new CC_FPU* modes.\n+\t(arc_select_cc_mode): Likewise.\n+\t(arc_conditional_register_usage): Allow 64 bit datum into even-odd\n+\tregister pair only. Allow access for ARCv2 accumulator.\n+\t(gen_compare_reg): Whenever we have FPU support use FPU compare\n+\tinstructions.\n+\t(arc_reorg): Don't generate brcc insns when FPU compare\n+\tinstructions are involved.\n+\t* config/arc/arc.h (TARGET_DPFP): Add TARGET_FP_DPAX condition.\n+\t(TARGET_OPTFPE): Add condition when ARC EM can use optimized\n+\tfloating point emulation.\n+\t(ACC_REG_FIRST, ACC_REG_LAST, ACCL_REGNO, ACCH_REGNO): Define.\n+\t(REVERSE_CONDITION): Add new CC_FPU* modes.\n+\t(TARGET_FP_SP_BASE): Define.\n+\t(TARGET_FP_DP_BASE): Likewise.\n+\t(TARGET_FP_SP_FUSED): Likewise.\n+\t(TARGET_FP_DP_FUSED): Likewise.\n+\t(TARGET_FP_SP_CONV): Likewise.\n+\t(TARGET_FP_DP_CONV): Likewise.\n+\t(TARGET_FP_SP_SQRT): Likewise.\n+\t(TARGET_FP_DP_SQRT): Likewise.\n+\t(TARGET_FP_DP_AX): Likewise.\n+\t* config/arc/arc.md (ARCV2_ACC): New constant.\n+\t(type): New fpu type attribute.\n+\t(SDF): Conditional iterator.\n+\t(cstore<mode>, cbranch<mode>): Change expand condition.\n+\t(addsf3, subsf3, mulsf3, adddf3, subdf3, muldf3): New expands,\n+\thandles FPU/FPX cases as well.\n+\t* config/arc/arc.opt (mfpu): New option.\n+\t* config/arc/fpx.md (addsf3_fpx, subsf3_fpx, mulsf3_fpx):\n+\tRenamed.\n+\t(adddf3, muldf3, subdf3): Removed.\n+\t* config/arc/predicates.md (proper_comparison_operator): Recognize\n+\tCC_FPU* modes.\n+\t* config/arc/fpu.md: New file.\n+\t* doc/invoke.texi (ARC Options): Document mfpu option.\n+\n 2016-02-16  Richard Biener  <rguenther@suse.de>\n \n \tPR rtl-optimization/69291"}, {"sha": "921a59876a1956892d6b5f6c25666dbf227cdbaf", "filename": "gcc/config/arc/arc-modes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-modes.def?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -35,3 +35,7 @@ CC_MODE (CC_FPX);\n VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n+\n+/* FPU condition flags.  */\n+CC_MODE (CC_FPU);\n+CC_MODE (CC_FPU_UNEQ);"}, {"sha": "1e11ebc41ffb226de71c5d01aaf39da55c3a071a", "filename": "gcc/config/arc/arc-opts.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-opts.h?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -27,3 +27,23 @@ enum processor_type\n   PROCESSOR_ARCEM,\n   PROCESSOR_ARCHS\n };\n+\n+/* Single precision floating point.  */\n+#define FPU_SP    0x0001\n+/* Single precision fused floating point operations.  */\n+#define FPU_SF    0x0002\n+/* Single precision floating point format conversion operations.  */\n+#define FPU_SC    0x0004\n+/* Single precision floating point sqrt and div operations.  */\n+#define FPU_SD    0x0008\n+/* Double precision floating point.  */\n+#define FPU_DP    0x0010\n+/* Double precision fused floating point operations.  */\n+#define FPU_DF    0x0020\n+/* Double precision floating point format conversion operations.  */\n+#define FPU_DC    0x0040\n+/* Double precision floating point sqrt and div operations.  */\n+#define FPU_DD    0x0080\n+/* Double precision floating point assist operations.  */\n+#define FPX_DP    0x0100\n+"}, {"sha": "d60db502ef85eb07cca0d582a21265584e51b714", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 131, "deletions": 21, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -719,9 +719,16 @@ arc_init (void)\n \n   /* FPX-3. No FPX extensions on pre-ARC600 cores.  */\n   if ((TARGET_DPFP || TARGET_SPFP)\n-      && !TARGET_ARCOMPACT_FAMILY)\n+      && (!TARGET_ARCOMPACT_FAMILY && !TARGET_EM))\n     error (\"FPX extensions not available on pre-ARC600 cores\");\n \n+  /* FPX-4.  No FPX extensions mixed with FPU extensions for ARC HS\n+     cpus.  */\n+  if ((TARGET_DPFP || TARGET_SPFP)\n+      && TARGET_HARD_FLOAT\n+      && TARGET_HS)\n+    error (\"No FPX/FPU mixing allowed\");\n+\n   /* Only selected multiplier configurations are available for HS.  */\n   if (TARGET_HS && ((arc_mpy_option > 2 && arc_mpy_option < 7)\n \t\t    || (arc_mpy_option == 1)))\n@@ -743,6 +750,19 @@ arc_init (void)\n   if (TARGET_LL64 && !TARGET_HS)\n     error (\"-mll64 is only supported for ARC HS cores\");\n \n+  /* FPU support only for V2.  */\n+  if (TARGET_HARD_FLOAT)\n+    {\n+      if (TARGET_EM\n+\t  && (arc_fpu_build & ~(FPU_SP | FPU_SF | FPU_SC | FPU_SD | FPX_DP)))\n+\terror (\"FPU double precision options are available for ARC HS only\");\n+      if (TARGET_HS && (arc_fpu_build & FPX_DP))\n+\terror (\"FPU double precision assist \"\n+\t       \"options are not available for ARC HS\");\n+      if (!TARGET_HS && !TARGET_EM)\n+\terror (\"FPU options are available for ARCv2 architecture only\");\n+    }\n+\n   arc_init_reg_tables ();\n \n   /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n@@ -926,6 +946,33 @@ get_arc_condition_code (rtx comparison)\n \tcase UNEQ      : return ARC_CC_LS;\n \tdefault : gcc_unreachable ();\n \t}\n+    case CC_FPUmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ\t       : return ARC_CC_EQ;\n+\tcase NE\t       : return ARC_CC_NE;\n+\tcase GT\t       : return ARC_CC_GT;\n+\tcase GE\t       : return ARC_CC_GE;\n+\tcase LT\t       : return ARC_CC_C;\n+\tcase LE\t       : return ARC_CC_LS;\n+\tcase UNORDERED : return ARC_CC_V;\n+\tcase ORDERED   : return ARC_CC_NV;\n+\tcase UNGT      : return ARC_CC_HI;\n+\tcase UNGE      : return ARC_CC_HS;\n+\tcase UNLT      : return ARC_CC_LT;\n+\tcase UNLE      : return ARC_CC_LE;\n+\t  /* UNEQ and LTGT do not have representation.  */\n+\tcase LTGT      : /* Fall through.  */\n+\tcase UNEQ      : /* Fall through.  */\n+\tdefault : gcc_unreachable ();\n+\t}\n+    case CC_FPU_UNEQmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase LTGT : return ARC_CC_NE;\n+\tcase UNEQ : return ARC_CC_EQ;\n+\tdefault : gcc_unreachable ();\n+\t}\n     default : gcc_unreachable ();\n     }\n   /*NOTREACHED*/\n@@ -1009,19 +1056,46 @@ arc_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \treturn CC_FP_GEmode;\n       default: gcc_unreachable ();\n       }\n-  else if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_OPTFPE)\n+  else if (TARGET_HARD_FLOAT\n+\t   && ((mode == SFmode && TARGET_FP_SP_BASE)\n+\t       || (mode == DFmode && TARGET_FP_DP_BASE)))\n     switch (op)\n       {\n-      case EQ: case NE: return CC_Zmode;\n-      case LT: case UNGE:\n-      case GT: case UNLE: return CC_FP_GTmode;\n-      case LE: case UNGT:\n-      case GE: case UNLT: return CC_FP_GEmode;\n-      case UNEQ: case LTGT: return CC_FP_UNEQmode;\n-      case ORDERED: case UNORDERED: return CC_FP_ORDmode;\n-      default: gcc_unreachable ();\n-      }\n+      case EQ:\n+      case NE:\n+      case UNORDERED:\n+      case ORDERED:\n+      case UNLT:\n+      case UNLE:\n+      case UNGT:\n+      case UNGE:\n+      case LT:\n+      case LE:\n+      case GT:\n+      case GE:\n+\treturn CC_FPUmode;\n+\n+      case LTGT:\n+      case UNEQ:\n+\treturn CC_FPU_UNEQmode;\n \n+      default:\n+\tgcc_unreachable ();\n+      }\n+  else if (GET_MODE_CLASS (mode) == MODE_FLOAT && TARGET_OPTFPE)\n+    {\n+      switch (op)\n+\t{\n+\tcase EQ: case NE: return CC_Zmode;\n+\tcase LT: case UNGE:\n+\tcase GT: case UNLE: return CC_FP_GTmode;\n+\tcase LE: case UNGT:\n+\tcase GE: case UNLT: return CC_FP_GEmode;\n+\tcase UNEQ: case LTGT: return CC_FP_UNEQmode;\n+\tcase ORDERED: case UNORDERED: return CC_FP_ORDmode;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    }\n   return CCmode;\n }\n \n@@ -1148,7 +1222,8 @@ arc_init_reg_tables (void)\n \t     we must explicitly check for them here.  */\n \t  if (i == (int) CCmode || i == (int) CC_ZNmode || i == (int) CC_Zmode\n \t      || i == (int) CC_Cmode\n-\t      || i == CC_FP_GTmode || i == CC_FP_GEmode || i == CC_FP_ORDmode)\n+\t      || i == CC_FP_GTmode || i == CC_FP_GEmode || i == CC_FP_ORDmode\n+\t      || i == CC_FPUmode || i == CC_FPU_UNEQmode)\n \t    arc_mode_class[i] = 1 << (int) C_MODE;\n \t  else\n \t    arc_mode_class[i] = 0;\n@@ -1282,6 +1357,16 @@ arc_conditional_register_usage (void)\n \tarc_hard_regno_mode_ok[60] = 1 << (int) S_MODE;\n     }\n \n+  /* ARCHS has 64-bit data-path which makes use of the even-odd paired\n+     registers.  */\n+  if (TARGET_HS)\n+    {\n+      for (regno = 1; regno < 32; regno +=2)\n+\t{\n+\t  arc_hard_regno_mode_ok[regno] = S_MODES;\n+\t}\n+    }\n+\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       if (i < 29)\n@@ -1376,6 +1461,19 @@ arc_conditional_register_usage (void)\n \n   /* pc : r63 */\n   arc_regno_reg_class[PROGRAM_COUNTER_REGNO] = GENERAL_REGS;\n+\n+  /*ARCV2 Accumulator.  */\n+  if (TARGET_V2\n+      && (TARGET_FP_DP_FUSED || TARGET_FP_SP_FUSED))\n+  {\n+    arc_regno_reg_class[ACCL_REGNO] = WRITABLE_CORE_REGS;\n+    arc_regno_reg_class[ACCH_REGNO] = WRITABLE_CORE_REGS;\n+    SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], ACCL_REGNO);\n+    SET_HARD_REG_BIT (reg_class_contents[WRITABLE_CORE_REGS], ACCH_REGNO);\n+    SET_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], ACCL_REGNO);\n+    SET_HARD_REG_BIT (reg_class_contents[CHEAP_CORE_REGS], ACCH_REGNO);\n+    arc_hard_regno_mode_ok[ACC_REG_FIRST] = D_MODES;\n+  }\n }\n \n /* Handle an \"interrupt\" attribute; arguments as in\n@@ -1545,6 +1643,10 @@ gen_compare_reg (rtx comparison, machine_mode omode)\n \t\t\t\t\t\t gen_rtx_REG (CC_FPXmode, 61),\n \t\t\t\t\t\t const0_rtx)));\n     }\n+  else if (TARGET_HARD_FLOAT\n+\t   && ((cmode == SFmode && TARGET_FP_SP_BASE)\n+\t       || (cmode == DFmode && TARGET_FP_DP_BASE)))\n+    emit_insn (gen_rtx_SET (cc_reg, gen_rtx_COMPARE (mode, x, y)));\n   else if (GET_MODE_CLASS (cmode) == MODE_FLOAT && TARGET_OPTFPE)\n     {\n       rtx op0 = gen_rtx_REG (cmode, 0);\n@@ -1638,10 +1740,11 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n   /* We must treat `__builtin_va_alist' as an anonymous arg.  */\n \n   next_cum = *get_cumulative_args (args_so_far);\n-  arc_function_arg_advance (pack_cumulative_args (&next_cum), mode, type, 1);\n+  arc_function_arg_advance (pack_cumulative_args (&next_cum),\n+\t\t\t    mode, type, true);\n   first_anon_arg = next_cum;\n \n-  if (first_anon_arg < MAX_ARC_PARM_REGS)\n+  if (FUNCTION_ARG_REGNO_P (first_anon_arg))\n     {\n       /* First anonymous (unnamed) argument is in a reg.  */\n \n@@ -4856,8 +4959,6 @@ arc_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n   return ret;\n }\n \n-\n-\n /* This function is used to control a function argument is passed in a\n    register, and which register.\n \n@@ -4895,8 +4996,10 @@ arc_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n    and the rest are pushed.  */\n \n static rtx\n-arc_function_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t  const_tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+arc_function_arg (cumulative_args_t cum_v,\n+\t\t  machine_mode mode,\n+\t\t  const_tree type ATTRIBUTE_UNUSED,\n+\t\t  bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int arg_num = *cum;\n@@ -4942,8 +5045,10 @@ arc_function_arg (cumulative_args_t cum_v, machine_mode mode,\n    course function_arg_partial_nregs will come into play.  */\n \n static void\n-arc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+arc_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  machine_mode mode,\n+\t\t\t  const_tree type,\n+\t\t\t  bool named ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes = (mode == BLKmode\n@@ -6398,6 +6503,11 @@ arc_reorg (void)\n \n \t  pc_target = SET_SRC (pattern);\n \n+\t  /* Avoid FPU instructions.  */\n+\t  if ((GET_MODE (XEXP (XEXP (pc_target, 0), 0)) == CC_FPUmode)\n+\t      || (GET_MODE (XEXP (XEXP (pc_target, 0), 0)) == CC_FPU_UNEQmode))\n+\t    continue;\n+\n \t  /* Now go back and search for the set cc insn.  */\n \n \t  label = XEXP (pc_target, 1);\n@@ -6420,7 +6530,7 @@ arc_reorg (void)\n \t\t      break;\n \t\t    }\n \t\t}\n-\t      if (! link_insn)\n+\t      if (!link_insn)\n \t\tcontinue;\n \t      else\n \t\t/* Check if this is a data dependency.  */"}, {"sha": "21c049f98508d5774b8b1f0ff48f85c78952d6be", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -255,7 +255,8 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_MIXED_CODE (TARGET_MIXED_CODE_SET)\n \n #define TARGET_SPFP (TARGET_SPFP_FAST_SET || TARGET_SPFP_COMPACT_SET)\n-#define TARGET_DPFP (TARGET_DPFP_FAST_SET || TARGET_DPFP_COMPACT_SET)\n+#define TARGET_DPFP (TARGET_DPFP_FAST_SET || TARGET_DPFP_COMPACT_SET\t\\\n+\t\t     || TARGET_FP_DP_AX)\n \n #define SUBTARGET_SWITCHES\n \n@@ -266,11 +267,12 @@ along with GCC; see the file COPYING3.  If not see\n    default for A7, and only for pre A7 cores when -mnorm is given.  */\n #define TARGET_NORM (TARGET_ARC700 || TARGET_NORM_SET || TARGET_HS)\n /* Indicate if an optimized floating point emulation library is available.  */\n-#define TARGET_OPTFPE \\\n- (TARGET_ARC700 \\\n-  /* We need a barrel shifter and NORM.  */ \\\n-  || (TARGET_ARC600 && TARGET_NORM_SET) \\\n-  || TARGET_HS)\n+#define TARGET_OPTFPE\t\t\t\t\\\n+   (TARGET_ARC700\t\t\t\t\\\n+    /* We need a barrel shifter and NORM.  */\t\\\n+    || (TARGET_ARC600 && TARGET_NORM_SET)\t\\\n+    || TARGET_HS\t\t\t\t\\\n+    || (TARGET_EM && TARGET_NORM_SET && TARGET_BARREL_SHIFTER))\n \n /* Non-zero means the cpu supports swap instruction.  This flag is set by\n    default for A7, and only for pre A7 cores when -mswap is given.  */\n@@ -713,6 +715,12 @@ enum reg_class\n #define ARC_FIRST_SIMD_DMA_CONFIG_OUT_REG  136\n #define ARC_LAST_SIMD_DMA_CONFIG_REG       143\n \n+/* ARCv2 double-register accumulator.  */\n+#define ACC_REG_FIRST 58\n+#define ACC_REG_LAST  59\n+#define ACCL_REGNO    (TARGET_BIG_ENDIAN ? ACC_REG_FIRST + 1 : ACC_REG_FIRST)\n+#define ACCH_REGNO    (TARGET_BIG_ENDIAN ? ACC_REG_FIRST : ACC_REG_FIRST + 1)\n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n@@ -864,7 +872,7 @@ arc_return_addr_rtx(COUNT,FRAME)\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT,N_NAMED_ARGS) \\\n-((CUM) = 0)\n+  ((CUM) = 0)\n \n /* The number of registers used for parameter passing.  Local to this file.  */\n #define MAX_ARC_PARM_REGS 8\n@@ -1656,12 +1664,13 @@ extern enum arc_function_type arc_compute_function_type (struct function *);\n    && GET_CODE (PATTERN (X)) != CLOBBER \\\n    && get_attr_is_##NAME (X) == IS_##NAME##_YES) \\\n \n-#define REVERSE_CONDITION(CODE,MODE) \\\n-\t(((MODE) == CC_FP_GTmode || (MODE) == CC_FP_GEmode \\\n-\t  || (MODE) == CC_FP_UNEQmode || (MODE) == CC_FP_ORDmode \\\n-\t  || (MODE) == CC_FPXmode) \\\n-\t ? reverse_condition_maybe_unordered ((CODE)) \\\n-\t : reverse_condition ((CODE)))\n+#define REVERSE_CONDITION(CODE,MODE)\t\t\t\t \\\n+  (((MODE) == CC_FP_GTmode || (MODE) == CC_FP_GEmode\t\t \\\n+    || (MODE) == CC_FP_UNEQmode || (MODE) == CC_FP_ORDmode\t \\\n+    || (MODE) == CC_FPXmode || (MODE) == CC_FPU_UNEQmode\t \\\n+    || (MODE) == CC_FPUmode)\t\t\t\t\t \\\n+   ? reverse_condition_maybe_unordered ((CODE))\t\t\t \\\n+   : reverse_condition ((CODE)))\n \n #define ADJUST_INSN_LENGTH(X, LENGTH) \\\n   ((LENGTH) \\\n@@ -1724,4 +1733,26 @@ enum\n    been written to by an ordinary instruction.  */\n #define TARGET_LP_WR_INTERLOCK (!TARGET_ARC600_FAMILY)\n \n+/* FPU defines.  */\n+/* Any FPU support.  */\n+#define TARGET_HARD_FLOAT (arc_fpu_build != 0)\n+/* Single precision floating point support.  */\n+#define TARGET_FP_SP_BASE   ((arc_fpu_build & FPU_SP) != 0)\n+/* Double precision floating point support.  */\n+#define TARGET_FP_DP_BASE   ((arc_fpu_build & FPU_DP) != 0)\n+/* Single precision floating point support with fused operation.  */\n+#define TARGET_FP_SP_FUSED  ((arc_fpu_build & FPU_SF) != 0)\n+/* Double precision floating point support with fused operation.  */\n+#define TARGET_FP_DP_FUSED  ((arc_fpu_build & FPU_DF) != 0)\n+/* Single precision floating point conversion instruction support.  */\n+#define TARGET_FP_SP_CONV   ((arc_fpu_build & FPU_SC) != 0)\n+/* Double precision floating point conversion instruction support.  */\n+#define TARGET_FP_DP_CONV   ((arc_fpu_build & FPU_DC) != 0)\n+/* Single precision floating point SQRT/DIV instruction support.  */\n+#define TARGET_FP_SP_SQRT   ((arc_fpu_build & FPU_SD) != 0)\n+/* Double precision floating point SQRT/DIV instruction support.  */\n+#define TARGET_FP_DP_SQRT   ((arc_fpu_build & FPU_DD) != 0)\n+/* Double precision floating point assist instruction support.  */\n+#define TARGET_FP_DP_AX     ((arc_fpu_build & FPX_DP) != 0)\n+\n #endif /* GCC_ARC_H */"}, {"sha": "4193d2610f19fe761ded21b055b3f6a7c24e8364", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 157, "deletions": 8, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -175,6 +175,7 @@\n    (ILINK2_REGNUM 30)\n    (RETURN_ADDR_REGNUM 31)\n    (MUL64_OUT_REG 58)\n+   (ARCV2_ACC 58)\n \n    (LP_COUNT 60)\n    (CC_REG 61)\n@@ -201,7 +202,8 @@\n    simd_varith_with_acc, simd_vlogic, simd_vlogic_with_acc,\n    simd_vcompare, simd_vpermute, simd_vpack, simd_vpack_with_acc,\n    simd_valign, simd_valign_with_acc, simd_vcontrol,\n-   simd_vspecial_3cycle, simd_vspecial_4cycle, simd_dma, mul16_em, div_rem\"\n+   simd_vspecial_3cycle, simd_vspecial_4cycle, simd_dma, mul16_em, div_rem,\n+   fpu\"\n   (cond [(eq_attr \"is_sfunc\" \"yes\")\n \t (cond [(match_test \"!TARGET_LONG_CALLS_SET && (!TARGET_MEDIUM_CALLS || GET_CODE (PATTERN (insn)) != COND_EXEC)\") (const_string \"call\")\n \t\t(match_test \"flag_pic\") (const_string \"sfunc\")]\n@@ -3364,7 +3366,8 @@\n \n })\n \n-(define_mode_iterator SDF [SF DF])\n+(define_mode_iterator SDF [(SF \"TARGET_FP_SP_BASE || TARGET_OPTFPE\")\n+\t\t\t   (DF \"TARGET_OPTFPE\")])\n \n (define_expand \"cstore<mode>4\"\n   [(set (reg:CC CC_REG)\n@@ -3374,7 +3377,7 @@\n \t(match_operator:SI 1 \"comparison_operator\" [(reg CC_REG)\n \t\t\t\t\t\t    (const_int 0)]))]\n \n-  \"TARGET_OPTFPE\"\n+  \"TARGET_FP_SP_BASE || TARGET_OPTFPE\"\n {\n   gcc_assert (XEXP (operands[1], 0) == operands[2]);\n   gcc_assert (XEXP (operands[1], 1) == operands[3]);\n@@ -5167,12 +5170,12 @@\n \t\t    (match_operand:SDF 2 \"register_operand\" \"\")))\n    (set (pc)\n \t(if_then_else\n-\t      (match_operator 0 \"comparison_operator\" [(reg CC_REG)\n-\t\t\t\t\t\t       (const_int 0)])\n-\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))]\n+\t (match_operator 0 \"comparison_operator\" [(reg CC_REG)\n+\t\t\t\t\t\t      (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n \n-  \"TARGET_OPTFPE\"\n+  \"TARGET_FP_SP_BASE || TARGET_OPTFPE\"\n {\n   gcc_assert (XEXP (operands[0], 0) == operands[1]);\n   gcc_assert (XEXP (operands[0], 1) == operands[2]);\n@@ -5624,9 +5627,155 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"misc\")])\n \n+\n+;; FPU/FPX expands\n+\n+;;add\n+(define_expand \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"\")\n+\t(plus:SF (match_operand:SF 1 \"nonmemory_operand\" \"\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_SP_BASE || TARGET_SPFP\"\n+  \"\n+  if (!register_operand (operands[1], SFmode)\n+      && !register_operand (operands[2], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+  \")\n+\n+;;sub\n+(define_expand \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\"            \"\")\n+\t(minus:SF (match_operand:SF 1 \"nonmemory_operand\" \"\")\n+\t\t  (match_operand:SF 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_SP_BASE || TARGET_SPFP\"\n+  \"\n+  if (!register_operand (operands[1], SFmode)\n+      && !register_operand (operands[2], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+  \")\n+\n+;;mul\n+(define_expand \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"\")\n+\t(mult:SF (match_operand:SF 1 \"nonmemory_operand\" \"\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_SP_BASE || TARGET_SPFP\"\n+  \"\n+  if (!register_operand (operands[1], SFmode)\n+      && !register_operand (operands[2], SFmode))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+  \")\n+\n+;;add\n+(define_expand \"adddf3\"\n+  [(set (match_operand:DF 0 \"double_register_operand\"           \"\")\n+\t(plus:DF (match_operand:DF 1 \"double_register_operand\"  \"\")\n+\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")))]\n+ \"TARGET_FP_DP_BASE || TARGET_DPFP\"\n+ \"\n+  if (TARGET_DPFP)\n+   {\n+    if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+     {\n+        rtx high, low, tmp;\n+        split_double (operands[2], &low, &high);\n+        tmp = force_reg (SImode, high);\n+        emit_insn (gen_adddf3_insn (operands[0], operands[1],\n+                                    operands[2], tmp, const0_rtx));\n+     }\n+    else\n+     emit_insn (gen_adddf3_insn (operands[0], operands[1],\n+                                 operands[2], const1_rtx, const1_rtx));\n+   DONE;\n+  }\n+ else if (TARGET_FP_DP_BASE)\n+  {\n+   if (!even_register_operand (operands[2], DFmode))\n+      operands[2] = force_reg (DFmode, operands[2]);\n+\n+   if (!even_register_operand (operands[1], DFmode))\n+      operands[1] = force_reg (DFmode, operands[1]);\n+  }\n+ else\n+  gcc_unreachable ();\n+ \")\n+\n+;;sub\n+(define_expand \"subdf3\"\n+  [(set (match_operand:DF 0 \"double_register_operand\"            \"\")\n+\t(minus:DF (match_operand:DF 1 \"nonmemory_operand\" \"\")\n+\t\t  (match_operand:DF 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_DP_BASE || TARGET_DPFP\"\n+  \"\n+   if (TARGET_DPFP)\n+    {\n+     if ((GET_CODE (operands[1]) == CONST_DOUBLE)\n+          || GET_CODE (operands[2]) == CONST_DOUBLE)\n+      {\n+        rtx high, low, tmp;\n+        int const_index = ((GET_CODE (operands[1]) == CONST_DOUBLE) ? 1 : 2);\n+        split_double (operands[const_index], &low, &high);\n+        tmp = force_reg (SImode, high);\n+        emit_insn (gen_subdf3_insn (operands[0], operands[1],\n+                                    operands[2], tmp, const0_rtx));\n+      }\n+    else\n+     emit_insn (gen_subdf3_insn (operands[0], operands[1],\n+                                 operands[2], const1_rtx, const1_rtx));\n+    DONE;\n+   }\n+  else if (TARGET_FP_DP_BASE)\n+   {\n+    if (!even_register_operand (operands[2], DFmode))\n+       operands[2] = force_reg (DFmode, operands[2]);\n+\n+    if (!even_register_operand (operands[1], DFmode))\n+       operands[1] = force_reg (DFmode, operands[1]);\n+   }\n+  else\n+   gcc_unreachable ();\n+  \")\n+\n+;;mul\n+(define_expand \"muldf3\"\n+  [(set (match_operand:DF 0 \"double_register_operand\"           \"\")\n+\t(mult:DF (match_operand:DF 1 \"double_register_operand\"  \"\")\n+\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_DP_BASE || TARGET_DPFP\"\n+  \"\n+   if (TARGET_DPFP)\n+    {\n+     if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+      {\n+        rtx high, low, tmp;\n+        split_double (operands[2], &low, &high);\n+        tmp = force_reg (SImode, high);\n+        emit_insn (gen_muldf3_insn (operands[0], operands[1],\n+                                    operands[2], tmp, const0_rtx));\n+      }\n+     else\n+      emit_insn (gen_muldf3_insn (operands[0], operands[1],\n+                                  operands[2], const1_rtx, const1_rtx));\n+    DONE;\n+   }\n+  else if (TARGET_FP_DP_BASE)\n+   {\n+    if (!even_register_operand (operands[2], DFmode))\n+       operands[2] = force_reg (DFmode, operands[2]);\n+\n+    if (!even_register_operand (operands[1], DFmode))\n+       operands[1] = force_reg (DFmode, operands[1]);\n+   }\n+  else\n+   gcc_unreachable ();\n+ \")\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n \n+;; include the arc-FPU instructions\n+(include \"fpu.md\")\n+\n (include \"simdext.md\")\n \n ;; include atomic extensions"}, {"sha": "2227b7554c309e6eeb83cc437f21e5e9f3cc2bce", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -413,3 +413,46 @@ Enable atomic instructions.\n mll64\n Target Report Mask(LL64)\n Enable double load/store instructions for ARC HS.\n+\n+mfpu=\n+Target RejectNegative Joined Enum(arc_fpu) Var(arc_fpu_build) Init(0)\n+Specify the name of the target floating point configuration.\n+\n+Enum\n+Name(arc_fpu) Type(int)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpus) Value(FPU_SP | FPU_SC)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpud) Value(FPU_SP | FPU_SC | FPU_DP | FPU_DC)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpuda) Value(FPU_SP | FPU_SC | FPX_DP)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpuda_div) Value(FPU_SP | FPU_SC | FPU_SD | FPX_DP)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpuda_fma) Value(FPU_SP | FPU_SC | FPU_SF | FPX_DP)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpuda_all) Value(FPU_SP | FPU_SC | FPU_SF | FPU_SD | FPX_DP)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpus_div) Value(FPU_SP | FPU_SC | FPU_SD)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpud_div) Value(FPU_SP | FPU_SC | FPU_SD | FPU_DP | FPU_DC | FPU_DD)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpus_fma) Value(FPU_SP | FPU_SC | FPU_SF)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpud_fma) Value(FPU_SP | FPU_SC | FPU_SF | FPU_DP | FPU_DC | FPU_DF)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpus_all) Value(FPU_SP | FPU_SC | FPU_SF | FPU_SD)\n+\n+EnumValue\n+Enum(arc_fpu) String(fpud_all) Value(FPU_SP | FPU_SC | FPU_SF | FPU_SD | FPU_DP | FPU_DC | FPU_DF | FPU_DD)"}, {"sha": "9b0a65d93863799d5d7f0d6154dc4a030bced486", "filename": "gcc/config/arc/fpu.md", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Ffpu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Ffpu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ffpu.md?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -0,0 +1,566 @@\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 32-bit floating point arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Addition\n+(define_insn \"*addsf3_fpu\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"=r,r,r,r,r\")\n+\t(plus:SF (match_operand:SF 1 \"nonmemory_operand\" \"%0,r,0,r,F\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\"  \"r,r,F,F,r\")))]\n+  \"TARGET_FP_SP_BASE\n+   && (register_operand (operands[1], SFmode)\n+       || register_operand (operands[2], SFmode))\"\n+  \"fsadd%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   ])\n+\n+;; Subtraction\n+(define_insn \"*subsf3_fpu\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"=r,r,r,r,r\")\n+\t(minus:SF (match_operand:SF 1 \"nonmemory_operand\" \"0,r,0,r,F\")\n+\t\t  (match_operand:SF 2 \"nonmemory_operand\" \"r,r,F,F,r\")))]\n+  \"TARGET_FP_SP_BASE\n+   && (register_operand (operands[1], SFmode)\n+       || register_operand (operands[2], SFmode))\"\n+  \"fssub%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   ])\n+\n+;; Multiplication\n+(define_insn \"*mulsf3_fpu\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"=r,r,r,r,r\")\n+\t(mult:SF (match_operand:SF 1 \"nonmemory_operand\" \"%0,r,0,r,F\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\"  \"r,r,F,F,r\")))]\n+  \"TARGET_FP_SP_BASE\n+   && (register_operand (operands[1], SFmode)\n+       || register_operand (operands[2], SFmode))\"\n+  \"fsmul%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   ])\n+\n+;; Multiplication with addition/subtraction\n+(define_expand \"fmasf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(fma:SF (match_operand:SF 1 \"nonmemory_operand\" \"\")\n+\t\t(match_operand:SF 2 \"nonmemory_operand\" \"\")\n+\t\t(match_operand:SF 3 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_FP_SP_FUSED\"\n+  \"{\n+   rtx tmp;\n+   tmp = gen_rtx_REG (SFmode, ACCL_REGNO);\n+   emit_move_insn (tmp, operands[3]);\n+   operands[3] = tmp;\n+   }\")\n+\n+(define_expand \"fnmasf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(fma:SF (neg:SF (match_operand:SF 1 \"nonmemory_operand\" \"\"))\n+\t\t(match_operand:SF 2 \"nonmemory_operand\"         \"\")\n+\t\t(match_operand:SF 3 \"nonmemory_operand\"         \"\")))]\n+  \"TARGET_FP_SP_FUSED\"\n+  \"{\n+   rtx tmp;\n+   tmp = gen_rtx_REG (SFmode, ACCL_REGNO);\n+   emit_move_insn (tmp, operands[3]);\n+   operands[3] = tmp;\n+}\")\n+\n+(define_insn \"fmasf4_fpu\"\n+  [(set (match_operand:SF 0 \"register_operand\"          \"=r,r,r,r,r\")\n+\t(fma:SF (match_operand:SF 1 \"nonmemory_operand\" \"%0,r,0,r,F\")\n+\t\t(match_operand:SF 2 \"nonmemory_operand\"  \"r,r,F,F,r\")\n+\t\t(match_operand:SF 3 \"mlo_operand\" \"\")))]\n+  \"TARGET_FP_SP_FUSED\n+   && (register_operand (operands[1], SFmode)\n+       || register_operand (operands[2], SFmode))\"\n+  \"fsmadd%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"fnmasf4_fpu\"\n+  [(set (match_operand:SF 0 \"register_operand\"                  \"=r,r,r,r,r\")\n+\t(fma:SF (neg:SF (match_operand:SF 1 \"nonmemory_operand\" \"%0,r,0,r,F\"))\n+\t\t(match_operand:SF 2 \"nonmemory_operand\"          \"r,r,F,F,r\")\n+\t\t(match_operand:SF 3 \"mlo_operand\" \"\")))]\n+  \"TARGET_FP_SP_FUSED\n+   && (register_operand (operands[1], SFmode)\n+       || register_operand (operands[2], SFmode))\"\n+  \"fsmsub%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_expand \"fmadf4\"\n+  [(match_operand:DF 0 \"even_register_operand\" \"\")\n+   (match_operand:DF 1 \"even_register_operand\" \"\")\n+   (match_operand:DF 2 \"even_register_operand\" \"\")\n+   (match_operand:DF 3 \"even_register_operand\" \"\")]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"{\n+   emit_insn (gen_fmadf4_split (operands[0], operands[1], operands[2], operands[3]));\n+   DONE;\n+   }\")\n+\n+(define_insn_and_split \"fmadf4_split\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"        \"\")\n+\t(fma:DF (match_operand:DF 1 \"even_register_operand\" \"\")\n+\t\t(match_operand:DF 2 \"even_register_operand\" \"\")\n+\t\t(match_operand:DF 3 \"even_register_operand\" \"\")))\n+   (clobber (reg:DF ARCV2_ACC))]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"#\"\n+  \"TARGET_FP_DP_FUSED\"\n+  [(const_int 0)]\n+  \"{\n+   rtx acc_reg = gen_rtx_REG (DFmode, ACC_REG_FIRST);\n+   emit_move_insn (acc_reg, operands[3]);\n+   emit_insn (gen_fmadf4_fpu (operands[0], operands[1], operands[2]));\n+   DONE;\n+  }\"\n+)\n+\n+(define_expand \"fnmadf4\"\n+  [(match_operand:DF 0 \"even_register_operand\" \"\")\n+   (match_operand:DF 1 \"even_register_operand\" \"\")\n+   (match_operand:DF 2 \"even_register_operand\" \"\")\n+   (match_operand:DF 3 \"even_register_operand\" \"\")]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"{\n+   emit_insn (gen_fnmadf4_split (operands[0], operands[1], operands[2], operands[3]));\n+   DONE;\n+   }\")\n+\n+(define_insn_and_split \"fnmadf4_split\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"                 \"\")\n+\t(fma:DF (neg:DF (match_operand:DF 1 \"even_register_operand\" \"\"))\n+\t\t(match_operand:DF 2 \"even_register_operand\"         \"\")\n+\t\t(match_operand:DF 3 \"even_register_operand\"         \"\")))\n+   (clobber (reg:DF ARCV2_ACC))]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"#\"\n+  \"TARGET_FP_DP_FUSED\"\n+  [(const_int 0)]\n+  \"{\n+   rtx acc_reg = gen_rtx_REG (DFmode, ACC_REG_FIRST);\n+   emit_move_insn (acc_reg, operands[3]);\n+   emit_insn (gen_fnmadf4_fpu (operands[0], operands[1], operands[2]));\n+   DONE;\n+  }\")\n+\n+(define_insn \"fmadf4_fpu\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"         \"=r,r\")\n+\t(fma:DF (match_operand:DF 1 \"even_register_operand\" \"%0,r\")\n+\t\t(match_operand:DF 2 \"even_register_operand\"  \"r,r\")\n+\t\t(reg:DF ARCV2_ACC)))]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"fdmadd%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"fnmadf4_fpu\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"                 \"=r,r\")\n+\t(fma:DF (neg:DF (match_operand:DF 1 \"even_register_operand\" \"%0,r\"))\n+\t\t(match_operand:DF 2 \"even_register_operand\"          \"r,r\")\n+\t\t(reg:DF ARCV2_ACC)))]\n+  \"TARGET_FP_DP_FUSED\"\n+  \"fdmsub%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; Division\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\"         \"=r,r,r,r,r\")\n+\t(div:SF (match_operand:SF 1 \"nonmemory_operand\" \"0,r,0,r,F\")\n+\t\t(match_operand:SF 2 \"nonmemory_operand\" \"r,r,F,F,r\")))]\n+  \"TARGET_FP_SP_SQRT\"\n+  \"fsdiv%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4,8,8,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,nocond,canuse_limm,nocond,nocond\")\n+   ])\n+\n+;; Negation\n+;; see pattern in arc.md\n+\n+;; Absolute value\n+;; see pattern in arc.md\n+\n+;; Square root\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"=r,r\")\n+\t(sqrt:SF (match_operand:SF 1 \"nonmemory_operand\"  \"r,F\")))]\n+  \"TARGET_FP_SP_SQRT\"\n+  \"fssqrt %0,%1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; Comparison\n+(define_insn \"*cmpsf_fpu\"\n+  [(set (reg:CC_FPU CC_REG)\n+\t(compare:CC_FPU (match_operand:SF 0 \"register_operand\"  \"r,r\")\n+\t\t\t(match_operand:SF 1 \"nonmemory_operand\" \"r,F\")))]\n+  \"TARGET_FP_SP_BASE\"\n+  \"fscmp%? %0, %1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"cond\" \"set\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,yes\")])\n+\n+(define_insn \"*cmpsf_fpu_uneq\"\n+  [(set (reg:CC_FPU_UNEQ CC_REG)\n+\t(compare:CC_FPU_UNEQ\n+\t (match_operand:SF 0 \"register_operand\"  \"r,r\")\n+\t (match_operand:SF 1 \"nonmemory_operand\" \"r,F\")))]\n+  \"TARGET_FP_SP_BASE\"\n+  \"fscmp %0, %1\\\\n\\\\tmov.v.f 0,0\\\\t;set Z flag\"\n+  [(set_attr \"length\" \"8,12\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"cond\" \"set\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: 64-bit floating point arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; Addition\n+(define_insn \"*adddf3_fpu\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"           \"=r,r\")\n+\t(plus:DF (match_operand:DF 1 \"even_register_operand\"  \"%0,r\")\n+\t\t (match_operand:DF 2 \"even_register_operand\"   \"r,r\")))]\n+  \"TARGET_FP_DP_BASE\"\n+  \"fdadd%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   ])\n+\n+\n+;; Subtraction\n+(define_insn \"*subdf3_fpu\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"           \"=r,r\")\n+\t(minus:DF (match_operand:DF 1 \"even_register_operand\"  \"0,r\")\n+\t\t  (match_operand:DF 2 \"even_register_operand\"  \"r,r\")))]\n+  \"TARGET_FP_DP_BASE\"\n+  \"fdsub%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   ])\n+\n+;; Multiplication\n+(define_insn \"*muldf3_fpu\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"           \"=r,r\")\n+\t(mult:DF (match_operand:DF 1 \"even_register_operand\"  \"%0,r\")\n+\t\t (match_operand:DF 2 \"even_register_operand\"   \"r,r\")))]\n+  \"TARGET_FP_DP_BASE\"\n+  \"fdmul%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   ])\n+\n+;; Division\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"         \"=r,r\")\n+\t(div:DF (match_operand:DF 1 \"even_register_operand\"  \"0,r\")\n+\t\t(match_operand:DF 2 \"even_register_operand\"  \"r,r\")))]\n+  \"TARGET_FP_DP_SQRT\"\n+  \"fddiv%? %0,%1,%2\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")\n+   (set_attr \"cond\" \"canuse,nocond\")\n+   ])\n+\n+;; Square root\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"          \"=r\")\n+\t(sqrt:DF (match_operand:DF 1 \"even_register_operand\"  \"r\")))]\n+  \"TARGET_FP_DP_SQRT\"\n+  \"fdsqrt %0,%1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; Comparison\n+(define_insn \"*cmpdf_fpu\"\n+  [(set (reg:CC_FPU CC_REG)\n+\t(compare:CC_FPU (match_operand:DF 0 \"even_register_operand\"  \"r\")\n+\t\t\t(match_operand:DF 1 \"even_register_operand\"  \"r\")))]\n+  \"TARGET_FP_DP_BASE\"\n+  \"fdcmp%? %0, %1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"cond\" \"set\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*cmpdf_fpu_uneq\"\n+  [(set (reg:CC_FPU_UNEQ CC_REG)\n+\t(compare:CC_FPU_UNEQ\n+\t (match_operand:DF 0 \"even_register_operand\"  \"r\")\n+\t (match_operand:DF 1 \"even_register_operand\"  \"r\")))]\n+  \"TARGET_FP_DP_BASE\"\n+  \"fdcmp %0, %1\\\\n\\\\tmov.v.f 0,0\\\\t;set Z flag\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"cond\" \"set\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Conversion routines\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; SF->DF\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"             \"=r,r\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\"  \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt32_64%? %0,%1,0x04\\\\t;fs2d %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SI->DF\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"      \"=r,r\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt32_64%? %0,%1,0x02\\\\t;fint2d %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; uSI->DF\n+(define_insn \"floatunssidf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"               \"=r,r\")\n+\t(unsigned_float:DF (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt32_64%? %0,%1,0x00\\\\t;fuint2d %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SF->uDI (using rounding towards zero)\n+(define_insn \"fixuns_truncsfdi2\"\n+  [(set (match_operand:DI 0 \"even_register_operand\"                    \"=r,r\")\n+\t(unsigned_fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt32_64%? %0,%1,0x09\\\\t;fs2ul_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SF->DI (using rounding towards zero)\n+(define_insn \"fix_truncsfdi2\"\n+  [(set (match_operand:DI 0 \"even_register_operand\"           \"=r,r\")\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt32_64%? %0,%1,0x0B\\\\t;fs2l_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SI->SF\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"           \"=r,r\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"TARGET_FP_SP_CONV\"\n+  \"fcvt32%? %0,%1,0x02\\\\t;fint2s %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; uSI->SF\n+(define_insn \"floatunssisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"                    \"=r,r\")\n+\t(unsigned_float:SF (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"TARGET_FP_SP_CONV\"\n+  \"fcvt32%? %0,%1,0x00\\\\t;fuint2s %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SF->uSI (using rounding towards zero)\n+(define_insn \"fixuns_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                         \"=r,r\")\n+\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_SP_CONV\"\n+  \"fcvt32%? %0,%1,0x09\\\\t;fs2uint_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; SF->SI (using rounding towards zero)\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r,r\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_SP_CONV\"\n+  \"fcvt32%? %0,%1,0x0B\\\\t;fs2int_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DI->DF\n+(define_insn \"floatdidf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"          \"=r,r\")\n+\t(float:DF (match_operand:DI 1 \"even_register_operand\" \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64%? %0,%1,0x02\\\\t;fl2d %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; uDI->DF\n+(define_insn \"floatunsdidf2\"\n+  [(set (match_operand:DF 0 \"even_register_operand\"                   \"=r,r\")\n+\t(unsigned_float:DF (match_operand:DI 1 \"even_register_operand\" \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64%? %0,%1,0x00\\\\t;ful2d %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DF->uDI (using rounding towards zero)\n+(define_insn \"fixuns_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"even_register_operand\"                         \"=r,r\")\n+\t(unsigned_fix:DI (fix:DF (match_operand:DF 1 \"even_register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64%? %0,%1,0x09\\\\t;fd2ul_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DF->DI (using rounding towards zero)\n+(define_insn \"fix_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"even_register_operand\"                \"=r,r\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"even_register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64%? %0,%1,0x0B\\\\t;fd2l_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DF->SF\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"                        \"=r,r\")\n+\t(float_truncate:SF (match_operand:DF 1 \"even_register_operand\" \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64_32%? %0,%1,0x04\\\\t;fd2s %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DI->SF\n+(define_insn \"floatdisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"               \"=r,r\")\n+\t(float:SF (match_operand:DI 1 \"even_register_operand\" \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64_32%? %0,%1,0x02\\\\t;fl2s %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; uDI->SF\n+(define_insn \"floatunsdisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\"                        \"=r,r\")\n+\t(unsigned_float:SF (match_operand:DI 1 \"even_register_operand\" \"0,r\")))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64_32%? %0,%1,0x00\\\\t;ful2s %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DF->uSI (using rounding towards zero)\n+(define_insn \"fixuns_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                              \"=r,r\")\n+\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"even_register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64_32%? %0,%1,0x09\\\\t;fd2uint_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)\n+\n+;; DF->SI (using rounding towards zero)\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                     \"=r,r\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"even_register_operand\" \"0,r\"))))]\n+  \"TARGET_FP_DP_CONV\"\n+  \"fcvt64_32%? %0,%1,0x0B\\\\t;fd2int_rz %0,%1\"\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"fpu\")\n+   (set_attr \"predicable\" \"yes,no\")]\n+)"}, {"sha": "b7906003748955960f38a20f7a53d5947ed2c56b", "filename": "gcc/config/arc/fpx.md", "status": "modified", "additions": 3, "deletions": 61, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Ffpx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Ffpx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ffpx.md?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -50,7 +50,7 @@\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-(define_insn \"addsf3\"\n+(define_insn \"*addsf3_fpx\"\n   [(set (match_operand:SF 0 \"register_operand\"          \"=r,r,r,r,r \")\n \t(plus:SF (match_operand:SF 1 \"nonmemory_operand\" \"0,r,GCal,r,0\")\n \t\t (match_operand:SF 2 \"nonmemory_operand\" \"I,rL,r,GCal,LrCal\")))]\n@@ -65,7 +65,7 @@\n   [(set_attr \"type\" \"spfp\")\n   (set_attr \"length\" \"4,4,8,8,8\")])\n \n-(define_insn \"subsf3\"\n+(define_insn \"*subsf3_fpx\"\n   [(set (match_operand:SF 0 \"register_operand\"          \"=r,r,r,r,r \")\n \t(minus:SF (match_operand:SF 1 \"nonmemory_operand\" \"r,0,GCal,r,0\")\n \t\t (match_operand:SF 2 \"nonmemory_operand\" \"rL,I,r,GCal,LrCal\")))]\n@@ -80,7 +80,7 @@\n   [(set_attr \"type\" \"spfp\")\n   (set_attr \"length\" \"4,4,8,8,8\")])\n \n-(define_insn \"mulsf3\"\n+(define_insn \"*mulsf3_fpx\"\n   [(set (match_operand:SF 0 \"register_operand\"          \"=r,r,r,r,r \")\n \t(mult:SF (match_operand:SF 1 \"nonmemory_operand\" \"r,0,GCal,r,0\")\n \t\t (match_operand:SF 2 \"nonmemory_operand\" \"rL,I,r,GCal,LrCal\")))]\n@@ -226,25 +226,6 @@\n ;; daddh{0}{1} 0, {reg_pair}2.hi, {reg_pair}2.lo\n ;; OR\n ;; daddh{0}{1} 0, reg3, limm2.lo\n-(define_expand \"adddf3\"\n-  [(set (match_operand:DF 0 \"arc_double_register_operand\"          \"\")\n-\t(plus:DF (match_operand:DF 1 \"arc_double_register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")))\n-     ]\n- \"TARGET_DPFP\"\n- \" if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-     {\n-        rtx high, low, tmp;\n-        split_double (operands[2], &low, &high);\n-        tmp = force_reg (SImode, high);\n-        emit_insn(gen_adddf3_insn(operands[0], operands[1], operands[2],tmp,const0_rtx));\n-     }\n-   else\n-     emit_insn(gen_adddf3_insn(operands[0], operands[1], operands[2],const1_rtx,const1_rtx));\n-     DONE;\n- \"\n-)\n-\n ;; daddh{0}{1} 0, {reg_pair}2.hi, {reg_pair}2.lo  /* operand 4 = 1*/\n ;; OR\n ;; daddh{0}{1} 0, reg3, limm2.lo /* operand 4 = 0 */\n@@ -270,25 +251,6 @@\n ;; dmulh{0}{1} 0, {reg_pair}2.hi, {reg_pair}2.lo\n ;; OR\n ;; dmulh{0}{1} 0, reg3, limm2.lo\n-(define_expand \"muldf3\"\n-  [(set (match_operand:DF 0 \"arc_double_register_operand\"          \"\")\n-\t(mult:DF (match_operand:DF 1 \"arc_double_register_operand\" \"\")\n-\t\t (match_operand:DF 2 \"nonmemory_operand\" \"\")))]\n-\"TARGET_DPFP\"\n-\"  if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-     {\n-        rtx high, low, tmp;\n-        split_double (operands[2], &low, &high);\n-        tmp = force_reg (SImode, high);\n-        emit_insn(gen_muldf3_insn(operands[0], operands[1], operands[2],tmp,const0_rtx));\n-     }\n-   else\n-     emit_insn(gen_muldf3_insn(operands[0], operands[1], operands[2],const1_rtx,const1_rtx));\n-\n-  DONE;\n- \")\n-\n-\n ;; dmulh{0}{1} 0, {reg_pair}2.hi, {reg_pair}2.lo /* operand 4 = 1*/\n ;; OR\n ;; dmulh{0}{1} 0, reg3, limm2.lo /* operand 4 = 0*/\n@@ -317,26 +279,6 @@\n ;; drsubh{0}{2} 0, {reg_pair}1.hi, {reg_pair}1.lo\n ;; OR\n ;; drsubh{0}{2} 0, reg3, limm1.lo\n-(define_expand \"subdf3\"\n-  [(set (match_operand:DF 0 \"arc_double_register_operand\"          \"\")\n-\t\t    (minus:DF (match_operand:DF 1 \"nonmemory_operand\" \"\")\n-\t\t\t\t  (match_operand:DF 2 \"nonmemory_operand\" \"\")))]\n-\"TARGET_DPFP\"\n-\"   if (GET_CODE (operands[1]) == CONST_DOUBLE || GET_CODE (operands[2]) == CONST_DOUBLE)\n-     {\n-        rtx high, low, tmp;\n-        int const_index = ((GET_CODE (operands[1]) == CONST_DOUBLE) ? 1: 2);\n-        split_double (operands[const_index], &low, &high);\n-        tmp = force_reg (SImode, high);\n-        emit_insn(gen_subdf3_insn(operands[0], operands[1], operands[2],tmp,const0_rtx));\n-     }\n-   else\n-     emit_insn(gen_subdf3_insn(operands[0], operands[1], operands[2],const1_rtx,const1_rtx));\n-\n-   DONE;\n-  \"\n-)\n-\n ;; dsubh{0}{1} 0, {reg_pair}2.hi, {reg_pair}2.lo /* operand 4 = 1 */\n ;; OR\n ;; dsubh{0}{1} 0, reg3, limm2.lo /* operand 4 = 0*/"}, {"sha": "85bbf8435588fcd0dc12cd5de6852ee8911c0f7b", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -504,6 +504,11 @@\n       return (code == EQ || code == NE || code == UNEQ || code == LTGT\n \t      || code == ORDERED || code == UNORDERED);\n \n+    case CC_FPUmode:\n+      return 1;\n+    case CC_FPU_UNEQmode:\n+      return 1;\n+\n     case CCmode:\n     case SImode: /* Used for BRcc.  */\n       return 1;\n@@ -797,3 +802,7 @@\n    return (REG_P (op) && ((REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t\t\t  || ((REGNO (op) & 1) == 0)));\n   })\n+\n+(define_predicate \"double_register_operand\"\n+  (ior (match_test \"even_register_operand (op, mode)\")\n+       (match_test \"arc_double_register_operand (op, mode)\")))"}, {"sha": "85f222117affdf6abcb251bea6f662ac70c3ba31", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3304d019bd1f9a8eb08b9dba3a430a59f52994/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8f3304d019bd1f9a8eb08b9dba3a430a59f52994", "patch": "@@ -599,7 +599,7 @@ Objective-C and Objective-C++ Dialects}.\n -mmixed-code -mq-class -mRcq -mRcw -msize-level=@var{level} @gol\n -mtune=@var{cpu} -mmultcost=@var{num} @gol\n -munalign-prob-threshold=@var{probability} -mmpy-option=@var{multo} @gol\n--mdiv-rem -mcode-density -mll64}\n+-mdiv-rem -mcode-density -mll64 -mfpu=@var{fpu}}\n \n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n@@ -13325,6 +13325,88 @@ MPYU, MPYM, MPYMU, and MPY_S.\n \n This option is only available for ARCv2 cores@.\n \n+@item -mfpu=@var{fpu}\n+@opindex mfpu\n+Enables specific floating-point hardware extension for ARCv2\n+core.  Supported values for @var{fpu} are:\n+\n+@table @samp\n+\n+@item fpus\n+@opindex fpus\n+Enables support for single precision floating point hardware\n+extensions@.\n+\n+@item fpud\n+@opindex fpud\n+Enables support for double precision floating point hardware\n+extensions.  The single precision floating point extension is also\n+enabled.  Not available for ARC EM@.\n+\n+@item fpuda\n+@opindex fpuda\n+Enables support for double precision floating point hardware\n+extensions using double precision assist instructions.  The single\n+precision floating point extension is also enabled.  This option is\n+only available for ARC EM@.\n+\n+@item fpuda_div\n+@opindex fpuda_div\n+Enables support for double precision floating point hardware\n+extensions using double precision assist instructions, and simple\n+precision square-root and divide hardware extensions.  The single\n+precision floating point extension is also enabled.  This option is\n+only available for ARC EM@.\n+\n+@item fpuda_fma\n+@opindex fpuda_fma\n+Enables support for double precision floating point hardware\n+extensions using double precision assist instructions, and simple\n+precision fused multiple and add hardware extension.  The single\n+precision floating point extension is also enabled.  This option is\n+only available for ARC EM@.\n+\n+@item fpuda_all\n+@opindex fpuda_all\n+Enables support for double precision floating point hardware\n+extensions using double precision assist instructions, and all simple\n+precision hardware extensions.  The single precision floating point\n+extension is also enabled.  This option is only available for ARC EM@.\n+\n+@item fpus_div\n+@opindex fpus_div\n+Enables support for single precision floating point, and single\n+precision square-root and divide hardware extensions@.\n+\n+@item fpud_div\n+@opindex fpud_div\n+Enables support for double precision floating point, and double\n+precision square-root and divide hardware extensions.  This option\n+includes option @samp{fpus_div}. Not available for ARC EM@.\n+\n+@item fpus_fma\n+@opindex fpus_fma\n+Enables support for single precision floating point, and single\n+precision fused multiple and add hardware extensions@.\n+\n+@item fpud_fma\n+@opindex fpud_fma\n+Enables support for double precision floating point, and double\n+precision fused multiple and add hardware extensions.  This option\n+includes option @samp{fpus_fma}.  Not available for ARC EM@.\n+\n+@item fpus_all\n+@opindex fpus_all\n+Enables support for all single precision floating point hardware\n+extensions@.\n+\n+@item fpud_all\n+@opindex fpud_all\n+Enables support for all single and double precision floating point\n+hardware extensions.  Not available for ARC EM@.\n+\n+@end table\n+\n @end table\n \n The following options are passed through to the assembler, and also"}]}