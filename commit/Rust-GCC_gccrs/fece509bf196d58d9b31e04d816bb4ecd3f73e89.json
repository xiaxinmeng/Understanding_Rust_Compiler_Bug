{"sha": "fece509bf196d58d9b31e04d816bb4ecd3f73e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVjZTUwOWJmMTk2ZDU4ZDliMzFlMDRkODE2YmI0ZWNkM2Y3M2U4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:17:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:17:12Z"}, "message": "poly_int: fold_indirect_ref_1\n\nThis patch makes fold_indirect_ref_1 handle polynomial offsets in\na POINTER_PLUS_EXPR.  The specific reason for doing this now is\nto handle:\n\n \t\t  (tree_to_uhwi (part_width) / BITS_PER_UNIT\n \t\t   * TYPE_VECTOR_SUBPARTS (op00type));\n\nwhen TYPE_VECTOR_SUBPARTS becomes a poly_int.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* fold-const.c (fold_indirect_ref_1): Handle polynomial offsets\n\tin a POINTER_PLUS_EXPR.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256146", "tree": {"sha": "38b9238d900975a5bb481499b05bec97aa54c328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38b9238d900975a5bb481499b05bec97aa54c328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fece509bf196d58d9b31e04d816bb4ecd3f73e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fece509bf196d58d9b31e04d816bb4ecd3f73e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fece509bf196d58d9b31e04d816bb4ecd3f73e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fece509bf196d58d9b31e04d816bb4ecd3f73e89/comments", "author": null, "committer": null, "parents": [{"sha": "d8f860ef70b33d0c49f31114c433b6c654c5a588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f860ef70b33d0c49f31114c433b6c654c5a588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f860ef70b33d0c49f31114c433b6c654c5a588"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "28998830858dc457ad65b2986ec43839e1688f75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fece509bf196d58d9b31e04d816bb4ecd3f73e89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fece509bf196d58d9b31e04d816bb4ecd3f73e89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fece509bf196d58d9b31e04d816bb4ecd3f73e89", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* fold-const.c (fold_indirect_ref_1): Handle polynomial offsets\n+\tin a POINTER_PLUS_EXPR.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e2e46005f8cc886ec87e7fb465b03b145d97203f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fece509bf196d58d9b31e04d816bb4ecd3f73e89/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fece509bf196d58d9b31e04d816bb4ecd3f73e89/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fece509bf196d58d9b31e04d816bb4ecd3f73e89", "patch": "@@ -14049,6 +14049,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n {\n   tree sub = op0;\n   tree subtype;\n+  poly_uint64 const_op01;\n \n   STRIP_NOPS (sub);\n   subtype = TREE_TYPE (sub);\n@@ -14103,7 +14104,7 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n     }\n \n   if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-      && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n+      && poly_int_tree_p (TREE_OPERAND (sub, 1), &const_op01))\n     {\n       tree op00 = TREE_OPERAND (sub, 0);\n       tree op01 = TREE_OPERAND (sub, 1);\n@@ -14120,15 +14121,12 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t      && type == TREE_TYPE (op00type))\n \t    {\n \t      tree part_width = TYPE_SIZE (type);\n-\t      unsigned HOST_WIDE_INT max_offset\n+\t      poly_uint64 max_offset\n \t\t= (tree_to_uhwi (part_width) / BITS_PER_UNIT\n \t\t   * TYPE_VECTOR_SUBPARTS (op00type));\n-\t      if (tree_int_cst_sign_bit (op01) == 0\n-\t\t  && compare_tree_int (op01, max_offset) == -1)\n+\t      if (known_lt (const_op01, max_offset))\n \t\t{\n-\t\t  unsigned HOST_WIDE_INT offset = tree_to_uhwi (op01);\n-\t\t  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n-\t\t  tree index = bitsize_int (indexi);\n+\t\t  tree index = bitsize_int (const_op01 * BITS_PER_UNIT);\n \t\t  return fold_build3_loc (loc,\n \t\t\t\t\t  BIT_FIELD_REF, type, op00,\n \t\t\t\t\t  part_width, index);\n@@ -14138,8 +14136,8 @@ fold_indirect_ref_1 (location_t loc, tree type, tree op0)\n \t  else if (TREE_CODE (op00type) == COMPLEX_TYPE\n \t\t   && type == TREE_TYPE (op00type))\n \t    {\n-\t      tree size = TYPE_SIZE_UNIT (type);\n-\t      if (tree_int_cst_equal (size, op01))\n+\t      if (known_eq (wi::to_poly_offset (TYPE_SIZE_UNIT (type)),\n+\t\t\t    const_op01))\n \t\treturn fold_build1_loc (loc, IMAGPART_EXPR, type, op00);\n \t    }\n \t  /* ((foo *)&fooarray)[1] => fooarray[1] */"}]}