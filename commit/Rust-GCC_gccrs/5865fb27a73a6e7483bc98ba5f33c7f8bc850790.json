{"sha": "5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "node_id": "C_kwDOANBUbNoAKDU4NjVmYjI3YTczYTZlNzQ4M2JjOThiYTVmMzNjN2Y4YmM4NTA3OTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-09T14:25:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T14:25:07Z"}, "message": "Merge #1425 #1451\n\n1425: Cleanup frontend entrypoint r=CohenArthur a=CohenArthur\n\nThis removes a lot of code that was simply ported from the Go frontend, and forbids the usage of multiple input files.\r\n\r\nAddresses #1115\n\n1451: Fix failiure to type inference on unit-structs r=philberty a=philberty\n\nThis patch set adds fixes to ensure we can type inference generic unit-structs.\r\n\r\nFixes #1447 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "52f27d91e342a6dbb55f97cf2508280898301c4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f27d91e342a6dbb55f97cf2508280898301c4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8m5DCRBK7hj4Ov3rIwAA+kgIAKAkXbqr6cqG2Bwy5dwW4sYe\nROcKL8uRT4SZzVL3sGbYkXgoCVnV2Mz2ZzcVRoqc9MfoxnA9JoiPBWerSyEnIU3S\naY86V8wNAX0O9H+0ecR4n6lN6ingNf45c2vjrSEGhpE6QJcSHl9nKGHqRN0smr3o\nj+I6MGQcdaue2+B63Feqyb33fVB7luiOJ4SI0ZccScVdPsRKOe75j1GRykcBJD9p\nVo2k0JRvrI3kQPj3DOzSDUDjzWP4ZxcepfYXyyy9vF1KdxMI3i0ruseVpuCD0IV1\nZDzYDUJ4vvRMWq45U2zbUdBobC4qXqIblGU/6orYvC6yFvSmECPL7ow8X6SuZWM=\n=RIG4\n-----END PGP SIGNATURE-----\n", "payload": "tree 52f27d91e342a6dbb55f97cf2508280898301c4b\nparent 17b625cbd612f05359c3199a3253f42e4cf25120\nparent 0ec8f938272b6dce9e133f98a199fd5123aa553f\nparent 92eef6c33d49137707e5b3962822c6dded1f3c79\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1660055107 +0000\ncommitter GitHub <noreply@github.com> 1660055107 +0000\n\nMerge #1425 #1451\n\n1425: Cleanup frontend entrypoint r=CohenArthur a=CohenArthur\n\nThis removes a lot of code that was simply ported from the Go frontend, and forbids the usage of multiple input files.\r\n\r\nAddresses #1115\n\n1451: Fix failiure to type inference on unit-structs r=philberty a=philberty\n\nThis patch set adds fixes to ensure we can type inference generic unit-structs.\r\n\r\nFixes #1447 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17b625cbd612f05359c3199a3253f42e4cf25120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b625cbd612f05359c3199a3253f42e4cf25120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b625cbd612f05359c3199a3253f42e4cf25120"}, {"sha": "0ec8f938272b6dce9e133f98a199fd5123aa553f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec8f938272b6dce9e133f98a199fd5123aa553f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec8f938272b6dce9e133f98a199fd5123aa553f"}, {"sha": "92eef6c33d49137707e5b3962822c6dded1f3c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92eef6c33d49137707e5b3962822c6dded1f3c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92eef6c33d49137707e5b3962822c6dded1f3c79"}], "stats": {"total": 313, "additions": 145, "deletions": 168}, "files": [{"sha": "95c92f8092b41ca156bc94caaf14ebb8bed946ef", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -69,13 +69,11 @@\n // Language-dependent contents of a type. GTY() mark used for garbage collector.\n struct GTY (()) lang_type\n {\n-  char dummy;\n };\n \n // Language-dependent contents of a decl.\n struct GTY (()) lang_decl\n {\n-  char dummy;\n };\n \n // Language-dependent contents of an identifier.  This must include a\n@@ -100,7 +98,6 @@ union GTY ((\n // We don't use language_function.\n struct GTY (()) language_function\n {\n-  int dummy;\n };\n \n // has to be in same compilation unit as session, so here for now\n@@ -172,7 +169,7 @@ grs_langhook_parse_file (void)\n {\n   rust_debug (\"Preparing to parse files. \");\n \n-  Rust::Session::get_instance ().parse_files (num_in_fnames, in_fnames);\n+  Rust::Session::get_instance ().handle_input_files (num_in_fnames, in_fnames);\n }\n \n /* Seems to get the exact type for a specific type - e.g. for scalar float with\n@@ -280,32 +277,10 @@ grs_langhook_handle_option (\n {\n   // Convert integer code to lang.opt enum codes with names.\n   enum opt_code code = (enum opt_code) scode;\n-  // used to store whether results of various stuff are successful\n-  // bool ret = true;\n \n-  // delegate to session manager\n+  // Delegate to session manager\n   return Rust::Session::get_instance ().handle_option (code, arg, value, kind,\n \t\t\t\t\t\t       loc, handlers);\n-\n-  // Handles options as listed in lang.opt.\n-  /*switch (code) {\n-      case OPT_I:\n-\t  // TODO: add search path\n-\t  break;\n-      case OPT_L:\n-\t  // TODO: add library link path or something\n-\t  break;\n-      case OPT_frust_dump:\n-\t  // enable dump and return whether this was successful\n-\t  ret = rust_enable_dump(arg) ? true : false;\n-\t  break;\n-      // no option handling for -o\n-      default:\n-\t  // return 1 to indicate option is valid\n-\t  break;\n-  }\n-\n-  return ret;*/\n }\n \n /* Run after parsing options.  */\n@@ -447,17 +422,10 @@ rust_localize_identifier (const char *ident)\n \n namespace selftest {\n \n-static void\n-simple_assert ()\n-{\n-  ASSERT_TRUE (true);\n-}\n-\n void\n run_rust_tests ()\n {\n   // Call tests for the rust frontend here\n-  simple_assert ();\n   rust_cfg_parser_test ();\n   rust_privacy_ctx_test ();\n   rust_crate_name_validation_test ();"}, {"sha": "7d599b1bd3a48a6e0656d89cccccf61ca81a8df0", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -575,13 +575,16 @@ Session::enable_dump (std::string arg)\n /* Actual main entry point for front-end. Called from langhook to parse files.\n  */\n void\n-Session::parse_files (int num_files, const char **files)\n+Session::handle_input_files (int num_files, const char **files)\n {\n+  if (num_files != 1)\n+    rust_fatal_error (Location (),\n+\t\t      \"only one file may be specified on the command line\");\n+\n+  const auto &file = files[0];\n+\n   if (options.crate_name.empty ())\n     {\n-      /* HACK: We use the first file to infer the crate name, which might be\n-       * incorrect: since rustc only allows one file to be supplied in the\n-       * command-line */\n       auto filename = \"-\";\n       if (num_files > 0)\n \tfilename = files[0];\n@@ -595,13 +598,9 @@ Session::parse_files (int num_files, const char **files)\n \n   CrateNum crate_num = mappings->get_next_crate_num (options.get_crate_name ());\n   mappings->set_current_crate (crate_num);\n-  for (int i = 0; i < num_files; i++)\n-    {\n-      rust_debug (\"Attempting to parse file: %s\", files[i]);\n-      parse_file (files[i]);\n-    }\n-  /* TODO: should semantic analysis be dealed with here? or per file? for now,\n-   * per-file. */\n+\n+  rust_debug (\"Attempting to parse file: %s\", file);\n+  compile_crate (file);\n }\n \n void\n@@ -657,7 +656,7 @@ Session::handle_crate_name (const AST::Crate &parsed_crate)\n \n // Parses a single file with filename filename.\n void\n-Session::parse_file (const char *filename)\n+Session::compile_crate (const char *filename)\n {\n   RAIIFile file_wrap (filename);\n   if (!file_wrap.ok ())"}, {"sha": "2432de705923700655ad67591e3c3f17f6a2845b", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -298,7 +298,7 @@ struct Session\n   bool handle_option (enum opt_code code, const char *arg, HOST_WIDE_INT value,\n \t\t      int kind, location_t loc,\n \t\t      const struct cl_option_handlers *handlers);\n-  void parse_files (int num_files, const char **files);\n+  void handle_input_files (int num_files, const char **files);\n   void init_options ();\n   void handle_crate_name (const AST::Crate &parsed_crate);\n \n@@ -314,7 +314,7 @@ struct Session\n   NodeId load_extern_crate (const std::string &crate_name, Location locus);\n \n private:\n-  void parse_file (const char *filename);\n+  void compile_crate (const char *filename);\n   bool enable_dump (std::string arg);\n \n   void dump_lex (Parser<Lexer> &parser) const;"}, {"sha": "b05f8ae5454df4da12cf48d5988e6694494ab3d8", "filename": "gcc/rust/rustspec.cc", "status": "modified", "additions": 11, "deletions": 120, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -40,13 +40,6 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n {\n   unsigned int i, j;\n \n-  /* This is a tristate:\n-     -1 means we should not link in librust\n-     0  means we should link in librust if it is needed\n-     1  means librust is needed and should be linked in.\n-     2  means librust is needed and should be linked statically.  */\n-  int library = 0;\n-\n   /* The new argument list will be contained in this.  */\n   struct cl_decoded_option *new_decoded_options;\n \n@@ -78,14 +71,6 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   /* Whether the -o option was used.  */\n   bool saw_opt_o = false;\n \n-  /* Whether the -c option was used.  Also used for -E, -fsyntax-only,\n-     in general anything which implies only compilation and not\n-     linking.  */\n-  bool saw_opt_c = false;\n-\n-  /* Whether the -S option was used.  */\n-  bool saw_opt_S = false;\n-\n   /* The first input file with an extension of .rs.  */\n   const char *first_rust_file = NULL;\n \n@@ -101,47 +86,9 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \n       switch (decoded_options[i].opt_index)\n \t{\n-\tcase OPT_r:\n-\tcase OPT_nostdlib:\n-\tcase OPT_nodefaultlibs:\n-\t  library = -1;\n-\t  break;\n-\n \tcase OPT_l:\n \t  if (strcmp (arg, \"c\") == 0)\n \t    args[i] |= WITHLIBC;\n-\t  else\n-\t    /* Unrecognized libraries (e.g. -lfoo) may require librust.  */\n-\t    library = (library == 0) ? 1 : library;\n-\t  break;\n-\n-\tcase OPT_x:\n-\t  if (library == 0 && strcmp (arg, \"rust\") == 0)\n-\t    library = 1;\n-\t  break;\n-\n-\tcase OPT_Xlinker:\n-\tcase OPT_Wl_:\n-\t  /* Arguments that go directly to the linker might be .o files,\n-\t     or something, and so might cause librust to be needed.  */\n-\t  if (library == 0)\n-\t    library = 1;\n-\t  break;\n-\n-\tcase OPT_c:\n-\tcase OPT_E:\n-\tcase OPT_M:\n-\tcase OPT_MM:\n-\tcase OPT_fsyntax_only:\n-\t  /* Don't specify libraries if we won't link, since that would\n-\t     cause a warning.  */\n-\t  saw_opt_c = true;\n-\t  library = -1;\n-\t  break;\n-\n-\tcase OPT_S:\n-\t  saw_opt_S = true;\n-\t  library = -1;\n \t  break;\n \n \tcase OPT_o:\n@@ -156,15 +103,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t  shared_libgcc = 0;\n \t  break;\n \n-\tcase OPT_static_librust:\n-\t  library = library >= 0 ? 2 : library;\n-\t  args[i] |= SKIPOPT;\n-\t  break;\n-\n \tcase OPT_SPECIAL_input_file:\n-\t  if (library == 0)\n-\t    library = 1;\n-\n \t  if (first_rust_file == NULL)\n \t    {\n \t      int len;\n@@ -173,6 +112,13 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t      if (len > 3 && strcmp (arg + len - 3, \".rs\") == 0)\n \t\tfirst_rust_file = arg;\n \t    }\n+\t  else\n+\t    {\n+\t      // FIXME: ARTHUR: Do we want to error here? If there's already one\n+\t      // file?\n+\t      // How do we error here? Do we want to instead just handle that in\n+\t      // the session manager?\n+\t    }\n \n \t  break;\n \t}\n@@ -185,7 +131,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n #endif\n \n   /* Make sure to have room for the trailing NULL argument.  */\n-  num_args = argc + shared_libgcc + (library > 0) * 5 + 10;\n+  num_args = argc + shared_libgcc * 5 + 10;\n   new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);\n \n   i = 0;\n@@ -199,7 +145,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n     {\n       new_decoded_options[j] = decoded_options[i];\n \n-      if (!saw_libc && (args[i] & WITHLIBC) && library > 0)\n+      if (!saw_libc && (args[i] & WITHLIBC))\n \t{\n \t  --j;\n \t  saw_libc = &decoded_options[i];\n@@ -217,67 +163,12 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n      driver will invoke rust1 separately for each input file.  FIXME:\n      This should probably use some other interface to force the driver\n      to set combine_inputs.  */\n-  if (first_rust_file != NULL && !saw_opt_o)\n+  if (!saw_opt_o)\n     {\n-      if (saw_opt_c || saw_opt_S)\n-\t{\n-\t  const char *base;\n-\t  int baselen;\n-\t  int alen;\n-\t  char *out;\n-\n-\t  base = lbasename (first_rust_file);\n-\t  baselen = strlen (base) - 3;\n-\t  alen = baselen + 3;\n-\t  out = XNEWVEC (char, alen);\n-\t  memcpy (out, base, baselen);\n-\t  /* The driver will convert .o to some other suffix (e.g.,\n-\t     .obj) if appropriate.  */\n-\t  out[baselen] = '.';\n-\t  if (saw_opt_S)\n-\t    out[baselen + 1] = 's';\n-\t  else\n-\t    out[baselen + 1] = 'o';\n-\t  out[baselen + 2] = '\\0';\n-\t  generate_option (OPT_o, out, 1, CL_DRIVER, &new_decoded_options[j]);\n-\t}\n-      else\n-\tgenerate_option (OPT_o, \"a.out\", 1, CL_DRIVER, &new_decoded_options[j]);\n+      generate_option (OPT_o, \"a.out\", 1, CL_DRIVER, &new_decoded_options[j]);\n       j++;\n     }\n \n-  /* Add `-lrust' if we haven't already done so.  */\n-  if (library > 0)\n-    {\n-      // generate_option (OPT_l, LIBGOBEGIN, 1, CL_DRIVER,\n-      //               &new_decoded_options[j]);\n-      // added_libraries++;\n-      // j++;\n-\n-#ifdef HAVE_LD_STATIC_DYNAMIC\n-      if (library > 1 && !static_link)\n-\t{\n-\t  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j]);\n-\t  j++;\n-\t}\n-#endif\n-\n-\t// generate_option (OPT_l, LIBGO, 1,\n-\t//   \t       CL_DRIVER, &new_decoded_options[j]);\n-\t// added_libraries++;\n-\t// j++;\n-\n-#ifdef HAVE_LD_STATIC_DYNAMIC\n-      if (library > 1 && !static_link)\n-\t{\n-\t  generate_option (OPT_Wl_, LD_DYNAMIC_OPTION, 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j]);\n-\t  j++;\n-\t}\n-#endif\n-    }\n-\n   if (saw_libc)\n     new_decoded_options[j++] = *saw_libc;\n   if (shared_libgcc && !static_link)"}, {"sha": "0c44f28e4ac0bfae44a34130773281c7ce705359", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -310,6 +310,17 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = lookup->clone ();\n+\n+    // Generic unit structs look like an identifier but they actually need be\n+    // handled as a path-in-expression so this gives us a chance to infer the\n+    // generic parameters.\n+    // see https://github.com/Rust-GCC/gccrs/issues/1447\n+    bool is_unit_struct\n+      = infered->get_kind () == TyTy::TypeKind::ADT && infered->is_unit ();\n+    if (is_unit_struct && infered->needs_generic_substitutions ())\n+      {\n+\tinfered = SubstMapper::InferSubst (infered, expr.get_locus ());\n+      }\n   }\n \n   void visit (HIR::LiteralExpr &expr) override"}, {"sha": "ed1636593c53059e71fc5da4d16522e407a3319c", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -1130,9 +1130,43 @@ class ADTCoercionRules : public BaseCoercionRules\n \t  }\n       }\n \n+    // generic args for the unit-struct case\n+    if (type.is_unit () && base->is_unit ())\n+      {\n+\trust_assert (type.get_num_substitutions ()\n+\t\t     == base->get_num_substitutions ());\n+\n+\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n+\t  {\n+\t    auto &a = base->get_substs ().at (i);\n+\t    auto &b = type.get_substs ().at (i);\n+\n+\t    auto pa = a.get_param_ty ();\n+\t    auto pb = b.get_param_ty ();\n+\n+\t    auto res = pa->unify (pb);\n+\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+\n     resolved = type.clone ();\n   }\n \n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -1172,6 +1206,18 @@ class TupleCoercionRules : public BaseCoercionRules\n \t\t\t\t    type.get_ident ().locus, fields);\n   }\n \n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "77d912a592108272091fb39a13ce1833351821e5", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -1128,9 +1128,43 @@ class ADTRules : public BaseRules\n \t  }\n       }\n \n+    // generic args for the unit-struct case\n+    if (type.is_unit () && base->is_unit ())\n+      {\n+\trust_assert (type.get_num_substitutions ()\n+\t\t     == base->get_num_substitutions ());\n+\n+\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n+\t  {\n+\t    auto &a = base->get_substs ().at (i);\n+\t    auto &b = type.get_substs ().at (i);\n+\n+\t    auto pa = a.get_param_ty ();\n+\t    auto pb = b.get_param_ty ();\n+\n+\t    auto res = pa->unify (pb);\n+\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+\n     resolved = type.clone ();\n   }\n \n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "e0543e6247c4a071bad0dd1f85589505835c9dc5", "filename": "gcc/testsuite/rust/compile/issue-1447.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1447.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5865fb27a73a6e7483bc98ba5f33c7f8bc850790/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1447.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1447.rs?ref=5865fb27a73a6e7483bc98ba5f33c7f8bc850790", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options \"-w\" }\n+struct PhantomData<T>;\n+\n+struct Hasher<S> {\n+    _marker: PhantomData<S>,\n+}\n+\n+struct Sip24Rounds;\n+\n+struct SipHasher24 {\n+    hasher: Hasher<Sip24Rounds>,\n+}\n+\n+impl SipHasher24 {\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n+        SipHasher24 {\n+            hasher: Hasher::new_with_keys(),\n+        }\n+    }\n+}\n+\n+impl<S> Hasher<S> {\n+    fn new_with_keys() -> Hasher<S> {\n+        Hasher {\n+            _marker: PhantomData,\n+        }\n+    }\n+}"}]}