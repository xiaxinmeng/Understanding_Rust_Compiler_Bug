{"sha": "dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "node_id": "C_kwDOANBUbNoAKGRkNzgxM2YwNWRmNTBkMmFkOGUwZGMzNDUwM2YyZGZmMGI1MjFkODk", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-05-12T02:23:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-05-13T22:21:12Z"}, "message": "compiler: always sort interface parse methods\n\nThe exporter relies on sorting interface parse methods.  It would sort\nthem as it encountered interface types.  However, when an interface\ntype is an element of a struct or array type, the exporter might\nencounter that interface type before sorting the parse methods.  If it\nthen encountered an identical interface type again, it could get\nconfused about whether the two types are identical or not.\n\nFix the problem by always sorting the parse methods in the\nfinalize_methods pass.\n\nAlso firm up the export type sorting to make sure we never have this\nkind of confusion again.  Doing this revealed that we need to be more\ncareful about sorting in order to handle aliases correctly.\n\nAlso fix the interface type hash computation to use the right hash\nvalue when looking at parse methods rather than all methods.\n\nThe test case for this is https://go.dev/cl/405759.\n\nFixes golang/go#52841\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/405556", "tree": {"sha": "737f1de3db3655c45a6997804f567e91fd57ba8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/737f1de3db3655c45a6997804f567e91fd57ba8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d75d4293dcc029a7b00f902d9b03416c9439af4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75d4293dcc029a7b00f902d9b03416c9439af4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75d4293dcc029a7b00f902d9b03416c9439af4d"}], "stats": {"total": 341, "additions": 289, "deletions": 52}, "files": [{"sha": "daa725f9de9c14dacb3a662fbe7951e9028e8971", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "patch": "@@ -1,4 +1,4 @@\n-6a33e7e30c89edc12340dc470b44791bb1066feb\n+f5bc28a30b7503015bbef38afb5812313184e822\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "70d3f708d3265fab60b042bb442e8b98b7a2c95a", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 278, "deletions": 37, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "patch": "@@ -360,16 +360,6 @@ Collect_export_references::type(Type* type)\n   if (type->is_abstract())\n     return TRAVERSE_SKIP_COMPONENTS;\n \n-  // For interfaces make sure that embedded methods are sorted, since the\n-  // comparison function we use for indexing types relies on it (this call has\n-  // to happen before the record_type call below).\n-  if (type->classification() == Type::TYPE_INTERFACE)\n-    {\n-      Interface_type* it = type->interface_type();\n-      if (it != NULL)\n-        it->sort_embedded();\n-    }\n-\n   if (!this->exp_->record_type(type))\n     {\n       // We've already seen this type.\n@@ -501,6 +491,11 @@ should_export(Named_object* no)\n   return true;\n }\n \n+// Compare Typed_identifier_list's.\n+\n+static int\n+compare_til(const Typed_identifier_list*, const Typed_identifier_list*);\n+\n // A functor to sort Named_object pointers by name.\n \n struct Sort_bindings\n@@ -514,10 +509,57 @@ struct Sort_bindings\n \t  return true;\n \tif (n2->package() == NULL)\n \t  return false;\n-\treturn n1->package()->pkgpath() < n2->package()->pkgpath();\n+\n+\t// Make sure we don't see the same pkgpath twice.\n+\tconst std::string& p1(n1->package()->pkgpath());\n+\tconst std::string& p2(n2->package()->pkgpath());\n+\tgo_assert(p1 != p2);\n+\n+\treturn p1 < p2;\n       }\n \n-    return n1->name() < n2->name();\n+    if (n1->name() != n2->name())\n+      return n1->name() < n2->name();\n+\n+    // We shouldn't see the same name twice, but it can happen for\n+    // nested type names.\n+\n+    go_assert(n1->is_type() && n2->is_type());\n+\n+    unsigned int ind1;\n+    const Named_object* g1 = n1->type_value()->in_function(&ind1);\n+    unsigned int ind2;\n+    const Named_object* g2 = n2->type_value()->in_function(&ind2);\n+\n+    if (g1 == NULL)\n+      {\n+\tgo_assert(g2 != NULL);\n+\treturn true;\n+      }\n+    else if (g2 == NULL)\n+      return false;\n+    else if (g1 == g2)\n+      {\n+\tgo_assert(ind1 != ind2);\n+\treturn ind1 < ind2;\n+      }\n+    else if ((g1->package() != g2->package()) || (g1->name() != g2->name()))\n+      return Sort_bindings()(g1, g2);\n+    else\n+      {\n+\t// This case can happen if g1 or g2 is a method.\n+\tif (g1 != NULL && g1->func_value()->is_method())\n+\t  {\n+\t    const Typed_identifier* r = g1->func_value()->type()->receiver();\n+\t    g1 = r->type()->named_type()->named_object();\n+\t  }\n+\tif (g2 != NULL && g2->func_value()->is_method())\n+\t  {\n+\t    const Typed_identifier* r = g2->func_value()->type()->receiver();\n+\t    g2 = r->type()->named_type()->named_object();\n+\t  }\n+\treturn Sort_bindings()(g1, g2);\n+      }\n   }\n };\n \n@@ -528,17 +570,20 @@ struct Sort_types\n   bool\n   operator()(const Type* t1, const Type* t2) const\n   {\n+    t1 = t1->forwarded();\n+    t2 = t2->forwarded();\n+\n     const Named_type* nt1 = t1->named_type();\n     const Named_type* nt2 = t2->named_type();\n     if (nt1 != NULL)\n       {\n-        if (nt2 != NULL)\n-          {\n-            Sort_bindings sb;\n-            return sb(nt1->named_object(), nt2->named_object());\n-          }\n-        else\n-          return true;\n+\tif (nt2 != NULL)\n+\t  {\n+\t    Sort_bindings sb;\n+\t    return sb(nt1->named_object(), nt2->named_object());\n+\t  }\n+\telse\n+\t  return true;\n       }\n     else if (nt2 != NULL)\n       return false;\n@@ -549,10 +594,218 @@ struct Sort_types\n     gogo->type_descriptor_backend_name(t1, NULL, &b1);\n     Backend_name b2;\n     gogo->type_descriptor_backend_name(t2, NULL, &b2);\n-    return b1.name() < b2.name();\n+\n+    std::string n1 = b1.name();\n+    std::string n2 = b2.name();\n+    if (n1 != n2)\n+      return n1 < n2;\n+\n+    // We should never see equal types here.  If we do, we may not\n+    // generate an identical output file for identical input.  But the\n+    // backend names can be equal because we want to treat aliases\n+    // differently while type_descriptor_backend_name does not.  In\n+    // that case we need to traverse the type elements.\n+\n+    // t1 == t2 in case std::sort compares elements to themselves.\n+    if (t1 == t2)\n+      return false;\n+\n+    Sort_types sort;\n+    Type_alias_identical identical;\n+    go_assert(!identical(t1, t2));\n+\n+    switch (t1->classification())\n+      {\n+      case Type::TYPE_ERROR:\n+\treturn false;\n+\n+      case Type::TYPE_VOID:\n+      case Type::TYPE_BOOLEAN:\n+      case Type::TYPE_INTEGER:\n+      case Type::TYPE_FLOAT:\n+      case Type::TYPE_COMPLEX:\n+      case Type::TYPE_STRING:\n+      case Type::TYPE_SINK:\n+      case Type::TYPE_NIL:\n+      case Type::TYPE_CALL_MULTIPLE_RESULT:\n+      case Type::TYPE_NAMED:\n+      case Type::TYPE_FORWARD:\n+      default:\n+\tgo_unreachable();\n+\n+      case Type::TYPE_FUNCTION:\n+\t{\n+\t  const Function_type* ft1 = t1->function_type();\n+\t  const Function_type* ft2 = t2->function_type();\n+\t  const Typed_identifier* r1 = ft1->receiver();\n+\t  const Typed_identifier* r2 = ft2->receiver();\n+\t  if (r1 == NULL)\n+\t    go_assert(r2 == NULL);\n+\t  else\n+\t    {\n+\t      go_assert(r2 != NULL);\n+\t      const Type* rt1 = r1->type()->forwarded();\n+\t      const Type* rt2 = r2->type()->forwarded();\n+\t      if (!identical(rt1, rt2))\n+\t\treturn sort(rt1, rt2);\n+\t    }\n+\n+\t  const Typed_identifier_list* p1 = ft1->parameters();\n+\t  const Typed_identifier_list* p2 = ft2->parameters();\n+\t  if (p1 == NULL || p1->empty())\n+\t    go_assert(p2 == NULL || p2->empty());\n+\t  else\n+\t    {\n+\t      go_assert(p2 != NULL && !p2->empty());\n+\t      int i = compare_til(p1, p2);\n+\t      if (i < 0)\n+\t\treturn false;\n+\t      else if (i > 0)\n+\t\treturn true;\n+\t    }\n+\n+\t  p1 = ft1->results();\n+\t  p2 = ft2->results();\n+\t  if (p1 == NULL || p1->empty())\n+\t    go_assert(p2 == NULL || p2->empty());\n+\t  else\n+\t    {\n+\t      go_assert(p2 != NULL && !p2->empty());\n+\t      int i = compare_til(p1, p2);\n+\t      if (i < 0)\n+\t\treturn false;\n+\t      else if (i > 0)\n+\t\treturn true;\n+\t    }\n+\n+\t  go_unreachable();\n+\t}\n+\n+      case Type::TYPE_POINTER:\n+\t{\n+\t  const Type* p1 = t1->points_to()->forwarded();\n+\t  const Type* p2 = t2->points_to()->forwarded();\n+\t  go_assert(!identical(p1, p2));\n+\t  return sort(p1, p2);\n+\t}\n+\n+      case Type::TYPE_STRUCT:\n+\t{\n+\t  const Struct_type* s1 = t1->struct_type();\n+\t  const Struct_type* s2 = t2->struct_type();\n+\t  const Struct_field_list* f1 = s1->fields();\n+\t  const Struct_field_list* f2 = s2->fields();\n+\t  go_assert(f1 != NULL && f2 != NULL);\n+\t  Struct_field_list::const_iterator p1 = f1->begin();\n+\t  Struct_field_list::const_iterator p2 = f2->begin();\n+\t  for (; p2 != f2->end(); ++p1, ++p2)\n+\t    {\n+\t      go_assert(p1 != f1->end());\n+\t      go_assert(p1->field_name() == p2->field_name());\n+\t      go_assert(p1->is_anonymous() == p2->is_anonymous());\n+\t      const Type* ft1 = p1->type()->forwarded();\n+\t      const Type* ft2 = p2->type()->forwarded();\n+\t      if (!identical(ft1, ft2))\n+\t\treturn sort(ft1, ft2);\n+\t    }\n+\t  go_assert(p1 == f1->end());\n+\t  go_unreachable();\n+\t}\n+\n+      case Type::TYPE_ARRAY:\n+\t{\n+\t  const Type* e1 = t1->array_type()->element_type()->forwarded();\n+\t  const Type* e2 = t2->array_type()->element_type()->forwarded();\n+\t  go_assert(!identical(e1, e2));\n+\t  return sort(e1, e2);\n+\t}\n+\n+      case Type::TYPE_MAP:\n+\t{\n+\t  const Map_type* m1 = t1->map_type();\n+\t  const Map_type* m2 = t2->map_type();\n+\t  const Type* k1 = m1->key_type()->forwarded();\n+\t  const Type* k2 = m2->key_type()->forwarded();\n+\t  if (!identical(k1, k2))\n+\t    return sort(k1, k2);\n+\t  const Type* v1 = m1->val_type()->forwarded();\n+\t  const Type* v2 = m2->val_type()->forwarded();\n+\t  go_assert(!identical(v1, v2));\n+\t  return sort(v1, v2);\n+\t}\n+\n+      case Type::TYPE_CHANNEL:\n+\t{\n+\t  const Type* e1 = t1->channel_type()->element_type()->forwarded();\n+\t  const Type* e2 = t2->channel_type()->element_type()->forwarded();\n+\t  go_assert(!identical(e1, e2));\n+\t  return sort(e1, e2);\n+\t}\n+\n+      case Type::TYPE_INTERFACE:\n+\t{\n+\t  const Interface_type* it1 = t1->interface_type();\n+\t  const Interface_type* it2 = t2->interface_type();\n+\t  const Typed_identifier_list* m1 = it1->local_methods();\n+\t  const Typed_identifier_list* m2 = it2->local_methods();\n+\n+\t  // We know the full method lists are the same, because the\n+\t  // mangled type names were the same, but here we are looking\n+\t  // at the local method lists, which include embedded\n+\t  // interfaces, and we can have an embedded empty interface.\n+\t  if (m1 == NULL || m1->empty())\n+\t    {\n+\t      go_assert(m2 != NULL && !m2->empty());\n+\t      return true;\n+\t    }\n+\t  else if (m2 == NULL || m2->empty())\n+\t    {\n+\t      go_assert(m1 != NULL && !m1->empty());\n+\t      return false;\n+\t    }\n+\n+\t  int i = compare_til(m1, m2);\n+\t  if (i < 0)\n+\t    return false;\n+\t  else if (i > 0)\n+\t    return true;\n+\t  else\n+\t    go_unreachable();\n+\t}\n+      }\n   }\n };\n \n+// Compare Typed_identifier_list's with Sort_types, returning -1, 0, +1.\n+\n+static int\n+compare_til(\n+    const Typed_identifier_list* til1,\n+    const Typed_identifier_list* til2)\n+{\n+  Type_alias_identical identical;\n+  Sort_types sort;\n+  Typed_identifier_list::const_iterator p1 = til1->begin();\n+  Typed_identifier_list::const_iterator p2 = til2->begin();\n+  for (; p2 != til2->end(); ++p1, ++p2)\n+    {\n+      if (p1 == til1->end())\n+\treturn -1;\n+      const Type* t1 = p1->type()->forwarded();\n+      const Type* t2 = p2->type()->forwarded();\n+      if (!identical(t1, t2))\n+\t{\n+\t  if (sort(t1, t2))\n+\t    return -1;\n+\t  else\n+\t    return +1;\n+\t}\n+    }\n+  if (p1 != til1->end())\n+    return +1;\n+  return 0;\n+}\n+\n // Export those identifiers marked for exporting.\n \n void\n@@ -714,17 +967,9 @@ bool\n Export::record_type(Type* type)\n {\n   type = type->forwarded();\n-\n   std::pair<Type_refs::iterator, bool> ins =\n     this->impl_->type_refs.insert(std::make_pair(type, 0));\n-  if (!ins.second)\n-    {\n-      // We've already seen this type.\n-      return false;\n-    }\n-  ins.first->second = 0;\n-\n-  return true;\n+  return ins.second;\n }\n \n // Assign the specified type an index.\n@@ -733,13 +978,12 @@ void\n Export::set_type_index(const Type* type)\n {\n   type = type->forwarded();\n-  std::pair<Type_refs::iterator, bool> ins =\n-    this->impl_->type_refs.insert(std::make_pair(type, 0));\n-  go_assert(!ins.second);\n+  Type_refs::iterator p = this->impl_->type_refs.find(type);\n+  go_assert(p != this->impl_->type_refs.end());\n   int index = this->type_index_;\n   ++this->type_index_;\n-  go_assert(ins.first->second == 0);\n-  ins.first->second = index;\n+  go_assert(p->second == 0);\n+  p->second = index;\n }\n \n // This helper assigns type indices to all types mentioned directly or\n@@ -758,9 +1002,6 @@ Export::assign_type_indices(const std::vector<Named_object*>& sorted_exports)\n     {\n       if (!(*p)->is_type())\n \tcontinue;\n-      Interface_type* it = (*p)->type_value()->interface_type();\n-      if (it != NULL)\n-        it->sort_embedded();\n       this->record_type((*p)->type_value());\n       this->set_type_index((*p)->type_value());\n     }"}, {"sha": "a8e309041e700e0b3fa83199483ace4c817d77db", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "patch": "@@ -9031,6 +9031,9 @@ Interface_type::finalize_methods()\n   if (this->parse_methods_ == NULL)\n     return;\n \n+  // The exporter uses parse_methods_.\n+  this->parse_methods_->sort_by_name();\n+\n   this->all_methods_ = new Typed_identifier_list();\n   this->all_methods_->reserve(this->parse_methods_->size());\n   Typed_identifier_list inherit;\n@@ -9318,15 +9321,17 @@ Interface_type::is_compatible_for_assign(const Interface_type* t,\n // Hash code.\n \n unsigned int\n-Interface_type::do_hash_for_method(Gogo*, int) const\n+Interface_type::do_hash_for_method(Gogo*, int flags) const\n {\n   go_assert(this->methods_are_finalized_);\n+  Typed_identifier_list* methods = (((flags & COMPARE_EMBEDDED_INTERFACES) != 0)\n+\t\t\t\t    ? this->parse_methods_\n+\t\t\t\t    : this->all_methods_);\n   unsigned int ret = 0;\n-  if (this->all_methods_ != NULL)\n+  if (methods != NULL)\n     {\n-      for (Typed_identifier_list::const_iterator p =\n-\t     this->all_methods_->begin();\n-\t   p != this->all_methods_->end();\n+      for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t   p != methods->end();\n \t   ++p)\n \t{\n \t  ret = Gogo::hash_string(p->name(), ret);"}, {"sha": "49404bd612729c3afdf5f67924ea0a97af2fda31", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd7813f05df50d2ad8e0dc34503f2dff0b521d89/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=dd7813f05df50d2ad8e0dc34503f2dff0b521d89", "patch": "@@ -3272,15 +3272,6 @@ class Interface_type : public Type\n   methods_are_finalized() const\n   { return this->methods_are_finalized_; }\n \n-  // Sort embedded interfaces by name. Needed when we are preparing\n-  // to emit types into the export data.\n-  void\n-  sort_embedded()\n-  {\n-    if (parse_methods_ != NULL)\n-      parse_methods_->sort_by_name();\n-  }\n-\n  protected:\n   int\n   do_traverse(Traverse*);"}]}