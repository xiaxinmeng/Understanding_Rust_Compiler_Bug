{"sha": "2961ac45b9e19523958757e607d11c5893d6368b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2MWFjNDViOWUxOTUyMzk1ODc1N2U2MDdkMTFjNTg5M2Q2MzY4Yg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-29T20:17:30Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-09-17T19:04:30Z"}, "message": "openacc: Remove unnecessary barriers (gimple worker partitioning/broadcast)\n\nThis is an optimisation for middle-end worker-partitioning support (used\nto support multiple workers on AMD GCN).  At present, barriers may be\nemitted in cases where they aren't needed and cannot be optimised away.\nThis patch stops the extraneous barriers from being emitted in the\nfirst place.\n\nOne exception to the above (where the barrier is still needed) is for\npredicated blocks of code that perform a write to gang-private shared\nmemory from one worker.  We must execute a barrier before other workers\nread that shared memory location.\n\ngcc/\n\t* config/gcn/gcn.c (gimple.h): Include.\n\t(gcn_fork_join): Emit barrier for worker-level joins.\n\t* omp-oacc-neuter-broadcast.cc (find_local_vars_to_propagate): Add\n\twrites_gang_private bitmap parameter. Set bit for blocks\n\tcontaining gang-private variable writes.\n\t(worker_single_simple): Don't emit barrier after predicated block.\n\t(worker_single_copy): Don't emit barrier if we're not broadcasting\n\tanything and the block contains no gang-private writes.\n\t(neuter_worker_single): Don't predicate blocks that only contain\n\tNOPs or internal marker functions.  Pass has_gang_private_write\n\targument to worker_single_copy.\n\t(oacc_do_neutering): Add writes_gang_private bitmap handling.", "tree": {"sha": "b5c070c46b04dc1db6c0b7ffa6cf5de74d3b9701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c070c46b04dc1db6c0b7ffa6cf5de74d3b9701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2961ac45b9e19523958757e607d11c5893d6368b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2961ac45b9e19523958757e607d11c5893d6368b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2961ac45b9e19523958757e607d11c5893d6368b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2961ac45b9e19523958757e607d11c5893d6368b/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2"}], "stats": {"total": 123, "additions": 94, "deletions": 29}, "files": [{"sha": "2a3fc96c1ee0fd905ecbd5a3d4af27e716d6a2c1", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2961ac45b9e19523958757e607d11c5893d6368b/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2961ac45b9e19523958757e607d11c5893d6368b/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=2961ac45b9e19523958757e607d11c5893d6368b", "patch": "@@ -51,6 +51,7 @@\n #include \"intl.h\"\n #include \"rtl-iter.h\"\n #include \"dwarf2.h\"\n+#include \"gimple.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -5133,10 +5134,14 @@ gcn_oacc_dim_pos (int dim)\n /* Implement TARGET_GOACC_FORK_JOIN.  */\n \n static bool\n-gcn_fork_join (gcall *ARG_UNUSED (call), const int *ARG_UNUSED (dims),\n-\t       bool ARG_UNUSED (is_fork))\n+gcn_fork_join (gcall *call, const int dims[], bool is_fork)\n {\n-  /* GCN does not need to expand fork/join markers at the RTL level.  */\n+  tree arg = gimple_call_arg (call, 2);\n+  unsigned axis = TREE_INT_CST_LOW (arg);\n+\n+  if (!is_fork && axis == GOMP_DIM_WORKER && dims[axis] != 1)\n+    return true;\n+\n   return false;\n }\n "}, {"sha": "aa5990ed7a12fd127efaec66f8fc43905db5e1d4", "filename": "gcc/omp-oacc-neuter-broadcast.cc", "status": "modified", "additions": 86, "deletions": 26, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2961ac45b9e19523958757e607d11c5893d6368b/gcc%2Fomp-oacc-neuter-broadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2961ac45b9e19523958757e607d11c5893d6368b/gcc%2Fomp-oacc-neuter-broadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-neuter-broadcast.cc?ref=2961ac45b9e19523958757e607d11c5893d6368b", "patch": "@@ -769,16 +769,19 @@ static void\n find_local_vars_to_propagate (parallel_g *par, unsigned outer_mask,\n \t\t\t      hash_set<tree> *partitioned_var_uses,\n \t\t\t      hash_set<tree> *gang_private_vars,\n+\t\t\t      bitmap writes_gang_private,\n \t\t\t      vec<propagation_set *> *prop_set)\n {\n   unsigned mask = outer_mask | par->mask;\n \n   if (par->inner)\n     find_local_vars_to_propagate (par->inner, mask, partitioned_var_uses,\n-\t\t\t\t  gang_private_vars, prop_set);\n+\t\t\t\t  gang_private_vars, writes_gang_private,\n+\t\t\t\t  prop_set);\n   if (par->next)\n     find_local_vars_to_propagate (par->next, outer_mask, partitioned_var_uses,\n-\t\t\t\t  gang_private_vars, prop_set);\n+\t\t\t\t  gang_private_vars, writes_gang_private,\n+\t\t\t\t  prop_set);\n \n   if (!(mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)))\n     {\n@@ -799,8 +802,7 @@ find_local_vars_to_propagate (parallel_g *par, unsigned outer_mask,\n \t\t  if (!VAR_P (var)\n \t\t      || is_global_var (var)\n \t\t      || AGGREGATE_TYPE_P (TREE_TYPE (var))\n-\t\t      || !partitioned_var_uses->contains (var)\n-\t\t      || gang_private_vars->contains (var))\n+\t\t      || !partitioned_var_uses->contains (var))\n \t\t    continue;\n \n \t\t  if (stmt_may_clobber_ref_p (stmt, var))\n@@ -814,6 +816,14 @@ find_local_vars_to_propagate (parallel_g *par, unsigned outer_mask,\n \t\t\t  fprintf (dump_file, \"\\n\");\n \t\t\t}\n \n+\t\t      if (gang_private_vars->contains (var))\n+\t\t\t{\n+\t\t\t  /* If we write a gang-private variable, we want a\n+\t\t\t     barrier at the end of the block.  */\n+\t\t\t  bitmap_set_bit (writes_gang_private, block->index);\n+\t\t\t  continue;\n+\t\t\t}\n+\n \t\t      if (!(*prop_set)[block->index])\n \t\t\t(*prop_set)[block->index] = new propagation_set;\n \n@@ -925,14 +935,6 @@ worker_single_simple (basic_block from, basic_block to,\n \t    }\n \t}\n     }\n-\n-  gsi = gsi_start_bb (skip_block);\n-\n-  decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n-  gimple *acc_bar = gimple_build_call (decl, 0);\n-\n-  gsi_insert_before (&gsi, acc_bar, GSI_SAME_STMT);\n-  update_stmt (acc_bar);\n }\n \n /* Build COMPONENT_REF and set TREE_THIS_VOLATILE and TREE_READONLY on it\n@@ -1011,7 +1013,7 @@ worker_single_copy (basic_block from, basic_block to,\n \t\t    hash_set<tree> *worker_partitioned_uses,\n \t\t    tree record_type, record_field_map_t *record_field_map,\n \t\t    unsigned HOST_WIDE_INT placement,\n-\t\t    bool isolate_broadcasts)\n+\t\t    bool isolate_broadcasts, bool has_gang_private_write)\n {\n   /* If we only have virtual defs, we'll have no record type, but we still want\n      to emit single_copy_start and (particularly) single_copy_end to act as\n@@ -1094,14 +1096,19 @@ worker_single_copy (basic_block from, basic_block to,\n   edge ef = make_edge (from, barrier_block, EDGE_FALSE_VALUE);\n   ef->probability = et->probability.invert ();\n \n-  decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n-  gimple *acc_bar = gimple_build_call (decl, 0);\n-\n   gimple_stmt_iterator bar_gsi = gsi_start_bb (barrier_block);\n-  gsi_insert_before (&bar_gsi, acc_bar, GSI_NEW_STMT);\n-\n   cond = gimple_build_cond (NE_EXPR, recv_tmp, zero_ptr, NULL_TREE, NULL_TREE);\n-  gsi_insert_after (&bar_gsi, cond, GSI_NEW_STMT);\n+\n+  if (record_type != char_type_node || has_gang_private_write)\n+    {\n+      decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+      gimple *acc_bar = gimple_build_call (decl, 0);\n+\n+      gsi_insert_before (&bar_gsi, acc_bar, GSI_NEW_STMT);\n+      gsi_insert_after (&bar_gsi, cond, GSI_NEW_STMT);\n+    }\n+  else\n+    gsi_insert_before (&bar_gsi, cond, GSI_NEW_STMT);\n \n   edge et2 = split_block (barrier_block, cond);\n   et2->flags &= ~EDGE_FALLTHRU;\n@@ -1263,7 +1270,8 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \t\t      vec<propagation_set *> *prop_set,\n \t\t      hash_set<tree> *partitioned_var_uses,\n \t\t      record_field_map_t *record_field_map,\n-\t\t      blk_offset_map_t *blk_offset_map)\n+\t\t      blk_offset_map_t *blk_offset_map,\n+\t\t      bitmap writes_gang_private)\n {\n   unsigned mask = outer_mask | par->mask;\n \n@@ -1349,21 +1357,71 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \t      (*prop_set)[block->index] = 0;\n \t    }\n \n-\t  tree record_type = (tree) block->aux;\n+\t  bool only_marker_fns = true;\n+\t  bool join_block = false;\n+\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t       !gsi_end_p (gsi);\n+\t       gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t  && gimple_call_internal_p (stmt, IFN_UNIQUE))\n+\t\t{\n+\t\t  enum ifn_unique_kind k = ((enum ifn_unique_kind)\n+\t\t    TREE_INT_CST_LOW (gimple_call_arg (stmt, 0)));\n+\t\t  if (k != IFN_UNIQUE_OACC_PRIVATE\n+\t\t      && k != IFN_UNIQUE_OACC_JOIN\n+\t\t      && k != IFN_UNIQUE_OACC_FORK\n+\t\t      && k != IFN_UNIQUE_OACC_HEAD_MARK\n+\t\t      && k != IFN_UNIQUE_OACC_TAIL_MARK)\n+\t\t    only_marker_fns = false;\n+\t\t  else if (k == IFN_UNIQUE_OACC_JOIN)\n+\t\t    /* The JOIN marker is special in that it *cannot* be\n+\t\t       predicated for worker zero, because it may be lowered\n+\t\t       to a barrier instruction and all workers must typically\n+\t\t       execute that barrier.  We shouldn't be doing any\n+\t\t       broadcasts from the join block anyway.  */\n+\t\t    join_block = true;\n+\t\t}\n+\t      else if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t       && gimple_call_internal_p (stmt, IFN_GOACC_LOOP))\n+\t\t/* Empty.  */;\n+\t      else if (gimple_nop_p (stmt))\n+\t\t/* Empty.  */;\n+\t      else\n+\t\tonly_marker_fns = false;\n+\t    }\n+\n+\t  /* We can skip predicating this block for worker zero if the only\n+\t     thing it contains is marker functions that will be removed in the\n+\t     oaccdevlow pass anyway.\n+\t     Don't do this if the block has (any) phi nodes, because those\n+\t     might define SSA names that need broadcasting.\n+\t     TODO: We might be able to skip transforming blocks that only\n+\t     contain some other trivial statements too.  */\n+\t  if (only_marker_fns && !phi_nodes (block))\n+\t    continue;\n+\n+\t  gcc_assert (!join_block);\n \n \t  if (has_defs)\n \t    {\n+\t      tree record_type = (tree) block->aux;\n \t      std::pair<unsigned HOST_WIDE_INT, bool> *off_rngalloc\n \t\t= blk_offset_map->get (block);\n \t      gcc_assert (!record_type || off_rngalloc);\n \t      unsigned HOST_WIDE_INT offset\n \t\t= off_rngalloc ? off_rngalloc->first : 0;\n \t      bool range_allocated\n \t\t= off_rngalloc ? off_rngalloc->second : true;\n+\t      bool has_gang_private_write\n+\t\t= bitmap_bit_p (writes_gang_private, block->index);\n \t      worker_single_copy (block, block, &def_escapes_block,\n \t\t\t\t  &worker_partitioned_uses, record_type,\n \t\t\t\t  record_field_map,\n-\t\t\t\t  offset, !range_allocated);\n+\t\t\t\t  offset, !range_allocated,\n+\t\t\t\t  has_gang_private_write);\n \t    }\n \t  else\n \t    worker_single_simple (block, block, &def_escapes_block);\n@@ -1401,11 +1459,11 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n   if (par->inner)\n     neuter_worker_single (par->inner, mask, worker_single, vector_single,\n \t\t\t  prop_set, partitioned_var_uses, record_field_map,\n-\t\t\t  blk_offset_map);\n+\t\t\t  blk_offset_map, writes_gang_private);\n   if (par->next)\n     neuter_worker_single (par->next, outer_mask, worker_single, vector_single,\n \t\t\t  prop_set, partitioned_var_uses, record_field_map,\n-\t\t\t  blk_offset_map);\n+\t\t\t  blk_offset_map, writes_gang_private);\n }\n \n static void\n@@ -1596,11 +1654,13 @@ oacc_do_neutering (unsigned HOST_WIDE_INT bounds_lo,\n \n   hash_set<tree> partitioned_var_uses;\n   hash_set<tree> gang_private_vars;\n+  auto_bitmap writes_gang_private;\n \n   find_gang_private_vars (&gang_private_vars);\n   find_partitioned_var_uses (par, mask, &partitioned_var_uses);\n   find_local_vars_to_propagate (par, mask, &partitioned_var_uses,\n-\t\t\t\t&gang_private_vars, &prop_set);\n+\t\t\t\t&gang_private_vars, writes_gang_private,\n+\t\t\t\t&prop_set);\n \n   record_field_map_t record_field_map;\n \n@@ -1757,7 +1817,7 @@ oacc_do_neutering (unsigned HOST_WIDE_INT bounds_lo,\n \n   neuter_worker_single (par, mask, worker_single, vector_single, &prop_set,\n \t\t\t&partitioned_var_uses, &record_field_map,\n-\t\t\t&blk_offset_map);\n+\t\t\t&blk_offset_map, writes_gang_private);\n \n   for (auto it : record_field_map)\n     delete it.second;"}]}