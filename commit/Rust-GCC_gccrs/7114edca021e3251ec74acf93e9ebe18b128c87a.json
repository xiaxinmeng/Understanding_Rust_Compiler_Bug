{"sha": "7114edca021e3251ec74acf93e9ebe18b128c87a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExNGVkY2EwMjFlMzI1MWVjNzRhY2Y5M2U5ZWJlMThiMTI4Yzg3YQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-09T18:42:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-11-09T18:42:28Z"}, "message": "re PR fortran/29699 (ICE in trans-decl.c)\n\n2006-11-09 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29699\n\t* trans-array.c (structure_alloc_comps): Detect pointers to\n\tarrays and use indirect reference to declaration.\n\t* resolve.c (resolve_fl_variable): Tidy up condition.\n\t(resolve_symbol): The same and only add initialization code if\n\tthe symbol is referenced.\n\t* trans-decl.c (gfc_trans_deferred_vars): Call gfc_trans_\n\tdeferred_array before gfc_trans_auto_array_allocation.\n\n\tPR fortran/21730\n\t* symbol.c (check_done): Remove.\n\t(gfc_add_attribute): Remove reference to check_done and remove\n\tthe argument attr_intent.\n\t(gfc_add_allocatable, gfc_add_dimension, gfc_add_external,\n\tgfc_add_intrinsic, gfc_add_optional, gfc_add_pointer,\n\tgfc_add_cray_pointer, gfc_add_cray_pointee, gfc_add_result,\n\tgfc_add_target, gfc_add_in_common, gfc_add_elemental,\n\tgfc_add_pure, gfc_add_recursive, gfc_add_procedure,\n\tgfc_add_type): Remove references to check_done.\n\t* decl.c (attr_decl1): Eliminate third argument in call to\n\tgfc_add_attribute.\n\t* gfortran.h : Change prototype for gfc_add_attribute.\n\n\n\n2006-11-09 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29699\n\t* gfortran.dg/alloc_comp_auto_array_1.f90: New test.\n\n\tPR fortran/21730\n\t* gfortran.dg/change_symbol_attributes_1.f90: New test.\n\nFrom-SVN: r118624", "tree": {"sha": "24d34b4ba251e9f21674a4a86c639715a08502f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24d34b4ba251e9f21674a4a86c639715a08502f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7114edca021e3251ec74acf93e9ebe18b128c87a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7114edca021e3251ec74acf93e9ebe18b128c87a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7114edca021e3251ec74acf93e9ebe18b128c87a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7114edca021e3251ec74acf93e9ebe18b128c87a/comments", "author": null, "committer": null, "parents": [{"sha": "d82a02fa4f3cd88f8d8f080ffe4bd9c7536c7e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82a02fa4f3cd88f8d8f080ffe4bd9c7536c7e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82a02fa4f3cd88f8d8f080ffe4bd9c7536c7e8f"}], "stats": {"total": 195, "additions": 139, "deletions": 56}, "files": [{"sha": "fcd1c4ea7e305d03d7a61b26dadb6f037149c9d6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -1,3 +1,28 @@\n+2006-11-09 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29699\n+\t* trans-array.c (structure_alloc_comps): Detect pointers to\n+\tarrays and use indirect reference to declaration.\n+\t* resolve.c (resolve_fl_variable): Tidy up condition.\n+\t(resolve_symbol): The same and only add initialization code if\n+\tthe symbol is referenced.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Call gfc_trans_\n+\tdeferred_array before gfc_trans_auto_array_allocation.\n+\n+\tPR fortran/21730\n+\t* symbol.c (check_done): Remove.\n+\t(gfc_add_attribute): Remove reference to check_done and remove\n+\tthe argument attr_intent.\n+\t(gfc_add_allocatable, gfc_add_dimension, gfc_add_external,\n+\tgfc_add_intrinsic, gfc_add_optional, gfc_add_pointer,\n+\tgfc_add_cray_pointer, gfc_add_cray_pointee, gfc_add_result,\n+\tgfc_add_target, gfc_add_in_common, gfc_add_elemental,\n+\tgfc_add_pure, gfc_add_recursive, gfc_add_procedure,\n+\tgfc_add_type): Remove references to check_done.\n+\t* decl.c (attr_decl1): Eliminate third argument in call to\n+\tgfc_add_attribute.\n+\t* gfortran.h : Change prototype for gfc_add_attribute.\n+\n 2006-11-08  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* invoke.texi: Added documentation for -fmax-errors option."}, {"sha": "6c5cfcc411ea70adefc714fc930338a86662ec70", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -3330,7 +3330,7 @@ attr_decl1 (void)\n \tgoto cleanup;\n     }\n \n-  if (gfc_add_attribute (&sym->attr, &var_locus, current_attr.intent) == FAILURE)\n+  if (gfc_add_attribute (&sym->attr, &var_locus) == FAILURE)\n     {\n       m = MATCH_ERROR;\n       goto cleanup;"}, {"sha": "05292375c2e4b551e29e8e46e8336665daab6075", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -1838,7 +1838,7 @@ void gfc_get_component_attr (symbol_attribute *, gfc_component *);\n \n void gfc_set_sym_referenced (gfc_symbol * sym);\n \n-try gfc_add_attribute (symbol_attribute *, locus *, unsigned int);\n+try gfc_add_attribute (symbol_attribute *, locus *);\n try gfc_add_allocatable (symbol_attribute *, locus *);\n try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n try gfc_add_external (symbol_attribute *, locus *);"}, {"sha": "872713f6fe54a9ec969603762186f0aa78488157", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -5497,8 +5497,11 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     }\n \n   /* Assign default initializer.  */\n-  if (sym->ts.type == BT_DERIVED && !sym->value && !sym->attr.pointer\n-      && !sym->attr.allocatable && (!flag || sym->attr.intent == INTENT_OUT))\n+  if (sym->ts.type == BT_DERIVED\n+\t&& !sym->value\n+\t&& !sym->attr.pointer\n+\t&& !sym->attr.allocatable\n+\t&& (!flag || sym->attr.intent == INTENT_OUT))\n     sym->value = gfc_default_initializer (&sym->ts);\n \n   return SUCCESS;\n@@ -6036,8 +6039,12 @@ resolve_symbol (gfc_symbol * sym)\n   /* If we have come this far we can apply default-initializers, as\n      described in 14.7.5, to those variables that have not already\n      been assigned one.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ns == gfc_current_ns && !sym->value\n-\t&& !sym->attr.allocatable && !sym->attr.alloc_comp)\n+  if (sym->ts.type == BT_DERIVED\n+\t&& sym->attr.referenced\n+\t&& sym->ns == gfc_current_ns\n+\t&& !sym->value\n+\t&& !sym->attr.allocatable\n+\t&& !sym->attr.alloc_comp)\n     {\n       symbol_attribute *a = &sym->attr;\n "}, {"sha": "fce6db46a87d4936d2e68ae271556a16b5d3ee10", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -601,28 +601,6 @@ check_used (symbol_attribute * attr, const char * name, locus * where)\n }\n \n \n-/* Used to prevent changing the attributes of a symbol after it has been\n-   used.  This check is only done for dummy variables as only these can be\n-   used in specification expressions.  Applying this to all symbols causes\n-   an error when we reach the body of a contained function.  */\n-\n-static int\n-check_done (symbol_attribute * attr, locus * where)\n-{\n-\n-  if (!(attr->dummy && attr->referenced))\n-    return 0;\n-\n-  if (where == NULL)\n-    where = &gfc_current_locus;\n-\n-  gfc_error (\"Cannot change attributes of symbol at %L\"\n-             \" after it has been used\", where);\n-\n-  return 1;\n-}\n-\n-\n /* Generate an error because of a duplicate attribute.  */\n \n static void\n@@ -638,12 +616,9 @@ duplicate_attr (const char *attr, locus * where)\n /* Called from decl.c (attr_decl1) to check attributes, when declared separately.  */\n \n try\n-gfc_add_attribute (symbol_attribute * attr, locus * where,\n-\t\t   unsigned int attr_intent)\n+gfc_add_attribute (symbol_attribute * attr, locus * where)\n {\n-\n-  if (check_used (attr, NULL, where)\n-\t|| (attr_intent == 0 && check_done (attr, where)))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   return check_conflict (attr, NULL, where);\n@@ -653,7 +628,7 @@ try\n gfc_add_allocatable (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->allocatable)\n@@ -671,7 +646,7 @@ try\n gfc_add_dimension (symbol_attribute * attr, const char *name, locus * where)\n {\n \n-  if (check_used (attr, name, where) || check_done (attr, where))\n+  if (check_used (attr, name, where))\n     return FAILURE;\n \n   if (attr->dimension)\n@@ -689,7 +664,7 @@ try\n gfc_add_external (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->external)\n@@ -708,7 +683,7 @@ try\n gfc_add_intrinsic (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->intrinsic)\n@@ -727,7 +702,7 @@ try\n gfc_add_optional (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->optional)\n@@ -745,7 +720,7 @@ try\n gfc_add_pointer (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   attr->pointer = 1;\n@@ -757,7 +732,7 @@ try\n gfc_add_cray_pointer (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   attr->cray_pointer = 1;\n@@ -769,7 +744,7 @@ try\n gfc_add_cray_pointee (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->cray_pointee)\n@@ -788,7 +763,7 @@ try\n gfc_add_result (symbol_attribute * attr, const char *name, locus * where)\n {\n \n-  if (check_used (attr, name, where) || check_done (attr, where))\n+  if (check_used (attr, name, where))\n     return FAILURE;\n \n   attr->result = 1;\n@@ -866,7 +841,7 @@ try\n gfc_add_target (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   if (attr->target)\n@@ -897,7 +872,7 @@ try\n gfc_add_in_common (symbol_attribute * attr, const char *name, locus * where)\n {\n \n-  if (check_used (attr, name, where) || check_done (attr, where))\n+  if (check_used (attr, name, where))\n     return FAILURE;\n \n   /* Duplicate attribute already checked for.  */\n@@ -965,7 +940,7 @@ try\n gfc_add_elemental (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   attr->elemental = 1;\n@@ -977,7 +952,7 @@ try\n gfc_add_pure (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   attr->pure = 1;\n@@ -989,7 +964,7 @@ try\n gfc_add_recursive (symbol_attribute * attr, locus * where)\n {\n \n-  if (check_used (attr, NULL, where) || check_done (attr, where))\n+  if (check_used (attr, NULL, where))\n     return FAILURE;\n \n   attr->recursive = 1;\n@@ -1093,7 +1068,7 @@ gfc_add_procedure (symbol_attribute * attr, procedure_type t,\n \t\t   const char *name, locus * where)\n {\n \n-  if (check_used (attr, name, where) || check_done (attr, where))\n+  if (check_used (attr, name, where))\n     return FAILURE;\n \n   if (attr->flavor != FL_PROCEDURE\n@@ -1202,10 +1177,6 @@ gfc_add_type (gfc_symbol * sym, gfc_typespec * ts, locus * where)\n {\n   sym_flavor flavor;\n \n-/* TODO: This is legal if it is reaffirming an implicit type.\n-  if (check_done (&sym->attr, where))\n-    return FAILURE;*/\n-\n   if (where == NULL)\n     where = &gfc_current_locus;\n "}, {"sha": "75f34198a0ffa77db6876bb53c6b7c1c5ad9fa6e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -4744,6 +4744,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n   gfc_init_block (&fnblock);\n \n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref (decl);\n+\n   /* If this an array of derived types with allocatable components\n      build a loop and recursively call this function.  */\n   if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE"}, {"sha": "1a916ccf93d1533f1f4c62fa313dc47c98b6bd9b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -2591,6 +2591,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n   gfc_symbol *sym;\n   gfc_formal_arglist *f;\n   stmtblock_t body;\n+  bool seen_trans_deferred_array = false;\n \n   /* Deal with implicit return variables.  Explicit return variables will\n      already have been added.  */\n@@ -2647,10 +2648,19 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t  if (TREE_STATIC (sym->backend_decl))\n \t\t    gfc_trans_static_array_pointer (sym);\n \t\t  else\n-\t\t    fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t\t    {\n+\t\t      seen_trans_deferred_array = true;\n+\t\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n+\t\t  if (sym_has_alloc_comp)\n+\t\t    {\n+\t\t      seen_trans_deferred_array = true;\n+\t\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t\t    }\n+\n \t\t  gfc_get_backend_locus (&loc);\n \t\t  gfc_set_backend_locus (&sym->declared_at);\n \t\t  fnbody = gfc_trans_auto_array_allocation (sym->backend_decl,\n@@ -2676,14 +2686,14 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t      break;\n \n \t    case AS_DEFERRED:\n-\t      if (!sym_has_alloc_comp)\n-\t\tfnbody = gfc_trans_deferred_array (sym, fnbody);\n+\t      seen_trans_deferred_array = true;\n+\t      fnbody = gfc_trans_deferred_array (sym, fnbody);\n \t      break;\n \n \t    default:\n \t      gcc_unreachable ();\n \t    }\n-\t  if (sym_has_alloc_comp)\n+\t  if (sym_has_alloc_comp && !seen_trans_deferred_array)\n \t    fnbody = gfc_trans_deferred_array (sym, fnbody);\n \t}\n       else if (sym_has_alloc_comp)"}, {"sha": "d2dd8722a5ce64bc00d42e0e5068037bab7ca13b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -1,3 +1,11 @@\n+2006-11-09 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29699\n+\t* gfortran.dg/alloc_comp_auto_array_1.f90: New test.\n+\n+\tPR fortran/21730\n+\t* gfortran.dg/change_symbol_attributes_1.f90: New test.\n+\n 2006-11-09  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* gcc.dg/20061109-1.c: New testcase."}, {"sha": "915b2108f46bfebdf2854c2691aeccb3081a4f78", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_auto_array_1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_1.f90?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+! Fix for PR29699 - see below for details.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+PROGRAM vocabulary_word_count\n+\n+  IMPLICIT NONE\n+  TYPE VARYING_STRING\n+    CHARACTER,DIMENSION(:),ALLOCATABLE :: chars\n+  ENDTYPE VARYING_STRING\n+\n+  INTEGER :: list_size=200\n+\n+  call extend_lists2\n+\n+CONTAINS\n+\n+! First the original problem: vocab_swap not being referenced caused\n+! an ICE because default initialization is used, which results in a\n+! call to gfc_conv_variable, which calls gfc_get_symbol_decl.\n+\n+  SUBROUTINE extend_lists1\n+    type(VARYING_STRING),DIMENSION(list_size) :: vocab_swap\n+  ENDSUBROUTINE extend_lists1\n+\n+! Curing this then uncovered two more problems: If vocab_swap were\n+! actually referenced, an ICE occurred in the gimplifier because\n+! the declaration for this automatic array is presented as a\n+! pointer to the array, rather than the array. Curing this allows\n+! the code to compile but it bombed out at run time because the\n+! malloc/free occurred in the wrong order with respect to the\n+! nullify/deallocate of the allocatable components.\n+\n+  SUBROUTINE extend_lists2\n+    type(VARYING_STRING),DIMENSION(list_size) :: vocab_swap\n+    allocate (vocab_swap(1)%chars(10))\n+    if (.not.allocated(vocab_swap(1)%chars)) call abort ()\n+    if (allocated(vocab_swap(10)%chars)) call abort ()\n+  ENDSUBROUTINE extend_lists2\n+  \n+ENDPROGRAM vocabulary_word_count"}, {"sha": "9b6ed37693be81bf6c2c8e5a0423c5c572926af7", "filename": "gcc/testsuite/gfortran.dg/change_symbol_attributes_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2Fgfortran.dg%2Fchange_symbol_attributes_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114edca021e3251ec74acf93e9ebe18b128c87a/gcc%2Ftestsuite%2Fgfortran.dg%2Fchange_symbol_attributes_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchange_symbol_attributes_1.f90?ref=7114edca021e3251ec74acf93e9ebe18b128c87a", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! Fix for PR21730 - declarations used to produce the error:\n+!   target        :: x                ! these 2 lines interchanged\n+!                    1\n+! Error: Cannot change attributes of symbol at (1) after it has been used.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+!\n+subroutine gfcbug27 (x)\n+  real, intent(inout) :: x(:)\n+\n+  real          :: tmp(size (x,1))  ! gfc produces an error unless\n+  target        :: x                ! these 2 lines interchanged\n+  real, pointer :: p(:)\n+\n+  p => x(:)\n+end subroutine gfcbug27"}]}