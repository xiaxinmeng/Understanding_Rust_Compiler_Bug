{"sha": "a27a5de96932f5568e8a4561dc82a1bd11814858", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3YTVkZTk2OTMyZjU1NjhlOGE0NTYxZGM4MmExYmQxMTgxNDg1OA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-26T16:47:58Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-26T16:47:58Z"}, "message": "invoke.texi: Remove -dv documentation.\n\ngcc/\n\t* doc/invoke.texi: Remove -dv documentation.  Fix up graph dump related\n\tdocumentation.  Document the '-graph' dump option.  Complete the '-slim'\n\tdump option documentation.\n\n\t* common.opt (Variable graph_dump_format): Remove.\n\t* flag-types.h (enum graph_dump_types): Remove.\n\t* flags.h (dump_for_graph): Remove.\n\t* opts.c (decode_d_option): Remove -dv handling.\n\t* sched-int.h (print_insn, print_pattern, print_value): Move prototypes\n\tfrom here ...\n\t* rtl.h: ...to here.  Add note that these functions ought to be in\n\tanother file.\n\t* sched-vis.c (print_insn): Add detailed dump for insn notes.\n\t* print-rtl.c (dump_for_graph): Remove.\n\t(print_rtx): Remove dump_for_graph related code.\n\t* graph.c: Almost complete re-write to dump DOT (GraphViz) dumps\n\tinstead of VCG dumps.\n\t* graph.h (print_rtl_graph_with_bb): Update prototype.\n\t* passes.c (finish_optimization_passes): Fix profile dump finishing.\n\tUnconditionally loop over graph dumps to finalize.\n\t(execute_function_dump): Split code to dump graphs to separate block.\n\t(execute_one_pass): Don't set TDF_GRAPH here, let the dump option\n\tdecoders do their job.\n\n\t* ddg.c (vcg_print_ddg): Make it a DEBUG_FUNCTION.\n\t* toplev.c: Don't include graph.h.\n\t* tree-optimize.c: Don't include graph.h.\n\ntestsuite/\n\t* testsuite/gcc.dg/20050811-1.c: Change -dv option to -graph option\n\tto -fdump-rtl-all.\n\t* testsuite/gcc.dg/pr37858.c: Remove -dv option.\n\nFrom-SVN: r193821", "tree": {"sha": "5059e53a87ca0ad87ef8f5e4d61bdce408a23bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5059e53a87ca0ad87ef8f5e4d61bdce408a23bc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a27a5de96932f5568e8a4561dc82a1bd11814858", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27a5de96932f5568e8a4561dc82a1bd11814858", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27a5de96932f5568e8a4561dc82a1bd11814858", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27a5de96932f5568e8a4561dc82a1bd11814858/comments", "author": null, "committer": null, "parents": [{"sha": "f460c170f063cacc7109395a8794de6cc362c87b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f460c170f063cacc7109395a8794de6cc362c87b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f460c170f063cacc7109395a8794de6cc362c87b"}], "stats": {"total": 861, "additions": 369, "deletions": 492}, "files": [{"sha": "80f9b03d45f2f23e6c77b0b5313120464d4397a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1,3 +1,33 @@\n+2012-11-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* doc/invoke.texi: Remove -dv documentation.  Fix up graph dump related\n+\tdocumentation.  Document the '-graph' dump option.  Complete the '-slim'\n+\tdump option documentation.\n+\n+\t* common.opt (Variable graph_dump_format): Remove.\n+\t* flag-types.h (enum graph_dump_types): Remove.\n+\t* flags.h (dump_for_graph): Remove.\n+\t* opts.c (decode_d_option): Remove -dv handling.\n+\t* sched-int.h (print_insn, print_pattern, print_value): Move prototypes\n+\tfrom here ...\n+\t* rtl.h: ...to here.  Add note that these functions ought to be in\n+\tanother file.\n+\t* sched-vis.c (print_insn): Add detailed dump for insn notes.\n+\t* print-rtl.c (dump_for_graph): Remove.\n+\t(print_rtx): Remove dump_for_graph related code.\n+\t* graph.c: Almost complete re-write to dump DOT (GraphViz) dumps\n+\tinstead of VCG dumps.\n+\t* graph.h (print_rtl_graph_with_bb): Update prototype.\n+\t* passes.c (finish_optimization_passes): Fix profile dump finishing.\n+\tUnconditionally loop over graph dumps to finalize.\n+\t(execute_function_dump): Split code to dump graphs to separate block.\n+\t(execute_one_pass): Don't set TDF_GRAPH here, let the dump option\n+\tdecoders do their job.\n+\n+\t* ddg.c (vcg_print_ddg): Make it a DEBUG_FUNCTION.\n+\t* toplev.c: Don't include graph.h.\n+\t* tree-optimize.c: Don't include graph.h.\n+\n 2012-11-26  Marek Polacek  <polacek@redhat.com>\n \n \t* cprop.c (hash_set): Remove variable.  Use regno"}, {"sha": "4c8bd118b289d4d83d6a9ea6a2d5996931e1b711", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -174,9 +174,6 @@ int rtl_dump_and_exit\n Variable\n int flag_print_asm_name\n \n-Variable\n-enum graph_dump_types graph_dump_format = no_graph\n-\n ; Name of top-level original source file (what was input to cpp).\n ; This comes from the #-command at the beginning of the actual input.\n ; If there isn't any there, then this is the cc1 input file name."}, {"sha": "28402e67c5ca74db048332a2c70236934bf9e292", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -753,7 +753,7 @@ print_ddg (FILE *file, ddg_ptr g)\n }\n \n /* Print the given DDG in VCG format.  */\n-void\n+DEBUG_FUNCTION void\n vcg_print_ddg (FILE *file, ddg_ptr g)\n {\n   int src_cuid;"}, {"sha": "51b6e851568c71924a43ef3c5dceda79fa27df4d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -5371,7 +5371,7 @@ appended with a sequential number starting from 1.  @var{range-list} is a\n comma-separated list of function ranges or assembler names.  Each range is a number\n pair separated by a colon.  The range is inclusive in both ends.  If the range\n is trivial, the number pair can be simplified as a single number.  If the\n-function's cgraph node's @var{uid} falls within one of the specified ranges,\n+function's call graph node's @var{uid} falls within one of the specified ranges,\n the @var{pass} is disabled for that function.  The @var{uid} is shown in the\n function header of a dump file, and the pass names can be dumped by using\n option @option{-fdump-passes}.\n@@ -5727,12 +5727,6 @@ also printed.\n Dump the RTL in the assembler output as a comment before each instruction.\n Also turns on @option{-dp} annotation.\n \n-@item -dv\n-@opindex dv\n-For each of the other indicated dump files (@option{-fdump-rtl-@var{pass}}),\n-dump a representation of the control flow graph suitable for viewing with VCG\n-to @file{@var{file}.@var{pass}.vcg}.\n-\n @item -dx\n @opindex dx\n Just generate RTL for a function instead of compiling it.  Usually used\n@@ -5841,10 +5835,16 @@ If @code{DECL_ASSEMBLER_NAME} has been set for a given decl, use that\n in the dump instead of @code{DECL_NAME}.  Its primary use is ease of\n use working backward from mangled names in the assembly file.\n @item slim\n-Inhibit dumping of members of a scope or body of a function merely\n-because that scope has been reached.  Only dump such items when they\n-are directly reachable by some other path.  When dumping pretty-printed\n-trees, this option inhibits dumping the bodies of control structures.\n+When dumping front-end intermediate representations, inhibit dumping\n+of members of a scope or body of a function merely because that scope\n+has been reached.  Only dump such items when they are directly reachable\n+by some other path.\n+\n+When dumping pretty-printed trees, this option inhibits dumping the\n+bodies of control structures.\n+\n+When dumping RTL, print the RTL in slim (condensed) form instead of\n+the default LISP-like representation.\n @item raw\n Print a raw representation of the tree.  By default, trees are\n pretty-printed into a C-like representation.\n@@ -5856,6 +5856,16 @@ Enable dumping various statistics about the pass (not honored by every dump\n option).\n @item blocks\n Enable showing basic block boundaries (disabled in raw dumps).\n+@item graph\n+For each of the other indicated dump files (@option{-fdump-rtl-@var{pass}}),\n+dump a representation of the control flow graph suitable for viewing with\n+GraphViz to @file{@var{file}.@var{passid}.@var{pass}.dot}.  Note that if\n+the file contains more than one function, the generated file cannot be\n+used directly by GraphViz@.  You must cut and paste each function's\n+graph into its own separate file first.\n+\n+This option currently only works for RTL dumps, and the RTL is always\n+dumped in slim form.\n @item vops\n Enable showing virtual operands for every statement.\n @item lineno"}, {"sha": "f5693506f15b5605c51bda6d35a98bd559c47879", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -141,13 +141,6 @@ enum excess_precision\n   EXCESS_PRECISION_STANDARD\n };\n \n-/* Selection of the graph form.  */\n-enum graph_dump_types\n-{\n-  no_graph = 0,\n-  vcg\n-};\n-\n /* Type of stack check.  */\n enum stack_check_type\n {"}, {"sha": "010e8ff933753f8d7370590aa724281fc965b756", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -89,9 +89,6 @@ extern struct target_flag_state *this_target_flag_state;\n #define flag_excess_precision \\\n   (this_target_flag_state->x_flag_excess_precision)\n \n-/* Nonzero if we dump in VCG format, not plain text.  */\n-extern int dump_for_graph;\n-\n /* Returns TRUE if generated code should match ABI version N or\n    greater is in use.  */\n "}, {"sha": "bb1bb7b6d939e49a8984ede0cabb731650f920f0", "filename": "gcc/graph.c", "status": "modified", "additions": 191, "deletions": 354, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1,7 +1,8 @@\n /* Output routines for graphical representation.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2007, 2008, 2010\n+   Copyright (C) 1998-2012\n    Free Software Foundation, Inc.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.\n+   Rewritten for DOT output by Steven Bosscher, 2012.\n \n This file is part of GCC.\n \n@@ -22,396 +23,244 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"hard-reg-set.h\"\n-#include \"obstack.h\"\n+#include \"diagnostic-core.h\" /* for fatal_error */\n+#include \"sbitmap.h\"\n #include \"basic-block.h\"\n-#include \"diagnostic-core.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n #include \"graph.h\"\n-#include \"emit-rtl.h\"\n-\n-static const char *const graph_ext[] =\n-{\n-  /* no_graph */ \"\",\n-  /* vcg */      \".vcg\",\n-};\n \n-/* The flag to indicate if output is inside of a building block.  */\n-static int inbb = 0;\n+/* DOT files with the .dot extension are recognized as document templates\n+   by a well-known piece of word processing software out of Redmond, WA.\n+   Therefore some recommend using the .gv extension instead.  Obstinately\n+   ignore that recommendatition...  */\n+static const char *const graph_ext = \".dot\";\n \n-static void start_fct (FILE *);\n-static void start_bb (FILE *, int);\n-static void node_data (FILE *, rtx);\n-static void draw_edge (FILE *, int, int, int, int);\n-static void end_fct (FILE *);\n-static void end_bb (FILE *);\n-\n-/* Output text for new basic block.  */\n-static void\n-start_fct (FILE *fp)\n+/* Open a file with MODE for dumping our graph to.\n+   Return the file pointer.  */\n+static FILE *\n+open_graph_file (const char *base, const char *mode)\n {\n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      fprintf (fp, \"\\\n-graph: { title: \\\"%s\\\"\\nfolding: 1\\nhidden: 2\\nnode: { title: \\\"%s.0\\\" }\\n\",\n-\t       current_function_name (), current_function_name ());\n-      break;\n-    case no_graph:\n-      break;\n-    }\n-}\n-\n-static void\n-start_bb (FILE *fp, int bb)\n-{\n-#if 0\n-  reg_set_iterator rsi;\n-#endif\n-\n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      fprintf (fp, \"\\\n-graph: {\\ntitle: \\\"%s.BB%d\\\"\\nfolding: 1\\ncolor: lightblue\\n\\\n-label: \\\"basic block %d\",\n-\t       current_function_name (), bb, bb);\n-      inbb = 1; /* Now We are inside of a building block.  */\n-      break;\n-    case no_graph:\n-      break;\n-    }\n+  size_t namelen = strlen (base);\n+  size_t extlen = strlen (graph_ext) + 1;\n+  char *buf = XALLOCAVEC (char, namelen + extlen);\n+  FILE *fp;\n \n-#if 0\n-  /* FIXME Should this be printed?  It makes the graph significantly larger.  */\n+  memcpy (buf, base, namelen);\n+  memcpy (buf + namelen, graph_ext, extlen);\n \n-  /* Print the live-at-start register list.  */\n-  fputc ('\\n', fp);\n-  EXECUTE_IF_SET_IN_REG_SET (basic_block_live_at_start[bb], 0, i, rsi)\n-    {\n-      fprintf (fp, \" %d\", i);\n-      if (i < FIRST_PSEUDO_REGISTER)\n-\tfprintf (fp, \" [%s]\", reg_names[i]);\n-    }\n-#endif\n+  fp = fopen (buf, mode);\n+  if (fp == NULL)\n+    fatal_error (\"can%'t open %s: %m\", buf);\n \n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      fputs (\"\\\"\\n\\n\", fp);\n-      break;\n-    case no_graph:\n-      break;\n-    }\n+  return fp;\n }\n \n-static void\n-node_data (FILE *fp, rtx tmp_rtx)\n+/* Print the output from print_insn or print_pattern with GraphViz-special\n+   characters escaped as necessary.  */\n+void\n+print_escaped_line (FILE *fp, const char *buf)\n {\n-  if (PREV_INSN (tmp_rtx) == 0)\n+  const char *p = buf;\n+\n+  while (*p)\n     {\n-      /* This is the first instruction.  Add an edge from the starting\n-\t block.  */\n-      switch (graph_dump_format)\n+      switch (*p)\n \t{\n-\tcase vcg:\n-\t  fprintf (fp, \"\\\n-edge: { sourcename: \\\"%s.0\\\" targetname: \\\"%s.%d\\\" }\\n\",\n-\t\t   current_function_name (),\n-\t\t   current_function_name (), XINT (tmp_rtx, 0));\n+\tcase '\\n':\n+\t  /* Print newlines as a left-aligned newline.  */\n+\t  fputs (\"\\\\l\\\\\\n\", fp);\n \t  break;\n-\tcase no_graph:\n+\n+\tcase '{':\n+\tcase '}':\n+\tcase '<':\n+\tcase '>':\n+\tcase '|':\n+\tcase '\"':\n+\tcase ' ':\n+\t  /* These characters have to be escaped to work with record-shape nodes.  */\n+\t  fputc ('\\\\', fp);\n+\t  /* fall through */\n+\tdefault:\n+\t  fputc (*p, fp);\n \t  break;\n \t}\n+      p++;\n     }\n+  fputs (\"\\\\l\\\\\\n\", fp);\n+}\n \n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      fprintf (fp, \"node: {\\n  title: \\\"%s.%d\\\"\\n  color: %s\\n  \\\n-label: \\\"%s %d\\n\",\n-\t       current_function_name (), XINT (tmp_rtx, 0),\n-\t       NOTE_P (tmp_rtx) ? \"lightgrey\"\n-\t       : NONJUMP_INSN_P (tmp_rtx) ? \"green\"\n-\t       : JUMP_P (tmp_rtx) ? \"darkgreen\"\n-\t       : CALL_P (tmp_rtx) ? \"darkgreen\"\n-\t       : LABEL_P (tmp_rtx) ?  \"\\\n-darkgrey\\n  shape: ellipse\" : \"white\",\n-\t       GET_RTX_NAME (GET_CODE (tmp_rtx)), XINT (tmp_rtx, 0));\n-      break;\n-    case no_graph:\n-      break;\n-    }\n+/* Draw a basic block BB belonging to the function with FNDECL_UID\n+   as its unique number.  */\n+static void\n+draw_cfg_node (FILE *fp, int fndecl_uid, basic_block bb)\n+{\n+  rtx insn;\n+  bool first = true;\n+  const char *shape;\n+  const char *fillcolor;\n \n-  /* Print the RTL.  */\n-  if (NOTE_P (tmp_rtx))\n+  if (bb->index == ENTRY_BLOCK || bb->index == EXIT_BLOCK)\n     {\n-      const char *name;\n-      name =  GET_NOTE_INSN_NAME (NOTE_KIND (tmp_rtx));\n-      fprintf (fp, \" %s\", name);\n+      shape = \"Mdiamond\";\n+      fillcolor = \"white\";\n     }\n-  else if (INSN_P (tmp_rtx))\n-    print_rtl_single (fp, PATTERN (tmp_rtx));\n   else\n-    print_rtl_single (fp, tmp_rtx);\n-\n-  switch (graph_dump_format)\n     {\n-    case vcg:\n-      fputs (\"\\\"\\n}\\n\", fp);\n-      break;\n-    case no_graph:\n-      break;\n+      shape = \"record\";\n+      fillcolor =\n+\tBB_PARTITION (bb) == BB_HOT_PARTITION ? \"lightpink\"\n+\t: BB_PARTITION (bb) == BB_COLD_PARTITION ? \"lightblue\"\n+\t: \"lightgrey\";\n     }\n-}\n \n-static void\n-draw_edge (FILE *fp, int from, int to, int bb_edge, int color_class)\n-{\n-  const char * color;\n-  switch (graph_dump_format)\n-    {\n-    case vcg:\n-      color = \"\";\n-      if (color_class == 2)\n-\tcolor = \"color: red \";\n-      else if (bb_edge)\n-\tcolor = \"color: blue \";\n-      else if (color_class == 3)\n-\tcolor = \"color: green \";\n-      fprintf (fp,\n-\t       \"edge: { sourcename: \\\"%s.%d\\\" targetname: \\\"%s.%d\\\" %s\",\n-\t       current_function_name (), from,\n-\t       current_function_name (), to, color);\n-      if (color_class)\n-\tfprintf (fp, \"class: %d \", color_class);\n-      fputs (\"}\\n\", fp);\n-      break;\n-    case no_graph:\n-      break;\n-    }\n-}\n+  fprintf (fp,\n+\t   \"\\tfn_%d_basic_block_%d [shape=%s,style=filled,fillcolor=%s,label=\\\"\",\n+\t   fndecl_uid, bb->index, shape, fillcolor);\n \n-static void\n-end_bb (FILE *fp)\n-{\n-  switch (graph_dump_format)\n+  if (bb->index == ENTRY_BLOCK)\n+    fputs (\"ENTRY\", fp);\n+  else if (bb->index == EXIT_BLOCK)\n+    fputs (\"EXIT\", fp);\n+  else\n     {\n-    case vcg:\n-      /* Check if we are inside of a building block.  */\n-      if (inbb != 0)\n-        {\n-          fputs (\"}\\n\", fp);\n-          inbb = 0; /* Now we are outside of a building block.  */\n-        }\n-      break;\n-    case no_graph:\n-      break;\n+      fputc ('{', fp);\n+      /* TODO: inter-bb stuff.  */\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  char buf[2048];\n+\n+\t  if (! first)\n+\t    fputc ('|', fp);\n+\n+\t  print_insn (buf, insn, 1);\n+\t  print_escaped_line (fp, buf);\n+\t  if (INSN_P (insn) && REG_NOTES (insn))\n+\t    for (rtx note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t      {\n+\t\tfprintf (fp, \"      %s: \",\n+\t\t\t GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n+\t\tprint_pattern (buf, XEXP (note, 0), 1);\n+\t\tprint_escaped_line (fp, buf);\n+\t      }\n+\n+\t  first = false;\n+\t}\n+      fputc ('}', fp);\n     }\n+\n+  fputs (\"\\\"];\\n\\n\", fp);\n }\n \n+/* Draw all successor edges of a basic block BB belonging to the function\n+   with FNDECL_UID as its unique number.  */\n static void\n-end_fct (FILE *fp)\n+draw_cfg_node_succ_edges (FILE *fp, int fndecl_uid, basic_block bb)\n {\n-  switch (graph_dump_format)\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-    case vcg:\n-      fprintf (fp, \"node: { title: \\\"%s.999999\\\" label: \\\"END\\\" }\\n}\\n\",\n-\t       current_function_name ());\n-      break;\n-    case no_graph:\n-      break;\n-    }\n-}\n-\f\n-/* Like print_rtl, but also print out live information for the start of each\n-   basic block.  */\n-void\n-print_rtl_graph_with_bb (const char *base, rtx rtx_first)\n-{\n-  rtx tmp_rtx;\n-  size_t namelen = strlen (base);\n-  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = XALLOCAVEC (char, namelen + extlen);\n-  FILE *fp;\n-\n-  if (!basic_block_info)\n-    return;\n+      const char *style = \"\\\"solid,bold\\\"\";\n+      const char *color = \"black\";\n+      int weight = 10;\n \n-  memcpy (buf, base, namelen);\n-  memcpy (buf + namelen, graph_ext[graph_dump_format], extlen);\n-\n-  fp = fopen (buf, \"a\");\n-  if (fp == NULL)\n-    return;\n-\n-  if (rtx_first == 0)\n-    fprintf (fp, \"(nil)\\n\");\n-  else\n-    {\n-      enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n-      int max_uid = get_max_uid ();\n-      int *start = XNEWVEC (int, max_uid);\n-      int *end = XNEWVEC (int, max_uid);\n-      enum bb_state *in_bb_p = XNEWVEC (enum bb_state, max_uid);\n-      basic_block bb;\n-      int i;\n-\n-      for (i = 0; i < max_uid; ++i)\n+      if (e->flags & EDGE_FAKE)\n \t{\n-\t  start[i] = end[i] = -1;\n-\t  in_bb_p[i] = NOT_IN_BB;\n+\t  style = \"dotted\";\n+\t  color = \"green\";\n+\t  weight = 0;\n \t}\n-\n-      FOR_EACH_BB_REVERSE (bb)\n+      else if (e->flags & EDGE_DFS_BACK)\n \t{\n-\t  rtx x;\n-\t  start[INSN_UID (BB_HEAD (bb))] = bb->index;\n-\t  end[INSN_UID (BB_END (bb))] = bb->index;\n-\t  for (x = BB_HEAD (bb); x != NULL_RTX; x = NEXT_INSN (x))\n-\t    {\n-\t      in_bb_p[INSN_UID (x)]\n-\t\t= (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n-\t\t ? IN_ONE_BB : IN_MULTIPLE_BB;\n-\t      if (x == BB_END (bb))\n-\t\tbreak;\n-\t    }\n+\t  style = \"\\\"dotted,bold\\\"\";\n+\t  color = \"blue\";\n+\t  weight = 10;\n \t}\n-\n-      /* Tell print-rtl that we want graph output.  */\n-      dump_for_graph = 1;\n-\n-      /* Start new function.  */\n-      start_fct (fp);\n-\n-      for (tmp_rtx = NEXT_INSN (rtx_first); NULL != tmp_rtx;\n-\t   tmp_rtx = NEXT_INSN (tmp_rtx))\n+      else if (e->flags & EDGE_FALLTHRU)\n \t{\n-\t  int edge_printed = 0;\n-\t  rtx next_insn;\n-\n-\t  if (start[INSN_UID (tmp_rtx)] < 0 && end[INSN_UID (tmp_rtx)] < 0)\n-\t    {\n-\t      if (BARRIER_P (tmp_rtx))\n-\t\tcontinue;\n-\t      if (NOTE_P (tmp_rtx)\n-\t\t  && (1 || in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB))\n-\t\tcontinue;\n-\t    }\n-\n-\t  if ((i = start[INSN_UID (tmp_rtx)]) >= 0)\n-\t    {\n-\t      /* We start a subgraph for each basic block.  */\n-\t      start_bb (fp, i);\n-\n-\t      if (i == 0)\n-\t\tdraw_edge (fp, 0, INSN_UID (tmp_rtx), 1, 0);\n-\t    }\n-\n-\t  /* Print the data for this node.  */\n-\t  node_data (fp, tmp_rtx);\n-\t  next_insn = next_nonnote_insn (tmp_rtx);\n-\n-\t  if ((i = end[INSN_UID (tmp_rtx)]) >= 0)\n-\t    {\n-\t      edge e;\n-\t      edge_iterator ei;\n-\n-\t      bb = BASIC_BLOCK (i);\n-\n-\t      /* End of the basic block.  */\n-\t      end_bb (fp);\n-\n-\t      /* Now specify the edges to all the successors of this\n-\t\t basic block.  */\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\t{\n-\t\t  if (e->dest != EXIT_BLOCK_PTR)\n-\t\t    {\n-\t\t      rtx block_head = BB_HEAD (e->dest);\n-\n-\t\t      draw_edge (fp, INSN_UID (tmp_rtx),\n-\t\t\t\t INSN_UID (block_head),\n-\t\t\t\t next_insn != block_head,\n-\t\t\t\t (e->flags & EDGE_ABNORMAL ? 2 : 0));\n-\n-\t\t      if (block_head == next_insn)\n-\t\t\tedge_printed = 1;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      draw_edge (fp, INSN_UID (tmp_rtx), 999999,\n-\t\t\t\t next_insn != 0,\n-\t\t\t\t (e->flags & EDGE_ABNORMAL ? 2 : 0));\n-\n-\t\t      if (next_insn == 0)\n-\t\t\tedge_printed = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (!edge_printed)\n-\t    {\n-\t      /* Don't print edges to barriers.  */\n-\t      if (next_insn == 0\n-\t\t  || !BARRIER_P (next_insn))\n-\t\tdraw_edge (fp, XINT (tmp_rtx, 0),\n-\t\t\t   next_insn ? INSN_UID (next_insn) : 999999, 0, 0);\n-\t      else\n-\t\t{\n-\t\t  /* We draw the remaining edges in class 3.  We have\n-\t\t     to skip over the barrier since these nodes are\n-\t\t     not printed at all.  */\n-\t\t  do\n-\t\t    next_insn = NEXT_INSN (next_insn);\n-\t\t  while (next_insn\n-\t\t\t && (NOTE_P (next_insn)\n-\t\t\t     || BARRIER_P (next_insn)));\n-\n-\t\t  draw_edge (fp, XINT (tmp_rtx, 0),\n-\t\t\t     next_insn ? INSN_UID (next_insn) : 999999, 0, 3);\n-\t\t}\n-\t    }\n+\t  color = \"blue\";\n+\t  weight = 100;\n \t}\n \n-      dump_for_graph = 0;\n+      if (e->flags & EDGE_ABNORMAL)\n+\tcolor = \"red\";\n \n-      end_fct (fp);\n-\n-      /* Clean up.  */\n-      free (start);\n-      free (end);\n-      free (in_bb_p);\n+      fprintf (fp,\n+\t       \"\\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n \"\n+\t       \"[style=%s,color=%s,weight=%d,constraint=%s];\\n\",\n+\t       fndecl_uid, e->src->index,\n+\t       fndecl_uid, e->dest->index,\n+\t       style, color, weight,\n+\t       (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? \"false\" : \"true\");\n     }\n+}\n+\n+/* Print a graphical representation of the CFG of function FUN.\n+   Currently only supports RTL in cfgrtl or cfglayout mode, GIMPLE is TODO.  */\n+void\n+print_rtl_graph_with_bb (const char *base, tree fndecl)\n+{\n+  const char *funcname = fndecl_name (fndecl);\n+  int fndecl_uid = DECL_UID (fndecl);\n+  FILE *fp = open_graph_file (base, \"a\");\n+  int *rpo = XNEWVEC (int, n_basic_blocks);\n+  basic_block bb;\n+  int i, n;\n+\n+  fprintf (fp,\n+\t   \"subgraph \\\"%s\\\" {\\n\"\n+\t   \"\\tcolor=\\\"black\\\";\\n\"\n+\t   \"\\tlabel=\\\"%s\\\";\\n\",\n+\t   funcname, funcname);\n+\n+  /* First print all basic blocks.\n+     Visit the blocks in reverse post order to get a good ranking\n+     of the nodes.  */\n+  n = pre_and_rev_post_order_compute (NULL, rpo, true);\n+  for (i = 0; i < n; i++)\n+    draw_cfg_node (fp, fndecl_uid, BASIC_BLOCK (rpo[i]));\n+\n+  /* Draw all edges at the end to get subgraphs right for GraphViz,\n+     which requires nodes to be defined before edges to cluster\n+     nodes properly.\n+\n+     Draw retreating edges as not constraining, this makes the layout\n+     of the graph better.  (??? Calling mark_dfs_back may change the\n+     compiler's behavior when dumping, but computing back edges here\n+     for ourselves is also not desirable.)  */\n+  mark_dfs_back_edges ();\n+  FOR_ALL_BB (bb)\n+    draw_cfg_node_succ_edges (fp, fndecl_uid, bb);\n+\n+  fputs (\"\\t}\\n\", fp);\n \n   fclose (fp);\n }\n \n+/* Start the dump of a graph.  */\n+static void\n+start_graph_dump (FILE *fp)\n+{\n+  fputs (\"digraph \\\"\\\" {\\n\"\n+\t \"overlap=false;\\n\",\n+\t fp);\n+}\n+\n+/* End the dump of a graph.  */\n+static void\n+end_graph_dump (FILE *fp)\n+{\n+  fputs (\"}\\n\", fp);\n+}\n \n /* Similar as clean_dump_file, but this time for graph output files.  */\n-\n void\n clean_graph_dump_file (const char *base)\n {\n-  size_t namelen = strlen (base);\n-  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = XALLOCAVEC (char, namelen + extlen);\n-  FILE *fp;\n-\n-  memcpy (buf, base, namelen);\n-  memcpy (buf + namelen, graph_ext[graph_dump_format], extlen);\n-\n-  fp = fopen (buf, \"w\");\n-\n-  if (fp == NULL)\n-    fatal_error (\"can%'t open %s: %m\", buf);\n-\n-  gcc_assert (graph_dump_format == vcg);\n-  fputs (\"graph: {\\nport_sharing: no\\n\", fp);\n-\n+  FILE *fp = open_graph_file (base, \"w\");\n+  start_graph_dump (fp);\n   fclose (fp);\n }\n \n@@ -420,19 +269,7 @@ clean_graph_dump_file (const char *base)\n void\n finish_graph_dump_file (const char *base)\n {\n-  size_t namelen = strlen (base);\n-  size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = XALLOCAVEC (char, namelen + extlen);\n-  FILE *fp;\n-\n-  memcpy (buf, base, namelen);\n-  memcpy (buf + namelen, graph_ext[graph_dump_format], extlen);\n-\n-  fp = fopen (buf, \"a\");\n-  if (fp != NULL)\n-    {\n-      gcc_assert (graph_dump_format == vcg);\n-      fputs (\"}\\n\", fp);\n-      fclose (fp);\n-    }\n+  FILE *fp = open_graph_file (base, \"a\");\n+  end_graph_dump (fp);\n+  fclose (fp);\n }"}, {"sha": "892ebb7edb5af23c83c610b07d179a4a7f7545d5", "filename": "gcc/graph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.h?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPH_H\n #define GCC_GRAPH_H\n \n-extern void print_rtl_graph_with_bb (const char *, rtx);\n+extern void print_rtl_graph_with_bb (const char *, tree);\n extern void clean_graph_dump_file (const char *);\n extern void finish_graph_dump_file (const char *);\n "}, {"sha": "b3a9afe8e4d8829896d05a749f9bcfc6fa69d454", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1982,9 +1982,6 @@ decode_d_option (const char *arg, struct gcc_options *opts,\n \topts->x_flag_dump_rtl_in_asm = 1;\n \topts->x_flag_print_asm_name = 1;\n \tbreak;\n-      case 'v':\n-\topts->x_graph_dump_format = vcg;\n-\tbreak;\n       case 'x':\n \topts->x_rtl_dump_and_exit = 1;\n \tbreak;"}, {"sha": "62f8e1c1e063a34c8271dca18883c29c2341d059", "filename": "gcc/passes.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -239,19 +239,18 @@ finish_optimization_passes (void)\n     {\n       dump_start (pass_profile.pass.static_pass_number, NULL);\n       print_combine_total_stats ();\n-      dump_finish (pass_combine.pass.static_pass_number);\n+      dump_finish (pass_profile.pass.static_pass_number);\n     }\n \n   /* Do whatever is necessary to finish printing the graphs.  */\n-  if (graph_dump_format != no_graph)\n-    for (i = TDI_end; (dfi = get_dump_file_info (i)) != NULL; ++i)\n-      if (dump_initialized_p (i)\n-\t  && (dfi->pflags & TDF_GRAPH) != 0\n-\t  && (name = get_dump_file_name (i)) != NULL)\n-\t{\n-\t  finish_graph_dump_file (name);\n-\t  free (name);\n-\t}\n+  for (i = TDI_end; (dfi = get_dump_file_info (i)) != NULL; ++i)\n+    if (dump_initialized_p (i)\n+\t&& (dfi->pflags & TDF_GRAPH) != 0\n+\t&& (name = get_dump_file_name (i)) != NULL)\n+      {\n+\tfinish_graph_dump_file (name);\n+\tfree (name);\n+      }\n \n   timevar_pop (TV_DUMP);\n }\n@@ -1777,18 +1776,16 @@ execute_function_dump (void *data ATTRIBUTE_UNUSED)\n       if (cfun->curr_properties & PROP_trees)\n         dump_function_to_file (current_function_decl, dump_file, dump_flags);\n       else\n-\t{\n-\t  print_rtl_with_bb (dump_file, get_insns (), dump_flags);\n-\n-\t  if ((cfun->curr_properties & PROP_cfg)\n-\t      && graph_dump_format != no_graph\n-\t      && (dump_flags & TDF_GRAPH))\n-\t    print_rtl_graph_with_bb (dump_file_name, get_insns ());\n-\t}\n+\tprint_rtl_with_bb (dump_file, get_insns (), dump_flags);\n \n       /* Flush the file.  If verification fails, we won't be able to\n \t close the file before aborting.  */\n       fflush (dump_file);\n+\n+      if ((cfun->curr_properties & PROP_cfg)\n+\t  && (cfun->curr_properties & PROP_rtl)\n+\t  && (dump_flags & TDF_GRAPH))\n+\tprint_rtl_graph_with_bb (dump_file_name, cfun->decl);\n     }\n }\n \n@@ -2338,13 +2335,11 @@ execute_one_pass (struct opt_pass *pass)\n \n   if (initializing_dump\n       && dump_file\n-      && graph_dump_format != no_graph\n+      && (dump_flags & TDF_GRAPH)\n       && cfun\n       && (cfun->curr_properties & (PROP_cfg | PROP_rtl))\n \t  == (PROP_cfg | PROP_rtl))\n     {\n-      get_dump_file_info (pass->static_pass_number)->pflags |= TDF_GRAPH;\n-      dump_flags |= TDF_GRAPH;\n       clean_graph_dump_file (dump_file_name);\n     }\n "}, {"sha": "75f93504c7341a2e31e7e9ed48b7ec4fba335c48", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 47, "deletions": 74, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -77,9 +77,6 @@ int flag_dump_unnumbered_links = 0;\n /* Nonzero means use simplified format without flags, modes, etc.  */\n int flag_simple = 0;\n \n-/* Nonzero if we are dumping graphical description.  */\n-int dump_for_graph;\n-\n #ifndef GENERATOR_FILE\n void\n print_mem_expr (FILE *outfile, const_tree expr)\n@@ -124,74 +121,62 @@ print_rtx (const_rtx in_rtx)\n \n   is_insn = INSN_P (in_rtx);\n \n-  /* When printing in VCG format we write INSNs, NOTE, LABEL, and BARRIER\n-     in separate nodes and therefore have to handle them special here.  */\n-  if (dump_for_graph\n-      && (is_insn || NOTE_P (in_rtx)\n-\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx)))\n-    {\n-      i = 3;\n-      indent = 0;\n-    }\n+  /* Print name of expression code.  */\n+  if (flag_simple && CONST_INT_P (in_rtx))\n+    fputc ('(', outfile);\n   else\n-    {\n-      /* Print name of expression code.  */\n-      if (flag_simple && CONST_INT_P (in_rtx))\n-\tfputc ('(', outfile);\n-      else\n-\tfprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n+    fprintf (outfile, \"(%s\", GET_RTX_NAME (GET_CODE (in_rtx)));\n \n-      if (! flag_simple)\n-\t{\n-\t  if (RTX_FLAG (in_rtx, in_struct))\n-\t    fputs (\"/s\", outfile);\n+  if (! flag_simple)\n+    {\n+      if (RTX_FLAG (in_rtx, in_struct))\n+\tfputs (\"/s\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, volatil))\n-\t    fputs (\"/v\", outfile);\n+      if (RTX_FLAG (in_rtx, volatil))\n+\tfputs (\"/v\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, unchanging))\n-\t    fputs (\"/u\", outfile);\n+      if (RTX_FLAG (in_rtx, unchanging))\n+\tfputs (\"/u\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, frame_related))\n-\t    fputs (\"/f\", outfile);\n+      if (RTX_FLAG (in_rtx, frame_related))\n+\tfputs (\"/f\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, jump))\n-\t    fputs (\"/j\", outfile);\n+      if (RTX_FLAG (in_rtx, jump))\n+\tfputs (\"/j\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, call))\n-\t    fputs (\"/c\", outfile);\n+      if (RTX_FLAG (in_rtx, call))\n+\tfputs (\"/c\", outfile);\n \n-\t  if (RTX_FLAG (in_rtx, return_val))\n-\t    fputs (\"/i\", outfile);\n+      if (RTX_FLAG (in_rtx, return_val))\n+\tfputs (\"/i\", outfile);\n \n-\t  /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n-\t  if ((GET_CODE (in_rtx) == EXPR_LIST\n-\t       || GET_CODE (in_rtx) == INSN_LIST)\n-\t      && (int)GET_MODE (in_rtx) < REG_NOTE_MAX)\n-\t    fprintf (outfile, \":%s\",\n-\t\t     GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n+      /* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */\n+      if ((GET_CODE (in_rtx) == EXPR_LIST\n+\t   || GET_CODE (in_rtx) == INSN_LIST)\n+\t  && (int)GET_MODE (in_rtx) < REG_NOTE_MAX)\n+\tfprintf (outfile, \":%s\",\n+\t\t GET_REG_NOTE_NAME (GET_MODE (in_rtx)));\n \n-\t  /* For other rtl, print the mode if it's not VOID.  */\n-\t  else if (GET_MODE (in_rtx) != VOIDmode)\n-\t    fprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+      /* For other rtl, print the mode if it's not VOID.  */\n+      else if (GET_MODE (in_rtx) != VOIDmode)\n+\tfprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n \n #ifndef GENERATOR_FILE\n-\t  if (GET_CODE (in_rtx) == VAR_LOCATION)\n-\t    {\n-\t      if (TREE_CODE (PAT_VAR_LOCATION_DECL (in_rtx)) == STRING_CST)\n-\t\tfputs (\" <debug string placeholder>\", outfile);\n-\t      else\n-\t\tprint_mem_expr (outfile, PAT_VAR_LOCATION_DECL (in_rtx));\n-\t      fputc (' ', outfile);\n-\t      print_rtx (PAT_VAR_LOCATION_LOC (in_rtx));\n-\t      if (PAT_VAR_LOCATION_STATUS (in_rtx)\n-\t\t  == VAR_INIT_STATUS_UNINITIALIZED)\n-\t\tfprintf (outfile, \" [uninit]\");\n-\t      sawclose = 1;\n-\t      i = GET_RTX_LENGTH (VAR_LOCATION);\n-\t    }\n-#endif\n+      if (GET_CODE (in_rtx) == VAR_LOCATION)\n+\t{\n+\t  if (TREE_CODE (PAT_VAR_LOCATION_DECL (in_rtx)) == STRING_CST)\n+\t    fputs (\" <debug string placeholder>\", outfile);\n+\t  else\n+\t    print_mem_expr (outfile, PAT_VAR_LOCATION_DECL (in_rtx));\n+\t  fputc (' ', outfile);\n+\t  print_rtx (PAT_VAR_LOCATION_LOC (in_rtx));\n+\t  if (PAT_VAR_LOCATION_STATUS (in_rtx)\n+\t      == VAR_INIT_STATUS_UNINITIALIZED)\n+\t    fprintf (outfile, \" [uninit]\");\n+\t  sawclose = 1;\n+\t  i = GET_RTX_LENGTH (VAR_LOCATION);\n \t}\n+#endif\n     }\n \n #ifndef GENERATOR_FILE\n@@ -217,14 +202,9 @@ print_rtx (const_rtx in_rtx)\n       string:\n \n \tif (str == 0)\n-\t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n+\t  fputs (\" \\\"\\\"\", outfile);\n \telse\n-\t  {\n-\t    if (dump_for_graph)\n-\t      fprintf (outfile, \" (\\\\\\\"%s\\\\\\\")\", str);\n-\t    else\n-\t      fprintf (outfile, \" (\\\"%s\\\")\", str);\n-\t  }\n+\t  fprintf (outfile, \" (\\\"%s\\\")\", str);\n \tsawclose = 1;\n \tbreak;\n \n@@ -652,15 +632,8 @@ print_rtx (const_rtx in_rtx)\n       break;\n     }\n \n-  if (dump_for_graph\n-      && (is_insn || NOTE_P (in_rtx)\n-\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx)))\n-    sawclose = 0;\n-  else\n-    {\n-      fputc (')', outfile);\n-      sawclose = 1;\n-    }\n+  fputc (')', outfile);\n+  sawclose = 1;\n }\n \n /* Print an rtx on the current line of FILE.  Initially indent IND"}, {"sha": "90b13429bb65cac8676b3838b43d8f9467265429", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -2605,6 +2605,14 @@ extern int print_rtl_single (FILE *, const_rtx);\n extern int print_rtl_single_with_indent (FILE *, const_rtx, int);\n extern void print_inline_rtx (FILE *, const_rtx, int);\n \n+/* Functions in sched-vis.c.  These must be outside INSN_SCHEDULING as\n+   sched-vis.c is compiled always.  FIXME: Ideally these functions would\n+   not be in sched-vis.c but in rtl.c, because they are not only used\n+   by the scheduler anymore but for all \"slim\" RTL dumping.  */\n+extern void print_insn (char *, const_rtx, int);\n+extern void print_pattern (char *, const_rtx, int);\n+extern void print_value (char *, const_rtx, int);\n+\n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (void);\n extern int prologue_epilogue_contains (const_rtx);"}, {"sha": "312a56d84dd6f7c6017b5e829eb27e3f1ec81ef4", "filename": "gcc/sched-int.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1578,11 +1578,5 @@ extern void sd_debug_lists (rtx, sd_list_types_def);\n \n #endif /* INSN_SCHEDULING */\n \n-/* Functions in sched-vis.c.  These must be outside INSN_SCHEDULING as\n-   sched-vis.c is compiled always.  */\n-extern void print_insn (char *, const_rtx, int);\n-extern void print_pattern (char *, const_rtx, int);\n-extern void print_value (char *, const_rtx, int);\n-\n #endif /* GCC_SCHED_INT_H */\n "}, {"sha": "9572a47dc468fbb8205e66e5e061cd97dceb0df9", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -782,12 +782,53 @@ print_insn (char *buf, const_rtx x, int verbose)\n       sprintf (buf, \"i%4d: barrier\", INSN_UID (x));\n       break;\n     case NOTE:\n-      sprintf (buf, \" %4d %s\", INSN_UID (x),\n-\t       GET_NOTE_INSN_NAME (NOTE_KIND (x)));\n-      break;\n+      {\n+        int uid = INSN_UID (x);\n+        const char *note_name = GET_NOTE_INSN_NAME (NOTE_KIND (x));\n+\tswitch (NOTE_KIND (x))\n+\t  {\n+\t  case NOTE_INSN_EH_REGION_BEG:\n+\t  case NOTE_INSN_EH_REGION_END:\n+\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n+\t\t     NOTE_EH_HANDLER (x));\n+\t    break;\n+\n+\t  case NOTE_INSN_BLOCK_BEG:\n+\t  case NOTE_INSN_BLOCK_END:\n+\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n+\t\t     BLOCK_NUMBER (NOTE_BLOCK (x)));\n+\t    break;\n+\n+\t  case NOTE_INSN_BASIC_BLOCK:\n+\t    sprintf (buf, \" %4d %s %d\", uid, note_name,\n+\t\t     NOTE_BASIC_BLOCK (x)->index);\n+\t    break;\n+\n+\t  case NOTE_INSN_DELETED_LABEL:\n+\t  case NOTE_INSN_DELETED_DEBUG_LABEL:\n+\t    {\n+\t      const char *label = NOTE_DELETED_LABEL_NAME (x);\n+\t      if (label == NULL)\n+\t\tlabel = \"\";\n+\t      sprintf (buf, \" %4d %s (\\\"%s\\\")\", uid, note_name, label);\n+\t    }\n+\t    break;\n+\n+\t  case NOTE_INSN_VAR_LOCATION:\n+\t    print_pattern (t, NOTE_VAR_LOCATION (x), verbose);\n+\t    sprintf (buf, \" %4d %s {%s}\", uid, note_name, t);\n+\t    break;\n+\n+\t  default:\n+\t    sprintf (buf, \" %4d %s\", uid, note_name);\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n     default:\n       sprintf (buf, \"i%4d  <What %s?>\", INSN_UID (x),\n \t       GET_RTX_NAME (GET_CODE (x)));\n+      break;\n     }\n }\t\t\t\t/* print_insn */\n "}, {"sha": "ed2bea89c63b63a53b8d8a5d71c6a2a1287ce5b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1,3 +1,9 @@\n+2012-11-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* testsuite/gcc.dg/20050811-1.c: Change -dv option to -graph option\n+\tto -fdump-rtl-all.\n+\t* testsuite/gcc.dg/pr37858.c: Remove -dv option.\n+\n 2012-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* lib/target-supports.exp (check_effective_target_arm_v8_vfp_ok):"}, {"sha": "010aa5a09ed19f73e0558e418577c8d20b6dd24b", "filename": "gcc/testsuite/gcc.dg/20050811-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2Fgcc.dg%2F20050811-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2Fgcc.dg%2F20050811-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20050811-1.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1,6 +1,6 @@\n-/* Test whether -dv -fdump-rtl-all doesn't crash.  */\n+/* Test whether -fdump-rtl-all-graph doesn't crash.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -dv -fdump-rtl-all\" } */\n+/* { dg-options \"-O2 -fdump-rtl-all-graph\" } */\n \n int foo (void)\n {"}, {"sha": "f606d4a5d1a1f3d06a22655c52febaf6b355dfe1", "filename": "gcc/testsuite/gcc.dg/pr37858.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr37858.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -1,6 +1,7 @@\n /* PR middle-end/37858 */\n+/* ??? With -dv removed, this test is a bit silly.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-early_local_cleanups -dv\" } */\n+/* { dg-options \"-O2 -fdump-ipa-early_local_cleanups\" } */\n \n int\n main (void)"}, {"sha": "2c2898c65c76b92f159273a6df0875bb124af6b2", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -49,7 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"intl.h\"\n #include \"ggc.h\"\n-#include \"graph.h\"\n #include \"regs.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\""}, {"sha": "48f7d450b10304232497bbb4e1adf5db931b49bf", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27a5de96932f5568e8a4561dc82a1bd11814858/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=a27a5de96932f5568e8a4561dc82a1bd11814858", "patch": "@@ -38,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"ggc.h\"\n #include \"cgraph.h\"\n-#include \"graph.h\"\n #include \"cfgloop.h\"\n #include \"except.h\"\n #include \"plugin.h\""}]}