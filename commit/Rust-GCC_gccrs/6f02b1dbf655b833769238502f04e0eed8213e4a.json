{"sha": "6f02b1dbf655b833769238502f04e0eed8213e4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwMmIxZGJmNjU1YjgzMzc2OTIzODUwMmYwNGUwZWVkODIxM2U0YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-07T03:50:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-07T03:50:08Z"}, "message": "ggc-page.c (ggc_push_context): Remove.\n\n\t* ggc-page.c (ggc_push_context): Remove.\n\t(ggc_pop_context): Likewise.\n\t* ggc.h (ggc_push_context): Remove.\n\t(ggc_pop_context): Likewise.\n\nFrom-SVN: r103979", "tree": {"sha": "f791e9db81e9b6b81a24a8b2d238a9cc05115d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f791e9db81e9b6b81a24a8b2d238a9cc05115d86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f02b1dbf655b833769238502f04e0eed8213e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f02b1dbf655b833769238502f04e0eed8213e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f02b1dbf655b833769238502f04e0eed8213e4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f02b1dbf655b833769238502f04e0eed8213e4a/comments", "author": null, "committer": null, "parents": [{"sha": "040c2e426f82c34dd55ea0920c3620695599f482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040c2e426f82c34dd55ea0920c3620695599f482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040c2e426f82c34dd55ea0920c3620695599f482"}], "stats": {"total": 110, "additions": 7, "deletions": 103}, "files": [{"sha": "65f3ff1dc980c8f1e6083fac8d051952fd8aed20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f02b1dbf655b833769238502f04e0eed8213e4a", "patch": "@@ -1,3 +1,10 @@\n+2005-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* ggc-page.c (ggc_push_context): Remove.\n+\t(ggc_pop_context): Likewise.\n+\t* ggc.h (ggc_push_context): Remove.\n+\t(ggc_pop_context): Likewise.\n+\n 2005-09-06  Saurabh Verma  <saurabh.verma@codito.com>\n \n \tPR target/8973"}, {"sha": "f9e64879d2ebd7197550787665b621ba1f72a329", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=6f02b1dbf655b833769238502f04e0eed8213e4a", "patch": "@@ -1540,18 +1540,6 @@ destroy_ggc_zone (struct alloc_zone *zone ATTRIBUTE_UNUSED)\n {\n }\n \n-/* Increment the `GC context'.  Objects allocated in an outer context\n-   are never freed, eliminating the need to register their roots.  */\n-\n-void\n-ggc_push_context (void)\n-{\n-  ++G.context_depth;\n-\n-  /* Die on wrap.  */\n-  gcc_assert (G.context_depth < HOST_BITS_PER_LONG);\n-}\n-\n /* Merge the SAVE_IN_USE_P and IN_USE_P arrays in P so that IN_USE_P\n    reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */\n \n@@ -1587,89 +1575,6 @@ ggc_recalculate_in_use_p (page_entry *p)\n \n   gcc_assert (p->num_free_objects < num_objects);\n }\n-\n-/* Decrement the `GC context'.  All objects allocated since the\n-   previous ggc_push_context are migrated to the outer context.  */\n-\n-void\n-ggc_pop_context (void)\n-{\n-  unsigned long omask;\n-  unsigned int depth, i, e;\n-#ifdef ENABLE_CHECKING\n-  unsigned int order;\n-#endif\n-\n-  depth = --G.context_depth;\n-  omask = (unsigned long)1 << (depth + 1);\n-\n-  if (!((G.context_depth_allocations | G.context_depth_collections) & omask))\n-    return;\n-\n-  G.context_depth_allocations |= (G.context_depth_allocations & omask) >> 1;\n-  G.context_depth_allocations &= omask - 1;\n-  G.context_depth_collections &= omask - 1;\n-\n-  /* The G.depth array is shortened so that the last index is the\n-     context_depth of the top element of by_depth.  */\n-  if (depth+1 < G.depth_in_use)\n-    e = G.depth[depth+1];\n-  else\n-    e = G.by_depth_in_use;\n-\n-  /* We might not have any PTEs of depth depth.  */\n-  if (depth < G.depth_in_use)\n-    {\n-\n-      /* First we go through all the pages at depth depth to\n-\t recalculate the in use bits.  */\n-      for (i = G.depth[depth]; i < e; ++i)\n-\t{\n-\t  page_entry *p = G.by_depth[i];\n-\n-\t  /* Check that all of the pages really are at the depth that\n-\t     we expect.  */\n-\t  gcc_assert (p->context_depth == depth);\n-\t  gcc_assert (p->index_by_depth == i);\n-\n-\t  prefetch (&save_in_use_p_i (i+8));\n-\t  prefetch (&save_in_use_p_i (i+16));\n-\t  if (save_in_use_p_i (i))\n-\t    {\n-\t      p = G.by_depth[i];\n-\t      ggc_recalculate_in_use_p (p);\n-\t      free (save_in_use_p_i (i));\n-\t      save_in_use_p_i (i) = 0;\n-\t    }\n-\t}\n-    }\n-\n-  /* Then, we reset all page_entries with a depth greater than depth\n-     to be at depth.  */\n-  for (i = e; i < G.by_depth_in_use; ++i)\n-    {\n-      page_entry *p = G.by_depth[i];\n-\n-      /* Check that all of the pages really are at the depth we\n-\t expect.  */\n-      gcc_assert (p->context_depth > depth);\n-      gcc_assert (p->index_by_depth == i);\n-      p->context_depth = depth;\n-    }\n-\n-  adjust_depth ();\n-\n-#ifdef ENABLE_CHECKING\n-  for (order = 2; order < NUM_ORDERS; order++)\n-    {\n-      page_entry *p;\n-\n-      for (p = G.pages[order]; p != NULL; p = p->next)\n-\tgcc_assert (p->context_depth < depth ||\n-\t\t    (p->context_depth == depth && !save_in_use_p (p)));\n-    }\n-#endif\n-}\n \f\n /* Unmark all objects.  */\n "}, {"sha": "d6b2ea833b7c9191aac35609274aa8712cd942e8", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02b1dbf655b833769238502f04e0eed8213e4a/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=6f02b1dbf655b833769238502f04e0eed8213e4a", "patch": "@@ -155,14 +155,6 @@ extern struct alloc_zone *new_ggc_zone (const char *);\n /* Free a complete GGC zone, destroying everything in it.  */\n extern void destroy_ggc_zone (struct alloc_zone *);\n \n-/* Start a new GGC context.  Memory allocated in previous contexts\n-   will not be collected while the new context is active.  */\n-extern void ggc_push_context (void);\n-\n-/* Finish a GC context.  Any uncollected memory in the new context\n-   will be merged with the old context.  */\n-extern void ggc_pop_context (void);\n-\n struct ggc_pch_data;\n \n /* Return a new ggc_pch_data structure.  */"}]}