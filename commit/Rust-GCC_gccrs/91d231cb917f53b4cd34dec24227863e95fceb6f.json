{"sha": "91d231cb917f53b4cd34dec24227863e95fceb6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkMjMxY2I5MTdmNTNiNGNkMzRkZWMyNDIyNzg2M2U5NWZjZWI2Zg==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-09-21T01:27:06Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-09-21T01:27:06Z"}, "message": "Table-driven attributes.\n\n\t* c-decl.c, config/alpha/alpha.c, config/arc/arc.c,\n\tconfig/arm/arm.c, config/arm/pe.c, config/avr/avr.c,\n\tconfig/avr/avr.h, config/d30v/d30v.h, config/fr30/fr30.h,\n\tconfig/h8300/h8300.c, config/i386/cygwin.h, config/i386/winnt.c,\n\tconfig/m32r/m32r.c, config/mcore/mcore.c, config/sh/sh.c,\n\tconfig/stormy16/stormy16.h, config/v850/v850.c, doc/c-tree.texi,\n\tdoc/tm.texi, ggc-common.c, integrate.c, print-tree.c, tree.c,\n\ttree.h: Rename DECL_MACHINE_ATTRIBUTES to DECL_ATTRIBUTES.\n\t* tree.h (struct tree_decl): Change machine_attributes to\n\tattributes.\n\t* doc/c-tree.texi: Document that all attributes are now attached\n\tto decls and types.\n\t* c-common.c (add_attribute, attrtab, attrtab_idx,\n\tdefault_valid_lang_attribute, valid_lang_attribute): Remove.\n\t(attribute_tables, attributes_initialized,\n\tc_common_attribute_table, default_lang_attribute_table): New\n\tvariables.\n\t(handle_packed_attribute, handle_nocommon_attribute,\n\thandle_common_attribute, handle_noreturn_attribute,\n\thandle_unused_attribute, handle_const_attribute,\n\thandle_transparent_union_attribute, handle_constructor_attribute,\n\thandle_destructor_attribute, handle_mode_attribute,\n\thandle_section_attribute, handle_aligned_attribute,\n\thandle_weak_attribute, handle_alias_attribute,\n\thandle_no_instrument_function_attribute,\n\thandle_no_check_memory_usage_attribute, handle_malloc_attribute,\n\thandle_no_limit_stack_attribute, handle_pure_attribute): New\n\tfunctions.\n\t(init_attributes, decl_attributes): Rewrite to implement\n\ttable-driven attributes.\n\t* c-common.h (enum attribute_flags): Move to tree.h.\n\t* c-format.c (decl_handle_format_attribute,\n\tdecl_handle_format_arg_attribute): Rename to\n\thandle_format_attribute and handle_format_arg_attribute.  Update\n\tfor table-driven attributes.\n\t* c-common.h (decl_handle_format_attribute,\n\tdecl_handle_format_arg_attribute): Remove prototypes.\n\t(handle_format_attribute, handle_format_arg_attribute): Add\n\tprototypes.\n\t* c-decl.c (grokdeclarator): Handle attributes nested inside\n\tdeclarators.\n\t* c-parse.in (setattrs, maybe_setattrs): Remove.\n\t(maybe_type_quals_setattrs): Rename to maybe_type_quals_attrs.\n\tUpdate to handle nested attributes properly.\n\t(maybe_resetattrs, after_type_declarator,\n\tparm_declarator_nostarttypename, notype_declarator, absdcl1_noea,\n\tabsdcl1_ea, direct_absdcl1): Update to handle nested attributes\n\tproperly.\n\t(make_pointer_declarator): Update to handle nested attributes\n\tproperly.\n\t* doc/extend.texi: Update documentation of limits of attributes\n\tsyntax.  Warn about problems with attribute semantics in C++.\n\t* target.h (struct target): Remove valid_decl_attribute and\n\tvalid_type_attribute.  Add attribute_table and\n\tfunction_attribute_inlinable_p.\n\t* target-def.h (TARGET_VALID_DECL_ATTRIBUTE,\n\tTARGET_VALID_TYPE_ATTRIBUTE): Remove.\n\t(TARGET_ATTRIBUTE_TABLE, TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P):\n\tAdd.\n\t(TARGET_INITIALIZER): Update.\n\t* integrate.c (FUNCTION_ATTRIBUTE_INLINABLE_P): Remove default\n\tdefinition.\n\t(function_attribute_inlinable_p): New function.  Check for the\n\tpresence of any machine attributes before using\n\ttargetm.function_attribute_inlinable_p.\n\t(function_cannot_inline_p): Update.\n\t* Makefile.in (integrate.o): Update dependencies.\n\t* doc/tm.texi: Update documentation of target attributes and\n\texample definition of TARGET_VALID_TYPE_ATTRIBUTE.\n\t* tree.c (default_valid_attribute_p, valid_machine_attribute):\n\tRemove.\n\t(default_target_attribute_table,\n\tdefault_function_attribute_inlinable_p): New.\n\t(lookup_attribute): Update comment to clarify handling of multiple\n\tattributes with the same name.\n\t(merge_attributes, attribute_list_contained): Allow multiple\n\tattributes with the same name but different arguments to appear in\n\tthe same attribute list.\n\t* tree.h (default_valid_attribute_p): Remove prototype.\n\t(struct attribute_spec): New.\n\t(default_target_attribute_table): Declare.\n\t(enum attribute_flags): Move from c-common.h.  Add\n\tATTR_FLAG_TYPE_IN_PLACE.\n\t(default_function_attribute_inlinable_p): Declare.\n\t* config/alpha/alpha.c (vms_valid_decl_attribute_p): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(vms_attribute_table): New.\n\t* config/arc/arc.c (arc_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(arc_attribute_table, arc_handle_interrupt_attribute): New.\n\t* config/arm/arm.c (arm_valid_type_attribute_p,\n\tarm_valid_decl_attribute_p, arm_pe_valid_decl_attribute_p):\n\tRemove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE, TARGET_VALID_DECL_ATTRIBUTE): Don't\n\tdefine.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(arm_attribute_table, arm_handle_fndecl_attribute,\n\tarm_handle_isr_attribute): New.\n\t* config/avr/avr.c (avr_valid_type_attribute,\n\tavr_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE, TARGET_VALID_TYPE_ATTRIBUTE): Don't\n\tdefine.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(avr_attribute_table, avr_handle_progmem_attribute,\n\tavr_handle_fndecl_attribute): New.\n\t* config/c4x/c4x.c (c4x_valid_type_attribute_p): Remove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(c4x_attribute_table, c4x_handle_fntype_attribute): New.\n\t* config/h8300/h8300.c (h8300_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(h8300_attribute_table, h8300_handle_fndecl_attribute,\n\th8300_handle_eightbit_data_attribute,\n\th8300_handle_tiny_data_attribute): New.\n\t* config/i386/i386-protos.h (ix86_valid_type_attribute_p,\n\ti386_pe_valid_decl_attribute_p, i386_pe_valid_type_attribute_p):\n\tRemove prototypes.\n\t(ix86_handle_dll_attribute, ix86_handle_shared_attribute): New\n\tdeclarations.\n\t* config/i386/i386.c (ix86_valid_type_attribute_p: Remove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE, TARGET_VALID_DECL_ATTRIBUTE): Don't\n\tdefine.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(ix86_attribute_table, ix86_handle_cdecl_attribute,\n\tix86_handle_regparm_attribute): New.\n\t* config/i386/winnt.c (i386_pe_valid_decl_attribute_p,\n\ti386_pe_valid_type_attribute_p): Remove.\n\t(ix86_handle_dll_attribute, ix86_handle_shared_attribute): New.\n\t* config/ia64/ia64.c (ia64_valid_type_attribute): Remove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(ia64_attribute_table): New.\n\t* config/m32r/m32r.c (m32r_valid_decl_attribute, interrupt_ident1,\n\tinterrupt_ident2, model_ident1, model_ident2): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(init_idents): Update.\n\t(m32r_attribute_table, m32r_handle_model_attribute): New.\n\t* config/m68hc11/m68hc11.c (m68hc11_valid_type_attribute_p):\n\tRemove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(m68hc11_attribute_table, m68hc11_handle_fntype_attribute): New.\n\t* config/mcore/mcore.c (mcore_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(mcore_attribute_table, mcore_handle_naked_attribute): New.\n\t* config/ns32k/ns32k.c (ns32k_valid_type_attribute_p): Remove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(ns32k_attribute_table, ns32k_handle_fntype_attribute): New.\n\t* config/rs6000/rs6000.c (rs6000_valid_type_attribute_p): Remove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(rs6000_attribute_table, rs6000_handle_longcall_attribute): New.\n\t* config/sh/sh.c (sh_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(sh_attribute_table, sh_handle_interrupt_handler_attribute,\n\tsh_handle_sp_switch_attribute, sh_handle_trap_exit_attribute):\n\tNew.\n\t* config/stormy16/stormy16.c (stormy16_valid_type_attribute):\n\tRemove.\n\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(stormy16_attribute_table, stormy16_handle_interrupt_attribute):\n\tNew.\n\t* config/v850/v850.c (v850_valid_decl_attribute): Remove.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n\t(TARGET_ATTRIBUTE_TABLE): Define.\n\t(v850_attribute_table, v850_handle_interrupt_attribute,\n\tv850_handle_data_area_attribute): New.\n\t* config/v850/v850-c.c (mark_current_function_as_interrupt):\n\tReturn void.  Call decl_attributes instead of\n\tvalid_machine_attribute.\n\ncp:\n\tTable-driven attributes.\n\t* decl.c: Rename DECL_MACHINE_ATTRIBUTES to DECL_ATTRIBUTES.\n\t* decl2.c (cplus_decl_attributes): Only take one attributes\n\tparameter.\n\t* cp-tree.c (cplus_decl_attributes): Update prototype.\n\t* class.c (finish_struct), decl.c (start_decl, start_function),\n\tdecl2.c (grokfield), friend.c (do_friend), parse.y\n\t(parse_bitfield): Update calls to cplus_decl_attributes.\n\t* decl.c (grokdeclarator): Take a pointer to a single ordinary\n\tattribute list.\n\t* decl.h (grokdeclarator): Update prototype.\n\t* decl2.c (grokfield): Take a single ordinary attribute list.\n\t* friend.c (do_friend): Likewise.\n\t* decl.c (shadow_tag, groktypename, start_decl,\n\tstart_handler_parms, grokdeclarator, grokparms, start_function,\n\tstart_method), decl2.c (grokfield, grokbitfield, grokoptypename),\n\tparse.y (parse_field, parse_bitfield, component_decl_1), pt.c\n\t(process_template_parm, do_decl_instantiation): Pass single\n\tordinary attribute lists around.\n\t* decl.c (grokdeclarator): Correct handling of nested attributes.\n\tRevert the patch\n\t1998-10-18  Jason Merrill  <jason@yorick.cygnus.com>\n\t\t* decl.c (grokdeclarator): Embedded attrs bind to the right,\n\t\tnot the left.\n\t.\n\t* cp-tree.h (cp_valid_lang_attribute): Remove declaration\n\t(cp_attribute_table): Declare.\n\t* decl.c (valid_lang_attribute): Don't define.\n\t(lang_attribute_table): Define.\n\t(init_decl_processing): Initialize lang_attribute_table instead of\n\tvalid_lang_attribute.\n\t* tree.c (cp_valid_lang_attribute): Remove.\n\t(handle_java_interface_attribute, handle_com_interface_attribute,\n\thandle_init_priority_attribute): New functions.\n\t(cp_attribute_table): New array.\n\t* decl2.c (import_export_class): Don't use\n\ttargetm.valid_type_attribute.\n\ntestsuite:\n\tTable-driven attributes.\n\t* g++.dg/ext/attrib1.C: New test.\n\nFrom-SVN: r45718", "tree": {"sha": "f30b39e86c1e124ae235fd7661bc83c06577bc32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f30b39e86c1e124ae235fd7661bc83c06577bc32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d231cb917f53b4cd34dec24227863e95fceb6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d231cb917f53b4cd34dec24227863e95fceb6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d231cb917f53b4cd34dec24227863e95fceb6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d231cb917f53b4cd34dec24227863e95fceb6f/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3007d592bf05a6f1728f023c46207083cd24ca32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3007d592bf05a6f1728f023c46207083cd24ca32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3007d592bf05a6f1728f023c46207083cd24ca32"}], "stats": {"total": 4240, "additions": 2613, "deletions": 1627}, "files": [{"sha": "00a521788492ec1b0783417013de2c0ce266be67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,3 +1,185 @@\n+2001-09-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\tTable-driven attributes.\n+\t* c-decl.c, config/alpha/alpha.c, config/arc/arc.c,\n+\tconfig/arm/arm.c, config/arm/pe.c, config/avr/avr.c,\n+\tconfig/avr/avr.h, config/d30v/d30v.h, config/fr30/fr30.h,\n+\tconfig/h8300/h8300.c, config/i386/cygwin.h, config/i386/winnt.c,\n+\tconfig/m32r/m32r.c, config/mcore/mcore.c, config/sh/sh.c,\n+\tconfig/stormy16/stormy16.h, config/v850/v850.c, doc/c-tree.texi,\n+\tdoc/tm.texi, ggc-common.c, integrate.c, print-tree.c, tree.c,\n+\ttree.h: Rename DECL_MACHINE_ATTRIBUTES to DECL_ATTRIBUTES.\n+\t* tree.h (struct tree_decl): Change machine_attributes to\n+\tattributes.\n+\t* doc/c-tree.texi: Document that all attributes are now attached\n+\tto decls and types.\n+\t* c-common.c (add_attribute, attrtab, attrtab_idx,\n+\tdefault_valid_lang_attribute, valid_lang_attribute): Remove.\n+\t(attribute_tables, attributes_initialized,\n+\tc_common_attribute_table, default_lang_attribute_table): New\n+\tvariables.\n+\t(handle_packed_attribute, handle_nocommon_attribute,\n+\thandle_common_attribute, handle_noreturn_attribute,\n+\thandle_unused_attribute, handle_const_attribute,\n+\thandle_transparent_union_attribute, handle_constructor_attribute,\n+\thandle_destructor_attribute, handle_mode_attribute,\n+\thandle_section_attribute, handle_aligned_attribute,\n+\thandle_weak_attribute, handle_alias_attribute,\n+\thandle_no_instrument_function_attribute,\n+\thandle_no_check_memory_usage_attribute, handle_malloc_attribute,\n+\thandle_no_limit_stack_attribute, handle_pure_attribute): New\n+\tfunctions.\n+\t(init_attributes, decl_attributes): Rewrite to implement\n+\ttable-driven attributes.\n+\t* c-common.h (enum attribute_flags): Move to tree.h.\n+\t* c-format.c (decl_handle_format_attribute,\n+\tdecl_handle_format_arg_attribute): Rename to\n+\thandle_format_attribute and handle_format_arg_attribute.  Update\n+\tfor table-driven attributes.\n+\t* c-common.h (decl_handle_format_attribute,\n+\tdecl_handle_format_arg_attribute): Remove prototypes.\n+\t(handle_format_attribute, handle_format_arg_attribute): Add\n+\tprototypes.\n+\t* c-decl.c (grokdeclarator): Handle attributes nested inside\n+\tdeclarators.\n+\t* c-parse.in (setattrs, maybe_setattrs): Remove.\n+\t(maybe_type_quals_setattrs): Rename to maybe_type_quals_attrs.\n+\tUpdate to handle nested attributes properly.\n+\t(maybe_resetattrs, after_type_declarator,\n+\tparm_declarator_nostarttypename, notype_declarator, absdcl1_noea,\n+\tabsdcl1_ea, direct_absdcl1): Update to handle nested attributes\n+\tproperly.\n+\t(make_pointer_declarator): Update to handle nested attributes\n+\tproperly.\n+\t* doc/extend.texi: Update documentation of limits of attributes\n+\tsyntax.  Warn about problems with attribute semantics in C++.\n+\t* target.h (struct target): Remove valid_decl_attribute and\n+\tvalid_type_attribute.  Add attribute_table and\n+\tfunction_attribute_inlinable_p.\n+\t* target-def.h (TARGET_VALID_DECL_ATTRIBUTE,\n+\tTARGET_VALID_TYPE_ATTRIBUTE): Remove.\n+\t(TARGET_ATTRIBUTE_TABLE, TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P):\n+\tAdd.\n+\t(TARGET_INITIALIZER): Update.\n+\t* integrate.c (FUNCTION_ATTRIBUTE_INLINABLE_P): Remove default\n+\tdefinition.\n+\t(function_attribute_inlinable_p): New function.  Check for the\n+\tpresence of any machine attributes before using\n+\ttargetm.function_attribute_inlinable_p.\n+\t(function_cannot_inline_p): Update.\n+\t* Makefile.in (integrate.o): Update dependencies.\n+\t* doc/tm.texi: Update documentation of target attributes and\n+\texample definition of TARGET_VALID_TYPE_ATTRIBUTE.\n+\t* tree.c (default_valid_attribute_p, valid_machine_attribute):\n+\tRemove.\n+\t(default_target_attribute_table,\n+\tdefault_function_attribute_inlinable_p): New.\n+\t(lookup_attribute): Update comment to clarify handling of multiple\n+\tattributes with the same name.\n+\t(merge_attributes, attribute_list_contained): Allow multiple\n+\tattributes with the same name but different arguments to appear in\n+\tthe same attribute list.\n+\t* tree.h (default_valid_attribute_p): Remove prototype.\n+\t(struct attribute_spec): New.\n+\t(default_target_attribute_table): Declare.\n+\t(enum attribute_flags): Move from c-common.h.  Add\n+\tATTR_FLAG_TYPE_IN_PLACE.\n+\t(default_function_attribute_inlinable_p): Declare.\n+\t* config/alpha/alpha.c (vms_valid_decl_attribute_p): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(vms_attribute_table): New.\n+\t* config/arc/arc.c (arc_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(arc_attribute_table, arc_handle_interrupt_attribute): New.\n+\t* config/arm/arm.c (arm_valid_type_attribute_p,\n+\tarm_valid_decl_attribute_p, arm_pe_valid_decl_attribute_p):\n+\tRemove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE, TARGET_VALID_DECL_ATTRIBUTE): Don't\n+\tdefine.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(arm_attribute_table, arm_handle_fndecl_attribute,\n+\tarm_handle_isr_attribute): New.\n+\t* config/avr/avr.c (avr_valid_type_attribute,\n+\tavr_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE, TARGET_VALID_TYPE_ATTRIBUTE): Don't\n+\tdefine.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(avr_attribute_table, avr_handle_progmem_attribute,\n+\tavr_handle_fndecl_attribute): New.\n+\t* config/c4x/c4x.c (c4x_valid_type_attribute_p): Remove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(c4x_attribute_table, c4x_handle_fntype_attribute): New.\n+\t* config/h8300/h8300.c (h8300_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(h8300_attribute_table, h8300_handle_fndecl_attribute,\n+\th8300_handle_eightbit_data_attribute,\n+\th8300_handle_tiny_data_attribute): New.\n+\t* config/i386/i386-protos.h (ix86_valid_type_attribute_p,\n+\ti386_pe_valid_decl_attribute_p, i386_pe_valid_type_attribute_p):\n+\tRemove prototypes.\n+\t(ix86_handle_dll_attribute, ix86_handle_shared_attribute): New\n+\tdeclarations.\n+\t* config/i386/i386.c (ix86_valid_type_attribute_p: Remove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE, TARGET_VALID_DECL_ATTRIBUTE): Don't\n+\tdefine.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(ix86_attribute_table, ix86_handle_cdecl_attribute,\n+\tix86_handle_regparm_attribute): New.\n+\t* config/i386/winnt.c (i386_pe_valid_decl_attribute_p,\n+\ti386_pe_valid_type_attribute_p): Remove.\n+\t(ix86_handle_dll_attribute, ix86_handle_shared_attribute): New.\n+\t* config/ia64/ia64.c (ia64_valid_type_attribute): Remove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(ia64_attribute_table): New.\n+\t* config/m32r/m32r.c (m32r_valid_decl_attribute, interrupt_ident1,\n+\tinterrupt_ident2, model_ident1, model_ident2): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(init_idents): Update.\n+\t(m32r_attribute_table, m32r_handle_model_attribute): New.\n+\t* config/m68hc11/m68hc11.c (m68hc11_valid_type_attribute_p):\n+\tRemove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(m68hc11_attribute_table, m68hc11_handle_fntype_attribute): New.\n+\t* config/mcore/mcore.c (mcore_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(mcore_attribute_table, mcore_handle_naked_attribute): New.\n+\t* config/ns32k/ns32k.c (ns32k_valid_type_attribute_p): Remove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(ns32k_attribute_table, ns32k_handle_fntype_attribute): New.\n+\t* config/rs6000/rs6000.c (rs6000_valid_type_attribute_p): Remove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(rs6000_attribute_table, rs6000_handle_longcall_attribute): New.\n+\t* config/sh/sh.c (sh_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(sh_attribute_table, sh_handle_interrupt_handler_attribute,\n+\tsh_handle_sp_switch_attribute, sh_handle_trap_exit_attribute):\n+\tNew.\n+\t* config/stormy16/stormy16.c (stormy16_valid_type_attribute):\n+\tRemove.\n+\t(TARGET_VALID_TYPE_ATTRIBUTE): Don't define\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(stormy16_attribute_table, stormy16_handle_interrupt_attribute):\n+\tNew.\n+\t* config/v850/v850.c (v850_valid_decl_attribute): Remove.\n+\t(TARGET_VALID_DECL_ATTRIBUTE): Don't define.\n+\t(TARGET_ATTRIBUTE_TABLE): Define.\n+\t(v850_attribute_table, v850_handle_interrupt_attribute,\n+\tv850_handle_data_area_attribute): New.\n+\t* config/v850/v850-c.c (mark_current_function_as_interrupt):\n+\tReturn void.  Call decl_attributes instead of\n+\tvalid_machine_attribute.\n+\n Fri Sep 21 01:49:41 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* sh-protos.h (sh_pr_n_sets): Declare."}, {"sha": "ddde078f7234f185605e926896c358462686d829", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1436,7 +1436,7 @@ real.o : real.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) toplev.h $(TM_P_H)\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    debug.h $(INTEGRATE_H) insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n    intl.h function.h output.h $(RECOG_H) except.h toplev.h $(LOOP_H) \\\n-   $(PARAMS_H) $(TM_P_H)\n+   $(PARAMS_H) $(TM_P_H) $(TARGET_H)\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n    toplev.h $(INSN_ATTR_H) $(TM_P_H) reload.h $(PREDICT_H)"}, {"sha": "8d00cfed7c57cae335ada7b100a6e91964fb0fe2", "filename": "gcc/c-common.c", "status": "modified", "additions": 910, "deletions": 433, "changes": 1343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -243,10 +243,7 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n-static void add_attribute\t\tPARAMS ((enum attrs, const char *,\n-\t\t\t\t\t\t int, int, int));\n static void init_attributes\t\tPARAMS ((void));\n-static int default_valid_lang_attribute PARAMS ((tree, tree, tree, tree));\n static int constant_fits_type_p\t\tPARAMS ((tree, tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n@@ -640,514 +637,994 @@ combine_strings (strings)\n   return value;\n }\n \f\n-/* To speed up processing of attributes, we maintain an array of\n-   IDENTIFIER_NODES and the corresponding attribute types.  */\n-\n-/* Array to hold attribute information.  */\n-\n-static struct {enum attrs id; tree name; int min, max, decl_req;} attrtab[50];\n-\n-static int attrtab_idx = 0;\n-\n-/* Add an entry to the attribute table above.  */\n-\n-static void\n-add_attribute (id, string, min_len, max_len, decl_req)\n-     enum attrs id;\n-     const char *string;\n-     int min_len, max_len;\n-     int decl_req;\n+/* Table of the tables of attributes (common, language, machine) searched.  */\n+static const struct attribute_spec *attribute_tables[3];\n+\n+static bool attributes_initialized = false;\n+\n+static tree handle_packed_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_nocommon_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_common_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_noreturn_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_unused_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_const_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_mode_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_section_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_aligned_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_weak_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_alias_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_no_check_memory_usage_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_malloc_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_pure_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+\n+/* Table of machine-independent attributes common to all C-like languages.  */\n+static const struct attribute_spec c_common_attribute_table[] =\n {\n-  char buf[100];\n-\n-  attrtab[attrtab_idx].id = id;\n-  attrtab[attrtab_idx].name = get_identifier (string);\n-  attrtab[attrtab_idx].min = min_len;\n-  attrtab[attrtab_idx].max = max_len;\n-  attrtab[attrtab_idx++].decl_req = decl_req;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"packed\",                 0, 0, false, false, false, handle_packed_attribute },\n+  { \"nocommon\",               0, 0, true,  false, false, handle_nocommon_attribute },\n+  { \"common\",                 0, 0, true,  false, false, handle_common_attribute },\n+  /* FIXME: logically, noreturn attributes should be listed as\n+     \"false, true, true\" and apply to function types.  But implementing this\n+     would require all the places in the compiler that use TREE_THIS_VOLATILE\n+     on a decl to identify non-returning functions to be located and fixed\n+     to check the function type instead.  */\n+  { \"noreturn\",               0, 0, true,  false, false, handle_noreturn_attribute },\n+  { \"volatile\",               0, 0, true,  false, false, handle_noreturn_attribute },\n+  { \"unused\",                 0, 0, false, false, false, handle_unused_attribute },\n+  /* The same comments as for noreturn attributes apply to const ones.  */\n+  { \"const\",                  0, 0, true,  false, false, handle_const_attribute },\n+  { \"transparent_union\",      0, 0, false, false, false, handle_transparent_union_attribute },\n+  { \"constructor\",            0, 0, true,  false, false, handle_constructor_attribute },\n+  { \"destructor\",             0, 0, true,  false, false, handle_destructor_attribute },\n+  { \"mode\",                   1, 1, true,  false, false, handle_mode_attribute },\n+  { \"section\",                1, 1, true,  false, false, handle_section_attribute },\n+  { \"aligned\",                0, 1, false, false, false, handle_aligned_attribute },\n+  { \"format\",                 3, 3, true,  false, false, handle_format_attribute },\n+  { \"format_arg\",             1, 1, true,  false, false, handle_format_arg_attribute },\n+  { \"weak\",                   0, 0, true,  false, false, handle_weak_attribute },\n+  { \"alias\",                  1, 1, true,  false, false, handle_alias_attribute },\n+  { \"no_instrument_function\", 0, 0, true,  false, false, handle_no_instrument_function_attribute },\n+  { \"no_check_memory_usage\",  0, 0, true,  false, false, handle_no_check_memory_usage_attribute },\n+  { \"malloc\",                 0, 0, true,  false, false, handle_malloc_attribute },\n+  { \"no_stack_limit\",         0, 0, true,  false, false, handle_no_limit_stack_attribute },\n+  { \"pure\",                   0, 0, true,  false, false, handle_pure_attribute },\n+  { NULL,                     0, 0, false, false, false, NULL }\n+};\n \n-  sprintf (buf, \"__%s__\", string);\n+/* Default empty table of language attributes.  */\n+static const struct attribute_spec default_lang_attribute_table[] =\n+{\n+  { NULL, 0, 0, false, false, false, NULL }\n+};\n \n-  attrtab[attrtab_idx].id = id;\n-  attrtab[attrtab_idx].name = get_identifier (buf);\n-  attrtab[attrtab_idx].min = min_len;\n-  attrtab[attrtab_idx].max = max_len;\n-  attrtab[attrtab_idx++].decl_req = decl_req;\n-}\n+/* Table of machine-independent attributes for a particular language.  */\n+const struct attribute_spec *lang_attribute_table = default_lang_attribute_table;\n \n-/* Initialize attribute table.  */\n+/* Initialize attribute tables, and make some sanity checks\n+   if --enable-checking.  */\n \n static void\n init_attributes ()\n {\n-  add_attribute (A_PACKED, \"packed\", 0, 0, 0);\n-  add_attribute (A_NOCOMMON, \"nocommon\", 0, 0, 1);\n-  add_attribute (A_COMMON, \"common\", 0, 0, 1);\n-  add_attribute (A_NORETURN, \"noreturn\", 0, 0, 1);\n-  add_attribute (A_NORETURN, \"volatile\", 0, 0, 1);\n-  add_attribute (A_UNUSED, \"unused\", 0, 0, 0);\n-  add_attribute (A_CONST, \"const\", 0, 0, 1);\n-  add_attribute (A_T_UNION, \"transparent_union\", 0, 0, 0);\n-  add_attribute (A_CONSTRUCTOR, \"constructor\", 0, 0, 1);\n-  add_attribute (A_DESTRUCTOR, \"destructor\", 0, 0, 1);\n-  add_attribute (A_MODE, \"mode\", 1, 1, 1);\n-  add_attribute (A_SECTION, \"section\", 1, 1, 1);\n-  add_attribute (A_ALIGNED, \"aligned\", 0, 1, 0);\n-  add_attribute (A_FORMAT, \"format\", 3, 3, 1);\n-  add_attribute (A_FORMAT_ARG, \"format_arg\", 1, 1, 1);\n-  add_attribute (A_WEAK, \"weak\", 0, 0, 1);\n-  add_attribute (A_ALIAS, \"alias\", 1, 1, 1);\n-  add_attribute (A_NO_INSTRUMENT_FUNCTION, \"no_instrument_function\", 0, 0, 1);\n-  add_attribute (A_NO_CHECK_MEMORY_USAGE, \"no_check_memory_usage\", 0, 0, 1);\n-  add_attribute (A_MALLOC, \"malloc\", 0, 0, 1);\n-  add_attribute (A_NO_LIMIT_STACK, \"no_stack_limit\", 0, 0, 1);\n-  add_attribute (A_PURE, \"pure\", 0, 0, 1);\n+#ifdef ENABLE_CHECKING\n+  int i;\n+#endif\n+  attribute_tables[0] = c_common_attribute_table;\n+  attribute_tables[1] = lang_attribute_table;\n+  attribute_tables[2] = targetm.attribute_table;\n+#ifdef ENABLE_CHECKING\n+  /* Make some sanity checks on the attribute tables.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j;\n+      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\t{\n+\t  /* The name must not begin and end with __.  */\n+\t  const char *name = attribute_tables[i][j].name;\n+\t  int len = strlen (name);\n+\t  if (name[0] == '_' && name[1] == '_'\n+\t      && name[len - 1] == '_' && name[len - 2] == '_')\n+\t    abort ();\n+\t  /* The minimum and maximum lengths must be consistent.  */\n+\t  if (attribute_tables[i][j].min_length < 0)\n+\t    abort ();\n+\t  if (attribute_tables[i][j].max_length != -1\n+\t      && attribute_tables[i][j].max_length < attribute_tables[i][j].min_length)\n+\t    abort ();\n+\t  /* An attribute cannot require both a DECL and a TYPE.  */\n+\t  if (attribute_tables[i][j].decl_required\n+\t      && attribute_tables[i][j].type_required)\n+\t    abort ();\n+\t  /* If an attribute requires a function type, in particular\n+\t     it requires a type.  */\n+\t  if (attribute_tables[i][j].function_type_required\n+\t      && !attribute_tables[i][j].type_required)\n+\t    abort ();\n+\t}\n+    }\n+  /* Check that each name occurs just once in each table.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j, k;\n+      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\tfor (k = j + 1; attribute_tables[i][k].name != NULL; k++)\n+\t  if (!strcmp (attribute_tables[i][j].name,\n+\t\t       attribute_tables[i][k].name))\n+\t    abort ();\n+    }\n+  /* Check that no name occurs in more than one table.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j;\n+      for (j = i + 1;\n+\t   j < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+\t   j++)\n+\t{\n+\t  int k, l;\n+\t  for (k = 0; attribute_tables[i][k].name != NULL; k++)\n+\t    for (l = 0; attribute_tables[j][l].name != NULL; l++)\n+\t      if (!strcmp (attribute_tables[i][k].name,\n+\t\t\t   attribute_tables[j][l].name))\n+\t\tabort ();\n+\t}\n+    }\n+#endif\n+  attributes_initialized = true;\n }\n \f\n-/* Default implementation of valid_lang_attribute, below.  By default, there\n-   are no language-specific attributes.  */\n-\n-static int\n-default_valid_lang_attribute (attr_name, attr_args, decl, type)\n-  tree attr_name ATTRIBUTE_UNUSED;\n-  tree attr_args ATTRIBUTE_UNUSED;\n-  tree decl ATTRIBUTE_UNUSED;\n-  tree type ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n-/* Return a 1 if ATTR_NAME and ATTR_ARGS denote a valid language-specific\n-   attribute for either declaration DECL or type TYPE and 0 otherwise.  */\n-\n-int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree))\n-     = default_valid_lang_attribute;\n-\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n-   it should be modified in place; if a TYPE, a copy should be created.\n-   FLAGS gives further information, in the form of a bitwise OR of flags\n-   in enum attribute_flags from c-common.h.  Depending on these flags,\n-   some attributes may be returned to be applied at a later stage (for\n-   example, to apply a decl attribute to the declaration rather than to\n-   its type).  */\n+   it should be modified in place; if a TYPE, a copy should be created\n+   unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further\n+   information, in the form of a bitwise OR of flags in enum attribute_flags\n+   from tree.h.  Depending on these flags, some attributes may be\n+   returned to be applied at a later stage (for example, to apply\n+   a decl attribute to the declaration rather than to its type).  */\n \n tree\n decl_attributes (node, attributes, flags)\n      tree *node, attributes;\n-     int flags ATTRIBUTE_UNUSED;\n+     int flags;\n {\n-  tree decl = 0, type = 0;\n-  int is_type = 0;\n   tree a;\n+  tree returned_attrs = NULL_TREE;\n \n-  if (attrtab_idx == 0)\n+  if (!attributes_initialized)\n     init_attributes ();\n \n-  if (DECL_P (*node))\n-    {\n-      decl = *node;\n-      type = TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n-    }\n-  else if (TYPE_P (*node))\n-    type = *node, is_type = 1;\n-\n   (*targetm.insert_attributes) (*node, &attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n     {\n       tree name = TREE_PURPOSE (a);\n       tree args = TREE_VALUE (a);\n+      tree *anode = node;\n+      const struct attribute_spec *spec = NULL;\n+      bool no_add_attrs = 0;\n       int i;\n-      enum attrs id;\n-\n-      for (i = 0; i < attrtab_idx; i++)\n-\tif (attrtab[i].name == name)\n-\t  break;\n \n-      if (i == attrtab_idx)\n+      for (i = 0;\n+\t   i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+\t   i++)\n \t{\n-\t  if (! valid_machine_attribute (name, args, decl, type)\n-\t      && ! (* valid_lang_attribute) (name, args, decl, type))\n-\t    warning (\"`%s' attribute directive ignored\",\n-\t\t     IDENTIFIER_POINTER (name));\n-\t  else if (decl != 0)\n-\t    type = TREE_TYPE (decl);\n-\t  continue;\n+\t  int j;\n+\t  for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\t    {\n+\t      if (is_attribute_p (attribute_tables[i][j].name, name))\n+\t\t{\n+\t\t  spec = &attribute_tables[i][j];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (spec != NULL)\n+\t    break;\n \t}\n-      else if (attrtab[i].decl_req && decl == 0)\n+\n+      if (spec == NULL)\n \t{\n-\t  warning (\"`%s' attribute does not apply to types\",\n+\t  warning (\"`%s' attribute directive ignored\",\n \t\t   IDENTIFIER_POINTER (name));\n \t  continue;\n \t}\n-      else if (list_length (args) < attrtab[i].min\n-\t       || list_length (args) > attrtab[i].max)\n+      else if (list_length (args) < spec->min_length\n+\t       || (spec->max_length >= 0\n+\t\t   && list_length (args) > spec->max_length))\n \t{\n \t  error (\"wrong number of arguments specified for `%s' attribute\",\n \t\t IDENTIFIER_POINTER (name));\n \t  continue;\n \t}\n \n-      id = attrtab[i].id;\n-      switch (id)\n+      if (spec->decl_required && !DECL_P (*anode))\n \t{\n-\tcase A_PACKED:\n-\t  if (is_type)\n-\t    TYPE_PACKED (type) = 1;\n-\t  else if (TREE_CODE (decl) == FIELD_DECL)\n-\t    DECL_PACKED (decl) = 1;\n-\t  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n-\t     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n-\n-\tcase A_NOCOMMON:\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n-\t    DECL_COMMON (decl) = 0;\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n-\n-\tcase A_COMMON:\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n-\t    DECL_COMMON (decl) = 1;\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n-\n-\tcase A_NORETURN:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    TREE_THIS_VOLATILE (decl) = 1;\n-\t  else if (TREE_CODE (type) == POINTER_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-\t    TREE_TYPE (decl) = type\n-\t      = build_pointer_type\n-\t\t(build_type_variant (TREE_TYPE (type),\n-\t\t\t\t     TREE_READONLY (TREE_TYPE (type)), 1));\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n-\n-\tcase A_MALLOC:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    DECL_IS_MALLOC (decl) = 1;\n-\t  /* ??? TODO: Support types.  */\n+\t  if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t       | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t       | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t    {\n+\t      /* Pass on this attribute to be tried again.  */\n+\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      continue;\n+\t    }\n \t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+\t    {\n+\t      warning (\"`%s' attribute does not apply to types\",\n+\t\t       IDENTIFIER_POINTER (name));\n+\t      continue;\n+\t    }\n+\t}\n \n-\tcase A_UNUSED:\n-\t  if (is_type)\n-\t    if (decl)\n-\t      TREE_USED (decl) = 1;\n-\t    else\n-\t      TREE_USED (type) = 1;\n-\t  else if (TREE_CODE (decl) == PARM_DECL\n-\t\t   || TREE_CODE (decl) == VAR_DECL\n-\t\t   || TREE_CODE (decl) == FUNCTION_DECL\n-\t\t   || TREE_CODE (decl) == LABEL_DECL)\n-\t    TREE_USED (decl) = 1;\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+      if (spec->type_required && DECL_P (*anode))\n+\t{\n+\t  anode = &TREE_TYPE (*anode);\n+\t}\n \n-\tcase A_CONST:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    TREE_READONLY (decl) = 1;\n-\t  else if (TREE_CODE (type) == POINTER_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-\t    TREE_TYPE (decl) = type\n-\t      = build_pointer_type\n-\t\t(build_type_variant (TREE_TYPE (type), 1,\n-\t\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n-\t  else\n-\t    warning ( \"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+      if (spec->function_type_required && TREE_CODE (*anode) != FUNCTION_TYPE\n+\t  && TREE_CODE (*anode) != METHOD_TYPE)\n+\t{\n+\t  if (TREE_CODE (*anode) == POINTER_TYPE\n+\t      && (TREE_CODE (TREE_TYPE (*anode)) == FUNCTION_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (*anode)) == METHOD_TYPE))\n+\t    {\n+\t      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t\t*anode = build_type_copy (*anode);\n+\t      anode = &TREE_TYPE (*anode);\n+\t    }\n+\t  else if (flags & (int) ATTR_FLAG_FUNCTION_NEXT)\n+\t    {\n+\t      /* Pass on this attribute to be tried again.  */\n+\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      continue;\n+\t    }\n \n-\tcase A_PURE:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    DECL_IS_PURE (decl) = 1;\n-\t  /* ??? TODO: Support types.  */\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+\t  if (TREE_CODE (*anode) != FUNCTION_TYPE\n+\t      && TREE_CODE (*anode) != METHOD_TYPE)\n+\t    {\n+\t      warning (\"`%s' attribute only applies to function types\",\n+\t\t       IDENTIFIER_POINTER (name));\n+\t      continue;\n+\t    }\n+\t}\n \n+      if (spec->handler != NULL)\n+\treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n+\t\t\t\t\t\t    flags, &no_add_attrs),\n+\t\t\t\t  returned_attrs);\n+      if (!no_add_attrs)\n+\t{\n+\t  tree old_attrs;\n+\t  tree a;\n \n-\tcase A_T_UNION:\n-\t  if (is_type\n-\t      && TREE_CODE (type) == UNION_TYPE\n-\t      && (decl == 0\n-\t\t  || (TYPE_FIELDS (type) != 0\n-\t\t      && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))))\n-\t    TYPE_TRANSPARENT_UNION (type) = 1;\n-\t  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n-\t\t   && TREE_CODE (type) == UNION_TYPE\n-\t\t   && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))\n-\t    DECL_TRANSPARENT_UNION (decl) = 1;\n+\t  if (DECL_P (*anode))\n+\t    old_attrs = DECL_ATTRIBUTES (*anode);\n \t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+\t    old_attrs = TYPE_ATTRIBUTES (*anode);\n \n-\tcase A_CONSTRUCTOR:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL\n-\t      && TREE_CODE (type) == FUNCTION_TYPE\n-\t      && decl_function_context (decl) == 0)\n+\t  for (a = lookup_attribute (spec->name, old_attrs);\n+\t       a != NULL_TREE;\n+\t       a = lookup_attribute (spec->name, TREE_CHAIN (a)))\n \t    {\n-\t      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-\t      TREE_USED (decl) = 1;\n+\t      if (simple_cst_equal (TREE_VALUE (a), args) == 1)\n+\t\tbreak;\n \t    }\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n \n-\tcase A_DESTRUCTOR:\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL\n-\t      && TREE_CODE (type) == FUNCTION_TYPE\n-\t      && decl_function_context (decl) == 0)\n+\t  if (a == NULL_TREE)\n \t    {\n-\t      DECL_STATIC_DESTRUCTOR (decl) = 1;\n-\t      TREE_USED (decl) = 1;\n+\t      /* This attribute isn't already in the list.  */\n+\t      if (DECL_P (*anode))\n+\t\tDECL_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n+\t      else if (flags & (int) ATTR_FLAG_TYPE_IN_PLACE)\n+\t\tTYPE_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n+\t      else\n+\t\t*anode = build_type_attribute_variant (*anode,\n+\t\t\t\t\t\t       tree_cons (name, args,\n+\t\t\t\t\t\t\t\t  old_attrs));\n \t    }\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+\t}\n+    }\n \n-\tcase A_MODE:\n-\t  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  else\n-\t    {\n-\t      int j;\n-\t      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n-\t      int len = strlen (p);\n-\t      enum machine_mode mode = VOIDmode;\n-\t      tree typefm;\n-\n-\t      if (len > 4 && p[0] == '_' && p[1] == '_'\n-\t\t  && p[len - 1] == '_' && p[len - 2] == '_')\n-\t\t{\n-\t\t  char *newp = (char *) alloca (len - 1);\n+  return returned_attrs;\n+}\n \n-\t\t  strcpy (newp, &p[2]);\n-\t\t  newp[len - 4] = '\\0';\n-\t\t  p = newp;\n-\t\t}\n+/* Handle a \"packed\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_packed_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree *type = NULL;\n+  if (DECL_P (*node))\n+    {\n+      if (TREE_CODE (*node) == TYPE_DECL)\n+\ttype = &TREE_TYPE (*node);\n+    }\n+  else\n+    type = node;\n+  if (type)\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_PACKED (*type) = 1;\n+    }\n+  else if (TREE_CODE (*node) == FIELD_DECL)\n+    DECL_PACKED (*node) = 1;\n+  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n+     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-\t      /* Give this decl a type with the specified mode.\n-\t\t First check for the special modes.  */\n-\t      if (! strcmp (p, \"byte\"))\n-\t\tmode = byte_mode;\n-\t      else if (!strcmp (p, \"word\"))\n-\t\tmode = word_mode;\n-\t      else if (! strcmp (p, \"pointer\"))\n-\t\tmode = ptr_mode;\n-\t      else\n-\t\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n-\t\t  if (!strcmp (p, GET_MODE_NAME (j)))\n-\t\t    mode = (enum machine_mode) j;\n-\n-\t      if (mode == VOIDmode)\n-\t\terror (\"unknown machine mode `%s'\", p);\n-\t      else if (0 == (typefm = type_for_mode (mode,\n-\t\t\t\t\t\t     TREE_UNSIGNED (type))))\n-\t\terror (\"no data type for mode `%s'\", p);\n-\t      else\n-\t\t{\n-\t\t  if (TYPE_PRECISION (typefm) > (TREE_UNSIGNED (type)\n-\t\t\t\t\t\t ? TYPE_PRECISION(uintmax_type_node)\n-\t\t\t\t\t\t : TYPE_PRECISION(intmax_type_node))\n-\t\t      && pedantic)\n-\t\t    pedwarn (\"type with more precision than %s\",\n-\t\t\t     TREE_UNSIGNED (type) ? \"uintmax_t\" : \"intmax_t\");\n-\t\t  TREE_TYPE (decl) = type = typefm;\n-\t\t  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n-\t\t  if (TREE_CODE (decl) != FIELD_DECL)\n-\t\t    layout_decl (decl, 0);\n-\t\t}\n-\t    }\n-\t  break;\n+  return NULL_TREE;\n+}\n \n-\tcase A_SECTION:\n-\t  if (targetm.have_named_sections)\n-\t    {\n-\t      if ((TREE_CODE (decl) == FUNCTION_DECL\n-\t\t   || TREE_CODE (decl) == VAR_DECL)\n-\t\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-\t\t{\n-\t\t  if (TREE_CODE (decl) == VAR_DECL\n-\t\t      && current_function_decl != NULL_TREE\n-\t\t      && ! TREE_STATIC (decl))\n-\t\t    error_with_decl (decl,\n-\t\t\t\t     \"section attribute cannot be specified for local variables\");\n-\t\t  /* The decl may have already been given a section attribute\n-\t\t     from a previous declaration.  Ensure they match.  */\n-\t\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n-\t\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n-\t\t    error_with_decl (*node,\n-\t\t\t\t     \"section of `%s' conflicts with previous declaration\");\n-\t\t  else\n-\t\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n-\t\t}\n-\t      else\n-\t\terror_with_decl (*node,\n-\t\t\t\t \"section attribute not allowed for `%s'\");\n-\t    }\n-\t  else\n-\t    error_with_decl (*node,\n-\t\t\t     \"section attributes are not supported for this target\");\n-\t  break;\n+/* Handle a \"nocommon\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 0;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-\tcase A_ALIGNED:\n-\t  {\n-\t    tree align_expr\n-\t      = (args ? TREE_VALUE (args)\n-\t\t : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\t    int i;\n-\n-\t    /* Strip any NOPs of any kind.  */\n-\t    while (TREE_CODE (align_expr) == NOP_EXPR\n-\t\t   || TREE_CODE (align_expr) == CONVERT_EXPR\n-\t\t   || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n-\t      align_expr = TREE_OPERAND (align_expr, 0);\n-\n-\t    if (TREE_CODE (align_expr) != INTEGER_CST)\n-\t      {\n-\t\terror (\"requested alignment is not a constant\");\n-\t\tcontinue;\n-\t      }\n+  return NULL_TREE;\n+}\n \n-\t    if ((i = tree_log2 (align_expr)) == -1)\n-\t      error (\"requested alignment is not a power of 2\");\n-\t    else if (i > HOST_BITS_PER_INT - 2)\n-\t      error (\"requested alignment is too large\");\n-\t    else if (is_type)\n-\t      {\n-\t\t/* If we have a TYPE_DECL, then copy the type, so that we\n-\t\t   don't accidentally modify a builtin type.  See pushdecl.  */\n-\t\tif (decl && TREE_TYPE (decl) != error_mark_node\n-\t\t    && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n-\t\t  {\n-\t\t    tree tt = TREE_TYPE (decl);\n-\t\t    DECL_ORIGINAL_TYPE (decl) = tt;\n-\t\t    tt = build_type_copy (tt);\n-\t\t    TYPE_NAME (tt) = decl;\n-\t\t    TREE_USED (tt) = TREE_USED (decl);\n-\t\t    TREE_TYPE (decl) = tt;\n-\t\t    type = tt;\n-\t\t  }\n-\n-\t\tTYPE_ALIGN (type) = (1 << i) * BITS_PER_UNIT;\n-\t\tTYPE_USER_ALIGN (type) = 1;\n-\t      }\n-\t    else if (TREE_CODE (decl) != VAR_DECL\n-\t\t     && TREE_CODE (decl) != FIELD_DECL)\n-\t      error_with_decl (decl,\n-\t\t\t       \"alignment may not be specified for `%s'\");\n-\t    else\n-\t      {\n-\t\tDECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n-\t\tDECL_USER_ALIGN (decl) = 1;\n-\t      }\n-\t  }\n-\t  break;\n+/* Handle a \"common\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_common_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-\tcase A_FORMAT:\n-\t  decl_handle_format_attribute (decl, args);\n-\t  break;\n+  return NULL_TREE;\n+}\n \n-\tcase A_FORMAT_ARG:\n-\t  decl_handle_format_arg_attribute (decl, args);\n-\t  break;\n+/* Handle a \"noreturn\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_THIS_VOLATILE (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type (build_type_variant (TREE_TYPE (type),\n+\t\t\t\t\t\tTREE_READONLY (TREE_TYPE (type)), 1));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-\tcase A_WEAK:\n-\t  declare_weak (decl);\n-\t  break;\n+  return NULL_TREE;\n+}\n \n-\tcase A_ALIAS:\n-\t  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-\t      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n-\t    error_with_decl (decl,\n-\t\t\t     \"`%s' defined both normally and as an alias\");\n-\t  else if (decl_function_context (decl) == 0)\n-\t    {\n-\t      tree id;\n+/* Handle a \"unused\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_unused_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node))\n+    {\n+      tree decl = *node;\n+\n+      if (TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == LABEL_DECL\n+\t  || TREE_CODE (decl) == TYPE_DECL)\n+\tTREE_USED (decl) = 1;\n+      else\n+\t{\n+\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*node = build_type_copy (*node);\n+      TREE_USED (*node) = 1;\n+    }\n \n-\t      id = TREE_VALUE (args);\n-\t      if (TREE_CODE (id) != STRING_CST)\n-\t\t{\n-\t\t  error (\"alias arg not a string\");\n-\t\t  break;\n-\t\t}\n-\t      id = get_identifier (TREE_STRING_POINTER (id));\n-\t      /* This counts as a use of the object pointed to.  */\n-\t      TREE_USED (id) = 1;\n+  return NULL_TREE;\n+}\n \n-\t      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t\tDECL_INITIAL (decl) = error_mark_node;\n-\t      else\n-\t\tDECL_EXTERNAL (decl) = 0;\n-\t      assemble_alias (decl, id);\n-\t    }\n-\t  else\n-\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  break;\n+/* Handle a \"const\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_const_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_READONLY (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type (build_type_variant (TREE_TYPE (type), 1,\n+\t\t\t\t\t\tTREE_THIS_VOLATILE (TREE_TYPE (type))));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-\tcase A_NO_CHECK_MEMORY_USAGE:\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"`%s' attribute applies only to functions\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n-\t    }\n-\t  else if (DECL_INITIAL (decl))\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"can't set `%s' attribute after definition\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n-\t    }\n-\t  else\n-\t    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n-\t  break;\n+  return NULL_TREE;\n+}\n \n-\tcase A_NO_INSTRUMENT_FUNCTION:\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"`%s' attribute applies only to functions\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n-\t    }\n-\t  else if (DECL_INITIAL (decl))\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"can't set `%s' attribute after definition\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n-\t    }\n-\t  else\n-\t    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n-\t  break;\n+/* Handle a \"transparent_union\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  if (is_type\n+      && TREE_CODE (*type) == UNION_TYPE\n+      && (decl == 0\n+\t  || (TYPE_FIELDS (*type) != 0\n+\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_TRANSPARENT_UNION (*type) = 1;\n+    }\n+  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n+\t   && TREE_CODE (*type) == UNION_TYPE\n+\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n+    DECL_TRANSPARENT_UNION (decl) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"constructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"destructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_DESTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"mode\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_mode_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  *no_add_attrs = true;\n+\n+  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n+    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+  else\n+    {\n+      int j;\n+      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n+      int len = strlen (p);\n+      enum machine_mode mode = VOIDmode;\n+      tree typefm;\n+\n+      if (len > 4 && p[0] == '_' && p[1] == '_'\n+\t  && p[len - 1] == '_' && p[len - 2] == '_')\n+\t{\n+\t  char *newp = (char *) alloca (len - 1);\n+\n+\t  strcpy (newp, &p[2]);\n+\t  newp[len - 4] = '\\0';\n+\t  p = newp;\n+\t}\n+\n+      /* Give this decl a type with the specified mode.\n+\t First check for the special modes.  */\n+      if (! strcmp (p, \"byte\"))\n+\tmode = byte_mode;\n+      else if (!strcmp (p, \"word\"))\n+\tmode = word_mode;\n+      else if (! strcmp (p, \"pointer\"))\n+\tmode = ptr_mode;\n+      else\n+\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n+\t  if (!strcmp (p, GET_MODE_NAME (j)))\n+\t    mode = (enum machine_mode) j;\n+\n+      if (mode == VOIDmode)\n+\terror (\"unknown machine mode `%s'\", p);\n+      else if (0 == (typefm = type_for_mode (mode,\n+\t\t\t\t\t     TREE_UNSIGNED (type))))\n+\terror (\"no data type for mode `%s'\", p);\n+      else\n+\t{\n+\t  if (TYPE_PRECISION (typefm) > (TREE_UNSIGNED (type)\n+\t\t\t\t\t ? TYPE_PRECISION(uintmax_type_node)\n+\t\t\t\t\t : TYPE_PRECISION(intmax_type_node))\n+\t      && pedantic)\n+\t    pedwarn (\"type with more precision than %s\",\n+\t\t     TREE_UNSIGNED (type) ? \"uintmax_t\" : \"intmax_t\");\n+\t  TREE_TYPE (decl) = type = typefm;\n+\t  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n+\t  if (TREE_CODE (decl) != FIELD_DECL)\n+\t    layout_decl (decl, 0);\n+\t}\n+    }\n \n-        case A_NO_LIMIT_STACK:\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"section\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_section_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (targetm.have_named_sections)\n+    {\n+      if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t   || TREE_CODE (decl) == VAR_DECL)\n+\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t{\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && current_function_decl != NULL_TREE\n+\t      && ! TREE_STATIC (decl))\n \t    {\n \t      error_with_decl (decl,\n-\t\t\t       \"`%s' attribute applies only to functions\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n+\t\t\t       \"section attribute cannot be specified for local variables\");\n+\t      *no_add_attrs = true;\n \t    }\n-\t  else if (DECL_INITIAL (decl))\n+\t  /* The decl may have already been given a section attribute\n+\t     from a previous declaration.  Ensure they match.  */\n+\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n+\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n \t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"can't set `%s' attribute after definition\",\n-\t\t\t       IDENTIFIER_POINTER (name));\n+\t      error_with_decl (*node,\n+\t\t\t       \"section of `%s' conflicts with previous declaration\");\n+\t      *no_add_attrs = true;\n \t    }\n \t  else\n-\t    DECL_NO_LIMIT_STACK (decl) = 1;\n-\t  break;\n+\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n+\t}\n+      else\n+\t{\n+\t  error_with_decl (*node,\n+\t\t\t   \"section attribute not allowed for `%s'\");\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      error_with_decl (*node,\n+\t\t       \"section attributes are not supported for this target\");\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"aligned\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+  tree align_expr = (args ? TREE_VALUE (args)\n+\t\t     : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+  int i;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  /* Strip any NOPs of any kind.  */\n+  while (TREE_CODE (align_expr) == NOP_EXPR\n+\t || TREE_CODE (align_expr) == CONVERT_EXPR\n+\t || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n+    align_expr = TREE_OPERAND (align_expr, 0);\n+\n+  if (TREE_CODE (align_expr) != INTEGER_CST)\n+    {\n+      error (\"requested alignment is not a constant\");\n+      *no_add_attrs = true;\n+    }\n+  else if ((i = tree_log2 (align_expr)) == -1)\n+    {\n+      error (\"requested alignment is not a power of 2\");\n+      *no_add_attrs = true;\n+    }\n+  else if (i > HOST_BITS_PER_INT - 2)\n+    {\n+      error (\"requested alignment is too large\");\n+      *no_add_attrs = true;\n+    }\n+  else if (is_type)\n+    {\n+      /* If we have a TYPE_DECL, then copy the type, so that we\n+\t don't accidentally modify a builtin type.  See pushdecl.  */\n+      if (decl && TREE_TYPE (decl) != error_mark_node\n+\t  && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n+\t{\n+\t  tree tt = TREE_TYPE (decl);\n+\t  *type = build_type_copy (*type);\n+\t  DECL_ORIGINAL_TYPE (decl) = tt;\n+\t  TYPE_NAME (*type) = decl;\n+\t  TREE_USED (*type) = TREE_USED (decl);\n+\t  TREE_TYPE (decl) = *type;\n \t}\n+      else if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+\n+      TYPE_ALIGN (*type) = (1 << i) * BITS_PER_UNIT;\n+      TYPE_USER_ALIGN (*type) = 1;\n+    }\n+  else if (TREE_CODE (decl) != VAR_DECL\n+\t   && TREE_CODE (decl) != FIELD_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"alignment may not be specified for `%s'\");\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n+      DECL_USER_ALIGN (decl) = 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"weak\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_weak_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+{\n+  declare_weak (*node);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"alias\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_alias_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n+      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' defined both normally and as an alias\");\n+      *no_add_attrs = true;\n+    }\n+  else if (decl_function_context (decl) == 0)\n+    {\n+      tree id;\n+\n+      id = TREE_VALUE (args);\n+      if (TREE_CODE (id) != STRING_CST)\n+\t{\n+\t  error (\"alias arg not a string\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+      id = get_identifier (TREE_STRING_POINTER (id));\n+      /* This counts as a use of the object pointed to.  */\n+      TREE_USED (id) = 1;\n+\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tDECL_INITIAL (decl) = error_mark_node;\n+      else\n+\tDECL_EXTERNAL (decl) = 0;\n+      assemble_alias (decl, id);\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_instrument_function\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_check_memory_usage\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_no_check_memory_usage_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n+  else\n+    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"malloc\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_MALLOC (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_limit_stack\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_LIMIT_STACK (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_pure_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_PURE (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n   return NULL_TREE;\n }\n "}, {"sha": "6ab2c06bef349f3c7e53f70e4a244671415bfe3e", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -503,29 +503,14 @@ extern const char *fname_as_string\t\tPARAMS ((int));\n extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n extern const char *fname_string\t\t\tPARAMS ((unsigned));\n \n-/* Flags that may be passed in the third argument of decl_attributes.  */\n-enum attribute_flags\n-{\n-  /* The type passed in is the type of a DECL, and any attributes that\n-     should be passed in again to be applied to the DECL rather than the\n-     type should be returned.  */\n-  ATTR_FLAG_DECL_NEXT = 1,\n-  /* The type passed in is a function return type, and any attributes that\n-     should be passed in again to be applied to the function type rather\n-     than the return type should be returned.  */\n-  ATTR_FLAG_FUNCTION_NEXT = 2,\n-  /* The type passed in is an array element type, and any attributes that\n-     should be passed in again to be applied to the array type rather\n-     than the element type should be returned.  */\n-  ATTR_FLAG_ARRAY_NEXT = 4\n-};\n-\n extern tree decl_attributes\t\t\tPARAMS ((tree *, tree, int));\n extern void init_function_format_info\t\tPARAMS ((void));\n extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));\n extern void set_Wformat\t\t\t\tPARAMS ((int));\n-extern void decl_handle_format_attribute\tPARAMS ((tree, tree));\n-extern void decl_handle_format_arg_attribute\tPARAMS ((tree, tree));\n+extern tree handle_format_attribute\t\tPARAMS ((tree *, tree, tree,\n+\t\t\t\t\t\t\t int, bool *));\n+extern tree handle_format_arg_attribute\t\tPARAMS ((tree *, tree, tree,\n+\t\t\t\t\t\t\t int, bool *));\n extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n extern tree c_sizeof\t\t\t\tPARAMS ((tree));\n extern tree c_alignof\t\t\t\tPARAMS ((tree));"}, {"sha": "4652267c667916d20a67a240d13f9ac1faa36ec5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1404,7 +1404,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   int errmsg = 0;\n \n   if (DECL_P (olddecl))\n-    DECL_MACHINE_ATTRIBUTES (newdecl)\n+    DECL_ATTRIBUTES (newdecl)\n       = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n \n   if (TREE_CODE (newtype) == ERROR_MARK\n@@ -2030,7 +2030,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \n   /* NEWDECL contains the merged attribute lists.\n      Update OLDDECL to be the same.  */\n-  DECL_MACHINE_ATTRIBUTES (olddecl) = DECL_MACHINE_ATTRIBUTES (newdecl);\n+  DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);\n \n   return 1;\n }\n@@ -3872,9 +3872,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   enum tree_code innermost_code = ERROR_MARK;\n   int bitfield = 0;\n   int size_varies = 0;\n-  tree decl_machine_attr = NULL_TREE;\n+  tree decl_attr = NULL_TREE;\n   tree array_ptr_quals = NULL_TREE;\n   int array_parm_static = 0;\n+  tree returned_attrs = NULL_TREE;\n \n   if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n@@ -3898,6 +3899,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  decl = TREE_OPERAND (decl, 0);\n \t  break;\n \n+\tcase TREE_LIST:\n+\t  decl = TREE_VALUE (decl);\n+\t  break;\n+\n \tcase IDENTIFIER_NODE:\n \t  name = IDENTIFIER_POINTER (decl);\n \t  decl = 0;\n@@ -3979,7 +3984,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       else if (TREE_CODE (id) == TYPE_DECL)\n \t{\n \t  type = TREE_TYPE (id);\n-\t  decl_machine_attr = DECL_MACHINE_ATTRIBUTES (id);\n+\t  decl_attr = DECL_ATTRIBUTES (id);\n \t  typedef_decl = id;\n \t}\n       /* Built-in types come as identifiers.  */\n@@ -4292,6 +4297,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       /* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]),\n \t an INDIRECT_REF (for *...),\n \t a CALL_EXPR (for ...(...)),\n+\t a TREE_LIST (for nested attributes),\n \t an identifier (for the name being declared)\n \t or a null pointer (for the place in an absolute declarator\n \t where the name was omitted).\n@@ -4313,7 +4319,30 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  array_parm_static = 0;\n \t}\n \n-      if (TREE_CODE (declarator) == ARRAY_REF)\n+      if (TREE_CODE (declarator) == TREE_LIST)\n+\t{\n+\t  /* We encode a declarator with embedded attributes using\n+\t     a TREE_LIST.  */\n+\t  tree attrs = TREE_PURPOSE (declarator);\n+\t  tree inner_decl;\n+\t  int attr_flags = 0;\n+\t  declarator = TREE_VALUE (declarator);\n+\t  inner_decl = declarator;\n+\t  while (inner_decl != NULL_TREE\n+\t\t && TREE_CODE (inner_decl) == TREE_LIST)\n+\t    inner_decl = TREE_VALUE (inner_decl);\n+\t  if (inner_decl == NULL_TREE\n+\t      || TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n+\t    attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n+\t  if (TREE_CODE (inner_decl) == CALL_EXPR)\n+\t    attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n+\t  if (TREE_CODE (inner_decl) == ARRAY_REF)\n+\t    attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n+\t  returned_attrs = decl_attributes (&type,\n+\t\t\t\t\t    chainon (returned_attrs, attrs),\n+\t\t\t\t\t    attr_flags);\n+\t}\n+      else if (TREE_CODE (declarator) == ARRAY_REF)\n \t{\n \t  register tree itype = NULL_TREE;\n \t  register tree size = TREE_OPERAND (declarator, 1);\n@@ -4657,6 +4686,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       if ((specbits & (1 << (int) RID_SIGNED))\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n+      decl_attributes (&decl, returned_attrs, 0);\n       return decl;\n     }\n \n@@ -4687,6 +4717,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \tpedwarn (\"ISO C forbids const or volatile function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n+      decl_attributes (&type, returned_attrs, 0);\n       return type;\n     }\n \n@@ -4711,7 +4742,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */\n \n   {\n-    register tree decl;\n+    tree decl;\n \n     if (decl_context == PARM)\n       {\n@@ -4860,7 +4891,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  pedwarn (\"invalid storage class for function `%s'\", name);\n \n \tdecl = build_decl (FUNCTION_DECL, declarator, type);\n-\tdecl = build_decl_attribute_variant (decl, decl_machine_attr);\n+\tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n \tif (pedantic && type_quals && ! DECL_IN_SYSTEM_HEADER (decl))\n \t  pedwarn (\"ISO C forbids qualified function types\");\n@@ -4953,6 +4984,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n     if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl)))\n       mark_addressable (decl);\n \n+    decl_attributes (&decl, returned_attrs, 0);\n+\n     return decl;\n   }\n }\n@@ -5341,7 +5374,7 @@ finish_struct (t, fieldlist, attributes)\n \n   TYPE_SIZE (t) = 0;\n \n-  decl_attributes (&t, attributes, 0);\n+  decl_attributes (&t, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n   /* Nameless union parm types are useful as GCC extension.  */\n   if (! (TREE_CODE (t) == UNION_TYPE && TYPE_NAME (t) == 0) && !pedantic)\n@@ -5705,7 +5738,7 @@ finish_enum (enumtype, values, attributes)\n   if (in_parm_level_p ())\n     warning (\"enum defined inside parms\");\n \n-  decl_attributes (&enumtype, attributes, 0);\n+  decl_attributes (&enumtype, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n   /* Calculate the maximum value of any enumerator in this type.  */\n "}, {"sha": "331cd252e8f6b80cef4192e91ef8c16d7bf0d501", "filename": "gcc/c-format.c", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -82,14 +82,17 @@ static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n \t\t\t\t\t\t int, int));\n static void record_international_format\tPARAMS ((tree, tree, int));\n \n-/* Handle the format attribute (with arguments ARGS) attached to the decl\n-   DECL.  It is already verified that DECL is a decl and ARGS contains\n-   exactly three arguments.  */\n-\n-void\n-decl_handle_format_attribute (decl, args)\n-     tree decl, args;\n+/* Handle a \"format\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+tree\n+handle_format_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n+  tree decl = *node;\n   tree type = TREE_TYPE (decl);\n   tree format_type_id = TREE_VALUE (args);\n   tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n@@ -104,13 +107,15 @@ decl_handle_format_attribute (decl, args)\n     {\n       error_with_decl (decl,\n \t\t       \"argument format specified for non-function `%s'\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n     {\n       error (\"unrecognized format specifier\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n   else\n     {\n@@ -121,7 +126,8 @@ decl_handle_format_attribute (decl, args)\n       if (format_type == format_type_error)\n \t{\n \t  warning (\"`%s' is an unrecognized format function type\", p);\n-\t  return;\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n \t}\n     }\n \n@@ -143,15 +149,17 @@ decl_handle_format_attribute (decl, args)\n       || TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n     {\n       error (\"format string has invalid operand number\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   format_num = TREE_INT_CST_LOW (format_num_expr);\n   first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n   if (first_arg_num != 0 && first_arg_num <= format_num)\n     {\n       error (\"format string arg follows the args to be formatted\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   /* If a parameter list is specified, verify that the format_num\n@@ -170,7 +178,8 @@ decl_handle_format_attribute (decl, args)\n \t      != char_type_node))\n \t{\n \t  error (\"format string arg not a string type\");\n-\t  return;\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n \t}\n \n       else if (first_arg_num != 0)\n@@ -183,30 +192,36 @@ decl_handle_format_attribute (decl, args)\n \t  if (arg_num != first_arg_num)\n \t    {\n \t      error (\"args to be formatted is not '...'\");\n-\t      return;\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n \t    }\n \t}\n     }\n \n   if (format_type == strftime_format_type && first_arg_num != 0)\n     {\n       error (\"strftime formats cannot format arguments\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   record_function_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n \t\t\t  format_type, format_num, first_arg_num);\n+  return NULL_TREE;\n }\n \n \n-/* Handle the format_arg attribute (with arguments ARGS) attached to\n-   the decl DECL.  It is already verified that DECL is a decl and\n-   ARGS contains exactly one argument.  */\n-\n-void\n-decl_handle_format_arg_attribute (decl, args)\n-     tree decl, args;\n+/* Handle a \"format\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+tree\n+handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n+  tree decl = *node;\n   tree type = TREE_TYPE (decl);\n   tree format_num_expr = TREE_VALUE (args);\n   unsigned HOST_WIDE_INT format_num;\n@@ -217,7 +232,8 @@ decl_handle_format_arg_attribute (decl, args)\n     {\n       error_with_decl (decl,\n \t\t       \"argument format specified for non-function `%s'\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   /* Strip any conversions from the first arg number and verify it\n@@ -231,7 +247,8 @@ decl_handle_format_arg_attribute (decl, args)\n       || TREE_INT_CST_HIGH (format_num_expr) != 0)\n     {\n       error (\"format string has invalid operand number\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   format_num = TREE_INT_CST_LOW (format_num_expr);\n@@ -252,7 +269,8 @@ decl_handle_format_arg_attribute (decl, args)\n \t      != char_type_node))\n \t{\n \t  error (\"format string arg not a string type\");\n-\t  return;\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n \t}\n     }\n \n@@ -261,11 +279,13 @@ decl_handle_format_arg_attribute (decl, args)\n \t  != char_type_node))\n     {\n       error (\"function does not return string type\");\n-      return;\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n \n   record_international_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n \t\t\t       format_num);\n+  return NULL_TREE;\n }\n \n typedef struct function_format_info"}, {"sha": "85c2815409d472a2c559fb0c2dde17b4f8fd2c0e", "filename": "gcc/c-parse.in", "status": "modified", "additions": 34, "deletions": 53, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -173,7 +173,7 @@ end ifc\n %type <ttype> declspecs_ts declspecs_nots\n %type <ttype> declspecs_ts_nosa declspecs_nots_nosa\n %type <ttype> declspecs_nosc_ts declspecs_nosc_nots declspecs_nosc declspecs\n-%type <ttype> maybe_type_quals_setattrs typespec_nonattr typespec_attr\n+%type <ttype> maybe_type_quals_attrs typespec_nonattr typespec_attr\n %type <ttype> typespec_reserved_nonattr typespec_reserved_attr\n %type <ttype> typespec_nonreserved_nonattr\n \n@@ -182,7 +182,6 @@ end ifc\n %type <ttype> init maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n-%type <ttype> maybe_setattrs\n %type <ttype> any_word extension\n \n %type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n@@ -847,29 +846,11 @@ setspecs: /* empty */\n \t\t  all_prefix_attributes = prefix_attributes; }\n \t;\n \n-/* ??? Yuck.  See maybe_setattrs.  */\n-setattrs: /* empty */\n-\t\t{ all_prefix_attributes = chainon ($<ttype>0, all_prefix_attributes); }\n-\t;\n-\n-maybe_setattrs:\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').\n-\t   Properly attributes ought to be able to apply to any level of\n-\t   nested declarator, but the necessary compiler support isn't\n-\t   present, so the attributes apply to a declaration (which may be\n-\t   nested).  */\n-\t  maybe_attribute setattrs\n-\t;\n-\n /* Possibly attributes after a comma, which should reset all_prefix_attributes\n    to prefix_attributes with these ones chained on the front.  */\n maybe_resetattrs:\n-\t\t{ all_prefix_attributes = prefix_attributes; }\n-\t  maybe_setattrs\n+\t  maybe_attribute\n+\t\t{ all_prefix_attributes = chainon ($1, prefix_attributes); }\n \t;\n \n decl:\n@@ -1347,18 +1328,12 @@ declspecs:\n \t| declspecs_sc_ts_sa_ea\n \t;\n \n-/* A (possibly empty) sequence of type qualifiers and attributes, to be\n-   followed by the effect of setattrs if any attributes were present.  */\n-maybe_type_quals_setattrs:\n+/* A (possibly empty) sequence of type qualifiers and attributes.  */\n+maybe_type_quals_attrs:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| declspecs_nosc_nots\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  /* ??? Yuck.  See maybe_setattrs.  */\n-\t\t  if (attrs != NULL_TREE)\n-\t\t    all_prefix_attributes = chainon (attrs, all_prefix_attributes);\n-\t\t  $$ = specs; }\n+\t\t{ $$ = $1; }\n \t;\n \n /* A type specifier (but not a type qualifier).\n@@ -1669,16 +1644,16 @@ declarator:\n /* A declarator that is allowed only after an explicit typespec.  */\n \n after_type_declarator:\n-\t  '(' maybe_setattrs after_type_declarator ')'\n-\t\t{ $$ = $3; }\n+\t  '(' maybe_attribute after_type_declarator ')'\n+\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n \t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n /*\t| after_type_declarator '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n \t| after_type_declarator array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n-\t| '*' maybe_type_quals_setattrs after_type_declarator  %prec UNARY\n+\t| '*' maybe_type_quals_attrs after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| TYPENAME\n ifobjc\n@@ -1717,12 +1692,12 @@ parm_declarator_nostarttypename:\n \t\t  poplevel (0, 0, 0); }  */\n \t| parm_declarator_nostarttypename array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n-\t| '*' maybe_type_quals_setattrs parm_declarator_starttypename  %prec UNARY\n+\t| '*' maybe_type_quals_attrs parm_declarator_starttypename  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' maybe_type_quals_setattrs parm_declarator_nostarttypename  %prec UNARY\n+\t| '*' maybe_type_quals_attrs parm_declarator_nostarttypename  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '(' maybe_setattrs parm_declarator_nostarttypename ')'\n-\t\t{ $$ = $3; }\n+\t| '(' maybe_attribute parm_declarator_nostarttypename ')'\n+\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n \t;\n \n /* A declarator allowed whether or not there has been\n@@ -1734,9 +1709,9 @@ notype_declarator:\n /*\t| notype_declarator '(' error ')'  %prec '.'\n \t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n \t\t  poplevel (0, 0, 0); }  */\n-\t| '(' maybe_setattrs notype_declarator ')'\n-\t\t{ $$ = $3; }\n-\t| '*' maybe_type_quals_setattrs notype_declarator  %prec UNARY\n+\t| '(' maybe_attribute notype_declarator ')'\n+\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n+\t| '*' maybe_type_quals_attrs notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| notype_declarator array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n@@ -1991,20 +1966,20 @@ absdcl1:  /* a nonempty absolute declarator */\n \n absdcl1_noea:\n \t  direct_absdcl1\n-\t| '*' maybe_type_quals_setattrs absdcl1_noea\n+\t| '*' maybe_type_quals_attrs absdcl1_noea\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t;\n \n absdcl1_ea:\n-\t  '*' maybe_type_quals_setattrs\n+\t  '*' maybe_type_quals_attrs\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| '*' maybe_type_quals_setattrs absdcl1_ea\n+\t| '*' maybe_type_quals_attrs absdcl1_ea\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t;\n \n direct_absdcl1:\n-\t  '(' maybe_setattrs absdcl1 ')'\n-\t\t{ $$ = $3; }\n+\t  '(' maybe_attribute absdcl1 ')'\n+\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n \t| direct_absdcl1 '(' parmlist\n \t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n \t| direct_absdcl1 array_declarator\n@@ -3904,15 +3879,21 @@ yyprint (file, yychar, yyl)\n \n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n-   TYPE_QUALS is a list of modifiers such as const or volatile\n-   to apply to the pointer type, represented as identifiers.\n+   TYPE_QUALS_ATTRS is a list of modifiers such as const or volatile\n+   to apply to the pointer type, represented as identifiers, possible mixed\n+   with attributes.\n \n-   We return an INDIRECT_REF whose \"contents\" are TARGET\n-   and whose type is the modifier list.  */\n+   We return an INDIRECT_REF whose \"contents\" are TARGET (inside a TREE_LIST,\n+   if attributes are present) and whose type is the modifier list.  */\n \n tree\n-make_pointer_declarator (type_quals, target)\n-     tree type_quals, target;\n+make_pointer_declarator (type_quals_attrs, target)\n+     tree type_quals_attrs, target;\n {\n-  return build1 (INDIRECT_REF, type_quals, target);\n+  tree quals, attrs;\n+  tree itarget = target;\n+  split_specs_attrs (type_quals_attrs, &quals, &attrs);\n+  if (attrs != NULL_TREE)\n+    itarget = tree_cons (attrs, target, NULL_TREE);\n+  return build1 (INDIRECT_REF, quals, itarget);\n }"}, {"sha": "4439368242ff26146e7314dc066fee6dfd47b13b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -181,13 +181,13 @@ static int unicosmk_need_dex PARAMS ((rtx));\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_ABI_OPEN_VMS\n-static int vms_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n+const struct attribute_spec vms_attribute_table[];\n static unsigned int vms_section_type_flags PARAMS ((tree, const char *, int));\n static void vms_asm_named_section PARAMS ((const char *, unsigned int));\n static void vms_asm_out_constructor PARAMS ((rtx, int));\n static void vms_asm_out_destructor PARAMS ((rtx, int));\n-# undef TARGET_VALID_DECL_ATTRIBUTE\n-# define TARGET_VALID_DECL_ATTRIBUTE vms_valid_decl_attribute_p\n+# undef TARGET_ATTRIBUTE_TABLE\n+# define TARGET_ATTRIBUTE_TABLE vms_attribute_table\n # undef TARGET_SECTION_TYPE_FLAGS\n # define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags\n #endif\n@@ -5732,17 +5732,12 @@ alpha_using_fp ()\n \n #if TARGET_ABI_OPEN_VMS\n \n-static int\n-vms_valid_decl_attribute_p (decl, attributes, identifier, args)\n-     tree decl ATTRIBUTE_UNUSED;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+const struct attribute_spec vms_attribute_table[] =\n {\n-  if (is_attribute_p (\"overlaid\", identifier))\n-    return (args == NULL_TREE);\n-  return 0;\n-}\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"overlaid\", 0, 0, true,  false, false, NULL },\n+  { NULL,       0, 0, false, false, false, NULL }\n+};\n \n #endif\n \n@@ -7895,8 +7890,8 @@ vms_section_type_flags (decl, name, reloc)\n {\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n-  if (decl && DECL_MACHINE_ATTRIBUTES (decl)\n-      && lookup_attribute (\"overlaid\", DECL_MACHINE_ATTRIBUTES (decl)))\n+  if (decl && DECL_ATTRIBUTES (decl)\n+      && lookup_attribute (\"overlaid\", DECL_ATTRIBUTES (decl)))\n     flags |= SECTION_VMS_OVERLAY;\n \n   return flags;"}, {"sha": "6875a6f502ce6cc2845019a3af8cbc225a6e15e9", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -87,7 +87,8 @@ static int current_insn_set_cc_p;\n static void record_cc_ref PARAMS ((rtx));\n static void arc_init_reg_tables PARAMS ((void));\n static int get_arc_condition_code PARAMS ((rtx));\n-static int arc_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+const struct attribute_spec arc_attribute_table[];\n+static tree arc_handle_interrupt_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void arc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void arc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n@@ -96,8 +97,8 @@ static void arc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n #define TARGET_ASM_FUNCTION_PROLOGUE arc_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE arc_output_function_epilogue\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE arc_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE arc_attribute_table\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -326,26 +327,40 @@ arc_init_reg_tables ()\n    interrupt - for interrupt functions\n */\n \n-/* Return nonzero if IDENTIFIER is a valid decl attribute.  */\n+const struct attribute_spec arc_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 1, 1, true,  false, false, arc_handle_interrupt_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \n-static int\n-arc_valid_decl_attribute (type, attributes, identifier, args)\n-     tree type ATTRIBUTE_UNUSED;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n+/* Handle an \"interrupt\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+arc_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node ATTRIBUTE_UNUSED;\n+     tree name;\n      tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n-  if (identifier == get_identifier (\"__interrupt__\")\n-      && list_length (args) == 1\n-      && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-    {\n-      tree value = TREE_VALUE (args);\n+  tree value = TREE_VALUE (args);\n \n-      if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n-\t   || !strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n-\treturn 1;\n+  if (TREE_CODE (value) != STRING_CST)\n+    {\n+      warning (\"argument of `%s' attribute is not a string constant\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n-  return 0;\n+  else if (strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n+    {\n+      warning (\"argument of `%s' attribute is not \\\"ilink1\\\" or \\\"ilink2\\\"\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n }\n \n \f\n@@ -956,7 +971,7 @@ arc_compute_function_type (decl)\n   fn_type = ARC_FUNCTION_NORMAL;\n \n   /* Now see if this is an interrupt handler.  */\n-  for (a = DECL_MACHINE_ATTRIBUTES (current_function_decl);\n+  for (a = DECL_ATTRIBUTES (current_function_decl);\n        a;\n        a = TREE_CHAIN (a))\n     {"}, {"sha": "fcd90ddf4bdb4ba6ca65dd5d2a10d857d7e8bd55", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 113, "deletions": 120, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -103,10 +103,9 @@ static int       current_file_function_operand\tPARAMS ((rtx));\n static Ulong     arm_compute_save_reg_mask\tPARAMS ((void));\n static Ulong     arm_isr_value \t\t\tPARAMS ((tree));\n static Ulong     arm_compute_func_type\t\tPARAMS ((void));\n-static int\t arm_valid_type_attribute_p\tPARAMS ((tree, tree,\n-\t\t\t\t\t\t\t tree, tree));\n-static int\t arm_valid_decl_attribute_p\tPARAMS ((tree, tree,\n-\t\t\t\t\t\t\t tree, tree));\n+static tree      arm_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree      arm_handle_isr_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec arm_attribute_table[];\n static void\t arm_output_function_epilogue\tPARAMS ((FILE *,\n \t\t\t\t\t\t\t HOST_WIDE_INT));\n static void\t arm_output_function_prologue\tPARAMS ((FILE *,\n@@ -130,16 +129,8 @@ static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE arm_valid_type_attribute_p\n-\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#ifdef ARM_PE\n-   static int arm_pe_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n-#  define TARGET_VALID_DECL_ATTRIBUTE arm_pe_valid_decl_attribute_p\n-#else\n-#  define TARGET_VALID_DECL_ATTRIBUTE arm_valid_decl_attribute_p\n-#endif\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE arm_attribute_table\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE arm_output_function_prologue\n@@ -845,7 +836,7 @@ arm_compute_func_type ()\n   if (current_function_needs_context)\n     type |= ARM_FT_NESTED;\n \n-  attr = DECL_MACHINE_ATTRIBUTES (current_function_decl);\n+  attr = DECL_ATTRIBUTES (current_function_decl);\n   \n   a = lookup_attribute (\"naked\", attr);\n   if (a != NULL_TREE)\n@@ -1909,39 +1900,120 @@ arm_pr_long_calls_off (pfile)\n }\n \n \f\n-/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine\n-   specific attribute for TYPE.  The attributes in ATTRIBUTES have\n-   previously been assigned to TYPE.  */\n-static int\n-arm_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+/* Table of machine attributes.  */\n+const struct attribute_spec arm_attribute_table[] =\n {\n-  if (   TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE\n-      && TREE_CODE (type) != FIELD_DECL\n-      && TREE_CODE (type) != TYPE_DECL)\n-    return 0;\n-\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   /* Function calls made to this symbol must be done indirectly, because\n      it may lie outside of the 26 bit addressing range of a normal function\n      call.  */\n-  if (is_attribute_p (\"long_call\", identifier))\n-    return (args == NULL_TREE);\n-  \n+  { \"long_call\",    0, 0, false, true,  true,  NULL },\n   /* Whereas these functions are always known to reside within the 26 bit\n      addressing range.  */\n-  if (is_attribute_p (\"short_call\", identifier))\n-    return (args == NULL_TREE);\n-  \n+  { \"short_call\",   0, 0, false, true,  true,  NULL },\n   /* Interrupt Service Routines have special prologue and epilogue requirements.  */ \n-  if (is_attribute_p (\"isr\", identifier)\n-      || is_attribute_p (\"interrupt\", identifier))\n-    return arm_isr_value (args);\n+  { \"isr\",          0, 1, false, false, false, arm_handle_isr_attribute },\n+  { \"interrupt\",    0, 1, false, false, false, arm_handle_isr_attribute },\n+  { \"naked\",        0, 0, true,  false, false, arm_handle_fndecl_attribute },\n+#ifdef ARM_PE\n+  /* ARM/PE has three new attributes:\n+     interfacearm - ?\n+     dllexport - for exporting a function/variable that will live in a dll\n+     dllimport - for importing a function/variable from a dll\n+\n+     Microsoft allows multiple declspecs in one __declspec, separating\n+     them with spaces.  We do NOT support this.  Instead, use __declspec\n+     multiple times.\n+  */\n+  { \"dllimport\",    0, 0, true,  false, false, NULL },\n+  { \"dllexport\",    0, 0, true,  false, false, NULL },\n+  { \"interfacearm\", 0, 0, true,  false, false, arm_handle_fndecl_attribute },\n+#endif\n+  { NULL,           0, 0, false, false, false, NULL }\n+};\n \n-  return 0;\n+/* Handle an attribute requiring a FUNCTION_DECL;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+arm_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"interrupt\" or \"isr\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node))\n+    {\n+      if (TREE_CODE (*node) != FUNCTION_DECL)\n+\t{\n+\t  warning (\"`%s' attribute only applies to functions\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n+      /* FIXME: the argument if any is checked for type attributes;\n+\t should it be checked for decl ones?  */\n+    }\n+  else\n+    {\n+      if (TREE_CODE (*node) == FUNCTION_TYPE\n+\t  || TREE_CODE (*node) == METHOD_TYPE)\n+\t{\n+\t  if (arm_isr_value (args) == ARM_FT_UNKNOWN)\n+\t    {\n+\t      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t      *no_add_attrs = true;\n+\t    }\n+\t}\n+      else if (TREE_CODE (*node) == POINTER_TYPE\n+\t       && (TREE_CODE (TREE_TYPE (*node)) == FUNCTION_TYPE\n+\t\t   || TREE_CODE (TREE_TYPE (*node)) == METHOD_TYPE)\n+\t       && arm_isr_value (args) != ARM_FT_UNKNOWN)\n+\t{\n+\t  *node = build_type_copy (*node);\n+\t  TREE_TYPE (*node) = build_type_attribute_variant (TREE_TYPE (*node),\n+\t\t\t\t\t\t\t    tree_cons (name,\n+\t\t\t\t\t\t\t\t       args,\n+\t\t\t\t\t\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (*node))));\n+\t  *no_add_attrs = true;\n+\t}\n+      else\n+\t{\n+\t  /* Possibly pass this attribute on from the type to a decl.  */\n+\t  if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t       | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t       | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t    {\n+\t      *no_add_attrs = true;\n+\t      return tree_cons (name, args, NULL_TREE);\n+\t    }\n+\t  else\n+\t    {\n+\t      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t    }\n+\t}\n+    }\n+\n+  return NULL_TREE;\n }\n \n /* Return 0 if the attributes for two types are incompatible, 1 if they\n@@ -4132,85 +4204,6 @@ multi_register_push (op, mode)\n   return 1;\n }\n \f\n-/* Routines for use with attributes.  */\n-\n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are\n-   the arguments supplied with ATTR.\n-\n-   Supported attributes:\n-\n-   naked:\n-     don't output any prologue or epilogue code, the user is assumed\n-     to do the right thing.\n-   \n-   isr or interrupt:\n-     Interrupt Service Routine.\n-\n-   interfacearm:\n-     Always assume that this function will be entered in ARM mode,\n-     not Thumb mode, and that the caller wishes to be returned to in\n-     ARM mode.  */\n-static int\n-arm_valid_decl_attribute_p (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args;\n-{\n-  /* The interrupt attribute can take args, so check for it before\n-     rejecting other attributes on the grounds that they did have args.  */\n-  if (is_attribute_p (\"isr\", attr)\n-      || is_attribute_p (\"interrupt\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n-\n-  if (args != NULL_TREE)\n-    return 0;\n-\n-  if (is_attribute_p (\"naked\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n-\n-#ifdef ARM_PE\n-  if (is_attribute_p (\"interfacearm\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n-#endif /* ARM_PE */\n-  \n-  return 0;\n-}\n-\n-#ifdef ARM_PE\n-\n-/* ARM/PE has three new attributes:\n-   naked - for interrupt functions\n-   dllexport - for exporting a function/variable that will live in a dll\n-   dllimport - for importing a function/variable from a dll\n-\n-   Microsoft allows multiple declspecs in one __declspec, separating\n-   them with spaces.  We do NOT support this.  Instead, use __declspec\n-   multiple times.\n-*/\n-\n-static int\n-arm_pe_valid_decl_attribute_p (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes;\n-     tree attr;\n-     tree args;\n-{\n-  if (args != NULL_TREE)\n-    return 0;\n-\n-  if (is_attribute_p (\"dllexport\", attr))\n-    return 1;\n-  \n-  if (is_attribute_p (\"dllimport\", attr))\n-    return 1;\n-\n-  return arm_valid_decl_attribute_p (decl, attributes, attr, args);\n-}\n-\n-#endif /* ARM_PE  */\n-\f\n /* Routines for use in generating RTL.  */\n rtx\n arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n@@ -9742,7 +9735,7 @@ is_called_in_ARM_mode (func)\n     return TRUE;\n \n #ifdef ARM_PE \n-  return lookup_attribute (\"interfacearm\", DECL_MACHINE_ATTRIBUTES (func)) != NULL_TREE;\n+  return lookup_attribute (\"interfacearm\", DECL_ATTRIBUTES (func)) != NULL_TREE;\n #else\n   return FALSE;\n #endif"}, {"sha": "9e7e95a5765a2ab18090b2479978ade362536b25", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,5 +1,5 @@\n /* Routines for GCC for ARM/pe.\n-   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Doug Evans (dje@cygnus.com).\n \n This file is part of GNU CC.\n@@ -45,7 +45,7 @@ arm_dllexport_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n-  exp = lookup_attribute (\"dllexport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n   if (exp)\n     return 1;\n \n@@ -67,7 +67,7 @@ arm_dllimport_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n-  imp = lookup_attribute (\"dllimport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n   if (imp)\n     return 1;\n "}, {"sha": "ed54cbb355396ca5c11b7d24acd85eba0b5a1dbb", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -58,8 +58,9 @@ static int    compare_sign_p       PARAMS ((rtx insn));\n static int    reg_was_0            PARAMS ((rtx insn, rtx op));\n static int    io_address_p         PARAMS ((rtx x, int size));\n void          debug_hard_reg_set   PARAMS ((HARD_REG_SET set));\n-static int    avr_valid_type_attribute PARAMS ((tree, tree, tree, tree));\n-static int    avr_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+static tree   avr_handle_progmem_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree   avr_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec avr_attribute_table[];\n static void   avr_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void   avr_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n@@ -177,11 +178,8 @@ int avr_case_values_threshold = 30000;\n #define TARGET_ASM_FUNCTION_PROLOGUE avr_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE avr_output_function_epilogue\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE avr_valid_decl_attribute\n-\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE avr_valid_type_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE avr_attribute_table\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -310,7 +308,7 @@ avr_naked_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     abort ();\n   \n-  a = lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"naked\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -326,7 +324,7 @@ interrupt_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"interrupt\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -342,7 +340,7 @@ signal_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"signal\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"signal\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -4665,54 +4663,76 @@ class_likely_spilled_p (c)\n   return (c != ALL_REGS && c != ADDW_REGS);\n }\n \n-/* Only `progmem' attribute valid for type.  */\n-\n-static int\n-avr_valid_type_attribute (type, attributes, identifier, args)\n-     tree type ATTRIBUTE_UNUSED;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args ATTRIBUTE_UNUSED;\n-{\n-  return is_attribute_p (\"progmem\", identifier);\n-}\n-\n-/* If IDENTIFIER with arguments ARGS is a valid machine specific\n-   attribute for DECL return 1.\n-   Valid attributes:\n+/* Valid attributes:\n    progmem - put data to program memory;\n    signal - make a function to be hardware interrupt. After function\n    prologue interrupts are disabled;\n    interrupt - make a function to be hardware interrupt. After function\n    prologue interrupts are enabled;\n-   naked     - don't generate function prologue/epilogue and `ret' command.  */\n+   naked     - don't generate function prologue/epilogue and `ret' command.\n \n-static int\n-avr_valid_decl_attribute (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args ATTRIBUTE_UNUSED;\n+   Only `progmem' attribute valid for type.  */\n+\n+const struct attribute_spec avr_attribute_table[] =\n {\n-  if (is_attribute_p (\"interrupt\", attr)\n-      || is_attribute_p (\"signal\", attr)\n-      || is_attribute_p (\"naked\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute },\n+  { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n+  { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n+  { \"naked\",     0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \n-  if (is_attribute_p (\"progmem\", attr)\n-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+/* Handle a \"progmem\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+avr_handle_progmem_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node))\n     {\n-      if (DECL_INITIAL (decl) == NULL_TREE && !DECL_EXTERNAL (decl))\n+      if (TREE_STATIC (*node) || DECL_EXTERNAL (*node))\n \t{\n-\t  warning (\"Only initialized variables can be placed into \"\n-\t\t   \"program memory area.\");\n-\t  return 0;\n+\t  if (DECL_INITIAL (*node) == NULL_TREE && !DECL_EXTERNAL (*node))\n+\t    {\n+\t      warning (\"Only initialized variables can be placed into \"\n+\t\t       \"program memory area.\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n \t}\n-      return 1;\n     }\n-  return 0;\n+\n+  return NULL_TREE;\n }\n \n+/* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+avr_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n \n /* Look for attribute `progmem' in DECL\n    if found return 1, otherwise 0.  */\n@@ -4727,7 +4747,7 @@ avr_progmem_p (decl)\n     return 0;\n \n   if (NULL_TREE\n-      != lookup_attribute (\"progmem\", DECL_MACHINE_ATTRIBUTES (decl)))\n+      != lookup_attribute (\"progmem\", DECL_ATTRIBUTES (decl)))\n     return 1;\n \n   a=decl;"}, {"sha": "9ded05e361e2bd2f49aa8d4fa87fc82d28062156", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1110,7 +1110,7 @@ enum reg_class {\n    FUNDECL is a C variable whose value is a tree node that describes\n    the function in question.  Normally it is a node of type\n    `FUNCTION_DECL' that describes the declaration of the function.\n-   From this you can obtain the DECL_MACHINE_ATTRIBUTES of the\n+   From this you can obtain the DECL_ATTRIBUTES of the\n    function.\n \n    FUNTYPE is a C variable whose value is a tree node that describes"}, {"sha": "7ed86b2ba58ae817b3569c3f1b9db3325e725c74", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -191,14 +191,15 @@ static int c4x_parse_pragma PARAMS ((const char *, tree *, tree *));\n static int c4x_r11_set_p PARAMS ((rtx));\n static int c4x_rptb_valid_p PARAMS ((rtx, rtx));\n static int c4x_label_ref_used_p PARAMS ((rtx, rtx));\n-static int c4x_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+static tree c4x_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec c4x_attribute_table[];\n static void c4x_insert_attributes PARAMS ((tree, tree *));\n static void c4x_asm_named_section PARAMS ((const char *, unsigned int));\n static int c4x_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE c4x_valid_type_attribute_p\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE c4x_attribute_table\n \n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES c4x_insert_attributes\n@@ -4761,31 +4762,36 @@ c4x_insert_attributes (decl, attributes)\n     }\n }\n \n+/* Table of valid machine attributes.  */\n+const struct attribute_spec c4x_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\",    0, 0, false, true,  true,  c4x_handle_fntype_attribute },\n+  /* FIXME: code elsewhere in this file treats \"naked\" as a synonym of\n+     \"interrupt\"; should it be accepted here?  */\n+  { \"assembler\",    0, 0, false, true,  true,  c4x_handle_fntype_attribute },\n+  { \"leaf_pretend\", 0, 0, false, true,  true,  c4x_handle_fntype_attribute },\n+  { NULL,           0, 0, false, false, false, NULL }\n+};\n \n-/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine\n-   specific attribute for TYPE.  The attributes in ATTRIBUTES have\n-   previously been assigned to TYPE.  */\n-\n-static int\n-c4x_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n+/* Handle an attribute requiring a FUNCTION_TYPE;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+c4x_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n      tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE)\n-    return 0;\n-  \n-  if (is_attribute_p (\"interrupt\", identifier))\n-    return 1;\n-  \n-  if (is_attribute_p (\"assembler\", identifier))\n-    return 1;\n-  \n-  if (is_attribute_p (\"leaf_pretend\", identifier))\n-    return 1;\n-  \n-  return 0;\n+  if (TREE_CODE (*node) != FUNCTION_TYPE)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n }\n \n "}, {"sha": "1ab9dc703fa4020154e638ffb893db221d1187bb", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -2272,7 +2272,7 @@ typedef struct d30v_stack {\n    FUNDECL is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_DECL' that\n    describes the declaration of the function.  From this it is possible to\n-   obtain the DECL_MACHINE_ATTRIBUTES of the function.\n+   obtain the DECL_ATTRIBUTES of the function.\n \n    FUNTYPE is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_TYPE' that"}, {"sha": "e94902cb5ae51c16a4ec0f737c6632d8ee08908f", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,7 +1,7 @@\n /*{{{  Comment.  */ \n \n /* Definitions of FR30 target. \n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n This file is part of GNU CC.\n@@ -824,7 +824,7 @@ enum reg_class\n    FUNDECL is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_DECL' that\n    describes the declaration of the function.  From this it is possible to\n-   obtain the DECL_MACHINE_ATTRIBUTES of the function.\n+   obtain the DECL_ATTRIBUTES of the function.\n \n    FUNTYPE is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_TYPE' that"}, {"sha": "34686a6440e95beeced124474567c075857e5104", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 89, "deletions": 38, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -53,7 +53,10 @@ static unsigned int compute_saved_regs PARAMS ((void));\n static void push PARAMS ((FILE *, int));\n static void pop PARAMS ((FILE *, int));\n static const char *cond_string PARAMS ((enum rtx_code));\n-static int h8300_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+const struct attribute_spec h8300_attribute_table[];\n+static tree h8300_handle_fndecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree h8300_handle_eightbit_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree h8300_handle_tiny_data_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void h8300_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void h8300_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void h8300_asm_named_section PARAMS ((const char *, unsigned int));\n@@ -98,8 +101,8 @@ static const char *const h8_mov_ops[2] = { \"mov.w\", \"mov.l\" };\n const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE h8300_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE h8300_attribute_table\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE h8300_output_function_prologue\n@@ -3102,7 +3105,7 @@ h8300_interrupt_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"interrupt_handler\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"interrupt_handler\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -3118,7 +3121,7 @@ h8300_os_task_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"OS_Task\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"OS_Task\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -3134,7 +3137,7 @@ h8300_monitor_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"monitor\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"monitor\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -3150,7 +3153,7 @@ h8300_funcvec_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"function_vector\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"function_vector\", DECL_ATTRIBUTES (func));\n   return a != NULL_TREE;\n }\n \n@@ -3166,7 +3169,7 @@ h8300_eightbit_data_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"eightbit_data\", DECL_MACHINE_ATTRIBUTES (decl));\n+  a = lookup_attribute (\"eightbit_data\", DECL_ATTRIBUTES (decl));\n   return a != NULL_TREE;\n }\n \n@@ -3182,15 +3185,11 @@ h8300_tiny_data_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"tiny_data\", DECL_MACHINE_ATTRIBUTES (decl));\n+  a = lookup_attribute (\"tiny_data\", DECL_ATTRIBUTES (decl));\n   return a != NULL_TREE;\n }\n \n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.\n-\n-   Supported attributes:\n+/* Supported attributes:\n \n    interrupt_handler: output a prologue and epilogue suitable for an\n    interrupt handler.\n@@ -3204,47 +3203,99 @@ h8300_tiny_data_p (decl)\n    tiny_data: This variable lives in the tiny data area and can be\n    referenced with 16-bit absolute memory references.  */\n \n-static int\n-h8300_valid_decl_attribute (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args;\n+const struct attribute_spec h8300_attribute_table[] =\n {\n-  if (args != NULL_TREE)\n-    return 0;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, h8300_handle_fndecl_attribute },\n+  { \"OS_Task\",           0, 0, true,  false, false, h8300_handle_fndecl_attribute },\n+  { \"monitor\",           0, 0, true,  false, false, h8300_handle_fndecl_attribute },\n+  { \"function_vector\",   0, 0, true,  false, false, h8300_handle_fndecl_attribute },\n+  { \"eightbit_data\",     0, 0, true,  false, false, h8300_handle_eightbit_data_attribute },\n+  { \"tiny_data\",         0, 0, true,  false, false, h8300_handle_tiny_data_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n \n-  if (is_attribute_p (\"interrupt_handler\", attr)\n-      || is_attribute_p (\"OS_Task\", attr)\n-      || is_attribute_p (\"monitor\", attr)\n-      || is_attribute_p (\"function_vector\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n \n-  if (is_attribute_p (\"eightbit_data\", attr)\n-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+/* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+h8300_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"eightbit_data\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+h8300_handle_eightbit_data_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n     {\n       if (DECL_INITIAL (decl) == NULL_TREE)\n \t{\n \t  warning (\"Only initialized variables can be placed into the 8-bit area.\");\n-\t  return 0;\n+\t  *no_add_attrs = true;\n \t}\n-      DECL_SECTION_NAME (decl) = build_string (7, \".eight\");\n-      return 1;\n+      else\n+\tDECL_SECTION_NAME (decl) = build_string (7, \".eight\");\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  if (is_attribute_p (\"tiny_data\", attr)\n-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"tiny_data\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+h8300_handle_tiny_data_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n     {\n       if (DECL_INITIAL (decl) == NULL_TREE)\n \t{\n \t  warning (\"Only initialized variables can be placed into the 8-bit area.\");\n-\t  return 0;\n+\t  *no_add_attrs = true;\n \t}\n-      DECL_SECTION_NAME (decl) = build_string (6, \".tiny\");\n-      return 1;\n+      else\n+\tDECL_SECTION_NAME (decl) = build_string (6, \".tiny\");\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n void"}, {"sha": "138d96fc7406df76dcb8b54e4fa8a97b00320b6d", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -191,7 +191,7 @@ union tree_node;\n    It's also used to handle dllimport override semantics.  */\n #if 0\n #define REDO_SECTION_INFO_P(DECL) \\\n-  ((DECL_MACHINE_ATTRIBUTES (DECL) != NULL_TREE) \\\n+  ((DECL_ATTRIBUTES (DECL) != NULL_TREE) \\\n    || (TREE_CODE (DECL) == VAR_DECL && DECL_VIRTUAL_P (DECL)))\n #else\n #define REDO_SECTION_INFO_P(DECL) 1"}, {"sha": "a81a29b02d88be640bb138895dbaa3f9b845196a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -173,9 +173,9 @@ extern int ix86_return_pops_args PARAMS ((tree, tree, int));\n extern int ix86_data_alignment PARAMS ((tree, int));\n extern int ix86_local_alignment PARAMS ((tree, int));\n extern int ix86_constant_alignment PARAMS ((tree, int));\n-extern int ix86_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n-extern int i386_pe_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n-extern int i386_pe_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+extern tree ix86_handle_dll_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+extern tree ix86_handle_shared_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+\n extern unsigned int i386_pe_section_type_flags PARAMS ((tree, const char *,\n \t\t\t\t\t\t\tint));\n extern void i386_pe_asm_named_section PARAMS ((const char *, unsigned int));"}, {"sha": "028c1ac8a176a01e5a8afc6d8495ceebf53cfbfb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 81, "deletions": 44, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -657,6 +657,9 @@ static int ix86_fp_comparison_cost PARAMS ((enum rtx_code code));\n static int ix86_save_reg PARAMS ((int, int));\n static void ix86_compute_frame_layout PARAMS ((struct ix86_frame *));\n static int ix86_comp_type_attributes PARAMS ((tree, tree));\n+const struct attribute_spec ix86_attribute_table[];\n+static tree ix86_handle_cdecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree ix86_handle_regparm_attribute PARAMS ((tree *, tree, tree, int, bool *));\n \n #ifdef DO_GLOBAL_CTORS_BODY\n static void ix86_svr3_asm_out_constructor PARAMS ((rtx, int));\n@@ -667,15 +670,11 @@ static void sco_asm_out_constructor PARAMS ((rtx, int));\n #endif\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-#  define TARGET_VALID_TYPE_ATTRIBUTE i386_pe_valid_type_attribute_p\n-#  undef TARGET_VALID_DECL_ATTRIBUTE\n-#  define TARGET_VALID_DECL_ATTRIBUTE i386_pe_valid_decl_attribute_p\n #  undef TARGET_MERGE_DECL_ATTRIBUTES\n #  define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n-#else\n-#  define TARGET_VALID_TYPE_ATTRIBUTE ix86_valid_type_attribute_p\n #endif\n \n #undef TARGET_COMP_TYPE_ATTRIBUTES\n@@ -977,56 +976,94 @@ optimization_options (level, size)\n #endif\n }\n \f\n-/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n-   attribute for TYPE.  The attributes in ATTRIBUTES have previously been\n-   assigned to TYPE.  */\n-\n-int\n-ix86_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+/* Table of valid machine attributes.  */\n+const struct attribute_spec ix86_attribute_table[] =\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE\n-      && TREE_CODE (type) != FIELD_DECL\n-      && TREE_CODE (type) != TYPE_DECL)\n-    return 0;\n-\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   /* Stdcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n-  if (is_attribute_p (\"stdcall\", identifier)\n-      && !TARGET_64BIT)\n-    return (args == NULL_TREE);\n-\n-  /* Cdecl attribute says the callee is a normal C declaration.  */\n-  if (is_attribute_p (\"cdecl\", identifier)\n-      && !TARGET_64BIT)\n-    return (args == NULL_TREE);\n-\n+  { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cdecl_attribute },\n+  /* Cdecl attribute says the callee is a normal C declaration */\n+  { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cdecl_attribute },\n   /* Regparm attribute specifies how many integer arguments are to be\n      passed in registers.  */\n-  if (is_attribute_p (\"regparm\", identifier))\n+  { \"regparm\",   1, 1, false, true,  true,  ix86_handle_regparm_attribute },\n+#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+  { \"dllimport\", 1, 1, false, false, false, ix86_handle_dll_attribute },\n+  { \"dllexport\", 1, 1, false, false, false, ix86_handle_dll_attribute },\n+  { \"shared\",    1, 1, true,  false, false, ix86_handle_shared_attribute },\n+#endif\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\n+/* Handle a \"cdecl\" or \"stdcall\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+ix86_handle_cdecl_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != METHOD_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n     {\n-      tree cst;\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-      if (! args || TREE_CODE (args) != TREE_LIST\n-\t  || TREE_CHAIN (args) != NULL_TREE\n-\t  || TREE_VALUE (args) == NULL_TREE)\n-\treturn 0;\n+  if (TARGET_64BIT)\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-      cst = TREE_VALUE (args);\n-      if (TREE_CODE (cst) != INTEGER_CST)\n-\treturn 0;\n+  return NULL_TREE;\n+}\n \n-      if (compare_tree_int (cst, REGPARM_MAX) > 0)\n-\treturn 0;\n+/* Handle a \"regparm\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+ix86_handle_regparm_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != METHOD_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      tree cst;\n \n-      return 1;\n+      cst = TREE_VALUE (args);\n+      if (TREE_CODE (cst) != INTEGER_CST)\n+\t{\n+\t  warning (\"`%s' attribute requires an integer constant argument\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n+      else if (compare_tree_int (cst, REGPARM_MAX) > 0)\n+\t{\n+\t  warning (\"argument to `%s' attribute larger than %d\",\n+\t\t   IDENTIFIER_POINTER (name), REGPARM_MAX);\n+\t  *no_add_attrs = true;\n+\t}\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n #if defined (OSF_OS) || defined (TARGET_OSF1ELF)"}, {"sha": "e14359d1c4b633b2f09c2ac13791070258218566", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Windows NT.\n    Contributed by Douglas Rupp (drupp@cs.washington.edu)\n-   Copyright (C) 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -49,51 +49,54 @@ int i386_pe_dllimport_p PARAMS ((tree));\n void i386_pe_mark_dllexport PARAMS ((tree));\n void i386_pe_mark_dllimport PARAMS ((tree));\n \n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.  */\n-\n-int\n-i386_pe_valid_decl_attribute_p (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n+/* Handle a \"dllimport\" or \"dllexport\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+tree\n+ix86_handle_dll_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n      tree args;\n+     int flags;\n+     bool *no_add_attrs;\n {\n-  if (args == NULL_TREE)\n+  /* These attributes may apply to structure and union types being created,\n+     but otherwise should pass to the declaration involved.  */\n+  if (!DECL_P (*node))\n     {\n-      if (is_attribute_p (\"dllexport\", attr))\n-\treturn 1;\n-      if (is_attribute_p (\"dllimport\", attr))\n-\treturn 1;\n-      if (is_attribute_p (\"shared\", attr))\n-\treturn TREE_CODE (decl) == VAR_DECL;\n+      if (flags & ((int) ATTR_FLAG_DECL_NEXT | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t{\n+\t  *no_add_attrs = true;\n+\t  return tree_cons (name, args, NULL_TREE);\n+\t}\n+      if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n+\t{\n+\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n-/* Return nonzero if ATTR is a valid attribute for TYPE.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.  */\n-\n-int\n-i386_pe_valid_type_attribute_p (type, attributes, attr, args)\n-     tree type;\n-     tree attributes;\n-     tree attr;\n-     tree args;\n+/* Handle a \"shared\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+tree\n+ix86_handle_shared_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n-  if (args == NULL_TREE\n-      && (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE))\n+  if (TREE_CODE (*node) != VAR_DECL)\n     {\n-      if (is_attribute_p (\"dllexport\", attr))\n-\treturn 1;\n-      if (is_attribute_p (\"dllimport\", attr))\n-\treturn 1;\n+      warning (\"`%s' attribute only applies to variables\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  return ix86_valid_type_attribute_p (type, attributes, attr, args);\n+  return NULL_TREE;\n }\n \f\n /* Return the type that we should use to determine if DECL is\n@@ -132,7 +135,7 @@ i386_pe_dllexport_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n-  exp = lookup_attribute (\"dllexport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n   if (exp)\n     return 1;\n \n@@ -163,7 +166,7 @@ i386_pe_dllimport_p (decl)\n   if (TREE_CODE (decl) != VAR_DECL\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n-  imp = lookup_attribute (\"dllimport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n   if (imp)\n     return 1;\n \n@@ -499,7 +502,7 @@ i386_pe_section_type_flags (decl, name, reloc)\n       flags = SECTION_WRITE;\n \n       if (decl && TREE_CODE (decl) == VAR_DECL\n-\t  && lookup_attribute (\"shared\", DECL_MACHINE_ATTRIBUTES (decl)))\n+\t  && lookup_attribute (\"shared\", DECL_ATTRIBUTES (decl)))\n \tflags |= SECTION_PE_SHARED;\n     }\n "}, {"sha": "9c56f376a5c069319a9752234d0f97a624f01cd0", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -138,7 +138,7 @@ static rtx ia64_expand_compare_and_swap PARAMS ((enum machine_mode, int,\n static rtx ia64_expand_lock_test_and_set PARAMS ((enum machine_mode,\n \t\t\t\t\t\t  tree, rtx));\n static rtx ia64_expand_lock_release PARAMS ((enum machine_mode, tree, rtx));\n-static int ia64_valid_type_attribute PARAMS((tree, tree, tree, tree));\n+const struct attribute_spec ia64_attribute_table[];\n static void ia64_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ia64_output_function_end_prologue PARAMS ((FILE *));\n@@ -156,8 +156,8 @@ static rtx ia64_cycle_display PARAMS ((int, rtx));\n \n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE ia64_valid_type_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE ia64_attribute_table\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS ia64_init_builtins\n@@ -6755,29 +6755,13 @@ ia64_epilogue_uses (regno)\n     }\n }\n \n-/* Return true if IDENTIFIER is a valid attribute for TYPE.  */\n-\n-static int\n-ia64_valid_type_attribute (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+/* Table of valid machine attributes.  */\n+const struct attribute_spec ia64_attribute_table[] =\n {\n-  /* We only support an attribute for function calls.  */\n-\n-  if (TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE)\n-    return 0;\n-\n-  /* The \"syscall_linkage\" attribute says the callee is a system call entry\n-     point.  This affects ia64_epilogue_uses.  */\n-\n-  if (is_attribute_p (\"syscall_linkage\", identifier))\n-    return args == NULL_TREE;\n-\n-  return 0;\n-}\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"syscall_linkage\", 0, 0, false, true,  true,  NULL },\n+  { NULL,              0, 0, false, false, false, NULL }\n+};\n \f\n /* For ia64, SYMBOL_REF_FLAG set means that it is a function.\n "}, {"sha": "f1ed72d2e8d53d407a81e69cacdbc1bc738d60ca", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -62,8 +62,8 @@ static int m32r_sched_odd_word_p;\n static void  init_reg_tables\t\t\tPARAMS ((void));\n static void  block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n static int   m32r_is_insn\t\t\tPARAMS ((rtx));\n-static int   m32r_valid_decl_attribute\t\tPARAMS ((tree, tree,\n-\t\t\t\t\t\t\t tree, tree));\n+const struct attribute_spec m32r_attribute_table[];\n+static tree  m32r_handle_model_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void  m32r_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void  m32r_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \n@@ -76,8 +76,8 @@ static int    m32r_issue_rate\t   PARAMS ((void));\n \n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE m32r_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE m32r_output_function_prologue\n@@ -250,10 +250,6 @@ init_reg_tables ()\n \tGrep for MODEL in m32r.h for more info.\n */\n \n-static tree interrupt_ident1;\n-static tree interrupt_ident2;\n-static tree model_ident1;\n-static tree model_ident2;\n static tree small_ident1;\n static tree small_ident2;\n static tree medium_ident1;\n@@ -264,12 +260,8 @@ static tree large_ident2;\n static void\n init_idents PARAMS ((void))\n {\n-  if (interrupt_ident1 == 0)\n+  if (small_ident1 == 0)\n     {\n-      interrupt_ident1 = get_identifier (\"interrupt\");\n-      interrupt_ident2 = get_identifier (\"__interrupt__\");\n-      model_ident1 = get_identifier (\"model\");\n-      model_ident2 = get_identifier (\"__model__\");\n       small_ident1 = get_identifier (\"small\");\n       small_ident2 = get_identifier (\"__small__\");\n       medium_ident1 = get_identifier (\"medium\");\n@@ -279,34 +271,43 @@ init_idents PARAMS ((void))\n     }\n }\n \n-/* Return nonzero if IDENTIFIER is a valid decl attribute.  */\n+const struct attribute_spec m32r_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 0, 0, true,  false, false, NULL },\n+  { \"model\",     1, 1, true,  false, false, m32r_handle_model_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \n-static int\n-m32r_valid_decl_attribute (type, attributes, identifier, args)\n-     tree type ATTRIBUTE_UNUSED;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n+\n+/* Handle an \"model\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+m32r_handle_model_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node ATTRIBUTE_UNUSED;\n+     tree name;\n      tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n-  init_idents ();\n-\n-  if ((identifier == interrupt_ident1\n-       || identifier == interrupt_ident2)\n-      && list_length (args) == 0)\n-    return 1;\n+  tree arg;\n \n-  if ((identifier == model_ident1\n-       || identifier == model_ident2)\n-      && list_length (args) == 1\n-      && (TREE_VALUE (args) == small_ident1\n-\t  || TREE_VALUE (args) == small_ident2\n-\t  || TREE_VALUE (args) == medium_ident1\n-\t  || TREE_VALUE (args) == medium_ident2\n-\t  || TREE_VALUE (args) == large_ident1\n-\t  || TREE_VALUE (args) == large_ident2))\n-    return 1;\n+  init_idents ();\n+  arg = TREE_VALUE (args);\n+\n+  if (arg != small_ident1\n+      && arg != small_ident2\n+      && arg != medium_ident1\n+      && arg != medium_ident2\n+      && arg != large_ident1\n+      && arg != large_ident2)\n+    {\n+      warning (\"invalid argument of `%s' attribute\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \f\n /* A C statement or statements to switch to the appropriate\n@@ -370,7 +371,7 @@ m32r_encode_section_info (decl)\n     {\n     case VAR_DECL :\n     case FUNCTION_DECL :\n-      model = lookup_attribute (\"model\", DECL_MACHINE_ATTRIBUTES (decl));\n+      model = lookup_attribute (\"model\", DECL_ATTRIBUTES (decl));\n       break;\n     case STRING_CST :\n     case CONSTRUCTOR :\n@@ -1747,7 +1748,7 @@ m32r_compute_function_type (decl)\n     return fn_type;\n \n   /* Compute function type.  */\n-  fn_type = (lookup_attribute (\"interrupt\", DECL_MACHINE_ATTRIBUTES (current_function_decl)) != NULL_TREE\n+  fn_type = (lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (current_function_decl)) != NULL_TREE\n \t     ? M32R_FUNCTION_INTERRUPT\n \t     : M32R_FUNCTION_NORMAL);\n "}, {"sha": "da45de0458a06fd80313721fb0c3605d0240a609", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -66,8 +66,8 @@ static rtx m68hc11_expand_compare PARAMS((enum rtx_code, rtx, rtx));\n static int must_parenthesize PARAMS ((rtx));\n static int m68hc11_shift_cost PARAMS ((enum machine_mode, rtx, int));\n static int m68hc11_auto_inc_p PARAMS ((rtx));\n-static int m68hc11_valid_type_attribute_p PARAMS((tree, tree,\n-\t\t\t\t\t\t  tree, tree));\n+static tree m68hc11_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec m68hc11_attribute_table[];\n \n void create_regs_rtx PARAMS ((void));\n static void m68hc11_add_gc_roots PARAMS ((void));\n@@ -209,8 +209,8 @@ const char *m68hc11_soft_reg_count;\n static int nb_soft_regs;\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE m68hc11_valid_type_attribute_p\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE m68hc11_attribute_table\n \n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE m68hc11_output_function_epilogue\n@@ -1130,30 +1130,34 @@ m68hc11_initialize_trampoline (tramp, fnaddr, cxt)\n \f\n /* Declaration of types.  */\n \n-/* If defined, a C expression whose value is nonzero if IDENTIFIER\n-   with arguments ARGS is a valid machine specific attribute for TYPE.\n-   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n-\n-static int\n-m68hc11_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+const struct attribute_spec m68hc11_attribute_table[] =\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != FIELD_DECL && TREE_CODE (type) != TYPE_DECL)\n-    return 0;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { \"trap\",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n+/* Handle an attribute requiring a FUNCTION_TYPE, FIELD_DECL or TYPE_DECL;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+m68hc11_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n     {\n-      if (is_attribute_p (\"interrupt\", identifier))\n-\treturn (args == NULL_TREE);\n-      if (is_attribute_p (\"trap\", identifier))\n-\treturn (args == NULL_TREE);\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Define this macro if references to a symbol must be treated"}, {"sha": "0a4a2b5f80e1e5f8dfe4ad7b7fd9354cf3f4a04a", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -130,8 +130,8 @@ static void       mcore_mark_dllexport         PARAMS ((tree));\n static void       mcore_mark_dllimport         PARAMS ((tree));\n static int        mcore_dllexport_p            PARAMS ((tree));\n static int        mcore_dllimport_p            PARAMS ((tree));\n-static int        mcore_valid_decl_attribute   PARAMS ((tree, tree,\n-\t\t\t\t\t\t\ttree, tree));\n+const struct attribute_spec mcore_attribute_table[];\n+static tree       mcore_handle_naked_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void\t  mcore_asm_named_section      PARAMS ((const char *,\n \t\t\t\t\t\t\tunsigned int));\n \f\n@@ -141,8 +141,8 @@ static void\t  mcore_asm_named_section      PARAMS ((const char *,\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE mcore_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE mcore_attribute_table\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -3387,7 +3387,7 @@ mcore_dllexport_p (decl)\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n \n-  return lookup_attribute (\"dllexport\", DECL_MACHINE_ATTRIBUTES (decl)) != 0;\n+  return lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl)) != 0;\n }\n \n static int\n@@ -3398,7 +3398,7 @@ mcore_dllimport_p (decl)\n       && TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n \n-  return lookup_attribute (\"dllimport\", DECL_MACHINE_ATTRIBUTES (decl)) != 0;\n+  return lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl)) != 0;\n }\n \n /* Cover function to implement ENCODE_SECTION_INFO.  */\n@@ -3449,24 +3449,27 @@ mcore_encode_section_info (decl)\n    dllexport - for exporting a function/variable that will live in a dll\n    dllimport - for importing a function/variable from a dll\n    naked     - do not create a function prologue/epilogue.  */\n-static int\n-mcore_valid_decl_attribute (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args;\n-{\n-  if (args != NULL_TREE)\n-    return 0;\n \n-  if (is_attribute_p (\"dllexport\", attr))\n-    return 1;\n+const struct attribute_spec mcore_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"dllexport\", 0, 0, true,  false, false, NULL },\n+  { \"dllimport\", 0, 0, true,  false, false, NULL },\n+  { \"naked\",     0, 0, true,  false, false, mcore_handle_naked_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \n-  if (is_attribute_p (\"dllimport\", attr))\n-    return 1;\n-  \n-  if (is_attribute_p (\"naked\", attr) &&\n-      TREE_CODE (decl) == FUNCTION_DECL)\n+/* Handle a \"naked\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+mcore_handle_naked_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n     {\n       /* PR14310 - don't complain about lack of return statement\n \t in naked functions.  The solution here is a gross hack\n@@ -3483,11 +3486,15 @@ mcore_valid_decl_attribute (decl, attributes, attr, args)\n \t}\n       else if (saved_warn_return_type_count)\n \tsaved_warn_return_type_count = 2;\n-      \n-      return 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Cover function for UNIQUE_SECTION.  */\n@@ -3530,7 +3537,7 @@ mcore_unique_section (decl, reloc)\n int\n mcore_naked_function_p ()\n {\n-  return lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (current_function_decl)) != NULL_TREE;\n+  return lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl)) != NULL_TREE;\n }\n \n static void"}, {"sha": "a7e89c25f17aac15221be514a753480855302481", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"toplev.h\"\n \n #ifdef OSF_OS\n int ns32k_num_files = 0;\n@@ -64,13 +65,14 @@ static const char *const ns32k_out_reg_names[] = OUTPUT_REGISTER_NAMES;\n static rtx gen_indexed_expr PARAMS ((rtx, rtx, rtx));\n static const char *singlemove_string PARAMS ((rtx *));\n static void move_tail PARAMS ((rtx[], int, int));\n-static int ns32k_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+static tree ns32k_handle_fntype_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec ns32k_attribute_table[];\n static void ns32k_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void ns32k_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE ns32k_valid_type_attribute_p\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE ns32k_attribute_table\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE ns32k_output_function_prologue\n@@ -1008,32 +1010,39 @@ symbolic_reference_mentioned_p (op)\n   return 0;\n }\n \f\n-/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n-   attribute for TYPE.  The attributes in ATTRIBUTES have previously been\n-   assigned to TYPE.  */\n-\n-static int\n-ns32k_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n-{\n-  if (TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != FIELD_DECL\n-      && TREE_CODE (type) != TYPE_DECL)\n-    return 0;\n+/* Table of machine-specific attributes.  */\n \n+const struct attribute_spec ns32k_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n   /* Stdcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n-  if (is_attribute_p (\"stdcall\", identifier))\n-    return (args == NULL_TREE);\n-\n+  { \"stdcall\", 0, 0, false, true,  true,  ns32k_handle_fntype_attribute },\n   /* Cdecl attribute says the callee is a normal C declaration */\n-  if (is_attribute_p (\"cdecl\", identifier))\n-    return (args == NULL_TREE);\n+  { \"cdecl\",   0, 0, false, true,  true,  ns32k_handle_fntype_attribute },\n+  { NULL,      0, 0, false, false, false, NULL }\n+};\n \n-  return 0;\n+/* Handle an attribute requiring a FUNCTION_TYPE, FIELD_DECL or TYPE_DECL;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+ns32k_handle_fntype_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n }\n \n \f"}, {"sha": "738c8a5bed85484c8ea0f1b15110ea1d97df88f4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -127,7 +127,8 @@ static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n static void rs6000_free_machine_status PARAMS ((struct function *));\n static void rs6000_init_machine_status PARAMS ((struct function *));\n static int rs6000_ra_ever_killed PARAMS ((void));\n-static int rs6000_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+static tree rs6000_handle_longcall_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+const struct attribute_spec rs6000_attribute_table[];\n static void rs6000_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void rs6000_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static rtx rs6000_emit_set_long_const PARAMS ((rtx,\n@@ -184,8 +185,8 @@ static char alt_reg_names[][8] =\n #endif\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE rs6000_valid_type_attribute_p\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE rs6000_attribute_table\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE rs6000_output_function_prologue\n@@ -8123,28 +8124,34 @@ rs6000_initialize_trampoline (addr, fnaddr, cxt)\n }\n \n \f\n-/* If defined, a C expression whose value is nonzero if IDENTIFIER\n-   with arguments ARGS is a valid machine specific attribute for TYPE.\n-   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n-\n-static int\n-rs6000_valid_type_attribute_p (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n-     tree args;\n+/* Table of valid machine attributes.  */\n+const struct attribute_spec rs6000_attribute_table[] =\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != FIELD_DECL\n-      && TREE_CODE (type) != TYPE_DECL)\n-    return 0;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"longcall\", 0, 0, false, true,  true,  rs6000_handle_longcall_attribute },\n+  { NULL,       0, 0, false, false, false, NULL }\n+};\n \n-  /* Longcall attribute says that the function is not within 2**26 bytes\n-     of the current function, and to do an indirect call.  */\n-  if (is_attribute_p (\"longcall\", identifier))\n-    return (args == NULL_TREE);\n+/* Handle a \"longcall\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+rs6000_handle_longcall_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Return a reference suitable for calling a function with the"}, {"sha": "684cff1ac5eea745218f887bcd8abc4d59cdce98", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 96, "deletions": 46, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -154,15 +154,18 @@ static int calc_live_regs PARAMS ((int *, int *));\n static void mark_use PARAMS ((rtx, rtx *));\n static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n static rtx mark_constant_pool_use PARAMS ((rtx));\n-static int sh_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+const struct attribute_spec sh_attribute_table[];\n+static tree sh_handle_interrupt_handler_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree sh_handle_sp_switch_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree sh_handle_trap_exit_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void sh_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void sh_insert_attributes PARAMS ((tree, tree *));\n static void sh_asm_named_section PARAMS ((const char *, unsigned int));\n static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE sh_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE sh_attribute_table\n \n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE sh_output_function_epilogue\n@@ -269,7 +272,7 @@ print_operand (stream, x, code)\n \n \tif ((lookup_attribute\n \t     (\"interrupt_handler\",\n-\t      DECL_MACHINE_ATTRIBUTES (current_function_decl)))\n+\t      DECL_ATTRIBUTES (current_function_decl)))\n \t    != NULL_TREE)\n \t  interrupt_handler = 1;\n \telse\n@@ -3964,7 +3967,7 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \n   if ((lookup_attribute\n        (\"interrupt_handler\",\n-\tDECL_MACHINE_ATTRIBUTES (current_function_decl)))\n+\tDECL_ATTRIBUTES (current_function_decl)))\n       != NULL_TREE)\n     interrupt_handler = 1;\n   else\n@@ -4058,7 +4061,7 @@ sh_expand_prologue ()\n \n   current_function_interrupt\n     = lookup_attribute (\"interrupt_handler\",\n-\t\t\tDECL_MACHINE_ATTRIBUTES (current_function_decl))\n+\t\t\tDECL_ATTRIBUTES (current_function_decl))\n     != NULL_TREE;\n \n   /* We have pretend args if we had an object sent partially in registers\n@@ -4656,11 +4659,7 @@ sh_insert_attributes (node, attributes)\n   return;\n }\n \n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ATTRIBUTES are any existing attributes and ARGS are the arguments\n-   supplied with ATTR.\n-\n-   Supported attributes:\n+/* Supported attributes:\n \n    interrupt_handler -- specifies this function is an interrupt handler.\n \n@@ -4670,59 +4669,110 @@ sh_insert_attributes (node, attributes)\n    trap_exit -- use a trapa to exit an interrupt function instead of\n    an rte instruction.  */\n \n-static int\n-sh_valid_decl_attribute (decl, attributes, attr, args)\n-     tree decl;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args;\n+const struct attribute_spec sh_attribute_table[] =\n {\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    return 0;\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n+  { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n \n-  if (is_attribute_p (\"interrupt_handler\", attr))\n+/* Handle an \"interrupt_handler\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+sh_handle_interrupt_handler_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n-      return 1;\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n     }\n \n-  if (is_attribute_p (\"sp_switch\", attr))\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"sp_switch\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+sh_handle_sp_switch_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (!pragma_interrupt)\n     {\n       /* The sp_switch attribute only has meaning for interrupt functions.  */\n-      if (!pragma_interrupt)\n-\treturn 0;\n-\n-      /* sp_switch must have an argument.  */\n-      if (!args || TREE_CODE (args) != TREE_LIST)\n-\treturn 0;\n-\n+      warning (\"`%s' attribute only applies to interrupt functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n+    {\n       /* The argument must be a constant string.  */\n-      if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n-\treturn 0;\n-\n+      warning (\"`%s' attribute argument not a string constant\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n       sp_switch = gen_rtx_SYMBOL_REF (VOIDmode,\n \t\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args)));\n-      return 1;\n     }\n \n-  if (is_attribute_p (\"trap_exit\", attr))\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"trap_exit\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+sh_handle_trap_exit_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (!pragma_interrupt)\n     {\n       /* The trap_exit attribute only has meaning for interrupt functions.  */\n-      if (!pragma_interrupt)\n-\treturn 0;\n-\n-      /* trap_exit must have an argument.  */\n-      if (!args || TREE_CODE (args) != TREE_LIST)\n-\treturn 0;\n-\n+      warning (\"`%s' attribute only applies to interrupt functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+    {\n       /* The argument must be a constant integer.  */\n-      if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n-\treturn 0;\n-\n+      warning (\"`%s' attribute argument not an integer constant\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n       trap_exit = TREE_INT_CST_LOW (TREE_VALUE (args));\n-      return 1;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \n \f"}, {"sha": "6ecf8ae819e9a87c7150d9e9fa4eaadb9e772401", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1909,30 +1909,34 @@ stormy16_interrupt_function_p ()\n   return lookup_attribute (\"interrupt\", attributes) != NULL_TREE;\n }\n \n-/* If defined, a C function which returns nonzero if IDENTIFIER\n-   with arguments ARGS is a valid machine specific attribute for TYPE.\n-   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE stormy16_valid_type_attribute\n-static int stormy16_valid_type_attribute PARAMS ((tree TYPE,\n-\t\t\t\t\t\t  tree ATTRIBUTES,\n-\t\t\t\t\t\t  tree IDENTIFIER,\n-\t\t\t\t\t\t  tree ARGS));\n-\n-static int\n-stormy16_valid_type_attribute (type, attributes, identifier, args)\n-     tree type;\n-     tree attributes ATTRIBUTE_UNUSED;\n-     tree identifier;\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE stormy16_attribute_table\n+static tree stormy16_handle_interrupt_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static const struct attribute_spec stormy16_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 0, 0, false, true,  true,  stormy16_handle_interrupt_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\n+/* Handle an \"interrupt\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+static tree\n+stormy16_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n      tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n-  if (TREE_CODE (type) != FUNCTION_TYPE)\n-    return 0;\n-  \n-  if (is_attribute_p (\"interrupt\", identifier))\n-    return 1;\n+  if (TREE_CODE (*node) != FUNCTION_TYPE)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n \n-  return 0;\n+  return NULL_TREE;\n }\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "d5920bcbaa031d356f464bd9703499dd84beeaa8", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1975,7 +1975,7 @@ enum reg_class\n    FUNDECL is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_DECL' that\n    describes the declaration of the function.  From this it is possible to\n-   obtain the DECL_MACHINE_ATTRIBUTES of the function.\n+   obtain the DECL_ATTRIBUTES of the function.\n \n    FUNTYPE is a C variable whose value is a tree node that describes the\n    function in question.  Normally it is a node of type `FUNCTION_TYPE' that"}, {"sha": "84aef1fe4d31b1ec2278a7e20a40e0427d50250b", "filename": "gcc/config/v850/v850-c.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fv850%2Fv850-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fv850%2Fv850-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-c.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n \f\n static int  pop_data_area          PARAMS ((v850_data_area));\n static int  push_data_area         PARAMS ((v850_data_area));\n-static int  mark_current_function_as_interrupt PARAMS ((void));\n+static void mark_current_function_as_interrupt PARAMS ((void));\n \f\n /* Push a data area onto the stack.  */\n \n@@ -85,7 +85,7 @@ pop_data_area (data_area)\n \n /* Set the machine specific 'interrupt' attribute on the current function.  */\n \n-static int\n+static void\n mark_current_function_as_interrupt ()\n {\n   tree name;\n@@ -104,8 +104,8 @@ mark_current_function_as_interrupt ()\n       return 0;\n     }\n   \n-  return valid_machine_attribute\n-    (name, NULL_TREE, current_function_decl, NULL_TREE);\n+  decl_attributes (&current_function_decl,\n+\t\t   tree_cons (name, NULL_TREE, NULL_TREE), 0);\n }\n \n \f"}, {"sha": "ea83c153164443604162f4c0cd4deaeab286e543", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -53,7 +53,9 @@ static int  const_costs_int          PARAMS ((HOST_WIDE_INT, int));\n static void substitute_ep_register   PARAMS ((rtx, rtx, int, int, rtx *, rtx *));\n static int  ep_memory_offset         PARAMS ((enum machine_mode, int));\n static void v850_set_data_area       PARAMS ((tree, v850_data_area));\n-static int v850_valid_decl_attribute PARAMS ((tree, tree, tree, tree));\n+const struct attribute_spec v850_attribute_table[];\n+static tree v850_handle_interrupt_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree v850_handle_data_area_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static void v850_insert_attributes   PARAMS ((tree, tree *));\n \n /* True if the current function has anonymous arguments.  */\n@@ -84,8 +86,8 @@ static int v850_interrupt_cache_p = FALSE;\n static int v850_interrupt_p = FALSE;\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_VALID_DECL_ATTRIBUTE\n-#define TARGET_VALID_DECL_ATTRIBUTE v850_valid_decl_attribute\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE v850_attribute_table\n \n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES v850_insert_attributes\n@@ -1978,13 +1980,13 @@ v850_data_area\n v850_get_data_area (decl)\n      tree decl;\n {\n-  if (lookup_attribute (\"sda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+  if (lookup_attribute (\"sda\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n     return DATA_AREA_SDA;\n   \n-  if (lookup_attribute (\"tda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+  if (lookup_attribute (\"tda\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n     return DATA_AREA_TDA;\n   \n-  if (lookup_attribute (\"zda\", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE)\n+  if (lookup_attribute (\"zda\", DECL_ATTRIBUTES (decl)) != NULL_TREE)\n     return DATA_AREA_ZDA;\n \n   return DATA_AREA_NORMAL;\n@@ -2008,62 +2010,92 @@ v850_set_data_area (decl, data_area)\n       return;\n     }\n \n-  DECL_MACHINE_ATTRIBUTES (decl) = tree_cons\n-    (name, NULL, DECL_MACHINE_ATTRIBUTES (decl));\n+  DECL_ATTRIBUTES (decl) = tree_cons\n+    (name, NULL, DECL_ATTRIBUTES (decl));\n }\n \f\n-/* Return nonzero if ATTR is a valid attribute for DECL.\n-   ARGS are the arguments supplied with ATTR.  */\n+const struct attribute_spec v850_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"interrupt\",         0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"sda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"tda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"zda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n \n-static int\n-v850_valid_decl_attribute (decl, unused, attr, args)\n-     tree decl;\n-     tree unused ATTRIBUTE_UNUSED;\n-     tree attr;\n-     tree args;\n+/* Handle an \"interrupt\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+v850_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (\"`%s' attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"sda\", \"tda\" or \"zda\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+v850_handle_data_area_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n {\n   v850_data_area data_area;\n   v850_data_area area;\n-  \n-  if (args != NULL_TREE)\n-    return 0;\n-\n-  if (is_attribute_p (\"interrupt_handler\", attr)\n-      || is_attribute_p (\"interrupt\", attr))\n-    return TREE_CODE (decl) == FUNCTION_DECL;\n+  tree decl = *node;\n \n   /* Implement data area attribute.  */\n-  if (is_attribute_p (\"sda\", attr))\n+  if (is_attribute_p (\"sda\", name))\n     data_area = DATA_AREA_SDA;\n-  else if (is_attribute_p (\"tda\", attr))\n+  else if (is_attribute_p (\"tda\", name))\n     data_area = DATA_AREA_TDA;\n-  else if (is_attribute_p (\"zda\", attr))\n+  else if (is_attribute_p (\"zda\", name))\n     data_area = DATA_AREA_ZDA;\n   else\n-    return 0;\n+    abort ();\n   \n   switch (TREE_CODE (decl))\n     {\n     case VAR_DECL:\n       if (current_function_decl != NULL_TREE)\n-\terror_with_decl (decl, \"\\\n+\t{\n+\t  error_with_decl (decl, \"\\\n a data area attribute cannot be specified for local variables\");\n-      \n+\t  *no_add_attrs = true;\n+\t}\n+\n       /* Drop through.  */\n \n     case FUNCTION_DECL:\n       area = v850_get_data_area (decl);\n       if (area != DATA_AREA_NORMAL && data_area != area)\n-\terror_with_decl (decl, \"\\\n+\t{\n+\t  error_with_decl (decl, \"\\\n data area of '%s' conflicts with previous declaration\");\n-      \n-      return 1;\n+\t  *no_add_attrs = true;\n+\t}\n+      break;\n       \n     default:\n       break;\n     }\n-  \n-  return 0;\n+\n+  return NULL_TREE;\n }\n \n \f\n@@ -2083,13 +2115,13 @@ v850_interrupt_function_p (func)\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return 0;\n \n-  a = lookup_attribute (\"interrupt_handler\", DECL_MACHINE_ATTRIBUTES (func));\n+  a = lookup_attribute (\"interrupt_handler\", DECL_ATTRIBUTES (func));\n   if (a != NULL_TREE)\n     ret = 1;\n \n   else\n     {\n-      a = lookup_attribute (\"interrupt\", DECL_MACHINE_ATTRIBUTES (func));\n+      a = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (func));\n       ret = a != NULL_TREE;\n     }\n "}, {"sha": "345cef4b008790823733945d2553bfa684e9219c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,3 +1,43 @@\n+2001-09-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\tTable-driven attributes.\n+\t* decl.c: Rename DECL_MACHINE_ATTRIBUTES to DECL_ATTRIBUTES.\n+\t* decl2.c (cplus_decl_attributes): Only take one attributes\n+\tparameter.\n+\t* cp-tree.c (cplus_decl_attributes): Update prototype.\n+\t* class.c (finish_struct), decl.c (start_decl, start_function),\n+\tdecl2.c (grokfield), friend.c (do_friend), parse.y\n+\t(parse_bitfield): Update calls to cplus_decl_attributes.\n+\t* decl.c (grokdeclarator): Take a pointer to a single ordinary\n+\tattribute list.\n+\t* decl.h (grokdeclarator): Update prototype.\n+\t* decl2.c (grokfield): Take a single ordinary attribute list.\n+\t* friend.c (do_friend): Likewise.\n+\t* decl.c (shadow_tag, groktypename, start_decl,\n+\tstart_handler_parms, grokdeclarator, grokparms, start_function,\n+\tstart_method), decl2.c (grokfield, grokbitfield, grokoptypename),\n+\tparse.y (parse_field, parse_bitfield, component_decl_1), pt.c\n+\t(process_template_parm, do_decl_instantiation): Pass single\n+\tordinary attribute lists around.\n+\t* decl.c (grokdeclarator): Correct handling of nested attributes.\n+\tRevert the patch\n+\t1998-10-18  Jason Merrill  <jason@yorick.cygnus.com>\n+\t\t* decl.c (grokdeclarator): Embedded attrs bind to the right,\n+\t\tnot the left.\n+\t.\n+\t* cp-tree.h (cp_valid_lang_attribute): Remove declaration\n+\t(cp_attribute_table): Declare.\n+\t* decl.c (valid_lang_attribute): Don't define.\n+\t(lang_attribute_table): Define.\n+\t(init_decl_processing): Initialize lang_attribute_table instead of\n+\tvalid_lang_attribute.\n+\t* tree.c (cp_valid_lang_attribute): Remove.\n+\t(handle_java_interface_attribute, handle_com_interface_attribute,\n+\thandle_init_priority_attribute): New functions.\n+\t(cp_attribute_table): New array.\n+\t* decl2.c (import_export_class): Don't use\n+\ttargetm.valid_type_attribute.\n+\n 2001-09-15  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t        * Make-lang.in (cp/error.o): Depend on real.h"}, {"sha": "0c106c375bf0c2dfb50635932dbacfc8a766359f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -5293,7 +5293,7 @@ finish_struct (t, attributes)\n      as necessary.  */\n   unreverse_member_declarations (t);\n \n-  cplus_decl_attributes (&t, attributes, NULL_TREE, 0);\n+  cplus_decl_attributes (&t, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n   /* Nadger the current location so that diagnostics point to the start of\n      the struct, not the end.  */"}, {"sha": "2662356451baf9a53355b66f6cca557364f86ddd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -3734,7 +3734,7 @@ extern tree grokbitfield\t\t\tPARAMS ((tree, tree, tree));\n extern tree groktypefield\t\t\tPARAMS ((tree, tree));\n extern tree grokoptypename\t\t\tPARAMS ((tree, tree));\n extern int copy_assignment_arg_p\t\tPARAMS ((tree, int));\n-extern void cplus_decl_attributes\t\tPARAMS ((tree *, tree, tree, int));\n+extern void cplus_decl_attributes\t\tPARAMS ((tree *, tree, int));\n extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));\n extern void defer_fn            \t\tPARAMS ((tree));\n@@ -4208,7 +4208,7 @@ extern tree walk_tree_without_duplicates        PARAMS ((tree *,\n \t\t\t\t\t\t\t walk_tree_fn,\n \t\t\t\t\t\t\t void *));\n extern tree copy_tree_r                         PARAMS ((tree *, int *, void *));\n-extern int cp_valid_lang_attribute\t\tPARAMS ((tree, tree, tree, tree));\n+extern const struct attribute_spec cp_attribute_table[];\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));\n extern tree cp_build_qualified_type_real        PARAMS ((tree, int, int));\n extern void remap_save_expr                     PARAMS ((tree *, splay_tree, tree, int *));"}, {"sha": "60938a702ba35f772acc1d6333d41809925cdec4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n \n-extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n+extern const struct attribute_spec *lang_attribute_table;\n \n #ifndef BOOL_TYPE_SIZE\n /* `bool' has size and alignment `1', on all platforms.  */\n@@ -3438,7 +3438,7 @@ duplicate_decls (newdecl, olddecl)\n \n   /* Copy all the DECL_... slots specified in the new decl\n      except for any that we copy here from the old type.  */\n-  DECL_MACHINE_ATTRIBUTES (newdecl)\n+  DECL_ATTRIBUTES (newdecl)\n     = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n@@ -3746,7 +3746,7 @@ duplicate_decls (newdecl, olddecl)\n \n   /* NEWDECL contains the merged attribute lists.\n      Update OLDDECL to be the same.  */\n-  DECL_MACHINE_ATTRIBUTES (olddecl) = DECL_MACHINE_ATTRIBUTES (newdecl);\n+  DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);\n \n   return 1;\n }\n@@ -6493,7 +6493,7 @@ init_decl_processing ()\n   /* Show we use EH for cleanups.  */\n   using_eh_for_cleanups ();\n \n-  valid_lang_attribute = cp_valid_lang_attribute;\n+  lang_attribute_table = cp_attribute_table;\n \n   /* Maintain consistency.  Perhaps we should just complain if they\n      say -fwritable-strings?  */\n@@ -6986,7 +6986,7 @@ shadow_tag (declspecs)\n       if (TYPE_FIELDS (t))\n \t{\n \t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n-\t\t\t\t      NULL_TREE);\n+\t\t\t\t      NULL);\n \t  finish_anon_union (decl);\n \t}\n     }\n@@ -7002,7 +7002,7 @@ groktypename (typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t TYPENAME, 0, NULL_TREE);\n+\t\t\t TYPENAME, 0, NULL);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -7031,7 +7031,6 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   tree context;\n   extern int have_extern_spec;\n   extern int used_extern_spec;\n-  tree attrlist;\n \n #if 0\n   /* See code below that used this.  */\n@@ -7046,13 +7045,10 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       used_extern_spec = 1;\n     }\n \n-  if (attributes || prefix_attributes)\n-    attrlist = build_tree_list (attributes, prefix_attributes);\n-  else\n-    attrlist = NULL_TREE;\n+  attributes = chainon (attributes, prefix_attributes);\n \n   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,\n-\t\t\t attrlist);\n+\t\t\t &attributes);\n \n   if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE)\n     return NULL_TREE;\n@@ -7119,7 +7115,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     }\n \n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n-  cplus_decl_attributes (&decl, attributes, prefix_attributes, 0);\n+  cplus_decl_attributes (&decl, attributes, 0);\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n@@ -8482,7 +8478,7 @@ start_handler_parms (declspecs, declarator)\n   if (declspecs)\n     {\n       decl = grokdeclarator (declarator, declspecs, CATCHPARM,\n-\t\t\t     1, NULL_TREE);\n+\t\t\t     1, NULL);\n       if (decl == NULL_TREE)\n \terror (\"invalid catch parameter\");\n     }\n@@ -9425,8 +9421,9 @@ check_special_function_return_type (sfk, type, optype)\n      BITFIELD for a field with specified width.\n    INITIALIZED is 1 if the decl has an initializer.\n \n-   ATTRLIST is a TREE_LIST node with prefix attributes in TREE_VALUE and\n-   normal attributes in TREE_PURPOSE, or NULL_TREE.\n+   ATTRLIST is a pointer to the list of attributes, which may be NULL\n+   if there are none; *ATTRLIST may be modified if attributes from inside\n+   the declarator should be applied to the declaration.\n \n    In the TYPENAME case, DECLARATOR is really an abstract declarator.\n    It may also be so in the PARM case, for a prototype where the\n@@ -9464,7 +9461,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      tree declarator;\n      enum decl_context decl_context;\n      int initialized;\n-     tree attrlist;\n+     tree *attrlist;\n {\n   RID_BIT_TYPE specbits;\n   int nclasses = 0;\n@@ -9487,7 +9484,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   int bitfield = 0;\n #if 0\n   /* See the code below that used this.  */\n-  tree decl_machine_attr = NULL_TREE;\n+  tree decl_attr = NULL_TREE;\n #endif\n   /* Set this to error_mark_node for FIELD_DECLs we could not handle properly.\n      All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */\n@@ -9506,8 +9503,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   tree raises = NULL_TREE;\n   int template_count = 0;\n   tree in_namespace = NULL_TREE;\n-  tree inner_attrs;\n-  int ignore_attrs;\n+  tree returned_attrs = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -9598,24 +9594,22 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   cp_finish_decl so we can get the variable\n \t\t   initialized...  */\n \n-\t\ttree attributes, prefix_attributes;\n+\t\ttree attributes;\n \n \t\t*next = TREE_OPERAND (decl, 0);\n \t\tinit = CALL_DECLARATOR_PARMS (decl);\n \n \t\tif (attrlist)\n \t\t  {\n-\t\t    attributes = TREE_PURPOSE (attrlist);\n-\t\t    prefix_attributes = TREE_VALUE (attrlist);\n+\t\t    attributes = *attrlist;\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    attributes = NULL_TREE;\n-\t\t    prefix_attributes = NULL_TREE;\n \t\t  }\n \n \t\tdecl = start_decl (declarator, declspecs, 1,\n-\t\t\t\t   attributes, prefix_attributes);\n+\t\t\t\t   attributes, NULL_TREE);\n \t\tdecl_type_access_control (decl);\n \t\tif (decl)\n \t\t  {\n@@ -9953,7 +9947,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      type = TREE_TYPE (t);\n #if 0\n \t      /* See the code below that used this.  */\n-\t      decl_machine_attr = DECL_MACHINE_ATTRIBUTES (id);\n+\t      decl_attr = DECL_ATTRIBUTES (id);\n #endif\n \t      typedef_decl = t;\n \t    }\n@@ -10312,9 +10306,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      Descend through it, creating more complex types, until we reach\n      the declared identifier (or NULL_TREE, in an absolute declarator).  */\n \n-  inner_attrs = NULL_TREE;\n-  ignore_attrs = 0;\n-\n   while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE\n \t && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n     {\n@@ -10363,28 +10354,30 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    }\n \t}\n \n-      /* See the comment for the TREE_LIST case, below.  */\n-      if (ignore_attrs)\n-\tignore_attrs = 0;\n-      else if (inner_attrs)\n-\t{\n-\t  decl_attributes (&type, inner_attrs, 0);\n-\t  inner_attrs = NULL_TREE;\n-\t}\n-\n       switch (TREE_CODE (declarator))\n \t{\n \tcase TREE_LIST:\n \t  {\n \t    /* We encode a declarator with embedded attributes using\n-\t       a TREE_LIST.  The attributes apply to the declarator\n-\t       directly inside them, so we have to skip an iteration\n-\t       before applying them to the type.  If the declarator just\n-\t       inside is the declarator-id, we apply the attrs to the\n-\t       decl itself.  */\n-\t    inner_attrs = TREE_PURPOSE (declarator);\n-\t    ignore_attrs = 1;\n+\t       a TREE_LIST.  */\n+\t    tree attrs = TREE_PURPOSE (declarator);\n+\t    tree inner_decl;\n \t    declarator = TREE_VALUE (declarator);\n+\t    inner_decl = declarator;\n+\t    while (inner_decl != NULL_TREE\n+\t\t   && TREE_CODE (inner_decl) == TREE_LIST)\n+\t      inner_decl = TREE_VALUE (inner_decl);\n+\t    int attr_flags = 0;\n+\t    if (inner_decl == NULL_TREE\n+\t\t|| TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n+\t      attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n+\t    if (TREE_CODE (inner_decl) == CALL_EXPR)\n+\t      attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n+\t    if (TREE_CODE (inner_decl) == ARRAY_REF)\n+\t      attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n+\t    returned_attrs = decl_attributes (&type,\n+\t\t\t\t\t      chainon (returned_attrs, attrs),\n+\t\t\t\t\t      attr_flags);\n \t  }\n \t  break;\n \n@@ -10883,15 +10876,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t}\n     }\n \n-  /* See the comment for the TREE_LIST case, above.  */\n-  if (inner_attrs)\n+  if (returned_attrs)\n     {\n-      if (! ignore_attrs)\n-\tdecl_attributes (&type, inner_attrs, 0);\n-      else if (attrlist)\n-\tTREE_VALUE (attrlist) = chainon (inner_attrs, TREE_VALUE (attrlist));\n+      if (attrlist)\n+\t*attrlist = chainon (returned_attrs, *attrlist);\n       else\n-\tattrlist = build_tree_list (NULL_TREE, inner_attrs);\n+\tattrlist = &returned_attrs;\n     }\n \n   /* Now TYPE has the actual type.  */\n@@ -11302,8 +11292,8 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \t      return decl;\n #if 0\n \t    /* This clobbers the attrs stored in `decl' from `attrlist'.  */\n-\t    /* The decl and setting of decl_machine_attr is also turned off.  */\n-\t    decl = build_decl_attribute_variant (decl, decl_machine_attr);\n+\t    /* The decl and setting of decl_attr is also turned off.  */\n+\t    decl = build_decl_attribute_variant (decl, decl_attr);\n #endif\n \n \t    /* [class.conv.ctor]\n@@ -11401,7 +11391,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n                   }\n               \n                 t = do_friend (ctype, declarator, decl,\n-              \t\t       last_function_parms, attrlist, flags, quals,\n+              \t\t       last_function_parms, *attrlist, flags, quals,\n               \t\t       funcdef_flag);\n               }\n             if (t && funcdef_flag)\n@@ -11838,7 +11828,7 @@ grokparms (first_parm)\n         break;\n \n       decl = grokdeclarator (TREE_VALUE (decl), TREE_PURPOSE (decl),\n-\t\t     PARM, init != NULL_TREE, NULL_TREE);\n+\t\t     PARM, init != NULL_TREE, NULL);\n       if (! decl || TREE_TYPE (decl) == error_mark_node)\n         continue;\n \n@@ -13269,7 +13259,7 @@ start_function (declspecs, declarator, attrs, flags)\n     }\n   else\n     {\n-      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL_TREE);\n+      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL);\n       /* If the declarator is not suitable for a function definition,\n \t cause a syntax error.  */\n       if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL) return 0;\n@@ -13554,7 +13544,7 @@ start_function (declspecs, declarator, attrs, flags)\n   pushlevel (0);\n   current_binding_level->parm_flag = 1;\n \n-  cplus_decl_attributes (&decl1, NULL_TREE, attrs, 0);\n+  cplus_decl_attributes (&decl1, attrs, 0);\n \n   /* Promote the value to int before returning it.  */\n   if (c_promoting_integer_type_p (restype))\n@@ -14056,7 +14046,7 @@ start_method (declspecs, declarator, attrlist)\n      tree declarator, declspecs, attrlist;\n {\n   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n-\t\t\t\tattrlist);\n+\t\t\t\t&attrlist);\n \n   /* Something too ugly to handle.  */\n   if (fndecl == NULL_TREE)"}, {"sha": "6f1418a3a3e01bcd6d9e15922b075362d13f78c8", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -31,7 +31,7 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator\t\t\tPARAMS ((tree, tree, enum decl_context, int, tree));\n+extern tree grokdeclarator\t\t\tPARAMS ((tree, tree, enum decl_context, int, tree *));\n \n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */"}, {"sha": "28236efb3e5d28af3fa5f7eaaf566254293db405", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1531,7 +1531,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       && TREE_CHAIN (init) == NULL_TREE)\n     init = NULL_TREE;\n \n-  value = grokdeclarator (declarator, declspecs, FIELD, init != 0, attrlist);\n+  value = grokdeclarator (declarator, declspecs, FIELD, init != 0, &attrlist);\n   if (! value || value == error_mark_node)\n     /* friend or constructor went bad.  */\n     return value;\n@@ -1628,8 +1628,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n     value = push_template_decl (value);\n \n   if (attrlist)\n-    cplus_decl_attributes (&value, TREE_PURPOSE (attrlist),\n-\t\t\t   TREE_VALUE (attrlist), 0);\n+    cplus_decl_attributes (&value, attrlist, 0);\n \n   if (TREE_CODE (value) == VAR_DECL)\n     {\n@@ -1679,7 +1678,7 @@ grokbitfield (declarator, declspecs, width)\n      tree declarator, declspecs, width;\n {\n   register tree value = grokdeclarator (declarator, declspecs, BITFIELD,\n-\t\t\t\t\t0, NULL_TREE);\n+\t\t\t\t\t0, NULL);\n \n   if (! value) return NULL_TREE; /* friends went bad.  */\n \n@@ -1735,7 +1734,7 @@ tree\n grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n-  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n+  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL);\n   return mangle_conv_op_name_for_type (t);\n }\n \n@@ -1824,8 +1823,8 @@ grok_function_init (decl, init)\n }\n \f\n void\n-cplus_decl_attributes (decl, attributes, prefix_attributes, flags)\n-     tree *decl, attributes, prefix_attributes;\n+cplus_decl_attributes (decl, attributes, flags)\n+     tree *decl, attributes;\n      int flags;\n {\n   if (*decl == NULL_TREE || *decl == void_type_node)\n@@ -1834,7 +1833,7 @@ cplus_decl_attributes (decl, attributes, prefix_attributes, flags)\n   if (TREE_CODE (*decl) == TEMPLATE_DECL)\n     decl = &DECL_TEMPLATE_RESULT (*decl);\n \n-  decl_attributes (decl, chainon (attributes, prefix_attributes), flags);\n+  decl_attributes (decl, attributes, flags);\n \n   if (TREE_CODE (*decl) == TYPE_DECL)\n     SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (*decl), TREE_TYPE (*decl));\n@@ -2371,17 +2370,9 @@ import_export_class (ctype)\n   if (CLASSTYPE_INTERFACE_ONLY (ctype))\n     return;\n \n-  if ((*targetm.valid_type_attribute) (ctype,\n-\t\t\t\t       TYPE_ATTRIBUTES (ctype),\n-\t\t\t\t       get_identifier (\"dllimport\"),\n-\t\t\t\t       NULL_TREE)\n-      && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))\n+  if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))\n     import_export = -1;\n-  else if ((*targetm.valid_type_attribute) (ctype,\n-\t\t\t\t\t    TYPE_ATTRIBUTES (ctype),\n-\t\t\t\t\t    get_identifier (\"dllexport\"),\n-\t\t\t\t\t    NULL_TREE)\n-\t   && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n+  else if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n     import_export = 1;\n \n   /* If we got -fno-implicit-templates, we import template classes that"}, {"sha": "d6d720cb38069144448d3f4343cbe0416ad031f8", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -309,7 +309,6 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n      int funcdef_flag;\n {\n   int is_friend_template = 0;\n-  tree prefix_attributes, attributes;\n \n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;\n@@ -435,19 +434,8 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n      handle them in start_decl_1, but since this is a friend decl start_decl_1\n      never gets to see it.  */\n \n-  if (attrlist)\n-    {\n-      attributes = TREE_PURPOSE (attrlist);\n-      prefix_attributes = TREE_VALUE (attrlist);\n-    }\n-  else\n-    {\n-      attributes = NULL_TREE;\n-      prefix_attributes = NULL_TREE;\n-    } \n-\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n-  cplus_decl_attributes (&decl, attributes, prefix_attributes, 0);\n+  cplus_decl_attributes (&decl, attrlist, 0);\n \n   return decl;\n }"}, {"sha": "9801c3817fa7963a2972df961ae6ad482412deae", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -164,7 +164,7 @@ parse_field (declarator, attributes, asmspec, init)\n      tree declarator, attributes, asmspec, init;\n {\n   tree d = grokfield (declarator, current_declspecs, init, asmspec,\n-\t\t      build_tree_list (attributes, prefix_attributes));\n+\t\t      chainon (attributes, prefix_attributes));\n   decl_type_access_control (d);\n   return d;\n }\n@@ -182,7 +182,7 @@ parse_bitfield (declarator, attributes, width)\n      tree declarator, attributes, width;\n {\n   tree d = grokbitfield (declarator, current_declspecs, width);\n-  cplus_decl_attributes (&d, attributes, prefix_attributes, 0);\n+  cplus_decl_attributes (&d, chainon (attributes, prefix_attributes), 0);\n   decl_type_access_control (d);\n   return d;\n }\n@@ -2639,11 +2639,9 @@ component_decl_1:\n \t\t  $$ = NULL_TREE; \n \t\t}\n \t| notype_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n-\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n \t| constructor_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n-\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n \t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n \t| error\n@@ -2661,10 +2659,9 @@ component_decl_1:\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  $$ = grokfield ($2, specs, $5, $3,\n-\t\t\t\t  build_tree_list ($4, attrs)); }\n+\t\t\t\t  chainon ($4, attrs)); }\n \t| component_constructor_declarator maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n-\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n "}, {"sha": "292513fb43e85fd4a755d7491d439bd025c6725c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1929,7 +1929,7 @@ process_template_parm (list, next)\n       my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n       /* is a const-param */\n       parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n-\t\t\t     PARM, 0, NULL_TREE);\n+\t\t\t     PARM, 0, NULL);\n \n       /* [temp.param]\n \n@@ -9356,7 +9356,7 @@ void\n do_decl_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n {\n-  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, NULL_TREE);\n+  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, NULL);\n   tree result = NULL_TREE;\n   int extern_p = 0;\n "}, {"sha": "32783adc728d26ada242d74a08621ce3cfe275f3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 130, "deletions": 89, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -50,6 +50,10 @@ static tree verify_stmt_tree_r PARAMS ((tree *, int *, void *));\n static tree find_tree_r PARAMS ((tree *, int *, void *));\n extern int cp_statement_code_p PARAMS ((enum tree_code));\n \n+static tree handle_java_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_com_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static tree handle_init_priority_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+\n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n    non-zero, rvalues of class type are considered lvalues.  */\n@@ -2182,108 +2186,145 @@ pod_type_p (t)\n   return 1;\n }\n \n-/* Return a 1 if ATTR_NAME and ATTR_ARGS denote a valid C++-specific\n-   attribute for either declaration DECL or type TYPE and 0 otherwise.\n-   Plugged into valid_lang_attribute.  */\n-\n-int\n-cp_valid_lang_attribute (attr_name, attr_args, decl, type)\n-  tree attr_name;\n-  tree attr_args ATTRIBUTE_UNUSED;\n-  tree decl ATTRIBUTE_UNUSED;\n-  tree type ATTRIBUTE_UNUSED;\n+/* Table of valid C++ attributes.  */\n+const struct attribute_spec cp_attribute_table[] =\n {\n-  if (is_attribute_p (\"java_interface\", attr_name))\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"java_interface\", 0, 0, false, false, false, handle_java_interface_attribute },\n+  { \"com_interface\",  0, 0, false, false, false, handle_com_interface_attribute },\n+  { \"init_priority\",  1, 1, true,  false, false, handle_init_priority_attribute },\n+  { NULL,             0, 0, false, false, false, NULL }\n+};\n+\n+/* Handle a \"java_interface\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_java_interface_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node)\n+      || !CLASS_TYPE_P (*node)\n+      || !TYPE_FOR_JAVA (*node))\n     {\n-      if (attr_args != NULL_TREE\n-\t  || decl != NULL_TREE\n-\t  || ! CLASS_TYPE_P (type)\n-\t  || ! TYPE_FOR_JAVA (type))\n-\t{\n-\t  error (\"`java_interface' attribute can only be applied to Java class definitions\");\n-\t  return 0;\n-\t}\n-      TYPE_JAVA_INTERFACE (type) = 1;\n-      return 1;\n+      error (\"`%s' attribute can only be applied to Java class definitions\",\n+\t     IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n     }\n-  if (is_attribute_p (\"com_interface\", attr_name))\n-    {\n-      static int warned;\n-      if (attr_args != NULL_TREE\n-\t  || decl != NULL_TREE\n-\t  || ! CLASS_TYPE_P (type)\n-\t  || type != TYPE_MAIN_VARIANT (type))\n-\t{\n-\t  warning (\"`com_interface' attribute can only be applied to class definitions\");\n-\t  return 0;\n-\t}\n+  if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+    *node = build_type_copy (*node);\n+  TYPE_JAVA_INTERFACE (*node) = 1;\n \n-      if (! warned++)\n-\twarning (\"\\\n-`com_interface' is obsolete; g++ vtables are now COM-compatible by default\");\n-      return 1;\n-    }\n-  else if (is_attribute_p (\"init_priority\", attr_name))\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"com_interface\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_com_interface_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  static int warned;\n+\n+  *no_add_attrs = true;\n+\n+  if (DECL_P (*node)\n+      || !CLASS_TYPE_P (*node)\n+      || *node != TYPE_MAIN_VARIANT (*node))\n     {\n-      tree initp_expr = (attr_args ? TREE_VALUE (attr_args): NULL_TREE);\n-      int pri;\n+      warning (\"`%s' attribute can only be applied to class definitions\",\n+\t       IDENTIFIER_POINTER (name));\n+      return NULL_TREE;\n+    }\n \n-      if (initp_expr)\n-\tSTRIP_NOPS (initp_expr);\n+  if (!warned++)\n+    warning (\"`%s' is obsolete; g++ vtables are now COM-compatible by default\",\n+\t     IDENTIFIER_POINTER (name));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"init_priority\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_init_priority_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree initp_expr = TREE_VALUE (args);\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+  int pri;\n+\n+  STRIP_NOPS (initp_expr);\n \t  \n-      if (!initp_expr || TREE_CODE (initp_expr) != INTEGER_CST)\n-\t{\n-\t  error (\"requested init_priority is not an integer constant\");\n-\t  return 0;\n-\t}\n+  if (!initp_expr || TREE_CODE (initp_expr) != INTEGER_CST)\n+    {\n+      error (\"requested init_priority is not an integer constant\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n \n-      pri = TREE_INT_CST_LOW (initp_expr);\n+  pri = TREE_INT_CST_LOW (initp_expr);\n \t\n-      type = strip_array_types (type);\n-\n-      if (decl == NULL_TREE\n-\t  || TREE_CODE (decl) != VAR_DECL\n-\t  || ! TREE_STATIC (decl)\n-\t  || DECL_EXTERNAL (decl)\n-\t  || (TREE_CODE (type) != RECORD_TYPE\n-\t      && TREE_CODE (type) != UNION_TYPE)\n-\t  /* Static objects in functions are initialized the\n-\t     first time control passes through that\n-\t     function. This is not precise enough to pin down an\n-\t     init_priority value, so don't allow it. */\n-\t  || current_function_decl) \n-\t{\n-\t  error (\"can only use init_priority attribute on file-scope definitions of objects of class type\");\n-\t  return 0;\n-\t}\n-\n-      if (pri > MAX_INIT_PRIORITY || pri <= 0)\n-\t{\n-\t  error (\"requested init_priority is out of range\");\n-\t  return 0;\n-\t}\n+  type = strip_array_types (type);\n+\n+  if (decl == NULL_TREE\n+      || TREE_CODE (decl) != VAR_DECL\n+      || !TREE_STATIC (decl)\n+      || DECL_EXTERNAL (decl)\n+      || (TREE_CODE (type) != RECORD_TYPE\n+\t  && TREE_CODE (type) != UNION_TYPE)\n+      /* Static objects in functions are initialized the\n+\t first time control passes through that\n+\t function. This is not precise enough to pin down an\n+\t init_priority value, so don't allow it. */\n+      || current_function_decl) \n+    {\n+      error (\"can only use `%s' attribute on file-scope definitions of objects of class type\",\n+\t     IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n \n-      /* Check for init_priorities that are reserved for\n-\t language and runtime support implementations.*/\n-      if (pri <= MAX_RESERVED_INIT_PRIORITY)\n-\t{\n-\t  warning \n-\t    (\"requested init_priority is reserved for internal use\");\n-\t}\n+  if (pri > MAX_INIT_PRIORITY || pri <= 0)\n+    {\n+      error (\"requested init_priority is out of range\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n \n-      if (SUPPORTS_INIT_PRIORITY)\n-\t{\n-\t  DECL_INIT_PRIORITY (decl) = pri;\n-\t  return 1;\n-\t}\n-      else\n-\t{\n-\t  error (\"init_priority attribute is not supported on this platform\");\n-\t  return 0;\n-\t}\n+  /* Check for init_priorities that are reserved for\n+     language and runtime support implementations.*/\n+  if (pri <= MAX_RESERVED_INIT_PRIORITY)\n+    {\n+      warning \n+\t(\"requested init_priority is reserved for internal use\");\n     }\n \n-  return 0;\n+  if (SUPPORTS_INIT_PRIORITY)\n+    {\n+      DECL_INIT_PRIORITY (decl) = pri;\n+      return NULL_TREE;\n+    }\n+  else\n+    {\n+      error (\"`%s' attribute is not supported on this platform\",\n+\t     IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n }\n \n /* Return a new PTRMEM_CST of the indicated TYPE.  The MEMBER is the"}, {"sha": "350c9bca2457b3eed43ecba105e50500b481ccbe", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1658,14 +1658,11 @@ to the same declaration or type, or @code{NULL_TREE} if there are no\n further attributes in the list.\n \n Attributes may be attached to declarations and to types; these\n-attributes may be accessed with the following macros.  At present only\n-machine-dependent attributes are stored in this way (other attributes\n-cause changes to the declaration or type or to other internal compiler\n-data structures, but are not themselves stored along with the\n-declaration or type), but in future all attributes may be stored like\n-this.\n-\n-@deftypefn {Tree Macro} tree DECL_MACHINE_ATTRIBUTES (tree @var{decl})\n+attributes may be accessed with the following macros.  All attributes\n+are stored in this way, and many also cause other changes to the\n+declaration or type or to other internal compiler data structures.\n+\n+@deftypefn {Tree Macro} tree DECL_ATTRIBUTES (tree @var{decl})\n This macro returns the attributes on the declaration @var{decl}.\n @end deftypefn\n "}, {"sha": "ea60b57fbf6881398ac5baa2c83ac36184134261", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -2449,6 +2449,14 @@ language.  Some details may vary for C++ and Objective-C@.  Because of\n infelicities in the grammar for attributes, some forms described here\n may not be successfully parsed in all cases.\n \n+There are some problems with the semantics of attributes in C++.  For\n+example, there are no manglings for attributes, although they may affect\n+code generation, so problems may arise when attributed types are used in\n+conjunction with templates or overloading.  Similarly, @code{typeid}\n+does not distinguish between types with different attributes.  Support\n+for attributes in C++ may be restricted in future to attributes on\n+declarations only, but not on nested declarators.\n+\n @xref{Function Attributes}, for details of the semantics of attributes\n applying to functions.  @xref{Variable Attributes}, for details of the\n semantics of attributes applying to variables.  @xref{Type Attributes},\n@@ -2520,9 +2528,8 @@ defined is not complete until after the attribute specifiers.\n Otherwise, an attribute specifier appears as part of a declaration,\n counting declarations of unnamed parameters and type names, and relates\n to that declaration (which may be nested in another declaration, for\n-example in the case of a parameter declaration).  In future, attribute\n-specifiers in some places may however apply to a particular declarator\n-within a declaration instead; these cases are noted below.  Where an\n+example in the case of a parameter declaration), or to a particular declarator\n+within a declaration.  Where an\n attribute specifier is applied to a parameter declared as a function or\n an array, it should apply to the function or array rather than the\n pointer to which the parameter is implicitly converted, but this is not\n@@ -2597,11 +2604,11 @@ ignored.\n \n An attribute specifier list may appear at the start of a nested\n declarator.  At present, there are some limitations in this usage: the\n-attributes apply to the identifier declared, rather than to a specific\n-declarator.  When attribute specifiers follow the @code{*} of a pointer\n+attributes correctly apply to the declarator, but for most individual\n+attributes the semantics this implies are not implemented.\n+When attribute specifiers follow the @code{*} of a pointer\n declarator, they may be mixed with any type qualifiers present.\n-The following describes intended future\n-semantics which make this syntax more useful only.  It will make the\n+The following describes the formal semantics of this syntax.  It will make the\n most sense if you are familiar with the formal specification of\n declarators in the ISO C standard.\n \n@@ -2642,8 +2649,26 @@ char *__attribute__((aligned(8))) *f;\n \n @noindent\n specifies the type ``pointer to 8-byte-aligned pointer to @code{char}''.\n-Note again that this describes intended future semantics, not current\n-implementation.\n+Note again that this does not work with most attributes; for example,\n+the usage of @samp{aligned} and @samp{noreturn} attributes given above\n+is not yet supported.\n+\n+For compatibility with existing code written for compiler versions that\n+did not implement attributes on nested declarators, some laxity is\n+allowed in the placing of attributes.  If an attribute that only applies\n+to types is applied to a declaration, it will be treated as applying to\n+the type of that declaration.  If an attribute that only applies to\n+declarations is applied to the type of a declaration, it will be treated\n+as applying to that declaration; and, for compatibility with code\n+placing the attributes immediately before the identifier declared, such\n+an attribute applied to a function return type will be treated as\n+applying to the function type, and such an attribute applied to an array\n+element type will be treated as applying to the array type.  If an\n+attribute that only applies to function types is applied to a\n+pointer-to-function type, it will be treated as applying to the pointer\n+target type; if such an attribute is applied to a function return type\n+that is not a pointer-to-function type, it will be treated as applying\n+to the function type.\n \n @node Function Prototypes\n @section Prototypes and Old-Style Function Definitions"}, {"sha": "721e16124d059caf0058d2a789cc75144e3595da", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 88, "deletions": 82, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -48,6 +48,7 @@ through the macros defined in the @file{.h} file.\n * Debugging Info::      Defining the format of debugging output.\n * Cross-compilation::   Handling floating point for cross-compilers.\n * Mode Switching::      Insertion of mode-switching instructions.\n+* Target Attributes::   Defining target-specific uses of @code{__attribute__}.\n * Misc::                Everything else.\n @end menu\n \n@@ -70,8 +71,8 @@ macros for which the default definition is inappropriate.  For example:\n \n /* @r{Initialize the GCC target structure.}  */\n \n-#undef TARGET_VALID_TYPE_ATTRIBUTE\n-#define TARGET_VALID_TYPE_ATTRIBUTE @var{machine}_valid_type_attribute_p\n+#undef TARGET_COMP_TYPE_ATTRIBUTES\n+#define TARGET_COMP_TYPE_ATTRIBUTES @var{machine}_comp_type_attributes\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n @end smallexample\n@@ -2528,7 +2529,7 @@ This describes the stack layout and calling conventions.\n * Caller Saves::\n * Function Entry::\n * Profiling::\n-* Inlining and Tail Calls::\n+* Tail Calls::\n @end menu\n \n @node Frame Layout\n@@ -3222,7 +3223,7 @@ after the function returns.\n @var{fundecl} is a C variable whose value is a tree node that describes\n the function in question.  Normally it is a node of type\n @code{FUNCTION_DECL} that describes the declaration of the function.\n-From this you can obtain the @code{DECL_MACHINE_ATTRIBUTES} of the function.\n+From this you can obtain the @code{DECL_ATTRIBUTES} of the function.\n \n @var{funtype} is a C variable whose value is a tree node that\n describes the function in question.  Normally it is a node of type\n@@ -4204,18 +4205,11 @@ profiling when the frame pointer is omitted.\n \n @end table\n \n-@node Inlining and Tail Calls\n-@subsection Permitting inlining and tail calls\n-@cindex inlining\n+@node Tail Calls\n+@subsection Permitting tail calls\n+@cindex tail calls\n \n @table @code\n-@findex FUNCTION_ATTRIBUTE_INLINABLE_P\n-@item FUNCTION_ATTRIBUTE_INLINABLE_P (@var{decl})\n-A C expression that evaluates to true if it is ok to inline @var{decl}\n-into the current function, despite its having target-specific\n-attributes.  By default, if a function has a target specific attribute\n-attached to it, it will not be inlined.\n-\n @findex FUNCTION_OK_FOR_SIBCALL\n @item FUNCTION_OK_FOR_SIBCALL (@var{decl})\n A C expression that evaluates to true if it is ok to perform a sibling\n@@ -8031,6 +8025,85 @@ Generate one or more insns to set @var{entity} to @var{mode}.\n the insn(s) are to be inserted.\n @end table\n \n+@node Target Attributes\n+@section Defining target-specific uses of @code{__attribute__}\n+@cindex target attributes\n+@cindex machine attributes\n+@cindex attributes, target-specific\n+\n+Target-specific attributes may be defined for functions, data and types.\n+These are described using the following target hooks; they also need to\n+be documented in @file{extend.texi}.\n+\n+@deftypevr {Target Hook} {const struct attribute_spec *} TARGET_ATTRIBUTE_TABLE\n+If defined, this target hook points to an array of @samp{struct\n+attribute_spec} (defined in @file{tree.h}) specifying the machine\n+specific attributes for this target and some of the restrictions on the\n+entities to which these attributes are applied and the arguments they\n+take.\n+@end deftypevr\n+\n+@deftypefn {Target Hook} int TARGET_COMP_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n+If defined, this target hook is a function which returns zero if the attributes on\n+@var{type1} and @var{type2} are incompatible, one if they are compatible,\n+and two if they are nearly compatible (which causes a warning to be\n+generated).  If this is not defined, machine-specific attributes are\n+supposed always to be compatible.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree @var{type})\n+If defined, this target hook is a function which assigns default attributes to\n+newly defined @var{type}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n+Define this target hook if the merging of type attributes needs special\n+handling.  If defined, the result is a list of the combined\n+@code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed\n+that @code{comptypes} has already been called and returned 1.  This\n+function may call @code{merge_attributes} to handle machine-independent\n+merging.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_MERGE_DECL_ATTRIBUTES (tree @var{olddecl}, tree @var{newdecl})\n+Define this target hook if the merging of decl attributes needs special\n+handling.  If defined, the result is a list of the combined\n+@code{DECL_ATTRIBUTES} of @var{olddecl} and @var{newdecl}.\n+@var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of\n+when this is needed are when one attribute overrides another, or when an\n+attribute is nullified by a subsequent definition.  This function may\n+call @code{merge_attributes} to handle machine-independent merging.\n+\n+@findex TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+If the only target-specific handling you require is @samp{dllimport} for\n+Windows targets, you should define the macro\n+@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}.  This links in a function\n+called @code{merge_dllimport_decl_attributes} which can then be defined\n+as the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  This is done\n+in @file{i386/cygwin.h} and @file{i386/i386.c}, for example.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_INSERT_ATTRIBUTES (tree @var{node}, tree *@var{attr_ptr})\n+Define this target hook if you want to be able to add attributes to a decl\n+when it is being created.  This is normally useful for back ends which\n+wish to implement a pragma by using the attributes which correspond to\n+the pragma's effect.  The @var{node} argument is the decl which is being\n+created.  The @var{attr_ptr} argument is a pointer to the attribute list\n+for this decl.  The list itself should not be modified, since it may be\n+shared with other decls, but attributes may be chained on the head of\n+the list and @code{*@var{attr_ptr}} modified to point to the new\n+attributes, or a copy of the list may be made if further changes are\n+needed.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (tree @var{fndecl})\n+@cindex inlining\n+This target hook returns @code{true} if it is ok to inline @var{fndecl}\n+into the current function, despite its having target-specific\n+attributes, @code{false} otherwise.  By default, if a function has a\n+target specific attribute attached to it, it will not be inlined.\n+@end deftypefn\n+\n @node Misc\n @section Miscellaneous Parameters\n @cindex parameters, miscellaneous\n@@ -8404,7 +8477,7 @@ other compilers for the same target.  In general, we discourage\n definition of target-specific pragmas for GCC@.\n \n If the pragma can be implemented by attributes then you should consider\n-defining @samp{INSERT_ATTRIBUTES} as well.\n+defining the target hook @samp{TARGET_INSERT_ATTRIBUTES} as well.\n \n Preprocessor macros that appear on pragma lines are not expanded.  All\n @samp{#pragma} directives that do not match any registered pragma are\n@@ -8484,74 +8557,7 @@ pack value of zero resets the behaviour to the default.  Successive\n invocations of this pragma cause the previous values to be stacked, so\n that invocations of @samp{#pragma pack(pop)} will return to the previous\n value.\n-@end table\n-\n-@deftypefn {Target Hook} int TARGET_VALID_DECL_ATTRIBUTE (tree @var{decl}, tree @var{attributes}, tree @var{identifier}, tree @var{args})\n-If defined, this target hook is a function which returns nonzero if @var{identifier} with\n-arguments @var{args} is a valid machine specific attribute for @var{decl}.\n-The attributes in @var{attributes} have previously been assigned to @var{decl}.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} int TARGET_VALID_TYPE_ATTRIBUTE (tree @var{type}, tree @var{attributes}, tree @var{identifier}, tree @var{args})\n-If defined, this target hook is a function which returns nonzero if @var{identifier} with\n-arguments @var{args} is a valid machine specific attribute for @var{type}.\n-The attributes in @var{attributes} have previously been assigned to @var{type}.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} int TARGET_COMP_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n-If defined, this target hook is a function which returns zero if the attributes on\n-@var{type1} and @var{type2} are incompatible, one if they are compatible,\n-and two if they are nearly compatible (which causes a warning to be\n-generated).  If this is not defined, machine-specific attributes are\n-supposed always to be compatible.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_SET_DEFAULT_TYPE_ATTRIBUTES (tree @var{type})\n-If defined, this target hook is a function which assigns default attributes to\n-newly defined @var{type}.\n-@end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n-Define this target hook if the merging of type attributes needs special\n-handling.  If defined, the result is a list of the combined\n-@code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed\n-that @code{comptypes} has already been called and returned 1.  This\n-function may call @code{merge_attributes} to handle machine-independent\n-merging.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} tree TARGET_MERGE_DECL_ATTRIBUTES (tree @var{olddecl}, tree @var{newdecl})\n-Define this target hook if the merging of decl attributes needs special\n-handling.  If defined, the result is a list of the combined\n-@code{DECL_MACHINE_ATTRIBUTES} of @var{olddecl} and @var{newdecl}.\n-@var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of\n-when this is needed are when one attribute overrides another, or when an\n-attribute is nullified by a subsequent definition.  This function may\n-call @code{merge_attributes} to handle machine-independent merging.\n-\n-@findex TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-If the only target-specific handling you require is @samp{dllimport} for\n-Windows targets, you should define the macro\n-@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}.  This links in a function\n-called @code{merge_dllimport_decl_attributes} which can then be defined\n-as the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  This is done\n-in @file{i386/cygwin.h} and @file{i386/i386.c}, for example.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_INSERT_ATTRIBUTES (tree @var{node}, tree *@var{attr_ptr})\n-Define this target hook if you want to be able to add attributes to a decl\n-when it is being created.  This is normally useful for back ends which\n-wish to implement a pragma by using the attributes which correspond to\n-the pragma's effect.  The @var{node} argument is the decl which is being\n-created.  The @var{attr_ptr} argument is a pointer to the attribute list\n-for this decl.  The list itself should not be modified, since it may be\n-shared with other decls, but attributes may be chained on the head of\n-the list and @code{*@var{attr_ptr}} modified to point to the new\n-attributes, or a copy of the list may be made if further changes are\n-needed.\n-@end deftypefn\n-\n-@table @code\n @findex DOLLARS_IN_IDENTIFIERS\n @item DOLLARS_IN_IDENTIFIERS\n Define this macro to control use of the character @samp{$} in identifier"}, {"sha": "80de3802fed257c691187643252d68a9dc958061", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -453,7 +453,7 @@ ggc_mark_trees ()\n \t  ggc_mark_tree (DECL_INITIAL (t));\n \t  ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n \t  ggc_mark_tree (DECL_SECTION_NAME (t));\n-\t  ggc_mark_tree (DECL_MACHINE_ATTRIBUTES (t));\n+\t  ggc_mark_tree (DECL_ATTRIBUTES (t));\n \t  if (DECL_RTL_SET_P (t))\n \t    ggc_mark_rtx (DECL_RTL (t));\n \t  ggc_mark_rtx (DECL_LIVE_RANGE_RTL (t));"}, {"sha": "7887b36cf18fba8ac97ea3fffdd79abb1183f071", "filename": "gcc/integrate.c", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"loop.h\"\n #include \"params.h\"\n #include \"ggc.h\"\n+#include \"target.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -63,12 +64,6 @@ extern struct obstack *function_maybepermanent_obstack;\n    ? (1 + (3 * list_length (DECL_ARGUMENTS (DECL))) / 2) \\\n    : (8 * (8 + list_length (DECL_ARGUMENTS (DECL)))))\n #endif\n-\n-/* Decide whether a function with a target specific attribute\n-   attached can be inlined.  By default we disallow this.  */\n-#ifndef FUNCTION_ATTRIBUTE_INLINABLE_P\n-#define FUNCTION_ATTRIBUTE_INLINABLE_P(FNDECL) 0\n-#endif\n \f\n \n /* Private type used by {get/has}_func_hard_reg_initial_val.  */\n@@ -82,6 +77,8 @@ typedef struct initial_value_struct {\n   initial_value_pair *entries;\n } initial_value_struct;\n \n+static bool function_attribute_inlinable_p PARAMS ((tree));\n+\n static void setup_initial_hard_reg_value_integration PARAMS ((struct function *, struct inline_remap *));\n \n static rtvec initialize_for_inline\tPARAMS ((tree));\n@@ -130,6 +127,38 @@ get_label_from_map (map, i)\n   return x;\n }\n \n+/* Return false if the function FNDECL cannot be inlined on account of its\n+   attributes, true otherwise.  */\n+static bool\n+function_attribute_inlinable_p (fndecl)\n+     tree fndecl;\n+{\n+  bool has_machine_attr = false;\n+  tree a;\n+\n+  for (a = DECL_ATTRIBUTES (fndecl); a; a = TREE_CHAIN (a))\n+    {\n+      tree name = TREE_PURPOSE (a);\n+      int i;\n+\n+      for (i = 0; targetm.attribute_table[i].name != NULL; i++)\n+\t{\n+\t  if (is_attribute_p (targetm.attribute_table[i].name, name))\n+\t    {\n+\t      has_machine_attr = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (has_machine_attr)\n+\tbreak;\n+    }\n+\n+  if (has_machine_attr)\n+    return (*targetm.function_attribute_inlinable_p) (fndecl);\n+  else\n+    return true;\n+}\n+\n /* Zero if the current function (whose FUNCTION_DECL is FNDECL)\n    is safe and reasonable to integrate into other functions.\n    Nonzero means value is a warning msgid with a single %s\n@@ -250,9 +279,8 @@ function_cannot_inline_p (fndecl)\n \n   /* If the function has a target specific attribute attached to it,\n      then we assume that we should not inline it.  This can be overriden\n-     by the target if it defines FUNCTION_ATTRIBUTE_INLINABLE_P.  */\n-  if (DECL_MACHINE_ATTRIBUTES (fndecl)\n-      && ! FUNCTION_ATTRIBUTE_INLINABLE_P (fndecl))\n+     by the target if it defines TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P.  */\n+  if (!function_attribute_inlinable_p (fndecl))\n     return N_(\"function with target specific attribute(s) cannot be inlined\");\n \n   return NULL;"}, {"sha": "f4476ba2d47ec52f4ac9c8f2f0732f3c52af01a4", "filename": "gcc/print-tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,5 +1,5 @@\n /* Prints out tree in human readable form - GNU C-compiler\n-   Copyright (C) 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Copyright (C) 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -433,8 +433,8 @@ print_node (file, prefix, node, indent)\n \t}\n \n       print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n-      print_node_brief (file, \"machine_attributes\",\n-\t\t\tDECL_MACHINE_ATTRIBUTES (node), indent + 4);\n+      print_node_brief (file, \"attributes\",\n+\t\t\tDECL_ATTRIBUTES (node), indent + 4);\n       print_node_brief (file, \"abstract_origin\",\n \t\t\tDECL_ABSTRACT_ORIGIN (node), indent + 4);\n "}, {"sha": "4b298bc52887a6b5f02d7997d96945ffbe3f5c86", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -107,11 +107,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n /* All in tree.c.  */\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n #define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n-#define TARGET_VALID_DECL_ATTRIBUTE default_valid_attribute_p\n-#define TARGET_VALID_TYPE_ATTRIBUTE default_valid_attribute_p\n+#define TARGET_ATTRIBUTE_TABLE default_target_attribute_table\n #define TARGET_COMP_TYPE_ATTRIBUTES default_comp_type_attributes\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES default_set_default_type_attributes\n #define TARGET_INSERT_ATTRIBUTES default_insert_attributes\n+#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P default_function_attribute_inlinable_p\n \n /* In builtins.c.  */\n #define TARGET_INIT_BUILTINS default_init_builtins\n@@ -129,11 +129,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_SCHED,\t\t\t\t\t\\\n   TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n   TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n-  TARGET_VALID_DECL_ATTRIBUTE,\t\t\t\\\n-  TARGET_VALID_TYPE_ATTRIBUTE,\t\t\t\\\n+  TARGET_ATTRIBUTE_TABLE,\t\t\t\\\n   TARGET_COMP_TYPE_ATTRIBUTES,\t\t\t\\\n   TARGET_SET_DEFAULT_TYPE_ATTRIBUTES,\t\t\\\n   TARGET_INSERT_ATTRIBUTES,\t\t\t\\\n+  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n   TARGET_INIT_BUILTINS,\t\t\t\t\\\n   TARGET_EXPAND_BUILTIN,\t\t\t\\\n   TARGET_SECTION_TYPE_FLAGS,\t\t\t\\"}, {"sha": "f7eca62368ecffaab66c2d0d8106a8f1f107e89b", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -121,17 +121,8 @@ struct gcc_target\n   /* Given two types, merge their attributes and return the result.  */\n   tree (* merge_type_attributes) PARAMS ((tree, tree));\n \n-  /* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine\n-     specific attribute for DECL.  The attributes in ATTRIBUTES have\n-     previously been assigned to DECL.  */\n-  int (* valid_decl_attribute) PARAMS ((tree decl, tree attributes,\n-\t\t\t\t\ttree identifier, tree args));\n-\n-  /* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine\n-     specific attribute for TYPE.  The attributes in ATTRIBUTES have\n-     previously been assigned to TYPE.  */\n-  int (* valid_type_attribute) PARAMS ((tree type, tree attributes,\n-\t\t\t\t\ttree identifier, tree args));\n+  /* Table of machine attributes and functions to handle them.  */\n+  const struct attribute_spec *attribute_table;\n \n   /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n      one if they are compatible and two if they are nearly compatible\n@@ -144,6 +135,10 @@ struct gcc_target\n   /* Insert attributes on the newly created DECL.  */\n   void (* insert_attributes) PARAMS ((tree decl, tree *attributes));\n \n+  /* Return true if FNDECL (which has at least one machine attribute)\n+     can be inlined despite its machine attributes, false otherwise.  */\n+  bool (* function_attribute_inlinable_p) PARAMS ((tree fndecl));\n+\n   /* Set up target-specific built-in functions.  */\n   void (* init_builtins) PARAMS ((void));\n "}, {"sha": "74508a6c9419080c4bb50db6c4bd98ff78e5966e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,3 +1,8 @@\n+2001-09-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\tTable-driven attributes.\n+\t* g++.dg/ext/attrib1.C: New test.\n+\n 2001-09-20  DJ Delorie  <dj@redhat.com>\n \n \t* gcc.dg/20000926-1.c: Update expected warning messages."}, {"sha": "2bd69e82a541af3217a6f49f5038354c22669294", "filename": "gcc/testsuite/g++.dg/ext/attrib1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib1.C?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -0,0 +1,10 @@\n+// Test for interpretation of attribute immediately before function name.\n+// Origin: Joseph Myers <jsm28@cam.ac.uk>\n+// { dg-do compile }\n+\n+// An attribute immediately before the function name should in this\n+// case properly apply to the return type, but compatibility with\n+// existing code using this form requires it to apply to the function\n+// type instead in the case of attributes applying to function types,\n+// and to the declaration in the case of attributes applying to declarations.\n+int ****__attribute__((format(printf, 1, 2))) foo(const char *, ...);"}, {"sha": "1741f6a7f024f651503828c60464e93d1f2edbea", "filename": "gcc/tree.c", "status": "modified", "additions": 48, "deletions": 138, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -2605,14 +2605,14 @@ build_expr_wfl (node, file, line, col)\n   return wfl;\n }\n \f\n-/* Return a declaration like DDECL except that its DECL_MACHINE_ATTRIBUTE\n+/* Return a declaration like DDECL except that its DECL_ATTRIBUTES\n    is ATTRIBUTE.  */\n \n tree\n build_decl_attribute_variant (ddecl, attribute)\n      tree ddecl, attribute;\n {\n-  DECL_MACHINE_ATTRIBUTES (ddecl) = attribute;\n+  DECL_ATTRIBUTES (ddecl) = attribute;\n   return ddecl;\n }\n \n@@ -2670,19 +2670,6 @@ build_type_attribute_variant (ttype, attribute)\n   return ttype;\n }\n \n-/* Default value of targetm.valid_decl_attribute_p and\n-   targetm.valid_type_attribute_p that always returns false.  */\n-\n-int\n-default_valid_attribute_p (attr_name, attr_args, decl, type)\n-     tree attr_name ATTRIBUTE_UNUSED;\n-     tree attr_args ATTRIBUTE_UNUSED;\n-     tree decl ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n /* Default value of targetm.comp_type_attributes that always returns 1.  */\n \n int\n@@ -2710,116 +2697,20 @@ default_insert_attributes (decl, attr_ptr)\n {\n }\n \n-/* Return 1 if ATTR_NAME and ATTR_ARGS is valid for either declaration\n-   DECL or type TYPE and 0 otherwise.  Validity is determined the\n-   target functions valid_decl_attribute and valid_machine_attribute.  */\n-\n-int\n-valid_machine_attribute (attr_name, attr_args, decl, type)\n-     tree attr_name;\n-     tree attr_args;\n-     tree decl;\n-     tree type;\n+/* Default value of targetm.attribute_table that is empty.  */\n+const struct attribute_spec default_target_attribute_table[] =\n {\n-  tree type_attrs;\n-\n-  if (TREE_CODE (attr_name) != IDENTIFIER_NODE)\n-    abort ();\n-\n-  if (decl)\n-    {\n-      tree decl_attrs = DECL_MACHINE_ATTRIBUTES (decl);\n-\n-      if ((*targetm.valid_decl_attribute) (decl, decl_attrs, attr_name,\n-\t\t\t\t\t   attr_args))\n-\t{\n-\t  tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n-\t\t\t\t\tdecl_attrs);\n-\n-\t  if (attr != NULL_TREE)\n-\t    {\n-\t      /* Override existing arguments.  Declarations are unique\n-\t\t so we can modify this in place.  */\n-\t      TREE_VALUE (attr) = attr_args;\n-\t    }\n-\t  else\n-\t    {\n-\t      decl_attrs = tree_cons (attr_name, attr_args, decl_attrs);\n-\t      decl = build_decl_attribute_variant (decl, decl_attrs);\n-\t    }\n-\n-\t  /* Don't apply the attribute to both the decl and the type.  */\n-\t  return 1;\n-\t}\n-    }\n-\n-  type_attrs = TYPE_ATTRIBUTES (type);\n-  if ((*targetm.valid_type_attribute) (type, type_attrs, attr_name,\n-\t\t\t\t       attr_args))\n-    {\n-      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n-\t\t\t\t    type_attrs);\n-\n-      if (attr != NULL_TREE)\n-\t{\n-\t  /* Override existing arguments.  ??? This currently\n-\t     works since attribute arguments are not included in\n-\t     `attribute_hash_list'.  Something more complicated\n-\t     may be needed in the future.  */\n-\t  TREE_VALUE (attr) = attr_args;\n-\t}\n-      else\n-\t{\n-\t  /* If this is part of a declaration, create a type variant,\n-\t     otherwise, this is part of a type definition, so add it\n-\t     to the base type.  */\n-\t  type_attrs = tree_cons (attr_name, attr_args, type_attrs);\n-\t  if (decl != 0)\n-\t    type = build_type_attribute_variant (type, type_attrs);\n-\t  else\n-\t    TYPE_ATTRIBUTES (type) = type_attrs;\n-\t}\n-\n-      if (decl)\n-\tTREE_TYPE (decl) = type;\n-\n-      return 1;\n-    }\n-  /* Handle putting a type attribute on pointer-to-function-type\n-     by putting the attribute on the function type.  */\n-  else if (POINTER_TYPE_P (type)\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t   && (*targetm.valid_type_attribute) (TREE_TYPE (type), type_attrs,\n-\t\t\t\t\t       attr_name, attr_args))\n-    {\n-      tree inner_type = TREE_TYPE (type);\n-      tree inner_attrs = TYPE_ATTRIBUTES (inner_type);\n-      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n-\t\t\t\t    type_attrs);\n-\n-      if (attr != NULL_TREE)\n-\tTREE_VALUE (attr) = attr_args;\n-      else\n-\t{\n-\t  inner_attrs = tree_cons (attr_name, attr_args, inner_attrs);\n-\t  inner_type = build_type_attribute_variant (inner_type,\n-\t\t\t\t\t\t     inner_attrs);\n-\t}\n-\n-      if (decl)\n-\tTREE_TYPE (decl) = build_pointer_type (inner_type);\n-      else\n-\t{\n-\t  /* Clear TYPE_POINTER_TO for the old inner type, since\n-\t     `type' won't be pointing to it anymore.  */\n-\t  TYPE_POINTER_TO (TREE_TYPE (type)) = NULL_TREE;\n-\t  TREE_TYPE (type) = inner_type;\n-\t}\n-\n-      return 1;\n-    }\n+  { NULL, 0, 0, false, false, false, NULL }\n+};\n \n-  return 0;\n+/* Default value of targetm.function_attribute_inlinable_p that always\n+   returns false.  */\n+bool\n+default_function_attribute_inlinable_p (fndecl)\n+     tree fndecl ATTRIBUTE_UNUSED;\n+{\n+  /* By default, functions with machine attributes cannot be inlined.  */\n+  return false;\n }\n \n /* Return non-zero if IDENT is a valid name for attribute ATTR,\n@@ -2873,7 +2764,9 @@ is_attribute_p (attr, ident)\n \n /* Given an attribute name and a list of attributes, return a pointer to the\n    attribute's list element if the attribute is part of the list, or NULL_TREE\n-   if not found.  */\n+   if not found.  If the attribute appears more than once, this only\n+   returns the first occurance; the TREE_CHAIN of the return value should\n+   be passed back in if further occurances are wanted.  */\n \n tree\n lookup_attribute (attr_name, list)\n@@ -2915,19 +2808,29 @@ merge_attributes (a1, a2)\n       else\n \t{\n \t  /* Pick the longest list, and hang on the other list.  */\n-\t  /* ??? For the moment we punt on the issue of attrs with args.  */\n \n \t  if (list_length (a1) < list_length (a2))\n \t    attributes = a2, a2 = a1;\n \n \t  for (; a2 != 0; a2 = TREE_CHAIN (a2))\n-\t    if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\t  attributes) == NULL_TREE)\n-\t      {\n-\t\ta1 = copy_node (a2);\n-\t\tTREE_CHAIN (a1) = attributes;\n-\t\tattributes = a1;\n-\t      }\n+\t    {\n+\t      tree a;\n+\t      for (a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n+\t\t\t\t\t attributes);\n+\t\t   a != NULL_TREE;\n+\t\t   a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n+\t\t\t\t\t TREE_CHAIN (a)))\n+\t\t{\n+\t\t  if (simple_cst_equal (TREE_VALUE (a), TREE_VALUE (a2)) == 1)\n+\t\t    break;\n+\t\t}\n+\t      if (a == NULL_TREE)\n+\t\t{\n+\t\t  a1 = copy_node (a2);\n+\t\t  TREE_CHAIN (a1) = attributes;\n+\t\t  attributes = a1;\n+\t\t}\n+\t    }\n \t}\n     }\n   return attributes;\n@@ -2951,8 +2854,8 @@ tree\n merge_decl_attributes (olddecl, newdecl)\n      tree olddecl, newdecl;\n {\n-  return merge_attributes (DECL_MACHINE_ATTRIBUTES (olddecl),\n-\t\t\t   DECL_MACHINE_ATTRIBUTES (newdecl));\n+  return merge_attributes (DECL_ATTRIBUTES (olddecl),\n+\t\t\t   DECL_ATTRIBUTES (newdecl));\n }\n \n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -2974,8 +2877,8 @@ merge_dllimport_decl_attributes (old, new)\n   tree a;\n   int delete_dllimport_p;\n \n-  old = DECL_MACHINE_ATTRIBUTES (old);\n-  new = DECL_MACHINE_ATTRIBUTES (new);\n+  old = DECL_ATTRIBUTES (old);\n+  new = DECL_ATTRIBUTES (new);\n \n   /* What we need to do here is remove from `old' dllimport if it doesn't\n      appear in `new'.  dllimport behaves like extern: if a declaration is\n@@ -3345,8 +3248,15 @@ attribute_list_contained (l1, l2)\n \n   for (; t2 != 0; t2 = TREE_CHAIN (t2))\n     {\n-      tree attr\n-\t= lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n+      tree attr;\n+      for (attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n+\t   attr != NULL_TREE;\n+\t   attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    TREE_CHAIN (attr)))\n+\t{\n+\t  if (simple_cst_equal (TREE_VALUE (t2), TREE_VALUE (attr)) == 1)\n+\t    break;\n+\t}\n \n       if (attr == 0)\n \treturn 0;"}, {"sha": "aee84340355a4d0bb50444cc543e6fe6275c03d6", "filename": "gcc/tree.h", "status": "modified", "additions": 73, "deletions": 6, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d231cb917f53b4cd34dec24227863e95fceb6f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=91d231cb917f53b4cd34dec24227863e95fceb6f", "patch": "@@ -1,5 +1,5 @@\n /* Front-end tree definitions for GNU compiler.\n-   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1337,9 +1337,8 @@ struct tree_type\n     type, or NULL_TREE if the given decl has \"file scope\".  */\n #define DECL_CONTEXT(NODE) (DECL_CHECK (NODE)->decl.context)\n #define DECL_FIELD_CONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.context)\n-/* In a DECL this is the field where configuration dependent machine\n-   attributes are store */\n-#define DECL_MACHINE_ATTRIBUTES(NODE) (DECL_CHECK (NODE)->decl.machine_attributes)\n+/* In a DECL this is the field where attributes are stored.  */\n+#define DECL_ATTRIBUTES(NODE) (DECL_CHECK (NODE)->decl.attributes)\n /* In a FIELD_DECL, this is the field position, counting in bytes, of the\n    byte containing the bit closest to the beginning of the structure.  */\n #define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.arguments)\n@@ -1754,7 +1753,7 @@ struct tree_decl\n   tree abstract_origin;\n   tree assembler_name;\n   tree section_name;\n-  tree machine_attributes;\n+  tree attributes;\n   rtx rtl;\t/* RTL representation for object.  */\n   rtx live_range_rtl;\n \n@@ -2069,14 +2068,82 @@ extern tree make_tree\t\t\tPARAMS ((tree, rtx));\n extern tree build_type_attribute_variant PARAMS ((tree, tree));\n extern tree build_decl_attribute_variant PARAMS ((tree, tree));\n \n+/* Structure describing an attribute and a function to handle it.  */\n+struct attribute_spec\n+{\n+  /* The name of the attribute (without any leading or trailing __),\n+     or NULL to mark the end of a table of attributes.  */\n+  const char *name;\n+  /* The minimum length of the list of arguments of the attribute.  */\n+  int min_length;\n+  /* The maximum length of the list of arguments of the attribute\n+     (-1 for no maximum).  */\n+  int max_length;\n+  /* Whether this attribute requires a DECL.  If it does, it will be passed\n+     from types of DECLs, function return types and array element types to\n+     the DECLs, function types and array types respectively; but when\n+     applied to a type in any other circumstances, it will be ignored with\n+     a warning.  (If greater control is desired for a given attribute,\n+     this should be false, and the flags argument to the handler may be\n+     used to gain greater control in that case.)  */\n+  bool decl_required;\n+  /* Whether this attribute requires a type.  If it does, it will be passed\n+     from a DECL to the type of that DECL.  */\n+  bool type_required;\n+  /* Whether this attribute requires a function (or method) type.  If it does,\n+     it will be passed from a function pointer type to the target type,\n+     and from a function return type (which is not itself a function\n+     pointer type) to the function type.  */\n+  bool function_type_required;\n+  /* Function to handle this attribute.  NODE points to the node to which\n+     the attribute is to be applied.  If a DECL, it should be modified in\n+     place; if a TYPE, a copy should be created.  NAME is the name of the\n+     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST\n+     of the arguments (which may be NULL).  FLAGS gives further information\n+     about the context of the attribute.  Afterwards, the attributes will\n+     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,\n+     unless *NO_ADD_ATTRS is set to true (which should be done on error,\n+     as well as in any other cases when the attributes should not be added\n+     to the DECL or TYPE).  Depending on FLAGS, any attributes to be\n+     applied to another type or DECL later may be returned;\n+     otherwise the return value should be NULL_TREE.  This pointer may be\n+     NULL if no special handling is required beyond the checks implied\n+     by the rest of this structure.  */\n+  tree (*handler) PARAMS ((tree *node, tree name, tree args,\n+\t\t\t   int flags, bool *no_add_attrs));\n+};\n+\n+extern const struct attribute_spec default_target_attribute_table[];\n+\n+/* Flags that may be passed in the third argument of decl_attributes, and\n+   to handler functions for attributes.  */\n+enum attribute_flags\n+{\n+  /* The type passed in is the type of a DECL, and any attributes that\n+     should be passed in again to be applied to the DECL rather than the\n+     type should be returned.  */\n+  ATTR_FLAG_DECL_NEXT = 1,\n+  /* The type passed in is a function return type, and any attributes that\n+     should be passed in again to be applied to the function type rather\n+     than the return type should be returned.  */\n+  ATTR_FLAG_FUNCTION_NEXT = 2,\n+  /* The type passed in is an array element type, and any attributes that\n+     should be passed in again to be applied to the array type rather\n+     than the element type should be returned.  */\n+  ATTR_FLAG_ARRAY_NEXT = 4,\n+  /* The type passed in is a structure, union or enumeration type being\n+     created, and should be modified in place.  */\n+  ATTR_FLAG_TYPE_IN_PLACE = 8\n+};\n+\n /* Default versions of target-overridable functions.  */\n \n extern tree merge_decl_attributes PARAMS ((tree, tree));\n extern tree merge_type_attributes PARAMS ((tree, tree));\n-extern int default_valid_attribute_p PARAMS ((tree, tree, tree, tree));\n extern int default_comp_type_attributes PARAMS ((tree, tree));\n extern void default_set_default_type_attributes PARAMS ((tree));\n extern void default_insert_attributes PARAMS ((tree, tree *));\n+extern bool default_function_attribute_inlinable_p PARAMS ((tree));\n \n /* Split a list of declspecs and attributes into two.  */\n "}]}