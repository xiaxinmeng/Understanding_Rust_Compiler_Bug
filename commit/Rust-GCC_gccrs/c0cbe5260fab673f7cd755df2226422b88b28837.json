{"sha": "c0cbe5260fab673f7cd755df2226422b88b28837", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjYmU1MjYwZmFiNjczZjdjZDc1NWRmMjIyNjQyMmI4OGIyODgzNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-09-12T18:28:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-09-12T18:28:20Z"}, "message": "re PR middle-end/82853 (Optimize x % 3 == 0 without modulo)\n\n\tPR middle-end/82853\n\t* expr.h (maybe_optimize_mod_cmp): Declare.\n\t* expr.c (mod_inv): New function.\n\t(maybe_optimize_mod_cmp): New function.\n\t(do_store_flag): Use it.\n\t* cfgexpand.c (expand_gimple_cond): Likewise.\n\n\t* gcc.target/i386/pr82853-1.c: New test.\n\t* gcc.target/i386/pr82853-2.c: New test.\n\nFrom-SVN: r264248", "tree": {"sha": "80f2a40dc45418305b5aabf0aed406735df224de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80f2a40dc45418305b5aabf0aed406735df224de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0cbe5260fab673f7cd755df2226422b88b28837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cbe5260fab673f7cd755df2226422b88b28837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cbe5260fab673f7cd755df2226422b88b28837", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cbe5260fab673f7cd755df2226422b88b28837/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e36332cf65b4ec5a1ea6b4b3a6ae8cb6ed9f455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e36332cf65b4ec5a1ea6b4b3a6ae8cb6ed9f455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e36332cf65b4ec5a1ea6b4b3a6ae8cb6ed9f455"}], "stats": {"total": 303, "additions": 302, "deletions": 1}, "files": [{"sha": "6314c60aa244f2e7afcbf4093c080c42ce270648", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -1,3 +1,12 @@\n+2018-09-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/82853\n+\t* expr.h (maybe_optimize_mod_cmp): Declare.\n+\t* expr.c (mod_inv): New function.\n+\t(maybe_optimize_mod_cmp): New function.\n+\t(do_store_flag): Use it.\n+\t* cfgexpand.c (expand_gimple_cond): Likewise.\n+\n 2018-09-09  Cesar Philippidis  <cesar@codesourcery.com>\n             Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "697b238669fb0687c3e277c0b3fb1cd63df4f39b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -2477,6 +2477,13 @@ expand_gimple_cond (basic_block bb, gcond *stmt)\n \t}\n     }\n \n+  /* Optimize (x % C1) == C2 or (x % C1) != C2 if it is beneficial\n+     into (x - C2) * C3 < C4.  */\n+  if ((code == EQ_EXPR || code == NE_EXPR)\n+      && TREE_CODE (op0) == SSA_NAME\n+      && TREE_CODE (op1) == INTEGER_CST)\n+    code = maybe_optimize_mod_cmp (code, &op0, &op1);\n+\n   last2 = last = get_last_insn ();\n \n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);"}, {"sha": "3b59f96f5390dd1951af0eba5e782ed10f7936d3", "filename": "gcc/expr.c", "status": "modified", "additions": 256, "deletions": 1, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -11491,6 +11491,243 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n   return init;\n }\n \f\n+/* Compute the modular multiplicative inverse of A modulo M\n+   using extended Euclid's algorithm.  Assumes A and M are coprime.  */\n+static wide_int\n+mod_inv (const wide_int &a, const wide_int &b)\n+{\n+  /* Verify the assumption.  */\n+  gcc_checking_assert (wi::eq_p (wi::gcd (a, b), 1));\n+\n+  unsigned int p = a.get_precision () + 1;\n+  gcc_checking_assert (b.get_precision () + 1 == p);\n+  wide_int c = wide_int::from (a, p, UNSIGNED);\n+  wide_int d = wide_int::from (b, p, UNSIGNED);\n+  wide_int x0 = wide_int::from (0, p, UNSIGNED);\n+  wide_int x1 = wide_int::from (1, p, UNSIGNED);\n+\n+  if (wi::eq_p (b, 1))\n+    return wide_int::from (1, p, UNSIGNED);\n+\n+  while (wi::gt_p (c, 1, UNSIGNED))\n+    {\n+      wide_int t = d;\n+      wide_int q = wi::divmod_trunc (c, d, UNSIGNED, &d);\n+      c = t;\n+      wide_int s = x0;\n+      x0 = wi::sub (x1, wi::mul (q, x0));\n+      x1 = s;\n+    }\n+  if (wi::lt_p (x1, 0, SIGNED))\n+    x1 += d;\n+  return x1;\n+}\n+\n+/* Attempt to optimize unsigned (X % C1) == C2 (or (X % C1) != C2).\n+   If C1 is odd to:\n+   (X - C2) * C3 <= C4 (or >), where\n+   C3 is modular multiplicative inverse of C1 and 1<<prec and\n+   C4 is ((1<<prec) - 1) / C1 or ((1<<prec) - 1) / C1 - 1 (the latter\n+   if C2 > ((1<<prec) - 1) % C1).\n+   If C1 is even, S = ctz (C1) and C2 is 0, use\n+   ((X * C3) r>> S) <= C4, where C3 is modular multiplicative\n+   inverse of C1>>S and 1<<prec and C4 is (((1<<prec) - 1) / (C1>>S)) >> S.\n+\n+   For signed (X % C1) == 0 if C1 is odd to (all operations in it\n+   unsigned):\n+   (X * C3) + C4 <= 2 * C4, where\n+   C3 is modular multiplicative inverse of (unsigned) C1 and 1<<prec and\n+   C4 is ((1<<(prec - 1) - 1) / C1).\n+   If C1 is even, S = ctz(C1), use\n+   ((X * C3) + C4) r>> S <= (C4 >> (S - 1))\n+   where C3 is modular multiplicative inverse of (unsigned)(C1>>S) and 1<<prec\n+   and C4 is ((1<<(prec - 1) - 1) / (C1>>S)) & (-1<<S).\n+\n+   See the Hacker's Delight book, section 10-17.  */\n+enum tree_code\n+maybe_optimize_mod_cmp (enum tree_code code, tree *arg0, tree *arg1)\n+{\n+  gcc_checking_assert (code == EQ_EXPR || code == NE_EXPR);\n+  gcc_checking_assert (TREE_CODE (*arg1) == INTEGER_CST);\n+\n+  if (optimize < 2)\n+    return code;\n+\n+  gimple *stmt = get_def_for_expr (*arg0, TRUNC_MOD_EXPR);\n+  if (stmt == NULL)\n+    return code;\n+\n+  tree treeop0 = gimple_assign_rhs1 (stmt);\n+  tree treeop1 = gimple_assign_rhs2 (stmt);\n+  if (TREE_CODE (treeop0) != SSA_NAME\n+      || TREE_CODE (treeop1) != INTEGER_CST\n+      /* x % pow2 is handled right already.  */\n+      || integer_pow2p (treeop1)\n+      /* Don't optimize the undefined behavior case x % 0;\n+\t x % 1 should have been optimized into zero, punt if\n+\t it makes it here for whatever reason;\n+\t x % -c should have been optimized into x % c.  */\n+      || compare_tree_int (treeop1, 2) <= 0\n+      /* Likewise x % c == d where d >= c should be always false.  */\n+      || tree_int_cst_le (treeop1, *arg1))\n+    return code;\n+\n+  tree type = TREE_TYPE (*arg0);\n+  scalar_int_mode mode;\n+  if (!is_a <scalar_int_mode> (TYPE_MODE (type), &mode))\n+    return code;\n+  if (GET_MODE_BITSIZE (mode) != TYPE_PRECISION (type)\n+      || TYPE_PRECISION (type) <= 1)\n+    return code;\n+\n+  signop sgn = UNSIGNED;\n+  /* If both operands are known to have the sign bit clear, handle\n+     even the signed modulo case as unsigned.  treeop1 is always\n+     positive >= 2, checked above.  */\n+  if (!TYPE_UNSIGNED (type) && get_range_pos_neg (treeop0) != 1)\n+    sgn = SIGNED;\n+\n+  if (!TYPE_UNSIGNED (type))\n+    {\n+      if (tree_int_cst_sgn (*arg1) == -1)\n+\treturn code;\n+      type = unsigned_type_for (type);\n+      if (!type || TYPE_MODE (type) != TYPE_MODE (TREE_TYPE (*arg0)))\n+\treturn code;\n+    }\n+\n+  int prec = TYPE_PRECISION (type);\n+  wide_int w = wi::to_wide (treeop1);\n+  int shift = wi::ctz (w);\n+  /* Unsigned (X % C1) == C2 is equivalent to (X - C2) % C1 == 0 if\n+     C2 <= -1U % C1, because for any Z >= 0U - C2 in that case (Z % C1) != 0.\n+     If C1 is odd, we can handle all cases by subtracting\n+     C4 below.  We could handle even the even C1 and C2 > -1U % C1 cases\n+     e.g. by testing for overflow on the subtraction, punt on that for now\n+     though.  */\n+  if ((sgn == SIGNED || shift) && !integer_zerop (*arg1))\n+    {\n+      if (sgn == SIGNED)\n+\treturn code;\n+      wide_int x = wi::umod_trunc (wi::mask (prec, false, prec), w);\n+      if (wi::gtu_p (wi::to_wide (*arg1), x))\n+\treturn code;\n+    }\n+\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, treeop0)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p);\n+      /* Punt if treeop0 is used in the same bb in a division\n+\t or another modulo with the same divisor.  We should expect\n+\t the division and modulo combined together.  */\n+      if (use_stmt == stmt\n+\t  || gimple_bb (use_stmt) != gimple_bb (stmt))\n+\tcontinue;\n+      if (!is_gimple_assign (use_stmt)\n+\t  || (gimple_assign_rhs_code (use_stmt) != TRUNC_DIV_EXPR\n+\t      && gimple_assign_rhs_code (use_stmt) != TRUNC_MOD_EXPR))\n+\tcontinue;\n+      if (gimple_assign_rhs1 (use_stmt) != treeop0\n+\t  || !operand_equal_p (gimple_assign_rhs2 (use_stmt), treeop1, 0))\n+\tcontinue;\n+      return code;\n+    }\n+\n+  w = wi::lrshift (w, shift);\n+  wide_int a = wide_int::from (w, prec + 1, UNSIGNED);\n+  wide_int b = wi::shifted_mask (prec, 1, false, prec + 1);\n+  wide_int m = wide_int::from (mod_inv (a, b), prec, UNSIGNED);\n+  tree c3 = wide_int_to_tree (type, m);\n+  tree c5 = NULL_TREE;\n+  wide_int d, e;\n+  if (sgn == UNSIGNED)\n+    {\n+      d = wi::divmod_trunc (wi::mask (prec, false, prec), w, UNSIGNED, &e);\n+      /* Use <= floor ((1<<prec) - 1) / C1 only if C2 <= ((1<<prec) - 1) % C1,\n+\t otherwise use < or subtract one from C4.  E.g. for\n+\t x % 3U == 0 we transform this into x * 0xaaaaaaab <= 0x55555555, but\n+\t x % 3U == 1 already needs to be\n+\t (x - 1) * 0xaaaaaaabU <= 0x55555554.  */\n+      if (!shift && wi::gtu_p (wi::to_wide (*arg1), e))\n+\td -= 1;\n+      if (shift)\n+\td = wi::lrshift (d, shift);\n+    }\n+  else\n+    {\n+      e = wi::udiv_trunc (wi::mask (prec - 1, false, prec), w);\n+      if (!shift)\n+\td = wi::lshift (e, 1);\n+      else\n+\t{\n+\t  e = wi::bit_and (e, wi::mask (shift, true, prec));\n+\t  d = wi::lrshift (e, shift - 1);\n+\t}\n+      c5 = wide_int_to_tree (type, e);\n+    }\n+  tree c4 = wide_int_to_tree (type, d);\n+\n+  rtx op0 = expand_normal (treeop0);\n+  treeop0 = make_tree (TREE_TYPE (treeop0), op0);\n+\n+  bool speed_p = optimize_insn_for_speed_p ();\n+\n+  do_pending_stack_adjust ();\n+\n+  location_t loc = gimple_location (stmt);\n+  struct separate_ops ops;\n+  ops.code = TRUNC_MOD_EXPR;\n+  ops.location = loc;\n+  ops.type = TREE_TYPE (treeop0);\n+  ops.op0 = treeop0;\n+  ops.op1 = treeop1;\n+  ops.op2 = NULL_TREE;\n+  start_sequence ();\n+  rtx mor = expand_expr_real_2 (&ops, NULL_RTX, TYPE_MODE (ops.type),\n+\t\t\t\tEXPAND_NORMAL);\n+  rtx_insn *moinsns = get_insns ();\n+  end_sequence ();\n+\n+  unsigned mocost = seq_cost (moinsns, speed_p);\n+  mocost += rtx_cost (mor, mode, EQ, 0, speed_p);\n+  mocost += rtx_cost (expand_normal (*arg1), mode, EQ, 1, speed_p);\n+\n+  tree t = fold_convert_loc (loc, type, treeop0);\n+  if (!integer_zerop (*arg1))\n+    t = fold_build2_loc (loc, MINUS_EXPR, type, t, fold_convert (type, *arg1));\n+  t = fold_build2_loc (loc, MULT_EXPR, type, t, c3);\n+  if (sgn == SIGNED)\n+    t = fold_build2_loc (loc, PLUS_EXPR, type, t, c5);\n+  if (shift)\n+    {\n+      tree s = build_int_cst (NULL_TREE, shift);\n+      t = fold_build2_loc (loc, RROTATE_EXPR, type, t, s);\n+    }\n+\n+  start_sequence ();\n+  rtx mur = expand_normal (t);\n+  rtx_insn *muinsns = get_insns ();\n+  end_sequence ();\n+\n+  unsigned mucost = seq_cost (muinsns, speed_p);\n+  mucost += rtx_cost (mur, mode, LE, 0, speed_p);\n+  mucost += rtx_cost (expand_normal (c4), mode, LE, 1, speed_p);\n+\n+  if (mocost <= mucost)\n+    {\n+      emit_insn (moinsns);\n+      *arg0 = make_tree (TREE_TYPE (*arg0), mor);\n+      return code;\n+    }\n+\n+  emit_insn (muinsns);\n+  *arg0 = make_tree (type, mur);\n+  *arg1 = c4;\n+  return code == EQ_EXPR ? LE_EXPR : GT_EXPR;\n+}\n+\f\n /* Generate code to calculate OPS, and exploded expression\n    using a store-flag instruction and return an rtx for the result.\n    OPS reflects a comparison.\n@@ -11548,7 +11785,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n \n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n-  \n+\n   /* For vector typed comparisons emit code to generate the desired\n      all-ones or all-zeros mask.  Conveniently use the VEC_COND_EXPR\n      expander for this.  */\n@@ -11567,6 +11804,24 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n \t}\n     }\n \n+  /* Optimize (x % C1) == C2 or (x % C1) != C2 if it is beneficial\n+     into (x - C2) * C3 < C4.  */\n+  if ((ops->code == EQ_EXPR || ops->code == NE_EXPR)\n+      && TREE_CODE (arg0) == SSA_NAME\n+      && TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      enum tree_code code = maybe_optimize_mod_cmp (ops->code, &arg0, &arg1);\n+      if (code != ops->code)\n+\t{\n+\t  struct separate_ops nops = *ops;\n+\t  nops.code = ops->code = code;\n+\t  nops.op0 = arg0;\n+\t  nops.op1 = arg1;\n+\t  nops.type = TREE_TYPE (arg0);\n+\t  return do_store_flag (&nops, target, mode);\n+\t}\n+    }\n+\n   /* Get the rtx comparison code to use.  We know that EXP is a comparison\n      operation of some type.  Some comparisons against 1 and -1 can be\n      converted to comparisons with zero.  Do so here so that the tests"}, {"sha": "19028f0e6a4042d0f52dcfad376fd9e48ee5400d", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -290,6 +290,8 @@ expand_normal (tree exp)\n    a string constant.  */\n extern tree string_constant (tree, tree *, tree *, tree *);\n \n+extern enum tree_code maybe_optimize_mod_cmp (enum tree_code, tree *, tree *);\n+\n /* Two different ways of generating switch statements.  */\n extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, profile_probability);\n extern int try_tablejump (tree, tree, tree, tree, rtx, rtx, profile_probability);"}, {"sha": "76ede60698463f16453186c02c7a2597a2aa57d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -1,3 +1,9 @@\n+2018-09-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/82853\n+\t* gcc.target/i386/pr82853-1.c: New test.\n+\t* gcc.target/i386/pr82853-2.c: New test.\n+\n 2018-09-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87280"}, {"sha": "822fe77591cbea76ac6968e7499f9bb038560e15", "filename": "gcc/testsuite/gcc.target/i386/pr82853-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-1.c?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -0,0 +1,15 @@\n+/* PR middle-end/82853 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-bmi2 -mtune=generic\" } */\n+/* { dg-final { scan-assembler-times \"mul\\[lq]\\t\" 7 } } */\n+/* { dg-final { scan-assembler-not \"div\\[lq]\\t\" } } */\n+/* { dg-final { scan-assembler-not \"lea\\[lq]\\t\\[^\\n\\r]*,\\[^\\n\\r]*,2\\\\)\" } } */\n+\n+unsigned f1 (unsigned x) { return (x % 679U) == 0; }\n+unsigned f2 (unsigned x) { return (x % 1738U) == 0; }\n+void bar (void);\n+void f3 (unsigned x) { if (x % 3 == 0) bar (); }\n+void f4 (unsigned x) { if (x % 3 == 1) bar (); }\n+void f5 (unsigned x) { if (x % 3 == 2) bar (); }\n+int f6 (int x) { return x % 3 == 0; }\n+int f7 (int x) { return x % 6 == 0; }"}, {"sha": "0c19e9d272a0d5ca05a7f738ccbd3c27aaa031d9", "filename": "gcc/testsuite/gcc.target/i386/pr82853-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cbe5260fab673f7cd755df2226422b88b28837/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82853-2.c?ref=c0cbe5260fab673f7cd755df2226422b88b28837", "patch": "@@ -0,0 +1,7 @@\n+/* PR middle-end/82853 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-bmi2 -mtune=generic\" } */\n+/* { dg-final { scan-assembler-times \"mul\\[lq]\\t\" 2 } } */\n+/* { dg-final { scan-assembler-not \"div\\[lq]\\t\" } } */\n+\n+unsigned f1 (unsigned x, unsigned *y) { *y = x / 679U; return (x % 679U) == 0; }"}]}