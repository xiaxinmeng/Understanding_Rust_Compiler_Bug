{"sha": "9839afaf5e6f9271f902f50ed2827a4faa274894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzOWFmYWY1ZTZmOTI3MWY5MDJmNTBlZDI4MjdhNGZhYTI3NDg5NA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-16T23:16:53Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-16T23:16:53Z"}, "message": "re PR target/39423 ([SH]  performance regression: lost mov @(disp,Rn))\n\n\tPR target/39423\n\t* config/sh/sh.md (*movsi_index_disp, *movhi_index_disp): Handle\n\tpotential T_REG clobber.  Convert zero extending split to\n\tinsn_and_split.\n\nFrom-SVN: r190458", "tree": {"sha": "2e3304b3d9541c7ad54baf380a3140649c035ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3304b3d9541c7ad54baf380a3140649c035ca7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9839afaf5e6f9271f902f50ed2827a4faa274894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839afaf5e6f9271f902f50ed2827a4faa274894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9839afaf5e6f9271f902f50ed2827a4faa274894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839afaf5e6f9271f902f50ed2827a4faa274894/comments", "author": null, "committer": null, "parents": [{"sha": "043d627e0661cd1e09bfcfcdf90658ffef04af60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/043d627e0661cd1e09bfcfcdf90658ffef04af60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/043d627e0661cd1e09bfcfcdf90658ffef04af60"}], "stats": {"total": 55, "additions": 40, "deletions": 15}, "files": [{"sha": "494a3d8758c17af45a3a9dcaafc34e73ed87e1c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839afaf5e6f9271f902f50ed2827a4faa274894/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839afaf5e6f9271f902f50ed2827a4faa274894/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9839afaf5e6f9271f902f50ed2827a4faa274894", "patch": "@@ -1,3 +1,10 @@\n+2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/39423\n+\t* config/sh/sh.md (*movsi_index_disp, *movhi_index_disp): Handle\n+\tpotential T_REG clobber.  Convert zero extending split to\n+\tinsn_and_split.\n+\n 2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54089"}, {"sha": "5128bcef3fe071dd468af916f79047fcabfaaa34", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839afaf5e6f9271f902f50ed2827a4faa274894/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839afaf5e6f9271f902f50ed2827a4faa274894/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=9839afaf5e6f9271f902f50ed2827a4faa274894", "patch": "@@ -5457,16 +5457,22 @@ label:\n ;;\tmov.l\t@(4,r5),r0\n ;;\n ;; See also PR 39423.\n+;; Notice that these patterns have a T_REG clobber, because the shift\n+;; sequence that will be split out might clobber the T_REG.  Ideally, the\n+;; clobber would be added conditionally, depending on the result of\n+;; sh_ashlsi_clobbers_t_reg_p.  When splitting out the shifts we must go\n+;; through the ashlsi3 expander in order to get the right shift insn --\n+;; a T_REG clobbering or non-clobbering shift sequence or dynamic shift.\n ;; FIXME: Fold copy pasted patterns somehow.\n ;; FIXME: Combine never tries this kind of patterns for DImode.\n (define_insn_and_split \"*movsi_index_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(match_operand:SI 1 \"mem_index_disp_operand\" \"m\"))]\n+\t(match_operand:SI 1 \"mem_index_disp_operand\" \"m\"))\n+   (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n+  [(set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n    (set (match_dup 0) (match_dup 7))]\n {\n   rtx mem = operands[1];\n@@ -5483,16 +5489,18 @@ label:\n   operands[7] =\n     replace_equiv_address (mem,\n \t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n+\n+  emit_insn (gen_ashlsi3 (operands[5], operands[1], operands[2]));\n })\n \n (define_insn_and_split \"*movhi_index_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\" \"m\")))]\n+\t(sign_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\" \"m\")))\n+   (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n+  [(set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n    (set (match_dup 0) (sign_extend:SI (match_dup 7)))]\n {\n   rtx mem = operands[1];\n@@ -5509,26 +5517,32 @@ label:\n   operands[7] =\n     replace_equiv_address (mem,\n \t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n+\n+  emit_insn (gen_ashlsi3 (operands[5], operands[1], operands[2]));\n })\n \n-(define_split\n+(define_insn_and_split \"*movhi_index_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t(zero_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\")))\n+   (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n-  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+\t      (clobber (reg:SI T_REG))])\n    (set (match_dup 0) (zero_extend:SI (match_dup 2)))]\n {\n   operands[2] = gen_lowpart (HImode, operands[0]);\n })\n \n (define_insn_and_split \"*movsi_index_disp\"\n   [(set (match_operand:SI 0 \"mem_index_disp_operand\" \"=m\")\n-\t(match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+\t(match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+   (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 0) (match_dup 2)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n+ [(set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n    (set (match_dup 7) (match_dup 1))]\n {\n   rtx mem = operands[0];\n@@ -5545,16 +5559,18 @@ label:\n   operands[7] =\n     replace_equiv_address (mem,\n \t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n+\n+  emit_insn (gen_ashlsi3 (operands[5], operands[0], operands[2]));\n })\n \n (define_insn_and_split \"*movsi_index_disp\"\n   [(set (match_operand:HI 0 \"mem_index_disp_operand\" \"=m\")\n-\t(match_operand:HI 1 \"arith_reg_operand\" \"r\"))]\n+\t(match_operand:HI 1 \"arith_reg_operand\" \"r\"))\n+   (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 0) (match_dup 2)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n+  [(set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n    (set (match_dup 7) (match_dup 1))]\n {\n   rtx mem = operands[0];\n@@ -5571,6 +5587,8 @@ label:\n   operands[7] =\n     replace_equiv_address (mem,\n \t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n+\n+  emit_insn (gen_ashlsi3 (operands[5], operands[0], operands[2]));\n })\n \n ;; Define additional pop for SH1 and SH2 so it does not get "}]}