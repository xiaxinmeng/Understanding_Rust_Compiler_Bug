{"sha": "29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlmM2ZkNWI2YWM5MDhhNzk2ZDBiYjIxY2FlYzAyZTg0MTZhM2M4OA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-24T21:59:49Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-24T21:59:49Z"}, "message": "re PR bootstrap/59279 (r205337 breaks bootstrap with java)\n\n\tPR bootstrap/59279\n\tRevert previous commit.\n\nFrom-SVN: r205338", "tree": {"sha": "79fcd005a08d6ca51e2a25820e9ad881a4dc0e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79fcd005a08d6ca51e2a25820e9ad881a4dc0e2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/comments", "author": null, "committer": null, "parents": [{"sha": "57d6c446c787d1dacd89c5cd504747d6857ad494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d6c446c787d1dacd89c5cd504747d6857ad494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d6c446c787d1dacd89c5cd504747d6857ad494"}], "stats": {"total": 214, "additions": 76, "deletions": 138}, "files": [{"sha": "1fd4f3f342c7793ab80e32613f471748548e55fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -1,3 +1,8 @@\n+2013-11-24  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR bootstrap/59279\n+\tRevert previous commit.\n+\n 2013-11-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* jump.c (reset_insn_reg_label_operand_notes): New function,"}, {"sha": "234e5b64fe7954d211a0c8e5012e5fc1d629a594", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -2944,65 +2944,40 @@ delete_unreachable_blocks (void)\n   return changed;\n }\n \n-\f\n-/* Look for, and delete, any dead jumptables between START and END.  */\n-\n-static void\n-delete_dead_jump_tables_between (rtx start, rtx end)\n-{\n-  rtx insn, next;\n-\n-  for (insn = start; insn != end; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      if (next != NULL_RTX\n-\t  && LABEL_P (insn)\n-\t  && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n-\t  && JUMP_TABLE_DATA_P (next))\n-\t{\n-\t  rtx label = insn, jump = next;\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Dead jumptable %i removed\\n\",\n-\t\t     INSN_UID (insn));\n-\n-\t  next = NEXT_INSN (next);\n-\t  delete_insn (jump);\n-\t  delete_insn (label);\n-\t}\n-    }\n-}\n-\n-\n /* Delete any jump tables never referenced.  We can't delete them at the\n-   time of removing tablejump insn as the label preceding the jump table\n-   data may be referenced by the preceding insns computing the destination.\n-   So we delay deleting and garbage-collect them from time to time, after\n-   a CFG cleanup.  */\n-\n+   time of removing tablejump insn as they are referenced by the preceding\n+   insns computing the destination, so we delay deleting and garbagecollect\n+   them once life information is computed.  */\n void\n delete_dead_jumptables (void)\n {\n   basic_block bb;\n \n-  /* Label reference count must up-to-date to detect dead jump tables.  */\n-  rebuild_jump_labels (get_insns ());\n-\n+  /* A dead jump table does not belong to any basic block.  Scan insns\n+     between two adjacent basic blocks.  */\n   FOR_EACH_BB (bb)\n     {\n-      if (current_ir_type () == IR_RTL_CFGLAYOUT)\n-\t{\n-\t  /* Jump tables only appear in the header or footer of BB.  */\n-\t  delete_dead_jump_tables_between (BB_HEADER (bb), NULL_RTX);\n-\t  delete_dead_jump_tables_between (BB_FOOTER (bb), NULL_RTX);\n-\t}\n-      else\n+      rtx insn, next;\n+\n+      for (insn = NEXT_INSN (BB_END (bb));\n+\t   insn && !NOTE_INSN_BASIC_BLOCK_P (insn);\n+\t   insn = next)\n \t{\n-\t  /* Jump tables are in the insns chain between basic blocks.  */\n-\t  rtx start = NEXT_INSN (BB_END (bb));\n-\t  rtx end = (bb->next_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t    ? NULL_RTX : BB_HEAD (bb->next_bb);\n-\t  delete_dead_jump_tables_between (start, end);\n+\t  next = NEXT_INSN (insn);\n+\t  if (LABEL_P (insn)\n+\t      && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n+\t      && JUMP_TABLE_DATA_P (next))\n+\t    {\n+\t      rtx label = insn, jump = next;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Dead jumptable %i removed\\n\",\n+\t\t\t INSN_UID (insn));\n+\n+\t      next = NEXT_INSN (next);\n+\t      delete_insn (jump);\n+\t      delete_insn (label);\n+\t    }\n \t}\n     }\n }\n@@ -3074,13 +3049,13 @@ cleanup_cfg (int mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_exit_edges ();\n \n-  /* Don't always call delete_dead_jumptables in cfglayout mode, because\n-     jump tables can only appear in the headers and footers of basic blocks\n-     and we usually are not interested in anything hiding there.\n-     But if an expensive cleanup is called for, garbage-collect the dead\n-     jump tables to get label reference counts right.  This sometimes\n-     allows some labels to be removed and more basic blocks to be merged.  */\n-  if (!(mode & CLEANUP_CFGLAYOUT) || (mode & CLEANUP_EXPENSIVE))\n+  /* Don't call delete_dead_jumptables in cfglayout mode, because\n+     that function assumes that jump tables are in the insns stream.\n+     But we also don't _have_ to delete dead jumptables in cfglayout\n+     mode because we shouldn't even be looking at things that are\n+     not in a basic block.  Dead jumptables are cleaned up when\n+     going out of cfglayout mode.  */\n+  if (!(mode & CLEANUP_CFGLAYOUT))\n     delete_dead_jumptables ();\n \n   /* ???  We probably do this way too often.  */"}, {"sha": "63f44afbbae1eb15c41ba6970e328881005fd2eb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -3696,10 +3696,10 @@ fixup_reorder_chain (void)\n #endif\n \n   /* Now add jumps and labels as needed to match the blocks new\n-     outgoing edges.  Fixup missing or redundant BARRIERs.  */\n+     outgoing edges.  */\n \n-  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ;\n-       bb = (basic_block) bb->aux)\n+  for (bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb; bb ; bb = (basic_block)\n+       bb->aux)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -3853,26 +3853,13 @@ fixup_reorder_chain (void)\n \n   relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n \n-  /* Annoying special case - stray barriers left in the code.  This happens\n-     if a tablejump is transformed to a simpe or confitional jump, or if a\n-     basic block ending in a tablejump is removed but the jump table itself\n-     is not.  */\n+  /* Annoying special case - jump around dead jumptables left in the code.  */\n   FOR_EACH_BB (bb)\n     {\n       edge e = find_fallthru_edge (bb->succs);\n \n-      if (e && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t{\n-\t  rtx insn, next;\n-\t  for (insn = NEXT_INSN (BB_END (e->src));\n-\t       insn != BB_HEAD (e->dest);\n-\t       insn = next)\n-\t    {\n-\t      next = NEXT_INSN (insn);\n-\t      if (BARRIER_P (insn))\n-\t\tremove_insn (insn);\n-\t    }\n-\t}\n+      if (e && !can_fallthru (e->src, e->dest))\n+\tforce_nonfallthru (e);\n     }\n \n   /* Ensure goto_locus from edges has some instructions with that locus\n@@ -4286,15 +4273,14 @@ break_superblocks (void)\n }\n \n /* Finalize the changes: reorder insn list according to the sequence specified\n-   by aux pointers, enter compensation code.  */\n+   by aux pointers, enter compensation code, rebuild scope forest.  */\n \n void\n cfg_layout_finalize (void)\n {\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n-  delete_dead_jumptables ();\n   force_one_exit_fallthru ();\n   rtl_register_cfg_hooks ();\n   if (reload_completed\n@@ -4305,6 +4291,9 @@ cfg_layout_finalize (void)\n     fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n \n+  rebuild_jump_labels (get_insns ());\n+  delete_dead_jumptables ();\n+\n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n   verify_flow_info ();"}, {"sha": "2902ebe0a8bed29171944593891f146ad938d639", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -5273,9 +5273,9 @@ ira (FILE *f)\n   if (optimize && rebuild_p)\n     {\n       timevar_push (TV_JUMP);\n+      rebuild_jump_labels (get_insns ());\n       if (purge_all_dead_edges ())\n \tdelete_unreachable_blocks ();\n-      rebuild_jump_labels (get_insns ());\n       timevar_pop (TV_JUMP);\n     }\n "}, {"sha": "a27aaa94b8daac5a252493ec196140d69f09a9bd", "filename": "gcc/jump.c", "status": "modified", "additions": 23, "deletions": 57, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -177,34 +177,6 @@ make_pass_cleanup_barriers (gcc::context *ctxt)\n }\n \n \f\n-/* Remove all REG_LABEL_OPERAND notes from INSN.\n-\n-   REG_LABEL_TARGET notes (including the JUMP_LABEL field) are sticky and\n-   not reset here; that way we won't lose association with a label when\n-   e.g. the source for a target register disappears out of reach for targets\n-   that may use jump-target registers.  Jump transformations are supposed to\n-   transform any REG_LABEL_TARGET notes.  The target label reference in a\n-   branch may disappear from the branch (and from the instruction before it)\n-   for other reasons, like register allocation.  */\n-\n-static void\n-reset_insn_reg_label_operand_notes (rtx insn)\n-{\n-  if (INSN_P (insn))\n-    {\n-      rtx note, next;\n-\n-      for (note = REG_NOTES (insn); note; note = next)\n-\t{\n-\t  next = XEXP (note, 1);\n-\t  if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n-\t      && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t    remove_note (insn, note);\n-\t}\n-    }\n-}\n-\n-\n /* Initialize LABEL_NUSES and JUMP_LABEL fields, add REG_LABEL_TARGET\n    for remaining targets for JUMP_P.  Delete any REG_LABEL_OPERAND\n    notes whose labels don't occur in the insn any more.  */\n@@ -214,38 +186,32 @@ init_label_info (rtx f)\n {\n   rtx insn;\n \n-  if (current_ir_type () == IR_RTL_CFGLAYOUT)\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      basic_block bb;\n-\n-      FOR_EACH_BB (bb)\n+      if (LABEL_P (insn))\n+\tLABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\n+      /* REG_LABEL_TARGET notes (including the JUMP_LABEL field) are\n+\t sticky and not reset here; that way we won't lose association\n+\t with a label when e.g. the source for a target register\n+\t disappears out of reach for targets that may use jump-target\n+\t registers.  Jump transformations are supposed to transform\n+\t any REG_LABEL_TARGET notes.  The target label reference in a\n+\t branch may disappear from the branch (and from the\n+\t instruction before it) for other reasons, like register\n+\t allocation.  */\n+\n+      if (INSN_P (insn))\n \t{\n-\t  /* Labels only appear between BB_HEAD and the basic block note,\n-\t     and in the basic block header and footer.  */\n-\t  for (insn = BB_HEAD (bb);\n-\t       insn && LABEL_P (insn);\n-\t       insn = NEXT_INSN (insn))\n-\t    LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-\t  for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n-\t    if (LABEL_P (insn))\n-\t      LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-\t  for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n-\t    if (LABEL_P (insn))\n-\t      LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n+\t  rtx note, next;\n \n-\t  FOR_BB_INSNS (bb, insn)\n-\t    if (INSN_P (insn))\n-\t      reset_insn_reg_label_operand_notes (insn);\n-\t}\n-    }\n-  else\n-    {\n-      for (insn = f; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (LABEL_P (insn))\n-\t    LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-\t  if (INSN_P (insn))\n-\t    reset_insn_reg_label_operand_notes (insn);\n+\t  for (note = REG_NOTES (insn); note; note = next)\n+\t    {\n+\t      next = XEXP (note, 1);\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND\n+\t\t  && ! reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n+\t\tremove_note (insn, note);\n+\t    }\n \t}\n     }\n }"}, {"sha": "664b1ace4273baf86e731b954ef2f64289d5dcc5", "filename": "gcc/loop-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -415,7 +415,7 @@ rtl_loop_done (void)\n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n \n-  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  cleanup_cfg (0);\n   if (dump_file)\n     {\n       dump_reg_info (dump_file);"}, {"sha": "f3130449909873d4238dcc61150aaf1a3b63d4fa", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f3fd5b6ac908a796d0bb21caec02e8416a3c88/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=29f3fd5b6ac908a796d0bb21caec02e8416a3c88", "patch": "@@ -1471,7 +1471,7 @@ sms_schedule (void)\n \tcontinue;\n       }\n \n-      /* Don't handle BBs with calls\n+      /* Don't handle BBs with calls or barriers\n \t or !single_set with the exception of instructions that include\n \t count_reg---these instructions are part of the control part\n \t that do-loop recognizes.\n@@ -1481,6 +1481,7 @@ sms_schedule (void)\n          rtx set;\n \n         if (CALL_P (insn)\n+            || BARRIER_P (insn)\n             || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n                 && !reg_mentioned_p (count_reg, insn))\n@@ -1495,6 +1496,8 @@ sms_schedule (void)\n \t    {\n \t      if (CALL_P (insn))\n \t\tfprintf (dump_file, \"SMS loop-with-call\\n\");\n+\t      else if (BARRIER_P (insn))\n+\t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n               else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n                 fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");"}]}