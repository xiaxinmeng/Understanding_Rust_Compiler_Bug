{"sha": "1890f2f0e210ef515c39728c54151372d36dd187", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg5MGYyZjBlMjEwZWY1MTVjMzk3MjhjNTQxNTEzNzJkMzZkZDE4Nw==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-05-18T12:58:41Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-06-24T12:47:34Z"}, "message": "x86: Move cpuinfo.h from libgcc to common/config/i386\n\nBoth x86 backend and libgcc define enum processor_features.  libgcc sets\nenum processor_feature and x86 backend checks enum processor_feature.\nThey are very easy out of sync and it has happened multiple times in the\npast.\n\n1. Move cpuinfo.h from libgcc to common/config/i386 so that we can share\nthe same enum processor_features in x86 backend and libgcc.\n2. Change __cpu_features2 to an array to support more processor features.\n3. Add more processor features to enum processor_features.\n\ngcc/\n\n\tPR target/95259\n\t* common/config/i386/cpuinfo.h: New file.\n\t(__processor_model): Moved from libgcc/config/i386/cpuinfo.h.\n\t(__processor_model2): New.\n\t(CHECK___builtin_cpu_is): New.  Defined as empty if not defined.\n\t(has_cpu_feature): New function.\n\t(set_cpu_feature): Likewise.\n\t(get_amd_cpu): Moved from libgcc/config/i386/cpuinfo.c.  Use\n\tCHECK___builtin_cpu_is.  Return AMD CPU name.\n\t(get_intel_cpu): Moved from libgcc/config/i386/cpuinfo.c.  Use\n\tUse CHECK___builtin_cpu_is.  Return Intel CPU name.\n\t(get_available_features): Moved from libgcc/config/i386/cpuinfo.c.\n\tAlso check FEATURE_3DNOW, FEATURE_3DNOWP, FEATURE_ADX,\n\tFEATURE_ABM, FEATURE_CLDEMOTE, FEATURE_CLFLUSHOPT, FEATURE_CLWB,\n\tFEATURE_CLZERO, FEATURE_CMPXCHG16B, FEATURE_CMPXCHG8B,\n\tFEATURE_ENQCMD, FEATURE_F16C, FEATURE_FSGSBASE, FEATURE_FXSAVE,\n\tFEATURE_HLE, FEATURE_IBT, FEATURE_LAHF_LM, FEATURE_LM,\n\tFEATURE_LWP, FEATURE_LZCNT, FEATURE_MOVBE, FEATURE_MOVDIR64B,\n\tFEATURE_MOVDIRI, FEATURE_MWAITX, FEATURE_OSXSAVE,\n\tFEATURE_PCONFIG, FEATURE_PKU, FEATURE_PREFETCHWT1, FEATURE_PRFCHW,\n\tFEATURE_PTWRITE, FEATURE_RDPID, FEATURE_RDRND, FEATURE_RDSEED,\n\tFEATURE_RTM, FEATURE_SERIALIZE, FEATURE_SGX, FEATURE_SHA,\n\tFEATURE_SHSTK, FEATURE_TBM, FEATURE_TSXLDTRK, FEATURE_VAES,\n\tFEATURE_WAITPKG, FEATURE_WBNOINVD, FEATURE_XSAVE, FEATURE_XSAVEC,\n\tFEATURE_XSAVEOPT and FEATURE_XSAVES\n\t(cpu_indicator_init): Moved from libgcc/config/i386/cpuinfo.c.\n\tAlso update cpu_model2.\n\t* common/config/i386/i386-cpuinfo.h (processor_vendor): Add\n\tAdd VENDOR_CENTAUR, VENDOR_CYRIX and VENDOR_NSC.\n\t(processor_features): Moved from gcc/config/i386/i386-builtins.c.\n\tRenamed F_XXX to FEATURE_XXX.  Add FEATURE_3DNOW, FEATURE_3DNOWP,\n\tFEATURE_ADX, FEATURE_ABM, FEATURE_CLDEMOTE, FEATURE_CLFLUSHOPT,\n\tFEATURE_CLWB, FEATURE_CLZERO, FEATURE_CMPXCHG16B,\n\tFEATURE_CMPXCHG8B, FEATURE_ENQCMD, FEATURE_F16C,\n\tFEATURE_FSGSBASE, FEATURE_FXSAVE, FEATURE_HLE, FEATURE_IBT,\n\tFEATURE_LAHF_LM, FEATURE_LM, FEATURE_LWP, FEATURE_LZCNT,\n\tFEATURE_MOVBE, FEATURE_MOVDIR64B, FEATURE_MOVDIRI,\n\tFEATURE_MWAITX, FEATURE_OSXSAVE, FEATURE_PCONFIG,\n\tFEATURE_PKU, FEATURE_PREFETCHWT1, FEATURE_PRFCHW,\n\tFEATURE_PTWRITE, FEATURE_RDPID, FEATURE_RDRND, FEATURE_RDSEED,\n\tFEATURE_RTM, FEATURE_SERIALIZE, FEATURE_SGX, FEATURE_SHA,\n\tFEATURE_SHSTK, FEATURE_TBM, FEATURE_TSXLDTRK, FEATURE_VAES,\n\tFEATURE_WAITPKG, FEATURE_WBNOINVD, FEATURE_XSAVE, FEATURE_XSAVEC,\n\tFEATURE_XSAVEOPT, FEATURE_XSAVES and CPU_FEATURE_MAX.\n\t(SIZE_OF_CPU_FEATURES): New.\n\t* config/i386/i386-builtins.c (processor_features): Removed.\n\t(isa_names_table): Replace F_XXX with FEATURE_XXX.\n\t(fold_builtin_cpu): Change __cpu_features2 to an array.\n\nlibgcc/\n\n\tPR target/95259\n\t* config/i386/cpuinfo.c: Don't include \"cpuinfo.h\".  Include\n\t\"common/config/i386/i386-cpuinfo.h\" and\n\t\"common/config/i386/cpuinfo.h\".\n\t(__cpu_features2): Changed to array.\n\t(get_amd_cpu): Removed.\n\t(get_intel_cpu): Likewise.\n\t(get_available_features): Likewise.\n\t(__cpu_indicator_init): Call cpu_indicator_init.\n\t* config/i386/cpuinfo.h: Removed.", "tree": {"sha": "e01fa626db371d11f70e951ae7154761b8fa2a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e01fa626db371d11f70e951ae7154761b8fa2a57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1890f2f0e210ef515c39728c54151372d36dd187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1890f2f0e210ef515c39728c54151372d36dd187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1890f2f0e210ef515c39728c54151372d36dd187", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1890f2f0e210ef515c39728c54151372d36dd187/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07"}], "stats": {"total": 1690, "additions": 1009, "deletions": 681}, "files": [{"sha": "2d72b3b60fd0ed0fc85c36015bd9e6bfa6a2bfed", "filename": "gcc/common/config/i386/cpuinfo.h", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h?ref=1890f2f0e210ef515c39728c54151372d36dd187", "patch": "@@ -0,0 +1,844 @@\n+/* Get CPU type and Features for x86 processors.\n+   Copyright (C) 2012-2020 Free Software Foundation, Inc.\n+   Contributed by Sriraman Tallam (tmsriram@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+struct __processor_model\n+{\n+  unsigned int __cpu_vendor;\n+  unsigned int __cpu_type;\n+  unsigned int __cpu_subtype;\n+  /* The first 32 features are stored as bitmasks in __cpu_features.\n+     The rest of features are stored as bitmasks in a separate array\n+     of unsigned int.  */\n+  unsigned int __cpu_features[1];\n+};\n+\n+struct __processor_model2\n+{\n+  unsigned int __cpu_family;\n+  unsigned int __cpu_model;\n+  unsigned int __cpu_max_level;\n+  unsigned int __cpu_ext_level;\n+};\n+\n+#ifndef CHECK___builtin_cpu_is\n+# define CHECK___builtin_cpu_is(cpu)\n+#endif\n+\n+/* Return non-zero if the processor has feature F.  */\n+\n+static inline int\n+has_cpu_feature (struct __processor_model *cpu_model,\n+\t\t unsigned int *cpu_features2,\n+\t\t enum processor_features f)\n+{\n+  unsigned int i;\n+  if (f < 32)\n+    {\n+      /* The first 32 features.  */\n+      return cpu_model->__cpu_features[0] & (1U << (f & 31));\n+    }\n+  /* The rest of features.  cpu_features2[i] contains features from\n+     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n+  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)\n+    if (f < (32 + 32 + i * 32))\n+    return cpu_features2[i] & (1U << ((f - (32 + i * 32)) & 31));\n+  gcc_unreachable ();\n+}\n+\n+static inline void\n+set_cpu_feature (struct __processor_model *cpu_model,\n+\t\t unsigned int *cpu_features2,\n+\t\t enum processor_features f)\n+{\n+  unsigned int i;\n+  if (f < 32)\n+    {\n+      /* The first 32 features.  */\n+      cpu_model->__cpu_features[0] |= (1U << (f & 31));\n+      return;\n+    }\n+  /* The rest of features.  cpu_features2[i] contains features from\n+     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n+  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)\n+    if (f < (32 + 32 + i * 32))\n+      {\n+\tcpu_features2[i] |= (1U << ((f - (32 + i * 32)) & 31));\n+\treturn;\n+      }\n+  gcc_unreachable ();\n+}\n+\n+/* Get the specific type of AMD CPU and return AMD CPU name.  Return\n+   NULL for unknown AMD CPU.  */\n+\n+static inline const char *\n+get_amd_cpu (struct __processor_model *cpu_model,\n+\t     struct __processor_model2 *cpu_model2,\n+\t     unsigned int *cpu_features2)\n+{\n+  const char *cpu = NULL;\n+  unsigned int family = cpu_model2->__cpu_family;\n+  unsigned int model = cpu_model2->__cpu_model;\n+\n+  switch (family)\n+    {\n+    case 0x10:\n+      /* AMD Family 10h.  */\n+      cpu = \"amdfam10\";\n+      cpu_model->__cpu_type = AMDFAM10H;\n+      switch (model)\n+\t{\n+\tcase 0x2:\n+\t  /* Barcelona.  */\n+\t  CHECK___builtin_cpu_is (\"amdfam10h\");\n+\t  CHECK___builtin_cpu_is (\"barcelona\");\n+\t  cpu_model->__cpu_subtype = AMDFAM10H_BARCELONA;\n+\t  break;\n+\tcase 0x4:\n+\t  /* Shanghai.  */\n+\t  CHECK___builtin_cpu_is (\"amdfam10h\");\n+\t  CHECK___builtin_cpu_is (\"shanghai\");\n+\t  cpu_model->__cpu_subtype = AMDFAM10H_SHANGHAI;\n+\t  break;\n+\tcase 0x8:\n+\t  /* Istanbul.  */\n+\t  CHECK___builtin_cpu_is (\"amdfam10h\");\n+\t  CHECK___builtin_cpu_is (\"istanbul\");\n+\t  cpu_model->__cpu_subtype = AMDFAM10H_ISTANBUL;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    case 0x14:\n+      /* AMD Family 14h \"btver1\". */\n+      cpu = \"btver1\";\n+      CHECK___builtin_cpu_is (\"btver1\");\n+      cpu_model->__cpu_type = AMD_BTVER1;\n+      break;\n+    case 0x15:\n+      /* AMD Family 15h \"Bulldozer\".  */\n+      cpu_model->__cpu_type = AMDFAM15H;\n+      if (model == 0x2)\n+\t{\n+\t  /* Bulldozer version 2 \"Piledriver\" */\n+\t  cpu = \"bdver2\";\n+\t  CHECK___builtin_cpu_is (\"bdver2\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER2;\n+\t}\n+      else if (model <= 0xf)\n+\t{\n+\t  /* Bulldozer version 1.  */\n+\t  cpu = \"bdver1\";\n+\t  CHECK___builtin_cpu_is (\"bdver1\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER1;\n+\t}\n+      else if (model <= 0x2f)\n+\t{\n+\t  /* Bulldozer version 2 \"Piledriver\" */\n+\t  cpu = \"bdver2\";\n+\t  CHECK___builtin_cpu_is (\"bdver2\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER2;\n+\t}\n+      else if (model <= 0x4f)\n+\t{\n+\t  /* Bulldozer version 3 \"Steamroller\"  */\n+\t  cpu = \"bdver3\";\n+\t  CHECK___builtin_cpu_is (\"bdver3\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER3;\n+\t}\n+      else if (model <= 0x7f)\n+\t{\n+\t  /* Bulldozer version 4 \"Excavator\"   */\n+\t  cpu = \"bdver4\";\n+\t  CHECK___builtin_cpu_is (\"bdver4\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER4;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_AVX2))\n+\t{\n+\t  cpu = \"bdver4\";\n+\t  CHECK___builtin_cpu_is (\"bdver4\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER4;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_XSAVEOPT))\n+\t{\n+\t  cpu = \"bdver3\";\n+\t  CHECK___builtin_cpu_is (\"bdver3\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER3;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_BMI))\n+\t{\n+\t  cpu = \"bdver2\";\n+\t  CHECK___builtin_cpu_is (\"bdver2\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER2;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_XOP))\n+\t{\n+\t  cpu = \"bdver1\";\n+\t  CHECK___builtin_cpu_is (\"bdver1\");\n+\t  cpu_model->__cpu_subtype = AMDFAM15H_BDVER1;\n+\t}\n+      break;\n+    case 0x16:\n+      /* AMD Family 16h \"btver2\" */\n+      cpu = \"btver2\";\n+      CHECK___builtin_cpu_is (\"btver2\");\n+      cpu_model->__cpu_type = AMD_BTVER2;\n+      break;\n+    case 0x17:\n+      cpu_model->__cpu_type = AMDFAM17H;\n+      if (model <= 0x1f)\n+\t{\n+\t  /* AMD family 17h version 1.  */\n+\t  cpu = \"znver1\";\n+\t  CHECK___builtin_cpu_is (\"znver1\");\n+\t  cpu_model->__cpu_subtype = AMDFAM17H_ZNVER1;\n+\t}\n+      else if (model >= 0x30)\n+\t{\n+\t  cpu = \"znver2\";\n+\t  CHECK___builtin_cpu_is (\"znver2\");\n+\t  cpu_model->__cpu_subtype = AMDFAM17H_ZNVER2;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_CLWB))\n+\t{\n+\t  cpu = \"znver2\";\n+\t  CHECK___builtin_cpu_is (\"znver2\");\n+\t  cpu_model->__cpu_subtype = AMDFAM17H_ZNVER2;\n+\t}\n+      else if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t\tFEATURE_CLZERO))\n+\t{\n+\t  cpu = \"znver1\";\n+\t  CHECK___builtin_cpu_is (\"znver1\");\n+\t  cpu_model->__cpu_subtype = AMDFAM17H_ZNVER1;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return cpu;\n+}\n+\n+/* Get the specific type of Intel CPU and return Intel CPU name.  Return\n+   NULL for unknown Intel CPU.  */\n+\n+static inline const char *\n+get_intel_cpu (struct __processor_model *cpu_model,\n+\t       struct __processor_model2 *cpu_model2,\n+\t       unsigned int *cpu_features2,\n+\t       unsigned int brand_id)\n+{\n+  const char *cpu = NULL;\n+\n+  /* Parse family and model only for brand ID 0 and model 6. */\n+  if (brand_id != 0 || cpu_model2->__cpu_family != 0x6)\n+    return cpu;\n+\n+  switch (cpu_model2->__cpu_model)\n+    {\n+    case 0x1c:\n+    case 0x26:\n+      /* Bonnell.  */\n+      cpu = \"bonnell\";\n+      CHECK___builtin_cpu_is (\"atom\");\n+      cpu_model->__cpu_type = INTEL_BONNELL;\n+      break;\n+    case 0x37:\n+    case 0x4a:\n+    case 0x4d:\n+    case 0x5d:\n+      /* Silvermont.  */\n+    case 0x4c:\n+    case 0x5a:\n+    case 0x75:\n+      /* Airmont.  */\n+      cpu = \"silvermont\";\n+      CHECK___builtin_cpu_is (\"silvermont\");\n+      cpu_model->__cpu_type = INTEL_SILVERMONT;\n+      break;\n+    case 0x5c:\n+    case 0x5f:\n+      /* Goldmont.  */\n+      cpu = \"goldmont\";\n+      CHECK___builtin_cpu_is (\"goldmont\");\n+      cpu_model->__cpu_type = INTEL_GOLDMONT;\n+      break;\n+    case 0x7a:\n+      /* Goldmont Plus.  */\n+      cpu = \"goldmont-plus\";\n+      CHECK___builtin_cpu_is (\"goldmont-plus\");\n+      cpu_model->__cpu_type = INTEL_GOLDMONT_PLUS;\n+      break;\n+    case 0x86:\n+    case 0x96:\n+    case 0x9c:\n+      /* Tremont.  */\n+      cpu = \"tremont\";\n+      CHECK___builtin_cpu_is (\"tremont\");\n+      cpu_model->__cpu_type = INTEL_TREMONT;\n+      break;\n+    case 0x57:\n+      /* Knights Landing.  */\n+      cpu = \"knl\";\n+      CHECK___builtin_cpu_is (\"knl\");\n+      cpu_model->__cpu_type = INTEL_KNL;\n+      break;\n+    case 0x85:\n+      /* Knights Mill. */\n+      cpu = \"knm\";\n+      CHECK___builtin_cpu_is (\"knm\");\n+      cpu_model->__cpu_type = INTEL_KNM;\n+      break;\n+    case 0x1a:\n+    case 0x1e:\n+    case 0x1f:\n+    case 0x2e:\n+      /* Nehalem.  */\n+      cpu = \"nehalem\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"nehalem\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_NEHALEM;\n+      break;\n+    case 0x25:\n+    case 0x2c:\n+    case 0x2f:\n+      /* Westmere.  */\n+      cpu = \"westmere\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"westmere\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_WESTMERE;\n+      break;\n+    case 0x2a:\n+    case 0x2d:\n+      /* Sandy Bridge.  */\n+      cpu = \"sandybridge\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"sandybridge\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_SANDYBRIDGE;\n+      break;\n+    case 0x3a:\n+    case 0x3e:\n+      /* Ivy Bridge.  */\n+      cpu = \"ivybridge\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"ivybridge\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_IVYBRIDGE;\n+      break;\n+    case 0x3c:\n+    case 0x3f:\n+    case 0x45:\n+    case 0x46:\n+      /* Haswell.  */\n+      cpu = \"haswell\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"haswell\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_HASWELL;\n+      break;\n+    case 0x3d:\n+    case 0x47:\n+    case 0x4f:\n+    case 0x56:\n+      /* Broadwell.  */\n+      cpu = \"broadwell\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"broadwell\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_BROADWELL;\n+      break;\n+    case 0x4e:\n+    case 0x5e:\n+      /* Skylake.  */\n+    case 0x8e:\n+    case 0x9e:\n+      /* Kaby Lake.  */\n+    case 0xa5:\n+    case 0xa6:\n+      /* Comet Lake.  */\n+      cpu = \"skylake\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"skylake\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_SKYLAKE;\n+      break;\n+    case 0x55:\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      if (has_cpu_feature (cpu_model, cpu_features2,\n+\t\t\t   FEATURE_AVX512VNNI))\n+\t{\n+\t  /* Cascade Lake.  */\n+\t  cpu = \"cascadelake\";\n+\t  CHECK___builtin_cpu_is (\"cascadelake\");\n+\t  cpu_model->__cpu_subtype = INTEL_COREI7_CASCADELAKE;\n+\t}\n+      else\n+\t{\n+\t  /* Skylake with AVX-512 support.  */\n+\t  cpu = \"skylake-avx512\";\n+\t  CHECK___builtin_cpu_is (\"skylake-avx512\");\n+\t  cpu_model->__cpu_subtype = INTEL_COREI7_SKYLAKE_AVX512;\n+\t}\n+      break;\n+    case 0x66:\n+      /* Cannon Lake.  */\n+      cpu = \"cannonlake\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"cannonlake\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_CANNONLAKE;\n+      break;\n+    case 0x6a:\n+    case 0x6c:\n+      /* Ice Lake server.  */\n+      cpu = \"icelake-server\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"icelake-server\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_ICELAKE_SERVER;\n+      break;\n+    case 0x7e:\n+    case 0x7d:\n+    case 0x9d:\n+       /* Ice Lake client.  */\n+      cpu = \"icelake-client\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"icelake-client\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_ICELAKE_CLIENT;\n+      break;\n+    case 0x8c:\n+    case 0x8d:\n+      /* Tiger Lake.  */\n+      cpu = \"tigerlake\";\n+      CHECK___builtin_cpu_is (\"corei7\");\n+      CHECK___builtin_cpu_is (\"tigerlake\");\n+      cpu_model->__cpu_type = INTEL_COREI7;\n+      cpu_model->__cpu_subtype = INTEL_COREI7_TIGERLAKE;\n+      break;\n+    case 0x17:\n+    case 0x1d:\n+      /* Penryn.  */\n+    case 0x0f:\n+      /* Merom.  */\n+      cpu = \"core2\";\n+      CHECK___builtin_cpu_is (\"core2\");\n+      cpu_model->__cpu_type = INTEL_CORE2;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return cpu;\n+}\n+\n+/* ECX and EDX are output of CPUID at level one.  */\n+static inline void\n+get_available_features (struct __processor_model *cpu_model,\n+\t\t\tstruct __processor_model2 *cpu_model2,\n+\t\t\tunsigned int *cpu_features2,\n+\t\t\tunsigned int ecx, unsigned int edx)\n+{\n+  unsigned int max_cpuid_level = cpu_model2->__cpu_max_level;\n+  unsigned int eax, ebx;\n+  unsigned int ext_level;\n+\n+  /* Get XCR_XFEATURE_ENABLED_MASK register with xgetbv.  */\n+#define XCR_XFEATURE_ENABLED_MASK\t0x0\n+#define XSTATE_FP\t\t\t0x1\n+#define XSTATE_SSE\t\t\t0x2\n+#define XSTATE_YMM\t\t\t0x4\n+#define XSTATE_OPMASK\t\t\t0x20\n+#define XSTATE_ZMM\t\t\t0x40\n+#define XSTATE_HI_ZMM\t\t\t0x80\n+\n+#define XCR_AVX_ENABLED_MASK \\\n+  (XSTATE_SSE | XSTATE_YMM)\n+#define XCR_AVX512F_ENABLED_MASK \\\n+  (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK | XSTATE_ZMM | XSTATE_HI_ZMM)\n+\n+  /* Check if AVX and AVX512 are usable.  */\n+  int avx_usable = 0;\n+  int avx512_usable = 0;\n+  if ((ecx & bit_OSXSAVE))\n+    {\n+      /* Check if XMM, YMM, OPMASK, upper 256 bits of ZMM0-ZMM15 and\n+\t ZMM16-ZMM31 states are supported by OSXSAVE.  */\n+      unsigned int xcrlow;\n+      unsigned int xcrhigh;\n+      __asm__ (\".byte 0x0f, 0x01, 0xd0\"\n+\t       : \"=a\" (xcrlow), \"=d\" (xcrhigh)\n+\t       : \"c\" (XCR_XFEATURE_ENABLED_MASK));\n+      if ((xcrlow & XCR_AVX_ENABLED_MASK) == XCR_AVX_ENABLED_MASK)\n+\t{\n+\t  avx_usable = 1;\n+\t  avx512_usable = ((xcrlow & XCR_AVX512F_ENABLED_MASK)\n+\t\t\t   == XCR_AVX512F_ENABLED_MASK);\n+\t}\n+    }\n+\n+#define set_feature(f) \\\n+  set_cpu_feature (cpu_model, cpu_features2, f)\n+\n+  if (edx & bit_CMOV)\n+    set_feature (FEATURE_CMOV);\n+  if (edx & bit_MMX)\n+    set_feature (FEATURE_MMX);\n+  if (edx & bit_SSE)\n+    set_feature (FEATURE_SSE);\n+  if (edx & bit_SSE2)\n+    set_feature (FEATURE_SSE2);\n+  if (edx & bit_CMPXCHG8B)\n+    set_feature (FEATURE_CMPXCHG8B);\n+  if (edx & bit_FXSAVE)\n+    set_feature (FEATURE_FXSAVE);\n+\n+  if (ecx & bit_POPCNT)\n+    set_feature (FEATURE_POPCNT);\n+  if (ecx & bit_AES)\n+    set_feature (FEATURE_AES);\n+  if (ecx & bit_PCLMUL)\n+    set_feature (FEATURE_PCLMUL);\n+  if (ecx & bit_SSE3)\n+    set_feature (FEATURE_SSE3);\n+  if (ecx & bit_SSSE3)\n+    set_feature (FEATURE_SSSE3);\n+  if (ecx & bit_SSE4_1)\n+    set_feature (FEATURE_SSE4_1);\n+  if (ecx & bit_SSE4_2)\n+    set_feature (FEATURE_SSE4_2);\n+  if (ecx & bit_OSXSAVE)\n+    set_feature (FEATURE_OSXSAVE);\n+  if (ecx & bit_CMPXCHG16B)\n+    set_feature (FEATURE_CMPXCHG16B);\n+  if (ecx & bit_MOVBE)\n+    set_feature (FEATURE_MOVBE);\n+  if (ecx & bit_AES)\n+    set_feature (FEATURE_AES);\n+  if (ecx & bit_F16C)\n+    set_feature (FEATURE_F16C);\n+  if (ecx & bit_RDRND)\n+    set_feature (FEATURE_RDRND);\n+  if (ecx & bit_XSAVE)\n+    set_feature (FEATURE_XSAVE);\n+  if (avx_usable)\n+    {\n+      if (ecx & bit_AVX)\n+\tset_feature (FEATURE_AVX);\n+      if (ecx & bit_FMA)\n+\tset_feature (FEATURE_FMA);\n+    }\n+\n+  /* Get Advanced Features at level 7 (eax = 7, ecx = 0/1). */\n+  if (max_cpuid_level >= 7)\n+    {\n+      __cpuid_count (7, 0, eax, ebx, ecx, edx);\n+      if (ebx & bit_BMI)\n+\tset_feature (FEATURE_BMI);\n+      if (ebx & bit_SGX)\n+\tset_feature (FEATURE_SGX);\n+      if (ebx & bit_HLE)\n+\tset_feature (FEATURE_HLE);\n+      if (ebx & bit_RTM)\n+\tset_feature (FEATURE_RTM);\n+      if (avx_usable)\n+\t{\n+\t  if (ebx & bit_AVX2)\n+\t    set_feature (FEATURE_AVX2);\n+\t  if (ecx & bit_VPCLMULQDQ)\n+\t    set_feature (FEATURE_VPCLMULQDQ);\n+\t}\n+      if (ebx & bit_BMI2)\n+\tset_feature (FEATURE_BMI2);\n+      if (ebx & bit_FSGSBASE)\n+\tset_feature (FEATURE_FSGSBASE);\n+      if (ebx & bit_RDSEED)\n+\tset_feature (FEATURE_RDSEED);\n+      if (ebx & bit_ADX)\n+\tset_feature (FEATURE_ADX);\n+      if (ebx & bit_SHA)\n+\tset_feature (FEATURE_SHA);\n+      if (ebx & bit_CLFLUSHOPT)\n+\tset_feature (FEATURE_CLFLUSHOPT);\n+      if (ebx & bit_CLWB)\n+\tset_feature (FEATURE_CLWB);\n+      if (ecx & bit_PREFETCHWT1)\n+\tset_feature (FEATURE_PREFETCHWT1);\n+      /* NB: bit_OSPKE indicates that OS supports PKU.  */\n+      if (ecx & bit_OSPKE)\n+\tset_feature (FEATURE_PKU);\n+      if (ecx & bit_RDPID)\n+\tset_feature (FEATURE_RDPID);\n+      if (ecx & bit_VAES)\n+\tset_feature (FEATURE_VAES);\n+      if (ecx & bit_GFNI)\n+\tset_feature (FEATURE_GFNI);\n+      if (ecx & bit_MOVDIRI)\n+\tset_feature (FEATURE_MOVDIRI);\n+      if (ecx & bit_MOVDIR64B)\n+\tset_feature (FEATURE_MOVDIR64B);\n+      if (ecx & bit_ENQCMD)\n+\tset_feature (FEATURE_ENQCMD);\n+      if (ecx & bit_CLDEMOTE)\n+\tset_feature (FEATURE_CLDEMOTE);\n+      if (ecx & bit_WAITPKG)\n+\tset_feature (FEATURE_WAITPKG);\n+      if (ecx & bit_SHSTK)\n+\tset_feature (FEATURE_SHSTK);\n+      if (edx & bit_SERIALIZE)\n+\tset_feature (FEATURE_SERIALIZE);\n+      if (edx & bit_TSXLDTRK)\n+\tset_feature (FEATURE_TSXLDTRK);\n+      if (edx & bit_PCONFIG)\n+\tset_feature (FEATURE_PCONFIG);\n+      if (edx & bit_IBT)\n+\tset_feature (FEATURE_IBT);\n+      if (avx512_usable)\n+\t{\n+\t  if (ebx & bit_AVX512F)\n+\t    set_feature (FEATURE_AVX512F);\n+\t  if (ebx & bit_AVX512VL)\n+\t    set_feature (FEATURE_AVX512VL);\n+\t  if (ebx & bit_AVX512BW)\n+\t    set_feature (FEATURE_AVX512BW);\n+\t  if (ebx & bit_AVX512DQ)\n+\t    set_feature (FEATURE_AVX512DQ);\n+\t  if (ebx & bit_AVX512CD)\n+\t    set_feature (FEATURE_AVX512CD);\n+\t  if (ebx & bit_AVX512PF)\n+\t    set_feature (FEATURE_AVX512PF);\n+\t  if (ebx & bit_AVX512ER)\n+\t    set_feature (FEATURE_AVX512ER);\n+\t  if (ebx & bit_AVX512IFMA)\n+\t    set_feature (FEATURE_AVX512IFMA);\n+\t  if (ecx & bit_AVX512VBMI)\n+\t    set_feature (FEATURE_AVX512VBMI);\n+\t  if (ecx & bit_AVX512VBMI2)\n+\t    set_feature (FEATURE_AVX512VBMI2);\n+\t  if (ecx & bit_AVX512VNNI)\n+\t    set_feature (FEATURE_AVX512VNNI);\n+\t  if (ecx & bit_AVX512BITALG)\n+\t    set_feature (FEATURE_AVX512BITALG);\n+\t  if (ecx & bit_AVX512VPOPCNTDQ)\n+\t    set_feature (FEATURE_AVX512VPOPCNTDQ);\n+\t  if (edx & bit_AVX5124VNNIW)\n+\t    set_feature (FEATURE_AVX5124VNNIW);\n+\t  if (edx & bit_AVX5124FMAPS)\n+\t    set_feature (FEATURE_AVX5124FMAPS);\n+\t  if (edx & bit_AVX512VP2INTERSECT)\n+\t    set_feature (FEATURE_AVX512VP2INTERSECT);\n+\n+\t  __cpuid_count (7, 1, eax, ebx, ecx, edx);\n+\t  if (eax & bit_AVX512BF16)\n+\t    set_feature (FEATURE_AVX512BF16);\n+\t}\n+    }\n+\n+  /* Get Advanced Features at level 0xd (eax = 0xd, ecx = 1). */\n+  if (max_cpuid_level >= 0xd)\n+    {\n+      __cpuid_count (0xd, 1, eax, ebx, ecx, edx);\n+      if (eax & bit_XSAVEOPT)\n+\tset_feature (FEATURE_XSAVEOPT);\n+      if (eax & bit_XSAVEC)\n+\tset_feature (FEATURE_XSAVEC);\n+      if (eax & bit_XSAVES)\n+\tset_feature (FEATURE_XSAVES);\n+    }\n+\n+  /* Get Advanced Features at level 0x14 (eax = 0x14, ecx = 0). */\n+  if (max_cpuid_level >= 0x14)\n+    {\n+      __cpuid_count (0x14, 0, eax, ebx, ecx, edx);\n+      if (ebx & bit_PTWRITE)\n+\tset_feature (FEATURE_PTWRITE);\n+    }\n+\n+  /* Check cpuid level of extended features.  */\n+  __cpuid (0x80000000, ext_level, ebx, ecx, edx);\n+\n+  cpu_model2->__cpu_ext_level = ext_level;\n+\n+  if (ext_level >= 0x80000001)\n+    {\n+      __cpuid (0x80000001, eax, ebx, ecx, edx);\n+\n+      if (ecx & bit_SSE4a)\n+\tset_feature (FEATURE_SSE4_A);\n+      if (ecx & bit_LAHF_LM)\n+\tset_feature (FEATURE_LAHF_LM);\n+      if (ecx & bit_ABM)\n+\tset_feature (FEATURE_ABM);\n+      if (ecx & bit_LWP)\n+\tset_feature (FEATURE_LWP);\n+      if (ecx & bit_TBM)\n+\tset_feature (FEATURE_TBM);\n+      if (ecx & bit_LZCNT)\n+\tset_feature (FEATURE_LZCNT);\n+      if (ecx & bit_PRFCHW)\n+\tset_feature (FEATURE_PRFCHW);\n+      if (ecx & bit_MWAITX)\n+\tset_feature (FEATURE_MWAITX);\n+\n+      if (edx & bit_LM)\n+\tset_feature (FEATURE_LM);\n+      if (edx & bit_3DNOWP)\n+\tset_feature (FEATURE_3DNOWP);\n+      if (edx & bit_3DNOW)\n+\tset_feature (FEATURE_3DNOW);\n+\n+      if (avx_usable)\n+\t{\n+\t  if (ecx & bit_FMA4)\n+\t    set_feature (FEATURE_FMA4);\n+\t  if (ecx & bit_XOP)\n+\t    set_feature (FEATURE_XOP);\n+\t}\n+    }\n+\n+  if (ext_level >= 0x80000008)\n+    {\n+      __cpuid (0x80000008, eax, ebx, ecx, edx);\n+      if (ebx & bit_CLZERO)\n+\tset_feature (FEATURE_CLZERO);\n+      if (ebx & bit_WBNOINVD)\n+\tset_feature (FEATURE_WBNOINVD);\n+    }\n+\n+#undef set_feature\n+}\n+\n+static inline int\n+cpu_indicator_init (struct __processor_model *cpu_model,\n+\t\t    struct __processor_model2 *cpu_model2,\n+\t\t    unsigned int *cpu_features2)\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  int max_level;\n+  unsigned int vendor;\n+  unsigned int model, family, brand_id;\n+  unsigned int extended_model, extended_family;\n+\n+  /* This function needs to run just once.  */\n+  if (cpu_model->__cpu_vendor)\n+    return 0;\n+\n+  /* Assume cpuid insn present. Run in level 0 to get vendor id. */\n+  if (!__get_cpuid (0, &eax, &ebx, &ecx, &edx))\n+    {\n+      cpu_model->__cpu_vendor = VENDOR_OTHER;\n+      return -1;\n+    }\n+\n+  vendor = ebx;\n+  max_level = eax;\n+\n+  if (max_level < 1)\n+    {\n+      cpu_model->__cpu_vendor = VENDOR_OTHER;\n+      return -1;\n+    }\n+\n+  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+    {\n+      cpu_model->__cpu_vendor = VENDOR_OTHER;\n+      return -1;\n+    }\n+\n+  cpu_model2->__cpu_max_level = max_level;\n+\n+  model = (eax >> 4) & 0x0f;\n+  family = (eax >> 8) & 0x0f;\n+  brand_id = ebx & 0xff;\n+  extended_model = (eax >> 12) & 0xf0;\n+  extended_family = (eax >> 20) & 0xff;\n+\n+  if (vendor == signature_INTEL_ebx)\n+    {\n+      /* Adjust model and family for Intel CPUS. */\n+      if (family == 0x0f)\n+\t{\n+\t  family += extended_family;\n+\t  model += extended_model;\n+\t}\n+      else if (family == 0x06)\n+\tmodel += extended_model;\n+\n+      cpu_model2->__cpu_family = family;\n+      cpu_model2->__cpu_model = model;\n+\n+      /* Find available features. */\n+      get_available_features (cpu_model, cpu_model2, cpu_features2,\n+\t\t\t      ecx, edx);\n+      /* Get CPU type.  */\n+      get_intel_cpu (cpu_model, cpu_model2, cpu_features2, brand_id);\n+      cpu_model->__cpu_vendor = VENDOR_INTEL;\n+    }\n+  else if (vendor == signature_AMD_ebx)\n+    {\n+      /* Adjust model and family for AMD CPUS. */\n+      if (family == 0x0f)\n+\t{\n+\t  family += extended_family;\n+\t  model += extended_model;\n+\t}\n+\n+      cpu_model2->__cpu_family = family;\n+      cpu_model2->__cpu_model = model;\n+\n+      /* Find available features. */\n+      get_available_features (cpu_model, cpu_model2, cpu_features2,\n+\t\t\t      ecx, edx);\n+      /* Get CPU type.  */\n+      get_amd_cpu (cpu_model, cpu_model2, cpu_features2);\n+      cpu_model->__cpu_vendor = VENDOR_AMD;\n+    }\n+  else if (vendor == signature_CENTAUR_ebx)\n+    cpu_model->__cpu_vendor = VENDOR_CENTAUR;\n+  else if (vendor == signature_CYRIX_ebx)\n+    cpu_model->__cpu_vendor = VENDOR_CYRIX;\n+  else if (vendor == signature_NSC_ebx)\n+    cpu_model->__cpu_vendor = VENDOR_NSC;\n+  else\n+    cpu_model->__cpu_vendor = VENDOR_OTHER;\n+\n+  gcc_assert (cpu_model->__cpu_vendor < VENDOR_MAX);\n+  gcc_assert (cpu_model->__cpu_type < CPU_TYPE_MAX);\n+  gcc_assert (cpu_model->__cpu_subtype < CPU_SUBTYPE_MAX);\n+\n+  return 0;\n+}"}, {"sha": "96cf0eaea4733cf875c5f0979e3454146762b150", "filename": "gcc/common/config/i386/i386-cpuinfo.h", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-cpuinfo.h?ref=1890f2f0e210ef515c39728c54151372d36dd187", "patch": "@@ -30,6 +30,9 @@ enum processor_vendor\n   VENDOR_INTEL = 1,\n   VENDOR_AMD,\n   VENDOR_OTHER,\n+  VENDOR_CENTAUR,\n+  VENDOR_CYRIX,\n+  VENDOR_NSC,\n   BUILTIN_VENDOR_MAX = VENDOR_OTHER,\n   VENDOR_MAX\n };\n@@ -122,6 +125,101 @@ enum feature_priority\n   P_PROC_DYNAMIC\n };\n \n+/* ISA Features supported. New features have to be inserted at the end.  */\n+\n+enum processor_features\n+{\n+  FEATURE_CMOV = 0,\n+  FEATURE_MMX,\n+  FEATURE_POPCNT,\n+  FEATURE_SSE,\n+  FEATURE_SSE2,\n+  FEATURE_SSE3,\n+  FEATURE_SSSE3,\n+  FEATURE_SSE4_1,\n+  FEATURE_SSE4_2,\n+  FEATURE_AVX,\n+  FEATURE_AVX2,\n+  FEATURE_SSE4_A,\n+  FEATURE_FMA4,\n+  FEATURE_XOP,\n+  FEATURE_FMA,\n+  FEATURE_AVX512F,\n+  FEATURE_BMI,\n+  FEATURE_BMI2,\n+  FEATURE_AES,\n+  FEATURE_PCLMUL,\n+  FEATURE_AVX512VL,\n+  FEATURE_AVX512BW,\n+  FEATURE_AVX512DQ,\n+  FEATURE_AVX512CD,\n+  FEATURE_AVX512ER,\n+  FEATURE_AVX512PF,\n+  FEATURE_AVX512VBMI,\n+  FEATURE_AVX512IFMA,\n+  FEATURE_AVX5124VNNIW,\n+  FEATURE_AVX5124FMAPS,\n+  FEATURE_AVX512VPOPCNTDQ,\n+  FEATURE_AVX512VBMI2,\n+  FEATURE_GFNI,\n+  FEATURE_VPCLMULQDQ,\n+  FEATURE_AVX512VNNI,\n+  FEATURE_AVX512BITALG,\n+  FEATURE_AVX512BF16,\n+  FEATURE_AVX512VP2INTERSECT,\n+  FEATURE_3DNOW,\n+  FEATURE_3DNOWP,\n+  FEATURE_ADX,\n+  FEATURE_ABM,\n+  FEATURE_CLDEMOTE,\n+  FEATURE_CLFLUSHOPT,\n+  FEATURE_CLWB,\n+  FEATURE_CLZERO,\n+  FEATURE_CMPXCHG16B,\n+  FEATURE_CMPXCHG8B,\n+  FEATURE_ENQCMD,\n+  FEATURE_F16C,\n+  FEATURE_FSGSBASE,\n+  FEATURE_FXSAVE,\n+  FEATURE_HLE,\n+  FEATURE_IBT,\n+  FEATURE_LAHF_LM,\n+  FEATURE_LM,\n+  FEATURE_LWP,\n+  FEATURE_LZCNT,\n+  FEATURE_MOVBE,\n+  FEATURE_MOVDIR64B,\n+  FEATURE_MOVDIRI,\n+  FEATURE_MWAITX,\n+  FEATURE_OSXSAVE,\n+  FEATURE_PCONFIG,\n+  FEATURE_PKU,\n+  FEATURE_PREFETCHWT1,\n+  FEATURE_PRFCHW,\n+  FEATURE_PTWRITE,\n+  FEATURE_RDPID,\n+  FEATURE_RDRND,\n+  FEATURE_RDSEED,\n+  FEATURE_RTM,\n+  FEATURE_SERIALIZE,\n+  FEATURE_SGX,\n+  FEATURE_SHA,\n+  FEATURE_SHSTK,\n+  FEATURE_TBM,\n+  FEATURE_TSXLDTRK,\n+  FEATURE_VAES,\n+  FEATURE_WAITPKG,\n+  FEATURE_WBNOINVD,\n+  FEATURE_XSAVE,\n+  FEATURE_XSAVEC,\n+  FEATURE_XSAVEOPT,\n+  FEATURE_XSAVES,\n+  CPU_FEATURE_MAX\n+};\n+\n+/* Size of __cpu_features2 array in libgcc/config/i386/cpuinfo.c.  */\n+#define SIZE_OF_CPU_FEATURES ((CPU_FEATURE_MAX - 1) / 32)\n+\n /* These are the values for vendor types, cpu types and subtypes.  Cpu\n    types and subtypes should be subtracted by the corresponding start\n    value.  */"}, {"sha": "57e709d6c43b9d1000c55635ecc5cecd09d6bf35", "filename": "gcc/config/i386/i386-builtins.c", "status": "modified", "additions": 58, "deletions": 89, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fconfig%2Fi386%2Fi386-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1890f2f0e210ef515c39728c54151372d36dd187/gcc%2Fconfig%2Fi386%2Fi386-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.c?ref=1890f2f0e210ef515c39728c54151372d36dd187", "patch": "@@ -1835,50 +1835,6 @@ ix86_builtin_reciprocal (tree fndecl)\n     }\n }\n \n-/* This is the order of bit-fields in __processor_features in cpuinfo.c */\n-enum processor_features\n-{\n-  F_CMOV = 0,\n-  F_MMX,\n-  F_POPCNT,\n-  F_SSE,\n-  F_SSE2,\n-  F_SSE3,\n-  F_SSSE3,\n-  F_SSE4_1,\n-  F_SSE4_2,\n-  F_AVX,\n-  F_AVX2,\n-  F_SSE4_A,\n-  F_FMA4,\n-  F_XOP,\n-  F_FMA,\n-  F_AVX512F,\n-  F_BMI,\n-  F_BMI2,\n-  F_AES,\n-  F_PCLMUL,\n-  F_AVX512VL,\n-  F_AVX512BW,\n-  F_AVX512DQ,\n-  F_AVX512CD,\n-  F_AVX512ER,\n-  F_AVX512PF,\n-  F_AVX512VBMI,\n-  F_AVX512IFMA,\n-  F_AVX5124VNNIW,\n-  F_AVX5124FMAPS,\n-  F_AVX512VPOPCNTDQ,\n-  F_AVX512VBMI2,\n-  F_GFNI,\n-  F_VPCLMULQDQ,\n-  F_AVX512VNNI,\n-  F_AVX512BITALG,\n-  F_AVX512BF16,\n-  F_AVX512VP2INTERSECT,\n-  F_MAX\n-};\n-\n /* These are the target attribute strings for which a dispatcher is\n    available, from fold_builtin_cpu.  */\n struct _isa_names_table\n@@ -1890,44 +1846,44 @@ struct _isa_names_table\n \n static const _isa_names_table isa_names_table[] =\n {\n-  {\"cmov\",    F_CMOV,\tP_NONE},\n-  {\"mmx\",     F_MMX,\tP_MMX},\n-  {\"popcnt\",  F_POPCNT,\tP_POPCNT},\n-  {\"sse\",     F_SSE,\tP_SSE},\n-  {\"sse2\",    F_SSE2,\tP_SSE2},\n-  {\"sse3\",    F_SSE3,\tP_SSE3},\n-  {\"ssse3\",   F_SSSE3,\tP_SSSE3},\n-  {\"sse4a\",   F_SSE4_A,\tP_SSE4_A},\n-  {\"sse4.1\",  F_SSE4_1,\tP_SSE4_1},\n-  {\"sse4.2\",  F_SSE4_2,\tP_SSE4_2},\n-  {\"avx\",     F_AVX,\tP_AVX},\n-  {\"fma4\",    F_FMA4,\tP_FMA4},\n-  {\"xop\",     F_XOP,\tP_XOP},\n-  {\"fma\",     F_FMA,\tP_FMA},\n-  {\"avx2\",    F_AVX2,\tP_AVX2},\n-  {\"avx512f\", F_AVX512F, P_AVX512F},\n-  {\"bmi\",     F_BMI,\tP_BMI},\n-  {\"bmi2\",    F_BMI2,\tP_BMI2},\n-  {\"aes\",     F_AES,\tP_AES},\n-  {\"pclmul\",  F_PCLMUL,\tP_PCLMUL},\n-  {\"avx512vl\",F_AVX512VL, P_NONE},\n-  {\"avx512bw\",F_AVX512BW, P_NONE},\n-  {\"avx512dq\",F_AVX512DQ, P_NONE},\n-  {\"avx512cd\",F_AVX512CD, P_NONE},\n-  {\"avx512er\",F_AVX512ER, P_NONE},\n-  {\"avx512pf\",F_AVX512PF, P_NONE},\n-  {\"avx512vbmi\",F_AVX512VBMI, P_NONE},\n-  {\"avx512ifma\",F_AVX512IFMA, P_NONE},\n-  {\"avx5124vnniw\",F_AVX5124VNNIW, P_NONE},\n-  {\"avx5124fmaps\",F_AVX5124FMAPS, P_NONE},\n-  {\"avx512vpopcntdq\",F_AVX512VPOPCNTDQ,\tP_NONE},\n-  {\"avx512vbmi2\", F_AVX512VBMI2, P_NONE},\n-  {\"gfni\",\tF_GFNI,\tP_NONE},\n-  {\"vpclmulqdq\", F_VPCLMULQDQ, P_NONE},\n-  {\"avx512vnni\", F_AVX512VNNI, P_NONE},\n-  {\"avx512bitalg\", F_AVX512BITALG, P_NONE},\n-  {\"avx512bf16\", F_AVX512BF16, P_NONE},\n-  {\"avx512vp2intersect\",F_AVX512VP2INTERSECT, P_NONE}\n+  {\"cmov\",    FEATURE_CMOV,\tP_NONE},\n+  {\"mmx\",     FEATURE_MMX,\tP_MMX},\n+  {\"popcnt\",  FEATURE_POPCNT,\tP_POPCNT},\n+  {\"sse\",     FEATURE_SSE,\tP_SSE},\n+  {\"sse2\",    FEATURE_SSE2,\tP_SSE2},\n+  {\"sse3\",    FEATURE_SSE3,\tP_SSE3},\n+  {\"ssse3\",   FEATURE_SSSE3,\tP_SSSE3},\n+  {\"sse4a\",   FEATURE_SSE4_A,\tP_SSE4_A},\n+  {\"sse4.1\",  FEATURE_SSE4_1,\tP_SSE4_1},\n+  {\"sse4.2\",  FEATURE_SSE4_2,\tP_SSE4_2},\n+  {\"avx\",     FEATURE_AVX,\tP_AVX},\n+  {\"fma4\",    FEATURE_FMA4,\tP_FMA4},\n+  {\"xop\",     FEATURE_XOP,\tP_XOP},\n+  {\"fma\",     FEATURE_FMA,\tP_FMA},\n+  {\"avx2\",    FEATURE_AVX2,\tP_AVX2},\n+  {\"avx512f\", FEATURE_AVX512F, P_AVX512F},\n+  {\"bmi\",     FEATURE_BMI,\tP_BMI},\n+  {\"bmi2\",    FEATURE_BMI2,\tP_BMI2},\n+  {\"aes\",     FEATURE_AES,\tP_AES},\n+  {\"pclmul\",  FEATURE_PCLMUL,\tP_PCLMUL},\n+  {\"avx512vl\",FEATURE_AVX512VL, P_NONE},\n+  {\"avx512bw\",FEATURE_AVX512BW, P_NONE},\n+  {\"avx512dq\",FEATURE_AVX512DQ, P_NONE},\n+  {\"avx512cd\",FEATURE_AVX512CD, P_NONE},\n+  {\"avx512er\",FEATURE_AVX512ER, P_NONE},\n+  {\"avx512pf\",FEATURE_AVX512PF, P_NONE},\n+  {\"avx512vbmi\",FEATURE_AVX512VBMI, P_NONE},\n+  {\"avx512ifma\",FEATURE_AVX512IFMA, P_NONE},\n+  {\"avx5124vnniw\",FEATURE_AVX5124VNNIW, P_NONE},\n+  {\"avx5124fmaps\",FEATURE_AVX5124FMAPS, P_NONE},\n+  {\"avx512vpopcntdq\",FEATURE_AVX512VPOPCNTDQ,\tP_NONE},\n+  {\"avx512vbmi2\", FEATURE_AVX512VBMI2, P_NONE},\n+  {\"gfni\",\tFEATURE_GFNI,\tP_NONE},\n+  {\"vpclmulqdq\", FEATURE_VPCLMULQDQ, P_NONE},\n+  {\"avx512vnni\", FEATURE_AVX512VNNI, P_NONE},\n+  {\"avx512bitalg\", FEATURE_AVX512BITALG, P_NONE},\n+  {\"avx512bf16\", FEATURE_AVX512BF16, P_NONE},\n+  {\"avx512vp2intersect\",FEATURE_AVX512VP2INTERSECT, P_NONE}\n };\n \n /* This parses the attribute arguments to target in DECL and determines\n@@ -2294,16 +2250,29 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \n       if (isa_names_table[i].feature >= 32)\n \t{\n-\t  tree __cpu_features2_var = make_var_decl (unsigned_type_node,\n+\t  tree index_type\n+\t    = build_index_type (size_int (SIZE_OF_CPU_FEATURES));\n+\t  tree type = build_array_type (unsigned_type_node, index_type);\n+\t  tree __cpu_features2_var = make_var_decl (type,\n \t\t\t\t\t\t    \"__cpu_features2\");\n \n \t  varpool_node::add (__cpu_features2_var);\n-\t  field_val = (1U << (isa_names_table[i].feature - 32));\n-\t  /* Return __cpu_features2 & field_val  */\n-\t  final = build2 (BIT_AND_EXPR, unsigned_type_node,\n-\t\t\t  __cpu_features2_var,\n-\t\t\t  build_int_cstu (unsigned_type_node, field_val));\n-\t  return build1 (CONVERT_EXPR, integer_type_node, final);\n+\t  for (unsigned int j = 0; j < SIZE_OF_CPU_FEATURES; j++)\n+\t    if (isa_names_table[i].feature < (32 + 32 + j * 32))\n+\t      {\n+\t\tfield_val = (1U << (isa_names_table[i].feature\n+\t\t\t\t    - (32 + j * 32)));\n+\t\ttree index = size_int (j);\n+\t\tarray_elt = build4 (ARRAY_REF, unsigned_type_node,\n+\t\t\t\t    __cpu_features2_var,\n+\t\t\t\t    index, NULL_TREE, NULL_TREE);\n+\t\t/* Return __cpu_features2[index] & field_val  */\n+\t\tfinal = build2 (BIT_AND_EXPR, unsigned_type_node,\n+\t\t\t\tarray_elt,\n+\t\t\t\tbuild_int_cstu (unsigned_type_node,\n+\t\t\t\t\t\tfield_val));\n+\t\treturn build1 (CONVERT_EXPR, integer_type_node, final);\n+\t      }\n \t}\n \n       field = TYPE_FIELDS (__processor_model_type);"}, {"sha": "7218952f32a851bd4962d38ea972f384af9c95b7", "filename": "libgcc/config/i386/cpuinfo.c", "status": "modified", "additions": 9, "deletions": 456, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1890f2f0e210ef515c39728c54151372d36dd187/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1890f2f0e210ef515c39728c54151372d36dd187/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c?ref=1890f2f0e210ef515c39728c54151372d36dd187", "patch": "@@ -26,7 +26,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"cpuid.h\"\n #include \"tsystem.h\"\n #include \"auto-target.h\"\n-#include \"cpuinfo.h\"\n+#include \"common/config/i386/i386-cpuinfo.h\"\n+#include \"common/config/i386/cpuinfo.h\"\n \n #ifdef HAVE_INIT_PRIORITY\n #define CONSTRUCTOR_PRIORITY (101)\n@@ -39,386 +40,14 @@ int __cpu_indicator_init (void)\n \n \n struct __processor_model __cpu_model = { };\n-#ifndef SHARED\n /* We want to move away from __cpu_model in libgcc_s.so.1 and the\n    size of __cpu_model is part of ABI.  So, new features that don't\n    fit into __cpu_model.__cpu_features[0] go into extra variables\n-   in libgcc.a only, preferrably hidden.  */\n-unsigned int __cpu_features2;\n-#endif\n-\n-\n-/* Get the specific type of AMD CPU.  */\n-\n-static void\n-get_amd_cpu (unsigned int family, unsigned int model)\n-{\n-  switch (family)\n-    {\n-    /* AMD Family 10h.  */\n-    case 0x10:\n-      __cpu_model.__cpu_type = AMDFAM10H;\n-      switch (model)\n-\t{\n-\tcase 0x2:\n-\t  /* Barcelona.  */\n-\t  __cpu_model.__cpu_subtype = AMDFAM10H_BARCELONA;\n-\t  break;\n-\tcase 0x4:\n-\t  /* Shanghai.  */\n-\t  __cpu_model.__cpu_subtype = AMDFAM10H_SHANGHAI;\n-\t  break;\n-\tcase 0x8:\n-\t  /* Istanbul.  */\n-\t  __cpu_model.__cpu_subtype = AMDFAM10H_ISTANBUL;\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-      break;\n-    /* AMD Family 14h \"btver1\". */\n-    case 0x14:\n-      __cpu_model.__cpu_type = AMD_BTVER1;\n-      break;\n-    /* AMD Family 15h \"Bulldozer\".  */\n-    case 0x15:\n-      __cpu_model.__cpu_type = AMDFAM15H;\n-\n-      if (model == 0x2)\n-\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER2;      \n-      /* Bulldozer version 1.  */\n-      else if (model <= 0xf)\n-\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER1;\n-      /* Bulldozer version 2 \"Piledriver\" */\n-      else if (model <= 0x2f)\n-\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER2;      \n-      /* Bulldozer version 3 \"Steamroller\"  */\n-      else if (model <= 0x4f)\n-\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER3;\n-      /* Bulldozer version 4 \"Excavator\"   */\n-      else if (model <= 0x7f)\n-\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER4;\n-      break;\n-    /* AMD Family 16h \"btver2\" */\n-    case 0x16:\n-      __cpu_model.__cpu_type = AMD_BTVER2;\n-      break;\n-    case 0x17:\n-      __cpu_model.__cpu_type = AMDFAM17H;\n-      /* AMD family 17h version 1.  */\n-      if (model <= 0x1f)\n-\t__cpu_model.__cpu_subtype = AMDFAM17H_ZNVER1;\n-      if (model >= 0x30)\n-\t __cpu_model.__cpu_subtype = AMDFAM17H_ZNVER2;\n-      break;\n-    default:\n-      break;\n-    }\n-}\n-\n-/* Get the specific type of Intel CPU.  */\n-\n-static void\n-get_intel_cpu (unsigned int family, unsigned int model, unsigned int brand_id)\n-{\n-  /* Parse family and model only if brand ID is 0. */\n-  if (brand_id == 0)\n-    {\n-      switch (family)\n-\t{\n-\tcase 0x5:\n-\t  /* Pentium.  */\n-\t  break;\n-\tcase 0x6:\n-\t  switch (model)\n-\t    {\n-\t    case 0x1c:\n-\t    case 0x26:\n-\t      /* Bonnell.  */\n-\t      __cpu_model.__cpu_type = INTEL_BONNELL;\n-\t      break;\n-\t    case 0x37:\n-\t    case 0x4a:\n-\t    case 0x4d:\n-\t    case 0x5a:\n-\t    case 0x5d:\n-\t      /* Silvermont.  */\n-\t      __cpu_model.__cpu_type = INTEL_SILVERMONT;\n-\t      break;\n-\t    case 0x5c:\n-\t    case 0x5f:\n-\t      /* Goldmont.  */\n-\t      __cpu_model.__cpu_type = INTEL_GOLDMONT;\n-\t      break;\n-\t    case 0x7a:\n-\t      /* Goldmont Plus.  */\n-\t      __cpu_model.__cpu_type = INTEL_GOLDMONT_PLUS;\n-\t      break;\n-\t    case 0x57:\n-\t      /* Knights Landing.  */\n-\t      __cpu_model.__cpu_type = INTEL_KNL;\n-\t      break;\n-\t    case 0x85:\n-\t      /* Knights Mill. */\n-\t      __cpu_model.__cpu_type = INTEL_KNM;\n-\t      break;\n-\t    case 0x1a:\n-\t    case 0x1e:\n-\t    case 0x1f:\n-\t    case 0x2e:\n-\t      /* Nehalem.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_NEHALEM;\n-\t      break;\n-\t    case 0x25:\n-\t    case 0x2c:\n-\t    case 0x2f:\n-\t      /* Westmere.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_WESTMERE;\n-\t      break;\n-\t    case 0x2a:\n-\t    case 0x2d:\n-\t      /* Sandy Bridge.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_SANDYBRIDGE;\n-\t      break;\n-\t    case 0x3a:\n-\t    case 0x3e:\n-\t      /* Ivy Bridge.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_IVYBRIDGE;\n-\t      break;\n-\t    case 0x3c:\n-\t    case 0x3f:\n-\t    case 0x45:\n-\t    case 0x46:\n-\t      /* Haswell.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_HASWELL;\n-\t      break;\n-\t    case 0x3d:\n-\t    case 0x47:\n-\t    case 0x4f:\n-\t    case 0x56:\n-\t      /* Broadwell.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_BROADWELL;\n-\t      break;\n-\t    case 0x4e:\n-\t    case 0x5e:\n-\t      /* Skylake.  */\n-\t    case 0x8e:\n-\t    case 0x9e:\n-\t      /* Kaby Lake.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_SKYLAKE;\n-\t      break;\n-\t    case 0x55:\n-\t      {\n-\t        unsigned int eax, ebx, ecx, edx;\n-\t        __cpu_model.__cpu_type = INTEL_COREI7;\n-\t        __cpuid_count (7, 0, eax, ebx, ecx, edx);\n-\t        if (ecx & bit_AVX512VNNI)\n-\t          /* Cascade Lake.  */\n-\t          __cpu_model.__cpu_subtype = INTEL_COREI7_CASCADELAKE;\n-\t        else\n-\t          /* Skylake with AVX-512 support.  */\n-\t          __cpu_model.__cpu_subtype = INTEL_COREI7_SKYLAKE_AVX512;\n-\t      }\n-\t      break;\n-\t    case 0x66:\n-\t      /* Cannon Lake.  */\n-\t      __cpu_model.__cpu_type = INTEL_COREI7;\n-\t      __cpu_model.__cpu_subtype = INTEL_COREI7_CANNONLAKE;\n-\t      break;\n-\t    case 0x17:\n-\t    case 0x1d:\n-\t      /* Penryn.  */\n-\t    case 0x0f:\n-\t      /* Merom.  */\n-\t      __cpu_model.__cpu_type = INTEL_CORE2;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  /* We have no idea.  */\n-\t  break;\n-\t}\n-    }\n-}\t             \t\n-\n-/* ECX and EDX are output of CPUID at level one.  MAX_CPUID_LEVEL is\n-   the max possible level of CPUID insn.  */\n-static void\n-get_available_features (unsigned int ecx, unsigned int edx,\n-\t\t\tint max_cpuid_level)\n-{\n-  unsigned int eax, ebx;\n-  unsigned int ext_level;\n-\n-  unsigned int features = 0;\n-  unsigned int features2 = 0;\n-\n-  /* Get XCR_XFEATURE_ENABLED_MASK register with xgetbv.  */\n-#define XCR_XFEATURE_ENABLED_MASK\t0x0\n-#define XSTATE_FP\t\t\t0x1\n-#define XSTATE_SSE\t\t\t0x2\n-#define XSTATE_YMM\t\t\t0x4\n-#define XSTATE_OPMASK\t\t\t0x20\n-#define XSTATE_ZMM\t\t\t0x40\n-#define XSTATE_HI_ZMM\t\t\t0x80\n-\n-#define XCR_AVX_ENABLED_MASK \\\n-  (XSTATE_SSE | XSTATE_YMM)\n-#define XCR_AVX512F_ENABLED_MASK \\\n-  (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK | XSTATE_ZMM | XSTATE_HI_ZMM)\n-\n-  /* Check if AVX and AVX512 are usable.  */\n-  int avx_usable = 0;\n-  int avx512_usable = 0;\n-  if ((ecx & bit_OSXSAVE))\n-    {\n-      /* Check if XMM, YMM, OPMASK, upper 256 bits of ZMM0-ZMM15 and\n-         ZMM16-ZMM31 states are supported by OSXSAVE.  */\n-      unsigned int xcrlow;\n-      unsigned int xcrhigh;\n-      asm (\".byte 0x0f, 0x01, 0xd0\"\n-\t   : \"=a\" (xcrlow), \"=d\" (xcrhigh)\n-\t   : \"c\" (XCR_XFEATURE_ENABLED_MASK));\n-      if ((xcrlow & XCR_AVX_ENABLED_MASK) == XCR_AVX_ENABLED_MASK)\n-\t{\n-\t  avx_usable = 1;\n-\t  avx512_usable = ((xcrlow & XCR_AVX512F_ENABLED_MASK)\n-\t\t\t   == XCR_AVX512F_ENABLED_MASK);\n-\t}\n-    }\n-\n-#define set_feature(f) \\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (f < 32)\t\t\t\t\\\n-\tfeatures |= (1U << (f & 31));\t\t\\\n-      else\t\t\t\t\t\\\n-\tfeatures2 |= (1U << ((f - 32) & 31));\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-  if (edx & bit_CMOV)\n-    set_feature (FEATURE_CMOV);\n-  if (edx & bit_MMX)\n-    set_feature (FEATURE_MMX);\n-  if (edx & bit_SSE)\n-    set_feature (FEATURE_SSE);\n-  if (edx & bit_SSE2)\n-    set_feature (FEATURE_SSE2);\n-  if (ecx & bit_POPCNT)\n-    set_feature (FEATURE_POPCNT);\n-  if (ecx & bit_AES)\n-    set_feature (FEATURE_AES);\n-  if (ecx & bit_PCLMUL)\n-    set_feature (FEATURE_PCLMUL);\n-  if (ecx & bit_SSE3)\n-    set_feature (FEATURE_SSE3);\n-  if (ecx & bit_SSSE3)\n-    set_feature (FEATURE_SSSE3);\n-  if (ecx & bit_SSE4_1)\n-    set_feature (FEATURE_SSE4_1);\n-  if (ecx & bit_SSE4_2)\n-    set_feature (FEATURE_SSE4_2);\n-  if (avx_usable)\n-    {\n-      if (ecx & bit_AVX)\n-\tset_feature (FEATURE_AVX);\n-      if (ecx & bit_FMA)\n-\tset_feature (FEATURE_FMA);\n-    }\n-\n-  /* Get Advanced Features at level 7 (eax = 7, ecx = 0/1). */\n-  if (max_cpuid_level >= 7)\n-    {\n-      __cpuid_count (7, 0, eax, ebx, ecx, edx);\n-      if (ebx & bit_BMI)\n-\tset_feature (FEATURE_BMI);\n-      if (avx_usable)\n-\t{\n-\t  if (ebx & bit_AVX2)\n-\t    set_feature (FEATURE_AVX2);\n-\t  if (ecx & bit_VPCLMULQDQ)\n-\t    set_feature (FEATURE_VPCLMULQDQ);\n-\t}\n-      if (ebx & bit_BMI2)\n-\tset_feature (FEATURE_BMI2);\n-      if (ecx & bit_GFNI)\n-\tset_feature (FEATURE_GFNI);\n-      if (avx512_usable)\n-\t{\n-\t  if (ebx & bit_AVX512F)\n-\t    set_feature (FEATURE_AVX512F);\n-\t  if (ebx & bit_AVX512VL)\n-\t    set_feature (FEATURE_AVX512VL);\n-\t  if (ebx & bit_AVX512BW)\n-\t    set_feature (FEATURE_AVX512BW);\n-\t  if (ebx & bit_AVX512DQ)\n-\t    set_feature (FEATURE_AVX512DQ);\n-\t  if (ebx & bit_AVX512CD)\n-\t    set_feature (FEATURE_AVX512CD);\n-\t  if (ebx & bit_AVX512PF)\n-\t    set_feature (FEATURE_AVX512PF);\n-\t  if (ebx & bit_AVX512ER)\n-\t    set_feature (FEATURE_AVX512ER);\n-\t  if (ebx & bit_AVX512IFMA)\n-\t    set_feature (FEATURE_AVX512IFMA);\n-\t  if (ecx & bit_AVX512VBMI)\n-\t    set_feature (FEATURE_AVX512VBMI);\n-\t  if (ecx & bit_AVX512VBMI2)\n-\t    set_feature (FEATURE_AVX512VBMI2);\n-\t  if (ecx & bit_AVX512VNNI)\n-\t    set_feature (FEATURE_AVX512VNNI);\n-\t  if (ecx & bit_AVX512BITALG)\n-\t    set_feature (FEATURE_AVX512BITALG);\n-\t  if (ecx & bit_AVX512VPOPCNTDQ)\n-\t    set_feature (FEATURE_AVX512VPOPCNTDQ);\n-\t  if (edx & bit_AVX5124VNNIW)\n-\t    set_feature (FEATURE_AVX5124VNNIW);\n-\t  if (edx & bit_AVX5124FMAPS)\n-\t    set_feature (FEATURE_AVX5124FMAPS);\n-\t  if (edx & bit_AVX512VP2INTERSECT)\n-\t    set_feature (FEATURE_AVX512VP2INTERSECT);\n+   in libgcc.a only, preferably hidden.\n \n-\t  __cpuid_count (7, 1, eax, ebx, ecx, edx);\n-\t  if (eax & bit_AVX512BF16)\n-\t    set_feature (FEATURE_AVX512BF16);\n-\t}\n-    }\n-\n-  /* Check cpuid level of extended features.  */\n-  __cpuid (0x80000000, ext_level, ebx, ecx, edx);\n-\n-  if (ext_level >= 0x80000001)\n-    {\n-      __cpuid (0x80000001, eax, ebx, ecx, edx);\n-\n-      if (ecx & bit_SSE4a)\n-\tset_feature (FEATURE_SSE4_A);\n-      if (avx_usable)\n-\t{\n-\t  if (ecx & bit_FMA4)\n-\t    set_feature (FEATURE_FMA4);\n-\t  if (ecx & bit_XOP)\n-\t    set_feature (FEATURE_XOP);\n-\t}\n-    }\n-    \n-  __cpu_model.__cpu_features[0] = features;\n-#ifndef SHARED\n-  __cpu_features2 = features2;\n-#else\n-  (void) features2;\n-#endif\n-}\n+   NB: Since older 386-builtins.c accesses __cpu_features2 as scalar or\n+   smaller array, it can only access the first few elements.  */\n+unsigned int __cpu_features2[SIZE_OF_CPU_FEATURES];\n \n /* A constructor function that is sets __cpu_model and __cpu_features with\n    the right values.  This needs to run only once.  This constructor is\n@@ -429,85 +58,9 @@ get_available_features (unsigned int ecx, unsigned int edx,\n int __attribute__ ((constructor CONSTRUCTOR_PRIORITY))\n __cpu_indicator_init (void)\n {\n-  unsigned int eax, ebx, ecx, edx;\n-\n-  int max_level;\n-  unsigned int vendor;\n-  unsigned int model, family, brand_id;\n-  unsigned int extended_model, extended_family;\n-\n-  /* This function needs to run just once.  */\n-  if (__cpu_model.__cpu_vendor)\n-    return 0;\n-\n-  /* Assume cpuid insn present. Run in level 0 to get vendor id. */\n-  if (!__get_cpuid (0, &eax, &ebx, &ecx, &edx))\n-    {\n-      __cpu_model.__cpu_vendor = VENDOR_OTHER;\n-      return -1;\n-    }\n-\n-  vendor = ebx;\n-  max_level = eax;\n-\n-  if (max_level < 1)\n-    {\n-      __cpu_model.__cpu_vendor = VENDOR_OTHER;\n-      return -1;\n-    }\n-\n-  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-    {\n-      __cpu_model.__cpu_vendor = VENDOR_OTHER;\n-      return -1;\n-    }\n-\n-  model = (eax >> 4) & 0x0f;\n-  family = (eax >> 8) & 0x0f;\n-  brand_id = ebx & 0xff;\n-  extended_model = (eax >> 12) & 0xf0;\n-  extended_family = (eax >> 20) & 0xff;\n-\n-  if (vendor == signature_INTEL_ebx)\n-    {\n-      /* Adjust model and family for Intel CPUS. */\n-      if (family == 0x0f)\n-\t{\n-\t  family += extended_family;\n-\t  model += extended_model;\n-\t}\n-      else if (family == 0x06)\n-\tmodel += extended_model;\n-\n-      /* Get CPU type.  */\n-      get_intel_cpu (family, model, brand_id);\n-      /* Find available features. */\n-      get_available_features (ecx, edx, max_level);\n-      __cpu_model.__cpu_vendor = VENDOR_INTEL;\n-    }\n-  else if (vendor == signature_AMD_ebx)\n-    {\n-      /* Adjust model and family for AMD CPUS. */\n-      if (family == 0x0f)\n-\t{\n-\t  family += extended_family;\n-\t  model += extended_model;\n-\t}\n-\n-      /* Get CPU type.  */\n-      get_amd_cpu (family, model);\n-      /* Find available features. */\n-      get_available_features (ecx, edx, max_level);\n-      __cpu_model.__cpu_vendor = VENDOR_AMD;\n-    }\n-  else\n-    __cpu_model.__cpu_vendor = VENDOR_OTHER;\n-\n-  gcc_assert (__cpu_model.__cpu_vendor < VENDOR_MAX);\n-  gcc_assert (__cpu_model.__cpu_type < CPU_TYPE_MAX);\n-  gcc_assert (__cpu_model.__cpu_subtype < CPU_SUBTYPE_MAX);\n-\n-  return 0;\n+  struct __processor_model2 cpu_model2;\n+  return cpu_indicator_init (&__cpu_model, &cpu_model2,\n+\t\t\t     __cpu_features2);\n }\n \n #if defined SHARED && defined USE_ELF_SYMVER"}, {"sha": "0f97510cde105639a38a2fc68f04f57cec7188cc", "filename": "libgcc/config/i386/cpuinfo.h", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h?ref=eb0ff770e29715deb8b2e6f5da736e0c1e8f8d07", "patch": "@@ -1,136 +0,0 @@\n-/* Get CPU type and Features for x86 processors.\n-   Copyright (C) 2012-2020 Free Software Foundation, Inc.\n-   Contributed by Sriraman Tallam (tmsriram@google.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Processor Vendor and Models. */\n-\n-enum processor_vendor\n-{\n-  VENDOR_INTEL = 1,\n-  VENDOR_AMD,\n-  VENDOR_OTHER,\n-  VENDOR_MAX\n-};\n-\n-/* Any new types or subtypes have to be inserted at the end. */\n-\n-enum processor_types\n-{\n-  INTEL_BONNELL = 1,\n-  INTEL_CORE2,\n-  INTEL_COREI7,\n-  AMDFAM10H,\n-  AMDFAM15H,\n-  INTEL_SILVERMONT,\n-  INTEL_KNL,\n-  AMD_BTVER1,\n-  AMD_BTVER2,  \n-  AMDFAM17H,\n-  INTEL_KNM,\n-  INTEL_GOLDMONT,\n-  INTEL_GOLDMONT_PLUS,\n-  INTEL_TREMONT,\n-  CPU_TYPE_MAX\n-};\n-\n-enum processor_subtypes\n-{\n-  INTEL_COREI7_NEHALEM = 1,\n-  INTEL_COREI7_WESTMERE,\n-  INTEL_COREI7_SANDYBRIDGE,\n-  AMDFAM10H_BARCELONA,\n-  AMDFAM10H_SHANGHAI,\n-  AMDFAM10H_ISTANBUL,\n-  AMDFAM15H_BDVER1,\n-  AMDFAM15H_BDVER2,\n-  AMDFAM15H_BDVER3,\n-  AMDFAM15H_BDVER4,\n-  AMDFAM17H_ZNVER1,\n-  INTEL_COREI7_IVYBRIDGE,\n-  INTEL_COREI7_HASWELL,\n-  INTEL_COREI7_BROADWELL,\n-  INTEL_COREI7_SKYLAKE,\n-  INTEL_COREI7_SKYLAKE_AVX512,\n-  INTEL_COREI7_CANNONLAKE,\n-  INTEL_COREI7_ICELAKE_CLIENT,\n-  INTEL_COREI7_ICELAKE_SERVER,\n-  AMDFAM17H_ZNVER2,\n-  INTEL_COREI7_CASCADELAKE,\n-  INTEL_COREI7_TIGERLAKE,\n-  INTEL_COREI7_COOPERLAKE,\n-  CPU_SUBTYPE_MAX\n-};\n-\n-/* ISA Features supported. New features have to be inserted at the end.  */\n-\n-enum processor_features\n-{\n-  FEATURE_CMOV = 0,\n-  FEATURE_MMX,\n-  FEATURE_POPCNT,\n-  FEATURE_SSE,\n-  FEATURE_SSE2,\n-  FEATURE_SSE3,\n-  FEATURE_SSSE3,\n-  FEATURE_SSE4_1,\n-  FEATURE_SSE4_2,\n-  FEATURE_AVX,\n-  FEATURE_AVX2,\n-  FEATURE_SSE4_A,\n-  FEATURE_FMA4,\n-  FEATURE_XOP,\n-  FEATURE_FMA,\n-  FEATURE_AVX512F,\n-  FEATURE_BMI,\n-  FEATURE_BMI2,\n-  FEATURE_AES,\n-  FEATURE_PCLMUL,\n-  FEATURE_AVX512VL,\n-  FEATURE_AVX512BW,\n-  FEATURE_AVX512DQ,\n-  FEATURE_AVX512CD,\n-  FEATURE_AVX512ER,\n-  FEATURE_AVX512PF,\n-  FEATURE_AVX512VBMI,\n-  FEATURE_AVX512IFMA,\n-  FEATURE_AVX5124VNNIW,\n-  FEATURE_AVX5124FMAPS,\n-  FEATURE_AVX512VPOPCNTDQ,\n-  FEATURE_AVX512VBMI2,\n-  FEATURE_GFNI,\n-  FEATURE_VPCLMULQDQ,\n-  FEATURE_AVX512VNNI,\n-  FEATURE_AVX512BITALG,\n-  FEATURE_AVX512BF16,\n-  FEATURE_AVX512VP2INTERSECT\n-};\n-\n-extern struct __processor_model\n-{\n-  unsigned int __cpu_vendor;\n-  unsigned int __cpu_type;\n-  unsigned int __cpu_subtype;\n-  unsigned int __cpu_features[1];\n-} __cpu_model;\n-extern unsigned int __cpu_features2;"}]}