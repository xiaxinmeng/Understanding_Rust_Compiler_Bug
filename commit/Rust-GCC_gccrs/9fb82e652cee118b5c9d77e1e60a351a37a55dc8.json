{"sha": "9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiODJlNjUyY2VlMTE4YjVjOWQ3N2UxZTYwYTM1MWEzN2E1NWRjOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-08-09T18:32:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-08-09T18:32:02Z"}, "message": "PR c++/81359 - Unparsed NSDMI error from SFINAE context.\n\n\t* init.c (get_nsdmi): Add complain parm.\n\t* typeck2.c (digest_nsdmi_init): Add complain parm.\n\t(process_init_constructor_record): Pass complain to get_nsdmi.\n\t* pt.c (maybe_instantiate_noexcept): Add complain parm, return bool.\n\t* method.c (get_defaulted_eh_spec): Add complain parm.  Pass it into\n\tsynthesized_method_walk.\n\t(synthesized_method_walk): Adjust.\n\t(walk_field_subobs): Pass complain to get_nsdmi.\n\t(defaulted_late_check): Skip other checks if deleted.\n\t* decl2.c (mark_used): Pass complain to maybe_instantiate_noexcept.\n\t* call.c (build_aggr_conv): Pass complain to get_nsdmi.\n\t* parser.c (defarg_location): New.\n\t* error.c (location_of): Use it.\n\nFrom-SVN: r250994", "tree": {"sha": "1ff0784160f8c2d88777310405e7581704bfedb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ff0784160f8c2d88777310405e7581704bfedb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04d07b61cb80fd97e98eb39451ff6a8675a63d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d07b61cb80fd97e98eb39451ff6a8675a63d90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d07b61cb80fd97e98eb39451ff6a8675a63d90"}], "stats": {"total": 187, "additions": 129, "deletions": 58}, "files": [{"sha": "5476c1135b6994caed0b35674aa88d0d3d2f8113", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -1,3 +1,20 @@\n+2017-08-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/81359 - Unparsed NSDMI error from SFINAE context.\n+\t* init.c (get_nsdmi): Add complain parm.\n+\t* typeck2.c (digest_nsdmi_init): Add complain parm.\n+\t(process_init_constructor_record): Pass complain to get_nsdmi.\n+\t* pt.c (maybe_instantiate_noexcept): Add complain parm, return bool.\n+\t* method.c (get_defaulted_eh_spec): Add complain parm.  Pass it into\n+\tsynthesized_method_walk.\n+\t(synthesized_method_walk): Adjust.\n+\t(walk_field_subobs): Pass complain to get_nsdmi.\n+\t(defaulted_late_check): Skip other checks if deleted.\n+\t* decl2.c (mark_used): Pass complain to maybe_instantiate_noexcept.\n+\t* call.c (build_aggr_conv): Pass complain to get_nsdmi.\n+\t* parser.c (defarg_location): New.\n+\t* error.c (location_of): Use it.\n+\n 2017-08-09  Marek Polacek  <polacek@redhat.com>\n \n \t* parser.c (cp_parser_perform_range_for_lookup): Use false instead of 0."}, {"sha": "4903119adcad0116e75ba7a35c990d1cdeaf2810", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -916,7 +916,7 @@ build_aggr_conv (tree type, tree ctor, int flags, tsubst_flags_t complain)\n       if (i < CONSTRUCTOR_NELTS (ctor))\n \tval = CONSTRUCTOR_ELT (ctor, i)->value;\n       else if (DECL_INITIAL (field))\n-\tval = get_nsdmi (field, /*ctor*/false);\n+\tval = get_nsdmi (field, /*ctor*/false, complain);\n       else if (TREE_CODE (ftype) == REFERENCE_TYPE)\n \t/* Value-initialization of reference is ill-formed.  */\n \treturn NULL;"}, {"sha": "94738bd8f78aa578d857c062c70b917a3ed99b32", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -8093,8 +8093,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  continue;\n \n \t/* In C++17 we need the noexcept-qualifier to compare types.  */\n-\tif (flag_noexcept_type)\n-\t  maybe_instantiate_noexcept (fn);\n+\tif (flag_noexcept_type\n+\t    && !maybe_instantiate_noexcept (fn, complain))\n+\t  continue;\n \n \t/* See if there's a match.  */\n \ttree fntype = static_fn_type (fn);\n@@ -8176,7 +8177,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \n \t  /* In C++17 we need the noexcept-qualifier to compare types.  */\n \t  if (flag_noexcept_type)\n-\t    maybe_instantiate_noexcept (instantiation);\n+\t    maybe_instantiate_noexcept (instantiation, complain);\n \n \t  /* See if there's a match.  */\n \t  tree fntype = static_fn_type (instantiation);"}, {"sha": "3a0bd1687e8bdc5b78bc859db1b04d6bd7947fe3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -6297,7 +6297,7 @@ extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n-extern tree get_nsdmi\t\t\t\t(tree, bool);\n+extern tree get_nsdmi\t\t\t\t(tree, bool, tsubst_flags_t);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree throw_bad_array_new_length\t\t(void);\n@@ -6355,7 +6355,7 @@ extern bool trivial_fn_p\t\t\t(tree);\n extern tree forward_parm\t\t\t(tree);\n extern bool is_trivially_xible\t\t\t(enum tree_code, tree, tree);\n extern bool is_xible\t\t\t\t(enum tree_code, tree, tree);\n-extern tree get_defaulted_eh_spec\t\t(tree);\n+extern tree get_defaulted_eh_spec\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern void after_nsdmi_defaulted_late_checks   (tree);\n extern bool maybe_explain_implicit_delete\t(tree);\n extern void explain_implicit_non_constexpr\t(tree);\n@@ -6385,6 +6385,7 @@ extern tree cp_convert_range_for (tree, tree, tree, tree, unsigned int, bool);\n extern bool parsing_nsdmi (void);\n extern bool parsing_default_capturing_generic_lambda_in_template (void);\n extern void inject_this_parameter (tree, cp_cv_quals);\n+extern location_t defarg_location (tree);\n \n /* in pt.c */\n extern bool check_template_shadow\t\t(tree);\n@@ -6448,7 +6449,7 @@ extern int more_specialized_fn\t\t\t(tree, tree, int);\n extern void do_decl_instantiation\t\t(tree, tree);\n extern void do_type_instantiation\t\t(tree, tree, tsubst_flags_t);\n extern bool always_instantiate_p\t\t(tree);\n-extern void maybe_instantiate_noexcept\t\t(tree);\n+extern bool maybe_instantiate_noexcept\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree instantiate_decl\t\t\t(tree, bool, bool);\n extern int comp_template_parms\t\t\t(const_tree, const_tree);\n extern bool builtin_pack_fn_p\t\t\t(tree);\n@@ -7166,7 +7167,7 @@ extern tree split_nonconstant_init\t\t(tree, tree);\n extern bool check_narrowing\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int, tsubst_flags_t);\n-extern tree digest_nsdmi_init\t\t        (tree, tree);\n+extern tree digest_nsdmi_init\t\t        (tree, tree, tsubst_flags_t);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "8187ab9317de49355a8539d21407a6733a8399f6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -4988,8 +4988,9 @@ mark_used (tree decl, tsubst_flags_t complain)\n   if (TREE_CODE (decl) == CONST_DECL)\n     used_types_insert (DECL_CONTEXT (decl));\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    maybe_instantiate_noexcept (decl);\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && !maybe_instantiate_noexcept (decl, complain))\n+    return false;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DELETED_FN (decl))"}, {"sha": "31ca8fe1eb2a9a2d7b6e772529bb17361e3d24b9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -3046,6 +3046,8 @@ location_of (tree t)\n \n   if (DECL_P (t))\n     return DECL_SOURCE_LOCATION (t);\n+  if (TREE_CODE (t) == DEFAULT_ARG)\n+    return defarg_location (t);\n   return EXPR_LOC_OR_LOC (t, input_location);\n }\n "}, {"sha": "83e685c00119cdad95c37b07525436fa1929c794", "filename": "gcc/cp/init.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -536,7 +536,7 @@ perform_target_ctor (tree init)\n /* Return the non-static data initializer for FIELD_DECL MEMBER.  */\n \n tree\n-get_nsdmi (tree member, bool in_ctor)\n+get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n {\n   tree init;\n   tree save_ccp = current_class_ptr;\n@@ -554,50 +554,54 @@ get_nsdmi (tree member, bool in_ctor)\n     {\n       init = DECL_INITIAL (DECL_TI_TEMPLATE (member));\n       if (TREE_CODE (init) == DEFAULT_ARG)\n-\tgoto unparsed;\n-\n+\t/* Unparsed.  */;\n       /* Check recursive instantiation.  */\n-      if (DECL_INSTANTIATING_NSDMI_P (member))\n+      else if (DECL_INSTANTIATING_NSDMI_P (member))\n \t{\n-\t  error (\"recursive instantiation of non-static data member \"\n-\t\t \"initializer for %qD\", member);\n+\t  if (complain & tf_error)\n+\t    error (\"recursive instantiation of default member \"\n+\t\t   \"initializer for %qD\", member);\n \t  init = error_mark_node;\n \t}\n       else\n \t{\n \t  DECL_INSTANTIATING_NSDMI_P (member) = 1;\n-\t  \n+\n \t  /* Do deferred instantiation of the NSDMI.  */\n \t  init = (tsubst_copy_and_build\n \t\t  (init, DECL_TI_ARGS (member),\n-\t\t   tf_warning_or_error, member, /*function_p=*/false,\n+\t\t   complain, member, /*function_p=*/false,\n \t\t   /*integral_constant_expression_p=*/false));\n-\t  init = digest_nsdmi_init (member, init);\n+\t  init = digest_nsdmi_init (member, init, complain);\n \t  \n \t  DECL_INSTANTIATING_NSDMI_P (member) = 0;\n \t}\n     }\n   else\n+    init = DECL_INITIAL (member);\n+\n+  if (init && TREE_CODE (init) == DEFAULT_ARG)\n     {\n-      init = DECL_INITIAL (member);\n-      if (init && TREE_CODE (init) == DEFAULT_ARG)\n+      if (complain & tf_error)\n \t{\n-\tunparsed:\n-\t  error (\"constructor required before non-static data member \"\n-\t\t \"for %qD has been parsed\", member);\n+\t  error (\"default member initializer for %qD required before the end \"\n+\t\t \"of its enclosing class\", member);\n+\t  inform (location_of (init), \"defined here\");\n \t  DECL_INITIAL (member) = error_mark_node;\n-\t  init = error_mark_node;\n \t}\n-      /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n-\t so the aggregate init code below will see a CONSTRUCTOR.  */\n-      bool simple_target = (init && SIMPLE_TARGET_EXPR_P (init));\n-      if (simple_target)\n-\tinit = TARGET_EXPR_INITIAL (init);\n-      init = break_out_target_exprs (init);\n-      if (simple_target && TREE_CODE (init) != CONSTRUCTOR)\n-\t/* Now put it back so C++17 copy elision works.  */\n-\tinit = get_target_expr (init);\n+      init = error_mark_node;\n     }\n+\n+  /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n+     so the aggregate init code below will see a CONSTRUCTOR.  */\n+  bool simple_target = (init && SIMPLE_TARGET_EXPR_P (init));\n+  if (simple_target)\n+    init = TARGET_EXPR_INITIAL (init);\n+  init = break_out_target_exprs (init);\n+  if (simple_target && TREE_CODE (init) != CONSTRUCTOR)\n+    /* Now put it back so C++17 copy elision works.  */\n+    init = get_target_expr (init);\n+\n   current_class_ptr = save_ccp;\n   current_class_ref = save_ccr;\n   return init;\n@@ -644,7 +648,7 @@ perform_member_init (tree member, tree init)\n   /* Use the non-static data member initializer if there was no\n      mem-initializer for this field.  */\n   if (init == NULL_TREE)\n-    init = get_nsdmi (member, /*ctor*/true);\n+    init = get_nsdmi (member, /*ctor*/true, tf_warning_or_error);\n \n   if (init == error_mark_node)\n     return;"}, {"sha": "bff960513c0c9de3be9468d49a242b242723e84d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -1357,7 +1357,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t default constructor is noexcept(false).  */\n \t      if (spec_p)\n \t\t{\n-\t\t  tree nsdmi = get_nsdmi (field, /*ctor*/false);\n+\t\t  tree nsdmi = get_nsdmi (field, /*ctor*/false, complain);\n \t\t  if (!expr_noexcept_p (nsdmi, complain))\n \t\t    *spec_p = noexcept_false_spec;\n \t\t}\n@@ -1660,6 +1660,10 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     flags |= LOOKUP_DEFAULTED;\n \n   tsubst_flags_t complain = diag ? tf_warning_or_error : tf_none;\n+  if (diag && spec_p)\n+    /* We're in get_defaulted_eh_spec; we don't actually want any walking\n+       diagnostics, we just want complain set.  */\n+    diag = false;\n   int quals = const_p ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED;\n \n   for (binfo = TYPE_BINFO (ctype), i = 0;\n@@ -1749,7 +1753,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n    needed.  Return what it should be.  */\n \n tree\n-get_defaulted_eh_spec (tree decl)\n+get_defaulted_eh_spec (tree decl, tsubst_flags_t complain)\n {\n   if (DECL_CLONED_FUNCTION_P (decl))\n     decl = DECL_CLONED_FUNCTION (decl);\n@@ -1759,8 +1763,9 @@ get_defaulted_eh_spec (tree decl)\n   tree parm_type = TREE_VALUE (parms);\n   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n   tree spec = empty_except_spec;\n+  bool diag = !DECL_DELETED_FN (decl) && (complain & tf_error);\n   synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,\n-\t\t\t   NULL, false, DECL_INHERITED_CTOR (decl),\n+\t\t\t   NULL, diag, DECL_INHERITED_CTOR (decl),\n \t\t\t   parms);\n   return spec;\n }\n@@ -2173,6 +2178,12 @@ defaulted_late_check (tree fn)\n \t\t\"does not match expected signature %qD\", implicit_fn);\n     }\n \n+  if (DECL_DELETED_FN (implicit_fn))\n+    {\n+      DECL_DELETED_FN (fn) = 1;\n+      return;\n+    }\n+\n   /* 8.4.2/2: An explicitly-defaulted function (...) may have an explicit\n      exception-specification only if it is compatible (15.4) with the \n      exception-specification on the implicit declaration.  If a function\n@@ -2231,9 +2242,6 @@ defaulted_late_check (tree fn)\n \t}\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;\n     }\n-\n-  if (DECL_DELETED_FN (implicit_fn))\n-    DECL_DELETED_FN (fn) = 1;\n }\n \n /* OK, we've parsed the NSDMI for class T, now we can check any explicit"}, {"sha": "9d989a7f84fb984d11ea03bf38fb07c1691eed82", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -27431,7 +27431,7 @@ cp_parser_late_parse_one_default_arg (cp_parser *parser, tree decl,\n       else if (maybe_reject_flexarray_init (decl, parsed_arg))\n \tparsed_arg = error_mark_node;\n       else\n-\tparsed_arg = digest_nsdmi_init (decl, parsed_arg);\n+\tparsed_arg = digest_nsdmi_init (decl, parsed_arg, tf_warning_or_error);\n     }\n \n   /* If the token stream has not been completely used up, then\n@@ -28681,6 +28681,17 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n   return default_argument;\n }\n \n+/* A location to use for diagnostics about an unparsed DEFAULT_ARG.  */\n+\n+location_t\n+defarg_location (tree default_argument)\n+{\n+  cp_token_cache *tokens = DEFARG_TOKENS (default_argument);\n+  location_t start = tokens->first->location;\n+  location_t end = tokens->last->location;\n+  return make_location (start, start, end);\n+}\n+\n /* Begin parsing tentatively.  We always save tokens while parsing\n    tentatively so that if the tentative parsing fails we can restore the\n    tokens.  */"}, {"sha": "3d6f4b512b536484c7add41d645580c20f4e2b91", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -22493,24 +22493,25 @@ always_instantiate_p (tree decl)\n }\n \n /* If FN has a noexcept-specifier that hasn't been instantiated yet,\n-   instantiate it now, modifying TREE_TYPE (fn).  */\n+   instantiate it now, modifying TREE_TYPE (fn).  Returns false on\n+   error, true otherwise.  */\n \n-void\n-maybe_instantiate_noexcept (tree fn)\n+bool\n+maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n {\n   tree fntype, spec, noex, clone;\n \n   /* Don't instantiate a noexcept-specification from template context.  */\n   if (processing_template_decl)\n-    return;\n+    return true;\n \n   if (DECL_CLONED_FUNCTION_P (fn))\n     fn = DECL_CLONED_FUNCTION (fn);\n   fntype = TREE_TYPE (fn);\n   spec = TYPE_RAISES_EXCEPTIONS (fntype);\n \n   if (!spec || !TREE_PURPOSE (spec))\n-    return;\n+    return true;\n \n   noex = TREE_PURPOSE (spec);\n \n@@ -22519,7 +22520,7 @@ maybe_instantiate_noexcept (tree fn)\n       static hash_set<tree>* fns = new hash_set<tree>;\n       bool added = false;\n       if (DEFERRED_NOEXCEPT_PATTERN (noex) == NULL_TREE)\n-\tspec = get_defaulted_eh_spec (fn);\n+\tspec = get_defaulted_eh_spec (fn, complain);\n       else if (!(added = !fns->add (fn)))\n \t{\n \t  /* If hash_set::add returns true, the element was already there.  */\n@@ -22553,6 +22554,9 @@ maybe_instantiate_noexcept (tree fn)\n       if (added)\n \tfns->remove (fn);\n \n+      if (spec == error_mark_node)\n+\treturn false;\n+\n       TREE_TYPE (fn) = build_exception_variant (fntype, spec);\n     }\n \n@@ -22563,6 +22567,8 @@ maybe_instantiate_noexcept (tree fn)\n       else\n \tTREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);\n     }\n+\n+  return true;\n }\n \n /* Produce the definition of D, a _DECL generated from a template.  If"}, {"sha": "06c079e41be077d5a55dafc344390ba2a7225339", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -1182,7 +1182,7 @@ digest_init_flags (tree type, tree init, int flags, tsubst_flags_t complain)\n \n /* Process the initializer INIT for an NSDMI DECL (a FIELD_DECL).  */\n tree\n-digest_nsdmi_init (tree decl, tree init)\n+digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n {\n   gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n@@ -1192,8 +1192,8 @@ digest_nsdmi_init (tree decl, tree init)\n     flags = LOOKUP_NORMAL;\n   if (BRACE_ENCLOSED_INITIALIZER_P (init)\n       && CP_AGGREGATE_TYPE_P (type))\n-    init = reshape_init (type, init, tf_warning_or_error);\n-  init = digest_init_flags (type, init, flags, tf_warning_or_error);\n+    init = reshape_init (type, init, complain);\n+  init = digest_init_flags (type, init, flags, complain);\n   if (TREE_CODE (init) == TARGET_EXPR)\n     /* This represents the whole initialization.  */\n     TARGET_EXPR_DIRECT_INIT_P (init) = true;\n@@ -1427,7 +1427,7 @@ process_init_constructor_record (tree type, tree init,\n \t      goto restart;\n \t    }\n \t  /* C++14 aggregate NSDMI.  */\n-\t  next = get_nsdmi (field, /*ctor*/false);\n+\t  next = get_nsdmi (field, /*ctor*/false, complain);\n \t}\n       else if (type_build_ctor_call (TREE_TYPE (field)))\n \t{\n@@ -1525,7 +1525,8 @@ process_init_constructor_union (tree type, tree init,\n \t    {\n \t      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (init),\n \t\t\t\t      field,\n-\t\t\t\t      get_nsdmi (field, /*in_ctor=*/false));\n+\t\t\t\t      get_nsdmi (field, /*in_ctor=*/false,\n+\t\t\t\t\t\t complain));\n \t      break;\n \t    }\n \t}"}, {"sha": "056d16dca4a1ddb883cf94952dd81399aaa9f143", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-defer6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-defer6.C?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -2,7 +2,7 @@\n \n struct A\n {\n-  int i = (A(), 42);\t\t// { dg-error \"constructor required\" }\n+  int i = (A(), 42);\t\t// { dg-error \"\" }\n };\n \n A a;"}, {"sha": "a885a2412796a883be99c3aae5282c664643fbc5", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-template14.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -3,14 +3,14 @@\n \n template<int> struct A\n {\n-  int i = (A<0>(), 0); // { dg-error \"recursive instantiation of non-static data\" }\n+  int i = (A<0>(), 0); // { dg-error \"recursive instantiation of default\" }\n };\n \n A<0> a;\n \n template<int N> struct B\n {\n-  B* p = new B<N>; // { dg-error \"recursive instantiation of non-static data\" }\n+  B* p = new B<N>; // { dg-error \"recursive instantiation of default\" }\n };\n \n B<1> x;"}, {"sha": "d8588b7f29ea0a77fa5038e4c2927a50c946631b", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi10.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi10.C?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -6,13 +6,13 @@ struct A1 {\n     int y1 = 1;\n   };\n \n-  A1(const B1& opts = B1()) {}  // { dg-error \"constructor\" }\n+  A1(const B1& opts = B1()) {}  // { dg-error \"default member initializer\" }\n };\n \n struct A2 {\n   struct B2 {\n     int x2, y2 = 1;\n   };\n \n-  A2(const B2& opts = B2()) {}  // { dg-error \"constructor\" }\n+  A2(const B2& opts = B2()) {}  // { dg-error \"default member initializer\" }\n };"}, {"sha": "d1c730b6d231aadc6c9718f51827bee5a4646991", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae59.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae59.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82e652cee118b5c9d77e1e60a351a37a55dc8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae59.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae59.C?ref=9fb82e652cee118b5c9d77e1e60a351a37a55dc8", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/81359\n+// { dg-do compile { target c++11 } }\n+\n+template<typename _Tp, typename = decltype(_Tp())>\n+static int test(int);\n+\n+template<typename>\n+static void test(...);\n+\n+template <class T, class = decltype(test<T>(0))>\n+struct A { };\n+\n+struct B\n+{\n+  struct C {\n+    int i = 0;\n+  };\n+  A<C> a;\n+};"}]}