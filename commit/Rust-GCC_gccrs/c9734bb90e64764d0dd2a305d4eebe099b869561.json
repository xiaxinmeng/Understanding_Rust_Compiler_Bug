{"sha": "c9734bb90e64764d0dd2a305d4eebe099b869561", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk3MzRiYjkwZTY0NzY0ZDBkZDJhMzA1ZDRlZWJlMDk5Yjg2OTU2MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-12T22:59:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-12T22:59:51Z"}, "message": "(expand_inline_function): Use single_set when appropriate.\n\nDelete insn that sets static_chain_incoming_rtx before its use.\n(subst_constants): Treat virtual reg as constant.\n\nFrom-SVN: r7910", "tree": {"sha": "7c0b0675a0f343546ac8ae231d3e70c75467a01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c0b0675a0f343546ac8ae231d3e70c75467a01a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9734bb90e64764d0dd2a305d4eebe099b869561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9734bb90e64764d0dd2a305d4eebe099b869561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9734bb90e64764d0dd2a305d4eebe099b869561", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9734bb90e64764d0dd2a305d4eebe099b869561/comments", "author": null, "committer": null, "parents": [{"sha": "426749e8af8eb4b0838ea81aaa9c41138ff160de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426749e8af8eb4b0838ea81aaa9c41138ff160de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426749e8af8eb4b0838ea81aaa9c41138ff160de"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "1f4874cacbd93a4c8d22037faf10bae56d3ef094", "filename": "gcc/integrate.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9734bb90e64764d0dd2a305d4eebe099b869561/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9734bb90e64764d0dd2a305d4eebe099b869561/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c9734bb90e64764d0dd2a305d4eebe099b869561", "patch": "@@ -1645,14 +1645,15 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {\n-      rtx copy, pattern;\n+      rtx copy, pattern, set;\n \n       map->orig_asm_operands_vector = 0;\n \n       switch (GET_CODE (insn))\n \t{\n \tcase INSN:\n \t  pattern = PATTERN (insn);\n+\t  set = single_set (insn);\n \t  copy = 0;\n \t  if (GET_CODE (pattern) == USE\n \t      && GET_CODE (XEXP (pattern, 0)) == REG\n@@ -1664,33 +1665,47 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n \t  /* Ignore setting a function value that we don't want to use.  */\n \t  if (map->inline_target == 0\n-\t      && GET_CODE (pattern) == SET\n-\t      && GET_CODE (SET_DEST (pattern)) == REG\n-\t      && REG_FUNCTION_VALUE_P (SET_DEST (pattern)))\n+\t      && set != 0\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REG_FUNCTION_VALUE_P (SET_DEST (set)))\n \t    {\n-\t      if (volatile_refs_p (SET_SRC (pattern)))\n+\t      if (volatile_refs_p (SET_SRC (set)))\n \t\t{\n+\t\t  rtx new_set;\n+\n \t\t  /* If we must not delete the source,\n \t\t     load it into a new temporary.  */\n \t\t  copy = emit_insn (copy_rtx_and_substitute (pattern, map));\n-\t\t  SET_DEST (PATTERN (copy)) \n-\t\t    = gen_reg_rtx (GET_MODE (SET_DEST (PATTERN (copy))));\n+\n+\t\t  new_set = single_set (copy);\n+\t\t  if (new_set == 0)\n+\t\t    abort ();\n+\n+\t\t  SET_DEST (new_set)\n+\t\t    = gen_reg_rtx (GET_MODE (SET_DEST (new_set)));\n \t\t}\n \t      else\n \t\tbreak;\n \t    }\n+\n+\t  /* If this is setting the static chain rtx, omit it.  */\n+\t  else if (static_chain_value != 0\n+\t\t   && set != 0\n+\t\t   && GET_CODE (SET_DEST (set)) == REG\n+\t\t   && rtx_equal_p (SET_DEST (set),\n+\t\t\t\t   static_chain_incoming_rtx))\n+\t    break;\n+\n \t  /* If this is setting the static chain pseudo, set it from\n \t     the value we want to give it instead.  */\n \t  else if (static_chain_value != 0\n-\t\t   && GET_CODE (pattern) == SET\n-\t\t   && rtx_equal_p (SET_SRC (pattern),\n+\t\t   && set != 0\n+\t\t   && rtx_equal_p (SET_SRC (set),\n \t\t\t\t   static_chain_incoming_rtx))\n \t    {\n-\t      rtx newdest = copy_rtx_and_substitute (SET_DEST (pattern), map);\n-\n-\t      copy = emit_insn (gen_rtx (SET, VOIDmode, newdest,\n-\t\t\t\t\t static_chain_value));\n+\t      rtx newdest = copy_rtx_and_substitute (SET_DEST (set), map);\n \n+\t      copy = emit_move_insn (newdest, static_chain_value);\n \t      static_chain_value = 0;\n \t    }\n \t  else\n@@ -2590,6 +2605,9 @@ subst_constants (loc, insn, map)\n \t/* If storing a recognizable value save it for later recording.  */\n \tif ((map->num_sets < MAX_RECOG_OPERANDS)\n \t    && (CONSTANT_P (src)\n+\t\t|| (GET_CODE (src) == REG\n+\t\t    && REGNO (src) >= FIRST_VIRTUAL_REGISTER\n+\t\t    && REGNO (src) <= LAST_VIRTUAL_REGISTER)\n \t\t|| (GET_CODE (src) == PLUS\n \t\t    && GET_CODE (XEXP (src, 0)) == REG\n \t\t    && REGNO (XEXP (src, 0)) >= FIRST_VIRTUAL_REGISTER"}]}