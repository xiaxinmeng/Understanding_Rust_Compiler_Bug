{"sha": "6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExNTFmODc2N2VlYjliYjg0ZWM2MDg0ZTUyYTNhNzAzYjQ5MjVkMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-11-26T09:48:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-11-26T09:48:21Z"}, "message": "re PR target/6466 (backend uses bad type for frame size calculation.)\n\n\tPR target/6466\n\t* config/sparc/sparc-protos.h (compute_frame_size): New prototype.\n\t(sparc_flat_compute_frame_size): Likewise.\n\t(sparc_flat_save_restore): Move prototype...\n\t* config/sparc/sparc.c (sparc_flat_save_restore): ...here.\n\t(save_regs): New prototype.\n\t(build_big_number): Likewise.\n\t(apparent_fsize): Change type to HOST_WIDE_INT.\n\t(actual_fsize): Likewise.\n\t(frame_base_offset): Likewise.\n\t(build_big_number): Add support for HOST_BITS_PER_WIDE_INT == 64.\n\tChange string descriptor to HOST_WIDE_INT_PRINT_DEC.\n\t[TARGET_ARCH64]: Use the sequence of sparc_emit_set_const64_longway\n\tto load a 64-bit constant.\n\t(sparc_nonflat_function_prologue): Change string descriptor to\n\tHOST_WIDE_INT_PRINT_DEC.  Change offset type to HOST_WIDE_INT.\n\t(output_restore_regs): Change offset type to HOST_WIDE_INT.\n\t(sparc_nonflat_function_epilogue): Change string descriptor to\n\tHOST_WIDE_INT_PRINT_DEC.  Use build_big_number.\n\t(output_sibcall): Change size type to HOST_WIDE_INT.  Use\n\tbuild_big_number.  Change string descriptor to HOST_WIDE_INT_PRINT_DEC.\n\t(sparc_frame_info): Change types for several components.\n\t(sparc_flat_compute_frame_size): Update types according to previous\n\tchange.\n\t(sparc_flat_function_prologue): Change string descriptor to\n\tHOST_WIDE_INT_PRINT_DEC.  Change offset type to int.  Use\n\tbuild_big_number.\n\t(sparc_flat_function_epilogue): Change offset type to int.\n\tRename 'size1' into 'reg_offset1'.  Change string descriptor to\n\tHOST_WIDE_INT_PRINT_DEC.  Use build_big_number.  Change big number\n\tlimit to 4096 instead of 4095.\n\n\t* config/sparc/sparc.c (mems_ok_for_ldd_peep): Change offset type to\n\tHOST_WIDE_INT.\n\nCo-Authored-By: Olivier Hainque <hainque@act-europe.fr>\n\nFrom-SVN: r73942", "tree": {"sha": "5f762e4fc2d50adec84015020a78d86674f05b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f762e4fc2d50adec84015020a78d86674f05b78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bc7a740215a43a3189aeeb5caa8381582cf5816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc7a740215a43a3189aeeb5caa8381582cf5816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc7a740215a43a3189aeeb5caa8381582cf5816"}], "stats": {"total": 379, "additions": 250, "deletions": 129}, "files": [{"sha": "81a7a47056537f44ee19e370263dd8745f6a043b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "patch": "@@ -1,3 +1,41 @@\n+2003-11-26  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+            Olivier Hainque  <hainque@act-europe.fr>\n+\n+\tPR target/6466\n+\t* config/sparc/sparc-protos.h (compute_frame_size): New prototype.\n+\t(sparc_flat_compute_frame_size): Likewise.\n+\t(sparc_flat_save_restore): Move prototype...\n+\t* config/sparc/sparc.c (sparc_flat_save_restore): ...here.\n+\t(save_regs): New prototype.\n+\t(build_big_number): Likewise.\n+\t(apparent_fsize): Change type to HOST_WIDE_INT.\n+\t(actual_fsize): Likewise.\n+\t(frame_base_offset): Likewise.\n+\t(build_big_number): Add support for HOST_BITS_PER_WIDE_INT == 64.\n+\tChange string descriptor to HOST_WIDE_INT_PRINT_DEC.\n+\t[TARGET_ARCH64]: Use the sequence of sparc_emit_set_const64_longway\n+\tto load a 64-bit constant.\n+\t(sparc_nonflat_function_prologue): Change string descriptor to\n+\tHOST_WIDE_INT_PRINT_DEC.  Change offset type to HOST_WIDE_INT.\n+\t(output_restore_regs): Change offset type to HOST_WIDE_INT.\n+\t(sparc_nonflat_function_epilogue): Change string descriptor to\n+\tHOST_WIDE_INT_PRINT_DEC.  Use build_big_number.\n+\t(output_sibcall): Change size type to HOST_WIDE_INT.  Use\n+\tbuild_big_number.  Change string descriptor to HOST_WIDE_INT_PRINT_DEC.\n+\t(sparc_frame_info): Change types for several components.\n+\t(sparc_flat_compute_frame_size): Update types according to previous\n+\tchange.\n+\t(sparc_flat_function_prologue): Change string descriptor to\n+\tHOST_WIDE_INT_PRINT_DEC.  Change offset type to int.  Use\n+\tbuild_big_number.\n+\t(sparc_flat_function_epilogue): Change offset type to int.\n+\tRename 'size1' into 'reg_offset1'.  Change string descriptor to\n+\tHOST_WIDE_INT_PRINT_DEC.  Use build_big_number.  Change big number\n+\tlimit to 4096 instead of 4095.\n+\n+\t* config/sparc/sparc.c (mems_ok_for_ldd_peep): Change offset type to\n+\tHOST_WIDE_INT.\n+\n 2003-11-24  Waldek Hebisch <hebisch@math.uni.wroc.pl>\n \n \t* function.c: Make outer_function-chain external."}, {"sha": "12c5d2d8969356ced19e2303fe2fe6d0ff3ea4f8", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "patch": "@@ -1,7 +1,7 @@\n-/* Prototypes of target machine for GCC, for Sun SPARC.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* Prototypes of target machine for SPARC.\n+   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n-   64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n+   64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n \n This file is part of GCC.\n@@ -51,19 +51,15 @@ extern enum direction function_arg_padding (enum machine_mode, tree);\n \n extern void load_pic_register (void);\n extern void order_regs_for_local_alloc (void);\n-extern int compute_frame_size (int, int);\n+extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT, int);\n extern int check_pic (int);\n extern int short_branch (int, int);\n extern int sparc_flat_epilogue_delay_slots (void);\n-extern unsigned long sparc_flat_compute_frame_size (int);\n+extern HOST_WIDE_INT sparc_flat_compute_frame_size (HOST_WIDE_INT);\n extern void sparc_profile_hook (int);\n extern void sparc_override_options (void);\n extern int leaf_return_peephole_ok (void);\n extern void sparc_output_scratch_registers (FILE *);\n-extern void sparc_flat_save_restore (FILE *, const char *,\n-\t\t\t\t     unsigned int, unsigned long,\n-\t\t\t\t     unsigned long, const char *,\n-\t\t\t\t     const char *, unsigned long);\n \n #ifdef RTX_CODE\n extern enum machine_mode select_cc_mode (enum rtx_code, rtx, rtx);"}, {"sha": "d33fd18a5b48de817fc3d7836cf48b739c9eef58", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 207, "deletions": 120, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a151f8767eeb9bb84ec6084e52a3a703b4925d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6a151f8767eeb9bb84ec6084e52a3a703b4925d3", "patch": "@@ -67,8 +67,8 @@ Boston, MA 02111-1307, USA.  */\n    scheduling (to see what can go in a delay slot).\n    APPARENT_FSIZE is the size of the stack less the register save area and less\n    the outgoing argument area.  It is used when saving call preserved regs.  */\n-static int apparent_fsize;\n-static int actual_fsize;\n+static HOST_WIDE_INT apparent_fsize;\n+static HOST_WIDE_INT actual_fsize;\n \n /* Number of live general or floating point registers needed to be\n    saved (as 4-byte quantities).  */\n@@ -131,12 +131,12 @@ struct machine_function GTY(())\n    too big for reg+constant addressing.  */\n \n static const char *frame_base_name;\n-static int frame_base_offset;\n+static HOST_WIDE_INT frame_base_offset;\n \n static void sparc_init_modes (void);\n-static int save_regs (FILE *, int, int, const char *, int, int, int);\n+static int save_regs (FILE *, int, int, const char *, int, int, HOST_WIDE_INT);\n static int restore_regs (FILE *, int, int, const char *, int, int);\n-static void build_big_number (FILE *, int, const char *);\n+static void build_big_number (FILE *, HOST_WIDE_INT, const char *);\n static int function_arg_slotno (const CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\ttree, int, int, int *, int *);\n \n@@ -155,6 +155,10 @@ static void sparc_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void sparc_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void sparc_flat_function_epilogue (FILE *, HOST_WIDE_INT);\n static void sparc_flat_function_prologue (FILE *, HOST_WIDE_INT);\n+static void sparc_flat_save_restore (FILE *, const char *, int,\n+\t\t\t\t     unsigned long, unsigned long,\n+\t\t\t\t     const char *, const char *,\n+\t\t\t\t     HOST_WIDE_INT);\n static void sparc_nonflat_function_epilogue (FILE *, HOST_WIDE_INT, int);\n static void sparc_nonflat_function_prologue (FILE *, HOST_WIDE_INT, int);\n #ifdef OBJECT_FORMAT_ELF\n@@ -3994,7 +3998,7 @@ sparc_init_modes (void)\n \n static int\n save_regs (FILE *file, int low, int high, const char *base,\n-\t   int offset, int n_regs, int real_offset)\n+\t   int offset, int n_regs, HOST_WIDE_INT real_offset)\n {\n   int i;\n \n@@ -4101,8 +4105,8 @@ restore_regs (FILE *file, int low, int high, const char *base,\n /* Compute the frame size required by the function.  This function is called\n    during the reload pass and also by output_function_prologue().  */\n \n-int\n-compute_frame_size (int size, int leaf_function)\n+HOST_WIDE_INT\n+compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n {\n   int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n@@ -4156,32 +4160,97 @@ compute_frame_size (int size, int leaf_function)\n   return SPARC_STACK_ALIGN (actual_fsize);\n }\n \n-/* Build a (32 bit) big number in a register.  */\n-/* ??? We may be able to use the set macro here too.  */\n+/* Build big number NUM in register REG and output the result to FILE.\n+   REG is guaranteed to be the only clobbered register.  The function\n+   will very likely emit several instructions, so it must not be called\n+   from within a delay slot.  */\n \n static void\n-build_big_number (FILE *file, int num, const char *reg)\n+build_big_number (FILE *file, HOST_WIDE_INT num, const char *reg)\n {\n-  if (num >= 0 || ! TARGET_ARCH64)\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  HOST_WIDE_INT high_bits = (num >> 32) & 0xffffffff;\n+\n+  if (high_bits == 0\n+#else\n+  if (num >= 0\n+#endif\n+      || ! TARGET_ARCH64)\n     {\n-      fprintf (file, \"\\tsethi\\t%%hi(%d), %s\\n\", num, reg);\n+      /* We don't use the 'set' macro because it appears to be broken\n+\t in the Solaris 7 assembler.  */\n+      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n+\t       num, reg);\n       if ((num & 0x3ff) != 0)\n-\tfprintf (file, \"\\tor\\t%s, %%lo(%d), %s\\n\", reg, num, reg);\n+\tfprintf (file, \"\\tor\\t%s, %%lo(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n+\t\t reg, num, reg);\n     }\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  else if (high_bits == 0xffffffff) /* && TARGET_ARCH64 */\n+#else\n   else /* num < 0 && TARGET_ARCH64 */\n+#endif\n     {\n       /* Sethi does not sign extend, so we must use a little trickery\n \t to use it for negative numbers.  Invert the constant before\n \t loading it in, then use xor immediate to invert the loaded bits\n \t (along with the upper 32 bits) to the desired constant.  This\n \t works because the sethi and immediate fields overlap.  */\n-      int asize = num;\n-      int inv = ~asize;\n-      int low = -0x400 + (asize & 0x3FF);\n+      HOST_WIDE_INT inv = ~num;\n+      HOST_WIDE_INT low = -0x400 + (num & 0x3ff);\n \t  \n-      fprintf (file, \"\\tsethi\\t%%hi(%d), %s\\n\\txor\\t%s, %d, %s\\n\",\n-\t       inv, reg, reg, low, reg);\n+      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n+\t       inv, reg);\n+      fprintf (file, \"\\txor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t       reg, low, reg);\n     }\n+#if HOST_BITS_PER_WIDE_INT == 64\n+  else /* TARGET_ARCH64 */\n+    {\n+      /* We don't use the 'setx' macro because if requires a scratch register.\n+         This is the translation of sparc_emit_set_const64_longway into asm.\n+         Hopefully we will soon have prologue/epilogue emitted as RTL.  */\n+      HOST_WIDE_INT low1 = (num >> (32 - 12))          & 0xfff;\n+      HOST_WIDE_INT low2 = (num >> (32 - 12 - 12))     & 0xfff;\n+      HOST_WIDE_INT low3 = (num >> (32 - 12 - 12 - 8)) & 0x0ff;\n+      int to_shift = 12;\n+\n+      /* We don't use the 'set' macro because it appears to be broken\n+\t in the Solaris 7 assembler.  */\n+      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n+\t       high_bits, reg);\n+      if ((high_bits & 0x3ff) != 0)\n+\tfprintf (file, \"\\tor\\t%s, %%lo(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n+\t\t reg, high_bits, reg);\n+\n+      if (low1 != 0)\n+\t{\n+\t  fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n+\t  fprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t   reg, low1, reg);\n+\t  to_shift = 12;\n+\t}\n+      else\n+\t{\n+\t  to_shift += 12;\n+\t}\n+      if (low2 != 0)\n+\t{\n+\t  fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n+\t  fprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t   reg, low2, reg);\n+\t  to_shift = 8;\n+\t}\n+      else\n+\t{\n+\t  to_shift += 8;\n+\t}\n+      fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n+      if (low3 != 0)\n+\tfprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t reg, low3, reg);\n+    }\n+#endif\n }\n \n /* Output any necessary .register pseudo-ops.  */\n@@ -4266,11 +4335,13 @@ sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n   else if (! leaf_function)\n     {\n       if (actual_fsize <= 4096)\n-\tfprintf (file, \"\\tsave\\t%%sp, -%d, %%sp\\n\", actual_fsize);\n+\tfprintf (file, \"\\tsave\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n+\t\t actual_fsize);\n       else if (actual_fsize <= 8192)\n \t{\n \t  fprintf (file, \"\\tsave\\t%%sp, -4096, %%sp\\n\");\n-\t  fprintf (file, \"\\tadd\\t%%sp, -%d, %%sp\\n\", actual_fsize - 4096);\n+\t  fprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n+\t\t   actual_fsize - 4096);\n \t}\n       else\n \t{\n@@ -4281,11 +4352,13 @@ sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n   else /* leaf function */\n     {\n       if (actual_fsize <= 4096)\n-\tfprintf (file, \"\\tadd\\t%%sp, -%d, %%sp\\n\", actual_fsize);\n+\tfprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n+\t\t actual_fsize);\n       else if (actual_fsize <= 8192)\n \t{\n \t  fprintf (file, \"\\tadd\\t%%sp, -4096, %%sp\\n\");\n-\t  fprintf (file, \"\\tadd\\t%%sp, -%d, %%sp\\n\", actual_fsize - 4096);\n+\t  fprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n+\t\t   actual_fsize - 4096);\n \t}\n       else\n \t{\n@@ -4322,7 +4395,8 @@ sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n   /* Call saved registers are saved just above the outgoing argument area.  */\n   if (num_gfregs)\n     {\n-      int offset, real_offset, n_regs;\n+      HOST_WIDE_INT offset, real_offset;\n+      int n_regs;\n       const char *base;\n \n       real_offset = -apparent_fsize;\n@@ -4356,7 +4430,8 @@ sparc_nonflat_function_prologue (FILE *file, HOST_WIDE_INT size,\n static void\n output_restore_regs (FILE *file, int leaf_function ATTRIBUTE_UNUSED)\n {\n-  int offset, n_regs;\n+  HOST_WIDE_INT offset;\n+  int n_regs;\n   const char *base;\n \n   offset = -apparent_fsize + frame_base_offset;\n@@ -4518,16 +4593,16 @@ sparc_nonflat_function_epilogue (FILE *file,\n   else if (actual_fsize == 0)\n     fprintf (file, \"\\t%s\\n\\tnop\\n\", ret);\n   else if (actual_fsize <= 4096)\n-    fprintf (file, \"\\t%s\\n\\tsub\\t%%sp, -%d, %%sp\\n\", ret, actual_fsize);\n+    fprintf (file, \"\\t%s\\n\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n+\t     ret, actual_fsize);\n   else if (actual_fsize <= 8192)\n-    fprintf (file, \"\\tsub\\t%%sp, -4096, %%sp\\n\\t%s\\n\\tsub\\t%%sp, -%d, %%sp\\n\",\n+    fprintf (file, \"\\tsub\\t%%sp, -4096, %%sp\\n\\t%s\\n\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n \t     ret, actual_fsize - 4096);\n-  else if ((actual_fsize & 0x3ff) == 0)\n-    fprintf (file, \"\\tsethi\\t%%hi(%d), %%g1\\n\\t%s\\n\\tadd\\t%%sp, %%g1, %%sp\\n\",\n-\t     actual_fsize, ret);\n-  else\t\t \n-    fprintf (file, \"\\tsethi\\t%%hi(%d), %%g1\\n\\tor\\t%%g1, %%lo(%d), %%g1\\n\\t%s\\n\\tadd\\t%%sp, %%g1, %%sp\\n\",\n-\t     actual_fsize, actual_fsize, ret);\n+  else\n+    {\n+      build_big_number (file, actual_fsize, \"%g1\");\n+      fprintf (file, \"\\t%s\\n\\tadd\\t%%sp, %%g1, %%sp\\n\", ret);\n+    }\n \n  output_vectors:\n   sparc_output_deferred_case_vectors ();\n@@ -4575,7 +4650,7 @@ output_sibcall (rtx insn, rtx call_operand)\n #else\n       int spare_slot = ((TARGET_ARCH32 || TARGET_CM_MEDLOW) && ! flag_pic);\n #endif\n-      int size = 0;\n+      HOST_WIDE_INT size = 0;\n \n       if ((actual_fsize || ! spare_slot) && delay_slot)\n \t{\n@@ -4598,15 +4673,9 @@ output_sibcall (rtx insn, rtx call_operand)\n \t      fputs (\"\\tsub\\t%sp, -4096, %sp\\n\", asm_out_file);\n \t      size = actual_fsize - 4096;\n \t    }\n-\t  else if ((actual_fsize & 0x3ff) == 0)\n-\t    fprintf (asm_out_file,\n-\t\t     \"\\tsethi\\t%%hi(%d), %%g1\\n\\tadd\\t%%sp, %%g1, %%sp\\n\",\n-\t\t     actual_fsize);\n \t  else\n \t    {\n-\t      fprintf (asm_out_file,\n-\t\t       \"\\tsethi\\t%%hi(%d), %%g1\\n\\tor\\t%%g1, %%lo(%d), %%g1\\n\",\n-\t\t       actual_fsize, actual_fsize);\n+\t      build_big_number (asm_out_file, actual_fsize, \"%g1\");\n \t      fputs (\"\\tadd\\t%%sp, %%g1, %%sp\\n\", asm_out_file);\n \t    }\n \t}\n@@ -4615,14 +4684,14 @@ output_sibcall (rtx insn, rtx call_operand)\n \t  output_asm_insn (\"sethi\\t%%hi(%a0), %%g1\", operands);\n \t  output_asm_insn (\"jmpl\\t%%g1 + %%lo(%a0), %%g0\", operands);\n \t  if (size)\n-\t    fprintf (asm_out_file, \"\\t sub\\t%%sp, -%d, %%sp\\n\", size);\n+\t    fprintf (asm_out_file, \"\\t sub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\", size);\n \t  else if (! delay_slot)\n \t    fputs (\"\\t nop\\n\", asm_out_file);\n \t}\n       else\n \t{\n \t  if (size)\n-\t    fprintf (asm_out_file, \"\\tsub\\t%%sp, -%d, %%sp\\n\", size);\n+\t    fprintf (asm_out_file, \"\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\", size);\n \t  /* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize\n \t     it into branch if possible.  */\n \t  output_asm_insn (\"or\\t%%o7, %%g0, %%g1\", operands);\n@@ -6530,7 +6599,7 @@ mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n {\n   rtx addr1, addr2;\n   unsigned int reg1;\n-  int offset1;\n+  HOST_WIDE_INT offset1;\n \n   /* The mems cannot be volatile.  */\n   if (MEM_VOLATILE_P (mem1) || MEM_VOLATILE_P (mem2))\n@@ -6652,7 +6721,7 @@ print_operand (FILE *file, rtx x, int code)\n       /* Print out what we are using as the frame pointer.  This might\n \t be %fp, or might be %sp+offset.  */\n       /* ??? What if offset is too big? Perhaps the caller knows it isn't? */\n-      fprintf (file, \"%s+%d\", frame_base_name, frame_base_offset);\n+      fprintf (file, \"%s+\"HOST_WIDE_INT_PRINT_DEC, frame_base_name, frame_base_offset);\n       return;\n     case '&':\n       /* Print some local dynamic TLS name.  */\n@@ -7251,16 +7320,16 @@ sparc64_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n \n struct sparc_frame_info\n {\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up.  */\n-  unsigned long var_size;\t/* # bytes that variables take up.  */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up.  */\n-  unsigned long extra_size;\t/* # bytes of extra gunk.  */\n-  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n-  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n+  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up.  */\n+  HOST_WIDE_INT var_size;\t/* # bytes that variables take up.  */\n+  int           args_size;\t/* # bytes that outgoing arguments take up.  */\n+  int           extra_size;\t/* # bytes of extra gunk.  */\n+  int           gp_reg_size;\t/* # bytes needed to store gp regs.  */\n+  int           fp_reg_size;\t/* # bytes needed to store fp regs.  */\n   unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n   unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n-  unsigned long reg_offset;\t/* Offset from new sp to store regs.  */\n-  int\t\tinitialized;\t/* Nonzero if frame size already calculated.  */\n+  int           reg_offset;\t/* Offset from new sp to store regs.  */\n+  int           initialized;\t/* Nonzero if frame size already calculated.  */\n };\n \n /* Current frame information calculated by sparc_flat_compute_frame_size.  */\n@@ -7305,20 +7374,20 @@ sparc_flat_must_save_register_p (int regno)\n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.  */\n \n-unsigned long\n-sparc_flat_compute_frame_size (int size)\n+HOST_WIDE_INT\n+sparc_flat_compute_frame_size (HOST_WIDE_INT size)\n               \t\t\t/* # of var. bytes allocated.  */\n {\n   int regno;\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up.  */\n-  unsigned long var_size;\t/* # bytes that variables take up.  */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up.  */\n-  unsigned long extra_size;\t/* # extra bytes.  */\n-  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n-  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n+  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up.  */\n+  HOST_WIDE_INT var_size;\t/* # bytes that variables take up.  */\n+  int           args_size;\t/* # bytes that outgoing arguments take up.  */\n+  int           extra_size;\t/* # extra bytes.  */\n+  int           gp_reg_size;\t/* # bytes needed to store gp regs.  */\n+  int           fp_reg_size;\t/* # bytes needed to store fp regs.  */\n   unsigned long gmask;\t\t/* Mask of saved gp registers.  */\n   unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n-  unsigned long reg_offset;\t/* Offset to register save area.  */\n+  int           reg_offset;\t/* Offset to register save area.  */\n   int           need_aligned_p;\t/* 1 if need the save area 8 byte aligned.  */\n \n   /* This is the size of the 16 word reg save area, 1 word struct addr\n@@ -7424,12 +7493,11 @@ sparc_flat_compute_frame_size (int size)\n    WORD_OP is either \"st\" for save, \"ld\" for restore.\n    DOUBLEWORD_OP is either \"std\" for save, \"ldd\" for restore.  */\n \n-void\n-sparc_flat_save_restore (FILE *file, const char *base_reg,\n-\t\t\t unsigned int offset, long unsigned int gmask,\n-\t\t\t long unsigned int fmask, const char *word_op,\n-\t\t\t const char *doubleword_op,\n-\t\t\t long unsigned int base_offset)\n+static void\n+sparc_flat_save_restore (FILE *file, const char *base_reg, int offset,\n+\t\t\t unsigned long gmask, unsigned long fmask,\n+\t\t\t const char *word_op, const char *doubleword_op,\n+\t\t\t HOST_WIDE_INT base_offset)\n {\n   int regno;\n \n@@ -7533,7 +7601,8 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n \n   /* This is only for the human reader.  */\n   fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n-  fprintf (file, \"\\t%s# vars= %ld, regs= %d/%d, args= %d, extra= %ld\\n\",\n+  fprintf (file, \"\\t%s# vars= \"HOST_WIDE_INT_PRINT_DEC\", \"\n+\t\t \"regs= %d/%d, args= %d, extra= %d\\n\",\n \t   ASM_COMMENT_START,\n \t   current_frame_info.var_size,\n \t   current_frame_info.gp_reg_size / 4,\n@@ -7564,7 +7633,7 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n      after %i7 so gdb won't have to look too far to find it.  */\n   if (size > 0)\n     {\n-      unsigned int reg_offset = current_frame_info.reg_offset;\n+      int reg_offset = current_frame_info.reg_offset;\n       const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n       static const char *const t1_str = \"%g1\";\n \n@@ -7580,26 +7649,26 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n \t the gdb folk first.  */\n \n       /* Is the entire register save area offsettable from %sp?  */\n-      if (reg_offset < 4096 - 64 * (unsigned) UNITS_PER_WORD)\n+      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n \t{\n \t  if (size <= 4096)\n \t    {\n-\t      fprintf (file, \"\\tadd\\t%s, %d, %s\\n\",\n-\t\t       sp_str, (int) -size, sp_str);\n+\t      fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t       sp_str, size, sp_str);\n \t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n \t\t\t   fp_str, sp_str, reg_offset);\n-\t\t  fprintf (file, \"\\tsub\\t%s, %d, %s\\t%s# set up frame pointer\\n\",\n-\t\t\t   sp_str, (int) -size, fp_str, ASM_COMMENT_START);\n+\t\t  fprintf (file, \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n+\t\t  \t\t \"\\t%s# set up frame pointer\\n\",\n+\t\t\t   sp_str, size, fp_str, ASM_COMMENT_START);\n \t\t  reg_offset += 4;\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      fprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC\n-\t\t       \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n-\t\t       size, t1_str, sp_str, t1_str, sp_str);\n+\t      build_big_number (file, size, t1_str);\n+\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n \t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n@@ -7637,33 +7706,40 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n       else\n \t{\n \t  /* Subtract %sp in two steps, but make sure there is always a\n-\t     64 byte register save area, and %sp is properly aligned.  */\n+\t     64-byte register save area, and %sp is properly aligned.  */\n+\n \t  /* Amount to decrement %sp by, the first time.  */\n-\t  unsigned HOST_WIDE_INT size1 = ((size - reg_offset + 64) + 15) & -16;\n-\t  /* Offset to register save area from %sp.  */\n-\t  unsigned HOST_WIDE_INT offset = size1 - (size - reg_offset);\n+\t  HOST_WIDE_INT size1 = ((size - reg_offset + 64) + 15) & -16;\n+\n+\t  /* Amount to decrement %sp by, the second time.  */\n+\t  HOST_WIDE_INT size2 = size - size1;\n+\n+\t  /* Offset to register save area from %sp after first decrement.  */\n+\t  int offset = (int)(size1 - (size - reg_offset));\n \t  \n \t  if (size1 <= 4096)\n \t    {\n-\t      fprintf (file, \"\\tadd\\t%s, %d, %s\\n\",\n-\t\t       sp_str, (int) -size1, sp_str);\n+\t      fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t       sp_str, size1, sp_str);\n \t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\\tsub\\t%s, %d, %s\\t%s# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, (int) offset, sp_str, (int) -size1,\n+\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\"\n+\t\t\t\t \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n+\t\t\t\t \"\\t%s# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, size1,\n \t\t\t   fp_str, ASM_COMMENT_START);\n \t\t  offset += 4;\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      fprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC\n-\t\t       \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n-\t\t       size1, t1_str, sp_str, t1_str, sp_str);\n+\t      build_big_number (file, size1, t1_str);\n+\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n \t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\\tadd\\t%s, %s, %s\\t%s# set up frame pointer\\n\",\n-\t\t\t   fp_str, sp_str, (int) offset, sp_str, t1_str,\n+\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\"\n+\t\t\t\t \"\\tadd\\t%s, %s, %s\\t%s# set up frame pointer\\n\",\n+\t\t\t   fp_str, sp_str, offset, sp_str, t1_str,\n \t\t\t   fp_str, ASM_COMMENT_START);\n \t\t  offset += 4;\n \t\t}\n@@ -7683,7 +7759,7 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n \t  if (gmask & RETURN_ADDR_MASK)\n \t    {\n \t      fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, (int) offset);\n+\t\t       reg_names[RETURN_ADDR_REGNUM], sp_str, offset);\n \t      if (dwarf2out_do_frame ())\n \t\t/* offset - size1 == reg_offset - size\n \t\t   if reg_offset were updated above like offset.  */\n@@ -7694,9 +7770,14 @@ sparc_flat_function_prologue (FILE *file, HOST_WIDE_INT size)\n \t\t\t\t   gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t\t   current_frame_info.fmask,\n \t\t\t\t   \"st\", \"std\", -size1);\n-\t  fprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n-\t\t   size - size1, t1_str, sp_str, t1_str, sp_str);\n+\t  if (size2 <= 4096)\n+\t    fprintf (file, \"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t     sp_str, size2, sp_str);\n+\t  else\n+\t    {\n+\t      build_big_number (file, size2, t1_str);\n+\t      fprintf (file, \"\\tsub\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n+\t    }\n \t  if (dwarf2out_do_frame ())\n \t    if (! (gmask & HARD_FRAME_POINTER_MASK))\n \t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, size);\n@@ -7742,8 +7823,8 @@ sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \n   if (!noepilogue)\n     {\n-      unsigned HOST_WIDE_INT reg_offset = current_frame_info.reg_offset;\n-      unsigned HOST_WIDE_INT size1;\n+      int reg_offset = current_frame_info.reg_offset;\n+      int reg_offset1;\n       const char *const sp_str = reg_names[STACK_POINTER_REGNUM];\n       const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n       static const char *const t1_str = \"%g1\";\n@@ -7752,51 +7833,57 @@ sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \t slots for most of the loads, also see if we can fill the final\n \t delay slot if not otherwise filled by the reload sequence.  */\n \n-      if (size > 4095)\n-\tfprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC \", %s\\n\",\n-\t\t size, t1_str);\n+      if (size > 4096)\n+\tbuild_big_number (file, size, t1_str);\n \n       if (frame_pointer_needed)\n \t{\n-\t  if (size > 4095)\n+\t  if (size > 4096)\n \t    fprintf (file,\"\\tsub\\t%s, %s, %s\\t\\t%s# sp not trusted here\\n\",\n \t\t     fp_str, t1_str, sp_str, ASM_COMMENT_START);\n \t  else\n-\t    fprintf (file,\"\\tsub\\t%s, %d, %s\\t\\t%s# sp not trusted here\\n\",\n-\t\t     fp_str, (int) size, sp_str, ASM_COMMENT_START);\n+\t    fprintf (file,\"\\tadd\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\"\n+\t\t\t  \"\\t\\t%s# sp not trusted here\\n\",\n+\t\t     fp_str, size, sp_str, ASM_COMMENT_START);\n \t}\n \n       /* Is the entire register save area offsettable from %sp?  */\n-      if (reg_offset < 4096 - 64 * (unsigned) UNITS_PER_WORD)\n+      if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n \t{\n-\t  size1 = 0;\n+\t  reg_offset1 = 0;\n \t}\n       else\n \t{\n \t  /* Restore %sp in two steps, but make sure there is always a\n-\t     64 byte register save area, and %sp is properly aligned.  */\n+\t     64-byte register save area, and %sp is properly aligned.  */\n+\n \t  /* Amount to increment %sp by, the first time.  */\n-\t  size1 = ((reg_offset - 64 - 16) + 15) & -16;\n+\t  reg_offset1 = ((reg_offset - 64 - 16) + 15) & -16;\n+\n \t  /* Offset to register save area from %sp.  */\n-\t  reg_offset = size1 - reg_offset;\n+\t  reg_offset = reg_offset1 - reg_offset;\n \n-\t  fprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC\n-\t\t   \", %s\\n\\tadd\\t%s, %s, %s\\n\",\n-\t\t   size1, t1_str, sp_str, t1_str, sp_str);\n+\t  if (reg_offset1 > 4096)\n+\t    {\n+\t      build_big_number (file, reg_offset1, t1_str);\n+\t      fprintf (file, \"\\tadd\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\tsub\\t%s, -%d, %s\\n\", sp_str, reg_offset1, sp_str);\n \t}\n \n       /* We must restore the frame pointer and return address reg first\n \t because they are treated specially by the prologue output code.  */\n       if (current_frame_info.gmask & HARD_FRAME_POINTER_MASK)\n \t{\n \t  fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t   sp_str, (int) reg_offset, fp_str);\n+\t\t   sp_str, reg_offset, fp_str);\n \t  reg_offset += 4;\n \t}\n       if (current_frame_info.gmask & RETURN_ADDR_MASK)\n \t{\n \t  fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t   sp_str, (int) reg_offset, reg_names[RETURN_ADDR_REGNUM]);\n+\t\t   sp_str, reg_offset, reg_names[RETURN_ADDR_REGNUM]);\n \t  reg_offset += 4;\n \t}\n \n@@ -7808,12 +7895,11 @@ sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \n       /* If we had to increment %sp in two steps, record it so the second\n \t restoration in the epilogue finishes up.  */\n-      if (size1 > 0)\n+      if (reg_offset1 > 0)\n \t{\n-\t  size -= size1;\n-\t  if (size > 4095)\n-\t    fprintf (file, \"\\tset\\t\" HOST_WIDE_INT_PRINT_DEC \", %s\\n\",\n-\t\t     size, t1_str);\n+\t  size -= reg_offset1;\n+\t  if (size > 4096)\n+\t    build_big_number (file, size, t1_str);\n \t}\n \n       if (current_function_returns_struct)\n@@ -7833,11 +7919,12 @@ sparc_flat_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n \t}\n \n-      else if (size > 4095)\n+      else if (size > 4096)\n \tfprintf (file, \"\\tadd\\t%s, %s, %s\\n\", sp_str, t1_str, sp_str);\n \n       else if (size > 0)\n-\tfprintf (file, \"\\tadd\\t%s, %d, %s\\n\", sp_str, (int) size, sp_str);\n+\tfprintf (file, \"\\tsub\\t%s, -\"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n+\t\t sp_str, size, sp_str);\n \n       else\n \tfprintf (file, \"\\tnop\\n\");"}]}