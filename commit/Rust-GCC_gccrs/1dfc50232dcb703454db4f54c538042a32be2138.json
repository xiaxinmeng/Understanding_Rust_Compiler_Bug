{"sha": "1dfc50232dcb703454db4f54c538042a32be2138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRmYzUwMjMyZGNiNzAzNDU0ZGI0ZjU0YzUzODA0MmEzMmJlMjEzOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-17T14:56:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-17T14:56:12Z"}, "message": "i386: Fix up *testqi_ext_3 define_insn_and_split [PR94567]\n\nAs the testcase shows, there are unfortunately more problematic cases\nin *testqi_ext_3 if the mode is not CCZmode, because the sign flag might\nnot behave the same between the insn with zero_extract and what we split it\ninto.\n\nThe previous fix to the insn condition was because *testdi_1 for mask with\nupper 32-bits clear and bit 31 set is implemented using SImode test and thus\nSF is set depending on that bit 31 rather than on always cleared.\n\nBut we can have other cases.  On the zero_extract (which has <MODE>mode),\nwe can have either the pos + len == precision of <MODE>mode, or\npos + len < precision of <MODE>mode cases.  The former one copies the most\nsignificant bit into SF, the latter will have SF always cleared.\n\nFor the former case, either it is a zero_extract from a larger mode, but\nthen when we perform test in that larger mode, SF will be always clear and\nthus mismatch from the zero_extract case (so we need to enforce CCZmode),\nor it will be a zero_extract from same mode with pos 0 and len equal to\nmode precision, such zero_extracts should have been really simplified\ninto their first operand.\n\nFor the latter case, when SF is always clear on the define_insn with\nzero_extract, we need to split into something that doesn't sometimes set\nSF, i.e. it has to be a test with mask that doesn't have the most\nsignificant bit set.  In some cases it can be achieved through using test\nin a wider mode (e.g. in the testcase, there is\n(zero_extract:SI (reg:HI) (const_int 13) (const_int 3))\nwhich will always set SF to 0, but we split it into\n(and:HI (reg:HI) (const_int -8))\nwhich will copy the MSB of (reg:HI) into SF, but we can do:\n(and:SI (subreg:SI (reg:HI) 0) (const_int 0xfff8))\nwhich will keep SF always cleared), but there are various cases where we\ncan't (when already using DImode, or when SImode and we'd turned it into\nthe problematic *testdi_1 implemented using SImode test, or when\nthe val operand is a MEM (we don't want to read from memory more than\nthe user originally wanted), paradoxical subreg of MEM could be problematic\ntoo if we through the narrowing end up with a MEM).\n\nSo, the patch attempts to require CCZmode (and not CCNOmode) if it can't\nreally ensure the SF will have same meaning between the define_insn and what\nwe split it into, and if we decide we allow CCNOmode, it needs to avoid\nperforming narrowing and/or widen if pos + len would indicate we'd have MSB\nset in the mask.\n\n2020-04-17  Jakub Jelinek  <jakub@redhat.com>\n\t    Jeff Law  <law@redhat.com>\n\n\tPR target/94567\n\t* config/i386/i386.md (*testqi_ext_3): Use CCZmode rather than\n\tCCNOmode in ix86_match_ccmode if len is equal to <MODE>mode precision,\n\tor pos + len >= 32, or pos + len is equal to operands[2] precision\n\tand operands[2] is not a register operand.  During splitting perform\n\tSImode AND if operands[0] doesn't have CCZmode and pos + len is\n\tequal to mode precision.\n\n\t* gcc.c-torture/execute/pr94567.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>", "tree": {"sha": "52da94cd39485905022949855c8ca964e4f5bfec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52da94cd39485905022949855c8ca964e4f5bfec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dfc50232dcb703454db4f54c538042a32be2138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dfc50232dcb703454db4f54c538042a32be2138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dfc50232dcb703454db4f54c538042a32be2138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dfc50232dcb703454db4f54c538042a32be2138/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "256f2b632908ba46bb185c4850fc8e79dfdb9dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/256f2b632908ba46bb185c4850fc8e79dfdb9dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/256f2b632908ba46bb185c4850fc8e79dfdb9dbc"}], "stats": {"total": 106, "additions": 99, "deletions": 7}, "files": [{"sha": "1c010560c19f49a5f28ba599bfbb9dba914fb1d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1dfc50232dcb703454db4f54c538042a32be2138", "patch": "@@ -1,3 +1,14 @@\n+2020-04-17  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\tPR target/94567\n+\t* config/i386/i386.md (*testqi_ext_3): Use CCZmode rather than\n+\tCCNOmode in ix86_match_ccmode if len is equal to <MODE>mode precision,\n+\tor pos + len >= 32, or pos + len is equal to operands[2] precision\n+\tand operands[2] is not a register operand.  During splitting perform\n+\tSImode AND if operands[0] doesn't have CCZmode and pos + len is\n+\tequal to mode precision.\n+\n 2020-04-17  Richard Biener  <rguenther@suse.de>\n \n \tPR other/94629"}, {"sha": "b426c21d3ddd071a3579a3ed6c219b00c2d71584", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1dfc50232dcb703454db4f54c538042a32be2138", "patch": "@@ -8730,10 +8730,38 @@\n \t   && INTVAL (operands[3]) > 32\n \t   && INTVAL (operands[3]) + INTVAL (operands[4]) == 64))\n    && ix86_match_ccmode (insn,\n-\t\t\t /* *testdi_1 requires CCZmode if the mask has bit\n+\t\t\t /* If zero_extract mode precision is the same\n+\t\t\t    as len, the SF of the zero_extract\n+\t\t\t    comparison will be the most significant\n+\t\t\t    extracted bit, but this could be matched\n+\t\t\t    after splitting only for pos 0 len all bits\n+\t\t\t    trivial extractions.  Require CCZmode.  */\n+\t\t\t (GET_MODE_PRECISION (<MODE>mode)\n+\t\t\t  == INTVAL (operands[3]))\n+\t\t\t /* Otherwise, require CCZmode if we'd use a mask\n+\t\t\t    with the most significant bit set and can't\n+\t\t\t    widen it to wider mode.  *testdi_1 also\n+\t\t\t    requires CCZmode if the mask has bit\n \t\t\t    31 set and all bits above it clear.  */\n-\t\t\t GET_MODE (operands[2]) == DImode\n-\t\t\t && INTVAL (operands[3]) + INTVAL (operands[4]) == 32\n+\t\t\t || (INTVAL (operands[3]) + INTVAL (operands[4])\n+\t\t\t     >= 32)\n+\t\t\t /* We can't widen also if val is not a REG.  */\n+\t\t\t || (INTVAL (operands[3]) + INTVAL (operands[4])\n+\t\t\t     == GET_MODE_PRECISION (GET_MODE (operands[2]))\n+\t\t\t     && !register_operand (operands[2],\n+\t\t\t\t\t\t   GET_MODE (operands[2])))\n+\t\t\t /* And we shouldn't widen if\n+\t\t\t    TARGET_PARTIAL_REG_STALL.  */\n+\t\t\t || (TARGET_PARTIAL_REG_STALL\n+\t\t\t     && (INTVAL (operands[3]) + INTVAL (operands[4])\n+\t\t\t\t >= (paradoxical_subreg_p (operands[2])\n+\t\t\t\t     && (GET_MODE_CLASS\n+\t\t\t\t\t  (GET_MODE (SUBREG_REG (operands[2])))\n+\t\t\t\t\t == MODE_INT)\n+\t\t\t\t     ? GET_MODE_PRECISION\n+\t\t\t\t\t (GET_MODE (SUBREG_REG (operands[2])))\n+\t\t\t\t     : GET_MODE_PRECISION\n+\t\t\t\t\t (GET_MODE (operands[2])))))\n \t\t\t ? CCZmode : CCNOmode)\"\n   \"#\"\n   \"&& 1\"\n@@ -8750,22 +8778,43 @@\n \n       /* Narrow paradoxical subregs to prevent partial register stalls.  */\n       if (GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (submode)\n-\t  && GET_MODE_CLASS (submode) == MODE_INT)\n+\t  && GET_MODE_CLASS (submode) == MODE_INT\n+\t  && (GET_MODE (operands[0]) == CCZmode\n+\t      || pos + len < GET_MODE_PRECISION (submode)\n+\t      || REG_P (SUBREG_REG (val))))\n \t{\n \t  val = SUBREG_REG (val);\n \t  mode = submode;\n \t}\n     }\n \n   /* Small HImode tests can be converted to QImode.  */\n-  if (register_operand (val, HImode) && pos + len <= 8)\n+  if (pos + len <= 8\n+      && register_operand (val, HImode))\n     {\n-      val = gen_lowpart (QImode, val);\n-      mode = QImode;\n+      rtx nval = gen_lowpart (QImode, val);\n+      if (!MEM_P (nval)\n+\t  || GET_MODE (operands[0]) == CCZmode\n+\t  || pos + len < 8)\n+\t{\n+\t  val = nval;\n+\t  mode = QImode;\n+\t}\n     }\n \n   gcc_assert (pos + len <= GET_MODE_PRECISION (mode));\n \n+  /* If the mask is going to have the sign bit set in the mode\n+     we want to do the comparison in and user isn't interested just\n+     in the zero flag, then we must widen the target mode.  */\n+  if (pos + len == GET_MODE_PRECISION (mode)\n+      && GET_MODE (operands[0]) != CCZmode)\n+    {\n+      gcc_assert (pos + len < 32 && !MEM_P (val));\n+      mode = SImode;\n+      val = gen_lowpart (mode, val);\n+    }\n+\n   wide_int mask\n     = wi::shifted_mask (pos, len, false, GET_MODE_PRECISION (mode));\n "}, {"sha": "830ee92357e5bac7429b3b5026eb1378550ee30f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1dfc50232dcb703454db4f54c538042a32be2138", "patch": "@@ -1,3 +1,9 @@\n+2020-04-17  Jakub Jelinek  <jakub@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\tPR target/94567\n+\t* gcc.c-torture/execute/pr94567.c: New test.\n+\n 2020-04-17  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/94608"}, {"sha": "679d73d2ef42392eedbbb57cbac805db45a3be89", "filename": "gcc/testsuite/gcc.c-torture/execute/pr94567.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr94567.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dfc50232dcb703454db4f54c538042a32be2138/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr94567.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr94567.c?ref=1dfc50232dcb703454db4f54c538042a32be2138", "patch": "@@ -0,0 +1,26 @@\n+/* PR target/94567 */\n+\n+volatile int a = 1, b;\n+short c, d = 4, f = 2, g;\n+unsigned short e = 53736;\n+\n+int\n+foo (int i, int j)\n+{\n+  return i && j ? 0 : i + j;\n+}\n+\n+int\n+main ()\n+{\n+  for (; a; a = 0)\n+    {\n+      unsigned short k = e;\n+      g = k >> 3;\n+      if (foo (g < (f || c), b))\n+\td = 0;\n+    }\n+  if (d != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}