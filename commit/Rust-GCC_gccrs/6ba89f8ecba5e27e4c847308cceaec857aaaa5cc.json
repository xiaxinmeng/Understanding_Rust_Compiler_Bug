{"sha": "6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJhODlmOGVjYmE1ZTI3ZTRjODQ3MzA4Y2NlYWVjODU3YWFhYTVjYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-11-06T16:50:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-11-06T16:50:46Z"}, "message": "cp-tree.h (lang_decl_flags): Add defined_in_class.\n\n\t* cp-tree.h (lang_decl_flags): Add defined_in_class.  Decrease\n\tsize of dummy.\n\t(DECL_DEFINED_IN_CLASS_P): New macro.\n\t(TEMPLATE_PARMS_FOR_INLINE): Document.\n\t(check_static_variable_definition): New function.\n\t* decl.c (cp_finish_decl): Set DECL_DEFINED_IN_CLASS_P, if\n\tappropriate.\n\t(check_static_variable_definition): Split out from ...\n\t(grokdeclarator): Here.\n\t* pt.c (check_default_tmpl_args): New function, split out from ...\n\t(push_template_decl_real): Here.\n\t(instantiate_template): Fix comment.\n\nFrom-SVN: r23549", "tree": {"sha": "807068e3e7b12507ad2145dae78b50605cfdb525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/807068e3e7b12507ad2145dae78b50605cfdb525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/comments", "author": null, "committer": null, "parents": [{"sha": "955fc2e7df0f443cbf538a0ad2991e352f8ab1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/955fc2e7df0f443cbf538a0ad2991e352f8ab1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/955fc2e7df0f443cbf538a0ad2991e352f8ab1f6"}], "stats": {"total": 329, "additions": 243, "deletions": 86}, "files": [{"sha": "ef4908fd3e64996e2a1cfc3e0474ada60c28dd9e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -1,3 +1,18 @@\n+1998-11-06  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (lang_decl_flags): Add defined_in_class.  Decrease\n+\tsize of dummy.\n+\t(DECL_DEFINED_IN_CLASS_P): New macro.\n+\t(TEMPLATE_PARMS_FOR_INLINE): Document.\n+\t(check_static_variable_definition): New function.\n+\t* decl.c (cp_finish_decl): Set DECL_DEFINED_IN_CLASS_P, if\n+\tappropriate. \n+\t(check_static_variable_definition): Split out from ...\n+\t(grokdeclarator): Here.\n+\t* pt.c (check_default_tmpl_args): New function, split out from ...\n+\t(push_template_decl_real): Here.\n+\t(instantiate_template): Fix comment.\n+\t\n 1998-11-04  Mark Mitchell  <mark@markmitchell.com>\n \n \t* cp-tree.h (CP_TYPE_CONST_P): Make {0,1}-valued."}, {"sha": "d502f93189d4dcd8b2b1e0a99ff4c583c8345f2f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -1095,7 +1095,8 @@ struct lang_decl_flags\n   unsigned comdat : 1;\n   unsigned needs_final_overrider : 1;\n   unsigned bitfield : 1;\n-  unsigned dummy : 2;\n+  unsigned defined_in_class : 1;\n+  unsigned dummy : 1;\n \n   tree access;\n   tree context;\n@@ -1165,6 +1166,11 @@ struct lang_decl\n    should be allocated.  */\n #define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3(NODE))\n \n+/* Nonzero if the DECL was defined in the class definition itself,\n+   rather than outside the class.  */\n+#define DECL_DEFINED_IN_CLASS_P(DECL) \\\n+ (DECL_LANG_SPECIFIC (DECL)->decl_flags.defined_in_class)\n+\n /* Nonzero for FUNCTION_DECL means that this decl is just a\n    friend declaration, and should not be added to the list of\n    member functions for this class.  */\n@@ -1357,6 +1363,9 @@ struct lang_decl\n \n #define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE(NODE)\n \n+/* Nonzero if the NODE corresponds to the template parameters for a\n+   member template, whose inline definition is being processed after\n+   the class definition is complete.  */\n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n \n #define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n@@ -2682,6 +2691,7 @@ extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n extern void cat_namespace_levels                PROTO((void));\n extern void fixup_anonymous_union               PROTO((tree));\n+extern int check_static_variable_definition     PROTO((tree, tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));"}, {"sha": "6ed993e790ccd69c88ef30adc6c35fd7d521be80", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -7071,6 +7071,12 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       init = NULL_TREE;\n     }\n \n+  if (current_class_type\n+      && DECL_REAL_CONTEXT (decl) == current_class_type\n+      && TYPE_BEING_DEFINED (current_class_type)\n+      && (DECL_INITIAL (decl) || init))\n+    DECL_DEFINED_IN_CLASS_P (decl) = 1;\n+\n   if (TREE_CODE (decl) == VAR_DECL \n       && DECL_CONTEXT (decl)\n       && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL\n@@ -8493,6 +8499,41 @@ build_ptrmemfunc_type (type)\n \n enum return_types { return_normal, return_ctor, return_dtor, return_conversion };\n \n+/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.\n+   Check to see that the definition is valid.  Issue appropriate error\n+   messages.  Return 1 if the definition is particularly bad, or 0\n+   otherwise.  */\n+\n+int\n+check_static_variable_definition (decl, type)\n+     tree decl;\n+     tree type;\n+{\n+  /* Motion 10 at San Diego: If a static const integral data member is\n+     initialized with an integral constant expression, the initializer\n+     may appear either in the declaration (within the class), or in\n+     the definition, but not both.  If it appears in the class, the\n+     member is a member constant.  The file-scope definition is always\n+     required.  */\n+  if (CLASS_TYPE_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      cp_error (\"in-class initialization of static data member of non-integral type `%T'\", \n+\t\ttype);\n+      /* If we just return the declaration, crashes will sometimes\n+\t occur.  We therefore return void_type_node, as if this was a\n+\t friend declaration, to cause callers to completely ignore\n+\t this declaration.  */\n+      return 1;\n+    }\n+  else if (!CP_TYPE_CONST_P (type))\n+    cp_error (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n+\t      decl);\n+  else if (pedantic && !INTEGRAL_TYPE_P (type))\n+    cp_pedwarn (\"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n+\n+  return 0;\n+}\n+\n tree\n grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      tree declspecs;\n@@ -10660,31 +10701,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    staticp = 1;\n \t\t  }\n \n-\t\t/* Motion 10 at San Diego: If a static const integral data\n-\t\t   member is initialized with an integral constant\n-\t\t   expression, the initializer may appear either in the\n-\t\t   declaration (within the class), or in the definition,\n-\t\t   but not both.  If it appears in the class, the member is\n-\t\t   a member constant.  The file-scope definition is always\n-\t\t   required.  */\n-\t\tif (CLASS_TYPE_P (type)\n-\t\t    || TREE_CODE (type) == REFERENCE_TYPE)\n-\t\t  {\n-\t\t    cp_error (\"in-class initialization of static data member of non-integral type `%T'\", \n-\t\t\t      type);\n-\t\t    /* If we just return the declaration, crashes will\n-\t\t       sometimes occur.  We therefore return\n-\t\t       void_type_node, as if this was a friend\n-\t\t       declaration, to cause callers to completely\n-\t\t       ignore this declaration.  */\n-\t\t    return void_type_node;\n-\t\t  }\n-\t\telse if (!(type_quals & TYPE_QUAL_CONST))\n-\t\t  cp_error (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n-\t\t\t    declarator);\n-\t\telse if (pedantic && ! INTEGRAL_TYPE_P (type) \n-\t\t\t && !uses_template_parms (type))\n-\t\t  cp_pedwarn (\"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'\", declarator, type);\n+\t\tif (uses_template_parms (type))\n+\t\t  /* We'll check at instantiation time.  */\n+\t\t  ;\n+\t\telse if (check_static_variable_definition (declarator,\n+\t\t\t\t\t\t\t   type))\n+\t\t  /* If we just return the declaration, crashes\n+\t\t     will sometimes occur.  We therefore return\n+\t\t\t void_type_node, as if this was a friend\n+\t\t\t declaration, to cause callers to completely\n+\t\t\t ignore this declaration.  */\n+\t\t  return void_type_node;\n \t      }\n \n \t    if (staticp)"}, {"sha": "aa814566129cd698714ff5573d7b7d2c2a019b0c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 118, "deletions": 60, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -135,6 +135,7 @@ static tree tsubst_arg_types PROTO((tree, tree, tree));\n static void check_specialization_scope PROTO((void));\n static tree process_partial_specialization PROTO((tree));\n static void set_current_access_from_decl PROTO((tree));\n+static void check_default_tmpl_args PROTO((tree, tree, int, int));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -1853,28 +1854,9 @@ process_partial_specialization (decl)\n   int ntparms = TREE_VEC_LENGTH (inner_parms);\n   int  i;\n   int did_error_intro = 0;\n-  int issued_default_arg_message = 0;\n   struct template_parm_data tpd;\n   struct template_parm_data tpd2;\n \n-  /* [temp.class.spec]\n-     \n-     The template parameter list of a specialization shall not\n-     contain default template argument values.  */\n-  for (i = 0; i < ntparms; ++i) \n-    {\n-      if (TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)))\n-\t{\n-\t  if (!issued_default_arg_message)\n-\t    {\n-\t      cp_error (\"default argument in partial specialization `%T'\", \n-\t\t\ttype);\n-\t      issued_default_arg_message = 1;\n-\t    }\n-\t  TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)) = NULL_TREE;\n-\t}\n-    }\n-\n   /* We check that each of the template parameters given in the\n      partial specialization is used in the argument list to the\n      specialization.  For example:\n@@ -2029,6 +2011,107 @@ process_partial_specialization (decl)\n   return decl;\n }\n \n+/* Check that a template declaration's use of default arguments is not\n+   invalid.  Here, PARMS are the template parameters.  IS_PRIMARY is\n+   non-zero if DECL is the thing declared by a primary template.\n+   IS_PARTIAL is non-zero if DECL is a partial specialization.  */\n+\n+static void\n+check_default_tmpl_args (decl, parms, is_primary, is_partial)\n+     tree decl;\n+     tree parms;\n+     int is_primary;\n+     int is_partial;\n+{\n+  char* msg;\n+  int   last_level_to_check;\n+\n+  /* [temp.param] \n+\n+     A default template-argument shall not be specified in a\n+     function template declaration or a function template definition, nor\n+     in the template-parameter-list of the definition of a member of a\n+     class template.  */\n+\n+  if (current_class_type\n+      && !TYPE_BEING_DEFINED (current_class_type)\n+      && DECL_REAL_CONTEXT (decl) == current_class_type\n+      && DECL_DEFINED_IN_CLASS_P (decl)) \n+    /* We already checked these parameters when the template was\n+       declared, so there's no need to do it again now.  This is an\n+       inline member function definition.  */\n+    return;\n+\n+  if (TREE_CODE (decl) != TYPE_DECL || is_partial || !is_primary)\n+    /* For an ordinary class template, default template arguments are\n+       allowed at the innermost level, e.g.:\n+         template <class T = int>\n+\t struct S {};\n+       but, in a partial specialization, they're not allowed even\n+       there, as we have in [temp.class.spec]:\n+     \n+\t The template parameter list of a specialization shall not\n+\t contain default template argument values.  \n+\n+       So, for a partial specialization, or for a function template,\n+       we look at all of them.  */\n+    ;\n+  else\n+    /* But, for a primary class template that is not a partial\n+       specialization we look at all template parameters except the\n+       innermost ones.  */\n+    parms = TREE_CHAIN (parms);\n+\n+  /* Figure out what error message to issue.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    msg = \"default argument for template parameter in function template `%D'\";\n+  else if (is_partial)\n+    msg = \"default argument in partial specialization `%D'\";\n+  else\n+    msg = \"default argument for template parameter for class enclosing `%D'\";\n+\n+  if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n+    /* If we're inside a class definition, there's no need to\n+       examine the paramters to the class itself.  On the one\n+       hand, they will be checked when the class is defined, and,\n+       on the other, default arguments are legal in things like:\n+         template <class T = double>\n+         struct S { template <class U> void f(U); };\n+       Here the default argument for `S' has no bearing on the\n+       declaration of `f'.  */\n+    last_level_to_check = template_class_depth (current_class_type) + 1;\n+  else\n+    /* Check everything.  */\n+    last_level_to_check = 0;\n+\n+  for (; parms && TMPL_PARMS_DEPTH (parms) >= last_level_to_check; \n+       parms = TREE_CHAIN (parms))\n+    {\n+      tree inner_parms = TREE_VALUE (parms);\n+      int i, ntparms;\n+\n+      ntparms = TREE_VEC_LENGTH (inner_parms);\n+      for (i = 0; i < ntparms; ++i) \n+\tif (TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)))\n+\t  {\n+\t    if (msg)\n+\t      {\n+\t\tcp_error (msg, decl);\n+\t\tmsg = 0;\n+\t      }\n+\n+\t    /* Clear out the default argument so that we are not\n+\t       confused later.  */\n+\t    TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)) = NULL_TREE;\n+\t  }\n+\n+      /* At this point, if we're still interested in issuing messages,\n+\t they must apply to classes surrounding the object declared.  */\n+      if (msg)\n+\tmsg = \"default argument for template parameter for class enclosing `%D'\"; \n+    }\n+}\n+\n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n    parameters given by current_template_args, or reuses a\n    previously existing one, if appropriate.  Returns the DECL, or an\n@@ -2046,6 +2129,12 @@ push_template_decl_real (decl, is_friend)\n   tree info;\n   tree ctx;\n   int primary;\n+  int is_partial;\n+\n+  /* See if this is a partial specialization.  */\n+  is_partial = (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n+\t\t&& TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n+\t\t&& CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)));\n \n   is_friend |= (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl));\n \n@@ -2076,6 +2165,7 @@ push_template_decl_real (decl, is_friend)\n   else\n     info = ctx;\n \n+  /* See if this is a primary template.  */\n   if (info && TREE_CODE (info) == FUNCTION_DECL)\n     primary = 0;\n   /* Note that template_class_depth returns 0 if given NULL_TREE, so\n@@ -2096,47 +2186,13 @@ push_template_decl_real (decl, is_friend)\n \tcp_error (\"template declaration of `%#T'\", TREE_TYPE (decl));\n     }\n \n-  /* Partial specialization.  */\n-  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n-      && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n-      && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n-    return process_partial_specialization (decl);\n+  /* Check to see that the rules regarding the use of default\n+     arguments are not being violated.  */\n+  check_default_tmpl_args (decl, current_template_parms, \n+\t\t\t   primary, is_partial);\n \n-  /* [temp.param] A default template-argument shall not be specified in a\n-     function template declaration or a function template definition, nor\n-     in the template-parameter-list of the definition of a member of a\n-     class template.  */\n-  {\n-    tree parms;\n-    int issued_default_arg_message = 0;\n-\n-    parms = current_template_parms;\n-    if (primary)\n-      parms = TREE_CHAIN (parms);\n-    for (; parms; parms = TREE_CHAIN (parms))\n-      {\n-\ttree inner_parms = TREE_VALUE (parms);\n-\tint i, ntparms;\n-\n-\tif (TREE_TYPE (inner_parms))\n-\t  continue;\n-\n-\tntparms = TREE_VEC_LENGTH (inner_parms);\n-\tfor (i = 0; i < ntparms; ++i) \n-\t  {\n-\t    if (TREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)))\n-\t      {\n-\t\tif (!issued_default_arg_message)\n-\t\t  {\n-\t\t    cp_error (\"default argument for template parameter of class enclosing `%D'\", \n-\t\t\t      decl);\n-\t\t    issued_default_arg_message = 1;\n-\t\t  }\n-\t\tTREE_PURPOSE (TREE_VEC_ELT (inner_parms, i)) = NULL_TREE;\n-\t      }\n-\t  }\n-      }\n-  }\n+  if (is_partial)\n+    return process_partial_specialization (decl);\n \n   args = current_template_args ();\n \n@@ -4604,6 +4660,8 @@ instantiate_class_template (type)\n \t    DECL_IN_AGGR_P (r) = 1;\n \t    DECL_EXTERNAL (r) = 1;\n \t    cp_finish_decl (r, DECL_INITIAL (r), NULL_TREE, 0, 0);\n+\t    if (DECL_DEFINED_IN_CLASS_P (r))\n+\t      check_static_variable_definition (r, TREE_TYPE (r));\n \t  }\n \t\n \t/* R will have a TREE_CHAIN if and only if it has already been\n@@ -6468,7 +6526,7 @@ tsubst_expr (t, args, in_decl)\n   return NULL_TREE;\n }\n \n-/* Instantiate the indicated variable of function template TMPL with\n+/* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n \n tree"}, {"sha": "0094c5ca7e07c740f56711a714a5cf660b8cfc03", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg6.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg6.C?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -0,0 +1,27 @@\n+// Build don't link:\n+\n+template <class T>\n+struct C {\n+  template <class U>\n+  void f(U); // OK\n+\n+  template <class V = int>\n+  struct I {}; // OK\n+\n+  template <class W = int>\n+  void h(W); // ERROR - default argument\n+  \n+  template <class Y>\n+  void k(Y);\n+};\n+\n+template <class T>\n+template <class U = double>\n+void C<T>::f(U) {} // ERROR - default argument\n+\n+template <class X = void*>\n+void g(X); // ERROR - default argument\n+\n+template <class T = double>\n+template <class Y>\n+void C<T>::k(Y) {} // ERROR - default argument"}, {"sha": "0db043fb6338476a338eb9e75578b8696a7f605e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg7.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg7.C?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+template <int Dim, class T, class EngineTag>\n+class Engine {};\n+\n+struct Brick;\n+ \n+template<int Dim, class T = double , class EngineTag = Brick >\n+struct ConstArray {\n+  static const int dimensions = Engine<Dim, T, EngineTag>::dimensions;\n+};"}, {"sha": "f6e125dbfb7633245774ec28f2e1d53246d69be7", "filename": "gcc/testsuite/g++.old-deja/g++.pt/static5.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba89f8ecba5e27e4c847308cceaec857aaaa5cc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fstatic5.C?ref=6ba89f8ecba5e27e4c847308cceaec857aaaa5cc", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S\n+{\n+  static const T t = 3; // ERROR - initializing non-integral type\n+};\n+\n+double d = S<double>::t;"}]}