{"sha": "bf44701f955b9901565dc918d039fe38e8a58099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY0NDcwMWY5NTViOTkwMTU2NWRjOTE4ZDAzOWZlMzhlOGE1ODA5OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-25T21:09:25Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-25T21:09:25Z"}, "message": "decl.c (elaborate_expression): Take a const string suffix instead of a tree.\n\n\t* gcc-interface/decl.c (elaborate_expression): Take a const string\n\tsuffix instead of a tree.\n\t(elaborate_expression_1): Likewise.\n\t(elaborate_expression_2): Likewise.\n\t(gnat_to_gnu_entity): Adjust to above changes.\n\t(build_subst_list): Likewise.\n\t(get_entity_char): New static function.\n\nFrom-SVN: r223655", "tree": {"sha": "efde796058d24e621fd21046228133d675684fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efde796058d24e621fd21046228133d675684fa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf44701f955b9901565dc918d039fe38e8a58099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44701f955b9901565dc918d039fe38e8a58099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf44701f955b9901565dc918d039fe38e8a58099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf44701f955b9901565dc918d039fe38e8a58099/comments", "author": null, "committer": null, "parents": [{"sha": "5277688be09abdc754e56919ed6011caf7191ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5277688be09abdc754e56919ed6011caf7191ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5277688be09abdc754e56919ed6011caf7191ede"}], "stats": {"total": 132, "additions": 69, "deletions": 63}, "files": [{"sha": "38b9fa33c19c8fd5f7950c4b12b91b745cdd4910", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf44701f955b9901565dc918d039fe38e8a58099/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf44701f955b9901565dc918d039fe38e8a58099/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bf44701f955b9901565dc918d039fe38e8a58099", "patch": "@@ -1,3 +1,13 @@\n+2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (elaborate_expression): Take a const string\n+\tsuffix instead of a tree.\n+\t(elaborate_expression_1): Likewise.\n+\t(elaborate_expression_2): Likewise.\n+\t(gnat_to_gnu_entity): Adjust to above changes.\n+\t(build_subst_list): Likewise.\n+\t(get_entity_char): New static function.\n+\n 2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Move around."}, {"sha": "a4b398425ea8999d80e325d04fc9745c99d806f7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf44701f955b9901565dc918d039fe38e8a58099/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf44701f955b9901565dc918d039fe38e8a58099/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=bf44701f955b9901565dc918d039fe38e8a58099", "patch": "@@ -173,10 +173,11 @@ static void prepend_one_attribute (struct attrib **,\n \t\t\t\t   enum attr_type, tree, tree, Node_Id);\n static void prepend_one_attribute_pragma (struct attrib **, Node_Id);\n static void prepend_attributes (struct attrib **, Entity_Id);\n-static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n+static tree elaborate_expression (Node_Id, Entity_Id, const char *, bool, bool,\n+\t\t\t\t  bool);\n static bool type_has_variable_size (tree);\n-static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n-static tree elaborate_expression_2 (tree, Entity_Id, tree, bool, bool,\n+static tree elaborate_expression_1 (tree, Entity_Id, const char *, bool, bool);\n+static tree elaborate_expression_2 (tree, Entity_Id, const char *, bool, bool,\n \t\t\t\t    unsigned int);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n@@ -211,6 +212,7 @@ static tree create_variant_part_from (tree, vec<variant_desc> , tree,\n \t\t\t\t      tree, vec<subst_pair> );\n static void copy_and_substitute_in_size (tree, tree, vec<subst_pair> );\n static void add_parallel_type_for_packed_array (tree, Entity_Id);\n+static const char *get_entity_char (Entity_Id);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n    to pass around calls performing profile compatibility checks.  */\n@@ -782,8 +784,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       calculating it each time.  */\n \t    if (global_bindings_p () && !TREE_CONSTANT (gnu_size))\n \t      gnu_size = elaborate_expression_1 (gnu_size, gnat_entity,\n-\t\t\t\t\t\t get_identifier (\"SIZE\"),\n-\t\t\t\t\t\t definition, false);\n+\t\t\t\t\t\t \"SIZE\", definition, false);\n \t  }\n \n \t/* If the size is zero byte, make it one byte since some linkers have\n@@ -1782,14 +1783,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       SET_TYPE_RM_MIN_VALUE\n \t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t definition, true,\n+\t\t\t\t\t gnat_entity, \"L\", definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       SET_TYPE_RM_MAX_VALUE\n \t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t definition, true,\n+\t\t\t\t\t gnat_entity, \"U\", definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n@@ -1964,14 +1963,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       SET_TYPE_RM_MIN_VALUE\n \t(gnu_type, elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t definition, true,\n+\t\t\t\t\t gnat_entity, \"L\", definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       SET_TYPE_RM_MAX_VALUE\n \t(gnu_type, elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t definition, true,\n+\t\t\t\t\t gnat_entity, \"U\", definition, true,\n \t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n \n       /* Inherit our alias set from what we're a subtype of, as for\n@@ -2598,28 +2595,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     inner dimensions.   */\n \t  if (global_bindings_p () && ndim > 1)\n \t    {\n-\t      tree gnu_st_name = get_identifier (\"ST\");\n \t      tree gnu_arr_type;\n \n-\t      for (gnu_arr_type = TREE_TYPE (gnu_type);\n+\t      for (gnu_arr_type = TREE_TYPE (gnu_type), index = 1;\n \t\t   TREE_CODE (gnu_arr_type) == ARRAY_TYPE;\n-\t\t   gnu_arr_type = TREE_TYPE (gnu_arr_type),\n-\t\t   gnu_st_name = concat_name (gnu_st_name, \"ST\"))\n+\t\t   gnu_arr_type = TREE_TYPE (gnu_arr_type), index++)\n \t\t{\n \t\t  tree eltype = TREE_TYPE (gnu_arr_type);\n+\t\t  char stride_name[32];\n \n+\t\t  sprintf (stride_name, \"ST%d\", index);\n \t\t  TYPE_SIZE (gnu_arr_type)\n \t\t    = elaborate_expression_1 (TYPE_SIZE (gnu_arr_type),\n-\t\t\t\t\t      gnat_entity, gnu_st_name,\n+\t\t\t\t\t      gnat_entity, stride_name,\n \t\t\t\t\t      definition, false);\n \n \t\t  /* ??? For now, store the size as a multiple of the\n \t\t     alignment of the element type in bytes so that we\n \t\t     can see the alignment from the tree.  */\n+\t\t  sprintf (stride_name, \"ST%d_A_UNIT\", index);\n \t\t  TYPE_SIZE_UNIT (gnu_arr_type)\n \t\t    = elaborate_expression_2 (TYPE_SIZE_UNIT (gnu_arr_type),\n-\t\t\t\t\t      gnat_entity,\n-\t\t\t\t\t      concat_name (gnu_st_name, \"A_U\"),\n+\t\t\t\t\t      gnat_entity, stride_name,\n \t\t\t\t\t      definition, false,\n \t\t\t\t\t      TYPE_ALIGN (eltype));\n \n@@ -4914,16 +4911,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree size = TYPE_SIZE (gnu_type);\n \n \t  TYPE_SIZE (gnu_type)\n-\t    = elaborate_expression_1 (size, gnat_entity,\n-\t\t\t\t      get_identifier (\"SIZE\"),\n-\t\t\t\t      definition, false);\n+\t    = elaborate_expression_1 (size, gnat_entity, \"SIZE\", definition,\n+\t\t\t\t      false);\n \n \t  /* ??? For now, store the size as a multiple of the alignment in\n \t     bytes so that we can see the alignment from the tree.  */\n \t  TYPE_SIZE_UNIT (gnu_type)\n \t    = elaborate_expression_2 (TYPE_SIZE_UNIT (gnu_type), gnat_entity,\n-\t\t\t\t      get_identifier (\"SIZE_A_UNIT\"),\n-\t\t\t\t      definition, false,\n+\t\t\t\t      \"SIZE_A_UNIT\", definition, false,\n \t\t\t\t      TYPE_ALIGN (gnu_type));\n \n \t  /* ??? gnu_type may come from an existing type so the MULT_EXPR node\n@@ -4957,29 +4952,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    {\n \t\t      TYPE_SIZE (union_type)\n \t\t\t= elaborate_expression_1 (TYPE_SIZE (union_type),\n-\t\t\t\t\t\t  gnat_entity,\n-\t\t\t\t\t\t  get_identifier (\"VSIZE\"),\n+\t\t\t\t\t\t  gnat_entity, \"VSIZE\",\n \t\t\t\t\t\t  definition, false);\n \n \t\t      /* ??? For now, store the size as a multiple of the\n \t\t\t alignment in bytes so that we can see the alignment\n \t\t\t from the tree.  */\n \t\t      TYPE_SIZE_UNIT (union_type)\n \t\t\t= elaborate_expression_2 (TYPE_SIZE_UNIT (union_type),\n-\t\t\t\t\t\t  gnat_entity,\n-\t\t\t\t\t\t  get_identifier\n-\t\t\t\t\t\t  (\"VSIZE_A_UNIT\"),\n+\t\t\t\t\t\t  gnat_entity, \"VSIZE_A_UNIT\",\n \t\t\t\t\t\t  definition, false,\n \t\t\t\t\t\t  TYPE_ALIGN (union_type));\n \n \t\t      /* ??? For now, store the offset as a multiple of the\n \t\t\t alignment in bytes so that we can see the alignment\n \t\t\t from the tree.  */\n \t\t      DECL_FIELD_OFFSET (variant_part)\n-\t\t\t= elaborate_expression_2 (offset,\n-\t\t\t\t\t\t  gnat_entity,\n-\t\t\t\t\t\t  get_identifier (\"VOFFSET\"),\n-\t\t\t\t\t\t  definition, false,\n+\t\t\t= elaborate_expression_2 (offset, gnat_entity,\n+\t\t\t\t\t\t  \"VOFFSET\", definition, false,\n \t\t\t\t\t\t  DECL_OFFSET_ALIGN\n \t\t\t\t\t\t  (variant_part));\n \t\t    }\n@@ -4992,8 +4982,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tada_size = TYPE_SIZE (gnu_type);\n \t      else\n \t\tada_size\n-\t\t  = elaborate_expression_1 (ada_size, gnat_entity,\n-\t\t\t\t\t    get_identifier (\"RM_SIZE\"),\n+\t\t  = elaborate_expression_1 (ada_size, gnat_entity, \"RM_SIZE\",\n \t\t\t\t\t    definition, false);\n \t      SET_TYPE_ADA_SIZE (gnu_type, ada_size);\n \t    }\n@@ -5016,9 +5005,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t{\n \t\t  DECL_FIELD_OFFSET (gnu_field)\n \t\t    = elaborate_expression_2 (DECL_FIELD_OFFSET (gnu_field),\n-\t\t\t\t\t      gnat_temp,\n-\t\t\t\t\t      get_identifier (\"OFFSET\"),\n-\t\t\t\t\t      definition, false,\n+\t\t\t\t\t      gnat_temp, \"OFFSET\", definition,\n+\t\t\t\t\t      false,\n \t\t\t\t\t      DECL_OFFSET_ALIGN (gnu_field));\n \n \t\t  /* ??? The context of gnu_field is not necessarily gnu_type\n@@ -5982,11 +5970,11 @@ elaborate_entity (Entity_Id gnat_entity)\n \t   are needed until after the front stops generating bogus\n \t   conversions on bounds of real types.  */\n \tif (!Raises_Constraint_Error (gnat_lb))\n-\t  elaborate_expression (gnat_lb, gnat_entity, get_identifier (\"L\"),\n-\t\t\t\ttrue, false, Needs_Debug_Info (gnat_entity));\n+\t  elaborate_expression (gnat_lb, gnat_entity, \"L\", true, false,\n+\t\t\t\tNeeds_Debug_Info (gnat_entity));\n \tif (!Raises_Constraint_Error (gnat_hb))\n-\t  elaborate_expression (gnat_hb, gnat_entity, get_identifier (\"U\"),\n-\t\t\t\ttrue, false, Needs_Debug_Info (gnat_entity));\n+\t  elaborate_expression (gnat_hb, gnat_entity, \"U\", true, false,\n+\t\t\t\tNeeds_Debug_Info (gnat_entity));\n       break;\n       }\n \n@@ -6009,7 +5997,7 @@ elaborate_entity (Entity_Id gnat_entity)\n \t    /* Ignore access discriminants.  */\n \t    if (!Is_Access_Type (Etype (Node (gnat_discriminant_expr))))\n \t      elaborate_expression (Node (gnat_discriminant_expr),\n-\t\t\t\t    gnat_entity, get_entity_name (gnat_field),\n+\t\t\t\t    gnat_entity, get_entity_char (gnat_field),\n \t\t\t\t    true, false, false);\n \t}\n       break;\n@@ -6157,15 +6145,15 @@ prepend_attributes (struct attrib **attr_list, Entity_Id gnat_entity)\n \f\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n-   return the GCC tree to use for that expression.  GNU_NAME is the suffix\n-   to use if a variable needs to be created and DEFINITION is true if this\n-   is a definition of GNAT_ENTITY.  If NEED_VALUE is true, we need a result;\n+   return the GCC tree to use for that expression.  S is the suffix to use\n+   if a variable needs to be created and DEFINITION is true if this is made\n+   for a definition of GNAT_ENTITY.  If NEED_VALUE is true, we need a result;\n    otherwise, we are just elaborating the expression for side-effects.  If\n    NEED_DEBUG is true, we need a variable for debugging purposes even if it\n    isn't needed for code generation.  */\n \n static tree\n-elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, tree gnu_name,\n+elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, const char *s,\n \t\t      bool definition, bool need_value, bool need_debug)\n {\n   tree gnu_expr;\n@@ -6188,8 +6176,8 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, tree gnu_name,\n     need_debug = false;\n \n   /* Otherwise, convert this tree to its GCC equivalent and elaborate it.  */\n-  gnu_expr = elaborate_expression_1 (gnat_to_gnu (gnat_expr), gnat_entity,\n-\t\t\t\t     gnu_name, definition, need_debug);\n+  gnu_expr = elaborate_expression_1 (gnat_to_gnu (gnat_expr), gnat_entity, s,\n+\t\t\t\t     definition, need_debug);\n \n   /* Save the expression in case we try to elaborate this entity again.  Since\n      it's not a DECL, don't check it.  Don't save if it's a discriminant.  */\n@@ -6202,7 +6190,7 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, tree gnu_name,\n /* Similar, but take a GNU expression and always return a result.  */\n \n static tree\n-elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n+elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t\t\tbool definition, bool need_debug)\n {\n   const bool expr_public_p = Is_Public (gnat_entity);\n@@ -6264,18 +6252,19 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n   /* Now create it, possibly only for debugging purposes.  */\n   if (use_variable || need_debug)\n     {\n-      /* The following variable creation can happen when processing the body of\n-\t subprograms that are defined out of the extended main unit and\n-\t inlined. In this case, we are not at the global scope, and thus the\n+      /* The following variable creation can happen when processing the body\n+\t of subprograms that are defined out of the extended main unit and\n+\t inlined.  In this case, we are not at the global scope, and thus the\n \t new variable must not be tagged \"external\", as we used to do here as\n-\t long as definition == 0.  */\n-      const bool external_flag = !definition && expr_global_p;\n+\t soon as DEFINITION was false.  */\n       tree gnu_decl\n-\t= create_var_decl_1\n-\t  (create_concat_name (gnat_entity, IDENTIFIER_POINTER (gnu_name)),\n-\t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, true, expr_public_p,\n-\t   external_flag, expr_global_p, !need_debug, NULL, gnat_entity);\n+\t= create_var_decl_1 (create_concat_name (gnat_entity, s), NULL_TREE,\n+\t\t\t     TREE_TYPE (gnu_expr), gnu_expr, true,\n+\t\t\t     expr_public_p, !definition && expr_global_p,\n+\t\t\t     expr_global_p, !need_debug, NULL, gnat_entity);\n \n+      /* Whether or not gnat_entity comes from source, this variable is a\n+\t compilation artifact.  */\n       DECL_ARTIFICIAL (gnu_decl) = 1;\n \n       /* Using this variable at debug time (if need_debug is true) requires a\n@@ -6297,7 +6286,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n /* Similar, but take an alignment factor and make it explicit in the tree.  */\n \n static tree\n-elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n+elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t\t\tbool definition, bool need_debug, unsigned int align)\n {\n   tree unit_align = size_int (align / BITS_PER_UNIT);\n@@ -6306,7 +6295,7 @@ elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \t\telaborate_expression_1 (size_binop (EXACT_DIV_EXPR,\n \t\t\t\t\t\t    gnu_expr,\n \t\t\t\t\t\t    unit_align),\n-\t\t\t\t\tgnat_entity, gnu_name, definition,\n+\t\t\t\t\tgnat_entity, s, definition,\n \t\t\t\t\tneed_debug),\n \t\tunit_align);\n }\n@@ -7784,7 +7773,7 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n \ttree replacement = convert (TREE_TYPE (gnu_field),\n \t\t\t\t    elaborate_expression\n \t\t\t\t    (Node (gnat_constr), gnat_subtype,\n-\t\t\t\t     get_entity_name (gnat_discrim),\n+\t\t\t\t     get_entity_char (gnat_discrim),\n \t\t\t\t     definition, true, false));\n \tsubst_pair s = {gnu_field, replacement};\n \tgnu_list.safe_push (s);\n@@ -8845,6 +8834,13 @@ rm_size (tree gnu_type)\n    fully-qualified name, possibly with type information encoding.\n    Otherwise, return the name.  */\n \n+static const char *\n+get_entity_char (Entity_Id gnat_entity)\n+{\n+  Get_Encoded_Name (gnat_entity);\n+  return ggc_strdup (Name_Buffer);\n+}\n+\n tree\n get_entity_name (Entity_Id gnat_entity)\n {"}]}