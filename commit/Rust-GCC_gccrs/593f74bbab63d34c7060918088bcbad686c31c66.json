{"sha": "593f74bbab63d34c7060918088bcbad686c31c66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkzZjc0YmJhYjYzZDM0YzcwNjA5MTgwODhiY2JhZDY4NmMzMWM2Ng==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-06T17:57:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-06T17:57:23Z"}, "message": "libgo: Update to weekly.2012-03-04 release.\n\nFrom-SVN: r185010", "tree": {"sha": "4ce83ca433796a728e9fdd00af105bce158532b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ce83ca433796a728e9fdd00af105bce158532b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/593f74bbab63d34c7060918088bcbad686c31c66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593f74bbab63d34c7060918088bcbad686c31c66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/593f74bbab63d34c7060918088bcbad686c31c66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593f74bbab63d34c7060918088bcbad686c31c66/comments", "author": null, "committer": null, "parents": [{"sha": "46402cbe0ba3ea92be9642cf18eedaefe57a414c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46402cbe0ba3ea92be9642cf18eedaefe57a414c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46402cbe0ba3ea92be9642cf18eedaefe57a414c"}], "stats": {"total": 5100, "additions": 3079, "deletions": 2021}, "files": [{"sha": "17d01ce726586b09437c143a6c2da1742dea9785", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -1,4 +1,4 @@\n-96bd78e7d35e\n+f4470a54e6db\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "d43f0542938d14875d5619ae94f1a61b06a4ca62", "filename": "libgo/Makefile.am", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -658,10 +658,17 @@ go_net_sock_file = go/net/sock_linux.go\n go_net_sockopt_file = go/net/sockopt_linux.go\n go_net_sockoptip_file = go/net/sockoptip_linux.go\n else\n+if LIBGO_IS_FREEBSD\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n go_net_sockopt_file = go/net/sockopt_bsd.go\n-go_net_sockoptip_file = go/net/sockoptip_bsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_freebsd.go\n+else\n+go_net_cgo_file = go/net/cgo_bsd.go\n+go_net_sock_file = go/net/sock_bsd.go\n+go_net_sockopt_file = go/net/sockopt_bsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_netbsd.go\n+endif\n endif\n endif\n endif\n@@ -704,6 +711,7 @@ go_net_files = \\\n \tgo/net/ipsock.go \\\n \tgo/net/ipsock_posix.go \\\n \tgo/net/lookup_unix.go \\\n+\tgo/net/mac.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n@@ -1126,8 +1134,7 @@ go_go_ast_files = \\\n \tgo/go/ast/walk.go\n go_go_build_files = \\\n \tgo/go/build/build.go \\\n-\tgo/go/build/dir.go \\\n-\tgo/go/build/path.go \\\n+\tgo/go/build/doc.go \\\n \tsyslist.go\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\"}, {"sha": "418c7876a31ec4922f69e5ae16e796eda67a4900", "filename": "libgo/Makefile.in", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -1012,19 +1012,23 @@ go_mime_files = \\\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_cgo_file = go/net/cgo_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_cgo_file = go/net/cgo_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_cgo_file = go/net/cgo_linux.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sock_file = go/net/sock_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockopt_file = go/net/sockopt_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockopt_file = go/net/sockopt_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sockopt_file = go/net/sockopt_linux.go\n-@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go\n+@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_netbsd.go\n+@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go go/net/sockoptip_freebsd.go\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n@@ -1055,6 +1059,7 @@ go_net_files = \\\n \tgo/net/ipsock.go \\\n \tgo/net/ipsock_posix.go \\\n \tgo/net/lookup_unix.go \\\n+\tgo/net/mac.go \\\n \tgo/net/net.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n@@ -1467,8 +1472,7 @@ go_go_ast_files = \\\n \n go_go_build_files = \\\n \tgo/go/build/build.go \\\n-\tgo/go/build/dir.go \\\n-\tgo/go/build/path.go \\\n+\tgo/go/build/doc.go \\\n \tsyslist.go\n \n go_go_doc_files = \\"}, {"sha": "f3826dcc48da228d6f9f3f215de11a0d5363a828", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -169,79 +169,51 @@ func (r *checksumReader) Read(b []byte) (n int, err error) {\n \n func (r *checksumReader) Close() error { return r.rc.Close() }\n \n-func readFileHeader(f *File, r io.Reader) error {\n-\tvar b [fileHeaderLen]byte\n-\tif _, err := io.ReadFull(r, b[:]); err != nil {\n-\t\treturn err\n-\t}\n-\tc := binary.LittleEndian\n-\tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n-\t\treturn ErrFormat\n-\t}\n-\tf.ReaderVersion = c.Uint16(b[4:6])\n-\tf.Flags = c.Uint16(b[6:8])\n-\tf.Method = c.Uint16(b[8:10])\n-\tf.ModifiedTime = c.Uint16(b[10:12])\n-\tf.ModifiedDate = c.Uint16(b[12:14])\n-\tf.CRC32 = c.Uint32(b[14:18])\n-\tf.CompressedSize = c.Uint32(b[18:22])\n-\tf.UncompressedSize = c.Uint32(b[22:26])\n-\tfilenameLen := int(c.Uint16(b[26:28]))\n-\textraLen := int(c.Uint16(b[28:30]))\n-\td := make([]byte, filenameLen+extraLen)\n-\tif _, err := io.ReadFull(r, d); err != nil {\n-\t\treturn err\n-\t}\n-\tf.Name = string(d[:filenameLen])\n-\tf.Extra = d[filenameLen:]\n-\treturn nil\n-}\n-\n // findBodyOffset does the minimum work to verify the file has a header\n // and returns the file body offset.\n func (f *File) findBodyOffset() (int64, error) {\n \tr := io.NewSectionReader(f.zipr, f.headerOffset, f.zipsize-f.headerOffset)\n-\tvar b [fileHeaderLen]byte\n-\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\tvar buf [fileHeaderLen]byte\n+\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n \t\treturn 0, err\n \t}\n-\tc := binary.LittleEndian\n-\tif sig := c.Uint32(b[:4]); sig != fileHeaderSignature {\n+\tb := readBuf(buf[:])\n+\tif sig := b.uint32(); sig != fileHeaderSignature {\n \t\treturn 0, ErrFormat\n \t}\n-\tfilenameLen := int(c.Uint16(b[26:28]))\n-\textraLen := int(c.Uint16(b[28:30]))\n+\tb = b[22:] // skip over most of the header\n+\tfilenameLen := int(b.uint16())\n+\textraLen := int(b.uint16())\n \treturn int64(fileHeaderLen + filenameLen + extraLen), nil\n }\n \n // readDirectoryHeader attempts to read a directory header from r.\n // It returns io.ErrUnexpectedEOF if it cannot read a complete header,\n // and ErrFormat if it doesn't find a valid header signature.\n func readDirectoryHeader(f *File, r io.Reader) error {\n-\tvar b [directoryHeaderLen]byte\n-\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\tvar buf [directoryHeaderLen]byte\n+\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n \t\treturn err\n \t}\n-\tc := binary.LittleEndian\n-\tif sig := c.Uint32(b[:4]); sig != directoryHeaderSignature {\n+\tb := readBuf(buf[:])\n+\tif sig := b.uint32(); sig != directoryHeaderSignature {\n \t\treturn ErrFormat\n \t}\n-\tf.CreatorVersion = c.Uint16(b[4:6])\n-\tf.ReaderVersion = c.Uint16(b[6:8])\n-\tf.Flags = c.Uint16(b[8:10])\n-\tf.Method = c.Uint16(b[10:12])\n-\tf.ModifiedTime = c.Uint16(b[12:14])\n-\tf.ModifiedDate = c.Uint16(b[14:16])\n-\tf.CRC32 = c.Uint32(b[16:20])\n-\tf.CompressedSize = c.Uint32(b[20:24])\n-\tf.UncompressedSize = c.Uint32(b[24:28])\n-\tfilenameLen := int(c.Uint16(b[28:30]))\n-\textraLen := int(c.Uint16(b[30:32]))\n-\tcommentLen := int(c.Uint16(b[32:34]))\n-\t// startDiskNumber := c.Uint16(b[34:36])    // Unused\n-\t// internalAttributes := c.Uint16(b[36:38]) // Unused\n-\tf.ExternalAttrs = c.Uint32(b[38:42])\n-\tf.headerOffset = int64(c.Uint32(b[42:46]))\n+\tf.CreatorVersion = b.uint16()\n+\tf.ReaderVersion = b.uint16()\n+\tf.Flags = b.uint16()\n+\tf.Method = b.uint16()\n+\tf.ModifiedTime = b.uint16()\n+\tf.ModifiedDate = b.uint16()\n+\tf.CRC32 = b.uint32()\n+\tf.CompressedSize = b.uint32()\n+\tf.UncompressedSize = b.uint32()\n+\tfilenameLen := int(b.uint16())\n+\textraLen := int(b.uint16())\n+\tcommentLen := int(b.uint16())\n+\tb = b[4:] // skipped start disk number and internal attributes (2x uint16)\n+\tf.ExternalAttrs = b.uint32()\n+\tf.headerOffset = int64(b.uint32())\n \td := make([]byte, filenameLen+extraLen+commentLen)\n \tif _, err := io.ReadFull(r, d); err != nil {\n \t\treturn err\n@@ -253,30 +225,30 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n }\n \n func readDataDescriptor(r io.Reader, f *File) error {\n-\tvar b [dataDescriptorLen]byte\n-\tif _, err := io.ReadFull(r, b[:]); err != nil {\n+\tvar buf [dataDescriptorLen]byte\n+\tif _, err := io.ReadFull(r, buf[:]); err != nil {\n \t\treturn err\n \t}\n-\tc := binary.LittleEndian\n-\tf.CRC32 = c.Uint32(b[:4])\n-\tf.CompressedSize = c.Uint32(b[4:8])\n-\tf.UncompressedSize = c.Uint32(b[8:12])\n+\tb := readBuf(buf[:])\n+\tf.CRC32 = b.uint32()\n+\tf.CompressedSize = b.uint32()\n+\tf.UncompressedSize = b.uint32()\n \treturn nil\n }\n \n func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error) {\n \t// look for directoryEndSignature in the last 1k, then in the last 65k\n-\tvar b []byte\n+\tvar buf []byte\n \tfor i, bLen := range []int64{1024, 65 * 1024} {\n \t\tif bLen > size {\n \t\t\tbLen = size\n \t\t}\n-\t\tb = make([]byte, int(bLen))\n-\t\tif _, err := r.ReadAt(b, size-bLen); err != nil && err != io.EOF {\n+\t\tbuf = make([]byte, int(bLen))\n+\t\tif _, err := r.ReadAt(buf, size-bLen); err != nil && err != io.EOF {\n \t\t\treturn nil, err\n \t\t}\n-\t\tif p := findSignatureInBlock(b); p >= 0 {\n-\t\t\tb = b[p:]\n+\t\tif p := findSignatureInBlock(buf); p >= 0 {\n+\t\t\tbuf = buf[p:]\n \t\t\tbreak\n \t\t}\n \t\tif i == 1 || bLen == size {\n@@ -285,16 +257,21 @@ func readDirectoryEnd(r io.ReaderAt, size int64) (dir *directoryEnd, err error)\n \t}\n \n \t// read header into struct\n-\tc := binary.LittleEndian\n-\td := new(directoryEnd)\n-\td.diskNbr = c.Uint16(b[4:6])\n-\td.dirDiskNbr = c.Uint16(b[6:8])\n-\td.dirRecordsThisDisk = c.Uint16(b[8:10])\n-\td.directoryRecords = c.Uint16(b[10:12])\n-\td.directorySize = c.Uint32(b[12:16])\n-\td.directoryOffset = c.Uint32(b[16:20])\n-\td.commentLen = c.Uint16(b[20:22])\n-\td.comment = string(b[22 : 22+int(d.commentLen)])\n+\tb := readBuf(buf[4:]) // skip signature\n+\td := &directoryEnd{\n+\t\tdiskNbr:            b.uint16(),\n+\t\tdirDiskNbr:         b.uint16(),\n+\t\tdirRecordsThisDisk: b.uint16(),\n+\t\tdirectoryRecords:   b.uint16(),\n+\t\tdirectorySize:      b.uint32(),\n+\t\tdirectoryOffset:    b.uint32(),\n+\t\tcommentLen:         b.uint16(),\n+\t}\n+\tl := int(d.commentLen)\n+\tif l > len(b) {\n+\t\treturn nil, errors.New(\"zip: invalid comment length\")\n+\t}\n+\td.comment = string(b[:l])\n \treturn d, nil\n }\n \n@@ -311,3 +288,17 @@ func findSignatureInBlock(b []byte) int {\n \t}\n \treturn -1\n }\n+\n+type readBuf []byte\n+\n+func (b *readBuf) uint16() uint16 {\n+\tv := binary.LittleEndian.Uint16(*b)\n+\t*b = (*b)[2:]\n+\treturn v\n+}\n+\n+func (b *readBuf) uint32() uint32 {\n+\tv := binary.LittleEndian.Uint32(*b)\n+\t*b = (*b)[4:]\n+\treturn v\n+}"}, {"sha": "066a61580c56d6ae8ccca5bc87662d34d5130edf", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -165,7 +165,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\tt.Errorf(\"%s: comment=%q, want %q\", zt.Name, z.Comment, zt.Comment)\n \t}\n \tif len(z.File) != len(zt.File) {\n-\t\tt.Errorf(\"%s: file count=%d, want %d\", zt.Name, len(z.File), len(zt.File))\n+\t\tt.Fatalf(\"%s: file count=%d, want %d\", zt.Name, len(z.File), len(zt.File))\n \t}\n \n \t// test read of each file"}, {"sha": "fdbd16da0482721d36b9ec257283f89589c29669", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -100,16 +100,6 @@ type directoryEnd struct {\n \tcomment            string\n }\n \n-func recoverError(errp *error) {\n-\tif e := recover(); e != nil {\n-\t\tif err, ok := e.(error); ok {\n-\t\t\t*errp = err\n-\t\t\treturn\n-\t\t}\n-\t\tpanic(e)\n-\t}\n-}\n-\n // msDosTimeToTime converts an MS-DOS date and time into a time.Time.\n // The resolution is 2s.\n // See: http://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx"}, {"sha": "b2cc55bc93b2ddd1f4faabb54b9136adbb3fbcfd", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 85, "deletions": 70, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -37,10 +37,10 @@ func NewWriter(w io.Writer) *Writer {\n \n // Close finishes writing the zip file by writing the central directory.\n // It does not (and can not) close the underlying writer.\n-func (w *Writer) Close() (err error) {\n+func (w *Writer) Close() error {\n \tif w.last != nil && !w.last.closed {\n-\t\tif err = w.last.close(); err != nil {\n-\t\t\treturn\n+\t\tif err := w.last.close(); err != nil {\n+\t\t\treturn err\n \t\t}\n \t\tw.last = nil\n \t}\n@@ -49,43 +49,55 @@ func (w *Writer) Close() (err error) {\n \t}\n \tw.closed = true\n \n-\tdefer recoverError(&err)\n-\n \t// write central directory\n \tstart := w.cw.count\n \tfor _, h := range w.dir {\n-\t\twrite(w.cw, uint32(directoryHeaderSignature))\n-\t\twrite(w.cw, h.CreatorVersion)\n-\t\twrite(w.cw, h.ReaderVersion)\n-\t\twrite(w.cw, h.Flags)\n-\t\twrite(w.cw, h.Method)\n-\t\twrite(w.cw, h.ModifiedTime)\n-\t\twrite(w.cw, h.ModifiedDate)\n-\t\twrite(w.cw, h.CRC32)\n-\t\twrite(w.cw, h.CompressedSize)\n-\t\twrite(w.cw, h.UncompressedSize)\n-\t\twrite(w.cw, uint16(len(h.Name)))\n-\t\twrite(w.cw, uint16(len(h.Extra)))\n-\t\twrite(w.cw, uint16(len(h.Comment)))\n-\t\twrite(w.cw, uint16(0)) // disk number start\n-\t\twrite(w.cw, uint16(0)) // internal file attributes\n-\t\twrite(w.cw, h.ExternalAttrs)\n-\t\twrite(w.cw, h.offset)\n-\t\twriteBytes(w.cw, []byte(h.Name))\n-\t\twriteBytes(w.cw, h.Extra)\n-\t\twriteBytes(w.cw, []byte(h.Comment))\n+\t\tvar buf [directoryHeaderLen]byte\n+\t\tb := writeBuf(buf[:])\n+\t\tb.uint32(uint32(directoryHeaderSignature))\n+\t\tb.uint16(h.CreatorVersion)\n+\t\tb.uint16(h.ReaderVersion)\n+\t\tb.uint16(h.Flags)\n+\t\tb.uint16(h.Method)\n+\t\tb.uint16(h.ModifiedTime)\n+\t\tb.uint16(h.ModifiedDate)\n+\t\tb.uint32(h.CRC32)\n+\t\tb.uint32(h.CompressedSize)\n+\t\tb.uint32(h.UncompressedSize)\n+\t\tb.uint16(uint16(len(h.Name)))\n+\t\tb.uint16(uint16(len(h.Extra)))\n+\t\tb.uint16(uint16(len(h.Comment)))\n+\t\tb = b[4:] // skip disk number start and internal file attr (2x uint16)\n+\t\tb.uint32(h.ExternalAttrs)\n+\t\tb.uint32(h.offset)\n+\t\tif _, err := w.cw.Write(buf[:]); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := io.WriteString(w.cw, h.Name); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := w.cw.Write(h.Extra); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := io.WriteString(w.cw, h.Comment); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \tend := w.cw.count\n \n \t// write end record\n-\twrite(w.cw, uint32(directoryEndSignature))\n-\twrite(w.cw, uint16(0))          // disk number\n-\twrite(w.cw, uint16(0))          // disk number where directory starts\n-\twrite(w.cw, uint16(len(w.dir))) // number of entries this disk\n-\twrite(w.cw, uint16(len(w.dir))) // number of entries total\n-\twrite(w.cw, uint32(end-start))  // size of directory\n-\twrite(w.cw, uint32(start))      // start of directory\n-\twrite(w.cw, uint16(0))          // size of comment\n+\tvar buf [directoryEndLen]byte\n+\tb := writeBuf(buf[:])\n+\tb.uint32(uint32(directoryEndSignature))\n+\tb = b[4:]                     // skip over disk number and first disk number (2x uint16)\n+\tb.uint16(uint16(len(w.dir)))  // number of entries this disk\n+\tb.uint16(uint16(len(w.dir)))  // number of entries total\n+\tb.uint32(uint32(end - start)) // size of directory\n+\tb.uint32(uint32(start))       // start of directory\n+\t// skipped size of comment (always zero)\n+\tif _, err := w.cw.Write(buf[:]); err != nil {\n+\t\treturn err\n+\t}\n \n \treturn w.cw.w.(*bufio.Writer).Flush()\n }\n@@ -152,22 +164,28 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \treturn fw, nil\n }\n \n-func writeHeader(w io.Writer, h *FileHeader) (err error) {\n-\tdefer recoverError(&err)\n-\twrite(w, uint32(fileHeaderSignature))\n-\twrite(w, h.ReaderVersion)\n-\twrite(w, h.Flags)\n-\twrite(w, h.Method)\n-\twrite(w, h.ModifiedTime)\n-\twrite(w, h.ModifiedDate)\n-\twrite(w, h.CRC32)\n-\twrite(w, h.CompressedSize)\n-\twrite(w, h.UncompressedSize)\n-\twrite(w, uint16(len(h.Name)))\n-\twrite(w, uint16(len(h.Extra)))\n-\twriteBytes(w, []byte(h.Name))\n-\twriteBytes(w, h.Extra)\n-\treturn nil\n+func writeHeader(w io.Writer, h *FileHeader) error {\n+\tvar buf [fileHeaderLen]byte\n+\tb := writeBuf(buf[:])\n+\tb.uint32(uint32(fileHeaderSignature))\n+\tb.uint16(h.ReaderVersion)\n+\tb.uint16(h.Flags)\n+\tb.uint16(h.Method)\n+\tb.uint16(h.ModifiedTime)\n+\tb.uint16(h.ModifiedDate)\n+\tb.uint32(h.CRC32)\n+\tb.uint32(h.CompressedSize)\n+\tb.uint32(h.UncompressedSize)\n+\tb.uint16(uint16(len(h.Name)))\n+\tb.uint16(uint16(len(h.Extra)))\n+\tif _, err := w.Write(buf[:]); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := io.WriteString(w, h.Name); err != nil {\n+\t\treturn err\n+\t}\n+\t_, err := w.Write(h.Extra)\n+\treturn err\n }\n \n type fileWriter struct {\n@@ -188,13 +206,13 @@ func (w *fileWriter) Write(p []byte) (int, error) {\n \treturn w.rawCount.Write(p)\n }\n \n-func (w *fileWriter) close() (err error) {\n+func (w *fileWriter) close() error {\n \tif w.closed {\n \t\treturn errors.New(\"zip: file closed twice\")\n \t}\n \tw.closed = true\n-\tif err = w.comp.Close(); err != nil {\n-\t\treturn\n+\tif err := w.comp.Close(); err != nil {\n+\t\treturn err\n \t}\n \n \t// update FileHeader\n@@ -204,12 +222,13 @@ func (w *fileWriter) close() (err error) {\n \tfh.UncompressedSize = uint32(w.rawCount.count)\n \n \t// write data descriptor\n-\tdefer recoverError(&err)\n-\twrite(w.zipw, fh.CRC32)\n-\twrite(w.zipw, fh.CompressedSize)\n-\twrite(w.zipw, fh.UncompressedSize)\n-\n-\treturn nil\n+\tvar buf [dataDescriptorLen]byte\n+\tb := writeBuf(buf[:])\n+\tb.uint32(fh.CRC32)\n+\tb.uint32(fh.CompressedSize)\n+\tb.uint32(fh.UncompressedSize)\n+\t_, err := w.zipw.Write(buf[:])\n+\treturn err\n }\n \n type countWriter struct {\n@@ -231,18 +250,14 @@ func (w nopCloser) Close() error {\n \treturn nil\n }\n \n-func write(w io.Writer, data interface{}) {\n-\tif err := binary.Write(w, binary.LittleEndian, data); err != nil {\n-\t\tpanic(err)\n-\t}\n+type writeBuf []byte\n+\n+func (b *writeBuf) uint16(v uint16) {\n+\tbinary.LittleEndian.PutUint16(*b, v)\n+\t*b = (*b)[2:]\n }\n \n-func writeBytes(w io.Writer, b []byte) {\n-\tn, err := w.Write(b)\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\tif n != len(b) {\n-\t\tpanic(io.ErrShortWrite)\n-\t}\n+func (b *writeBuf) uint32(v uint32) {\n+\tbinary.LittleEndian.PutUint32(*b, v)\n+\t*b = (*b)[4:]\n }"}, {"sha": "b44d0e7d167893c9f813f99ce736adf9fa34131c", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -23,7 +23,6 @@ var (\n \tErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n \tErrBufferFull        = errors.New(\"bufio: buffer full\")\n \tErrNegativeCount     = errors.New(\"bufio: negative count\")\n-\terrInternal          = errors.New(\"bufio: internal error\")\n )\n \n // Buffered input."}, {"sha": "b28239b7862d3714eea3a353b2777eef8cddb6f7", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -7,7 +7,7 @@\n package ecdsa\n \n // References:\n-//   [NSA]: Suite B implementor's guide to FIPS 186-3,\n+//   [NSA]: Suite B implementer's guide to FIPS 186-3,\n //     http://www.nsa.gov/ia/_files/ecdsa.pdf\n //   [SECG]: SECG, SEC1\n //     http://www.secg.org/download/aid-780/sec1-v2.pdf"}, {"sha": "911a9a62e3cc160e77ed52f54eb4d4863b39aedc", "filename": "libgo/go/crypto/tls/root_darwin.go", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,11 +5,9 @@\n package tls\n \n /*\n-// Note: We disable -Werror here because the code in this file uses a deprecated API to stay\n-// compatible with both Mac OS X 10.6 and 10.7. Using a deprecated function on Darwin generates\n-// a warning.\n-#cgo CFLAGS: -Wno-error -Wno-deprecated-declarations\n+#cgo CFLAGS: -mmacosx-version-min=10.6 -D__MAC_OS_X_VERSION_MAX_ALLOWED=1060\n #cgo LDFLAGS: -framework CoreFoundation -framework Security\n+\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n \n@@ -40,26 +38,12 @@ int FetchPEMRoots(CFDataRef *pemRoots) {\n \t\t\tcontinue;\n \t\t}\n \n-\t\t// SecKeychainImportExport is deprecated in >= OS X 10.7, and has been replaced by\n-\t\t// SecItemExport.  If we're built on a host with a Lion SDK, this code gets conditionally\n-\t\t// included in the output, also for binaries meant for 10.6.\n-\t\t//\n-\t\t// To make sure that we run on both Mac OS X 10.6 and 10.7 we use weak linking\n-\t\t// and check whether SecItemExport is available before we attempt to call it. On\n-\t\t// 10.6, this won't be the case, and we'll fall back to calling SecKeychainItemExport.\n-#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1070\n-\t\tif (SecItemExport) {\n-\t\t\terr = SecItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n-\t\t\tif (err != noErr) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t} else\n-#endif\n-\t\tif (data == NULL) {\n-\t\t\terr = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n-\t\t\tif (err != noErr) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n+\t\t// Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.\n+\t\t// Once we support weak imports via cgo we should prefer that, and fall back to this\n+\t\t// for older systems.\n+\t\terr = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n+\t\tif (err != noErr) {\n+\t\t\tcontinue;\n \t\t}\n \n \t\tif (data != NULL) {"}, {"sha": "3859dd8d4888cbc19fe401274056f69d084055c0", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -135,8 +135,8 @@ func (c *Certificate) isValid(certType int, opts *VerifyOptions) error {\n \n // Verify attempts to verify c by building one or more chains from c to a\n // certificate in opts.roots, using certificates in opts.Intermediates if\n-// needed. If successful, it returns one or chains where the first element of\n-// the chain is c and the last element is from opts.Roots.\n+// needed. If successful, it returns one or more chains where the first\n+// element of the chain is c and the last element is from opts.Roots.\n //\n // WARNING: this doesn't do any revocation checking.\n func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {"}, {"sha": "f5da86b54a021c0d560693b001aca6642ad4d2eb", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -153,7 +153,7 @@ const (\n //\n // md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }\n //\n-// md5WithRSAEncryption OBJECT IDENTIFER ::= { pkcs-1 4 }\n+// md5WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 4 }\n //\n // sha-1WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 5 }\n // \n@@ -172,9 +172,9 @@ const (\n //\n // RFC 5758 3.1 DSA Signature Algorithms\n //\n-// dsaWithSha356 OBJECT IDENTIFER ::= {\n+// dsaWithSha256 OBJECT IDENTIFIER ::= {\n //    joint-iso-ccitt(2) country(16) us(840) organization(1) gov(101)\n-//    algorithms(4) id-dsa-with-sha2(3) 2}\n+//    csor(3) algorithms(4) id-dsa-with-sha2(3) 2}\n //\n var (\n \toidSignatureMD2WithRSA    = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 2}"}, {"sha": "02f090d53f31c68c346a7633c4b64f6fe71c9739", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -29,17 +29,13 @@ type ByteOrder interface {\n \tString() string\n }\n \n-// This is byte instead of struct{} so that it can be compared,\n-// allowing, e.g., order == binary.LittleEndian.\n-type unused byte\n-\n // LittleEndian is the little-endian implementation of ByteOrder.\n var LittleEndian littleEndian\n \n // BigEndian is the big-endian implementation of ByteOrder.\n var BigEndian bigEndian\n \n-type littleEndian unused\n+type littleEndian struct{}\n \n func (littleEndian) Uint16(b []byte) uint16 { return uint16(b[0]) | uint16(b[1])<<8 }\n \n@@ -79,7 +75,7 @@ func (littleEndian) String() string { return \"LittleEndian\" }\n \n func (littleEndian) GoString() string { return \"binary.LittleEndian\" }\n \n-type bigEndian unused\n+type bigEndian struct{}\n \n func (bigEndian) Uint16(b []byte) uint16 { return uint16(b[1]) | uint16(b[0])<<8 }\n "}, {"sha": "ebcbb78ebe6e0d7d6dd07d1e5ee6f94a0184fcb1", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -1455,11 +1455,14 @@ func TestFuzz(t *testing.T) {\n func TestFuzzRegressions(t *testing.T) {\n \t// An instance triggering a type name of length ~102 GB.\n \ttestFuzz(t, 1328492090837718000, 100, new(float32))\n+\t// An instance triggering a type name of 1.6 GB.\n+\t// Commented out because it takes 5m to run.\n+\t//testFuzz(t, 1330522872628565000, 100, new(int))\n }\n \n func testFuzz(t *testing.T, seed int64, n int, input ...interface{}) {\n-\tt.Logf(\"seed=%d n=%d\\n\", seed, n)\n \tfor _, e := range input {\n+\t\tt.Logf(\"seed=%d n=%d e=%T\", seed, n, e)\n \t\trng := rand.New(rand.NewSource(seed))\n \t\tfor i := 0; i < n; i++ {\n \t\t\tencFuzzDec(rng, e)"}, {"sha": "31d1351fc4f5c1917c9f35695bf1e10b5528df41", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -3,14 +3,15 @@\n // license that can be found in the LICENSE file.\n \n // Delete the next line to include in the gob package.\n-// +build gob-debug\n+// +build ignore\n \n package gob\n \n // This file is not normally included in the gob package.  Used only for debugging the package itself.\n-// Add debug.go to the files listed in the Makefile to add Debug to the gob package.\n // Except for reading uints, it is an implementation of a reader that is independent of\n // the one implemented by Decoder.\n+// To enable the Debug function, delete the +build ignore line above and do\n+//\tgo install\n \n import (\n \t\"bytes\""}, {"sha": "0708a83c99ad728be95c111b29f0ac15ac63b1b3", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -392,12 +392,12 @@ func decUint8Slice(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t}\n \t\tp = *(*unsafe.Pointer)(p)\n \t}\n-\tn := int(state.decodeUint())\n-\tif n < 0 {\n-\t\terrorf(\"negative length decoding []byte\")\n+\tn := state.decodeUint()\n+\tif n > uint64(state.b.Len()) {\n+\t\terrorf(\"length of []byte exceeds input size (%d bytes)\", n)\n \t}\n \tslice := (*[]uint8)(p)\n-\tif cap(*slice) < n {\n+\tif uint64(cap(*slice)) < n {\n \t\t*slice = make([]uint8, n)\n \t} else {\n \t\t*slice = (*slice)[0:n]\n@@ -417,7 +417,11 @@ func decString(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t}\n \t\tp = *(*unsafe.Pointer)(p)\n \t}\n-\tb := make([]byte, state.decodeUint())\n+\tn := state.decodeUint()\n+\tif n > uint64(state.b.Len()) {\n+\t\terrorf(\"string length exceeds input size (%d bytes)\", n)\n+\t}\n+\tb := make([]byte, n)\n \tstate.b.Read(b)\n \t// It would be a shame to do the obvious thing here,\n \t//\t*(*string)(p) = string(b)\n@@ -647,7 +651,11 @@ func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n // decodeSlice decodes a slice and stores the slice header through p.\n // Slices are encoded as an unsigned length followed by the elements.\n func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl error) {\n-\tn := int(uintptr(state.decodeUint()))\n+\tnr := state.decodeUint()\n+\tif nr > uint64(state.b.Len()) {\n+\t\terrorf(\"length of slice exceeds input size (%d elements)\", nr)\n+\t}\n+\tn := int(nr)\n \tif indir > 0 {\n \t\tup := unsafe.Pointer(p)\n \t\tif *(*unsafe.Pointer)(up) == nil {\n@@ -702,6 +710,9 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \t\t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.InterfaceData()\n \t\treturn\n \t}\n+\tif len(name) > 1024 {\n+\t\terrorf(\"name too long (%d bytes): %.20q...\", len(name), name)\n+\t}\n \t// The concrete type must be registered.\n \ttyp, ok := nameToConcreteType[name]\n \tif !ok {"}, {"sha": "17238c98df0d3bdf04a1084c1edd129a656f8e84", "filename": "libgo/go/encoding/gob/dump.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdump.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -7,6 +7,7 @@\n package main\n \n // Need to compile package gob with debug.go to build this program.\n+// See comments in debug.go for how to do this.\n \n import (\n \t\"encoding/gob\""}, {"sha": "050786dfd1fa5ad3f82a05c031b6378f63e08b4b", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -709,7 +709,7 @@ func TestGobPtrSlices(t *testing.T) {\n \t\tt.Fatal(\"decode:\", err)\n \t}\n \tif !reflect.DeepEqual(in, out) {\n-\t\tt.Fatal(\"got %v; wanted %v\", out, in)\n+\t\tt.Fatalf(\"got %v; wanted %v\", out, in)\n \t}\n }\n "}, {"sha": "d758758d97816352b6c50bc2451cb2cea3d6d510", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -239,16 +239,6 @@ func TestEscape(t *testing.T) {\n \t}\n }\n \n-func TestHTMLEscape(t *testing.T) {\n-\tb, err := MarshalForHTML(\"foobarbaz<>&quux\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"MarshalForHTML error: %v\", err)\n-\t}\n-\tif !bytes.Equal(b, []byte(`\"foobarbaz\\u003c\\u003e\\u0026quux\"`)) {\n-\t\tt.Fatalf(\"Unexpected encoding of \\\"<>&\\\": %s\", b)\n-\t}\n-}\n-\n // WrongString is a struct that's misusing the ,string modifier.\n type WrongString struct {\n \tMessage string `json:\"result,string\"`"}, {"sha": "5425a3a90a125e6ed3f31d679e87192f28ac88eb", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -123,17 +123,6 @@ func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n \treturn buf.Bytes(), nil\n }\n \n-// MarshalForHTML is like Marshal but applies HTMLEscape to the output.\n-func MarshalForHTML(v interface{}) ([]byte, error) {\n-\tb, err := Marshal(v)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tvar buf bytes.Buffer\n-\tHTMLEscape(&buf, b)\n-\treturn buf.Bytes(), nil\n-}\n-\n // HTMLEscape appends to dst the JSON-encoded src with <, >, and &\n // characters inside string literals changed to \\u003c, \\u003e, \\u0026\n // so that the JSON will be safe to embed inside HTML <script> tags.\n@@ -200,11 +189,6 @@ func (e *MarshalerError) Error() string {\n \treturn \"json: error calling MarshalJSON for type \" + e.Type.String() + \": \" + e.Err.Error()\n }\n \n-type interfaceOrPtrValue interface {\n-\tIsNil() bool\n-\tElem() reflect.Value\n-}\n-\n var hex = \"0123456789abcdef\"\n \n // An encodeState encodes JSON into a bytes.Buffer.\n@@ -276,7 +260,7 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\tb, err := m.MarshalJSON()\n \t\tif err == nil {\n \t\t\t// copy JSON into buffer, checking validity.\n-\t\t\terr = Compact(&e.Buffer, b)\n+\t\t\terr = compact(&e.Buffer, b, true)\n \t\t}\n \t\tif err != nil {\n \t\t\te.error(&MarshalerError{v.Type(), err})"}, {"sha": "cb1c77eb529f7ab112606f61eb638bd947f4c29e", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -167,3 +167,22 @@ func TestRefValMarshal(t *testing.T) {\n \t\tt.Errorf(\"got %q, want %q\", got, want)\n \t}\n }\n+\n+// C implements Marshaler and returns unescaped JSON.\n+type C int\n+\n+func (C) MarshalJSON() ([]byte, error) {\n+\treturn []byte(`\"<&>\"`), nil\n+}\n+\n+func TestMarshalerEscaping(t *testing.T) {\n+\tvar c C\n+\tconst want = `\"\\u003c\\u0026\\u003e\"`\n+\tb, err := Marshal(c)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\tif got := string(b); got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+}"}, {"sha": "e8dfa4ec43630bb745c0e01346caa6999d51db02", "filename": "libgo/go/encoding/json/indent.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Findent.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -9,11 +9,24 @@ import \"bytes\"\n // Compact appends to dst the JSON-encoded src with\n // insignificant space characters elided.\n func Compact(dst *bytes.Buffer, src []byte) error {\n+\treturn compact(dst, src, false)\n+}\n+\n+func compact(dst *bytes.Buffer, src []byte, escape bool) error {\n \torigLen := dst.Len()\n \tvar scan scanner\n \tscan.reset()\n \tstart := 0\n \tfor i, c := range src {\n+\t\tif escape && (c == '<' || c == '>' || c == '&') {\n+\t\t\tif start < i {\n+\t\t\t\tdst.Write(src[start:i])\n+\t\t\t}\n+\t\t\tdst.WriteString(`\\u00`)\n+\t\t\tdst.WriteByte(hex[c>>4])\n+\t\t\tdst.WriteByte(hex[c&0xF])\n+\t\t\tstart = i + 1\n+\t\t}\n \t\tv := scan.step(&scan, int(c))\n \t\tif v >= scanSkipSpace {\n \t\t\tif v == scanError {"}, {"sha": "b6978a1e65b5a590c6c722153af5d675224386fe", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -136,12 +136,12 @@ type NamePrecedence struct {\n \n type XMLNameWithTag struct {\n \tXMLName Name   `xml:\"InXMLNameTag\"`\n-\tValue   string \",chardata\"\n+\tValue   string `xml:\",chardata\"`\n }\n \n type XMLNameWithoutTag struct {\n \tXMLName Name\n-\tValue   string \",chardata\"\n+\tValue   string `xml:\",chardata\"`\n }\n \n type NameInField struct {\n@@ -532,9 +532,9 @@ var marshalTests = []struct {\n \t\t\tInFieldName: \"D\",\n \t\t},\n \t\tExpectXML: `<Parent>` +\n-\t\t\t`<InTag><Value>A</Value></InTag>` +\n-\t\t\t`<InXMLName><Value>B</Value></InXMLName>` +\n-\t\t\t`<InXMLNameTag><Value>C</Value></InXMLNameTag>` +\n+\t\t\t`<InTag>A</InTag>` +\n+\t\t\t`<InXMLName>B</InXMLName>` +\n+\t\t\t`<InXMLNameTag>C</InXMLNameTag>` +\n \t\t\t`<InFieldName>D</InFieldName>` +\n \t\t\t`</Parent>`,\n \t\tMarshalOnly: true,\n@@ -548,9 +548,9 @@ var marshalTests = []struct {\n \t\t\tInFieldName: \"D\",\n \t\t},\n \t\tExpectXML: `<Parent>` +\n-\t\t\t`<InTag><Value>A</Value></InTag>` +\n-\t\t\t`<FromNameVal><Value>B</Value></FromNameVal>` +\n-\t\t\t`<InXMLNameTag><Value>C</Value></InXMLNameTag>` +\n+\t\t\t`<InTag>A</InTag>` +\n+\t\t\t`<FromNameVal>B</FromNameVal>` +\n+\t\t\t`<InXMLNameTag>C</InXMLNameTag>` +\n \t\t\t`<InFieldName>D</InFieldName>` +\n \t\t\t`</Parent>`,\n \t\tUnmarshalOnly: true,"}, {"sha": "1168086771fb1e7d583ebbfe2a925527781cbeed", "filename": "libgo/go/exp/gotype/doc.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -34,6 +34,8 @@ The flags are:\n \t\tVerbose mode.\n \n Debugging flags:\n+\t-comments\n+\t\tParse comments (ignored if -ast not set).\n \t-ast\n \t\tPrint AST (disables concurrent parsing).\n \t-trace"}, {"sha": "30eaf22fca6b270a33a6be37d6b6ec17f1174c23", "filename": "libgo/go/exp/gotype/gotype.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -27,8 +27,9 @@ var (\n \tallErrors = flag.Bool(\"e\", false, \"print all (including spurious) errors\")\n \n \t// debugging support\n-\tprintTrace = flag.Bool(\"trace\", false, \"print parse trace\")\n-\tprintAST   = flag.Bool(\"ast\", false, \"print AST\")\n+\tparseComments = flag.Bool(\"comments\", false, \"parse comments (ignored if -ast not set)\")\n+\tprintTrace    = flag.Bool(\"trace\", false, \"print parse trace\")\n+\tprintAST      = flag.Bool(\"ast\", false, \"print AST\")\n )\n \n var exitCode = 0\n@@ -73,6 +74,9 @@ func parse(fset *token.FileSet, filename string, src []byte) *ast.File {\n \tif *allErrors {\n \t\tmode |= parser.SpuriousErrors\n \t}\n+\tif *parseComments && *printAST {\n+\t\tmode |= parser.ParseComments\n+\t}\n \tif *printTrace {\n \t\tmode |= parser.Trace\n \t}"}, {"sha": "c105a4e709aeae2afd07035d795daefb1decf342", "filename": "libgo/go/exp/html/node.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fnode.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -110,7 +110,7 @@ func (s *nodeStack) top() *Node {\n \treturn nil\n }\n \n-// index returns the index of the top-most occurence of n in the stack, or -1\n+// index returns the index of the top-most occurrence of n in the stack, or -1\n // if n is not present.\n func (s *nodeStack) index(n *Node) int {\n \tfor i := len(*s) - 1; i >= 0; i-- {"}, {"sha": "c443b78d82554e08a6e162c38b02137886bad3b9", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -18,17 +18,17 @@ package norm\n // has the form:\n //    <header> <decomp_byte>* [<tccc> [<lccc>]]\n // The header contains the number of bytes in the decomposition (excluding this\n-// length byte). The two most significant bits of this lenght byte correspond\n+// length byte). The two most significant bits of this length byte correspond\n // to bit 2 and 3 of qcIfo (see below).  The byte sequence itself starts at v+1.\n // The byte sequence is followed by a trailing and leading CCC if the values\n // for these are not zero.  The value of v determines which ccc are appended\n // to the sequences.  For v < firstCCC, there are none, for v >= firstCCC,\n-// the seqence is followed by a trailing ccc, and for v >= firstLeadingCC\n+// the sequence is followed by a trailing ccc, and for v >= firstLeadingCC\n // there is an additional leading ccc.\n \n const (\n \tqcInfoMask      = 0xF  // to clear all but the relevant bits in a qcInfo\n-\theaderLenMask   = 0x3F // extract the lenght value from the header byte\n+\theaderLenMask   = 0x3F // extract the length value from the header byte\n \theaderFlagsMask = 0xC0 // extract the qcInfo bits from the header byte\n )\n "}, {"sha": "0c627e9ab54fa1bc891f0882dabfcba49b0f5e8f", "filename": "libgo/go/exp/proxy/per_host.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -75,7 +75,7 @@ func (p *PerHost) dialerForRequest(host string) Dialer {\n }\n \n // AddFromString parses a string that contains comma-separated values\n-// specifing hosts that should use the bypass proxy. Each value is either an\n+// specifying hosts that should use the bypass proxy. Each value is either an\n // IP address, a CIDR range, a zone (*.example.com) or a hostname\n // (localhost). A best effort is made to parse the string and errors are\n // ignored."}, {"sha": "cb996f28055531868b516773db13ad70c7329638", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -18,6 +18,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"text/scanner\"\n )\n \n@@ -39,11 +40,14 @@ func findPkg(path string) (filename, id string) {\n \tswitch path[0] {\n \tdefault:\n \t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n-\t\ttree, pkg, err := build.FindTree(path)\n-\t\tif err != nil {\n+\t\tbp, _ := build.Import(path, \"\", build.FindOnly)\n+\t\tif bp.PkgObj == \"\" {\n \t\t\treturn\n \t\t}\n-\t\tnoext = filepath.Join(tree.PkgDir(), pkg)\n+\t\tnoext = bp.PkgObj\n+\t\tif strings.HasSuffix(noext, \".a\") {\n+\t\t\tnoext = noext[:len(noext)-2]\n+\t\t}\n \n \tcase '.':\n \t\t// \"./x\" -> \"/this/directory/x.ext\", \"/this/directory/x\"\n@@ -742,7 +746,7 @@ func (p *gcParser) parseVarDecl() {\n }\n \n // FuncBody = \"{\" ... \"}\" .\n-// \n+//\n func (p *gcParser) parseFuncBody() {\n \tp.expect('{')\n \tfor i := 1; i > 0; p.next() {"}, {"sha": "85d244cf04a5f2a8eca56db25d011330da6ce00f", "filename": "libgo/go/exp/types/types.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// PACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\n-// Package types declares the types used to represent Go types.\n+// Package types declares the types used to represent Go types\n+// (UNDER CONSTRUCTION). ANY AND ALL PARTS MAY CHANGE.\n //\n package types\n "}, {"sha": "02cf9e022343765edad62d4608e486715320c3b9", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file contains printing suppport for ASTs.\n+// This file contains printing support for ASTs.\n \n package ast\n "}, {"sha": "eece7610562de836bbe4ce1a2cd0fea942151de0", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 940, "deletions": 2, "changes": 942, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -2,10 +2,948 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package build provides tools for building Go packages.\n package build\n \n-import \"errors\"\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/doc\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\tpathpkg \"path\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"unicode\"\n+)\n+\n+// A Context specifies the supporting context for a build.\n+type Context struct {\n+\tGOARCH      string   // target architecture\n+\tGOOS        string   // target operating system\n+\tGOROOT      string   // Go root\n+\tGOPATH      string   // Go path\n+\tCgoEnabled  bool     // whether cgo can be used\n+\tBuildTags   []string // additional tags to recognize in +build lines\n+\tUseAllFiles bool     // use files regardless of +build lines, file names\n+\tGccgo       bool     // assume use of gccgo when computing object paths\n+\n+\t// By default, Import uses the operating system's file system calls\n+\t// to read directories and files.  To read from other sources,\n+\t// callers can set the following functions.  They all have default\n+\t// behaviors that use the local file system, so clients need only set\n+\t// the functions whose behaviors they wish to change.\n+\n+\t// JoinPath joins the sequence of path fragments into a single path.\n+\t// If JoinPath is nil, Import uses filepath.Join.\n+\tJoinPath func(elem ...string) string\n+\n+\t// SplitPathList splits the path list into a slice of individual paths.\n+\t// If SplitPathList is nil, Import uses filepath.SplitList.\n+\tSplitPathList func(list string) []string\n+\n+\t// IsAbsPath reports whether path is an absolute path.\n+\t// If IsAbsPath is nil, Import uses filepath.IsAbs.\n+\tIsAbsPath func(path string) bool\n+\n+\t// IsDir reports whether the path names a directory.\n+\t// If IsDir is nil, Import calls os.Stat and uses the result's IsDir method.\n+\tIsDir func(path string) bool\n+\n+\t// HasSubdir reports whether dir is a subdirectory of\n+\t// (perhaps multiple levels below) root.\n+\t// If so, HasSubdir sets rel to a slash-separated path that\n+\t// can be joined to root to produce a path equivalent to dir.\n+\t// If HasSubdir is nil, Import uses an implementation built on\n+\t// filepath.EvalSymlinks.\n+\tHasSubdir func(root, dir string) (rel string, ok bool)\n+\n+\t// ReadDir returns a slice of os.FileInfo, sorted by Name,\n+\t// describing the content of the named directory.\n+\t// If ReadDir is nil, Import uses io.ReadDir.\n+\tReadDir func(dir string) (fi []os.FileInfo, err error)\n+\n+\t// OpenFile opens a file (not a directory) for reading.\n+\t// If OpenFile is nil, Import uses os.Open.\n+\tOpenFile func(path string) (r io.ReadCloser, err error)\n+}\n+\n+// joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join.\n+func (ctxt *Context) joinPath(elem ...string) string {\n+\tif f := ctxt.JoinPath; f != nil {\n+\t\treturn f(elem...)\n+\t}\n+\treturn filepath.Join(elem...)\n+}\n+\n+// splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList.\n+func (ctxt *Context) splitPathList(s string) []string {\n+\tif f := ctxt.SplitPathList; f != nil {\n+\t\treturn f(s)\n+\t}\n+\treturn filepath.SplitList(s)\n+}\n+\n+// isAbsPath calls ctxt.IsAbsSPath (if not nil) or else filepath.IsAbs.\n+func (ctxt *Context) isAbsPath(path string) bool {\n+\tif f := ctxt.IsAbsPath; f != nil {\n+\t\treturn f(path)\n+\t}\n+\treturn filepath.IsAbs(path)\n+}\n+\n+// isDir calls ctxt.IsDir (if not nil) or else uses os.Stat.\n+func (ctxt *Context) isDir(path string) bool {\n+\tif f := ctxt.IsDir; f != nil {\n+\t\treturn f(path)\n+\t}\n+\tfi, err := os.Stat(path)\n+\treturn err == nil && fi.IsDir()\n+}\n+\n+// hasSubdir calls ctxt.HasSubdir (if not nil) or else uses\n+// the local file system to answer the question.\n+func (ctxt *Context) hasSubdir(root, dir string) (rel string, ok bool) {\n+\tif f := ctxt.HasSubdir; f != nil {\n+\t\treturn f(root, dir)\n+\t}\n+\n+\tif p, err := filepath.EvalSymlinks(root); err == nil {\n+\t\troot = p\n+\t}\n+\tif p, err := filepath.EvalSymlinks(dir); err == nil {\n+\t\tdir = p\n+\t}\n+\tconst sep = string(filepath.Separator)\n+\troot = filepath.Clean(root)\n+\tif !strings.HasSuffix(root, sep) {\n+\t\troot += sep\n+\t}\n+\tdir = filepath.Clean(dir)\n+\tif !strings.HasPrefix(dir, root) {\n+\t\treturn \"\", false\n+\t}\n+\treturn filepath.ToSlash(dir[len(root):]), true\n+}\n+\n+// readDir calls ctxt.ReadDir (if not nil) or else ioutil.ReadDir.\n+func (ctxt *Context) readDir(path string) ([]os.FileInfo, error) {\n+\tif f := ctxt.ReadDir; f != nil {\n+\t\treturn f(path)\n+\t}\n+\treturn ioutil.ReadDir(path)\n+}\n+\n+// openFile calls ctxt.OpenFile (if not nil) or else os.Open.\n+func (ctxt *Context) openFile(path string) (io.ReadCloser, error) {\n+\tif fn := ctxt.OpenFile; fn != nil {\n+\t\treturn fn(path)\n+\t}\n+\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, err // nil interface\n+\t}\n+\treturn f, nil\n+}\n+\n+// isFile determines whether path is a file by trying to open it.\n+// It reuses openFile instead of adding another function to the\n+// list in Context.\n+func (ctxt *Context) isFile(path string) bool {\n+\tf, err := ctxt.openFile(path)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tf.Close()\n+\treturn true\n+}\n+\n+// gopath returns the list of Go path directories.\n+func (ctxt *Context) gopath() []string {\n+\tvar all []string\n+\tfor _, p := range ctxt.splitPathList(ctxt.GOPATH) {\n+\t\tif p == \"\" || p == ctxt.GOROOT {\n+\t\t\t// Empty paths are uninteresting.\n+\t\t\t// If the path is the GOROOT, ignore it.\n+\t\t\t// People sometimes set GOPATH=$GOROOT, which is useless\n+\t\t\t// but would cause us to find packages with import paths\n+\t\t\t// like \"pkg/math\".\n+\t\t\t// Do not get confused by this common mistake.\n+\t\t\tcontinue\n+\t\t}\n+\t\tall = append(all, p)\n+\t}\n+\treturn all\n+}\n+\n+// SrcDirs returns a list of package source root directories.\n+// It draws from the current Go root and Go path but omits directories\n+// that do not exist.\n+func (ctxt *Context) SrcDirs() []string {\n+\tvar all []string\n+\tif ctxt.GOROOT != \"\" {\n+\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\")\n+\t\tif ctxt.isDir(dir) {\n+\t\t\tall = append(all, dir)\n+\t\t}\n+\t}\n+\tfor _, p := range ctxt.gopath() {\n+\t\tdir := ctxt.joinPath(p, \"src\")\n+\t\tif ctxt.isDir(dir) {\n+\t\t\tall = append(all, dir)\n+\t\t}\n+\t}\n+\treturn all\n+}\n+\n+// Default is the default Context for builds.\n+// It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables\n+// if set, or else the compiled code's GOARCH, GOOS, and GOROOT.\n+var Default Context = defaultContext()\n+\n+var cgoEnabled = map[string]bool{\n+\t\"darwin/386\":    true,\n+\t\"darwin/amd64\":  true,\n+\t\"linux/386\":     true,\n+\t\"linux/amd64\":   true,\n+\t\"freebsd/386\":   true,\n+\t\"freebsd/amd64\": true,\n+\t\"windows/386\":   true,\n+\t\"windows/amd64\": true,\n+}\n+\n+func defaultContext() Context {\n+\tvar c Context\n+\n+\tc.GOARCH = envOr(\"GOARCH\", runtime.GOARCH)\n+\tc.GOOS = envOr(\"GOOS\", runtime.GOOS)\n+\tc.GOROOT = runtime.GOROOT()\n+\tc.GOPATH = envOr(\"GOPATH\", \"\")\n+\n+\tswitch os.Getenv(\"CGO_ENABLED\") {\n+\tcase \"1\":\n+\t\tc.CgoEnabled = true\n+\tcase \"0\":\n+\t\tc.CgoEnabled = false\n+\tdefault:\n+\t\tc.CgoEnabled = cgoEnabled[c.GOOS+\"/\"+c.GOARCH]\n+\t}\n+\n+\treturn c\n+}\n+\n+func envOr(name, def string) string {\n+\ts := os.Getenv(name)\n+\tif s == \"\" {\n+\t\treturn def\n+\t}\n+\treturn s\n+}\n+\n+// An ImportMode controls the behavior of the Import method.\n+type ImportMode uint\n+\n+const (\n+\t// If FindOnly is set, Import stops after locating the directory\n+\t// that should contain the sources for a package.  It does not\n+\t// read any files in the directory.\n+\tFindOnly ImportMode = 1 << iota\n+\n+\t// If AllowBinary is set, Import can be satisfied by a compiled\n+\t// package object without corresponding sources.\n+\tAllowBinary\n+)\n+\n+// A Package describes the Go package found in a directory.\n+type Package struct {\n+\tDir        string // directory containing package sources\n+\tName       string // package name\n+\tDoc        string // documentation synopsis\n+\tImportPath string // import path of package (\"\" if unknown)\n+\tRoot       string // root of Go tree where this package lives\n+\tSrcRoot    string // package source root directory (\"\" if unknown)\n+\tPkgRoot    string // package install root directory (\"\" if unknown)\n+\tBinDir     string // command install directory (\"\" if unknown)\n+\tGoroot     bool   // package found in Go root\n+\tPkgObj     string // installed .a file\n+\n+\t// Source files\n+\tGoFiles  []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n+\tCgoFiles []string // .go source files that import \"C\"\n+\tCFiles   []string // .c source files\n+\tHFiles   []string // .h source files\n+\tSFiles   []string // .s source files\n+\n+\t// Cgo directives\n+\tCgoPkgConfig []string // Cgo pkg-config directives\n+\tCgoCFLAGS    []string // Cgo CFLAGS directives\n+\tCgoLDFLAGS   []string // Cgo LDFLAGS directives\n+\n+\t// Dependency information\n+\tImports   []string                    // imports from GoFiles, CgoFiles\n+\tImportPos map[string][]token.Position // line information for Imports\n+\n+\t// Test information\n+\tTestGoFiles    []string                    // _test.go files in package\n+\tTestImports    []string                    // imports from TestGoFiles\n+\tTestImportPos  map[string][]token.Position // line information for TestImports\n+\tXTestGoFiles   []string                    // _test.go files outside package\n+\tXTestImports   []string                    // imports from XTestGoFiles\n+\tXTestImportPos map[string][]token.Position // line information for XTestImports\n+}\n+\n+// IsCommand reports whether the package is considered a\n+// command to be installed (not just a library).\n+// Packages named \"main\" are treated as commands.\n+func (p *Package) IsCommand() bool {\n+\treturn p.Name == \"main\"\n+}\n+\n+// ImportDir is like Import but processes the Go package found in\n+// the named directory.\n+func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error) {\n+\treturn ctxt.Import(\".\", dir, mode)\n+}\n+\n+// Import returns details about the Go package named by the import path,\n+// interpreting local import paths relative to the src directory.  If the path\n+// is a local import path naming a package that can be imported using a\n+// standard import path, the returned package will set p.ImportPath to\n+// that path.\n+//\n+// In the directory containing the package, .go, .c, .h, and .s files are\n+// considered part of the package except for:\n+//\n+//\t- .go files in package documentation\n+//\t- files starting with _ or .\n+//\t- files with build constraints not satisfied by the context\n+//\n+// If an error occurs, Import returns a non-nil error also returns a non-nil\n+// *Package containing partial information.\n+//\n+func (ctxt *Context) Import(path string, src string, mode ImportMode) (*Package, error) {\n+\tp := &Package{\n+\t\tImportPath: path,\n+\t}\n+\n+\tvar pkga string\n+\tif ctxt.Gccgo {\n+\t\tdir, elem := pathpkg.Split(p.ImportPath)\n+\t\tpkga = \"pkg/gccgo/\" + dir + \"lib\" + elem + \".a\"\n+\t} else {\n+\t\tpkga = \"pkg/\" + ctxt.GOOS + \"_\" + ctxt.GOARCH + \"/\" + p.ImportPath + \".a\"\n+\t}\n+\n+\tbinaryOnly := false\n+\tif IsLocalImport(path) {\n+\t\tif src == \"\" {\n+\t\t\treturn p, fmt.Errorf(\"import %q: import relative to unknown directory\", path)\n+\t\t}\n+\t\tif !ctxt.isAbsPath(path) {\n+\t\t\tp.Dir = ctxt.joinPath(src, path)\n+\t\t}\n+\t\t// Determine canonical import path, if any.\n+\t\tif ctxt.GOROOT != \"\" {\n+\t\t\troot := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\")\n+\t\t\tif sub, ok := ctxt.hasSubdir(root, p.Dir); ok {\n+\t\t\t\tp.Goroot = true\n+\t\t\t\tp.ImportPath = sub\n+\t\t\t\tp.Root = ctxt.GOROOT\n+\t\t\t\tgoto Found\n+\t\t\t}\n+\t\t}\n+\t\tall := ctxt.gopath()\n+\t\tfor i, root := range all {\n+\t\t\trootsrc := ctxt.joinPath(root, \"src\")\n+\t\t\tif sub, ok := ctxt.hasSubdir(rootsrc, p.Dir); ok {\n+\t\t\t\t// We found a potential import path for dir,\n+\t\t\t\t// but check that using it wouldn't find something\n+\t\t\t\t// else first.\n+\t\t\t\tif ctxt.GOROOT != \"\" {\n+\t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", sub); ctxt.isDir(dir) {\n+\t\t\t\t\t\tgoto Found\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tfor _, earlyRoot := range all[:i] {\n+\t\t\t\t\tif dir := ctxt.joinPath(earlyRoot, \"src\", sub); ctxt.isDir(dir) {\n+\t\t\t\t\t\tgoto Found\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// sub would not name some other directory instead of this one.\n+\t\t\t\t// Record it.\n+\t\t\t\tp.ImportPath = sub\n+\t\t\t\tp.Root = root\n+\t\t\t\tgoto Found\n+\t\t\t}\n+\t\t}\n+\t\t// It's okay that we didn't find a root containing dir.\n+\t\t// Keep going with the information we have.\n+\t} else {\n+\t\tif strings.HasPrefix(path, \"/\") {\n+\t\t\treturn p, fmt.Errorf(\"import %q: cannot import absolute path\", path)\n+\t\t}\n+\t\t// Determine directory from import path.\n+\t\tif ctxt.GOROOT != \"\" {\n+\t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", \"pkg\", path)\n+\t\t\tisDir := ctxt.isDir(dir)\n+\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n+\t\t\tif isDir || binaryOnly {\n+\t\t\t\tp.Dir = dir\n+\t\t\t\tp.Goroot = true\n+\t\t\t\tp.Root = ctxt.GOROOT\n+\t\t\t\tgoto Found\n+\t\t\t}\n+\t\t}\n+\t\tfor _, root := range ctxt.gopath() {\n+\t\t\tdir := ctxt.joinPath(root, \"src\", path)\n+\t\t\tisDir := ctxt.isDir(dir)\n+\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && ctxt.isFile(ctxt.joinPath(root, pkga))\n+\t\t\tif isDir || binaryOnly {\n+\t\t\t\tp.Dir = dir\n+\t\t\t\tp.Root = root\n+\t\t\t\tgoto Found\n+\t\t\t}\n+\t\t}\n+\t\treturn p, fmt.Errorf(\"import %q: cannot find package\", path)\n+\t}\n+\n+Found:\n+\tif p.Root != \"\" {\n+\t\tif p.Goroot {\n+\t\t\tp.SrcRoot = ctxt.joinPath(p.Root, \"src\", \"pkg\")\n+\t\t} else {\n+\t\t\tp.SrcRoot = ctxt.joinPath(p.Root, \"src\")\n+\t\t}\n+\t\tp.PkgRoot = ctxt.joinPath(p.Root, \"pkg\")\n+\t\tp.BinDir = ctxt.joinPath(p.Root, \"bin\")\n+\t\tp.PkgObj = ctxt.joinPath(p.Root, pkga)\n+\t}\n+\n+\tif mode&FindOnly != 0 {\n+\t\treturn p, nil\n+\t}\n+\tif binaryOnly && (mode&AllowBinary) != 0 {\n+\t\treturn p, nil\n+\t}\n+\n+\tdirs, err := ctxt.readDir(p.Dir)\n+\tif err != nil {\n+\t\treturn p, err\n+\t}\n+\n+\tvar Sfiles []string // files with \".S\" (capital S)\n+\tvar firstFile string\n+\timported := make(map[string][]token.Position)\n+\ttestImported := make(map[string][]token.Position)\n+\txTestImported := make(map[string][]token.Position)\n+\tfset := token.NewFileSet()\n+\tfor _, d := range dirs {\n+\t\tif d.IsDir() {\n+\t\t\tcontinue\n+\t\t}\n+\t\tname := d.Name()\n+\t\tif strings.HasPrefix(name, \"_\") ||\n+\t\t\tstrings.HasPrefix(name, \".\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !ctxt.UseAllFiles && !ctxt.goodOSArchFile(name) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\ti := strings.LastIndex(name, \".\")\n+\t\tif i < 0 {\n+\t\t\ti = len(name)\n+\t\t}\n+\t\text := name[i:]\n+\t\tswitch ext {\n+\t\tcase \".go\", \".c\", \".s\", \".h\", \".S\":\n+\t\t\t// tentatively okay\n+\t\tdefault:\n+\t\t\t// skip\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfilename := ctxt.joinPath(p.Dir, name)\n+\t\tf, err := ctxt.openFile(filename)\n+\t\tif err != nil {\n+\t\t\treturn p, err\n+\t\t}\n+\t\tdata, err := ioutil.ReadAll(f)\n+\t\tf.Close()\n+\t\tif err != nil {\n+\t\t\treturn p, fmt.Errorf(\"read %s: %v\", filename, err)\n+\t\t}\n+\n+\t\t// Look for +build comments to accept or reject the file.\n+\t\tif !ctxt.UseAllFiles && !ctxt.shouldBuild(data) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Going to save the file.  For non-Go files, can stop here.\n+\t\tswitch ext {\n+\t\tcase \".c\":\n+\t\t\tp.CFiles = append(p.CFiles, name)\n+\t\t\tcontinue\n+\t\tcase \".h\":\n+\t\t\tp.HFiles = append(p.HFiles, name)\n+\t\t\tcontinue\n+\t\tcase \".s\":\n+\t\t\tp.SFiles = append(p.SFiles, name)\n+\t\t\tcontinue\n+\t\tcase \".S\":\n+\t\t\tSfiles = append(Sfiles, name)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tpf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\treturn p, err\n+\t\t}\n+\n+\t\tpkg := string(pf.Name.Name)\n+\t\tif pkg == \"documentation\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tisTest := strings.HasSuffix(name, \"_test.go\")\n+\t\tisXTest := false\n+\t\tif isTest && strings.HasSuffix(pkg, \"_test\") {\n+\t\t\tisXTest = true\n+\t\t\tpkg = pkg[:len(pkg)-len(\"_test\")]\n+\t\t}\n+\n+\t\tif p.Name == \"\" {\n+\t\t\tp.Name = pkg\n+\t\t\tfirstFile = name\n+\t\t} else if pkg != p.Name {\n+\t\t\treturn p, fmt.Errorf(\"found packages %s (%s) and %s (%s) in %s\", p.Name, firstFile, pkg, name, p.Dir)\n+\t\t}\n+\t\tif pf.Doc != nil && p.Doc == \"\" {\n+\t\t\tp.Doc = doc.Synopsis(pf.Doc.Text())\n+\t\t}\n+\n+\t\t// Record imports and information about cgo.\n+\t\tisCgo := false\n+\t\tfor _, decl := range pf.Decls {\n+\t\t\td, ok := decl.(*ast.GenDecl)\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, dspec := range d.Specs {\n+\t\t\t\tspec, ok := dspec.(*ast.ImportSpec)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tquoted := string(spec.Path.Value)\n+\t\t\t\tpath, err := strconv.Unquote(quoted)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tlog.Panicf(\"%s: parser returned invalid quoted string: <%s>\", filename, quoted)\n+\t\t\t\t}\n+\t\t\t\tif isXTest {\n+\t\t\t\t\txTestImported[path] = append(xTestImported[path], fset.Position(spec.Pos()))\n+\t\t\t\t} else if isTest {\n+\t\t\t\t\ttestImported[path] = append(testImported[path], fset.Position(spec.Pos()))\n+\t\t\t\t} else {\n+\t\t\t\t\timported[path] = append(imported[path], fset.Position(spec.Pos()))\n+\t\t\t\t}\n+\t\t\t\tif path == \"C\" {\n+\t\t\t\t\tif isTest {\n+\t\t\t\t\t\treturn p, fmt.Errorf(\"use of cgo in test %s not supported\", filename)\n+\t\t\t\t\t}\n+\t\t\t\t\tcg := spec.Doc\n+\t\t\t\t\tif cg == nil && len(d.Specs) == 1 {\n+\t\t\t\t\t\tcg = d.Doc\n+\t\t\t\t\t}\n+\t\t\t\t\tif cg != nil {\n+\t\t\t\t\t\tif err := ctxt.saveCgo(filename, p, cg); err != nil {\n+\t\t\t\t\t\t\treturn p, err\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tisCgo = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif isCgo {\n+\t\t\tif ctxt.CgoEnabled {\n+\t\t\t\tp.CgoFiles = append(p.CgoFiles, name)\n+\t\t\t}\n+\t\t} else if isXTest {\n+\t\t\tp.XTestGoFiles = append(p.XTestGoFiles, name)\n+\t\t} else if isTest {\n+\t\t\tp.TestGoFiles = append(p.TestGoFiles, name)\n+\t\t} else {\n+\t\t\tp.GoFiles = append(p.GoFiles, name)\n+\t\t}\n+\t}\n+\tif p.Name == \"\" {\n+\t\treturn p, fmt.Errorf(\"no Go source files in %s\", p.Dir)\n+\t}\n+\n+\tp.Imports, p.ImportPos = cleanImports(imported)\n+\tp.TestImports, p.TestImportPos = cleanImports(testImported)\n+\tp.XTestImports, p.XTestImportPos = cleanImports(xTestImported)\n+\n+\t// add the .S files only if we are using cgo\n+\t// (which means gcc will compile them).\n+\t// The standard assemblers expect .s files.\n+\tif len(p.CgoFiles) > 0 {\n+\t\tp.SFiles = append(p.SFiles, Sfiles...)\n+\t\tsort.Strings(p.SFiles)\n+\t}\n+\n+\treturn p, nil\n+}\n+\n+func cleanImports(m map[string][]token.Position) ([]string, map[string][]token.Position) {\n+\tall := make([]string, 0, len(m))\n+\tfor path := range m {\n+\t\tall = append(all, path)\n+\t}\n+\tsort.Strings(all)\n+\treturn all, m\n+}\n+\n+// Import is shorthand for Default.Import.\n+func Import(path, src string, mode ImportMode) (*Package, error) {\n+\treturn Default.Import(path, src, mode)\n+}\n+\n+// ImportDir is shorthand for Default.ImportDir.\n+func ImportDir(dir string, mode ImportMode) (*Package, error) {\n+\treturn Default.ImportDir(dir, mode)\n+}\n+\n+var slashslash = []byte(\"//\")\n+\n+// shouldBuild reports whether it is okay to use this file,\n+// The rule is that in the file's leading run of // comments\n+// and blank lines, which must be followed by a blank line\n+// (to avoid including a Go package clause doc comment),\n+// lines beginning with '// +build' are taken as build directives.\n+//\n+// The file is accepted only if each such line lists something\n+// matching the file.  For example:\n+//\n+//\t// +build windows linux\n+//\n+// marks the file as applicable only on Windows and Linux.\n+//\n+func (ctxt *Context) shouldBuild(content []byte) bool {\n+\t// Pass 1. Identify leading run of // comments and blank lines,\n+\t// which must be followed by a blank line.\n+\tend := 0\n+\tp := content\n+\tfor len(p) > 0 {\n+\t\tline := p\n+\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\tline, p = line[:i], p[i+1:]\n+\t\t} else {\n+\t\t\tp = p[len(p):]\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif len(line) == 0 { // Blank line\n+\t\t\tend = cap(content) - cap(line) // &line[0] - &content[0]\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.HasPrefix(line, slashslash) { // Not comment line\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tcontent = content[:end]\n+\n+\t// Pass 2.  Process each line in the run.\n+\tp = content\n+\tfor len(p) > 0 {\n+\t\tline := p\n+\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n+\t\t\tline, p = line[:i], p[i+1:]\n+\t\t} else {\n+\t\t\tp = p[len(p):]\n+\t\t}\n+\t\tline = bytes.TrimSpace(line)\n+\t\tif bytes.HasPrefix(line, slashslash) {\n+\t\t\tline = bytes.TrimSpace(line[len(slashslash):])\n+\t\t\tif len(line) > 0 && line[0] == '+' {\n+\t\t\t\t// Looks like a comment +line.\n+\t\t\t\tf := strings.Fields(string(line))\n+\t\t\t\tif f[0] == \"+build\" {\n+\t\t\t\t\tok := false\n+\t\t\t\t\tfor _, tok := range f[1:] {\n+\t\t\t\t\t\tif ctxt.match(tok) {\n+\t\t\t\t\t\t\tok = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif !ok {\n+\t\t\t\t\t\treturn false // this one doesn't match\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true // everything matches\n+}\n+\n+// saveCgo saves the information from the #cgo lines in the import \"C\" comment.\n+// These lines set CFLAGS and LDFLAGS and pkg-config directives that affect\n+// the way cgo's C code is built.\n+//\n+// TODO(rsc): This duplicates code in cgo.\n+// Once the dust settles, remove this code from cgo.\n+func (ctxt *Context) saveCgo(filename string, di *Package, cg *ast.CommentGroup) error {\n+\ttext := cg.Text()\n+\tfor _, line := range strings.Split(text, \"\\n\") {\n+\t\torig := line\n+\n+\t\t// Line is\n+\t\t//\t#cgo [GOOS/GOARCH...] LDFLAGS: stuff\n+\t\t//\n+\t\tline = strings.TrimSpace(line)\n+\t\tif len(line) < 5 || line[:4] != \"#cgo\" || (line[4] != ' ' && line[4] != '\\t') {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Split at colon.\n+\t\tline = strings.TrimSpace(line[4:])\n+\t\ti := strings.Index(line, \":\")\n+\t\tif i < 0 {\n+\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n+\t\t}\n+\t\tline, argstr := line[:i], line[i+1:]\n+\n+\t\t// Parse GOOS/GOARCH stuff.\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) < 1 {\n+\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n+\t\t}\n+\n+\t\tcond, verb := f[:len(f)-1], f[len(f)-1]\n+\t\tif len(cond) > 0 {\n+\t\t\tok := false\n+\t\t\tfor _, c := range cond {\n+\t\t\t\tif ctxt.match(c) {\n+\t\t\t\t\tok = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\targs, err := splitQuoted(argstr)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n+\t\t}\n+\t\tfor _, arg := range args {\n+\t\t\tif !safeName(arg) {\n+\t\t\t\treturn fmt.Errorf(\"%s: malformed #cgo argument: %s\", filename, arg)\n+\t\t\t}\n+\t\t}\n+\n+\t\tswitch verb {\n+\t\tcase \"CFLAGS\":\n+\t\t\tdi.CgoCFLAGS = append(di.CgoCFLAGS, args...)\n+\t\tcase \"LDFLAGS\":\n+\t\t\tdi.CgoLDFLAGS = append(di.CgoLDFLAGS, args...)\n+\t\tcase \"pkg-config\":\n+\t\t\tdi.CgoPkgConfig = append(di.CgoPkgConfig, args...)\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"%s: invalid #cgo verb: %s\", filename, orig)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+var safeBytes = []byte(\"+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz:\")\n+\n+func safeName(s string) bool {\n+\tif s == \"\" {\n+\t\treturn false\n+\t}\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif c := s[i]; c < 0x80 && bytes.IndexByte(safeBytes, c) < 0 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// splitQuoted splits the string s around each instance of one or more consecutive\n+// white space characters while taking into account quotes and escaping, and\n+// returns an array of substrings of s or an empty list if s contains only white space.\n+// Single quotes and double quotes are recognized to prevent splitting within the\n+// quoted region, and are removed from the resulting substrings. If a quote in s\n+// isn't closed err will be set and r will have the unclosed argument as the\n+// last element.  The backslash is used for escaping.\n+//\n+// For example, the following string:\n+//\n+//     a b:\"c d\" 'e''f'  \"g\\\"\"\n+//\n+// Would be parsed as:\n+//\n+//     []string{\"a\", \"b:c d\", \"ef\", `g\"`}\n+//\n+func splitQuoted(s string) (r []string, err error) {\n+\tvar args []string\n+\targ := make([]rune, len(s))\n+\tescaped := false\n+\tquoted := false\n+\tquote := '\\x00'\n+\ti := 0\n+\tfor _, rune := range s {\n+\t\tswitch {\n+\t\tcase escaped:\n+\t\t\tescaped = false\n+\t\tcase rune == '\\\\':\n+\t\t\tescaped = true\n+\t\t\tcontinue\n+\t\tcase quote != '\\x00':\n+\t\t\tif rune == quote {\n+\t\t\t\tquote = '\\x00'\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\tcase rune == '\"' || rune == '\\'':\n+\t\t\tquoted = true\n+\t\t\tquote = rune\n+\t\t\tcontinue\n+\t\tcase unicode.IsSpace(rune):\n+\t\t\tif quoted || i > 0 {\n+\t\t\t\tquoted = false\n+\t\t\t\targs = append(args, string(arg[:i]))\n+\t\t\t\ti = 0\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\targ[i] = rune\n+\t\ti++\n+\t}\n+\tif quoted || i > 0 {\n+\t\targs = append(args, string(arg[:i]))\n+\t}\n+\tif quote != 0 {\n+\t\terr = errors.New(\"unclosed quote\")\n+\t} else if escaped {\n+\t\terr = errors.New(\"unfinished escaping\")\n+\t}\n+\treturn args, err\n+}\n+\n+// match returns true if the name is one of:\n+//\n+//\t$GOOS\n+//\t$GOARCH\n+//\tcgo (if cgo is enabled)\n+//\t!cgo (if cgo is disabled)\n+//\ttag (if tag is listed in ctxt.BuildTags)\n+//\t!tag (if tag is not listed in ctxt.BuildTags)\n+//\ta slash-separated list of any of these\n+//\n+func (ctxt *Context) match(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\tif i := strings.Index(name, \",\"); i >= 0 {\n+\t\t// comma-separated list\n+\t\treturn ctxt.match(name[:i]) && ctxt.match(name[i+1:])\n+\t}\n+\tif strings.HasPrefix(name, \"!!\") { // bad syntax, reject always\n+\t\treturn false\n+\t}\n+\tif strings.HasPrefix(name, \"!\") { // negation\n+\t\treturn !ctxt.match(name[1:])\n+\t}\n+\n+\t// Tags must be letters, digits, underscores.\n+\t// Unlike in Go identifiers, all digits is fine (e.g., \"386\").\n+\tfor _, c := range name {\n+\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\t// special tags\n+\tif ctxt.CgoEnabled && name == \"cgo\" {\n+\t\treturn true\n+\t}\n+\tif name == ctxt.GOOS || name == ctxt.GOARCH {\n+\t\treturn true\n+\t}\n+\n+\t// other tags\n+\tfor _, tag := range ctxt.BuildTags {\n+\t\tif tag == name {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// goodOSArchFile returns false if the name contains a $GOOS or $GOARCH\n+// suffix which does not match the current system.\n+// The recognized name formats are:\n+//\n+//     name_$(GOOS).*\n+//     name_$(GOARCH).*\n+//     name_$(GOOS)_$(GOARCH).*\n+//     name_$(GOOS)_test.*\n+//     name_$(GOARCH)_test.*\n+//     name_$(GOOS)_$(GOARCH)_test.*\n+//\n+func (ctxt *Context) goodOSArchFile(name string) bool {\n+\tif dot := strings.Index(name, \".\"); dot != -1 {\n+\t\tname = name[:dot]\n+\t}\n+\tl := strings.Split(name, \"_\")\n+\tif n := len(l); n > 0 && l[n-1] == \"test\" {\n+\t\tl = l[:n-1]\n+\t}\n+\tn := len(l)\n+\tif n >= 2 && knownOS[l[n-2]] && knownArch[l[n-1]] {\n+\t\treturn l[n-2] == ctxt.GOOS && l[n-1] == ctxt.GOARCH\n+\t}\n+\tif n >= 1 && knownOS[l[n-1]] {\n+\t\treturn l[n-1] == ctxt.GOOS\n+\t}\n+\tif n >= 1 && knownArch[l[n-1]] {\n+\t\treturn l[n-1] == ctxt.GOARCH\n+\t}\n+\treturn true\n+}\n+\n+var knownOS = make(map[string]bool)\n+var knownArch = make(map[string]bool)\n+\n+func init() {\n+\tfor _, v := range strings.Fields(goosList) {\n+\t\tknownOS[v] = true\n+\t}\n+\tfor _, v := range strings.Fields(goarchList) {\n+\t\tknownArch[v] = true\n+\t}\n+}\n+\n+// ToolDir is the directory containing build tools.\n+var ToolDir = filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+\n+// IsLocalImport reports whether the import path is\n+// a local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n+func IsLocalImport(path string) bool {\n+\treturn path == \".\" || path == \"..\" ||\n+\t\tstrings.HasPrefix(path, \"./\") || strings.HasPrefix(path, \"../\")\n+}\n \n // ArchChar returns the architecture character for the given goarch.\n // For example, ArchChar(\"amd64\") returns \"6\"."}, {"sha": "06b8b0e94f86365f6553e7f0f462602998383752", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 39, "deletions": 71, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,83 +5,14 @@\n package build\n \n import (\n+\t\"os\"\n \t\"path/filepath\"\n-\t\"reflect\"\n \t\"runtime\"\n-\t\"sort\"\n \t\"testing\"\n )\n \n-func sortstr(x []string) []string {\n-\tsort.Strings(x)\n-\treturn x\n-}\n-\n-var buildPkgs = []struct {\n-\tdir  string\n-\tinfo *DirInfo\n-}{\n-\t{\n-\t\t\"go/build/pkgtest\",\n-\t\t&DirInfo{\n-\t\t\tGoFiles:      []string{\"pkgtest.go\"},\n-\t\t\tSFiles:       []string{\"sqrt_\" + runtime.GOARCH + \".s\"},\n-\t\t\tPackage:      \"pkgtest\",\n-\t\t\tImports:      []string{\"bytes\"},\n-\t\t\tTestImports:  []string{\"fmt\", \"pkgtest\"},\n-\t\t\tTestGoFiles:  sortstr([]string{\"sqrt_test.go\", \"sqrt_\" + runtime.GOARCH + \"_test.go\"}),\n-\t\t\tXTestGoFiles: []string{\"xsqrt_test.go\"},\n-\t\t},\n-\t},\n-\t{\n-\t\t\"go/build/cmdtest\",\n-\t\t&DirInfo{\n-\t\t\tGoFiles:     []string{\"main.go\"},\n-\t\t\tPackage:     \"main\",\n-\t\t\tImports:     []string{\"go/build/pkgtest\"},\n-\t\t\tTestImports: []string{},\n-\t\t},\n-\t},\n-\t{\n-\t\t\"go/build/cgotest\",\n-\t\t&DirInfo{\n-\t\t\tCgoFiles:    ifCgo([]string{\"cgotest.go\"}),\n-\t\t\tCFiles:      []string{\"cgotest.c\"},\n-\t\t\tHFiles:      []string{\"cgotest.h\"},\n-\t\t\tImports:     []string{\"C\", \"unsafe\"},\n-\t\t\tTestImports: []string{},\n-\t\t\tPackage:     \"cgotest\",\n-\t\t},\n-\t},\n-}\n-\n-func ifCgo(x []string) []string {\n-\tif DefaultContext.CgoEnabled {\n-\t\treturn x\n-\t}\n-\treturn nil\n-}\n-\n-func TestBuild(t *testing.T) {\n-\tfor _, tt := range buildPkgs {\n-\t\ttree := Path[0] // Goroot\n-\t\tdir := filepath.Join(tree.SrcDir(), tt.dir)\n-\t\tinfo, err := ScanDir(dir)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"ScanDir(%#q): %v\", tt.dir, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\t// Don't bother testing import positions.\n-\t\ttt.info.ImportPos, tt.info.TestImportPos = info.ImportPos, info.TestImportPos\n-\t\tif !reflect.DeepEqual(info, tt.info) {\n-\t\t\tt.Errorf(\"ScanDir(%#q) = %#v, want %#v\\n\", tt.dir, info, tt.info)\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}\n-\n func TestMatch(t *testing.T) {\n-\tctxt := DefaultContext\n+\tctxt := Default\n \twhat := \"default\"\n \tmatch := func(tag string) {\n \t\tif !ctxt.match(tag) {\n@@ -106,3 +37,40 @@ func TestMatch(t *testing.T) {\n \tmatch(runtime.GOOS + \",\" + runtime.GOARCH + \",!bar\")\n \tnomatch(runtime.GOOS + \",\" + runtime.GOARCH + \",bar\")\n }\n+\n+func TestDotSlashImport(t *testing.T) {\n+\tp, err := ImportDir(\"testdata/other\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(p.Imports) != 1 || p.Imports[0] != \"./file\" {\n+\t\tt.Fatalf(\"testdata/other: Imports=%v, want [./file]\", p.Imports)\n+\t}\n+\n+\tp1, err := Import(\"./file\", \"testdata/other\", 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif p1.Name != \"file\" {\n+\t\tt.Fatalf(\"./file: Name=%q, want %q\", p1.Name, \"file\")\n+\t}\n+\tdir := filepath.Clean(\"testdata/other/file\") // Clean to use \\ on Windows\n+\tif p1.Dir != dir {\n+\t\tt.Fatalf(\"./file: Dir=%q, want %q\", p1.Name, dir)\n+\t}\n+}\n+\n+func TestLocalDirectory(t *testing.T) {\n+\tcwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tp, err := ImportDir(cwd, 0)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif p.ImportPath != \"go/build\" {\n+\t\tt.Fatalf(\"ImportPath=%q, want %q\", p.ImportPath, \"go/build\")\n+\t}\n+}"}, {"sha": "93bbf06883f39b3730a55732e23a23a873162373", "filename": "libgo/go/go/build/cgotest/cgotest.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fcgotest%2Fcgotest.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package cgotest\n-\n-/*\n-char* greeting = \"hello, world\";\n-*/\n-// #include \"cgotest.h\"\n-import \"C\"\n-import \"unsafe\"\n-\n-var Greeting = C.GoString(C.greeting)\n-\n-func DoAdd(x, y int) (sum int) {\n-\tC.Add(C.int(x), C.int(y), (*C.int)(unsafe.Pointer(&sum)))\n-\treturn\n-}"}, {"sha": "bed4f485a0a222e1fc04d6753b07262cc0bff58a", "filename": "libgo/go/go/build/cmdtest/main.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fcmdtest%2Fmain.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import \"go/build/pkgtest\"\n-\n-func main() {\n-\tpkgtest.Foo()\n-\tprint(int(pkgtest.Sqrt(9)))\n-}"}, {"sha": "6b30f76265b2450127261b29e9d5d4275e981ea6", "filename": "libgo/go/go/build/dir.go", "status": "removed", "additions": 0, "deletions": 705, "changes": 705, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,705 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package build\n-\n-import (\n-\t\"bytes\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/parser\"\n-\t\"go/token\"\n-\t\"io/ioutil\"\n-\t\"log\"\n-\t\"os\"\n-\t\"path\"\n-\t\"path/filepath\"\n-\t\"runtime\"\n-\t\"sort\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"unicode\"\n-)\n-\n-// A Context specifies the supporting context for a build.\n-type Context struct {\n-\tGOARCH      string   // target architecture\n-\tGOOS        string   // target operating system\n-\tCgoEnabled  bool     // whether cgo can be used\n-\tBuildTags   []string // additional tags to recognize in +build lines\n-\tUseAllFiles bool     // use files regardless of +build lines, file names\n-\n-\t// By default, ScanDir uses the operating system's\n-\t// file system calls to read directories and files.\n-\t// Callers can override those calls to provide other\n-\t// ways to read data by setting ReadDir and ReadFile.\n-\t// ScanDir does not make any assumptions about the\n-\t// format of the strings dir and file: they can be\n-\t// slash-separated, backslash-separated, even URLs.\n-\n-\t// ReadDir returns a slice of os.FileInfo, sorted by Name,\n-\t// describing the content of the named directory.\n-\t// The dir argument is the argument to ScanDir.\n-\t// If ReadDir is nil, ScanDir uses io.ReadDir.\n-\tReadDir func(dir string) (fi []os.FileInfo, err error)\n-\n-\t// ReadFile returns the content of the file named file\n-\t// in the directory named dir.  The dir argument is the\n-\t// argument to ScanDir, and the file argument is the\n-\t// Name field from an os.FileInfo returned by ReadDir.\n-\t// The returned path is the full name of the file, to be\n-\t// used in error messages.\n-\t//\n-\t// If ReadFile is nil, ScanDir uses filepath.Join(dir, file)\n-\t// as the path and ioutil.ReadFile to read the data.\n-\tReadFile func(dir, file string) (path string, content []byte, err error)\n-}\n-\n-func (ctxt *Context) readDir(dir string) ([]os.FileInfo, error) {\n-\tif f := ctxt.ReadDir; f != nil {\n-\t\treturn f(dir)\n-\t}\n-\treturn ioutil.ReadDir(dir)\n-}\n-\n-func (ctxt *Context) readFile(dir, file string) (string, []byte, error) {\n-\tif f := ctxt.ReadFile; f != nil {\n-\t\treturn f(dir, file)\n-\t}\n-\tp := filepath.Join(dir, file)\n-\tcontent, err := ioutil.ReadFile(p)\n-\treturn p, content, err\n-}\n-\n-// The DefaultContext is the default Context for builds.\n-// It uses the GOARCH and GOOS environment variables\n-// if set, or else the compiled code's GOARCH and GOOS.\n-var DefaultContext Context = defaultContext()\n-\n-var cgoEnabled = map[string]bool{\n-\t\"darwin/386\":    true,\n-\t\"darwin/amd64\":  true,\n-\t\"linux/386\":     true,\n-\t\"linux/amd64\":   true,\n-\t\"freebsd/386\":   true,\n-\t\"freebsd/amd64\": true,\n-\t\"windows/386\":   true,\n-\t\"windows/amd64\": true,\n-}\n-\n-func defaultContext() Context {\n-\tvar c Context\n-\n-\tc.GOARCH = envOr(\"GOARCH\", runtime.GOARCH)\n-\tc.GOOS = envOr(\"GOOS\", runtime.GOOS)\n-\n-\ts := os.Getenv(\"CGO_ENABLED\")\n-\tswitch s {\n-\tcase \"1\":\n-\t\tc.CgoEnabled = true\n-\tcase \"0\":\n-\t\tc.CgoEnabled = false\n-\tdefault:\n-\t\tc.CgoEnabled = cgoEnabled[c.GOOS+\"/\"+c.GOARCH]\n-\t}\n-\n-\treturn c\n-}\n-\n-func envOr(name, def string) string {\n-\ts := os.Getenv(name)\n-\tif s == \"\" {\n-\t\treturn def\n-\t}\n-\treturn s\n-}\n-\n-type DirInfo struct {\n-\tPackage        string                      // Name of package in dir\n-\tPackageComment *ast.CommentGroup           // Package comments from GoFiles\n-\tImportPath     string                      // Import path of package in dir\n-\tImports        []string                    // All packages imported by GoFiles\n-\tImportPos      map[string][]token.Position // Source code location of imports\n-\n-\t// Source files\n-\tGoFiles  []string // .go files in dir (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n-\tHFiles   []string // .h files in dir\n-\tCFiles   []string // .c files in dir\n-\tSFiles   []string // .s (and, when using cgo, .S files in dir)\n-\tCgoFiles []string // .go files that import \"C\"\n-\n-\t// Cgo directives\n-\tCgoPkgConfig []string // Cgo pkg-config directives\n-\tCgoCFLAGS    []string // Cgo CFLAGS directives\n-\tCgoLDFLAGS   []string // Cgo LDFLAGS directives\n-\n-\t// Test information\n-\tTestGoFiles   []string // _test.go files in package\n-\tXTestGoFiles  []string // _test.go files outside package\n-\tTestImports   []string // All packages imported by (X)TestGoFiles\n-\tTestImportPos map[string][]token.Position\n-}\n-\n-func (d *DirInfo) IsCommand() bool {\n-\t// TODO(rsc): This is at least a little bogus.\n-\treturn d.Package == \"main\"\n-}\n-\n-// ScanDir calls DefaultContext.ScanDir.\n-func ScanDir(dir string) (info *DirInfo, err error) {\n-\treturn DefaultContext.ScanDir(dir)\n-}\n-\n-// TODO(rsc): Move this comment to a more appropriate place.\n-\n-// ScanDir returns a structure with details about the Go package\n-// found in the given directory.\n-//\n-// Most .go, .c, .h, and .s files in the directory are considered part\n-// of the package.  The exceptions are:\n-//\n-//\t- .go files in package main (unless no other package is found)\n-//\t- .go files in package documentation\n-//\t- files starting with _ or .\n-//\t- files with build constraints not satisfied by the context\n-//\n-// Build Constraints\n-//\n-// A build constraint is a line comment beginning with the directive +build\n-// that lists the conditions under which a file should be included in the package.\n-// Constraints may appear in any kind of source file (not just Go), but\n-// they must be appear near the top of the file, preceded\n-// only by blank lines and other line comments.\n-//\n-// A build constraint is evaluated as the OR of space-separated options;\n-// each option evaluates as the AND of its comma-separated terms;\n-// and each term is an alphanumeric word or, preceded by !, its negation.\n-// That is, the build constraint:\n-//\n-//\t// +build linux,386 darwin,!cgo\n-//\n-// corresponds to the boolean formula:\n-//\n-//\t(linux AND 386) OR (darwin AND (NOT cgo))\n-//\n-// During a particular build, the following words are satisfied:\n-//\n-//\t- the target operating system, as spelled by runtime.GOOS\n-//\t- the target architecture, as spelled by runtime.GOARCH\n-//\t- \"cgo\", if ctxt.CgoEnabled is true\n-//\t- any additional words listed in ctxt.BuildTags\n-//\n-// If a file's name, after stripping the extension and a possible _test suffix,\n-// matches *_GOOS, *_GOARCH, or *_GOOS_GOARCH for any known operating\n-// system and architecture values, then the file is considered to have an implicit\n-// build constraint requiring those terms.\n-//\n-// Examples\n-//\n-// To keep a file from being considered for the build:\n-//\n-//\t// +build ignore\n-//\n-// (any other unsatisfied word will work as well, but ``ignore'' is conventional.)\n-//\n-// To build a file only when using cgo, and only on Linux and OS X:\n-//\n-//\t// +build linux,cgo darwin,cgo\n-// \n-// Such a file is usually paired with another file implementing the\n-// default functionality for other systems, which in this case would\n-// carry the constraint:\n-//\n-//\t// +build !linux !darwin !cgo\n-//\n-// Naming a file dns_windows.go will cause it to be included only when\n-// building the package for Windows; similarly, math_386.s will be included\n-// only when building the package for 32-bit x86.\n-//\n-func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n-\tdirs, err := ctxt.readDir(dir)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar Sfiles []string // files with \".S\" (capital S)\n-\tvar di DirInfo\n-\tvar firstFile string\n-\timported := make(map[string][]token.Position)\n-\ttestImported := make(map[string][]token.Position)\n-\tfset := token.NewFileSet()\n-\tfor _, d := range dirs {\n-\t\tif d.IsDir() {\n-\t\t\tcontinue\n-\t\t}\n-\t\tname := d.Name()\n-\t\tif strings.HasPrefix(name, \"_\") ||\n-\t\t\tstrings.HasPrefix(name, \".\") {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !ctxt.UseAllFiles && !ctxt.goodOSArchFile(name) {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\text := path.Ext(name)\n-\t\tswitch ext {\n-\t\tcase \".go\", \".c\", \".s\", \".h\", \".S\":\n-\t\t\t// tentatively okay\n-\t\tdefault:\n-\t\t\t// skip\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tfilename, data, err := ctxt.readFile(dir, name)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\t// Look for +build comments to accept or reject the file.\n-\t\tif !ctxt.UseAllFiles && !ctxt.shouldBuild(data) {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Going to save the file.  For non-Go files, can stop here.\n-\t\tswitch ext {\n-\t\tcase \".c\":\n-\t\t\tdi.CFiles = append(di.CFiles, name)\n-\t\t\tcontinue\n-\t\tcase \".h\":\n-\t\t\tdi.HFiles = append(di.HFiles, name)\n-\t\t\tcontinue\n-\t\tcase \".s\":\n-\t\t\tdi.SFiles = append(di.SFiles, name)\n-\t\t\tcontinue\n-\t\tcase \".S\":\n-\t\t\tSfiles = append(Sfiles, name)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tpf, err := parser.ParseFile(fset, filename, data, parser.ImportsOnly|parser.ParseComments)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tpkg := string(pf.Name.Name)\n-\t\tif pkg == \"documentation\" {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tisTest := strings.HasSuffix(name, \"_test.go\")\n-\t\tif isTest && strings.HasSuffix(pkg, \"_test\") {\n-\t\t\tpkg = pkg[:len(pkg)-len(\"_test\")]\n-\t\t}\n-\n-\t\tif di.Package == \"\" {\n-\t\t\tdi.Package = pkg\n-\t\t\tfirstFile = name\n-\t\t} else if pkg != di.Package {\n-\t\t\treturn nil, fmt.Errorf(\"%s: found packages %s (%s) and %s (%s)\", dir, di.Package, firstFile, pkg, name)\n-\t\t}\n-\t\tif pf.Doc != nil {\n-\t\t\tif di.PackageComment != nil {\n-\t\t\t\tdi.PackageComment.List = append(di.PackageComment.List, pf.Doc.List...)\n-\t\t\t} else {\n-\t\t\t\tdi.PackageComment = pf.Doc\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Record imports and information about cgo.\n-\t\tisCgo := false\n-\t\tfor _, decl := range pf.Decls {\n-\t\t\td, ok := decl.(*ast.GenDecl)\n-\t\t\tif !ok {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tfor _, dspec := range d.Specs {\n-\t\t\t\tspec, ok := dspec.(*ast.ImportSpec)\n-\t\t\t\tif !ok {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tquoted := string(spec.Path.Value)\n-\t\t\t\tpath, err := strconv.Unquote(quoted)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tlog.Panicf(\"%s: parser returned invalid quoted string: <%s>\", filename, quoted)\n-\t\t\t\t}\n-\t\t\t\tif isTest {\n-\t\t\t\t\ttestImported[path] = append(testImported[path], fset.Position(spec.Pos()))\n-\t\t\t\t} else {\n-\t\t\t\t\timported[path] = append(imported[path], fset.Position(spec.Pos()))\n-\t\t\t\t}\n-\t\t\t\tif path == \"C\" {\n-\t\t\t\t\tif isTest {\n-\t\t\t\t\t\treturn nil, fmt.Errorf(\"%s: use of cgo in test not supported\", filename)\n-\t\t\t\t\t}\n-\t\t\t\t\tcg := spec.Doc\n-\t\t\t\t\tif cg == nil && len(d.Specs) == 1 {\n-\t\t\t\t\t\tcg = d.Doc\n-\t\t\t\t\t}\n-\t\t\t\t\tif cg != nil {\n-\t\t\t\t\t\tif err := ctxt.saveCgo(filename, &di, cg); err != nil {\n-\t\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tisCgo = true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif isCgo {\n-\t\t\tif ctxt.CgoEnabled {\n-\t\t\t\tdi.CgoFiles = append(di.CgoFiles, name)\n-\t\t\t}\n-\t\t} else if isTest {\n-\t\t\tif pkg == string(pf.Name.Name) {\n-\t\t\t\tdi.TestGoFiles = append(di.TestGoFiles, name)\n-\t\t\t} else {\n-\t\t\t\tdi.XTestGoFiles = append(di.XTestGoFiles, name)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tdi.GoFiles = append(di.GoFiles, name)\n-\t\t}\n-\t}\n-\tif di.Package == \"\" {\n-\t\treturn nil, fmt.Errorf(\"%s: no Go source files\", dir)\n-\t}\n-\tdi.Imports = make([]string, len(imported))\n-\tdi.ImportPos = imported\n-\ti := 0\n-\tfor p := range imported {\n-\t\tdi.Imports[i] = p\n-\t\ti++\n-\t}\n-\tdi.TestImports = make([]string, len(testImported))\n-\tdi.TestImportPos = testImported\n-\ti = 0\n-\tfor p := range testImported {\n-\t\tdi.TestImports[i] = p\n-\t\ti++\n-\t}\n-\n-\t// add the .S files only if we are using cgo\n-\t// (which means gcc will compile them).\n-\t// The standard assemblers expect .s files.\n-\tif len(di.CgoFiles) > 0 {\n-\t\tdi.SFiles = append(di.SFiles, Sfiles...)\n-\t\tsort.Strings(di.SFiles)\n-\t}\n-\n-\t// File name lists are sorted because ReadDir sorts.\n-\tsort.Strings(di.Imports)\n-\tsort.Strings(di.TestImports)\n-\treturn &di, nil\n-}\n-\n-var slashslash = []byte(\"//\")\n-\n-// shouldBuild reports whether it is okay to use this file,\n-// The rule is that in the file's leading run of // comments\n-// and blank lines, which must be followed by a blank line\n-// (to avoid including a Go package clause doc comment),\n-// lines beginning with '// +build' are taken as build directives.\n-//\n-// The file is accepted only if each such line lists something\n-// matching the file.  For example:\n-//\n-//\t// +build windows linux\n-//\n-// marks the file as applicable only on Windows and Linux.\n-//\n-func (ctxt *Context) shouldBuild(content []byte) bool {\n-\t// Pass 1. Identify leading run of // comments and blank lines,\n-\t// which must be followed by a blank line.\n-\tend := 0\n-\tp := content\n-\tfor len(p) > 0 {\n-\t\tline := p\n-\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n-\t\t\tline, p = line[:i], p[i+1:]\n-\t\t} else {\n-\t\t\tp = p[len(p):]\n-\t\t}\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif len(line) == 0 { // Blank line\n-\t\t\tend = cap(content) - cap(line) // &line[0] - &content[0]\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !bytes.HasPrefix(line, slashslash) { // Not comment line\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tcontent = content[:end]\n-\n-\t// Pass 2.  Process each line in the run.\n-\tp = content\n-\tfor len(p) > 0 {\n-\t\tline := p\n-\t\tif i := bytes.IndexByte(line, '\\n'); i >= 0 {\n-\t\t\tline, p = line[:i], p[i+1:]\n-\t\t} else {\n-\t\t\tp = p[len(p):]\n-\t\t}\n-\t\tline = bytes.TrimSpace(line)\n-\t\tif bytes.HasPrefix(line, slashslash) {\n-\t\t\tline = bytes.TrimSpace(line[len(slashslash):])\n-\t\t\tif len(line) > 0 && line[0] == '+' {\n-\t\t\t\t// Looks like a comment +line.\n-\t\t\t\tf := strings.Fields(string(line))\n-\t\t\t\tif f[0] == \"+build\" {\n-\t\t\t\t\tok := false\n-\t\t\t\t\tfor _, tok := range f[1:] {\n-\t\t\t\t\t\tif ctxt.match(tok) {\n-\t\t\t\t\t\t\tok = true\n-\t\t\t\t\t\t\tbreak\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif !ok {\n-\t\t\t\t\t\treturn false // this one doesn't match\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn true // everything matches\n-}\n-\n-// saveCgo saves the information from the #cgo lines in the import \"C\" comment.\n-// These lines set CFLAGS and LDFLAGS and pkg-config directives that affect\n-// the way cgo's C code is built.\n-//\n-// TODO(rsc): This duplicates code in cgo.\n-// Once the dust settles, remove this code from cgo.\n-func (ctxt *Context) saveCgo(filename string, di *DirInfo, cg *ast.CommentGroup) error {\n-\ttext := cg.Text()\n-\tfor _, line := range strings.Split(text, \"\\n\") {\n-\t\torig := line\n-\n-\t\t// Line is\n-\t\t//\t#cgo [GOOS/GOARCH...] LDFLAGS: stuff\n-\t\t//\n-\t\tline = strings.TrimSpace(line)\n-\t\tif len(line) < 5 || line[:4] != \"#cgo\" || (line[4] != ' ' && line[4] != '\\t') {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Split at colon.\n-\t\tline = strings.TrimSpace(line[4:])\n-\t\ti := strings.Index(line, \":\")\n-\t\tif i < 0 {\n-\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n-\t\t}\n-\t\tline, argstr := line[:i], line[i+1:]\n-\n-\t\t// Parse GOOS/GOARCH stuff.\n-\t\tf := strings.Fields(line)\n-\t\tif len(f) < 1 {\n-\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n-\t\t}\n-\n-\t\tcond, verb := f[:len(f)-1], f[len(f)-1]\n-\t\tif len(cond) > 0 {\n-\t\t\tok := false\n-\t\t\tfor _, c := range cond {\n-\t\t\t\tif ctxt.match(c) {\n-\t\t\t\t\tok = true\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !ok {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\n-\t\targs, err := splitQuoted(argstr)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"%s: invalid #cgo line: %s\", filename, orig)\n-\t\t}\n-\t\tfor _, arg := range args {\n-\t\t\tif !safeName(arg) {\n-\t\t\t\treturn fmt.Errorf(\"%s: malformed #cgo argument: %s\", filename, arg)\n-\t\t\t}\n-\t\t}\n-\n-\t\tswitch verb {\n-\t\tcase \"CFLAGS\":\n-\t\t\tdi.CgoCFLAGS = append(di.CgoCFLAGS, args...)\n-\t\tcase \"LDFLAGS\":\n-\t\t\tdi.CgoLDFLAGS = append(di.CgoLDFLAGS, args...)\n-\t\tcase \"pkg-config\":\n-\t\t\tdi.CgoPkgConfig = append(di.CgoPkgConfig, args...)\n-\t\tdefault:\n-\t\t\treturn fmt.Errorf(\"%s: invalid #cgo verb: %s\", filename, orig)\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-var safeBytes = []byte(\"+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz:\")\n-\n-func safeName(s string) bool {\n-\tif s == \"\" {\n-\t\treturn false\n-\t}\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif c := s[i]; c < 0x80 && bytes.IndexByte(safeBytes, c) < 0 {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-// splitQuoted splits the string s around each instance of one or more consecutive\n-// white space characters while taking into account quotes and escaping, and\n-// returns an array of substrings of s or an empty list if s contains only white space.\n-// Single quotes and double quotes are recognized to prevent splitting within the\n-// quoted region, and are removed from the resulting substrings. If a quote in s\n-// isn't closed err will be set and r will have the unclosed argument as the\n-// last element.  The backslash is used for escaping.\n-//\n-// For example, the following string:\n-//\n-//     a b:\"c d\" 'e''f'  \"g\\\"\"\n-//\n-// Would be parsed as:\n-//\n-//     []string{\"a\", \"b:c d\", \"ef\", `g\"`}\n-//\n-func splitQuoted(s string) (r []string, err error) {\n-\tvar args []string\n-\targ := make([]rune, len(s))\n-\tescaped := false\n-\tquoted := false\n-\tquote := '\\x00'\n-\ti := 0\n-\tfor _, rune := range s {\n-\t\tswitch {\n-\t\tcase escaped:\n-\t\t\tescaped = false\n-\t\tcase rune == '\\\\':\n-\t\t\tescaped = true\n-\t\t\tcontinue\n-\t\tcase quote != '\\x00':\n-\t\t\tif rune == quote {\n-\t\t\t\tquote = '\\x00'\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\tcase rune == '\"' || rune == '\\'':\n-\t\t\tquoted = true\n-\t\t\tquote = rune\n-\t\t\tcontinue\n-\t\tcase unicode.IsSpace(rune):\n-\t\t\tif quoted || i > 0 {\n-\t\t\t\tquoted = false\n-\t\t\t\targs = append(args, string(arg[:i]))\n-\t\t\t\ti = 0\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\targ[i] = rune\n-\t\ti++\n-\t}\n-\tif quoted || i > 0 {\n-\t\targs = append(args, string(arg[:i]))\n-\t}\n-\tif quote != 0 {\n-\t\terr = errors.New(\"unclosed quote\")\n-\t} else if escaped {\n-\t\terr = errors.New(\"unfinished escaping\")\n-\t}\n-\treturn args, err\n-}\n-\n-// match returns true if the name is one of:\n-//\n-//\t$GOOS\n-//\t$GOARCH\n-//\tcgo (if cgo is enabled)\n-//\t!cgo (if cgo is disabled)\n-//\ttag (if tag is listed in ctxt.BuildTags)\n-//\t!tag (if tag is not listed in ctxt.BuildTags)\n-//\ta slash-separated list of any of these\n-//\n-func (ctxt *Context) match(name string) bool {\n-\tif name == \"\" {\n-\t\treturn false\n-\t}\n-\tif i := strings.Index(name, \",\"); i >= 0 {\n-\t\t// comma-separated list\n-\t\treturn ctxt.match(name[:i]) && ctxt.match(name[i+1:])\n-\t}\n-\tif strings.HasPrefix(name, \"!!\") { // bad syntax, reject always\n-\t\treturn false\n-\t}\n-\tif strings.HasPrefix(name, \"!\") { // negation\n-\t\treturn !ctxt.match(name[1:])\n-\t}\n-\n-\t// Tags must be letters, digits, underscores.\n-\t// Unlike in Go identifiers, all digits is fine (e.g., \"386\").\n-\tfor _, c := range name {\n-\t\tif !unicode.IsLetter(c) && !unicode.IsDigit(c) && c != '_' {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\n-\t// special tags\n-\tif ctxt.CgoEnabled && name == \"cgo\" {\n-\t\treturn true\n-\t}\n-\tif name == ctxt.GOOS || name == ctxt.GOARCH {\n-\t\treturn true\n-\t}\n-\n-\t// other tags\n-\tfor _, tag := range ctxt.BuildTags {\n-\t\tif tag == name {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\n-\treturn false\n-}\n-\n-// goodOSArchFile returns false if the name contains a $GOOS or $GOARCH\n-// suffix which does not match the current system.\n-// The recognized name formats are:\n-//\n-//     name_$(GOOS).*\n-//     name_$(GOARCH).*\n-//     name_$(GOOS)_$(GOARCH).*\n-//     name_$(GOOS)_test.*\n-//     name_$(GOARCH)_test.*\n-//     name_$(GOOS)_$(GOARCH)_test.*\n-//\n-func (ctxt *Context) goodOSArchFile(name string) bool {\n-\tif dot := strings.Index(name, \".\"); dot != -1 {\n-\t\tname = name[:dot]\n-\t}\n-\tl := strings.Split(name, \"_\")\n-\tif n := len(l); n > 0 && l[n-1] == \"test\" {\n-\t\tl = l[:n-1]\n-\t}\n-\tn := len(l)\n-\tif n >= 2 && knownOS[l[n-2]] && knownArch[l[n-1]] {\n-\t\treturn l[n-2] == ctxt.GOOS && l[n-1] == ctxt.GOARCH\n-\t}\n-\tif n >= 1 && knownOS[l[n-1]] {\n-\t\treturn l[n-1] == ctxt.GOOS\n-\t}\n-\tif n >= 1 && knownArch[l[n-1]] {\n-\t\treturn l[n-1] == ctxt.GOARCH\n-\t}\n-\treturn true\n-}\n-\n-var knownOS = make(map[string]bool)\n-var knownArch = make(map[string]bool)\n-\n-func init() {\n-\tfor _, v := range strings.Fields(goosList) {\n-\t\tknownOS[v] = true\n-\t}\n-\tfor _, v := range strings.Fields(goarchList) {\n-\t\tknownArch[v] = true\n-\t}\n-}"}, {"sha": "67c26ac7f4f7edc4ab8792ebcaf75f7cc9573461", "filename": "libgo/go/go/build/doc.go", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package build gathers information about Go packages.\n+//\n+// Go Path\n+//\n+// The Go path is a list of directory trees containing Go source code.\n+// It is consulted to resolve imports that cannot be found in the standard\n+// Go tree.  The default path is the value of the GOPATH environment\n+// variable, interpreted as a path list appropriate to the operating system\n+// (on Unix, the variable is a colon-separated string;\n+// on Windows, a semicolon-separated string;\n+// on Plan 9, a list).\n+//\n+// Each directory listed in the Go path must have a prescribed structure:\n+//\n+// The src/ directory holds source code.  The path below 'src' determines\n+// the import path or executable name.\n+//\n+// The pkg/ directory holds installed package objects.\n+// As in the Go tree, each target operating system and\n+// architecture pair has its own subdirectory of pkg\n+// (pkg/GOOS_GOARCH).\n+// \n+// If DIR is a directory listed in the Go path, a package with\n+// source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n+// has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n+// (or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n+// \n+// The bin/ directory holds compiled commands.\n+// Each command is named for its source directory, but only\n+// using the final element, not the entire path.  That is, the\n+// command with source in DIR/src/foo/quux is installed into\n+// DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n+// so that you can add DIR/bin to your PATH to get at the\n+// installed commands.\n+// \n+// Here's an example directory layout:\n+// \n+//\tGOPATH=/home/user/gocode\n+// \n+//\t/home/user/gocode/\n+//\t    src/\n+//\t        foo/\n+//\t            bar/               (go code in package bar)\n+//\t                x.go\n+//\t            quux/              (go code in package main)\n+//\t                y.go\n+//\t    bin/\n+//\t        quux                   (installed command)\n+//\t    pkg/\n+//\t        linux_amd64/\n+//\t            foo/\n+//\t                bar.a          (installed package object)\n+//\n+// Build Constraints\n+//\n+// A build constraint is a line comment beginning with the directive +build\n+// that lists the conditions under which a file should be included in the package.\n+// Constraints may appear in any kind of source file (not just Go), but\n+// they must be appear near the top of the file, preceded\n+// only by blank lines and other line comments.\n+//\n+// A build constraint is evaluated as the OR of space-separated options;\n+// each option evaluates as the AND of its comma-separated terms;\n+// and each term is an alphanumeric word or, preceded by !, its negation.\n+// That is, the build constraint:\n+//\n+//\t// +build linux,386 darwin,!cgo\n+//\n+// corresponds to the boolean formula:\n+//\n+//\t(linux AND 386) OR (darwin AND (NOT cgo))\n+//\n+// During a particular build, the following words are satisfied:\n+//\n+//\t- the target operating system, as spelled by runtime.GOOS\n+//\t- the target architecture, as spelled by runtime.GOARCH\n+//\t- \"cgo\", if ctxt.CgoEnabled is true\n+//\t- any additional words listed in ctxt.BuildTags\n+//\n+// If a file's name, after stripping the extension and a possible _test suffix,\n+// matches *_GOOS, *_GOARCH, or *_GOOS_GOARCH for any known operating\n+// system and architecture values, then the file is considered to have an implicit\n+// build constraint requiring those terms.\n+//\n+// To keep a file from being considered for the build:\n+//\n+//\t// +build ignore\n+//\n+// (any other unsatisfied word will work as well, but ``ignore'' is conventional.)\n+//\n+// To build a file only when using cgo, and only on Linux and OS X:\n+//\n+//\t// +build linux,cgo darwin,cgo\n+//\n+// Such a file is usually paired with another file implementing the\n+// default functionality for other systems, which in this case would\n+// carry the constraint:\n+//\n+//\t// +build !linux !darwin !cgo\n+//\n+// Naming a file dns_windows.go will cause it to be included only when\n+// building the package for Windows; similarly, math_386.s will be included\n+// only when building the package for 32-bit x86.\n+//\n+package build"}, {"sha": "e160ac3b280bb13aad02c8605838542b1dc7c915", "filename": "libgo/go/go/build/path.go", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,182 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package build\n-\n-import (\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"runtime\"\n-)\n-\n-// ToolDir is the directory containing build tools.\n-var ToolDir = filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n-\n-// Path is a validated list of Trees derived from $GOROOT and $GOPATH at init.\n-var Path []*Tree\n-\n-// Tree describes a Go source tree, either $GOROOT or one from $GOPATH.\n-type Tree struct {\n-\tPath   string\n-\tGoroot bool\n-}\n-\n-func newTree(p string) (*Tree, error) {\n-\tif !filepath.IsAbs(p) {\n-\t\treturn nil, errors.New(\"must be absolute\")\n-\t}\n-\tep, err := filepath.EvalSymlinks(p)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn &Tree{Path: ep}, nil\n-}\n-\n-// SrcDir returns the tree's package source directory.\n-func (t *Tree) SrcDir() string {\n-\tif t.Goroot {\n-\t\treturn filepath.Join(t.Path, \"src\", \"pkg\")\n-\t}\n-\treturn filepath.Join(t.Path, \"src\")\n-}\n-\n-// PkgDir returns the tree's package object directory.\n-func (t *Tree) PkgDir() string {\n-\tgoos, goarch := runtime.GOOS, runtime.GOARCH\n-\tif e := os.Getenv(\"GOOS\"); e != \"\" {\n-\t\tgoos = e\n-\t}\n-\tif e := os.Getenv(\"GOARCH\"); e != \"\" {\n-\t\tgoarch = e\n-\t}\n-\treturn filepath.Join(t.Path, \"pkg\", goos+\"_\"+goarch)\n-}\n-\n-// BinDir returns the tree's binary executable directory.\n-func (t *Tree) BinDir() string {\n-\tif t.Goroot {\n-\t\tif gobin := os.Getenv(\"GOBIN\"); gobin != \"\" {\n-\t\t\treturn filepath.Clean(gobin)\n-\t\t}\n-\t}\n-\treturn filepath.Join(t.Path, \"bin\")\n-}\n-\n-// HasSrc returns whether the given package's\n-// source can be found inside this Tree.\n-func (t *Tree) HasSrc(pkg string) bool {\n-\tfi, err := os.Stat(filepath.Join(t.SrcDir(), pkg))\n-\tif err != nil {\n-\t\treturn false\n-\t}\n-\treturn fi.IsDir()\n-}\n-\n-// HasPkg returns whether the given package's\n-// object file can be found inside this Tree.\n-func (t *Tree) HasPkg(pkg string) bool {\n-\tfi, err := os.Stat(filepath.Join(t.PkgDir(), pkg+\".a\"))\n-\tif err != nil {\n-\t\treturn false\n-\t}\n-\treturn !fi.IsDir()\n-}\n-\n-var (\n-\tErrNotFound     = errors.New(\"package could not be found locally\")\n-\tErrTreeNotFound = errors.New(\"no valid GOROOT or GOPATH could be found\")\n-)\n-\n-// FindTree takes an import or filesystem path and returns the\n-// tree where the package source should be and the package import path.\n-func FindTree(path string) (tree *Tree, pkg string, err error) {\n-\tif isLocalPath(path) {\n-\t\tif path, err = filepath.Abs(path); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tif path, err = filepath.EvalSymlinks(path); err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tfor _, t := range Path {\n-\t\t\ttpath := t.SrcDir() + string(filepath.Separator)\n-\t\t\tif !filepath.HasPrefix(path, tpath) {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\ttree = t\n-\t\t\tpkg = filepath.ToSlash(path[len(tpath):])\n-\t\t\treturn\n-\t\t}\n-\t\terr = fmt.Errorf(\"path %q not inside a GOPATH\", path)\n-\t\treturn\n-\t}\n-\ttree = defaultTree\n-\tpkg = filepath.ToSlash(path)\n-\tfor _, t := range Path {\n-\t\tif t.HasSrc(pkg) {\n-\t\t\ttree = t\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tif tree == nil {\n-\t\terr = ErrTreeNotFound\n-\t} else {\n-\t\terr = ErrNotFound\n-\t}\n-\treturn\n-}\n-\n-// isLocalPath returns whether the given path is local (/foo ./foo ../foo . ..)\n-// Windows paths that starts with drive letter (c:\\foo c:foo) are considered local.\n-func isLocalPath(s string) bool {\n-\tconst sep = string(filepath.Separator)\n-\treturn s == \".\" || s == \"..\" ||\n-\t\tfilepath.HasPrefix(s, sep) ||\n-\t\tfilepath.HasPrefix(s, \".\"+sep) || filepath.HasPrefix(s, \"..\"+sep) ||\n-\t\tfilepath.VolumeName(s) != \"\"\n-}\n-\n-var (\n-\t// argument lists used by the build's gc and ld methods\n-\tgcImportArgs []string\n-\tldImportArgs []string\n-\n-\t// default tree for remote packages\n-\tdefaultTree *Tree\n-)\n-\n-// set up Path: parse and validate GOROOT and GOPATH variables\n-func init() {\n-\troot := runtime.GOROOT()\n-\tt, err := newTree(root)\n-\tif err == nil {\n-\t\tt.Goroot = true\n-\t\tPath = []*Tree{t}\n-\t}\n-\n-\tfor _, p := range filepath.SplitList(os.Getenv(\"GOPATH\")) {\n-\t\tif p == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tt, err := newTree(p)\n-\t\tif err != nil {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tPath = append(Path, t)\n-\t\tgcImportArgs = append(gcImportArgs, \"-I\", t.PkgDir())\n-\t\tldImportArgs = append(ldImportArgs, \"-L\", t.PkgDir())\n-\n-\t\t// select first GOPATH entry as default\n-\t\tif defaultTree == nil {\n-\t\t\tdefaultTree = t\n-\t\t}\n-\t}\n-\n-\t// use GOROOT if no valid GOPATH specified\n-\tif defaultTree == nil && len(Path) > 0 {\n-\t\tdefaultTree = Path[0]\n-\t}\n-}"}, {"sha": "08eea1e2bc37899fc1b78bcc78c777a28386669f", "filename": "libgo/go/go/build/pkgtest/pkgtest.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package pkgtest\n-\n-import \"bytes\"\n-\n-func Foo() *bytes.Buffer {\n-\treturn nil\n-}\n-\n-func Sqrt(x float64) float64"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_386_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1 +0,0 @@\n-package pkgtest"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_amd64_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1 +0,0 @@\n-package pkgtest"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_arm_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1 +0,0 @@\n-package pkgtest"}, {"sha": "ee9fd5de68862c3ed01883d9a1bd8b9a4e5c9b4b", "filename": "libgo/go/go/build/pkgtest/sqrt_test.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,9 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package pkgtest\n-\n-import \"fmt\"\n-\n-var _ = fmt.Printf"}, {"sha": "3898d1dda590fb318e775bc2b39aeeb4487ba47b", "filename": "libgo/go/go/build/pkgtest/xsqrt_test.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46402cbe0ba3ea92be9642cf18eedaefe57a414c/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go?ref=46402cbe0ba3ea92be9642cf18eedaefe57a414c", "patch": "@@ -1,9 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package pkgtest_test\n-\n-import \"pkgtest\"\n-\n-var _ = pkgtest.Foo"}, {"sha": "9157faf8cb94ff36308589456939b4ea4394ae41", "filename": "libgo/go/go/build/syslist_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -55,7 +55,7 @@ var tests = []GoodFileTest{\n \n func TestGoodOSArch(t *testing.T) {\n \tfor _, test := range tests {\n-\t\tif DefaultContext.goodOSArchFile(test.name) != test.result {\n+\t\tif Default.goodOSArchFile(test.name) != test.result {\n \t\t\tt.Fatalf(\"goodOSArchFile(%q) != %v\", test.name, test.result)\n \t\t}\n \t}"}, {"sha": "bbfd3e9e59887325b173a8ac1ecb9a89ce8a0d9d", "filename": "libgo/go/go/build/testdata/other/file/file.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Ffile%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Ffile%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Ffile%2Ffile.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,5 @@\n+// Test data - not compiled.\n+\n+package file\n+\n+func F() {}"}, {"sha": "e0904357c926d1ed8cc2c8892d33c0ccddf7fcff", "filename": "libgo/go/go/build/testdata/other/main.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Ftestdata%2Fother%2Fmain.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,11 @@\n+// Test data - not compiled.\n+\n+package main\n+\n+import (\n+\t\"./file\"\n+)\n+\n+func main() {\n+\tfile.F()\n+}"}, {"sha": "5eaae37b7decdf0b9c21197561f4a31e538e7e07", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -432,15 +432,31 @@ func (r *reader) readFile(src *ast.File) {\n \t\t\t\tr.readValue(d)\n \t\t\tcase token.TYPE:\n \t\t\t\t// types are handled individually\n+\t\t\t\tif len(d.Specs) == 1 && !d.Lparen.IsValid() {\n+\t\t\t\t\t// common case: single declaration w/o parentheses\n+\t\t\t\t\t// (if a single declaration is parenthesized,\n+\t\t\t\t\t// create a new fake declaration below, so that\n+\t\t\t\t\t// go/doc type declarations always appear w/o\n+\t\t\t\t\t// parentheses)\n+\t\t\t\t\tif s, ok := d.Specs[0].(*ast.TypeSpec); ok {\n+\t\t\t\t\t\tr.readType(d, s)\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t\tfor _, spec := range d.Specs {\n \t\t\t\t\tif s, ok := spec.(*ast.TypeSpec); ok {\n \t\t\t\t\t\t// use an individual (possibly fake) declaration\n \t\t\t\t\t\t// for each type; this also ensures that each type\n \t\t\t\t\t\t// gets to (re-)use the declaration documentation\n \t\t\t\t\t\t// if there's none associated with the spec itself\n \t\t\t\t\t\tfake := &ast.GenDecl{\n-\t\t\t\t\t\t\tDoc:    d.Doc,\n-\t\t\t\t\t\t\tTokPos: d.Pos(),\n+\t\t\t\t\t\t\tDoc: d.Doc,\n+\t\t\t\t\t\t\t// don't use the existing TokPos because it\n+\t\t\t\t\t\t\t// will lead to the wrong selection range for\n+\t\t\t\t\t\t\t// the fake declaration if there are more\n+\t\t\t\t\t\t\t// than one type in the group (this affects\n+\t\t\t\t\t\t\t// src/cmd/godoc/godoc.go's posLink_urlFunc)\n+\t\t\t\t\t\t\tTokPos: s.Pos(),\n \t\t\t\t\t\t\tTok:    token.TYPE,\n \t\t\t\t\t\t\tSpecs:  []ast.Spec{s},\n \t\t\t\t\t\t}"}, {"sha": "a122baf087997afc8d7b2306d09b0d1491f403dc", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -14,6 +14,9 @@ import (\n \t\"go/ast\"\n \t\"go/scanner\"\n \t\"go/token\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"unicode\"\n )\n \n // The parser structure holds the parser's internal state.\n@@ -1913,6 +1916,17 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n \n type parseSpecFunction func(p *parser, doc *ast.CommentGroup, iota int) ast.Spec\n \n+func isValidImport(lit string) bool {\n+\tconst illegalChars = `!\"#$%&'()*,:;<=>?[\\]^{|}` + \"`\\uFFFD\"\n+\ts, _ := strconv.Unquote(lit) // go/scanner returns a legal string literal\n+\tfor _, r := range s {\n+\t\tif !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn s != \"\"\n+}\n+\n func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ImportSpec\"))\n@@ -1929,6 +1943,9 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \n \tvar path *ast.BasicLit\n \tif p.tok == token.STRING {\n+\t\tif !isValidImport(p.lit) {\n+\t\t\tp.error(p.pos, \"invalid import path: \"+p.lit)\n+\t\t}\n \t\tpath = &ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}\n \t\tp.next()\n \t} else {"}, {"sha": "93ca3d6aa39e96645c61821fd5a43853ce4404bd", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,6 +5,7 @@\n package parser\n \n import (\n+\t\"fmt\"\n \t\"go/ast\"\n \t\"go/token\"\n \t\"os\"\n@@ -204,3 +205,48 @@ func TestVarScope(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var imports = map[string]bool{\n+\t`\"a\"`:        true,\n+\t\"`a`\":        true,\n+\t`\"a/b\"`:      true,\n+\t`\"a.b\"`:      true,\n+\t`\"m\\x61th\"`:  true,\n+\t`\"greek/\u03b1\u03b2\"`: true,\n+\t`\"\"`:         false,\n+\n+\t// Each of these pairs tests both `` vs \"\" strings\n+\t// and also use of invalid characters spelled out as\n+\t// escape sequences and written directly.\n+\t// For example `\"\\x00\"` tests import \"\\x00\"\n+\t// while \"`\\x00`\" tests import `<actual-NUL-byte>`.\n+\t`\"\\x00\"`:     false,\n+\t\"`\\x00`\":     false,\n+\t`\"\\x7f\"`:     false,\n+\t\"`\\x7f`\":     false,\n+\t`\"a!\"`:       false,\n+\t\"`a!`\":       false,\n+\t`\"a b\"`:      false,\n+\t\"`a b`\":      false,\n+\t`\"a\\\\b\"`:     false,\n+\t\"`a\\\\b`\":     false,\n+\t\"\\\"`a`\\\"\":    false,\n+\t\"`\\\"a\\\"`\":    false,\n+\t`\"\\x80\\x80\"`: false,\n+\t\"`\\x80\\x80`\": false,\n+\t`\"\\xFFFD\"`:   false,\n+\t\"`\\xFFFD`\":   false,\n+}\n+\n+func TestImports(t *testing.T) {\n+\tfor path, isValid := range imports {\n+\t\tsrc := fmt.Sprintf(\"package p; import %s\", path)\n+\t\t_, err := ParseFile(fset, \"\", src, 0)\n+\t\tswitch {\n+\t\tcase err != nil && isValid:\n+\t\t\tt.Errorf(\"ParseFile(%s): got %v; expected no error\", src, err)\n+\t\tcase err == nil && !isValid:\n+\t\t\tt.Errorf(\"ParseFile(%s): got no error; expected one\", src)\n+\t\t}\n+\t}\n+}"}, {"sha": "05b4ef59a2dc1957e1cf797e7e0a35764cb65651", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 163, "deletions": 198, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"bytes\"\n \t\"go/ast\"\n \t\"go/token\"\n+\t\"unicode/utf8\"\n )\n \n // Other formatting issues:\n@@ -82,46 +83,37 @@ func (p *printer) setComment(g *ast.CommentGroup) {\n type exprListMode uint\n \n const (\n-\tblankStart exprListMode = 1 << iota // print a blank before a non-empty list\n-\tblankEnd                            // print a blank after a non-empty list\n-\tcommaSep                            // elements are separated by commas\n-\tcommaTerm                           // list is optionally terminated by a comma\n-\tnoIndent                            // no extra indentation in multi-line lists\n+\tcommaTerm exprListMode = 1 << iota // list is optionally terminated by a comma\n+\tnoIndent                           // no extra indentation in multi-line lists\n )\n \n-// Sets multiLine to true if the identifier list spans multiple lines.\n // If indent is set, a multi-line identifier list is indented after the\n // first linebreak encountered.\n-func (p *printer) identList(list []*ast.Ident, indent bool, multiLine *bool) {\n+func (p *printer) identList(list []*ast.Ident, indent bool) {\n \t// convert into an expression list so we can re-use exprList formatting\n \txlist := make([]ast.Expr, len(list))\n \tfor i, x := range list {\n \t\txlist[i] = x\n \t}\n-\tmode := commaSep\n+\tvar mode exprListMode\n \tif !indent {\n-\t\tmode |= noIndent\n+\t\tmode = noIndent\n \t}\n-\tp.exprList(token.NoPos, xlist, 1, mode, multiLine, token.NoPos)\n+\tp.exprList(token.NoPos, xlist, 1, mode, token.NoPos)\n }\n \n // Print a list of expressions. If the list spans multiple\n // source lines, the original line breaks are respected between\n-// expressions. Sets multiLine to true if the list spans multiple\n-// lines.\n+// expressions.\n //\n // TODO(gri) Consider rewriting this to be independent of []ast.Expr\n //           so that we can use the algorithm for any kind of list\n //           (e.g., pass list via a channel over which to range).\n-func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exprListMode, multiLine *bool, next0 token.Pos) {\n+func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exprListMode, next0 token.Pos) {\n \tif len(list) == 0 {\n \t\treturn\n \t}\n \n-\tif mode&blankStart != 0 {\n-\t\tp.print(blank)\n-\t}\n-\n \tprev := p.posFor(prev0)\n \tnext := p.posFor(next0)\n \tline := p.lineFor(list[0].Pos())\n@@ -131,17 +123,11 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t// all list entries on a single line\n \t\tfor i, x := range list {\n \t\t\tif i > 0 {\n-\t\t\t\tif mode&commaSep != 0 {\n-\t\t\t\t\t// use position of expression following the comma as\n-\t\t\t\t\t// comma position for correct comment placement\n-\t\t\t\t\tp.print(x.Pos(), token.COMMA)\n-\t\t\t\t}\n-\t\t\t\tp.print(blank)\n+\t\t\t\t// use position of expression following the comma as\n+\t\t\t\t// comma position for correct comment placement\n+\t\t\t\tp.print(x.Pos(), token.COMMA, blank)\n \t\t\t}\n-\t\t\tp.expr0(x, depth, multiLine)\n-\t\t}\n-\t\tif mode&blankEnd != 0 {\n-\t\t\tp.print(blank)\n+\t\t\tp.expr0(x, depth)\n \t\t}\n \t\treturn\n \t}\n@@ -161,7 +147,6 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \tprevBreak := -1 // index of last expression that was followed by a linebreak\n \tif prev.IsValid() && prev.Line < line && p.linebreak(line, 0, ws, true) {\n \t\tws = ignore\n-\t\t*multiLine = true\n \t\tprevBreak = 0\n \t}\n \n@@ -215,23 +200,20 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \n \t\tif i > 0 {\n \t\t\tneedsLinebreak := prevLine < line && prevLine > 0 && line > 0\n-\t\t\tif mode&commaSep != 0 {\n-\t\t\t\t// use position of expression following the comma as\n-\t\t\t\t// comma position for correct comment placement, but\n-\t\t\t\t// only if the expression is on the same line\n-\t\t\t\tif !needsLinebreak {\n-\t\t\t\t\tp.print(x.Pos())\n-\t\t\t\t}\n-\t\t\t\tp.print(token.COMMA)\n+\t\t\t// use position of expression following the comma as\n+\t\t\t// comma position for correct comment placement, but\n+\t\t\t// only if the expression is on the same line\n+\t\t\tif !needsLinebreak {\n+\t\t\t\tp.print(x.Pos())\n \t\t\t}\n+\t\t\tp.print(token.COMMA)\n \t\t\tneedsBlank := true\n \t\t\tif needsLinebreak {\n \t\t\t\t// lines are broken using newlines so comments remain aligned\n \t\t\t\t// unless forceFF is set or there are multiple expressions on\n \t\t\t\t// the same line in which case formfeed is used\n \t\t\t\tif p.linebreak(line, 0, ws, useFF || prevBreak+1 < i) {\n \t\t\t\t\tws = ignore\n-\t\t\t\t\t*multiLine = true\n \t\t\t\t\tprevBreak = i\n \t\t\t\t\tneedsBlank = false // we got a line break instead\n \t\t\t\t}\n@@ -245,11 +227,11 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t\t// we have a key:value expression that fits onto one line and\n \t\t\t// is in a list with more then one entry: use a column for the\n \t\t\t// key such that consecutive entries can align if possible\n-\t\t\tp.expr(pair.Key, multiLine)\n+\t\t\tp.expr(pair.Key)\n \t\t\tp.print(pair.Colon, token.COLON, vtab)\n-\t\t\tp.expr(pair.Value, multiLine)\n+\t\t\tp.expr(pair.Value)\n \t\t} else {\n-\t\t\tp.expr0(x, depth, multiLine)\n+\t\t\tp.expr0(x, depth)\n \t\t}\n \t}\n \n@@ -264,18 +246,13 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\treturn\n \t}\n \n-\tif mode&blankEnd != 0 {\n-\t\tp.print(blank)\n-\t}\n-\n \tif ws == ignore && mode&noIndent == 0 {\n \t\t// unindent if we indented\n \t\tp.print(unindent)\n \t}\n }\n \n-// Sets multiLine to true if the the parameter list spans multiple lines.\n-func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n+func (p *printer) parameters(fields *ast.FieldList) {\n \tp.print(fields.Opening, token.LPAREN)\n \tif len(fields.List) > 0 {\n \t\tprevLine := p.lineFor(fields.Opening)\n@@ -306,7 +283,6 @@ func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n \t\t\tif needsLinebreak && p.linebreak(parLineBeg, 0, ws, true) {\n \t\t\t\t// break line if the opening \"(\" or previous parameter ended on a different line\n \t\t\t\tws = ignore\n-\t\t\t\t*multiLine = true\n \t\t\t} else if i > 0 {\n \t\t\t\tp.print(blank)\n \t\t\t}\n@@ -318,11 +294,11 @@ func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n \t\t\t\t// again at the end (and still ws == indent). Thus, a subsequent indent\n \t\t\t\t// by a linebreak call after a type, or in the next multi-line identList\n \t\t\t\t// will do the right thing.\n-\t\t\t\tp.identList(par.Names, ws == indent, multiLine)\n+\t\t\t\tp.identList(par.Names, ws == indent)\n \t\t\t\tp.print(blank)\n \t\t\t}\n \t\t\t// parameter type\n-\t\t\tp.expr(par.Type, multiLine)\n+\t\t\tp.expr(par.Type)\n \t\t\tprevLine = parLineEnd\n \t\t}\n \t\t// if the closing \")\" is on a separate line from the last parameter,\n@@ -339,27 +315,26 @@ func (p *printer) parameters(fields *ast.FieldList, multiLine *bool) {\n \tp.print(fields.Closing, token.RPAREN)\n }\n \n-// Sets multiLine to true if the signature spans multiple lines.\n-func (p *printer) signature(params, result *ast.FieldList, multiLine *bool) {\n-\tp.parameters(params, multiLine)\n+func (p *printer) signature(params, result *ast.FieldList) {\n+\tp.parameters(params)\n \tn := result.NumFields()\n \tif n > 0 {\n \t\tp.print(blank)\n \t\tif n == 1 && result.List[0].Names == nil {\n \t\t\t// single anonymous result; no ()'s\n-\t\t\tp.expr(result.List[0].Type, multiLine)\n+\t\t\tp.expr(result.List[0].Type)\n \t\t\treturn\n \t\t}\n-\t\tp.parameters(result, multiLine)\n+\t\tp.parameters(result)\n \t}\n }\n \n func identListSize(list []*ast.Ident, maxSize int) (size int) {\n \tfor i, x := range list {\n \t\tif i > 0 {\n-\t\t\tsize += 2 // \", \"\n+\t\t\tsize += len(\", \")\n \t\t}\n-\t\tsize += len(x.Name)\n+\t\tsize += utf8.RuneCountInString(x.Name)\n \t\tif size >= maxSize {\n \t\t\tbreak\n \t\t}\n@@ -389,6 +364,10 @@ func (p *printer) setLineComment(text string) {\n \tp.setComment(&ast.CommentGroup{List: []*ast.Comment{{Slash: token.NoPos, Text: text}}})\n }\n \n+func (p *printer) isMultiLine(n ast.Node) bool {\n+\treturn p.lineFor(n.End())-p.lineFor(n.Pos()) > 1\n+}\n+\n func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool) {\n \tlbrace := fields.Opening\n \tlist := fields.List\n@@ -412,12 +391,12 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \t\t\t\t\t// no comments so no need for comma position\n \t\t\t\t\tp.print(token.COMMA, blank)\n \t\t\t\t}\n-\t\t\t\tp.expr(x, ignoreMultiLine)\n+\t\t\t\tp.expr(x)\n \t\t\t}\n \t\t\tif len(f.Names) > 0 {\n \t\t\t\tp.print(blank)\n \t\t\t}\n-\t\t\tp.expr(f.Type, ignoreMultiLine)\n+\t\t\tp.expr(f.Type)\n \t\t\tp.print(blank, rbrace, token.RBRACE)\n \t\t\treturn\n \t\t}\n@@ -435,31 +414,30 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \t\tif len(list) == 1 {\n \t\t\tsep = blank\n \t\t}\n-\t\tvar ml bool\n+\t\tnewSection := false\n \t\tfor i, f := range list {\n \t\t\tif i > 0 {\n-\t\t\t\tp.linebreak(p.lineFor(f.Pos()), 1, ignore, ml)\n+\t\t\t\tp.linebreak(p.lineFor(f.Pos()), 1, ignore, newSection)\n \t\t\t}\n-\t\t\tml = false\n \t\t\textraTabs := 0\n \t\t\tp.setComment(f.Doc)\n \t\t\tif len(f.Names) > 0 {\n \t\t\t\t// named fields\n-\t\t\t\tp.identList(f.Names, false, &ml)\n+\t\t\t\tp.identList(f.Names, false)\n \t\t\t\tp.print(sep)\n-\t\t\t\tp.expr(f.Type, &ml)\n+\t\t\t\tp.expr(f.Type)\n \t\t\t\textraTabs = 1\n \t\t\t} else {\n \t\t\t\t// anonymous field\n-\t\t\t\tp.expr(f.Type, &ml)\n+\t\t\t\tp.expr(f.Type)\n \t\t\t\textraTabs = 2\n \t\t\t}\n \t\t\tif f.Tag != nil {\n \t\t\t\tif len(f.Names) > 0 && sep == vtab {\n \t\t\t\t\tp.print(sep)\n \t\t\t\t}\n \t\t\t\tp.print(sep)\n-\t\t\t\tp.expr(f.Tag, &ml)\n+\t\t\t\tp.expr(f.Tag)\n \t\t\t\textraTabs = 0\n \t\t\t}\n \t\t\tif f.Comment != nil {\n@@ -468,6 +446,7 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \t\t\t\t}\n \t\t\t\tp.setComment(f.Comment)\n \t\t\t}\n+\t\t\tnewSection = p.isMultiLine(f)\n \t\t}\n \t\tif isIncomplete {\n \t\t\tif len(list) > 0 {\n@@ -479,22 +458,22 @@ func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool)\n \n \t} else { // interface\n \n-\t\tvar ml bool\n+\t\tnewSection := false\n \t\tfor i, f := range list {\n \t\t\tif i > 0 {\n-\t\t\t\tp.linebreak(p.lineFor(f.Pos()), 1, ignore, ml)\n+\t\t\t\tp.linebreak(p.lineFor(f.Pos()), 1, ignore, newSection)\n \t\t\t}\n-\t\t\tml = false\n \t\t\tp.setComment(f.Doc)\n \t\t\tif ftyp, isFtyp := f.Type.(*ast.FuncType); isFtyp {\n \t\t\t\t// method\n-\t\t\t\tp.expr(f.Names[0], &ml)\n-\t\t\t\tp.signature(ftyp.Params, ftyp.Results, &ml)\n+\t\t\t\tp.expr(f.Names[0])\n+\t\t\t\tp.signature(ftyp.Params, ftyp.Results)\n \t\t\t} else {\n \t\t\t\t// embedded interface\n-\t\t\t\tp.expr(f.Type, &ml)\n+\t\t\t\tp.expr(f.Type)\n \t\t\t}\n \t\t\tp.setComment(f.Comment)\n+\t\t\tnewSection = p.isMultiLine(f)\n \t\t}\n \t\tif isIncomplete {\n \t\t\tif len(list) > 0 {\n@@ -635,23 +614,22 @@ func reduceDepth(depth int) int {\n //\t   cutoff is 6 (always use spaces) in Normal mode\n //\t   and 4 (never use spaces) in Compact mode.\n //\n-// Sets multiLine to true if the binary expression spans multiple lines.\n-func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiLine *bool) {\n+func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int) {\n \tprec := x.Op.Precedence()\n \tif prec < prec1 {\n \t\t// parenthesis needed\n \t\t// Note: The parser inserts an ast.ParenExpr node; thus this case\n \t\t//       can only occur if the AST is created in a different way.\n \t\tp.print(token.LPAREN)\n-\t\tp.expr0(x, reduceDepth(depth), multiLine) // parentheses undo one level of depth\n+\t\tp.expr0(x, reduceDepth(depth)) // parentheses undo one level of depth\n \t\tp.print(token.RPAREN)\n \t\treturn\n \t}\n \n \tprintBlank := prec < cutoff\n \n \tws := indent\n-\tp.expr1(x.X, prec, depth+diffPrec(x.X, prec), multiLine)\n+\tp.expr1(x.X, prec, depth+diffPrec(x.X, prec))\n \tif printBlank {\n \t\tp.print(blank)\n \t}\n@@ -663,14 +641,13 @@ func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiL\n \t\t// in the source\n \t\tif p.linebreak(yline, 1, ws, true) {\n \t\t\tws = ignore\n-\t\t\t*multiLine = true\n \t\t\tprintBlank = false // no blank after line break\n \t\t}\n \t}\n \tif printBlank {\n \t\tp.print(blank)\n \t}\n-\tp.expr1(x.Y, prec+1, depth+1, multiLine)\n+\tp.expr1(x.Y, prec+1, depth+1)\n \tif ws == ignore {\n \t\tp.print(unindent)\n \t}\n@@ -681,8 +658,7 @@ func isBinary(expr ast.Expr) bool {\n \treturn ok\n }\n \n-// Sets multiLine to true if the expression spans multiple lines.\n-func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n+func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \tp.print(expr.Pos())\n \n \tswitch x := expr.(type) {\n@@ -697,33 +673,33 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \t\t\tp.internalError(\"depth < 1:\", depth)\n \t\t\tdepth = 1\n \t\t}\n-\t\tp.binaryExpr(x, prec1, cutoff(x, depth), depth, multiLine)\n+\t\tp.binaryExpr(x, prec1, cutoff(x, depth), depth)\n \n \tcase *ast.KeyValueExpr:\n-\t\tp.expr(x.Key, multiLine)\n+\t\tp.expr(x.Key)\n \t\tp.print(x.Colon, token.COLON, blank)\n-\t\tp.expr(x.Value, multiLine)\n+\t\tp.expr(x.Value)\n \n \tcase *ast.StarExpr:\n \t\tconst prec = token.UnaryPrec\n \t\tif prec < prec1 {\n \t\t\t// parenthesis needed\n \t\t\tp.print(token.LPAREN)\n \t\t\tp.print(token.MUL)\n-\t\t\tp.expr(x.X, multiLine)\n+\t\t\tp.expr(x.X)\n \t\t\tp.print(token.RPAREN)\n \t\t} else {\n \t\t\t// no parenthesis needed\n \t\t\tp.print(token.MUL)\n-\t\t\tp.expr(x.X, multiLine)\n+\t\t\tp.expr(x.X)\n \t\t}\n \n \tcase *ast.UnaryExpr:\n \t\tconst prec = token.UnaryPrec\n \t\tif prec < prec1 {\n \t\t\t// parenthesis needed\n \t\t\tp.print(token.LPAREN)\n-\t\t\tp.expr(x, multiLine)\n+\t\t\tp.expr(x)\n \t\t\tp.print(token.RPAREN)\n \t\t} else {\n \t\t\t// no parenthesis needed\n@@ -732,60 +708,59 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \t\t\t\t// TODO(gri) Remove this code if it cannot be reached.\n \t\t\t\tp.print(blank)\n \t\t\t}\n-\t\t\tp.expr1(x.X, prec, depth, multiLine)\n+\t\t\tp.expr1(x.X, prec, depth)\n \t\t}\n \n \tcase *ast.BasicLit:\n \t\tp.print(x)\n \n \tcase *ast.FuncLit:\n-\t\tp.expr(x.Type, multiLine)\n-\t\tp.funcBody(x.Body, p.distance(x.Type.Pos(), p.pos), true, multiLine)\n+\t\tp.expr(x.Type)\n+\t\tp.funcBody(x.Body, p.distance(x.Type.Pos(), p.pos), true)\n \n \tcase *ast.ParenExpr:\n \t\tif _, hasParens := x.X.(*ast.ParenExpr); hasParens {\n \t\t\t// don't print parentheses around an already parenthesized expression\n \t\t\t// TODO(gri) consider making this more general and incorporate precedence levels\n-\t\t\tp.expr0(x.X, reduceDepth(depth), multiLine) // parentheses undo one level of depth\n+\t\t\tp.expr0(x.X, reduceDepth(depth)) // parentheses undo one level of depth\n \t\t} else {\n \t\t\tp.print(token.LPAREN)\n-\t\t\tp.expr0(x.X, reduceDepth(depth), multiLine) // parentheses undo one level of depth\n+\t\t\tp.expr0(x.X, reduceDepth(depth)) // parentheses undo one level of depth\n \t\t\tp.print(x.Rparen, token.RPAREN)\n \t\t}\n \n \tcase *ast.SelectorExpr:\n-\t\tp.expr1(x.X, token.HighestPrec, depth, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, depth)\n \t\tp.print(token.PERIOD)\n \t\tif line := p.lineFor(x.Sel.Pos()); p.pos.IsValid() && p.pos.Line < line {\n \t\t\tp.print(indent, newline, x.Sel.Pos(), x.Sel, unindent)\n-\t\t\t*multiLine = true\n \t\t} else {\n \t\t\tp.print(x.Sel.Pos(), x.Sel)\n \t\t}\n \n \tcase *ast.TypeAssertExpr:\n-\t\tp.expr1(x.X, token.HighestPrec, depth, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, depth)\n \t\tp.print(token.PERIOD, token.LPAREN)\n \t\tif x.Type != nil {\n-\t\t\tp.expr(x.Type, multiLine)\n+\t\t\tp.expr(x.Type)\n \t\t} else {\n \t\t\tp.print(token.TYPE)\n \t\t}\n \t\tp.print(token.RPAREN)\n \n \tcase *ast.IndexExpr:\n \t\t// TODO(gri): should treat[] like parentheses and undo one level of depth\n-\t\tp.expr1(x.X, token.HighestPrec, 1, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, 1)\n \t\tp.print(x.Lbrack, token.LBRACK)\n-\t\tp.expr0(x.Index, depth+1, multiLine)\n+\t\tp.expr0(x.Index, depth+1)\n \t\tp.print(x.Rbrack, token.RBRACK)\n \n \tcase *ast.SliceExpr:\n \t\t// TODO(gri): should treat[] like parentheses and undo one level of depth\n-\t\tp.expr1(x.X, token.HighestPrec, 1, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, 1)\n \t\tp.print(x.Lbrack, token.LBRACK)\n \t\tif x.Low != nil {\n-\t\t\tp.expr0(x.Low, depth+1, multiLine)\n+\t\t\tp.expr0(x.Low, depth+1)\n \t\t}\n \t\t// blanks around \":\" if both sides exist and either side is a binary expression\n \t\tif depth <= 1 && x.Low != nil && x.High != nil && (isBinary(x.Low) || isBinary(x.High)) {\n@@ -794,29 +769,34 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \t\t\tp.print(token.COLON)\n \t\t}\n \t\tif x.High != nil {\n-\t\t\tp.expr0(x.High, depth+1, multiLine)\n+\t\t\tp.expr0(x.High, depth+1)\n \t\t}\n \t\tp.print(x.Rbrack, token.RBRACK)\n \n \tcase *ast.CallExpr:\n \t\tif len(x.Args) > 1 {\n \t\t\tdepth++\n \t\t}\n-\t\tp.expr1(x.Fun, token.HighestPrec, depth, multiLine)\n+\t\tp.expr1(x.Fun, token.HighestPrec, depth)\n \t\tp.print(x.Lparen, token.LPAREN)\n-\t\tp.exprList(x.Lparen, x.Args, depth, commaSep|commaTerm, multiLine, x.Rparen)\n \t\tif x.Ellipsis.IsValid() {\n+\t\t\tp.exprList(x.Lparen, x.Args, depth, 0, x.Ellipsis)\n \t\t\tp.print(x.Ellipsis, token.ELLIPSIS)\n+\t\t\tif x.Rparen.IsValid() && p.lineFor(x.Ellipsis) < p.lineFor(x.Rparen) {\n+\t\t\t\tp.print(token.COMMA, formfeed)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tp.exprList(x.Lparen, x.Args, depth, commaTerm, x.Rparen)\n \t\t}\n \t\tp.print(x.Rparen, token.RPAREN)\n \n \tcase *ast.CompositeLit:\n \t\t// composite literal elements that are composite literals themselves may have the type omitted\n \t\tif x.Type != nil {\n-\t\t\tp.expr1(x.Type, token.HighestPrec, depth, multiLine)\n+\t\t\tp.expr1(x.Type, token.HighestPrec, depth)\n \t\t}\n \t\tp.print(x.Lbrace, token.LBRACE)\n-\t\tp.exprList(x.Lbrace, x.Elts, 1, commaSep|commaTerm, multiLine, x.Rbrace)\n+\t\tp.exprList(x.Lbrace, x.Elts, 1, commaTerm, x.Rbrace)\n \t\t// do not insert extra line breaks because of comments before\n \t\t// the closing '}' as it might break the code if there is no\n \t\t// trailing ','\n@@ -825,34 +805,34 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \tcase *ast.Ellipsis:\n \t\tp.print(token.ELLIPSIS)\n \t\tif x.Elt != nil {\n-\t\t\tp.expr(x.Elt, multiLine)\n+\t\t\tp.expr(x.Elt)\n \t\t}\n \n \tcase *ast.ArrayType:\n \t\tp.print(token.LBRACK)\n \t\tif x.Len != nil {\n-\t\t\tp.expr(x.Len, multiLine)\n+\t\t\tp.expr(x.Len)\n \t\t}\n \t\tp.print(token.RBRACK)\n-\t\tp.expr(x.Elt, multiLine)\n+\t\tp.expr(x.Elt)\n \n \tcase *ast.StructType:\n \t\tp.print(token.STRUCT)\n \t\tp.fieldList(x.Fields, true, x.Incomplete)\n \n \tcase *ast.FuncType:\n \t\tp.print(token.FUNC)\n-\t\tp.signature(x.Params, x.Results, multiLine)\n+\t\tp.signature(x.Params, x.Results)\n \n \tcase *ast.InterfaceType:\n \t\tp.print(token.INTERFACE)\n \t\tp.fieldList(x.Methods, false, x.Incomplete)\n \n \tcase *ast.MapType:\n \t\tp.print(token.MAP, token.LBRACK)\n-\t\tp.expr(x.Key, multiLine)\n+\t\tp.expr(x.Key)\n \t\tp.print(token.RBRACK)\n-\t\tp.expr(x.Value, multiLine)\n+\t\tp.expr(x.Value)\n \n \tcase *ast.ChanType:\n \t\tswitch x.Dir {\n@@ -864,7 +844,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \t\t\tp.print(token.CHAN, token.ARROW)\n \t\t}\n \t\tp.print(blank)\n-\t\tp.expr(x.Value, multiLine)\n+\t\tp.expr(x.Value)\n \n \tdefault:\n \t\tpanic(\"unreachable\")\n@@ -873,14 +853,13 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \treturn\n }\n \n-func (p *printer) expr0(x ast.Expr, depth int, multiLine *bool) {\n-\tp.expr1(x, token.LowestPrec, depth, multiLine)\n+func (p *printer) expr0(x ast.Expr, depth int) {\n+\tp.expr1(x, token.LowestPrec, depth)\n }\n \n-// Sets multiLine to true if the expression spans multiple lines.\n-func (p *printer) expr(x ast.Expr, multiLine *bool) {\n+func (p *printer) expr(x ast.Expr) {\n \tconst depth = 1\n-\tp.expr1(x, token.LowestPrec, depth, multiLine)\n+\tp.expr1(x, token.LowestPrec, depth)\n }\n \n // ----------------------------------------------------------------------------\n@@ -894,13 +873,13 @@ func (p *printer) stmtList(list []ast.Stmt, _indent int, nextIsRBrace bool) {\n \tif _indent > 0 {\n \t\tp.print(indent)\n \t}\n-\tvar multiLine bool\n+\tmultiLine := false\n \tfor i, s := range list {\n \t\t// _indent == 0 only for lists of switch/select case clauses;\n \t\t// in those cases each clause is a new section\n \t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, i == 0 || _indent == 0 || multiLine)\n-\t\tmultiLine = false\n-\t\tp.stmt(s, nextIsRBrace && i == len(list)-1, &multiLine)\n+\t\tp.stmt(s, nextIsRBrace && i == len(list)-1)\n+\t\tmultiLine = p.isMultiLine(s)\n \t}\n \tif _indent > 0 {\n \t\tp.print(unindent)\n@@ -957,25 +936,25 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po\n \tif init == nil && post == nil {\n \t\t// no semicolons required\n \t\tif expr != nil {\n-\t\t\tp.expr(stripParens(expr), ignoreMultiLine)\n+\t\t\tp.expr(stripParens(expr))\n \t\t\tneedsBlank = true\n \t\t}\n \t} else {\n \t\t// all semicolons required\n \t\t// (they are not separators, print them explicitly)\n \t\tif init != nil {\n-\t\t\tp.stmt(init, false, ignoreMultiLine)\n+\t\t\tp.stmt(init, false)\n \t\t}\n \t\tp.print(token.SEMICOLON, blank)\n \t\tif expr != nil {\n-\t\t\tp.expr(stripParens(expr), ignoreMultiLine)\n+\t\t\tp.expr(stripParens(expr))\n \t\t\tneedsBlank = true\n \t\t}\n \t\tif isForStmt {\n \t\t\tp.print(token.SEMICOLON, blank)\n \t\t\tneedsBlank = false\n \t\t\tif post != nil {\n-\t\t\t\tp.stmt(post, false, ignoreMultiLine)\n+\t\t\t\tp.stmt(post, false)\n \t\t\t\tneedsBlank = true\n \t\t\t}\n \t\t}\n@@ -985,16 +964,15 @@ func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, po\n \t}\n }\n \n-// Sets multiLine to true if the statements spans multiple lines.\n-func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n+func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool) {\n \tp.print(stmt.Pos())\n \n \tswitch s := stmt.(type) {\n \tcase *ast.BadStmt:\n \t\tp.print(\"BadStmt\")\n \n \tcase *ast.DeclStmt:\n-\t\tp.decl(s.Decl, multiLine)\n+\t\tp.decl(s.Decl)\n \n \tcase *ast.EmptyStmt:\n \t\t// nothing to do\n@@ -1004,7 +982,7 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\t// is applied before the line break if there is no comment\n \t\t// between (see writeWhitespace)\n \t\tp.print(unindent)\n-\t\tp.expr(s.Label, multiLine)\n+\t\tp.expr(s.Label)\n \t\tp.print(s.Colon, token.COLON, indent)\n \t\tif e, isEmpty := s.Stmt.(*ast.EmptyStmt); isEmpty {\n \t\t\tif !nextIsRBrace {\n@@ -1014,78 +992,77 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\t} else {\n \t\t\tp.linebreak(p.lineFor(s.Stmt.Pos()), 1, ignore, true)\n \t\t}\n-\t\tp.stmt(s.Stmt, nextIsRBrace, multiLine)\n+\t\tp.stmt(s.Stmt, nextIsRBrace)\n \n \tcase *ast.ExprStmt:\n \t\tconst depth = 1\n-\t\tp.expr0(s.X, depth, multiLine)\n+\t\tp.expr0(s.X, depth)\n \n \tcase *ast.SendStmt:\n \t\tconst depth = 1\n-\t\tp.expr0(s.Chan, depth, multiLine)\n+\t\tp.expr0(s.Chan, depth)\n \t\tp.print(blank, s.Arrow, token.ARROW, blank)\n-\t\tp.expr0(s.Value, depth, multiLine)\n+\t\tp.expr0(s.Value, depth)\n \n \tcase *ast.IncDecStmt:\n \t\tconst depth = 1\n-\t\tp.expr0(s.X, depth+1, multiLine)\n+\t\tp.expr0(s.X, depth+1)\n \t\tp.print(s.TokPos, s.Tok)\n \n \tcase *ast.AssignStmt:\n \t\tvar depth = 1\n \t\tif len(s.Lhs) > 1 && len(s.Rhs) > 1 {\n \t\t\tdepth++\n \t\t}\n-\t\tp.exprList(s.Pos(), s.Lhs, depth, commaSep, multiLine, s.TokPos)\n-\t\tp.print(blank, s.TokPos, s.Tok)\n-\t\tp.exprList(s.TokPos, s.Rhs, depth, blankStart|commaSep, multiLine, token.NoPos)\n+\t\tp.exprList(s.Pos(), s.Lhs, depth, 0, s.TokPos)\n+\t\tp.print(blank, s.TokPos, s.Tok, blank)\n+\t\tp.exprList(s.TokPos, s.Rhs, depth, 0, token.NoPos)\n \n \tcase *ast.GoStmt:\n \t\tp.print(token.GO, blank)\n-\t\tp.expr(s.Call, multiLine)\n+\t\tp.expr(s.Call)\n \n \tcase *ast.DeferStmt:\n \t\tp.print(token.DEFER, blank)\n-\t\tp.expr(s.Call, multiLine)\n+\t\tp.expr(s.Call)\n \n \tcase *ast.ReturnStmt:\n \t\tp.print(token.RETURN)\n \t\tif s.Results != nil {\n-\t\t\tp.exprList(s.Pos(), s.Results, 1, blankStart|commaSep, multiLine, token.NoPos)\n+\t\t\tp.print(blank)\n+\t\t\tp.exprList(s.Pos(), s.Results, 1, 0, token.NoPos)\n \t\t}\n \n \tcase *ast.BranchStmt:\n \t\tp.print(s.Tok)\n \t\tif s.Label != nil {\n \t\t\tp.print(blank)\n-\t\t\tp.expr(s.Label, multiLine)\n+\t\t\tp.expr(s.Label)\n \t\t}\n \n \tcase *ast.BlockStmt:\n \t\tp.block(s, 1)\n-\t\t*multiLine = true\n \n \tcase *ast.IfStmt:\n \t\tp.print(token.IF)\n \t\tp.controlClause(false, s.Init, s.Cond, nil)\n \t\tp.block(s.Body, 1)\n-\t\t*multiLine = true\n \t\tif s.Else != nil {\n \t\t\tp.print(blank, token.ELSE, blank)\n \t\t\tswitch s.Else.(type) {\n \t\t\tcase *ast.BlockStmt, *ast.IfStmt:\n-\t\t\t\tp.stmt(s.Else, nextIsRBrace, ignoreMultiLine)\n+\t\t\t\tp.stmt(s.Else, nextIsRBrace)\n \t\t\tdefault:\n \t\t\t\tp.print(token.LBRACE, indent, formfeed)\n-\t\t\t\tp.stmt(s.Else, true, ignoreMultiLine)\n+\t\t\t\tp.stmt(s.Else, true)\n \t\t\t\tp.print(unindent, formfeed, token.RBRACE)\n \t\t\t}\n \t\t}\n \n \tcase *ast.CaseClause:\n \t\tif s.List != nil {\n-\t\t\tp.print(token.CASE)\n-\t\t\tp.exprList(s.Pos(), s.List, 1, blankStart|commaSep, multiLine, s.Colon)\n+\t\t\tp.print(token.CASE, blank)\n+\t\t\tp.exprList(s.Pos(), s.List, 1, 0, s.Colon)\n \t\t} else {\n \t\t\tp.print(token.DEFAULT)\n \t\t}\n@@ -1096,25 +1073,23 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\tp.print(token.SWITCH)\n \t\tp.controlClause(false, s.Init, s.Tag, nil)\n \t\tp.block(s.Body, 0)\n-\t\t*multiLine = true\n \n \tcase *ast.TypeSwitchStmt:\n \t\tp.print(token.SWITCH)\n \t\tif s.Init != nil {\n \t\t\tp.print(blank)\n-\t\t\tp.stmt(s.Init, false, ignoreMultiLine)\n+\t\t\tp.stmt(s.Init, false)\n \t\t\tp.print(token.SEMICOLON)\n \t\t}\n \t\tp.print(blank)\n-\t\tp.stmt(s.Assign, false, ignoreMultiLine)\n+\t\tp.stmt(s.Assign, false)\n \t\tp.print(blank)\n \t\tp.block(s.Body, 0)\n-\t\t*multiLine = true\n \n \tcase *ast.CommClause:\n \t\tif s.Comm != nil {\n \t\t\tp.print(token.CASE, blank)\n-\t\t\tp.stmt(s.Comm, false, ignoreMultiLine)\n+\t\t\tp.stmt(s.Comm, false)\n \t\t} else {\n \t\t\tp.print(token.DEFAULT)\n \t\t}\n@@ -1129,29 +1104,26 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\t\tp.print(body.Lbrace, token.LBRACE, body.Rbrace, token.RBRACE)\n \t\t} else {\n \t\t\tp.block(body, 0)\n-\t\t\t*multiLine = true\n \t\t}\n \n \tcase *ast.ForStmt:\n \t\tp.print(token.FOR)\n \t\tp.controlClause(true, s.Init, s.Cond, s.Post)\n \t\tp.block(s.Body, 1)\n-\t\t*multiLine = true\n \n \tcase *ast.RangeStmt:\n \t\tp.print(token.FOR, blank)\n-\t\tp.expr(s.Key, multiLine)\n+\t\tp.expr(s.Key)\n \t\tif s.Value != nil {\n \t\t\t// use position of value following the comma as\n \t\t\t// comma position for correct comment placement\n \t\t\tp.print(s.Value.Pos(), token.COMMA, blank)\n-\t\t\tp.expr(s.Value, multiLine)\n+\t\t\tp.expr(s.Value)\n \t\t}\n \t\tp.print(blank, s.TokPos, s.Tok, blank, token.RANGE, blank)\n-\t\tp.expr(stripParens(s.X), multiLine)\n+\t\tp.expr(stripParens(s.X))\n \t\tp.print(blank)\n \t\tp.block(s.Body, 1)\n-\t\t*multiLine = true\n \n \tdefault:\n \t\tpanic(\"unreachable\")\n@@ -1228,20 +1200,20 @@ func keepTypeColumn(specs []ast.Spec) []bool {\n \treturn m\n }\n \n-func (p *printer) valueSpec(s *ast.ValueSpec, keepType, doIndent bool, multiLine *bool) {\n+func (p *printer) valueSpec(s *ast.ValueSpec, keepType, doIndent bool) {\n \tp.setComment(s.Doc)\n-\tp.identList(s.Names, doIndent, multiLine) // always present\n+\tp.identList(s.Names, doIndent) // always present\n \textraTabs := 3\n \tif s.Type != nil || keepType {\n \t\tp.print(vtab)\n \t\textraTabs--\n \t}\n \tif s.Type != nil {\n-\t\tp.expr(s.Type, multiLine)\n+\t\tp.expr(s.Type)\n \t}\n \tif s.Values != nil {\n-\t\tp.print(vtab, token.ASSIGN)\n-\t\tp.exprList(token.NoPos, s.Values, 1, blankStart|commaSep, multiLine, token.NoPos)\n+\t\tp.print(vtab, token.ASSIGN, blank)\n+\t\tp.exprList(token.NoPos, s.Values, 1, 0, token.NoPos)\n \t\textraTabs--\n \t}\n \tif s.Comment != nil {\n@@ -1255,17 +1227,16 @@ func (p *printer) valueSpec(s *ast.ValueSpec, keepType, doIndent bool, multiLine\n // The parameter n is the number of specs in the group. If doIndent is set,\n // multi-line identifier lists in the spec are indented when the first\n // linebreak is encountered.\n-// Sets multiLine to true if the spec spans multiple lines.\n //\n-func (p *printer) spec(spec ast.Spec, n int, doIndent bool, multiLine *bool) {\n+func (p *printer) spec(spec ast.Spec, n int, doIndent bool) {\n \tswitch s := spec.(type) {\n \tcase *ast.ImportSpec:\n \t\tp.setComment(s.Doc)\n \t\tif s.Name != nil {\n-\t\t\tp.expr(s.Name, multiLine)\n+\t\t\tp.expr(s.Name)\n \t\t\tp.print(blank)\n \t\t}\n-\t\tp.expr(s.Path, multiLine)\n+\t\tp.expr(s.Path)\n \t\tp.setComment(s.Comment)\n \t\tp.print(s.EndPos)\n \n@@ -1274,35 +1245,34 @@ func (p *printer) spec(spec ast.Spec, n int, doIndent bool, multiLine *bool) {\n \t\t\tp.internalError(\"expected n = 1; got\", n)\n \t\t}\n \t\tp.setComment(s.Doc)\n-\t\tp.identList(s.Names, doIndent, multiLine) // always present\n+\t\tp.identList(s.Names, doIndent) // always present\n \t\tif s.Type != nil {\n \t\t\tp.print(blank)\n-\t\t\tp.expr(s.Type, multiLine)\n+\t\t\tp.expr(s.Type)\n \t\t}\n \t\tif s.Values != nil {\n-\t\t\tp.print(blank, token.ASSIGN)\n-\t\t\tp.exprList(token.NoPos, s.Values, 1, blankStart|commaSep, multiLine, token.NoPos)\n+\t\t\tp.print(blank, token.ASSIGN, blank)\n+\t\t\tp.exprList(token.NoPos, s.Values, 1, 0, token.NoPos)\n \t\t}\n \t\tp.setComment(s.Comment)\n \n \tcase *ast.TypeSpec:\n \t\tp.setComment(s.Doc)\n-\t\tp.expr(s.Name, multiLine)\n+\t\tp.expr(s.Name)\n \t\tif n == 1 {\n \t\t\tp.print(blank)\n \t\t} else {\n \t\t\tp.print(vtab)\n \t\t}\n-\t\tp.expr(s.Type, multiLine)\n+\t\tp.expr(s.Type)\n \t\tp.setComment(s.Comment)\n \n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n }\n \n-// Sets multiLine to true if the declaration spans multiple lines.\n-func (p *printer) genDecl(d *ast.GenDecl, multiLine *bool) {\n+func (p *printer) genDecl(d *ast.GenDecl) {\n \tp.setComment(d.Doc)\n \tp.print(d.Pos(), d.Tok, blank)\n \n@@ -1315,32 +1285,31 @@ func (p *printer) genDecl(d *ast.GenDecl, multiLine *bool) {\n \t\t\t\t// two or more grouped const/var declarations:\n \t\t\t\t// determine if the type column must be kept\n \t\t\t\tkeepType := keepTypeColumn(d.Specs)\n-\t\t\t\tvar ml bool\n+\t\t\t\tnewSection := false\n \t\t\t\tfor i, s := range d.Specs {\n \t\t\t\t\tif i > 0 {\n-\t\t\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, ml)\n+\t\t\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, newSection)\n \t\t\t\t\t}\n-\t\t\t\t\tml = false\n-\t\t\t\t\tp.valueSpec(s.(*ast.ValueSpec), keepType[i], false, &ml)\n+\t\t\t\t\tp.valueSpec(s.(*ast.ValueSpec), keepType[i], false)\n+\t\t\t\t\tnewSection = p.isMultiLine(s)\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tvar ml bool\n+\t\t\t\tnewSection := false\n \t\t\t\tfor i, s := range d.Specs {\n \t\t\t\t\tif i > 0 {\n-\t\t\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, ml)\n+\t\t\t\t\t\tp.linebreak(p.lineFor(s.Pos()), 1, ignore, newSection)\n \t\t\t\t\t}\n-\t\t\t\t\tml = false\n-\t\t\t\t\tp.spec(s, n, false, &ml)\n+\t\t\t\t\tp.spec(s, n, false)\n+\t\t\t\t\tnewSection = p.isMultiLine(s)\n \t\t\t\t}\n \t\t\t}\n \t\t\tp.print(unindent, formfeed)\n-\t\t\t*multiLine = true\n \t\t}\n \t\tp.print(d.Rparen, token.RPAREN)\n \n \t} else {\n \t\t// single declaration\n-\t\tp.spec(d.Specs[0], 1, true, multiLine)\n+\t\tp.spec(d.Specs[0], 1, true)\n \t}\n }\n \n@@ -1404,8 +1373,7 @@ func (p *printer) isOneLineFunc(b *ast.BlockStmt, headerSize int) bool {\n \treturn headerSize+bodySize <= maxSize\n }\n \n-// Sets multiLine to true if the function body spans multiple lines.\n-func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool, multiLine *bool) {\n+func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool) {\n \tif b == nil {\n \t\treturn\n \t}\n@@ -1422,7 +1390,7 @@ func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool, multiLi\n \t\t\t\tif i > 0 {\n \t\t\t\t\tp.print(token.SEMICOLON, blank)\n \t\t\t\t}\n-\t\t\t\tp.stmt(s, i == len(b.List)-1, ignoreMultiLine)\n+\t\t\t\tp.stmt(s, i == len(b.List)-1)\n \t\t\t}\n \t\t\tp.print(blank)\n \t\t}\n@@ -1432,7 +1400,6 @@ func (p *printer) funcBody(b *ast.BlockStmt, headerSize int, isLit bool, multiLi\n \n \tp.print(blank)\n \tp.block(b, 1)\n-\t*multiLine = true\n }\n \n // distance returns the column difference between from and to if both\n@@ -1446,28 +1413,26 @@ func (p *printer) distance(from0 token.Pos, to token.Position) int {\n \treturn infinity\n }\n \n-// Sets multiLine to true if the declaration spans multiple lines.\n-func (p *printer) funcDecl(d *ast.FuncDecl, multiLine *bool) {\n+func (p *printer) funcDecl(d *ast.FuncDecl) {\n \tp.setComment(d.Doc)\n \tp.print(d.Pos(), token.FUNC, blank)\n \tif d.Recv != nil {\n-\t\tp.parameters(d.Recv, multiLine) // method: print receiver\n+\t\tp.parameters(d.Recv) // method: print receiver\n \t\tp.print(blank)\n \t}\n-\tp.expr(d.Name, multiLine)\n-\tp.signature(d.Type.Params, d.Type.Results, multiLine)\n-\tp.funcBody(d.Body, p.distance(d.Pos(), p.pos), false, multiLine)\n+\tp.expr(d.Name)\n+\tp.signature(d.Type.Params, d.Type.Results)\n+\tp.funcBody(d.Body, p.distance(d.Pos(), p.pos), false)\n }\n \n-// Sets multiLine to true if the declaration spans multiple lines.\n-func (p *printer) decl(decl ast.Decl, multiLine *bool) {\n+func (p *printer) decl(decl ast.Decl) {\n \tswitch d := decl.(type) {\n \tcase *ast.BadDecl:\n \t\tp.print(d.Pos(), \"BadDecl\")\n \tcase *ast.GenDecl:\n-\t\tp.genDecl(d, multiLine)\n+\t\tp.genDecl(d)\n \tcase *ast.FuncDecl:\n-\t\tp.funcDecl(d, multiLine)\n+\t\tp.funcDecl(d)\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n@@ -1490,7 +1455,7 @@ func declToken(decl ast.Decl) (tok token.Token) {\n func (p *printer) file(src *ast.File) {\n \tp.setComment(src.Doc)\n \tp.print(src.Pos(), token.PACKAGE, blank)\n-\tp.expr(src.Name, ignoreMultiLine)\n+\tp.expr(src.Name)\n \n \tif len(src.Decls) > 0 {\n \t\ttok := token.ILLEGAL\n@@ -1509,7 +1474,7 @@ func (p *printer) file(src *ast.File) {\n \t\t\t\tmin = 2\n \t\t\t}\n \t\t\tp.linebreak(p.lineFor(d.Pos()), min, ignore, false)\n-\t\t\tp.decl(d, ignoreMultiLine)\n+\t\t\tp.decl(d)\n \t\t}\n \t}\n "}, {"sha": "a027d32da89889e0ecacca8831904512f729f1ae", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -34,9 +34,6 @@ const (\n \tunindent = whiteSpace('<')\n )\n \n-// Use ignoreMultiLine if the multiLine information is not important.\n-var ignoreMultiLine = new(bool)\n-\n // A pmode value represents the current printer mode.\n type pmode int\n \n@@ -280,10 +277,9 @@ func (p *printer) writeString(pos token.Position, s string, isLit bool) {\n // it as is likely to help position the comment nicely.\n // pos is the comment position, next the position of the item\n // after all pending comments, prev is the previous comment in\n-// a group of comments (or nil), and isKeyword indicates if the\n-// next item is a keyword.\n+// a group of comments (or nil), and tok is the next token.\n //\n-func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *ast.Comment, isKeyword bool) {\n+func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *ast.Comment, tok token.Token) {\n \tif len(p.output) == 0 {\n \t\t// the comment is the first item to be printed - don't write any whitespace\n \t\treturn\n@@ -338,38 +334,41 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *as\n \t\t// comment on a different line:\n \t\t// separate with at least one line break\n \t\tdroppedLinebreak := false\n-\t\tif prev == nil {\n-\t\t\t// first comment of a comment group\n-\t\t\tj := 0\n-\t\t\tfor i, ch := range p.wsbuf {\n-\t\t\t\tswitch ch {\n-\t\t\t\tcase blank, vtab:\n-\t\t\t\t\t// ignore any horizontal whitespace before line breaks\n-\t\t\t\t\tp.wsbuf[i] = ignore\n+\t\tj := 0\n+\t\tfor i, ch := range p.wsbuf {\n+\t\t\tswitch ch {\n+\t\t\tcase blank, vtab:\n+\t\t\t\t// ignore any horizontal whitespace before line breaks\n+\t\t\t\tp.wsbuf[i] = ignore\n+\t\t\t\tcontinue\n+\t\t\tcase indent:\n+\t\t\t\t// apply pending indentation\n+\t\t\t\tcontinue\n+\t\t\tcase unindent:\n+\t\t\t\t// if this is not the last unindent, apply it\n+\t\t\t\t// as it is (likely) belonging to the last\n+\t\t\t\t// construct (e.g., a multi-line expression list)\n+\t\t\t\t// and is not part of closing a block\n+\t\t\t\tif i+1 < len(p.wsbuf) && p.wsbuf[i+1] == unindent {\n \t\t\t\t\tcontinue\n-\t\t\t\tcase indent:\n-\t\t\t\t\t// apply pending indentation\n+\t\t\t\t}\n+\t\t\t\t// if the next token is not a closing }, apply the unindent\n+\t\t\t\t// if it appears that the comment is aligned with the\n+\t\t\t\t// token; otherwise assume the unindent is part of a\n+\t\t\t\t// closing block and stop (this scenario appears with\n+\t\t\t\t// comments before a case label where the comments\n+\t\t\t\t// apply to the next case instead of the current one)\n+\t\t\t\tif tok != token.RBRACE && pos.Column == next.Column {\n \t\t\t\t\tcontinue\n-\t\t\t\tcase unindent:\n-\t\t\t\t\t// if the next token is a keyword, apply the outdent\n-\t\t\t\t\t// if it appears that the comment is aligned with the\n-\t\t\t\t\t// keyword; otherwise assume the outdent is part of a\n-\t\t\t\t\t// closing block and stop (this scenario appears with\n-\t\t\t\t\t// comments before a case label where the comments\n-\t\t\t\t\t// apply to the next case instead of the current one)\n-\t\t\t\t\tif isKeyword && pos.Column == next.Column {\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\tcase newline, formfeed:\n-\t\t\t\t\t// TODO(gri): may want to keep formfeed info in some cases\n-\t\t\t\t\tp.wsbuf[i] = ignore\n-\t\t\t\t\tdroppedLinebreak = true\n \t\t\t\t}\n-\t\t\t\tj = i\n-\t\t\t\tbreak\n+\t\t\tcase newline, formfeed:\n+\t\t\t\tp.wsbuf[i] = ignore\n+\t\t\t\tdroppedLinebreak = prev == nil // record only if first comment of a group\n \t\t\t}\n-\t\t\tp.writeWhitespace(j)\n+\t\t\tj = i\n+\t\t\tbreak\n \t\t}\n+\t\tp.writeWhitespace(j)\n \n \t\t// determine number of linebreaks before the comment\n \t\tn := 0\n@@ -678,7 +677,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (wro\n \tvar last *ast.Comment\n \tfor p.commentBefore(next) {\n \t\tfor _, c := range p.comment.List {\n-\t\t\tp.writeCommentPrefix(p.posFor(c.Pos()), next, last, c, tok.IsKeyword())\n+\t\t\tp.writeCommentPrefix(p.posFor(c.Pos()), next, last, c, tok)\n \t\t\tp.writeComment(c)\n \t\t\tlast = c\n \t\t}\n@@ -1011,18 +1010,18 @@ func (p *printer) printNode(node interface{}) error {\n \t// format node\n \tswitch n := node.(type) {\n \tcase ast.Expr:\n-\t\tp.expr(n, ignoreMultiLine)\n+\t\tp.expr(n)\n \tcase ast.Stmt:\n \t\t// A labeled statement will un-indent to position the\n \t\t// label. Set indent to 1 so we don't get indent \"underflow\".\n \t\tif _, labeledStmt := n.(*ast.LabeledStmt); labeledStmt {\n \t\t\tp.indent = 1\n \t\t}\n-\t\tp.stmt(n, false, ignoreMultiLine)\n+\t\tp.stmt(n, false)\n \tcase ast.Decl:\n-\t\tp.decl(n, ignoreMultiLine)\n+\t\tp.decl(n)\n \tcase ast.Spec:\n-\t\tp.spec(n, 1, false, ignoreMultiLine)\n+\t\tp.spec(n, 1, false)\n \tcase *ast.File:\n \t\tp.file(n)\n \tdefault:"}, {"sha": "497d671f240bd06fe71c0ddc7fa6288d47087cc0", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -154,15 +154,12 @@ var data = []entry{\n }\n \n func TestFiles(t *testing.T) {\n-\tfor i, e := range data {\n+\tfor _, e := range data {\n \t\tsource := filepath.Join(dataDir, e.source)\n \t\tgolden := filepath.Join(dataDir, e.golden)\n \t\tcheck(t, source, golden, e.mode)\n \t\t// TODO(gri) check that golden is idempotent\n \t\t//check(t, golden, golden, e.mode)\n-\t\tif testing.Short() && i >= 3 {\n-\t\t\tbreak\n-\t\t}\n \t}\n }\n "}, {"sha": "d9aa2d82f7d8510392ca2effb38f32909f3a8fa0", "filename": "libgo/go/go/printer/testdata/comments.golden", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.golden?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -168,6 +168,91 @@ func typeswitch(x interface{}) {\n \t// this comment should not be indented\n }\n \n+//\n+// Indentation of comments after possibly indented multi-line constructs\n+// (test cases for issue 3147).\n+//\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\t// comment\n+\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\t// comment\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\n+\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\t// comment\n+\n+\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\t// comment\n+\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+// Test case from issue 3147.\n+func f() {\n+\ttemplateText := \"a\" +\t// A\n+\t\t\"b\" +\t// B\n+\t\t\"c\"\t// C\n+\n+\t// should be aligned with f()\n+\tf()\n+}\n+\n+// Modified test case from issue 3147.\n+func f() {\n+\ttemplateText := \"a\" +\t// A\n+\t\t\"b\" +\t// B\n+\t\t\"c\"\t// C\n+\n+\t\t// may not be aligned with f() (source is not aligned)\n+\tf()\n+}\n+\n+//\n+// Test cases for alignment of lines in general comments.\n+//\n+\n func _() {\n \t/* freestanding comment\n \t   aligned\t\tline"}, {"sha": "6084b3fe4500666a6d6380cedeb7ad43a3752892", "filename": "libgo/go/go/printer/testdata/comments.input", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments.input?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -171,6 +171,91 @@ func typeswitch(x interface{}) {\n \t// this comment should not be indented\n }\n \n+//\n+// Indentation of comments after possibly indented multi-line constructs\n+// (test cases for issue 3147).\n+//\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2 // comment\n+\t\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2 // comment\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\n+// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2 // comment\n+\n+\t\t// should be indented like s\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2 // comment\n+\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+func _() {\n+\ts := 1 +\n+\t\t2\n+\n+\t// should be indented like s\n+\t_ = 0\n+}\n+\n+// Test case from issue 3147.\n+func f() {\n+\ttemplateText := \"a\" + // A\n+\t\t\"b\" + // B\n+\t\t\"c\" // C\n+\n+\t// should be aligned with f()\n+\tf()\n+}\n+\n+// Modified test case from issue 3147.\n+func f() {\n+\ttemplateText := \"a\" + // A\n+\t\t\"b\" + // B\n+\t\t\"c\" // C\n+\n+\t\t// may not be aligned with f() (source is not aligned)\n+\tf()\n+}\n+\n+//\n+// Test cases for alignment of lines in general comments.\n+//\n+\n func _() {\n \t/* freestanding comment\n \t   aligned\t\tline"}, {"sha": "7ed7cb61ae5cddbeea5d076f8e23419b6f0f2515", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -83,13 +83,13 @@ import (\n // more import examples\n import (\n \t\"xxx\"\n-\t\"much longer name\"\t// comment\n-\t\"short name\"\t\t// comment\n+\t\"much_longer_name\"\t// comment\n+\t\"short_name\"\t\t// comment\n )\n \n import (\n \t_ \"xxx\"\n-\t\"much longer name\"\t// comment\n+\t\"much_longer_name\"\t// comment\n )\n \n import (\n@@ -500,7 +500,7 @@ type _ struct {\n \n type _ struct {\n \ta, b,\n-\tc, d\tint\t// this line should be indented\n+\tc, d\t\tint\t// this line should be indented\n \tu, v, w, x\tfloat\t// this line should be indented\n \tp, q,\n \tr, s\tfloat\t// this line should be indented\n@@ -562,7 +562,7 @@ var a2, b2,\n \n var (\n \ta3, b3,\n-\tc3, d3\tint\t// this line should be indented\n+\tc3, d3\t\tint\t// this line should be indented\n \ta4, b4, c4\tint\t// this line should be indented\n )\n "}, {"sha": "df8c2b167e16bcb719196f47d462184ee74e4337", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -84,13 +84,13 @@ import (\n // more import examples\n import (\n \t\"xxx\"\n-\t\"much longer name\" // comment\n-\t\"short name\" // comment\n+\t\"much_longer_name\" // comment\n+\t\"short_name\" // comment\n )\n \n import (\n \t_ \"xxx\"\n-\t\"much longer name\" // comment\n+\t\"much_longer_name\" // comment\n )\n \n import ("}, {"sha": "45fa4d97a4a5ca89ba58cae0cc796ba0f6d4662a", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -625,3 +625,25 @@ func f() {\n \t\tlog.Fatal(err)\n \t}\n }\n+\n+// Handle multi-line argument lists ending in ... correctly.\n+// Was issue 3130.\n+func _() {\n+\t_ = append(s, a...)\n+\t_ = append(\n+\t\ts, a...)\n+\t_ = append(s,\n+\t\ta...)\n+\t_ = append(\n+\t\ts,\n+\t\ta...)\n+\t_ = append(s, a...,\n+\t)\n+\t_ = append(s,\n+\t\ta...,\n+\t)\n+\t_ = append(\n+\t\ts,\n+\t\ta...,\n+\t)\n+}"}, {"sha": "f545c66057ca93d00cc8b6b07f2476f62056017e", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -654,3 +654,25 @@ func f() {\n \t    log.Fatal(err)\n \t}\n }\n+\n+// Handle multi-line argument lists ending in ... correctly.\n+// Was issue 3130.\n+func _() {\n+\t_ = append(s, a...)\n+\t_ = append(\n+\t\ts, a...)\n+\t_ = append(s,\n+\t\ta...)\n+\t_ = append(\n+\t\ts,\n+\t\ta...)\n+\t_ = append(s, a...,\n+\t)\n+\t_ = append(s,\n+\t\ta...,\n+\t)\n+\t_ = append(\n+\t\ts,\n+\t\ta...,\n+\t)\n+}"}, {"sha": "87a4b00836d168d3169734ca0ba5415e082bffcb", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -625,3 +625,25 @@ func f() {\n \t\tlog.Fatal(err)\n \t}\n }\n+\n+// Handle multi-line argument lists ending in ... correctly.\n+// Was issue 3130.\n+func _() {\n+\t_ = append(s, a...)\n+\t_ = append(\n+\t\ts, a...)\n+\t_ = append(s,\n+\t\ta...)\n+\t_ = append(\n+\t\ts,\n+\t\ta...)\n+\t_ = append(s, a...,\n+\t)\n+\t_ = append(s,\n+\t\ta...,\n+\t)\n+\t_ = append(\n+\t\ts,\n+\t\ta...,\n+\t)\n+}"}, {"sha": "dba8bbd435156a68221d5a9e445785bf9a111577", "filename": "libgo/go/go/printer/testdata/parser.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -52,7 +52,7 @@ type parser struct {\n \t// Non-syntactic parser control\n \texprLev int // < 0: in control clause, >= 0: in expression\n \n-\t// Ordinary identifer scopes\n+\t// Ordinary identifier scopes\n \tpkgScope   *ast.Scope        // pkgScope.Outer == nil\n \ttopScope   *ast.Scope        // top-most scope; may be pkgScope\n \tunresolved []*ast.Ident      // unresolved identifiers"}, {"sha": "ffca21edba9e3827cfcdf53550380ffa4957e155", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -8,6 +8,82 @@ var expr bool\n \n func use(x interface{})\t{}\n \n+// Formatting of multi-line return statements.\n+func _f() {\n+\treturn\n+\treturn x, y, z\n+\treturn T{}\n+\treturn T{1, 2, 3},\n+\t\tx, y, z\n+\treturn T{1, 2, 3},\n+\t\tx, y,\n+\t\tz\n+\treturn T{1,\n+\t\t2,\n+\t\t3}\n+\treturn T{1,\n+\t\t2,\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t\t3}\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1, 2, 3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1,\n+\t\t\t2, 3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1,\n+\t\t\t2,\n+\t\t\t3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t},\n+\t\tnil\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t},\n+\t\tT{\n+\t\t\tx:\t3,\n+\t\t\ty:\t4,\n+\t\t},\n+\t\tnil\n+\treturn x + y +\n+\t\tz\n+\treturn func() {}\n+\treturn func() {\n+\t\t_ = 0\n+\t}, T{\n+\t\t1, 2,\n+\t}\n+\treturn func() {\n+\t\t_ = 0\n+\t}\n+\treturn func() T {\n+\t\treturn T{\n+\t\t\t1, 2,\n+\t\t}\n+\t}\n+}\n+\n // Formatting of if-statement headers.\n func _() {\n \tif true {"}, {"sha": "99945e9551aaf195a65c688f6c538d1d91c7c3ea", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -8,6 +8,82 @@ var expr bool\n \n func use(x interface{}) {}\n \n+// Formatting of multi-line return statements.\n+func _f() {\n+\treturn\n+\treturn x, y, z\n+\treturn T{}\n+\treturn T{1, 2, 3},\n+\t\tx, y, z\n+\treturn T{1, 2, 3},\n+\t\tx, y,\n+\t\tz\n+\treturn T{1,\n+\t\t2,\n+\t\t3}\n+\treturn T{1,\n+\t\t2,\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t\t3}\n+\treturn T{\n+\t\t1,\n+\t\t2,\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1, 2, 3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1,\n+\t\t\t2, 3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t1,\n+\t\tT{1,\n+\t\t\t2,\n+\t\t\t3},\n+\t\t3,\n+\t}\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n+\t\tnil\n+\treturn T{\n+\t\t\t1,\n+\t\t\t2,\n+\t\t},\n+\t\tT{\n+\t\t\tx: 3,\n+\t\t\ty: 4,\n+\t\t},\n+\t\tnil\n+\treturn x + y +\n+\t\tz\n+\treturn func() {}\n+\treturn func() {\n+\t\t_ = 0\n+\t}, T{\n+\t\t1, 2,\n+\t}\n+\treturn func() {\n+\t\t_ = 0\n+\t}\n+\treturn func() T {\n+\t\treturn T {\n+\t\t\t1, 2,\n+\t\t}\n+\t}\n+}\n+\n // Formatting of if-statement headers.\n func _() {\n \tif true {}"}, {"sha": "3699ea1a91c45c82e546239589f6f14c5e8b4b3f", "filename": "libgo/go/html/template/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fdoc.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -19,7 +19,7 @@ to parse and execute HTML templates safely.\n \n   tmpl, err := template.New(\"name\").Parse(...)\n   // Error checking elided\n-  err = tmpl.Execute(out, \"Foo\", data)\n+  err = tmpl.Execute(out, data)\n \n If successful, tmpl will now be injection-safe. Otherwise, err is an error\n defined in the docs for ErrorCode."}, {"sha": "a058e20d7b340701658708f2f02e4ee0a32483ad", "filename": "libgo/go/html/template/escape.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -593,7 +593,7 @@ func (e *escaper) escapeText(c context, n *parse.TextNode) context {\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor j := i; j < end; j++ {\n-\t\t\t\tif s[j] == '<' && !bytes.HasPrefix(s[j:], doctypeBytes) {\n+\t\t\t\tif s[j] == '<' && !bytes.HasPrefix(bytes.ToUpper(s[j:]), doctypeBytes) {\n \t\t\t\t\tb.Write(s[written:j])\n \t\t\t\t\tb.WriteString(\"&lt;\")\n \t\t\t\t\twritten = j + 1"}, {"sha": "2bbb1b1bc94cfb40341b15d8b9696bc5db9a7f53", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -223,14 +223,14 @@ func TestEscape(t *testing.T) {\n \t\t\t`<button onclick='alert(&quot;\\x3cHello\\x3e&quot;)'>`,\n \t\t},\n \t\t{\n-\t\t\t\"badMarshaller\",\n+\t\t\t\"badMarshaler\",\n \t\t\t`<button onclick='alert(1/{{.B}}in numbers)'>`,\n \t\t\t`<button onclick='alert(1/ /* json: error calling MarshalJSON for type *template.badMarshaler: invalid character &#39;f&#39; looking for beginning of object key string */null in numbers)'>`,\n \t\t},\n \t\t{\n-\t\t\t\"jsMarshaller\",\n+\t\t\t\"jsMarshaler\",\n \t\t\t`<button onclick='alert({{.M}})'>`,\n-\t\t\t`<button onclick='alert({&#34;&lt;foo&gt;&#34;:&#34;O&#39;Reilly&#34;})'>`,\n+\t\t\t`<button onclick='alert({&#34;\\u003cfoo\\u003e&#34;:&#34;O&#39;Reilly&#34;})'>`,\n \t\t},\n \t\t{\n \t\t\t\"jsStrNotUnderEscaped\",\n@@ -431,6 +431,11 @@ func TestEscape(t *testing.T) {\n \t\t\t\"<!DOCTYPE html>Hello, World!\",\n \t\t\t\"<!DOCTYPE html>Hello, World!\",\n \t\t},\n+\t\t{\n+\t\t\t\"HTML doctype not case-insensitive\",\n+\t\t\t\"<!doCtYPE htMl>Hello, World!\",\n+\t\t\t\"<!doCtYPE htMl>Hello, World!\",\n+\t\t},\n \t\t{\n \t\t\t\"No doctype injection\",\n \t\t\t`<!{{\"DOCTYPE\"}}`,"}, {"sha": "36c88e23e6e4e1530c9dfc4474f12659e76ce68a", "filename": "libgo/go/html/template/html.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fhtml.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -134,7 +134,7 @@ var htmlNospaceNormReplacementTable = []string{\n \t'`': \"&#96;\",\n }\n \n-// htmlReplacer returns s with runes replaced acccording to replacementTable\n+// htmlReplacer returns s with runes replaced according to replacementTable\n // and when badRunes is true, certain bad runes are allowed through unescaped.\n func htmlReplacer(s string, replacementTable []string, badRunes bool) string {\n \twritten, b := 0, new(bytes.Buffer)"}, {"sha": "7074834d6137f1aad12b0fd3cd919216efe71ce9", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -6,6 +6,10 @@\n // Its primary job is to wrap existing implementations of such primitives,\n // such as those in package os, into shared public interfaces that\n // abstract the functionality, plus some other related primitives.\n+//\n+// Because these interfaces and primitives wrap lower-level operations with\n+// various implementations, unless otherwise informed clients should not\n+// assume they are safe for parallel execution.\n package io\n \n import (\n@@ -156,6 +160,9 @@ type WriterTo interface {\n // If ReadAt is reading from an input source with a seek offset,\n // ReadAt should not affect nor be affected by the underlying\n // seek offset.\n+//\n+// Clients of ReadAt can execute parallel ReadAt calls on the\n+// same input source.\n type ReaderAt interface {\n \tReadAt(p []byte, off int64) (n int, err error)\n }"}, {"sha": "f3f0f175706ad117b6ce194421a8bd9690cdd6c9", "filename": "libgo/go/io/pipe.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fio%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fio%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -175,6 +175,10 @@ func (w *PipeWriter) CloseWithError(err error) error {\n // with code expecting an io.Writer.\n // Reads on one end are matched with writes on the other,\n // copying data directly between the two; there is no internal buffering.\n+// It is safe to call Read and Write in parallel with each other or with\n+// Close. Close will complete once pending I/O is done. Parallel calls to\n+// Read, and parallel calls to Write, are also safe:\n+// the individual calls will be gated sequentially.\n func Pipe() (*PipeReader, *PipeWriter) {\n \tp := new(pipe)\n \tp.rwait.L = &p.l"}, {"sha": "f1247c383fd5f74355bd71875b2cc12e4467e281", "filename": "libgo/go/math/const.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fmath%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fmath%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fconst.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -27,11 +27,11 @@ const (\n // Max is the largest finite value representable by the type.\n // SmallestNonzero is the smallest positive, non-zero value representable by the type.\n const (\n-\tMaxFloat32             = 3.40282346638528859811704183484516925440e+38  /* 2**127 * (2**24 - 1) / 2**23 */\n-\tSmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 /* 1 / 2**(127 - 1 + 23) */\n+\tMaxFloat32             = 3.40282346638528859811704183484516925440e+38  // 2**127 * (2**24 - 1) / 2**23\n+\tSmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23)\n \n-\tMaxFloat64             = 1.797693134862315708145274237317043567981e+308 /* 2**1023 * (2**53 - 1) / 2**52 */\n-\tSmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 /* 1 / 2**(1023 - 1 + 52) */\n+\tMaxFloat64             = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52\n+\tSmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52)\n )\n \n // Integer limit values."}, {"sha": "10ca5faf7070aa345df2e63d8df793e183fe6233", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -69,7 +69,7 @@ func resolveNetAddr(op, net, addr string) (afnet string, a Addr, err error) {\n //\n // Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n // \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n-// (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\".\n+// (IPv4-only), \"ip6\" (IPv6-only), \"unix\" and \"unixpacket\".\n //\n // For TCP and UDP networks, addresses have the form host:port.\n // If host is a literal IPv6 address, it must be enclosed"}, {"sha": "5f5aea146a647d716df29509fbc426c660271ff2", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,6 +5,8 @@\n package net\n \n import (\n+\t\"flag\"\n+\t\"regexp\"\n \t\"runtime\"\n \t\"testing\"\n \t\"time\"\n@@ -128,3 +130,82 @@ func TestSelfConnect(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var runErrorTest = flag.Bool(\"run_error_test\", false, \"let TestDialError check for dns errors\")\n+\n+type DialErrorTest struct {\n+\tNet     string\n+\tRaddr   string\n+\tPattern string\n+}\n+\n+var dialErrorTests = []DialErrorTest{\n+\t{\n+\t\t\"datakit\", \"mh/astro/r70\",\n+\t\t\"dial datakit mh/astro/r70: unknown network datakit\",\n+\t},\n+\t{\n+\t\t\"tcp\", \"127.0.0.1:\u263a\",\n+\t\t\"dial tcp 127.0.0.1:\u263a: unknown port tcp/\u263a\",\n+\t},\n+\t{\n+\t\t\"tcp\", \"no-such-name.google.com.:80\",\n+\t\t\"dial tcp no-such-name.google.com.:80: lookup no-such-name.google.com.( on .*)?: no (.*)\",\n+\t},\n+\t{\n+\t\t\"tcp\", \"no-such-name.no-such-top-level-domain.:80\",\n+\t\t\"dial tcp no-such-name.no-such-top-level-domain.:80: lookup no-such-name.no-such-top-level-domain.( on .*)?: no (.*)\",\n+\t},\n+\t{\n+\t\t\"tcp\", \"no-such-name:80\",\n+\t\t`dial tcp no-such-name:80: lookup no-such-name\\.(.*\\.)?( on .*)?: no (.*)`,\n+\t},\n+\t{\n+\t\t\"tcp\", \"mh/astro/r70:http\",\n+\t\t\"dial tcp mh/astro/r70:http: lookup mh/astro/r70: invalid domain name\",\n+\t},\n+\t{\n+\t\t\"unix\", \"/etc/file-not-found\",\n+\t\t\"dial unix /etc/file-not-found: no such file or directory\",\n+\t},\n+\t{\n+\t\t\"unix\", \"/etc/\",\n+\t\t\"dial unix /etc/: (permission denied|socket operation on non-socket|connection refused)\",\n+\t},\n+\t{\n+\t\t\"unixpacket\", \"/etc/file-not-found\",\n+\t\t\"dial unixpacket /etc/file-not-found: no such file or directory\",\n+\t},\n+\t{\n+\t\t\"unixpacket\", \"/etc/\",\n+\t\t\"dial unixpacket /etc/: (permission denied|socket operation on non-socket|connection refused)\",\n+\t},\n+}\n+\n+var duplicateErrorPattern = `dial (.*) dial (.*)`\n+\n+func TestDialError(t *testing.T) {\n+\tif !*runErrorTest {\n+\t\tt.Logf(\"test disabled; use -run_error_test to enable\")\n+\t\treturn\n+\t}\n+\tfor i, tt := range dialErrorTests {\n+\t\tc, err := Dial(tt.Net, tt.Raddr)\n+\t\tif c != nil {\n+\t\t\tc.Close()\n+\t\t}\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"#%d: nil error, want match for %#q\", i, tt.Pattern)\n+\t\t\tcontinue\n+\t\t}\n+\t\ts := err.Error()\n+\t\tmatch, _ := regexp.MatchString(tt.Pattern, s)\n+\t\tif !match {\n+\t\t\tt.Errorf(\"#%d: %q, want match for %#q\", i, s, tt.Pattern)\n+\t\t}\n+\t\tmatch, _ = regexp.MatchString(duplicateErrorPattern, s)\n+\t\tif match {\n+\t\t\tt.Errorf(\"#%d: %q, duplicate error return from Dial\", i, s)\n+\t\t}\n+\t}\n+}"}, {"sha": "03c4499720f02cb88e5c9af2a6d145c4edf339d6", "filename": "libgo/go/net/dialgoogle_test.go", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdialgoogle_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -42,9 +42,8 @@ func doDial(t *testing.T, network, addr string) {\n }\n \n func TestLookupCNAME(t *testing.T) {\n-\tif testing.Short() {\n-\t\t// Don't use external network.\n-\t\tt.Logf(\"skipping external network test during -short\")\n+\tif testing.Short() || !*testExternal {\n+\t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n \tcname, err := LookupCNAME(\"www.google.com\")\n@@ -67,9 +66,8 @@ var googleaddrsipv4 = []string{\n }\n \n func TestDialGoogleIPv4(t *testing.T) {\n-\tif testing.Short() {\n-\t\t// Don't use external network.\n-\t\tt.Logf(\"skipping external network test during -short\")\n+\tif testing.Short() || !*testExternal {\n+\t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n \n@@ -124,9 +122,8 @@ var googleaddrsipv6 = []string{\n }\n \n func TestDialGoogleIPv6(t *testing.T) {\n-\tif testing.Short() {\n-\t\t// Don't use external network.\n-\t\tt.Logf(\"skipping external network test during -short\")\n+\tif testing.Short() || !*testExternal {\n+\t\tt.Logf(\"skipping test to avoid external network\")\n \t\treturn\n \t}\n \t// Only run tcp6 if the kernel will take it."}, {"sha": "1ba7bec5fc5b2f3669dc660f2fee325514e1bcc9", "filename": "libgo/go/net/http/cgi/child.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fchild.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -144,6 +144,7 @@ func Serve(handler http.Handler) error {\n \t\tbufw:   bufio.NewWriter(os.Stdout),\n \t}\n \thandler.ServeHTTP(rw, req)\n+\trw.Write(nil) // make sure a response is sent\n \tif err = rw.bufw.Flush(); err != nil {\n \t\treturn err\n \t}"}, {"sha": "859911f9805bede12c5a99ad19a17339be252db4", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -41,6 +41,7 @@ func runCgiTest(t *testing.T, h *Handler, httpreq string, expectedMap map[string\n \n \t// Make a map to hold the test map that the CGI returns.\n \tm := make(map[string]string)\n+\tm[\"_body\"] = rw.Body.String()\n \tlinesRead := 0\n readlines:\n \tfor {"}, {"sha": "e1a78c8f62f4cdef7ea6b3f58a587541f33d70a9", "filename": "libgo/go/net/http/cgi/matryoshka_test.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fmatryoshka_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fmatryoshka_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fmatryoshka_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -51,6 +51,22 @@ func TestHostingOurselves(t *testing.T) {\n \t}\n }\n \n+// Test that a child handler only writing headers works.\n+func TestChildOnlyHeaders(t *testing.T) {\n+\th := &Handler{\n+\t\tPath: os.Args[0],\n+\t\tRoot: \"/test.go\",\n+\t\tArgs: []string{\"-test.run=TestBeChildCGIProcess\"},\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"_body\": \"\",\n+\t}\n+\treplay := runCgiTest(t, h, \"GET /test.go?no-body=1 HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+\tif expected, got := \"X-Test-Value\", replay.Header().Get(\"X-Test-Header\"); got != expected {\n+\t\tt.Errorf(\"got a X-Test-Header of %q; expected %q\", got, expected)\n+\t}\n+}\n+\n // Note: not actually a test.\n func TestBeChildCGIProcess(t *testing.T) {\n \tif os.Getenv(\"REQUEST_METHOD\") == \"\" {\n@@ -59,8 +75,11 @@ func TestBeChildCGIProcess(t *testing.T) {\n \t}\n \tServe(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n \t\trw.Header().Set(\"X-Test-Header\", \"X-Test-Value\")\n-\t\tfmt.Fprintf(rw, \"test=Hello CGI-in-CGI\\n\")\n \t\treq.ParseForm()\n+\t\tif req.FormValue(\"no-body\") == \"1\" {\n+\t\t\treturn\n+\t\t}\n+\t\tfmt.Fprintf(rw, \"test=Hello CGI-in-CGI\\n\")\n \t\tfor k, vv := range req.Form {\n \t\t\tfor _, v := range vv {\n \t\t\t\tfmt.Fprintf(rw, \"param-%s=%s\\n\", k, v)"}, {"sha": "5aa93ce58373d7437b79363e6aa5dab2b0666467", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -152,12 +152,19 @@ func TestFileServerCleans(t *testing.T) {\n \t}\n }\n \n+func mustRemoveAll(dir string) {\n+\terr := os.RemoveAll(dir)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+}\n+\n func TestFileServerImplicitLeadingSlash(t *testing.T) {\n \ttempDir, err := ioutil.TempDir(\"\", \"\")\n \tif err != nil {\n \t\tt.Fatalf(\"TempDir: %v\", err)\n \t}\n-\tdefer os.RemoveAll(tempDir)\n+\tdefer mustRemoveAll(tempDir)\n \tif err := ioutil.WriteFile(filepath.Join(tempDir, \"foo.txt\"), []byte(\"Hello world\"), 0644); err != nil {\n \t\tt.Fatalf(\"WriteFile: %v\", err)\n \t}\n@@ -172,6 +179,7 @@ func TestFileServerImplicitLeadingSlash(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"ReadAll %s: %v\", suffix, err)\n \t\t}\n+\t\tres.Body.Close()\n \t\treturn string(b)\n \t}\n \tif s := get(\"/bar/\"); !strings.Contains(s, \">foo.txt<\") {"}, {"sha": "57cf0c9417dbae8c822d28d7dc88a23e14a14e41", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"net\"\n \t\"net/http\"\n \t\"os\"\n+\t\"sync\"\n )\n \n // A Server is an HTTP server listening on a system-chosen port on the\n@@ -25,6 +26,10 @@ type Server struct {\n \t// Config may be changed after calling NewUnstartedServer and\n \t// before Start or StartTLS.\n \tConfig *http.Server\n+\n+\t// wg counts the number of outstanding HTTP requests on this server.\n+\t// Close blocks until all requests are finished.\n+\twg sync.WaitGroup\n }\n \n // historyListener keeps track of all connections that it's ever\n@@ -93,6 +98,7 @@ func (s *Server) Start() {\n \t}\n \ts.Listener = &historyListener{s.Listener, make([]net.Conn, 0)}\n \ts.URL = \"http://\" + s.Listener.Addr().String()\n+\ts.wrapHandler()\n \tgo s.Config.Serve(s.Listener)\n \tif *serve != \"\" {\n \t\tfmt.Fprintln(os.Stderr, \"httptest: serving on\", s.URL)\n@@ -118,9 +124,21 @@ func (s *Server) StartTLS() {\n \n \ts.Listener = &historyListener{tlsListener, make([]net.Conn, 0)}\n \ts.URL = \"https://\" + s.Listener.Addr().String()\n+\ts.wrapHandler()\n \tgo s.Config.Serve(s.Listener)\n }\n \n+func (s *Server) wrapHandler() {\n+\th := s.Config.Handler\n+\tif h == nil {\n+\t\th = http.DefaultServeMux\n+\t}\n+\ts.Config.Handler = &waitGroupHandler{\n+\t\ts: s,\n+\t\th: h,\n+\t}\n+}\n+\n // NewTLSServer starts and returns a new Server using TLS.\n // The caller should call Close when finished, to shut it down.\n func NewTLSServer(handler http.Handler) *Server {\n@@ -129,9 +147,11 @@ func NewTLSServer(handler http.Handler) *Server {\n \treturn ts\n }\n \n-// Close shuts down the server.\n+// Close shuts down the server and blocks until all outstanding\n+// requests on this server have completed.\n func (s *Server) Close() {\n \ts.Listener.Close()\n+\ts.wg.Wait()\n }\n \n // CloseClientConnections closes any currently open HTTP connections\n@@ -146,6 +166,20 @@ func (s *Server) CloseClientConnections() {\n \t}\n }\n \n+// waitGroupHandler wraps a handler, incrementing and decrementing a\n+// sync.WaitGroup on each request, to enable Server.Close to block\n+// until outstanding requests are finished.\n+type waitGroupHandler struct {\n+\ts *Server\n+\th http.Handler // non-nil\n+}\n+\n+func (h *waitGroupHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n+\th.s.wg.Add(1)\n+\tdefer h.s.wg.Done() // a defer, in case ServeHTTP below panics\n+\th.h.ServeHTTP(w, r)\n+}\n+\n // localhostCert is a PEM-encoded TLS cert with SAN DNS names\n // \"127.0.0.1\" and \"[::1]\", expiring at the last second of 2049 (the end\n // of ASN.1 time)."}, {"sha": "892ef4eded0c1cf56818d99201464312d984c452", "filename": "libgo/go/net/http/httputil/dump.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"io/ioutil\"\n \t\"net\"\n \t\"net/http\"\n+\t\"net/url\"\n \t\"strings\"\n \t\"time\"\n )\n@@ -59,6 +60,19 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \t\t}\n \t}\n \n+\t// Since we're using the actual Transport code to write the request,\n+\t// switch to http so the Transport doesn't try to do an SSL\n+\t// negotiation with our dumpConn and its bytes.Buffer & pipe.\n+\t// The wire format for https and http are the same, anyway.\n+\treqSend := req\n+\tif req.URL.Scheme == \"https\" {\n+\t\treqSend = new(http.Request)\n+\t\t*reqSend = *req\n+\t\treqSend.URL = new(url.URL)\n+\t\t*reqSend.URL = *req.URL\n+\t\treqSend.URL.Scheme = \"http\"\n+\t}\n+\n \t// Use the actual Transport code to record what we would send\n \t// on the wire, but not using TCP.  Use a Transport with a\n \t// customer dialer that returns a fake net.Conn that waits\n@@ -79,7 +93,7 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \t\t},\n \t}\n \n-\t_, err := t.RoundTrip(req)\n+\t_, err := t.RoundTrip(reqSend)\n \n \treq.Body = save\n \tif err != nil {"}, {"sha": "5afe9ba74e36cc2b40e7b4f86891140baa6f7861", "filename": "libgo/go/net/http/httputil/dump_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -71,6 +71,18 @@ var dumpTests = []dumpTest{\n \t\t\t\"User-Agent: Go http package\\r\\n\" +\n \t\t\t\"Accept-Encoding: gzip\\r\\n\\r\\n\",\n \t},\n+\n+\t// Test that an https URL doesn't try to do an SSL negotiation\n+\t// with a bytes.Buffer and hang with all goroutines not\n+\t// runnable.\n+\t{\n+\t\tReq: *mustNewRequest(\"GET\", \"https://example.com/foo\", nil),\n+\n+\t\tWantDumpOut: \"GET /foo HTTP/1.1\\r\\n\" +\n+\t\t\t\"Host: example.com\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"Accept-Encoding: gzip\\r\\n\\r\\n\",\n+\t},\n }\n \n func TestDumpRequest(t *testing.T) {"}, {"sha": "507938acac71cefe2adce14d011261e597e60e9c", "filename": "libgo/go/net/http/httputil/persist.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -383,7 +383,7 @@ func (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error) {\n \t// Make sure body is fully consumed, even if user does not call body.Close\n \tif lastbody != nil {\n \t\t// body.Close is assumed to be idempotent and multiple calls to\n-\t\t// it should return the error that its first invokation\n+\t\t// it should return the error that its first invocation\n \t\t// returned.\n \t\terr = lastbody.Close()\n \t\tif err != nil {"}, {"sha": "ffb393ccf6ab9cada206f752a1d034778dfdfe22", "filename": "libgo/go/net/http/lex.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Flex.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -14,14 +14,6 @@ func isSeparator(c byte) bool {\n \treturn false\n }\n \n-func isSpace(c byte) bool {\n-\tswitch c {\n-\tcase ' ', '\\t', '\\r', '\\n':\n-\t\treturn true\n-\t}\n-\treturn false\n-}\n-\n func isCtl(c byte) bool { return (0 <= c && c <= 31) || c == 127 }\n \n func isChar(c byte) bool { return 0 <= c && c <= 127 }"}, {"sha": "8ab72ac23f9af139a0f2011e502c5b98d3c19d1c", "filename": "libgo/go/net/http/sniff_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -129,9 +129,10 @@ func TestSniffWriteSize(t *testing.T) {\n \t}))\n \tdefer ts.Close()\n \tfor _, size := range []int{0, 1, 200, 600, 999, 1000, 1023, 1024, 512 << 10, 1 << 20} {\n-\t\t_, err := Get(fmt.Sprintf(\"%s/?size=%d\", ts.URL, size))\n+\t\tres, err := Get(fmt.Sprintf(\"%s/?size=%d\", ts.URL, size))\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"size %d: %v\", size, err)\n \t\t}\n+\t\tres.Body.Close()\n \t}\n }"}, {"sha": "5af0b77c4288172745278cd9cf7f22bd23f3c106", "filename": "libgo/go/net/http/status.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fstatus.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Fstatus.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fstatus.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -43,6 +43,7 @@ const (\n \tStatusUnsupportedMediaType         = 415\n \tStatusRequestedRangeNotSatisfiable = 416\n \tStatusExpectationFailed            = 417\n+\tStatusTeapot                       = 418\n \n \tStatusInternalServerError     = 500\n \tStatusNotImplemented          = 501\n@@ -90,6 +91,7 @@ var statusText = map[int]string{\n \tStatusUnsupportedMediaType:         \"Unsupported Media Type\",\n \tStatusRequestedRangeNotSatisfiable: \"Requested Range Not Satisfiable\",\n \tStatusExpectationFailed:            \"Expectation Failed\",\n+\tStatusTeapot:                       \"I'm a teapot\",\n \n \tStatusInternalServerError:     \"Internal Server Error\",\n \tStatusNotImplemented:          \"Not Implemented\","}, {"sha": "3c8fe7f5b510110e49d6e07ebccbdbffb9ddbb44", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -383,7 +383,7 @@ func fixTransferEncoding(requestMethod string, header Header) ([]string, error)\n \t// chunked encoding must always come first.\n \tfor _, encoding := range encodings {\n \t\tencoding = strings.ToLower(strings.TrimSpace(encoding))\n-\t\t// \"identity\" encoding is not recored\n+\t\t// \"identity\" encoding is not recorded\n \t\tif encoding == \"identity\" {\n \t\t\tbreak\n \t\t}"}, {"sha": "09579f8a0934916a53cb6cadd91a0cf4bd65149e", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -76,7 +76,9 @@ type Transport struct {\n // ProxyFromEnvironment returns the URL of the proxy to use for a\n // given request, as indicated by the environment variables\n // $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy).\n-// Either URL or an error is returned.\n+// An error is returned if the proxy environment is invalid.\n+// A nil URL and nil error are returned if no proxy is defined in the\n+// environment, or a proxy should not be used for the given request.\n func ProxyFromEnvironment(req *Request) (*url.URL, error) {\n \tproxy := getenvEitherCase(\"HTTP_PROXY\")\n \tif proxy == \"\" {\n@@ -86,7 +88,7 @@ func ProxyFromEnvironment(req *Request) (*url.URL, error) {\n \t\treturn nil, nil\n \t}\n \tproxyURL, err := url.Parse(proxy)\n-\tif err != nil {\n+\tif err != nil || proxyURL.Scheme == \"\" {\n \t\tif u, err := url.Parse(\"http://\" + proxy); err == nil {\n \t\t\tproxyURL = u\n \t\t\terr = nil"}, {"sha": "cbb3884f9eac87e18baad5d965dd12e0db69b61f", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -16,6 +16,7 @@ import (\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"net/url\"\n+\t\"os\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n@@ -727,6 +728,36 @@ func TestTransportAltProto(t *testing.T) {\n \t}\n }\n \n+var proxyFromEnvTests = []struct {\n+\tenv     string\n+\twanturl string\n+\twanterr error\n+}{\n+\t{\"127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n+\t{\"http://127.0.0.1:8080\", \"http://127.0.0.1:8080\", nil},\n+\t{\"https://127.0.0.1:8080\", \"https://127.0.0.1:8080\", nil},\n+\t{\"\", \"<nil>\", nil},\n+}\n+\n+func TestProxyFromEnvironment(t *testing.T) {\n+\tos.Setenv(\"HTTP_PROXY\", \"\")\n+\tos.Setenv(\"http_proxy\", \"\")\n+\tos.Setenv(\"NO_PROXY\", \"\")\n+\tos.Setenv(\"no_proxy\", \"\")\n+\tfor i, tt := range proxyFromEnvTests {\n+\t\tos.Setenv(\"HTTP_PROXY\", tt.env)\n+\t\treq, _ := NewRequest(\"GET\", \"http://example.com\", nil)\n+\t\turl, err := ProxyFromEnvironment(req)\n+\t\tif g, e := fmt.Sprintf(\"%v\", err), fmt.Sprintf(\"%v\", tt.wanterr); g != e {\n+\t\t\tt.Errorf(\"%d. got error = %q, want %q\", i, g, e)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got := fmt.Sprintf(\"%s\", url); got != tt.wanturl {\n+\t\t\tt.Errorf(\"%d. got URL = %q, want %q\", i, url, tt.wanturl)\n+\t\t}\n+\t}\n+}\n+\n // rgz is a gzip quine that uncompresses to itself.\n var rgz = []byte{\n \t0x1f, 0x8b, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,"}, {"sha": "269af0ca3d526e7be323c8c633e111980ea54add", "filename": "libgo/go/net/http/triv.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftriv.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -108,7 +108,6 @@ func DateServer(rw http.ResponseWriter, req *http.Request) {\n \t\tfmt.Fprintf(rw, \"fork/exec: %s\\n\", err)\n \t\treturn\n \t}\n-\tdefer p.Release()\n \tio.Copy(rw, r)\n \twait, err := p.Wait(0)\n \tif err != nil {"}, {"sha": "f25d046c171ea1bb4b512230b2a922726f3540b1", "filename": "libgo/go/net/interface.go", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -6,11 +6,7 @@\n \n package net\n \n-import (\n-\t\"bytes\"\n-\t\"errors\"\n-\t\"fmt\"\n-)\n+import \"errors\"\n \n var (\n \terrInvalidInterface         = errors.New(\"net: invalid interface\")\n@@ -20,77 +16,6 @@ var (\n \terrNoSuchMulticastInterface = errors.New(\"net: no such multicast interface\")\n )\n \n-// A HardwareAddr represents a physical hardware address.\n-type HardwareAddr []byte\n-\n-func (a HardwareAddr) String() string {\n-\tvar buf bytes.Buffer\n-\tfor i, b := range a {\n-\t\tif i > 0 {\n-\t\t\tbuf.WriteByte(':')\n-\t\t}\n-\t\tfmt.Fprintf(&buf, \"%02x\", b)\n-\t}\n-\treturn buf.String()\n-}\n-\n-// ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the\n-// following formats:\n-//   01:23:45:67:89:ab\n-//   01:23:45:67:89:ab:cd:ef\n-//   01-23-45-67-89-ab\n-//   01-23-45-67-89-ab-cd-ef\n-//   0123.4567.89ab\n-//   0123.4567.89ab.cdef\n-func ParseMAC(s string) (hw HardwareAddr, err error) {\n-\tif len(s) < 14 {\n-\t\tgoto error\n-\t}\n-\n-\tif s[2] == ':' || s[2] == '-' {\n-\t\tif (len(s)+1)%3 != 0 {\n-\t\t\tgoto error\n-\t\t}\n-\t\tn := (len(s) + 1) / 3\n-\t\tif n != 6 && n != 8 {\n-\t\t\tgoto error\n-\t\t}\n-\t\thw = make(HardwareAddr, n)\n-\t\tfor x, i := 0, 0; i < n; i++ {\n-\t\t\tvar ok bool\n-\t\t\tif hw[i], ok = xtoi2(s[x:], s[2]); !ok {\n-\t\t\t\tgoto error\n-\t\t\t}\n-\t\t\tx += 3\n-\t\t}\n-\t} else if s[4] == '.' {\n-\t\tif (len(s)+1)%5 != 0 {\n-\t\t\tgoto error\n-\t\t}\n-\t\tn := 2 * (len(s) + 1) / 5\n-\t\tif n != 6 && n != 8 {\n-\t\t\tgoto error\n-\t\t}\n-\t\thw = make(HardwareAddr, n)\n-\t\tfor x, i := 0, 0; i < n; i += 2 {\n-\t\t\tvar ok bool\n-\t\t\tif hw[i], ok = xtoi2(s[x:x+2], 0); !ok {\n-\t\t\t\tgoto error\n-\t\t\t}\n-\t\t\tif hw[i+1], ok = xtoi2(s[x+2:], s[4]); !ok {\n-\t\t\t\tgoto error\n-\t\t\t}\n-\t\t\tx += 5\n-\t\t}\n-\t} else {\n-\t\tgoto error\n-\t}\n-\treturn hw, nil\n-\n-error:\n-\treturn nil, errors.New(\"invalid MAC address: \" + s)\n-}\n-\n // Interface represents a mapping between network interface name\n // and index.  It also represents network interface facility\n // information."}, {"sha": "0a33bfdb517fe6eacddb100b5793a5621f3987c8", "filename": "libgo/go/net/interface_test.go", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Finterface_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Finterface_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -6,8 +6,6 @@ package net\n \n import (\n \t\"bytes\"\n-\t\"reflect\"\n-\t\"strings\"\n \t\"testing\"\n )\n \n@@ -96,46 +94,3 @@ func testMulticastAddrs(t *testing.T, ifmat []Addr) {\n \t\t}\n \t}\n }\n-\n-var mactests = []struct {\n-\tin  string\n-\tout HardwareAddr\n-\terr string\n-}{\n-\t{\"01:23:45:67:89:AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n-\t{\"01-23-45-67-89-AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n-\t{\"0123.4567.89AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n-\t{\"ab:cd:ef:AB:CD:EF\", HardwareAddr{0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef}, \"\"},\n-\t{\"01.02.03.04.05.06\", nil, \"invalid MAC address\"},\n-\t{\"01:02:03:04:05:06:\", nil, \"invalid MAC address\"},\n-\t{\"x1:02:03:04:05:06\", nil, \"invalid MAC address\"},\n-\t{\"01002:03:04:05:06\", nil, \"invalid MAC address\"},\n-\t{\"01:02003:04:05:06\", nil, \"invalid MAC address\"},\n-\t{\"01:02:03004:05:06\", nil, \"invalid MAC address\"},\n-\t{\"01:02:03:04005:06\", nil, \"invalid MAC address\"},\n-\t{\"01:02:03:04:05006\", nil, \"invalid MAC address\"},\n-\t{\"01-02:03:04:05:06\", nil, \"invalid MAC address\"},\n-\t{\"01:02-03-04-05-06\", nil, \"invalid MAC address\"},\n-\t{\"0123:4567:89AF\", nil, \"invalid MAC address\"},\n-\t{\"0123-4567-89AF\", nil, \"invalid MAC address\"},\n-\t{\"01:23:45:67:89:AB:CD:EF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n-\t{\"01-23-45-67-89-AB-CD-EF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n-\t{\"0123.4567.89AB.CDEF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n-}\n-\n-func match(err error, s string) bool {\n-\tif s == \"\" {\n-\t\treturn err == nil\n-\t}\n-\treturn err != nil && strings.Contains(err.Error(), s)\n-}\n-\n-func TestParseMAC(t *testing.T) {\n-\tfor _, tt := range mactests {\n-\t\tout, err := ParseMAC(tt.in)\n-\t\tif !reflect.DeepEqual(out, tt.out) || !match(err, tt.err) {\n-\t\t\tt.Errorf(\"ParseMAC(%q) = %v, %v, want %v, %v\", tt.in, out, err, tt.out,\n-\t\t\t\ttt.err)\n-\t\t}\n-\t}\n-}"}, {"sha": "2c698304b21d790e79f25bb337de30fa533c6c05", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -76,7 +76,7 @@ func lookupProtocol(name string) (proto int, err error) {\n }\n \n func lookupHost(host string) (addrs []string, err error) {\n-\t// Use /net/cs insead of /net/dns because cs knows about\n+\t// Use /net/cs instead of /net/dns because cs knows about\n \t// host names in local network (e.g. from /lib/ndb/local)\n \tlines, err := queryCS(\"tcp\", host, \"1\")\n \tif err != nil {"}, {"sha": "3a61dfb29c2ce77759a8700bcbeaa7a26c3c7eeb", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -12,7 +12,7 @@ import (\n \t\"testing\"\n )\n \n-var testExternal = flag.Bool(\"external\", false, \"allow use of external networks during test\")\n+var testExternal = flag.Bool(\"external\", true, \"allow use of external networks during long test\")\n \n func TestGoogleSRV(t *testing.T) {\n \tif testing.Short() || !*testExternal {\n@@ -78,3 +78,40 @@ func TestGoogleDNSAddr(t *testing.T) {\n \t\tt.Errorf(\"no results\")\n \t}\n }\n+\n+var revAddrTests = []struct {\n+\tAddr      string\n+\tReverse   string\n+\tErrPrefix string\n+}{\n+\t{\"1.2.3.4\", \"4.3.2.1.in-addr.arpa.\", \"\"},\n+\t{\"245.110.36.114\", \"114.36.110.245.in-addr.arpa.\", \"\"},\n+\t{\"::ffff:12.34.56.78\", \"78.56.34.12.in-addr.arpa.\", \"\"},\n+\t{\"::1\", \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.\", \"\"},\n+\t{\"1::\", \"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.0.0.0.ip6.arpa.\", \"\"},\n+\t{\"1234:567::89a:bcde\", \"e.d.c.b.a.9.8.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.7.6.5.0.4.3.2.1.ip6.arpa.\", \"\"},\n+\t{\"1234:567:fefe:bcbc:adad:9e4a:89a:bcde\", \"e.d.c.b.a.9.8.0.a.4.e.9.d.a.d.a.c.b.c.b.e.f.e.f.7.6.5.0.4.3.2.1.ip6.arpa.\", \"\"},\n+\t{\"1.2.3\", \"\", \"unrecognized address\"},\n+\t{\"1.2.3.4.5\", \"\", \"unrecognized address\"},\n+\t{\"1234:567:bcbca::89a:bcde\", \"\", \"unrecognized address\"},\n+\t{\"1234:567::bcbc:adad::89a:bcde\", \"\", \"unrecognized address\"},\n+}\n+\n+func TestReverseAddress(t *testing.T) {\n+\tfor i, tt := range revAddrTests {\n+\t\ta, err := reverseaddr(tt.Addr)\n+\t\tif len(tt.ErrPrefix) > 0 && err == nil {\n+\t\t\tt.Errorf(\"#%d: expected %q, got <nil> (error)\", i, tt.ErrPrefix)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(tt.ErrPrefix) == 0 && err != nil {\n+\t\t\tt.Errorf(\"#%d: expected <nil>, got %q (error)\", i, err)\n+\t\t}\n+\t\tif err != nil && err.(*DNSError).Err != tt.ErrPrefix {\n+\t\t\tt.Errorf(\"#%d: expected %q, got %q (mismatched error)\", i, tt.ErrPrefix, err.(*DNSError).Err)\n+\t\t}\n+\t\tif a != tt.Reverse {\n+\t\t\tt.Errorf(\"#%d: expected %q, got %q (reverse address)\", i, tt.Reverse, a)\n+\t\t}\n+\t}\n+}"}, {"sha": "e0637d00b74e59b9c1b013a1490e3698923b4193", "filename": "libgo/go/net/mac.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmac.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// MAC address manipulations\n+\n+package net\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// A HardwareAddr represents a physical hardware address.\n+type HardwareAddr []byte\n+\n+func (a HardwareAddr) String() string {\n+\tvar buf bytes.Buffer\n+\tfor i, b := range a {\n+\t\tif i > 0 {\n+\t\t\tbuf.WriteByte(':')\n+\t\t}\n+\t\tfmt.Fprintf(&buf, \"%02x\", b)\n+\t}\n+\treturn buf.String()\n+}\n+\n+// ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the\n+// following formats:\n+//   01:23:45:67:89:ab\n+//   01:23:45:67:89:ab:cd:ef\n+//   01-23-45-67-89-ab\n+//   01-23-45-67-89-ab-cd-ef\n+//   0123.4567.89ab\n+//   0123.4567.89ab.cdef\n+func ParseMAC(s string) (hw HardwareAddr, err error) {\n+\tif len(s) < 14 {\n+\t\tgoto error\n+\t}\n+\n+\tif s[2] == ':' || s[2] == '-' {\n+\t\tif (len(s)+1)%3 != 0 {\n+\t\t\tgoto error\n+\t\t}\n+\t\tn := (len(s) + 1) / 3\n+\t\tif n != 6 && n != 8 {\n+\t\t\tgoto error\n+\t\t}\n+\t\thw = make(HardwareAddr, n)\n+\t\tfor x, i := 0, 0; i < n; i++ {\n+\t\t\tvar ok bool\n+\t\t\tif hw[i], ok = xtoi2(s[x:], s[2]); !ok {\n+\t\t\t\tgoto error\n+\t\t\t}\n+\t\t\tx += 3\n+\t\t}\n+\t} else if s[4] == '.' {\n+\t\tif (len(s)+1)%5 != 0 {\n+\t\t\tgoto error\n+\t\t}\n+\t\tn := 2 * (len(s) + 1) / 5\n+\t\tif n != 6 && n != 8 {\n+\t\t\tgoto error\n+\t\t}\n+\t\thw = make(HardwareAddr, n)\n+\t\tfor x, i := 0, 0; i < n; i += 2 {\n+\t\t\tvar ok bool\n+\t\t\tif hw[i], ok = xtoi2(s[x:x+2], 0); !ok {\n+\t\t\t\tgoto error\n+\t\t\t}\n+\t\t\tif hw[i+1], ok = xtoi2(s[x+2:], s[4]); !ok {\n+\t\t\t\tgoto error\n+\t\t\t}\n+\t\t\tx += 5\n+\t\t}\n+\t} else {\n+\t\tgoto error\n+\t}\n+\treturn hw, nil\n+\n+error:\n+\treturn nil, errors.New(\"invalid MAC address: \" + s)\n+}"}, {"sha": "3837e740cf98ab0fffe1a0e72dc6105674329402", "filename": "libgo/go/net/mac_test.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fmac_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fmac_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmac_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var mactests = []struct {\n+\tin  string\n+\tout HardwareAddr\n+\terr string\n+}{\n+\t{\"01:23:45:67:89:AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n+\t{\"01-23-45-67-89-AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n+\t{\"0123.4567.89AB\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab}, \"\"},\n+\t{\"ab:cd:ef:AB:CD:EF\", HardwareAddr{0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef}, \"\"},\n+\t{\"01.02.03.04.05.06\", nil, \"invalid MAC address\"},\n+\t{\"01:02:03:04:05:06:\", nil, \"invalid MAC address\"},\n+\t{\"x1:02:03:04:05:06\", nil, \"invalid MAC address\"},\n+\t{\"01002:03:04:05:06\", nil, \"invalid MAC address\"},\n+\t{\"01:02003:04:05:06\", nil, \"invalid MAC address\"},\n+\t{\"01:02:03004:05:06\", nil, \"invalid MAC address\"},\n+\t{\"01:02:03:04005:06\", nil, \"invalid MAC address\"},\n+\t{\"01:02:03:04:05006\", nil, \"invalid MAC address\"},\n+\t{\"01-02:03:04:05:06\", nil, \"invalid MAC address\"},\n+\t{\"01:02-03-04-05-06\", nil, \"invalid MAC address\"},\n+\t{\"0123:4567:89AF\", nil, \"invalid MAC address\"},\n+\t{\"0123-4567-89AF\", nil, \"invalid MAC address\"},\n+\t{\"01:23:45:67:89:AB:CD:EF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n+\t{\"01-23-45-67-89-AB-CD-EF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n+\t{\"0123.4567.89AB.CDEF\", HardwareAddr{1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef}, \"\"},\n+}\n+\n+func match(err error, s string) bool {\n+\tif s == \"\" {\n+\t\treturn err == nil\n+\t}\n+\treturn err != nil && strings.Contains(err.Error(), s)\n+}\n+\n+func TestParseMAC(t *testing.T) {\n+\tfor _, tt := range mactests {\n+\t\tout, err := ParseMAC(tt.in)\n+\t\tif !reflect.DeepEqual(out, tt.out) || !match(err, tt.err) {\n+\t\t\tt.Errorf(\"ParseMAC(%q) = %v, %v, want %v, %v\", tt.in, out, err, tt.out,\n+\t\t\t\ttt.err)\n+\t\t}\n+\t}\n+}"}, {"sha": "c1a90de0131b624b7d4b346934bfcba19f0e7fc9", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,130 +5,12 @@\n package net\n \n import (\n-\t\"flag\"\n \t\"io\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"testing\"\n \t\"time\"\n )\n \n-var runErrorTest = flag.Bool(\"run_error_test\", false, \"let TestDialError check for dns errors\")\n-\n-type DialErrorTest struct {\n-\tNet     string\n-\tRaddr   string\n-\tPattern string\n-}\n-\n-var dialErrorTests = []DialErrorTest{\n-\t{\n-\t\t\"datakit\", \"mh/astro/r70\",\n-\t\t\"dial datakit mh/astro/r70: unknown network datakit\",\n-\t},\n-\t{\n-\t\t\"tcp\", \"127.0.0.1:\u263a\",\n-\t\t\"dial tcp 127.0.0.1:\u263a: unknown port tcp/\u263a\",\n-\t},\n-\t{\n-\t\t\"tcp\", \"no-such-name.google.com.:80\",\n-\t\t\"dial tcp no-such-name.google.com.:80: lookup no-such-name.google.com.( on .*)?: no (.*)\",\n-\t},\n-\t{\n-\t\t\"tcp\", \"no-such-name.no-such-top-level-domain.:80\",\n-\t\t\"dial tcp no-such-name.no-such-top-level-domain.:80: lookup no-such-name.no-such-top-level-domain.( on .*)?: no (.*)\",\n-\t},\n-\t{\n-\t\t\"tcp\", \"no-such-name:80\",\n-\t\t`dial tcp no-such-name:80: lookup no-such-name\\.(.*\\.)?( on .*)?: no (.*)`,\n-\t},\n-\t{\n-\t\t\"tcp\", \"mh/astro/r70:http\",\n-\t\t\"dial tcp mh/astro/r70:http: lookup mh/astro/r70: invalid domain name\",\n-\t},\n-\t{\n-\t\t\"unix\", \"/etc/file-not-found\",\n-\t\t\"dial unix /etc/file-not-found: [nN]o such file or directory\",\n-\t},\n-\t{\n-\t\t\"unix\", \"/etc/\",\n-\t\t\"dial unix /etc/: ([pP]ermission denied|socket operation on non-socket|connection refused)\",\n-\t},\n-\t{\n-\t\t\"unixpacket\", \"/etc/file-not-found\",\n-\t\t\"dial unixpacket /etc/file-not-found: no such file or directory\",\n-\t},\n-\t{\n-\t\t\"unixpacket\", \"/etc/\",\n-\t\t\"dial unixpacket /etc/: (permission denied|socket operation on non-socket|connection refused)\",\n-\t},\n-}\n-\n-var duplicateErrorPattern = `dial (.*) dial (.*)`\n-\n-func TestDialError(t *testing.T) {\n-\tif !*runErrorTest {\n-\t\tt.Logf(\"test disabled; use --run_error_test to enable\")\n-\t\treturn\n-\t}\n-\tfor i, tt := range dialErrorTests {\n-\t\tc, err := Dial(tt.Net, tt.Raddr)\n-\t\tif c != nil {\n-\t\t\tc.Close()\n-\t\t}\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"#%d: nil error, want match for %#q\", i, tt.Pattern)\n-\t\t\tcontinue\n-\t\t}\n-\t\ts := err.Error()\n-\t\tmatch, _ := regexp.MatchString(tt.Pattern, s)\n-\t\tif !match {\n-\t\t\tt.Errorf(\"#%d: %q, want match for %#q\", i, s, tt.Pattern)\n-\t\t}\n-\t\tmatch, _ = regexp.MatchString(duplicateErrorPattern, s)\n-\t\tif match {\n-\t\t\tt.Errorf(\"#%d: %q, duplicate error return from Dial\", i, s)\n-\t\t}\n-\t}\n-}\n-\n-var revAddrTests = []struct {\n-\tAddr      string\n-\tReverse   string\n-\tErrPrefix string\n-}{\n-\t{\"1.2.3.4\", \"4.3.2.1.in-addr.arpa.\", \"\"},\n-\t{\"245.110.36.114\", \"114.36.110.245.in-addr.arpa.\", \"\"},\n-\t{\"::ffff:12.34.56.78\", \"78.56.34.12.in-addr.arpa.\", \"\"},\n-\t{\"::1\", \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.\", \"\"},\n-\t{\"1::\", \"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.0.0.0.ip6.arpa.\", \"\"},\n-\t{\"1234:567::89a:bcde\", \"e.d.c.b.a.9.8.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.7.6.5.0.4.3.2.1.ip6.arpa.\", \"\"},\n-\t{\"1234:567:fefe:bcbc:adad:9e4a:89a:bcde\", \"e.d.c.b.a.9.8.0.a.4.e.9.d.a.d.a.c.b.c.b.e.f.e.f.7.6.5.0.4.3.2.1.ip6.arpa.\", \"\"},\n-\t{\"1.2.3\", \"\", \"unrecognized address\"},\n-\t{\"1.2.3.4.5\", \"\", \"unrecognized address\"},\n-\t{\"1234:567:bcbca::89a:bcde\", \"\", \"unrecognized address\"},\n-\t{\"1234:567::bcbc:adad::89a:bcde\", \"\", \"unrecognized address\"},\n-}\n-\n-func TestReverseAddress(t *testing.T) {\n-\tfor i, tt := range revAddrTests {\n-\t\ta, err := reverseaddr(tt.Addr)\n-\t\tif len(tt.ErrPrefix) > 0 && err == nil {\n-\t\t\tt.Errorf(\"#%d: expected %q, got <nil> (error)\", i, tt.ErrPrefix)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif len(tt.ErrPrefix) == 0 && err != nil {\n-\t\t\tt.Errorf(\"#%d: expected <nil>, got %q (error)\", i, err)\n-\t\t}\n-\t\tif err != nil && err.(*DNSError).Err != tt.ErrPrefix {\n-\t\t\tt.Errorf(\"#%d: expected %q, got %q (mismatched error)\", i, tt.ErrPrefix, err.(*DNSError).Err)\n-\t\t}\n-\t\tif a != tt.Reverse {\n-\t\t\tt.Errorf(\"#%d: expected %q, got %q (reverse address)\", i, tt.Reverse, a)\n-\t\t}\n-\t}\n-}\n-\n func TestShutdown(t *testing.T) {\n \tif runtime.GOOS == \"plan9\" {\n \t\treturn"}, {"sha": "f7abf21f157f9089211ee92922a614e53b24b0a6", "filename": "libgo/go/net/rpc/client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -140,7 +140,7 @@ func (client *Client) input() {\n \t}\n \tclient.mutex.Unlock()\n \tclient.sending.Unlock()\n-\tif err != io.EOF || !closing {\n+\tif err != io.EOF && !closing {\n \t\tlog.Println(\"rpc: client protocol error:\", err)\n \t}\n }"}, {"sha": "1680e2f0d7086ed445ffc3374896d35917b37afe", "filename": "libgo/go/net/rpc/server.go", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -13,13 +13,19 @@\n \tOnly methods that satisfy these criteria will be made available for remote access;\n \tother methods will be ignored:\n \n-\t\t- the method name is exported, that is, begins with an upper case letter.\n-\t\t- the method receiver is exported or local (defined in the package\n-\t\t  registering the service).\n-\t\t- the method has two arguments, both exported or local types.\n+\t\t- the method is exported.\n+\t\t- the method has two arguments, both exported (or builtin) types.\n \t\t- the method's second argument is a pointer.\n \t\t- the method has return type error.\n \n+\tIn effect, the method must look schematically like\n+\n+\t\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n+\n+\twhere T, T1 and T2 can be marshaled by encoding/gob.\n+\tThese requirements apply even if a different codec is used.\n+\t(In future, these requirements may soften for custom codecs.)\n+\n \tThe method's first argument represents the arguments provided by the caller; the\n \tsecond argument represents the result parameters to be returned to the caller.\n \tThe method's return value, if non-nil, is passed back as a string that the client\n@@ -36,10 +42,12 @@\n \tcall, a pointer containing the arguments, and a pointer to receive the result\n \tparameters.\n \n-\tCall waits for the remote call to complete; Go launches the call asynchronously\n-\tand returns a channel that will signal completion.\n+\tThe Call method waits for the remote call to complete while the Go method\n+\tlaunches the call asynchronously and signals completion using the Call\n+\tstructure's Done channel.\n \n-\tPackage \"gob\" is used to transport the data.\n+\tUnless an explicit codec is set up, package encoding/gob is used to\n+\ttransport the data.\n \n \tHere is a simple example.  A server wishes to export an object of type Arith:\n \n@@ -256,6 +264,7 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) erro\n \t\tmethod := s.typ.Method(m)\n \t\tmtype := method.Type\n \t\tmname := method.Name\n+\t\t// Method must be exported.\n \t\tif method.PkgPath != \"\" {\n \t\t\tcontinue\n \t\t}\n@@ -267,7 +276,7 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) erro\n \t\t// First arg need not be a pointer.\n \t\targType := mtype.In(1)\n \t\tif !isExportedOrBuiltinType(argType) {\n-\t\t\tlog.Println(mname, \"argument type not exported or local:\", argType)\n+\t\t\tlog.Println(mname, \"argument type not exported:\", argType)\n \t\t\tcontinue\n \t\t}\n \t\t// Second arg must be a pointer.\n@@ -276,15 +285,17 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) erro\n \t\t\tlog.Println(\"method\", mname, \"reply type not a pointer:\", replyType)\n \t\t\tcontinue\n \t\t}\n+\t\t// Reply type must be exported.\n \t\tif !isExportedOrBuiltinType(replyType) {\n-\t\t\tlog.Println(\"method\", mname, \"reply type not exported or local:\", replyType)\n+\t\t\tlog.Println(\"method\", mname, \"reply type not exported:\", replyType)\n \t\t\tcontinue\n \t\t}\n-\t\t// Method needs one out: error.\n+\t\t// Method needs one out.\n \t\tif mtype.NumOut() != 1 {\n \t\t\tlog.Println(\"method\", mname, \"has wrong number of outs:\", mtype.NumOut())\n \t\t\tcontinue\n \t\t}\n+\t\t// The return type of the method must be error.\n \t\tif returnType := mtype.Out(0); returnType != typeOfError {\n \t\t\tlog.Println(\"method\", mname, \"returns\", returnType.String(), \"not error\")\n \t\t\tcontinue\n@@ -301,10 +312,10 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) erro\n \treturn nil\n }\n \n-// A value sent as a placeholder for the response when the server receives an invalid request.\n-type InvalidRequest struct{}\n-\n-var invalidRequest = InvalidRequest{}\n+// A value sent as a placeholder for the server's response value when the server\n+// receives an invalid request. It is never decoded by the client since the Response\n+// contains an error when it is used.\n+var invalidRequest = struct{}{}\n \n func (server *Server) sendResponse(sending *sync.Mutex, req *Request, reply interface{}, codec ServerCodec, errmsg string) {\n \tresp := server.getResponse()"}, {"sha": "446d92aa343ae9fdb2d9d26bc47036ac1713fdcf", "filename": "libgo/go/net/sockoptip_netbsd.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fsockoptip_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fsockoptip_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_netbsd.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for NetBSD\n+\n+package net\n+\n+import \"syscall\"\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\t// TODO: Implement this\n+\treturn nil, syscall.EAFNOSUPPORT\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\t// TODO: Implement this\n+\treturn syscall.EAFNOSUPPORT\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\t// TODO: Implement this\n+\treturn false, syscall.EAFNOSUPPORT\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\t// TODO: Implement this\n+\treturn syscall.EAFNOSUPPORT\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\t// TODO: Implement this\n+\treturn false, syscall.EAFNOSUPPORT\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\t// TODO: Implement this\n+\treturn syscall.EAFNOSUPPORT\n+}"}, {"sha": "ef350f0f946f99fad4c4a996a8cc703ff3507f1f", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -40,7 +40,7 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n \t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s did not return 0, timeout: %v, %v\", what, network, addr, n, err1)\n \t\t\treturn\n \t\t}\n-\t\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || dt > 250*time.Millisecond {\n+\t\tif dt := t1.Sub(t0); dt < 50*time.Millisecond || !testing.Short() && dt > 250*time.Millisecond {\n \t\t\terrc <- fmt.Errorf(\"fd.%s on %s %s took %s, expected 0.1s\", what, network, addr, dt)\n \t\t\treturn\n \t\t}"}, {"sha": "ea5fad41a53197ded90b6593c6e94920fbf2d180", "filename": "libgo/go/net/udp_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fudp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fnet%2Fudp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudp_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -38,18 +38,18 @@ func testWriteToConn(t *testing.T, raddr string) {\n \n \t_, err = c.(*UDPConn).WriteToUDP([]byte(\"Connection-oriented mode socket\"), ra)\n \tif err == nil {\n-\t\tt.Fatal(\"WriteToUDP should be failed\")\n+\t\tt.Fatal(\"WriteToUDP should fail\")\n \t}\n \tif err != nil && err.(*OpError).Err != ErrWriteToConnected {\n-\t\tt.Fatalf(\"WriteToUDP should be failed as ErrWriteToConnected: %v\", err)\n+\t\tt.Fatalf(\"WriteToUDP should fail as ErrWriteToConnected: %v\", err)\n \t}\n \n \t_, err = c.(*UDPConn).WriteTo([]byte(\"Connection-oriented mode socket\"), ra)\n \tif err == nil {\n-\t\tt.Fatal(\"WriteTo should be failed\")\n+\t\tt.Fatal(\"WriteTo should fail\")\n \t}\n \tif err != nil && err.(*OpError).Err != ErrWriteToConnected {\n-\t\tt.Fatalf(\"WriteTo should be failed as ErrWriteToConnected: %v\", err)\n+\t\tt.Fatalf(\"WriteTo should fail as ErrWriteToConnected: %v\", err)\n \t}\n \n \t_, err = c.Write([]byte(\"Connection-oriented mode socket\"))\n@@ -82,6 +82,6 @@ func testWriteToPacketConn(t *testing.T, raddr string) {\n \n \t_, err = c.(*UDPConn).Write([]byte(\"Connection-less mode socket\"))\n \tif err == nil {\n-\t\tt.Fatal(\"Write should be failed\")\n+\t\tt.Fatal(\"Write should fail\")\n \t}\n }"}, {"sha": "6a531e0d74e4488fa47304062f695de9c24a86e0", "filename": "libgo/go/os/doc.go", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdoc.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -4,13 +4,85 @@\n \n package os\n \n+import \"time\"\n+\n // FindProcess looks for a running process by its pid.\n // The Process it returns can be used to obtain information\n // about the underlying operating system process.\n func FindProcess(pid int) (p *Process, err error) {\n \treturn findProcess(pid)\n }\n \n+// StartProcess starts a new process with the program, arguments and attributes\n+// specified by name, argv and attr.\n+//\n+// StartProcess is a low-level interface. The os/exec package provides\n+// higher-level interfaces.\n+//\n+// If there is an error, it will be of type *PathError.\n+func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {\n+\treturn startProcess(name, argv, attr)\n+}\n+\n+// Release releases any resources associated with the Process p,\n+// rendering it unusable in the future.\n+// Release only needs to be called if Wait is not.\n+func (p *Process) Release() error {\n+\treturn p.release()\n+}\n+\n+// Kill causes the Process to exit immediately.\n+func (p *Process) Kill() error {\n+\treturn p.kill()\n+}\n+\n+// Wait waits for the Process to exit, and then returns a\n+// ProcessState describing its status and an error, if any.\n+// Wait releases any resources associated with the Process.\n+func (p *Process) Wait() (*ProcessState, error) {\n+\treturn p.wait()\n+}\n+\n+// Signal sends a signal to the Process.\n+func (p *Process) Signal(sig Signal) error {\n+\treturn p.signal(sig)\n+}\n+\n+// UserTime returns the user CPU time of the exited process and its children.\n+func (p *ProcessState) UserTime() time.Duration {\n+\treturn p.userTime()\n+}\n+\n+// SystemTime returns the system CPU time of the exited process and its children.\n+func (p *ProcessState) SystemTime() time.Duration {\n+\treturn p.systemTime()\n+}\n+\n+// Exited returns whether the program has exited.\n+func (p *ProcessState) Exited() bool {\n+\treturn p.exited()\n+}\n+\n+// Success reports whether the program exited successfully,\n+// such as with exit status 0 on Unix.\n+func (p *ProcessState) Success() bool {\n+\treturn p.success()\n+}\n+\n+// Sys returns system-dependent exit information about\n+// the process.  Convert it to the appropriate underlying\n+// type, such as syscall.WaitStatus on Unix, to access its contents.\n+func (p *ProcessState) Sys() interface{} {\n+\treturn p.sys()\n+}\n+\n+// SysUsage returns system-dependent resource usage information about\n+// the exited process.  Convert it to the appropriate underlying\n+// type, such as *syscall.Rusage on Unix, to access its contents.\n+func (p *ProcessState) SysUsage() interface{} {\n+\treturn p.sysUsage()\n+}\n+\n // Hostname returns the host name reported by the kernel.\n func Hostname() (name string, err error) {\n \treturn hostname()"}, {"sha": "531b87ca55671a179e20a43f04af36899316fbda", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -13,7 +13,7 @@ import (\n type Process struct {\n \tPid    int\n \thandle uintptr\n-\tdone   bool // process has been successfuly waited on\n+\tdone   bool // process has been successfully waited on\n }\n \n func newProcess(pid int, handle uintptr) *Process {"}, {"sha": "41cc8c26f4ce7efd505887e606570f91b235c300", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -11,10 +11,7 @@ import (\n \t\"time\"\n )\n \n-// StartProcess starts a new process with the program, arguments and attributes\n-// specified by name, argv and attr.\n-// If there is an error, it will be of type *PathError.\n-func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n+func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n \tsysattr := &syscall.ProcAttr{\n \t\tDir: attr.Dir,\n \t\tEnv: attr.Env,\n@@ -40,7 +37,7 @@ func (note Plan9Note) String() string {\n \treturn string(note)\n }\n \n-func (p *Process) Signal(sig Signal) error {\n+func (p *Process) signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n@@ -54,8 +51,7 @@ func (p *Process) Signal(sig Signal) error {\n \treturn e\n }\n \n-// Kill causes the Process to exit immediately.\n-func (p *Process) Kill() error {\n+func (p *Process) kill() error {\n \tf, e := OpenFile(\"/proc/\"+itoa(p.Pid)+\"/ctl\", O_WRONLY, 0)\n \tif e != nil {\n \t\treturn NewSyscallError(\"kill\", e)\n@@ -65,9 +61,7 @@ func (p *Process) Kill() error {\n \treturn e\n }\n \n-// Wait waits for the Process to exit or stop, and then returns a\n-// ProcessState describing its status and an error, if any.\n-func (p *Process) Wait() (ps *ProcessState, err error) {\n+func (p *Process) wait() (ps *ProcessState, err error) {\n \tvar waitmsg syscall.Waitmsg\n \n \tif p.Pid == -1 {\n@@ -94,8 +88,7 @@ func (p *Process) Wait() (ps *ProcessState, err error) {\n \treturn ps, nil\n }\n \n-// Release releases any resources associated with the Process.\n-func (p *Process) Release() error {\n+func (p *Process) release() error {\n \t// NOOP for Plan 9.\n \tp.Pid = -1\n \t// no need for a finalizer anymore\n@@ -108,7 +101,7 @@ func findProcess(pid int) (p *Process, err error) {\n \treturn newProcess(pid, 0), nil\n }\n \n-// ProcessState stores information about process as reported by Wait.\n+// ProcessState stores information about a process, as reported by Wait.\n type ProcessState struct {\n \tpid    int              // The process's id.\n \tstatus *syscall.Waitmsg // System-dependent status info.\n@@ -119,40 +112,27 @@ func (p *ProcessState) Pid() int {\n \treturn p.pid\n }\n \n-// Exited returns whether the program has exited.\n-func (p *ProcessState) Exited() bool {\n+func (p *ProcessState) exited() bool {\n \treturn p.status.Exited()\n }\n \n-// Success reports whether the program exited successfully,\n-// such as with exit status 0 on Unix.\n-func (p *ProcessState) Success() bool {\n+func (p *ProcessState) success() bool {\n \treturn p.status.ExitStatus() == 0\n }\n \n-// Sys returns system-dependent exit information about\n-// the process.  Convert it to the appropriate underlying\n-// type, such as *syscall.Waitmsg on Plan 9, to access its contents.\n-func (p *ProcessState) Sys() interface{} {\n+func (p *ProcessState) sys() interface{} {\n \treturn p.status\n }\n \n-// SysUsage returns system-dependent resource usage information about\n-// the exited process.  Convert it to the appropriate underlying\n-// type, such as *syscall.Waitmsg on Plan 9, to access its contents.\n-func (p *ProcessState) SysUsage() interface{} {\n+func (p *ProcessState) sysUsage() interface{} {\n \treturn p.status\n }\n \n-// UserTime returns the user CPU time of the exited process and its children.\n-// It is always reported as 0 on Windows.\n-func (p *ProcessState) UserTime() time.Duration {\n+func (p *ProcessState) userTime() time.Duration {\n \treturn time.Duration(p.status.Time[0]) * time.Millisecond\n }\n \n-// SystemTime returns the system CPU time of the exited process and its children.\n-// It is always reported as 0 on Windows.\n-func (p *ProcessState) SystemTime() time.Duration {\n+func (p *ProcessState) systemTime() time.Duration {\n \treturn time.Duration(p.status.Time[1]) * time.Millisecond\n }\n "}, {"sha": "70351cfb313144951e30007343d2e4fa1dcaa518", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -10,14 +10,17 @@ import (\n \t\"syscall\"\n )\n \n-// StartProcess starts a new process with the program, arguments and attributes\n-// specified by name, argv and attr.\n-//\n-// StartProcess is a low-level interface. The os/exec package provides\n-// higher-level interfaces.\n-//\n-// If there is an error, it will be of type *PathError.\n-func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n+func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n+\t// Double-check existence of the directory we want\n+\t// to chdir into.  We can make the error clearer this way.\n+\tif attr != nil && attr.Dir != \"\" {\n+\t\tif _, err := Stat(attr.Dir); err != nil {\n+\t\t\tpe := err.(*PathError)\n+\t\t\tpe.Op = \"chdir\"\n+\t\t\treturn nil, pe\n+\t\t}\n+\t}\n+\n \tsysattr := &syscall.ProcAttr{\n \t\tDir: attr.Dir,\n \t\tEnv: attr.Env,\n@@ -37,12 +40,11 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \treturn newProcess(pid, h), nil\n }\n \n-// Kill causes the Process to exit immediately.\n-func (p *Process) Kill() error {\n+func (p *Process) kill() error {\n \treturn p.Signal(Kill)\n }\n \n-// ProcessState stores information about process as reported by Wait.\n+// ProcessState stores information about a process, as reported by Wait.\n type ProcessState struct {\n \tpid    int                // The process's id.\n \tstatus syscall.WaitStatus // System-dependent status info.\n@@ -54,28 +56,19 @@ func (p *ProcessState) Pid() int {\n \treturn p.pid\n }\n \n-// Exited returns whether the program has exited.\n-func (p *ProcessState) Exited() bool {\n+func (p *ProcessState) exited() bool {\n \treturn p.status.Exited()\n }\n \n-// Success reports whether the program exited successfully,\n-// such as with exit status 0 on Unix.\n-func (p *ProcessState) Success() bool {\n+func (p *ProcessState) success() bool {\n \treturn p.status.ExitStatus() == 0\n }\n \n-// Sys returns system-dependent exit information about\n-// the process.  Convert it to the appropriate underlying\n-// type, such as syscall.WaitStatus on Unix, to access its contents.\n-func (p *ProcessState) Sys() interface{} {\n+func (p *ProcessState) sys() interface{} {\n \treturn p.status\n }\n \n-// SysUsage returns system-dependent resource usage information about\n-// the exited process.  Convert it to the appropriate underlying\n-// type, such as *syscall.Rusage on Unix, to access its contents.\n-func (p *ProcessState) SysUsage() interface{} {\n+func (p *ProcessState) sysUsage() interface{} {\n \treturn p.rusage\n }\n "}, {"sha": "ecfe5353bc1f9ce84747ccb51f9b4ce944d39917", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -13,9 +13,7 @@ import (\n \t\"time\"\n )\n \n-// Wait waits for the Process to exit or stop, and then returns a\n-// ProcessState describing its status and an error, if any.\n-func (p *Process) Wait() (ps *ProcessState, err error) {\n+func (p *Process) wait() (ps *ProcessState, err error) {\n \tif p.Pid == -1 {\n \t\treturn nil, syscall.EINVAL\n \t}\n@@ -36,8 +34,7 @@ func (p *Process) Wait() (ps *ProcessState, err error) {\n \treturn ps, nil\n }\n \n-// Signal sends a signal to the Process.\n-func (p *Process) Signal(sig Signal) error {\n+func (p *Process) signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n@@ -51,8 +48,7 @@ func (p *Process) Signal(sig Signal) error {\n \treturn nil\n }\n \n-// Release releases any resources associated with the Process.\n-func (p *Process) Release() error {\n+func (p *Process) release() error {\n \t// NOOP for unix.\n \tp.Pid = -1\n \t// no need for a finalizer anymore\n@@ -65,12 +61,10 @@ func findProcess(pid int) (p *Process, err error) {\n \treturn newProcess(pid, 0), nil\n }\n \n-// UserTime returns the user CPU time of the exited process and its children.\n-func (p *ProcessState) UserTime() time.Duration {\n+func (p *ProcessState) userTime() time.Duration {\n \treturn time.Duration(p.rusage.Utime.Nano()) * time.Nanosecond\n }\n \n-// SystemTime returns the system CPU time of the exited process and its children.\n-func (p *ProcessState) SystemTime() time.Duration {\n+func (p *ProcessState) systemTime() time.Duration {\n \treturn time.Duration(p.rusage.Stime.Nano()) * time.Nanosecond\n }"}, {"sha": "5beca4a6509650c80f14b3f49d64e1d05e368aad", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -12,9 +12,7 @@ import (\n \t\"unsafe\"\n )\n \n-// Wait waits for the Process to exit or stop, and then returns a\n-// ProcessState describing its status and an error, if any.\n-func (p *Process) Wait() (ps *ProcessState, err error) {\n+func (p *Process) wait() (ps *ProcessState, err error) {\n \ts, e := syscall.WaitForSingleObject(syscall.Handle(p.handle), syscall.INFINITE)\n \tswitch s {\n \tcase syscall.WAIT_OBJECT_0:\n@@ -29,12 +27,22 @@ func (p *Process) Wait() (ps *ProcessState, err error) {\n \tif e != nil {\n \t\treturn nil, NewSyscallError(\"GetExitCodeProcess\", e)\n \t}\n+\tvar u syscall.Rusage\n+\te = syscall.GetProcessTimes(syscall.Handle(p.handle), &u.CreationTime, &u.ExitTime, &u.KernelTime, &u.UserTime)\n+\tif e != nil {\n+\t\treturn nil, NewSyscallError(\"GetProcessTimes\", e)\n+\t}\n \tp.done = true\n-\treturn &ProcessState{p.Pid, syscall.WaitStatus{Status: s, ExitCode: ec}, new(syscall.Rusage)}, nil\n+\t// NOTE(brainman): It seems that sometimes process is not dead\n+\t// when WaitForSingleObject returns. But we do not know any\n+\t// other way to wait for it. Sleeping for a while seems to do\n+\t// the trick sometimes. So we will sleep and smell the roses.\n+\tdefer time.Sleep(5 * time.Millisecond)\n+\tdefer p.Release()\n+\treturn &ProcessState{p.Pid, syscall.WaitStatus{ExitCode: ec}, &u}, nil\n }\n \n-// Signal sends a signal to the Process.\n-func (p *Process) Signal(sig Signal) error {\n+func (p *Process) signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n@@ -46,8 +54,7 @@ func (p *Process) Signal(sig Signal) error {\n \treturn syscall.Errno(syscall.EWINDOWS)\n }\n \n-// Release releases any resources associated with the Process.\n-func (p *Process) Release() error {\n+func (p *Process) release() error {\n \tif p.handle == uintptr(syscall.InvalidHandle) {\n \t\treturn syscall.EINVAL\n \t}\n@@ -85,14 +92,15 @@ func init() {\n \t}\n }\n \n-// UserTime returns the user CPU time of the exited process and its children.\n-// For now, it is always reported as 0 on Windows.\n-func (p *ProcessState) UserTime() time.Duration {\n-\treturn 0\n+func ftToDuration(ft *syscall.Filetime) time.Duration {\n+\tn := int64(ft.HighDateTime)<<32 + int64(ft.LowDateTime) // in 100-nanosecond intervals\n+\treturn time.Duration(n*100) * time.Nanosecond\n+}\n+\n+func (p *ProcessState) userTime() time.Duration {\n+\treturn ftToDuration(&p.rusage.UserTime)\n }\n \n-// SystemTime returns the system CPU time of the exited process and its children.\n-// For now, it is always reported as 0 on Windows.\n-func (p *ProcessState) SystemTime() time.Duration {\n-\treturn 0\n+func (p *ProcessState) systemTime() time.Duration {\n+\treturn ftToDuration(&p.rusage.KernelTime)\n }"}, {"sha": "4acf35d675508d62ff25e832acddbb67190ab774", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -25,7 +25,7 @@\n //\topen file.go: no such file or directory\n //\n // The file's data can then be read into a slice of bytes. Read and\n-// Write take their byte counts from the length of the artument slice.\n+// Write take their byte counts from the length of the argument slice.\n //\n //\tdata := make([]byte, 100)\n //\tcount, err := file.Read(data)"}, {"sha": "aa01669a5da43683635438448b9777655b7ca17e", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -528,7 +528,6 @@ func exec(t *testing.T, dir, cmd string, args []string, expect string) {\n \tif err != nil {\n \t\tt.Fatalf(\"StartProcess: %v\", err)\n \t}\n-\tdefer p.Release()\n \tw.Close()\n \n \tvar b bytes.Buffer\n@@ -846,7 +845,6 @@ func run(t *testing.T, cmd []string) string {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tdefer p.Release()\n \tw.Close()\n \n \tvar b bytes.Buffer\n@@ -1012,3 +1010,38 @@ func TestNilProcessStateString(t *testing.T) {\n \t\tt.Errorf(\"(*ProcessState)(nil).String() = %q, want %q\", s, \"<nil>\")\n \t}\n }\n+\n+func TestSameFile(t *testing.T) {\n+\tfa, err := Create(\"a\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Create(a): %v\", err)\n+\t}\n+\tdefer Remove(fa.Name())\n+\tfa.Close()\n+\tfb, err := Create(\"b\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Create(b): %v\", err)\n+\t}\n+\tdefer Remove(fb.Name())\n+\tfb.Close()\n+\n+\tia1, err := Stat(\"a\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat(a): %v\", err)\n+\t}\n+\tia2, err := Stat(\"a\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat(a): %v\", err)\n+\t}\n+\tif !SameFile(ia1, ia2) {\n+\t\tt.Errorf(\"files should be same\")\n+\t}\n+\n+\tib, err := Stat(\"b\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat(b): %v\", err)\n+\t}\n+\tif SameFile(ia1, ib) {\n+\t\tt.Errorf(\"files should be different\")\n+\t}\n+}"}, {"sha": "cfe46981f131255bd5d8f9f347772d385e2a533e", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -139,6 +139,7 @@ func FromSlash(path string) string {\n \n // SplitList splits a list of paths joined by the OS-specific ListSeparator,\n // usually found in PATH or GOPATH environment variables.\n+// Unlike strings.Split, SplitList returns an empty slice when passed an empty string.\n func SplitList(path string) []string {\n \tif path == \"\" {\n \t\treturn []string{}"}, {"sha": "cf028a75c525e2495cb081590863dbc9c47d3444", "filename": "libgo/go/path/filepath/path_plan9.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -17,7 +17,7 @@ func VolumeName(path string) string {\n \treturn \"\"\n }\n \n-// HasPrefix tests whether the path p begins with prefix.\n+// HasPrefix exists for historical compatibility and should not be used.\n func HasPrefix(p, prefix string) bool {\n \treturn strings.HasPrefix(p, prefix)\n }"}, {"sha": "305e307272f8b7a831f6291b0370d96d31a1c964", "filename": "libgo/go/path/filepath/path_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -19,7 +19,7 @@ func VolumeName(path string) string {\n \treturn \"\"\n }\n \n-// HasPrefix tests whether the path p begins with prefix.\n+// HasPrefix exists for historical compatibility and should not be used.\n func HasPrefix(p, prefix string) bool {\n \treturn strings.HasPrefix(p, prefix)\n }"}, {"sha": "1d1d23bfe7ccd8ff22f186e8babcc8a747794f3d", "filename": "libgo/go/path/filepath/path_windows.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -67,8 +67,7 @@ func VolumeName(path string) (v string) {\n \treturn \"\"\n }\n \n-// HasPrefix tests whether the path p begins with prefix.\n-// It ignores case while comparing.\n+// HasPrefix exists for historical compatibility and should not be used.\n func HasPrefix(p, prefix string) bool {\n \tif strings.HasPrefix(p, prefix) {\n \t\treturn true"}, {"sha": "56744a514bc2b01b6823fe477efd1fabe70695b7", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -629,6 +629,13 @@ type DeepEqualTest struct {\n \teq   bool\n }\n \n+// Simple functions for DeepEqual tests.\n+var (\n+\tfn1 func()             // nil.\n+\tfn2 func()             // nil.\n+\tfn3 = func() { fn1() } // Not nil.\n+)\n+\n var deepEqualTests = []DeepEqualTest{\n \t// Equalities\n \t{1, 1, true},\n@@ -641,6 +648,7 @@ var deepEqualTests = []DeepEqualTest{\n \t{Basic{1, 0.5}, Basic{1, 0.5}, true},\n \t{error(nil), error(nil), true},\n \t{map[int]string{1: \"one\", 2: \"two\"}, map[int]string{2: \"two\", 1: \"one\"}, true},\n+\t{fn1, fn2, true},\n \n \t// Inequalities\n \t{1, 2, false},\n@@ -658,6 +666,8 @@ var deepEqualTests = []DeepEqualTest{\n \t{map[int]string{2: \"two\", 1: \"one\"}, map[int]string{1: \"one\"}, false},\n \t{nil, 1, false},\n \t{1, nil, false},\n+\t{fn1, fn3, false},\n+\t{fn3, fn3, false},\n \n \t// Nil vs empty: not the same.\n \t{[]int{}, []int(nil), false},\n@@ -1737,3 +1747,15 @@ func isValid(v Value) {\n \t\tpanic(\"zero Value\")\n \t}\n }\n+\n+func TestAlias(t *testing.T) {\n+\tx := string(\"hello\")\n+\tv := ValueOf(&x).Elem()\n+\toldvalue := v.Interface()\n+\tv.SetString(\"world\")\n+\tnewvalue := v.Interface()\n+\n+\tif oldvalue != \"hello\" || newvalue != \"world\" {\n+\t\tt.Errorf(\"aliasing: old=%q new=%q, want hello, world\", oldvalue, newvalue)\n+\t}\n+}"}, {"sha": "c12e90f36ccc229b5ad29d6bcabcf70ce1060442", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -108,6 +108,12 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool\n \t\t\t}\n \t\t}\n \t\treturn true\n+\tcase Func:\n+\t\tif v1.IsNil() && v2.IsNil() {\n+\t\t\treturn true\n+\t\t}\n+\t\t// Can't do better than this:\n+\t\treturn false\n \tdefault:\n \t\t// Normal equality suffices\n \t\treturn valueInterface(v1, false) == valueInterface(v2, false)\n@@ -117,8 +123,8 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool\n }\n \n // DeepEqual tests for deep equality. It uses normal == equality where possible\n-// but will scan members of arrays, slices, and fields of structs. It correctly\n-// handles recursive types.\n+// but will scan members of arrays, slices, maps, and fields of structs. It correctly\n+// handles recursive types. Functions are equal only if they are both nil.\n func DeepEqual(a1, a2 interface{}) bool {\n \tif a1 == nil || a2 == nil {\n \t\treturn a1 == a2"}, {"sha": "b1dd0a1fecd26fd25abcda2ddf71fce695c9dfe7", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -12,7 +12,7 @@\n // for that type.\n //\n // See \"The Laws of Reflection\" for an introduction to reflection in Go:\n-// http://blog.golang.org/2011/09/laws-of-reflection.html\n+// http://golang.org/doc/articles/laws_of_reflection.html\n package reflect\n \n import ("}, {"sha": "b490e99f4091f307730efd7f7dc4308ad93a4e28", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -792,13 +792,15 @@ func (v Value) CanInterface() bool {\n \treturn v.flag&(flagMethod|flagRO) == 0\n }\n \n-// Interface returns v's value as an interface{}.\n+// Interface returns v's current value as an interface{}.\n+// It is equivalent to:\n+//\tvar i interface{} = (v's underlying value)\n // If v is a method obtained by invoking Value.Method\n // (as opposed to Type.Method), Interface cannot return an\n // interface value, so it panics.\n // It also panics if the Value was obtained by accessing\n // unexported struct fields.\n-func (v Value) Interface() interface{} {\n+func (v Value) Interface() (i interface{}) {\n \treturn valueInterface(v, true)\n }\n \n@@ -834,6 +836,16 @@ func valueInterface(v Value, safe bool) interface{} {\n \tvar eface emptyInterface\n \teface.typ = v.typ.runtimeType()\n \teface.word = v.iword()\n+\n+\tif v.flag&flagIndir != 0 && v.typ.size > ptrSize {\n+\t\t// eface.word is a pointer to the actual data,\n+\t\t// which might be changed.  We need to return\n+\t\t// a pointer to unchanging data, so make a copy.\n+\t\tptr := unsafe_New(v.typ)\n+\t\tmemmove(ptr, unsafe.Pointer(eface.word), v.typ.size)\n+\t\teface.word = iword(ptr)\n+\t}\n+\n \treturn *(*interface{})(unsafe.Pointer(&eface))\n }\n "}, {"sha": "f67e8a8f9aef882524c35f7517c7f1b6ec816934", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -20,8 +20,8 @@ import (\n \t\"text/tabwriter\"\n )\n \n-// BUG(rsc): CPU profiling is broken on OS X, due to an Apple kernel bug.\n-// For details, see http://code.google.com/p/go/source/detail?r=35b716c94225.\n+// BUG(rsc): A bug in the OS X Snow Leopard 64-bit kernel prevents\n+// CPU profiling from giving accurate results on that system.\n \n // A Profile is a collection of stack traces showing the call sequences\n // that led to instances of a particular event, such as allocation.\n@@ -156,7 +156,7 @@ func (p *Profile) Count() int {\n }\n \n // Add adds the current execution stack to the profile, associated with value.\n-// Add stores value in an internal map, so value must be suitable for use as \n+// Add stores value in an internal map, so value must be suitable for use as\n // a map key and will not be garbage collected until the corresponding\n // call to Remove.  Add panics if the profile already contains a stack for value.\n //"}, {"sha": "2dc7aef7e96bbdaba4e3af60aa8ceba75b385874", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -7,6 +7,7 @@ package pprof_test\n import (\n \t\"bytes\"\n \t\"hash/crc32\"\n+\t\"os/exec\"\n \t\"runtime\"\n \t. \"runtime/pprof\"\n \t\"strings\"\n@@ -17,8 +18,16 @@ import (\n func TestCPUProfile(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"darwin\":\n-\t\t// see Apple Bug Report #9177434 (copied into change description)\n-\t\treturn\n+\t\tout, err := exec.Command(\"uname\", \"-a\").CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tvers := string(out)\n+\t\tt.Logf(\"uname -a: %v\", vers)\n+\t\tif strings.Contains(vers, \"Darwin Kernel Version 10.8.0\") && strings.Contains(vers, \"root:xnu-1504.15.3~1/RELEASE_X86_64\") {\n+\t\t\tt.Logf(\"skipping test on known-broken kernel (64-bit Snow Leopard)\")\n+\t\t\treturn\n+\t\t}\n \tcase \"plan9\":\n \t\t// unimplemented\n \t\treturn"}, {"sha": "aa5e5607ca0b94c795ddeaff0e21f7c9faa76160", "filename": "libgo/go/strconv/extfloat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fextfloat.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -477,7 +477,7 @@ func (f *extFloat) ShortestDecimal(d *decimal, lower, upper *extFloat) bool {\n // all data is known with a error estimate of ulpBinary*\u03b5.\n func adjustLastDigit(d *decimal, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary uint64) bool {\n \tif ulpDecimal < 2*ulpBinary {\n-\t\t// Appromixation is too wide.\n+\t\t// Approximation is too wide.\n \t\treturn false\n \t}\n \tfor currentDiff+ulpDecimal/2+ulpBinary < targetDiff {"}, {"sha": "daeb85ef6bbf2878d6dc803072999451fcf0ea8f", "filename": "libgo/go/strings/example_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -41,6 +41,7 @@ func ExampleContainsAny() {\n func ExampleCount() {\n \tfmt.Println(strings.Count(\"cheese\", \"e\"))\n \tfmt.Println(strings.Count(\"five\", \"\")) // before & after each rune\n+\n \t// Output:\n \t// 3\n \t// 5"}, {"sha": "15649240035718d5130a7ee5aecf8028058e5d03", "filename": "libgo/go/sync/example_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsync%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsync%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fexample_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -5,6 +5,7 @@\n package sync_test\n \n import (\n+\t\"fmt\"\n \t\"net/http\"\n \t\"sync\"\n )\n@@ -32,3 +33,22 @@ func ExampleWaitGroup() {\n \t// Wait for all HTTP fetches to complete.\n \twg.Wait()\n }\n+\n+func ExampleOnce() {\n+\tvar once sync.Once\n+\tonceBody := func() {\n+\t\tfmt.Printf(\"Only once\\n\")\n+\t}\n+\tdone := make(chan bool)\n+\tfor i := 0; i < 10; i++ {\n+\t\tgo func() {\n+\t\t\tonce.Do(onceBody)\n+\t\t\tdone <- true\n+\t\t}()\n+\t}\n+\tfor i := 0; i < 10; i++ {\n+\t\t<-done\n+\t}\n+\t// Output:\n+\t// Only once\n+}"}, {"sha": "0165b1ffb2b4563f7abd6a00c4b3838d5d646bad", "filename": "libgo/go/sync/waitgroup.go", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -11,21 +11,6 @@ import \"sync/atomic\"\n // goroutines to wait for.  Then each of the goroutines\n // runs and calls Done when finished.  At the same time,\n // Wait can be used to block until all goroutines have finished.\n-//\n-// For example:\n-//\n-//   for i := 0; i < n; i++ {\n-//       if !condition(i) {\n-//           continue\n-//       }\n-//       wg.Add(1)\n-//       go func() {\n-//           // Do something.\n-//           wg.Done()\n-//       }()\n-//   }\n-//   wg.Wait()\n-// \n type WaitGroup struct {\n \tm       Mutex\n \tcounter int32"}, {"sha": "6d36e3985f36b9f7b481a052a8d6c41dd12113f5", "filename": "libgo/go/syscall/socket.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsyscall%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Fsyscall%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -217,6 +217,13 @@ func Socketpair(domain, typ, proto int) (fd [2]int, err error) {\n //sys\tgetsockopt(s int, level int, name int, val uintptr, vallen *Socklen_t) (err error)\n //getsockopt(s int, level int, name int, val *byte, vallen *Socklen_t) int\n \n+func GetsockoptByte(fd, level, opt int) (value byte, err error) {\n+\tvar n byte\n+\tvallen := Socklen_t(1)\n+\terr = getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&n)), &vallen)\n+\treturn n, err\n+}\n+\n func GetsockoptInt(fd, level, opt int) (value int, err error) {\n \tvar n int32\n \tvallen := Socklen_t(4)\n@@ -254,6 +261,11 @@ func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) {\n //sys\tsetsockopt(s int, level int, name int, val *byte, vallen Socklen_t) (err error)\n //setsockopt(s int, level int, optname int, val *byte, vallen Socklen_t) int\n \n+func SetsockoptByte(fd, level, opt int, value byte) (err error) {\n+\tvar n = byte(value)\n+\treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), 1)\n+}\n+\n func SetsockoptInt(fd, level, opt int, value int) (err error) {\n \tvar n = int32(value)\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), 4)"}, {"sha": "671c798760bafb3a0f121aec74445ffb5699740a", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -19,14 +19,22 @@ type InternalExample struct {\n \tOutput string\n }\n \n-func RunExamples(examples []InternalExample) (ok bool) {\n+func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool) {\n \tok = true\n \n \tvar eg InternalExample\n \n \tstdout, stderr := os.Stdout, os.Stderr\n \n \tfor _, eg = range examples {\n+\t\tmatched, err := matchString(*match, eg.Name)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid regexp for -test.run: %s\\n\", err)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tif !matched {\n+\t\t\tcontinue\n+\t\t}\n \t\tif *chatty {\n \t\t\tfmt.Printf(\"=== RUN: %s\\n\", eg.Name)\n \t\t}"}, {"sha": "477d2ac23aef0fea15dcbea398c16d8744926682", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -99,7 +99,7 @@ var (\n \n \t// Report as tests are run; default is silent for success.\n \tchatty         = flag.Bool(\"test.v\", false, \"verbose: print additional output\")\n-\tmatch          = flag.String(\"test.run\", \"\", \"regular expression to select tests to run\")\n+\tmatch          = flag.String(\"test.run\", \"\", \"regular expression to select tests and examples to run\")\n \tmemProfile     = flag.String(\"test.memprofile\", \"\", \"write a memory profile to the named file after execution\")\n \tmemProfileRate = flag.Int(\"test.memprofilerate\", 0, \"if >=0, sets runtime.MemProfileRate\")\n \tcpuProfile     = flag.String(\"test.cpuprofile\", \"\", \"write a cpu profile to the named file during execution\")\n@@ -280,7 +280,7 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n \tbefore()\n \tstartAlarm()\n \ttestOk := RunTests(matchString, tests)\n-\texampleOk := RunExamples(examples)\n+\texampleOk := RunExamples(matchString, examples)\n \tif !testOk || !exampleOk {\n \t\tfmt.Println(\"FAIL\")\n \t\tos.Exit(1)"}, {"sha": "10e0f7fc373b969bdfec14bbb904ed1f3a35e113", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -142,11 +142,6 @@ An argument is a simple value, denoted by one of the following.\n \t    .Field1.Key1.Method1.Field2.Key2.Method2\n \t  Methods can also be evaluated on variables, including chaining:\n \t    $x.Method1.Field\n-\t- The name of a niladic function-valued struct field of the data,\n-\t  preceded by a period, such as\n-\t\t.Function\n-\t  Function-valued fields behave like methods (of structs) but do not\n-\t  pass a receiver.\n \t- The name of a niladic function, such as\n \t\tfun\n \t  The result is the value of invoking the function, fun(). The return\n@@ -155,6 +150,10 @@ An argument is a simple value, denoted by one of the following.\n \n Arguments may evaluate to any type; if they are pointers the implementation\n automatically indirects to the base type when required.\n+If an evaluation yields a function value, such as a function-valued\n+field of a struct, the function is not invoked automatically, but it\n+can be used as a truth value for an if action and the like. To invoke\n+it, use the call function, defined below.\n \n A pipeline is a possibly chained sequence of \"commands\". A command is a simple\n value (argument) or a function or method call, possibly with multiple arguments:\n@@ -167,9 +166,6 @@ value (argument) or a function or method call, possibly with multiple arguments:\n \t\tThe result is the value of calling the method with the\n \t\targuments:\n \t\t\tdot.Method(Argument1, etc.)\n-\t.Function [Argument...]\n-\t\tA function-valued field of a struct works like a method but does\n-\t\tnot pass the receiver.\n \tfunctionName [Argument...]\n \t\tThe result is the value of calling the function associated\n \t\twith the name:\n@@ -257,6 +253,17 @@ Predefined global functions are named as follows.\n \t\tfirst empty argument or the last argument, that is,\n \t\t\"and x y\" behaves as \"if x then y else x\". All the\n \t\targuments are evaluated.\n+\tcall\n+\t\tReturns the result of calling the first argument, which\n+\t\tmust be a function, with the remaining arguments as parameters.\n+\t\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n+\t\tY is a func-valued field, map entry, or the like.\n+\t\tThe first argument must be the result of an evaluation\n+\t\tthat yields a value of function type (as distinct from\n+\t\ta predefined function such as print). The function must\n+\t\treturn either one or two result values, the second of which\n+\t\tis of type error. If the arguments don't match the function\n+\t\tor the returned error value is non-nil, execution stops.\n \thtml\n \t\tReturns the escaped HTML equivalent of the textual\n \t\trepresentation of its arguments."}, {"sha": "ad0118e4e6821a16890552dc5759325a9c4295b2", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -421,11 +421,8 @@ func (s *state) evalField(dot reflect.Value, fieldName string, args []parse.Node\n \t\t\tfield := receiver.FieldByIndex(tField.Index)\n \t\t\tif tField.PkgPath == \"\" { // field is exported\n \t\t\t\t// If it's a function, we must call it.\n-\t\t\t\tif field.Type().Kind() == reflect.Func {\n-\t\t\t\t\treturn s.evalCall(dot, field, fieldName, args, final)\n-\t\t\t\t}\n \t\t\t\tif hasArgs {\n-\t\t\t\t\ts.errorf(\"%s is not a method or function but has arguments\", fieldName)\n+\t\t\t\t\ts.errorf(\"%s has arguments but cannot be invoked as function\", fieldName)\n \t\t\t\t}\n \t\t\t\treturn field\n \t\t\t}"}, {"sha": "70ab39cad20b20900413acc5de3045d492ae8364", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -60,7 +60,9 @@ type T struct {\n \tPSI *[]int\n \tNIL *int\n \t// Function (not method)\n-\tFunc func(...string) string\n+\tBinaryFunc      func(string, string) string\n+\tVariadicFunc    func(...string) string\n+\tVariadicFuncInt func(int, ...string) string\n \t// Template to test evaluation of templates.\n \tTmpl *Template\n }\n@@ -120,7 +122,9 @@ var tVal = &T{\n \tErr:               errors.New(\"erroozle\"),\n \tPI:                newInt(23),\n \tPSI:               newIntSlice(21, 22, 23),\n-\tFunc:              func(s ...string) string { return fmt.Sprint(\"<\", strings.Join(s, \"+\"), \">\") },\n+\tBinaryFunc:        func(a, b string) string { return fmt.Sprintf(\"[%s=%s]\", a, b) },\n+\tVariadicFunc:      func(s ...string) string { return fmt.Sprint(\"<\", strings.Join(s, \"+\"), \">\") },\n+\tVariadicFuncInt:   func(a int, s ...string) string { return fmt.Sprint(a, \"=<\", strings.Join(s, \"+\"), \">\") },\n \tTmpl:              Must(New(\"x\").Parse(\"test template\")), // \"x\" is the value of .X\n }\n \n@@ -300,13 +304,26 @@ var execTests = []execTest{\n \t\t\"{{with $x := .}}{{with .SI}}{{$.GetU.TrueFalse $.True}}{{end}}{{end}}\",\n \t\t\"true\", tVal, true},\n \n-\t// Function call\n-\t{\".Func\", \"-{{.Func}}-\", \"-<>-\", tVal, true},\n-\t{\".Func2\", \"-{{.Func `he` `llo`}}-\", \"-<he+llo>-\", tVal, true},\n+\t// Function call builtin.\n+\t{\".BinaryFunc\", \"{{call .BinaryFunc `1` `2`}}\", \"[1=2]\", tVal, true},\n+\t{\".VariadicFunc0\", \"{{call .VariadicFunc}}\", \"<>\", tVal, true},\n+\t{\".VariadicFunc2\", \"{{call .VariadicFunc `he` `llo`}}\", \"<he+llo>\", tVal, true},\n+\t{\".VariadicFuncInt\", \"{{call .VariadicFuncInt 33 `he` `llo`}}\", \"33=<he+llo>\", tVal, true},\n+\t{\"if .BinaryFunc call\", \"{{ if .BinaryFunc}}{{call .BinaryFunc `1` `2`}}{{end}}\", \"[1=2]\", tVal, true},\n+\t{\"if not .BinaryFunc call\", \"{{ if not .BinaryFunc}}{{call .BinaryFunc `1` `2`}}{{else}}No{{end}}\", \"No\", tVal, true},\n+\n+\t// Erroneous function calls (check args).\n+\t{\".BinaryFuncTooFew\", \"{{call .BinaryFunc `1`}}\", \"\", tVal, false},\n+\t{\".BinaryFuncTooMany\", \"{{call .BinaryFunc `1` `2` `3`}}\", \"\", tVal, false},\n+\t{\".BinaryFuncBad0\", \"{{call .BinaryFunc 1 3}}\", \"\", tVal, false},\n+\t{\".BinaryFuncBad1\", \"{{call .BinaryFunc `1` 3}}\", \"\", tVal, false},\n+\t{\".VariadicFuncBad0\", \"{{call .VariadicFunc 3}}\", \"\", tVal, false},\n+\t{\".VariadicFuncIntBad0\", \"{{call .VariadicFuncInt}}\", \"\", tVal, false},\n+\t{\".VariadicFuncIntBad`\", \"{{call .VariadicFuncInt `x`}}\", \"\", tVal, false},\n \n \t// Pipelines.\n \t{\"pipeline\", \"-{{.Method0 | .Method2 .U16}}-\", \"-Method2: 16 M0-\", tVal, true},\n-\t{\"pipeline func\", \"-{{.Func `llo` | .Func `he` }}-\", \"-<he+<llo>>-\", tVal, true},\n+\t{\"pipeline func\", \"-{{call .VariadicFunc `llo` | call .VariadicFunc `he` }}-\", \"-<he+<llo>>-\", tVal, true},\n \n \t// If.\n \t{\"if true\", \"{{if true}}TRUE{{end}}\", \"TRUE\", tVal, true},"}, {"sha": "525179cb499839a8a0e853d94e3dfe9b5bf3871f", "filename": "libgo/go/text/template/funcs.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -24,6 +24,7 @@ type FuncMap map[string]interface{}\n \n var builtins = FuncMap{\n \t\"and\":      and,\n+\t\"call\":     call,\n \t\"html\":     HTMLEscaper,\n \t\"index\":    index,\n \t\"js\":       JSEscaper,\n@@ -151,6 +152,53 @@ func length(item interface{}) (int, error) {\n \treturn 0, fmt.Errorf(\"len of type %s\", v.Type())\n }\n \n+// Function invocation\n+\n+// call returns the result of evaluating the the first argument as a function.\n+// The function must return 1 result, or 2 results, the second of which is an error.\n+func call(fn interface{}, args ...interface{}) (interface{}, error) {\n+\tv := reflect.ValueOf(fn)\n+\ttyp := v.Type()\n+\tif typ.Kind() != reflect.Func {\n+\t\treturn nil, fmt.Errorf(\"non-function of type %s\", typ)\n+\t}\n+\tif !goodFunc(typ) {\n+\t\treturn nil, fmt.Errorf(\"function called with %d args; should be 1 or 2\", typ.NumOut())\n+\t}\n+\tnumIn := typ.NumIn()\n+\tvar dddType reflect.Type\n+\tif typ.IsVariadic() {\n+\t\tif len(args) < numIn-1 {\n+\t\t\treturn nil, fmt.Errorf(\"wrong number of args: got %d want at least %d\", len(args), numIn-1)\n+\t\t}\n+\t\tdddType = typ.In(numIn - 1).Elem()\n+\t} else {\n+\t\tif len(args) != numIn {\n+\t\t\treturn nil, fmt.Errorf(\"wrong number of args: got %d want %d\", len(args), numIn)\n+\t\t}\n+\t}\n+\targv := make([]reflect.Value, len(args))\n+\tfor i, arg := range args {\n+\t\tvalue := reflect.ValueOf(arg)\n+\t\t// Compute the expected type. Clumsy because of variadics.\n+\t\tvar argType reflect.Type\n+\t\tif !typ.IsVariadic() || i < numIn-1 {\n+\t\t\targType = typ.In(i)\n+\t\t} else {\n+\t\t\targType = dddType\n+\t\t}\n+\t\tif !value.Type().AssignableTo(argType) {\n+\t\t\treturn nil, fmt.Errorf(\"arg %d has type %s; should be %s\", i, value.Type(), argType)\n+\t\t}\n+\t\targv[i] = reflect.ValueOf(arg)\n+\t}\n+\tresult := v.Call(argv)\n+\tif len(result) == 2 {\n+\t\treturn result[0].Interface(), result[1].Interface().(error)\n+\t}\n+\treturn result[0].Interface(), nil\n+}\n+\n // Boolean logic.\n \n func truth(a interface{}) bool {"}, {"sha": "22dedc4f83939777345765418fc0ef22e1db00a3", "filename": "libgo/go/text/template/multi_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fmulti_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -265,6 +265,12 @@ func TestRedefinition(t *testing.T) {\n \tif tmpl, err = New(\"tmpl1\").Parse(`{{define \"test\"}}foo{{end}}`); err != nil {\n \t\tt.Fatalf(\"parse 1: %v\", err)\n \t}\n+\tif _, err = tmpl.Parse(`{{define \"test\"}}bar{{end}}`); err == nil {\n+\t\tt.Fatal(\"expected error\")\n+\t}\n+\tif !strings.Contains(err.Error(), \"redefinition\") {\n+\t\tt.Fatalf(\"expected redefinition error; got %v\", err)\n+\t}\n \tif _, err = tmpl.New(\"tmpl2\").Parse(`{{define \"test\"}}bar{{end}}`); err == nil {\n \t\tt.Fatal(\"expected error\")\n \t}"}, {"sha": "d67b3888085cfee4dbe119f870a0ed32d2c30dbe", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -193,6 +193,8 @@ func (t *Tree) add(treeSet map[string]*Tree) {\n // IsEmptyTree reports whether this tree (node) is empty of everything but space.\n func IsEmptyTree(n Node) bool {\n \tswitch n := n.(type) {\n+\tcase nil:\n+\t\treturn true\n \tcase *ActionNode:\n \tcase *IfNode:\n \tcase *ListNode:"}, {"sha": "18c0a8b835e3a57cfabe91f28f677f6b6da7e8ee", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -287,6 +287,9 @@ var isEmptyTests = []isEmptyTest{\n }\n \n func TestIsEmpty(t *testing.T) {\n+\tif !IsEmptyTree(nil) {\n+\t\tt.Errorf(\"nil tree is not empty\")\n+\t}\n \tfor _, test := range isEmptyTests {\n \t\ttree, err := New(\"root\").Parse(test.input, \"\", \"\", make(map[string]*Tree), nil)\n \t\tif err != nil {"}, {"sha": "82fc9e5e39db2a76439c02e31b24c90c9872a8d5", "filename": "libgo/go/text/template/template.go", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ftemplate.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -178,10 +178,11 @@ func (t *Template) Parse(text string) (*Template, error) {\n \t\t\ttmpl = t.New(name)\n \t\t}\n \t\t// Even if t == tmpl, we need to install it in the common.tmpl map.\n-\t\tif err := t.associate(tmpl); err != nil {\n+\t\tif replace, err := t.associate(tmpl, tree); err != nil {\n \t\t\treturn nil, err\n+\t\t} else if replace {\n+\t\t\ttmpl.Tree = tree\n \t\t}\n-\t\ttmpl.Tree = tree\n \t\ttmpl.leftDelim = t.leftDelim\n \t\ttmpl.rightDelim = t.rightDelim\n \t}\n@@ -191,22 +192,23 @@ func (t *Template) Parse(text string) (*Template, error) {\n // associate installs the new template into the group of templates associated\n // with t. It is an error to reuse a name except to overwrite an empty\n // template. The two are already known to share the common structure.\n-func (t *Template) associate(new *Template) error {\n+// The boolean return value reports wither to store this tree as t.Tree.\n+func (t *Template) associate(new *Template, tree *parse.Tree) (bool, error) {\n \tif new.common != t.common {\n \t\tpanic(\"internal error: associate not common\")\n \t}\n \tname := new.name\n \tif old := t.tmpl[name]; old != nil {\n \t\toldIsEmpty := parse.IsEmptyTree(old.Root)\n-\t\tnewIsEmpty := new.Tree != nil && parse.IsEmptyTree(new.Root)\n-\t\tif !oldIsEmpty && !newIsEmpty {\n-\t\t\treturn fmt.Errorf(\"template: redefinition of template %q\", name)\n-\t\t}\n+\t\tnewIsEmpty := parse.IsEmptyTree(tree.Root)\n \t\tif newIsEmpty {\n \t\t\t// Whether old is empty or not, new is empty; no reason to replace old.\n-\t\t\treturn nil\n+\t\t\treturn false, nil\n+\t\t}\n+\t\tif !oldIsEmpty {\n+\t\t\treturn false, fmt.Errorf(\"template: redefinition of template %q\", name)\n \t\t}\n \t}\n \tt.tmpl[name] = new\n-\treturn nil\n+\treturn true, nil\n }"}, {"sha": "ad52bab216f8545835a7aae71727ab08a67aa3fc", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -6,14 +6,6 @@ package time\n \n import \"errors\"\n \n-const (\n-\tnumeric = iota\n-\talphabetic\n-\tseparator\n-\tplus\n-\tminus\n-)\n-\n // These are predefined layouts for use in Time.Format.\n // The standard time used in the layouts is:\n //\tMon Jan 2 15:04:05 MST 2006"}, {"sha": "440d3b42f12f3b931eb0362a4601d785e8b5b7e4", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -120,8 +120,11 @@ func TestAfterTick(t *testing.T) {\n \tt1 := Now()\n \td := t1.Sub(t0)\n \ttarget := Delta * Count\n-\tif d < target*9/10 || d > target*30/10 {\n-\t\tt.Fatalf(\"%d ticks of %s took %s, expected %s\", Count, Delta, d, target)\n+\tif d < target*9/10 {\n+\t\tt.Fatalf(\"%d ticks of %s too fast: took %s, expected %s\", Count, Delta, d, target)\n+\t}\n+\tif !testing.Short() && d > target*30/10 {\n+\t\tt.Fatalf(\"%d ticks of %s too slow: took %s, expected %s\", Count, Delta, d, target)\n \t}\n }\n "}, {"sha": "f7ded24d2929d42599f2f30170c7c78bad93f875", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -152,7 +152,7 @@ func (d Weekday) String() string { return days[d] }\n // rely heavily on division and modulus by positive constants.  For\n // calendrical calculations we want these divisions to round down, even\n // for negative values, so that the remainder is always positive, but\n-// Go's division (like most hardware divison instructions) rounds to\n+// Go's division (like most hardware division instructions) rounds to\n // zero.  We can still do those computations and then adjust the result\n // for a negative numerator, but it's annoying to write the adjustment\n // over and over.  Instead, we can change to a different epoch so long\n@@ -384,6 +384,15 @@ type Duration int64\n \n // Common durations.  There is no definition for units of Day or larger\n // to avoid confusion across daylight savings time zone transitions.\n+//\n+// To count the number of units in a Duration, divide:\n+//\tsecond := time.Second\n+//\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n+//\n+// To convert an integer number of units to a Duration, multiply:\n+//\tseconds := 10\n+//\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n+//\n const (\n \tNanosecond  Duration = 1\n \tMicrosecond          = 1000 * Nanosecond\n@@ -758,10 +767,6 @@ func (t Time) UnixNano() int64 {\n \treturn (t.sec+internalToUnix)*1e9 + int64(t.nsec)\n }\n \n-type gobError string\n-\n-func (g gobError) Error() string { return string(g) }\n-\n const timeGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface."}, {"sha": "7e8bb9b234f2ea6f664f98e2dd2057bcb6463954", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -40,7 +40,7 @@ static void mainstart (void *);\n int\n main (int argc, char **argv)\n {\n-  runtime_initsig ();\n+  runtime_check ();\n   runtime_args (argc, (byte **) argv);\n   runtime_osinit ();\n   runtime_schedinit ();"}, {"sha": "9a533a577a46eb358a16623eb6de6dd04e24d88a", "filename": "libgo/runtime/lock_futex.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Flock_futex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Flock_futex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_futex.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -118,8 +118,12 @@ runtime_notewakeup(Note *n)\n void\n runtime_notesleep(Note *n)\n {\n+\tif(runtime_m()->profilehz > 0)\n+\t\truntime_setprof(false);\n \twhile(runtime_atomicload(&n->key) == 0)\n \t\truntime_futexsleep(&n->key, 0, -1);\n+\tif(runtime_m()->profilehz > 0)\n+\t\truntime_setprof(true);\n }\n \n void\n@@ -135,14 +139,18 @@ runtime_notetsleep(Note *n, int64 ns)\n \tif(runtime_atomicload(&n->key) != 0)\n \t\treturn;\n \n+\tif(runtime_m()->profilehz > 0)\n+\t\truntime_setprof(false);\n \tdeadline = runtime_nanotime() + ns;\n \tfor(;;) {\n \t\truntime_futexsleep(&n->key, 0, ns);\n \t\tif(runtime_atomicload(&n->key) != 0)\n-\t\t\treturn;\n+\t\t\tbreak;\n \t\tnow = runtime_nanotime();\n \t\tif(now >= deadline)\n-\t\t\treturn;\n+\t\t\tbreak;\n \t\tns = deadline - now;\n \t}\n+\tif(runtime_m()->profilehz > 0)\n+\t\truntime_setprof(true);\n }"}, {"sha": "8c4b3973bdc59a0f12249809631618c1941e442a", "filename": "libgo/runtime/lock_sema.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Flock_sema.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Flock_sema.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flock_sema.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -159,7 +159,11 @@ runtime_notesleep(Note *n)\n \t\treturn;\n \t}\n \t// Queued.  Sleep.\n+\tif(m->profilehz > 0)\n+\t\truntime_setprof(false);\n \truntime_semasleep(-1);\n+\tif(m->profilehz > 0)\n+\t\truntime_setprof(true);\n }\n \n void\n@@ -185,12 +189,16 @@ runtime_notetsleep(Note *n, int64 ns)\n \t\treturn;\n \t}\n \n+\tif(m->profilehz > 0)\n+\t\truntime_setprof(false);\n \tdeadline = runtime_nanotime() + ns;\n \tfor(;;) {\n \t\t// Registered.  Sleep.\n \t\tif(runtime_semasleep(ns) >= 0) {\n \t\t\t// Acquired semaphore, semawakeup unregistered us.\n \t\t\t// Done.\n+\t\t\tif(m->profilehz > 0)\n+\t\t\t\truntime_setprof(true);\n \t\t\treturn;\n \t\t}\n \n@@ -203,6 +211,9 @@ runtime_notetsleep(Note *n, int64 ns)\n \t\tns = deadline - now;\n \t}\n \n+\tif(m->profilehz > 0)\n+\t\truntime_setprof(true);\n+\n \t// Deadline arrived.  Still registered.  Semaphore not acquired.\n \t// Want to give up and return, but have to unregister first,\n \t// so that any notewakeup racing with the return does not"}, {"sha": "3fde250af3b792e8432b757c0474809e2e28f569", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -277,6 +277,7 @@ runtime_mallocinit(void)\n \tuintptr arena_size, bitmap_size;\n \textern byte end[];\n \tbyte *want;\n+\tuintptr limit;\n \n \truntime_sizeof_C_MStats = sizeof(MStats);\n \n@@ -291,10 +292,12 @@ runtime_mallocinit(void)\n \n \truntime_InitSizes();\n \n+\tlimit = runtime_memlimit();\n+\n \t// Set up the allocation arena, a contiguous area of memory where\n \t// allocated data will be found.  The arena begins with a bitmap large\n \t// enough to hold 4 bits per allocated word.\n-\tif(sizeof(void*) == 8) {\n+\tif(sizeof(void*) == 8 && (limit == 0 || limit > (1<<30))) {\n \t\t// On a 64-bit machine, allocate from a single contiguous reservation.\n \t\t// 16 GB should be big enough for now.\n \t\t//\n@@ -343,6 +346,10 @@ runtime_mallocinit(void)\n \t\t// of address space, which is probably too much in a 32-bit world.\n \t\tbitmap_size = MaxArena32 / (sizeof(void*)*8/4);\n \t\tarena_size = 512<<20;\n+\t\tif(limit > 0 && arena_size+bitmap_size > limit) {\n+\t\t\tbitmap_size = (limit / 9) & ~((1<<PageShift) - 1);\n+\t\t\tarena_size = bitmap_size * 8;\n+\t\t}\n \t\t\n \t\t// SysReserve treats the address we ask for, end, as a hint,\n \t\t// not as an absolute requirement.  If we ask for the end\n@@ -359,6 +366,8 @@ runtime_mallocinit(void)\n \t\tp = runtime_SysReserve(want, bitmap_size + arena_size);\n \t\tif(p == nil)\n \t\t\truntime_throw(\"runtime: cannot reserve arena virtual address space\");\n+\t\tif((uintptr)p & (((uintptr)1<<PageShift)-1))\n+\t\t\truntime_printf(\"runtime: SysReserve returned unaligned address %p; asked for %p\", p, (void*)(bitmap_size+arena_size));\n \t}\n \tif((uintptr)p & (((uintptr)1<<PageShift)-1))\n \t\truntime_throw(\"runtime: SysReserve returned unaligned address\");"}, {"sha": "4aa7c45dcb3a8ce86e8c35d1040ba5246f779cec", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -654,14 +654,6 @@ markfin(void *v)\n \tscanblock(v, size);\n }\n \n-struct root_list {\n-\tstruct root_list *next;\n-\tstruct root {\n-\t\tvoid *decl;\n-\t\tsize_t size;\n-\t} roots[];\n-};\n-\n static struct root_list* roots;\n \n void"}, {"sha": "6bf38aa9934e5e105c313ca039c3fb1ea3378afd", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -326,7 +326,7 @@ MHeap_FreeLocked(MHeap *h, MSpan *s)\n }\n \n // Release (part of) unused memory to OS.\n-// Goroutine created in runtime_schedinit.\n+// Goroutine created at startup.\n // Loop forever.\n void\n runtime_MHeap_Scavenger(void* dummy)"}, {"sha": "31e8287e704f9524a90d1a15cf00cf5845531227", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -416,8 +416,6 @@ runtime_schedinit(void)\n \t// Can not enable GC until all roots are registered.\n \t// mstats.enablegc = 1;\n \tm->nomemprof--;\n-\n-\tscvg = __go_go(runtime_MHeap_Scavenger, nil);\n }\n \n extern void main_init(void) __asm__ (\"__go_init_main\");\n@@ -435,6 +433,7 @@ runtime_main(void)\n \t// to preserve the lock.\n \truntime_LockOSThread();\n \truntime_sched.init = true;\n+\tscvg = __go_go(runtime_MHeap_Scavenger, nil);\n \tmain_init();\n \truntime_sched.init = false;\n \tif(!runtime_sched.lockmain)\n@@ -548,7 +547,7 @@ mcommoninit(M *m)\n \t\tm->mcache = runtime_allocmcache();\n \n \truntime_callers(1, m->createstack, nelem(m->createstack));\n-\t\n+\n \t// Add to runtime_allm so garbage collector doesn't free m\n \t// when it is just in a register or thread-local storage.\n \tm->alllink = runtime_allm;\n@@ -791,10 +790,11 @@ nextgandunlock(void)\n \t\tmput(m);\n \t}\n \n-\t// Look for deadlock situation: one single active g which happens to be scvg.\n-\tif(runtime_sched.grunning == 1 && runtime_sched.gwait == 0) {\n-\t\tif(scvg->status == Grunning || scvg->status == Gsyscall)\n-\t\t\truntime_throw(\"all goroutines are asleep - deadlock!\");\n+\t// Look for deadlock situation.\n+\tif((scvg == nil && runtime_sched.grunning == 0) ||\n+\t   (scvg != nil && runtime_sched.grunning == 1 && runtime_sched.gwait == 0 &&\n+\t    (scvg->status == Grunning || scvg->status == Gsyscall))) {\n+\t\truntime_throw(\"all goroutines are asleep - deadlock!\");\n \t}\n \n \tm->nextg = nil;\n@@ -1135,6 +1135,9 @@ runtime_entersyscall(void)\n {\n \tuint32 v;\n \n+\tif(m->profilehz > 0)\n+\t\truntime_setprof(false);\n+\n \t// Leave SP around for gc and traceback.\n #ifdef USING_SPLIT_STACK\n \tg->gcstack = __splitstack_find(NULL, NULL, &g->gcstack_size,\n@@ -1205,6 +1208,9 @@ runtime_exitsyscall(void)\n #endif\n \t\tgp->gcnext_sp = nil;\n \t\truntime_memclr(gp->gcregs, sizeof gp->gcregs);\n+\n+\t\tif(m->profilehz > 0)\n+\t\t\truntime_setprof(true);\n \t\treturn;\n \t}\n "}, {"sha": "78c865ba17594b8d81ce36babd335b96cbc27f44", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -184,6 +184,21 @@ runtime_fastrand1(void)\n \treturn x;\n }\n \n+static struct root_list runtime_roots =\n+{ NULL,\n+  { { &syscall_Envs, sizeof syscall_Envs },\n+    { &os_Args, sizeof os_Args },\n+    { NULL, 0 } },\n+};\n+\n+void\n+runtime_check(void)\n+{\n+\t__go_register_gc_roots(&runtime_roots);\n+\n+\truntime_initsig ();\n+}\n+\n int64\n runtime_cputicks(void)\n {"}, {"sha": "40c59a82777c7eec31da2071a35a12fd5afaa100", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -427,6 +427,8 @@ void\truntime_osyield(void);\n void\truntime_LockOSThread(void) __asm__(\"libgo_runtime.runtime.LockOSThread\");\n void\truntime_UnlockOSThread(void) __asm__(\"libgo_runtime.runtime.UnlockOSThread\");\n \n+uintptr\truntime_memlimit(void);\n+\n // If appropriate, ask the operating system to control whether this\n // thread should receive profiling signals.  This is only necessary on OS X.\n // An operating system should not deliver a profiling signal to a\n@@ -441,3 +443,16 @@ void\truntime_time_scan(void (*)(byte*, int64));\n \n void\truntime_setsig(int32, bool, bool);\n #define runtime_setitimer setitimer\n+\n+void\truntime_check(void);\n+\n+// A list of global variables that the garbage collector must scan.\n+struct root_list {\n+\tstruct root_list *next;\n+\tstruct root {\n+\t\tvoid *decl;\n+\t\tsize_t size;\n+\t} roots[];\n+};\n+\n+void\t__go_register_gc_roots(struct root_list*);"}, {"sha": "6a69fb429a44a7ef04874ce4973a7db3a8e5a0e4", "filename": "libgo/runtime/thread-linux.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -3,6 +3,16 @@\n // license that can be found in the LICENSE file.\n \n #include \"runtime.h\"\n+#include \"defs.h\"\n+\n+// Linux futex.\n+//\n+//\tfutexsleep(uint32 *addr, uint32 val)\n+//\tfutexwakeup(uint32 *addr)\n+//\n+// Futexsleep atomically checks if *addr == val and if so, sleeps on addr.\n+// Futexwakeup wakes up threads sleeping on addr.\n+// Futexsleep is allowed to wake up spuriously.\n \n #include <errno.h>\n #include <string.h>"}, {"sha": "12d009926e316c75f1b662f7bfc173e0c3dc94d0", "filename": "libgo/runtime/thread.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593f74bbab63d34c7060918088bcbad686c31c66/libgo%2Fruntime%2Fthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread.c?ref=593f74bbab63d34c7060918088bcbad686c31c66", "patch": "@@ -4,6 +4,8 @@\n \n #include <errno.h>\n #include <signal.h>\n+#include <sys/time.h>\n+#include <sys/resource.h>\n \n #include \"runtime.h\"\n #include \"go-assert.h\"\n@@ -138,6 +140,7 @@ runtime_minit(void)\n \tbyte* stack;\n \tsize_t stacksize;\n \tstack_t ss;\n+\tsigset_t sigs;\n \n \t// Initialize signal handling.\n \truntime_m()->gsignal = runtime_malg(32*1024, &stack, &stacksize);\t// OS X wants >=8K, Linux >=2K\n@@ -146,4 +149,34 @@ runtime_minit(void)\n \tss.ss_size = stacksize;\n \tif(sigaltstack(&ss, nil) < 0)\n \t\t*(int *)0xf1 = 0xf1;\n+\tif (sigemptyset(&sigs) != 0)\n+\t\truntime_throw(\"sigemptyset\");\n+\tsigprocmask(SIG_SETMASK, &sigs, nil);\n+}\n+\n+uintptr\n+runtime_memlimit(void)\n+{\n+\tstruct rlimit rl;\n+\tuintptr used;\n+\n+\tif(getrlimit(RLIMIT_AS, &rl) != 0)\n+\t\treturn 0;\n+\tif(rl.rlim_cur >= 0x7fffffff)\n+\t\treturn 0;\n+\n+\t// Estimate our VM footprint excluding the heap.\n+\t// Not an exact science: use size of binary plus\n+\t// some room for thread stacks.\n+\tused = (64<<20);\n+\tif(used >= rl.rlim_cur)\n+\t\treturn 0;\n+\n+\t// If there's not at least 16 MB left, we're probably\n+\t// not going to be able to do much.  Treat as no limit.\n+\trl.rlim_cur -= used;\n+\tif(rl.rlim_cur < (16<<20))\n+\t\treturn 0;\n+\n+\treturn rl.rlim_cur - used;\n }"}]}