{"sha": "93f93f9f2865f06a0929d5311101c5bc4b6565bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmOTNmOWYyODY1ZjA2YTA5MjlkNTMxMTEwMWM1YmM0YjY1NjViYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-11-13T12:21:26Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-11-13T12:21:26Z"}, "message": "Buffer.java: Implemented.\n\n2002-11-13  Michael Koch <konqueror@gmx.de>\n\n\t* java/nio/Buffer.java: Implemented.\n\t* java/nio/CharBuffer.java: New file.\n\t* java/nio/InvalidMarkException.java: New file.\n\t* java/nio/channels/DatagramChannel.java: Implemented.\n\t* java/nio/channels/ServerSocketChannel.java: Implemented.\n\t* java/nio/channels/SocketChannel.java: Implemented.\n\t* java/nio/channels/spi/AbstractChannel.java: Removed.\n\t* java/nio/channels/spi/AbstractSelectableChannel.java:\n\tImplemented.\n\t* java/nio/charset/Charset.java:\n\tMerge from Classpath.\n\t* java/nio/charset/CharsetDecoder.java: New file.\n\t* java/nio/charset/CharsetEncoder.java: New file.\n\t* java/nio/charset/CoderResult.java: New file.\n\t* Makefile.am (ordinary_java_source_files): Added new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r59075", "tree": {"sha": "db3be97532ba927b2d999315ce0cc17581fbbaa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3be97532ba927b2d999315ce0cc17581fbbaa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93f93f9f2865f06a0929d5311101c5bc4b6565bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f93f9f2865f06a0929d5311101c5bc4b6565bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f93f9f2865f06a0929d5311101c5bc4b6565bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f93f9f2865f06a0929d5311101c5bc4b6565bc/comments", "author": null, "committer": null, "parents": [{"sha": "7b53becc108e717109ebf7541b1af06083d8e95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b53becc108e717109ebf7541b1af06083d8e95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b53becc108e717109ebf7541b1af06083d8e95c"}], "stats": {"total": 2088, "additions": 2006, "deletions": 82}, "files": [{"sha": "54c9e04d85c194b9b9cbb751b68cb0f8eb9f7341", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -1,3 +1,22 @@\n+2002-11-12  Michael Koch <konqueror@gmx.de>\n+\n+\t* java/nio/Buffer.java: Implemented.\n+\t* java/nio/CharBuffer.java: New file.\n+\t* java/nio/InvalidMarkException.java: New file.\n+\t* java/nio/channels/DatagramChannel.java: Implemented.\n+\t* java/nio/channels/ServerSocketChannel.java: Implemented.\n+\t* java/nio/channels/SocketChannel.java: Implemented.\n+\t* java/nio/channels/spi/AbstractChannel.java: Removed.\n+\t* java/nio/channels/spi/AbstractSelectableChannel.java:\n+\tImplemented.\n+\t* java/nio/charset/Charset.java:\n+\tMerge from Classpath.\n+\t* java/nio/charset/CharsetDecoder.java: New file.\n+\t* java/nio/charset/CharsetEncoder.java: New file.\n+\t* java/nio/charset/CoderResult.java: New file.\n+\t* Makefile.am (ordinary_java_source_files): Added new files.\n+\t* Makefile.in: Regenerated.\n+\t\n 2002-11-11  Jesse Rosenstock  <jmr@ugcs.caltech.edu>\n \n \t* gnu/java/nio/charset/ISO_8859_1.java,\n@@ -9,10 +28,7 @@\n \tgnu/java/nio/charset/UTF_16Encoder.java,\n \tgnu/java/nio/charset/UTF_16LE.java,\n \tgnu/java/nio/charset/UTF_8.java: New files.\n-\t* Makefile.am ():\n-\tAdded new files.\n-\t* Makefile.in: Regenerated.\n-\t\n+\n 2002-11-11  Michael Koch <konqueror@gmx.de>\n \n \t* java/nio/charset/CharacterCodingException.java:"}, {"sha": "d07aa8269d42d6406bbba54fdf874f9c9df0889b", "filename": "libjava/Makefile.am", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -1871,6 +1871,15 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/nio/charset/ISO_8859_1.java \\\n+gnu/java/nio/charset/Provider.java \\\n+gnu/java/nio/charset/US_ASCII.java \\\n+gnu/java/nio/charset/UTF_16.java \\\n+gnu/java/nio/charset/UTF_16BE.java \\\n+gnu/java/nio/charset/UTF_16Decoder.java \\\n+gnu/java/nio/charset/UTF_16Encoder.java \\\n+gnu/java/nio/charset/UTF_16LE.java \\\n+gnu/java/nio/charset/UTF_8.java \\\n gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/provider/DERReader.java \\\n gnu/java/security/provider/DERWriter.java \\\n@@ -1963,6 +1972,8 @@ java/nio/BufferOverflowException.java \\\n java/nio/BufferUnderflowException.java \\\n java/nio/ByteBuffer.java \\\n java/nio/ByteOrder.java \\\n+java/nio/CharBuffer.java \\\n+java/nio/InvalidMarkException.java \\\n java/nio/MappedByteBuffer.java \\\n java/nio/channels/AlreadyConnectedException.java \\\n java/nio/channels/ByteChannel.java \\\n@@ -1982,14 +1993,16 @@ java/nio/channels/ServerSocketChannel.java \\\n java/nio/channels/SocketChannel.java \\\n java/nio/channels/WritableByteChannel.java \\\n java/nio/channels/spi/AbstractSelectableChannel.java \\\n-java/nio/channels/spi/AbstractChannel.java \\\n java/nio/channels/spi/AbstractInterruptibleChannel.java \\\n java/nio/channels/spi/AbstractSelectionKey.java \\\n java/nio/channels/spi/AbstractSelector.java \\\n java/nio/channels/spi/SelectorProvider.java \\\n java/nio/charset/Charset.java \\\n java/nio/charset/CharacterCodingException.java \\\n+java/nio/charset/CharsetDecoder.java \\\n+java/nio/charset/CharsetEncoder.java \\\n java/nio/charset/CoderMalfunctionError.java \\\n+java/nio/charset/CoderResult.java \\\n java/nio/charset/CodingErrorAction.java \\\n java/nio/charset/IllegalCharsetNameException.java \\\n java/nio/charset/MalformedInputException.java \\"}, {"sha": "4ece78cc7254cbb026975debeeaf22459fe749fa", "filename": "libjava/Makefile.in", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -1621,6 +1621,15 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/nio/charset/ISO_8859_1.java \\\n+gnu/java/nio/charset/Provider.java \\\n+gnu/java/nio/charset/US_ASCII.java \\\n+gnu/java/nio/charset/UTF_16.java \\\n+gnu/java/nio/charset/UTF_16BE.java \\\n+gnu/java/nio/charset/UTF_16Decoder.java \\\n+gnu/java/nio/charset/UTF_16Encoder.java \\\n+gnu/java/nio/charset/UTF_16LE.java \\\n+gnu/java/nio/charset/UTF_8.java \\\n gnu/java/security/der/DEREncodingException.java \\\n gnu/java/security/provider/DERReader.java \\\n gnu/java/security/provider/DERWriter.java \\\n@@ -1713,6 +1722,8 @@ java/nio/BufferOverflowException.java \\\n java/nio/BufferUnderflowException.java \\\n java/nio/ByteBuffer.java \\\n java/nio/ByteOrder.java \\\n+java/nio/CharBuffer.java \\\n+java/nio/InvalidMarkException.java \\\n java/nio/MappedByteBuffer.java \\\n java/nio/channels/AlreadyConnectedException.java \\\n java/nio/channels/ByteChannel.java \\\n@@ -1732,14 +1743,16 @@ java/nio/channels/ServerSocketChannel.java \\\n java/nio/channels/SocketChannel.java \\\n java/nio/channels/WritableByteChannel.java \\\n java/nio/channels/spi/AbstractSelectableChannel.java \\\n-java/nio/channels/spi/AbstractChannel.java \\\n java/nio/channels/spi/AbstractInterruptibleChannel.java \\\n java/nio/channels/spi/AbstractSelectionKey.java \\\n java/nio/channels/spi/AbstractSelector.java \\\n java/nio/channels/spi/SelectorProvider.java \\\n java/nio/charset/Charset.java \\\n java/nio/charset/CharacterCodingException.java \\\n+java/nio/charset/CharsetDecoder.java \\\n+java/nio/charset/CharsetEncoder.java \\\n java/nio/charset/CoderMalfunctionError.java \\\n+java/nio/charset/CoderResult.java \\\n java/nio/charset/CodingErrorAction.java \\\n java/nio/charset/IllegalCharsetNameException.java \\\n java/nio/charset/MalformedInputException.java \\\n@@ -2514,7 +2527,15 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_HK.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_SG.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_TW.P \\\n-.deps/gnu/java/math/MPN.P \\\n+.deps/gnu/java/math/MPN.P .deps/gnu/java/nio/charset/ISO_8859_1.P \\\n+.deps/gnu/java/nio/charset/Provider.P \\\n+.deps/gnu/java/nio/charset/US_ASCII.P \\\n+.deps/gnu/java/nio/charset/UTF_16.P \\\n+.deps/gnu/java/nio/charset/UTF_16BE.P \\\n+.deps/gnu/java/nio/charset/UTF_16Decoder.P \\\n+.deps/gnu/java/nio/charset/UTF_16Encoder.P \\\n+.deps/gnu/java/nio/charset/UTF_16LE.P \\\n+.deps/gnu/java/nio/charset/UTF_8.P \\\n .deps/gnu/java/rmi/RMIMarshalledObjectInputStream.P \\\n .deps/gnu/java/rmi/RMIMarshalledObjectOutputStream.P \\\n .deps/gnu/java/rmi/dgc/DGCImpl.P .deps/gnu/java/rmi/dgc/DGCImpl_Skel.P \\\n@@ -2981,7 +3002,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/net/natPlainSocketImpl.P .deps/java/nio/Buffer.P \\\n .deps/java/nio/BufferOverflowException.P \\\n .deps/java/nio/BufferUnderflowException.P .deps/java/nio/ByteBuffer.P \\\n-.deps/java/nio/ByteOrder.P .deps/java/nio/MappedByteBuffer.P \\\n+.deps/java/nio/ByteOrder.P .deps/java/nio/CharBuffer.P \\\n+.deps/java/nio/InvalidMarkException.P .deps/java/nio/MappedByteBuffer.P \\\n .deps/java/nio/channels/AlreadyConnectedException.P \\\n .deps/java/nio/channels/ByteChannel.P .deps/java/nio/channels/Channel.P \\\n .deps/java/nio/channels/ClosedChannelException.P \\\n@@ -2998,15 +3020,17 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/nio/channels/ServerSocketChannel.P \\\n .deps/java/nio/channels/SocketChannel.P \\\n .deps/java/nio/channels/WritableByteChannel.P \\\n-.deps/java/nio/channels/spi/AbstractChannel.P \\\n .deps/java/nio/channels/spi/AbstractInterruptibleChannel.P \\\n .deps/java/nio/channels/spi/AbstractSelectableChannel.P \\\n .deps/java/nio/channels/spi/AbstractSelectionKey.P \\\n .deps/java/nio/channels/spi/AbstractSelector.P \\\n .deps/java/nio/channels/spi/SelectorProvider.P \\\n .deps/java/nio/charset/CharacterCodingException.P \\\n .deps/java/nio/charset/Charset.P \\\n+.deps/java/nio/charset/CharsetDecoder.P \\\n+.deps/java/nio/charset/CharsetEncoder.P \\\n .deps/java/nio/charset/CoderMalfunctionError.P \\\n+.deps/java/nio/charset/CoderResult.P \\\n .deps/java/nio/charset/CodingErrorAction.P \\\n .deps/java/nio/charset/IllegalCharsetNameException.P \\\n .deps/java/nio/charset/MalformedInputException.P \\"}, {"sha": "9474fb453f0389534d3ddd91775289f9847b9f73", "filename": "libjava/java/nio/Buffer.java", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FBuffer.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -39,4 +39,155 @@\n \n public abstract class Buffer\n {\n+  int cap = 0;\n+  int limit = 0;\n+  int pos = 0;\n+  int mark = -1;\n+\n+  /**\n+   * Retrieves the capacity of the buffer.\n+   */\n+  public final int capacity ()\n+  {\n+    return cap;\n+  }\n+\n+  /**\n+   * Clears the buffer.\n+   */\n+  public final Buffer clear ()\n+  {\n+    limit = cap;\n+    pos = 0;\n+    mark = -1;\n+    return this;\n+  }\n+    \n+  /**\n+   * Flips the buffer.\n+   */\n+  public final Buffer flip ()\n+  {\n+    limit = pos;\n+    pos = 0;\n+    mark = -1;\n+    return this;\n+  }\n+    \n+  /**\n+   * Tells whether the buffer has remaining data to read or not.\n+   */\n+  public final boolean hasRemaining ()\n+  {\n+    return limit > pos;\n+  }\n+\n+  /**\n+   * Tells whether this buffer is read only or not.\n+   */\n+  public abstract boolean isReadOnly ();\n+\n+  /**\n+   * Retrieves the current limit of the buffer.\n+   */\n+  public final int limit ()\n+  {\n+    return limit;\n+  }\n+\n+  /**\n+   * Sets this buffer's limit.\n+   * \n+   * @param newLimit The new limit value; must be non-negative and no larger\n+   * than this buffer's capacity.\n+   *\n+   * @exception IllegalArgumentException If the preconditions on newLimit\n+   * do not hold.\n+   */\n+  public final Buffer limit (int newLimit)\n+  {\n+    if ((newLimit < 0) || (newLimit > cap))\n+      throw new IllegalArgumentException ();\n+\n+    if (newLimit <= mark)\n+        mark = -1;\n+\n+    if (pos > newLimit)\n+        pos = newLimit - 1;\n+\n+    limit = newLimit;\n+    return this;\n+  }\n+\n+  /**\n+   * Sets this buffer's mark at its position.\n+   */\n+  public final Buffer mark ()\n+  {\n+    mark = pos;\n+    return this;\n+  }\n+\n+  /**\n+   * Retrieves the current position of this buffer.\n+   */\n+  public final int position ()\n+  {\n+    return pos;\n+  }\n+    \n+  /**\n+   * Sets this buffer's position. If the mark is defined and larger than the\n+   * new position then it is discarded.\n+   * \n+   * @param newPosition The new position value; must be non-negative and no\n+   * larger than the current limit.\n+   * \n+   * @exception IllegalArgumentException If the preconditions on newPosition\n+   * do not hold\n+   */\n+  public final Buffer position (int newPosition)\n+  {\n+    if ((newPosition < 0) || (newPosition > limit))\n+      throw new IllegalArgumentException ();\n+\n+    if (newPosition <= mark)\n+        mark = -1;\n+\n+    pos = newPosition;\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the number of elements between the current position and the limit.\n+   */\n+  public final int remaining()\n+  {\n+    return limit - pos;\n+  }\n+\n+  /**\n+   * Resets this buffer's position to the previously-marked position.\n+   * \n+   * @exception InvalidMarkException If the mark has not been set.\n+   */\n+  public final Buffer reset()\n+  {\n+    if (mark == -1)\n+      throw new InvalidMarkException ();\n+\n+    pos = mark;\n+    return this;\n+  }\n+\n+  /**\n+   * Rewinds this buffer. The position is set to zero and the mark\n+   * is discarded.\n+   */\n+  public final Buffer rewind()\n+  {\n+    pos = 0;\n+    mark = -1;\n+    return this;\n+  }\n }"}, {"sha": "2a21ef93ff536b3f20dc5fbc64689699e70eacfc", "filename": "libjava/java/nio/CharBuffer.java", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FCharBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FCharBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharBuffer.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -0,0 +1,291 @@\n+/* CharBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+public abstract class CharBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+\n+  protected char [] backing_buffer;\n+  \n+  public static CharBuffer allocate (int capacity)\n+  {\n+    return null;\n+  }\n+  \n+  /**\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static CharBuffer wrap (char[] array, int offset, int length)\n+  {\n+    if ((offset < 0) ||\n+        (offset > array.length) ||\n+        (length < 0) ||\n+        (length > (array.length - offset)))\n+      throw new IndexOutOfBoundsException ();\n+ \n+    return null;\n+  }\n+  \n+  final public static CharBuffer wrap (CharSequence a)\n+  {\n+    return wrap (a, 0, a.length ());\n+  }\n+  \n+  /**\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static CharBuffer wrap (CharSequence a, int offset, int length)\n+  {\n+    char [] buffer = new char [length];\n+    \n+    for (int i = offset; i < length; i++)\n+      {\n+        buffer [i] = a.charAt (i);\n+      }\n+    \n+    return wrap (buffer, 0, length);\n+  }\n+  \n+  final public static CharBuffer wrap (char[] array)\n+  {\n+    return wrap  (array, 0, array.length);\n+  }\n+  \n+  /**\n+   * @exception BufferUnderflowException FIXME\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public CharBuffer get (char[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst [i] = get ();\n+      }\n+    return this;\n+  }\n+  \n+  /**\n+   * @exception BufferUnderflowException FIXME\n+   */\n+  final public CharBuffer get (char[] dst)\n+  {\n+    return get (dst, 0, dst.length);\n+  }\n+  \n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception IllegalArgumentException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  final public CharBuffer put (CharBuffer src)\n+  {\n+    while (src.hasRemaining ())\n+      put (src.get ());\n+\n+    return this;\n+  }\n+ \n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  final public CharBuffer put (char[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put (src [i]);\n+\n+    return this;\n+  }\n+\n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public final CharBuffer put (char[] src)\n+  {\n+    return put (src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray ()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  /**\n+   * @exception ReadOnlyBufferException FIXME\n+   * @exception UnsupportedOperationException FIXME\n+   */\n+  public final char[] array ()\n+  {\n+    return backing_buffer;\n+  }\n+  \n+  /**\n+   * @exception ReadOnlyBufferException FIXME\n+   * @exception UnsupportedOperationException FIXME\n+   */\n+  public final int arrayOffset ()\n+  {\n+    return 0;\n+  }\n+  \n+  public int hashCode ()\n+  {\n+    return super.hashCode ();\n+  }\n+  \n+  public boolean equals (Object obj)\n+  {\n+    if (obj instanceof CharBuffer)\n+      return compareTo (obj) == 0;\n+    \n+    return false;\n+  }\n+ \n+  /**\n+   * @exception ClassCastException FIXME\n+   */\n+  public int compareTo(Object obj)\n+  {\n+    CharBuffer a = (CharBuffer) obj;\n+    \n+    if (a.remaining () != remaining ())\n+      return 1;\n+    \n+    if (! hasArray () || ! a.hasArray ())\n+      return 1;\n+    \n+    int r = remaining ();\n+    int i1 = pos;\n+    int i2 = a.pos;\n+    \n+    for (int i = 0; i < r; i++)\n+      {\n+        int t = (int) (get (i1)- a.get (i2));\n+\t\n+        if (t != 0)\n+          return (int) t;\n+      }\n+    return 0;\n+  }\n+ \n+  /**\n+   * @exception BufferUnderflowException FIXME\n+   */\n+  public abstract char get ();\n+  \n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public abstract CharBuffer put (char b);\n+  \n+  /**\n+   * @exception IndexOutOfBoundsException FIXME\n+   */\n+  public abstract char get (int index);\n+  \n+  /**\n+   * @exception IndexOutOfBoundsException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public abstract CharBuffer put (int index, char b);\n+ \n+  /**\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public abstract CharBuffer compact ();\n+  \n+  public abstract boolean isDirect ();\n+  \n+  public abstract CharBuffer slice ();\n+  \n+  public abstract CharBuffer duplicate ();\n+  \n+  public abstract CharBuffer asReadOnlyBuffer ();\n+  \n+  public String toString ()\n+  {\n+    return \"\";\n+  }\n+\n+  public final int length ()\n+  { \n+    return 0;\n+  }\n+\n+  public abstract ByteOrder order ();\n+\n+  /**\n+   * @exception IndexOutOfBoundsException FIXME\n+   */\n+  public abstract CharSequence subSequence (int start, int length);\n+\n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception IndexOutOfBoundsException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public CharBuffer put (String str, int start, int length)\n+  {\n+    return null;\n+  }\n+  \n+  /**\n+   * @exception BufferOverflowException FIXME\n+   * @exception ReadOnlyBufferException FIXME\n+   */\n+  public final CharBuffer put (String str)\n+  {\n+    return null;\n+  }\n+  \n+  /**\n+   * @exception IndexOutOfBoundsException FIXME\n+   */\n+  public final char charAt (int index)\n+  {\n+    return ' ';\n+  }\n+}"}, {"sha": "5917855a4c99943cf13c3fe70d3e38999f785104", "filename": "libjava/java/nio/InvalidMarkException.java", "status": "renamed", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FInvalidMarkException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2FInvalidMarkException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FInvalidMarkException.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -1,4 +1,4 @@\n-/* AbstractChannel.java -- \n+/* InvalidMarkException.java -- \n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,23 +35,18 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-package java.nio.channels.spi;\n+package java.nio;\n \n-import java.io.IOException;\n-import java.nio.channels.Channel;\n-\n-public abstract class AbstractChannel implements Channel\n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n+public class InvalidMarkException extends IllegalStateException\n {\n-  boolean opened;\n-\n-  public boolean isOpen()\n-  {\n-    return opened;\n-  }\n-\n-  public void close() throws IOException\n+  /**\n+   * Creates the exception\n+   */\n+  public InvalidMarkException ()\n   {\n-    if (! isOpen())\n-      return;\n   }\n }", "previous_filename": "libjava/java/nio/channels/spi/AbstractChannel.java"}, {"sha": "eefa443cb2932caaaec39e54d5925bf08db26723", "filename": "libjava/java/nio/channels/DatagramChannel.java", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FDatagramChannel.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -37,14 +37,117 @@\n \n package java.nio.channels;\n \n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n \n+/**\n+ * @since 1.4\n+ */\n public abstract class DatagramChannel\n   extends AbstractSelectableChannel\n+  implements ByteChannel, ScatteringByteChannel, GatheringByteChannel\n {\n-  public DatagramChannel (SelectorProvider provider)\n+  /**\n+   * Initializes the channel.\n+   */\n+  protected DatagramChannel (SelectorProvider provider)\n   {\n     super (provider);\n   }\n+\n+  /**\n+   * Opens a datagram channel.\n+   */\n+  public static DatagramChannel open () throws IOException\n+  {\n+    return SelectorProvider.provider ().openDatagramChannel ();\n+  }\n+  \n+  /**\n+   * Reads data from this channel.\n+   */\n+  public final long read (ByteBuffer[] dsts) throws IOException\n+  {\n+    long b = 0;\n+    \n+    for (int i = 0; i < dsts.length; i++)\n+      b += read (dsts[i]);\n+    \n+    return b;\n+  }\n+  \n+  /**\n+   * Writes data to this channel.\n+   */\n+  public final long write (ByteBuffer[] srcs)\n+  {\n+    long b = 0;\n+    \n+    for (int i = 0;i < srcs.length; i++)\n+      b += write (srcs[i]);\n+    \n+    return b;\n+  }\n+    \n+  /**\n+   * Connects this channel's socket.\n+   */\n+  public abstract DatagramChannel connect (SocketAddress remote);\n+\n+  /**\n+   * Disonnects this channel's socket.\n+   */\n+  public abstract DatagramChannel disconnect ();\n+\n+  /**\n+   * Tells whether or not this channel's socket is connected.\n+   */\n+  public abstract boolean isConnected ();\n+  \n+  /**\n+   * Reads data from this channel.\n+   */\n+  public abstract int read (ByteBuffer dst);\n+  \n+  /**\n+   * Reads data from this channel.\n+   */\n+  public abstract long read (ByteBuffer[] dsts, int offset, int length);\n+ \n+  /**\n+   * Receives a datagram via this channel.\n+   */\n+  public abstract SocketAddress receive (ByteBuffer dst);\n+ \n+  /**\n+   * Sends a datagram via this channel.\n+   */\n+  public abstract int send (ByteBuffer src, SocketAddress target);\n+ \n+  /**\n+   * Retrieves the channel's socket.\n+   */\n+  public abstract DatagramSocket socket ();\n+  \n+  /**\n+   * Writes data to this channel.\n+   */\n+  public abstract int write (ByteBuffer src);\n+  \n+  /**\n+   * Writes data to this channel.\n+   */\n+  public abstract long write (ByteBuffer[] srcs, int offset, int length);\n+\n+  /**\n+   * Retrieves the valid operations for this channel.\n+   */\n+  public final int validOps ()\n+  {\n+    return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n+  }    \n }"}, {"sha": "ed8d39264dff44898865f71bbdf5591b96c4e7a6", "filename": "libjava/java/nio/channels/ServerSocketChannel.java", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FServerSocketChannel.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -39,12 +39,49 @@\n \n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n+import java.nio.ByteOrder;\n+import java.nio.ByteBuffer;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n \n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n public abstract class ServerSocketChannel\n   extends AbstractSelectableChannel\n {\n+  /**\n+   * Initializes this channel.\n+   */\n   public ServerSocketChannel (SelectorProvider provider)\n   {\n     super (provider);\n   }\n+  \n+  /**\n+   *  Accepts a connection made to this channel's socket.\n+   */\n+  public abstract SocketChannel accept ();\n+  \n+  /**\n+   * Retrieves the channels socket.\n+   */\n+  public abstract ServerSocket socket ();\n+    \n+  /**\n+   * Opens a server socker channel.\n+   */\n+  public static ServerSocketChannel open () throws IOException\n+  {\n+    return SelectorProvider.provider ().openServerSocketChannel ();\n+  }\n+\n+  /**\n+   * Retrieves the valid operations for this channel.\n+   */\n+  public final int validOps ()\n+  {\n+    return SelectionKey.OP_ACCEPT;\n+  } \n }"}, {"sha": "1d93430947e1af13932249e82cf48e266b733b2d", "filename": "libjava/java/nio/channels/SocketChannel.java", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FSocketChannel.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -39,12 +39,127 @@\n \n import java.nio.channels.spi.AbstractSelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n+import java.nio.ByteBuffer;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n \n-public abstract class SocketChannel\n-  extends AbstractSelectableChannel\n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n+abstract public class SocketChannel extends AbstractSelectableChannel\n {\n-  public SocketChannel (SelectorProvider provider)\n+  /**\n+   * Initializes this socket.\n+   */\n+  protected SocketChannel (SelectorProvider provider)\n   {\n     super (provider);\n   }\n+ \n+  /**\n+   * Opens a socket channel.\n+   */\n+  public static SocketChannel open () throws IOException\n+  {\n+    return SelectorProvider.provider ().openSocketChannel ();\n+  }\n+  \n+  /**\n+   * Opens a channel and connects it to a remote address.\n+   */\n+  public static SocketChannel open (SocketAddress remote) throws IOException\n+  {\n+    SocketChannel ch = open ();\n+\t\n+    if (ch.connect (remote))\n+      {\n+      }\n+    \n+    return ch;\n+  }\n+    \n+  /**\n+   * Reads data from the channel.\n+   */\n+  public final long read (ByteBuffer[] dsts)\n+  {\n+    long b = 0;\n+    \n+    for (int i = 0; i < dsts.length; i++)\n+      {\n+        b += read (dsts [i]);\n+      }\n+    \n+    return b;\n+  }\n+    \n+  /**\n+   * Writes data to the channel.\n+   */\n+  public final long write (ByteBuffer[] dsts)\n+  {\n+    long b = 0;\n+\n+    for (int  i= 0; i < dsts.length; i++)\n+      {\n+        b += write (dsts [i]);\n+      }\n+    \n+    return b;\n+  }    \n+   \n+  /**\n+   * Retrieves the valid operations for this channel.\n+   */\n+  public final int validOps ()\n+  {\n+    return SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n+  }\n+\n+  /**\n+   * Reads data from the channel.\n+   */\n+  public abstract int read (ByteBuffer dst);\n+\n+  /**\n+   * Connects the channel's socket to the remote address.\n+   */\n+  public abstract boolean connect (SocketAddress remote) throws IOException;\n+  \n+  /**\n+   * Finishes the process of connecting a socket channel.\n+   */\n+  public abstract boolean finishConnect ();\n+ \n+  /**\n+   * Tells whether or not the channel's socket is connected.\n+   */\n+  public abstract boolean isConnected ();\n+  \n+  /**\n+   * Tells whether or not a connection operation is in progress on this channel.\n+   */\n+  public abstract boolean isConnectionPending ();\n+  \n+  /**\n+   * Reads data from the channel.\n+   */\n+  public abstract long read (ByteBuffer[] dsts, int offset, int length);\n+ \n+  /**\n+   * Retrieves the channel's socket.\n+   */\n+  public abstract Socket socket ();\n+  \n+  /**\n+   * Writes data to the channel.\n+   */\n+  public abstract int write (ByteBuffer src);\n+  \n+  /**\n+   * Writes data to the channel.\n+   */\n+  public abstract long write (ByteBuffer[] srcs, int offset, int length);\n }"}, {"sha": "433b7294902b3e26079f67a9a65730aa819ffb9c", "filename": "libjava/java/nio/channels/spi/AbstractSelectableChannel.java", "status": "modified", "additions": 158, "deletions": 5, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2Fspi%2FAbstractSelectableChannel.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -1,4 +1,4 @@\n-/* AbstractSelectableChannel.java --\n+/* AbstractSelectableChannel.java\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,18 +37,171 @@\n \n package java.nio.channels.spi;\n \n+import java.io.IOException;\n+import java.nio.channels.ClosedChannelException;\n import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n \n-public abstract class AbstractSelectableChannel\n-  extends SelectableChannel\n+public abstract class AbstractSelectableChannel extends SelectableChannel\n {\n+  int registered;\n+  boolean blocking = true;\n+  Object LOCK = new Object ();\n+  SelectorProvider provider;\n+  List keys;\n+\n+  /**\n+   * Initializes the channel\n+   */\n   protected AbstractSelectableChannel (SelectorProvider provider)\n   {\n+    this.provider = provider;\n+  }\n+\n+  /**\n+   * Retrieves the object upon which the configureBlocking and register\n+   * methods synchronize.\n+   */\n+  public final Object blockingLock ()\n+  {\n+    return LOCK;\n+  }\n+    \n+  /**\n+   * Adjusts this channel's blocking mode.\n+   */\n+  public final SelectableChannel configureBlocking (boolean block)\n+  {\n+    synchronized (LOCK)\n+      {\n+    \tblocking = true;\n+    \timplConfigureBlocking (block);\n+      }\n+    \n+    return this;\n+  }\n+\n+  /**\n+   * Closes this channel.\n+   */\n+  protected final void implCloseChannel ()\n+  {\n+    implCloseSelectableChannel ();\n   }\n+\n+  /**\n+   * Closes this selectable channel.\n+   */\n+  protected abstract void implCloseSelectableChannel ();\n   \n+  /**\n+   * Adjusts this channel's blocking mode.\n+   */\n+  protected abstract void implConfigureBlocking (boolean block);\n+\n+  /**\n+   * Tells whether or not every I/O operation on this channel will block\n+   * until it completes.\n+   */\n   public final boolean isBlocking()\n   {\n-    return true;\n+    return blocking;\n+  }\n+\n+  /**\n+   * Tells whether or not this channel is currently registered with\n+   * any selectors.\n+   */\n+  public final boolean isRegistered()\n+  {\n+    return registered > 0;\n+  }\n+\n+  /**\n+   * Retrieves the key representing the channel's registration with the\n+   * given selector.\n+   */\n+  public final SelectionKey keyFor(Selector selector)\n+  {\n+    try\n+      {\n+        return register (selector, 0, null);\n+      }\n+    catch (Exception e)\n+      {\n+        return null;\n+      }\n   }\n-}\n \n+  /**\n+   * Returns the provider that created this channel.\n+   */\n+  public final SelectorProvider provider ()\n+  {\n+    return provider;\n+  }\n+\n+  private SelectionKey locate (Selector selector)\n+  {\n+    if (keys == null)\n+      return null;\n+    \n+    SelectionKey k = null;\n+    ListIterator it = keys.listIterator ();\n+    \n+    while (it.hasNext ())\n+      {\n+    \tk = (SelectionKey) it.next ();\n+    \tif (k.selector () == selector)\n+          {\n+            return k;\n+          }\n+      }\n+    \n+    return k;\n+  }\n+\n+  private void add (SelectionKey key)\n+  {\n+    if (keys == null)\n+      keys = new LinkedList ();\n+    \n+    keys.add (key);\n+  }\n+\n+  /**\n+   * Registers this channel with the given selector, returning a selection key.\n+   */\n+  public final SelectionKey register (Selector selin, int ops, Object att)\n+    throws ClosedChannelException\n+  {\n+    if (!isOpen ())\n+      throw new ClosedChannelException();\n+\n+    SelectionKey k = null;\n+    AbstractSelector selector = (AbstractSelector) selin;\n+\n+    synchronized (LOCK)\n+      {\n+    \tk = locate (selector);\n+\n+    \tif (k != null)\n+          {\n+            k.attach (att);\n+          }\n+    \telse\n+          {\n+            k = selector.register (this, ops, att);\n+    \t\t\n+            if (k != null)\n+              add (k);\n+    \t  }\n+      }\n+\n+    return k;\n+  }\n+}"}, {"sha": "5d96daf7f762db842e7396bca2d175c15494dea0", "filename": "libjava/java/nio/charset/Charset.java", "status": "modified", "additions": 209, "deletions": 48, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharset.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharset.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fcharset%2FCharset.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -37,54 +37,215 @@\n \n package java.nio.charset;\n \n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.spi.CharsetProvider;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import gnu.java.nio.charset.Provider;\n \n-import java.nio.*;\n-\n-public class Charset\n-{\n-    public static Charset forName(String name)\n-    {\n-\treturn new Charset();\n-    }\n-\n-/*\n-    public CharsetDecoder newDecoder()\n-    {\t\n-\treturn new CharsetDecoder(this,2,2)\n-\t    {\n-\t\tprotected CoderResult decodeLoop(ByteBuffer  in,\n-\t\t\t\t\t\t CharBuffer  out)\n-\t\t{\n-\t\t    while (in.hasRemaining())\n-\t\t\t{\n-\t\t\t    char a = (char) in.get();\n-\t\t\t    out.put(a);\n-\t\t\t}\n-\t\t    return null;\n-\t\t}\n-\t    };\n-    }\n-\n-    public CharsetEncoder newEncoder()\n-    {\t\t\n-\treturn new CharsetEncoder(this,2,2)\n-\t    {\n-\t\tprotected CoderResult encodeLoop(CharBuffer  in,\n-\t\t\t\t\t\t ByteBuffer  out)\n-\t\t{\n-\t\t    //System.out.println(\"in encode loop:\"+in.hasRemaining());\n-\n-\t\t    while (in.hasRemaining())\n-\t\t\t{\n-\t\t\t    char a = in.get();\n-\t\t\t    out.put((byte)a);\n-\n-\t\t\t    //int len = out.position();\n-\t\t\t    //System.out.println(\"pos=\"+len + \",\"+a);\n-\t\t\t}\n-\t\t    return null;\n-\t\t}\n-\t    };\n-    }\n+/**\n+ * @author Jesse Rosenstock\n+ * @since 1.4\n  */\n+public abstract class Charset implements Comparable\n+{\n+  private final String canonicalName;\n+  private final String[] aliases;\n+  \n+  protected Charset (String canonicalName, String[] aliases)\n+  {\n+    checkName (canonicalName);\n+    if (aliases != null)\n+      {\n+        int n = aliases.length;\n+        for (int i = 0; i < n; ++i)\n+            checkName (aliases[i]);\n+      }\n+\n+    this.canonicalName = canonicalName;\n+    this.aliases = aliases;\n+  }\n+\n+  /**\n+   * @throws IllegalCharsetNameException  if the name is illegal\n+   */\n+  private static void checkName (String name)\n+  {\n+    int n = name.length ();\n+\n+    if (n == 0)\n+      throw new IllegalCharsetNameException (name);\n+\n+    char ch = name.charAt (0);\n+    if (!(('A' <= ch && ch <= 'Z')\n+          || ('a' <= ch && ch <= 'z')\n+          || ('0' <= ch && ch <= '9')))\n+      throw new IllegalCharsetNameException (name);\n+\n+    for (int i = 1; i < n; ++i)\n+      {\n+        ch = name.charAt (i);\n+        if (!(('A' <= ch && ch <= 'Z')\n+              || ('a' <= ch && ch <= 'z')\n+              || ('0' <= ch && ch <= '9')\n+              || ch == '-' || ch == '.' || ch == ':' || ch == '_'))\n+          throw new IllegalCharsetNameException (name);\n+      }\n+  }\n+\n+  public static boolean isSupported (String charsetName)\n+  {\n+    return charsetForName (charsetName) != null;\n+  }\n+ \n+  public static Charset forName (String charsetName)\n+  {\n+    Charset cs = charsetForName (charsetName);\n+    if (cs == null)\n+      throw new UnsupportedCharsetException (charsetName);\n+    return cs;\n+  }\n+\n+  /**\n+   * Retrieves a charset for the given charset name.\n+   *\n+   * @return A charset object for the charset with the specified name, or\n+   *   <code>null</code> if no such charset exists.\n+   *\n+   * @throws IllegalCharsetNameException  if the name is illegal\n+   */\n+  private static Charset charsetForName (String charsetName)\n+  {\n+    checkName (charsetName);\n+    return provider ().charsetForName (charsetName);\n+  }\n+\n+  public static SortedMap availableCharsets ()\n+  {\n+    TreeMap charsets = new TreeMap (String.CASE_INSENSITIVE_ORDER);\n+\n+    for (Iterator i = provider ().charsets (); i.hasNext (); )\n+      {\n+        Charset cs = (Charset) i.next ();\n+        charsets.put (cs.name (), cs);\n+      }\n+\n+    return Collections.unmodifiableSortedMap (charsets);\n+  }\n+\n+  // XXX: we need to support multiple providers, reading them from\n+  // java.nio.charset.spi.CharsetProvider in the resource directory\n+  // META-INF/services\n+  private static final CharsetProvider provider ()\n+  {\n+    return Provider.provider ();\n+  }\n+\n+  public final String name ()\n+  {\n+    return canonicalName;\n+  }\n+\n+  public final Set aliases ()\n+  {\n+    if (aliases == null)\n+      return Collections.EMPTY_SET;\n+\n+    // should we cache the aliasSet instead?\n+    int n = aliases.length;\n+    HashSet aliasSet = new HashSet (n);\n+    for (int i = 0; i < n; ++i)\n+        aliasSet.add (aliases[i]);\n+    return Collections.unmodifiableSet (aliasSet);\n+  }\n+\n+  public String displayName ()\n+  {\n+    return canonicalName;\n+  }\n+\n+  public String displayName (Locale locale)\n+  {\n+    return canonicalName;\n+  }\n+\n+  public final boolean isRegistered (String name)\n+  {\n+    return !name.startsWith (\"x-\") && !name.startsWith (\"X-\");\n+  }\n+\n+  public abstract boolean contains (Charset cs);\n+\n+  public abstract CharsetDecoder newDecoder ();\n+\n+  public abstract CharsetEncoder newEncoder ();\n+\n+  public boolean canEncode ()\n+  {\n+    return true;\n+  }\n+\n+  public final ByteBuffer encode (CharBuffer cb)\n+  {\n+    try\n+      {\n+        // TODO: cache encoders between sucessive invocations\n+        return newEncoder ().onMalformedInput (CodingErrorAction.REPLACE)\n+                            .onUnmappableCharacter (CodingErrorAction.REPLACE)\n+                            .encode (cb);\n+      }\n+    catch (CharacterCodingException e)\n+      {\n+        throw new AssertionError (e);\n+      }\n+  }\n+  \n+  public final ByteBuffer encode (String str)\n+  {\n+    return encode (CharBuffer.wrap (str));\n+  }\n+\n+  public CharBuffer decode (ByteBuffer bb)\n+  {\n+    try\n+     {\n+        // TODO: cache encoders between sucessive invocations\n+        return newDecoder ().onMalformedInput (CodingErrorAction.REPLACE)\n+                            .onUnmappableCharacter (CodingErrorAction.REPLACE)\n+                            .decode (bb);\n+      }\n+    catch (CharacterCodingException e)\n+      {\n+        throw new AssertionError (e);\n+      }\n+  }\n+\n+  public final int compareTo (Object ob)\n+  {\n+    return canonicalName.compareToIgnoreCase (((Charset) ob).canonicalName);\n+  }\n+\n+  public final int hashCode ()\n+  {\n+    return canonicalName.hashCode ();\n+  }\n+\n+  public final boolean equals (Object ob)\n+  {\n+    if (ob instanceof Charset)\n+      return canonicalName.equalsIgnoreCase (((Charset) ob).canonicalName);\n+    else\n+      return false;\n+  }\n+\n+  public final String toString ()\n+  {\n+    return canonicalName;\n+  }\n }"}, {"sha": "185de149fd43d9a925df2d89df7b40d8d7b4e804", "filename": "libjava/java/nio/charset/CharsetDecoder.java", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetDecoder.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -0,0 +1,312 @@\n+/* CharsetDecoder.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+\n+/**\n+ * @author Jesse Rosenstock\n+ * @since 1.4\n+ */\n+public abstract class CharsetDecoder\n+{\n+  private static final int STATE_RESET   = 0;\n+  private static final int STATE_CODING  = 1;\n+  private static final int STATE_END     = 2;\n+  private static final int STATE_FLUSHED = 3;\n+\n+  private static final String DEFAULT_REPLACEMENT = \"\\uFFFD\";\n+\n+  private final Charset charset;\n+  private final float averageCharsPerByte;\n+  private final float maxCharsPerByte;\n+  private String replacement;\n+\n+  private int state = STATE_RESET;\n+\n+  private CodingErrorAction malformedInputAction\n+    = CodingErrorAction.REPORT;\n+  private CodingErrorAction unmappableCharacterAction\n+    = CodingErrorAction.REPORT;\n+\n+  private CharsetDecoder (Charset cs, float averageCharsPerByte,\n+                          float maxCharsPerByte, String replacement)\n+  {\n+    if (averageCharsPerByte <= 0.0f)\n+      throw new IllegalArgumentException (\"Non-positive averageCharsPerByte\");\n+    if (maxCharsPerByte <= 0.0f)\n+      throw new IllegalArgumentException (\"Non-positive maxCharsPerByte\");\n+\n+    this.charset = cs;\n+    this.averageCharsPerByte\n+      = averageCharsPerByte;\n+    this.maxCharsPerByte\n+      = maxCharsPerByte;\n+    this.replacement = replacement;\n+    implReplaceWith (replacement);\n+  }\n+\n+  protected CharsetDecoder (Charset cs, float averageCharsPerByte,\n+                            float maxCharsPerByte)\n+  {\n+    this (cs, averageCharsPerByte, maxCharsPerByte, DEFAULT_REPLACEMENT);\n+  }\n+\n+  public final float averageCharsPerByte ()\n+  {\n+    return averageCharsPerByte;\n+  }\n+\n+  public final Charset charset ()\n+  {\n+    return charset;\n+  }\n+\n+  public final CharBuffer decode (ByteBuffer in)\n+    throws CharacterCodingException\n+  {\n+    // XXX: Sun's Javadoc seems to contradict itself saying an\n+    // IllegalStateException is thrown \"if a decoding operation is already\n+    // in progress\" and also that \"it resets this Decoder\".\n+    // Should we check to see that the state is reset, or should we\n+    // call reset()?\n+    if (state != STATE_RESET)\n+      throw new IllegalStateException ();\n+\n+    // REVIEW: Using max instead of average may allocate a very large\n+    // buffer.  Maybe we should do something more efficient?\n+    int remaining = in.remaining ();\n+    int n = (int) (remaining * maxCharsPerByte ());\n+    CharBuffer out = CharBuffer.allocate (n);\n+\n+    if (remaining == 0)\n+      {\n+        state = STATE_FLUSHED;\n+        return out;\n+      }\n+\n+    CoderResult cr = decode (in, out, true);\n+    if (cr.isError ())\n+      cr.throwException ();\n+\n+    cr = flush (out);\n+    if (cr.isError ())\n+      cr.throwException ();\n+\n+    out.flip ();\n+    return out;\n+  }\n+\n+  public final CoderResult decode (ByteBuffer in, CharBuffer out,\n+                                   boolean endOfInput)\n+  {\n+    int newState = endOfInput ? STATE_END : STATE_CODING;\n+    // XXX: Need to check for \"previous step was an invocation [not] of\n+    // this method with a value of true for the endOfInput parameter but\n+    // a return value indicating an incomplete decoding operation\"\n+    // XXX: We will not check the previous return value, just\n+    // that the previous call passed true for endOfInput\n+    if (state != STATE_RESET && state != STATE_CODING\n+        && !(endOfInput && state == STATE_END))\n+      throw new IllegalStateException ();\n+    state = newState;\n+\n+    for (;;)\n+      {\n+        CoderResult cr;\n+        try\n+          {\n+            cr = decodeLoop (in, out);\n+          }\n+        catch (RuntimeException e)\n+          {\n+            throw new CoderMalfunctionError (e);\n+          }\n+\n+        if (cr.isOverflow ())\n+          return cr;\n+\n+        if (cr.isUnderflow ())\n+          {\n+            if (endOfInput && in.hasRemaining ())\n+              cr = CoderResult.malformedForLength (in.remaining ());\n+            else\n+              return cr;\n+          }\n+\n+        CodingErrorAction action = cr.isMalformed ()\n+                                     ? malformedInputAction\n+                                     : unmappableCharacterAction;\n+\n+        if (action == CodingErrorAction.REPORT)\n+          return cr;\n+\n+        if (action == CodingErrorAction.REPLACE)\n+          {\n+            if (out.remaining () < replacement.length ())\n+              return CoderResult.OVERFLOW;\n+            out.put (replacement);\n+          }\n+\n+        in.position (in.position () + cr.length ());\n+      }\n+  }\n+\n+  protected abstract CoderResult decodeLoop (ByteBuffer in, CharBuffer out);\n+\n+  public Charset detectedCharset ()\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+    \n+  public final CoderResult flush (CharBuffer out)\n+  {\n+    // It seems weird that you can flush after reset, but Sun's javadoc\n+    // says an IllegalStateException is thrown \"If the previous step of the\n+    // current decoding operation was an invocation neither of the reset\n+    // method nor ... of the three-argument decode method with a value of\n+    // true for the endOfInput parameter.\"\n+    // Further note that flush() only requires that there not be\n+    // an IllegalStateException if the previous step was a call to\n+    // decode with true as the last argument.  It does not require\n+    // that the call succeeded.  decode() does require that it succeeded.\n+    // XXX: test this to see if reality matches javadoc\n+    if (state != STATE_RESET && state != STATE_END)\n+      throw new IllegalStateException ();\n+\n+    state = STATE_FLUSHED;\n+    return implFlush (out);\n+  }\n+\n+  protected CoderResult implFlush (CharBuffer out)\n+  {\n+    return CoderResult.UNDERFLOW;\n+  }\n+\n+  public final CharsetDecoder onMalformedInput (CodingErrorAction newAction)\n+  {\n+    if (newAction == null)\n+      throw new IllegalArgumentException (\"Null action\");\n+\n+    malformedInputAction = newAction;\n+    implOnMalformedInput (newAction);\n+    return this;\n+  }\n+\n+  protected void implOnMalformedInput (CodingErrorAction newAction)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implOnUnmappableCharacter (CodingErrorAction newAction)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implReplaceWith (String newReplacement)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implReset ()\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  public boolean isAutoDetecting ()\n+  {\n+    return false;\n+  }\n+\n+  public boolean isCharsetDetected ()\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public CodingErrorAction malformedInputAction ()\n+  {\n+    return malformedInputAction;\n+  }\n+\n+  public final float maxCharsPerByte ()\n+  {\n+    return maxCharsPerByte;\n+  }\n+\n+  public final CharsetDecoder onUnmappableCharacter\n+    (CodingErrorAction newAction)\n+  {\n+    if (newAction == null)\n+      throw new IllegalArgumentException (\"Null action\");\n+\n+    unmappableCharacterAction = newAction;\n+    implOnUnmappableCharacter (newAction);\n+    return this;\n+  }\n+\n+  public final String replacement ()\n+  {\n+    return replacement;\n+  }\n+\n+  public final CharsetDecoder replaceWith (String newReplacement)\n+  {\n+    if (newReplacement == null)\n+      throw new IllegalArgumentException (\"Null replacement\");\n+    if (newReplacement.length () == 0)\n+      throw new IllegalArgumentException (\"Empty replacement\");\n+    // XXX: what about maxCharsPerByte?\n+\n+    this.replacement = newReplacement;\n+    implReplaceWith (newReplacement);\n+    return this;\n+  }\n+\n+  public final CharsetDecoder reset ()\n+  {\n+    state = STATE_RESET;\n+    implReset ();\n+    return this;\n+  }\n+\n+  public CodingErrorAction unmappableCharacterAction ()\n+  {\n+    return unmappableCharacterAction;\n+  }\n+}"}, {"sha": "dd434a79752e78436fc849685fe0a14715ec0d42", "filename": "libjava/java/nio/charset/CharsetEncoder.java", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetEncoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetEncoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fcharset%2FCharsetEncoder.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -0,0 +1,360 @@\n+/* CharsetEncoder.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.charset;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+\n+/**\n+ * @author Jesse Rosenstock\n+ * @since 1.4\n+ */\n+public abstract class CharsetEncoder\n+{\n+  private static final int STATE_RESET   = 0;\n+  private static final int STATE_CODING  = 1;\n+  private static final int STATE_END     = 2;\n+  private static final int STATE_FLUSHED = 3;\n+  \n+  private static final byte[] DEFAULT_REPLACEMENT = {(byte)'?'};\n+\n+  private final Charset charset;\n+  private final float averageBytesPerChar;\n+  private final float maxBytesPerChar;\n+  private byte[] replacement;\n+\n+  private int state = STATE_RESET;\n+\n+  private CodingErrorAction malformedInputAction\n+    = CodingErrorAction.REPORT;\n+  private CodingErrorAction unmappableCharacterAction\n+    = CodingErrorAction.REPORT;\n+\n+  protected CharsetEncoder (Charset cs, float averageBytesPerChar,\n+                            float maxBytesPerChar)\n+  {\n+    this (cs, averageBytesPerChar, maxBytesPerChar, DEFAULT_REPLACEMENT);\n+  }\n+\n+  protected CharsetEncoder (Charset cs, float averageBytesPerChar, \n+                            float maxBytesPerChar, byte[] replacement)\n+  {\n+    if (averageBytesPerChar <= 0.0f)\n+      throw new IllegalArgumentException (\"Non-positive averageBytesPerChar\");\n+    if (maxBytesPerChar <= 0.0f)\n+      throw new IllegalArgumentException (\"Non-positive maxBytesPerChar\");\n+\n+    this.charset = cs;\n+    this.averageBytesPerChar\n+      = averageBytesPerChar;\n+    this.maxBytesPerChar\n+      = maxBytesPerChar;\n+    this.replacement = replacement;\n+    implReplaceWith (replacement);\n+  }\n+ \n+  public final float averageBytesPerChar ()\n+  {\n+    return averageBytesPerChar;\n+  }\n+\n+  public boolean canEncode (char c)\n+  {\n+    CharBuffer cb = CharBuffer.allocate (1).put (c);\n+    cb.flip ();\n+    return canEncode (cb);\n+  }\n+\n+  public boolean canEncode (CharSequence cs)\n+  {\n+    CharBuffer cb;\n+    if (cs instanceof CharBuffer)\n+      cb = ((CharBuffer) cs).duplicate ();\n+    else\n+      cb = CharBuffer.wrap (cs);\n+    return canEncode (cb);\n+  }\n+\n+  private boolean canEncode (CharBuffer cb)\n+  {\n+    // It is an error if a coding operation is \"in progress\"\n+    // I take that to mean the state is not reset or flushed.\n+    // XXX: check \"in progress\" everywhere\n+    if (state == STATE_FLUSHED)\n+      reset ();\n+    else if (state != STATE_RESET)\n+      throw new IllegalStateException ();\n+\n+    CodingErrorAction oldMalformedInputAction = malformedInputAction;\n+    CodingErrorAction oldUnmappableCharacterAction\n+      = unmappableCharacterAction;\n+\n+    try\n+      {\n+        if (oldMalformedInputAction != CodingErrorAction.REPORT)\n+          onMalformedInput (CodingErrorAction.REPORT);\n+        if (oldUnmappableCharacterAction != CodingErrorAction.REPORT)\n+          onUnmappableCharacter (CodingErrorAction.REPORT);\n+      }\n+    catch (Exception e)\n+      {\n+        return false;\n+      }\n+    finally\n+      {\n+        if (oldMalformedInputAction != CodingErrorAction.REPORT)\n+          onMalformedInput (oldMalformedInputAction);\n+        if (oldUnmappableCharacterAction != CodingErrorAction.REPORT)\n+          onUnmappableCharacter (oldUnmappableCharacterAction);\n+      }\n+\n+    return true;\n+  }\n+\n+  public final Charset charset ()\n+  {\n+    return charset;\n+  }\n+\n+  public final ByteBuffer encode (CharBuffer in)\n+    throws CharacterCodingException\n+  {\n+    // XXX: Sun's Javadoc seems to contradict itself saying an\n+    // IllegalStateException is thrown \"if a decoding operation is already\n+    // in progress\" and also that \"it resets this Encoder\".\n+    // Should we check to see that the state is reset, or should we\n+    // call reset()?\n+    if (state != STATE_RESET)\n+      throw new IllegalStateException ();\n+\n+    // REVIEW: Using max instead of average may allocate a very large\n+    // buffer.  Maybe we should do something more efficient?\n+    int remaining = in.remaining ();\n+    int n = (int) (remaining * maxBytesPerChar ());\n+    ByteBuffer out = ByteBuffer.allocate (n);\n+\n+    if (remaining == 0)\n+      {\n+        state = STATE_FLUSHED;\n+        return out;\n+      }\n+\n+    CoderResult cr = encode (in, out, true);\n+    if (cr.isError ())\n+      cr.throwException ();\n+\n+    cr = flush (out);\n+    if (cr.isError ())\n+      cr.throwException ();\n+\n+    out.flip ();\n+    return out;\n+  }\n+\n+  public final CoderResult encode (CharBuffer in, ByteBuffer out,\n+                                   boolean endOfInput)\n+  {\n+    int newState = endOfInput ? STATE_END : STATE_CODING;\n+    // XXX: Need to check for \"previous step was an invocation [not] of\n+    // this method with a value of true for the endOfInput parameter but\n+    // a return value indicating an incomplete decoding operation\"\n+    // XXX: We will not check the previous return value, just\n+    // that the previous call passed true for endOfInput\n+    if (state != STATE_RESET && state != STATE_CODING\n+        && !(endOfInput && state == STATE_END))\n+      throw new IllegalStateException ();\n+    state = newState;\n+\n+    for (;;)\n+      {\n+        CoderResult cr;\n+        try\n+          {\n+            cr = encodeLoop (in, out);\n+          }\n+        catch (RuntimeException e)\n+          {\n+            throw new CoderMalfunctionError (e);\n+          }\n+\n+        if (cr.isOverflow ())\n+          return cr;\n+\n+        if (cr.isUnderflow ())\n+          {\n+            if (endOfInput && in.hasRemaining ())\n+              cr = CoderResult.malformedForLength (in.remaining ());\n+            else\n+              return cr;\n+          }\n+\n+        CodingErrorAction action = cr.isMalformed ()\n+                                     ? malformedInputAction\n+                                     : unmappableCharacterAction;\n+\n+        if (action == CodingErrorAction.REPORT)\n+          return cr;\n+\n+        if (action == CodingErrorAction.REPLACE)\n+          {\n+            if (out.remaining () < replacement.length)\n+              return CoderResult.OVERFLOW;\n+            out.put (replacement);\n+          }\n+\n+        in.position (in.position () + cr.length ());\n+      }\n+  }\n+\n+  protected abstract CoderResult encodeLoop (CharBuffer in, ByteBuffer out);\n+\n+  public final CoderResult flush (ByteBuffer out)\n+  {\n+    // It seems weird that you can flush after reset, but Sun's javadoc\n+    // says an IllegalStateException is thrown \"If the previous step of the\n+    // current decoding operation was an invocation neither of the reset\n+    // method nor ... of the three-argument encode method with a value of\n+    // true for the endOfInput parameter.\"\n+    // Further note that flush() only requires that there not be\n+    // an IllegalStateException if the previous step was a call to\n+    // encode with true as the last argument.  It does not require\n+    // that the call succeeded.  encode() does require that it succeeded.\n+    // XXX: test this to see if reality matches javadoc\n+    if (state != STATE_RESET && state != STATE_END)\n+      throw new IllegalStateException ();\n+\n+    state = STATE_FLUSHED;\n+    return implFlush (out);\n+  }\n+\n+  protected CoderResult implFlush (ByteBuffer out)\n+  {\n+    return CoderResult.UNDERFLOW;\n+  }\n+\n+  protected void implOnMalformedInput (CodingErrorAction newAction)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implOnUnmappableCharacter (CodingErrorAction newAction)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implReplaceWith (byte[] newReplacement)\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  protected void implReset ()\n+  {\n+    // default implementation does nothing\n+  }\n+\n+  public boolean isLegalReplacement (byte[] replacement)\n+  {\n+    // TODO: cache the decoder\n+    // error actions will be REPORT after construction\n+    CharsetDecoder decoder = charset.newDecoder ();\n+    ByteBuffer bb = ByteBuffer.wrap (replacement);\n+    CharBuffer cb\n+      = CharBuffer.allocate ((int) (replacement.length\n+                                    * decoder.maxCharsPerByte ()));\n+    return !decoder.decode (bb, cb, true).isError ();\n+  }\n+\n+  public CodingErrorAction malformedInputAction ()\n+  {\n+    return malformedInputAction;\n+  }\n+\n+  public final float maxBytesPerChar ()\n+  {\n+    return maxBytesPerChar;\n+  }\n+\n+  public final CharsetEncoder onMalformedInput (CodingErrorAction newAction)\n+  {\n+    if (newAction == null)\n+      throw new IllegalArgumentException (\"Null action\");\n+\n+    malformedInputAction = newAction;\n+    implOnMalformedInput (newAction);\n+    return this;\n+  }\n+\n+  public final CharsetEncoder onUnmappableCharacter\n+    (CodingErrorAction newAction)\n+  {\n+    if (newAction == null)\n+      throw new IllegalArgumentException (\"Null action\");\n+\n+    unmappableCharacterAction = newAction;\n+    implOnUnmappableCharacter (newAction);\n+    return this;\n+  }\n+\n+  public final byte[] replacement ()\n+  {\n+    return replacement;\n+  }\n+\n+  public final CharsetEncoder replaceWith (byte[] newReplacement)\n+  {\n+    if (newReplacement == null)\n+      throw new IllegalArgumentException (\"Null replacement\");\n+    if (newReplacement.length == 0)\n+      throw new IllegalArgumentException (\"Empty replacement\");\n+    // XXX: what about maxBytesPerChar?\n+\n+      if (!isLegalReplacement (newReplacement))\n+        throw new IllegalArgumentException (\"Illegal replacement\");\n+\n+    this.replacement = newReplacement;\n+    implReplaceWith (newReplacement);\n+    return this;\n+  }\n+\n+  public final CharsetEncoder reset ()\n+  {\n+    state = STATE_RESET;\n+    implReset ();\n+    return this;\n+  }\n+}"}, {"sha": "69deadcc4f02c4ac3aae66b8f6d18ddff720ed3a", "filename": "libjava/java/nio/charset/CoderResult.java", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCoderResult.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f93f9f2865f06a0929d5311101c5bc4b6565bc/libjava%2Fjava%2Fnio%2Fcharset%2FCoderResult.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fcharset%2FCoderResult.java?ref=93f93f9f2865f06a0929d5311101c5bc4b6565bc", "patch": "@@ -0,0 +1,193 @@\n+/* CoderResult.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.charset;\n+\n+import java.lang.ref.WeakReference;\n+import java.nio.BufferOverflowException;\n+import java.nio.BufferUnderflowException;\n+import java.util.HashMap;\n+\n+/**\n+ * @author Jesse Rosenstock\n+ * @since 1.4\n+ */\n+public class CoderResult\n+{ \n+  private static final int TYPE_MALFORMED  = 0;\n+  private static final int TYPE_OVERFLOW   = 1;\n+  private static final int TYPE_UNDERFLOW  = 2;\n+  private static final int TYPE_UNMAPPABLE = 3;\n+\n+  public static final CoderResult OVERFLOW\n+    = new CoderResult (TYPE_OVERFLOW, 0);\n+  public static final CoderResult UNDERFLOW\n+    = new CoderResult (TYPE_UNDERFLOW, 0);\n+  \n+  private static final String[] names\n+    = { \"MALFORMED\", \"OVERFLOW\", \"UNDERFLOW\", \"UNMAPPABLE\" };\n+\n+  private static final Cache malformedCache\n+    = new Cache ()\n+      {\n+        protected CoderResult make (int length)\n+        {\n+          return new CoderResult (TYPE_MALFORMED, length);\n+        }\n+      };\n+\n+  private static final Cache unmappableCache\n+    = new Cache ()\n+      {\n+        protected CoderResult make (int length)\n+        {\n+          return new CoderResult (TYPE_UNMAPPABLE, length);\n+        }\n+      };\n+\n+  private final int type;\n+  private final int length;\n+\n+  private CoderResult (int type, int length)\n+  {\n+    this.type = type;\n+    this.length = length;\n+  }\n+\n+  public boolean isError ()\n+  {\n+    return length > 0;\n+  }\n+\n+  public boolean isMalformed ()\n+  {\n+    return type == TYPE_MALFORMED;\n+  }\n+\n+  public boolean isOverflow ()\n+  {\n+    return type == TYPE_OVERFLOW;\n+  }\n+\n+  public boolean isUnderflow ()\n+  {\n+    return type == TYPE_UNDERFLOW;\n+  }\n+\n+  public boolean isUnmappable ()\n+  {\n+    return type == TYPE_UNMAPPABLE;\n+  }\n+\n+  public int length ()\n+  {\n+    if (length <= 0)\n+      throw new UnsupportedOperationException ();\n+    else\n+      return length;\n+  }\n+\n+  public static CoderResult malformedForLength (int length)\n+  {\n+    return malformedCache.get (length);\n+  }\n+    \n+  public void throwException ()\n+    throws CharacterCodingException\n+  {\n+    switch (type)\n+      {\n+        case TYPE_MALFORMED:\n+          throw new MalformedInputException (length);\n+        case TYPE_OVERFLOW:\n+          throw new BufferOverflowException ();\n+        case TYPE_UNDERFLOW:\n+          throw new BufferUnderflowException ();\n+        case TYPE_UNMAPPABLE:\n+          throw new UnmappableCharacterException (length);\n+      }\n+  }\n+\n+  public String toString ()\n+  {\n+    String name = names[type];\n+    return (length > 0) ? name + '[' + length + ']' : name;\n+  }\n+\n+  public static CoderResult unmappableForLength (int length)\n+  {\n+    return unmappableCache.get (length);\n+  }    \n+\n+  private abstract static class Cache\n+  {\n+    private final HashMap cache;\n+\n+    private Cache ()\n+    {\n+      // If we didn't synchronize on this, then cache would be initialized\n+      // without holding a lock.  Undefined behavior would occur if the\n+      // first thread to call get(int) was not the same as the one that\n+      // called the constructor.\n+      synchronized (this)\n+        {\n+          cache = new HashMap ();\n+        }\n+    }\n+\n+    private synchronized CoderResult get (int length)\n+    {\n+      if (length <= 0)\n+        throw new IllegalArgumentException (\"Non-positive length\");\n+\n+      Integer len = new Integer (length);\n+      CoderResult cr = null;\n+      Object o;\n+      if ((o = cache.get (len)) != null)\n+        cr = (CoderResult) ((WeakReference) o).get ();\n+      if (cr == null)\n+        {\n+          cr = make (length);\n+          cache.put (len, cr);\n+        }\n+\n+      return cr;\n+    }\n+\n+    protected abstract CoderResult make (int length);\n+  }\n+}"}]}