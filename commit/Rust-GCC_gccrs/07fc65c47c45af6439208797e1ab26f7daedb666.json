{"sha": "07fc65c47c45af6439208797e1ab26f7daedb666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdmYzY1YzQ3YzQ1YWY2NDM5MjA4Nzk3ZTFhYjI2ZjdkYWVkYjY2Ng==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2002-03-08T20:11:04Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2002-03-08T20:11:04Z"}, "message": "41intnam.ads, [...]: Merge in ACT changes.\n\n\t* 41intnam.ads, 42intnam.ads, 4aintnam.ads, 4cintnam.ads,\n\t4dintnam.ads, 4gintnam.ads, 4hintnam.ads, 4lintnam.ads,\n\t4mintnam.ads, 4pintnam.ads, 4rintnam.ads, 4sintnam.ads,\n\t4uintnam.ads, 4vcalend.adb, 4zintnam.ads, 52system.ads,\n\t5amastop.adb, 5asystem.ads, 5ataprop.adb, 5atpopsp.adb,\n\t5avxwork.ads, 5bosinte.adb, 5bsystem.ads, 5esystem.ads,\n\t5fsystem.ads, 5ftaprop.adb, 5ginterr.adb, 5gmastop.adb,\n\t5gsystem.ads, 5gtaprop.adb, 5gtasinf.adb, 5gtasinf.ads,\n\t5hparame.ads, 5hsystem.ads, 5htaprop.adb, 5htraceb.adb,\n\t5itaprop.adb, 5ksystem.ads, 5kvxwork.ads, 5lintman.adb,\n\t5lsystem.ads, 5mvxwork.ads, 5ninmaop.adb, 5nosinte.ads,\n\t5ntaprop.adb, 5ointerr.adb, 5omastop.adb, 5oosinte.adb,\n\t5osystem.ads, 5otaprop.adb, 5otaspri.ads, 5pvxwork.ads,\n\t5qtaprop.adb, 5sintman.adb, 5ssystem.ads, 5staprop.adb,\n\t5stpopse.adb, 5svxwork.ads, 5tosinte.ads, 5uintman.adb,\n\t5vasthan.adb, 5vinmaop.adb, 5vinterr.adb, 5vintman.adb,\n\t5vmastop.adb, 5vparame.ads, 5vsystem.ads, 5vtaprop.adb,\n\t5vtpopde.adb, 5wmemory.adb, 5wsystem.ads, 5wtaprop.adb,\n\t5ysystem.ads, 5zinterr.adb, 5zintman.adb, 5zosinte.adb,\n\t5zosinte.ads, 5zsystem.ads, 5ztaprop.adb, 6vcpp.adb, 6vcstrea.adb,\n\t7sintman.adb, 7staprop.adb, 7stpopsp.adb, 9drpc.adb,\n\tMake-lang.in, Makefile.in, a-caldel.adb, a-comlin.ads,\n\ta-dynpri.adb, a-except.adb, a-except.ads, a-finali.adb,\n\ta-ncelfu.ads, a-reatim.adb, a-retide.adb, a-stream.ads,\n\ta-ststio.adb, a-ststio.ads, a-stwifi.adb, a-tags.adb, a-tasatt.adb,\n\ta-textio.adb, a-tideau.adb, a-tiflau.adb, a-tigeau.adb,\n\ta-tigeau.ads, a-tiinau.adb, a-timoau.adb, a-witeio.adb,\n\ta-wtdeau.adb, a-wtenau.adb, a-wtflau.adb, a-wtgeau.adb,\n\ta-wtgeau.ads, a-wtinau.adb, a-wtmoau.adb, ada-tree.def, ada-tree.h,\n\tadaint.c, adaint.h, ali-util.adb, ali.adb, ali.ads, atree.adb,\n\tatree.ads, atree.h, back_end.adb, bcheck.adb, bindgen.adb,\n\tbindusg.adb, checks.adb, comperr.adb, config-lang.in, csets.adb,\n\tcsets.ads, cstand.adb, cstreams.c, debug.adb, debug.ads, decl.c,\n\teinfo.adb, einfo.ads, einfo.h, elists.h, errout.adb, errout.ads,\n\teval_fat.adb, exp_aggr.adb, exp_attr.adb, exp_ch11.adb,\n\texp_ch12.adb, exp_ch13.adb, exp_ch2.adb, exp_ch3.adb, exp_ch3.ads,\n\texp_ch4.adb, exp_ch5.adb, exp_ch6.adb, exp_ch7.adb, exp_ch7.ads,\n\texp_ch9.adb, exp_ch9.ads, exp_dbug.adb, exp_dbug.ads, exp_disp.ads,\n\texp_dist.adb, exp_fixd.adb, exp_intr.adb, exp_pakd.adb,\n\texp_prag.adb, exp_strm.adb, exp_util.adb, exp_util.ads,\n\texpander.adb, expect.c, fe.h, fmap.adb, fmap.ads, fname-uf.adb,\n\tfreeze.adb, frontend.adb, g-awk.adb, g-cgideb.adb, g-comlin.adb,\n\tg-comlin.ads, g-debpoo.adb, g-dirope.adb, g-dirope.ads,\n\tg-dyntab.adb, g-expect.adb, g-expect.ads, g-io.ads, g-io_aux.adb,\n\tg-io_aux.ads, g-locfil.adb, g-locfil.ads, g-os_lib.adb,\n\tg-os_lib.ads, g-regexp.adb, g-regpat.adb, g-socket.adb,\n\tg-socket.ads, g-spipat.adb, g-table.adb, g-trasym.adb,\n\tg-trasym.ads, gigi.h, gmem.c, gnat1drv.adb, gnatbind.adb, gnatbl.c,\n\tgnatchop.adb, gnatcmd.adb, gnatdll.adb, gnatfind.adb, gnatlbr.adb,\n\tgnatlink.adb, gnatls.adb, gnatmem.adb, gnatprep.adb, gnatvsn.ads,\n\tgnatxref.adb, hlo.adb, hostparm.ads, i-cobol.adb, i-cpp.adb,\n\ti-cstrea.ads, i-cstrin.adb, i-pacdec.adb, i-vxwork.ads,\n\timpunit.adb, init.c, inline.adb, io-aux.c, layout.adb, lib-load.adb,\n\tlib-util.adb, lib-writ.adb, lib-writ.ads, lib-xref.adb,\n\tlib-xref.ads, lib.adb, lib.ads, make.adb, makeusg.adb, mdll.adb,\n\tmemroot.adb, misc.c, mlib-tgt.adb, mlib-utl.adb, mlib-utl.ads,\n\tmlib.adb, namet.adb, namet.ads, namet.h, nlists.h, nmake.adb,\n\tnmake.ads, nmake.adt, opt.adb, opt.ads, osint.adb, osint.ads,\n\toutput.adb, output.ads, par-ch2.adb, par-ch3.adb, par-ch5.adb,\n\tpar-prag.adb, par-tchk.adb, par-util.adb, par.adb, prj-attr.adb,\n\tprj-dect.adb, prj-env.adb, prj-env.ads, prj-nmsc.adb, prj-part.adb,\n\tprj-proc.adb, prj-strt.adb, prj-tree.adb, prj-tree.ads, prj.adb,\n\tprj.ads, raise.c, raise.h, repinfo.adb, restrict.adb, restrict.ads,\n\trident.ads, rtsfind.adb, rtsfind.ads, s-arit64.adb, s-asthan.adb,\n\ts-atacco.adb, s-atacco.ads, s-auxdec.adb, s-crc32.adb, s-crc32.ads,\n\ts-direio.adb, s-fatgen.adb, s-fileio.adb, s-finimp.adb,\n\ts-gloloc.adb, s-gloloc.ads, s-interr.adb, s-mastop.adb,\n\ts-mastop.ads, s-memory.adb, s-parame.ads, s-parint.adb,\n\ts-pooglo.adb, s-pooloc.adb, s-rpc.adb, s-secsta.adb, s-sequio.adb,\n\ts-shasto.adb, s-soflin.adb, s-soflin.ads, s-stache.adb,\n\ts-taasde.adb, s-taasde.ads, s-tadeca.adb, s-tadeca.ads,\n\ts-tadert.adb, s-tadert.ads, s-taenca.adb, s-taenca.ads,\n\ts-taprob.adb, s-taprop.ads, s-tarest.adb, s-tasdeb.adb,\n\ts-tasini.adb, s-tasini.ads, s-taskin.adb, s-taskin.ads,\n\ts-tasque.adb, s-tasque.ads, s-tasren.adb, s-tasren.ads,\n\ts-tassta.adb, s-tasuti.adb, s-tasuti.ads, s-tataat.adb,\n\ts-tataat.ads, s-tpoben.adb, s-tpoben.ads, s-tpobop.adb,\n\ts-tposen.adb, s-tposen.ads, s-traceb.adb, s-traceb.ads,\n\ts-unstyp.ads, s-widenu.adb, scn-nlit.adb, scn.adb, sem.adb,\n\tsem_aggr.adb, sem_attr.adb, sem_attr.ads, sem_case.adb,\n\tsem_ch10.adb, sem_ch11.adb, sem_ch11.ads, sem_ch12.adb,\n\tsem_ch13.adb, sem_ch13.ads, sem_ch2.adb, sem_ch3.adb, sem_ch3.ads,\n\tsem_ch4.adb, sem_ch5.adb, sem_ch6.adb, sem_ch6.ads, sem_ch7.adb,\n\tsem_ch8.adb, sem_ch8.ads, sem_ch9.adb, sem_disp.adb, sem_dist.adb,\n\tsem_elab.adb, sem_elim.adb, sem_elim.ads, sem_eval.adb,\n\tsem_intr.adb, sem_mech.adb, sem_prag.adb, sem_res.adb,\n\tsem_type.adb, sem_util.adb, sem_util.ads, sem_vfpt.adb,\n\tsem_warn.adb, sinfo.adb, sinfo.ads, sinfo.h, sinput-l.adb,\n\tsinput-l.ads, sinput.adb, sinput.ads, snames.adb, snames.ads,\n\tsnames.h, sprint.adb, sprint.ads, stringt.adb, stringt.ads,\n\tstringt.h, style.adb, switch.adb, switch.ads, sysdep.c, system.ads,\n\ttable.adb, targparm.adb, targparm.ads, targtyps.c, tbuild.adb,\n\ttbuild.ads, tracebak.c, trans.c, tree_gen.adb, tree_io.adb,\n\ttreepr.adb, treepr.ads, treeprs.ads, treeprs.adt, ttypes.ads,\n\ttypes.adb, types.ads, types.h, uintp.ads, urealp.ads, usage.adb,\n\tutils.c, utils2.c, validsw.adb, xnmake.adb, xr_tabls.adb,\n\txr_tabls.ads, xref_lib.adb, xref_lib.ads : Merge in ACT changes.\n\n\t* 1ssecsta.adb, 1ssecsta.ads, a-chlat9.ads, a-cwila9.ads,\n\tg-enblsp.adb, g-md5.adb, g-md5.ads, gnatname.adb, gnatname.ads,\n\tmkdir.c, osint-b.adb, osint-b.ads, osint-c.adb, osint-c.ads,\n\tosint-l.adb, osint-l.ads, osint-m.adb, osint-m.ads : New files\n\n\t* 3lsoccon.ads, 5qparame.ads, 5qvxwork.ads, 5smastop.adb,\n\t5zparame.ads, gnatmain.adb, gnatmain.ads, gnatpsys.adb : Removed\n\n\t* mdllfile.adb, mdllfile.ads, mdlltool.adb, mdlltool.ads : Renamed\n\tto mdll-fil.ad[bs] and mdll-util.ad[bs]\n\n\t* mdll-fil.adb, mdll-fil.ads, mdll-utl.adb, mdll-utl.ads : Renamed\n\tfrom mdllfile.ad[bs] and mdlltool.ad[bs]\n\nFrom-SVN: r50451", "tree": {"sha": "b584a79288c93215b05fb451943291ccd039388b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b584a79288c93215b05fb451943291ccd039388b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07fc65c47c45af6439208797e1ab26f7daedb666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07fc65c47c45af6439208797e1ab26f7daedb666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07fc65c47c45af6439208797e1ab26f7daedb666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07fc65c47c45af6439208797e1ab26f7daedb666/comments", "author": null, "committer": null, "parents": [{"sha": "24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514"}], "stats": {"total": 54992, "additions": 30569, "deletions": 24423}, "files": [{"sha": "0bb1f2ac1226849a0c438e12d3a657644bf5988a", "filename": "gcc/ada/1ssecsta.adb", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F1ssecsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F1ssecsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F1ssecsta.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -0,0 +1,145 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . S E C O N D A R Y _ S T A C K                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the HI-E version of this package.\n+\n+with Unchecked_Conversion;\n+\n+package body System.Secondary_Stack is\n+\n+   use type SSE.Storage_Offset;\n+\n+   type Memory is array (Mark_Id range <>) of SSE.Storage_Element;\n+\n+   type Stack_Id is record\n+      Top  : Mark_Id;\n+      Last : Mark_Id;\n+      Mem  : Memory (1 .. Mark_Id'Last);\n+   end record;\n+   pragma Suppress_Initialization (Stack_Id);\n+\n+   type Stack_Ptr is access Stack_Id;\n+\n+   function From_Addr is new Unchecked_Conversion (Address, Stack_Ptr);\n+\n+   function Get_Sec_Stack return Stack_Ptr;\n+   pragma Import (C, Get_Sec_Stack, \"__gnat_get_secondary_stack\");\n+   --  Return the address of the secondary stack.\n+   --  In a multi-threaded environment, Sec_Stack should be a thread-local\n+   --  variable.\n+\n+   --  Possible implementation of Get_Sec_Stack in a single-threaded\n+   --  environment:\n+   --\n+   --     Chunk : aliased Memory (1 .. Default_Secondary_Stack_Size);\n+   --     for Chunk'Alignment use Standard'Maximum_Alignment;\n+   --     --  The secondary stack.\n+   --\n+   --     function Get_Sec_Stack return Stack_Ptr is\n+   --     begin\n+   --        return From_Addr (Chunk'Address);\n+   --     end Get_Sec_Stack;\n+   --\n+   --  begin\n+   --     SS_Init (Chunk'Address, Default_Secondary_Stack_Size);\n+   --  end System.Secondary_Stack;\n+\n+   -----------------\n+   -- SS_Allocate --\n+   -----------------\n+\n+   procedure SS_Allocate\n+     (Address      : out System.Address;\n+      Storage_Size : SSE.Storage_Count)\n+   is\n+      Max_Align    : constant Mark_Id := Mark_Id (Standard'Maximum_Alignment);\n+      Max_Size     : constant Mark_Id :=\n+                       ((Mark_Id (Storage_Size) + Max_Align - 1) / Max_Align)\n+                         * Max_Align;\n+      Sec_Stack    : constant Stack_Ptr := Get_Sec_Stack;\n+\n+   begin\n+      if Sec_Stack.Top + Max_Size > Sec_Stack.Last then\n+         raise Storage_Error;\n+      end if;\n+\n+      Address := Sec_Stack.Mem (Sec_Stack.Top)'Address;\n+      Sec_Stack.Top := Sec_Stack.Top + Mark_Id (Max_Size);\n+   end SS_Allocate;\n+\n+   -------------\n+   -- SS_Free --\n+   -------------\n+\n+   procedure SS_Free (Stk : in out System.Address) is\n+   begin\n+      Stk := Null_Address;\n+   end SS_Free;\n+\n+   -------------\n+   -- SS_Init --\n+   -------------\n+\n+   procedure SS_Init\n+     (Stk  : System.Address;\n+      Size : Natural := Default_Secondary_Stack_Size)\n+   is\n+      Stack : Stack_Ptr := From_Addr (Stk);\n+   begin\n+      pragma Assert (Size >= 2 * Mark_Id'Max_Size_In_Storage_Elements);\n+\n+      Stack.Top := Stack.Mem'First;\n+      Stack.Last := Mark_Id (Size) - 2 * Mark_Id'Max_Size_In_Storage_Elements;\n+   end SS_Init;\n+\n+   -------------\n+   -- SS_Mark --\n+   -------------\n+\n+   function SS_Mark return Mark_Id is\n+   begin\n+      return Get_Sec_Stack.Top;\n+   end SS_Mark;\n+\n+   ----------------\n+   -- SS_Release --\n+   ----------------\n+\n+   procedure SS_Release (M : Mark_Id) is\n+   begin\n+      Get_Sec_Stack.Top := M;\n+   end SS_Release;\n+\n+end System.Secondary_Stack;"}, {"sha": "a2212e5dd676d834b84b4c92b4b45c2ac18c3773", "filename": "gcc/ada/1ssecsta.ads", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F1ssecsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F1ssecsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F1ssecsta.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -0,0 +1,85 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . S E C O N D A R Y _ S T A C K                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Storage_Elements;\n+\n+package System.Secondary_Stack is\n+\n+   package SSE renames System.Storage_Elements;\n+\n+   Default_Secondary_Stack_Size : constant := 10 * 1024;\n+   --  Default size of a secondary stack\n+\n+   procedure SS_Init\n+     (Stk  : System.Address;\n+      Size : Natural := Default_Secondary_Stack_Size);\n+   --  Initialize the secondary stack with a main stack of the given Size.\n+   --\n+   --  Stk is an \"in\" parameter that is already pointing to a memory area of\n+   --  size Size.\n+   --\n+   --  The secondary stack is fixed, and any attempt to allocate more than the\n+   --  initial size will result in a Storage_Error being raised.\n+\n+   procedure SS_Allocate\n+     (Address      : out System.Address;\n+      Storage_Size : SSE.Storage_Count);\n+   --  Allocate enough space for a 'Storage_Size' bytes object with Maximum\n+   --  alignment. The address of the allocated space is returned in 'Address'\n+\n+   procedure SS_Free (Stk : in out System.Address);\n+   --  Release the memory allocated for the Secondary Stack. That is to say,\n+   --  all the allocated chuncks.\n+   --  Upon return, Stk will be set to System.Null_Address\n+\n+   type Mark_Id is private;\n+   --  Type used to mark the stack.\n+\n+   function SS_Mark return Mark_Id;\n+   --  Return the Mark corresponding to the current state of the stack\n+\n+   procedure SS_Release (M : Mark_Id);\n+   --  Restore the state of the stack corresponding to the mark M. If an\n+   --  additional chunk have been allocated, it will never be freed during a\n+\n+private\n+\n+   SS_Pool : Integer;\n+   --  Unused entity that is just present to ease the sharing of the pool\n+   --  mechanism for specific allocation/deallocation in the compiler\n+\n+   type Mark_Id is new SSE.Integer_Address;\n+\n+end System.Secondary_Stack;"}, {"sha": "4371e0d3a3704e0fe2e469a4f4557ae7c1731ec3", "filename": "gcc/ada/3lsoccon.ads", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F3lsoccon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F3lsoccon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F3lsoccon.ads?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "patch": "@@ -1,115 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               G N A T . S O C K E T S . C O N S T A N T S                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                            $Revision$\n---                                                                          --\n---              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT is maintained by Ada Core Technologies Inc (http://www.gnat.com).   --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the version for GNU/Linux\n-\n-package GNAT.Sockets.Constants is\n-\n-   --  Families\n-\n-   AF_INET              : constant :=                2;\n-   AF_INET6             : constant :=               10;\n-\n-   --  Modes\n-\n-   SOCK_STREAM          : constant :=                1;\n-   SOCK_DGRAM           : constant :=                2;\n-\n-   --  Socket Errors\n-\n-   EBADF                : constant :=                9;\n-   ENOTSOCK             : constant :=               88;\n-   ENOTCONN             : constant :=              107;\n-   ENOBUFS              : constant :=              105;\n-   EOPNOTSUPP           : constant :=               95;\n-   EFAULT               : constant :=               14;\n-   EWOULDBLOCK          : constant :=               11;\n-   EADDRNOTAVAIL        : constant :=               99;\n-   EMSGSIZE             : constant :=               90;\n-   EADDRINUSE           : constant :=               98;\n-   EINVAL               : constant :=               22;\n-   EACCES               : constant :=               13;\n-   EAFNOSUPPORT         : constant :=               97;\n-   EISCONN              : constant :=              106;\n-   ETIMEDOUT            : constant :=              110;\n-   ECONNREFUSED         : constant :=              111;\n-   ENETUNREACH          : constant :=              101;\n-   EALREADY             : constant :=              114;\n-   EINPROGRESS          : constant :=              115;\n-   ENOPROTOOPT          : constant :=               92;\n-   EPROTONOSUPPORT      : constant :=               93;\n-   EINTR                : constant :=                4;\n-   EIO                  : constant :=                5;\n-   ESOCKTNOSUPPORT      : constant :=               94;\n-\n-   --  Host Errors\n-\n-   HOST_NOT_FOUND       : constant :=                1;\n-   TRY_AGAIN            : constant :=                2;\n-   NO_ADDRESS           : constant :=                4;\n-   NO_RECOVERY          : constant :=                3;\n-\n-   --  Control Flags\n-\n-   FIONBIO              : constant :=            21537;\n-   FIONREAD             : constant :=            21531;\n-\n-   --  Shutdown Modes\n-\n-   SHUT_RD              : constant :=                0;\n-   SHUT_WR              : constant :=                1;\n-   SHUT_RDWR            : constant :=                2;\n-\n-   --  Protocol Levels\n-\n-   SOL_SOCKET           : constant :=                1;\n-   IPPROTO_IP           : constant :=                0;\n-   IPPROTO_UDP          : constant :=               17;\n-   IPPROTO_TCP          : constant :=                6;\n-\n-   --  Socket Options\n-\n-   TCP_NODELAY          : constant :=                1;\n-   SO_SNDBUF            : constant :=                7;\n-   SO_RCVBUF            : constant :=                8;\n-   SO_REUSEADDR         : constant :=                2;\n-   SO_KEEPALIVE         : constant :=                9;\n-   SO_LINGER            : constant :=               13;\n-   SO_ERROR             : constant :=                4;\n-   SO_BROADCAST         : constant :=                6;\n-   IP_ADD_MEMBERSHIP    : constant :=               35;\n-   IP_DROP_MEMBERSHIP   : constant :=               36;\n-   IP_MULTICAST_TTL     : constant :=               33;\n-   IP_MULTICAST_LOOP    : constant :=               34;\n-end GNAT.Sockets.Constants;"}, {"sha": "40a0132b13ce7bf90a8e782e8e7e4f21f4cef794", "filename": "gcc/ada/41intnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F41intnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F41intnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F41intnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n with System.OS_Interface;\n --  used for names of interrupts"}, {"sha": "d95d62a8f02800203ce333aa22d41d1a1345dbfe", "filename": "gcc/ada/42intnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F42intnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F42intnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F42intnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n with System.OS_Interface;\n --  used for names of interrupts"}, {"sha": "c53c51a63d7310841741a65277fedcade9939d1c", "filename": "gcc/ada/4aintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4aintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4aintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4aintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.4 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n with System.OS_Interface;\n --  used for names of interrupts"}, {"sha": "54823751a5cae98f373e2680fb9cb937c48b2c9f", "filename": "gcc/ada/4cintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4cintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4cintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4cintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.4 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---           Copyright (C) 1991-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1991-2002 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,7 +49,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "3e8285bb332f14254ab447dc6214b4126ce9f63b", "filename": "gcc/ada/4dintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4dintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4dintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4dintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.4 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2001 Free Software Foundation, Inc.       --\n+--             Copyright (C) 1991-2002 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: Made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "be2c19a1fbfabbe4283cfbc5bfb0870ac197e380", "filename": "gcc/ada/4gintnam.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4gintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4gintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4gintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -8,7 +8,7 @@\n --                                                                          --\n --                             $Revision$\n --                                                                          --\n---             Copyright (C) 1997-2001, Florida State University            --\n+--             Copyright (C) 1997-2002, Florida State University            --\n --                                                                          --\n -- GNARL is free software; you can redistribute it  and/or modify it  under --\n -- terms  of  the  GNU  Library General Public License  as published by the --\n@@ -50,7 +50,6 @@\n --  (Pthread library):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "f3b5e75c3be1e061dda9b156a47eb4f83cc8d399", "filename": "gcc/ada/4hintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4hintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4hintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4hintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.5 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--             Copyright (C) 1991-2002, Florida State University            --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "dcb8164d47d316f8bb3bae50e2d066428f2a0e45", "filename": "gcc/ada/4lintnam.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4lintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4lintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4lintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -8,7 +8,7 @@\n --                                                                          --\n --                             $Revision$\n --                                                                          --\n---           Copyright (C) 1991-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1991-2002 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,7 +49,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handler\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "60afd6ebdd83a1f81a87b5df1c1f8417fc232307", "filename": "gcc/ada/4mintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4mintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4mintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4mintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.4 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---          Copyright (C) 1996-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handlers\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "7c15f146a963430758f17af31a3209103c6ea7ba", "filename": "gcc/ada/4pintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4pintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4pintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4pintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.4 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---           Copyright (C) 1991-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1991-2002 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handlers\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "e4f91e2247987a98c9b370eaecdfddaddda7ca91", "filename": "gcc/ada/4rintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4rintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4rintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4rintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.5 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2001 Free Software Foundation, Inc.       --\n+--             Copyright (C) 1991-2002 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handlers\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n --  This target-dependent package spec contains names of interrupts\n --  supported by the local system."}, {"sha": "8ebf91b71b4b67a6f44ec61dab5b91d713f687e9", "filename": "gcc/ada/4sintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4sintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4sintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4sintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.7 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2001 Free Software Foundation, Inc.       --\n+--             Copyright (C) 1991-2002 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,7 +49,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handlers\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n with System.OS_Interface;\n --  used for names of interrupts"}, {"sha": "f2f03e362888530fc4e7fecf51eb2d55e88411bb", "filename": "gcc/ada/4uintnam.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4uintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4uintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4uintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.7 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2001 Free Software Foundation, Inc.       --\n+--             Copyright (C) 1991-2002 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,6 @@\n --  The pragma Unreserve_All_Interrupts affects the following signal(s):\n --\n --  SIGINT: made available for Ada handlers\n---  SIGILL, SIGBUS, SIGSEGV: disconnected from runtime exception mapping\n \n with System.OS_Interface;\n --  used for names of interrupts"}, {"sha": "e0503b59aa91207d2e7539ca263f52c6b2e1e3d2", "filename": "gcc/ada/4vcalend.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4vcalend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4vcalend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4vcalend.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.19 $\n+--                            $Revision$\n --                                                                          --\n --            Copyright (C) 1992-2000 Free Software Foundation, Inc.        --\n --                                                                          --\n@@ -60,9 +60,6 @@ package body Ada.Calendar is\n \n    --  Some basic constants used throughout\n \n-   Days_In_Month : constant array (Month_Number) of Day_Number :=\n-                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n-\n    function To_Relative_Time (D : Duration) return Time;\n \n    function To_Relative_Time (D : Duration) return Time is"}, {"sha": "3b03c0daf9e5d67b3e864a39f1fb074c54de3ae4", "filename": "gcc/ada/4zintnam.ads", "status": "modified", "additions": 2, "deletions": 146, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4zintnam.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F4zintnam.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F4zintnam.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.3 $                             --\n+--                             $Revision$\n --                                                                          --\n---           Copyright (C) 1991-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1998-2001 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,157 +35,13 @@\n ------------------------------------------------------------------------------\n \n --  This is the VxWorks version of this package.\n---\n---  The following signals are reserved by the run time:\n---\n---  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGABRT\n---\n---  The pragma Unreserve_All_Interrupts affects the following signal(s):\n---\n---  none\n-\n---  This target-dependent package spec contains names of interrupts\n---  supported by the local system.\n \n with System.OS_Interface;\n-with System.VxWorks;\n \n package Ada.Interrupts.Names is\n \n    subtype Hardware_Interrupts is Interrupt_ID\n      range Interrupt_ID'First .. System.OS_Interface.Max_HW_Interrupt;\n    --  Range of values that can be used for hardware interrupts.\n \n-   --  The following constants can be used for software interrupts mapped to\n-   --  user-level signals:\n-\n-   SIGHUP : constant Interrupt_ID;\n-   --  hangup\n-\n-   SIGINT : constant Interrupt_ID;\n-   --  interrupt\n-\n-   SIGQUIT : constant Interrupt_ID;\n-   --  quit\n-\n-   SIGILL : constant Interrupt_ID;\n-   --  illegal instruction (not reset)\n-\n-   SIGTRAP : constant Interrupt_ID;\n-   --  trace trap (not reset)\n-\n-   SIGIOT : constant Interrupt_ID;\n-   --  IOT instruction\n-\n-   SIGABRT : constant Interrupt_ID;\n-   --  used by abort, replace SIGIOT\n-\n-   SIGEMT : constant Interrupt_ID;\n-   --  EMT instruction\n-\n-   SIGFPE : constant Interrupt_ID;\n-   --  floating point exception\n-\n-   SIGKILL : constant Interrupt_ID;\n-   --  kill (cannot be caught or ignored)\n-\n-   SIGBUS : constant Interrupt_ID;\n-   --  bus error\n-\n-   SIGSEGV : constant Interrupt_ID;\n-   --  segmentation violation\n-\n-   SIGSYS : constant Interrupt_ID;\n-   --  bad argument to system call\n-\n-   SIGPIPE : constant Interrupt_ID;\n-   --  no one to read it\n-\n-   SIGALRM : constant Interrupt_ID;\n-   --  alarm clock\n-\n-   SIGTERM : constant Interrupt_ID;\n-   --  software termination signal from kill\n-\n-   SIGURG : constant Interrupt_ID;\n-   --  urgent condition on IO channel\n-\n-   SIGSTOP : constant Interrupt_ID;\n-   --  stop (cannot be caught or ignored)\n-\n-   SIGTSTP : constant Interrupt_ID;\n-   --  user stop requested from tty\n-\n-   SIGCONT : constant Interrupt_ID;\n-   --  stopped process has been continued\n-\n-   SIGCHLD : constant Interrupt_ID;\n-   --  child status change\n-\n-   SIGTTIN : constant Interrupt_ID;\n-   --  background tty read attempted\n-\n-   SIGTTOU : constant Interrupt_ID;\n-   --  background tty write attempted\n-\n-   SIGIO : constant Interrupt_ID;\n-   --  input/output possible,\n-\n-   SIGXCPU : constant Interrupt_ID;\n-   --  CPU time limit exceeded\n-\n-   SIGXFSZ : constant Interrupt_ID;\n-   --  filesize limit exceeded\n-\n-   SIGVTALRM : constant Interrupt_ID;\n-   --  virtual timer expired\n-\n-   SIGPROF : constant Interrupt_ID;\n-   --  profiling timer expired\n-\n-   SIGWINCH : constant Interrupt_ID;\n-   --  window size change\n-\n-   SIGUSR1 : constant Interrupt_ID;\n-   --  user defined signal 1\n-\n-   SIGUSR2 : constant Interrupt_ID;\n-   --  user defined signal 2\n-\n-private\n-\n-   Signal_Base : constant := System.VxWorks.Num_HW_Interrupts;\n-\n-   SIGHUP     : constant Interrupt_ID :=  1 + Signal_Base;\n-   SIGINT     : constant Interrupt_ID :=  2 + Signal_Base;\n-   SIGQUIT    : constant Interrupt_ID :=  3 + Signal_Base;\n-   SIGILL     : constant Interrupt_ID :=  4 + Signal_Base;\n-   SIGTRAP    : constant Interrupt_ID :=  5 + Signal_Base;\n-   SIGIOT     : constant Interrupt_ID :=  6 + Signal_Base;\n-   SIGABRT    : constant Interrupt_ID :=  6 + Signal_Base;\n-   SIGEMT     : constant Interrupt_ID :=  7 + Signal_Base;\n-   SIGFPE     : constant Interrupt_ID :=  8 + Signal_Base;\n-   SIGKILL    : constant Interrupt_ID :=  9 + Signal_Base;\n-   SIGBUS     : constant Interrupt_ID := 10 + Signal_Base;\n-   SIGSEGV    : constant Interrupt_ID := 11 + Signal_Base;\n-   SIGSYS     : constant Interrupt_ID := 12 + Signal_Base;\n-   SIGPIPE    : constant Interrupt_ID := 13 + Signal_Base;\n-   SIGALRM    : constant Interrupt_ID := 14 + Signal_Base;\n-   SIGTERM    : constant Interrupt_ID := 15 + Signal_Base;\n-   SIGURG     : constant Interrupt_ID := 16 + Signal_Base;\n-   SIGSTOP    : constant Interrupt_ID := 17 + Signal_Base;\n-   SIGTSTP    : constant Interrupt_ID := 18 + Signal_Base;\n-   SIGCONT    : constant Interrupt_ID := 19 + Signal_Base;\n-   SIGCHLD    : constant Interrupt_ID := 20 + Signal_Base;\n-   SIGTTIN    : constant Interrupt_ID := 21 + Signal_Base;\n-   SIGTTOU    : constant Interrupt_ID := 22 + Signal_Base;\n-   SIGIO      : constant Interrupt_ID := 23 + Signal_Base;\n-   SIGXCPU    : constant Interrupt_ID := 24 + Signal_Base;\n-   SIGXFSZ    : constant Interrupt_ID := 25 + Signal_Base;\n-   SIGVTALRM  : constant Interrupt_ID := 26 + Signal_Base;\n-   SIGPROF    : constant Interrupt_ID := 27 + Signal_Base;\n-   SIGWINCH   : constant Interrupt_ID := 28 + Signal_Base;\n-   SIGUSR1    : constant Interrupt_ID := 30 + Signal_Base;\n-   SIGUSR2    : constant Interrupt_ID := 31 + Signal_Base;\n-\n end Ada.Interrupts.Names;"}, {"sha": "861fc7be45860c0ed5d097d1525b3706ffa0e539", "filename": "gcc/ada/52system.ads", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F52system.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F52system.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F52system.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                         (LynxOS PPC/x86 Version)\n --                                                                          --\n---                            $Revision: 1.4 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,32 +88,18 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -131,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "adbb2d27cec20046292ea0294ff5992288f14e60", "filename": "gcc/ada/5amastop.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5amastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5amastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5amastop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                         (Version for Alpha/Dec Unix)                     --\n --                                                                          --\n---                            $Revision: 1.5 $\n+--                            $Revision$\n --                                                                          --\n --           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n --                                                                          --\n@@ -87,11 +87,8 @@ package body System.Machine_State_Operations is\n    ------------------------\n \n    procedure Free_Machine_State (M : in out Machine_State) is\n-      procedure Gnat_Free (M : in Machine_State);\n-      pragma Import (C, Gnat_Free, \"__gnat_free\");\n-\n    begin\n-      Gnat_Free (M);\n+      Memory.Free (Address (M));\n       M := Machine_State (Null_Address);\n    end Free_Machine_State;\n "}, {"sha": "1ae0fef716fc9d811468c3d8ce65786e96e1cfda", "filename": "gcc/ada/5asystem.ads", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5asystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5asystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5asystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                           (DEC Unix Version)                             --\n --                                                                          --\n---                            $Revision: 1.20 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 64;\n+   Memory_Size  : constant := 2 ** 64;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n+   Max_Priority           : constant Positive := 60;\n+   Max_Interrupt_Priority : constant Positive := 63;\n \n-   Max_Interrupt_Priority : constant Positive := 31;\n+   subtype Any_Priority       is Integer      range  0 .. 63;\n+   subtype Priority           is Any_Priority range  0 .. 60;\n+   subtype Interrupt_Priority is Any_Priority range 61 .. 63;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n-\n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 30;\n \n private\n \n@@ -130,10 +117,13 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := False;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n-   Functions_Return_By_DSP   : constant Boolean := True;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;\n    High_Integrity_Mode       : constant Boolean := False;\n    Machine_Overflows         : constant Boolean := False;\n@@ -143,9 +133,9 @@ private\n    Stack_Check_Default       : constant Boolean := True;\n    Stack_Check_Probes        : constant Boolean := True;\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := True;\n+   ZCX_By_Default            : constant Boolean := False;\n    GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := True;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n \n    --  Note: Denorm is False because denormals are only handled properly\n    --  if the -mieee switch is set, and we do not require this usage.\n@@ -193,37 +183,29 @@ private\n    --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n \n    Underlying_Priorities : constant Priorities_Mapping :=\n-     (Priority'First     => 16,\n-      1  => 17,\n-      2  => 18,\n-      3  => 18,\n-      4  => 18,\n-      5  => 18,\n-      6  => 19,\n-      7  => 19,\n-      8  => 19,\n-      9  => 20,\n-      10 => 20,\n-      11 => 21,\n-      12 => 21,\n-      13 => 22,\n-      14 => 23,\n-      Default_Priority   => 24,\n-      16 => 25,\n-      17 => 25,\n-      18 => 25,\n-      19 => 26,\n-      20 => 26,\n-      21 => 26,\n-      22 => 27,\n-      23 => 27,\n-      24 => 27,\n-      25 => 28,\n-      26 => 28,\n-      27 => 29,\n-      28 => 29,\n-      29 => 30,\n-      Priority'Last      => 30,\n-      Interrupt_Priority => 31);\n+\n+     (Priority'First => 0,\n+\n+       1 =>  1,  2 =>  2,  3 =>  3,  4 =>  4,  5 =>  5,\n+       6 =>  6,  7 =>  7,  8 =>  8,  9 =>  9, 10 => 10,\n+      11 => 11, 12 => 12, 13 => 13, 14 => 14, 15 => 15,\n+      16 => 16, 17 => 17, 18 => 18, 19 => 19, 20 => 20,\n+      21 => 21, 22 => 22, 23 => 23, 24 => 24, 25 => 25,\n+      26 => 26, 27 => 27, 28 => 28, 29 => 29,\n+\n+      Default_Priority => 30,\n+\n+      31 => 31, 32 => 32, 33 => 33, 34 => 34, 35 => 35,\n+      36 => 36, 37 => 37, 38 => 38, 39 => 39, 40 => 40,\n+      41 => 41, 42 => 42, 43 => 43, 44 => 44, 45 => 45,\n+      46 => 46, 47 => 47, 48 => 48, 49 => 49, 50 => 50,\n+      51 => 51, 52 => 52, 53 => 53, 54 => 54, 55 => 55,\n+      56 => 56, 57 => 57, 58 => 58, 59 => 59,\n+\n+      Priority'Last => 60,\n+\n+      61 => 61, 62 => 62,\n+\n+      Interrupt_Priority'Last => 63);\n \n end System;"}, {"sha": "c586ac0b5ca24b9b44445e79a8e21af394f3ce2b", "filename": "gcc/ada/5ataprop.adb", "status": "modified", "additions": 116, "deletions": 76, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ataprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ataprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ataprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -99,15 +98,17 @@ package body System.Task_Primitives.Operations is\n \n    package SSL renames System.Soft_Links;\n \n-   -----------------\n-   -- Local Data  --\n-   -----------------\n+   ----------------\n+   -- Local Data --\n+   ----------------\n \n    --  The followings are logically constants, but need to be initialized\n    --  at run time.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -221,7 +222,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -317,33 +318,40 @@ package body System.Task_Primitives.Operations is\n          All_Tasks_Link := Self_ID.Common.All_Tasks_Link;\n          Current_Prio := Get_Priority (Self_ID);\n \n-         --  if there is no other task, no need to check priorities\n-         if All_Tasks_Link /= Null_Task and then\n-            L.Ceiling < Interfaces.C.int (Current_Prio) then\n+         --  If there is no other task, no need to check priorities\n+\n+         if All_Tasks_Link /= Null_Task\n+           and then L.Ceiling < Interfaces.C.int (Current_Prio)\n+         then\n             Ceiling_Violation := True;\n             return;\n          end if;\n       end if;\n \n       Result := pthread_mutex_lock (L.L'Access);\n-\n       pragma Assert (Result = 0);\n \n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -366,18 +374,22 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    -----------\n@@ -390,9 +402,13 @@ package body System.Task_Primitives.Operations is\n    is\n       Result : Interfaces.C.int;\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait\n-        (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n \n       --  EINTR is not considered a failure.\n \n@@ -437,8 +453,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -477,6 +501,11 @@ package body System.Task_Primitives.Operations is\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -498,8 +527,13 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Request'Access);\n+            else\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -512,6 +546,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -612,7 +651,7 @@ package body System.Task_Primitives.Operations is\n       Self_ID.Common.LL.Thread := pthread_self;\n       Specific.Set (Self_ID);\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n       for J in Known_Tasks'Range loop\n          if Known_Tasks (J) = null then\n@@ -622,7 +661,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -644,45 +683,42 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr  : aliased pthread_condattr_t;\n \n    begin\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n+      if not Single_Lock then\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+         if Result = 0 then\n+            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n \n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n       end if;\n \n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -829,13 +865,18 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n+\n       if T.Known_Tasks_Index /= -1 then\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n+\n       Free (Tmp);\n    end Finalize_TCB;\n \n@@ -891,23 +932,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -944,7 +985,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       Environment_Task_ID := Environment_Task;\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n       Specific.Initialize (Environment_Task);\n@@ -971,7 +1012,6 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n       --  Mask Environment task for all signals. The original mask of the\n       --  Environment task will be recovered by Interrupt_Server task"}, {"sha": "cc386d46963a4edafe94033a974e6ab9d06b40ad", "filename": "gcc/ada/5atpopsp.adb", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5atpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5atpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5atpopsp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2001, Florida State University             --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,15 +30,17 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n --  This is a POSIX version of this package where foreign threads are\n --  recognized.\n---  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread and RTEMS\n---  use this version.\n+--  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread,\n+--  GNU/Linux threads and RTEMS use this version.\n+\n+with System.Task_Info;\n+--  Use for Unspecified_Task_Info\n \n with System.Soft_Links;\n --  used to initialize TSD for a C thread, in function Self\n@@ -71,7 +73,7 @@ package body Specific is\n \n    Fake_ATCB_List : Fake_ATCB_Ptr;\n    --  A linear linked list.\n-   --  The list is protected by All_Tasks_L;\n+   --  The list is protected by Single_RTS_Lock;\n    --  Nodes are added to this list from the front.\n    --  Once a node is added to this list, it is never removed.\n \n@@ -109,7 +111,7 @@ package body Specific is\n       --  We dare not call anything that might require an ATCB, until\n       --  we have the new ATCB in place.\n \n-      Write_Lock (All_Tasks_L'Access);\n+      Lock_RTS;\n       Q := null;\n       P := Fake_ATCB_List;\n \n@@ -195,7 +197,7 @@ package body Specific is\n \n       --  Must not unlock until Next_ATCB is again allocated.\n \n-      Unlock (All_Tasks_L'Access);\n+      Unlock_RTS;\n       return Self_ID;\n    end New_Fake_ATCB;\n \n@@ -205,7 +207,6 @@ package body Specific is\n \n    procedure Initialize (Environment_Task : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_key_create (ATCB_Key'Access, null);\n       pragma Assert (Result = 0);\n@@ -223,7 +224,6 @@ package body Specific is\n \n    procedure Set (Self_Id : Task_ID) is\n       Result  : Interfaces.C.int;\n-\n    begin\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n       pragma Assert (Result = 0);\n@@ -233,37 +233,21 @@ package body Specific is\n    -- Self --\n    ----------\n \n-   --  To make Ada tasks and C threads interoperate better, we have\n-   --  added some functionality to Self.  Suppose a C main program\n-   --  (with threads) calls an Ada procedure and the Ada procedure\n-   --  calls the tasking runtime system.  Eventually, a call will be\n-   --  made to self.  Since the call is not coming from an Ada task,\n-   --  there will be no corresponding ATCB.\n-\n-   --  (The entire Ada run-time system may not have been elaborated,\n-   --  either, but that is a different problem, that we will need to\n-   --  solve another way.)\n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n \n-   --  What we do in Self is to catch references that do not come\n-   --  from recognized Ada tasks, and create an ATCB for the calling\n-   --  thread.\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n \n-   --  The new ATCB will be \"detached\" from the normal Ada task\n-   --  master hierarchy, much like the existing implicitly created\n-   --  signal-server tasks.\n-\n-   --  We will also use such points to poll for disappearance of the\n-   --  threads associated with any implicit ATCBs that we created\n-   --  earlier, and take the opportunity to recover them.\n-\n-   --  A nasty problem here is the limitations of the compilation\n-   --  order dependency, and in particular the GNARL/GNULLI layering.\n-   --  To initialize an ATCB we need to assume System.Tasking has\n-   --  been elaborated.\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n \n    function Self return Task_ID is\n       Result : System.Address;\n-\n    begin\n       Result := pthread_getspecific (ATCB_Key);\n "}, {"sha": "6c16373bc720fe50010c8e4f56cf7196dc903464", "filename": "gcc/ada/5avxwork.ads", "status": "modified", "additions": 7, "deletions": 58, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5avxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5avxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5avxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                             $Revision: 1.3 $                             --\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1998-2001 Free Software Foundation              --\n+--            Copyright (C) 1998-2001 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -43,68 +42,18 @@ package System.VxWorks is\n \n    package IC renames Interfaces.C;\n \n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 5.3[.1]),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n-\n-   type Wind_Fill_1 is array (0 .. 16#77#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#80# .. 16#1c7#) of IC.unsigned_char;\n-   type Wind_Fill_3 is array (16#1d8# .. 16#777#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1;  -- 0x00 - 0x77\n-      Priority        : IC.int;  -- 0x78 - 0x7b, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x7c - 0x7f, base priority\n-      Fill_2          : Wind_Fill_2;  -- 0x80 - 0x1c7\n-      spare1          : Address;  -- 0x1c8 - 0x1cb\n-      spare2          : Address;  -- 0x1cc - 0x1cf\n-      spare3          : Address;  -- 0x1d0 - 0x1d3\n-      spare4          : Address;  -- 0x1d4 - 0x1d7\n-\n-      --  Fill_3 is much smaller on the board runtime, but the larger size\n-      --  below keeps this record compatible with vxsim.\n-\n-      Fill_3          : Wind_Fill_3;     -- 0x1d8 - 0x777\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-\n-   --  Floating point context record.  Alpha version\n+   --  Floating point context record. Alpha version\n \n    FP_NUM_DREGS : constant := 32;\n    type Fpx_Array is array (1 .. FP_NUM_DREGS) of IC.double;\n \n    type FP_CONTEXT is record\n-      fpx :   Fpx_Array;\n+      fpx   : Fpx_Array;\n       fpcsr : IC.long;\n    end record;\n    pragma Convention (C, FP_CONTEXT);\n \n-   --  Number of entries in hardware interrupt vector table.  Value of\n-   --  0 disables hardware interrupt handling until it can be tested\n-   Num_HW_Interrupts : constant := 0;\n-\n-   --  VxWorks 5.3 and 5.4 version\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_name         : Address;  --  name of task\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-   end record;\n-   pragma Convention (C, TASK_DESC);\n+   Num_HW_Interrupts : constant := 256;\n+   --  Number of entries in hardware interrupt vector table.\n \n end System.VxWorks;"}, {"sha": "b692a7545171fe7664e4aae9355cd6589edb0812", "filename": "gcc/ada/5bosinte.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5bosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5bosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bosinte.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                              $Revision: 1.8 $\n+--                              $Revision$\n --                                                                          --\n---             Copyright (C) 1997-2001, Florida State University            --\n+--          Copyright (C) 1997-2001, Free Software Fundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -140,7 +139,7 @@ package body System.OS_Interface is\n    function sched_yield return int is\n \n       procedure pthread_yield;\n-      pragma Import (C, pthread_yield, \"pthread_yield\");\n+      pragma Import (C, pthread_yield, \"sched_yield\");\n \n    begin\n       pthread_yield;"}, {"sha": "bc7a226d3160a8b8bbd8a44431a4d8cdb5958efb", "filename": "gcc/ada/5bsystem.ads", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5bsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5bsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -5,11 +5,11 @@\n --                               S Y S T E M                                --\n --                                                                          --\n --                                 S p e c                                  --\n---                            (AIX/PPC Version)\n+--                            (AIX/PPC Version)                             --\n --                                                                          --\n---                            $Revision: 1.4 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,32 +88,18 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -131,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "2a4d594f8936225272a98d4a34125d8846c251cc", "filename": "gcc/ada/5esystem.ads", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5esystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5esystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5esystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                          (X86 Solaris Version)                           --\n --                                                                          --\n---                            $Revision: 1.10 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;\n@@ -145,6 +135,6 @@ private\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n    ZCX_By_Default            : constant Boolean := False;\n    GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := True;\n \n end System;"}, {"sha": "a68767b2a020287d579365f8d321f3cc3eb66cb9", "filename": "gcc/ada/5fsystem.ads", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5fsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5fsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5fsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                           (SGI Irix, o32 ABI)                            --\n --                                                                          --\n---                            $Revision: 1.13 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := False;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := True;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "20b21f5ecf86263007371ba8af21e469f1b4e632", "filename": "gcc/ada/5ftaprop.adb", "status": "modified", "additions": 86, "deletions": 58, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ftaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ftaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ftaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2001, Florida State University             --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -117,8 +116,10 @@ package body System.Task_Primitives.Operations is\n    ATCB_Key : aliased pthread_key_t;\n    --  Key used to find the Ada Task_ID associated with a thread\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Locking_Rules (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -206,7 +207,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -308,7 +309,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_lock (L);\n       Ceiling_Violation := Result = EINVAL;\n@@ -318,20 +318,24 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = EINVAL);\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -349,26 +353,27 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_unlock (L);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    -----------\n@@ -381,9 +386,13 @@ package body System.Task_Primitives.Operations is\n    is\n       Result : Interfaces.C.int;\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n \n       --  EINTR is not considered a failure.\n \n@@ -424,8 +433,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -461,6 +478,11 @@ package body System.Task_Primitives.Operations is\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -495,6 +517,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -621,7 +648,7 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0);\n       end if;\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n       for J in Known_Tasks'Range loop\n          if Known_Tasks (J) = null then\n@@ -631,7 +658,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -652,28 +679,27 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr : aliased pthread_condattr_t;\n \n    begin\n-      Initialize_Lock (Self_ID.Common.LL.L'Access, All_Tasks_Level);\n+      if not Single_Lock then\n+         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+      end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -821,8 +847,10 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -885,23 +913,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -939,7 +967,7 @@ package body System.Task_Primitives.Operations is\n       Environment_Task_ID := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n       Enter_Task (Environment_Task);\n "}, {"sha": "4b7d1a30a1b4510d85a25035fc5d52c166fa8a63", "filename": "gcc/ada/5ginterr.adb", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ginterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ginterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ginterr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.13 $\n+--                             $Revision$\n --                                                                          --\n---              Copyright (C) 1998-1999 Free Software Fundation             --\n+--              Copyright (C) 1998-2001 Free Software Fundation             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -68,13 +67,17 @@ with System.Tasking.Initialization;\n \n with System.Interrupt_Management;\n \n+with System.Parameters;\n+--  used for Single_Lock\n+\n with Interfaces.C;\n --  used for int\n \n with Unchecked_Conversion;\n \n package body System.Interrupts is\n \n+   use Parameters;\n    use Tasking;\n    use Ada.Exceptions;\n    use System.OS_Interface;\n@@ -650,11 +653,21 @@ package body System.Interrupts is\n          end loop;\n \n          Initialization.Defer_Abort (Self_Id);\n+\n+         if Single_Lock then\n+            STPO.Lock_RTS;\n+         end if;\n+\n          STPO.Write_Lock (Self_Id);\n          Self_Id.Common.State := Interrupt_Server_Idle_Sleep;\n          STPO.Sleep (Self_Id, Interrupt_Server_Idle_Sleep);\n          Self_Id.Common.State := Runnable;\n          STPO.Unlock (Self_Id);\n+\n+         if Single_Lock then\n+            STPO.Unlock_RTS;\n+         end if;\n+\n          Initialization.Undefer_Abort (Self_Id);\n \n          --  Undefer abort here to allow a window for this task"}, {"sha": "c3b41f93af2caf0c587ad5bfd99e7cab745061b5", "filename": "gcc/ada/5gmastop.adb", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gmastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gmastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gmastop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                         (Version for IRIX/MIPS)                          --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -66,27 +66,26 @@ package body System.Machine_State_Operations is\n \n    type Reg_Array is array (0 .. 31) of Uns64;\n \n-   type Sigcontext is\n-      record\n-         SC_Regmask           : Uns32;          --  0\n-         SC_Status            : Uns32;          --  4\n-         SC_PC                : Uns64;          --  8\n-         SC_Regs              : Reg_Array;      --  16\n-         SC_Fpregs            : Reg_Array;      --  272\n-         SC_Ownedfp           : Uns32;          --  528\n-         SC_Fpc_Csr           : Uns32;          --  532\n-         SC_Fpc_Eir           : Uns32;          --  536\n-         SC_Ssflags           : Uns32;          --  540\n-         SC_Mdhi              : Uns64;          --  544\n-         SC_Mdlo              : Uns64;          --  552\n-         SC_Cause             : Uns64;          --  560\n-         SC_Badvaddr          : Uns64;          --  568\n-         SC_Triggersave       : Uns64;          --  576\n-         SC_Sigset            : Uns64;          --  584\n-         SC_Fp_Rounded_Result : Uns64;          --  592\n-         SC_Pancake           : Uns64_Array (0 .. 5);\n-         SC_Pad               : Uns64_Array (0 .. 26);\n-      end record;\n+   type Sigcontext is record\n+      SC_Regmask           : Uns32;          --  0\n+      SC_Status            : Uns32;          --  4\n+      SC_PC                : Uns64;          --  8\n+      SC_Regs              : Reg_Array;      --  16\n+      SC_Fpregs            : Reg_Array;      --  272\n+      SC_Ownedfp           : Uns32;          --  528\n+      SC_Fpc_Csr           : Uns32;          --  532\n+      SC_Fpc_Eir           : Uns32;          --  536\n+      SC_Ssflags           : Uns32;          --  540\n+      SC_Mdhi              : Uns64;          --  544\n+      SC_Mdlo              : Uns64;          --  552\n+      SC_Cause             : Uns64;          --  560\n+      SC_Badvaddr          : Uns64;          --  568\n+      SC_Triggersave       : Uns64;          --  576\n+      SC_Sigset            : Uns64;          --  584\n+      SC_Fp_Rounded_Result : Uns64;          --  592\n+      SC_Pancake           : Uns64_Array (0 .. 5);\n+      SC_Pad               : Uns64_Array (0 .. 26);\n+   end record;\n \n    type Sigcontext_Ptr is access all Sigcontext;\n \n@@ -253,11 +252,8 @@ package body System.Machine_State_Operations is\n    ------------------------\n \n    procedure Free_Machine_State (M : in out Machine_State) is\n-      procedure Gnat_Free (M : in Machine_State);\n-      pragma Import (C, Gnat_Free, \"__gnat_free\");\n-\n    begin\n-      Gnat_Free (M);\n+      Memory.Free (Address (M));\n       M := Machine_State (Null_Address);\n    end Free_Machine_State;\n "}, {"sha": "f3f4c0ff4d3992167019ae9f84cf6bda5f1a905e", "filename": "gcc/ada/5gsystem.ads", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                           (SGI Irix, n32 ABI)                            --\n --                                                                          --\n---                            $Revision: 1.19 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 64;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := False;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := True;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "c2718ddcc13eb3075460d16b7c0e8355412ed02f", "filename": "gcc/ada/5gtaprop.adb", "status": "modified", "additions": 110, "deletions": 166, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---              Copyright (C) 1991-2001, Florida State University           --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -106,15 +105,16 @@ package body System.Task_Primitives.Operations is\n    --  The followings are logically constants, but need to be initialized\n    --  at run time.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n \n    Locking_Policy : Character;\n-   pragma Import (C, Locking_Policy, \"__gl_locking_policy\",\n-                  \"__gl_locking_policy\");\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n \n    Clock_Address : constant System.Address :=\n      System.Storage_Elements.To_Address (16#200F90#);\n@@ -169,7 +169,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -267,28 +267,31 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_lock (L);\n \n       Ceiling_Violation := Result = FUNC_ERR and then errno = EINVAL;\n       pragma Assert (Result /= FUNC_ERR);\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -306,132 +309,55 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_unlock (L);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n    procedure Sleep\n      (Self_ID  : ST.Task_ID;\n-      Reason   : System.Tasking.Task_States) is\n-\n+      Reason   : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n+\n       --  EINTR is not considered a failure.\n       pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n \n-   --  Note that we are relying heaviliy here on the GNAT feature\n-   --  that Calendar.Time, System.Real_Time.Time, Duration, and\n-   --  System.Real_Time.Time_Span are all represented in the same\n-   --  way, i.e., as a 64-bit count of nanoseconds.\n-   --  This allows us to always pass the timeout value as a Duration.\n-\n-   --  ?????  .........\n-   --  We are taking liberties here with the semantics of the delays.\n-   --  That is, we make no distinction between delays on the Calendar clock\n-   --  and delays on the Real_Time clock.  That is technically incorrect, if\n-   --  the Calendar clock happens to be reset or adjusted.\n-   --  To solve this defect will require modification to the compiler\n-   --  interface, so that it can pass through more information, to tell\n-   --  us here which clock to use!\n-\n-   --  cond_timedwait will return if any of the following happens:\n-   --  1) some other task did cond_signal on this condition variable\n-   --     In this case, the return value is 0\n-   --  2) the call just returned, for no good reason\n-   --     This is called a \"spurious wakeup\".\n-   --     In this case, the return value may also be 0.\n-   --  3) the time delay expires\n-   --     In this case, the return value is ETIME\n-   --  4) this task received a signal, which was handled by some\n-   --     handler procedure, and now the thread is resuming execution\n-   --     UNIX calls this an \"interrupted\" system call.\n-   --     In this case, the return value is EINTR\n-\n-   --  If the cond_timedwait returns 0 or EINTR, it is still\n-   --  possible that the time has actually expired, and by chance\n-   --  a signal or cond_signal occurred at around the same time.\n-\n-   --  We have also observed that on some OS's the value ETIME\n-   --  will be returned, but the clock will show that the full delay\n-   --  has not yet expired.\n-\n-   --  For these reasons, we need to check the clock after return\n-   --  from cond_timedwait.  If the time has expired, we will set\n-   --  Timedout = True.\n-\n-   --  This check might be omitted for systems on which the\n-   --  cond_timedwait() never returns early or wakes up spuriously.\n-\n-   --  Annex D requires that completion of a delay cause the task\n-   --  to go to the end of its priority queue, regardless of whether\n-   --  the task actually was suspended by the delay.  Since\n-   --  cond_timedwait does not do this on Solaris, we add a call\n-   --  to thr_yield at the end.  We might do this at the beginning,\n-   --  instead, but then the round-robin effect would not be the\n-   --  same; the delayed task would be ahead of other tasks of the\n-   --  same priority that awoke while it was sleeping.\n-\n-   --  For Timed_Sleep, we are expecting possible cond_signals\n-   --  to indicate other events (e.g., completion of a RV or\n-   --  completion of the abortable part of an async. select),\n-   --  we want to always return if interrupted. The caller will\n-   --  be responsible for checking the task state to see whether\n-   --  the wakeup was spurious, and to go back to sleep again\n-   --  in that case.  We don't need to check for pending abort\n-   --  or priority change on the way in our out; that is the\n-   --  caller's responsibility.\n-\n-   --  For Timed_Delay, we are not expecting any cond_signals or\n-   --  other interruptions, except for priority changes and aborts.\n-   --  Therefore, we don't want to return unless the delay has\n-   --  actually expired, or the call has been aborted.  In this\n-   --  case, since we want to implement the entire delay statement\n-   --  semantics, we do need to check for pending abort and priority\n-   --  changes.  We can quietly handle priority changes inside the\n-   --  procedure, since there is no entry-queue reordering involved.\n-\n    -----------------\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-   --  Yielded should be False unles we know for certain that the\n-   --  operation resulted in the calling task going to the end of\n-   --  the dispatching queue for its priority.\n-   --  ?????\n-   --  This version presumes the worst, so Yielded is always False.\n-   --  On some targets, if cond_timedwait always yields, we could\n-   --  set Yielded to True just before the cond_timedwait call.\n-\n    procedure Timed_Sleep\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -461,8 +387,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -482,10 +416,6 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n-\n    procedure Timed_Delay\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -495,13 +425,18 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Request    : aliased struct_timeval;\n       Result     : Interfaces.C.int;\n-   begin\n \n+   begin\n       --  Only the little window between deferring abort and\n       --  locking Self_ID is the reason we need to\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -523,8 +458,13 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Request'Access);\n+            else\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -538,6 +478,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       pthread_yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -578,10 +523,9 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup\n      (T : ST.Task_ID;\n-      Reason : System.Tasking.Task_States) is\n-\n+      Reason : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -608,7 +552,6 @@ package body System.Task_Primitives.Operations is\n       Loss_Of_Inheritance : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       T.Common.Current_Priority := Prio;\n       Result := pthread_setprio (T.Common.LL.Thread, Interfaces.C.int (Prio));\n@@ -631,9 +574,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Enter_Task (Self_ID : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-\n       Self_ID.Common.LL.Thread := pthread_self;\n       Self_ID.Common.LL.LWP := sproc_self;\n \n@@ -642,17 +583,17 @@ package body System.Task_Primitives.Operations is\n \n       pragma Assert (Result = 0);\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -669,31 +610,31 @@ package body System.Task_Primitives.Operations is\n    ----------------------\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n-      Result : Interfaces.C.int;\n+      Result    : Interfaces.C.int;\n       Cond_Attr : aliased pthread_condattr_t;\n \n    begin\n-      Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+      if not Single_Lock then\n+         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+      end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -723,6 +664,7 @@ package body System.Task_Primitives.Operations is\n         (System.Task_Info.Resource_Vector_T, System.OS_Interface.resource_t);\n \n       use System.Task_Info;\n+\n    begin\n       if Stack_Size = Unspecified_Size then\n          Adjusted_Stack_Size :=\n@@ -809,8 +751,11 @@ package body System.Task_Primitives.Operations is\n       Tmp    : Task_ID := T;\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n \n@@ -836,7 +781,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Task (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_kill (T.Common.LL.Thread,\n         Interfaces.C.int (System.Interrupt_Management.Abort_Task_Interrupt));\n@@ -873,23 +817,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -929,7 +873,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       Environment_Task_ID := Environment_Task;\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n       Enter_Task (Environment_Task);"}, {"sha": "5eae351aa3aafd2232008406389573f9cf28a48a", "filename": "gcc/ada/5gtasinf.adb", "status": "modified", "additions": 85, "deletions": 26, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtasinf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtasinf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtasinf.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.2 $                              --\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,7 @@ with Interfaces.C;\n with System.OS_Interface;\n with System;\n with Unchecked_Conversion;\n+\n package body System.Task_Info is\n \n    use System.OS_Interface;\n@@ -67,67 +68,92 @@ package body System.Task_Info is\n       TXTLOCK  => 2,\n       DATLOCK  => 4);\n \n+   -------------------------------\n+   -- Resource_Vector_Functions --\n+   -------------------------------\n+\n    package body Resource_Vector_Functions is\n \n-      function \"+\" (R : Resource_T)\n-        return Resource_Vector_T is\n+      ---------\n+      -- \"+\" --\n+      ---------\n+\n+      function \"+\" (R : Resource_T) return Resource_Vector_T is\n          Result  : Resource_Vector_T  := NO_RESOURCES;\n+\n       begin\n          Result (Resource_T'Pos (R)) := True;\n          return Result;\n       end \"+\";\n \n-      function \"+\" (R1, R2 : Resource_T)\n-        return Resource_Vector_T is\n+      function \"+\" (R1, R2 : Resource_T) return Resource_Vector_T is\n          Result  : Resource_Vector_T  := NO_RESOURCES;\n+\n       begin\n          Result (Resource_T'Pos (R1)) := True;\n          Result (Resource_T'Pos (R2)) := True;\n          return Result;\n       end \"+\";\n \n-      function \"+\" (R : Resource_T; S : Resource_Vector_T)\n-        return Resource_Vector_T is\n+      function \"+\"\n+        (R    : Resource_T;\n+         S    : Resource_Vector_T)\n+         return Resource_Vector_T\n+      is\n          Result  : Resource_Vector_T := S;\n+\n       begin\n          Result (Resource_T'Pos (R)) := True;\n          return Result;\n       end \"+\";\n \n-      function \"+\" (S : Resource_Vector_T; R : Resource_T)\n-        return Resource_Vector_T is\n+      function \"+\"\n+        (S    : Resource_Vector_T;\n+         R    : Resource_T)\n+         return Resource_Vector_T\n+      is\n          Result  : Resource_Vector_T :=  S;\n+\n       begin\n          Result (Resource_T'Pos (R)) := True;\n          return Result;\n       end \"+\";\n \n-      function \"+\" (S1, S2 : Resource_Vector_T)\n-        return Resource_Vector_T is\n+      function \"+\" (S1, S2 : Resource_Vector_T) return Resource_Vector_T is\n          Result  : Resource_Vector_T;\n+\n       begin\n          Result :=  S1 or S2;\n          return Result;\n       end \"+\";\n \n-      function \"-\" (S : Resource_Vector_T; R : Resource_T)\n-        return Resource_Vector_T is\n+      function \"-\"\n+        (S    : Resource_Vector_T;\n+         R    : Resource_T)\n+         return Resource_Vector_T\n+      is\n          Result  : Resource_Vector_T := S;\n+\n       begin\n          Result (Resource_T'Pos (R)) := False;\n          return Result;\n       end \"-\";\n \n    end Resource_Vector_Functions;\n \n+   ---------------\n+   -- New_Sproc --\n+   ---------------\n+\n    function New_Sproc (Attr : Sproc_Attributes) return sproc_t is\n       Sproc_Attr : aliased sproc_attr_t;\n       Sproc      : aliased sproc_t;\n       Status     : int;\n+\n    begin\n       Status := sproc_attr_init (Sproc_Attr'Unrestricted_Access);\n-      if Status = 0 then\n \n+      if Status = 0 then\n          Status := sproc_attr_setresources\n            (Sproc_Attr'Unrestricted_Access,\n             To_Resource_T (Attr.Sproc_Resources));\n@@ -136,13 +162,13 @@ package body System.Task_Info is\n             if Attr.CPU > Num_Processors then\n                raise Invalid_CPU_Number;\n             end if;\n+\n             Status := sproc_attr_setcpu\n               (Sproc_Attr'Unrestricted_Access,\n                int (Attr.CPU));\n          end if;\n \n          if Attr.Resident /= NOLOCK then\n-\n             if Geteuid /= 0 then\n                raise Permission_Error;\n             end if;\n@@ -153,6 +179,7 @@ package body System.Task_Info is\n          end if;\n \n          if Attr.NDPRI /= NDP_NONE then\n+--  ??? why is that comment out, should it be removed ?\n --          if Geteuid /= 0 then\n --             raise Permission_Error;\n --          end if;\n@@ -184,81 +211,113 @@ package body System.Task_Info is\n       return Sproc;\n    end New_Sproc;\n \n+   ---------------\n+   -- New_Sproc --\n+   ---------------\n+\n    function New_Sproc\n      (Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n       CPU             : CPU_Number             := ANY_CPU;\n       Resident        : Page_Locking           := NOLOCK;\n       NDPRI           : Non_Degrading_Priority := NDP_NONE)\n-      return            sproc_t is\n-\n+      return            sproc_t\n+   is\n       Attr : Sproc_Attributes :=\n         (Sproc_Resources, CPU, Resident, NDPRI);\n \n    begin\n       return New_Sproc (Attr);\n    end New_Sproc;\n \n+   -------------------------------\n+   -- Unbound_Thread_Attributes --\n+   -------------------------------\n+\n    function Unbound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n       Thread_Timeslice : Duration          := 0.0)\n-      return             Thread_Attributes is\n+      return             Thread_Attributes\n+   is\n    begin\n       return (False, Thread_Resources, Thread_Timeslice);\n    end Unbound_Thread_Attributes;\n \n+   -----------------------------\n+   -- Bound_Thread_Attributes --\n+   -----------------------------\n+\n    function Bound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n       Thread_Timeslice : Duration          := 0.0;\n       Sproc            : sproc_t)\n-      return             Thread_Attributes is\n+      return             Thread_Attributes\n+   is\n    begin\n       return (True, Thread_Resources, Thread_Timeslice, Sproc);\n    end Bound_Thread_Attributes;\n \n+   -----------------------------\n+   -- Bound_Thread_Attributes --\n+   -----------------------------\n+\n    function Bound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n       Thread_Timeslice : Duration               := 0.0;\n       Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n       CPU              : CPU_Number             := ANY_CPU;\n       Resident         : Page_Locking           := NOLOCK;\n       NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return             Thread_Attributes is\n-\n+      return             Thread_Attributes\n+   is\n       Sproc : sproc_t := New_Sproc\n         (Sproc_Resources, CPU, Resident, NDPRI);\n \n    begin\n       return (True, Thread_Resources, Thread_Timeslice, Sproc);\n    end Bound_Thread_Attributes;\n \n+   -----------------------------------\n+   -- New_Unbound_Thread_Attributes --\n+   -----------------------------------\n+\n    function New_Unbound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n       Thread_Timeslice : Duration          := 0.0)\n-      return             Task_Info_Type is\n+      return             Task_Info_Type\n+   is\n    begin\n       return new Thread_Attributes'\n         (False, Thread_Resources, Thread_Timeslice);\n    end New_Unbound_Thread_Attributes;\n \n+   ---------------------------------\n+   -- New_Bound_Thread_Attributes --\n+   ---------------------------------\n+\n    function New_Bound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n       Thread_Timeslice : Duration          := 0.0;\n       Sproc            : sproc_t)\n-      return             Task_Info_Type is\n+      return             Task_Info_Type\n+   is\n    begin\n       return new Thread_Attributes'\n         (True, Thread_Resources, Thread_Timeslice, Sproc);\n    end  New_Bound_Thread_Attributes;\n \n+   ---------------------------------\n+   -- New_Bound_Thread_Attributes --\n+   ---------------------------------\n+\n    function New_Bound_Thread_Attributes\n      (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n       Thread_Timeslice : Duration               := 0.0;\n       Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n       CPU              : CPU_Number             := ANY_CPU;\n       Resident         : Page_Locking           := NOLOCK;\n       NDPRI            : Non_Degrading_Priority := NDP_NONE)\n-      return             Task_Info_Type is\n-\n+      return             Task_Info_Type\n+   is\n       Sproc : sproc_t := New_Sproc\n         (Sproc_Resources, CPU, Resident, NDPRI);\n "}, {"sha": "7767023af8ef4f0fa51d3caa8e2a4bdb3cb0f0e8", "filename": "gcc/ada/5gtasinf.ads", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtasinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5gtasinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtasinf.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.4 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,7 @@\n \n with System.OS_Interface;\n with Unchecked_Deallocation;\n+\n package System.Task_Info is\n pragma Elaborate_Body;\n --  To ensure that a body is allowed\n@@ -49,10 +50,10 @@ pragma Elaborate_Body;\n    ---------------------------------------------------------\n \n    --  The SGI implementation of the GNU Low-Level Interface (GNULLI)\n-   --  implements each Ada task as a Posix thread (Pthread).  The SGI\n+   --  implements each Ada task as a Posix thread (Pthread). The SGI\n    --  Pthread library distributes threads across one or more processes\n-   --  that are members of a common share group.  Irix distributes\n-   --  processes across the available CPUs on a given machine.  The\n+   --  that are members of a common share group. Irix distributes\n+   --  processes across the available CPUs on a given machine. The\n    --  pragma Task_Info provides the mechanism to control the distribution\n    --  of tasks to sprocs, and sprocs to processors.\n \n@@ -103,19 +104,37 @@ pragma Elaborate_Body;\n    NO_RESOURCES : constant Resource_Vector_T := (others => False);\n \n    generic\n-      type Resource_T is (<>); -- Discrete type up to 32 entries\n+      type Resource_T is (<>);\n+      --  Discrete type up to 32 entries\n+\n    package Resource_Vector_Functions is\n-      function \"+\"(R : Resource_T)\n+      function \"+\"\n+        (R    : Resource_T)\n          return Resource_Vector_T;\n-      function \"+\"(R1, R2 : Resource_T)\n+\n+      function \"+\"\n+        (R1   : Resource_T;\n+         R2   : Resource_T)\n          return Resource_Vector_T;\n-      function \"+\"(R : Resource_T; S : Resource_Vector_T)\n+\n+      function \"+\"\n+        (R    : Resource_T;\n+         S    : Resource_Vector_T)\n          return Resource_Vector_T;\n-      function \"+\"(S : Resource_Vector_T; R : Resource_T)\n+\n+      function \"+\"\n+        (S    : Resource_Vector_T;\n+         R    : Resource_T)\n          return Resource_Vector_T;\n-      function \"+\"(S1, S2 : Resource_Vector_T)\n+\n+      function \"+\"\n+        (S1   : Resource_Vector_T;\n+         S2   : Resource_Vector_T)\n          return Resource_Vector_T;\n-      function \"-\"(S : Resource_Vector_T; R : Resource_T)\n+\n+      function \"-\"\n+        (S    : Resource_Vector_T;\n+         R    : Resource_T)\n          return Resource_Vector_T;\n    end Resource_Vector_Functions;\n \n@@ -129,7 +148,7 @@ pragma Elaborate_Body;\n \n    ANY_CPU : constant CPU_Number := CPU_Number'First;\n \n-   --\n+   type Non_Degrading_Priority is range 0 .. 255;\n    --  Specification of IRIX Non Degrading Priorities.\n    --\n    --  WARNING: IRIX priorities have the reverse meaning of Ada priorities.\n@@ -138,24 +157,22 @@ pragma Elaborate_Body;\n    --\n    --  See the schedctl(2) man page for a complete discussion of non-degrading\n    --  priorities.\n-   --\n-   type Non_Degrading_Priority is range 0 .. 255;\n \n-   --  these priorities are higher than ALL normal user process priorities\n-   NDPHIMAX   : constant Non_Degrading_Priority := 30;\n-   NDPHIMIN   : constant Non_Degrading_Priority := 39;\n+   NDPHIMAX : constant Non_Degrading_Priority := 30;\n+   NDPHIMIN : constant Non_Degrading_Priority := 39;\n+   --  These priorities are higher than ALL normal user process priorities\n \n    subtype NDP_High is Non_Degrading_Priority range NDPHIMAX .. NDPHIMIN;\n \n-   --  these priorities overlap normal user process priorities\n    NDPNORMMAX : constant Non_Degrading_Priority := 40;\n    NDPNORMMIN : constant Non_Degrading_Priority := 127;\n+   --  These priorities overlap normal user process priorities\n \n    subtype NDP_Norm is Non_Degrading_Priority range NDPNORMMAX .. NDPNORMMIN;\n \n-   --  these priorities are below ALL normal user process priorities\n-   NDPLOMAX   : constant Non_Degrading_Priority := 128;\n-   NDPLOMIN   : constant Non_Degrading_Priority := 254;\n+   NDPLOMAX : constant Non_Degrading_Priority := 128;\n+   NDPLOMIN : constant Non_Degrading_Priority := 254;\n+   --  These priorities are below ALL normal user process priorities\n \n    NDP_NONE   : constant Non_Degrading_Priority := 255;\n \n@@ -168,17 +185,16 @@ pragma Elaborate_Body;\n        DATLOCK     --  Lock data segment into memory (data lock)\n       );\n \n-   type Sproc_Attributes is\n-      record\n-         Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n-         CPU             : CPU_Number             := ANY_CPU;\n-         Resident        : Page_Locking           := NOLOCK;\n-         NDPRI           : Non_Degrading_Priority := NDP_NONE;\n+   type Sproc_Attributes is record\n+      Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      CPU             : CPU_Number             := ANY_CPU;\n+      Resident        : Page_Locking           := NOLOCK;\n+      NDPRI           : Non_Degrading_Priority := NDP_NONE;\n+--  ??? why is that commented out, should it be removed ?\n --       Sproc_Slice     : Duration               := 0.0;\n --       Deadline_Period : Duration               := 0.0;\n --       Deadline_Alloc  : Duration               := 0.0;\n-\n-      end record;\n+   end record;\n \n    Default_Sproc_Attributes : constant Sproc_Attributes :=\n       (NO_RESOURCES, ANY_CPU, NOLOCK, NDP_NONE);\n@@ -190,10 +206,8 @@ pragma Elaborate_Body;\n       Resident        : Page_Locking           := NOLOCK;\n       NDPRI           : Non_Degrading_Priority := NDP_NONE)\n       return            sproc_t;\n-   --\n-   --  Allocates a sproc_t controll structure and creates the\n+   --  Allocates a sproc_t control structure and creates the\n    --  corresponding sproc.\n-   --\n \n    Invalid_CPU_Number : exception;\n    Permission_Error   : exception;\n@@ -203,17 +217,18 @@ pragma Elaborate_Body;\n    -- Thread Attributes --\n    -----------------------\n \n-   type Thread_Attributes (Bound_To_Sproc : Boolean) is\n-      record\n-         Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n-         Thread_Timeslice : Duration          := 0.0;\n-         case Bound_To_Sproc is\n-            when False =>\n-               null;\n-            when True   =>\n-               Sproc : sproc_t;\n-         end case;\n-      end record;\n+   type Thread_Attributes (Bound_To_Sproc : Boolean) is record\n+      Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+\n+      Thread_Timeslice : Duration          := 0.0;\n+\n+      case Bound_To_Sproc is\n+         when False =>\n+            null;\n+         when True   =>\n+            Sproc : sproc_t;\n+      end case;\n+   end record;\n \n    Default_Thread_Attributes : constant Thread_Attributes :=\n      (False, NO_RESOURCES, 0.0);"}, {"sha": "f7713e9974c4fae59b25d6e77d41ff034689de1c", "filename": "gcc/ada/5hparame.ads", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5hparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5hparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hparame.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.5 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,7 @@\n ------------------------------------------------------------------------------\n \n --  This is the HP version of this package\n+--  Blank line intentional so that it lines up exactly with default.\n \n --  This package defines some system dependent parameters for GNAT. These\n --  are values that are referenced by the runtime library and are therefore\n@@ -101,7 +102,7 @@ pragma Pure (Parameters);\n    --  proper implementation of the stack overflow check.\n \n    ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n+   -- Characteristics of Types in Interfaces.C --\n    ----------------------------------------------\n \n    long_bits : constant := Long_Integer'Size;\n@@ -132,4 +133,59 @@ pragma Pure (Parameters);\n    Garbage_Collected : constant Boolean := False;\n    --  The storage mode for this system (release on program exit)\n \n+   ---------------------\n+   -- Tasking Profile --\n+   ---------------------\n+\n+   --  In the following sections, constant parameters are defined to\n+   --  allow some optimizations within the tasking run time based on\n+   --  restrictions on the tasking features.\n+\n+   ----------------------\n+   -- Locking Strategy --\n+   ----------------------\n+\n+   Single_Lock : constant Boolean := False;\n+   --  Indicates whether a single lock should be used within the tasking\n+   --  run-time to protect internal structures. If True, a single lock\n+   --  will be used, meaning less locking/unlocking operations, but also\n+   --  more global contention. In general, Single_Lock should be set to\n+   --  True on single processor machines, and to False to multi-processor\n+   --  systems, but this can vary from application to application and also\n+   --  depends on the scheduling policy.\n+\n+   -------------------\n+   -- Task Abortion --\n+   -------------------\n+\n+   No_Abort : constant Boolean := False;\n+   --  This constant indicates whether abort statements and asynchronous\n+   --  transfer of control (ATC) are disallowed. If set to True, it is\n+   --  assumed that neither construct is used, and the run time does not\n+   --  need to defer/undefer abort and check for pending actions at\n+   --  completion points. A value of True for No_Abort corresponds to:\n+   --  pragma Restrictions (No_Abort_Statements);\n+   --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n+\n+   ----------------------\n+   -- Dynamic Priority --\n+   ----------------------\n+\n+   Dynamic_Priority_Support : constant Boolean := True;\n+   --  This constant indicates whether dynamic changes of task priorities\n+   --  are allowed (True means normal RM mode in which such changes are\n+   --  allowed). In particular, if this is False, then we do not need to\n+   --  poll for pending base priority changes at every abort completion\n+   --  point. A value of False for Dynamic_Priority_Support corresponds\n+   --  to pragma Restrictions (No_Dynamic_Priorities);\n+\n+   --------------------\n+   -- Runtime Traces --\n+   --------------------\n+\n+   Runtime_Traces : constant Boolean := False;\n+   --  This constant indicates whether the runtime outputs traces to a\n+   --  predefined output or not (True means that traces are output).\n+   --  See System.Traces for more details.\n+\n end System.Parameters;"}, {"sha": "d6b40dce4db21f9adfadc7d631d377facbcc0b92", "filename": "gcc/ada/5hsystem.ads", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5hsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5hsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                             (HP-UX Version)                              --\n --                                                                          --\n---                            $Revision: 1.15 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := False;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := False;"}, {"sha": "7efc38806aee24098c0065e596390c10e1dc6a9b", "filename": "gcc/ada/5htaprop.adb", "status": "modified", "additions": 132, "deletions": 160, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5htaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5htaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,12 +29,11 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a HP-UX version of this package\n+--  This is a HP-UX DCE threads version of this package\n \n --  This package contains all the GNULL primitives that interface directly\n --  with the underlying OS.\n@@ -106,8 +105,10 @@ package body System.Task_Primitives.Operations is\n    ATCB_Key : aliased pthread_key_t;\n    --  Key used to find the Ada Task_ID associated with a thread\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -143,53 +144,12 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Handler --\n    -------------------\n \n-   --  Target-dependent binding of inter-thread Abort signal to\n-   --  the raising of the Abort_Signal exception.\n-\n-   --  The technical issues and alternatives here are essentially\n-   --  the same as for raising exceptions in response to other\n-   --  signals (e.g. Storage_Error).  See code and comments in\n-   --  the package body System.Interrupt_Management.\n-\n-   --  Some implementations may not allow an exception to be propagated\n-   --  out of a handler, and others might leave the signal or\n-   --  interrupt that invoked this handler masked after the exceptional\n-   --  return to the application code.\n-\n-   --  GNAT exceptions are originally implemented using setjmp()/longjmp().\n-   --  On most UNIX systems, this will allow transfer out of a signal handler,\n-   --  which is usually the only mechanism available for implementing\n-   --  asynchronous handlers of this kind.  However, some\n-   --  systems do not restore the signal mask on longjmp(), leaving the\n-   --  abort signal masked.\n-\n-   --  Alternative solutions include:\n-\n-   --       1. Change the PC saved in the system-dependent Context\n-   --          parameter to point to code that raises the exception.\n-   --          Normal return from this handler will then raise\n-   --          the exception after the mask and other system state has\n-   --          been restored (see example below).\n-   --       2. Use siglongjmp()/sigsetjmp() to implement exceptions.\n-   --       3. Unmask the signal in the Abortion_Signal exception handler\n-   --          (in the RTS).\n-\n-   --  The following procedure would be needed if we can't lonjmp out of\n-   --  a signal handler.  (See below.)\n-   --  procedure Raise_Abort_Signal is\n-   --  begin\n-   --     raise Standard'Abort_Signal;\n-   --  end if;\n-\n    procedure Abort_Handler (Sig : Signal) is\n       Self_Id : constant Task_ID := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n    begin\n-      --  Assuming it is safe to longjmp out of a signal handler, the\n-      --  following code can be used:\n-\n       if Self_Id.Deferral_Level = 0\n         and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level and then\n         not Self_Id.Aborting\n@@ -204,15 +164,6 @@ package body System.Task_Primitives.Operations is\n \n          raise Standard'Abort_Signal;\n       end if;\n-\n-      --  Otherwise, something like this is required:\n-      --  if not Abort_Is_Deferred.all then\n-      --    --  Overwrite the return PC address with the address of the\n-      --    --  special raise routine, and \"return\" to that routine's\n-      --    --  starting address.\n-      --    Context.PC := Raise_Abort_Signal'Address;\n-      --    return;\n-      --  end if;\n    end Abort_Handler;\n \n    -----------------\n@@ -243,7 +194,6 @@ package body System.Task_Primitives.Operations is\n \n    function Self return Task_ID is\n       Result : System.Address;\n-\n    begin\n       Result := pthread_getspecific (ATCB_Key);\n       pragma Assert (Result /= System.Null_Address);\n@@ -256,7 +206,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -266,7 +216,8 @@ package body System.Task_Primitives.Operations is\n       L    : access Lock)\n    is\n       Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n+      Result     : Interfaces.C.int;\n+\n    begin\n       Result := pthread_mutexattr_init (Attributes'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n@@ -290,7 +241,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n       Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n+      Result     : Interfaces.C.int;\n \n    begin\n       Result := pthread_mutexattr_init (Attributes'Access);\n@@ -318,15 +269,13 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L.L'Access);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : access RTS_Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n@@ -337,8 +286,7 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Result    : Interfaces.C.int;\n-\n+      Result : Interfaces.C.int;\n    begin\n       L.Owner_Priority := Get_Priority (Self);\n \n@@ -352,20 +300,24 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -382,41 +334,48 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Unlock (L : access Lock) is\n-      Result    : Interfaces.C.int;\n-\n+      Result : Interfaces.C.int;\n    begin\n       Result := pthread_mutex_unlock (L.L'Access);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason  : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n+\n       --  EINTR is not considered a failure.\n       pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n@@ -425,10 +384,6 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n    procedure Timed_Sleep\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -441,6 +396,7 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n+\n    begin\n       Timedout := True;\n       Yielded := False;\n@@ -458,9 +414,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait\n-              (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-               Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -479,10 +442,6 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n-\n    procedure Timed_Delay\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -492,13 +451,18 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n-   begin\n \n+   begin\n       --  Only the little window between deferring abort and\n       --  locking Self_ID is the reason we need to\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -520,8 +484,13 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Request'Access);\n+            else\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -534,6 +503,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Result := sched_yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -567,7 +541,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -579,7 +552,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Yield (Do_Yield : Boolean := True) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if Do_Yield then\n          Result := sched_yield;\n@@ -681,15 +653,17 @@ package body System.Task_Primitives.Operations is\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n       pragma Assert (Result = 0);\n \n-      Lock_All_Tasks_List;\n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      Lock_RTS;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n-      Unlock_All_Tasks_List;\n+\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -701,55 +675,52 @@ package body System.Task_Primitives.Operations is\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n \n-   ----------------------\n-   --  Initialize_TCB  --\n-   ----------------------\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-      Cond_Attr : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n \n    begin\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      if not Single_Lock then\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n+         if Result = 0 then\n+            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n \n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n       end if;\n \n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -834,8 +805,11 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n \n@@ -901,23 +875,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -955,7 +929,7 @@ package body System.Task_Primitives.Operations is\n \n       Environment_Task_ID := Environment_Task;\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n       Enter_Task (Environment_Task);\n@@ -985,7 +959,6 @@ package body System.Task_Primitives.Operations is\n    end do_nothing;\n \n begin\n-\n    declare\n       Result : Interfaces.C.int;\n    begin\n@@ -998,5 +971,4 @@ begin\n       Result := pthread_key_create (ATCB_Key'Access, do_nothing'Access);\n       pragma Assert (Result = 0);\n    end;\n-\n end System.Task_Primitives.Operations;"}, {"sha": "232449258a3225097ecb894aa7be369d4de940f2", "filename": "gcc/ada/5htraceb.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5htraceb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5htraceb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htraceb.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.10 $\n+--                            $Revision$\n --                                                                          --\n---           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2002 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -200,9 +200,6 @@ package body System.Traceback is\n    --  Descriptors.\n \n    subtype UWT is Unwind_Table_Region;\n-   type UWT_Ptr is access all UWT;\n-\n-   function To_UWT_Address is new Ada.Unchecked_Conversion (UWT_Ptr, Address);\n \n    --  The subprograms imported below are provided by the HP library\n \n@@ -598,4 +595,3 @@ package body System.Traceback is\n    end Call_Chain;\n \n end System.Traceback;\n-"}, {"sha": "56797f6cbd23e80b0d1db97d4639cb67a10ab650", "filename": "gcc/ada/5itaprop.adb", "status": "modified", "additions": 149, "deletions": 102, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5itaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5itaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5itaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -112,11 +111,10 @@ package body System.Task_Primitives.Operations is\n    --  The followings are logically constants, but need to be initialized\n    --  at run time.\n \n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n-\n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -186,6 +184,29 @@ package body System.Task_Primitives.Operations is\n    function To_pthread_t is new Unchecked_Conversion\n      (Integer, System.OS_Interface.pthread_t);\n \n+   --------------------\n+   -- Local Packages --\n+   --------------------\n+\n+   package Specific is\n+\n+      procedure Initialize (Environment_Task : Task_ID);\n+      pragma Inline (Initialize);\n+      --  Initialize various data needed by this package.\n+\n+      procedure Set (Self_Id : Task_ID);\n+      pragma Inline (Set);\n+      --  Set the self id for the current task.\n+\n+      function Self return Task_ID;\n+      pragma Inline (Self);\n+      --  Return a pointer to the Ada Task Control Block of the calling task.\n+\n+   end Specific;\n+\n+   package body Specific is separate;\n+   --  The body of this package is target specific.\n+\n    -------------------\n    -- Abort_Handler --\n    -------------------\n@@ -297,9 +318,27 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Handler;\n \n-   -------------------\n-   --  Stack_Guard  --\n-   -------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n+\n+   procedure Lock_RTS is\n+   begin\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n+\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n+\n+   procedure Unlock_RTS is\n+   begin\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n \n    --  The underlying thread system extends the memory (up to 2MB) when\n    --  needed.\n@@ -322,22 +361,15 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n-      Result : System.Address;\n-\n-   begin\n-      Result := pthread_getspecific (ATCB_Key);\n-      pragma Assert (Result /= System.Null_Address);\n-      return To_Task_ID (Result);\n-   end Self;\n+   function Self return Task_ID renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n    ---------------------\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -401,7 +433,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if Priority_Ceiling_Emulation then\n          declare\n@@ -427,20 +458,24 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -458,7 +493,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if Priority_Ceiling_Emulation then\n          declare\n@@ -476,39 +510,44 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-      --  Beware of any changes to this that might\n-      --  require access to the ATCB after the mutex is unlocked.\n-      --  This is the last operation performed by a task\n-      --  before it allows its ATCB to be deallocated, so it\n-      --  MUST NOT refer to the ATCB.\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason   : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n+\n       --  EINTR is not considered a failure.\n       pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n@@ -550,9 +589,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait\n-              (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-               Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -591,6 +637,11 @@ package body System.Task_Primitives.Operations is\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -612,8 +663,13 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Request'Access);\n+            else\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -626,6 +682,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Result := sched_yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -734,23 +795,22 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Enter_Task (Self_ID : Task_ID) is\n-      Result : Interfaces.C.int;\n-\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n \n-      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n-      pragma Assert (Result = 0);\n+      Specific.Set (Self_ID);\n \n-      Lock_All_Tasks_List;\n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      Lock_RTS;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n-      Unlock_All_Tasks_List;\n+\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -778,13 +838,15 @@ package body System.Task_Primitives.Operations is\n \n       Self_ID.Common.LL.Thread := To_pthread_t (-1);\n \n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      if not Single_Lock then\n+         Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+           Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n       end if;\n \n       Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n@@ -794,13 +856,13 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n    end Initialize_TCB;\n \n    -----------------\n@@ -865,13 +927,18 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n+\n       if T.Known_Tasks_Index /= -1 then\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n+\n       Free (Tmp);\n    end Finalize_TCB;\n \n@@ -927,24 +994,6 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n-\n-   procedure Lock_All_Tasks_List is\n-   begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n-\n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n-\n-   procedure Unlock_All_Tasks_List is\n-   begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n-\n    ------------------\n    -- Suspend_Task --\n    ------------------\n@@ -994,8 +1043,10 @@ package body System.Task_Primitives.Operations is\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n+      --  Initialize the global RTS lock\n+\n+      Specific.Initialize (Environment_Task);\n \n       Enter_Task (Environment_Task);\n \n@@ -1038,9 +1089,5 @@ begin\n             pragma Assert (Result = 0);\n          end if;\n       end loop;\n-\n-      Result := pthread_key_create (ATCB_Key'Access, null);\n-      pragma Assert (Result = 0);\n    end;\n-\n end System.Task_Primitives.Operations;"}, {"sha": "60bbcdb67f63465f733c1c46ddb2d11bc42f5360", "filename": "gcc/ada/5ksystem.ads", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ksystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ksystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ksystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                          (VxWorks version M68K)                          --\n --                                                                          --\n---                            $Revision: 1.11 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,40 +88,26 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   --  256 is reserved for the VxWorks kernel\n-   --  248 - 255 correspond to hardware interrupt levels 0 .. 7\n-   --  247 is a catchall default \"interrupt\" priority for signals, allowing\n-   --  higher priority than normal tasks, but lower than hardware\n-   --  priority levels.  Protected Object ceilings can override\n-   --  these values\n-   --  246 is used by the Interrupt_Manager task\n-\n-   Max_Priority : constant Positive := 245;\n+   --  256        is reserved for the VxWorks kernel\n+   --  248 - 255  correspond to hardware interrupt levels 0 .. 7\n+   --  247        is a catchall default \"interrupt\" priority for signals,\n+   --             allowing higher priority than normal tasks, but lower than\n+   --             hardware priority levels.  Protected Object ceilings can\n+   --             override these values.\n+   --  246        is used by the Interrupt_Manager task\n \n+   Max_Priority           : constant Positive := 245;\n    Max_Interrupt_Priority : constant Positive := 255;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range   0 .. 255;\n+   subtype Priority           is Any_Priority range   0 .. 245;\n+   subtype Interrupt_Priority is Any_Priority range 246 .. 255;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 122;\n \n private\n \n@@ -139,8 +125,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := False;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := False;"}, {"sha": "89e64f4318e3556e7ad5712910614d1225ba84dd", "filename": "gcc/ada/5kvxwork.ads", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5kvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5kvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5kvxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1998-2001 Free Software Foundation              --\n+--            Copyright (C) 1998-2001 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,30 +43,9 @@ package System.VxWorks is\n \n    package IC renames Interfaces.C;\n \n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 5.3[.1]),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n+   --  Floating point context record. 68K version\n \n-   type Wind_Fill_1 is array (0 .. 16#3F#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#48# .. 16#107#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1; -- 0x00 - 0x3f\n-      Priority        : IC.int;  -- 0x40 - 0x43, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x44 - 0x47, base priority\n-      Fill_2          : Wind_Fill_2; -- 0x48 - 0x107\n-      spare1          : Address;  -- 0x108 - 0x10b\n-      spare2          : Address;  -- 0x10c - 0x10f\n-      spare3          : Address;  -- 0x110 - 0x113\n-      spare4          : Address;  -- 0x114 - 0x117\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-   --  Floating point context record.  68K version\n-\n-   FP_NUM_DREGS : constant := 8;\n+   FP_NUM_DREGS        : constant := 8;\n    FP_STATE_FRAME_SIZE : constant := 216;\n \n    type DOUBLEX is array (1 .. 12) of Interfaces.Unsigned_8;\n@@ -97,25 +76,4 @@ package System.VxWorks is\n    Num_HW_Interrupts : constant := 256;\n    --  Number of entries in the hardware interrupt vector table\n \n-   --  VxWorks 5.3 and 5.4 version\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_name         : Address;  --  name of task\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-   end record;\n-   pragma Convention (C, TASK_DESC);\n-\n end System.VxWorks;"}, {"sha": "678d43aeba0d1c0d682342c3769a5f715e6accd1", "filename": "gcc/ada/5lintman.adb", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5lintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5lintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--             Copyright (C) 1991-2002 Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -304,33 +304,22 @@ begin\n \n       act.sa_mask := Signal_Mask;\n \n-      Result :=\n-        sigaction\n-        (Signal (SIGFPE), act'Unchecked_Access,\n-         old_act'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Exception_Interrupts'First + 1 .. Exception_Interrupts'Last loop\n+      for J in Exception_Interrupts'Range loop\n          Keep_Unmasked (Exception_Interrupts (J)) := True;\n-         if Unreserve_All_Interrupts = 0 then\n-            Result :=\n-              sigaction\n-              (Signal (Exception_Interrupts (J)),\n-               act'Unchecked_Access,\n-               old_act'Unchecked_Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result :=\n+           sigaction\n+           (Signal (Exception_Interrupts (J)),\n+            act'Unchecked_Access,\n+            old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n       end loop;\n \n       Keep_Unmasked (Abort_Task_Interrupt) := True;\n-      Keep_Unmasked (SIGXCPU) := True;\n-      Keep_Unmasked (SIGBUS) := True;\n-      Keep_Unmasked (SIGFPE) := True;\n \n       --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but in the\n       --  same time, disable the ability of handling this signal\n       --  via Ada.Interrupts.\n-      --  The pragma Unreserve_All_Interrupts let the user the ability to\n+      --  The pragma Unreserve_All_Interrupts allows the user to\n       --  change this behavior.\n \n       if Unreserve_All_Interrupts = 0 then"}, {"sha": "8cdd347e9acb82d2fa67eba8eb2aaece09fddb95", "filename": "gcc/ada/5lsystem.ads", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5lsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5lsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -5,11 +5,11 @@\n --                               S Y S T E M                                --\n --                                                                          --\n --                                 S p e c                                  --\n---                          (GNU/Linux/x86 Version)                         --\n+--                          (GNU-Linux/x86 Version)                         --\n --                                                                          --\n --                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,32 +88,18 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -131,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;\n@@ -146,5 +135,5 @@ private\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n    ZCX_By_Default            : constant Boolean := False;\n    GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := True;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n end System;"}, {"sha": "72be5d142bf3bc4a937dc8cbd1e10af8a1432d83", "filename": "gcc/ada/5mvxwork.ads", "status": "modified", "additions": 7, "deletions": 51, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5mvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5mvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5mvxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1998-2001 Free Software Foundation              --\n+--            Copyright (C) 1998-2001 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -43,61 +42,18 @@ package System.VxWorks is\n \n    package IC renames Interfaces.C;\n \n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 5.3[.1]),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n-\n-   type Wind_Fill_1 is array (0 .. 16#3F#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#48# .. 16#107#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1; -- 0x00 - 0x3f\n-      Priority        : IC.int;  -- 0x40 - 0x43, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x44 - 0x47, base priority\n-      Fill_2          : Wind_Fill_2; -- 0x48 - 0x107\n-      spare1          : Address;  -- 0x108 - 0x10b\n-      spare2          : Address;  -- 0x10c - 0x10f\n-      spare3          : Address;  -- 0x110 - 0x113\n-      spare4          : Address;  -- 0x114 - 0x117\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-   --  Floating point context record.  MIPS version\n+   --  Floating point context record. MIPS version\n \n    FP_NUM_DREGS : constant := 16;\n    type Fpx_Array is array (1 .. FP_NUM_DREGS) of IC.double;\n \n    type FP_CONTEXT is record\n-      fpx :   Fpx_Array;\n+      fpx   : Fpx_Array;\n       fpcsr : IC.int;\n    end record;\n    pragma Convention (C, FP_CONTEXT);\n \n-   --  Number of entries in hardware interrupt vector table.  Value of\n-   --  0 disables hardware interrupt handling until it can be tested\n-   Num_HW_Interrupts : constant := 0;\n-\n-   --  VxWorks 5.3 and 5.4 version\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_name         : Address;  --  name of task\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-   end record;\n-   pragma Convention (C, TASK_DESC);\n+   Num_HW_Interrupts : constant := 256;\n+   --  Number of entries in hardware interrupt vector table.\n \n end System.VxWorks;"}, {"sha": "3164c3fddadeed429454bb37d8081a6a3c0d8d89", "filename": "gcc/ada/5ninmaop.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ninmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ninmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ninmaop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -2,14 +2,13 @@\n --                                                                          --\n --                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n --                                                                          --\n---           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T .        --\n---                           O P E R A T I O N S                            --\n+--                  SYSTEM.INTERRUPT_MANAGEMENT.OPERATIONS                  --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.5 $                             --\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,6 +38,10 @@\n \n package body System.Interrupt_Management.Operations is\n \n+   --  Turn off warnings since many unused formals\n+\n+   pragma Warnings (Off);\n+\n    ----------------------------\n    -- Thread_Block_Interrupt --\n    ----------------------------"}, {"sha": "a62a43081f4ae1ef12247d5089bfc1816e6149ab", "filename": "gcc/ada/5nosinte.ads", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5nosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5nosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5nosinte.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,25 +29,21 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n --  This is the no tasking version\n \n-with Interfaces.C;\n package System.OS_Interface is\n    pragma Preelaborate;\n \n-   subtype int            is Interfaces.C.int;\n-\n    -------------\n    -- Signals --\n    -------------\n \n    Max_Interrupt : constant := 2;\n-   type Signal is new int range 0 .. Max_Interrupt;\n+   type Signal is new Integer range 0 .. Max_Interrupt;\n \n    type sigset_t is new Integer;\n    type Thread_Id is new Integer;"}, {"sha": "c16306cd20fd9704ffa290cf970d0605b491f0bc", "filename": "gcc/ada/5ntaprop.adb", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ntaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ntaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ntaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.33 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -59,9 +58,9 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n \n-   -------------------\n-   --  Stack_Guard  --\n-   -------------------\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n \n    procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n    begin\n@@ -92,8 +91,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n-      L    : access Lock)\n-   is\n+      L    : access Lock) is\n    begin\n       null;\n    end Initialize_Lock;\n@@ -126,7 +124,9 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n    begin\n       null;\n    end Write_Lock;\n@@ -154,7 +154,7 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n    begin\n       null;\n    end Unlock;\n@@ -164,12 +164,11 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason  : System.Tasking.Task_States) is\n+   procedure Sleep (Self_ID : Task_ID; Reason  : System.Tasking.Task_States) is\n    begin\n       null;\n    end Sleep;\n@@ -195,25 +194,11 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes)\n-   is\n-      Rel_Time : Duration;\n-\n-      procedure sleep (How_Long : Natural);\n-      pragma Import (C, sleep, \"sleep\");\n-\n+     (Self_ID : Task_ID;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes) is\n    begin\n-      if Mode = Relative then\n-         Rel_Time := Time;\n-      else\n-         Rel_Time := Time - Monotonic_Clock;\n-      end if;\n-\n-      if Rel_Time > 0.0 then\n-         sleep (Natural (Rel_Time));\n-      end if;\n+      null;\n    end Timed_Delay;\n \n    ---------------------\n@@ -248,8 +233,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T : Task_ID;\n-      Prio : System.Any_Priority;\n+     (T                   : Task_ID;\n+      Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False) is\n    begin\n       null;\n@@ -300,8 +285,7 @@ package body System.Task_Primitives.Operations is\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n+      Succeeded  : out Boolean) is\n    begin\n       Succeeded := False;\n    end Create_Task;\n@@ -372,23 +356,23 @@ package body System.Task_Primitives.Operations is\n       return null;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n       null;\n-   end Lock_All_Tasks_List;\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n       null;\n-   end Unlock_All_Tasks_List;\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -424,7 +408,6 @@ package body System.Task_Primitives.Operations is\n    No_Tasking : Boolean;\n \n begin\n-\n    --  Can't raise an exception because target independent packages try to\n    --  do an Abort_Defer, which gets a memory fault.\n "}, {"sha": "57491bc4cb1fde3b356ee97b720cc3690aec0efd", "filename": "gcc/ada/5ointerr.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ointerr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ointerr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ointerr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.5 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2000 Florida State University              --\n+--            Copyright (C) 1991-2001 Florida State University              --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,8 @@ with Ada.Exceptions;\n \n package body System.Interrupts is\n \n+   pragma Warnings (Off); -- kill warnings on unreferenced formals\n+\n    use System.Tasking;\n \n    -----------------------"}, {"sha": "66fee89f758e95b268d5b407dda40f181291ea0a", "filename": "gcc/ada/5omastop.adb", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5omastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5omastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5omastop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 B o d y                                  --\n --                            (Version for x86)                             --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n---           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2002 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,6 +41,7 @@\n with Unchecked_Conversion;\n with System.Storage_Elements;\n with System.Machine_Code; use System.Machine_Code;\n+with System.Memory;\n \n package body System.Machine_State_Operations is\n \n@@ -54,11 +55,7 @@ package body System.Machine_State_Operations is\n \n    function To_Address is new Unchecked_Conversion (Uns32, Address);\n \n-   function To_Uns32 is new Unchecked_Conversion (Integer,  Uns32);\n-   function To_Uns32 is new Unchecked_Conversion (Address,  Uns32);\n-\n    type Uns32_Ptr is access all Uns32;\n-   function To_Uns32_Ptr is new Unchecked_Conversion (Address, Uns32_Ptr);\n    function To_Uns32_Ptr is new Unchecked_Conversion (Uns32,   Uns32_Ptr);\n \n    --  Note: the type Uns32 has an alignment of 4. However, in some cases\n@@ -178,9 +175,12 @@ package body System.Machine_State_Operations is\n    Op_Immed : constant Bits6 := 2#100000#;\n \n    Op2_addl_Immed : constant Bits5 := 2#11100#;\n+   pragma Unreferenced (Op2_addl_Immed);\n+\n    Op2_subl_Immed : constant Bits5 := 2#11101#;\n \n    type Word_Byte is (Word, Byte);\n+   pragma Unreferenced (Byte);\n \n    type Ins_addl_subl_byte is record\n       Op   : Bits6;           -- Set to Op_Immed\n@@ -329,14 +329,11 @@ package body System.Machine_State_Operations is\n    ----------------------------\n \n    function Allocate_Machine_State return Machine_State is\n-\n       use System.Storage_Elements;\n \n-      function Gnat_Malloc (Size : Storage_Offset) return Machine_State;\n-      pragma Import (C, Gnat_Malloc, \"__gnat_malloc\");\n-\n    begin\n-      return Gnat_Malloc (MState'Max_Size_In_Storage_Elements);\n+      return Machine_State\n+        (Memory.Alloc (MState'Max_Size_In_Storage_Elements));\n    end Allocate_Machine_State;\n \n    --------------------\n@@ -445,11 +442,8 @@ package body System.Machine_State_Operations is\n    ------------------------\n \n    procedure Free_Machine_State (M : in out Machine_State) is\n-      procedure Gnat_Free (M : in Machine_State);\n-      pragma Import (C, Gnat_Free, \"__gnat_free\");\n-\n    begin\n-      Gnat_Free (M);\n+      Memory.Free (Address (M));\n       M := Machine_State (Null_Address);\n    end Free_Machine_State;\n \n@@ -584,7 +578,11 @@ package body System.Machine_State_Operations is\n \n    procedure Set_Signal_Machine_State\n      (M       : Machine_State;\n-      Context : System.Address) is\n+      Context : System.Address)\n+   is\n+      pragma Warnings (Off, M);\n+      pragma Warnings (Off, Context);\n+\n    begin\n       null;\n    end Set_Signal_Machine_State;"}, {"sha": "4ae707df55c815af27e354665cab51bb81584fa7", "filename": "gcc/ada/5oosinte.adb", "status": "modified", "additions": 2, "deletions": 136, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5oosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5oosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5oosinte.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.3 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2001 Florida State University              --\n+--            Copyright (C) 1991-2002 Florida State University              --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,6 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n --  tasking operations. It causes infinite loops and other problems.\n \n-with Interfaces.C.Strings;\n with Interfaces.OS2Lib.Errors;\n with Interfaces.OS2Lib.Synchronization;\n \n@@ -51,33 +50,6 @@ package body System.OS_Interface is\n    use Interfaces.OS2Lib.Synchronization;\n    use Interfaces.OS2Lib.Errors;\n \n-   ------------------\n-   -- Timer (spec) --\n-   ------------------\n-\n-   --  Although the OS uses a 32-bit integer representing milliseconds\n-   --  as timer value that doesn't work for us since 32 bits are not\n-   --  enough for absolute timing. Also it is useful to use better\n-   --  intermediate precision when adding/subtracting timing intervals.\n-   --  So we use the standard Ada Duration type which is implemented using\n-   --  microseconds.\n-\n-   --  Shouldn't the timer be moved to a separate package ???\n-\n-   type Timer is record\n-      Handle : aliased HTIMER := NULLHANDLE;\n-      Event  : aliased HEV    := NULLHANDLE;\n-   end record;\n-\n-   procedure Initialize (T :    out Timer);\n-   procedure Finalize   (T : in out Timer);\n-   procedure Wait       (T : in out Timer);\n-   procedure Reset      (T : in out Timer);\n-\n-   procedure Set_Timer_For (T : in out Timer; Period : in Duration);\n-   procedure Set_Timer_At  (T : in out Timer; Time   : in Duration);\n-   --  Add a hook to locate the Epoch, for use with Calendar????\n-\n    -----------\n    -- Yield --\n    -----------\n@@ -147,110 +119,4 @@ package body System.OS_Interface is\n       return Tick_Count * Tick_Duration;\n    end Clock;\n \n-   ----------------------\n-   -- Initialize Timer --\n-   ----------------------\n-\n-   procedure Initialize (T : out Timer) is\n-   begin\n-      pragma Assert\n-        (T.Handle = NULLHANDLE, \"GNULLI---Timer already initialized\");\n-\n-      Must_Not_Fail (DosCreateEventSem\n-        (pszName => Interfaces.C.Strings.Null_Ptr,\n-         f_phev  => T.Event'Unchecked_Access,\n-         flAttr  => DC_SEM_SHARED,\n-         fState  => False32));\n-   end Initialize;\n-\n-   -------------------\n-   -- Set_Timer_For --\n-   -------------------\n-\n-   procedure Set_Timer_For\n-     (T         : in out Timer;\n-      Period    : in Duration)\n-   is\n-      Rel_Time  : Duration_In_Millisec :=\n-                    Duration_In_Millisec (Period * 1_000.0);\n-\n-   begin\n-      pragma Assert\n-        (T.Event /= NULLHANDLE, \"GNULLI---Timer not initialized\");\n-      pragma Assert\n-        (T.Handle = NULLHANDLE, \"GNULLI---Timer already in use\");\n-\n-      Must_Not_Fail (DosAsyncTimer\n-        (msec      => ULONG (Rel_Time),\n-         F_hsem    => HSEM (T.Event),\n-         F_phtimer => T.Handle'Unchecked_Access));\n-   end Set_Timer_For;\n-\n-   ------------------\n-   -- Set_Timer_At --\n-   ------------------\n-\n-   --  Note that the timer is started in a critical section to prevent the\n-   --  race condition when absolute time is converted to time relative to\n-   --  current time. T.Event will be posted when the Time has passed\n-\n-   procedure Set_Timer_At\n-     (T         : in out Timer;\n-      Time      : in Duration)\n-   is\n-      Relative_Time : Duration;\n-\n-   begin\n-      Must_Not_Fail (DosEnterCritSec);\n-\n-      begin\n-         Relative_Time := Time - Clock;\n-         if Relative_Time >  0.0 then\n-            Set_Timer_For (T, Period => Time - Clock);\n-         else\n-            Sem_Must_Not_Fail (DosPostEventSem (T.Event));\n-         end if;\n-      end;\n-\n-      Must_Not_Fail (DosExitCritSec);\n-   end Set_Timer_At;\n-\n-   ----------\n-   -- Wait --\n-   ----------\n-\n-   procedure Wait (T : in out Timer) is\n-   begin\n-      Sem_Must_Not_Fail (DosWaitEventSem (T.Event, SEM_INDEFINITE_WAIT));\n-      T.Handle := NULLHANDLE;\n-   end Wait;\n-\n-   -----------\n-   -- Reset --\n-   -----------\n-\n-   procedure Reset (T : in out Timer) is\n-      Dummy_Count : aliased ULONG;\n-\n-   begin\n-      if T.Handle /= NULLHANDLE then\n-         Must_Not_Fail (DosStopTimer (T.Handle));\n-         T.Handle := NULLHANDLE;\n-      end if;\n-\n-      Sem_Must_Not_Fail\n-        (DosResetEventSem (T.Event, Dummy_Count'Unchecked_Access));\n-   end Reset;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (T : in out Timer) is\n-   begin\n-      Reset (T);\n-      Must_Not_Fail (DosCloseEventSem (T.Event));\n-      T.Event := NULLHANDLE;\n-   end Finalize;\n-\n end System.OS_Interface;"}, {"sha": "8e3774e6760436ac7325bc26154458742f36ca58", "filename": "gcc/ada/5osystem.ads", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5osystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5osystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5osystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                             (OS/2 Version)                               --\n --                                                                          --\n---                            $Revision: 1.9 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,32 +88,18 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -131,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;\n@@ -146,6 +135,6 @@ private\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n    ZCX_By_Default            : constant Boolean := False;\n    GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := True;\n \n end System;"}, {"sha": "a71a09db015116b2583414851d05c0a4b96c880f", "filename": "gcc/ada/5otaprop.adb", "status": "modified", "additions": 181, "deletions": 111, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5otaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5otaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5otaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -91,29 +90,29 @@ package body System.Task_Primitives.Operations is\n    use Interfaces.OS2Lib.Errors;\n    use Interfaces.OS2Lib.Threads;\n    use Interfaces.OS2Lib.Synchronization;\n+   use System.Parameters;\n    use System.Tasking.Debug;\n    use System.Tasking;\n    use System.OS_Interface;\n    use Interfaces.C;\n    use System.OS_Primitives;\n \n-   ----------------------\n-   --  Local Constants --\n-   ----------------------\n+   ---------------------\n+   -- Local Constants --\n+   ---------------------\n \n    Max_Locks_Per_Task   : constant := 100;\n    Suppress_Owner_Check : constant Boolean := False;\n \n-   ------------------\n-   --  Local Types --\n-   ------------------\n+   -----------------\n+   -- Local Types --\n+   -----------------\n \n-   type Microseconds is new IC.long;\n    subtype Lock_Range is Integer range 0 .. Max_Locks_Per_Task;\n \n-   ------------------\n-   --  Local Data  --\n-   ------------------\n+   -----------------\n+   -- Local Data  --\n+   -----------------\n \n    --  The OS/2 DosAllocThreadLocalMemory API is used to allocate our TCB_Ptr.\n \n@@ -138,8 +137,10 @@ package body System.Task_Primitives.Operations is\n \n    type PPTLD is access all Access_Thread_Local_Data;\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -192,15 +193,18 @@ package body System.Task_Primitives.Operations is\n    --  handler or to change the execution context of the thread.\n    --  So asynchonous transfer of control is not supported.\n \n-   -------------------\n-   --  Stack_Guard  --\n-   -------------------\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n \n    --  The underlying thread system sets a guard page at the\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n    procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+      pragma Warnings (Off, T);\n+      pragma Warnings (Off, On);\n+\n    begin\n       null;\n    end Stack_Guard;\n@@ -220,7 +224,6 @@ package body System.Task_Primitives.Operations is\n \n    function Self return Task_ID is\n       Self_ID : Task_ID renames Thread_Local_Data_Ptr.Self_ID;\n-\n    begin\n       --  Check that the thread local data has been initialized.\n \n@@ -252,6 +255,8 @@ package body System.Task_Primitives.Operations is\n    end Initialize_Lock;\n \n    procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      pragma Warnings (Off, Level);\n+\n    begin\n       if DosCreateMutexSem\n         (ICS.Null_Ptr, L.Mutex'Unchecked_Access, 0, False32) /= NO_ERROR\n@@ -312,44 +317,52 @@ package body System.Task_Primitives.Operations is\n       L.Owner_ID := Self_ID.all'Address;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n-      Self_ID      : constant Task_ID := Thread_Local_Data_Ptr.Self_ID;\n-      Old_Priority : constant Any_Priority :=\n-        Self_ID.Common.LL.Current_Priority;\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n+      Self_ID      : Task_ID;\n+      Old_Priority : Any_Priority;\n \n    begin\n-      --  Increase priority before getting the lock\n-      --  to prevent priority inversion\n+      if not Single_Lock or else Global_Lock then\n+         Self_ID := Thread_Local_Data_Ptr.Self_ID;\n+         Old_Priority := Self_ID.Common.LL.Current_Priority;\n \n-      Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-        Thread_Local_Data_Ptr.Lock_Prio_Level + 1;\n+         --  Increase priority before getting the lock\n+         --  to prevent priority inversion\n \n-      if L.Priority > Old_Priority then\n-         Set_Temporary_Priority (Self_ID, L.Priority);\n-      end if;\n+         Thread_Local_Data_Ptr.Lock_Prio_Level :=\n+           Thread_Local_Data_Ptr.Lock_Prio_Level + 1;\n \n-      --  Request the lock and then update the lock owner data\n+         if L.Priority > Old_Priority then\n+            Set_Temporary_Priority (Self_ID, L.Priority);\n+         end if;\n \n-      Must_Not_Fail (DosRequestMutexSem (L.Mutex, SEM_INDEFINITE_WAIT));\n-      L.Owner_Priority := Old_Priority;\n-      L.Owner_ID := Self_ID.all'Address;\n+         --  Request the lock and then update the lock owner data\n+\n+         Must_Not_Fail (DosRequestMutexSem (L.Mutex, SEM_INDEFINITE_WAIT));\n+         L.Owner_Priority := Old_Priority;\n+         L.Owner_ID := Self_ID.all'Address;\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n    begin\n-      --  Request the lock and then update the lock owner data\n+      if not Single_Lock then\n+         --  Request the lock and then update the lock owner data\n \n-      Must_Not_Fail\n-        (DosRequestMutexSem (T.Common.LL.L.Mutex, SEM_INDEFINITE_WAIT));\n-      T.Common.LL.L.Owner_ID := Null_Address;\n+         Must_Not_Fail\n+           (DosRequestMutexSem (T.Common.LL.L.Mutex, SEM_INDEFINITE_WAIT));\n+         T.Common.LL.L.Owner_ID := Null_Address;\n+      end if;\n    end Write_Lock;\n \n    ---------------\n    -- Read_Lock --\n    ---------------\n \n-   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean)\n-      renames Write_Lock;\n+   procedure Read_Lock\n+     (L : access Lock; Ceiling_Violation : out Boolean) renames Write_Lock;\n \n    ------------\n    -- Unlock --\n@@ -383,61 +396,76 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n-      Self_ID      : constant Task_ID := Thread_Local_Data_Ptr.Self_ID;\n-      Old_Priority : constant Any_Priority := L.Owner_Priority;\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n+      Self_ID      : Task_ID;\n+      Old_Priority : Any_Priority;\n \n    begin\n-      --  Check that this task holds the lock\n+      if not Single_Lock or else Global_Lock then\n+         Self_ID := Thread_Local_Data_Ptr.Self_ID;\n+         Old_Priority := L.Owner_Priority;\n+         --  Check that this task holds the lock\n \n-      pragma Assert (Suppress_Owner_Check\n-        or else L.Owner_ID = Self_ID.all'Address);\n+         pragma Assert (Suppress_Owner_Check\n+           or else L.Owner_ID = Self_ID.all'Address);\n \n-      --  Upate the owner data\n+         --  Upate the owner data\n \n-      L.Owner_ID := Null_Address;\n+         L.Owner_ID := Null_Address;\n \n-      --  Do the actual unlocking. No more references\n-      --  to owner data of L after this point.\n+         --  Do the actual unlocking. No more references\n+         --  to owner data of L after this point.\n \n-      Must_Not_Fail (DosReleaseMutexSem (L.Mutex));\n+         Must_Not_Fail (DosReleaseMutexSem (L.Mutex));\n \n-      --  Reset priority after unlocking to avoid priority inversion\n-      Thread_Local_Data_Ptr.Lock_Prio_Level :=\n-        Thread_Local_Data_Ptr.Lock_Prio_Level - 1;\n+         --  Reset priority after unlocking to avoid priority inversion\n+         Thread_Local_Data_Ptr.Lock_Prio_Level :=\n+           Thread_Local_Data_Ptr.Lock_Prio_Level - 1;\n \n-      if L.Priority /= Old_Priority then\n-         Set_Temporary_Priority (Self_ID, Old_Priority);\n+         if L.Priority /= Old_Priority then\n+            Set_Temporary_Priority (Self_ID, Old_Priority);\n+         end if;\n       end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n    begin\n-      --  Check the owner data\n+      if not Single_Lock then\n+         --  Check the owner data\n \n-      pragma Assert (Suppress_Owner_Check\n-        or else T.Common.LL.L.Owner_ID = Null_Address);\n+         pragma Assert (Suppress_Owner_Check\n+           or else T.Common.LL.L.Owner_ID = Null_Address);\n \n-      --  Do the actual unlocking. No more references\n-      --  to owner data of T.Common.LL.L after this point.\n+         --  Do the actual unlocking. No more references\n+         --  to owner data of T.Common.LL.L after this point.\n \n-      Must_Not_Fail (DosReleaseMutexSem (T.Common.LL.L.Mutex));\n+         Must_Not_Fail (DosReleaseMutexSem (T.Common.LL.L.Mutex));\n+      end if;\n    end Unlock;\n \n    -----------\n    -- Sleep --\n    -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      pragma Warnings (Off, Reason);\n+\n       Count : aliased ULONG; -- Used to store dummy result\n \n    begin\n       --  Must reset Cond BEFORE L is unlocked.\n \n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV, Count'Unchecked_Access));\n-      Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      else\n+         Unlock (Self_ID);\n+      end if;\n \n       --  No problem if we are interrupted here.\n       --  If the condition is signaled, DosWaitEventSem will simply not block.\n@@ -447,7 +475,11 @@ package body System.Task_Primitives.Operations is\n \n       --  Since L was previously accquired, lock operation should not fail.\n \n-      Write_Lock (Self_ID);\n+      if Single_Lock then\n+         Lock_RTS;\n+      else\n+         Write_Lock (Self_ID);\n+      end if;\n    end Sleep;\n \n    -----------------\n@@ -472,6 +504,8 @@ package body System.Task_Primitives.Operations is\n       Timedout : out Boolean;\n       Yielded  : out Boolean)\n    is\n+      pragma Warnings (Off, Reason);\n+\n       Check_Time : constant Duration := OSP.Monotonic_Clock;\n       Rel_Time   : Duration;\n       Abs_Time   : Duration;\n@@ -485,7 +519,12 @@ package body System.Task_Primitives.Operations is\n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV,\n          Count'Unchecked_Access));\n-      Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      else\n+         Unlock (Self_ID);\n+      end if;\n \n       Timedout := True;\n       Yielded := False;\n@@ -529,7 +568,11 @@ package body System.Task_Primitives.Operations is\n \n       --  Ensure post-condition\n \n-      Write_Lock (Self_ID);\n+      if Single_Lock then\n+         Lock_RTS;\n+      else\n+         Write_Lock (Self_ID);\n+      end if;\n \n       if Timedout then\n          Sem_Must_Not_Fail (DosPostEventSem (Self_ID.Common.LL.CV));\n@@ -550,7 +593,7 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Timedout   : Boolean := True;\n       Time_Out   : ULONG;\n-      Result    : APIRET;\n+      Result     : APIRET;\n       Count      : aliased ULONG;  --  Used to store dummy result\n \n    begin\n@@ -559,14 +602,24 @@ package body System.Task_Primitives.Operations is\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n-      Write_Lock (Self_ID);\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      else\n+         Write_Lock (Self_ID);\n+      end if;\n \n       --  Must reset Cond BEFORE Self_ID is unlocked.\n \n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV,\n          Count'Unchecked_Access));\n-      Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      else\n+         Unlock (Self_ID);\n+      end if;\n \n       if Mode = Relative then\n          Rel_Time := Time;\n@@ -578,6 +631,7 @@ package body System.Task_Primitives.Operations is\n \n       if Rel_Time > 0.0 then\n          Self_ID.Common.State := Delay_Sleep;\n+\n          loop\n             if Self_ID.Pending_Priority_Change then\n                Self_ID.Pending_Priority_Change := False;\n@@ -599,15 +653,22 @@ package body System.Task_Primitives.Operations is\n          Timedout := Result = ERROR_TIMEOUT;\n       end if;\n \n-      --  Ensure post-condition\n-\n-      Write_Lock (Self_ID);\n+      if Single_Lock then\n+         Lock_RTS;\n+      else\n+         Write_Lock (Self_ID);\n+      end if;\n \n       if Timedout then\n          Sem_Must_Not_Fail (DosPostEventSem (Self_ID.Common.LL.CV));\n       end if;\n \n-      Unlock (Self_ID);\n+      if Single_Lock then\n+         Unlock_RTS;\n+      else\n+         Unlock (Self_ID);\n+      end if;\n+\n       System.OS_Interface.Yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -617,6 +678,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+      pragma Warnings (Off, Reason);\n    begin\n       Sem_Must_Not_Fail (DosPostEventSem (T.Common.LL.CV));\n    end Wakeup;\n@@ -659,7 +721,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Delta_Priority /= 0 then\n-\n          --  ??? There is a race-condition here\n          --  The TCB is updated before the system call to make\n          --  pre-emption in the critical section less likely.\n@@ -679,9 +740,12 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T : Task_ID;\n-      Prio : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False) is\n+     (T                   : Task_ID;\n+      Prio                : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      pragma Warnings (Off, Loss_Of_Inheritance);\n+\n    begin\n       T.Common.Current_Priority := Prio;\n       Set_Temporary_Priority (T, Prio);\n@@ -702,21 +766,22 @@ package body System.Task_Primitives.Operations is\n \n    procedure Enter_Task (Self_ID : Task_ID) is\n    begin\n-\n       --  Initialize thread local data. Must be done first.\n \n       Thread_Local_Data_Ptr.Self_ID := Self_ID;\n       Thread_Local_Data_Ptr.Lock_Prio_Level := 0;\n \n-      Lock_All_Tasks_List;\n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      Lock_RTS;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n-      Unlock_All_Tasks_List;\n+\n+      Unlock_RTS;\n \n       --  For OS/2, we can set Self_ID.Common.LL.Thread in\n       --  Create_Task, since the thread is created suspended.\n@@ -725,7 +790,6 @@ package body System.Task_Primitives.Operations is\n       --  has been initialized.\n \n       --  .... Do we need to do anything with signals for OS/2 ???\n-      null;\n    end Enter_Task;\n \n    --------------\n@@ -746,17 +810,19 @@ package body System.Task_Primitives.Operations is\n       if DosCreateEventSem (ICS.Null_Ptr,\n         Self_ID.Common.LL.CV'Unchecked_Access, 0, True32) = NO_ERROR\n       then\n-         if DosCreateMutexSem (ICS.Null_Ptr,\n-           Self_ID.Common.LL.L.Mutex'Unchecked_Access, 0, False32) /= NO_ERROR\n+         if not Single_Lock\n+           and then DosCreateMutexSem\n+             (ICS.Null_Ptr,\n+              Self_ID.Common.LL.L.Mutex'Unchecked_Access,\n+              0,\n+              False32) /= NO_ERROR\n          then\n             Succeeded := False;\n             Must_Not_Fail (DosCloseEventSem (Self_ID.Common.LL.CV));\n          else\n             Succeeded := True;\n          end if;\n \n-         pragma Assert (Self_ID.Common.LL.L.Mutex /= 0);\n-\n          --  We now want to do the equivalent of:\n \n          --  Initialize_Lock\n@@ -774,7 +840,7 @@ package body System.Task_Primitives.Operations is\n          Succeeded := False;\n       end if;\n \n-      --  Note: at one time we had anb exception handler here, whose code\n+      --  Note: at one time we had an exception handler here, whose code\n       --  was as follows:\n \n       --  exception\n@@ -789,7 +855,6 @@ package body System.Task_Primitives.Operations is\n       --  result in messing with Jmpbuf values too early. If and when we get\n       --  switched entirely to the new zero-cost exception scheme, we could\n       --  put this handler back in!\n-\n    end Initialize_TCB;\n \n    -----------------\n@@ -889,12 +954,18 @@ package body System.Task_Primitives.Operations is\n \n       procedure Free is new\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n    begin\n       Must_Not_Fail (DosCloseEventSem (T.Common.LL.CV));\n-      Finalize_Lock (T.Common.LL.L'Unchecked_Access);\n+\n+      if not Single_Lock then\n+         Finalize_Lock (T.Common.LL.L'Unchecked_Access);\n+      end if;\n+\n       if T.Known_Tasks_Index /= -1 then\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n+\n       Free (Tmp);\n    end Finalize_TCB;\n \n@@ -916,6 +987,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Abort_Task (T : Task_ID) is\n+      pragma Warnings (Off, T);\n+\n    begin\n       null;\n \n@@ -956,23 +1029,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -1010,11 +1083,10 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize (Environment_Task : Task_ID) is\n       Succeeded : Boolean;\n-\n    begin\n       Environment_Task_ID := Environment_Task;\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n       --  Set ID of environment task.\n@@ -1047,7 +1119,6 @@ package body System.Task_Primitives.Operations is\n \n       --  Insert here any other special\n       --  initialization needed for the environment task.\n-\n    end Initialize;\n \n begin\n@@ -1062,5 +1133,4 @@ begin\n \n    Thread_Local_Data_Ptr.Self_ID := null;\n    Thread_Local_Data_Ptr.Lock_Prio_Level := 0;\n-\n end System.Task_Primitives.Operations;"}, {"sha": "e2a575f344b6b6171ef2d1c033765ef7208218f5", "filename": "gcc/ada/5otaspri.ads", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5otaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5otaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5otaspri.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.5 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-1999 Florida State University              --\n+--            Copyright (C) 1991-2001 Florida State University              --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,13 +69,12 @@ package System.Task_Primitives is\n \n --  private\n \n-   type Lock is\n-      record\n-         Mutex          : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n-         Priority       : Integer;\n-         Owner_Priority : Integer;\n-         Owner_ID       : Address;\n-      end record;\n+   type Lock is record\n+      Mutex          : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n+      Priority       : Integer;\n+      Owner_Priority : Integer;\n+      Owner_ID       : Address;\n+   end record;\n \n    type RTS_Lock is new Lock;\n "}, {"sha": "c29f358aaa3d1a3af39c6b2ca367d765c67f760b", "filename": "gcc/ada/5pvxwork.ads", "status": "modified", "additions": 6, "deletions": 49, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5pvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5pvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5pvxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                             $Revision: 1.1 $                             --\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1998 - 2001 Free Software Foundation           --\n+--            Copyright (C) 1998-2001 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the PPC VxWorks 5.x version of this package.  A different version\n---  is used for VxWorks 6.0\n+--  This is the PPC VxWorks version of this package.\n \n with Interfaces.C;\n \n@@ -44,60 +43,18 @@ package System.VxWorks is\n \n    package IC renames Interfaces.C;\n \n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 5.3[.1]),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n-\n-   type Wind_Fill_1 is array (0 .. 16#3F#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#48# .. 16#107#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1; -- 0x00 - 0x3f\n-      Priority        : IC.int;  -- 0x40 - 0x43, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x44 - 0x47, base priority\n-      Fill_2          : Wind_Fill_2; -- 0x48 - 0x107\n-      spare1          : Address;  -- 0x108 - 0x10b\n-      spare2          : Address;  -- 0x10c - 0x10f\n-      spare3          : Address;  -- 0x110 - 0x113\n-      spare4          : Address;  -- 0x114 - 0x117\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-   --  Floating point context record.  PPC version\n+   --  Floating point context record. PPC version\n \n    FP_NUM_DREGS : constant := 32;\n    type Fpr_Array is array (1 .. FP_NUM_DREGS) of IC.double;\n \n    type FP_CONTEXT is record\n-      fpr :   Fpr_Array;\n+      fpr   : Fpr_Array;\n       fpcsr : IC.int;\n-      pad :   IC.int;\n+      pad   : IC.int;\n    end record;\n    pragma Convention (C, FP_CONTEXT);\n \n    Num_HW_Interrupts : constant := 256;\n \n-   --  VxWorks 5.3 and 5.4 version\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_name         : Address;  --  name of task\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-   end record;\n-   pragma Convention (C, TASK_DESC);\n-\n end System.VxWorks;"}, {"sha": "1c42fdcd45674a8579f58ee103379e8ddb2720ff", "filename": "gcc/ada/5qparame.ads", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5qparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5qparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qparame.ads?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "patch": "@@ -1,136 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                            $Revision$\n---                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the RT-GNU/Linux version.\n---  Blank line intentional so that it lines up exactly with default.\n-\n---  This package defines some system dependent parameters for GNAT. These\n---  are values that are referenced by the runtime library and are therefore\n---  relevant to the target machine.\n-\n---  The parameters whose value is defined in the spec are not generally\n---  expected to be changed. If they are changed, it will be necessary to\n---  recompile the run-time library.\n-\n---  The parameters which are defined by functions can be changed by modifying\n---  the body of System.Parameters in file s-parame.adb. A change to this body\n---  requires only rebinding and relinking of the application.\n-\n---  Note: do not introduce any pragma Inline statements into this unit, since\n---  otherwise the relinking and rebinding capability would be deactivated.\n-\n-package System.Parameters is\n-pragma Pure (Parameters);\n-\n-   ---------------------------------------\n-   -- Task And Stack Allocation Control --\n-   ---------------------------------------\n-\n-   type Task_Storage_Size is new Integer;\n-   --  Type used in tasking units for task storage size\n-\n-   type Size_Type is new Task_Storage_Size;\n-   --  Type used to provide task storage size to runtime\n-\n-   Unspecified_Size : constant Size_Type := Size_Type'First;\n-   --  Value used to indicate that no size type is set\n-\n-   subtype Ratio is Size_Type range -1 .. 100;\n-   Dynamic : constant Size_Type := 10;\n-   --  The secondary stack ratio is a constant between 0 and 100 which\n-   --  determines the percentage of the allocated task stack that is\n-   --  used by the secondary stack (the rest being the primary stack).\n-   --  The special value of minus one indicates that the secondary\n-   --  stack is to be allocated from the heap instead.\n-\n-   Sec_Stack_Ratio : constant Ratio := Dynamic;\n-   --  This constant defines the handling of the secondary stack\n-\n-   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Ratio = Dynamic;\n-   --  Convenient Boolean for testing for dynamic secondary stack\n-\n-   function Default_Stack_Size return Size_Type;\n-   --  Default task stack size used if none is specified\n-\n-   function Minimum_Stack_Size return Size_Type;\n-   --  Minimum task stack size permitted\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n-   --  Given the storage size stored in the TCB, return the Storage_Size\n-   --  value required by the RM for the Storage_Size attribute. The\n-   --  required adjustment is as follows:\n-   --\n-   --    when Size = Unspecified_Size, return Default_Stack_Size\n-   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n-   --    otherwise return given Size\n-\n-   Stack_Grows_Down  : constant Boolean := True;\n-   --  This constant indicates whether the stack grows up (False) or\n-   --  down (True) in memory as functions are called. It is used for\n-   --  proper implementation of the stack overflow check.\n-\n-   ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n-   ----------------------------------------------\n-\n-   long_bits : constant := Long_Integer'Size;\n-   --  Number of bits in type long and unsigned_long. The normal convention\n-   --  is that this is the same as type Long_Integer, but this is not true\n-   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n-\n-   ----------------------------------------------\n-   -- Behavior of Pragma Finalize_Storage_Only --\n-   ----------------------------------------------\n-\n-   --  Garbage_Collected is a Boolean constant whose value indicates the\n-   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n-\n-   --    Garbage_Collected = False\n-\n-   --      The system releases all storage on program termination only,\n-   --      but not other garbage collection occurs, so finalization calls\n-   --      are ommitted only for outer level onjects can be omitted if\n-   --      pragma Finalize_Storage_Only is used.\n-\n-   --    Garbage_Collected = True\n-\n-   --      The system provides full garbage collection, so it is never\n-   --      necessary to release storage for controlled objects for which\n-   --      a pragma Finalize_Storage_Only is used.\n-\n-   Garbage_Collected : constant Boolean := False;\n-   --  The storage mode for this system (release on program exit)\n-\n-end System.Parameters;"}, {"sha": "6d18563e5837e50a319fe04f360af3842e10edef", "filename": "gcc/ada/5qtaprop.adb", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5qtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5qtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qtaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -8,7 +8,7 @@\n --                                                                          --\n --                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -185,8 +184,10 @@ package body System.Task_Primitives.Operations is\n    --  In the current implementation, this is the task assigned permanently\n    --  as the regular GNU/Linux kernel.\n \n-   All_Tasks_L : aliased RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    --  The followings are internal configuration constants needed.\n    Next_Serial_Number : Task_Serial_Number := 100;\n@@ -722,12 +723,10 @@ package body System.Task_Primitives.Operations is\n    -- Write_Lock --\n    ----------------\n \n-   procedure Write_Lock\n-     (L : access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Prio : constant System.Any_Priority :=\n         Current_Task.Common.LL.Active_Priority;\n+\n    begin\n       pragma Debug (Printk (\"procedure Write_Lock called\" & LF));\n \n@@ -756,7 +755,9 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Prio : constant System.Any_Priority :=\n         Current_Task.Common.LL.Active_Priority;\n \n@@ -872,7 +873,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Flags : Integer;\n    begin\n       pragma Debug (Printk (\"procedure Unlock (RTS_Lock) called\" & LF));\n@@ -1607,27 +1608,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      pragma Debug (Printk (\"procedure Lock_All_Tasks_List called\" & LF));\n-\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      pragma Debug (Printk (\"procedure Unlock_All_Tasks_List called\" & LF));\n-\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    -----------------\n    -- Stack_Guard --\n@@ -1770,7 +1767,10 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n+\n+      --  Single_Lock isn't supported in this configuration\n+      pragma Assert (not Single_Lock);\n \n       Enter_Task (Environment_Task);\n    end Initialize;"}, {"sha": "7f3bd8c2393cf607b455db00b6bad4469ae715a5", "filename": "gcc/ada/5qvxwork.ads", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5qvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5qvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qvxwork.ads?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "patch": "@@ -1,112 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n---                                                                          --\n---                        S Y S T E M . V X W O R K S                       --\n---                                                                          --\n---                                   S p e c                                --\n---                                                                          --\n---                             $Revision: 1.1 $                             --\n---                                                                          --\n---             Copyright (C) 1998 - 2001 Free Software Foundation           --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the PPC VxWorks 6.0 version of this package. A different version\n---  is used for VxWorks 5.x\n-\n-with Interfaces.C;\n-\n-package System.VxWorks is\n-   pragma Preelaborate (System.VxWorks);\n-\n-   package IC renames Interfaces.C;\n-\n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 6.0),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n-\n-   type Wind_Fill_1 is array (0 .. 16#6B#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#74# .. 16#10F#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1; -- 0x00 - 0x6b\n-      Priority        : IC.int;  -- 0x6c - 0x6f, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x70 - 0x73, base priority\n-      Fill_2          : Wind_Fill_2; -- 0x74 - 0x10f\n-      spare1          : Address;  -- 0x110 - 0x113\n-      spare2          : Address;  -- 0x114 - 0x117\n-      spare3          : Address;  -- 0x118 - 0x11b\n-      spare4          : Address;  -- 0x11c - 0x11f\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-   --  Floating point context record.  PPC version\n-\n-   FP_NUM_DREGS : constant := 32;\n-   type Fpr_Array is array (1 .. FP_NUM_DREGS) of IC.double;\n-\n-   type FP_CONTEXT is record\n-      fpr :   Fpr_Array;\n-      fpcsr : IC.int;\n-      pad :   IC.int;\n-   end record;\n-   pragma Convention (C, FP_CONTEXT);\n-\n-   Num_HW_Interrupts : constant := 256;\n-\n-   --  For VxWorks 6.0\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-\n-      td_PExcStkBase  : Address;  --  exception stack base\n-      td_PExcStkPtr   : Address;  --  exception stack pointer\n-      td_ExcStkHigh   : IC.int;   --  exception stack max usage\n-      td_ExcStkMgn    : IC.int;   --  exception stack margin\n-\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-\n-      td_PdId         : Address;  --  task's home protection domain\n-      td_name         : Address;  --  name of task\n-   end record;\n-\n-   pragma Convention (C, TASK_DESC);\n-\n-end System.VxWorks;"}, {"sha": "97cebf1202d516759a29bea9a4f6a4abc412c92f", "filename": "gcc/ada/5sintman.adb", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5sintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5sintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.21 $                            --\n+--                             $Revision$                            --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -173,13 +173,6 @@ begin\n       act.sa_mask := mask;\n \n       Keep_Unmasked (Abort_Task_Interrupt) := True;\n-      Keep_Unmasked (SIGXCPU) := True;\n-      Keep_Unmasked (SIGFPE) := True;\n-      Result :=\n-        sigaction\n-        (Signal (SIGFPE), act'Unchecked_Access,\n-         old_act'Unchecked_Access);\n-      pragma Assert (Result = 0);\n \n       --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but in the\n       --  same time, disable the ability of handling this signal\n@@ -191,17 +184,13 @@ begin\n          Keep_Unmasked (SIGINT) := True;\n       end if;\n \n-      for J in\n-        Exception_Interrupts'First + 1 .. Exception_Interrupts'Last loop\n+      for J in Exception_Interrupts'Range loop\n          Keep_Unmasked (Exception_Interrupts (J)) := True;\n-\n-         if Unreserve_All_Interrupts = 0 then\n-            Result :=\n-              sigaction\n-              (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n-               old_act'Unchecked_Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result :=\n+           sigaction\n+           (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+            old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n       end loop;\n \n       for J in Unmasked'Range loop"}, {"sha": "4dfc8ad8b222ccd0fa8dd5eebf33e9e90a9d76b3", "filename": "gcc/ada/5smastop.adb", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5smastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5smastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5smastop.adb?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "patch": "@@ -1,159 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     SYSTEM.MACHINE_STATE_OPERATIONS                      --\n---                                                                          --\n---                                 B o d y                                  --\n---            (Version using the GCC stack unwinding mechanism)             --\n---                                                                          --\n---                            $Revision: 1.3 $\n---                                                                          --\n---           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version of System.Machine_State_Operations is for use on\n---  systems where the GCC stack unwinding mechanism is supported.\n---  It is currently only used on Solaris\n-\n-package body System.Machine_State_Operations is\n-\n-   use System.Storage_Elements;\n-   use System.Exceptions;\n-\n-   ----------------------------\n-   -- Allocate_Machine_State --\n-   ----------------------------\n-\n-   function Allocate_Machine_State return Machine_State is\n-      function Machine_State_Length return Storage_Offset;\n-      pragma Import (C, Machine_State_Length, \"__gnat_machine_state_length\");\n-\n-      function Gnat_Malloc (Size : Storage_Offset) return Machine_State;\n-      pragma Import (C, Gnat_Malloc, \"__gnat_malloc\");\n-\n-   begin\n-      return Gnat_Malloc (Machine_State_Length);\n-   end Allocate_Machine_State;\n-\n-   -------------------\n-   -- Enter_Handler --\n-   -------------------\n-\n-   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n-      procedure c_enter_handler (m : Machine_State; handler : Handler_Loc);\n-      pragma Import (C, c_enter_handler, \"__gnat_enter_handler\");\n-\n-   begin\n-      c_enter_handler (M, Handler);\n-   end Enter_Handler;\n-\n-   ----------------\n-   -- Fetch_Code --\n-   ----------------\n-\n-   function Fetch_Code (Loc : Code_Loc) return Code_Loc is\n-   begin\n-      return Loc;\n-   end Fetch_Code;\n-\n-   ------------------------\n-   -- Free_Machine_State --\n-   ------------------------\n-\n-   procedure Free_Machine_State (M : in out Machine_State) is\n-      procedure Gnat_Free (M : in Machine_State);\n-      pragma Import (C, Gnat_Free, \"__gnat_free\");\n-\n-   begin\n-      Gnat_Free (M);\n-      M := Machine_State (Null_Address);\n-   end Free_Machine_State;\n-\n-   ------------------\n-   -- Get_Code_Loc --\n-   ------------------\n-\n-   function Get_Code_Loc (M : Machine_State) return Code_Loc is\n-      function c_get_code_loc (m : Machine_State) return Code_Loc;\n-      pragma Import (C, c_get_code_loc, \"__gnat_get_code_loc\");\n-\n-   begin\n-      return c_get_code_loc (M);\n-   end Get_Code_Loc;\n-\n-   --------------------------\n-   -- Machine_State_Length --\n-   --------------------------\n-\n-   function Machine_State_Length return Storage_Offset is\n-\n-      function c_machine_state_length return Storage_Offset;\n-      pragma Import (C, c_machine_state_length, \"__gnat_machine_state_length\");\n-\n-   begin\n-      return c_machine_state_length;\n-   end Machine_State_Length;\n-\n-   ---------------\n-   -- Pop_Frame --\n-   ---------------\n-\n-   procedure Pop_Frame\n-     (M    : Machine_State;\n-      Info : Subprogram_Info_Type)\n-   is\n-      procedure c_pop_frame (m : Machine_State);\n-      pragma Import (C, c_pop_frame, \"__gnat_pop_frame\");\n-\n-   begin\n-      c_pop_frame (M);\n-   end Pop_Frame;\n-\n-   -----------------------\n-   -- Set_Machine_State --\n-   -----------------------\n-\n-   procedure Set_Machine_State (M : Machine_State) is\n-      procedure c_set_machine_state (m : Machine_State);\n-      pragma Import (C, c_set_machine_state, \"__gnat_set_machine_state\");\n-\n-   begin\n-      c_set_machine_state (M);\n-      Pop_Frame (M, System.Null_Address);\n-   end Set_Machine_State;\n-\n-   ------------------------------\n-   -- Set_Signal_Machine_State --\n-   ------------------------------\n-\n-   procedure Set_Signal_Machine_State\n-     (M       : Machine_State;\n-      Context : System.Address) is\n-   begin\n-      null;\n-   end Set_Signal_Machine_State;\n-\n-end System.Machine_State_Operations;"}, {"sha": "544f96700aa53397079ae502a5c5d1fa992f40ff", "filename": "gcc/ada/5ssystem.ads", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ssystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ssystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ssystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                          (SUN Solaris Version)                           --\n --                                                                          --\n---                            $Revision: 1.14 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "a1959d4bcf5c1d8d4d062bdd0a8e095470d8c56f", "filename": "gcc/ada/5staprop.adb", "status": "modified", "additions": 190, "deletions": 181, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5staprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2001, Florida State University             --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -108,11 +107,6 @@ package body System.Task_Primitives.Operations is\n    --  Local Data  --\n    ------------------\n \n-   ATCB_Magic_Code : constant := 16#ADAADAAD#;\n-   --  This is used to allow us to catch attempts to call Self\n-   --  from outside an Ada task, with high probability.\n-   --  For an Ada task, Task_Wrapper.Magic_Number = ATCB_Magic_Code.\n-\n    --  The following are logically constants, but need to be initialized\n    --  at run time.\n \n@@ -128,8 +122,10 @@ package body System.Task_Primitives.Operations is\n    --  Key used to find the Ada Task_ID associated with a thread,\n    --  at least for C threads unknown to the Ada run-time system.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Next_Serial_Number : Task_Serial_Number := 100;\n    --  We start at 100, to reserve some special values for\n@@ -140,9 +136,6 @@ package body System.Task_Primitives.Operations is\n    --  Priority Support  --\n    ------------------------\n \n-   Dynamic_Priority_Support : constant Boolean := True;\n-   --  controls whether we poll for pending priority changes during sleeps\n-\n    Priority_Ceiling_Emulation : constant Boolean := True;\n    --  controls whether we emulate priority ceiling locking\n \n@@ -194,7 +187,7 @@ package body System.Task_Primitives.Operations is\n \n    Fake_ATCB_List : Fake_ATCB_Ptr;\n    --  A linear linked list.\n-   --  The list is protected by All_Tasks_L;\n+   --  The list is protected by Single_RTS_Lock;\n    --  Nodes are added to this list from the front.\n    --  Once a node is added to this list, it is never removed.\n \n@@ -245,20 +238,16 @@ package body System.Task_Primitives.Operations is\n \n    function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n \n-   type Ptr is access Task_ID;\n-   function To_Ptr is new Unchecked_Conversion (Interfaces.C.unsigned, Ptr);\n-   function To_Ptr is new Unchecked_Conversion (System.Address, Ptr);\n-\n-   type Iptr is access Interfaces.C.unsigned;\n-   function To_Iptr is new Unchecked_Conversion (Interfaces.C.unsigned, Iptr);\n-\n    function Thread_Body_Access is\n      new Unchecked_Conversion (System.Address, Thread_Body);\n \n    function New_Fake_ATCB (Stack_Base : Interfaces.C.unsigned) return Task_ID;\n    --  Allocate and Initialize a new ATCB. This code can safely be called from\n    --  a foreign thread, as it doesn't access implicitly or explicitly\n    --  \"self\" before having initialized the new ATCB.\n+   pragma Warnings (Off, New_Fake_ATCB);\n+   --  Disable warning on this function, since the Solaris x86 version does\n+   --  not use it.\n \n    ------------\n    -- Checks --\n@@ -309,10 +298,10 @@ package body System.Task_Primitives.Operations is\n       --  This section is ticklish.\n       --  We dare not call anything that might require an ATCB, until\n       --  we have the new ATCB in place.\n-      --  Note: we don't use \"Write_Lock (All_Tasks_L'Access);\" because\n-      --  we don't yet have an ATCB, and so can't pass the safety check.\n+      --  Note: we don't use Lock_RTS because we don't yet have an ATCB, and\n+      --  so can't pass the safety check.\n \n-      Result := mutex_lock (All_Tasks_L.L'Access);\n+      Result := mutex_lock (Single_RTS_Lock.L'Access);\n       Q := null;\n       P := Fake_ATCB_List;\n \n@@ -415,10 +404,10 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end loop;\n \n-      Result := mutex_unlock (All_Tasks_L.L'Access);\n+      Result := mutex_unlock (Single_RTS_Lock.L'Access);\n \n-      --  We cannot use \"Unlock (All_Tasks_L'Access);\" because\n-      --  we did not use Write_Lock, and so would not pass the checks.\n+      --  We cannot use Unlock_RTS because we did not use Write_Lock, and so\n+      --  would not pass the checks.\n \n       return Self_ID;\n    end New_Fake_ATCB;\n@@ -550,7 +539,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_L, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -658,24 +647,28 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Record_Lock (Lock_Ptr (L)));\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Check_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n-      Result := mutex_lock (L.L'Access);\n-      pragma Assert (Result = 0);\n-      pragma Assert (Record_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+      if not Single_Lock or else Global_Lock then\n+         pragma Assert (Check_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+         Result := mutex_lock (L.L'Access);\n+         pragma Assert (Result = 0);\n+         pragma Assert (Record_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Check_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n-      Result := mutex_lock (T.Common.LL.L.L'Access);\n-      pragma Assert (Result = 0);\n-      pragma Assert (Record_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+      if not Single_Lock then\n+         pragma Assert (Check_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+         Result := mutex_lock (T.Common.LL.L.L'Access);\n+         pragma Assert (Result = 0);\n+         pragma Assert (Record_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -693,7 +686,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result  : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Unlock (Lock_Ptr (L)));\n \n@@ -715,22 +707,24 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Check_Unlock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n-      Result := mutex_unlock (L.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         pragma Assert (Check_Unlock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+         Result := mutex_unlock (L.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Check_Unlock (To_Lock_Ptr (T.Common.LL.L'Access)));\n-      Result := mutex_unlock (T.Common.LL.L.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         pragma Assert (Check_Unlock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+         Result := mutex_unlock (T.Common.LL.L.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    --  For the time delay implementation, we need to make sure we\n@@ -899,16 +893,17 @@ package body System.Task_Primitives.Operations is\n       --  We need the above code even if we do direct fetch of Task_ID in Self\n       --  for the main task on Sun, x86 Solaris and for gcc 2.7.2.\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n-      Unlock_All_Tasks_List;\n+\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -920,13 +915,12 @@ package body System.Task_Primitives.Operations is\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n \n-   ----------------------\n-   --  Initialize_TCB  --\n-   ----------------------\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n-      Result : Interfaces.C.int;\n-\n+      Result : Interfaces.C.int := 0;\n    begin\n       --  Give the task a unique serial number.\n \n@@ -935,25 +929,28 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Next_Serial_Number /= 0);\n \n       Self_ID.Common.LL.Thread := To_thread_t (-1);\n-      Result := mutex_init\n-        (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n-      Self_ID.Common.LL.L.Level :=\n-        Private_Task_Serial_Number (Self_ID.Serial_Number);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if not Single_Lock then\n+         Result := mutex_init\n+           (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n+         Self_ID.Common.LL.L.Level :=\n+           Private_Task_Serial_Number (Self_ID.Serial_Number);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n \n       if Result = 0 then\n          Result := cond_init (Self_ID.Common.LL.CV'Access, USYNC_THREAD, 0);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n \n-         if Result /= 0 then\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         if not Single_Lock then\n             Result := mutex_destroy (Self_ID.Common.LL.L.L'Access);\n             pragma Assert (Result = 0);\n-            Succeeded := False;\n-         else\n-            Succeeded := True;\n          end if;\n \n-      else\n          Succeeded := False;\n       end if;\n    end Initialize_TCB;\n@@ -1042,8 +1039,12 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       T.Common.LL.Thread := To_thread_t (0);\n-      Result := mutex_destroy (T.Common.LL.L.L'Access);\n-      pragma Assert (Result = 0);\n+\n+      if not Single_Lock then\n+         Result := mutex_destroy (T.Common.LL.L.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n \n@@ -1083,16 +1084,15 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n    procedure Sleep\n      (Self_ID : Task_ID;\n       Reason  : Task_States)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Sleep (Reason));\n \n@@ -1104,11 +1104,17 @@ package body System.Task_Primitives.Operations is\n          Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n       end if;\n \n-      Result := cond_wait\n-        (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n-      pragma Assert (Result = 0 or else Result = EINTR);\n+      if Single_Lock then\n+         Result := cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock.L'Access);\n+      else\n+         Result := cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n+      end if;\n+\n       pragma Assert (Record_Wakeup\n         (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n+      pragma Assert (Result = 0 or else Result = EINTR);\n    end Sleep;\n \n    --  Note that we are relying heaviliy here on the GNAT feature\n@@ -1121,7 +1127,7 @@ package body System.Task_Primitives.Operations is\n    --  ???\n    --  We are taking liberties here with the semantics of the delays.\n    --  That is, we make no distinction between delays on the Calendar clock\n-   --  and delays on the Real_Time clock.  That is technically incorrect, if\n+   --  and delays on the Real_Time clock. That is technically incorrect, if\n    --  the Calendar clock happens to be reset or adjusted.\n    --  To solve this defect will require modification to the compiler\n    --  interface, so that it can pass through more information, to tell\n@@ -1157,9 +1163,9 @@ package body System.Task_Primitives.Operations is\n \n    --  Annex D requires that completion of a delay cause the task\n    --  to go to the end of its priority queue, regardless of whether\n-   --  the task actually was suspended by the delay.  Since\n+   --  the task actually was suspended by the delay. Since\n    --  cond_timedwait does not do this on Solaris, we add a call\n-   --  to thr_yield at the end.  We might do this at the beginning,\n+   --  to thr_yield at the end. We might do this at the beginning,\n    --  instead, but then the round-robin effect would not be the\n    --  same; the delayed task would be ahead of other tasks of the\n    --  same priority that awoke while it was sleeping.\n@@ -1177,29 +1183,16 @@ package body System.Task_Primitives.Operations is\n    --  For Timed_Delay, we are not expecting any cond_signals or\n    --  other interruptions, except for priority changes and aborts.\n    --  Therefore, we don't want to return unless the delay has\n-   --  actually expired, or the call has been aborted.  In this\n+   --  actually expired, or the call has been aborted. In this\n    --  case, since we want to implement the entire delay statement\n    --  semantics, we do need to check for pending abort and priority\n-   --  changes.  We can quietly handle priority changes inside the\n+   --  changes. We can quietly handle priority changes inside the\n    --  procedure, since there is no entry-queue reordering involved.\n \n    -----------------\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n-   --  Yielded should be False unles we know for certain that the\n-   --  operation resulted in the calling task going to the end of\n-   --  the dispatching queue for its priority.\n-\n-   --  ???\n-   --  This version presumes the worst, so Yielded is always False.\n-   --  On some targets, if cond_timedwait always yields, we could\n-   --  set Yielded to True just before the cond_timedwait call.\n-\n    procedure Timed_Sleep\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -1232,8 +1225,15 @@ package body System.Task_Primitives.Operations is\n               or else (Dynamic_Priority_Support and then\n                 Self_ID.Pending_Priority_Change);\n \n-            Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock.L'Access, Request'Access);\n+            else\n+               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L.L'Access, Request'Access);\n+            end if;\n+\n+            Yielded := True;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -1255,10 +1255,6 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n-\n    procedure Timed_Delay\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -1268,13 +1264,19 @@ package body System.Task_Primitives.Operations is\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : Interfaces.C.int;\n+      Yielded    : Boolean := False;\n \n    begin\n       --  Only the little window between deferring abort and\n       --  locking Self_ID is the reason we need to\n       --  check for pending abort and priority change below!\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -1299,8 +1301,15 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock.L'Access, Request'Access);\n+            else\n+               Result := cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L.L'Access, Request'Access);\n+            end if;\n+\n+            Yielded := True;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -1316,7 +1325,15 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n-      thr_yield;\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n+      if not Yielded then\n+         thr_yield;\n+      end if;\n+\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n \n@@ -1329,7 +1346,6 @@ package body System.Task_Primitives.Operations is\n       Reason : Task_States)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       pragma Assert (Check_Wakeup (T, Reason));\n       Result := cond_signal (T.Common.LL.CV'Access);\n@@ -1400,6 +1416,10 @@ package body System.Task_Primitives.Operations is\n          return False;\n       end if;\n \n+      if Single_Lock then\n+         return True;\n+      end if;\n+\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1435,6 +1455,10 @@ package body System.Task_Primitives.Operations is\n \n       L.Owner := To_Owner_ID (Self_ID);\n \n+      if Single_Lock then\n+         return True;\n+      end if;\n+\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1463,6 +1487,10 @@ package body System.Task_Primitives.Operations is\n          return False;\n       end if;\n \n+      if Single_Lock then\n+         return True;\n+      end if;\n+\n       --  Check that caller is holding own lock, on top of list\n \n       if Self_ID.Common.LL.Locks /=\n@@ -1501,6 +1529,10 @@ package body System.Task_Primitives.Operations is\n \n       L.Owner := To_Owner_ID (Self_ID);\n \n+      if Single_Lock then\n+         return True;\n+      end if;\n+\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1566,7 +1598,7 @@ package body System.Task_Primitives.Operations is\n \n       if Unlock_Count - Check_Count > 1000 then\n          Check_Count := Unlock_Count;\n-         Old_Owner := To_Task_ID (All_Tasks_L.Owner);\n+         Old_Owner   := To_Task_ID (Single_RTS_Lock.Owner);\n       end if;\n \n       --  Check that caller is abort-deferred\n@@ -1596,7 +1628,6 @@ package body System.Task_Primitives.Operations is\n \n    function Check_Finalize_Lock (L : Lock_Ptr) return Boolean is\n       Self_ID : Task_ID := Self;\n-\n    begin\n       --  Check that caller is abort-deferred\n \n@@ -1664,23 +1695,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -1717,10 +1748,10 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Initialize (Environment_Task : ST.Task_ID) is\n-      act       : aliased struct_sigaction;\n-      old_act   : aliased struct_sigaction;\n-      Tmp_Set   : aliased sigset_t;\n-      Result    : Interfaces.C.int;\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n \n       procedure Configure_Processors;\n       --  Processors configuration\n@@ -1740,71 +1771,51 @@ package body System.Task_Primitives.Operations is\n       --  _SC_NPROCESSORS_CONF, minus one.\n \n       procedure Configure_Processors is\n+         Proc_Acc  : constant GNAT.OS_Lib.String_Access :=\n+           GNAT.OS_Lib.Getenv (\"GNAT_PROCESSOR\");\n+         Proc      : aliased processorid_t;  --  User processor #\n+         Last_Proc : processorid_t;          --  Last processor #\n \n-         Proc_Acc : constant GNAT.OS_Lib.String_Access :=\n-                        GNAT.OS_Lib.Getenv (\"GNAT_PROCESSOR\");\n       begin\n          if Proc_Acc.all'Length /= 0 then\n-\n             --  Environment variable is defined\n \n-            declare\n-               Proc : aliased processorid_t;  --  User processor #\n-               Last_Proc : processorid_t;     --  Last processor #\n-\n-            begin\n-               Last_Proc := Num_Procs - 1;\n-\n-               if Last_Proc = -1 then\n+            Last_Proc := Num_Procs - 1;\n \n-                  --  Unable to read system variable _SC_NPROCESSORS_CONF\n-                  --  Ignore environment variable GNAT_PROCESSOR\n+            if Last_Proc /= -1 then\n+               Proc := processorid_t'Value (Proc_Acc.all);\n \n+               if Proc <= -2  or else Proc > Last_Proc then\n+                  --  Use the default configuration\n                   null;\n+               elsif Proc = -1 then\n+                  --  Choose a processor\n \n-               else\n-                  Proc := processorid_t'Value (Proc_Acc.all);\n-\n-                  if Proc < -2  or Proc > Last_Proc then\n-                     raise Constraint_Error;\n-\n-                  elsif Proc = -2 then\n+                  Result := 0;\n \n-                     --  Use the default configuration\n+                  while Proc < Last_Proc loop\n+                     Proc := Proc + 1;\n+                     Result := p_online (Proc, PR_STATUS);\n+                     exit when Result = PR_ONLINE;\n+                  end loop;\n \n-                     null;\n+                  pragma Assert (Result = PR_ONLINE);\n+                  Result := processor_bind (P_PID, P_MYID, Proc, null);\n+                  pragma Assert (Result = 0);\n \n-                  elsif Proc = -1 then\n-\n-                     --  Choose a processor\n-\n-                     Result := 0;\n-                     while Proc < Last_Proc loop\n-                        Proc := Proc + 1;\n-                        Result := p_online (Proc, PR_STATUS);\n-                        exit when Result = PR_ONLINE;\n-                     end loop;\n-\n-                     pragma Assert (Result = PR_ONLINE);\n-                     Result := processor_bind (P_PID, P_MYID, Proc, null);\n-                     pragma Assert (Result = 0);\n-\n-                  else\n-                     --  Use user processor\n+               else\n+                  --  Use user processor\n \n-                     Result := processor_bind (P_PID, P_MYID, Proc, null);\n-                     pragma Assert (Result = 0);\n-                  end if;\n+                  Result := processor_bind (P_PID, P_MYID, Proc, null);\n+                  pragma Assert (Result = 0);\n                end if;\n-\n-            exception\n-               when Constraint_Error =>\n-\n-                  --  Illegal environment variable GNAT_PROCESSOR - ignored\n-\n-                  null;\n-            end;\n+            end if;\n          end if;\n+\n+      exception\n+         when Constraint_Error =>\n+            --  Illegal environment variable GNAT_PROCESSOR - ignored\n+            null;\n       end Configure_Processors;\n \n    --  Start of processing for Initialize\n@@ -1821,7 +1832,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n       Enter_Task (Environment_Task);\n \n@@ -1861,7 +1872,6 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n       --  Mask Environment task for all signals. The original mask of the\n       --  Environment task will be recovered by Interrupt_Server task\n@@ -1892,12 +1902,11 @@ begin\n \n    if Dispatching_Policy = 'F' then\n       declare\n-         Result : Interfaces.C.long;\n+         Result      : Interfaces.C.long;\n          Class_Info  : aliased struct_pcinfo;\n          Secs, Nsecs : Interfaces.C.long;\n \n       begin\n-\n          --  If a pragma Time_Slice is specified, takes the value in account.\n \n          if Time_Slice_Val > 0 then\n@@ -1918,7 +1927,7 @@ begin\n \n          Class_Info.pc_clname (1) := 'R';\n          Class_Info.pc_clname (2) := 'T';\n-         Class_Info.pc_clname (3) := ASCII.Nul;\n+         Class_Info.pc_clname (3) := ASCII.NUL;\n \n          Result := priocntl (PC_VERSION, P_LWPID, P_MYID, PC_GETCID,\n            Class_Info'Address);"}, {"sha": "95c03cbec6391ee6187ab60a029752983cfce98f", "filename": "gcc/ada/5stpopse.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5stpopse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5stpopse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5stpopse.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.2 $                             --\n+--                             $Revision$\n --                                                                          --\n---            Copyright (C) 1991-1998, Florida State University             --\n+--            Copyright (C) 1992-2002, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -139,6 +139,17 @@ separate (System.Task_Primitives.Operations)\n --  been elaborated.\n \n function Self return Task_ID is\n+   ATCB_Magic_Code : constant := 16#ADAADAAD#;\n+   --  This is used to allow us to catch attempts to call Self\n+   --  from outside an Ada task, with high probability.\n+   --  For an Ada task, Task_Wrapper.Magic_Number = ATCB_Magic_Code.\n+\n+   type Iptr is access Interfaces.C.unsigned;\n+   function To_Iptr is new Unchecked_Conversion (Interfaces.C.unsigned, Iptr);\n+\n+   type Ptr is access Task_ID;\n+   function To_Ptr is new Unchecked_Conversion (Interfaces.C.unsigned, Ptr);\n+\n    X      : Ptr;\n    Result : Interfaces.C.int;\n "}, {"sha": "48330b08ec47fee2a183fa98d45e73076c196644", "filename": "gcc/ada/5svxwork.ads", "status": "modified", "additions": 10, "deletions": 57, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5svxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5svxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5svxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                             $Revision: 1.1 $                             --\n+--                             $Revision$\n --                                                                          --\n---               Copyright (C) 1998-2001 Free Software Foundation           --\n+--            Copyright (C) 1998-2002 Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,42 +29,18 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the SPARC64 VxWorks version of this package.\n+--  This is the Sparc64 VxWorks version of this package.\n \n-with Interfaces.C;\n+with Interfaces;\n \n package System.VxWorks is\n    pragma Preelaborate (System.VxWorks);\n \n-   package IC renames Interfaces.C;\n-\n-   --  Define enough of a Wind Task Control Block in order to\n-   --  obtain the inherited priority.  When porting this to\n-   --  different versions of VxWorks (this is based on 5.3[.1]),\n-   --  be sure to look at the definition for WIND_TCB located\n-   --  in $WIND_BASE/target/h/taskLib.h\n-\n-   type Wind_Fill_1 is array (0 .. 16#3F#) of IC.unsigned_char;\n-   type Wind_Fill_2 is array (16#48# .. 16#107#) of IC.unsigned_char;\n-\n-   type Wind_TCB is record\n-      Fill_1          : Wind_Fill_1; -- 0x00 - 0x3f\n-      Priority        : IC.int;  -- 0x40 - 0x43, current (inherited) priority\n-      Normal_Priority : IC.int;  -- 0x44 - 0x47, base priority\n-      Fill_2          : Wind_Fill_2; -- 0x48 - 0x107\n-      spare1          : Address;  -- 0x108 - 0x10b\n-      spare2          : Address;  -- 0x10c - 0x10f\n-      spare3          : Address;  -- 0x110 - 0x113\n-      spare4          : Address;  -- 0x114 - 0x117\n-   end record;\n-   type Wind_TCB_Ptr is access Wind_TCB;\n-\n-   --  Floating point context record.  SPARCV9 version\n+   --  Floating point context record. SPARCV9 version\n \n    FP_NUM_DREGS : constant := 32;\n \n@@ -75,37 +51,14 @@ package System.VxWorks is\n    for Fpd_Array'Alignment use 8;\n \n    type FP_CONTEXT is record\n-      fpd :   Fpd_Array;\n-      fsr :   RType;\n+      fpd : Fpd_Array;\n+      fsr : RType;\n    end record;\n \n    for FP_CONTEXT'Alignment use 8;\n    pragma Convention (C, FP_CONTEXT);\n \n-   --  Number of entries in hardware interrupt vector table.  Value of\n-   --  0 disables hardware interrupt handling until we have time to test it\n-   --  on this target.\n-   Num_HW_Interrupts : constant := 0;\n-\n-   --  VxWorks 5.3 and 5.4 version\n-   type TASK_DESC is record\n-      td_id           : IC.int;   --  task id\n-      td_name         : Address;  --  name of task\n-      td_priority     : IC.int;   --  task priority\n-      td_status       : IC.int;   --  task status\n-      td_options      : IC.int;   --  task option bits (see below)\n-      td_entry        : Address;  --  original entry point of task\n-      td_sp           : Address;  --  saved stack pointer\n-      td_pStackBase   : Address;  --  the bottom of the stack\n-      td_pStackLimit  : Address;  --  the effective end of the stack\n-      td_pStackEnd    : Address;  --  the actual end of the stack\n-      td_stackSize    : IC.int;   --  size of stack in bytes\n-      td_stackCurrent : IC.int;   --  current stack usage in bytes\n-      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n-      td_stackMargin  : IC.int;   --  current stack margin in bytes\n-      td_errorStatus  : IC.int;   --  most recent task error status\n-      td_delay        : IC.int;   --  delay/timeout ticks\n-   end record;\n-   pragma Convention (C, TASK_DESC);\n+   Num_HW_Interrupts : constant := 256;\n+   --  Number of entries in hardware interrupt vector table.\n \n end System.VxWorks;"}, {"sha": "de068af97cb91bfc27c0a31a9418f80877d1e4fa", "filename": "gcc/ada/5tosinte.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5tosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5tosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5tosinte.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---                             $Revision: 1.26 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1997-2001, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2002, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,14 +120,16 @@ package System.OS_Interface is\n    SIGFREEZE  : constant := 34; --  used by CPR (Solaris)\n    SIGTHAW    : constant := 35; --  used by CPR (Solaris)\n    SIGCANCEL  : constant := 36; --  used for thread cancel (Solaris)\n+   SIGRTMIN   : constant := 38; --  first (highest-priority) realtime signal\n+   SIGRTMAX   : constant := 45; --  last (lowest-priority) realtime signal\n \n    type Signal_Set is array (Natural range <>) of Signal;\n \n    Unmasked    : constant Signal_Set :=\n      (SIGTRAP, SIGLWP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n \n    Reserved    : constant Signal_Set :=\n-     (SIGKILL, SIGSTOP, SIGALRM, SIGVTALRM, SIGWAITING);\n+     (SIGKILL, SIGSTOP, SIGALRM, SIGVTALRM, SIGWAITING, SIGRTMAX);\n \n    type sigset_t is private;\n "}, {"sha": "5073fcaec2bceed9d6628e15a4190bdbe45919c5", "filename": "gcc/ada/5uintman.adb", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5uintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5uintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5uintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.15 $                            --\n+--                             $Revision$                            --\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--             Copyright (C) 1991-2002 Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -208,28 +208,18 @@ begin\n       for J in Exception_Interrupts'Range loop\n          Keep_Unmasked (Exception_Interrupts (J)) := True;\n \n-         if Unreserve_All_Interrupts = 0 then\n-            Result :=\n-              sigaction\n-              (Signal (Exception_Interrupts (J)),\n-               act'Unchecked_Access,\n-               old_act'Unchecked_Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result :=\n+           sigaction\n+           (Signal (Exception_Interrupts (J)),\n+            act'Unchecked_Access,\n+            old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n       end loop;\n \n       Keep_Unmasked (Abort_Task_Interrupt) := True;\n-      Keep_Unmasked (SIGBUS)  := True;\n-      Keep_Unmasked (SIGFPE) := True;\n-      Result :=\n-        sigaction\n-        (Signal (SIGFPE), act'Unchecked_Access,\n-         old_act'Unchecked_Access);\n-\n       Keep_Unmasked (SIGALRM) := True;\n       Keep_Unmasked (SIGSTOP) := True;\n       Keep_Unmasked (SIGKILL) := True;\n-      Keep_Unmasked (SIGXCPU) := True;\n \n       --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but at\n       --  the same time, disable the ability of handling this signal using"}, {"sha": "bf32f29c38378a24dd09170dcd7e9afc99fac920", "filename": "gcc/ada/5vasthan.adb", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vasthan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vasthan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vasthan.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.18 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1996-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,7 +60,6 @@ with Ada.Task_Identification;\n with Ada.Exceptions; use Ada.Exceptions;\n \n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n \n package body System.AST_Handling is\n \n@@ -162,12 +161,6 @@ package body System.AST_Handling is\n    function To_AST_Handler is new Ada.Unchecked_Conversion\n      (AST_Handler_Data_Ref, System.Aux_DEC.AST_Handler);\n \n-   function To_AST_Data_Handler_Ref is new Ada.Unchecked_Conversion\n-     (System.Aux_DEC.AST_Handler, AST_Handler_Data_Ref);\n-\n-   function To_AST_Data_Handler_Ref is new Ada.Unchecked_Conversion\n-     (AST_Handler, AST_Handler_Data_Ref);\n-\n    --  Each time Create_AST_Handler is called, a new value of this record\n    --  type is created, containing a copy of the procedure descriptor for\n    --  the routine used to handle all AST's (Process_AST), and the Task_Id\n@@ -198,9 +191,6 @@ package body System.AST_Handling is\n \n    type AST_Handler_Vector is array (Natural range <>) of AST_Handler_Data;\n    type AST_Handler_Vector_Ref is access all AST_Handler_Vector;\n-   procedure Free is new Ada.Unchecked_Deallocation\n-     (Object => AST_Handler_Vector,\n-      Name   => AST_Handler_Vector_Ref);\n \n --  type AST_Vector_Ptr is new Ada.Finalization.Controlled with record\n --  removed due to problem with controlled attribute, consequence is that\n@@ -211,9 +201,6 @@ package body System.AST_Handling is\n       Vector : AST_Handler_Vector_Ref;\n    end record;\n \n-   procedure Finalize (Object : in out AST_Vector_Ptr);\n-   --  Used to get rid of allocated AST_Vector's\n-\n    AST_Vector_Init : AST_Vector_Ptr;\n    --  Initial value, treated as constant, Vector will be null.\n \n@@ -308,9 +295,6 @@ package body System.AST_Handling is\n    type AST_Server_Task_Ptr is access all AST_Server_Task;\n    --  Type used to allocate server tasks\n \n-   function To_Integer is new Ada.Unchecked_Conversion\n-     (ATID.Task_Id, Integer);\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -532,15 +516,6 @@ package body System.AST_Handling is\n       Total_Number := AST_Service_Queue_Size;\n    end Expand_AST_Packet_Pool;\n \n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Object : in out AST_Vector_Ptr) is\n-   begin\n-      Free (Object.Vector);\n-   end Finalize;\n-\n    -----------------\n    -- Process_AST --\n    -----------------"}, {"sha": "c3fb9fe596b08924515561012c28646976aa04bb", "filename": "gcc/ada/5vinmaop.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vinmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vinmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vinmaop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.8 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---             Copyright (C) 1991-2000 Florida State University             --\n+--             Copyright (C) 1991-2001 Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,7 +57,6 @@ package body System.Interrupt_Management.Operations is\n    use type unsigned_short;\n \n    function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n-   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n    package POP renames System.Task_Primitives.Operations;\n \n    ----------------------------"}, {"sha": "798fd80473d359867864a5b5906fe5bd03d3a6d7", "filename": "gcc/ada/5vinterr.adb", "status": "modified", "additions": 51, "deletions": 169, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vinterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vinterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vinterr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -84,13 +83,8 @@ with System.Interrupt_Management.Operations;\n --           Set_Interrupt_Mask\n --           IS_Member\n --           Environment_Mask\n---           All_Tasks_Mask\n pragma Elaborate_All (System.Interrupt_Management.Operations);\n \n-with System.Error_Reporting;\n-pragma Warnings (Off, System.Error_Reporting);\n---  used for Shutdown\n-\n with System.Task_Primitives.Operations;\n --  used for Write_Lock\n --           Unlock\n@@ -125,12 +119,15 @@ with System.Tasking.Initialization;\n --  used for Defer_Abort\n --           Undefer_Abort\n \n+with System.Parameters;\n+--  used for Single_Lock\n+\n with Unchecked_Conversion;\n \n package body System.Interrupts is\n \n    use Tasking;\n-   use System.Error_Reporting;\n+   use System.Parameters;\n    use Ada.Exceptions;\n \n    package PRI renames System.Task_Primitives;\n@@ -146,11 +143,13 @@ package body System.Interrupts is\n    -- Local Tasks --\n    -----------------\n \n-   --  WARNING: System.Tasking.Utilities performs calls to this task\n+   --  WARNING: System.Tasking.Stages performs calls to this task\n    --  with low-level constructs. Do not change this spec without synchro-\n    --  nizing it.\n \n    task Interrupt_Manager is\n+      entry Detach_Interrupt_Entries (T : Task_ID);\n+\n       entry Initialize (Mask : IMNG.Interrupt_Mask);\n \n       entry Attach_Handler\n@@ -174,8 +173,6 @@ package body System.Interrupts is\n          E         : Task_Entry_Index;\n          Interrupt : Interrupt_ID);\n \n-      entry Detach_Interrupt_Entries (T : Task_ID);\n-\n       entry Block_Interrupt (Interrupt : Interrupt_ID);\n \n       entry Unblock_Interrupt (Interrupt : Interrupt_ID);\n@@ -260,109 +257,20 @@ package body System.Interrupts is\n    Access_Hold : Server_Task_Access;\n    --  variable used to allocate Server_Task using \"new\".\n \n-   L : aliased PRI.RTS_Lock;\n-   --  L protects contents in tables above corresponding to interrupts\n-   --  for which Server_ID (T) = null.\n-   --\n-   --  If Server_ID (T) /= null then protection is via\n-   --  per-task (TCB) lock of Server_ID (T).\n-   --\n-   --  For deadlock prevention, L should not be locked after\n-   --  any other lock is held.\n-\n-   Task_Lock : array (Interrupt_ID'Range) of Boolean := (others => False);\n-   --  Boolean flags to give matching Locking and Unlocking. See the comments\n-   --  in Lock_Interrupt.\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Lock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID);\n-   --  protect the tables using L or per-task lock. Set the Boolean\n-   --  value Task_Lock if the lock is made using per-task lock.\n-   --  This information is needed so that Unlock_Interrupt\n-   --  performs unlocking on the same lock. The situation we are preventing\n-   --  is, for example, when Attach_Handler is called for the first time\n-   --  we lock L and create an Server_Task. For a matching unlocking, if we\n-   --  rely on the fact that there is a Server_Task, we will unlock the\n-   --  per-task lock.\n-\n-   procedure Unlock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID);\n-\n    function Is_Registered (Handler : Parameterless_Handler) return Boolean;\n+   --  See if the Handler has been \"pragma\"ed using Interrupt_Handler.\n+   --  Always consider a null handler as registered.\n \n-   --------------------\n-   -- Lock_Interrupt --\n-   --------------------\n-\n-   --  ?????\n-   --  This package has been modified several times.\n-   --  Do we still need this fancy locking scheme, now that more operations\n-   --  are entries of the interrupt manager task?\n-   --  ?????\n-   --  More likely, we will need to convert one or more entry calls to\n-   --  protected operations, because presently we are violating locking order\n-   --  rules by calling a task entry from within the runtime system.\n-\n-   procedure Lock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID)\n-   is\n-   begin\n-      Initialization.Defer_Abort (Self_ID);\n-\n-      POP.Write_Lock (L'Access);\n-\n-      if Task_Lock (Interrupt) then\n-\n-         --  We need to use per-task lock.\n-\n-         POP.Unlock (L'Access);\n-         POP.Write_Lock (Server_ID (Interrupt));\n-\n-         --  Rely on the fact that once Server_ID is set to a non-null\n-         --  value it will never be set back to null.\n-\n-      elsif Server_ID (Interrupt) /= Null_Task then\n-\n-         --  We need to use per-task lock.\n-\n-         Task_Lock (Interrupt) := True;\n-         POP.Unlock (L'Access);\n-         POP.Write_Lock (Server_ID (Interrupt));\n-      end if;\n-   end Lock_Interrupt;\n-\n-   ----------------------\n-   -- Unlock_Interrupt --\n-   ----------------------\n-\n-   procedure Unlock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID)\n-   is\n-   begin\n-      if Task_Lock (Interrupt) then\n-         POP.Unlock (Server_ID (Interrupt));\n-      else\n-         POP.Unlock (L'Access);\n-      end if;\n-\n-      Initialization.Undefer_Abort (Self_ID);\n-   end Unlock_Interrupt;\n-\n-   ----------------------------------\n-   --  Register_Interrupt_Handler  --\n-   ----------------------------------\n+   --------------------------------\n+   -- Register_Interrupt_Handler --\n+   --------------------------------\n \n    procedure Register_Interrupt_Handler (Handler_Addr : System.Address) is\n       New_Node_Ptr : R_Link;\n-\n    begin\n       --  This routine registers the Handler as usable for Dynamic\n       --  Interrupt Handler. Routines attaching and detaching Handler\n@@ -393,11 +301,7 @@ package body System.Interrupts is\n    -- Is_Registered --\n    -------------------\n \n-   --  See if the Handler has been \"pragma\"ed using Interrupt_Handler.\n-   --  Always consider a null handler as registered.\n-\n    function Is_Registered (Handler : Parameterless_Handler) return Boolean is\n-\n       type Fat_Ptr is record\n          Object_Addr  : System.Address;\n          Handler_Addr : System.Address;\n@@ -529,8 +433,7 @@ package body System.Interrupts is\n    procedure Attach_Handler\n      (New_Handler : in Parameterless_Handler;\n       Interrupt   : in Interrupt_ID;\n-      Static      : in Boolean := False)\n-   is\n+      Static      : in Boolean := False) is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n@@ -557,8 +460,7 @@ package body System.Interrupts is\n      (Old_Handler : out Parameterless_Handler;\n       New_Handler : in Parameterless_Handler;\n       Interrupt   : in Interrupt_ID;\n-      Static      : in Boolean := False)\n-   is\n+      Static      : in Boolean := False) is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n@@ -583,16 +485,14 @@ package body System.Interrupts is\n \n    procedure Detach_Handler\n      (Interrupt : in Interrupt_ID;\n-      Static    : in Boolean := False)\n-   is\n+      Static    : in Boolean := False) is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n            Interrupt_ID'Image (Interrupt) & \" is reserved\");\n       end if;\n \n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n-\n    end Detach_Handler;\n \n    ---------------\n@@ -623,7 +523,7 @@ package body System.Interrupts is\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n-      Interrupt   : constant Interrupt_ID :=\n+      Interrupt : constant Interrupt_ID :=\n         Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n \n    begin\n@@ -678,9 +578,7 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By\n-     (Interrupt : Interrupt_ID)\n-      return      System.Tasking.Task_ID\n-   is\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_ID is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n@@ -724,9 +622,9 @@ package body System.Interrupts is\n \n    task body Interrupt_Manager is\n \n-      ----------------------\n-      --  Local Variables --\n-      ----------------------\n+      ---------------------\n+      -- Local Variables --\n+      ---------------------\n \n       Intwait_Mask  : aliased IMNG.Interrupt_Mask;\n       Ret_Interrupt : Interrupt_ID;\n@@ -757,15 +655,12 @@ package body System.Interrupts is\n          New_Handler : in  Parameterless_Handler;\n          Interrupt   : in  Interrupt_ID;\n          Static      : in  Boolean;\n-         Restoration : in  Boolean := False)\n-      is\n+         Restoration : in  Boolean := False) is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n-\n             --  In case we have an Interrupt Entry already installed.\n             --  raise a program error. (propagate it to the caller).\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"An interrupt is already installed\");\n          end if;\n@@ -778,7 +673,6 @@ package body System.Interrupts is\n          --  may be detaching a static handler to restore a dynamic one.\n \n          if not Restoration and then not Static\n-\n             --  Tries to overwrite a static Interrupt Handler with a\n             --  dynamic Handler\n \n@@ -789,7 +683,6 @@ package body System.Interrupts is\n \n                         or else not Is_Registered (New_Handler))\n          then\n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"Trying to overwrite a static Interrupt Handler with a \" &\n               \"dynamic Handler\");\n@@ -842,11 +735,9 @@ package body System.Interrupts is\n \n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n-\n             --  In case we have an Interrupt Entry installed.\n             --  raise a program error. (propagate it to the caller).\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"An interrupt entry is already installed\");\n          end if;\n@@ -856,11 +747,9 @@ package body System.Interrupts is\n          --  status of the current_Handler.\n \n          if not Static and then User_Handler (Interrupt).Static then\n-\n             --  Tries to detach a static Interrupt Handler.\n             --  raise a program error.\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"Trying to detach a static Interrupt Handler\");\n          end if;\n@@ -933,7 +822,6 @@ package body System.Interrupts is\n \n          declare\n             Old_Handler : Parameterless_Handler;\n-\n          begin\n             select\n \n@@ -943,10 +831,8 @@ package body System.Interrupts is\n                 Static      : in Boolean;\n                 Restoration : in Boolean := False)\n             do\n-               Lock_Interrupt (Self_ID, Interrupt);\n                Unprotected_Exchange_Handler\n                  (Old_Handler, New_Handler, Interrupt, Static, Restoration);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n             end Attach_Handler;\n \n             or accept Exchange_Handler\n@@ -955,35 +841,28 @@ package body System.Interrupts is\n                 Interrupt   : in Interrupt_ID;\n                 Static      : in Boolean)\n             do\n-               Lock_Interrupt (Self_ID, Interrupt);\n                Unprotected_Exchange_Handler\n                  (Old_Handler, New_Handler, Interrupt, Static);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n             end Exchange_Handler;\n \n             or accept Detach_Handler\n                (Interrupt   : in Interrupt_ID;\n                 Static      : in Boolean)\n             do\n-               Lock_Interrupt (Self_ID, Interrupt);\n                Unprotected_Detach_Handler (Interrupt, Static);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n             end Detach_Handler;\n \n             or accept Bind_Interrupt_To_Entry\n               (T       : Task_ID;\n                E       : Task_Entry_Index;\n                Interrupt : Interrupt_ID)\n             do\n-               Lock_Interrupt (Self_ID, Interrupt);\n-\n                --  if there is a binding already (either a procedure or an\n                --  entry), raise Program_Error (propagate it to the caller).\n \n                if User_Handler (Interrupt).H /= null\n                  or else User_Entry (Interrupt).T /= Null_Task\n                then\n-                  Unlock_Interrupt (Self_ID, Interrupt);\n                   Raise_Exception (Program_Error'Identity,\n                     \"A binding for this interrupt is already present\");\n                end if;\n@@ -1014,16 +893,12 @@ package body System.Interrupts is\n                   POP.Wakeup (Server_ID (Interrupt),\n                               Interrupt_Server_Idle_Sleep);\n                end if;\n-\n-               Unlock_Interrupt (Self_ID, Interrupt);\n             end Bind_Interrupt_To_Entry;\n \n             or accept Detach_Interrupt_Entries (T : Task_ID)\n             do\n                for I in Interrupt_ID'Range loop\n                   if not Is_Reserved (I) then\n-                     Lock_Interrupt (Self_ID, I);\n-\n                      if User_Entry (I).T = T then\n \n                         --  The interrupt should no longer be ignored if\n@@ -1034,8 +909,6 @@ package body System.Interrupts is\n                           (T => Null_Task, E => Null_Task_Entry);\n                         IMOP.Interrupt_Self_Process (IMNG.Interrupt_ID (I));\n                      end if;\n-\n-                     Unlock_Interrupt (Self_ID, I);\n                   end if;\n                end loop;\n \n@@ -1063,23 +936,17 @@ package body System.Interrupts is\n             end select;\n \n          exception\n-\n             --  If there is a program error we just want to propagate it\n             --  to the caller and do not want to stop this task.\n \n             when Program_Error =>\n                null;\n \n             when others =>\n-               pragma Assert\n-                 (Shutdown (\"Interrupt_Manager---exception not expected\"));\n+               pragma Assert (False);\n                null;\n          end;\n-\n       end loop;\n-\n-      pragma Assert (Shutdown (\"Interrupt_Manager---should not get here\"));\n-\n    end Interrupt_Manager;\n \n    -----------------\n@@ -1131,6 +998,10 @@ package body System.Interrupts is\n          --  from status change (Unblocked -> Blocked). If that is not\n          --  the case, we should exceute the attached Procedure or Entry.\n \n+         if Single_Lock then\n+            POP.Lock_RTS;\n+         end if;\n+\n          POP.Write_Lock (Self_ID);\n \n          if User_Handler (Interrupt).H = null\n@@ -1144,7 +1015,6 @@ package body System.Interrupts is\n             Self_ID.Common.State := Runnable;\n \n          else\n-\n             Self_ID.Common.State := Interrupt_Server_Blocked_On_Event_Flag;\n             Ret_Interrupt := IMOP.Interrupt_Wait (Intwait_Mask'Access);\n             Self_ID.Common.State := Runnable;\n@@ -1160,9 +1030,17 @@ package body System.Interrupts is\n \n                   POP.Unlock (Self_ID);\n \n+                  if Single_Lock then\n+                     POP.Unlock_RTS;\n+                  end if;\n+\n                   Tmp_Handler.all;\n                   POP.Write_Lock (Self_ID);\n \n+                  if Single_Lock then\n+                     POP.Lock_RTS;\n+                  end if;\n+\n                elsif User_Entry (Interrupt).T /= Null_Task then\n                   Tmp_ID := User_Entry (Interrupt).T;\n                   Tmp_Entry_Index := User_Entry (Interrupt).E;\n@@ -1171,22 +1049,33 @@ package body System.Interrupts is\n \n                   POP.Unlock (Self_ID);\n \n+                  if Single_Lock then\n+                     POP.Unlock_RTS;\n+                  end if;\n+\n                   System.Tasking.Rendezvous.Call_Simple\n                     (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n \n                   POP.Write_Lock (Self_ID);\n+\n+                  if Single_Lock then\n+                     POP.Lock_RTS;\n+                  end if;\n                end if;\n             end if;\n          end if;\n \n          POP.Unlock (Self_ID);\n+\n+         if Single_Lock then\n+            POP.Unlock_RTS;\n+         end if;\n+\n          System.Tasking.Initialization.Undefer_Abort (Self_ID);\n \n          --  Undefer abort here to allow a window for this task\n          --  to be aborted  at the time of system shutdown.\n       end loop;\n-\n-      pragma Assert (Shutdown (\"Server_Task---should not get here\"));\n    end Server_Task;\n \n    -------------------------------------\n@@ -1239,8 +1128,7 @@ package body System.Interrupts is\n \n    procedure Install_Handlers\n      (Object       : access Static_Interrupt_Protection;\n-      New_Handlers : in New_Handler_Array)\n-   is\n+      New_Handlers : in New_Handler_Array) is\n    begin\n       for N in New_Handlers'Range loop\n \n@@ -1268,12 +1156,6 @@ begin\n \n    Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n \n-   --  Initialize the lock L.\n-\n-   Initialization.Defer_Abort (Self);\n-   POP.Initialize_Lock (L'Access, POP.ATCB_Level);\n-   Initialization.Undefer_Abort (Self);\n-\n    --  During the elaboration of this package body we want RTS to\n    --  inherit the interrupt mask from the Environment Task.\n "}, {"sha": "fd9e774bd6fa240a53f6c84b516b6b0f2af57700", "filename": "gcc/ada/5vintman.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.6 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---           Copyright (C) 1991-2000, Florida State University              --\n+--           Copyright (C) 1991-2001, Florida State University              --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,8 +50,6 @@ package body System.Interrupt_Management is\n    use System.OS_Interface;\n    use type unsigned_long;\n \n-   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n-\n    ---------------------------\n    -- Initialize_Interrupts --\n    ---------------------------"}, {"sha": "e2eec9e3de23d2249b4d867b74c3cd40ef16636f", "filename": "gcc/ada/5vmastop.adb", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vmastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vmastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vmastop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 B o d y                                  --\n --                         (Version for Alpha/VMS)                          --\n --                                                                          --\n---                            $Revision: 1.3 $\n+--                            $Revision$\n --                                                                          --\n---              Copyright (C) 2001 Ada Core Technologies, Inc.              --\n+--          Copyright (C) 2001-2002 Ada Core Technologies, Inc.             --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,13 +65,6 @@ package body System.Machine_State_Operations is\n    end record;\n    for ICB_Fflags_Bits_Type'Size use 24;\n \n-   ICB_Fflags_Bits_Type_Init : constant ICB_Fflags_Bits_Type :=\n-     (ExceptIon_Frame    => False,\n-      Ast_Frame          => False,\n-      Bottom_Of_STACK    => False,\n-      Base_Frame         => False,\n-      Filler_1           => 0);\n-\n    type ICB_Hdr_Quad_Type is record\n       Context_Length : Unsigned_Longword;\n       Fflags_Bits    : ICB_Fflags_Bits_Type;\n@@ -85,11 +78,6 @@ package body System.Machine_State_Operations is\n    end record;\n    for ICB_Hdr_Quad_Type'Size use 64;\n \n-   ICB_Hdr_Quad_Type_Init : constant ICB_Hdr_Quad_Type :=\n-     (Context_Length => 0,\n-      Fflags_Bits    => ICB_Fflags_Bits_Type_Init,\n-      Block_Version  => 0);\n-\n    type Invo_Context_Blk_Type is record\n       --\n       --  The first quadword contains:\n@@ -150,16 +138,6 @@ package body System.Machine_State_Operations is\n    end record;\n    for Invo_Context_Blk_Type'Size use 4352;\n \n-   Invo_Context_Blk_Type_Init : constant Invo_Context_Blk_Type :=\n-     (Hdr_Quad             => ICB_Hdr_Quad_Type_Init,\n-      Procedure_Descriptor => (0, 0),\n-      Program_Counter      => 0,\n-      Processor_Status     => 0,\n-      Ireg                 => (others => (0, 0)),\n-      Freg                 => (others => (0, 0)),\n-      System_Defined       => (others => (0, 0)),\n-      Filler_1             => (others => ASCII.NUL));\n-\n    subtype Invo_Handle_Type is Unsigned_Longword;\n \n    type Invo_Handle_Access_Type is access all Invo_Handle_Type;\n@@ -172,9 +150,6 @@ package body System.Machine_State_Operations is\n    function To_Machine_State is new Unchecked_Conversion\n      (System.Address, Machine_State);\n \n-   function To_Code_Loc is new Unchecked_Conversion\n-     (Unsigned_Longword, Code_Loc);\n-\n    ----------------------------\n    -- Allocate_Machine_State --\n    ----------------------------\n@@ -244,11 +219,8 @@ package body System.Machine_State_Operations is\n    ------------------------\n \n    procedure Free_Machine_State (M : in out Machine_State) is\n-      procedure Gnat_Free (M : in Invo_Handle_Access_Type);\n-      pragma Import (C, Gnat_Free, \"__gnat_free\");\n-\n    begin\n-      Gnat_Free (To_Invo_Handle_Access (M));\n+      Memory.Free (Address (M));\n       M := Machine_State (Null_Address);\n    end Free_Machine_State;\n "}, {"sha": "e0a6cc61f96ff02a4bdd4597a1944210b5f109d8", "filename": "gcc/ada/5vparame.ads", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vparame.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.23 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -133,4 +133,59 @@ pragma Pure (Parameters);\n    Garbage_Collected : constant Boolean := False;\n    --  The storage mode for this system (release on program exit)\n \n+   ---------------------\n+   -- Tasking Profile --\n+   ---------------------\n+\n+   --  In the following sections, constant parameters are defined to\n+   --  allow some optimizations within the tasking run time based on\n+   --  restrictions on the tasking features.\n+\n+   ----------------------\n+   -- Locking Strategy --\n+   ----------------------\n+\n+   Single_Lock : constant Boolean := True;\n+   --  Indicates whether a single lock should be used within the tasking\n+   --  run-time to protect internal structures. If True, a single lock\n+   --  will be used, meaning less locking/unlocking operations, but also\n+   --  more global contention. In general, Single_Lock should be set to\n+   --  True on single processor machines, and to False to multi-processor\n+   --  systems, but this can vary from application to application and also\n+   --  depends on the scheduling policy.\n+\n+   -------------------\n+   -- Task Abortion --\n+   -------------------\n+\n+   No_Abort : constant Boolean := False;\n+   --  This constant indicates whether abort statements and asynchronous\n+   --  transfer of control (ATC) are disallowed. If set to True, it is\n+   --  assumed that neither construct is used, and the run time does not\n+   --  need to defer/undefer abort and check for pending actions at\n+   --  completion points. A value of True for No_Abort corresponds to:\n+   --  pragma Restrictions (No_Abort_Statements);\n+   --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n+\n+   ----------------------\n+   -- Dynamic Priority --\n+   ----------------------\n+\n+   Dynamic_Priority_Support : constant Boolean := True;\n+   --  This constant indicates whether dynamic changes of task priorities\n+   --  are allowed (True means normal RM mode in which such changes are\n+   --  allowed). In particular, if this is False, then we do not need to\n+   --  poll for pending base priority changes at every abort completion\n+   --  point. A value of False for Dynamic_Priority_Support corresponds\n+   --  to pragma Restrictions (No_Dynamic_Priorities);\n+\n+   --------------------\n+   -- Runtime Traces --\n+   --------------------\n+\n+   Runtime_Traces : constant Boolean := False;\n+   --  This constant indicates whether the runtime outputs traces to a\n+   --  predefined output or not (True means that traces are output).\n+   --  See System.Traces for more details.\n+\n end System.Parameters;"}, {"sha": "724669637722a1891349b38747499a897b4b3f00", "filename": "gcc/ada/5vsystem.ads", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                       (OpenVMS DEC Threads Version)                      --\n --                                                                          --\n---                            $Revision: 1.25 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := False;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;"}, {"sha": "afe39b643e5df4eee379a3c340a22579700a07cd", "filename": "gcc/ada/5vtaprop.adb", "status": "modified", "additions": 138, "deletions": 126, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -94,8 +93,10 @@ package body System.Task_Primitives.Operations is\n    ATCB_Key : aliased pthread_key_t;\n    --  Key used to find the Ada Task_ID associated with a thread\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -170,7 +171,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -244,15 +245,13 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L.L'Access);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : access RTS_Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n@@ -289,20 +288,24 @@ package body System.Task_Primitives.Operations is\n --      Set_Priority (Self_ID, System.Any_Priority (L.Prio));\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -320,40 +323,47 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_unlock (L.L'Access);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason  : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n+\n       --  EINTR is not considered a failure.\n       pragma Assert (Result = 0 or else Result = EINTR);\n \n@@ -369,10 +379,6 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n    procedure Timed_Sleep\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n@@ -392,7 +398,7 @@ package body System.Task_Primitives.Operations is\n       Sleep_Time := To_OS_Time (Time, Mode);\n \n       if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-           or else Self_ID.Pending_Priority_Change\n+        or else Self_ID.Pending_Priority_Change\n       then\n          return;\n       end if;\n@@ -407,50 +413,55 @@ package body System.Task_Primitives.Operations is\n          raise Storage_Error;\n       end if;\n \n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n+\n+      Yielded := True;\n \n       if not Self_ID.Common.LL.AST_Pending then\n          Timedout := True;\n       else\n          Sys_Cantim (Status, To_Address (Self_ID), 0);\n          pragma Assert ((Status and 1) = 1);\n       end if;\n-\n    end Timed_Sleep;\n \n    -----------------\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n-\n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes)\n+     (Self_ID : Task_ID;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes)\n    is\n       Sleep_Time : OS_Time;\n       Result     : Interfaces.C.int;\n       Status     : Cond_Value_Type;\n+      Yielded    : Boolean := False;\n \n    begin\n-\n       --  Only the little window between deferring abort and\n       --  locking Self_ID is the reason we need to\n-      --  check for pending abort and priority change below! :(\n+      --  check for pending abort and priority change below!\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n \n       SSL.Abort_Defer.all;\n       Write_Lock (Self_ID);\n \n-      if not (Time = 0.0 and then Mode = Relative) then\n-\n+      if Time /= 0.0 or else Mode /= Relative then\n          Sleep_Time := To_OS_Time (Time, Mode);\n \n          if Mode = Relative or else OS_Clock < Sleep_Time then\n-\n             Self_ID.Common.State := Delay_Sleep;\n             Self_ID.Common.LL.AST_Pending := True;\n \n@@ -475,20 +486,33 @@ package body System.Task_Primitives.Operations is\n                   exit;\n                end if;\n \n-               Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-                 Self_ID.Common.LL.L'Access);\n+               if Single_Lock then\n+                  Result := pthread_cond_wait\n+                    (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+               else\n+                  Result := pthread_cond_wait\n+                    (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+               end if;\n+\n+               Yielded := True;\n \n                exit when not Self_ID.Common.LL.AST_Pending;\n-\n             end loop;\n \n             Self_ID.Common.State := Runnable;\n-\n          end if;\n       end if;\n \n       Unlock (Self_ID);\n-      Result := sched_yield;\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n+      if not Yielded then\n+         Result := sched_yield;\n+      end if;\n+\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n \n@@ -514,7 +538,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -526,7 +549,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Yield (Do_Yield : Boolean := True) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if Do_Yield then\n          Result := sched_yield;\n@@ -538,15 +560,15 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T : Task_ID;\n-      Prio : System.Any_Priority;\n+     (T                   : Task_ID;\n+      Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n-      Result     : Interfaces.C.int;\n-      Param      : aliased struct_sched_param;\n+      Result : Interfaces.C.int;\n+      Param  : aliased struct_sched_param;\n    begin\n       T.Common.Current_Priority := Prio;\n-      Param.sched_priority  := Interfaces.C.int (Underlying_Priorities (Prio));\n+      Param.sched_priority := Interfaces.C.int (Underlying_Priorities (Prio));\n \n       if Time_Slice_Val > 0 then\n          Result := pthread_setschedparam\n@@ -579,7 +601,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Enter_Task (Self_ID : Task_ID) is\n       Result  : Interfaces.C.int;\n-\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n \n@@ -591,15 +612,17 @@ package body System.Task_Primitives.Operations is\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n       pragma Assert (Result = 0);\n \n-      Lock_All_Tasks_List;\n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      Lock_RTS;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n-      Unlock_All_Tasks_List;\n+\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -621,53 +644,34 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr    : aliased pthread_condattr_t;\n \n    begin\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n+      if not Single_Lock then\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n \n---      Don't use, see comment in s-osinte.ads about ERRORCHECK mutexes.\n---      Result := pthread_mutexattr_settype_np\n---        (Mutex_Attr'Access, PTHREAD_MUTEX_ERRORCHECK_NP);\n---      pragma Assert (Result = 0);\n-\n---      Result := pthread_mutexattr_setprotocol\n---        (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n---      pragma Assert (Result = 0);\n-\n---      Result := pthread_mutexattr_setprioceiling\n---        (Mutex_Attr'Access, Interfaces.C.int (System.Any_Priority'Last));\n---      pragma Assert (Result = 0);\n+         if Result = 0 then\n+            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n \n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n       end if;\n \n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n          Self_ID.Common.LL.Exc_Stack_Ptr := new Exc_Stack_T;\n@@ -676,8 +680,11 @@ package body System.Task_Primitives.Operations is\n             Self_ID.Common.LL.Exc_Stack_Ptr (Exc_Stack_T'Last)'Address);\n \n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -777,13 +784,18 @@ package body System.Task_Primitives.Operations is\n        (Exc_Stack_T, Exc_Stack_Ptr_T);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n+\n       if T.Known_Tasks_Index /= -1 then\n          Known_Tasks (T.Known_Tasks_Index) := null;\n       end if;\n+\n       Free (T.Common.LL.Exc_Stack_Ptr);\n       Free (Tmp);\n    end Finalize_TCB;\n@@ -851,23 +863,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -899,7 +911,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       Environment_Task_ID := Environment_Task;\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n       Enter_Task (Environment_Task);"}, {"sha": "902a598f246edd13a4f7122ec6f8f64ee9894206", "filename": "gcc/ada/5vtpopde.adb", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vtpopde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5vtpopde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtpopde.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -2,14 +2,13 @@\n --                                                                          --\n --                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n --                                                                          --\n---    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S     --\n---                                 . D E C                                  --\n+--                   SYSTEM.TASK_PRIMITIVES.OPERATIONS.DEC                  --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $                             --\n+--                             $Revision$\n --                                                                          --\n---              Copyright (C) 2000 Free Software Foundation, Inc.           --\n+--           Copyright (C) 2000-2001 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,28 +33,29 @@\n -- State University (http://www.gnat.com).                                  --\n --                                                                          --\n ------------------------------------------------------------------------------\n+\n --   This package is for OpenVMS/Alpha\n---\n+\n with System.OS_Interface;\n with System.Tasking;\n with Unchecked_Conversion;\n+\n package body System.Task_Primitives.Operations.DEC is\n \n    use System.OS_Interface;\n    use System.Tasking;\n    use System.Aux_DEC;\n    use type Interfaces.C.int;\n \n-   --  The FAB_RAB_Type specifieds where the context field (the calling\n+   --  The FAB_RAB_Type specifies where the context field (the calling\n    --  task) is stored.  Other fields defined for FAB_RAB aren't need and\n    --  so are ignored.\n-   type FAB_RAB_Type is\n-   record\n+\n+   type FAB_RAB_Type is record\n       CTX : Unsigned_Longword;\n    end record;\n \n-   for FAB_RAB_Type use\n-   record\n+   for FAB_RAB_Type use record\n       CTX at 24 range 0 .. 31;\n    end record;\n \n@@ -81,8 +81,9 @@ package body System.Task_Primitives.Operations.DEC is\n    ---------------------------\n \n    procedure Interrupt_AST_Handler (ID : Address) is\n-      Result     : Interfaces.C.int;\n-      AST_Self_ID    : Task_ID := To_Task_Id (ID);\n+      Result      : Interfaces.C.int;\n+      AST_Self_ID : Task_ID := To_Task_Id (ID);\n+\n    begin\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -93,8 +94,9 @@ package body System.Task_Primitives.Operations.DEC is\n    ---------------------\n \n    procedure RMS_AST_Handler (ID : Address) is\n-      AST_Self_ID    : Task_ID := To_Task_Id (To_FAB_RAB (ID).CTX);\n-      Result     : Interfaces.C.int;\n+      AST_Self_ID : Task_ID := To_Task_Id (To_FAB_RAB (ID).CTX);\n+      Result      : Interfaces.C.int;\n+\n    begin\n       AST_Self_ID.Common.LL.AST_Pending := False;\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n@@ -107,6 +109,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    function Self return Unsigned_Longword is\n       Self_ID : Task_ID := Self;\n+\n    begin\n       Self_ID.Common.LL.AST_Pending := True;\n       return To_Unsigned_Longword (Self);\n@@ -117,8 +120,9 @@ package body System.Task_Primitives.Operations.DEC is\n    -------------------------\n \n    procedure Starlet_AST_Handler (ID : Address) is\n-      Result     : Interfaces.C.int;\n-      AST_Self_ID    : Task_ID := To_Task_Id (ID);\n+      Result      : Interfaces.C.int;\n+      AST_Self_ID : Task_ID := To_Task_Id (ID);\n+\n    begin\n       AST_Self_ID.Common.LL.AST_Pending := False;\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n@@ -131,12 +135,15 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Task_Synch is\n       Synch_Self_ID : Task_ID := Self;\n+\n    begin\n       Write_Lock (Synch_Self_ID);\n       Synch_Self_ID.Common.State := AST_Server_Sleep;\n+\n       while Synch_Self_ID.Common.LL.AST_Pending loop\n          Sleep (Synch_Self_ID, AST_Server_Sleep);\n       end loop;\n+\n       Synch_Self_ID.Common.State := Runnable;\n       Unlock (Synch_Self_ID);\n    end Task_Synch;"}, {"sha": "76ce6f00adccd7100b13d66b6b7c02e2ebc31a2f", "filename": "gcc/ada/5wmemory.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wmemory.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wmemory.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wmemory.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.2 $\n+--                            $Revision$\n --                                                                          --\n --             Copyright (C) 2001 Free Software Foundation, Inc.            --\n --                                                                          --\n@@ -214,7 +214,7 @@ package body System.Memory is\n       Result := c_realloc (Ptr, Actual_Size);\n \n       if Result /= System.Null_Address then\n-         Available_Memory := Available_Memory + Old_Size - msize (Ptr);\n+         Available_Memory := Available_Memory + Old_Size - msize (Result);\n       end if;\n \n       Unlock_Task.all;"}, {"sha": "de471a8a45672e9fef222eabf0403e0f3b3585f3", "filename": "gcc/ada/5wsystem.ads", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -7,9 +7,9 @@\n --                                 S p e c                                  --\n --                               (NT Version)                               --\n --                                                                          --\n---                            $Revision: 1.19 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -92,27 +92,14 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority : constant Positive := 30;\n-\n+   Max_Priority           : constant Positive := 30;\n    Max_Interrupt_Priority : constant Positive := 31;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n \n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n-\n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 15;\n \n private\n \n@@ -130,8 +117,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := True;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := True;\n@@ -198,4 +188,11 @@ private\n \n       Interrupt_Priority         => 15);\n \n+   pragma Linker_Options (\"-Wl,--stack=0x2000000\");\n+   --  This is used to change the default stack (32 MB) size for non tasking\n+   --  programs. We change this value for GNAT on Windows here because the\n+   --  binutils on this platform have switched to a too low value for Ada\n+   --  programs. Note that we also set the stack size for tasking programs in\n+   --  System.Task_Primitives.Operations.\n+\n end System;"}, {"sha": "4f37526bef7f08fbb7bbb46edc96753d14ad5dde", "filename": "gcc/ada/5wtaprop.adb", "status": "modified", "additions": 90, "deletions": 52, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5wtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wtaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -91,7 +90,10 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n \n-   pragma Linker_Options (\"-Xlinker --stack=0x800000,0x1000\");\n+   pragma Link_With (\"-Xlinker --stack=0x800000,0x1000\");\n+   --  Change the stack size (8 MB) for tasking programs on Windows. This\n+   --  permit to have more than 30 tasks running at the same time. Note that\n+   --  we set the stack size for non tasking programs on System unit.\n \n    package SSL renames System.Soft_Links;\n \n@@ -102,8 +104,10 @@ package body System.Task_Primitives.Operations is\n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -133,7 +137,7 @@ package body System.Task_Primitives.Operations is\n \n    Fake_ATCB_List : Fake_ATCB_Ptr;\n    --  A linear linked list.\n-   --  The list is protected by All_Tasks_L;\n+   --  The list is protected by Single_RTS_Lock;\n    --  Nodes are added to this list from the front.\n    --  Once a node is added to this list, it is never removed.\n \n@@ -184,7 +188,7 @@ package body System.Task_Primitives.Operations is\n       --  We dare not call anything that might require an ATCB, until\n       --  we have the new ATCB in place.\n \n-      Write_Lock (All_Tasks_L'Access);\n+      Lock_RTS;\n       Q := null;\n       P := Fake_ATCB_List;\n \n@@ -263,7 +267,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Must not unlock until Next_ATCB is again allocated.\n \n-      Unlock (All_Tasks_L'Access);\n+      Unlock_RTS;\n       return Self_ID;\n    end New_Fake_ATCB;\n \n@@ -475,7 +479,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --  initialized in Initialize_TCB and the Storage_Error is handled.\n-   --  Other mutexes (such as All_Tasks_Lock, Memory_Lock...) used in\n+   --  Other mutexes (such as RTS_Lock, Memory_Lock...) used in\n    --  the RTS is initialized before any status change of RTS.\n    --  Therefore raising Storage_Error in the following routines\n    --  should be able to be handled safely.\n@@ -526,15 +530,20 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False) is\n    begin\n-      EnterCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      if not Single_Lock or else Global_Lock then\n+         EnterCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n    begin\n-      EnterCriticalSection\n-        (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+      if not Single_Lock then\n+         EnterCriticalSection\n+           (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -555,15 +564,19 @@ package body System.Task_Primitives.Operations is\n       LeaveCriticalSection (L.Mutex'Access);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n    begin\n-      LeaveCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      if not Single_Lock or else Global_Lock then\n+         LeaveCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n    begin\n-      LeaveCriticalSection\n-        (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+      if not Single_Lock then\n+         LeaveCriticalSection\n+           (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+      end if;\n    end Unlock;\n \n    -----------\n@@ -576,7 +589,11 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Self_ID = Self);\n \n-      Cond_Wait (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Cond_Wait (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Cond_Wait (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n \n       if Self_ID.Deferral_Level = 0\n         and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n@@ -611,7 +628,7 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       Timedout := True;\n-      Yielded := False;\n+      Yielded  := False;\n \n       if Mode = Relative then\n          Rel_Time := Time;\n@@ -626,8 +643,13 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Rel_Time, Local_Timedout, Result);\n+            if Single_Lock then\n+               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Rel_Time, Local_Timedout, Result);\n+            else\n+               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Rel_Time, Local_Timedout, Result);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -660,9 +682,14 @@ package body System.Task_Primitives.Operations is\n    begin\n       --  Only the little window between deferring abort and\n       --  locking Self_ID is the reason we need to\n-      --  check for pending abort and priority change below! :(\n+      --  check for pending abort and priority change below!\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -685,8 +712,13 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Rel_Time, Timedout, Result);\n+            if Single_Lock then\n+               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Rel_Time, Timedout, Result);\n+            else\n+               Cond_Timed_Wait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Rel_Time, Timedout, Result);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -697,6 +729,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -834,7 +871,7 @@ package body System.Task_Primitives.Operations is\n \n       Self_ID.Common.LL.Thread_Id := GetCurrentThreadId;\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n       for J in Known_Tasks'Range loop\n          if Known_Tasks (J) = null then\n@@ -844,7 +881,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -856,14 +893,18 @@ package body System.Task_Primitives.Operations is\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n \n-   ----------------------\n-   --  Initialize_TCB  --\n-   ----------------------\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n    begin\n       Initialize_Cond (Self_ID.Common.LL.CV'Access);\n-      Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+\n+      if not Single_Lock then\n+         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+      end if;\n+\n       Succeeded := True;\n    end Initialize_TCB;\n \n@@ -880,12 +921,6 @@ package body System.Task_Primitives.Operations is\n    is\n       hTask          : HANDLE;\n       TaskId         : aliased DWORD;\n-\n-      --  ??? The fact that we can't use PVOID because the compiler\n-      --  gives a \"PVOID is not visible\" error is a GNAT bug.\n-      --  The strange thing is that the file compiles fine during a regular\n-      --  build.\n-\n       pTaskParameter : System.OS_Interface.PVOID;\n       dwStackSize    : DWORD;\n       Result         : DWORD;\n@@ -952,7 +987,10 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Finalize_Lock (T.Common.LL.L'Access);\n+      if not Single_Lock then\n+         Finalize_Lock (T.Common.LL.L'Access);\n+      end if;\n+\n       Finalize_Cond (T.Common.LL.CV'Access);\n \n       if T.Known_Tasks_Index /= -1 then\n@@ -997,23 +1035,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ----------------\n    -- Initialize --\n@@ -1033,7 +1071,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n       Environment_Task.Common.LL.Thread := GetCurrentThread;\n       Enter_Task (Environment_Task);"}, {"sha": "466b142660eda91936392430945735851be4022b", "filename": "gcc/ada/5ysystem.ads", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ysystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ysystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ysystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -5,11 +5,11 @@\n --                               S Y S T E M                                --\n --                                                                          --\n --                                 S p e c                                  --\n---                      (VXWORKS Version PPC, Sparc64)                      --\n+--                          (VXWORKS Version PPC)                           --\n --                                                                          --\n---                            $Revision: 1.6 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n \n    --  Address comparison\n \n@@ -88,40 +88,26 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   --  256 is reserved for the VxWorks kernel\n-   --  248 - 255 correspond to hardware interrupt levels 0 .. 7\n-   --  247 is a catchall default \"interrupt\" priority for signals, allowing\n-   --  higher priority than normal tasks, but lower than hardware\n-   --  priority levels.  Protected Object ceilings can override\n-   --  these values\n-   --  246 is used by the Interrupt_Manager task\n+   --  256        is reserved for the VxWorks kernel\n+   --  248 - 255  correspond to hardware interrupt levels 0 .. 7\n+   --  247        is a catchall default \"interrupt\" priority for signals,\n+   --             allowing higher priority than normal tasks, but lower than\n+   --             hardware priority levels.  Protected Object ceilings can\n+   --             override these values.\n+   --  246        is used by the Interrupt_Manager task\n \n+   Max_Priority           : constant Positive := 245;\n    Max_Interrupt_Priority : constant Positive := 255;\n \n-   Max_Priority : constant Positive := 245;\n+   subtype Any_Priority       is Integer      range   0 .. 255;\n+   subtype Priority           is Any_Priority range   0 .. 245;\n+   subtype Interrupt_Priority is Any_Priority range 246 .. 255;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n-\n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n-\n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 122;\n \n private\n \n@@ -139,8 +125,11 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := False;\n    Denorm                    : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n    Frontend_Layout           : constant Boolean := False;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Long_Shifts_Inlined       : constant Boolean := False;"}, {"sha": "dccc143a6c6aab9879dc6727422a87cecb3ae1ef", "filename": "gcc/ada/5zinterr.adb", "status": "modified", "additions": 121, "deletions": 648, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zinterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zinterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zinterr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -46,13 +45,6 @@\n --  hardware interrupts, which may be masked or unmasked using routined\n --  interfaced to the relevant VxWorks system calls.\n \n---  Note : Direct calls to sigaction, sigprocmask, pthread_sigsetmask or any\n---  other low-level interface that changes the signal action or\n---  signal mask needs careful consideration.\n---  One may achieve the effect of system calls first masking RTS blocked\n---  (by calling Block_Interrupt) for the signal under consideration.\n---  This will make all the tasks in RTS blocked for the signal.\n-\n --  Once we associate a Signal_Server_Task with an signal, the task never\n --  goes away, and we never remove the association. On the other hand, it\n --  is more convenient to terminate an associated Interrupt_Server_Task\n@@ -72,15 +64,13 @@\n --  service requests are ensured via user calls to the Interrupt_Manager\n --  entries.\n \n---  This is the VxWorks version of this package, supporting both signals\n---  and vectored hardware interrupts.\n+--  This is the VxWorks version of this package, supporting vectored hardware\n+--  interrupts.\n \n with Unchecked_Conversion;\n \n with System.OS_Interface; use System.OS_Interface;\n \n-with System.VxWorks;\n-\n with Interfaces.VxWorks;\n \n with Ada.Task_Identification;\n@@ -89,39 +79,6 @@ with Ada.Task_Identification;\n with Ada.Exceptions;\n --  used for Raise_Exception\n \n-with System.Task_Primitives;\n---  used for RTS_Lock\n---           Self\n-\n-with System.Interrupt_Management;\n---  used for Reserve\n---           Interrupt_ID\n---           Interrupt_Mask\n---           Abort_Task_Interrupt\n-\n-with System.Interrupt_Management.Operations;\n---  used for Thread_Block_Interrupt\n---           Thread_Unblock_Interrupt\n---           Install_Default_Action\n---           Install_Ignore_Action\n---           Copy_Interrupt_Mask\n---           Set_Interrupt_Mask\n---           Empty_Interrupt_Mask\n---           Fill_Interrupt_Mask\n---           Add_To_Interrupt_Mask\n---           Delete_From_Interrupt_Mask\n---           Interrupt_Wait\n---           Interrupt_Self_Process\n---           Get_Interrupt_Mask\n---           Set_Interrupt_Mask\n---           IS_Member\n---           Environment_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n-with System.Error_Reporting;\n---  used for Shutdown\n-\n with System.Task_Primitives.Operations;\n --  used for Write_Lock\n --           Unlock\n@@ -130,9 +87,6 @@ with System.Task_Primitives.Operations;\n --           Sleep\n --           Initialize_Lock\n \n-with System.Task_Primitives.Interrupt_Operations;\n---  used for Set_Interrupt_ID\n-\n with System.Storage_Elements;\n --  used for To_Address\n --           To_Integer\n@@ -152,21 +106,13 @@ with System.Tasking.Rendezvous;\n --  used for Call_Simple\n pragma Elaborate_All (System.Tasking.Rendezvous);\n \n-with System.Tasking.Initialization;\n---  used for Defer_Abort\n---           Undefer_Abort\n-\n package body System.Interrupts is\n \n    use Tasking;\n-   use System.Error_Reporting;\n    use Ada.Exceptions;\n \n    package PRI renames System.Task_Primitives;\n    package POP renames System.Task_Primitives.Operations;\n-   package PIO renames System.Task_Primitives.Interrupt_Operations;\n-   package IMNG renames System.Interrupt_Management;\n-   package IMOP renames System.Interrupt_Management.Operations;\n \n    function To_Ada is new Unchecked_Conversion\n      (System.Tasking.Task_ID, Ada.Task_Identification.Task_Id);\n@@ -178,12 +124,12 @@ package body System.Interrupts is\n    -- Local Tasks --\n    -----------------\n \n-   --  WARNING: System.Tasking.Utilities performs calls to this task\n+   --  WARNING: System.Tasking.Stages performs calls to this task\n    --  with low-level constructs. Do not change this spec without synchro-\n    --  nizing it.\n \n    task Interrupt_Manager is\n-      entry Initialize (Mask : IMNG.Interrupt_Mask);\n+      entry Detach_Interrupt_Entries (T : Task_ID);\n \n       entry Attach_Handler\n         (New_Handler : Parameterless_Handler;\n@@ -206,18 +152,9 @@ package body System.Interrupts is\n          E         : Task_Entry_Index;\n          Interrupt : Interrupt_ID);\n \n-      entry Detach_Interrupt_Entries (T : Task_ID);\n-\n       pragma Interrupt_Priority (System.Interrupt_Priority'First);\n    end Interrupt_Manager;\n \n-   task type Signal_Server_Task (Interrupt : Interrupt_ID) is\n-      pragma Interrupt_Priority (System.Interrupt_Priority'First + 1);\n-   end Signal_Server_Task;\n-   --  Server task for signal handling\n-\n-   type Signal_Task_Access is access Signal_Server_Task;\n-\n    task type Interrupt_Server_Task\n      (Interrupt : Interrupt_ID; Int_Sema : SEM_ID) is\n       --  Server task for vectored hardware interrupt handling\n@@ -275,33 +212,16 @@ package body System.Interrupts is\n    --  is needed to determine whether to create a new Server_Task.\n \n    Semaphore_ID_Map : array\n-     (Interrupt_ID range 0 .. System.VxWorks.Num_HW_Interrupts) of SEM_ID :=\n-        (others => 0);\n+     (Interrupt_ID range 0 .. System.OS_Interface.Max_HW_Interrupt)\n+      of SEM_ID := (others => 0);\n    --  Array of binary semaphores associated with vectored interrupts\n    --  Note that the last bound should be Max_HW_Interrupt, but this will raise\n    --  Storage_Error if Num_HW_Interrupts is null, so use an extra 4 bytes\n    --  instead.\n \n-   Signal_Access_Hold : Signal_Task_Access;\n-   --  Variable for allocating a Signal_Server_Task\n-\n    Interrupt_Access_Hold : Interrupt_Task_Access;\n    --  Variable for allocating an Interrupt_Server_Task\n \n-   L : aliased PRI.RTS_Lock;\n-   --  L protects the contents of the above tables for interrupts / signals\n-   --  for which Server_ID (I) = Null_Task.\n-   --\n-   --  If Server_ID (I) /= Null_Task then protection is via the\n-   --  per-task (TCB) lock of Server_ID (I).\n-   --\n-   --  For deadlock prevention, L should not be locked after\n-   --  any other lock is held, hence we use PO_Level which is the highest\n-   --  lock level for error checking.\n-\n-   Task_Lock : array (Interrupt_ID) of Boolean := (others => False);\n-   --  Booleans indicating whether the per task lock is used\n-\n    Default_Handler : array (HW_Interrupt) of Interfaces.VxWorks.VOIDFUNCPTR;\n    --  Vectored interrupt handlers installed prior to program startup.\n    --  These are saved only when the umbrella handler is installed for\n@@ -319,25 +239,9 @@ package body System.Interrupts is\n    --  Unbind the handlers for hardware interrupt server tasks at program\n    --  termination.\n \n-   procedure Lock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID);\n-   --  Protect the tables using L or the per-task lock. Set the Boolean\n-   --  value Task_Lock if the lock is made using per-task lock.\n-   --  This information is needed so that Unlock_Interrupt\n-   --  performs unlocking on the same lock. The situation we are preventing\n-   --  is, for example, when Attach_Handler is called for the first time\n-   --  we lock L and create an Server_Task. For a matching unlocking, if we\n-   --  rely on the fact that there is a Server_Task, we will unlock the\n-   --  per-task lock.\n-\n-   procedure Unlock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID);\n-   --  Unlock interrupt previously locked by Lock_Interrupt\n-\n    function Is_Registered (Handler : Parameterless_Handler) return Boolean;\n-   --  Needs comment ???\n+   --  See if Handler has been \"pragma\"ed using Interrupt_Handler.\n+   --  Always consider a null handler as registered.\n \n    procedure Notify_Interrupt (Param : System.Address);\n    --  Umbrella handler for vectored interrupts (not signals)\n@@ -351,9 +255,6 @@ package body System.Interrupts is\n    --  Install the runtime umbrella handler for a vectored hardware\n    --  interrupt\n \n-   function To_Signal (S : Interrupt_ID) return IMNG.Interrupt_ID;\n-   --  Convert interrupt ID to signal number.\n-\n    procedure Unimplemented (Feature : String);\n    pragma No_Return (Unimplemented);\n    --  Used to mark a call to an unimplemented function. Raises Program_Error\n@@ -374,8 +275,7 @@ package body System.Interrupts is\n    procedure Attach_Handler\n      (New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False)\n-   is\n+      Static      : Boolean := False) is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Attach_Handler (New_Handler, Interrupt, Static);\n@@ -395,7 +295,7 @@ package body System.Interrupts is\n       Int_Ref : System.Address)\n    is\n       Interrupt : constant Interrupt_ID :=\n-                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+        Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n \n    begin\n       Check_Reserved_Interrupt (Interrupt);\n@@ -431,9 +331,7 @@ package body System.Interrupts is\n    ---------------------\n \n    function Current_Handler\n-     (Interrupt : Interrupt_ID)\n-      return      Parameterless_Handler\n-   is\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n \n@@ -457,8 +355,7 @@ package body System.Interrupts is\n \n    procedure Detach_Handler\n      (Interrupt : Interrupt_ID;\n-      Static    : Boolean := False)\n-   is\n+      Static    : Boolean := False) is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n@@ -489,8 +386,7 @@ package body System.Interrupts is\n      (Old_Handler : out Parameterless_Handler;\n       New_Handler : Parameterless_Handler;\n       Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False)\n-   is\n+      Static      : Boolean := False) is\n    begin\n       Check_Reserved_Interrupt (Interrupt);\n       Interrupt_Manager.Exchange_Handler\n@@ -525,10 +421,9 @@ package body System.Interrupts is\n    -- Finalize_Interrupt_Servers --\n    --------------------------------\n \n-   --  Restore default handlers for interrupt servers.  Signal servers\n-   --  restore the default handlers when they're aborted.  This is called\n-   --  by the Interrupt_Manager task when it receives the abort signal\n-   --  during program finalization.\n+   --  Restore default handlers for interrupt servers.\n+   --  This is called by the Interrupt_Manager task when it receives the abort\n+   --  signal during program finalization.\n \n    procedure Finalize_Interrupt_Servers is\n    begin\n@@ -554,17 +449,13 @@ package body System.Interrupts is\n    -------------------------------------\n \n    function Has_Interrupt_Or_Attach_Handler\n-     (Object : access Dynamic_Interrupt_Protection)\n-      return   Boolean\n-   is\n+     (Object : access Dynamic_Interrupt_Protection) return Boolean is\n    begin\n       return True;\n    end Has_Interrupt_Or_Attach_Handler;\n \n    function Has_Interrupt_Or_Attach_Handler\n-     (Object : access Static_Interrupt_Protection)\n-      return   Boolean\n-   is\n+     (Object : access Static_Interrupt_Protection) return Boolean is\n    begin\n       return True;\n    end Has_Interrupt_Or_Attach_Handler;\n@@ -628,12 +519,11 @@ package body System.Interrupts is\n    is\n       use Interfaces.VxWorks;\n \n-      Vec         : constant Interrupt_Vector :=\n-                      INUM_TO_IVEC (Interfaces.VxWorks.int (Interrupt));\n+      Vec  : constant Interrupt_Vector :=\n+        INUM_TO_IVEC (Interfaces.VxWorks.int (Interrupt));\n       Old_Handler : constant VOIDFUNCPTR :=\n-                      intVecGet\n-                        (INUM_TO_IVEC (Interfaces.VxWorks.int (Interrupt)));\n-      Stat        : Interfaces.VxWorks.STATUS;\n+        intVecGet (INUM_TO_IVEC (Interfaces.VxWorks.int (Interrupt)));\n+      Stat : Interfaces.VxWorks.STATUS;\n \n    begin\n       --  Only install umbrella handler when no Ada handler has already been\n@@ -692,9 +582,6 @@ package body System.Interrupts is\n    -- Is_Registered --\n    -------------------\n \n-   --  See if Handler has been \"pragma\"ed using Interrupt_Handler.\n-   --  Always consider a null handler as registered.\n-\n    function Is_Registered (Handler : Parameterless_Handler) return Boolean is\n       type Fat_Ptr is record\n          Object_Addr  : System.Address;\n@@ -725,7 +612,6 @@ package body System.Interrupts is\n       end loop;\n \n       return False;\n-\n    end Is_Registered;\n \n    -----------------\n@@ -734,63 +620,12 @@ package body System.Interrupts is\n \n    function Is_Reserved (Interrupt : Interrupt_ID) return Boolean is\n    begin\n-      if Interrupt < System.VxWorks.Num_HW_Interrupts then\n-         return False;\n-      else\n-         return IMNG.Reserve (To_Signal (Interrupt));\n-      end if;\n+      return False;\n    end Is_Reserved;\n \n-   --------------------\n-   -- Lock_Interrupt --\n-   --------------------\n-\n-   --  ?????\n-   --  This package has been modified several times.\n-   --  Do we still need this fancy locking scheme, now that more operations\n-   --  are entries of the interrupt manager task?\n-   --  ?????\n-   --  More likely, we will need to convert one or more entry calls to\n-   --  protected operations, because presently we are violating locking order\n-   --  rules by calling a task entry from within the runtime system.\n-\n-   procedure Lock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID) is\n-   begin\n-      Initialization.Defer_Abort (Self_ID);\n-\n-      POP.Write_Lock (L'Access);\n-\n-      if Task_Lock (Interrupt) then\n-         pragma Assert (Server_ID (Interrupt) /= null,\n-                        \"Task_Lock is true for null server task\");\n-         pragma Assert\n-           (not Ada.Task_Identification.Is_Terminated\n-            (To_Ada (Server_ID (Interrupt))),\n-            \"Attempt to lock per task lock of terminated server: \" &\n-            \"Task_Lock => True\");\n-\n-         POP.Unlock (L'Access);\n-         POP.Write_Lock (Server_ID (Interrupt));\n-\n-      elsif Server_ID (Interrupt) /= Null_Task then\n-         pragma Assert\n-           (not Ada.Task_Identification.Is_Terminated\n-            (To_Ada (Server_ID (Interrupt))),\n-            \"Attempt to lock per task lock of terminated server: \" &\n-            \"Task_Lock => False\");\n-\n-         Task_Lock (Interrupt) := True;\n-         POP.Unlock (L'Access);\n-         POP.Write_Lock (Server_ID (Interrupt));\n-      end if;\n-\n-   end Lock_Interrupt;\n-\n-   ------------------------\n-   --  Notify_Interrupt  --\n-   ------------------------\n+   ----------------------\n+   -- Notify_Interrupt --\n+   ----------------------\n \n    --  Umbrella handler for vectored hardware interrupts (as opposed to\n    --  signals and exceptions).  As opposed to the signal implementation,\n@@ -859,15 +694,6 @@ package body System.Interrupts is\n       end if;\n    end Register_Interrupt_Handler;\n \n-   ---------------\n-   -- To_Signal --\n-   ---------------\n-\n-   function To_Signal (S : Interrupt_ID) return IMNG.Interrupt_ID is\n-   begin\n-      return IMNG.Interrupt_ID (S - System.VxWorks.Num_HW_Interrupts);\n-   end To_Signal;\n-\n    -----------------------\n    -- Unblock_Interrupt --\n    -----------------------\n@@ -908,28 +734,6 @@ package body System.Interrupts is\n          Feature & \" not implemented on VxWorks\");\n    end Unimplemented;\n \n-   ----------------------\n-   -- Unlock_Interrupt --\n-   ----------------------\n-\n-   procedure Unlock_Interrupt\n-     (Self_ID   : Task_ID;\n-      Interrupt : Interrupt_ID) is\n-   begin\n-      if Task_Lock (Interrupt) then\n-         pragma Assert\n-           (not Ada.Task_Identification.Is_Terminated\n-            (To_Ada (Server_ID (Interrupt))),\n-            \"Attempt to unlock per task lock of terminated server\");\n-\n-         POP.Unlock (Server_ID (Interrupt));\n-      else\n-         POP.Unlock (L'Access);\n-      end if;\n-\n-      Initialization.Undefer_Abort (Self_ID);\n-   end Unlock_Interrupt;\n-\n    -----------------------\n    -- Interrupt_Manager --\n    -----------------------\n@@ -939,9 +743,7 @@ package body System.Interrupts is\n       -- Local Variables --\n       ---------------------\n \n-      Intwait_Mask : aliased IMNG.Interrupt_Mask;\n-      Old_Mask     : aliased IMNG.Interrupt_Mask;\n-      Self_ID      : Task_ID := POP.Self;\n+      Self_Id : constant Task_ID := POP.Self;\n \n       --------------------\n       -- Local Routines --\n@@ -957,10 +759,6 @@ package body System.Interrupts is\n       --  Otherwise, we have to interrupt Server_Task for status change\n       --  through an abort signal.\n \n-      --  The following two procedures are labelled Unprotected... in order to\n-      --  indicate that Lock/Unlock_Interrupt operations are needed around\n-      --  around calls to them.\n-\n       procedure Unprotected_Exchange_Handler\n         (Old_Handler : out Parameterless_Handler;\n          New_Handler : Parameterless_Handler;\n@@ -978,24 +776,8 @@ package body System.Interrupts is\n \n       procedure Bind_Handler (Interrupt : Interrupt_ID) is\n       begin\n-         if Interrupt < System.VxWorks.Num_HW_Interrupts then\n-            Install_Umbrella_Handler\n-              (HW_Interrupt (Interrupt), Notify_Interrupt'Access);\n-\n-         else\n-            --  Mask this task for the given signal so that all tasks\n-            --  are masked for the signal and the actual delivery of the\n-            --  signal will be caught using \"sigwait\" by the\n-            --  corresponding Server_Task.\n-\n-            IMOP.Thread_Block_Interrupt (To_Signal (Interrupt));\n-            --  We have installed a handler or an entry before we called\n-            --  this procedure. If the handler task is waiting to be\n-            --  awakened, do it here. Otherwise, the signal will be\n-            --  discarded.\n-\n-            POP.Wakeup (Server_ID (Interrupt), Interrupt_Server_Idle_Sleep);\n-         end if;\n+         Install_Umbrella_Handler\n+           (HW_Interrupt (Interrupt), Notify_Interrupt'Access);\n       end Bind_Handler;\n \n       --------------------\n@@ -1004,44 +786,17 @@ package body System.Interrupts is\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n          S : STATUS;\n-         Ret_Interrupt : IMNG.Interrupt_ID;\n-\n-         use type IMNG.Interrupt_ID;\n          use type STATUS;\n \n       begin\n-         if Interrupt < System.VxWorks.Num_HW_Interrupts then\n-\n-            --  Hardware interrupt\n+         --  Hardware interrupt\n \n-            Install_Default_Action (HW_Interrupt (Interrupt));\n-\n-            --  Flush server task off semaphore, allowing it to terminate\n-\n-            S := semFlush (Semaphore_ID_Map (Interrupt));\n-            pragma Assert (S = 0);\n-\n-         else\n-            --  Currently, there is a handler or an entry attached and\n-            --  the corresponding Server_Task is waiting on \"sigwait.\"\n-            --  We have to wake up the Server_Task and make it\n-            --  wait on a condition variable by sending an\n-            --  Abort_Task_Interrupt\n+         Install_Default_Action (HW_Interrupt (Interrupt));\n \n-            --  Make sure corresponding Server_Task is out of its own\n-            --  sigwait state.\n+         --  Flush server task off semaphore, allowing it to terminate\n \n-            POP.Abort_Task (Server_ID (Interrupt));\n-            Ret_Interrupt := IMOP.Interrupt_Wait (Intwait_Mask'Access);\n-            pragma Assert (Ret_Interrupt = IMNG.Abort_Task_Interrupt);\n-\n-            IMOP.Install_Default_Action (To_Signal (Interrupt));\n-\n-            --  Unmake the Interrupt for this task in order to allow default\n-            --  action again.\n-\n-            IMOP.Thread_Unblock_Interrupt (To_Signal (Interrupt));\n-         end if;\n+         S := semFlush (Semaphore_ID_Map (Interrupt));\n+         pragma Assert (S = 0);\n       end Unbind_Handler;\n \n       --------------------------------\n@@ -1055,11 +810,9 @@ package body System.Interrupts is\n          Old_Handler : Parameterless_Handler;\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n-\n             --  If an interrupt entry is installed raise\n             --  Program_Error. (propagate it to the caller).\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"An interrupt entry is already installed\");\n          end if;\n@@ -1069,11 +822,9 @@ package body System.Interrupts is\n          --  status of the Current_Handler.\n \n          if not Static and then User_Handler (Interrupt).Static then\n-\n             --  Trying to detach a static Interrupt Handler.\n             --  raise Program_Error.\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception (Program_Error'Identity,\n               \"Trying to detach a static Interrupt Handler\");\n          end if;\n@@ -1088,7 +839,6 @@ package body System.Interrupts is\n          if Old_Handler /= null then\n             Unbind_Handler (Interrupt);\n          end if;\n-\n       end Unprotected_Detach_Handler;\n \n       ----------------------------------\n@@ -1103,13 +853,12 @@ package body System.Interrupts is\n          Restoration : Boolean := False) is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n-\n             --  If an interrupt entry is already installed, raise\n             --  Program_Error. (propagate it to the caller).\n \n-            Unlock_Interrupt (Self_ID, Interrupt);\n-            Raise_Exception (Program_Error'Identity,\n-              \"An interrupt is already installed\");\n+            Raise_Exception\n+              (Program_Error'Identity,\n+               \"An interrupt is already installed\");\n          end if;\n \n          --  Note : A null handler with Static = True will\n@@ -1122,15 +871,14 @@ package body System.Interrupts is\n          if not Restoration and then not Static\n            and then (User_Handler (Interrupt).Static\n \n-                     --  Trying to overwrite a static Interrupt Handler with a\n-                     --  dynamic Handler\n+            --  Trying to overwrite a static Interrupt Handler with a\n+            --  dynamic Handler\n \n-                     --  The new handler is not specified as an\n-                     --  Interrupt Handler by a pragma.\n+            --  The new handler is not specified as an\n+            --  Interrupt Handler by a pragma.\n \n-                     or else not Is_Registered (New_Handler))\n+           or else not Is_Registered (New_Handler))\n          then\n-            Unlock_Interrupt (Self_ID, Interrupt);\n             Raise_Exception\n               (Program_Error'Identity,\n                \"Trying to overwrite a static Interrupt Handler with a \" &\n@@ -1165,46 +913,23 @@ package body System.Interrupts is\n                 Ada.Task_Identification.Is_Terminated\n                   (To_Ada (Server_ID (Interrupt))))\n          then\n-            --  When a new Server_Task is created, it should have its\n-            --  signal mask set to the All_Tasks_Mask.\n-\n-            IMOP.Set_Interrupt_Mask\n-              (IMOP.All_Tasks_Mask'Access, Old_Mask'Access);\n-\n-            if Interrupt < System.VxWorks.Num_HW_Interrupts then\n-\n-               --  Vectored hardware interrupt\n-\n-               Interrupt_Access_Hold :=\n-                 new Interrupt_Server_Task\n-                   (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n-               Server_ID (Interrupt) :=\n-                 To_System (Interrupt_Access_Hold.all'Identity);\n-\n-            else\n-               --  Signal\n-\n-               Signal_Access_Hold := new Signal_Server_Task (Interrupt);\n-               Server_ID (Interrupt) :=\n-                 To_System (Signal_Access_Hold.all'Identity);\n-            end if;\n-\n-            IMOP.Set_Interrupt_Mask (Old_Mask'Access);\n+            Interrupt_Access_Hold :=\n+              new Interrupt_Server_Task\n+                (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+            Server_ID (Interrupt) :=\n+              To_System (Interrupt_Access_Hold.all'Identity);\n          end if;\n \n          if (New_Handler = null) and then Old_Handler /= null then\n-\n             --  Restore default handler\n \n             Unbind_Handler (Interrupt);\n \n          elsif Old_Handler = null then\n-\n             --  Save default handler\n \n             Bind_Handler (Interrupt);\n          end if;\n-\n       end Unprotected_Exchange_Handler;\n \n       --  Start of processing for Interrupt_Manager\n@@ -1215,56 +940,6 @@ package body System.Interrupts is\n \n       System.Tasking.Utilities.Make_Independent;\n \n-      --  Environment task gets its own interrupt mask, saves it,\n-      --  and then masks all signals except the Keep_Unmasked set.\n-\n-      --  During rendezvous, the Interrupt_Manager receives the old\n-      --  signal mask of the environment task, and sets its own\n-      --  signal mask to that value.\n-\n-      --  The environment task will call this entry of Interrupt_Manager\n-      --  during elaboration of the body of this package.\n-\n-      accept Initialize (Mask : IMNG.Interrupt_Mask) do\n-         declare\n-            The_Mask : aliased IMNG.Interrupt_Mask;\n-\n-         begin\n-            IMOP.Copy_Interrupt_Mask (The_Mask, Mask);\n-            IMOP.Set_Interrupt_Mask (The_Mask'Access);\n-         end;\n-      end Initialize;\n-\n-      --  Note: All tasks in RTS will have all reserved signals\n-      --  being masked (except the Interrupt_Manager) and Keep_Unmasked\n-      --  signals unmasked when created.\n-\n-      --  Abort_Task_Interrupt is one of the signals unmasked\n-      --  in all tasks. We mask the signal in this particular task\n-      --  so that \"sigwait\" is can catch an explicit\n-      --  Abort_Task_Interrupt from a Server_Task.\n-\n-      --  This sigwaiting is needed to ensure that a Signal_Server_Task is\n-      --  out of its own sigwait state. This extra synchronization is\n-      --  necessary to prevent following scenarios:\n-\n-      --   1) Interrupt_Manager sends an Abort_Task_Interrupt to a\n-      --      Signal_Server_Task then changes its own signal mask (OS level).\n-      --      If a signal (corresponding to the Signal_Server_Task) arrives\n-      --      in the meantime, we have the Interrupt_Manager umnasked and\n-      --      the Signal_Server_Task waiting on sigwait.\n-\n-      --   2) For unbinding a handler, we install a default action in the\n-      --      Interrupt_Manager. POSIX.1c states that the result of using\n-      --      \"sigwait\" and \"sigaction\" simultaneously on the same signal\n-      --      is undefined. Therefore, we need to be informed from the\n-      --      Signal_Server_Task that it is out of its sigwait stage.\n-\n-      IMOP.Empty_Interrupt_Mask (Intwait_Mask'Access);\n-      IMOP.Add_To_Interrupt_Mask\n-        (Intwait_Mask'Access, IMNG.Abort_Task_Interrupt);\n-      IMOP.Thread_Block_Interrupt (IMNG.Abort_Task_Interrupt);\n-\n       loop\n          --  A block is needed to absorb Program_Error exception\n \n@@ -1273,300 +948,123 @@ package body System.Interrupts is\n \n          begin\n             select\n-\n                accept Attach_Handler\n                  (New_Handler : Parameterless_Handler;\n                   Interrupt   : Interrupt_ID;\n                   Static      : Boolean;\n                   Restoration : Boolean := False)\n                do\n-                  Lock_Interrupt (Self_ID, Interrupt);\n                   Unprotected_Exchange_Handler\n                     (Old_Handler, New_Handler, Interrupt, Static, Restoration);\n-                  Unlock_Interrupt (Self_ID, Interrupt);\n                end Attach_Handler;\n \n-            or accept Exchange_Handler\n-              (Old_Handler : out Parameterless_Handler;\n-               New_Handler : Parameterless_Handler;\n-               Interrupt   : Interrupt_ID;\n-               Static      : Boolean)\n-            do\n-               Lock_Interrupt (Self_ID, Interrupt);\n-               Unprotected_Exchange_Handler\n-                 (Old_Handler, New_Handler, Interrupt, Static);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n-            end Exchange_Handler;\n-\n-            or accept Detach_Handler\n-               (Interrupt   : Interrupt_ID;\n-                Static      : Boolean)\n-            do\n-               Lock_Interrupt (Self_ID, Interrupt);\n-               Unprotected_Detach_Handler (Interrupt, Static);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n-            end Detach_Handler;\n-\n-            or accept Bind_Interrupt_To_Entry\n-              (T       : Task_ID;\n-               E       : Task_Entry_Index;\n-               Interrupt : Interrupt_ID)\n-            do\n-               Lock_Interrupt (Self_ID, Interrupt);\n-\n-               --  If there is a binding already (either a procedure or an\n-               --  entry), raise Program_Error (propagate it to the caller).\n-\n-               if User_Handler (Interrupt).H /= null\n-                 or else User_Entry (Interrupt).T /= Null_Task\n-               then\n-                  Unlock_Interrupt (Self_ID, Interrupt);\n-                  Raise_Exception\n-                    (Program_Error'Identity,\n-                     \"A binding for this interrupt is already present\");\n-               end if;\n-\n-               User_Entry (Interrupt) := Entry_Assoc' (T => T, E => E);\n-\n-               --  Indicate the attachment of interrupt entry in the ATCB.\n-               --  This is needed  so when an interrupt entry task terminates\n-               --  the binding can be cleaned. The call to unbinding must be\n-               --  make by the task before it terminates.\n-\n-               T.Interrupt_Entry := True;\n-\n-               --  Invoke a corresponding Server_Task if not yet created.\n-               --  Place Task_ID info in Server_ID array.\n-\n-               if Server_ID (Interrupt) = Null_Task or else\n-                 Ada.Task_Identification.Is_Terminated\n-                 (To_Ada (Server_ID (Interrupt))) then\n-\n-                  --  When a new Server_Task is created, it should have its\n-                  --  signal mask set to the All_Tasks_Mask.\n-\n-                  IMOP.Set_Interrupt_Mask\n-                    (IMOP.All_Tasks_Mask'Access, Old_Mask'Access);\n-\n-                  if Interrupt < System.VxWorks.Num_HW_Interrupts then\n-                     Interrupt_Access_Hold := new Interrupt_Server_Task\n-                       (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n-                     Server_ID (Interrupt) :=\n-                       To_System (Interrupt_Access_Hold.all'Identity);\n+            or\n+               accept Exchange_Handler\n+                 (Old_Handler : out Parameterless_Handler;\n+                  New_Handler : Parameterless_Handler;\n+                  Interrupt   : Interrupt_ID;\n+                  Static      : Boolean)\n+               do\n+                  Unprotected_Exchange_Handler\n+                    (Old_Handler, New_Handler, Interrupt, Static);\n+               end Exchange_Handler;\n \n-                  else\n-                     Signal_Access_Hold := new Signal_Server_Task (Interrupt);\n-                     Server_ID (Interrupt) :=\n-                       To_System (Signal_Access_Hold.all'Identity);\n+            or\n+               accept Detach_Handler\n+                  (Interrupt   : Interrupt_ID;\n+                   Static      : Boolean)\n+               do\n+                  Unprotected_Detach_Handler (Interrupt, Static);\n+               end Detach_Handler;\n+            or\n+               accept Bind_Interrupt_To_Entry\n+                 (T       : Task_ID;\n+                  E       : Task_Entry_Index;\n+                  Interrupt : Interrupt_ID)\n+               do\n+                  --  If there is a binding already (either a procedure or an\n+                  --  entry), raise Program_Error (propagate it to the caller).\n+\n+                  if User_Handler (Interrupt).H /= null\n+                    or else User_Entry (Interrupt).T /= Null_Task\n+                  then\n+                     Raise_Exception\n+                       (Program_Error'Identity,\n+                        \"A binding for this interrupt is already present\");\n                   end if;\n \n-                  IMOP.Set_Interrupt_Mask (Old_Mask'Access);\n-               end if;\n+                  User_Entry (Interrupt) := Entry_Assoc' (T => T, E => E);\n \n-               Bind_Handler (Interrupt);\n-               Unlock_Interrupt (Self_ID, Interrupt);\n-            end Bind_Interrupt_To_Entry;\n+                  --  Indicate the attachment of interrupt entry in the ATCB.\n+                  --  This is needed so when an interrupt entry task terminates\n+                  --  the binding can be cleaned. The call to unbinding must be\n+                  --  make by the task before it terminates.\n \n-            or accept Detach_Interrupt_Entries (T : Task_ID)\n-            do\n-               for Int in Interrupt_ID'Range loop\n-                  if not Is_Reserved (Int) then\n-                     Lock_Interrupt (Self_ID, Int);\n+                  T.Interrupt_Entry := True;\n \n-                     if User_Entry (Int).T = T then\n+                  --  Invoke a corresponding Server_Task if not yet created.\n+                  --  Place Task_ID info in Server_ID array.\n \n-                        User_Entry (Int) := Entry_Assoc'\n-                          (T => Null_Task, E => Null_Task_Entry);\n-                        Unbind_Handler (Int);\n-                     end if;\n-\n-                     Unlock_Interrupt (Self_ID, Int);\n+                  if Server_ID (Interrupt) = Null_Task\n+                    or else\n+                      Ada.Task_Identification.Is_Terminated\n+                        (To_Ada (Server_ID (Interrupt)))\n+                  then\n+                     Interrupt_Access_Hold := new Interrupt_Server_Task\n+                       (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+                     Server_ID (Interrupt) :=\n+                       To_System (Interrupt_Access_Hold.all'Identity);\n                   end if;\n-               end loop;\n \n-               --  Indicate in ATCB that no interrupt entries are attached.\n+                  Bind_Handler (Interrupt);\n+               end Bind_Interrupt_To_Entry;\n+\n+            or\n+               accept Detach_Interrupt_Entries (T : Task_ID) do\n+                  for Int in Interrupt_ID'Range loop\n+                     if not Is_Reserved (Int) then\n+                        if User_Entry (Int).T = T then\n+                           User_Entry (Int) := Entry_Assoc'\n+                             (T => Null_Task, E => Null_Task_Entry);\n+                           Unbind_Handler (Int);\n+                        end if;\n+                     end if;\n+                  end loop;\n \n-               T.Interrupt_Entry := False;\n-            end Detach_Interrupt_Entries;\n+                  --  Indicate in ATCB that no interrupt entries are attached.\n \n+                  T.Interrupt_Entry := False;\n+               end Detach_Interrupt_Entries;\n             end select;\n \n          exception\n-\n             --  If there is a Program_Error we just want to propagate it to\n             --  the caller and do not want to stop this task.\n \n             when Program_Error =>\n                null;\n \n-            when E : others =>\n-               pragma Assert\n-                 (Shutdown (\"Interrupt_Manager---exception not expected\" &\n-                            ASCII.LF &\n-                            Exception_Information (E)));\n+            when others =>\n+               pragma Assert (False);\n                null;\n          end;\n       end loop;\n \n-      pragma Assert (Shutdown (\"Interrupt_Manager---should not get here\"));\n    exception\n       when Standard'Abort_Signal =>\n          --  Flush interrupt server semaphores, so they can terminate\n          Finalize_Interrupt_Servers;\n          raise;\n    end Interrupt_Manager;\n \n-   ------------------------\n-   -- Signal_Server_Task --\n-   ------------------------\n-\n-   task body Signal_Server_Task is\n-      Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n-      Ret_Interrupt   : IMNG.Interrupt_ID;\n-      Self_ID         : Task_ID := Self;\n-      Tmp_Handler     : Parameterless_Handler;\n-      Tmp_ID          : Task_ID;\n-      Tmp_Entry_Index : Task_Entry_Index;\n-\n-      use type IMNG.Interrupt_ID;\n-\n-   begin\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Server_Task will terminate gracefully.\n-\n-      System.Tasking.Utilities.Make_Independent;\n-\n-      --  Install default action in system level.\n-\n-      IMOP.Install_Default_Action (To_Signal (Interrupt));\n-\n-      --  Note: All tasks in RTS will have all reserved signals\n-      --  masked (except the Interrupt_Manager) and Keep_Unmasked\n-      --  unmasked when created.\n-\n-      --  Abort_Task_Interrupt is one of the signals unmasked\n-      --  in all tasks. We mask it in this particular task\n-      --  so that \"sigwait\" can catch an explicit\n-      --  Abort_Task_Interrupt from the Interrupt_Manager.\n-\n-      --  There are two signals that this task catches through\n-      --  \"sigwait.\" One is the signal it is designated to catch\n-      --  in order to execute an user handler or entry. The other is\n-      --  Abort_Task_Interrupt. This signal is sent from the\n-      --  Interrupt_Manager to inform of status changes (e.g: become Blocked,\n-      --  or a handler or entry is to be detached).\n-\n-      --  Prepare the mask to be used for sigwait.\n-\n-      IMOP.Empty_Interrupt_Mask (Intwait_Mask'Access);\n-\n-      IMOP.Add_To_Interrupt_Mask\n-        (Intwait_Mask'Access, To_Signal (Interrupt));\n-\n-      IMOP.Add_To_Interrupt_Mask\n-        (Intwait_Mask'Access, IMNG.Abort_Task_Interrupt);\n-\n-      IMOP.Thread_Block_Interrupt (IMNG.Abort_Task_Interrupt);\n-\n-      PIO.Set_Interrupt_ID (To_Signal (Interrupt), Self_ID);\n-\n-      loop\n-         System.Tasking.Initialization.Defer_Abort (Self_ID);\n-         POP.Write_Lock (Self_ID);\n-\n-         if User_Handler (Interrupt).H = null\n-           and then User_Entry (Interrupt).T = Null_Task\n-         then\n-\n-            --  No signal binding. If a signal is received,\n-            --  Interrupt_Manager will take the default action.\n-\n-            Self_ID.Common.State := Interrupt_Server_Blocked_Interrupt_Sleep;\n-            POP.Sleep (Self_ID, Interrupt_Server_Idle_Sleep);\n-            Self_ID.Common.State := Runnable;\n-\n-         else\n-            --  A handler or an entry is installed. At this point all tasks\n-            --  mask for the signal is masked. Catch it using\n-            --  sigwait.\n-\n-            --  This task may wake up from sigwait by receiving a signal\n-            --  (Abort_Task_Interrupt) from the Interrupt_Manager for unbinding\n-            --  a procedure handler or an entry. Or it could be a wake up\n-            --  from status change (Unblocked -> Blocked). If that is not\n-            --  the case, we should execute the attached procedure or entry.\n-\n-            POP.Unlock (Self_ID);\n-\n-            Ret_Interrupt := IMOP.Interrupt_Wait (Intwait_Mask'Access);\n-\n-            if Ret_Interrupt = IMNG.Abort_Task_Interrupt then\n-               --  Inform the Interrupt_Manager of wakeup from above sigwait.\n-\n-               POP.Abort_Task (Interrupt_Manager_ID);\n-               POP.Write_Lock (Self_ID);\n-\n-            else\n-               POP.Write_Lock (Self_ID);\n-\n-               --  Even though we have received a signal, the status may\n-               --  have changed before we got the Self_ID lock above.\n-               --  Therefore we make sure a handler or an entry is still\n-               --  bound and make appropriate call.\n-               --  If there is no call to make we need to regenerate the\n-               --  signal in order not to lose it.\n-\n-               if User_Handler (Interrupt).H /= null then\n-\n-                  Tmp_Handler := User_Handler (Interrupt).H;\n-\n-                  --  RTS calls should not be made with self being locked.\n-\n-                  POP.Unlock (Self_ID);\n-\n-                  Tmp_Handler.all;\n-                  POP.Write_Lock (Self_ID);\n-\n-               elsif User_Entry (Interrupt).T /= Null_Task then\n-\n-                  Tmp_ID := User_Entry (Interrupt).T;\n-                  Tmp_Entry_Index := User_Entry (Interrupt).E;\n-\n-                  --  RTS calls should not be made with self being locked.\n-\n-                  POP.Unlock (Self_ID);\n-\n-                  System.Tasking.Rendezvous.Call_Simple\n-                    (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n-\n-                  POP.Write_Lock (Self_ID);\n-               else\n-                  --  This is a situation where this task woke up receiving a\n-                  --  signal and before it got the lock the signal was blocked.\n-                  --  We do not want to lose the signal so we regenerate it at\n-                  --  the process level.\n-\n-                  IMOP.Interrupt_Self_Process (Ret_Interrupt);\n-               end if;\n-            end if;\n-         end if;\n-\n-         POP.Unlock (Self_ID);\n-         System.Tasking.Initialization.Undefer_Abort (Self_ID);\n-\n-         --  Undefer abort here to allow a window for this task\n-         --  to be aborted at the time of system shutdown.\n-      end loop;\n-   end Signal_Server_Task;\n-\n    ---------------------------\n    -- Interrupt_Server_Task --\n    ---------------------------\n \n    --  Server task for vectored hardware interrupt handling\n \n    task body Interrupt_Server_Task is\n-      Self_ID         : Task_ID := Self;\n+      Self_Id         : constant Task_ID := Self;\n       Tmp_Handler     : Parameterless_Handler;\n       Tmp_ID          : Task_ID;\n       Tmp_Entry_Index : Task_Entry_Index;\n@@ -1607,7 +1105,7 @@ package body System.Interrupts is\n \n             --  Wait for the Interrupt_Manager to complete its work\n \n-            POP.Write_Lock (Self_ID);\n+            POP.Write_Lock (Self_Id);\n \n             --  Delete the associated semaphore\n \n@@ -1618,41 +1116,16 @@ package body System.Interrupts is\n             --  Set status for the Interrupt_Manager\n \n             Semaphore_ID_Map (Interrupt) := 0;\n-            Task_Lock (Interrupt) := False;\n             Server_ID (Interrupt) := Null_Task;\n-            POP.Unlock (Self_ID);\n+            POP.Unlock (Self_Id);\n \n             exit;\n          end if;\n       end loop;\n    end Interrupt_Server_Task;\n \n begin\n-   --  Elaboration code for package System.Interrupts\n-\n    --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent.\n \n    Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n-\n-   --  Initialize the lock L.\n-\n-   Initialization.Defer_Abort (Self);\n-   POP.Initialize_Lock (L'Access, POP.PO_Level);\n-   Initialization.Undefer_Abort (Self);\n-\n-   --  During the elaboration of this package body we want the RTS to\n-   --  inherit its signal mask from the Environment Task.\n-\n-   --  The Environment Task should have gotten its mask from\n-   --  the enclosing process during the RTS start up. (See\n-   --  in s-inmaop.adb). Pass the Interrupt_Mask of the Environment\n-   --  task to the Interrupt_Manager.\n-\n-   --  Note : At this point we know that all tasks (including\n-   --  RTS internal servers) are masked for non-reserved signals\n-   --  (see s-taprop.adb). Only the Interrupt_Manager will have\n-   --  masks set up differently, inheriting the original Environment\n-   --  Task's mask.\n-\n-   Interrupt_Manager.Initialize (IMOP.Environment_Mask);\n end System.Interrupts;"}, {"sha": "d49da4dc85caf71c1ca12b1df0b5933271612698", "filename": "gcc/ada/5zintman.adb", "status": "modified", "additions": 15, "deletions": 155, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.11 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -52,42 +51,22 @@\n --  may be used by the thread library.\n \n with Interfaces.C;\n---  used for int and other types\n-\n-with System.Error_Reporting;\n-pragma Warnings (Off, System.Error_Reporting);\n---  used for Shutdown\n \n with System.OS_Interface;\n --  used for various Constants, Signal and types\n \n-with Unchecked_Conversion;\n-\n package body System.Interrupt_Management is\n \n-   use Interfaces.C;\n-   use System.Error_Reporting;\n    use System.OS_Interface;\n-\n-   function To_Isr is new Unchecked_Conversion (Long_Integer, isr_address);\n+   use type Interfaces.C.int;\n \n    type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n-   Exception_Interrupts : constant Interrupt_List :=\n+   Exception_Interrupts : constant Interrupt_List (1 .. 4) :=\n      (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n \n    --  Keep these variables global so that they are initialized only once.\n \n    Exception_Action : aliased struct_sigaction;\n-   Default_Action : aliased struct_sigaction;\n-\n-   --  ????? Use these horrible imports here to solve elaboration order\n-   --  problems.\n-\n-   type Task_Id is access all Integer;\n-\n-   Interrupt_ID_Map : array (Interrupt_ID) of Task_Id;\n-   pragma Import (Ada, Interrupt_ID_Map,\n-     \"system__task_primitives__interrupt_operations__interrupt_id_map\");\n \n    ----------------------\n    -- Notify_Exception --\n@@ -99,13 +78,10 @@ package body System.Interrupt_Management is\n \n    procedure Notify_Exception (signo : Signal) is\n       Mask   : aliased sigset_t;\n-      Result : Interfaces.C.int;\n-      My_Id  : pthread_t;\n+      Result : int;\n+      My_Id  : t_id;\n+\n    begin\n-      --  VxWorks will always mask out the signal during the signal\n-      --  handler and will reenable it on a longjmp.  GNAT does\n-      --  not generate a longjmp to return from a signal handler\n-      --  so the signal will still be masked unless we unmask it.\n       Result := pthread_sigmask (SIG_SETMASK, null, Mask'Unchecked_Access);\n       Result := sigdelset (Mask'Access, signo);\n       Result := pthread_sigmask (SIG_SETMASK, Mask'Unchecked_Access, null);\n@@ -114,26 +90,11 @@ package body System.Interrupt_Management is\n       --  exception.  We take the liberty of resuming the task\n       --  for the application.\n       My_Id := taskIdSelf;\n+\n       if taskIsSuspended (My_Id) /= 0 then\n          Result := taskResume (My_Id);\n       end if;\n \n-      --  As long as we are using a longjmp to return control to the\n-      --  exception handler on the runtime stack, we are safe. The original\n-      --  signal mask (the one we had before coming into this signal catching\n-      --  function) will be restored by the longjmp. Therefore, raising\n-      --  an exception in this handler should be a safe operation.\n-\n-      --  Check that treatment of exception propagation here\n-      --  is consistent with treatment of the abort signal in\n-      --  System.Task_Primitives.Operations.\n-\n-      --  How can SIGSEGV be split into constraint and storage errors?\n-      --  What should SIGILL really raise ? Some implementations have\n-      --  codes for different types of SIGILL and some raise Storage_Error.\n-      --  What causes SIGBUS and should it be caught?\n-      --  Peter Burwood\n-\n       case signo is\n          when SIGFPE =>\n             raise Constraint_Error;\n@@ -144,63 +105,11 @@ package body System.Interrupt_Management is\n          when SIGBUS =>\n             raise Program_Error;\n          when others =>\n-            pragma Assert (Shutdown (\"Unexpected signal\"));\n-            null;\n+            --  Unexpected signal\n+            raise Program_Error;\n       end case;\n    end Notify_Exception;\n \n-   -------------------\n-   -- Notify_Signal --\n-   -------------------\n-\n-   --  VxWorks needs a special casing here. Each VxWorks task has a completely\n-   --  separate signal handling, so the usual signal masking can't work.\n-   --  This idea is to handle all the signals in all the tasks, and when\n-   --  such a signal occurs, redirect it to the dedicated task (if any) or\n-   --  reraise it.\n-\n-   procedure Notify_Signal (signo : Signal);\n-\n-   procedure Notify_Signal (signo : Signal) is\n-      Mask    : aliased sigset_t;\n-      Result  : Interfaces.C.int;\n-      My_Id   : pthread_t;\n-      old_isr : isr_address;\n-\n-      function Get_Thread_Id (T : Task_Id) return pthread_t;\n-      pragma Import (Ada, Get_Thread_Id,\n-        \"system__task_primitives__operations__get_thread_id\");\n-\n-   begin\n-      --  VxWorks will always mask out the signal during the signal\n-      --  handler and will reenable it on a longjmp.  GNAT does\n-      --  not generate a longjmp to return from a signal handler\n-      --  so the signal will still be masked unless we unmask it.\n-      Result := pthread_sigmask (SIG_SETMASK, null, Mask'Unchecked_Access);\n-      Result := sigdelset (Mask'Access, signo);\n-      Result := pthread_sigmask (SIG_SETMASK, Mask'Unchecked_Access, null);\n-\n-      --  VxWorks will suspend the task when it gets a hardware\n-      --  exception.  We take the liberty of resuming the task\n-      --  for the application.\n-      My_Id := taskIdSelf;\n-      if taskIsSuspended (My_Id) /= 0 then\n-         Result := taskResume (My_Id);\n-      end if;\n-\n-      --  ??? Need a lock around this, in case the handler is detached\n-      --  between the two following statements.\n-\n-      if Interrupt_ID_Map (Interrupt_ID (signo)) /= null then\n-         Result :=\n-           kill (Get_Thread_Id (Interrupt_ID_Map (Interrupt_ID (signo))),\n-             Signal (signo));\n-      else\n-         old_isr := c_signal (signo, To_Isr (SIG_DFL));\n-         Result := kill (My_Id, Signal (signo));\n-      end if;\n-   end Notify_Signal;\n-\n    ---------------------------\n    -- Initialize_Interrupts --\n    ---------------------------\n@@ -209,20 +118,11 @@ package body System.Interrupt_Management is\n    --  to initialize signal handling in each task.\n \n    procedure Initialize_Interrupts is\n+      Result  : int;\n       old_act : aliased struct_sigaction;\n-      Result  : Interfaces.C.int;\n \n    begin\n-      for J in Interrupt_ID'First + 1 .. Interrupt_ID'Last loop\n-         if J /= Abort_Task_Interrupt then\n-            Result := sigaction (Signal (J), Default_Action'Access,\n-              old_act'Unchecked_Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n       for J in Exception_Interrupts'Range loop\n-         Keep_Unmasked (Exception_Interrupts (J)) := True;\n          Result :=\n            sigaction\n              (Signal (Exception_Interrupts (J)), Exception_Action'Access,\n@@ -233,63 +133,23 @@ package body System.Interrupt_Management is\n \n begin\n    declare\n-      mask         : aliased sigset_t;\n-      default_mask : aliased sigset_t;\n-      Result       : Interfaces.C.int;\n-\n+      mask   : aliased sigset_t;\n+      Result : int;\n    begin\n-      --  The VxWorks POSIX threads library currently needs initialization.\n-      --  We wish it could be in System.OS_Interface, but that would\n-      --  cause an elaboration problem.\n-\n-      pthread_init;\n-\n       Abort_Task_Interrupt := SIGABRT;\n       --  Change this if you want to use another signal for task abort.\n       --  SIGTERM might be a good one.\n \n       Exception_Action.sa_handler := Notify_Exception'Address;\n-      Default_Action.sa_handler   := Notify_Signal'Address;\n-\n-      Exception_Action.sa_flags := SA_SIGINFO + SA_ONSTACK;\n-      Default_Action.sa_flags := SA_SIGINFO + SA_ONSTACK;\n-      --  Send us extra signal information (SA_SIGINFO) on the\n-      --  stack (SA_ONSTACK).\n-      --  There is no SA_NODEFER in VxWorks.  The signal mask is\n-      --  restored after a longjmp so the SA_NODEFER option is\n-      --  not needed.  - Dan Eischen\n-\n+      Exception_Action.sa_flags := SA_ONSTACK;\n       Result := sigemptyset (mask'Access);\n       pragma Assert (Result = 0);\n-      Result := sigemptyset (default_mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Interrupt_ID'First + 1 .. Interrupt_ID'Last loop\n-         Result := sigaddset (default_mask'Access, Signal (J));\n-         pragma Assert (Result = 0);\n-      end loop;\n \n       for J in Exception_Interrupts'Range loop\n          Result := sigaddset (mask'Access, Signal (Exception_Interrupts (J)));\n          pragma Assert (Result = 0);\n-         Result :=\n-           sigdelset (default_mask'Access, Signal (Exception_Interrupts (J)));\n-         pragma Assert (Result = 0);\n       end loop;\n \n       Exception_Action.sa_mask := mask;\n-      Default_Action.sa_mask := default_mask;\n-\n-      --  Initialize_Interrupts is called for each task in Enter_Task\n-\n-      Keep_Unmasked (Abort_Task_Interrupt) := True;\n-\n-      Reserve := Reserve or Keep_Unmasked or Keep_Masked;\n-\n-      Reserve (0) := True;\n-      --  We do not have Signal 0 in reality. We just use this value\n-      --  to identify non-existent signals (see s-intnam.ads). Therefore,\n-      --  Signal 0 should not be used in all signal related operations hence\n-      --  mark it as reserved.\n    end;\n end System.Interrupt_Management;"}, {"sha": "747022bf584a71c7aeb01948dda96b44d6e9918b", "filename": "gcc/ada/5zosinte.adb", "status": "modified", "additions": 26, "deletions": 691, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zosinte.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---                             $Revision: 1.15 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1997-2001 Free Software Foundation             --\n+--             Copyright (C) 1997-2002 Free Software Foundation             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -43,171 +42,22 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n --  tasking operations. It causes infinite loops and other problems.\n \n-with Interfaces.C; use Interfaces.C;\n-\n-with System.VxWorks;\n---  used for Wind_TCB_Ptr\n-\n-with Unchecked_Conversion;\n-\n package body System.OS_Interface is\n \n-   use System.VxWorks;\n-\n-   --  Option flags for taskSpawn\n-\n-   VX_UNBREAKABLE    : constant := 16#0002#;\n-   VX_FP_TASK        : constant := 16#0008#;\n-   VX_FP_PRIVATE_ENV : constant := 16#0080#;\n-   VX_NO_STACK_FILL  : constant := 16#0100#;\n-\n-   function taskSpawn\n-     (name          : System.Address;  --  Pointer to task name\n-      priority      : int;\n-      options       : int;\n-      stacksize     : size_t;\n-      start_routine : Thread_Body;\n-      arg1          : System.Address;\n-      arg2          : int := 0;\n-      arg3          : int := 0;\n-      arg4          : int := 0;\n-      arg5          : int := 0;\n-      arg6          : int := 0;\n-      arg7          : int := 0;\n-      arg8          : int := 0;\n-      arg9          : int := 0;\n-      arg10         : int := 0) return pthread_t;\n-   pragma Import (C, taskSpawn, \"taskSpawn\");\n-\n-   procedure taskDelete (tid : pthread_t);\n-   pragma Import (C, taskDelete, \"taskDelete\");\n-\n-   --  These are the POSIX scheduling priorities. These are enabled\n-   --  when the global variable posixPriorityNumbering is 1.\n-\n-   POSIX_SCHED_FIFO_LOW_PRI  : constant := 0;\n-   POSIX_SCHED_FIFO_HIGH_PRI : constant := 255;\n-   POSIX_SCHED_RR_LOW_PRI    : constant := 0;\n-   POSIX_SCHED_RR_HIGH_PRI   : constant := 255;\n-\n-   --  These are the VxWorks native (default) scheduling priorities.\n-   --  These are used when the global variable posixPriorityNumbering\n-   --  is 0.\n-\n-   SCHED_FIFO_LOW_PRI  : constant := 255;\n-   SCHED_FIFO_HIGH_PRI : constant := 0;\n-   SCHED_RR_LOW_PRI    : constant := 255;\n-   SCHED_RR_HIGH_PRI   : constant := 0;\n-\n-   --  Global variable to enable POSIX priority numbering.\n-   --  By default, it is 0 and VxWorks native priority numbering\n-   --  is used.\n-\n-   posixPriorityNumbering : int;\n-   pragma Import (C, posixPriorityNumbering, \"posixPriorityNumbering\");\n-\n-   --  VxWorks will let you set round-robin scheduling globally\n-   --  for all tasks, but not for individual tasks.  Attempting\n-   --  to set the scheduling policy for a specific task (using\n-   --  sched_setscheduler) to something other than what the system\n-   --  is currently using will fail.  If you wish to change the\n-   --  scheduling policy, then use the following function to set\n-   --  it globally for all tasks.  When ticks is 0, time slicing\n-   --  (round-robin scheduling) is disabled.\n-\n-   function kernelTimeSlice (ticks : int) return int;\n-   pragma Import (C, kernelTimeSlice, \"kernelTimeSlice\");\n+   use type Interfaces.C.int;\n \n-   function taskPriorityGet\n-     (tid       : pthread_t;\n-      pPriority : access int)\n-     return int;\n-   pragma Import (C, taskPriorityGet, \"taskPriorityGet\");\n+   Low_Priority : constant := 255;\n+   --  VxWorks native (default) lowest scheduling priority.\n \n-   function taskPrioritySet\n-     (tid         : pthread_t;\n-      newPriority : int)\n-     return int;\n-   pragma Import (C, taskPrioritySet, \"taskPrioritySet\");\n-\n-   function To_Wind_TCB_Ptr is\n-     new Unchecked_Conversion (pthread_t, Wind_TCB_Ptr);\n-\n-\n-   --  Error codes (errno).  The lower level 16 bits are the\n-   --  error code, with the upper 16 bits representing the\n-   --  module number in which the error occurred.  By convention,\n-   --  the module number is 0 for UNIX errors.  VxWorks reserves\n-   --  module numbers 1-500, with the remaining module numbers\n-   --  being available for user applications.\n-\n-   M_objLib                 : constant := 61 * 2**16;\n-   --  semTake() failure with ticks = NO_WAIT\n-   S_objLib_OBJ_UNAVAILABLE : constant := M_objLib + 2;\n-   --  semTake() timeout with ticks > NO_WAIT\n-   S_objLib_OBJ_TIMEOUT     : constant := M_objLib + 4;\n-\n-   --  We use two different kinds of VxWorks semaphores: mutex\n-   --  and binary semaphores.  A null (0) ID is returned when\n-   --  a semaphore cannot be created. Binary semaphores and common\n-   --  operations are declared in the spec of this package,\n-   --  as they are used to implement hardware interrupt handling\n-\n-   function semMCreate\n-     (options : int) return SEM_ID;\n-   pragma Import (C, semMCreate, \"semMCreate\");\n-\n-\n-   function taskLock return int;\n-   pragma Import (C, taskLock, \"taskLock\");\n-\n-   function taskUnlock return int;\n-   pragma Import (C, taskUnlock, \"taskUnlock\");\n-\n-   -------------------------------------------------------\n-   --  Convenience routines to convert between VxWorks  --\n-   --  priority and POSIX priority.                     --\n-   -------------------------------------------------------\n-\n-   function To_Vxworks_Priority (Priority : in int) return int;\n-   pragma Inline (To_Vxworks_Priority);\n-\n-   function To_Posix_Priority (Priority : in int) return int;\n-   pragma Inline (To_Posix_Priority);\n-\n-   function To_Vxworks_Priority (Priority : in int) return int is\n-   begin\n-      return SCHED_FIFO_LOW_PRI - Priority;\n-   end To_Vxworks_Priority;\n-\n-   function To_Posix_Priority (Priority : in int) return int is\n-   begin\n-      return SCHED_FIFO_LOW_PRI - Priority;\n-   end To_Posix_Priority;\n-\n-   ----------------------------------------\n-   --  Implementation of POSIX routines  --\n-   ----------------------------------------\n-\n-   -----------------------------------------\n-   --  Nonstandard Thread Initialization  --\n-   -----------------------------------------\n-\n-   procedure pthread_init is\n-   begin\n-      Keys_Created := 0;\n-      Time_Slice := -1;\n-   end pthread_init;\n-\n-   ---------------------------\n-   --  POSIX.1c  Section 3  --\n-   ---------------------------\n+   -------------\n+   -- sigwait --\n+   -------------\n \n    function sigwait\n      (set : access sigset_t;\n       sig : access Signal) return int\n    is\n-      Result  : Interfaces.C.int;\n+      Result : int;\n \n       function sigwaitinfo\n         (set : access sigset_t; sigvalue : System.Address) return int;\n@@ -225,532 +75,6 @@ package body System.OS_Interface is\n       end if;\n    end sigwait;\n \n-   ----------------------------\n-   --  POSIX.1c  Section 11  --\n-   ----------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int is\n-   begin\n-      --  Let's take advantage of VxWorks priority inversion\n-      --  protection.\n-      --\n-      --  ??? - Do we want to also specify SEM_DELETE_SAFE???\n-\n-      attr.Flags := int (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n-\n-      --  Initialize the ceiling priority to the maximim priority.\n-      --  We will use POSIX priorities since these routines are\n-      --  emulating POSIX routines.\n-\n-      attr.Prio_Ceiling := POSIX_SCHED_FIFO_HIGH_PRI;\n-      attr.Protocol := PTHREAD_PRIO_INHERIT;\n-      return 0;\n-   end pthread_mutexattr_init;\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int is\n-   begin\n-      attr.Flags := 0;\n-      attr.Prio_Ceiling := POSIX_SCHED_FIFO_HIGH_PRI;\n-      attr.Protocol := PTHREAD_PRIO_INHERIT;\n-      return 0;\n-   end pthread_mutexattr_destroy;\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int\n-   is\n-      Result : int := 0;\n-\n-   begin\n-      --  A mutex should initially be created full and the task\n-      --  protected from deletion while holding the semaphore.\n-\n-      mutex.Mutex := semMCreate (attr.Flags);\n-      mutex.Prio_Ceiling := attr.Prio_Ceiling;\n-      mutex.Protocol := attr.Protocol;\n-\n-      if mutex.Mutex = 0 then\n-         Result := errno;\n-      end if;\n-\n-      return Result;\n-   end pthread_mutex_init;\n-\n-   function pthread_mutex_destroy\n-     (mutex : access pthread_mutex_t) return int\n-   is\n-      Result : STATUS;\n-   begin\n-      Result := semDelete (mutex.Mutex);\n-\n-      if Result /= 0 then\n-         Result := errno;\n-      end if;\n-\n-      mutex.Mutex := 0;  --  Ensure the mutex is properly cleaned.\n-      mutex.Prio_Ceiling := POSIX_SCHED_FIFO_HIGH_PRI;\n-      mutex.Protocol := PTHREAD_PRIO_INHERIT;\n-      return Result;\n-   end pthread_mutex_destroy;\n-\n-   function pthread_mutex_lock\n-     (mutex : access pthread_mutex_t) return int\n-   is\n-      Result    : int;\n-      WTCB_Ptr  : Wind_TCB_Ptr;\n-   begin\n-      WTCB_Ptr := To_Wind_TCB_Ptr (taskIdSelf);\n-\n-      if WTCB_Ptr = null then\n-         return errno;\n-      end if;\n-\n-      --  Check the current inherited priority in the WIND_TCB\n-      --  against the mutex ceiling priority and return EINVAL\n-      --  upon a ceiling violation.\n-      --\n-      --  We always convert the VxWorks priority to POSIX priority\n-      --  in case the current priority ordering has changed (see\n-      --  posixPriorityNumbering).  The mutex ceiling priority is\n-      --  maintained as POSIX compatible.\n-\n-      if mutex.Protocol = PTHREAD_PRIO_PROTECT and then\n-         To_Posix_Priority (WTCB_Ptr.Priority) > mutex.Prio_Ceiling\n-      then\n-         return EINVAL;\n-      end if;\n-\n-      Result := semTake (mutex.Mutex, WAIT_FOREVER);\n-\n-      if Result /= 0 then\n-         Result := errno;\n-      end if;\n-\n-      return Result;\n-   end pthread_mutex_lock;\n-\n-   function pthread_mutex_unlock\n-     (mutex : access pthread_mutex_t) return int\n-   is\n-      Result : int;\n-   begin\n-      Result := semGive (mutex.Mutex);\n-\n-      if Result /= 0 then\n-         Result := errno;\n-      end if;\n-\n-      return Result;\n-   end pthread_mutex_unlock;\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int is\n-   begin\n-      attr.Flags := SEM_Q_PRIORITY;\n-      return 0;\n-   end pthread_condattr_init;\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int is\n-   begin\n-      attr.Flags := 0;\n-      return 0;\n-   end pthread_condattr_destroy;\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int\n-   is\n-      Result  : int := 0;\n-\n-   begin\n-      --  Condition variables should be initially created\n-      --  empty.\n-\n-      cond.Sem := semBCreate (attr.Flags, SEM_EMPTY);\n-      cond.Waiting := 0;\n-\n-      if cond.Sem = 0 then\n-         Result := errno;\n-      end if;\n-\n-      return Result;\n-   end pthread_cond_init;\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int is\n-      Result : int;\n-\n-   begin\n-      Result := semDelete (cond.Sem);\n-\n-      if Result /= 0 then\n-         Result := errno;\n-      end if;\n-\n-      return Result;\n-   end pthread_cond_destroy;\n-\n-   function pthread_cond_signal\n-     (cond : access pthread_cond_t) return int\n-   is\n-      Result : int := 0;\n-      Status : int;\n-\n-   begin\n-      --  Disable task scheduling.\n-\n-      Status := taskLock;\n-\n-      --  Iff someone is currently waiting on the condition variable\n-      --  then release the semaphore; we don't want to leave the\n-      --  semaphore in the full state because the next guy to do\n-      --  a condition wait operation would not block.\n-\n-      if cond.Waiting > 0 then\n-         Result := semGive (cond.Sem);\n-\n-         --  One less thread waiting on the CV.\n-\n-         cond.Waiting := cond.Waiting - 1;\n-\n-         if Result /= 0 then\n-            Result := errno;\n-         end if;\n-      end if;\n-\n-      --  Reenable task scheduling.\n-\n-      Status := taskUnlock;\n-\n-      return Result;\n-   end pthread_cond_signal;\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int\n-   is\n-      Result : int;\n-      Status : int;\n-   begin\n-      --  Disable task scheduling.\n-\n-      Status := taskLock;\n-\n-      --  Release the mutex as required by POSIX.\n-\n-      Result := semGive (mutex.Mutex);\n-\n-      --  Indicate that there is another thread waiting on the CV.\n-\n-      cond.Waiting := cond.Waiting + 1;\n-\n-      --  Perform a blocking operation to take the CV semaphore.\n-      --  Note that a blocking operation in VxWorks will reenable\n-      --  task scheduling.  When we are no longer blocked and control\n-      --  is returned, task scheduling will again be disabled.\n-\n-      Result := semTake (cond.Sem, WAIT_FOREVER);\n-\n-      if Result /= 0 then\n-         cond.Waiting := cond.Waiting - 1;\n-         Result := EINVAL;\n-      end if;\n-\n-      --  Take the mutex as required by POSIX.\n-\n-      Status := semTake (mutex.Mutex, WAIT_FOREVER);\n-\n-      if Status /= 0 then\n-         Result := EINVAL;\n-      end if;\n-\n-      --  Reenable task scheduling.\n-\n-      Status := taskUnlock;\n-\n-      return Result;\n-   end pthread_cond_wait;\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int\n-   is\n-      Result  : int;\n-      Status  : int;\n-      Ticks   : int;\n-      TS      : aliased timespec;\n-   begin\n-      Status := clock_gettime (CLOCK_REALTIME, TS'Unchecked_Access);\n-\n-      --  Calculate the number of clock ticks for the timeout.\n-\n-      Ticks := To_Clock_Ticks (To_Duration (abstime.all) - To_Duration (TS));\n-\n-      if Ticks <= 0 then\n-         --  It is not worth the time to try to perform a semTake,\n-         --  because we know it will always fail.  A semTake with\n-         --  ticks = 0 (NO_WAIT) will not block and therefore not\n-         --  allow another task to give the semaphore.  And if we've\n-         --  designed pthread_cond_signal correctly, the semaphore\n-         --  should never be left in a full state.\n-         --\n-         --  Make sure we give up the CPU.\n-\n-         Status := taskDelay (0);\n-         return ETIMEDOUT;\n-      end if;\n-\n-      --  Disable task scheduling.\n-\n-      Status := taskLock;\n-\n-      --  Release the mutex as required by POSIX.\n-\n-      Result := semGive (mutex.Mutex);\n-\n-      --  Indicate that there is another thread waiting on the CV.\n-\n-      cond.Waiting := cond.Waiting + 1;\n-\n-      --  Perform a blocking operation to take the CV semaphore.\n-      --  Note that a blocking operation in VxWorks will reenable\n-      --  task scheduling.  When we are no longer blocked and control\n-      --  is returned, task scheduling will again be disabled.\n-\n-      Result := semTake (cond.Sem, Ticks);\n-\n-      if Result /= 0 then\n-         if errno = S_objLib_OBJ_TIMEOUT then\n-            Result := ETIMEDOUT;\n-         else\n-            Result := EINVAL;\n-         end if;\n-         cond.Waiting := cond.Waiting - 1;\n-      end if;\n-\n-      --  Take the mutex as required by POSIX.\n-\n-      Status := semTake (mutex.Mutex, WAIT_FOREVER);\n-\n-      if Status /= 0 then\n-         Result := EINVAL;\n-      end if;\n-\n-      --  Reenable task scheduling.\n-\n-      Status := taskUnlock;\n-\n-      return Result;\n-   end pthread_cond_timedwait;\n-\n-   ----------------------------\n-   --  POSIX.1c  Section 13  --\n-   ----------------------------\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int is\n-   begin\n-      if protocol < PTHREAD_PRIO_NONE\n-        or protocol > PTHREAD_PRIO_PROTECT\n-      then\n-         return EINVAL;\n-      end if;\n-\n-      attr.Protocol := protocol;\n-      return 0;\n-   end pthread_mutexattr_setprotocol;\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int is\n-   begin\n-      --  Our interface to the rest of the world is meant\n-      --  to be POSIX compliant; keep the priority in POSIX\n-      --  format.\n-\n-      attr.Prio_Ceiling := prioceiling;\n-      return 0;\n-   end pthread_mutexattr_setprioceiling;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int\n-   is\n-      Result : int;\n-   begin\n-      --  Convert the POSIX priority to VxWorks native\n-      --  priority.\n-\n-      Result := taskPrioritySet (thread,\n-        To_Vxworks_Priority (param.sched_priority));\n-      return 0;\n-   end pthread_setschedparam;\n-\n-   function sched_yield return int is\n-   begin\n-      return taskDelay (0);\n-   end sched_yield;\n-\n-   function pthread_sched_rr_set_interval (usecs : int) return int is\n-      Result  : int := 0;\n-      D_Slice : Duration;\n-   begin\n-      --  Check to see if round-robin scheduling (time slicing)\n-      --  is enabled.  If the time slice is the default value (-1)\n-      --  or any negative number, we will leave the kernel time\n-      --  slice unchanged.  If the time slice is 0, we disable\n-      --  kernel time slicing by setting it to 0.  Otherwise, we\n-      --  set the kernel time slice to the specified value converted\n-      --  to clock ticks.\n-\n-      Time_Slice := usecs;\n-\n-      if Time_Slice > 0 then\n-         D_Slice := Duration (Time_Slice) / Duration (1_000_000.0);\n-         Result := kernelTimeSlice (To_Clock_Ticks (D_Slice));\n-\n-      else\n-         if Time_Slice = 0 then\n-            Result := kernelTimeSlice (0);\n-         end if;\n-      end if;\n-\n-      return Result;\n-   end pthread_sched_rr_set_interval;\n-\n-   function pthread_attr_init (attr : access pthread_attr_t) return int is\n-   begin\n-      attr.Stacksize := 100000;   -- What else can I do?\n-      attr.Detachstate := PTHREAD_CREATE_DETACHED;\n-      attr.Priority := POSIX_SCHED_FIFO_LOW_PRI;\n-      attr.Taskname := System.Null_Address;\n-      return 0;\n-   end pthread_attr_init;\n-\n-   function pthread_attr_destroy (attr : access pthread_attr_t) return int is\n-   begin\n-      attr.Stacksize := 0;\n-      attr.Detachstate := 0;\n-      attr.Priority := POSIX_SCHED_FIFO_LOW_PRI;\n-      attr.Taskname := System.Null_Address;\n-      return 0;\n-   end pthread_attr_destroy;\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int is\n-   begin\n-      attr.Detachstate := detachstate;\n-      return 0;\n-   end pthread_attr_setdetachstate;\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int is\n-   begin\n-      attr.Stacksize := stacksize;\n-      return 0;\n-   end pthread_attr_setstacksize;\n-\n-   --  In VxWorks tasks, we can set the task name.  This\n-   --  makes it really convenient for debugging.\n-\n-   function pthread_attr_setname_np\n-     (attr : access pthread_attr_t;\n-      name : System.Address) return int is\n-   begin\n-      attr.Taskname := name;\n-      return 0;\n-   end pthread_attr_setname_np;\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attr          : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int is\n-   begin\n-      thread.all := taskSpawn (attr.Taskname,\n-        To_Vxworks_Priority (attr.Priority), VX_FP_TASK, attr.Stacksize,\n-        start_routine, arg);\n-\n-      if thread.all = -1 then\n-         return -1;\n-      else\n-         return 0;\n-      end if;\n-   end pthread_create;\n-\n-   function pthread_detach (thread : pthread_t) return int is\n-   begin\n-      return 0;\n-   end pthread_detach;\n-\n-   procedure pthread_exit (status : System.Address) is\n-   begin\n-      taskDelete (0);\n-   end pthread_exit;\n-\n-   function pthread_self return pthread_t is\n-   begin\n-      return taskIdSelf;\n-   end pthread_self;\n-\n-   function pthread_equal (t1 : pthread_t; t2 : pthread_t) return int is\n-   begin\n-      if t1 = t2 then\n-         return 1;\n-      else\n-         return 0;\n-      end if;\n-   end pthread_equal;\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int\n-   is\n-      Result : int;\n-   begin\n-      if Integer (key) not in Key_Storage'Range then\n-         return EINVAL;\n-      end if;\n-\n-      Key_Storage (Integer (key)) := value;\n-      Result := taskVarAdd (taskIdSelf, Key_Storage (Integer (key))'Access);\n-\n-      --  We should be able to directly set the key with the following:\n-      --     Key_Storage (key) := value;\n-      --  but we'll be safe and use taskVarSet.\n-      --  ??? Come back and revisit this.\n-\n-      Result := taskVarSet (taskIdSelf,\n-        Key_Storage (Integer (key))'Access, value);\n-      return Result;\n-   end pthread_setspecific;\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address is\n-   begin\n-      return Key_Storage (Integer (key));\n-   end pthread_getspecific;\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int is\n-   begin\n-      Keys_Created := Keys_Created + 1;\n-\n-      if Keys_Created not in Key_Storage'Range then\n-         return ENOMEM;\n-      end if;\n-\n-      key.all := pthread_key_t (Keys_Created);\n-      return 0;\n-   end pthread_key_create;\n-\n    -----------------\n    -- To_Duration --\n    -----------------\n@@ -777,21 +101,31 @@ package body System.OS_Interface is\n          S := S - 1;\n          F := F + 1.0;\n       end if;\n+\n       return timespec' (ts_sec => S,\n         ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n    end To_Timespec;\n \n+   -------------------------\n+   -- To_VxWorks_Priority --\n+   -------------------------\n+\n+   function To_VxWorks_Priority (Priority : in int) return int is\n+   begin\n+      return Low_Priority - Priority;\n+   end To_VxWorks_Priority;\n+\n    --------------------\n    -- To_Clock_Ticks --\n    --------------------\n \n    --  ??? - For now, we'll always get the system clock rate\n    --  since it is allowed to be changed during run-time in\n-   --  VxWorks.  A better method would be to provide an operation\n+   --  VxWorks. A better method would be to provide an operation\n    --  to set it that so we can always know its value.\n    --\n    --  Another thing we should probably allow for is a resultant\n-   --  tick count greater than int'Last.  This should probably\n+   --  tick count greater than int'Last. This should probably\n    --  be a procedure with two output parameters, one in the\n    --  range 0 .. int'Last, and another representing the overflow\n    --  count.\n@@ -800,7 +134,11 @@ package body System.OS_Interface is\n       Ticks          : Long_Long_Integer;\n       Rate_Duration  : Duration;\n       Ticks_Duration : Duration;\n+\n    begin\n+      if D < 0.0 then\n+         return -1;\n+      end if;\n \n       --  Ensure that the duration can be converted to ticks\n       --  at the current clock tick rate without overflowing.\n@@ -809,10 +147,7 @@ package body System.OS_Interface is\n \n       if D > (Duration'Last / Rate_Duration) then\n          Ticks := Long_Long_Integer (int'Last);\n-\n       else\n-         --  We always want to round up to the nearest clock tick.\n-\n          Ticks_Duration := D * Rate_Duration;\n          Ticks := Long_Long_Integer (Ticks_Duration);\n "}, {"sha": "e4cc55852117dab706b4497fbd01548114f62997", "filename": "gcc/ada/5zosinte.ads", "status": "modified", "additions": 119, "deletions": 303, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zosinte.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -50,19 +49,15 @@\n \n with Interfaces.C;\n with System.VxWorks;\n+\n package System.OS_Interface is\n    pragma Preelaborate;\n \n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-   subtype char           is Interfaces.C.char;\n+   subtype int         is Interfaces.C.int;\n+   subtype short       is Short_Integer;\n+   type long           is new Long_Integer;\n+   type unsigned_long  is mod 2 ** long'Size;\n+   type size_t         is mod 2 ** Standard'Address_Size;\n \n    -----------\n    -- Errno --\n@@ -83,22 +78,14 @@ package System.OS_Interface is\n    -- Signals and Interrupts --\n    ----------------------------\n \n-   --  In order to support both signal and hardware interrupt handling,\n-   --  the ranges of \"interrupt IDs\" for the vectored hardware interrupts\n-   --  and the signals are catenated. In other words, the external IDs\n-   --  used to designate signals are relocated beyond the range of the\n-   --  vectored interrupts. The IDs given in Ada.Interrupts.Names should\n-   --  be used to designate signals; vectored interrupts are designated\n-   --  by their interrupt number.\n-\n    NSIG : constant := 32;\n    --  Number of signals on the target OS\n    type Signal is new int range 0 .. Interfaces.C.\"-\" (NSIG, 1);\n \n    Max_HW_Interrupt : constant := System.VxWorks.Num_HW_Interrupts - 1;\n    type HW_Interrupt is new int range 0 .. Max_HW_Interrupt;\n \n-   Max_Interrupt : constant := Max_HW_Interrupt + NSIG;\n+   Max_Interrupt : constant := Max_HW_Interrupt;\n \n    SIGILL  : constant :=  4; --  illegal instruction (not reset)\n    SIGABRT : constant :=  6; --  used by abort, replace SIGIOT in the future\n@@ -116,10 +103,9 @@ package System.OS_Interface is\n    SIG_SETMASK : constant := 3;\n \n    --  The sa_flags in struct sigaction.\n-   SA_SIGINFO : constant := 16#0002#;\n-   SA_ONSTACK : constant := 16#0004#;\n+   SA_SIGINFO   : constant := 16#0002#;\n+   SA_ONSTACK   : constant := 16#0004#;\n \n-   --  ANSI args and returns from signal().\n    SIG_DFL : constant := 0;\n    SIG_IGN : constant := 1;\n \n@@ -170,6 +156,17 @@ package System.OS_Interface is\n       oset : sigset_t_ptr) return int;\n    pragma Import (C, pthread_sigmask, \"sigprocmask\");\n \n+   type t_id is new long;\n+   subtype Thread_Id is t_id;\n+\n+   function kill (pid : t_id; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   --  VxWorks doesn't have getpid; taskIdSelf is the equivalent\n+   --  routine.\n+   function getpid return t_id;\n+   pragma Import (C, getpid, \"taskIdSelf\");\n+\n    ----------\n    -- Time --\n    ----------\n@@ -199,261 +196,104 @@ package System.OS_Interface is\n      (clock_id : clockid_t; tp : access timespec) return int;\n    pragma Import (C, clock_gettime, \"clock_gettime\");\n \n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   --  Scheduling policies.\n-   SCHED_FIFO  : constant := 1;\n-   SCHED_RR    : constant := 2;\n-   SCHED_OTHER : constant := 4;\n+   type ULONG is new unsigned_long;\n \n-   -------------\n-   -- Threads --\n-   -------------\n+   procedure tickSet (ticks : ULONG);\n+   pragma Import (C, tickSet, \"tickSet\");\n \n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n+   function tickGet return ULONG;\n+   pragma Import (C, tickGet, \"tickGet\");\n \n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n+   -----------------------------------------------------\n+   --  Convenience routine to convert between VxWorks --\n+   --  priority and Ada priority.                     --\n+   -----------------------------------------------------\n \n-   null_pthread : constant pthread_t;\n+   function To_VxWorks_Priority (Priority : in int) return int;\n+   pragma Inline (To_VxWorks_Priority);\n \n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 0;\n-   PTHREAD_CREATE_JOINABLE : constant := 1;\n-\n-   function kill (pid : pthread_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   --  VxWorks doesn't have getpid; taskIdSelf is the equivalent\n-   --  routine.\n-   function getpid return pthread_t;\n-   pragma Import (C, getpid, \"taskIdSelf\");\n-\n-   ---------------------------------\n-   -- Nonstandard Thread Routines --\n-   ---------------------------------\n-\n-   procedure pthread_init;\n-   pragma Inline (pthread_init);\n-   --  Vxworks requires this for the moment.\n+   --------------------------\n+   -- VxWorks specific API --\n+   --------------------------\n \n-   function taskIdSelf return pthread_t;\n+   function taskIdSelf return t_id;\n    pragma Import (C, taskIdSelf, \"taskIdSelf\");\n \n-   function taskSuspend (tid : pthread_t) return int;\n+   function taskSuspend (tid : t_id) return int;\n    pragma Import (C, taskSuspend, \"taskSuspend\");\n \n-   function taskResume (tid : pthread_t) return int;\n+   function taskResume (tid : t_id) return int;\n    pragma Import (C, taskResume, \"taskResume\");\n \n-   function taskIsSuspended (tid : pthread_t) return int;\n+   function taskIsSuspended (tid : t_id) return int;\n    pragma Import (C, taskIsSuspended, \"taskIsSuspended\");\n \n    function taskVarAdd\n-     (tid  : pthread_t;\n-      pVar : access System.Address) return int;\n+     (tid : t_id; pVar : System.Address) return int;\n    pragma Import (C, taskVarAdd, \"taskVarAdd\");\n \n    function taskVarDelete\n-     (tid  : pthread_t;\n-      pVar : access System.Address) return int;\n+     (tid : t_id; pVar : access System.Address) return int;\n    pragma Import (C, taskVarDelete, \"taskVarDelete\");\n \n    function taskVarSet\n-     (tid   : pthread_t;\n+     (tid   : t_id;\n       pVar  : access System.Address;\n       value : System.Address) return int;\n    pragma Import (C, taskVarSet, \"taskVarSet\");\n \n    function taskVarGet\n-     (tid   : pthread_t;\n-      pVar  : access System.Address) return int;\n+     (tid  : t_id;\n+      pVar : access System.Address) return int;\n    pragma Import (C, taskVarGet, \"taskVarGet\");\n \n-   function taskInfoGet\n-     (tid       : pthread_t;\n-      pTaskDesc : access System.VxWorks.TASK_DESC) return int;\n-   pragma Import (C, taskInfoGet, \"taskInfoGet\");\n-\n    function taskDelay (ticks : int) return int;\n+   procedure taskDelay (ticks : int);\n    pragma Import (C, taskDelay, \"taskDelay\");\n \n    function sysClkRateGet return int;\n    pragma Import (C, sysClkRateGet, \"sysClkRateGet\");\n \n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutexattr_init);\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutexattr_destroy);\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutex_init);\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_destroy);\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_lock);\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_unlock);\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_condattr_init);\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_condattr_destroy);\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_cond_init);\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Inline (pthread_cond_destroy);\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Inline (pthread_cond_signal);\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_cond_wait);\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Inline (pthread_cond_timedwait);\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_PROTECT : constant := 2;\n-   PTHREAD_PRIO_INHERIT : constant := 1;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Inline (pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Inline (pthread_mutexattr_setprioceiling);\n-\n-   type struct_sched_param is record\n-      sched_priority : int;\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Inline (pthread_setschedparam);\n-\n-   function sched_yield return int;\n-   pragma Inline (sched_yield);\n-\n-   function pthread_sched_rr_set_interval (usecs : int) return int;\n-   pragma Inline (pthread_sched_rr_set_interval);\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attr : access pthread_attr_t) return int;\n-   pragma Inline (pthread_attr_init);\n-\n-   function pthread_attr_destroy (attr : access pthread_attr_t) return int;\n-   pragma Inline (pthread_attr_destroy);\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Inline (pthread_attr_setdetachstate);\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Inline (pthread_attr_setstacksize);\n-\n-   function pthread_attr_setname_np\n-     (attr : access pthread_attr_t;\n-      name : System.Address) return int;\n-   --  In VxWorks tasks, we have a non-portable routine to set the\n-   --  task name. This makes it really convenient for debugging.\n-   pragma Inline (pthread_attr_setname_np);\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attr          : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Inline (pthread_create);\n-\n-   function pthread_detach (thread : pthread_t) return int;\n-   pragma Inline (pthread_detach);\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Inline (pthread_exit);\n-\n-   function pthread_self return pthread_t;\n-   pragma Inline (pthread_self);\n-\n-   function pthread_equal (t1 : pthread_t; t2 : pthread_t) return int;\n-   pragma Inline (pthread_equal);\n-   --  be careful not to use \"=\" on thread_t!\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Inline (pthread_setspecific);\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Inline (pthread_getspecific);\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Inline (pthread_key_create);\n-\n-   --  VxWorks binary semaphores. These are exported for use by the\n-   --  implementation of hardware interrupt handling.\n+   --  Option flags for taskSpawn\n+\n+   VX_UNBREAKABLE    : constant := 16#0002#;\n+   VX_FP_TASK        : constant := 16#0008#;\n+   VX_FP_PRIVATE_ENV : constant := 16#0080#;\n+   VX_NO_STACK_FILL  : constant := 16#0100#;\n+\n+   function taskSpawn\n+     (name          : System.Address;  --  Pointer to task name\n+      priority      : int;\n+      options       : int;\n+      stacksize     : size_t;\n+      start_routine : System.Address;\n+      arg1          : System.Address;\n+      arg2          : int := 0;\n+      arg3          : int := 0;\n+      arg4          : int := 0;\n+      arg5          : int := 0;\n+      arg6          : int := 0;\n+      arg7          : int := 0;\n+      arg8          : int := 0;\n+      arg9          : int := 0;\n+      arg10         : int := 0) return t_id;\n+   pragma Import (C, taskSpawn, \"taskSpawn\");\n+\n+   procedure taskDelete (tid : t_id);\n+   pragma Import (C, taskDelete, \"taskDelete\");\n+\n+   function kernelTimeSlice (ticks : int) return int;\n+   pragma Import (C, kernelTimeSlice, \"kernelTimeSlice\");\n+\n+   function taskPrioritySet\n+     (tid : t_id; newPriority : int) return int;\n+   pragma Import (C, taskPrioritySet, \"taskPrioritySet\");\n \n    subtype STATUS is int;\n    --  Equivalent of the C type STATUS\n \n    OK    : constant STATUS := 0;\n-   ERROR : constant STATUS := Interfaces.C.\"-\" (1);\n+   ERROR : constant STATUS := Interfaces.C.int (-1);\n \n    --  Semaphore creation flags.\n \n@@ -462,7 +302,7 @@ package System.OS_Interface is\n    SEM_DELETE_SAFE    : constant := 4;  -- only valid for binary semaphore\n    SEM_INVERSION_SAFE : constant := 8;  -- only valid for binary semaphore\n \n-   --  Semaphore initial state flags;\n+   --  Semaphore initial state flags\n \n    SEM_EMPTY : constant := 0;\n    SEM_FULL  : constant := 1;\n@@ -472,36 +312,57 @@ package System.OS_Interface is\n    WAIT_FOREVER : constant := -1;\n    NO_WAIT      : constant := 0;\n \n-   type SEM_ID is new long;\n-   --  The VxWorks semaphore ID is an integer which is really just\n-   --  a pointer to a semaphore structure.\n-\n-   function semBCreate (Options : int; Initial_State : int) return SEM_ID;\n-   --  Create a binary semaphore.  Returns ID, or 0 if memory could not\n-   --  be allocated\n+   --  Error codes (errno).  The lower level 16 bits are the\n+   --  error code, with the upper 16 bits representing the\n+   --  module number in which the error occurred.  By convention,\n+   --  the module number is 0 for UNIX errors.  VxWorks reserves\n+   --  module numbers 1-500, with the remaining module numbers\n+   --  being available for user applications.\n+\n+   M_objLib                 : constant := 61 * 2**16;\n+   --  semTake() failure with ticks = NO_WAIT\n+   S_objLib_OBJ_UNAVAILABLE : constant := M_objLib + 2;\n+   --  semTake() timeout with ticks > NO_WAIT\n+   S_objLib_OBJ_TIMEOUT     : constant := M_objLib + 4;\n+\n+   type SEM_ID is new System.Address;\n+   --  typedef struct semaphore *SEM_ID;\n+\n+   --  We use two different kinds of VxWorks semaphores: mutex\n+   --  and binary semaphores.  A null ID is returned when\n+   --  a semaphore cannot be created.\n+\n+   function semBCreate (options : int; initial_state : int) return SEM_ID;\n+   --  Create a binary semaphore. Return ID, or 0 if memory could not\n+   --  be allocated.\n    pragma Import (C, semBCreate, \"semBCreate\");\n \n-   function semTake (SemID : SEM_ID; Timeout : int) return STATUS;\n+   function semMCreate (options : int) return SEM_ID;\n+   pragma Import (C, semMCreate, \"semMCreate\");\n+\n+   function semDelete (Sem : SEM_ID) return int;\n+   --  Delete a semaphore\n+   pragma Import (C, semDelete, \"semDelete\");\n+\n+   function semGive (Sem : SEM_ID) return int;\n+   pragma Import (C, semGive, \"semGive\");\n+\n+   function semTake (Sem : SEM_ID; timeout : int) return int;\n    --  Attempt to take binary semaphore.  Error is returned if operation\n    --  times out\n    pragma Import (C, semTake, \"semTake\");\n \n-   function semGive (SemID : SEM_ID) return STATUS;\n-   --  Release one thread blocked on the semaphore\n-   pragma Import (C, semGive, \"semGive\");\n-\n    function semFlush (SemID : SEM_ID) return STATUS;\n    --  Release all threads blocked on the semaphore\n    pragma Import (C, semFlush, \"semFlush\");\n \n-   function semDelete (SemID : SEM_ID) return STATUS;\n-   --  Delete a semaphore\n-   pragma Import (C, semDelete, \"semDelete\");\n+   function taskLock return int;\n+   pragma Import (C, taskLock, \"taskLock\");\n \n+   function taskUnlock return int;\n+   pragma Import (C, taskUnlock, \"taskUnlock\");\n \n private\n-   --  This interface assumes that \"unsigned\" and \"int\" are 32-bit entities.\n-\n    type sigset_t is new long;\n \n    type pid_t is new int;\n@@ -511,49 +372,4 @@ private\n    type clockid_t is new int;\n    CLOCK_REALTIME : constant clockid_t := 0;\n \n-   --  Priority ceilings are now implemented in the body of\n-   --  this package.\n-\n-   type pthread_mutexattr_t is record\n-      Flags        : int;   --  mutex semaphore creation flags\n-      Prio_Ceiling : int;   --  priority ceiling\n-      Protocol     : int;\n-   end record;\n-\n-   type pthread_mutex_t is record\n-      Mutex        : SEM_ID;\n-      Protocol     : int;\n-      Prio_Ceiling : int;  --  priority ceiling of lock\n-   end record;\n-\n-   type pthread_condattr_t is record\n-      Flags : int;\n-   end record;\n-\n-   type pthread_cond_t is record\n-      Sem     : SEM_ID;   --  VxWorks semaphore ID\n-      Waiting : Integer;  --  Number of queued tasks waiting\n-   end record;\n-\n-   type pthread_attr_t is record\n-      Stacksize   : size_t;\n-      Detachstate : int;\n-      Priority    : int;\n-      Taskname    : System.Address;\n-   end record;\n-\n-   type pthread_t is new long;\n-\n-   null_pthread : constant pthread_t := 0;\n-\n-   type pthread_key_t is new int;\n-\n-   --  These are to store the pthread_keys that are created with\n-   --  pthread_key_create.  Currently, we only need one key.\n-\n-   Key_Storage  : array (1 .. 10) of aliased System.Address;\n-   Keys_Created : Integer;\n-\n-   Time_Slice : int;\n-\n end System.OS_Interface;"}, {"sha": "e515df183540c3669b1a3854bf19151db7d446fe", "filename": "gcc/ada/5zparame.ads", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5zparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2F5zparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zparame.ads?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514", "patch": "@@ -1,135 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                            $Revision: 1.13 $\n---                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VxWorks/68k version of this package\n-\n---  This package defines some system dependent parameters for GNAT. These\n---  are values that are referenced by the runtime library and are therefore\n---  relevant to the target machine.\n-\n---  The parameters whose value is defined in the spec are not generally\n---  expected to be changed. If they are changed, it will be necessary to\n---  recompile the run-time library.\n-\n---  The parameters which are defined by functions can be changed by modifying\n---  the body of System.Parameters in file s-parame.adb. A change to this body\n---  requires only rebinding and relinking of the application.\n-\n---  Note: do not introduce any pragma Inline statements into this unit, since\n---  otherwise the relinking and rebinding capability would be deactivated.\n-\n-package System.Parameters is\n-pragma Pure (Parameters);\n-\n-   ---------------------------------------\n-   -- Task And Stack Allocation Control --\n-   ---------------------------------------\n-\n-   type Task_Storage_Size is new Integer;\n-   --  Type used in tasking units for task storage size\n-\n-   type Size_Type is new Task_Storage_Size;\n-   --  Type used to provide task storage size to runtime\n-\n-   Unspecified_Size : constant Size_Type := Size_Type'First;\n-   --  Value used to indicate that no size type is set\n-\n-   subtype Ratio is Size_Type range -1 .. 100;\n-   Dynamic : constant Size_Type := -1;\n-   --  Secondary_Stack_Ratio is a constant between 0 and 100 wich\n-   --  determines the percentage of the allocate task stack that is\n-   --  used by the secondary stack (the rest being the primary stack).\n-   --  The special value of minus one indicates that the secondary\n-   --  stack is to be allocated from the heap instead.\n-\n-   Sec_Stack_Ratio : constant Ratio := -1;\n-   --  This constant defines the handling of the secondary stack\n-\n-   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Ratio = Dynamic;\n-   --  Convenient Boolean for testing for dynmaic secondary stack\n-\n-   function Default_Stack_Size return Size_Type;\n-   --  Default task stack size used if none is specified\n-\n-   function Minimum_Stack_Size return Size_Type;\n-   --  Minimum task stack size permitted\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n-   --  Given the storage size stored in the TCB, return the Storage_Size\n-   --  value required by the RM for the Storage_Size attribute. The\n-   --  required adjustment is as follows:\n-   --\n-   --    when Size = Unspecified_Size, return Default_Stack_Size\n-   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n-   --    otherwise return given Size\n-\n-   Stack_Grows_Down  : constant Boolean := True;\n-   --  This constant indicates whether the stack grows up (False) or\n-   --  down (True) in memory as functions are called. It is used for\n-   --  proper implementation of the stack overflow check.\n-\n-   ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n-   ----------------------------------------------\n-\n-   long_bits : constant := Long_Integer'Size;\n-   --  Number of bits in type long and unsigned_long. The normal convention\n-   --  is that this is the same as type Long_Integer, but this is not true\n-   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n-\n-   ----------------------------------------------\n-   -- Behavior of Pragma Finalize_Storage_Only --\n-   ----------------------------------------------\n-\n-   --  Garbage_Collected is a Boolean constant whose value indicates the\n-   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n-\n-   --    Garbage_Collected = False\n-\n-   --      The system releases all storage on program termination only,\n-   --      but not other garbage collection occurs, so finalization calls\n-   --      are ommitted only for outer level onjects can be omitted if\n-   --      pragma Finalize_Storage_Only is used.\n-\n-   --    Garbage_Collected = True\n-\n-   --      The system provides full garbage collection, so it is never\n-   --      necessary to release storage for controlled objects for which\n-   --      a pragma Finalize_Storage_Only is used.\n-\n-   Garbage_Collected : constant Boolean := False;\n-   --  The storage mode for this system (release on program exit)\n-\n-end System.Parameters;"}, {"sha": "341b60dce313f10237c867e89c646ce7de99af96", "filename": "gcc/ada/5zsystem.ads", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5zsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zsystem.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -5,11 +5,11 @@\n --                               S Y S T E M                                --\n --                                                                          --\n --                                 S p e c                                  --\n---                       (VXWORKS Version Alpha, Mips)                      --\n+--                         (VXWORKS Version Alpha)                          --\n --                                                                          --\n---                            $Revision: 1.14 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -60,16 +60,16 @@ pragma Pure (System);\n    Max_Mantissa          : constant := 63;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n-   Tick                  : constant := Standard'Tick;\n+   Tick                  : constant := 1.0;\n \n    --  Storage-related Declarations\n \n    type Address is private;\n    Null_Address : constant Address;\n \n-   Storage_Unit : constant := Standard'Storage_Unit;\n-   Word_Size    : constant := Standard'Word_Size;\n-   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 64;\n+   Memory_Size  : constant := 2 ** 64;\n \n    --  Address comparison\n \n@@ -88,40 +88,26 @@ pragma Pure (System);\n    --  Other System-Dependent Declarations\n \n    type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order :=\n-                         Bit_Order'Val (Standard'Default_Bit_Order);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n \n    --  Priority-related Declarations (RM D.1)\n \n-   --  256 is reserved for the VxWorks kernel\n-   --  248 - 255 correspond to hardware interrupt levels 0 .. 7\n-   --  247 is a catchall default \"interrupt\" priority for signals, allowing\n-   --  higher priority than normal tasks, but lower than hardware\n-   --  priority levels.  Protected Object ceilings can override\n-   --  these values\n-   --  246 is used by the Interrupt_Manager task\n-\n-   Max_Priority : constant Positive := 245;\n+   --  256        is reserved for the VxWorks kernel\n+   --  248 - 255  correspond to hardware interrupt levels 0 .. 7\n+   --  247        is a catchall default \"interrupt\" priority for signals,\n+   --             allowing higher priority than normal tasks, but lower than\n+   --             hardware priority levels.  Protected Object ceilings can\n+   --             override these values.\n+   --  246        is used by the Interrupt_Manager task\n \n+   Max_Priority           : constant Positive := 245;\n    Max_Interrupt_Priority : constant Positive := 255;\n \n-   subtype Any_Priority is Integer\n-     range 0 .. Standard'Max_Interrupt_Priority;\n-\n-   subtype Priority is Any_Priority\n-     range 0 .. Standard'Max_Priority;\n-\n-   --  Functional notation is needed in the following to avoid visibility\n-   --  problems when this package is compiled through rtsfind in the middle\n-   --  of another compilation.\n+   subtype Any_Priority       is Integer      range   0 .. 255;\n+   subtype Priority           is Any_Priority range   0 .. 245;\n+   subtype Interrupt_Priority is Any_Priority range 246 .. 255;\n \n-   subtype Interrupt_Priority is Any_Priority\n-     range\n-       Standard.\"+\" (Standard'Max_Priority,  1) ..\n-         Standard'Max_Interrupt_Priority;\n-\n-   Default_Priority : constant Priority :=\n-     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+   Default_Priority : constant Priority := 122;\n \n private\n \n@@ -139,19 +125,22 @@ private\n    --  of the individual switch values.\n \n    AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n    Command_Line_Args         : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := True;\n-   Stack_Check_Probes        : constant Boolean := False;\n-   Stack_Check_Default       : constant Boolean := False;\n    Denorm                    : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := False;\n+   High_Integrity_Mode       : constant Boolean := False;\n    Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n    OpenVMS                   : constant Boolean := False;\n    Signed_Zeros              : constant Boolean := True;\n-   Long_Shifts_Inlined       : constant Boolean := False;\n-   High_Integrity_Mode       : constant Boolean := False;\n-   Functions_Return_By_DSP   : constant Boolean := False;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := True;\n    ZCX_By_Default            : constant Boolean := False;\n    GCC_ZCX_Support           : constant Boolean := False;\n    Front_End_ZCX_Support     : constant Boolean := False;"}, {"sha": "6dacbd3b7c2033e39f749c6e30dcb90699173fe5", "filename": "gcc/ada/5ztaprop.adb", "status": "modified", "additions": 378, "deletions": 397, "changes": 775, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ztaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F5ztaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ztaprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.2 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -46,10 +45,6 @@ pragma Polling (Off);\n with System.Tasking.Debug;\n --  used for Known_Tasks\n \n-with Interfaces.C;\n---  used for int\n---           size_t\n-\n with System.Interrupt_Management;\n --  used for Keep_Unmasked\n --           Abort_Task_Interrupt\n@@ -78,11 +73,7 @@ with System.Tasking;\n with System.Task_Info;\n --  used for Task_Image\n \n-with System.OS_Primitives;\n---  used for Delay_Modes\n-\n-with System.VxWorks;\n---  used for TASK_DESC\n+with Interfaces.C;\n \n with Unchecked_Conversion;\n with Unchecked_Deallocation;\n@@ -92,25 +83,31 @@ package body System.Task_Primitives.Operations is\n    use System.Tasking.Debug;\n    use System.Tasking;\n    use System.Task_Info;\n-   use Interfaces.C;\n    use System.OS_Interface;\n    use System.Parameters;\n-   use System.OS_Primitives;\n+   use type Interfaces.C.int;\n \n    package SSL renames System.Soft_Links;\n \n-   ------------------\n-   --  Local Data  --\n-   ------------------\n+   subtype int is System.OS_Interface.int;\n+\n+   Relative : constant := 0;\n+\n+   ----------------\n+   -- Local Data --\n+   ----------------\n \n    --  The followings are logically constants, but need to be initialized\n    --  at run time.\n \n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a VxWorks task.\n+   Current_Task : aliased Task_ID;\n+   pragma Export (Ada, Current_Task);\n+   --  Task specific value used to store the Ada Task_ID.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -132,19 +129,14 @@ package body System.Task_Primitives.Operations is\n    FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n    --  Indicates whether FIFO_Within_Priorities is set.\n \n-   Mutex_Protocol : Interfaces.C.int;\n-\n-   Stack_Limit : aliased System.Address;\n-   pragma Import (C, Stack_Limit, \"__gnat_stack_limit\");\n+   Mutex_Protocol : Priority_Type;\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    procedure Abort_Handler (signo : Signal);\n \n-   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n-\n    function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n \n    -------------------\n@@ -153,13 +145,13 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (signo : Signal) is\n       Self_ID : constant Task_ID := Self;\n-      Result  : Interfaces.C.int;\n+      Result  : int;\n       Old_Set : aliased sigset_t;\n \n    begin\n       if Self_ID.Deferral_Level = 0\n-        and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level and then\n-        not Self_ID.Aborting\n+        and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+        and then not Self_ID.Aborting\n       then\n          Self_ID.Aborting := True;\n \n@@ -178,17 +170,9 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n-      Task_Descriptor : aliased System.VxWorks.TASK_DESC;\n-      Result          : Interfaces.C.int;\n-\n    begin\n-      if On then\n-         Result := taskInfoGet (T.Common.LL.Thread,\n-           Task_Descriptor'Unchecked_Access);\n-         pragma Assert (Result = 0);\n-\n-         Stack_Limit := Task_Descriptor.td_pStackLimit;\n-      end if;\n+      --  Nothing needed.\n+      null;\n    end Stack_Guard;\n \n    -------------------\n@@ -205,26 +189,23 @@ package body System.Task_Primitives.Operations is\n    ----------\n \n    function Self return Task_ID is\n-      Result : System.Address;\n-\n    begin\n-      Result := pthread_getspecific (ATCB_Key);\n-      pragma Assert (Result /= System.Null_Address);\n-      return To_Task_ID (Result);\n+      pragma Assert (Current_Task /= null);\n+      return Current_Task;\n    end Self;\n \n    -----------------------------\n    -- Install_Signal_Handlers --\n    -----------------------------\n \n    procedure Install_Signal_Handlers;\n-   pragma Inline (Install_Signal_Handlers);\n+   --  Install the default signal handlers for the current task.\n \n    procedure Install_Signal_Handlers is\n       act       : aliased struct_sigaction;\n       old_act   : aliased struct_sigaction;\n       Tmp_Set   : aliased sigset_t;\n-      Result    : Interfaces.C.int;\n+      Result    : int;\n \n    begin\n       act.sa_flags := 0;\n@@ -248,95 +229,37 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore rasing Storage_Error in the following routines\n-   --        should be able to be handled safely.\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : access Lock)\n-   is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n+   procedure Initialize_Lock (Prio : System.Any_Priority; L : access Lock) is\n    begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_setprotocol\n-        (Attributes'Access, Mutex_Protocol);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutexattr_setprioceiling\n-         (Attributes'Access, Interfaces.C.int (Prio));\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n+      L.Mutex := semMCreate (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n+      L.Prio_Ceiling := int (Prio);\n+      L.Protocol := Mutex_Protocol;\n+      pragma Assert (L.Mutex /= 0);\n    end Initialize_Lock;\n \n    procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_setprotocol\n-        (Attributes'Access, Mutex_Protocol);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutexattr_setprioceiling\n-        (Attributes'Access,\n-         Interfaces.C.int (System.Any_Priority'Last));\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n+      L.Mutex := semMCreate (SEM_Q_PRIORITY + SEM_INVERSION_SAFE);\n+      L.Prio_Ceiling := int (System.Any_Priority'Last);\n+      L.Protocol := Mutex_Protocol;\n+      pragma Assert (L.Mutex /= 0);\n    end Initialize_Lock;\n \n    -------------------\n    -- Finalize_Lock --\n    -------------------\n \n    procedure Finalize_Lock (L : access Lock) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_mutex_destroy (L);\n+      Result := semDelete (L.Mutex);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_mutex_destroy (L);\n+      Result := semDelete (L.Mutex);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n@@ -345,31 +268,39 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Result     : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_mutex_lock (L);\n-\n-      --  Assume that the cause of EINVAL is a priority ceiling violation\n+      if L.Protocol = Prio_Protect\n+        and then int (Self.Common.Current_Priority) > L.Prio_Ceiling\n+      then\n+         Ceiling_Violation := True;\n+         return;\n+      else\n+         Ceiling_Violation := False;\n+      end if;\n \n-      Ceiling_Violation := (Result = EINVAL);\n-      pragma Assert (Result = 0 or else Result = EINVAL);\n+      Result := semTake (L.Mutex, WAIT_FOREVER);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n+      Result : int;\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := semTake (L.Mutex, WAIT_FOREVER);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := semTake (T.Common.LL.L.Mutex, WAIT_FOREVER);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -386,45 +317,82 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Unlock (L : access Lock) is\n-      Result  : Interfaces.C.int;\n-\n+      Result  : int;\n    begin\n-      Result := pthread_mutex_unlock (L);\n+      Result := semGive (L.Mutex);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n+      Result : int;\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := semGive (L.Mutex);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := semGive (T.Common.LL.L.Mutex);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n-\n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n-      Result : Interfaces.C.int;\n+   -----------\n+   -- Sleep --\n+   -----------\n \n+   procedure Sleep (Self_ID : Task_ID; Reason : System.Tasking.Task_States) is\n+      Result : int;\n    begin\n       pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n \n-      --  EINTR is not considered a failure.\n+      --  Disable task scheduling.\n+\n+      Result := taskLock;\n+\n+      --  Release the mutex before sleeping.\n+\n+      if Single_Lock then\n+         Result := semGive (Single_RTS_Lock.Mutex);\n+      else\n+         Result := semGive (Self_ID.Common.LL.L.Mutex);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+\n+      --  Indicate that there is another thread waiting on the CV.\n+\n+      Self_ID.Common.LL.CV.Waiting := Self_ID.Common.LL.CV.Waiting + 1;\n+\n+      --  Perform a blocking operation to take the CV semaphore.\n+      --  Note that a blocking operation in VxWorks will reenable\n+      --  task scheduling. When we are no longer blocked and control\n+      --  is returned, task scheduling will again be disabled.\n+\n+      Result := semTake (Self_ID.Common.LL.CV.Sem, WAIT_FOREVER);\n+\n+      if Result /= 0 then\n+         Self_ID.Common.LL.CV.Waiting := Self_ID.Common.LL.CV.Waiting - 1;\n+         pragma Assert (False);\n+      end if;\n+\n+      --  Take the mutex back.\n+\n+      if Single_Lock then\n+         Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n+      else\n+         Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+\n+      --  Reenable task scheduling.\n \n-      pragma Assert (Result = 0 or else Result = EINTR);\n+      Result := taskUnlock;\n    end Sleep;\n \n    -----------------\n@@ -443,42 +411,78 @@ package body System.Task_Primitives.Operations is\n       Timedout : out Boolean;\n       Yielded  : out Boolean)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n+      Ticks  : int;\n+      Result : int;\n \n    begin\n       Timedout := True;\n-      Yielded := False;\n+      Yielded := True;\n \n       if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+         --  Systematically add one since the first tick will delay\n+         --  *at most* 1 / Rate_Duration seconds, so we need to add one to\n+         --  be on the safe side.\n+\n+         Ticks := To_Clock_Ticks (Time) + 1;\n       else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+         Ticks := To_Clock_Ticks (Time - Monotonic_Clock);\n       end if;\n \n-      if Abs_Time > Check_Time then\n-         Request := To_Timespec (Abs_Time);\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-              or else Self_ID.Pending_Priority_Change;\n+      if Ticks > 0 then\n+         --  Disable task scheduling.\n+\n+         Result := taskLock;\n+\n+         --  Release the mutex before sleeping.\n+\n+         if Single_Lock then\n+            Result := semGive (Single_RTS_Lock.Mutex);\n+         else\n+            Result := semGive (Self_ID.Common.LL.L.Mutex);\n+         end if;\n+\n+         pragma Assert (Result = 0);\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n-            Yielded := True;\n-            exit when Abs_Time <= Monotonic_Clock;\n+         --  Indicate that there is another thread waiting on the CV.\n \n-            if Result = 0 or Result = EINTR then\n+         Self_ID.Common.LL.CV.Waiting := Self_ID.Common.LL.CV.Waiting + 1;\n \n-               --  Somebody may have called Wakeup for us\n+         --  Perform a blocking operation to take the CV semaphore.\n+         --  Note that a blocking operation in VxWorks will reenable\n+         --  task scheduling. When we are no longer blocked and control\n+         --  is returned, task scheduling will again be disabled.\n \n+         Result := semTake (Self_ID.Common.LL.CV.Sem, Ticks);\n+\n+         if Result = 0 then\n+            --  Somebody may have called Wakeup for us\n+\n+            Timedout := False;\n+\n+         else\n+            Self_ID.Common.LL.CV.Waiting := Self_ID.Common.LL.CV.Waiting - 1;\n+\n+            if errno /= S_objLib_OBJ_TIMEOUT then\n                Timedout := False;\n-               exit;\n             end if;\n+         end if;\n \n-            pragma Assert (Result = ETIMEDOUT);\n-         end loop;\n+         --  Take the mutex back.\n+\n+         if Single_Lock then\n+            Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n+         else\n+            Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n+         end if;\n+\n+         pragma Assert (Result = 0);\n+\n+         --  Reenable task scheduling.\n+\n+         Result := taskUnlock;\n+\n+      else\n+         taskDelay (0);\n       end if;\n    end Timed_Sleep;\n \n@@ -487,36 +491,48 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    --  This is for use in implementing delay statements, so\n-   --  we assume the caller is abort-deferred but is holding\n-   --  no locks.\n+   --  we assume the caller is holding no locks.\n \n    procedure Timed_Delay\n      (Self_ID  : Task_ID;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n-      Check_Time : constant Duration := Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n-      Yielded    : Boolean := False;\n+      Orig     : constant Duration := Monotonic_Clock;\n+      Absolute : Duration;\n+      Ticks    : int;\n+      Timedout : Boolean;\n+      Result   : int;\n+\n    begin\n+      SSL.Abort_Defer.all;\n \n-      --  Only the little window between deferring abort and\n-      --  locking Self_ID is the reason we need to\n-      --  check for pending abort and priority change below! :(\n+      if Single_Lock then\n+         Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n+      else\n+         Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n+      end if;\n \n-      SSL.Abort_Defer.all;\n-      Write_Lock (Self_ID);\n+      pragma Assert (Result = 0);\n \n       if Mode = Relative then\n-         Abs_Time := Time + Check_Time;\n+         Absolute := Orig + Time;\n+\n+         Ticks := To_Clock_Ticks (Time);\n+\n+         if Ticks > 0 then\n+            --  The first tick will delay anytime between 0 and\n+            --  1 / sysClkRateGet seconds, so we need to add one to\n+            --  be on the safe side.\n+\n+            Ticks := Ticks + 1;\n+         end if;\n       else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+         Absolute := Time;\n+         Ticks    := To_Clock_Ticks (Time - Orig);\n       end if;\n \n-      if Abs_Time > Check_Time then\n-         Request := To_Timespec (Abs_Time);\n+      if Ticks > 0 then\n          Self_ID.Common.State := Delay_Sleep;\n \n          loop\n@@ -528,24 +544,61 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n-            Yielded := True;\n-            exit when Abs_Time <= Monotonic_Clock;\n+            Timedout := False;\n+            Result := taskLock;\n+\n+            if Single_Lock then\n+               Result := semGive (Single_RTS_Lock.Mutex);\n+            else\n+               Result := semGive (Self_ID.Common.LL.L.Mutex);\n+            end if;\n+\n+            pragma Assert (Result = 0);\n+\n+            --  Indicate that there is another thread waiting on the CV.\n+\n+            Self_ID.Common.LL.CV.Waiting := Self_ID.Common.LL.CV.Waiting + 1;\n+\n+            Result := semTake (Self_ID.Common.LL.CV.Sem, Ticks);\n+\n+            if Result /= 0 then\n+               Self_ID.Common.LL.CV.Waiting :=\n+                 Self_ID.Common.LL.CV.Waiting - 1;\n+\n+               if errno = S_objLib_OBJ_TIMEOUT then\n+                  Timedout := True;\n+               else\n+                  Ticks := To_Clock_Ticks (Absolute - Monotonic_Clock);\n+               end if;\n+            end if;\n+\n+            if Single_Lock then\n+               Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n+            else\n+               Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n+            end if;\n+\n+            pragma Assert (Result = 0);\n \n-            pragma Assert (Result = 0\n-                             or else Result = ETIMEDOUT\n-                             or else Result = EINTR);\n+            --  Reenable task scheduling.\n+\n+            Result := taskUnlock;\n+\n+            exit when Timedout;\n          end loop;\n \n          Self_ID.Common.State := Runnable;\n+      else\n+         taskDelay (0);\n       end if;\n \n-      Unlock (Self_ID);\n-\n-      if not Yielded then\n-         Result := sched_yield;\n+      if Single_Lock then\n+         Result := semGive (Single_RTS_Lock.Mutex);\n+      else\n+         Result := semGive (Self_ID.Common.LL.L.Mutex);\n       end if;\n+\n+      pragma Assert (Result = 0);\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n \n@@ -555,7 +608,8 @@ package body System.Task_Primitives.Operations is\n \n    function Monotonic_Clock return Duration is\n       TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n+      Result : int;\n+\n    begin\n       Result := clock_gettime (CLOCK_REALTIME, TS'Unchecked_Access);\n       pragma Assert (Result = 0);\n@@ -576,22 +630,40 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n+      --  Disable task scheduling.\n+\n+      Result := taskLock;\n+\n+      --  Iff someone is currently waiting on the condition variable\n+      --  then release the semaphore; we don't want to leave the\n+      --  semaphore in the full state because the next guy to do\n+      --  a condition wait operation would not block.\n+\n+      if T.Common.LL.CV.Waiting > 0 then\n+         Result := semGive (T.Common.LL.CV.Sem);\n+\n+         --  One less thread waiting on the CV.\n+\n+         T.Common.LL.CV.Waiting := T.Common.LL.CV.Waiting - 1;\n+\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      --  Reenable task scheduling.\n+\n+      Result := taskUnlock;\n    end Wakeup;\n \n    -----------\n    -- Yield --\n    -----------\n \n    procedure Yield (Do_Yield : Boolean := True) is\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n-      Result := sched_yield;\n+      Result := taskDelay (0);\n    end Yield;\n \n    ------------------\n@@ -613,25 +685,15 @@ package body System.Task_Primitives.Operations is\n       Prio : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n-      Param      : aliased struct_sched_param;\n       Array_Item : Integer;\n-      Result     : Interfaces.C.int;\n+      Result     : int;\n \n    begin\n-      Param.sched_priority := Interfaces.C.int (Prio);\n-\n-      if Time_Slice_Val <= 0 then\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n-      else\n-         Result := pthread_setschedparam\n-           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n-      end if;\n-\n+      Result := taskPrioritySet\n+        (T.Common.LL.Thread, To_VxWorks_Priority (int (Prio)));\n       pragma Assert (Result = 0);\n \n       if FIFO_Within_Priorities then\n-\n          --  Annex D requirement [RM D.2.2 par. 9]:\n          --    If the task drops its priority due to the loss of inherited\n          --    priority, it is added at the head of the ready queue for its\n@@ -676,18 +738,16 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Enter_Task (Self_ID : Task_ID) is\n-      Result  : Interfaces.C.int;\n+      Result : int;\n \n       procedure Init_Float;\n       pragma Import (C, Init_Float, \"__gnat_init_float\");\n       --  Properly initializes the FPU for PPC/MIPS systems.\n \n    begin\n-      Self_ID.Common.LL.Thread := pthread_self;\n-\n-      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n-      pragma Assert (Result = 0);\n-\n+      Self_ID.Common.LL.Thread := taskIdSelf;\n+      Result := taskVarAdd (0, Current_Task'Address);\n+      Current_Task := Self_ID;\n       Init_Float;\n \n       --  Install the signal handlers.\n@@ -696,17 +756,17 @@ package body System.Task_Primitives.Operations is\n \n       Install_Signal_Handlers;\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n-      for T in Known_Tasks'Range loop\n-         if Known_Tasks (T) = null then\n-            Known_Tasks (T) := Self_ID;\n-            Self_ID.Known_Tasks_Index := T;\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -718,70 +778,25 @@ package body System.Task_Primitives.Operations is\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n \n-   ----------------------\n-   --  Initialize_TCB  --\n-   ----------------------\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-      Cond_Attr : aliased pthread_condattr_t;\n-\n    begin\n-      Self_ID.Common.LL.Thread := null_pthread;\n-\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      Self_ID.Common.LL.CV.Sem := semBCreate (SEM_Q_PRIORITY, SEM_EMPTY);\n+      Self_ID.Common.LL.CV.Waiting := 0;\n+      Self_ID.Common.LL.Thread := 0;\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_mutexattr_setprotocol\n-        (Mutex_Attr'Access, Mutex_Protocol);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutexattr_setprioceiling\n-        (Mutex_Attr'Access, Interfaces.C.int (System.Any_Priority'Last));\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n+      if Self_ID.Common.LL.CV.Sem = 0 then\n          Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = 0 then\n-         Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-      end if;\n+         Succeeded := True;\n \n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+         end if;\n+      end if;\n    end Initialize_TCB;\n \n    -----------------\n@@ -797,22 +812,17 @@ package body System.Task_Primitives.Operations is\n    is\n       use type System.Task_Info.Task_Image_Type;\n \n-      Adjusted_Stack_Size : Interfaces.C.size_t;\n-      Attributes          : aliased pthread_attr_t;\n-      Result              : Interfaces.C.int;\n-\n-      function Thread_Body_Access is new\n-        Unchecked_Conversion (System.Address, Thread_Body);\n+      Adjusted_Stack_Size : size_t;\n \n    begin\n       if Stack_Size = Unspecified_Size then\n-         Adjusted_Stack_Size := Interfaces.C.size_t (Default_Stack_Size);\n+         Adjusted_Stack_Size := size_t (Default_Stack_Size);\n \n       elsif Stack_Size < Minimum_Stack_Size then\n-         Adjusted_Stack_Size := Interfaces.C.size_t (Minimum_Stack_Size);\n+         Adjusted_Stack_Size := size_t (Minimum_Stack_Size);\n \n       else\n-         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+         Adjusted_Stack_Size := size_t (Stack_Size);\n       end if;\n \n       --  Ask for 4 extra bytes of stack space so that the ATCB\n@@ -821,7 +831,7 @@ package body System.Task_Primitives.Operations is\n       --  gets the amount of stack requested exclusive of the needs\n       --  of the runtime.\n       --\n-      --  We also have to allocate 10 more bytes for the task name\n+      --  We also have to allocate n more bytes for the task name\n       --  storage and enough space for the Wind Task Control Block\n       --  which is around 0x778 bytes.  VxWorks also seems to carve out\n       --  additional space, so use 2048 as a nice round number.\n@@ -832,59 +842,43 @@ package body System.Task_Primitives.Operations is\n       --        set the task name to something appropriate.\n       Adjusted_Stack_Size := Adjusted_Stack_Size + 2048;\n \n-      Result := pthread_attr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_attr_setdetachstate\n-        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Adjusted_Stack_Size);\n-      pragma Assert (Result = 0);\n-\n-      --  Let's check to see if the task has an image string and\n-      --  use that as the VxWorks task name.\n-      if T.Common.Task_Image /= null then\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      if T.Common.Task_Image = null then\n+         T.Common.LL.Thread := taskSpawn\n+           (System.Null_Address,\n+            To_VxWorks_Priority (int (Priority)),\n+            VX_FP_TASK,\n+            Adjusted_Stack_Size,\n+            Wrapper,\n+            To_Address (T));\n+      else\n          declare\n-            Task_Name : aliased constant String :=\n-              T.Common.Task_Image.all & ASCII.NUL;\n+            Name : aliased String (1 .. T.Common.Task_Image'Length + 1);\n          begin\n-            Result := pthread_attr_setname_np\n-              (Attributes'Access, Task_Name'Address);\n-\n-            --  Since the initial signal mask of a thread is inherited from the\n-            --  creator, and the Environment task has all its signals masked,\n-            --  we do not need to manipulate caller's signal mask at this\n-            --  point. All tasks in RTS will have All_Tasks_Mask initially.\n-            Result := pthread_create\n-              (T.Common.LL.Thread'Access,\n-               Attributes'Access,\n-               Thread_Body_Access (Wrapper),\n+            Name (1 .. Name'Last - 1) := T.Common.Task_Image.all;\n+            Name (Name'Last) := ASCII.NUL;\n+\n+            T.Common.LL.Thread := taskSpawn\n+              (Name'Address,\n+               To_VxWorks_Priority (int (Priority)),\n+               VX_FP_TASK,\n+               Adjusted_Stack_Size,\n+               Wrapper,\n                To_Address (T));\n          end;\n-      else\n-         --  No specified task name\n-         Result := pthread_create\n-           (T.Common.LL.Thread'Access,\n-            Attributes'Access,\n-            Thread_Body_Access (Wrapper),\n-            To_Address (T));\n       end if;\n-      pragma Assert (Result = 0);\n \n-      Succeeded := Result = 0;\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n+      if T.Common.LL.Thread = -1 then\n+         Succeeded := False;\n+      else\n+         Succeeded := True;\n+      end if;\n \n       Task_Creation_Hook (T.Common.LL.Thread);\n-\n       Set_Priority (T, Priority);\n    end Create_Task;\n \n@@ -893,19 +887,21 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n+      Result : int;\n       Tmp    : Task_ID := T;\n \n       procedure Free is new\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      T.Common.LL.Thread := null_pthread;\n+      if Single_Lock then\n+         Result := semDelete (T.Common.LL.L.Mutex);\n+         pragma Assert (Result = 0);\n+      end if;\n \n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      T.Common.LL.Thread := 0;\n \n-      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      Result := semDelete (T.Common.LL.CV.Sem);\n       pragma Assert (Result = 0);\n \n       if T.Known_Tasks_Index /= -1 then\n@@ -922,15 +918,15 @@ package body System.Task_Primitives.Operations is\n    procedure Exit_Task is\n    begin\n       Task_Termination_Hook;\n-      pthread_exit (System.Null_Address);\n+      taskDelete (0);\n    end Exit_Task;\n \n    ----------------\n    -- Abort_Task --\n    ----------------\n \n    procedure Abort_Task (T : Task_ID) is\n-      Result : Interfaces.C.int;\n+      Result : int;\n    begin\n       Result := kill (T.Common.LL.Thread,\n         Signal (Interrupt_Management.Abort_Task_Interrupt));\n@@ -941,7 +937,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_Exit --\n    ----------------\n \n-   --  Dummy versions. The only currently working versions is for solaris\n+   --  Dummy versions. The only currently working version is for solaris\n    --  (native).\n \n    function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n@@ -967,23 +963,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -993,7 +989,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_ID;\n       Thread_Self : Thread_Id) return Boolean is\n    begin\n-      if T.Common.LL.Thread /= null_pthread\n+      if T.Common.LL.Thread /= 0\n         and then T.Common.LL.Thread /= Thread_Self\n       then\n          return taskSuspend (T.Common.LL.Thread) = 0;\n@@ -1010,7 +1006,7 @@ package body System.Task_Primitives.Operations is\n      (T           : ST.Task_ID;\n       Thread_Self : Thread_Id) return Boolean is\n    begin\n-      if T.Common.LL.Thread /= null_pthread\n+      if T.Common.LL.Thread /= 0\n         and then T.Common.LL.Thread /= Thread_Self\n       then\n          return taskResume (T.Common.LL.Thread) = 0;\n@@ -1029,45 +1025,30 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n       Enter_Task (Environment_Task);\n    end Initialize;\n \n begin\n    declare\n-      Result : Interfaces.C.int;\n-\n+      Result : int;\n    begin\n       if Locking_Policy = 'C' then\n-         Mutex_Protocol := PTHREAD_PRIO_PROTECT;\n+         Mutex_Protocol := Prio_Protect;\n+      elsif Locking_Policy = 'I' then\n+         Mutex_Protocol := Prio_Inherit;\n       else\n-         --  We default to VxWorks native priority inheritence\n-         --  and inversion safe mutexes with no ceiling checks.\n-         Mutex_Protocol := PTHREAD_PRIO_INHERIT;\n+         Mutex_Protocol := Prio_None;\n       end if;\n \n       if Time_Slice_Val > 0 then\n-         Result := pthread_sched_rr_set_interval\n-           (Interfaces.C.int (Time_Slice_Val));\n+         Result := kernelTimeSlice\n+           (To_Clock_Ticks\n+             (Duration (Time_Slice_Val) / Duration (1_000_000.0)));\n       end if;\n \n-      --  Prepare the set of signals that should unblocked in all tasks\n-\n       Result := sigemptyset (Unblocked_Signal_Mask'Access);\n       pragma Assert (Result = 0);\n-\n-      for J in Interrupt_Management.Interrupt_ID loop\n-         if Interrupt_Management.Keep_Unmasked (J) then\n-            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n-      Result := pthread_key_create (ATCB_Key'Access, null);\n-      pragma Assert (Result = 0);\n-\n-      Result := taskVarAdd (getpid, Stack_Limit'Access);\n-      pragma Assert (Result = 0);\n    end;\n end System.Task_Primitives.Operations;"}, {"sha": "33fcd32839c727a1206b3d85657d7a087a880067", "filename": "gcc/ada/6vcpp.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F6vcpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F6vcpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vcpp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n---            Copyright (C) 2000, Free Software Foundation, Inc.            --\n+--         Copyright (C) 2000-2002, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -76,13 +76,9 @@ package body Interfaces.CPP is\n    function To_Type_Specific_Data_Ptr is\n      new Unchecked_Conversion (Address, Type_Specific_Data_Ptr);\n \n-   function To_Address is new Unchecked_Conversion (Vtable_Ptr, Address);\n    function To_Address is\n      new Unchecked_Conversion (Type_Specific_Data_Ptr, Address);\n \n-   function To_Vtable_Ptr is new Unchecked_Conversion (Tag, Vtable_Ptr);\n-   function To_Tag is new Unchecked_Conversion (Vtable_Ptr, Tag);\n-\n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------"}, {"sha": "cc9e91bd1a341e7a084e9136e503bf4c51f4f987", "filename": "gcc/ada/6vcstrea.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F6vcstrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F6vcstrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vcstrea.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1996-1999 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,7 @@\n \n --  This is the Alpha/VMS version.\n \n+with Unchecked_Conversion;\n package body Interfaces.C_Streams is\n \n    ------------"}, {"sha": "b2dccbadb0542410b7800382925101337783c1cb", "filename": "gcc/ada/7sintman.adb", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7sintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7sintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sintman.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--             Copyright (C) 1991-2002, Florida State University            --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -189,13 +189,6 @@ begin\n       act.sa_mask := Signal_Mask;\n \n       Keep_Unmasked (Abort_Task_Interrupt) := True;\n-      Keep_Unmasked (SIGXCPU) := True;\n-      Keep_Unmasked (SIGFPE) := True;\n-      Result :=\n-        sigaction\n-        (Signal (SIGFPE), act'Unchecked_Access,\n-         old_act'Unchecked_Access);\n-      pragma Assert (Result = 0);\n \n       --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but at\n       --  the same time, disable the ability of handling this signal via\n@@ -208,18 +201,14 @@ begin\n          Keep_Unmasked (SIGINT) := True;\n       end if;\n \n-      for J in\n-        Exception_Interrupts'First + 1 .. Exception_Interrupts'Last\n-      loop\n+      for J in Exception_Interrupts'Range loop\n          Keep_Unmasked (Exception_Interrupts (J)) := True;\n \n-         if Unreserve_All_Interrupts = 0 then\n-            Result :=\n-              sigaction\n-              (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n-               old_act'Unchecked_Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result :=\n+           sigaction\n+           (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+            old_act'Unchecked_Access);\n+         pragma Assert (Result = 0);\n       end loop;\n \n       for J in Unmasked'Range loop"}, {"sha": "b34292d9d4fa3159839091ea8a1d53882f9df6ac", "filename": "gcc/ada/7staprop.adb", "status": "modified", "additions": 132, "deletions": 107, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7staprop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001, Florida State University            --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -101,15 +101,17 @@ package body System.Task_Primitives.Operations is\n \n    package SSL renames System.Soft_Links;\n \n-   ------------------\n-   --  Local Data  --\n-   ------------------\n+   ----------------\n+   -- Local Data --\n+   ----------------\n \n    --  The followings are logically constants, but need to be initialized\n    --  at run time.\n \n-   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n-   --  See comments on locking rules in System.Tasking (spec).\n+   Single_RTS_Lock : aliased RTS_Lock;\n+   --  This is a lock to allow only one thread of control in the RTS at\n+   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_ID : Task_ID;\n    --  A variable to hold Task_ID for the environment task.\n@@ -143,8 +145,7 @@ package body System.Task_Primitives.Operations is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Abort_Handler\n-     (Sig     : Signal);\n+   procedure Abort_Handler (Sig : Signal);\n \n    function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n \n@@ -252,15 +253,13 @@ package body System.Task_Primitives.Operations is\n       --    Context.PC := Raise_Abort_Signal'Address;\n       --    return;\n       --  end if;\n-\n    end Abort_Handler;\n \n-   -------------------\n-   --  Stack_Guard  --\n-   -------------------\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n \n    procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n-\n       Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n       Guard_Page_Address : Address;\n \n@@ -304,7 +303,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Note: mutexes and cond_variables needed per-task basis are\n    --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n    --        used in RTS is initialized before any status change of RTS.\n    --        Therefore rasing Storage_Error in the following routines\n    --        should be able to be handled safely.\n@@ -395,15 +394,13 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n    end Finalize_Lock;\n \n    procedure Finalize_Lock (L : access RTS_Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_destroy (L);\n       pragma Assert (Result = 0);\n@@ -415,7 +412,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_lock (L);\n \n@@ -425,20 +421,24 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Result = EINVAL);\n    end Write_Lock;\n \n-   procedure Write_Lock (L : access RTS_Lock) is\n+   procedure Write_Lock\n+     (L : access RTS_Lock; Global_Lock : Boolean := False)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_lock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Write_Lock;\n \n    ---------------\n@@ -456,40 +456,46 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_mutex_unlock (L);\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock (L : access RTS_Lock) is\n+   procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (L);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock or else Global_Lock then\n+         Result := pthread_mutex_unlock (L);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n-      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n    end Unlock;\n \n-   -------------\n-   --  Sleep  --\n-   -------------\n+   -----------\n+   -- Sleep --\n+   -----------\n \n-   procedure Sleep (Self_ID : Task_ID;\n-                    Reason   : System.Tasking.Task_States) is\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason   : System.Tasking.Task_States)\n+   is\n       Result : Interfaces.C.int;\n-\n    begin\n-      pragma Assert (Self_ID = Self);\n-      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n-        Self_ID.Common.LL.L'Access);\n+      if Single_Lock then\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n+      else\n+         Result := pthread_cond_wait\n+           (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+      end if;\n \n       --  EINTR is not considered a failure.\n \n@@ -548,8 +554,16 @@ package body System.Task_Primitives.Operations is\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n               or else Self_ID.Pending_Priority_Change;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n+                  Request'Access);\n+\n+            else\n+               Result := pthread_cond_timedwait\n+                 (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+                  Request'Access);\n+            end if;\n \n             exit when Abs_Time <= Monotonic_Clock;\n \n@@ -591,6 +605,11 @@ package body System.Task_Primitives.Operations is\n       --  check for pending abort and priority change below! :(\n \n       SSL.Abort_Defer.all;\n+\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -626,8 +645,14 @@ package body System.Task_Primitives.Operations is\n \n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n-              Self_ID.Common.LL.L'Access, Request'Access);\n+            if Single_Lock then\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Single_RTS_Lock'Access, Request'Access);\n+            else\n+               Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L'Access, Request'Access);\n+            end if;\n+\n             exit when Abs_Time <= Monotonic_Clock;\n \n             pragma Assert (Result = 0\n@@ -639,6 +664,11 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n       Result := sched_yield;\n       SSL.Abort_Undefer.all;\n    end Timed_Delay;\n@@ -673,7 +703,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_cond_signal (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -685,7 +714,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Yield (Do_Yield : Boolean := True) is\n       Result : Interfaces.C.int;\n-\n    begin\n       if Do_Yield then\n          Result := sched_yield;\n@@ -697,8 +725,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T : Task_ID;\n-      Prio : System.Any_Priority;\n+     (T                   : Task_ID;\n+      Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n       Result : Interfaces.C.int;\n@@ -744,17 +772,17 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Set (Self_ID);\n \n-      Lock_All_Tasks_List;\n+      Lock_RTS;\n \n-      for I in Known_Tasks'Range loop\n-         if Known_Tasks (I) = null then\n-            Known_Tasks (I) := Self_ID;\n-            Self_ID.Known_Tasks_Index := I;\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n             exit;\n          end if;\n       end loop;\n \n-      Unlock_All_Tasks_List;\n+      Unlock_RTS;\n    end Enter_Task;\n \n    --------------\n@@ -772,8 +800,8 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-      Cond_Attr : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n \n    begin\n       --  Give the task a unique serial number.\n@@ -782,53 +810,50 @@ package body System.Task_Primitives.Operations is\n       Next_Serial_Number := Next_Serial_Number + 1;\n       pragma Assert (Next_Serial_Number /= 0);\n \n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+      if not Single_Lock then\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n+         if Result = 0 then\n+            Result := pthread_mutexattr_setprotocol\n+              (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n+            pragma Assert (Result = 0);\n \n-      Result := pthread_mutexattr_setprotocol\n-        (Mutex_Attr'Access, PTHREAD_PRIO_PROTECT);\n-      pragma Assert (Result = 0);\n+            Result := pthread_mutexattr_setprioceiling\n+              (Mutex_Attr'Access, Interfaces.C.int (System.Any_Priority'Last));\n+            pragma Assert (Result = 0);\n \n-      Result := pthread_mutexattr_setprioceiling\n-        (Mutex_Attr'Access, Interfaces.C.int (System.Any_Priority'Last));\n-      pragma Assert (Result = 0);\n+            Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n \n-      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n-        Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n+         if Result /= 0 then\n+            Succeeded := False;\n+            return;\n+         end if;\n \n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n       end if;\n \n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-         Succeeded := False;\n-         return;\n+      if Result = 0 then\n+         Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+           Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n       end if;\n \n-      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n-        Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n+         if not Single_Lock then\n+            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+\n          Succeeded := False;\n       end if;\n \n@@ -936,8 +961,10 @@ package body System.Task_Primitives.Operations is\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n \n    begin\n-      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-      pragma Assert (Result = 0);\n+      if not Single_Lock then\n+         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -1001,23 +1028,23 @@ package body System.Task_Primitives.Operations is\n       return Environment_Task_ID;\n    end Environment_Task;\n \n-   -------------------------\n-   -- Lock_All_Tasks_List --\n-   -------------------------\n+   --------------\n+   -- Lock_RTS --\n+   --------------\n \n-   procedure Lock_All_Tasks_List is\n+   procedure Lock_RTS is\n    begin\n-      Write_Lock (All_Tasks_L'Access);\n-   end Lock_All_Tasks_List;\n+      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Lock_RTS;\n \n-   ---------------------------\n-   -- Unlock_All_Tasks_List --\n-   ---------------------------\n+   ----------------\n+   -- Unlock_RTS --\n+   ----------------\n \n-   procedure Unlock_All_Tasks_List is\n+   procedure Unlock_RTS is\n    begin\n-      Unlock (All_Tasks_L'Access);\n-   end Unlock_All_Tasks_List;\n+      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+   end Unlock_RTS;\n \n    ------------------\n    -- Suspend_Task --\n@@ -1056,7 +1083,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n \n-      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n       Specific.Initialize (Environment_Task);\n \n@@ -1083,7 +1110,6 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n       --  Mask Environment task for all signals. The original mask of the\n       --  Environment task will be recovered by Interrupt_Server task\n@@ -1104,5 +1130,4 @@ begin\n          end if;\n       end loop;\n    end;\n-\n end System.Task_Primitives.Operations;"}, {"sha": "c8c13669d79ebcaba88732633107f778a83f07b7", "filename": "gcc/ada/7stpopsp.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7stpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F7stpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7stpopsp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -2,14 +2,13 @@\n --                                                                          --\n --                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n --                                                                          --\n---    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S .   --\n---                              S P E C I F I C                             --\n+--                SYSTEM.TASK_PRIMITIVES.OPERATIONS.SPECIFIC                --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.1 $                             --\n+--                             $Revision$                             --\n --                                                                          --\n---            Copyright (C) 1991-1998, Florida State University             --\n+--            Copyright (C) 1991-2001, Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,7 +67,7 @@ package body Specific is\n    ---------\n \n    procedure Set (Self_Id : Task_ID) is\n-      Result  : Interfaces.C.int;\n+      Result : Interfaces.C.int;\n \n    begin\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));"}, {"sha": "8edba9e46fb3b8d360e4266b0f994758cbf39131", "filename": "gcc/ada/9drpc.adb", "status": "modified", "additions": 152, "deletions": 150, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F9drpc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2F9drpc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F9drpc.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $                              --\n+--                            $Revision$\n --                                                                          --\n---     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Version for ???\n+\n with Unchecked_Deallocation;\n with Ada.Streams;\n \n@@ -43,6 +45,10 @@ pragma Elaborate (System.RPC.Garlic);\n \n package body System.RPC is\n \n+   --  ??? general note: the debugging calls are very heavy, especially\n+   --  those that create exception handlers in every procedure. Do we\n+   --  really still need all this stuff?\n+\n    use type Ada.Streams.Stream_Element_Count;\n    use type Ada.Streams.Stream_Element_Offset;\n \n@@ -52,7 +58,7 @@ package body System.RPC is\n    Max_Of_Message_Id : constant := 127;\n \n    subtype Message_Id_Type is\n-      Integer range -Max_Of_Message_Id .. Max_Of_Message_Id;\n+     Integer range -Max_Of_Message_Id .. Max_Of_Message_Id;\n    --  A message id is either a request id or reply id. A message id is\n    --  provided with a message to a receiving stub which uses the opposite\n    --  as a reply id. A message id helps to retrieve to which task is\n@@ -67,9 +73,9 @@ package body System.RPC is\n    type Message_Length_Per_Request is array (Request_Id_Type)\n       of Ada.Streams.Stream_Element_Count;\n \n-   Header_Size : Ada.Streams.Stream_Element_Count\n-      := Streams.Get_Integer_Initial_Size +\n-         Streams.Get_SEC_Initial_Size;\n+   Header_Size : Ada.Streams.Stream_Element_Count :=\n+                   Streams.Get_Integer_Initial_Size +\n+                     Streams.Get_SEC_Initial_Size;\n    --  Initial size needed for frequently used header streams\n \n    Stream_Error : exception;\n@@ -94,33 +100,30 @@ package body System.RPC is\n           Params_Size  : in Ada.Streams.Stream_Element_Count;\n           Result_Size  : in Ada.Streams.Stream_Element_Count;\n           Protocol     : in Garlic.Protocol_Access);\n-      --  This entry provides an anonymous task a remote call to perform\n-      --  This task calls for a\n-      --  Request id is provided to construct the reply id by using\n-      --  -Request. Partition is used to send the reply message. Params_Size\n-      --  is the size of the calling stub Params stream. Then, Protocol\n-      --  (used by the environment task previously) allows to extract the\n-      --  message following the header (The header is extracted by the\n-      --  environment task)\n+      --  This entry provides an anonymous task a remote call to perform.\n+      --  This task calls for a Request id is provided to construct the\n+      --  reply id by using -Request. Partition is used to send the reply\n+      --  message. Params_Size is the size of the calling stub Params stream.\n+      --  Then Protocol (used by the environment task previously) allows\n+      --  extraction of the message following the header (The header is\n+      --  extracted by the environment task)\n+      --  Note: grammar in above is obscure??? needs cleanup\n \n    end Anonymous_Task_Type;\n \n    type Anonymous_Task_Access is access Anonymous_Task_Type;\n \n-   type Anonymous_Task_List is\n-      record\n-         Head     : Anonymous_Task_Node_Access;\n-         Tail     : Anonymous_Task_Node_Access;\n-      end record;\n-\n-   type Anonymous_Task_Node is\n-      record\n-         Element : Anonymous_Task_Access;\n-         Next    : Anonymous_Task_Node_Access;\n-      end record;\n-   --  Types we need to construct a singly linked list of anonymous tasks\n-   --  This pool is maintained to avoid a task creation each time a RPC\n-   --  occurs\n+   type Anonymous_Task_List is record\n+      Head     : Anonymous_Task_Node_Access;\n+      Tail     : Anonymous_Task_Node_Access;\n+   end record;\n+\n+   type Anonymous_Task_Node is record\n+      Element : Anonymous_Task_Access;\n+      Next    : Anonymous_Task_Node_Access;\n+   end record;\n+   --  Types we need to construct a singly linked list of anonymous tasks.\n+   --  This pool is maintained to avoid a task creation each time a RPC occurs.\n \n    protected Garbage_Collector is\n \n@@ -133,6 +136,7 @@ package body System.RPC is\n          (Item : in out Anonymous_Task_Node_Access);\n       --  Anonymous task pool management : queue this task in the pool\n       --  of inactive anonymous tasks.\n+\n    private\n \n       Anonymous_List : Anonymous_Task_Node_Access;\n@@ -230,48 +234,54 @@ package body System.RPC is\n    ---------------\n \n    procedure Head_Node\n-     (Index  :    out Packet_Node_Access;\n-      Stream : in     Params_Stream_Type) is\n+     (Index  : out Packet_Node_Access;\n+      Stream : Params_Stream_Type)\n+   is\n    begin\n       Index := Stream.Extra.Head;\n-   exception when others =>\n-      D (D_Exception, \"exception in Head_Node\");\n-      raise;\n+\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Head_Node\");\n+         raise;\n    end Head_Node;\n \n    ---------------\n    -- Tail_Node --\n    ---------------\n \n    procedure Tail_Node\n-     (Index  :    out Packet_Node_Access;\n-      Stream : in     Params_Stream_Type) is\n+     (Index  : out Packet_Node_Access;\n+      Stream : Params_Stream_Type)\n+   is\n    begin\n       Index := Stream.Extra.Tail;\n-   exception when others =>\n-      D (D_Exception, \"exception in Tail_Node\");\n-      raise;\n+\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Tail_Node\");\n+         raise;\n    end Tail_Node;\n \n    ---------------\n    -- Null_Node --\n    ---------------\n \n-   function Null_Node\n-     (Index : in Packet_Node_Access) return Boolean is\n+   function Null_Node (Index : in Packet_Node_Access) return Boolean is\n    begin\n       return Index = null;\n-   exception when others =>\n-      D (D_Exception, \"exception in Null_Node\");\n-      raise;\n+\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Null_Node\");\n+         raise;\n    end Null_Node;\n \n    ----------------------\n    -- Delete_Head_Node --\n    ----------------------\n \n-   procedure Delete_Head_Node\n-     (Stream : in out Params_Stream_Type) is\n+   procedure Delete_Head_Node (Stream : in out Params_Stream_Type) is\n \n       procedure Free is\n         new Unchecked_Deallocation\n@@ -280,7 +290,6 @@ package body System.RPC is\n       Next_Node : Packet_Node_Access := Stream.Extra.Head.Next;\n \n    begin\n-\n       --  Delete head node and free memory usage\n \n       Free (Stream.Extra.Head);\n@@ -292,19 +301,18 @@ package body System.RPC is\n          Stream.Extra.Tail := null;\n       end if;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Delete_Head_Node\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Delete_Head_Node\");\n+         raise;\n    end Delete_Head_Node;\n \n    ---------------\n    -- Next_Node --\n    ---------------\n \n-   procedure Next_Node\n-     (Node : in out Packet_Node_Access) is\n+   procedure Next_Node (Node : in out Packet_Node_Access) is\n    begin\n-\n       --  Node is set to the next node\n       --  If not possible, Stream_Error is raised\n \n@@ -314,20 +322,20 @@ package body System.RPC is\n          Node := Node.Next;\n       end if;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Next_Node\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Next_Node\");\n+         raise;\n    end Next_Node;\n \n    ---------------------\n    -- Append_New_Node --\n    ---------------------\n \n-   procedure Append_New_Node\n-     (Stream : in out Params_Stream_Type) is\n+   procedure Append_New_Node (Stream : in out Params_Stream_Type) is\n       Index : Packet_Node_Access;\n-   begin\n \n+   begin\n       --  Set Index to the end of the linked list\n \n       Tail_Node (Index, Stream);\n@@ -340,17 +348,17 @@ package body System.RPC is\n          Stream.Extra.Tail := Stream.Extra.Head;\n \n       else\n-\n          --  The list is not empty : link new node with tail\n \n          Stream.Extra.Tail.Next := new Packet_Node;\n          Stream.Extra.Tail := Stream.Extra.Tail.Next;\n \n       end if;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Append_New_Node\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Append_New_Node\");\n+         raise;\n    end Append_New_Node;\n \n    ----------\n@@ -360,17 +368,17 @@ package body System.RPC is\n    procedure Read\n      (Stream : in out Params_Stream_Type;\n       Item   : out Ada.Streams.Stream_Element_Array;\n-      Last   : out Ada.Streams.Stream_Element_Offset) renames\n-      System.RPC.Streams.Read;\n+      Last   : out Ada.Streams.Stream_Element_Offset)\n+     renames System.RPC.Streams.Read;\n \n    -----------\n    -- Write --\n    -----------\n \n    procedure Write\n      (Stream : in out Params_Stream_Type;\n-      Item   : in Ada.Streams.Stream_Element_Array) renames\n-      System.RPC.Streams.Write;\n+      Item   : in Ada.Streams.Stream_Element_Array)\n+     renames System.RPC.Streams.Write;\n \n    -----------------------\n    -- Garbage_Collector --\n@@ -382,12 +390,11 @@ package body System.RPC is\n       -- Garbage_Collector.Allocate --\n       --------------------------------\n \n-      procedure Allocate\n-         (Item : out Anonymous_Task_Node_Access) is\n+      procedure Allocate (Item : out Anonymous_Task_Node_Access) is\n          New_Anonymous_Task_Node : Anonymous_Task_Node_Access;\n          Anonymous_Task          : Anonymous_Task_Access;\n-      begin\n \n+      begin\n          --  If the list is empty, allocate a new anonymous task\n          --  Otherwise, reuse the first queued anonymous task\n \n@@ -404,7 +411,6 @@ package body System.RPC is\n             New_Anonymous_Task_Node.all := (Anonymous_Task, null);\n \n          else\n-\n             --  Extract one task from the list\n             --  Set the Next field to null to avoid possible bugs\n \n@@ -418,27 +424,27 @@ package body System.RPC is\n \n          Item := New_Anonymous_Task_Node;\n \n-      exception when others =>\n-         D (D_Exception, \"exception in Allocate (Anonymous Task)\");\n-         raise;\n+      exception\n+         when others =>\n+            D (D_Exception, \"exception in Allocate (Anonymous Task)\");\n+            raise;\n       end Allocate;\n \n       ----------------------------------\n       -- Garbage_Collector.Deallocate --\n       ----------------------------------\n \n-      procedure Deallocate\n-        (Item : in out Anonymous_Task_Node_Access) is\n+      procedure Deallocate (Item : in out Anonymous_Task_Node_Access) is\n       begin\n-\n          --  Enqueue the task in the free list\n \n          Item.Next := Anonymous_List;\n          Anonymous_List := Item;\n \n-      exception when others =>\n-         D (D_Exception, \"exception in Deallocate (Anonymous Task)\");\n-         raise;\n+      exception\n+         when others =>\n+            D (D_Exception, \"exception in Deallocate (Anonymous Task)\");\n+            raise;\n       end Deallocate;\n \n    end Garbage_Collector;\n@@ -448,15 +454,16 @@ package body System.RPC is\n    ------------\n \n    procedure Do_RPC\n-     (Partition  : in Partition_ID;\n+     (Partition  : Partition_ID;\n       Params     : access Params_Stream_Type;\n-      Result     : access Params_Stream_Type) is\n+      Result     : access Params_Stream_Type)\n+   is\n       Protocol   : Protocol_Access;\n       Request    : Request_Id_Type;\n       Header     : aliased Params_Stream_Type (Header_Size);\n       R_Length   : Ada.Streams.Stream_Element_Count;\n-   begin\n \n+   begin\n       --  Parameters order :\n       --       Opcode   (provided and used by garlic)\n       --   (1) Size     (provided by s-rpc and used by garlic)\n@@ -538,7 +545,6 @@ package body System.RPC is\n          declare\n             New_Result : aliased Params_Stream_Type (R_Length);\n          begin\n-\n             --  Adjust the Result stream size right now to be able to load\n             --  the stream in one receive call. Create a temporary resutl\n             --  that will be substituted to Do_RPC one\n@@ -570,7 +576,6 @@ package body System.RPC is\n          end;\n \n       else\n-\n          --  Do RPC locally and first wait for Partition_RPC_Receiver to be\n          --  set\n \n@@ -580,23 +585,25 @@ package body System.RPC is\n \n       end if;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Do_RPC\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Do_RPC\");\n+         raise;\n    end Do_RPC;\n \n    ------------\n    -- Do_APC --\n    ------------\n \n    procedure Do_APC\n-     (Partition  : in Partition_ID;\n-      Params     : access Params_Stream_Type) is\n+     (Partition  : Partition_ID;\n+      Params     : access Params_Stream_Type)\n+   is\n       Message_Id : Message_Id_Type := 0;\n       Protocol   : Protocol_Access;\n       Header     : aliased Params_Stream_Type (Header_Size);\n-   begin\n \n+   begin\n       --  For more informations, see above\n       --  Request = 0 as we are not waiting for a reply message\n       --  Result length = 0 as we don't expect a result at all\n@@ -660,7 +667,6 @@ package body System.RPC is\n          declare\n             Result   : aliased Params_Stream_Type (0);\n          begin\n-\n             --  Result is here a dummy parameter\n             --  No reason to deallocate as it is not allocated at all\n \n@@ -672,29 +678,31 @@ package body System.RPC is\n \n       end if;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Do_APC\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Do_APC\");\n+         raise;\n    end Do_APC;\n \n    ----------------------------\n    -- Establish_RPC_Receiver --\n    ----------------------------\n \n-   procedure Establish_RPC_Receiver (\n-          Partition : in Partition_ID;\n-          Receiver  : in RPC_Receiver) is\n+   procedure Establish_RPC_Receiver\n+     (Partition : in Partition_ID;\n+      Receiver  : in RPC_Receiver)\n+   is\n    begin\n-\n       --  Set Partition_RPC_Receiver and allow RPC mechanism\n \n       Partition_RPC_Receiver := Receiver;\n       Partition_Receiver.Set;\n       D (D_Elaborate, \"Partition_Receiver is set\");\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Establish_RPC_Receiver\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Establish_RPC_Receiver\");\n+         raise;\n    end Establish_RPC_Receiver;\n \n    ----------------\n@@ -705,24 +713,24 @@ package body System.RPC is\n       Last_Request : Request_Id_Type := Request_Id_Type'First;\n       Current_Rqst : Request_Id_Type := Request_Id_Type'First;\n       Current_Size : Ada.Streams.Stream_Element_Count;\n-   begin\n \n+   begin\n       loop\n+         --  Three services:\n \n-         --  Three services :\n-         --  New_Request to get an entry in Dispatcher table\n-         --  Wait_On for Do_RPC calls\n-         --  Wake_Up called by environment task when a Do_RPC receives\n-         --  the result of its remote call\n+         --    New_Request to get an entry in Dispatcher table\n \n-         select\n+         --    Wait_On for Do_RPC calls\n+\n+         --    Wake_Up called by environment task when a Do_RPC receives\n+         --    the result of its remote call\n \n-            accept New_Request\n-              (Request : out Request_Id_Type) do\n+         select\n+            accept New_Request (Request : out Request_Id_Type) do\n                Request := Last_Request;\n \n                --  << TODO >>\n-               --  Avaibility check\n+               --  ??? Avaibility check\n \n                if Last_Request = Request_Id_Type'Last then\n                   Last_Request := Request_Id_Type'First;\n@@ -733,11 +741,10 @@ package body System.RPC is\n             end New_Request;\n \n          or\n-\n             accept Wake_Up\n-              (Request : in Request_Id_Type;\n-               Length  : in Ada.Streams.Stream_Element_Count) do\n-\n+              (Request : Request_Id_Type;\n+               Length  : Ada.Streams.Stream_Element_Count)\n+            do\n                --  The environment reads the header and has been notified\n                --  of the reply id and the size of the result message\n \n@@ -747,34 +754,33 @@ package body System.RPC is\n             end Wake_Up;\n \n             --  << TODO >>\n-            --  Must be select with delay for aborted tasks\n+            --  ??? Must be select with delay for aborted tasks\n \n             select\n \n                accept Wait_On (Current_Rqst)\n-                 (Length  : out Ada.Streams.Stream_Element_Count) do\n+                 (Length  : out Ada.Streams.Stream_Element_Count)\n+               do\n                   Length := Current_Size;\n                end Wait_On;\n \n             or\n-\n                --  To free the Dispatcher when a task is aborted\n \n                delay 1.0;\n \n             end select;\n \n          or\n-\n             terminate;\n-\n          end select;\n \n       end loop;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Dispatcher body\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Dispatcher body\");\n+         raise;\n    end Dispatcher;\n \n    -------------------------\n@@ -788,10 +794,9 @@ package body System.RPC is\n       Params_S     : Ada.Streams.Stream_Element_Count; --  Params message size\n       Result_S     : Ada.Streams.Stream_Element_Count; --  Result message size\n       C_Protocol   : Protocol_Access;                  --  Current Protocol\n-   begin\n \n+   begin\n       loop\n-\n          --  Get a new RPC to execute\n \n          select\n@@ -800,7 +805,8 @@ package body System.RPC is\n                Partition    : in Partition_ID;\n                Params_Size  : in Ada.Streams.Stream_Element_Count;\n                Result_Size  : in Ada.Streams.Stream_Element_Count;\n-               Protocol     : in Protocol_Access) do\n+               Protocol     : in Protocol_Access)\n+            do\n                C_Message_Id := Message_Id;\n                C_Partition  := Partition;\n                Params_S     := Params_Size;\n@@ -812,11 +818,11 @@ package body System.RPC is\n          end select;\n \n          declare\n-            Params   : aliased Params_Stream_Type (Params_S);\n-            Result   : aliased Params_Stream_Type (Result_S);\n-            Header   : aliased Params_Stream_Type (Header_Size);\n-         begin\n+            Params : aliased Params_Stream_Type (Params_S);\n+            Result : aliased Params_Stream_Type (Result_S);\n+            Header : aliased Params_Stream_Type (Header_Size);\n \n+         begin\n             --  We reconstruct all the client context : Params and Result\n             --  with the SAME size, then we receive Params from calling stub\n \n@@ -863,7 +869,6 @@ package body System.RPC is\n                  (Header'Access,\n                   Streams.Get_Stream_Size (Result'Access));\n \n-\n                --  Get a protocol method to comunicate with the remote\n                --  partition and give the message size\n \n@@ -903,12 +908,10 @@ package body System.RPC is\n                  (C_Protocol.all,\n                   C_Partition);\n                Streams.Deallocate (Header);\n-\n             end if;\n \n             Streams.Deallocate (Params);\n             Streams.Deallocate (Result);\n-\n          end;\n \n          --  Enqueue into the anonymous task free list : become inactive\n@@ -917,9 +920,10 @@ package body System.RPC is\n \n       end loop;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Anonymous_Task_Type body\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Anonymous_Task_Type body\");\n+         raise;\n    end Anonymous_Task_Type;\n \n    -----------------\n@@ -934,15 +938,14 @@ package body System.RPC is\n       Header       : aliased Params_Stream_Type (Header_Size);\n       Protocol     : Protocol_Access;\n       Anonymous    : Anonymous_Task_Node_Access;\n-   begin\n \n+   begin\n       --  Wait the Partition_RPC_Receiver to be set\n \n       accept Start;\n       D (D_Elaborate, \"Environment task elaborated\");\n \n       loop\n-\n          --  We receive first a fixed size message : the header\n          --  Header = Message Id + Message Size\n \n@@ -952,10 +955,10 @@ package body System.RPC is\n          --  protocol to use to communicate with the calling partition\n \n          Garlic.Initiate_Receive\n-            (Partition,\n-             Message_Size,\n-             Protocol,\n-             Garlic.Remote_Call);\n+           (Partition,\n+            Message_Size,\n+            Protocol,\n+            Garlic.Remote_Call);\n          D (D_Communication,\n             \"Environment task - Receive protocol to talk to active partition\" &\n             Partition_ID'Image (Partition));\n@@ -968,9 +971,9 @@ package body System.RPC is\n             \"Environment task - Receive Header from partition\" &\n             Partition_ID'Image (Partition));\n          Garlic.Receive\n-            (Protocol.all,\n-             Partition,\n-             Header'Access);\n+           (Protocol.all,\n+            Partition,\n+            Header'Access);\n \n          --  Evaluate the remaining size of the message\n \n@@ -1001,7 +1004,6 @@ package body System.RPC is\n             Dispatcher.Wake_Up (-Message_Id, Result_Size);\n \n          else\n-\n             --  The message was send by a calling stub : get an anonymous\n             --  task to perform the job\n \n@@ -1027,13 +1029,13 @@ package body System.RPC is\n \n       end loop;\n \n-   exception when others =>\n-      D (D_Exception, \"exception in Environment\");\n-      raise;\n+   exception\n+      when others =>\n+         D (D_Exception, \"exception in Environment\");\n+         raise;\n    end Environnement;\n \n begin\n-\n    --  Set debugging information\n \n    Debugging.Set_Environment_Variable (\"RPC\");"}, {"sha": "3791b448461b81d1f0ff7d70d5d0b9796029476f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 250, "deletions": 136, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -1,3 +1,117 @@\n+2002-03-07  Geert Bosch  <bosch@gnat.com>\n+\n+\t* 41intnam.ads, 42intnam.ads, 4aintnam.ads, 4cintnam.ads,\n+\t4dintnam.ads, 4gintnam.ads, 4hintnam.ads, 4lintnam.ads,\n+\t4mintnam.ads, 4pintnam.ads, 4rintnam.ads, 4sintnam.ads,\n+\t4uintnam.ads, 4vcalend.adb, 4zintnam.ads, 52system.ads,\n+\t5amastop.adb, 5asystem.ads, 5ataprop.adb, 5atpopsp.adb,\n+\t5avxwork.ads, 5bosinte.adb, 5bsystem.ads, 5esystem.ads,\n+\t5fsystem.ads, 5ftaprop.adb, 5ginterr.adb, 5gmastop.adb,\n+\t5gsystem.ads, 5gtaprop.adb, 5gtasinf.adb, 5gtasinf.ads,\n+\t5hparame.ads, 5hsystem.ads, 5htaprop.adb, 5htraceb.adb,\n+\t5itaprop.adb, 5ksystem.ads, 5kvxwork.ads, 5lintman.adb,\n+\t5lsystem.ads, 5mvxwork.ads, 5ninmaop.adb, 5nosinte.ads,\n+\t5ntaprop.adb, 5ointerr.adb, 5omastop.adb, 5oosinte.adb,\n+\t5osystem.ads, 5otaprop.adb, 5otaspri.ads, 5pvxwork.ads,\n+\t5qtaprop.adb, 5sintman.adb, 5ssystem.ads, 5staprop.adb,\n+\t5stpopse.adb, 5svxwork.ads, 5tosinte.ads, 5uintman.adb,\n+\t5vasthan.adb, 5vinmaop.adb, 5vinterr.adb, 5vintman.adb,\n+\t5vmastop.adb, 5vparame.ads, 5vsystem.ads, 5vtaprop.adb,\n+\t5vtpopde.adb, 5wmemory.adb, 5wsystem.ads, 5wtaprop.adb,\n+\t5ysystem.ads, 5zinterr.adb, 5zintman.adb, 5zosinte.adb,\n+\t5zosinte.ads, 5zsystem.ads, 5ztaprop.adb, 6vcpp.adb, 6vcstrea.adb,\n+\t7sintman.adb, 7staprop.adb, 7stpopsp.adb, 9drpc.adb,\n+\tMake-lang.in, Makefile.in, a-caldel.adb, a-comlin.ads,\n+\ta-dynpri.adb, a-except.adb, a-except.ads, a-finali.adb,\n+\ta-ncelfu.ads, a-reatim.adb, a-retide.adb, a-stream.ads,\n+\ta-ststio.adb, a-ststio.ads, a-stwifi.adb, a-tags.adb, a-tasatt.adb,\n+\ta-textio.adb, a-tideau.adb, a-tiflau.adb, a-tigeau.adb,\n+\ta-tigeau.ads, a-tiinau.adb, a-timoau.adb, a-witeio.adb,\n+\ta-wtdeau.adb, a-wtenau.adb, a-wtflau.adb, a-wtgeau.adb,\n+\ta-wtgeau.ads, a-wtinau.adb, a-wtmoau.adb, ada-tree.def, ada-tree.h,\n+\tadaint.c, adaint.h, ali-util.adb, ali.adb, ali.ads, atree.adb,\n+\tatree.ads, atree.h, back_end.adb, bcheck.adb, bindgen.adb,\n+\tbindusg.adb, checks.adb, comperr.adb, config-lang.in, csets.adb,\n+\tcsets.ads, cstand.adb, cstreams.c, debug.adb, debug.ads, decl.c,\n+\teinfo.adb, einfo.ads, einfo.h, elists.h, errout.adb, errout.ads,\n+\teval_fat.adb, exp_aggr.adb, exp_attr.adb, exp_ch11.adb,\n+\texp_ch12.adb, exp_ch13.adb, exp_ch2.adb, exp_ch3.adb, exp_ch3.ads,\n+\texp_ch4.adb, exp_ch5.adb, exp_ch6.adb, exp_ch7.adb, exp_ch7.ads,\n+\texp_ch9.adb, exp_ch9.ads, exp_dbug.adb, exp_dbug.ads, exp_disp.ads,\n+\texp_dist.adb, exp_fixd.adb, exp_intr.adb, exp_pakd.adb,\n+\texp_prag.adb, exp_strm.adb, exp_util.adb, exp_util.ads,\n+\texpander.adb, expect.c, fe.h, fmap.adb, fmap.ads, fname-uf.adb,\n+\tfreeze.adb, frontend.adb, g-awk.adb, g-cgideb.adb, g-comlin.adb,\n+\tg-comlin.ads, g-debpoo.adb, g-dirope.adb, g-dirope.ads,\n+\tg-dyntab.adb, g-expect.adb, g-expect.ads, g-io.ads, g-io_aux.adb,\n+\tg-io_aux.ads, g-locfil.adb, g-locfil.ads, g-os_lib.adb,\n+\tg-os_lib.ads, g-regexp.adb, g-regpat.adb, g-socket.adb,\n+\tg-socket.ads, g-spipat.adb, g-table.adb, g-trasym.adb,\n+\tg-trasym.ads, gigi.h, gmem.c, gnat1drv.adb, gnatbind.adb, gnatbl.c,\n+\tgnatchop.adb, gnatcmd.adb, gnatdll.adb, gnatfind.adb, gnatlbr.adb,\n+\tgnatlink.adb, gnatls.adb, gnatmem.adb, gnatprep.adb, gnatvsn.ads,\n+\tgnatxref.adb, hlo.adb, hostparm.ads, i-cobol.adb, i-cpp.adb,\n+\ti-cstrea.ads, i-cstrin.adb, i-pacdec.adb, i-vxwork.ads,\n+\timpunit.adb, init.c, inline.adb, io-aux.c, layout.adb, lib-load.adb,\n+\tlib-util.adb, lib-writ.adb, lib-writ.ads, lib-xref.adb,\n+\tlib-xref.ads, lib.adb, lib.ads, make.adb, makeusg.adb, mdll.adb,\n+\tmemroot.adb, misc.c, mlib-tgt.adb, mlib-utl.adb, mlib-utl.ads,\n+\tmlib.adb, namet.adb, namet.ads, namet.h, nlists.h, nmake.adb,\n+\tnmake.ads, nmake.adt, opt.adb, opt.ads, osint.adb, osint.ads,\n+\toutput.adb, output.ads, par-ch2.adb, par-ch3.adb, par-ch5.adb,\n+\tpar-prag.adb, par-tchk.adb, par-util.adb, par.adb, prj-attr.adb,\n+\tprj-dect.adb, prj-env.adb, prj-env.ads, prj-nmsc.adb, prj-part.adb,\n+\tprj-proc.adb, prj-strt.adb, prj-tree.adb, prj-tree.ads, prj.adb,\n+\tprj.ads, raise.c, raise.h, repinfo.adb, restrict.adb, restrict.ads,\n+\trident.ads, rtsfind.adb, rtsfind.ads, s-arit64.adb, s-asthan.adb,\n+\ts-atacco.adb, s-atacco.ads, s-auxdec.adb, s-crc32.adb, s-crc32.ads,\n+\ts-direio.adb, s-fatgen.adb, s-fileio.adb, s-finimp.adb,\n+\ts-gloloc.adb, s-gloloc.ads, s-interr.adb, s-mastop.adb,\n+\ts-mastop.ads, s-memory.adb, s-parame.ads, s-parint.adb,\n+\ts-pooglo.adb, s-pooloc.adb, s-rpc.adb, s-secsta.adb, s-sequio.adb,\n+\ts-shasto.adb, s-soflin.adb, s-soflin.ads, s-stache.adb,\n+\ts-taasde.adb, s-taasde.ads, s-tadeca.adb, s-tadeca.ads,\n+\ts-tadert.adb, s-tadert.ads, s-taenca.adb, s-taenca.ads,\n+\ts-taprob.adb, s-taprop.ads, s-tarest.adb, s-tasdeb.adb,\n+\ts-tasini.adb, s-tasini.ads, s-taskin.adb, s-taskin.ads,\n+\ts-tasque.adb, s-tasque.ads, s-tasren.adb, s-tasren.ads,\n+\ts-tassta.adb, s-tasuti.adb, s-tasuti.ads, s-tataat.adb,\n+\ts-tataat.ads, s-tpoben.adb, s-tpoben.ads, s-tpobop.adb,\n+\ts-tposen.adb, s-tposen.ads, s-traceb.adb, s-traceb.ads,\n+\ts-unstyp.ads, s-widenu.adb, scn-nlit.adb, scn.adb, sem.adb,\n+\tsem_aggr.adb, sem_attr.adb, sem_attr.ads, sem_case.adb,\n+\tsem_ch10.adb, sem_ch11.adb, sem_ch11.ads, sem_ch12.adb,\n+\tsem_ch13.adb, sem_ch13.ads, sem_ch2.adb, sem_ch3.adb, sem_ch3.ads,\n+\tsem_ch4.adb, sem_ch5.adb, sem_ch6.adb, sem_ch6.ads, sem_ch7.adb,\n+\tsem_ch8.adb, sem_ch8.ads, sem_ch9.adb, sem_disp.adb, sem_dist.adb,\n+\tsem_elab.adb, sem_elim.adb, sem_elim.ads, sem_eval.adb,\n+\tsem_intr.adb, sem_mech.adb, sem_prag.adb, sem_res.adb,\n+\tsem_type.adb, sem_util.adb, sem_util.ads, sem_vfpt.adb,\n+\tsem_warn.adb, sinfo.adb, sinfo.ads, sinfo.h, sinput-l.adb,\n+\tsinput-l.ads, sinput.adb, sinput.ads, snames.adb, snames.ads,\n+\tsnames.h, sprint.adb, sprint.ads, stringt.adb, stringt.ads,\n+\tstringt.h, style.adb, switch.adb, switch.ads, sysdep.c, system.ads,\n+\ttable.adb, targparm.adb, targparm.ads, targtyps.c, tbuild.adb,\n+\ttbuild.ads, tracebak.c, trans.c, tree_gen.adb, tree_io.adb,\n+\ttreepr.adb, treepr.ads, treeprs.ads, treeprs.adt, ttypes.ads,\n+\ttypes.adb, types.ads, types.h, uintp.ads, urealp.ads, usage.adb,\n+\tutils.c, utils2.c, validsw.adb, xnmake.adb, xr_tabls.adb,\n+\txr_tabls.ads, xref_lib.adb, xref_lib.ads : Merge in ACT changes.\n+\n+\t* 1ssecsta.adb, 1ssecsta.ads, a-chlat9.ads, a-cwila9.ads,\n+\tg-enblsp.adb, g-md5.adb, g-md5.ads, gnatname.adb, gnatname.ads,\n+\tmkdir.c, osint-b.adb, osint-b.ads, osint-c.adb, osint-c.ads,\n+\tosint-l.adb, osint-l.ads, osint-m.adb, osint-m.ads : New files\n+\n+\t* 3lsoccon.ads, 5qparame.ads, 5qvxwork.ads, 5smastop.adb,\n+\t5zparame.ads, gnatmain.adb, gnatmain.ads, gnatpsys.adb : Removed\n+\n+\t* mdllfile.adb, mdllfile.ads, mdlltool.adb, mdlltool.ads : Renamed\n+\tto mdll-fil.ad[bs] and mdll-util.ad[bs]\n+\n+\t* mdll-fil.adb, mdll-fil.ads, mdll-utl.adb, mdll-utl.ads : Renamed\n+\tfrom mdllfile.ad[bs] and mdlltool.ad[bs]\n+\n 2002-03-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* utils.c (init_gnat_to_gnu, init_gigi_decls): Use ARRAY_SIZE in\n@@ -92,27 +206,27 @@\n \t\n \t* prj-env.ads: Minor reformatting\n \t\n-\t* switch.adb: Minor reformatting.  Do proper raise of Bad_Switch if \n-\terror found (there were odd exceptions to this general rule in \n+\t* switch.adb: Minor reformatting.  Do proper raise of Bad_Switch if\n+\terror found (there were odd exceptions to this general rule in\n \t-gnatec/-gnatem processing)\n \t\n 2001-12-19  Olivier Hainque <hainque@gnat.com>\n \n-\t* raise.c (__gnat_eh_personality): Exception handling personality \n-\troutine for Ada.  Still in rough state, inspired from the C++ version \n+\t* raise.c (__gnat_eh_personality): Exception handling personality\n+\troutine for Ada.  Still in rough state, inspired from the C++ version\n \tand still containing a bunch of debugging artifacts.\n-\t(parse_lsda_header, get_ttype_entry): Local (static) helpers, also \n+\t(parse_lsda_header, get_ttype_entry): Local (static) helpers, also\n \tinspired from the C++ library.\n \t\n-\t* raise.c (eh_personality): Add comments. Part of work for the GCC 3 \n+\t* raise.c (eh_personality): Add comments. Part of work for the GCC 3\n \texception handling integration.\n \t\n 2001-12-19  Arnaud Charlet <charlet@gnat.com>\n \n \t* Makefile.in: Remove use of 5smastop.adb which is obsolete.\n \t(HIE_SOURCES): Add s-secsta.ad{s,b}.\n \t(HIE_OBJS): Add s-fat*.o\n-\t(RAVEN_SOURCES): Remove files that are no longer required. Add \n+\t(RAVEN_SOURCES): Remove files that are no longer required. Add\n \tinterrupt handling files.\n \t(RAVEN_MOD): Removed, no longer needed.\n \t\n@@ -121,20 +235,20 @@\n \t* a-ngelfu.adb: Remove ??? comment for inappropriate Inline_Always\n \tAdd 2001 to copyright date\n \t\n-\t* g-regpat.adb: Change pragma Inline_Always to Inline. There is no \n+\t* g-regpat.adb: Change pragma Inline_Always to Inline. There is no\n \tneed to force universal inlining for these cases.\n \t\n 2001-12-19  Arnaud Charlet <charlet@gnat.com>\n \n-\t* s-taprob.adb: Minor clean ups so that this unit can be used in \n+\t* s-taprob.adb: Minor clean ups so that this unit can be used in\n \tRavenscar HI.\n \t\n \t* exp_ch7.adb: Allow use of secondary stack in HI mode.\n \tDisallow it when pragma Restrictions (No_Secondary_Stack) is specified.\n \t\n 2001-12-19  Vincent Celier <celier@gnat.com>\n \n-\t* prj-tree.ads (Project_Node_Record): Add comments for components \n+\t* prj-tree.ads (Project_Node_Record): Add comments for components\n \tPkg_Id and Case_Insensitive.\n \t\n 2001-12-19  Pascal Obry <obry@gnat.com>\n@@ -151,28 +265,28 @@\n \n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_res.adb (Resolve_Selected_Component): do not generate a \n-\tdiscriminant check if the selected component is a component of \n+\t* sem_res.adb (Resolve_Selected_Component): do not generate a\n+\tdiscriminant check if the selected component is a component of\n \tthe argument of an initialization procedure.\n \n-\t* trans.c (tree_transform, case of arithmetic operators): If result \n-\ttype is private, the gnu_type is the base type of the full view, \n+\t* trans.c (tree_transform, case of arithmetic operators): If result\n+\ttype is private, the gnu_type is the base type of the full view,\n \tgiven that the full view itself may be a subtype.\n \t\n 2001-12-17  Robert Dewar <dewar@gnat.com>\n \n \t* sem_res.adb: Minor reformatting\n \t\n-\t* trans.c (tree_transform, case N_Real_Literal): Add missing third \n-\tparameter in call to Machine (unknown horrible effects from this \n+\t* trans.c (tree_transform, case N_Real_Literal): Add missing third\n+\tparameter in call to Machine (unknown horrible effects from this\n \tomission).\n \t\n \t* urealp.h: Add definition of Round_Even for call to Machine\n \tAdd third parameter for Machine\n \t\n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_warn.adb (Check_One_Unit): Suppress warnings completely on \n+\t* sem_warn.adb (Check_One_Unit): Suppress warnings completely on\n \tpredefined units in No_Run_Time mode.\n \t\n 2001-12-17  Richard Kenner <kenner@gnat.com>\n@@ -181,7 +295,7 @@\n \t\n 2001-12-17  Olivier Hainque <hainque@gnat.com>\n \n-\t* a-except.adb: Preparation work for future integration of the GCC 3 \n+\t* a-except.adb: Preparation work for future integration of the GCC 3\n \texception handling mechanism\n \t(Notify_Handled_Exception, Notify_Unhandled_Exception): New routines\n \tto factorize previous code sequences and make them externally callable,\n@@ -195,10 +309,10 @@\n \t\n 2001-12-17  Arnaud Charlet <charlet@gnat.com>\n \n-\t* bindgen.adb (Gen_Ada_Init_*): Set priority of environment task in \n+\t* bindgen.adb (Gen_Ada_Init_*): Set priority of environment task in\n \tHI-E mode, in order to support Ravenscar profile properly.\n \t\n-\t* cstand.adb (Create_Standard): Duration is a 32 bit type in HI-E \n+\t* cstand.adb (Create_Standard): Duration is a 32 bit type in HI-E\n \tmode on 32 bits targets.\n \t\n 2001-12-17  Vincent Celier <celier@gnat.com>\n@@ -225,7 +339,7 @@\n \t\n \t* prj-env.ads (Create_Mapping_File): New procedure.\n \t\n-\t* switch.adb (Scan_Front_End_Switches): Add processing for -gnatem \n+\t* switch.adb (Scan_Front_End_Switches): Add processing for -gnatem\n \t(Mapping_File)\n \t\n \t* usage.adb: Add entry for new switch -gnatem.\n@@ -234,7 +348,7 @@\n \t\n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch10.adb (Analyze_With_Clause): Retrieve proper entity when unit \n+\t* sem_ch10.adb (Analyze_With_Clause): Retrieve proper entity when unit\n \tis a package instantiation rewritten as a package body.\n \t(Install_Withed_Unit): Undo previous change, now redundant.\n \t\n@@ -247,7 +361,7 @@\n \t(Layout_Array_Type): Convert Len expression to Unsigned after calls to\n \tCompute_Length and Determine_Range.\n \tAbove changes fix problem with length computation for supernull arrays\n-\twhere Max (Len, 0) wasn't getting applied due to the Unsigned \n+\twhere Max (Len, 0) wasn't getting applied due to the Unsigned\n \tconversion used by Compute_Length.\n \t\n 2001-12-17  Arnaud Charlet <charlet@gnat.com>\n@@ -265,14 +379,14 @@\n \n 2001-12-17  Joel Brobecker <brobecke@gnat.com>\n \n-\t* gnat_rm.texi: Fix minor typos. Found while reading the section \n+\t* gnat_rm.texi: Fix minor typos. Found while reading the section\n \tregarding \"Bit_Order Clauses\" that was sent to a customer.\n \tVery interesting documentation!\n \t\n 2001-12-17  Robert Dewar <dewar@gnat.com>\n \n-\t* sem_case.adb (Choice_Image): Avoid creating improper character \n-\tliteral names by using the routine Set_Character_Literal_Name. This \n+\t* sem_case.adb (Choice_Image): Avoid creating improper character\n+\tliteral names by using the routine Set_Character_Literal_Name. This\n \tfixes bombs in certain error message cases.\n \t\n 2001-12-17  Arnaud Charlet <charlet@gnat.com>\n@@ -281,20 +395,20 @@\n \t\n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch12.adb (Validate_Derived_Type_Instance): Handle properly the \n-\tcase where the formal is an extension of another formal in the current \n+\t* sem_ch12.adb (Validate_Derived_Type_Instance): Handle properly the\n+\tcase where the formal is an extension of another formal in the current\n \tunit or in a parent generic unit.\n \t\n 2001-12-17  Arnaud Charlet <charlet@gnat.com>\n \n-\t* s-tposen.adb: Update comments.  Minor reformatting. \n+\t* s-tposen.adb: Update comments.  Minor reformatting.\n \tMinor code clean up.\n \t\n \t* s-tarest.adb: Update comments.  Minor code reorganization.\n \t\n 2001-12-17  Gary Dismukes <dismukes@gnat.com>\n \n-\t* exp_attr.adb (Attribute_Tag): Suppress expansion of <type_name>'Tag \n+\t* exp_attr.adb (Attribute_Tag): Suppress expansion of <type_name>'Tag\n \twhen Java_VM.\n \t\n 2001-12-17  Robert Dewar <dewar@gnat.com>\n@@ -303,7 +417,7 @@\n \t\n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch3.adb (Build_Derived_Private_Type): Refine check to handle \n+\t* sem_ch3.adb (Build_Derived_Private_Type): Refine check to handle\n \tderivations nested within a child unit: verify that the parent\n \ttype is declared in an outer scope.\n \t\n@@ -313,16 +427,16 @@\n \t\n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_warn.adb (Check_One_Unit): In No_Run_Time mode, do not post \n-\twarning if current unit is a predefined one, from which bodies may \n+\t* sem_warn.adb (Check_One_Unit): In No_Run_Time mode, do not post\n+\twarning if current unit is a predefined one, from which bodies may\n \thave been deleted.\n \t\n 2001-12-17  Robert Dewar <dewar@gnat.com>\n \n \t* eval_fat.ads: Add comment that Round_Even is referenced in Ada code\n \tFix header format. Add 2001 to copyright date.\n \t\n-\t* exp_dbug.adb (Get_Encoded_Name): Fix out of bounds reference, \n+\t* exp_dbug.adb (Get_Encoded_Name): Fix out of bounds reference,\n \twhich caused CE during compilation if checks were enabled.\n \n 2001-12-17  Vincent Celier <celier@gnat.com>\n@@ -334,13 +448,13 @@\n \t(Collect_Arguments_And_Compile): Use new function Switches_Of.\n \tWhen using a project file, test if there are any relative\n \tsearch path. Fail if there are any.\n-\t(Gnatmake): Only add switches for the primary directory when not using \n-\ta project file. When using a project file, change directory to the \n-\tobject directory of the main project file. When using a project file, \n-\ttest if there are any relative search path. Fail if there are any. \n-\tWhen using a project file, fail if specified executable is relative \n-\tpath with directory information, and prepend executable, if not \n-\tspecified as an absolute path, with the exec directory.  Make sure \n+\t(Gnatmake): Only add switches for the primary directory when not using\n+\ta project file. When using a project file, change directory to the\n+\tobject directory of the main project file. When using a project file,\n+\ttest if there are any relative search path. Fail if there are any.\n+\tWhen using a project file, fail if specified executable is relative\n+\tpath with directory information, and prepend executable, if not\n+\tspecified as an absolute path, with the exec directory.  Make sure\n \tthat only one -o switch is transmitted to the linker.\n \t\n \t* prj-attr.adb (Initialization_Data): Add project attribute Exec_Dir\n@@ -375,23 +489,23 @@\n \n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* trans.c (process_freeze_entity): Do nothing if the entity is a \n+\t* trans.c (process_freeze_entity): Do nothing if the entity is a\n \tsubprogram that was already elaborated.\n \t\n 2001-12-17  Richard Kenner <kenner@gnat.com>\n \t\n-\t* decl.c (gnat_to_gnu_entity, object): Do not back-annotate Alignment \n+\t* decl.c (gnat_to_gnu_entity, object): Do not back-annotate Alignment\n \tand Esize if object is referenced via pointer.\n \n 2001-12-17  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch3.adb (Analyze_Variant_Part): check that type of discriminant \n+\t* sem_ch3.adb (Analyze_Variant_Part): check that type of discriminant\n \tis discrete before analyzing choices.\n \t\n 2001-12-17  Joel Brobecker <brobecke@gnat.com>\n \n-\t* bindgen.adb (Gen_Output_File_Ada): Generate a new C-like string \n-\tcontaining the name of the Ada Main Program. This string is mainly \n+\t* bindgen.adb (Gen_Output_File_Ada): Generate a new C-like string\n+\tcontaining the name of the Ada Main Program. This string is mainly\n \tintended for the debugger.\n \t(Gen_Output_File_C): Do the equivalent change when generating a C file.\n \t\n@@ -439,10 +553,10 @@\n \n 2001-12-17  Robert Dewar <dewar@gnat.com>\n \n-\t* frontend.adb: Move call to Check_Unused_Withs from Frontend, so \n+\t* frontend.adb: Move call to Check_Unused_Withs from Frontend, so\n \tthat it happens before modification of Sloc values for -gnatD.\n \t\n-\t* gnat1drv.adb: Move call to Check_Unused_Withs to Frontend, \n+\t* gnat1drv.adb: Move call to Check_Unused_Withs to Frontend,\n \tso that it happens before modification of Sloc values for -gnatD.\n \t\n \t* switch.adb: Minor reformatting\n@@ -481,19 +595,19 @@\n \n 2001-12-14  Vincent Celier <celier@gnat.com>\n \n-\t* osint.adb(Create_Debug_File): When an object file is specified, \n+\t* osint.adb(Create_Debug_File): When an object file is specified,\n \tput the .dg file in the same directory as the object file.\n \t\n 2001-12-14  Robert Dewar <dewar@gnat.com>\n \n \t* osint.adb: Minor reformatting\n \t\n-\t* lib-xref.adb (Output_Instantiation): New procedure to generate \n+\t* lib-xref.adb (Output_Instantiation): New procedure to generate\n \tinstantiation references.\n \t\n \t* lib-xref.ads: Add documentation of handling of generic references.\n \t\n-\t* ali.adb (Read_Instantiation_Ref): New procedure to read \n+\t* ali.adb (Read_Instantiation_Ref): New procedure to read\n \tinstantiation references\n \t\n \t* ali.ads: Add spec for storing instantiation references\n@@ -515,35 +629,35 @@\n \t\n 2001-12-14  Matt Gingell <gingell@gnat.com>\n \n-\t* adaint.c: mktemp is a macro on Lynx and can not be used as an \n+\t* adaint.c: mktemp is a macro on Lynx and can not be used as an\n \texpression.\n \t\n 2001-12-14  Richard Kenner <kenner@gnat.com>\n \n-\t* misc.c (gnat_expand_constant): Do not strip UNCHECKED_CONVERT_EXPR \n+\t* misc.c (gnat_expand_constant): Do not strip UNCHECKED_CONVERT_EXPR\n \tif operand is CONSTRUCTOR.\n \t\n 2001-12-14  Ed Schonberg <schonber@gnat.com>\n \n-\t* trans.c (tree_transform, case N_Assignment_Statement): Set lineno \n-\tbefore emiting check on right-hand side, so that exception information \n+\t* trans.c (tree_transform, case N_Assignment_Statement): Set lineno\n+\tbefore emiting check on right-hand side, so that exception information\n \tis correct.\n \n 2001-12-14  Richard Kenner <kenner@gnat.com>\n \t\n-\t* utils.c (create_var_decl): Throw away initializing expression \n+\t* utils.c (create_var_decl): Throw away initializing expression\n \tif just annotating types and non-constant.\n \t\n 2001-12-14  Vincent Celier <celier@gnat.com>\n \n \t* prj-nmsc.adb: (Ada_Check): Migrate drom Ada_Default_... to\n \tDefault_Ada_...\n \t\n-\t* prj.adb: (Ada_Default_Spec_Suffix, Ada_Default_Impl_Suffix): \n+\t* prj.adb: (Ada_Default_Spec_Suffix, Ada_Default_Impl_Suffix):\n \tRemove functions.\n \t(Default_Ada_Spec_Suffix, Default_Ada_Impl_Suffix): Move to spec.\n \t\n-\t* prj.ads: (Ada_Default_Spec_Suffix, Ada_Default_Impl_Suffix): \n+\t* prj.ads: (Ada_Default_Spec_Suffix, Ada_Default_Impl_Suffix):\n \tRemove functions.\n \t(Default_Ada_Spec_Suffix, Default_Ada_Impl_Suffix): Move from body.\n \n@@ -577,17 +691,17 @@\n \n 2001-12-12  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch12.adb (Save_Entity_Descendant): Use syntactic field names \n+\t* sem_ch12.adb (Save_Entity_Descendant): Use syntactic field names\n \ton known node types, rather than untyped fields. Further cleanups.\n \t\n 2001-12-12  Robert Dewar <dewar@gnat.com>\n \n \t* sem_ch12.adb:\n \t(Save_Entity_Descendant): Minor comment update.\n \t(Copy_Generic_Node): Deal with incorrect reference to Associated_Node\n-\t of an N_Attribute_Reference node. As per note below, this does not \n+\t of an N_Attribute_Reference node. As per note below, this does not\n \teliminate need for Associated_Node in attribute ref nodes.\n-\t(Associated_Node): Documentation explicitly mentions attribute \n+\t(Associated_Node): Documentation explicitly mentions attribute\n \treference nodes, since this field is used in such nodes.\n \t\n \t* sem_ch12.adb (Associated_Node): Minor documentation cleanup.\n@@ -600,26 +714,26 @@\n \t\n \t* prj-dect.ads: Fix copyright header\n \t\n-\t* s-arit64.adb (Multiply_With_Ovflo_Check): Fix case where both \n+\t* s-arit64.adb (Multiply_With_Ovflo_Check): Fix case where both\n \tinputs fit in 32 bits, but the result still overflows.\n \t\n \t* s-fatgen.ads: Minor comment improvement\n \t\n 2001-12-12  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch4.adb (Analyze_Selected_Component): If the prefix is of a \n-\tformal derived type, look for an inherited component from the full \n+\t* sem_ch4.adb (Analyze_Selected_Component): If the prefix is of a\n+\tformal derived type, look for an inherited component from the full\n \tview of the parent, if any.\n \t\n 2001-12-12  Robert Dewar <dewar@gnat.com>\n \n \t* checks.ads (Apply_Alignment_Check): New procedure.\n \t\n-\t* exp_ch13.adb (Expand_N_Freeze_Entity): Generate dynamic check to \n-\tensure that the alignment of objects with address clauses is \n+\t* exp_ch13.adb (Expand_N_Freeze_Entity): Generate dynamic check to\n+\tensure that the alignment of objects with address clauses is\n \tappropriate, and raise PE if not.\n \n-\t* exp_util.ads (Must_Be_Aligned): Removed, replaced by \n+\t* exp_util.ads (Must_Be_Aligned): Removed, replaced by\n \tExp_Pakd.Known_Aligned_Enough\n \t\n \t* mdllfile.ads: Minor reformatting\n@@ -628,18 +742,18 @@\n \t\n 2001-12-12  Ed Schonberg <schonber@gnat.com>\n \n-\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration): Extend previous \n-\tfix to any component reference if enclosing record has non-standard \n+\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration): Extend previous\n+\tfix to any component reference if enclosing record has non-standard\n \trepresentation.\n \t\n 2001-12-12  Vincent Celier <celier@gnat.com>\n \n-\t* g-dirope.ads (Find, Wildcard_Iterator): Moved to child package \n+\t* g-dirope.ads (Find, Wildcard_Iterator): Moved to child package\n \tIteration\n \t\n 2001-12-12  Ed Schonberg <schonber@gnat.com>\n \n-\t* freeze.ads: Make Freeze_Fixed_Point_Type visible, for use in \n+\t* freeze.ads: Make Freeze_Fixed_Point_Type visible, for use in\n \tsem_attr.\n \t\n 2001-12-12  Robert Dewar <dewar@gnat.com>\n@@ -653,14 +767,14 @@\n \t\n 2001-12-12  Pascal Obry <obry@gnat.com>\n \n-\t* g-dirope.adb (Expand_Path.Var): Correctly detect end of \n+\t* g-dirope.adb (Expand_Path.Var): Correctly detect end of\n \tvariable name.\n \n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \n \t* sem_ch10.adb (Install_Withed_Unit): If the unit is a generic instance\n-\tthat is the parent of other generics, the instance body replaces the \n-\tinstance node.  Retrieve the instance of the spec, which is the one \n+\tthat is the parent of other generics, the instance body replaces the\n+\tinstance node.  Retrieve the instance of the spec, which is the one\n \tthat is visible in clients and within the body.\n \n 2001-12-11  Vincent Celier <celier@gnat.com>\n@@ -677,7 +791,7 @@\n \t\n 2001-12-11  Vincent Celier <celier@gnat.com>\n \n-\t* prj-attr.adb (Initialization_Data): Change name from \n+\t* prj-attr.adb (Initialization_Data): Change name from\n \tInitialisation_Data.\n \t\n 2001-12-11  Emmanuel Briot <briot@gnat.com>\n@@ -687,7 +801,7 @@\n \t\n 2001-12-11  Vasiliy Fofanov <fofanov@gnat.com>\n \n-\t* g-os_lib.ads: String_List type added, Argument_List type is now \n+\t* g-os_lib.ads: String_List type added, Argument_List type is now\n \tsubtype of String_List.\n \t\n 2001-12-11  Robert Dewar <dewar@gnat.com>\n@@ -697,7 +811,7 @@\n \t\n 2001-12-11  Vincent Celier <celier@gnat.com>\n \n-\t* g-dirope.adb (Expand_Path): Fix bug. (wrong length when adding a \n+\t* g-dirope.adb (Expand_Path): Fix bug. (wrong length when adding a\n \tstring to the buffer).\n \n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n@@ -706,18 +820,18 @@\n \tsem_attr.\n \t\n \t* sem_attr.adb: Simplify previous fix for Address.\n-\t(Set_Bounds): If prefix is a non-frozen fixed-point type, freeze now, \n-\tto avoid anomalies where the bound of the type appears to raise \n+\t(Set_Bounds): If prefix is a non-frozen fixed-point type, freeze now,\n+\tto avoid anomalies where the bound of the type appears to raise\n \tconstraint error.\n \n 2001-12-11  Robert Dewar <dewar@gnat.com>\n \n-\t* lib-xref.adb (Output_Refs): Make sure pointers are always properly \n+\t* lib-xref.adb (Output_Refs): Make sure pointers are always properly\n \thandled.\n \t\n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Check for a \n+\t* sem_ch12.adb (Analyze_Subprogram_Instantiation): Check for a\n \trenamed unit before checking for recursive instantiations.\n \t\n 2001-12-11  Emmanuel Briot <briot@gnat.com>\n@@ -726,15 +840,15 @@\n \n 2001-12-11  Robert Dewar <dewar@gnat.com>\n \n-\t* lib-xref.adb (Output_Refs): Don't output type references outside \n+\t* lib-xref.adb (Output_Refs): Don't output type references outside\n \tthe main unit if they are not otherwise referenced.\n \t\n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_attr.adb (Analyze_attribute, case Address and Size): Simplify \n+\t* sem_attr.adb (Analyze_attribute, case Address and Size): Simplify\n \tcode and diagnose additional illegal uses\n \t\n-\t* sem_util.adb (Is_Object_Reference): An indexed component is an \n+\t* sem_util.adb (Is_Object_Reference): An indexed component is an\n \tobject only if the prefix is.\n \t\n 2001-12-11  Vincent Celier <celier@gnat.com>\n@@ -759,10 +873,10 @@\n \t\n 2001-12-11  Robert Dewar <dewar@gnat.com>\n \n-\t* exp_util.adb (Must_Be_Aligned): Removed, replaced by \n+\t* exp_util.adb (Must_Be_Aligned): Removed, replaced by\n \tExp_Pakd.Known_Aligned_Enough\n \t\n-\t* sem_ch13.adb (Check_Address_Alignment): Removed, extended \n+\t* sem_ch13.adb (Check_Address_Alignment): Removed, extended\n \tversion is moved to Exp_Ch13.\n \n 2001-12-11  Robert Dewar <dewar@gnat.com>\n@@ -781,18 +895,18 @@\n \t\n \t* exp_pakd.adb (Known_Aligned_Enough): Replaces Known_Aligned_Enough.\n \t\n-\t* lib-xref.adb: Extend generation of <..> notation to cover \n-\tsubtype/object types. Note that this is a complete rewrite, \n-\tgetting rid of the very nasty quadratic algorithm previously \n+\t* lib-xref.adb: Extend generation of <..> notation to cover\n+\tsubtype/object types. Note that this is a complete rewrite,\n+\tgetting rid of the very nasty quadratic algorithm previously\n \tused for derived type output.\n \t\n-\t* lib-xref.ads: Extend description of <..> notation to cover \n-\tsubtype/object types. Uses {..} for these other cases. \n+\t* lib-xref.ads: Extend description of <..> notation to cover\n+\tsubtype/object types. Uses {..} for these other cases.\n \tAlso use (..) for pointer types.\n \t\n \t* sem_util.adb (Check_Potentially_Blocking_Operation): Slight cleanup.\n \t\n-\t* exp_pakd.adb: Minor reformatting.  Note that prevous RH should say: \n+\t* exp_pakd.adb: Minor reformatting.  Note that prevous RH should say:\n \t(Known_Aligned_Enough): Replaces Must_Be_Aligned.\n \n 2001-12-11  Vincent Celier <celier@gnat.com>\n@@ -816,26 +930,26 @@\n \n 2001-12-11  Robert Dewar <dewar@gnat.com>\n \n-\t* checks.adb (Insert_Valid_Check): Apply validity check to expression \n+\t* checks.adb (Insert_Valid_Check): Apply validity check to expression\n \tof conversion, not to result of conversion.\n \n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \t\n-\t* sem_ch3.adb (Build_Derived_Record_Type): set Controlled flag \n-\tbefore freezing parent. If the declarations are mutually recursive, \n-\tan access to the current record type may be frozen before the \n+\t* sem_ch3.adb (Build_Derived_Record_Type): set Controlled flag\n+\tbefore freezing parent. If the declarations are mutually recursive,\n+\tan access to the current record type may be frozen before the\n \tderivation is complete.\n \n 2001-12-05  Vincent Celier <celier@gnat.com>\n \n-\t* gnatcmd.adb: (MAKE): Add new translations: -b /BIND_ONLY, \n+\t* gnatcmd.adb: (MAKE): Add new translations: -b /BIND_ONLY,\n \t-c /COMPILE_ONLY, -l /LINK_ONLY\n \t\n \t* opt.ads:\n \t(Bind_Only): New Flag\n \t(Link_Only): New flag\n \t\n-\t* switch.adb (Scan_Make_Switches): Add processing for -b (Bind_Only) \n+\t* switch.adb (Scan_Make_Switches): Add processing for -b (Bind_Only)\n \tand -l (Link_Only)\n \t\n \t* makeusg.adb: Add new switches -b and -l. Update Copyright notice.\n@@ -849,28 +963,28 @@\n \n 2001-12-05  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_eval.adb (Eval_Concatenation): If left operand is a null string, \n+\t* sem_eval.adb (Eval_Concatenation): If left operand is a null string,\n \tget bounds from right operand.\n \t\n \t* sem_eval.adb: Minor reformatting\n \t\n-\t* exp_util.adb (Make_Literal_Range): use bound of literal rather \n+\t* exp_util.adb (Make_Literal_Range): use bound of literal rather\n \tthan Index'First, its lower bound may be different from 1.\n \t\n-\t* exp_util.adb: Undo earlier change, fixes ACVC regressions C48009B \n+\t* exp_util.adb: Undo earlier change, fixes ACVC regressions C48009B\n \tand C48009J\n \t\n 2001-12-05  Vincent Celier <celier@gnat.com>\n \n \t* prj-nmsc.adb Minor reformatting\n \t\n-\t* prj-nmsc.adb (Language_Independent_Check): Reset Library flag if \n+\t* prj-nmsc.adb (Language_Independent_Check): Reset Library flag if\n \tset and libraries are not supported.\n \t\n 2001-12-05  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch3.adb (Build_Derived_Private_Type): set Public status of \n-\tprivate view explicitly, so the back-end can treat as a global \n+\t* sem_ch3.adb (Build_Derived_Private_Type): set Public status of\n+\tprivate view explicitly, so the back-end can treat as a global\n \twhen appropriate.\n \n 2001-12-05  Ed Schonberg <schonber@gnat.com>\n@@ -880,11 +994,11 @@\n \n 2001-12-05  Vincent Celier <celier@gnat.com>\n \t\n-\t* prj-nmsc.adb (Language_Independent_Check): Issue a warning if \n-\tlibraries are not supported and both attributes Library_Name and \n+\t* prj-nmsc.adb (Language_Independent_Check): Issue a warning if\n+\tlibraries are not supported and both attributes Library_Name and\n \tLibrary_Dir are specified.\n \t\n-\t* prj-proc.adb (Expression): Set location of Result to location of \n+\t* prj-proc.adb (Expression): Set location of Result to location of\n \tfirst term.\n \t\n \t* Makefile.in: Add mlib.o, mlib-fil.o, mlib-tgt and mlib-utl to GNATLS.\n@@ -905,7 +1019,7 @@\n \n 2001-12-05  Robert Dewar <dewar@gnat.com>\n \n-\t* checks.adb (Determine_Range): Increase cache size for checks. \n+\t* checks.adb (Determine_Range): Increase cache size for checks.\n \tMinor reformatting\n \t\n \t* exp_ch6.adb: Minor reformatting\n@@ -914,20 +1028,20 @@\n \tsubprograms as pure in the code generator is almost surely a mistake\n \tthat will lead to unexpected results.\n \t\n-\t* exp_util.adb (Remove_Side_Effects): Clean up old ??? comment and \n+\t* exp_util.adb (Remove_Side_Effects): Clean up old ??? comment and\n \tchange handling of conversions.\n \t\n \t* g-regexp.adb: Use System.IO instead of Ada.Text_IO.\n \n 2001-12-05  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch3.adb (Analyze_Object_Declaration): If expression is an \n-\taggregate with static wrong size, attach generated Raise node to \n+\t* sem_ch3.adb (Analyze_Object_Declaration): If expression is an\n+\taggregate with static wrong size, attach generated Raise node to\n \tdeclaration.\n \n 2001-12-05  Robert Dewar <dewar@gnat.com>\n \n-\t* sem_attr.adb (Analyze_Attribute): Defend against bad Val attribute. \n+\t* sem_attr.adb (Analyze_Attribute): Defend against bad Val attribute.\n \tFixes compilation abandoned bomb in B24009B.\n \n 2001-12-05  Ed Schonberg <schonber@gnat.com>\n@@ -962,7 +1076,7 @@\n \t\n \t* prj-nmsc.adb: Minor comment changes (modifying -> extends).\n \t\n-\t* prj-part.adb (Parse_Single_Project): Change Tok_Modifying to \n+\t* prj-part.adb (Parse_Single_Project): Change Tok_Modifying to\n \tTok_Extends.\n \t\n \t* prj.adb (Initialize): Change Modifying to Extends.\n@@ -975,10 +1089,10 @@\n \n 2001-12-05  Robert Dewar <dewar@gnat.com>\n \n-\t* sem_warn.adb: Remove stuff for conditionals, we are not going to \n+\t* sem_warn.adb: Remove stuff for conditionals, we are not going to\n \tdo this after all.\n \t\n-\t* sem_warn.ads: Remove stuff for conditionals, we are not going to \n+\t* sem_warn.ads: Remove stuff for conditionals, we are not going to\n \tdo this after all.  Add 2001 to copyright notice\n \n 2001-12-04  Geert Bosch <bosch@gnat.com>\n@@ -987,8 +1101,8 @@\n \n 2001-12-04  Robert Dewar <dewar@gnat.com>\n \n-\t* errout.adb (Error_Msg): Ignore attempt to put error msg at junk \n-\tlocation if we already have errors. Stops some cases of cascaded \n+\t* errout.adb (Error_Msg): Ignore attempt to put error msg at junk\n+\tlocation if we already have errors. Stops some cases of cascaded\n \terrors.\n \t\n \t* errout.adb: Improve comment.\n@@ -999,7 +1113,7 @@\n \t(Analyze_Formal_Type_Definition): Defend against Error.\n \t(Analyze_Formal_Subprogram): Defend against Error.\n \t\n-\t* par-ch12.adb (F_Formal_Type_Declaration): In case of error, \n+\t* par-ch12.adb (F_Formal_Type_Declaration): In case of error,\n \tremove following semicolon if present. Removes cascaded error.\n \n 2001-12-04  Douglas B. Rupp <rupp@gnat.com>\n@@ -1016,22 +1130,22 @@\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* einfo.ads: Block_Node points to the identifier of the block, not to \n-\tthe block node itself, to preserve the link when the block is \n-\trewritten, e.g. within an if-statement with a static condition. \n+\t* einfo.ads: Block_Node points to the identifier of the block, not to\n+\tthe block node itself, to preserve the link when the block is\n+\trewritten, e.g. within an if-statement with a static condition.\n \t\n-\t* inline.adb (Cleanup_Scopes): recover block statement from block \n+\t* inline.adb (Cleanup_Scopes): recover block statement from block\n \tentity using new meaning of Block_Node.\n \t\n-\t* sem_ch5.adb (Analyze_Block_Statement): set Block_Node to point to \n+\t* sem_ch5.adb (Analyze_Block_Statement): set Block_Node to point to\n \tidentifier of block node, rather than to node itself.\n \n 2001-12-04  Gary Dismukes <dismukes@gnat.com>\n \t\n \t* layout.adb:\n \t(Get_Max_Size): Fix \"start of processing\" comment to say Get_Max_Size.\n \t(Discrimify): Go back to setting the Etypes of the selected component\n-\tbecause the Vname component does not exist at this point and will \n+\tbecause the Vname component does not exist at this point and will\n \tfail name resolution. Also set Analyzed.\n \tRemove with and use of Sem_Res.\n \n@@ -1048,28 +1162,28 @@\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch7.adb (New_Private_Type): Set Is_Tagged_Type flag before \n+\t* sem_ch7.adb (New_Private_Type): Set Is_Tagged_Type flag before\n \tprocessing discriminants to diagnose illegal default values.\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_attr.adb (Resolve_Attribute): Handle properly an non-classwide \n-\taccess discriminant within a type extension that constrains its \n+\t* sem_attr.adb (Resolve_Attribute): Handle properly an non-classwide\n+\taccess discriminant within a type extension that constrains its\n \tparent discriminants.\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_ch3.adb (Find_Type_Of_Subtype_Indic): If subtype indication \n+\t* sem_ch3.adb (Find_Type_Of_Subtype_Indic): If subtype indication\n \tis malformed, use instance of Any_Id to allow analysis to proceed.\n \t\n-\t* par-ch12.adb (P_Formal_Type_Declaration): Propagate Error if \n+\t* par-ch12.adb (P_Formal_Type_Declaration): Propagate Error if\n \ttype definition is illegal.\n \t(P_Formal_Derived_Type_Definition): Better recovery when TAGGED is\n \tmisplaced.\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_warn.adb (Output_Unreferenced_Messages): Extend previous fix to \n+\t* sem_warn.adb (Output_Unreferenced_Messages): Extend previous fix to\n \tconstants.\n \n 2001-12-04  Robert Dewar <dewar@gnat.com>\n@@ -1080,13 +1194,13 @@\n \n \t* exp_util.adb: Minor reformatting from last change\n \t\n-\t* errout.adb (Check_For_Warning): For a Raised_Constraint_Error node \n-\twhich is a rewriting of an expression, traverse the original \n+\t* errout.adb (Check_For_Warning): For a Raised_Constraint_Error node\n+\twhich is a rewriting of an expression, traverse the original\n \texpression to remove warnings that may have been posted on it.\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* exp_util.adb (Must_Be_Aligned): Return false for a component of a \n+\t* exp_util.adb (Must_Be_Aligned): Return false for a component of a\n \trecord that has other packed components.\n \n 2001-12-04  Douglass B. Rupp <rupp@gnat.com>\n@@ -1099,7 +1213,7 @@\n \n 2001-12-04  Arnaud Charlet <charlet@gnat.com>\n \n-\t* Makefile.adalib: Clarify step 3 (use of gnat.adc) as it causes \n+\t* Makefile.adalib: Clarify step 3 (use of gnat.adc) as it causes\n \tmore confusion than it solves.\n \n 2001-12-04  Geert bosch <bosch@gnat.com>\n@@ -1108,12 +1222,12 @@\n \n 2001-12-04  Geert Bosch  <bosch@gnat.com>\n \n-\t* Makefile.in (update-sources): New target. \n+\t* Makefile.in (update-sources): New target.\n \tFor use by gcc_release script.\n \n 2001-12-04  Ed Schonberg <schonber@gnat.com>\n \n-\t* sem_prag.adb (Analyze_Pragma, case Validity_Checks): do not treat as \n+\t* sem_prag.adb (Analyze_Pragma, case Validity_Checks): do not treat as\n \ta configuration pragma, it is now legal wherever a pragma can appear.\n \n 2001-12-04  Zack Weinberg  <zack@codesourcery.com>"}, {"sha": "1cd8ff6dba6ee495479165d00083dff5d5aa1793", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 101, "deletions": 134, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -1,5 +1,5 @@\n # Top level makefile fragment for GNU Ada (GNAT).\n-#   Copyright (C) 1994, 1995, 1996, 1997, 1997, 1999, 2000, 2001\n+#   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002\n #   Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n@@ -22,7 +22,7 @@\n # This file provides the language dependent support in the main Makefile.\n # Each language makefile fragment must provide the following targets:\n #\n-# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n+# foo.all.cross, foo.start.encap, foo.rest.encap,\n # foo.info, foo.dvi,\n # foo.install-normal, foo.install-common, foo.install-info, foo.install-man,\n # foo.uninstall, foo.mostlyclean, foo.clean, foo.distclean, foo.extraclean,\n@@ -47,21 +47,21 @@ shext  =\n \f\n # Extra flags to pass to recursive makes.\n BOOT_ADAFLAGS= $(ADAFLAGS)\n-ADAFLAGS= -W -Wall -gnatpg -gnata\n+ADAFLAGS= -gnatpg -gnata\n GNATLIBFLAGS= -W -Wall -gnatpg\n GNATLIBCFLAGS= -g -O2\n ADA_INCLUDE_DIR = $(libsubdir)/adainclude\n ADA_RTL_OBJ_DIR = $(libsubdir)/adalib\n THREAD_KIND=native\n+TRACE=no\n GNATBIND = gnatbind\n ADA_FLAGS_TO_PASS = \\\n-\t\"ADA_CFLAGS=$(CFLAGS)\" \\\n-\t\"ADA_FOR_BUILD=$(ADA_FOR_BUILD)\" \\\n-\t\"ADA_INCLUDE_DIR=$(ADA_INCLUDE_DIR)\" \\\n-\t\"ADA_RTL_OBJ_DIR=$(ADA_RTL_OBJ_DIR)\" \\\n-\t\"ADAFLAGS=$(ADAFLAGS)\" \\\n-\t\"ADA_FOR_TARGET=$(ADA_FOR_TARGET)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"ADA_FOR_BUILD=$(ADA_FOR_BUILD)\"\t\\\n+\t\"ADA_INCLUDE_DIR=$(ADA_INCLUDE_DIR)\"\t\\\n+\t\"ADA_RTL_OBJ_DIR=$(ADA_RTL_OBJ_DIR)\"\t\\\n+\t\"ADAFLAGS=$(ADAFLAGS)\"\t\t\t\\\n+\t\"ADA_FOR_TARGET=$(ADA_FOR_TARGET)\"\t\\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\"\t\t\\\n \t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\"\n \n # Define the names for selecting Ada in LANGUAGES.\n@@ -72,110 +72,79 @@ Ada ada: gnat1$(exeext) gnatbind$(exeext)\n \n # There are too many Ada sources to check against here.  Let's\n # always force the recursive make.\n+ADA_TOOLS_FLAGS_TO_PASS=\\\n+        \"CC=../../xgcc -B../../\"\t\\\n+        \"CFLAGS=$(CFLAGS)\"\t\t\\\n+\t\"exeext=$(exeext)\"              \\\n+        \"ADAFLAGS=$(ADAFLAGS)\"\t\t\\\n+        \"ADA_INCLUDES=-I../rts\"\t\t\\\n+\t\"GNATMAKE=../../gnatmake\"\t\\\n+\t\"GNATLINK=../../gnatlink\"\t\\\n+\t\"GNATBIND=../../gnatbind\"\n+\n gnat1$(exeext): prefix.o attribs.o $(LIBDEPS) $(BACKEND) force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n+\t$(MAKE) -C ada $(SUBDIR_FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n \t\t../gnat1$(exeext)\n \n-gnatbind$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n+gnatbind$(exeext): force\n+\t$(MAKE) -C ada $(SUBDIR_FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n \t\t../gnatbind$(exeext)\n \n-gnatmake$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatmake$(exeext)\n-\n-gnatbl$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatbl$(exeext)\n-\n-gnatchop$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatchop$(exeext)\n-\n-gnatcmd$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatcmd$(exeext)\n-\n-gnatlink$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatlink$(exeext)\n-\n-gnatkr$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatkr$(exeext)\n-\n-gnatls$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatls$(exeext)\n-\n-gnatmem$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatmem$(exeext)\n-\n-gnatprep$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatprep$(exeext)\n-\n-gnatpsta$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatpsta$(exeext)\n-\n-gnatpsys$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatpsys$(exeext)\n-\n-gnatxref$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatxref$(exeext)\n-\n-gnatfind$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatfind$(exeext)\n-\n-# Gnatlbr is extra tool only used on VMS\n-\n-gnatlbr$(exeext): $(CONFIG_H) prefix.o force\n-\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t\t../gnatlbr$(exeext)\n-\n-# use target-gcc\n+# use target-gcc target-gnatmake target-gnatbind target-gnatlink \n gnattools: $(GCC_PARTS) force\n-\t$(MAKE) $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t   CC=\"../xgcc -B../\" STAGE_PREFIX=../ \\\n-\t   gnatbl$(exeext) gnatchop$(exeext) gnatcmd$(exeext) \\\n-\t   gnatkr$(exeext) gnatlink$(exeext) \\\n-\t   gnatls$(exeext) gnatmake$(exeext) \\\n-\t   gnatprep$(exeext) gnatpsta$(exeext) gnatpsys$(exeext) \\\n-       gnatxref$(exeext) gnatfind$(exeext) $(EXTRA_GNATTOOLS)\n-\n-# use host-gcc\n+\t$(MAKE) -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n+\t   ADA_INCLUDES=\"-I- -I../rts\"\\\n+\t   CC=\"../../xgcc -B../../\" STAGE_PREFIX=../../  gnattools1\n+\t$(MAKE) -C ada $(ADA_TOOLS_FLAGS_TO_PASS) gnattools2\n+\t$(MAKE) -C ada $(ADA_TOOLS_FLAGS_TO_PASS) gnattools3\n+\n+regnattools: \n+\t$(MAKE) -C ada $(ADA_TOOLS_FLAGS_TO_PASS) gnattools1-re\n+\t$(MAKE) -C ada $(ADA_TOOLS_FLAGS_TO_PASS) gnattools2\n+\t$(MAKE) -C ada $(ADA_TOOLS_FLAGS_TO_PASS) gnattools3\n+\n+# use host-gcc host-gnatmake host-gnatbind host-gnatlink\n+# put the host RTS dir first in the PATH to hide the default runtime\n+# files that are among the sources\n+RTS_DIR:=$(dir $(subst \\,/,$(shell $(CC) -print-libgcc-file-name)))\n cross-gnattools: force\n-\t$(MAKE) $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n-\t   gnatbl$(exeext) gnatchop$(exeext) gnatcmd$(exeext) \\\n-\t   gnatkr$(exeext) gnatlink$(exeext) \\\n-\t   gnatls$(exeext) gnatmake$(exeext) \\\n-\t   gnatprep$(exeext) gnatpsta$(exeext) gnatpsys$(exeext) \\\n-\t   gnatxref$(exeext) gnatfind$(exeext) $(EXTRA_GNATTOOLS)\n-\n-# use target-gcc\n+\t$(MAKE)  -C ada $(FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS)\\\n+\t   ADA_INCLUDES=\"-I$(RTS_DIR)adainclude -I$(RTS_DIR)adalib\" \\\n+\t   GNATMAKE=\"gnatmake\" \\\n+           GNATBIND=\"gnatbind\" \\\n+           GNATLINK=\"gnatlink\" \\\n+           LIBGNAT=\"\" \\\n+\t   gnattools1-re gnattools2\n+  \n+rts-none: force\n+\t$(MAKE) -C ada  $(FLAGS_TO_PASS) GNATMAKE=../gnatmake rts-none\n+\n+install-rts-none: force\n+\t$(MAKE) -C ada  $(FLAGS_TO_PASS) install-rts RTS_NAME=none\n+\n+rts-ravenscar: force\n+\t$(MAKE) -C ada  $(FLAGS_TO_PASS) GNATMAKE=../gnatmake rts-ravenscar\n+\n+install-rts-ravenscar: force\n+\t$(MAKE) -C ada  $(FLAGS_TO_PASS) install-rts RTS_NAME=ravenscar\n+\n gnatlib: force\n \t$(MAKE) -C ada $(FLAGS_TO_PASS)  \\\n-\t   CC=\"../xgcc -B../\" ADAC=\"../xgcc -B../\" STAGE_PREFIX=../ \\\n \t   GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n \t   GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n \t   TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" \\\n \t   THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t   TRACE=\"$(TRACE)\" \\\n \t   gnatlib\n \n-# use target-gcc\n gnatlib-shared: force\n \t$(MAKE) -C ada $(FLAGS_TO_PASS)  \\\n-\t   CC=\"../xgcc -B../\" ADAC=\"../xgcc -B../\" STAGE_PREFIX=../ \\\n \t   GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n \t   GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n \t   GNATLIBLDFLAGS=\"$(GNATLIBLDFLAGS)\" \\\n \t   TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" \\\n \t   THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t   TRACE=\"$(TRACE)\" \\\n \t   gnatlib-shared\n \n # use only for native compiler\n@@ -187,7 +156,6 @@ gnat-cross: force\n \f\n # Build hooks:\n \n-ada.all.build: \n ada.all.cross:\n \t-if [ -f gnatbind$(exeext) ] ; \\\n \tthen \\\n@@ -201,9 +169,9 @@ ada.all.cross:\n \tthen \\\n \t  $(MV) gnatchop$(exeext)   gnatchop-cross$(exeext); \\\n \tfi\n-\t-if [ -f gnatcmd$(exeext) ] ; \\\n+\t-if [ -f gnat$(exeext) ] ; \\\n \tthen \\\n-\t   $(MV) gnatcmd$(exeext)  gnatcmd-cross$(exeext); \\\n+\t   $(MV) gnat$(exeext)  gnat-cross$(exeext); \\\n \tfi\n \t-if [ -f gnatkr$(exeext) ] ; \\\n \tthen \\\n@@ -225,6 +193,10 @@ ada.all.cross:\n \tthen \\\n \t   $(MV) gnatmem$(exeext)  gnatmem-cross$(exeext); \\\n \tfi\n+\t-if [ -f gnatname$(exeext) ] ; \\\n+\tthen \\\n+\t   $(MV) gnatname$(exeext)  gnatname-cross$(exeext); \\\n+\tfi\n \t-if [ -f gnatprep$(exeext) ] ; \\\n \tthen \\\n \t   $(MV) gnatprep$(exeext)  gnatprep-cross$(exeext); \\\n@@ -233,10 +205,6 @@ ada.all.cross:\n \tthen \\\n \t   $(MV) gnatpsta$(exeext)  gnatpsta-cross$(exeext); \\\n \tfi\n-\t-if [ -f gnatpsys$(exeext) ] ; \\\n-\tthen \\\n-\t   $(MV) gnatpsys$(exeext)  gnatpsys-cross$(exeext); \\\n-\tfi\n \t-if [ -f gnatxref$(exeext) ] ; \\\n \tthen \\\n \t   $(MV) gnatxref$(exeext)  gnatxref-cross$(exeext); \\\n@@ -259,7 +227,7 @@ ada.install-normal:\n \n # Install the binder program as $(target_alias)-gnatbind\n # and also as either gnatbind (if native) or $(tooldir)/bin/gnatbind\n-# likewise for gnatf, gnatchop, and gnatlink, gnatkr, gnatmake, gnatcmd,\n+# likewise for gnatf, gnatchop, and gnatlink, gnatkr, gnatmake, gnat,\n # gnatprep, gnatbl, gnatls, gnatxref, gnatfind\n ada.install-common:\n \t-if [ -f gnat1$(exeext) ] ; \\\n@@ -294,7 +262,7 @@ ada.install-common:\n \tfi\n \t-if [ -f gnat1$(exeext) ] ; \\\n \tthen \\\n-\t  if [ -f gnatchop-cross$(exeext) ] ; \\\n+\t  if [ -f gnatchop-cross$(shext) ] ; \\\n \t  then \\\n \t    $(RM) $(bindir)/$(target_alias)-gnatchop$(shext); \\\n \t    $(INSTALL_PROGRAM) $(srcdir)/ada/gnatchop$(shext) $(bindir)/$(target_alias)-gnatchop$(shext); \\\n@@ -324,17 +292,17 @@ ada.install-common:\n \tfi\n \t-if [ -f gnat1$(exeext) ] ; \\\n \tthen \\\n-\t  if [ -f gnatcmd-cross$(exeext) ] ; \\\n+\t  if [ -f gnat-cross$(exeext) ] ; \\\n \t  then \\\n \t    $(RM) $(bindir)/$(target_alias)-gnat$(exeext); \\\n-\t    $(INSTALL_PROGRAM) gnatcmd-cross$(exeext) $(bindir)/$(target_alias)-gnat$(exeext); \\\n+\t    $(INSTALL_PROGRAM) gnat-cross$(exeext) $(bindir)/$(target_alias)-gnat$(exeext); \\\n \t    if [ -d $(tooldir)/bin/. ] ; then \\\n \t       rm -f $(tooldir)/bin/gnat$(exeext); \\\n-\t       $(INSTALL_PROGRAM) gnatcmd-cross$(exeext) $(tooldir)/bin/gnat$(exeext); \\\n+\t       $(INSTALL_PROGRAM) gnat-cross$(exeext) $(tooldir)/bin/gnat$(exeext); \\\n             fi; \\\n \t  else \\\n \t    $(RM) $(bindir)/gnat$(exeext); \\\n-\t    $(INSTALL_PROGRAM) gnatcmd$(exeext) $(bindir)/gnat$(exeext); \\\n+\t    $(INSTALL_PROGRAM) gnat$(exeext) $(bindir)/gnat$(exeext); \\\n \t  fi ; \\\n \tfi\n \t-if [ -f gnat1$(exeext) ] ; \\\n@@ -409,6 +377,17 @@ ada.install-common:\n \t  fi ; \\\n \tfi\n \t-if [ -f gnat1$(exeext) ] ; \\\n+\tthen \\\n+\t  if [ -f gnatname-cross$(exeext) ] ; \\\n+\t  then \\\n+\t    $(RM) $(bindir)/$(target_alias)-gnatname$(exeext); \\\n+\t    $(INSTALL_PROGRAM) gnatname-cross$(exeext) $(bindir)/$(target_alias)-gnatname$(exeext); \\\n+\t  else \\\n+\t    $(RM) $(bindir)/gnatname$(exeext); \\\n+\t    $(INSTALL_PROGRAM) gnatname$(exeext) $(bindir)/gnatname$(exeext); \\\n+\t  fi ; \\\n+\tfi\n+\t-if [ -f gnat1$(exeext) ] ; \\\n \tthen \\\n \t  if [ -f gnatprep-cross$(exeext) ] ; \\\n \t  then \\\n@@ -438,21 +417,6 @@ ada.install-common:\n \t    $(INSTALL_PROGRAM) gnatpsta$(exeext) $(bindir)/gnatpsta$(exeext); \\\n \t  fi ; \\\n \tfi\n-\t-if [ -f gnat1$(exeext) ] ; \\\n-\tthen \\\n-\t  if [ -f gnatpsys-cross$(exeext) ] ; \\\n-\t  then \\\n-\t    $(RM) $(bindir)/$(target_alias)-gnatpsys$(exeext); \\\n-\t    $(INSTALL_PROGRAM) gnatpsys-cross$(exeext) $(bindir)/$(target_alias)-gnatpsys$(exeext); \\\n-\t    if [ -d $(tooldir)/bin/. ] ; then \\\n-\t       rm -f $(tooldir)/bin/gnatpsys$(exeext); \\\n-\t       $(INSTALL_PROGRAM) gnatpsys-cross$(exeext) $(tooldir)/bin/gnatpsys$(exeext); \\\n-            fi; \\\n-\t  else \\\n-\t    $(RM) $(bindir)/gnatpsys$(exeext); \\\n-\t    $(INSTALL_PROGRAM) gnatpsys$(exeext) $(bindir)/gnatpsys$(exeext); \\\n-\t  fi ; \\\n-    fi\n \t-if [ -f gnat1$(exeext) ] ; \\\n \tthen \\\n \t  if [ -f gnatxref-cross$(exeext) ] ; \\\n@@ -475,16 +439,18 @@ ada.install-common:\n \t    $(INSTALL_PROGRAM) gnatfind$(exeext) $(bindir)/gnatfind$(exeext); \\\n \t  fi ; \\\n \tfi\n-#\n-# Gnatlbr is only use on VMS\n-#\n \t-if [ -f gnat1$(exeext) ] ; \\\n \tthen \\\n \t  if [ -f gnatchop$(exeext) ] ; \\\n \t  then \\\n \t    $(RM) $(bindir)/gnatchop$(exeext); \\\n \t    $(INSTALL_PROGRAM) gnatchop$(exeext) $(bindir)/gnatchop$(exeext); \\\n \t  fi ; \\\n+#\n+# Gnatlbr is only used on VMS.\n+#\n+\t-if [ -f gnat1$(exeext) ] ; \\\n+\tthen \\\n \t  if [ -f gnatlbr$(exeext) ] ; \\\n \t  then \\\n \t    $(RM) $(bindir)/gnatlbr$(exeext); \\\n@@ -517,44 +483,44 @@ ada.uninstall:\n \t-$(RM) $(bindir)/gnatbind$(exeext)\n \t-$(RM) $(bindir)/gnatbl$(exeext)\n \t-$(RM) $(bindir)/gnatchop$(exeext)\n-\t-$(RM) $(bindir)/gnatcmd$(exeext)\n+\t-$(RM) $(bindir)/gnat$(exeext)\n \t-$(RM) $(bindir)/gnatdll$(exeext)\n \t-$(RM) $(bindir)/gnatkr$(exeext)\n \t-$(RM) $(bindir)/gnatlink$(exeext)\n \t-$(RM) $(bindir)/gnatls$(exeext)\n \t-$(RM) $(bindir)/gnatmake$(exeext)\n \t-$(RM) $(bindir)/gnatmem$(exeext)\n+\t-$(RM) $(bindir)/gnatname$(exeext)\n \t-$(RM) $(bindir)/gnatprep$(exeext)\n \t-$(RM) $(bindir)/gnatpsta$(exeext)\n-\t-$(RM) $(bindir)/gnatpsys$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatbind$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatbl$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatchop$(exeext)\n-\t-$(RM) $(bindir)/$(target_alias)-gnatcmd$(exeext)\n+\t-$(RM) $(bindir)/$(target_alias)-gnat$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatkr(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatlink$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatls$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatmake$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatmem$(exeext)\n+\t-$(RM) $(bindir)/$(target_alias)-gnatname$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatprep$(exeext)\n \t-$(RM) $(bindir)/$(target_alias)-gnatpsta$(exeext)\n-\t-$(RM) $(bindir)/$(target_alias)-gnatpsys$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatbind$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatbl$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatchop$(exeext)\n-\t-$(RM) $(tooldir)/bin/gnatcmd$(exeext)\n+\t-$(RM) $(tooldir)/bin/gnat$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatdll$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatkr$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatlink$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatls$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatmake$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatmem$(exeext)\n+\t-$(RM) $(tooldir)/bin/gnatname$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatprep$(exeext)\n \t-$(RM) $(tooldir)/bin/gnatpsta$(exeext)\n-\t-$(RM) $(tooldir)/bin/gnatpsys$(exeext)\n # Gnatlbr and Gnatchop are only used on VMS\n \t-$(RM) $(bindir)/gnatlbr$(exeext) $(bindir)/gnatchop$(exeext)\n-\f\n+\n # Clean hooks:\n # A lot of the ancillary files are deleted by the main makefile.\n # We just have to delete files specific to us.\n@@ -568,22 +534,23 @@ ada.distclean:\n \t-$(RM) ada/Makefile\n \t-$(RM) gnatbl$(exeext)\n \t-$(RM) gnatchop$(exeext)\n-\t-$(RM) gnatcmd$(exeext)\n+\t-$(RM) gnat$(exeext)\n \t-$(RM) gnatdll$(exeext)\n \t-$(RM) gnatkr$(exeext)\n \t-$(RM) gnatlink$(exeext)\n \t-$(RM) gnatls$(exeext)\n \t-$(RM) gnatmake$(exeext)\n \t-$(RM) gnatmem$(exeext)\n+\t-$(RM) gnatname$(exeext)\n \t-$(RM) gnatprep$(exeext)\n \t-$(RM) gnatpsta$(exeext)\n-\t-$(RM) gnatpsys$(exeext)\n \t-$(RM) gnatfind$(exeext)\n \t-$(RM) gnatxref$(exeext)\n-# Gnatlbr and Gnatchop are only used on VMS\n-\t-$(RM) gnatchop$(exeext) gnatlbr$(exeext)\n+# Gnatlbr is only used on VMS\n+\t-$(RM) gnatlbr$(exeext)\n \t-$(RM) ada/rts/*\n \t-$(RMDIR) ada/rts\n+\t-$(RM) ada/tools/*\n \t-$(RMDIR) ada/tools\n ada.extraclean:\n ada.maintainer-clean:"}, {"sha": "cd2fb22122afab708f1cfdb3a8a4823733cc888b", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 1991, "deletions": 2258, "changes": 4249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9a5aa29a1ceeba2cc66851923ef5929a992a6405", "filename": "gcc/ada/a-caldel.adb", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-caldel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-caldel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.37 $\n+--                             $Revision$\n --                                                                          --\n --             Copyright (C) 1991-2001 Florida State University             --\n --                                                                          --\n@@ -41,13 +41,21 @@ with System.OS_Primitives;\n with System.Soft_Links;\n --  Used for Timed_Delay\n \n+with System.Traces;\n+--  Used for Send_Trace_Info\n+\n+with System.Parameters;\n+--  used for Runtime_Traces\n+\n package body Ada.Calendar.Delays is\n \n    package OSP renames System.OS_Primitives;\n    package SSL renames System.Soft_Links;\n \n    use type SSL.Timed_Delay_Call;\n \n+   use System.Traces;\n+\n    --  Earlier, the following operations were implemented using\n    --  System.Time_Operations.  The idea was to avoid sucking in the tasking\n    --  packages.  This did not work.  Logically, we can't have it both ways.\n@@ -68,17 +76,35 @@ package body Ada.Calendar.Delays is\n \n    procedure Delay_For (D : Duration) is\n    begin\n+      if System.Parameters.Runtime_Traces then\n+         Send_Trace_Info (W_Delay, D);\n+      end if;\n+\n       SSL.Timed_Delay.all (Duration'Min (D, OSP.Max_Sensible_Delay),\n-        OSP.Relative);\n+                           OSP.Relative);\n+\n+      if System.Parameters.Runtime_Traces then\n+         Send_Trace_Info (M_Delay, D);\n+      end if;\n    end Delay_For;\n \n    -----------------\n    -- Delay_Until --\n    -----------------\n \n    procedure Delay_Until (T : Time) is\n+      D : constant Duration := To_Duration (T);\n+\n    begin\n-      SSL.Timed_Delay.all (To_Duration (T), OSP.Absolute_Calendar);\n+      if System.Parameters.Runtime_Traces then\n+         Send_Trace_Info (WU_Delay, D);\n+      end if;\n+\n+      SSL.Timed_Delay.all (D, OSP.Absolute_Calendar);\n+\n+      if System.Parameters.Runtime_Traces then\n+         Send_Trace_Info (M_Delay, D);\n+      end if;\n    end Delay_Until;\n \n    --------------------"}, {"sha": "b1fbd9e434a02f5f965a291edc4b7ee681f06db4", "filename": "gcc/ada/a-chlat9.ads", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-chlat9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-chlat9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chlat9.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -0,0 +1,336 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--               A D A . C H A R A C T E R S . L A T I N _ 9                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--            Copyright (C) 2002 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the modifications made to Ada.Characters.Latin_1,  noted --\n+-- in the text, to derive the equivalent Latin-9 package.                   --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides definitions for Latin-9 (ISO-8859-9) analogous to\n+--  those defined in the standard package Ada.Characters.Latin_1 for Latin-1.\n+\n+package Ada.Characters.Latin_9 is\n+pragma Pure (Latin_9);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL                  : constant Character := Character'Val (0);\n+   SOH                  : constant Character := Character'Val (1);\n+   STX                  : constant Character := Character'Val (2);\n+   ETX                  : constant Character := Character'Val (3);\n+   EOT                  : constant Character := Character'Val (4);\n+   ENQ                  : constant Character := Character'Val (5);\n+   ACK                  : constant Character := Character'Val (6);\n+   BEL                  : constant Character := Character'Val (7);\n+   BS                   : constant Character := Character'Val (8);\n+   HT                   : constant Character := Character'Val (9);\n+   LF                   : constant Character := Character'Val (10);\n+   VT                   : constant Character := Character'Val (11);\n+   FF                   : constant Character := Character'Val (12);\n+   CR                   : constant Character := Character'Val (13);\n+   SO                   : constant Character := Character'Val (14);\n+   SI                   : constant Character := Character'Val (15);\n+\n+   DLE                  : constant Character := Character'Val (16);\n+   DC1                  : constant Character := Character'Val (17);\n+   DC2                  : constant Character := Character'Val (18);\n+   DC3                  : constant Character := Character'Val (19);\n+   DC4                  : constant Character := Character'Val (20);\n+   NAK                  : constant Character := Character'Val (21);\n+   SYN                  : constant Character := Character'Val (22);\n+   ETB                  : constant Character := Character'Val (23);\n+   CAN                  : constant Character := Character'Val (24);\n+   EM                   : constant Character := Character'Val (25);\n+   SUB                  : constant Character := Character'Val (26);\n+   ESC                  : constant Character := Character'Val (27);\n+   FS                   : constant Character := Character'Val (28);\n+   GS                   : constant Character := Character'Val (29);\n+   RS                   : constant Character := Character'Val (30);\n+   US                   : constant Character := Character'Val (31);\n+\n+   --------------------------------\n+   -- ISO 646 Graphic Characters --\n+   --------------------------------\n+\n+   Space                : constant Character := ' ';  -- Character'Val(32)\n+   Exclamation          : constant Character := '!';  -- Character'Val(33)\n+   Quotation            : constant Character := '\"';  -- Character'Val(34)\n+   Number_Sign          : constant Character := '#';  -- Character'Val(35)\n+   Dollar_Sign          : constant Character := '$';  -- Character'Val(36)\n+   Percent_Sign         : constant Character := '%';  -- Character'Val(37)\n+   Ampersand            : constant Character := '&';  -- Character'Val(38)\n+   Apostrophe           : constant Character := ''';  -- Character'Val(39)\n+   Left_Parenthesis     : constant Character := '(';  -- Character'Val(40)\n+   Right_Parenthesis    : constant Character := ')';  -- Character'Val(41)\n+   Asterisk             : constant Character := '*';  -- Character'Val(42)\n+   Plus_Sign            : constant Character := '+';  -- Character'Val(43)\n+   Comma                : constant Character := ',';  -- Character'Val(44)\n+   Hyphen               : constant Character := '-';  -- Character'Val(45)\n+   Minus_Sign           : Character renames Hyphen;\n+   Full_Stop            : constant Character := '.';  -- Character'Val(46)\n+   Solidus              : constant Character := '/';  -- Character'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Character := ':';  -- Character'Val(58)\n+   Semicolon            : constant Character := ';';  -- Character'Val(59)\n+   Less_Than_Sign       : constant Character := '<';  -- Character'Val(60)\n+   Equals_Sign          : constant Character := '=';  -- Character'Val(61)\n+   Greater_Than_Sign    : constant Character := '>';  -- Character'Val(62)\n+   Question             : constant Character := '?';  -- Character'Val(63)\n+\n+   Commercial_At        : constant Character := '@';  -- Character'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Character := '[';  -- Character'Val (91)\n+   Reverse_Solidus      : constant Character := '\\';  -- Character'Val (92)\n+   Right_Square_Bracket : constant Character := ']';  -- Character'Val (93)\n+   Circumflex           : constant Character := '^';  -- Character'Val (94)\n+   Low_Line             : constant Character := '_';  -- Character'Val (95)\n+\n+   Grave                : constant Character := '`';  -- Character'Val (96)\n+   LC_A                 : constant Character := 'a';  -- Character'Val (97)\n+   LC_B                 : constant Character := 'b';  -- Character'Val (98)\n+   LC_C                 : constant Character := 'c';  -- Character'Val (99)\n+   LC_D                 : constant Character := 'd';  -- Character'Val (100)\n+   LC_E                 : constant Character := 'e';  -- Character'Val (101)\n+   LC_F                 : constant Character := 'f';  -- Character'Val (102)\n+   LC_G                 : constant Character := 'g';  -- Character'Val (103)\n+   LC_H                 : constant Character := 'h';  -- Character'Val (104)\n+   LC_I                 : constant Character := 'i';  -- Character'Val (105)\n+   LC_J                 : constant Character := 'j';  -- Character'Val (106)\n+   LC_K                 : constant Character := 'k';  -- Character'Val (107)\n+   LC_L                 : constant Character := 'l';  -- Character'Val (108)\n+   LC_M                 : constant Character := 'm';  -- Character'Val (109)\n+   LC_N                 : constant Character := 'n';  -- Character'Val (110)\n+   LC_O                 : constant Character := 'o';  -- Character'Val (111)\n+   LC_P                 : constant Character := 'p';  -- Character'Val (112)\n+   LC_Q                 : constant Character := 'q';  -- Character'Val (113)\n+   LC_R                 : constant Character := 'r';  -- Character'Val (114)\n+   LC_S                 : constant Character := 's';  -- Character'Val (115)\n+   LC_T                 : constant Character := 't';  -- Character'Val (116)\n+   LC_U                 : constant Character := 'u';  -- Character'Val (117)\n+   LC_V                 : constant Character := 'v';  -- Character'Val (118)\n+   LC_W                 : constant Character := 'w';  -- Character'Val (119)\n+   LC_X                 : constant Character := 'x';  -- Character'Val (120)\n+   LC_Y                 : constant Character := 'y';  -- Character'Val (121)\n+   LC_Z                 : constant Character := 'z';  -- Character'Val (122)\n+   Left_Curly_Bracket   : constant Character := '{';  -- Character'Val (123)\n+   Vertical_Line        : constant Character := '|';  -- Character'Val (124)\n+   Right_Curly_Bracket  : constant Character := '}';  -- Character'Val (125)\n+   Tilde                : constant Character := '~';  -- Character'Val (126)\n+   DEL                  : constant Character := Character'Val (127);\n+\n+   ---------------------------------\n+   -- ISO 6429 Control Characters --\n+   ---------------------------------\n+\n+   IS4 : Character renames FS;\n+   IS3 : Character renames GS;\n+   IS2 : Character renames RS;\n+   IS1 : Character renames US;\n+\n+   Reserved_128         : constant Character := Character'Val (128);\n+   Reserved_129         : constant Character := Character'Val (129);\n+   BPH                  : constant Character := Character'Val (130);\n+   NBH                  : constant Character := Character'Val (131);\n+   Reserved_132         : constant Character := Character'Val (132);\n+   NEL                  : constant Character := Character'Val (133);\n+   SSA                  : constant Character := Character'Val (134);\n+   ESA                  : constant Character := Character'Val (135);\n+   HTS                  : constant Character := Character'Val (136);\n+   HTJ                  : constant Character := Character'Val (137);\n+   VTS                  : constant Character := Character'Val (138);\n+   PLD                  : constant Character := Character'Val (139);\n+   PLU                  : constant Character := Character'Val (140);\n+   RI                   : constant Character := Character'Val (141);\n+   SS2                  : constant Character := Character'Val (142);\n+   SS3                  : constant Character := Character'Val (143);\n+\n+   DCS                  : constant Character := Character'Val (144);\n+   PU1                  : constant Character := Character'Val (145);\n+   PU2                  : constant Character := Character'Val (146);\n+   STS                  : constant Character := Character'Val (147);\n+   CCH                  : constant Character := Character'Val (148);\n+   MW                   : constant Character := Character'Val (149);\n+   SPA                  : constant Character := Character'Val (150);\n+   EPA                  : constant Character := Character'Val (151);\n+\n+   SOS                  : constant Character := Character'Val (152);\n+   Reserved_153         : constant Character := Character'Val (153);\n+   SCI                  : constant Character := Character'Val (154);\n+   CSI                  : constant Character := Character'Val (155);\n+   ST                   : constant Character := Character'Val (156);\n+   OSC                  : constant Character := Character'Val (157);\n+   PM                   : constant Character := Character'Val (158);\n+   APC                  : constant Character := Character'Val (159);\n+\n+   ------------------------------\n+   -- Other Graphic Characters --\n+   ------------------------------\n+\n+   --  Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space              : constant Character := Character'Val (160);\n+   NBSP                        : Character renames No_Break_Space;\n+   Inverted_Exclamation        : constant Character := Character'Val (161);\n+   Cent_Sign                   : constant Character := Character'Val (162);\n+   Pound_Sign                  : constant Character := Character'Val (163);\n+   Euro_Sign                   : constant Character := Character'Val (164);\n+   Yen_Sign                    : constant Character := Character'Val (165);\n+   UC_S_Caron                  : constant Character := Character'Val (166);\n+   Section_Sign                : constant Character := Character'Val (167);\n+   LC_S_Caron                  : constant Character := Character'Val (168);\n+   Copyright_Sign              : constant Character := Character'Val (169);\n+   Feminine_Ordinal_Indicator  : constant Character := Character'Val (170);\n+   Left_Angle_Quotation        : constant Character := Character'Val (171);\n+   Not_Sign                    : constant Character := Character'Val (172);\n+   Soft_Hyphen                 : constant Character := Character'Val (173);\n+   Registered_Trade_Mark_Sign  : constant Character := Character'Val (174);\n+   Macron                      : constant Character := Character'Val (175);\n+\n+   --  Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign                 : constant Character := Character'Val (176);\n+   Ring_Above                  : Character renames Degree_Sign;\n+   Plus_Minus_Sign             : constant Character := Character'Val (177);\n+   Superscript_Two             : constant Character := Character'Val (178);\n+   Superscript_Three           : constant Character := Character'Val (179);\n+   UC_Z_Caron                  : constant Character := Character'Val (180);\n+   Micro_Sign                  : constant Character := Character'Val (181);\n+   Pilcrow_Sign                : constant Character := Character'Val (182);\n+   Paragraph_Sign              : Character renames Pilcrow_Sign;\n+   Middle_Dot                  : constant Character := Character'Val (183);\n+   LC_Z_Caron                  : constant Character := Character'Val (184);\n+   Superscript_One             : constant Character := Character'Val (185);\n+   Masculine_Ordinal_Indicator : constant Character := Character'Val (186);\n+   Right_Angle_Quotation       : constant Character := Character'Val (187);\n+   UC_Ligature_OE              : constant Character := Character'Val (188);\n+   LC_Ligature_OE              : constant Character := Character'Val (189);\n+   UC_Y_Diaeresis              : constant Character := Character'Val (190);\n+   Inverted_Question           : constant Character := Character'Val (191);\n+\n+   --  Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave                  : constant Character := Character'Val (192);\n+   UC_A_Acute                  : constant Character := Character'Val (193);\n+   UC_A_Circumflex             : constant Character := Character'Val (194);\n+   UC_A_Tilde                  : constant Character := Character'Val (195);\n+   UC_A_Diaeresis              : constant Character := Character'Val (196);\n+   UC_A_Ring                   : constant Character := Character'Val (197);\n+   UC_AE_Diphthong             : constant Character := Character'Val (198);\n+   UC_C_Cedilla                : constant Character := Character'Val (199);\n+   UC_E_Grave                  : constant Character := Character'Val (200);\n+   UC_E_Acute                  : constant Character := Character'Val (201);\n+   UC_E_Circumflex             : constant Character := Character'Val (202);\n+   UC_E_Diaeresis              : constant Character := Character'Val (203);\n+   UC_I_Grave                  : constant Character := Character'Val (204);\n+   UC_I_Acute                  : constant Character := Character'Val (205);\n+   UC_I_Circumflex             : constant Character := Character'Val (206);\n+   UC_I_Diaeresis              : constant Character := Character'Val (207);\n+\n+   --  Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth            : constant Character := Character'Val (208);\n+   UC_N_Tilde                  : constant Character := Character'Val (209);\n+   UC_O_Grave                  : constant Character := Character'Val (210);\n+   UC_O_Acute                  : constant Character := Character'Val (211);\n+   UC_O_Circumflex             : constant Character := Character'Val (212);\n+   UC_O_Tilde                  : constant Character := Character'Val (213);\n+   UC_O_Diaeresis              : constant Character := Character'Val (214);\n+   Multiplication_Sign         : constant Character := Character'Val (215);\n+   UC_O_Oblique_Stroke         : constant Character := Character'Val (216);\n+   UC_U_Grave                  : constant Character := Character'Val (217);\n+   UC_U_Acute                  : constant Character := Character'Val (218);\n+   UC_U_Circumflex             : constant Character := Character'Val (219);\n+   UC_U_Diaeresis              : constant Character := Character'Val (220);\n+   UC_Y_Acute                  : constant Character := Character'Val (221);\n+   UC_Icelandic_Thorn          : constant Character := Character'Val (222);\n+   LC_German_Sharp_S           : constant Character := Character'Val (223);\n+\n+   --  Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave                  : constant Character := Character'Val (224);\n+   LC_A_Acute                  : constant Character := Character'Val (225);\n+   LC_A_Circumflex             : constant Character := Character'Val (226);\n+   LC_A_Tilde                  : constant Character := Character'Val (227);\n+   LC_A_Diaeresis              : constant Character := Character'Val (228);\n+   LC_A_Ring                   : constant Character := Character'Val (229);\n+   LC_AE_Diphthong             : constant Character := Character'Val (230);\n+   LC_C_Cedilla                : constant Character := Character'Val (231);\n+   LC_E_Grave                  : constant Character := Character'Val (232);\n+   LC_E_Acute                  : constant Character := Character'Val (233);\n+   LC_E_Circumflex             : constant Character := Character'Val (234);\n+   LC_E_Diaeresis              : constant Character := Character'Val (235);\n+   LC_I_Grave                  : constant Character := Character'Val (236);\n+   LC_I_Acute                  : constant Character := Character'Val (237);\n+   LC_I_Circumflex             : constant Character := Character'Val (238);\n+   LC_I_Diaeresis              : constant Character := Character'Val (239);\n+\n+   --  Character positions 240 (16#F0#) .. 255 (16#FF)\n+   LC_Icelandic_Eth            : constant Character := Character'Val (240);\n+   LC_N_Tilde                  : constant Character := Character'Val (241);\n+   LC_O_Grave                  : constant Character := Character'Val (242);\n+   LC_O_Acute                  : constant Character := Character'Val (243);\n+   LC_O_Circumflex             : constant Character := Character'Val (244);\n+   LC_O_Tilde                  : constant Character := Character'Val (245);\n+   LC_O_Diaeresis              : constant Character := Character'Val (246);\n+   Division_Sign               : constant Character := Character'Val (247);\n+   LC_O_Oblique_Stroke         : constant Character := Character'Val (248);\n+   LC_U_Grave                  : constant Character := Character'Val (249);\n+   LC_U_Acute                  : constant Character := Character'Val (250);\n+   LC_U_Circumflex             : constant Character := Character'Val (251);\n+   LC_U_Diaeresis              : constant Character := Character'Val (252);\n+   LC_Y_Acute                  : constant Character := Character'Val (253);\n+   LC_Icelandic_Thorn          : constant Character := Character'Val (254);\n+   LC_Y_Diaeresis              : constant Character := Character'Val (255);\n+\n+   ------------------------------------------------\n+   -- Summary of Changes from Latin-1 => Latin-9 --\n+   ------------------------------------------------\n+\n+   --   164     Currency                => Euro_Sign\n+   --   166     Broken_Bar              => UC_S_Caron\n+   --   168     Diaeresis               => LC_S_Caron\n+   --   180     Acute                   => UC_Z_Caron\n+   --   184     Cedilla                 => LC_Z_Caron\n+   --   188     Fraction_One_Quarter    => UC_Ligature_OE\n+   --   189     Fraction_One_Half       => LC_Ligature_OE\n+   --   190     Fraction_Three_Quarters => UC_Y_Diaeresis\n+\n+end Ada.Characters.Latin_9;"}, {"sha": "e2637b7f639bb96541873f6ad085cdf88fc282cc", "filename": "gcc/ada/a-comlin.ads", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.12 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -71,13 +71,48 @@ pragma Preelaborate (Command_Line);\n \n    procedure Set_Exit_Status (Code : Exit_Status);\n \n-private\n+   ------------------------------------\n+   -- Note on Interface Requirements --\n+   ------------------------------------\n+\n+   --  If the main program is in Ada, this package works as specified without\n+   --  any other work than the normal steps of WITH'ing the package and then\n+   --  calling the desired routines.\n+\n+   --  If the main program is not in Ada, then the information must be made\n+   --  available for this package to work correctly. In particular, it is\n+   --  required that the global variable \"gnat_argc\" contain the number of\n+   --  arguments, and that the global variable \"gnat_argv\" points to an\n+   --  array of null-terminated strings, the first entry being the command\n+   --  name, and the remaining entries being the command arguments.\n+\n+   --  These correspond to the normal argc/argv variables passed to a C\n+   --  main program, and the following is an example of a complete C main\n+   --  program that stores the required information:\n \n+   --    main(int argc, char **argv, char **envp)\n+   --    {\n+   --       extern int    gnat_argc;\n+   --       extern char **gnat_argv;\n+   --       extern char **gnat_envp;\n+   --       gnat_argc = argc;\n+   --       gnat_argv = argv;\n+   --       gnat_envp = envp;\n+\n+   --       adainit();\n+   --       adamain();\n+   --       adafinal();\n+   --    }\n+\n+   --  The assignment statements ensure that the necessary information is\n+   --  available for finding the command name and command line arguments.\n+\n+private\n    Success : constant Exit_Status := 0;\n    Failure : constant Exit_Status := 1;\n \n    --  The following locations support the operation of the package\n-   --  Ada.Command_Line_Remove, whih provides facilities for logically\n+   --  Ada.Command_Line.Remove, whih provides facilities for logically\n    --  removing arguments from the command line. If one of the remove\n    --  procedures is called in this unit, then Remove_Args/Remove_Count\n    --  are set to indicate which arguments are removed. If no such calls"}, {"sha": "7dcf532ec6afc8d588f1353a2505ae75022dc8a6", "filename": "gcc/ada/a-cwila9.ads", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-cwila9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-cwila9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cwila9.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -0,0 +1,338 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUNTIME COMPONENTS                          --\n+--                                                                          --\n+--          A D A . C H A R A C T E R S . W I D E _ L A T I N _ 9           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides definitions analogous to those in the GNAT\n+--  package Ada.Characters.Latin_9 except that the type of the constants\n+--  is Wide_Character instead of Character. The provision of this package\n+--  is in accordance with the implementation permission in RM (A.3.3(27)).\n+\n+package Ada.Characters.Wide_Latin_9 is\n+pragma Pure (Wide_Latin_9);\n+\n+   ------------------------\n+   -- Control Characters --\n+   ------------------------\n+\n+   NUL                  : constant Wide_Character := Wide_Character'Val (0);\n+   SOH                  : constant Wide_Character := Wide_Character'Val (1);\n+   STX                  : constant Wide_Character := Wide_Character'Val (2);\n+   ETX                  : constant Wide_Character := Wide_Character'Val (3);\n+   EOT                  : constant Wide_Character := Wide_Character'Val (4);\n+   ENQ                  : constant Wide_Character := Wide_Character'Val (5);\n+   ACK                  : constant Wide_Character := Wide_Character'Val (6);\n+   BEL                  : constant Wide_Character := Wide_Character'Val (7);\n+   BS                   : constant Wide_Character := Wide_Character'Val (8);\n+   HT                   : constant Wide_Character := Wide_Character'Val (9);\n+   LF                   : constant Wide_Character := Wide_Character'Val (10);\n+   VT                   : constant Wide_Character := Wide_Character'Val (11);\n+   FF                   : constant Wide_Character := Wide_Character'Val (12);\n+   CR                   : constant Wide_Character := Wide_Character'Val (13);\n+   SO                   : constant Wide_Character := Wide_Character'Val (14);\n+   SI                   : constant Wide_Character := Wide_Character'Val (15);\n+\n+   DLE                  : constant Wide_Character := Wide_Character'Val (16);\n+   DC1                  : constant Wide_Character := Wide_Character'Val (17);\n+   DC2                  : constant Wide_Character := Wide_Character'Val (18);\n+   DC3                  : constant Wide_Character := Wide_Character'Val (19);\n+   DC4                  : constant Wide_Character := Wide_Character'Val (20);\n+   NAK                  : constant Wide_Character := Wide_Character'Val (21);\n+   SYN                  : constant Wide_Character := Wide_Character'Val (22);\n+   ETB                  : constant Wide_Character := Wide_Character'Val (23);\n+   CAN                  : constant Wide_Character := Wide_Character'Val (24);\n+   EM                   : constant Wide_Character := Wide_Character'Val (25);\n+   SUB                  : constant Wide_Character := Wide_Character'Val (26);\n+   ESC                  : constant Wide_Character := Wide_Character'Val (27);\n+   FS                   : constant Wide_Character := Wide_Character'Val (28);\n+   GS                   : constant Wide_Character := Wide_Character'Val (29);\n+   RS                   : constant Wide_Character := Wide_Character'Val (30);\n+   US                   : constant Wide_Character := Wide_Character'Val (31);\n+\n+   -------------------------------------\n+   -- ISO 646 Graphic Wide_Characters --\n+   -------------------------------------\n+\n+   Space                : constant Wide_Character := ' ';  -- WC'Val(32)\n+   Exclamation          : constant Wide_Character := '!';  -- WC'Val(33)\n+   Quotation            : constant Wide_Character := '\"';  -- WC'Val(34)\n+   Number_Sign          : constant Wide_Character := '#';  -- WC'Val(35)\n+   Dollar_Sign          : constant Wide_Character := '$';  -- WC'Val(36)\n+   Percent_Sign         : constant Wide_Character := '%';  -- WC'Val(37)\n+   Ampersand            : constant Wide_Character := '&';  -- WC'Val(38)\n+   Apostrophe           : constant Wide_Character := ''';  -- WC'Val(39)\n+   Left_Parenthesis     : constant Wide_Character := '(';  -- WC'Val(40)\n+   Right_Parenthesis    : constant Wide_Character := ')';  -- WC'Val(41)\n+   Asterisk             : constant Wide_Character := '*';  -- WC'Val(42)\n+   Plus_Sign            : constant Wide_Character := '+';  -- WC'Val(43)\n+   Comma                : constant Wide_Character := ',';  -- WC'Val(44)\n+   Hyphen               : constant Wide_Character := '-';  -- WC'Val(45)\n+   Minus_Sign           : Wide_Character renames Hyphen;\n+   Full_Stop            : constant Wide_Character := '.';  -- WC'Val(46)\n+   Solidus              : constant Wide_Character := '/';  -- WC'Val(47)\n+\n+   --  Decimal digits '0' though '9' are at positions 48 through 57\n+\n+   Colon                : constant Wide_Character := ':';  -- WC'Val(58)\n+   Semicolon            : constant Wide_Character := ';';  -- WC'Val(59)\n+   Less_Than_Sign       : constant Wide_Character := '<';  -- WC'Val(60)\n+   Equals_Sign          : constant Wide_Character := '=';  -- WC'Val(61)\n+   Greater_Than_Sign    : constant Wide_Character := '>';  -- WC'Val(62)\n+   Question             : constant Wide_Character := '?';  -- WC'Val(63)\n+\n+   Commercial_At        : constant Wide_Character := '@';  -- WC'Val(64)\n+\n+   --  Letters 'A' through 'Z' are at positions 65 through 90\n+\n+   Left_Square_Bracket  : constant Wide_Character := '[';  -- WC'Val (91)\n+   Reverse_Solidus      : constant Wide_Character := '\\';  -- WC'Val (92)\n+   Right_Square_Bracket : constant Wide_Character := ']';  -- WC'Val (93)\n+   Circumflex           : constant Wide_Character := '^';  -- WC'Val (94)\n+   Low_Line             : constant Wide_Character := '_';  -- WC'Val (95)\n+\n+   Grave                : constant Wide_Character := '`';  -- WC'Val (96)\n+   LC_A                 : constant Wide_Character := 'a';  -- WC'Val (97)\n+   LC_B                 : constant Wide_Character := 'b';  -- WC'Val (98)\n+   LC_C                 : constant Wide_Character := 'c';  -- WC'Val (99)\n+   LC_D                 : constant Wide_Character := 'd';  -- WC'Val (100)\n+   LC_E                 : constant Wide_Character := 'e';  -- WC'Val (101)\n+   LC_F                 : constant Wide_Character := 'f';  -- WC'Val (102)\n+   LC_G                 : constant Wide_Character := 'g';  -- WC'Val (103)\n+   LC_H                 : constant Wide_Character := 'h';  -- WC'Val (104)\n+   LC_I                 : constant Wide_Character := 'i';  -- WC'Val (105)\n+   LC_J                 : constant Wide_Character := 'j';  -- WC'Val (106)\n+   LC_K                 : constant Wide_Character := 'k';  -- WC'Val (107)\n+   LC_L                 : constant Wide_Character := 'l';  -- WC'Val (108)\n+   LC_M                 : constant Wide_Character := 'm';  -- WC'Val (109)\n+   LC_N                 : constant Wide_Character := 'n';  -- WC'Val (110)\n+   LC_O                 : constant Wide_Character := 'o';  -- WC'Val (111)\n+   LC_P                 : constant Wide_Character := 'p';  -- WC'Val (112)\n+   LC_Q                 : constant Wide_Character := 'q';  -- WC'Val (113)\n+   LC_R                 : constant Wide_Character := 'r';  -- WC'Val (114)\n+   LC_S                 : constant Wide_Character := 's';  -- WC'Val (115)\n+   LC_T                 : constant Wide_Character := 't';  -- WC'Val (116)\n+   LC_U                 : constant Wide_Character := 'u';  -- WC'Val (117)\n+   LC_V                 : constant Wide_Character := 'v';  -- WC'Val (118)\n+   LC_W                 : constant Wide_Character := 'w';  -- WC'Val (119)\n+   LC_X                 : constant Wide_Character := 'x';  -- WC'Val (120)\n+   LC_Y                 : constant Wide_Character := 'y';  -- WC'Val (121)\n+   LC_Z                 : constant Wide_Character := 'z';  -- WC'Val (122)\n+   Left_Curly_Bracket   : constant Wide_Character := '{';  -- WC'Val (123)\n+   Vertical_Line        : constant Wide_Character := '|';  -- WC'Val (124)\n+   Right_Curly_Bracket  : constant Wide_Character := '}';  -- WC'Val (125)\n+   Tilde                : constant Wide_Character := '~';  -- WC'Val (126)\n+   DEL                  : constant Wide_Character := Wide_Character'Val (127);\n+\n+   --------------------------------------\n+   -- ISO 6429 Control Wide_Characters --\n+   --------------------------------------\n+\n+   IS4 : Wide_Character renames FS;\n+   IS3 : Wide_Character renames GS;\n+   IS2 : Wide_Character renames RS;\n+   IS1 : Wide_Character renames US;\n+\n+   Reserved_128         : constant Wide_Character := Wide_Character'Val (128);\n+   Reserved_129         : constant Wide_Character := Wide_Character'Val (129);\n+   BPH                  : constant Wide_Character := Wide_Character'Val (130);\n+   NBH                  : constant Wide_Character := Wide_Character'Val (131);\n+   Reserved_132         : constant Wide_Character := Wide_Character'Val (132);\n+   NEL                  : constant Wide_Character := Wide_Character'Val (133);\n+   SSA                  : constant Wide_Character := Wide_Character'Val (134);\n+   ESA                  : constant Wide_Character := Wide_Character'Val (135);\n+   HTS                  : constant Wide_Character := Wide_Character'Val (136);\n+   HTJ                  : constant Wide_Character := Wide_Character'Val (137);\n+   VTS                  : constant Wide_Character := Wide_Character'Val (138);\n+   PLD                  : constant Wide_Character := Wide_Character'Val (139);\n+   PLU                  : constant Wide_Character := Wide_Character'Val (140);\n+   RI                   : constant Wide_Character := Wide_Character'Val (141);\n+   SS2                  : constant Wide_Character := Wide_Character'Val (142);\n+   SS3                  : constant Wide_Character := Wide_Character'Val (143);\n+\n+   DCS                  : constant Wide_Character := Wide_Character'Val (144);\n+   PU1                  : constant Wide_Character := Wide_Character'Val (145);\n+   PU2                  : constant Wide_Character := Wide_Character'Val (146);\n+   STS                  : constant Wide_Character := Wide_Character'Val (147);\n+   CCH                  : constant Wide_Character := Wide_Character'Val (148);\n+   MW                   : constant Wide_Character := Wide_Character'Val (149);\n+   SPA                  : constant Wide_Character := Wide_Character'Val (150);\n+   EPA                  : constant Wide_Character := Wide_Character'Val (151);\n+\n+   SOS                  : constant Wide_Character := Wide_Character'Val (152);\n+   Reserved_153         : constant Wide_Character := Wide_Character'Val (153);\n+   SCI                  : constant Wide_Character := Wide_Character'Val (154);\n+   CSI                  : constant Wide_Character := Wide_Character'Val (155);\n+   ST                   : constant Wide_Character := Wide_Character'Val (156);\n+   OSC                  : constant Wide_Character := Wide_Character'Val (157);\n+   PM                   : constant Wide_Character := Wide_Character'Val (158);\n+   APC                  : constant Wide_Character := Wide_Character'Val (159);\n+\n+   -----------------------------------\n+   -- Other Graphic Wide_Characters --\n+   -----------------------------------\n+\n+   --  Wide_Character positions 160 (16#A0#) .. 175 (16#AF#)\n+\n+   No_Break_Space       : constant Wide_Character := Wide_Character'Val (160);\n+   NBSP                 : Wide_Character renames No_Break_Space;\n+   Inverted_Exclamation : constant Wide_Character := Wide_Character'Val (161);\n+   Cent_Sign            : constant Wide_Character := Wide_Character'Val (162);\n+   Pound_Sign           : constant Wide_Character := Wide_Character'Val (163);\n+   Euro_Sign            : constant Wide_Character := Wide_Character'Val (164);\n+   Yen_Sign             : constant Wide_Character := Wide_Character'Val (165);\n+   UC_S_Caron           : constant Wide_Character := Wide_Character'Val (166);\n+   Section_Sign         : constant Wide_Character := Wide_Character'Val (167);\n+   LC_S_Caron           : constant Wide_Character := Wide_Character'Val (168);\n+   Copyright_Sign       : constant Wide_Character := Wide_Character'Val (169);\n+   Feminine_Ordinal_Indicator\n+                        : constant Wide_Character := Wide_Character'Val (170);\n+   Left_Angle_Quotation : constant Wide_Character := Wide_Character'Val (171);\n+   Not_Sign             : constant Wide_Character := Wide_Character'Val (172);\n+   Soft_Hyphen          : constant Wide_Character := Wide_Character'Val (173);\n+   Registered_Trade_Mark_Sign\n+                        : constant Wide_Character := Wide_Character'Val (174);\n+   Macron               : constant Wide_Character := Wide_Character'Val (175);\n+\n+   --  Wide_Character positions 176 (16#B0#) .. 191 (16#BF#)\n+\n+   Degree_Sign          : constant Wide_Character := Wide_Character'Val (176);\n+   Ring_Above           : Wide_Character renames Degree_Sign;\n+   Plus_Minus_Sign      : constant Wide_Character := Wide_Character'Val (177);\n+   Superscript_Two      : constant Wide_Character := Wide_Character'Val (178);\n+   Superscript_Three    : constant Wide_Character := Wide_Character'Val (179);\n+   UC_Z_Caron           : constant Wide_Character := Wide_Character'Val (180);\n+   Micro_Sign           : constant Wide_Character := Wide_Character'Val (181);\n+   Pilcrow_Sign         : constant Wide_Character := Wide_Character'Val (182);\n+   Paragraph_Sign       : Wide_Character renames Pilcrow_Sign;\n+   Middle_Dot           : constant Wide_Character := Wide_Character'Val (183);\n+   LC_Z_Caron           : constant Wide_Character := Wide_Character'Val (184);\n+   Superscript_One      : constant Wide_Character := Wide_Character'Val (185);\n+   Masculine_Ordinal_Indicator\n+                        : constant Wide_Character := Wide_Character'Val (186);\n+   Right_Angle_Quotation\n+                        : constant Wide_Character := Wide_Character'Val (187);\n+   UC_Ligature_OE       : constant Wide_Character := Wide_Character'Val (188);\n+   LC_Ligature_OE       : constant Wide_Character := Wide_Character'Val (189);\n+   UC_Y_Diaeresis       : constant Wide_Character := Wide_Character'Val (190);\n+   Inverted_Question    : constant Wide_Character := Wide_Character'Val (191);\n+\n+   --  Wide_Character positions 192 (16#C0#) .. 207 (16#CF#)\n+\n+   UC_A_Grave           : constant Wide_Character := Wide_Character'Val (192);\n+   UC_A_Acute           : constant Wide_Character := Wide_Character'Val (193);\n+   UC_A_Circumflex      : constant Wide_Character := Wide_Character'Val (194);\n+   UC_A_Tilde           : constant Wide_Character := Wide_Character'Val (195);\n+   UC_A_Diaeresis       : constant Wide_Character := Wide_Character'Val (196);\n+   UC_A_Ring            : constant Wide_Character := Wide_Character'Val (197);\n+   UC_AE_Diphthong      : constant Wide_Character := Wide_Character'Val (198);\n+   UC_C_Cedilla         : constant Wide_Character := Wide_Character'Val (199);\n+   UC_E_Grave           : constant Wide_Character := Wide_Character'Val (200);\n+   UC_E_Acute           : constant Wide_Character := Wide_Character'Val (201);\n+   UC_E_Circumflex      : constant Wide_Character := Wide_Character'Val (202);\n+   UC_E_Diaeresis       : constant Wide_Character := Wide_Character'Val (203);\n+   UC_I_Grave           : constant Wide_Character := Wide_Character'Val (204);\n+   UC_I_Acute           : constant Wide_Character := Wide_Character'Val (205);\n+   UC_I_Circumflex      : constant Wide_Character := Wide_Character'Val (206);\n+   UC_I_Diaeresis       : constant Wide_Character := Wide_Character'Val (207);\n+\n+   --  Wide_Character positions 208 (16#D0#) .. 223 (16#DF#)\n+\n+   UC_Icelandic_Eth     : constant Wide_Character := Wide_Character'Val (208);\n+   UC_N_Tilde           : constant Wide_Character := Wide_Character'Val (209);\n+   UC_O_Grave           : constant Wide_Character := Wide_Character'Val (210);\n+   UC_O_Acute           : constant Wide_Character := Wide_Character'Val (211);\n+   UC_O_Circumflex      : constant Wide_Character := Wide_Character'Val (212);\n+   UC_O_Tilde           : constant Wide_Character := Wide_Character'Val (213);\n+   UC_O_Diaeresis       : constant Wide_Character := Wide_Character'Val (214);\n+   Multiplication_Sign  : constant Wide_Character := Wide_Character'Val (215);\n+   UC_O_Oblique_Stroke  : constant Wide_Character := Wide_Character'Val (216);\n+   UC_U_Grave           : constant Wide_Character := Wide_Character'Val (217);\n+   UC_U_Acute           : constant Wide_Character := Wide_Character'Val (218);\n+   UC_U_Circumflex      : constant Wide_Character := Wide_Character'Val (219);\n+   UC_U_Diaeresis       : constant Wide_Character := Wide_Character'Val (220);\n+   UC_Y_Acute           : constant Wide_Character := Wide_Character'Val (221);\n+   UC_Icelandic_Thorn   : constant Wide_Character := Wide_Character'Val (222);\n+   LC_German_Sharp_S    : constant Wide_Character := Wide_Character'Val (223);\n+\n+   --  Wide_Character positions 224 (16#E0#) .. 239 (16#EF#)\n+\n+   LC_A_Grave           : constant Wide_Character := Wide_Character'Val (224);\n+   LC_A_Acute           : constant Wide_Character := Wide_Character'Val (225);\n+   LC_A_Circumflex      : constant Wide_Character := Wide_Character'Val (226);\n+   LC_A_Tilde           : constant Wide_Character := Wide_Character'Val (227);\n+   LC_A_Diaeresis       : constant Wide_Character := Wide_Character'Val (228);\n+   LC_A_Ring            : constant Wide_Character := Wide_Character'Val (229);\n+   LC_AE_Diphthong      : constant Wide_Character := Wide_Character'Val (230);\n+   LC_C_Cedilla         : constant Wide_Character := Wide_Character'Val (231);\n+   LC_E_Grave           : constant Wide_Character := Wide_Character'Val (232);\n+   LC_E_Acute           : constant Wide_Character := Wide_Character'Val (233);\n+   LC_E_Circumflex      : constant Wide_Character := Wide_Character'Val (234);\n+   LC_E_Diaeresis       : constant Wide_Character := Wide_Character'Val (235);\n+   LC_I_Grave           : constant Wide_Character := Wide_Character'Val (236);\n+   LC_I_Acute           : constant Wide_Character := Wide_Character'Val (237);\n+   LC_I_Circumflex      : constant Wide_Character := Wide_Character'Val (238);\n+   LC_I_Diaeresis       : constant Wide_Character := Wide_Character'Val (239);\n+\n+   --  Wide_Character positions 240 (16#F0#) .. 255 (16#FF)\n+\n+   LC_Icelandic_Eth     : constant Wide_Character := Wide_Character'Val (240);\n+   LC_N_Tilde           : constant Wide_Character := Wide_Character'Val (241);\n+   LC_O_Grave           : constant Wide_Character := Wide_Character'Val (242);\n+   LC_O_Acute           : constant Wide_Character := Wide_Character'Val (243);\n+   LC_O_Circumflex      : constant Wide_Character := Wide_Character'Val (244);\n+   LC_O_Tilde           : constant Wide_Character := Wide_Character'Val (245);\n+   LC_O_Diaeresis       : constant Wide_Character := Wide_Character'Val (246);\n+   Division_Sign        : constant Wide_Character := Wide_Character'Val (247);\n+   LC_O_Oblique_Stroke  : constant Wide_Character := Wide_Character'Val (248);\n+   LC_U_Grave           : constant Wide_Character := Wide_Character'Val (249);\n+   LC_U_Acute           : constant Wide_Character := Wide_Character'Val (250);\n+   LC_U_Circumflex      : constant Wide_Character := Wide_Character'Val (251);\n+   LC_U_Diaeresis       : constant Wide_Character := Wide_Character'Val (252);\n+   LC_Y_Acute           : constant Wide_Character := Wide_Character'Val (253);\n+   LC_Icelandic_Thorn   : constant Wide_Character := Wide_Character'Val (254);\n+   LC_Y_Diaeresis       : constant Wide_Character := Wide_Character'Val (255);\n+\n+   ------------------------------------------------\n+   -- Summary of Changes from Latin-1 => Latin-9 --\n+   ------------------------------------------------\n+\n+   --   164     Currency                => Euro_Sign\n+   --   166     Broken_Bar              => UC_S_Caron\n+   --   168     Diaeresis               => LC_S_Caron\n+   --   180     Acute                   => UC_Z_Caron\n+   --   184     Cedilla                 => LC_Z_Caron\n+   --   188     Fraction_One_Quarter    => UC_Ligature_OE\n+   --   189     Fraction_One_Half       => LC_Ligature_OE\n+   --   190     Fraction_Three_Quarters => UC_Y_Diaeresis\n+\n+end Ada.Characters.Wide_Latin_9;"}, {"sha": "c7ba5bcc68537b0f422a3b11ae59e068b4260aed", "filename": "gcc/ada/a-dynpri.adb", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-dynpri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-dynpri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dynpri.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.25 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2001 Florida State University             --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -56,10 +55,16 @@ with Ada.Exceptions;\n with System.Tasking.Initialization;\n --  used for Defer/Undefer_Abort\n \n+with System.Parameters;\n+--  used for Single_Lock\n+\n with Unchecked_Conversion;\n \n package body Ada.Dynamic_Priorities is\n \n+   package STPO renames System.Task_Primitives.Operations;\n+\n+   use System.Parameters;\n    use System.Tasking;\n    use Ada.Exceptions;\n \n@@ -107,7 +112,7 @@ package body Ada.Dynamic_Priorities is\n           Ada.Task_Identification.Current_Task)\n    is\n       Target  : constant Task_ID := Convert_Ids (T);\n-      Self_ID : constant Task_ID := System.Task_Primitives.Operations.Self;\n+      Self_ID : constant Task_ID := STPO.Self;\n       Error_Message : constant String := \"Trying to set the priority of a \";\n \n    begin\n@@ -121,34 +126,49 @@ package body Ada.Dynamic_Priorities is\n            Error_Message & \"terminated task\");\n       end if;\n \n-      System.Tasking.Initialization.Defer_Abort (Self_ID);\n-      System.Task_Primitives.Operations.Write_Lock (Target);\n+      Initialization.Defer_Abort (Self_ID);\n+\n+      if Single_Lock then\n+         STPO.Lock_RTS;\n+      end if;\n+\n+      STPO.Write_Lock (Target);\n \n       if Self_ID = Target then\n          Target.Common.Base_Priority := Priority;\n-         System.Task_Primitives.Operations.Set_Priority (Target, Priority);\n-         System.Task_Primitives.Operations.Unlock (Target);\n-         System.Task_Primitives.Operations.Yield;\n+         STPO.Set_Priority (Target, Priority);\n+\n+         STPO.Unlock (Target);\n+\n+         if Single_Lock then\n+            STPO.Unlock_RTS;\n+         end if;\n+\n+         STPO.Yield;\n          --  Yield is needed to enforce FIFO task dispatching.\n          --  LL Set_Priority is made while holding the RTS lock so that\n          --  it is inheriting high priority until it release all the RTS\n          --  locks.\n          --  If this is used in a system where Ceiling Locking is\n          --  not enforced we may end up getting two Yield effects.\n+\n       else\n          Target.New_Base_Priority := Priority;\n          Target.Pending_Priority_Change := True;\n          Target.Pending_Action := True;\n \n-         System.Task_Primitives.Operations.Wakeup\n-           (Target, Target.Common.State);\n+         STPO.Wakeup (Target, Target.Common.State);\n          --  If the task is suspended, wake it up to perform the change.\n          --  check for ceiling violations ???\n-         System.Task_Primitives.Operations.Unlock (Target);\n \n+         STPO.Unlock (Target);\n+\n+         if Single_Lock then\n+            STPO.Unlock_RTS;\n+         end if;\n       end if;\n-      System.Tasking.Initialization.Undefer_Abort (Self_ID);\n \n+      Initialization.Undefer_Abort (Self_ID);\n    end Set_Priority;\n \n end Ada.Dynamic_Priorities;"}, {"sha": "89932751dc22537bd61b096ca5907404bfc71ba5", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 772, "deletions": 183, "changes": 955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -8,7 +8,7 @@\n --                                                                          --\n --                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -89,9 +89,119 @@ package body Ada.Exceptions is\n    --  Boolean indicating whether tracebacks should be stored in exception\n    --  occurrences.\n \n+   Zero_Cost_Exceptions : Integer;\n+   pragma Import (C, Zero_Cost_Exceptions, \"__gl_zero_cost_exceptions\");\n+   --  Boolean indicating if we are handling exceptions using a zero cost\n+   --  mechanism.\n+   --\n+   --  ??? We currently have two alternatives for this scheme : one using\n+   --  front-end tables and one using back-end tables. The former is known to\n+   --  only work for GNAT3 and the latter is known to only work for GNAT5.\n+   --  Both are present in this implementation and it would be good to have\n+   --  separate bodies at some point.\n+   --\n+   --  Note that although we currently do not support it, the GCC3 back-end\n+   --  tables are also potentially useable for setjmp/longjmp processing.\n+\n    Nline : constant String := String' (1 => ASCII.LF);\n    --  Convenient shortcut\n \n+   ------------------------------------------------\n+   -- Entities to interface with the GCC runtime --\n+   ------------------------------------------------\n+\n+   --  These come from \"C++ ABI for Itanium : Exception handling\", which is\n+   --  the reference for GCC. They are used only when we are relying on\n+   --  back-end tables for exception propagation, which in turn is currenly\n+   --  only the case for Zero_Cost_Exceptions in GNAT5.\n+\n+   --  Return codes from the GCC runtime functions used to propagate\n+   --  an exception.\n+\n+   type Unwind_Reason_Code is\n+     (URC_NO_REASON,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+\n+   --  ??? pragma Unreferenced is unknown until 3.15, so we need to disable\n+   --  warnings around it to fix the bootstrap path.\n+\n+   pragma Warnings (Off);\n+   pragma Unreferenced\n+     (URC_NO_REASON,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+   pragma Warnings (On);\n+\n+   pragma Convention (C, Unwind_Reason_Code);\n+\n+   --  Mandatory common header for any exception object handled by the\n+   --  GCC unwinding runtime.\n+\n+   subtype Exception_Class is String (1 .. 8);\n+\n+   GNAT_Exception_Class : constant Exception_Class\n+     := \"GNU\" & ASCII.NUL & \"Ada\" & ASCII.NUL;\n+\n+   type Unwind_Exception is record\n+      Class    : Exception_Class := GNAT_Exception_Class;\n+      Cleanup  : System.Address  := System.Null_Address;\n+      Private1 : Integer;\n+      Private2 : Integer;\n+   end record;\n+\n+   pragma Convention (C, Unwind_Exception);\n+\n+   for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n+\n+   --  A GNAT exception object to be dealt with by the personality routine\n+   --  called by the GCC unwinding runtime. This structure shall match the\n+   --  one in raise.c and is currently experimental as it might be merged\n+   --  with the GNAT runtime definition some day.\n+\n+   type GNAT_GCC_Exception is record\n+      Header : Unwind_Exception;\n+      --  Exception header first, as required by the ABI.\n+\n+      Id : Exception_Id;\n+      --  Usual Exception identifier\n+\n+      Handled_By_Others : Boolean;\n+      --  Is this exception handled by \"when others\" ?\n+\n+      Has_Cleanup : Boolean;\n+      --  Did we see any at-end handler while walking up the stack\n+      --  searching for a handler ? This is used to determine if we\n+      --  start the propagation again after having tried once without\n+      --  finding a true handler for the exception.\n+\n+      Select_Cleanups : Boolean;\n+      --  Do we consider at-end handlers as legitimate handlers for the\n+      --  exception ? This is used to control the propagation process\n+      --  as described in Raise_Current_Excep.\n+   end record;\n+\n+   pragma Convention (C, GNAT_GCC_Exception);\n+\n+   --  GCC runtime functions used\n+\n+   function Unwind_RaiseException\n+     (E    : access GNAT_GCC_Exception)\n+      return Unwind_Reason_Code;\n+   pragma Import (C, Unwind_RaiseException, \"_Unwind_RaiseException\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -106,30 +216,69 @@ package body Ada.Exceptions is\n    procedure ZZZ;\n    --  Mark end of procedures in this package\n \n-   Address_Image_Length : constant :=\n-                            13 + 10 * Boolean'Pos (Standard'Address_Size > 32);\n-   --  Length of string returned by Address_Image function\n-\n    function Address_Image (A : System.Address) return String;\n    --  Returns at string of the form 0xhhhhhhhhh for 32-bit addresses\n    --  or 0xhhhhhhhhhhhhhhhh for 64-bit addresses. Hex characters are\n    --  in lower case.\n \n+   procedure Call_Chain (Excep : EOA);\n+   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n+   --  call chain.\n+\n    procedure Free\n      is new Ada.Unchecked_Deallocation\n        (Subprogram_Descriptor_List, Subprogram_Descriptor_List_Ptr);\n \n+   procedure Process_Raise_Exception\n+     (E                   : Exception_Id;\n+      From_Signal_Handler : Boolean);\n+   pragma Inline (Process_Raise_Exception);\n+   pragma No_Return (Process_Raise_Exception);\n+   --  This is the lowest level raise routine. It raises the exception\n+   --  referenced by Current_Excep.all in the TSD, without deferring abort\n+   --  (the caller must ensure that abort is deferred on entry).\n+   --\n+   --  This is actually the common implementation for Raise_Current_Excep and\n+   --  Raise_From_Signal_Handler, with a couple of operations inhibited when\n+   --  called from the latter. The origin of the call is indicated by the\n+   --  From_Signal_Handler argument.\n+   --\n+   --  The Inline pragma is there for efficiency reasons.\n+\n+   procedure Propagate_Exception_With_FE_Support (Mstate : Machine_State);\n+   pragma No_Return (Propagate_Exception_With_FE_Support);\n+   --  This procedure propagates the exception represented by the occurrence\n+   --  referenced by Current_Excep in the TSD for the current task. M is the\n+   --  initial machine state, representing the site of the exception raise\n+   --  operation.\n+   --\n+   --  The procedure searches the front end exception tables for an applicable\n+   --  handler, calling Pop_Frame as needed. If and when it locates an\n+   --  applicable handler, Enter_Handler is called to actually enter this\n+   --  handler. If the search is unable to locate an applicable handler,\n+   --  execution is terminated by calling Unhandled_Exception_Terminate.\n+\n+   procedure Propagate_Exception_With_GCC_Support (Mstate : Machine_State);\n+   pragma No_Return (Propagate_Exception_With_GCC_Support);\n+   --  This procedure propagates the exception represented by the occurrence\n+   --  referenced by Current_Excep in the TSD for the current task. M is the\n+   --  initial machine state, representing the site of the exception raise\n+   --  operation. It is currently not used and is there for the purpose of\n+   --  interface consistency against Propagate_Exception_With_FE_Support.\n+   --\n+   --  The procedure builds an object suitable for the libgcc processing and\n+   --  calls Unwind_RaiseException to actually throw, taking care of handling\n+   --  the two phase scheme it implements.\n+\n    procedure Raise_Current_Excep (E : Exception_Id);\n    pragma No_Return (Raise_Current_Excep);\n    pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n-   --  This is the lowest level raise routine. It raises the exception\n-   --  referenced by Current_Excep.all in the TSD, without deferring\n-   --  abort (the caller must ensure that abort is deferred on entry).\n-   --  The parameter E is ignored.\n+   --  This is a simple wrapper to Process_Raise_Exception setting the\n+   --  From_Signal_Handler argument to False.\n    --\n    --  This external name for Raise_Current_Excep is historical, and probably\n-   --  should be changed but for now we keep it, because gdb knows about it.\n-   --  The parameter is also present for historical compatibility. ???\n+   --  should be changed but for now we keep it, because gdb and gigi know\n+   --  about it.\n \n    procedure Raise_Exception_No_Defer\n       (E : Exception_Id; Message : String := \"\");\n@@ -148,31 +297,74 @@ package body Ada.Exceptions is\n \n    procedure Raise_With_Location\n      (E : Exception_Id;\n-      F : SSL.Big_String_Ptr;\n+      F : Big_String_Ptr;\n       L : Integer);\n    pragma No_Return (Raise_With_Location);\n    --  Raise an exception with given exception id value. A filename and line\n    --  number is associated with the raise and is stored in the exception\n    --  occurrence.\n \n+   procedure Raise_With_Location_And_Msg\n+     (E : Exception_Id;\n+      F : Big_String_Ptr;\n+      L : Integer;\n+      M : Big_String_Ptr);\n+   pragma No_Return (Raise_With_Location_And_Msg);\n+   --  Raise an exception with given exception id value. A filename and line\n+   --  number is associated with the raise and is stored in the exception\n+   --  occurrence and in addition a string message M is appended to this.\n+\n    procedure Raise_Constraint_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer);\n+     (File : Big_String_Ptr;\n+      Line : Integer);\n    pragma No_Return (Raise_Constraint_Error);\n-   pragma Export (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n+   pragma Export\n+     (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n    --  Raise constraint error with file:line information\n \n+   procedure Raise_Constraint_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr);\n+   pragma No_Return (Raise_Constraint_Error_Msg);\n+   pragma Export\n+     (C, Raise_Constraint_Error_Msg, \"__gnat_raise_constraint_error_msg\");\n+   --  Raise constraint error with file:line + msg information\n+\n    procedure Raise_Program_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer);\n+     (File : Big_String_Ptr;\n+      Line : Integer);\n    pragma No_Return (Raise_Program_Error);\n-   pragma Export (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n+   pragma Export\n+     (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n    --  Raise program error with file:line information\n \n+   procedure Raise_Program_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr);\n+   pragma No_Return (Raise_Program_Error_Msg);\n+   pragma Export\n+     (C, Raise_Program_Error_Msg, \"__gnat_raise_program_error_msg\");\n+   --  Raise program error with file:line + msg information\n+\n    procedure Raise_Storage_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer);\n+     (File : Big_String_Ptr;\n+      Line : Integer);\n    pragma No_Return (Raise_Storage_Error);\n-   pragma Export (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n+   pragma Export\n+     (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n    --  Raise storage error with file:line information\n \n+   procedure Raise_Storage_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr);\n+   pragma No_Return (Raise_Storage_Error_Msg);\n+   pragma Export\n+     (C, Raise_Storage_Error_Msg, \"__gnat_raise_storage_error_msg\");\n+   --  Raise storage error with file:line + reason msg information\n+\n    --  The exception raising process and the automatic tracing mechanism rely\n    --  on some careful use of flags attached to the exception occurrence. The\n    --  graph below illustrates the relations between the Raise_ subprograms\n@@ -211,12 +403,16 @@ package body Ada.Exceptions is\n \n    procedure Set_Exception_C_Msg\n      (Id   : Exception_Id;\n-      Msg  : SSL.Big_String_Ptr;\n-      Line : Integer := 0);\n+      Msg1 : Big_String_Ptr;\n+      Line : Integer        := 0;\n+      Msg2 : Big_String_Ptr := null);\n    --  This routine is called to setup the exception referenced by the\n    --  Current_Excep field in the TSD to contain the indicated Id value\n-   --  and message. Msg is a null terminated string. when Line > 0,\n-   --  Msg is the filename and line the line number of the exception location.\n+   --  and message. Msg1 is a null terminated string which is generated\n+   --  as the exception message. If line is non-zero, then a colon and\n+   --  the decimal representation of this integer is appended to the\n+   --  message. When Msg2 is non-null, a space and this additional null\n+   --  terminated string is added to the message.\n \n    procedure To_Stderr (S : String);\n    pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n@@ -261,6 +457,264 @@ package body Ada.Exceptions is\n    --  which are somewhat redundant is historical. Notify_Exception\n    --  certainly is complete enough, but GDB still uses this routine.\n \n+   -----------------------------\n+   -- Run-Time Check Routines --\n+   -----------------------------\n+\n+   --  These routines are called from the runtime to raise a specific\n+   --  exception with a reason message attached. The parameters are\n+   --  the file name and line number in each case. The names are keyed\n+   --  to the codes defined in Types.ads and a-types.h (for example,\n+   --  the name Rcheck_05 refers to the Reason whose Pos code is 5).\n+\n+   procedure Rcheck_00 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_01 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_02 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_03 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_04 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_05 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_06 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_07 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_08 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_09 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_10 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_11 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_12 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_13 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_14 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_15 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_16 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_17 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_18 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_19 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_20 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_21 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_22 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_23 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_24 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer);\n+\n+   pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n+   pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n+   pragma Export (C, Rcheck_02, \"__gnat_rcheck_02\");\n+   pragma Export (C, Rcheck_03, \"__gnat_rcheck_03\");\n+   pragma Export (C, Rcheck_04, \"__gnat_rcheck_04\");\n+   pragma Export (C, Rcheck_05, \"__gnat_rcheck_05\");\n+   pragma Export (C, Rcheck_06, \"__gnat_rcheck_06\");\n+   pragma Export (C, Rcheck_07, \"__gnat_rcheck_07\");\n+   pragma Export (C, Rcheck_08, \"__gnat_rcheck_08\");\n+   pragma Export (C, Rcheck_09, \"__gnat_rcheck_09\");\n+   pragma Export (C, Rcheck_10, \"__gnat_rcheck_10\");\n+   pragma Export (C, Rcheck_11, \"__gnat_rcheck_11\");\n+   pragma Export (C, Rcheck_12, \"__gnat_rcheck_12\");\n+   pragma Export (C, Rcheck_13, \"__gnat_rcheck_13\");\n+   pragma Export (C, Rcheck_14, \"__gnat_rcheck_14\");\n+   pragma Export (C, Rcheck_15, \"__gnat_rcheck_15\");\n+   pragma Export (C, Rcheck_16, \"__gnat_rcheck_16\");\n+   pragma Export (C, Rcheck_17, \"__gnat_rcheck_17\");\n+   pragma Export (C, Rcheck_18, \"__gnat_rcheck_18\");\n+   pragma Export (C, Rcheck_19, \"__gnat_rcheck_19\");\n+   pragma Export (C, Rcheck_20, \"__gnat_rcheck_20\");\n+   pragma Export (C, Rcheck_21, \"__gnat_rcheck_21\");\n+   pragma Export (C, Rcheck_22, \"__gnat_rcheck_22\");\n+   pragma Export (C, Rcheck_23, \"__gnat_rcheck_23\");\n+   pragma Export (C, Rcheck_24, \"__gnat_rcheck_24\");\n+   pragma Export (C, Rcheck_25, \"__gnat_rcheck_25\");\n+   pragma Export (C, Rcheck_26, \"__gnat_rcheck_26\");\n+   pragma Export (C, Rcheck_27, \"__gnat_rcheck_27\");\n+   pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n+\n+   ---------------------------------------------\n+   -- Reason Strings for Run-Time Check Calls --\n+   ---------------------------------------------\n+\n+   --  These strings are null-terminated and are used by Rcheck_nn. The\n+   --  strings correspond to the definitions for Types.RT_Exception_Code.\n+\n+   use ASCII;\n+\n+   Rmsg_00 : constant String := \"access check failed\"              & NUL;\n+   Rmsg_01 : constant String := \"access parameter is null\"         & NUL;\n+   Rmsg_02 : constant String := \"discriminant check failed\"        & NUL;\n+   Rmsg_03 : constant String := \"divide by zero\"                   & NUL;\n+   Rmsg_04 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_05 : constant String := \"index check failed\"               & NUL;\n+   Rmsg_06 : constant String := \"invalid data\"                     & NUL;\n+   Rmsg_07 : constant String := \"length check failed\"              & NUL;\n+   Rmsg_08 : constant String := \"overflow check failed\"            & NUL;\n+   Rmsg_09 : constant String := \"partition check failed\"           & NUL;\n+   Rmsg_10 : constant String := \"range check failed\"               & NUL;\n+   Rmsg_11 : constant String := \"tag check failed\"                 & NUL;\n+   Rmsg_12 : constant String := \"access before elaboration\"        & NUL;\n+   Rmsg_13 : constant String := \"accessibility check failed\"       & NUL;\n+   Rmsg_14 : constant String := \"all guards closed\"                & NUL;\n+   Rmsg_15 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_16 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_17 : constant String := \"finalize raised exception\"        & NUL;\n+   Rmsg_18 : constant String := \"invalid data\"                     & NUL;\n+   Rmsg_19 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_20 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_21 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_22 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_23 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_24 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_25 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_26 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_27 : constant String := \"object too large\"                 & NUL;\n+   Rmsg_28 : constant String := \"restriction violation\"            & NUL;\n+\n+   --------------------------------------\n+   -- Calls to Run-Time Check Routines --\n+   --------------------------------------\n+\n+   procedure Rcheck_00 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_00'Address));\n+   end Rcheck_00;\n+\n+   procedure Rcheck_01 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_01'Address));\n+   end Rcheck_01;\n+\n+   procedure Rcheck_02 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_02'Address));\n+   end Rcheck_02;\n+\n+   procedure Rcheck_03 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_03'Address));\n+   end Rcheck_03;\n+\n+   procedure Rcheck_04 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_04'Address));\n+   end Rcheck_04;\n+\n+   procedure Rcheck_05 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_05'Address));\n+   end Rcheck_05;\n+\n+   procedure Rcheck_06 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_06'Address));\n+   end Rcheck_06;\n+\n+   procedure Rcheck_07 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_07'Address));\n+   end Rcheck_07;\n+\n+   procedure Rcheck_08 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_08'Address));\n+   end Rcheck_08;\n+\n+   procedure Rcheck_09 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_09'Address));\n+   end Rcheck_09;\n+\n+   procedure Rcheck_10 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_10'Address));\n+   end Rcheck_10;\n+\n+   procedure Rcheck_11 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, To_Ptr (Rmsg_11'Address));\n+   end Rcheck_11;\n+\n+   procedure Rcheck_12 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_12'Address));\n+   end Rcheck_12;\n+\n+   procedure Rcheck_13 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_13'Address));\n+   end Rcheck_13;\n+\n+   procedure Rcheck_14 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_14'Address));\n+   end Rcheck_14;\n+\n+   procedure Rcheck_15 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_15'Address));\n+   end Rcheck_15;\n+\n+   procedure Rcheck_16 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_16'Address));\n+   end Rcheck_16;\n+\n+   procedure Rcheck_17 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_17'Address));\n+   end Rcheck_17;\n+\n+   procedure Rcheck_18 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_18'Address));\n+   end Rcheck_18;\n+\n+   procedure Rcheck_19 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_19'Address));\n+   end Rcheck_19;\n+\n+   procedure Rcheck_20 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_20'Address));\n+   end Rcheck_20;\n+\n+   procedure Rcheck_21 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_21'Address));\n+   end Rcheck_21;\n+\n+   procedure Rcheck_22 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_22'Address));\n+   end Rcheck_22;\n+\n+   procedure Rcheck_23 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_23'Address));\n+   end Rcheck_23;\n+\n+   procedure Rcheck_24 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_24'Address));\n+   end Rcheck_24;\n+\n+   procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_25'Address));\n+   end Rcheck_25;\n+\n+   procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_26'Address));\n+   end Rcheck_26;\n+\n+   procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_27'Address));\n+   end Rcheck_27;\n+\n+   procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_28'Address));\n+   end Rcheck_28;\n+\n    ---------------------------------------\n    -- Exception backtracing subprograms --\n    ---------------------------------------\n@@ -307,18 +761,18 @@ package body Ada.Exceptions is\n      (N    : Natural;\n       Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append the image of N at the end of the provided information string.\n+   --  Append the image of N at the end of the provided information string\n \n    procedure Append_Info_NL\n      (Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append a CR/LF couple at the end of the provided information string.\n+   --  Append a LF at the end of the provided information string\n \n    procedure Append_Info_String\n      (S    : String;\n       Info : in out String;\n       Ptr  : in out Natural);\n-   --  Append a string at the end of the provided information string.\n+   --  Append a string at the end of the provided information string\n \n    --  To build Exception_Information and Tailored_Exception_Information,\n    --  we then use three intermediate functions :\n@@ -408,22 +862,6 @@ package body Ada.Exceptions is\n    procedure Unhandled_Terminate;\n    pragma Import (C, Unhandled_Terminate, \"__gnat_unhandled_terminate\");\n \n-   procedure Propagate_Exception (Mstate : Machine_State);\n-   pragma No_Return (Propagate_Exception);\n-   --  This procedure propagates the exception represented by the occurrence\n-   --  referenced by Current_Excep in the TSD for the current task. M is\n-   --  the initial machine state, representing the site of the exception\n-   --  raise operation. Propagate_Exception searches the exception tables\n-   --  for an applicable handler, calling Pop_Frame as needed. If and when\n-   --  it locates an applicable handler Propagate_Exception makes a call\n-   --  to Enter_Handler to actually enter the handler. If the search is\n-   --  unable to locate an applicable handler, execution is terminated by\n-   --  calling Unhandled_Exception_Terminate.\n-\n-   procedure Call_Chain (Excep : EOA);\n-   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n-   --  call chain.\n-\n    -----------------------\n    -- Polling Interface --\n    -----------------------\n@@ -503,8 +941,6 @@ package body Ada.Exceptions is\n       Ptr  : in out Natural)\n    is\n    begin\n-      Ptr := Ptr + 1;\n-      Info (Ptr) := ASCII.CR;\n       Ptr := Ptr + 1;\n       Info (Ptr) := ASCII.LF;\n    end Append_Info_NL;\n@@ -823,11 +1259,98 @@ package body Ada.Exceptions is\n       return Name (P .. Name'Length);\n    end Exception_Name_Simple;\n \n-   -------------------------\n-   -- Propagate_Exception --\n-   -------------------------\n+   -----------------------------\n+   -- Process_Raise_Exception --\n+   -----------------------------\n+\n+   procedure Process_Raise_Exception\n+     (E                   : Exception_Id;\n+      From_Signal_Handler : Boolean)\n+   is\n+      pragma Inspection_Point (E);\n+      --  This is so the debugger can reliably inspect the parameter\n+\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+      Mstate_Ptr  : constant Machine_State :=\n+                      Machine_State (Get_Machine_State_Addr.all);\n+      Excep       : EOA := Get_Current_Excep.all;\n+\n+   begin\n+      --  WARNING : There should be no exception handler for this body\n+      --  because this would cause gigi to prepend a setup for a new\n+      --  jmpbuf to the sequence of statements. We would then always get\n+      --  this new buf in Jumpbuf_Ptr instead of the one for the exception\n+      --  we are handling, which would completely break the whole design\n+      --  of this procedure.\n+\n+      --  Processing varies between zero cost and setjmp/lonjmp processing.\n+\n+      if Zero_Cost_Exceptions /= 0 then\n+\n+         --  Use the front-end tables to propagate if we have them, otherwise\n+         --  resort to the GCC back-end alternative. The backtrace for the\n+         --  occurrence is stored while walking up the stack, and thus stops\n+         --  in the handler's frame if there is one. Notifications are also\n+         --  not performed here since it is not yet known if the exception is\n+         --  handled.\n+\n+         --  Set the machine state unless we are raising from a signal handler\n+         --  since it has already been set properly in that case.\n+\n+         if not From_Signal_Handler then\n+            Set_Machine_State (Mstate_Ptr);\n+         end if;\n+\n+         if Subprogram_Descriptors /= null then\n+            Propagate_Exception_With_FE_Support (Mstate_Ptr);\n+         else\n+            Propagate_Exception_With_GCC_Support (Mstate_Ptr);\n+         end if;\n+\n+      else\n+\n+         --  Compute the backtrace for this occurrence if the corresponding\n+         --  binder option has been set and we are not raising from a signal\n+         --  handler. Call_Chain takes care of the reraise case.\n+\n+         if not From_Signal_Handler\n+           and then Exception_Tracebacks /= 0\n+         then\n+            Call_Chain (Excep);\n+         end if;\n+\n+         --  If the jump buffer pointer is non-null, transfer control using\n+         --  it. Otherwise announce an unhandled exception (note that this\n+         --  means that we have no finalizations to do other than at the outer\n+         --  level). Perform the necessary notification tasks in both cases.\n+\n+         if Jumpbuf_Ptr /= Null_Address then\n+\n+            if not Excep.Exception_Raised then\n+               Excep.Exception_Raised := True;\n+               Notify_Handled_Exception (Null_Loc, False, False);\n+\n+               --  The low level debugger notification is skipped from the\n+               --  call above because we do not have the necessary information\n+               --  to \"feed\" it properly.\n \n-   procedure Propagate_Exception (Mstate : Machine_State) is\n+            end if;\n+\n+            builtin_longjmp (Jumpbuf_Ptr, 1);\n+\n+         else\n+            Notify_Unhandled_Exception (E);\n+            Unhandled_Exception_Terminate;\n+         end if;\n+      end if;\n+\n+   end Process_Raise_Exception;\n+\n+   -----------------------------------------\n+   -- Propagate_Exception_With_FE_Support --\n+   -----------------------------------------\n+\n+   procedure Propagate_Exception_With_FE_Support (Mstate : Machine_State) is\n       Excep  : constant EOA := Get_Current_Excep.all;\n       Loc    : Code_Loc;\n       Lo, Hi : Natural;\n@@ -872,10 +1395,10 @@ package body Ada.Exceptions is\n       FH_Mstate : aliased Machine_State_Record;\n       --  Records the machine state for the finalization handler\n \n-      FH_Handler : Code_Loc;\n+      FH_Handler : Code_Loc := Null_Address;\n       --  Record handler address for finalization handler\n \n-      FH_Num_Trb : Natural;\n+      FH_Num_Trb : Natural := 0;\n       --  Save number of tracebacks for finalization handler\n \n    begin\n@@ -1034,75 +1557,111 @@ package body Ada.Exceptions is\n \n       Unhandled_Exception_Terminate;\n \n-   end Propagate_Exception;\n+   end Propagate_Exception_With_FE_Support;\n \n-   -------------------------\n-   -- Raise_Current_Excep --\n-   -------------------------\n-\n-   procedure Raise_Current_Excep (E : Exception_Id) is\n-\n-      pragma Inspection_Point (E);\n-      --  This is so the debugger can reliably inspect the parameter\n+   ------------------------------------------\n+   -- Propagate_Exception_With_GCC_Support --\n+   ------------------------------------------\n \n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Mstate_Ptr  : constant Machine_State :=\n-                      Machine_State (Get_Machine_State_Addr.all);\n-      Excep       : EOA;\n+   procedure Propagate_Exception_With_GCC_Support (Mstate : Machine_State) is\n+      Excep          : EOA := Get_Current_Excep.all;\n+      This_Exception : aliased GNAT_GCC_Exception;\n+      Status         : Unwind_Reason_Code;\n \n    begin\n-      --  WARNING : There should be no exception handler for this body\n-      --  because this would cause gigi to prepend a setup for a new\n-      --  jmpbuf to the sequence of statements. We would then always get\n-      --  this new buf in Jumpbuf_Ptr instead of the one for the exception\n-      --  we are handling, which would completely break the whole design\n-      --  of this procedure.\n+      --  ??? Nothing is currently done for backtracing purposes. We could\n+      --  have used the personality routine to record the addresses while\n+      --  walking up the stack, but this method has two drawbacks : 1/ the\n+      --  trace is incomplete if the exception is handled since we don't walk\n+      --  up the frame with the handler, and 2/ we will miss frames if the\n+      --  exception propagates through frames for which our personality\n+      --  routine is not called (e.g. if C or C++ frames are on the way).\n+\n+      --  Fill in the useful flags for the personality routine called for each\n+      --  frame via the call to Unwind_RaiseException below.\n+\n+      This_Exception.Id := Excep.Id;\n+      This_Exception.Handled_By_Others := not Excep.Id.Not_Handled_By_Others;\n+      This_Exception.Has_Cleanup := False;\n+\n+      --  We are looking for a regular handler first. If there is one, either\n+      --  it or the first at-end handler before it will be entered. If there\n+      --  is none, control will normally get back to after the call, with\n+      --  Has_Cleanup set to true if at least one at-end handler has been\n+      --  found while walking up the stack.\n+\n+      This_Exception.Select_Cleanups := False;\n+\n+      Status := Unwind_RaiseException (This_Exception'Access);\n+\n+      --  If we get here we know the exception is not handled, as otherwise\n+      --  Unwind_RaiseException arranges for a handler to be entered. We might\n+      --  have met cleanups handlers, though, requiring to start again with\n+      --  the Select_Cleanups flag set to True.\n+\n+      --  Before restarting for cleanups, take the necessary steps to enable\n+      --  the debugger to gain control while the stack is still intact. Flag\n+      --  the occurrence as raised to avoid notifying again in case cleanup\n+      --  handlers are entered later.\n+\n+      if not Excep.Exception_Raised then\n+         Excep.Exception_Raised := True;\n+         Notify_Unhandled_Exception (Excep.Id);\n+      end if;\n \n-      --  If the jump buffer pointer is non-null, it means that a jump\n-      --  buffer was allocated (obviously that happens only in the case\n-      --  of zero cost exceptions not implemented, or if a jump buffer\n-      --  was manually set up by C code).\n+      --  Now raise again selecting cleanups as true handlers. Only do this if\n+      --  we know at least one such handler exists since otherwise we would\n+      --  perform a complete stack upwalk for nothing.\n \n-      if Jumpbuf_Ptr /= Null_Address then\n-         Excep := Get_Current_Excep.all;\n+      if This_Exception.Has_Cleanup then\n+         This_Exception.Select_Cleanups := True;\n+         Status := Unwind_RaiseException (This_Exception'Access);\n \n-         if Exception_Tracebacks /= 0 then\n-            Call_Chain (Excep);\n-         end if;\n+         --  The first cleanup found is entered. It performs its job, raises\n+         --  the initial exception again, and the flow goes back to the first\n+         --  step above with the stack in a different state.\n+      end if;\n \n-         --  Perform the necessary notification tasks if this is not a\n-         --  reraise. Actually ask to skip the low level debugger notification\n-         --  call since we do not have the necessary information to \"feed\"\n-         --  it properly.\n+      --  We get here when there is no handler to be run at all. The debugger\n+      --  has been notified before the second step above.\n \n-         if not Excep.Exception_Raised then\n-            Excep.Exception_Raised := True;\n-            Notify_Handled_Exception (Null_Loc, False, False);\n-         end if;\n+      Unhandled_Exception_Terminate;\n \n-         builtin_longjmp (Jumpbuf_Ptr, 1);\n+   end Propagate_Exception_With_GCC_Support;\n \n-      --  If we have no jump buffer, then either zero cost exception\n-      --  handling is in place, or we have no handlers anyway. In\n-      --  either case we have an unhandled exception. If zero cost\n-      --  exception handling is in place, propagate the exception\n+   ----------------------------\n+   -- Raise_Constraint_Error --\n+   ----------------------------\n \n-      elsif Subprogram_Descriptors /= null then\n-         Set_Machine_State (Mstate_Ptr);\n-         Propagate_Exception (Mstate_Ptr);\n+   procedure Raise_Constraint_Error\n+     (File : Big_String_Ptr;\n+      Line : Integer)\n+   is\n+   begin\n+      Raise_With_Location (Constraint_Error_Def'Access, File, Line);\n+   end Raise_Constraint_Error;\n \n-      --  Otherwise, we know the exception is unhandled by the absence\n-      --  of an allocated jump buffer. Note that this means that we also\n-      --  have no finalizations to do other than at the outer level.\n+   --------------------------------\n+   -- Raise_Constraint_Error_Msg --\n+   --------------------------------\n \n-      else\n-         if Exception_Tracebacks /= 0 then\n-            Call_Chain (Get_Current_Excep.all);\n-         end if;\n+   procedure Raise_Constraint_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Constraint_Error_Def'Access, File, Line, Msg);\n+   end Raise_Constraint_Error_Msg;\n \n-         Notify_Unhandled_Exception (E);\n-         Unhandled_Exception_Terminate;\n-      end if;\n+   -------------------------\n+   -- Raise_Current_Excep --\n+   -------------------------\n+\n+   procedure Raise_Current_Excep (E : Exception_Id) is\n+   begin\n+      Process_Raise_Exception (E => E, From_Signal_Handler => False);\n    end Raise_Current_Excep;\n \n    ---------------------\n@@ -1150,51 +1709,12 @@ package body Ada.Exceptions is\n \n    procedure Raise_From_Signal_Handler\n      (E : Exception_Id;\n-      M : SSL.Big_String_Ptr)\n+      M : Big_String_Ptr)\n    is\n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Mstate_Ptr  : constant Machine_State :=\n-                      Machine_State (Get_Machine_State_Addr.all);\n-\n    begin\n       Set_Exception_C_Msg (E, M);\n       Abort_Defer.all;\n-\n-      --  Now we raise the exception. The following code is essentially\n-      --  identical to the Raise_Current_Excep routine, except that in the\n-      --  zero cost exception case, we do not call Set_Machine_State, since\n-      --  the signal handler that passed control here has already set the\n-      --  machine state directly.\n-      --\n-      --  We also do not compute the backtrace for the occurrence since going\n-      --  through the signal handler is far from trivial and it is not a\n-      --  problem to fail providing a backtrace in the \"raised from signal\n-      --  handler\" case.\n-\n-      --  If the jump buffer pointer is non-null, it means that a jump\n-      --  buffer was allocated (obviously that happens only in the case\n-      --  of zero cost exceptions not implemented, or if a jump buffer\n-      --  was manually set up by C code).\n-\n-      if Jumpbuf_Ptr /= Null_Address then\n-         builtin_longjmp (Jumpbuf_Ptr, 1);\n-\n-      --  If we have no jump buffer, then either zero cost exception\n-      --  handling is in place, or we have no handlers anyway. In\n-      --  either case we have an unhandled exception. If zero cost\n-      --  exception handling is in place, propagate the exception\n-\n-      elsif Subprogram_Descriptors /= null then\n-         Propagate_Exception (Mstate_Ptr);\n-\n-      --  Otherwise, we know the exception is unhandled by the absence\n-      --  of an allocated jump buffer. Note that this means that we also\n-      --  have no finalizations to do other than at the outer level.\n-\n-      else\n-         Notify_Unhandled_Exception (E);\n-         Unhandled_Exception_Terminate;\n-      end if;\n+      Process_Raise_Exception (E => E, From_Signal_Handler => True);\n    end Raise_From_Signal_Handler;\n \n    ------------------\n@@ -1209,63 +1729,103 @@ package body Ada.Exceptions is\n       Raise_With_Msg (E);\n    end Raise_No_Msg;\n \n-   -------------------------\n-   -- Raise_With_Location --\n-   -------------------------\n-\n-   procedure Raise_With_Location\n-     (E : Exception_Id;\n-      F : SSL.Big_String_Ptr;\n-      L : Integer) is\n-   begin\n-      Set_Exception_C_Msg (E, F, L);\n-      Abort_Defer.all;\n-      Raise_Current_Excep (E);\n-   end Raise_With_Location;\n-\n-   ----------------------------\n-   -- Raise_Constraint_Error --\n-   ----------------------------\n-\n-   procedure Raise_Constraint_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer) is\n-   begin\n-      Raise_With_Location (Constraint_Error_Def'Access, File, Line);\n-   end Raise_Constraint_Error;\n-\n    -------------------------\n    -- Raise_Program_Error --\n    -------------------------\n \n    procedure Raise_Program_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer) is\n+     (File : Big_String_Ptr;\n+      Line : Integer)\n+   is\n    begin\n       Raise_With_Location (Program_Error_Def'Access, File, Line);\n    end Raise_Program_Error;\n \n+   -----------------------------\n+   -- Raise_Program_Error_Msg --\n+   -----------------------------\n+\n+   procedure Raise_Program_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Program_Error_Def'Access, File, Line, Msg);\n+   end Raise_Program_Error_Msg;\n+\n    -------------------------\n    -- Raise_Storage_Error --\n    -------------------------\n \n    procedure Raise_Storage_Error\n-     (File : SSL.Big_String_Ptr; Line : Integer) is\n+     (File : Big_String_Ptr;\n+      Line : Integer)\n+   is\n    begin\n       Raise_With_Location (Storage_Error_Def'Access, File, Line);\n    end Raise_Storage_Error;\n \n+   -----------------------------\n+   -- Raise_Storage_Error_Msg --\n+   -----------------------------\n+\n+   procedure Raise_Storage_Error_Msg\n+     (File : Big_String_Ptr;\n+      Line : Integer;\n+      Msg  : Big_String_Ptr)\n+   is\n+   begin\n+      Raise_With_Location_And_Msg\n+        (Storage_Error_Def'Access, File, Line, Msg);\n+   end Raise_Storage_Error_Msg;\n+\n    ----------------------\n    -- Raise_With_C_Msg --\n    ----------------------\n \n    procedure Raise_With_C_Msg\n-     (E    : Exception_Id;\n-      M    : SSL.Big_String_Ptr) is\n+     (E : Exception_Id;\n+      M : Big_String_Ptr)\n+   is\n    begin\n       Set_Exception_C_Msg (E, M);\n       Abort_Defer.all;\n       Raise_Current_Excep (E);\n    end Raise_With_C_Msg;\n \n+   -------------------------\n+   -- Raise_With_Location --\n+   -------------------------\n+\n+   procedure Raise_With_Location\n+     (E : Exception_Id;\n+      F : Big_String_Ptr;\n+      L : Integer)\n+   is\n+   begin\n+      Set_Exception_C_Msg (E, F, L);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Location;\n+\n+   ---------------------------------\n+   -- Raise_With_Location_And_Msg --\n+   ---------------------------------\n+\n+   procedure Raise_With_Location_And_Msg\n+     (E : Exception_Id;\n+      F : Big_String_Ptr;\n+      L : Integer;\n+      M : Big_String_Ptr)\n+   is\n+   begin\n+      Set_Exception_C_Msg (E, F, L, M);\n+      Abort_Defer.all;\n+      Raise_Current_Excep (E);\n+   end Raise_With_Location_And_Msg;\n+\n    --------------------\n    -- Raise_With_Msg --\n    --------------------\n@@ -1513,13 +2073,15 @@ package body Ada.Exceptions is\n \n    procedure Set_Exception_C_Msg\n      (Id   : Exception_Id;\n-      Msg  : Big_String_Ptr;\n-      Line : Integer := 0)\n+      Msg1 : Big_String_Ptr;\n+      Line : Integer        := 0;\n+      Msg2 : Big_String_Ptr := null)\n    is\n       Excep  : constant EOA := Get_Current_Excep.all;\n       Val    : Integer := Line;\n       Remind : Integer;\n       Size   : Integer := 1;\n+      Ptr    : Natural;\n \n    begin\n       Excep.Exception_Raised := False;\n@@ -1529,14 +2091,17 @@ package body Ada.Exceptions is\n       Excep.Msg_Length       := 0;\n       Excep.Cleanup_Flag     := False;\n \n-      while Msg (Excep.Msg_Length + 1) /= ASCII.NUL\n+      while Msg1 (Excep.Msg_Length + 1) /= ASCII.NUL\n         and then Excep.Msg_Length < Exception_Msg_Max_Length\n       loop\n          Excep.Msg_Length := Excep.Msg_Length + 1;\n-         Excep.Msg (Excep.Msg_Length) := Msg (Excep.Msg_Length);\n+         Excep.Msg (Excep.Msg_Length) := Msg1 (Excep.Msg_Length);\n       end loop;\n \n+      --  Append line number if present\n+\n       if Line > 0 then\n+\n          --  Compute the number of needed characters\n \n          while Val > 0 loop\n@@ -1561,6 +2126,24 @@ package body Ada.Exceptions is\n             end loop;\n          end if;\n       end if;\n+\n+      --  Append second message if present\n+\n+      if Msg2 /= null\n+        and then Excep.Msg_Length + 1 < Exception_Msg_Max_Length\n+      then\n+         Excep.Msg_Length := Excep.Msg_Length + 1;\n+         Excep.Msg (Excep.Msg_Length) := ' ';\n+\n+         Ptr := 1;\n+         while Msg2 (Ptr) /= ASCII.NUL\n+           and then Excep.Msg_Length < Exception_Msg_Max_Length\n+         loop\n+            Excep.Msg_Length := Excep.Msg_Length + 1;\n+            Excep.Msg (Excep.Msg_Length) := Msg2 (Ptr);\n+            Ptr := Ptr + 1;\n+         end loop;\n+      end if;\n    end Set_Exception_C_Msg;\n \n    -------------------\n@@ -1593,7 +2176,7 @@ package body Ada.Exceptions is\n \n       procedure Next_String;\n       --  On entry, To points to last character of previous line of the\n-      --  message, terminated by CR/LF. On return, From .. To are set to\n+      --  message, terminated by LF. On return, From .. To are set to\n       --  specify the next string, or From > To if there are no more lines.\n \n       procedure Bad_EO is\n@@ -1605,15 +2188,15 @@ package body Ada.Exceptions is\n \n       procedure Next_String is\n       begin\n-         From := To + 3;\n+         From := To + 2;\n \n          if From < S'Last then\n             To := From + 1;\n \n-            while To < S'Last - 2 loop\n+            while To < S'Last - 1 loop\n                if To >= S'Last then\n                   Bad_EO;\n-               elsif S (To + 1) = ASCII.CR then\n+               elsif S (To + 1) = ASCII.LF then\n                   exit;\n                else\n                   To := To + 1;\n@@ -1631,7 +2214,7 @@ package body Ada.Exceptions is\n       else\n          X.Cleanup_Flag := False;\n \n-         To := S'First - 3;\n+         To := S'First - 2;\n          Next_String;\n \n          if S (From .. From + 15) /= \"Exception name: \" then\n@@ -1885,8 +2468,14 @@ package body Ada.Exceptions is\n    type int is new Integer;\n \n    procedure Unhandled_Exception_Terminate is\n-      Excep : constant EOA    := Get_Current_Excep.all;\n-      Msg   : constant String := Exception_Message (Excep.all);\n+\n+      Excep : constant EOA := Save_Occurrence (Get_Current_Excep.all.all);\n+      --  This occurrence will be used to display a message after finalization.\n+      --  It is necessary to save a copy here, or else the designated value\n+      --  could be overwritten if an exception is raised during finalization\n+      --  (even if that exception is caught).\n+\n+      Msg : constant String := Exception_Message (Excep.all);\n \n    --  Start of processing for Unhandled_Exception_Terminate\n "}, {"sha": "bdc2d38c577b3f518d6efd4ce6387a6baa0b1d9d", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.50 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -85,7 +85,7 @@ package Ada.Exceptions is\n    --    PID=nnnn\n    --    0xyyyyyyyy 0xyyyyyyyy ...\n    --\n-   --  The lines are separated by an ASCII.CR/ASCII.LF sequence.\n+   --  The lines are separated by a ASCII.LF character\n    --  The nnnn is the partition Id given as decimal digits.\n    --  The 0x... line represents traceback program counter locations,\n    --  in order with the first one being the exception location.\n@@ -100,7 +100,7 @@ package Ada.Exceptions is\n \n    function Save_Occurrence\n      (Source : Exception_Occurrence)\n-      return Exception_Occurrence_Access;\n+      return   Exception_Occurrence_Access;\n \n private\n    package SSL renames System.Standard_Library;"}, {"sha": "d6513ca07d4fe519f85997353fa5ab3ddba9bdf6", "filename": "gcc/ada/a-finali.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-finali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-finali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-finali.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.10 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -51,6 +51,8 @@ package body Ada.Finalization is\n    ------------\n \n    procedure Adjust (Object : in out Controlled) is\n+      pragma Warnings (Off, Object);\n+\n    begin\n       null;\n    end Adjust;\n@@ -60,11 +62,15 @@ package body Ada.Finalization is\n    --------------\n \n    procedure Finalize (Object : in out Controlled) is\n+      pragma Warnings (Off, Object);\n+\n    begin\n       null;\n    end Finalize;\n \n    procedure Finalize (Object : in out Limited_Controlled) is\n+      pragma Warnings (Off, Object);\n+\n    begin\n       null;\n    end Finalize;\n@@ -74,11 +80,15 @@ package body Ada.Finalization is\n    ----------------\n \n    procedure Initialize (Object : in out Controlled) is\n+      pragma Warnings (Off, Object);\n+\n    begin\n       null;\n    end Initialize;\n \n    procedure Initialize (Object : in out Limited_Controlled) is\n+      pragma Warnings (Off, Object);\n+\n    begin\n       null;\n    end Initialize;"}, {"sha": "f45e84a72f116c89477294dbb4fd7c8723e732be", "filename": "gcc/ada/a-ncelfu.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ncelfu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ncelfu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ncelfu.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.3 $                              --\n+--                            $Revision$\n --                                                                          --\n -- This specification is adapted from the Ada Reference Manual for use with --\n -- GNAT.  In accordance with the copyright of that document, you can freely --\n@@ -21,3 +21,5 @@ with Ada.Numerics.Generic_Complex_Elementary_Functions;\n package Ada.Numerics.Complex_Elementary_Functions is\n   new Ada.Numerics.Generic_Complex_Elementary_Functions\n                                             (Ada.Numerics.Complex_Types);\n+\n+pragma Pure (Ada.Numerics.Complex_Elementary_Functions);"}, {"sha": "155e27157159a909ebc3149e56a9efd7f7f908e1", "filename": "gcc/ada/a-reatim.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-reatim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-reatim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -8,7 +8,7 @@\n --                                                                          --\n --                            $Revision$\n --                                                                          --\n---            Copyright (C) 1991-2001, Florida State University             --\n+--            Copyright (C) 1991-2002, Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -46,11 +45,13 @@ package body Ada.Real_Time is\n    --  Note that Constraint_Error may be propagated\n \n    function \"*\" (Left : Time_Span; Right : Integer) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Duration (Left) * Right);\n    end \"*\";\n \n    function \"*\" (Left : Integer; Right : Time_Span) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Left * Duration (Right));\n    end \"*\";\n@@ -62,16 +63,19 @@ package body Ada.Real_Time is\n    --  Note that Constraint_Error may be propagated\n \n    function \"+\" (Left : Time; Right : Time_Span) return Time is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time (Duration (Left) + Duration (Right));\n    end \"+\";\n \n    function \"+\" (Left : Time_Span; Right : Time) return Time is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time (Duration (Left) + Duration (Right));\n    end \"+\";\n \n    function \"+\" (Left, Right : Time_Span) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Duration (Left) + Duration (Right));\n    end \"+\";\n@@ -83,21 +87,25 @@ package body Ada.Real_Time is\n    --  Note that Constraint_Error may be propagated\n \n    function \"-\" (Left : Time; Right : Time_Span) return Time is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time (Duration (Left) - Duration (Right));\n    end \"-\";\n \n    function \"-\" (Left, Right : Time) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Duration (Left) - Duration (Right));\n    end \"-\";\n \n    function \"-\" (Left, Right : Time_Span) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Duration (Left) - Duration (Right));\n    end \"-\";\n \n    function \"-\" (Right : Time_Span) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span_Zero - Right;\n    end \"-\";\n@@ -109,11 +117,13 @@ package body Ada.Real_Time is\n    --  Note that Constraint_Error may be propagated\n \n    function \"/\" (Left, Right : Time_Span) return Integer is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Integer (Duration (Left) / Duration (Right));\n    end \"/\";\n \n    function \"/\" (Left : Time_Span; Right : Integer) return Time_Span is\n+      pragma Unsuppress (Overflow_Check);\n    begin\n       return Time_Span (Duration (Left) / Right);\n    end \"/\";\n@@ -190,7 +200,7 @@ package body Ada.Real_Time is\n          SC := SC - 1;\n       end if;\n \n-      TS := T - Time (SC);\n+      TS := Time_Span (Duration (T) - Duration (SC));\n    end Split;\n \n    -------------"}, {"sha": "9c64e96e0acc4bdcb5a6c5d0760c169789ffa271", "filename": "gcc/ada/a-retide.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-retide.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-retide.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-retide.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.28 $\n+--                             $Revision$\n --                                                                          --\n---             Copyright (C) 1991-1999 Florida State University             --\n+--         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,29 +29,26 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n with System.Task_Primitives.Operations;\n --  Used for Timed_Delay\n \n-with System.OS_Primitives;\n---  Used for Delay_Modes\n-\n package body Ada.Real_Time.Delays is\n \n    package STPO renames System.Task_Primitives.Operations;\n-   package OSP renames System.OS_Primitives;\n+\n+   Absolute_RT : constant := 2;\n \n    -----------------\n    -- Delay_Until --\n    -----------------\n \n    procedure Delay_Until (T : Time) is\n    begin\n-      STPO.Timed_Delay (STPO.Self, To_Duration (T), OSP.Absolute_RT);\n+      STPO.Timed_Delay (STPO.Self, To_Duration (T), Absolute_RT);\n    end Delay_Until;\n \n    -----------------"}, {"sha": "c0818c3c1a88a4c79a78294fa8f8e248360fc2cd", "filename": "gcc/ada/a-stream.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-stream.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-stream.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stream.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.9 $                              --\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -53,7 +53,7 @@ pragma Pure (Streams);\n       Stream_Element_Offset range 0 .. Stream_Element_Offset'Last;\n \n    type Stream_Element_Array is\n-      array (Stream_Element_Offset range <>) of Stream_Element;\n+      array (Stream_Element_Offset range <>) of aliased Stream_Element;\n \n    procedure Read\n      (Stream : in out Root_Stream_Type;"}, {"sha": "eacf0c5f1d3486e4c74efc2ec6f6dd33d7352f7b", "filename": "gcc/ada/a-ststio.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ststio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ststio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ststio.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.32 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2000, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,6 +64,8 @@ package body Ada.Streams.Stream_IO is\n    -------------------\n \n    function AFCB_Allocate (Control_Block : Stream_AFCB) return FCB.AFCB_Ptr is\n+      pragma Warnings (Off, Control_Block);\n+\n    begin\n       return new Stream_AFCB;\n    end AFCB_Allocate;\n@@ -75,6 +77,8 @@ package body Ada.Streams.Stream_IO is\n    --  No special processing required for closing Stream_IO file\n \n    procedure AFCB_Close (File : access Stream_AFCB) is\n+      pragma Warnings (Off, File);\n+\n    begin\n       null;\n    end AFCB_Close;\n@@ -149,7 +153,7 @@ package body Ada.Streams.Stream_IO is\n    -- Flush --\n    -----------\n \n-   procedure Flush (File : in out File_Type) is\n+   procedure Flush (File : File_Type) is\n    begin\n       FIO.Flush (AP (File));\n    end Flush;\n@@ -261,10 +265,6 @@ package body Ada.Streams.Stream_IO is\n       if File.Last_Op /= Op_Read\n         or else File.Shared_Status = FCB.Yes\n       then\n-         if End_Of_File (File) then\n-            raise End_Error;\n-         end if;\n-\n          Locked_Processing : begin\n             SSL.Lock_Task.all;\n             Set_Position (File);"}, {"sha": "2c20a6fbe8037990fc2e02ee1847aad678e9b9d1", "filename": "gcc/ada/a-ststio.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ststio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-ststio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ststio.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                            $Revision: 1.14 $                             --\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -128,7 +128,10 @@ package Ada.Streams.Stream_IO is\n \n    procedure Set_Mode (File : in out File_Type; Mode : in File_Mode);\n \n-   procedure Flush (File : in out File_Type);\n+   --  Note: The parameter file is IN OUT in the RM, but this is clearly\n+   --  an oversight, and was intended to be IN, see AI95-00057.\n+\n+   procedure Flush (File : File_Type);\n \n    ----------------\n    -- Exceptions --"}, {"sha": "900951e742811acf0c6448e0b8271effa07b8c28", "filename": "gcc/ada/a-stwifi.adb", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-stwifi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-stwifi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwifi.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.17 $                             --\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-1997 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-\n with Ada.Strings.Wide_Maps; use Ada.Strings.Wide_Maps;\n with Ada.Strings.Wide_Search;\n \n@@ -158,9 +157,11 @@ package body Ada.Strings.Wide_Fixed is\n \n       else\n          declare\n-            Result : constant Wide_String :=\n-                       Source (Source'First .. From - 1) &\n-                       Source (Through + 1 .. Source'Last);\n+            Len    : constant Integer := Source'Length - (Through - From + 1);\n+            Result : constant\n+                       Wide_String (Source'First .. Source'First + Len - 1) :=\n+                         Source (Source'First .. From - 1) &\n+                         Source (Through + 1 .. Source'Last);\n          begin\n             return Result;\n          end;\n@@ -381,13 +382,15 @@ package body Ada.Strings.Wide_Fixed is\n       else\n          declare\n             Result_Length : Natural :=\n-                Natural'Max (Source'Length,\n-                             Position - Source'First + New_Item'Length);\n+                              Natural'Max\n+                                (Source'Length,\n+                                 Position - Source'First + New_Item'Length);\n+\n             Result : Wide_String (1 .. Result_Length);\n \n          begin\n             Result := Source (Source'First .. Position - 1) & New_Item &\n-                     Source (Position + New_Item'Length .. Source'Last);\n+                        Source (Position + New_Item'Length .. Source'Last);\n             return Result;\n          end;\n       end if;"}, {"sha": "661c30999162eb16fa0b8f4960c5c39a85fcb785", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.30 $\n+--                            $Revision$\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,8 +63,6 @@ package body Ada.Tags is\n --                                  |      tags         |\n --                                  +-------------------+\n \n-   use System;\n-\n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n    type Tag_Table is array (Natural range <>) of Tag;\n@@ -93,21 +91,20 @@ package body Ada.Tags is\n    -------------------------------------------\n \n    function To_Type_Specific_Data_Ptr is\n-     new Unchecked_Conversion (Address, Type_Specific_Data_Ptr);\n+     new Unchecked_Conversion (S.Address, Type_Specific_Data_Ptr);\n \n-   function To_Address is new Unchecked_Conversion (Tag, Address);\n    function To_Address is\n-     new Unchecked_Conversion (Type_Specific_Data_Ptr, Address);\n+     new Unchecked_Conversion (Type_Specific_Data_Ptr, S.Address);\n \n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------\n \n    function To_Cstring_Ptr is\n-     new Unchecked_Conversion (Address, Cstring_Ptr);\n+     new Unchecked_Conversion (S.Address, Cstring_Ptr);\n \n    function To_Address is\n-     new Unchecked_Conversion (Cstring_Ptr, Address);\n+     new Unchecked_Conversion (Cstring_Ptr, S.Address);\n \n    -----------------------\n    -- Local Subprograms --\n@@ -130,8 +127,8 @@ package body Ada.Tags is\n    package HTable_Subprograms is\n       procedure Set_HT_Link (T : Tag; Next : Tag);\n       function  Get_HT_Link (T : Tag) return Tag;\n-      function Hash (F : Address) return HTable_Headers;\n-      function Equal (A, B : Address) return Boolean;\n+      function Hash (F : S.Address) return HTable_Headers;\n+      function Equal (A, B : S.Address) return Boolean;\n    end HTable_Subprograms;\n \n    package External_Tag_HTable is new GNAT.HTable.Static_HTable (\n@@ -141,7 +138,7 @@ package body Ada.Tags is\n      Null_Ptr   => null,\n      Set_Next   => HTable_Subprograms.Set_HT_Link,\n      Next       => HTable_Subprograms.Get_HT_Link,\n-     Key        => Address,\n+     Key        => S.Address,\n      Get_Key    => Get_External_Tag,\n      Hash       => HTable_Subprograms.Hash,\n      Equal      => HTable_Subprograms.Equal);\n@@ -158,7 +155,7 @@ package body Ada.Tags is\n    -- Equal --\n    -----------\n \n-      function Equal (A, B : Address) return Boolean is\n+      function Equal (A, B : S.Address) return Boolean is\n          Str1 : Cstring_Ptr := To_Cstring_Ptr (A);\n          Str2 : Cstring_Ptr := To_Cstring_Ptr (B);\n          J    : Integer := 1;\n@@ -190,7 +187,7 @@ package body Ada.Tags is\n       -- Hash --\n       ----------\n \n-      function Hash (F : Address) return HTable_Headers is\n+      function Hash (F : S.Address) return HTable_Headers is\n          function H is new GNAT.HTable.Hash (HTable_Headers);\n          Str : Cstring_Ptr := To_Cstring_Ptr (F);\n          Res : constant HTable_Headers := H (Str (1 .. Length (Str)));\n@@ -262,7 +259,7 @@ package body Ada.Tags is\n    -- Get_Expanded_Name --\n    -----------------------\n \n-   function Get_Expanded_Name (T : Tag) return Address is\n+   function Get_Expanded_Name (T : Tag) return S.Address is\n    begin\n       return To_Address (T.TSD.Expanded_Name);\n    end Get_Expanded_Name;\n@@ -271,7 +268,7 @@ package body Ada.Tags is\n    -- Get_External_Tag --\n    ----------------------\n \n-   function Get_External_Tag (T : Tag) return Address is\n+   function Get_External_Tag (T : Tag) return S.Address is\n    begin\n       return To_Address (T.TSD.External_Tag);\n    end Get_External_Tag;\n@@ -292,7 +289,7 @@ package body Ada.Tags is\n    function Get_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive)\n-      return     Address\n+      return     S.Address\n    is\n    begin\n       return T.Prims_Ptr (Position);\n@@ -320,7 +317,7 @@ package body Ada.Tags is\n    -- Get_TSD --\n    -------------\n \n-   function Get_TSD  (T : Tag) return Address is\n+   function Get_TSD  (T : Tag) return S.Address is\n    begin\n       return To_Address (T.TSD);\n    end Get_TSD;\n@@ -345,7 +342,7 @@ package body Ada.Tags is\n    -- Inherit_TSD --\n    -----------------\n \n-   procedure Inherit_TSD (Old_TSD : Address; New_Tag : Tag) is\n+   procedure Inherit_TSD (Old_TSD : S.Address; New_Tag : Tag) is\n       TSD     : constant Type_Specific_Data_Ptr :=\n                   To_Type_Specific_Data_Ptr (Old_TSD);\n       New_TSD : Type_Specific_Data renames New_Tag.TSD.all;\n@@ -422,14 +419,14 @@ package body Ada.Tags is\n \n    type T_Ptr is access all T;\n \n-   function To_T_Ptr is new Unchecked_Conversion (Address, T_Ptr);\n+   function To_T_Ptr is new Unchecked_Conversion (S.Address, T_Ptr);\n \n    --  The profile of the implicitly defined _size primitive\n \n-   type Acc_Size is access function (A : Address) return Long_Long_Integer;\n-   function To_Acc_Size is new Unchecked_Conversion (Address, Acc_Size);\n+   type Acc_Size is access function (A : S.Address) return Long_Long_Integer;\n+   function To_Acc_Size is new Unchecked_Conversion (S.Address, Acc_Size);\n \n-   function Parent_Size (Obj : Address) return SSE.Storage_Count is\n+   function Parent_Size (Obj : S.Address) return SSE.Storage_Count is\n \n       --  Get the tag of the object\n \n@@ -463,7 +460,7 @@ package body Ada.Tags is\n    -- Set_Expanded_Name --\n    -----------------------\n \n-   procedure Set_Expanded_Name (T : Tag; Value : Address) is\n+   procedure Set_Expanded_Name (T : Tag; Value : S.Address) is\n    begin\n       T.TSD.Expanded_Name := To_Cstring_Ptr (Value);\n    end Set_Expanded_Name;\n@@ -472,7 +469,7 @@ package body Ada.Tags is\n    -- Set_External_Tag --\n    ----------------------\n \n-   procedure Set_External_Tag (T : Tag; Value : Address) is\n+   procedure Set_External_Tag (T : Tag; Value : S.Address) is\n    begin\n       T.TSD.External_Tag := To_Cstring_Ptr (Value);\n    end Set_External_Tag;\n@@ -496,7 +493,7 @@ package body Ada.Tags is\n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n-      Value    : Address)\n+      Value    : S.Address)\n    is\n    begin\n       T.Prims_Ptr (Position) := Value;\n@@ -528,7 +525,7 @@ package body Ada.Tags is\n    -- Set_TSD --\n    -------------\n \n-   procedure Set_TSD (T : Tag; Value : Address) is\n+   procedure Set_TSD (T : Tag; Value : S.Address) is\n    begin\n       T.TSD := To_Type_Specific_Data_Ptr (Value);\n    end Set_TSD;"}, {"sha": "594bfec935eb2dbfb4f7fbcb7757f852bfaacb02", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,9 +6,9 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n---             Copyright (C) 1991-2000 Florida State University             --\n+--             Copyright (C) 1991-2002 Florida State University             --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,7 @@\n -- covered by the  GNU Public License.                                      --\n --                                                                          --\n -- GNARL was developed by the GNARL team at Florida State University. It is --\n--- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n--- State University (http://www.gnat.com).                                  --\n+-- now maintained by Ada Core Technologies, Inc. (http://www.gnat.com).     --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -182,8 +181,7 @@\n --  The latter initialization requires a list of all the instantiation\n --  descriptors. Updates to this list, as well as the bit-vector that\n --  is used to reserve slots for attributes in the TCB, require mutual\n---  exclusion. That is provided by the lock\n---  System.Tasking.Task_Attributes.All_Attrs_L.\n+--  exclusion. That is provided by the Lock/Unlock_RTS.\n \n --  One special problem that added complexity to the design is that\n --  the per-task list of indirect attributes contains objects of\n@@ -243,7 +241,7 @@ with System.Storage_Elements;\n with System.Task_Primitives.Operations;\n --  used for Write_Lock\n --           Unlock\n---           Lock/Unlock_All_Tasks_List\n+--           Lock/Unlock_RTS\n \n with System.Tasking;\n --  used for Access_Address\n@@ -301,6 +299,14 @@ package body Ada.Task_Attributes is\n    type Wrapper;\n    type Access_Wrapper is access all Wrapper;\n \n+   pragma Warnings (Off);\n+   --  We turn warnings off for the following declarations of the\n+   --  To_Attribute_Handle conversions, since these are used only\n+   --  for small attributes where we know that there are no problems\n+   --  with alignment, but the compiler will generate warnings for\n+   --  the occurrences in the large attribute case, even though\n+   --  they will not actually be used.\n+\n    function To_Attribute_Handle is new Unchecked_Conversion\n      (Access_Address, Attribute_Handle);\n    --  For reference to directly addressed task attributes\n@@ -312,6 +318,10 @@ package body Ada.Task_Attributes is\n      (Access_Integer_Address, Attribute_Handle);\n    --  For reference to directly addressed task attributes\n \n+   pragma Warnings (On);\n+   --  End of warnings off region for directly addressed\n+   --  attribute conversion functions.\n+\n    function To_Access_Address is new Unchecked_Conversion\n      (Access_Node, Access_Address);\n    --  To store pointer to list of indirect attributes\n@@ -320,9 +330,15 @@ package body Ada.Task_Attributes is\n      (Access_Address, Access_Node);\n    --  To fetch pointer to list of indirect attributes\n \n+   pragma Warnings (Off);\n    function To_Access_Wrapper is new Unchecked_Conversion\n      (Access_Dummy_Wrapper, Access_Wrapper);\n-   --  To fetch pointer to actual wrapper of attribute node\n+   pragma Warnings (On);\n+   --  To fetch pointer to actual wrapper of attribute node. We turn off\n+   --  warnings since this may generate an alignment warning. The warning\n+   --  can be ignored since Dummy_Wrapper is only a non-generic standin\n+   --  for the real wrapper type (we never actually allocate objects of\n+   --  type Dummy_Wrapper).\n \n    function To_Access_Dummy_Wrapper is new Unchecked_Conversion\n      (Access_Wrapper, Access_Dummy_Wrapper);\n@@ -388,7 +404,7 @@ package body Ada.Task_Attributes is\n      (T    : Task_Identification.Task_Id := Task_Identification.Current_Task)\n       return Attribute_Handle\n    is\n-      TT          : Task_ID := To_Task_ID (T);\n+      TT            : Task_ID := To_Task_ID (T);\n       Error_Message : constant String := \"Trying to get the reference of a\";\n \n    begin\n@@ -404,13 +420,24 @@ package body Ada.Task_Attributes is\n \n       begin\n          Defer_Abortion;\n-         POP.Write_Lock (All_Attrs_L'Access);\n+         POP.Lock_RTS;\n+\n+         --  Directly addressed case\n \n          if Local.Index /= 0 then\n-            POP.Unlock (All_Attrs_L'Access);\n+            POP.Unlock_RTS;\n             Undefer_Abortion;\n+\n+            --  Return the attribute handle. Warnings off because this return\n+            --  statement generates alignment warnings for large attributes\n+            --  (but will never be executed in this case anyway).\n+\n+            pragma Warnings (Off);\n             return\n               To_Attribute_Handle (TT.Direct_Attributes (Local.Index)'Access);\n+            pragma Warnings (On);\n+\n+         --  Not directly addressed\n \n          else\n             declare\n@@ -420,28 +447,28 @@ package body Ada.Task_Attributes is\n             begin\n                while P /= null loop\n                   if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n-                     POP.Unlock (All_Attrs_L'Access);\n+                     POP.Unlock_RTS;\n                      Undefer_Abortion;\n                      return To_Access_Wrapper (P.Wrapper).Value'Access;\n                   end if;\n \n                   P := P.Next;\n                end loop;\n \n-               --  Unlock All_Attrs_L here to follow the lock ordering rule\n+               --  Unlock the RTS here to follow the lock ordering rule\n                --  that prevent us from using new (i.e the Global_Lock) while\n                --  holding any other lock.\n \n-               POP.Unlock (All_Attrs_L'Access);\n+               POP.Unlock_RTS;\n                W := new Wrapper'\n                      ((null, Local'Unchecked_Access, null), Initial_Value);\n-               POP.Write_Lock (All_Attrs_L'Access);\n+               POP.Lock_RTS;\n \n                P := W.Noed'Unchecked_Access;\n                P.Wrapper := To_Access_Dummy_Wrapper (W);\n                P.Next := To_Access_Node (TT.Indirect_Attributes);\n                TT.Indirect_Attributes := To_Access_Address (P);\n-               POP.Unlock (All_Attrs_L'Access);\n+               POP.Unlock_RTS;\n                Undefer_Abortion;\n                return W.Value'Access;\n             end;\n@@ -452,7 +479,7 @@ package body Ada.Task_Attributes is\n \n       exception\n          when others =>\n-            POP.Unlock (All_Attrs_L'Access);\n+            POP.Unlock_RTS;\n             Undefer_Abortion;\n             raise;\n       end;\n@@ -493,9 +520,9 @@ package body Ada.Task_Attributes is\n \n          begin\n             Defer_Abortion;\n-            POP.Write_Lock (All_Attrs_L'Access);\n-\n+            POP.Lock_RTS;\n             Q := To_Access_Node (TT.Indirect_Attributes);\n+\n             while Q /= null loop\n                if Q.Instance = Access_Instance'(Local'Unchecked_Access) then\n                   if P = null then\n@@ -506,7 +533,7 @@ package body Ada.Task_Attributes is\n \n                   W := To_Access_Wrapper (Q.Wrapper);\n                   Free (W);\n-                  POP.Unlock (All_Attrs_L'Access);\n+                  POP.Unlock_RTS;\n                   Undefer_Abortion;\n                   return;\n                end if;\n@@ -515,12 +542,12 @@ package body Ada.Task_Attributes is\n                Q := Q.Next;\n             end loop;\n \n-            POP.Unlock (All_Attrs_L'Access);\n+            POP.Unlock_RTS;\n             Undefer_Abortion;\n \n          exception\n             when others =>\n-               POP.Unlock (All_Attrs_L'Access);\n+               POP.Unlock_RTS;\n                Undefer_Abortion;\n          end;\n \n@@ -560,15 +587,27 @@ package body Ada.Task_Attributes is\n \n       begin\n          Defer_Abortion;\n-         POP.Write_Lock (All_Attrs_L'Access);\n+         POP.Lock_RTS;\n+\n+         --  Directly addressed case\n \n          if Local.Index /= 0 then\n+\n+            --  Set attribute handle, warnings off, because this code can\n+            --  generate alignment warnings with large attributes (but of\n+            --  course wil not be executed in this case, since we never\n+            --  have direct addressing in such cases).\n+\n+            pragma Warnings (Off);\n             To_Attribute_Handle\n                (TT.Direct_Attributes (Local.Index)'Access).all := Val;\n-            POP.Unlock (All_Attrs_L'Access);\n+            pragma Warnings (On);\n+            POP.Unlock_RTS;\n             Undefer_Abortion;\n             return;\n \n+         --  Not directly addressed\n+\n          else\n             declare\n                P : Access_Node := To_Access_Node (TT.Indirect_Attributes);\n@@ -579,36 +618,35 @@ package body Ada.Task_Attributes is\n \n                   if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n                      To_Access_Wrapper (P.Wrapper).Value := Val;\n-                     POP.Unlock (All_Attrs_L'Access);\n+                     POP.Unlock_RTS;\n                      Undefer_Abortion;\n                      return;\n                   end if;\n \n                   P := P.Next;\n                end loop;\n \n-               --  Unlock TT here to follow the lock ordering rule that\n+               --  Unlock RTS here to follow the lock ordering rule that\n                --  prevent us from using new (i.e the Global_Lock) while\n                --  holding any other lock.\n \n-               POP.Unlock (All_Attrs_L'Access);\n+               POP.Unlock_RTS;\n                W := new Wrapper'\n                      ((null, Local'Unchecked_Access, null), Val);\n-               POP.Write_Lock (All_Attrs_L'Access);\n-\n+               POP.Lock_RTS;\n                P := W.Noed'Unchecked_Access;\n                P.Wrapper := To_Access_Dummy_Wrapper (W);\n                P.Next := To_Access_Node (TT.Indirect_Attributes);\n                TT.Indirect_Attributes := To_Access_Address (P);\n             end;\n          end if;\n \n-         POP.Unlock (All_Attrs_L'Access);\n+         POP.Unlock_RTS;\n          Undefer_Abortion;\n \n       exception\n          when others =>\n-            POP.Unlock (All_Attrs_L'Access);\n+            POP.Unlock_RTS;\n             Undefer_Abortion;\n             raise;\n       end;\n@@ -648,23 +686,35 @@ package body Ada.Task_Attributes is\n       end if;\n \n       begin\n+         --  Directly addressed case\n+\n          if Local.Index /= 0 then\n+\n+            --  Get value of attribute. Warnings off, because for large\n+            --  attributes, this code can generate alignment warnings.\n+            --  But of course large attributes are never directly addressed\n+            --  so in fact we will never execute the code in this case.\n+\n+            pragma Warnings (Off);\n             Result :=\n               To_Attribute_Handle\n                 (TT.Direct_Attributes (Local.Index)'Access).all;\n+            pragma Warnings (On);\n+\n+         --  Not directly addressed\n \n          else\n             declare\n                P : Access_Node;\n \n             begin\n                Defer_Abortion;\n-               POP.Write_Lock (All_Attrs_L'Access);\n-\n+               POP.Lock_RTS;\n                P := To_Access_Node (TT.Indirect_Attributes);\n+\n                while P /= null loop\n                   if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n-                     POP.Unlock (All_Attrs_L'Access);\n+                     POP.Unlock_RTS;\n                      Undefer_Abortion;\n                      return To_Access_Wrapper (P.Wrapper).Value;\n                   end if;\n@@ -673,12 +723,12 @@ package body Ada.Task_Attributes is\n                end loop;\n \n                Result := Initial_Value;\n-               POP.Unlock (All_Attrs_L'Access);\n+               POP.Unlock_RTS;\n                Undefer_Abortion;\n \n             exception\n                when others =>\n-                  POP.Unlock (All_Attrs_L'Access);\n+                  POP.Unlock_RTS;\n                   Undefer_Abortion;\n                   raise;\n             end;\n@@ -707,11 +757,15 @@ begin\n    pragma Warnings (On);\n \n    declare\n-      Two_To_J    : Direct_Index_Vector;\n-\n+      Two_To_J : Direct_Index_Vector;\n    begin\n       Defer_Abortion;\n-      POP.Write_Lock (All_Attrs_L'Access);\n+\n+      --  Need protection for updating links to per-task initialization and\n+      --  finalization routines, in case some task is being created or\n+      --  terminated concurrently.\n+\n+      POP.Lock_RTS;\n \n       --  Add this instantiation to the list of all instantiations.\n \n@@ -749,12 +803,6 @@ begin\n          end loop;\n       end if;\n \n-      --  Need protection of All_Tasks_L for updating links to\n-      --  per-task initialization and finalization routines,\n-      --  in case some task is being created or terminated concurrently.\n-\n-      POP.Lock_All_Tasks_List;\n-\n       --  Attribute goes directly in the TCB\n \n       if Local.Index /= 0 then\n@@ -791,8 +839,7 @@ begin\n \n       end if;\n \n-      POP.Unlock_All_Tasks_List;\n-      POP.Unlock (All_Attrs_L'Access);\n+      POP.Unlock_RTS;\n       Undefer_Abortion;\n \n    exception\n@@ -804,5 +851,4 @@ begin\n          --  any initializations that succeeded up to this point, or we will\n          --  risk a dangling reference when the task terminates.\n    end;\n-\n end Ada.Task_Attributes;"}, {"sha": "d8e156cb133575e38875299c15689dfc13d66399", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.81 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -58,6 +58,8 @@ package body Ada.Text_IO is\n    -------------------\n \n    function AFCB_Allocate (Control_Block : Text_AFCB) return FCB.AFCB_Ptr is\n+      pragma Warnings (Off, Control_Block);\n+\n    begin\n       return new Text_AFCB;\n    end AFCB_Allocate;"}, {"sha": "48593ce479719e69b467a40ccce4d87bba34d97f", "filename": "gcc/ada/a-tideau.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tideau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tideau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tideau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.12 $\n+--                            $Revision$\n --                                                                          --\n --          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n --                                                                          --\n@@ -68,7 +68,7 @@ package body Ada.Text_IO.Decimal_Aux is\n       end if;\n \n       Item := Scan_Decimal (Buf, Ptr'Access, Stop, Scale);\n-      Check_End_Of_Field (File, Buf, Stop, Ptr, Width);\n+      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n       return Item;\n    end Get_Dec;\n \n@@ -97,7 +97,7 @@ package body Ada.Text_IO.Decimal_Aux is\n       end if;\n \n       Item := Scan_Long_Long_Decimal (Buf, Ptr'Access, Stop, Scale);\n-      Check_End_Of_Field (File, Buf, Stop, Ptr, Width);\n+      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n       return Item;\n    end Get_LLD;\n "}, {"sha": "685de685083b5507a3f3689c2680ae668ebd0200", "filename": "gcc/ada/a-tiflau.adb", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tiflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tiflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiflau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "82e9a0372ec1cb6941cc1e3eab280fdd1e01a757", "filename": "gcc/ada/a-tigeau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tigeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tigeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "19aa099130c566c5980e214f5e42303ab4630285", "filename": "gcc/ada/a-tigeau.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tigeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tigeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeau.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "0e7c443a121d62d226fd7a5b0296e0d1cae1a051", "filename": "gcc/ada/a-tiinau.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tiinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-tiinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tiinau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cb11a06d206ac413acc894a36be9da97e982657f", "filename": "gcc/ada/a-timoau.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-timoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-timoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-timoau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "b464b3e47aabf664a2f443181a8f34518661909b", "filename": "gcc/ada/a-witeio.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-witeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-witeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-witeio.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9ea4978076ea1af770fa527c50dba0c62f3a5775", "filename": "gcc/ada/a-wtdeau.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtdeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtdeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtdeau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1aa1afe1e4c3ff3f9c00531a9d9210eb23018674", "filename": "gcc/ada/a-wtenau.adb", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtenau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtenau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtenau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8122d9166a01954c4666bb8a64c9f1bc63f120ef", "filename": "gcc/ada/a-wtflau.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtflau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d539f46bcc641a49d49fcb8fffa02f7cb9cdb364", "filename": "gcc/ada/a-wtgeau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtgeau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "59b6e37bb49b78b891e3d8f59b6a3c5f99a72cd1", "filename": "gcc/ada/a-wtgeau.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtgeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtgeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtgeau.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ab3040b2bb6b983a8626936f11d1e4042e6ddb51", "filename": "gcc/ada/a-wtinau.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtinau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1ef8a6036621241a06f8016ae616186b14bfe878", "filename": "gcc/ada/a-wtmoau.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtmoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fa-wtmoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtmoau.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4c1f6874623d2c871417d192dc97e1fe3d616f3a", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "34a7a0255de147112f26d784dd433fcbc799eef2", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "2e40648418fae38bc11f7d25b39381ed6b29f4c0", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 275, "deletions": 256, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "649ece1c19bcb9389bc7aba452fd67f56b04b2af", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cb2a8877a1d322507c6dfd3491d46764912805dd", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "b654e32efc65edd0948f6f5dcb8f41a4a40b9a5e", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 129, "deletions": 98, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a5092594c50a72f0d0e1975a098d3d235d8d4a9f", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f9c24bf29308222c3432c2b682a165c761d222c3", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "45d8f08553fb039635db8b75ae32949b1e57337f", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "2fced8e02a87e060e2a7a927229be62729a75ab9", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 246, "deletions": 247, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7f31b57f3dd7df3758c7e50edc8a37c5a8f20a7d", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7d23d2743ca1568e9ae61338c0405c14265a1744", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 80, "deletions": 59, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "015ed90b16070b9248ab2ed0d251fc79ec992fc9", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 175, "deletions": 148, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "24772ed5daa401ef505ff1d3d9e73d9dabc5d00b", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 43, "deletions": 73, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1bd28ad8df32c4b27bcf2163516d689a5b32d6cd", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a3ffd6d74bd320ffa20a06ca9efcaff35367889a", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d9029c14b8db5dac35dd0975ed2c16ec83952d5f", "filename": "gcc/ada/config-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fconfig-lang.in?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8e4f9935978f77754e490e7a607f5352886ad231", "filename": "gcc/ada/csets.adb", "status": "modified", "additions": 91, "deletions": 14, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcsets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcsets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsets.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "09952d2dd30b8af6a33963033ed5ab3192fb3730", "filename": "gcc/ada/csets.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcsets.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcsets.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsets.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e0e8a655ebf7ad7dd6f5ec3d0afac94209f06022", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "dbff6afe20da1b1473e88a25ee325f0bf63632bc", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7887e804502064350647cd3c1735478166c38ffc", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e1735274bcdba852c2d354f8fadde612cf33e7c7", "filename": "gcc/ada/debug.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdebug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdebug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4b3b3a3ad4cee1f815aa4f4568bf587e310935a5", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 155, "deletions": 93, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "c84e10e71cec7341e93d60a0edad73ef7355477f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 163, "deletions": 39, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f9dda49eb66ec24b305e1dd145b06a38cd909987", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 90, "deletions": 56, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "6507e2f70bf7fb43f028e40691c31241146bb4ce", "filename": "gcc/ada/einfo.h", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1113a6a43c6780732737cbdc71762825d0d005ff", "filename": "gcc/ada/elists.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Felists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Felists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8e208d7974cf01071a343b333e7956e2e58689b5", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 197, "deletions": 65, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ffaa4c184839ca31926af86cf1ea53b1980d8d0c", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f7f328ff5e090d087788f2c45e1092e6e46e24d7", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "36d8c64499f21911a20799b0d8b5d20c9bcfa45a", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 784, "deletions": 335, "changes": 1119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "417c15988c9b03cec0c2adc38145a9e60b7eec7a", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "70da08b331d29026dc12bbda3d957d19016dabbb", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 94, "deletions": 22, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "6ecead18a47c686f3f23badc407b8afb50dbd888", "filename": "gcc/ada/exp_ch12.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch12.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "b1e24128c0bd01a00e865bb1b53dd844d4c4147b", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 92, "deletions": 65, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7460591d833ef90316864fb1df4ff1ca06c8e7ac", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7a39b4c9380d776d190f5132b770628cc70d4cc7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 189, "deletions": 86, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "915b0c241a3cb861d3b379035459bcd8efbc494f", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1d2bd7f70895fb2c1b3ab7b09b35d05486544848", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "509738929aa376787b54808a616e4ec05e293470", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cbe6df63f98ff0f176b6d6132cf2e887de6ee394", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "74225b4f37195c102bc6ebe3e4dfa9c7ca840d8f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 92, "deletions": 10, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e2207deefe6aac995d5a6ca62ef0d7d6867d17b2", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "905cb41acc8956de465fcfe3d1c7a1cf27337831", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ebb021f96174b85b4a02ad3faf7058cd2764619f", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1a130789641378ed30508af293ed532f055495d1", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 199, "deletions": 294, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9e6f8caca57820986a3916cd92a5f755754d5807", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 77, "deletions": 140, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "722d78874741e32bd6b6cf8bf395760f0147c065", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a4fbe7c776d5971adc0bd2d5fce826f2afdf5756", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "2d49f90006901e2341b67b473270e5212f61ba6e", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ae28efd647e7fe99aa6e218d00f674e2b0803364", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "511cd4c95a51e2d9de0975f7513897c57d05d35b", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "54ea0413cb78f3ef387cfb40e29cfd6953d296cf", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "604d1922aab491184a7c384ffedf93875e8204de", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7c17fb65017fece799fc0f959ebbe77e5469af28", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 98, "deletions": 8, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "44b71edc871a3e92ed1d8351c2cb12664c163af3", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "55bbf386d1bbde0882d75333c92597164e3bf049", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "663eb3f929889321821785573f6804be5053643a", "filename": "gcc/ada/expect.c", "status": "modified", "additions": 138, "deletions": 14, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexpect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fexpect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpect.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4b2dc8e6696b3f3288e3bc88a6ce418974a828fe", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9c1ffea51911ce35965b5409dd9dd03db762d6af", "filename": "gcc/ada/fmap.adb", "status": "modified", "additions": 167, "deletions": 54, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffmap.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "0e37b9b5c7cceae3ac1ad093685a7c94af6a63a4", "filename": "gcc/ada/fmap.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffmap.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "5f4fb9a22bba1025ef27344b4e6530c9943c6fd0", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7fe7f8affb3aeae477428ee7be0e29321cd52546", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 173, "deletions": 28, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d8460d261a1d0aabe37f487f67e47424281b1ddc", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "3a303eea3c0628e5a172baaf98bc78f0dddfca59", "filename": "gcc/ada/g-awk.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-awk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-awk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "b3a3469cba298ea7b534f29e5117c22ef903de00", "filename": "gcc/ada/g-cgideb.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-cgideb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-cgideb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgideb.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "16aea3f733059f1dcac675543bc9d8913e285283", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 224, "deletions": 37, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "37f11f1549315bb4753d43eb150b7ba5b253b8aa", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f4e779ad4551b4140e9b40d2d8caa32a013de020", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8c26c63107e9eede727e696b3b00fe9377284790", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "62308a674b1fa371353d92aac923a969767d7038", "filename": "gcc/ada/g-dirope.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dirope.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dirope.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d788f9257bd54616c1fd43f6ab6b27ddc788574c", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cec401f3207f29fab8e3d3002505423bcc9690f5", "filename": "gcc/ada/g-enblsp.adb", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-enblsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-enblsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-enblsp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e114cd94c200c2cb86f078b768480521663444e0", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 47, "deletions": 100, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e1b0daaa7c72f9f202a9c5bc7579e3a36b23adce", "filename": "gcc/ada/g-expect.ads", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-expect.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-expect.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1d3b285572b3dbe2b8dcf5fe012017f234bec921", "filename": "gcc/ada/g-io.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "27d78d9dd2c584aa428f00f72e6425bb02626a60", "filename": "gcc/ada/g-io_aux.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io_aux.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f6d1ce29d644c1b0fd698b47e37ce66378dc73e7", "filename": "gcc/ada/g-io_aux.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-io_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-io_aux.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ced160c7f97764461467e31946b575b752527483", "filename": "gcc/ada/g-locfil.adb", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-locfil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-locfil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-locfil.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1034252548e8ef597f88e7df4cd2510104c4e789", "filename": "gcc/ada/g-locfil.ads", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-locfil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-locfil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-locfil.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d5ca09058b214d8b032002eb2f4a4f63bf222ded", "filename": "gcc/ada/g-md5.adb", "status": "added", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-md5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-md5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-md5.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "c89d2099f4136866758d9303ad00f34de51a0541", "filename": "gcc/ada/g-md5.ads", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-md5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-md5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-md5.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9c5b6f14bd58526f9d8775cc9ff80353bf329f23", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 201, "deletions": 62, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a878f90e74b6badd9bebb6486cf0cfdd31f8515e", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 71, "deletions": 26, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "66d56674009ec957939365aa969b57a403a8fa43", "filename": "gcc/ada/g-regexp.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regexp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "561dca3ed6605e1a44f3b7c84454aaffc6edf18f", "filename": "gcc/ada/g-regpat.adb", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "5ff59835247ff7bd81905614b39194bb998e604e", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "2e207b25077b51126d0dda8a6ed321f824095fe6", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "469ac056b37b9c48058127e090fb0d95e789f3fd", "filename": "gcc/ada/g-spipat.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "82411ba69b212f3e83acd182bc1269da1da2671a", "filename": "gcc/ada/g-table.adb", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-table.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-table.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "71bc5a59da8f2b794fa7f144f7655a03088ffaf8", "filename": "gcc/ada/g-trasym.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-trasym.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-trasym.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "47ce3b367def991da1e6005d45fe6244a3c312a8", "filename": "gcc/ada/g-trasym.ads", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fg-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7c8541a8184cf80f2d6c7e15f24bd26014a2b2c8", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cc1bea203c1e48df4eaf7cb872b75cf491f102f0", "filename": "gcc/ada/gmem.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "72679d5233a3ad26b0bf064441eb3c6e3509c102", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d66df981c0bb56a7a2d47faabf23faf9f8a2a800", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f18105821277ad2564e759a9d7f21e0e4dcff03c", "filename": "gcc/ada/gnatbl.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbl.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "725ff4ac4b256cd7b747168b22f843f0ab907f7c", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "090bf426ce58cdf93bae3ce44114776448d31733", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 2269, "deletions": 1322, "changes": 3591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "5fba394df2e55e7136d1b64380b995409de6b89a", "filename": "gcc/ada/gnatdll.adb", "status": "modified", "additions": 75, "deletions": 38, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatdll.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "541ad4bf766dfe73f57703e65adb84f89b58207b", "filename": "gcc/ada/gnatfind.adb", "status": "modified", "additions": 84, "deletions": 27, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatfind.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a6896161ea433435477f7bd3982cb2d05744da89", "filename": "gcc/ada/gnatlbr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatlbr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatlbr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlbr.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "24a1198806a1c252b01a246715f7b1bd029f740f", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 198, "deletions": 140, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9a2b4c8d47040a621f829af8fe378b0bd80a0a7c", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 106, "deletions": 231, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "cba6181b64bff8cc03386456529bf2fd8b772439", "filename": "gcc/ada/gnatmain.adb", "status": "removed", "additions": 0, "deletions": 594, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2Fgnatmain.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2Fgnatmain.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmain.adb?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514"}, {"sha": "c6a99ae718974c6dea9027f0cb6d4dc8addd7252", "filename": "gcc/ada/gnatmem.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatmem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatmem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatmem.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4dc3364db3dfb59efcb667b2c11ad9955b98fc51", "filename": "gcc/ada/gnatname.adb", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "373c8e72a9d6ddaffdcd4fbceaaef65635ebd386", "filename": "gcc/ada/gnatname.ads", "status": "renamed", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatname.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatname.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "previous_filename": "gcc/ada/gnatmain.ads"}, {"sha": "23400dac90aba5831856e60e814742d66875978e", "filename": "gcc/ada/gnatprep.adb", "status": "modified", "additions": 201, "deletions": 36, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatprep.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "9e65c2a25377fc8ecd239e95797c666110c01f1b", "filename": "gcc/ada/gnatpsys.adb", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2Fgnatpsys.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514/gcc%2Fada%2Fgnatpsys.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatpsys.adb?ref=24965e7a8ac518b99a3bd7ef5b2d8d88f96bf514"}, {"sha": "36a95c5dc000bf6ec98e880cc6abcde41e17f107", "filename": "gcc/ada/gnatvsn.ads", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatvsn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatvsn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatvsn.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f930de6c97c354ad61f69fed3e92cf0179539035", "filename": "gcc/ada/gnatxref.adb", "status": "modified", "additions": 79, "deletions": 23, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatxref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fgnatxref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatxref.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "c657ea4b7bb08e7d0d3dfc6b6794b49955e24e7e", "filename": "gcc/ada/hlo.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fhlo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fhlo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhlo.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "69ca47aad9c4f6aba1423355cea291de4d0c8bf5", "filename": "gcc/ada/hostparm.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fhostparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fhostparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhostparm.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d4ebf30bbff129770521ae4906414b1d2597be28", "filename": "gcc/ada/i-cobol.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cobol.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cobol.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cobol.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "b44885d0f93275d488a97e822d361e18ea60e065", "filename": "gcc/ada/i-cpp.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cpp.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "dcb006501499935aecdb81c0adc85911778de29c", "filename": "gcc/ada/i-cstrea.ads", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cstrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cstrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "df59e9b9f4c7faee026ba9ab22f6ceee94aa25e5", "filename": "gcc/ada/i-cstrin.adb", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cstrin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-cstrin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrin.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e49c455635f3cb1690958adaac3335deaf4370e1", "filename": "gcc/ada/i-pacdec.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-pacdec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-pacdec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-pacdec.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "82b744e741599e49f508a8f5142c09cf4904fe82", "filename": "gcc/ada/i-vxwork.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-vxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fi-vxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-vxwork.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "3fb0c56f91be148a1e346e765f9e2ed691489154", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f5888b0f9955ad41fe5598256f8f788f758d5c9d", "filename": "gcc/ada/init.c", "status": "modified", "additions": 86, "deletions": 90, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "09ba57ca678872dbe8b3b78feb7767dbfba28853", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "5b9fca0e32616882b79ab4e3330bbd40dc7cdf79", "filename": "gcc/ada/io-aux.c", "status": "modified", "additions": 8, "deletions": 54, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fio-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fio-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fio-aux.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8245e9556d7d39059f9fce97933d9953f0c29536", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a8d4250cc225be6dc3d3640b716a1db77a9a53c1", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "bee3a768ff86eb717136e5962a0078b2f2a2d63e", "filename": "gcc/ada/lib-util.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-util.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e0c3c406d2a19661a1141e0eaf7cbf9621c5a04b", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "3ef8f0c6c708998c9dad6e73485c6cedce75c9ce", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e0e20b45edd779e67fe3e39ac9febbd8612ff7b7", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "c56a8566065fbfd78eaea7a249d5e88e9b3526b2", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 134, "deletions": 98, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "8d2ea918901316fa65602e05365545acc064c65a", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "006d5ae9b0be600cd66496ed47276118ad178190", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e46c54e836ff9abdf1c51c23d000860e4cffa3d1", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 560, "deletions": 321, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "051c8f16b8048c75046c95eedbe1b2624b9130a2", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 45, "deletions": 73, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "20a8123b75c11bcf8a33e3d63abef90f94f1f4b1", "filename": "gcc/ada/mdll-fil.adb", "status": "renamed", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-fil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-fil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-fil.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "previous_filename": "gcc/ada/mdllfile.adb"}, {"sha": "3953012bb629ed6bd10a910b42e2acd8b1ac5dcc", "filename": "gcc/ada/mdll-fil.ads", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-fil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-fil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-fil.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "previous_filename": "gcc/ada/mdllfile.ads"}, {"sha": "75488ccf278efa420afbcdb3becc4e432051a54b", "filename": "gcc/ada/mdll-utl.adb", "status": "renamed", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-utl.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "previous_filename": "gcc/ada/mdlltool.adb"}, {"sha": "130e14cbee07c7d7249f6f78e825963c11857e27", "filename": "gcc/ada/mdll-utl.ads", "status": "renamed", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-utl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll-utl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-utl.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666", "previous_filename": "gcc/ada/mdlltool.ads"}, {"sha": "9f476b2b04db6c9b4df28e8c628746df93a7e816", "filename": "gcc/ada/mdll.adb", "status": "modified", "additions": 79, "deletions": 76, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "0cca01293e39fead53cc37178a2aa2bec98b1e5b", "filename": "gcc/ada/memroot.adb", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmemroot.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmemroot.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemroot.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "99e06fea7e527154a9ca1be04fe5b98e18d8e959", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 124, "deletions": 282, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a273d23561da641f40046625a028c2af72c48ffd", "filename": "gcc/ada/mkdir.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmkdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmkdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmkdir.c?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "dd2ae15d88306001f4762e7365521d47db04334e", "filename": "gcc/ada/mlib-tgt.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "36b465d27cb04fb59e4a1fe26b16f84fab02ca1b", "filename": "gcc/ada/mlib-utl.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "dacf91929a42dd2fe8523034dd0d388fdca854cc", "filename": "gcc/ada/mlib-utl.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-utl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib-utl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "37c8ee3c4cd84311b37fbfdf38b551e5495fb6dc", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1044be89ea849e2a58a6e77039dfea8462f56c23", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "f22f182dde740767e026b70236be7a05db4d27ff", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7d53610172b65b7898ce664ab24121d3eb9775d3", "filename": "gcc/ada/namet.h", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "30bf8ee1ca6c4f91cf5d3968aa5597df951cb754", "filename": "gcc/ada/nlists.h", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnlists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnlists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.h?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "858d5a8540e49b1c4af3f420d927f7719efeabbf", "filename": "gcc/ada/nmake.adb", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "ab774ecf22c54a6159fed250d17481f8abf4acb3", "filename": "gcc/ada/nmake.ads", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnmake.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fnmake.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnmake.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4ddc37822533bbdfb58ac7935ee1087cb5c06209", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "66e239f81a180017d20038cb11bc7deffd89e22a", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 137, "deletions": 87, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "d793bd1ab23fed74a8cc6556b3ba740e1ea010e9", "filename": "gcc/ada/osint-b.adb", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-b.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "580974ce60ed095d3105d7b7e280750d09e3972c", "filename": "gcc/ada/osint-b.ads", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-b.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-b.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-b.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "40198cd00fd11cc516242cf04fa55a0ab0ecdf98", "filename": "gcc/ada/osint-c.adb", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-c.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "30984fae6f205bacc98c1b313cc70160d51ffa69", "filename": "gcc/ada/osint-c.ads", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-c.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "2f5cf12eff1f4c5946056ffdacec62999a81eca2", "filename": "gcc/ada/osint-l.adb", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-l.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "1e8c8f4bef46f3cfb7727ef029a89723adf3cbd0", "filename": "gcc/ada/osint-l.ads", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-l.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-l.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-l.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "3ff563fe789e8a4cd1dac417f99547af14f8c666", "filename": "gcc/ada/osint-m.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-m.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "45d94f585eb74a4dbd98d8dc5a2f59ad8c71e6ba", "filename": "gcc/ada/osint-m.ads", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-m.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint-m.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint-m.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "95ec2d6062c60d8870d566c4fe0aad5b6808d792", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 323, "deletions": 694, "changes": 1017, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "5f3eb15afa1b7013c412651bf9e6ffa74147e6c0", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 147, "deletions": 235, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "4c2f148fbf7e727d20bc3f76fc85d8720711ebf7", "filename": "gcc/ada/output.adb", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "a6605297e3268ed1598ec92dbbe00c470cdfad9a", "filename": "gcc/ada/output.ads", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Foutput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Foutput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.ads?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "bade8aae77b6e203de78f747b9c2fe3d23e0e905", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7dd82b250d1350860233894d48e2f2fabc702497", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "46866ec6e5d1513532e6075523cc1ae4b2add36c", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "7ab1c350aa7c3b56a08be0f429552ac23f7cb2f5", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}, {"sha": "e3f619c8f4533d538e04d1556dbe03a00fb54e2d", "filename": "gcc/ada/par-tchk.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fc65c47c45af6439208797e1ab26f7daedb666/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=07fc65c47c45af6439208797e1ab26f7daedb666"}]}