{"sha": "447a704564e850ccba796bb688b5bc83fd3ee892", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3YTcwNDU2NGU4NTBjY2JhNzk2YmI2ODhiNWJjODNmZDNlZTg5Mg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-11-04T18:44:13Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-11-04T18:44:13Z"}, "message": "re PR debug/54693 (VTA guality issues with loops)\n\nPR debug/54693\n* tree-ssa-threadedge.c (propagate_threaded_block_debug_into):\nNew, rewritten from debug stmt copying code...\n(thread_around_empty_block): ... removed from here.\n(thread_across_edge): Call propagate_threaded_block_debug_into.\n\nFrom-SVN: r193138", "tree": {"sha": "9b2764e159a783f231719c21b79e4b32df016978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2764e159a783f231719c21b79e4b32df016978"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447a704564e850ccba796bb688b5bc83fd3ee892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447a704564e850ccba796bb688b5bc83fd3ee892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447a704564e850ccba796bb688b5bc83fd3ee892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447a704564e850ccba796bb688b5bc83fd3ee892/comments", "author": null, "committer": null, "parents": [{"sha": "48e3b832bd1f56a8a3b10df5aada6eec28ca14c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e3b832bd1f56a8a3b10df5aada6eec28ca14c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e3b832bd1f56a8a3b10df5aada6eec28ca14c1"}], "stats": {"total": 114, "additions": 95, "deletions": 19}, "files": [{"sha": "ddffb1a19d415dac38f22be2c08e5d07d9b15a03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447a704564e850ccba796bb688b5bc83fd3ee892/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447a704564e850ccba796bb688b5bc83fd3ee892/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=447a704564e850ccba796bb688b5bc83fd3ee892", "patch": "@@ -1,3 +1,11 @@\n+2012-11-04  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/54693\n+\t* tree-ssa-threadedge.c (propagate_threaded_block_debug_into):\n+\tNew, rewritten from debug stmt copying code...\n+\t(thread_around_empty_block): ... removed from here.\n+\t(thread_across_edge): Call propagate_threaded_block_debug_into.\n+\n 2012-11-04  Dehao Chen  <dehao@google.com>\n \n \t* expr.c (expand_expr_real_1): Change to not using input_location."}, {"sha": "a9c671e4eccfa95b5d8d0dec6064320c4ae44884", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 87, "deletions": 19, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447a704564e850ccba796bb688b5bc83fd3ee892/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447a704564e850ccba796bb688b5bc83fd3ee892/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=447a704564e850ccba796bb688b5bc83fd3ee892", "patch": "@@ -610,6 +610,85 @@ cond_arg_set_in_bb (edge e, basic_block bb)\n   return false;\n }\n \n+/* Copy debug stmts from DEST's chain of single predecessors up to\n+   SRC, so that we don't lose the bindings as PHI nodes are introduced\n+   when DEST gains new predecessors.  */\n+static void\n+propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n+{\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  if (!single_pred_p (dest))\n+    return;\n+\n+  gcc_checking_assert (dest != src);\n+\n+  gimple_stmt_iterator gsi = gsi_after_labels (dest);\n+  pointer_set_t *vars = pointer_set_create ();\n+\n+  for (gimple_stmt_iterator si = gsi;\n+       !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple stmt = gsi_stmt (si);\n+      if (!is_gimple_debug (stmt))\n+\tbreak;\n+\n+      tree var;\n+\n+      if (gimple_debug_bind_p (stmt))\n+\tvar = gimple_debug_bind_get_var (stmt);\n+      else if (gimple_debug_source_bind_p (stmt))\n+\tvar = gimple_debug_source_bind_get_var (stmt);\n+      else\n+\tgcc_unreachable ();\n+\n+      pointer_set_insert (vars, var);\n+    }\n+\n+  basic_block bb = dest;\n+\n+  do\n+    {\n+      bb = single_pred (bb);\n+      for (gimple_stmt_iterator si = gsi_last_bb (bb);\n+\t   !gsi_end_p (si); gsi_prev (&si))\n+\t{\n+\t  gimple stmt = gsi_stmt (si);\n+\t  if (!is_gimple_debug (stmt))\n+\t    continue;\n+\n+\t  tree var;\n+\n+\t  if (gimple_debug_bind_p (stmt))\n+\t    var = gimple_debug_bind_get_var (stmt);\n+\t  else if (gimple_debug_source_bind_p (stmt))\n+\t    var = gimple_debug_source_bind_get_var (stmt);\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  /* Discard debug bind overlaps.  ??? Unlike stmts from src,\n+\t     copied into a new block that will precede BB, debug bind\n+\t     stmts in bypassed BBs may actually be discarded if\n+\t     they're overwritten by subsequent debug bind stmts, which\n+\t     might be a problem once we introduce stmt frontier notes\n+\t     or somesuch.  Adding `&& bb == src' to the condition\n+\t     below will preserve all potentially relevant debug\n+\t     notes.  */\n+\t  if (pointer_set_insert (vars, var))\n+\t    continue;\n+\n+\t  stmt = gimple_copy (stmt);\n+\t  /* ??? Should we drop the location of the copy to denote\n+\t     they're artificial bindings?  */\n+\t  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n+\t}\n+    }\n+  while (bb != src && single_pred_p (bb));\n+\n+  pointer_set_destroy (vars);\n+}\n+\n /* TAKEN_EDGE represents the an edge taken as a result of jump threading.\n    See if we can thread around TAKEN_EDGE->dest as well.  If so, return\n    the edge out of TAKEN_EDGE->dest that we can statically compute will be\n@@ -637,24 +716,6 @@ thread_around_empty_block (edge taken_edge,\n   if (!single_pred_p (bb))\n     return NULL;\n \n-  /* Before threading, copy DEBUG stmts from the predecessor, so that\n-     we don't lose the bindings as we redirect the edges.  */\n-  if (MAY_HAVE_DEBUG_STMTS)\n-    {\n-      gsi = gsi_after_labels (bb);\n-      for (gimple_stmt_iterator si = gsi_last_bb (taken_edge->src);\n-\t   !gsi_end_p (si); gsi_prev (&si))\n-\t{\n-\t  stmt = gsi_stmt (si);\n-\t  if (!is_gimple_debug (stmt))\n-\t    continue;\n-\n-\t  stmt = gimple_copy (stmt);\n-\t  /* ??? Should we drop the location of the copy?  */\n-\t  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n-\t}\n-    }\n-\n   /* This block must have more than one successor.  */\n   if (single_succ_p (bb))\n     return NULL;\n@@ -827,6 +888,9 @@ thread_across_edge (gimple dummy_cond,\n \t    }\n \n \t  remove_temporary_equivalences (stack);\n+\t  if (!taken_edge)\n+\t    return;\n+\t  propagate_threaded_block_debug_into (taken_edge->dest, e->dest);\n \t  register_jump_thread (e, taken_edge, NULL);\n \t  return;\n \t}\n@@ -892,7 +956,11 @@ thread_across_edge (gimple dummy_cond,\n \t       same.  */\n \t    tmp = find_edge (taken_edge->src, e3->dest);\n \t    if (!tmp || phi_args_equal_on_edges (tmp, e3))\n-\t      register_jump_thread (e, taken_edge, e3);\n+\t      {\n+\t\tpropagate_threaded_block_debug_into (e3->dest,\n+\t\t\t\t\t\t     taken_edge->dest);\n+\t\tregister_jump_thread (e, taken_edge, e3);\n+\t      }\n \t  }\n \n       }"}]}