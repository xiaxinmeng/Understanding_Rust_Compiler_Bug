{"sha": "78cf8279acfb5c38229579af7d72ce3b9bfc511c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjZjgyNzlhY2ZiNWMzODIyOTU3OWFmN2Q3MmNlM2I5YmZjNTExYw==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@linux.org.pl", "date": "2000-06-24T18:01:26Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-06-24T18:01:26Z"}, "message": "avr-protos.h (avr_hard_regno_mode_ok): New prototype.\n\n\t* config/avr/avr-protos.h (avr_hard_regno_mode_ok): New prototype.\n\t* config/avr/avr.c (out_adj_frame_ptr, out_set_stack_ptr):\n\tNew functions, common code moved from function_{prologue,epilogue}\n\tand extended to support the -mtiny-stack option.\n\t(function_prologue, function_epilogue): Use them.\n\tUse lo8/hi8 consistently for asm output readability.\n\t(avr_hard_regno_mode_ok): New function.\n\t* config/avr/avr.h (TARGET_SWITCHES): Fix typo.  Add -mtiny-stack.\n\t(UNITS_PER_WORD): Define as 4 (not 1) when compiling libgcc2.c.\n\t(HARD_REGNO_MODE_OK): Call the avr_hard_regno_mode_ok function.\n\t* config/avr/avr.md (*mov_sp_r): Add support for -mtiny-stack.\n\tWrite SPH before SPL.\n\t(*movqi): No need to disable interrupts for just one \"out\"\n\tin alternative 5.  Change length attribute from 4 to 1.\n\t* config/avr/libgcc.S (__prologue_saves__, __epilogue_restores__):\n\tWrite SPH before SPL.\n\nFrom-SVN: r34678", "tree": {"sha": "5ac9b8f3997175b76bbf24be11bb1c4e821c878a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ac9b8f3997175b76bbf24be11bb1c4e821c878a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78cf8279acfb5c38229579af7d72ce3b9bfc511c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cf8279acfb5c38229579af7d72ce3b9bfc511c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78cf8279acfb5c38229579af7d72ce3b9bfc511c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cf8279acfb5c38229579af7d72ce3b9bfc511c/comments", "author": null, "committer": null, "parents": [{"sha": "f9f27ee563eb3741820d0fa91196900dd5621108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f27ee563eb3741820d0fa91196900dd5621108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f27ee563eb3741820d0fa91196900dd5621108"}], "stats": {"total": 297, "additions": 201, "deletions": 96}, "files": [{"sha": "7e39f84db4594e531bdd64fa47d666067aecfd42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -1,3 +1,22 @@\n+2000-06-24  Marek Michalkiewicz  <marekm@linux.org.pl>\n+\n+\t* config/avr/avr-protos.h (avr_hard_regno_mode_ok): New prototype.\n+\t* config/avr/avr.c (out_adj_frame_ptr, out_set_stack_ptr):\n+\tNew functions, common code moved from function_{prologue,epilogue}\n+\tand extended to support the -mtiny-stack option.\n+\t(function_prologue, function_epilogue): Use them.\n+\tUse lo8/hi8 consistently for asm output readability.\n+\t(avr_hard_regno_mode_ok): New function.\n+\t* config/avr/avr.h (TARGET_SWITCHES): Fix typo.  Add -mtiny-stack.\n+\t(UNITS_PER_WORD): Define as 4 (not 1) when compiling libgcc2.c.\n+\t(HARD_REGNO_MODE_OK): Call the avr_hard_regno_mode_ok function.\n+\t* config/avr/avr.md (*mov_sp_r): Add support for -mtiny-stack.\n+\tWrite SPH before SPL.\n+\t(*movqi): No need to disable interrupts for just one \"out\"\n+\tin alternative 5.  Change length attribute from 4 to 1.\n+\t* config/avr/libgcc.S (__prologue_saves__, __epilogue_restores__):\n+\tWrite SPH before SPL.\n+\n 2000-06-24  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* rtl.texi (Vector Operations): New node."}, {"sha": "4399dbaa6e7cc91c5768de40a2d381d7b3d93e56", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -138,6 +138,8 @@ extern int    byte_immediate_operand PARAMS ((register rtx op,\n extern int    test_hard_reg_class    PARAMS ((enum reg_class class, rtx x));\n extern int    jump_over_one_insn_p   PARAMS ((rtx insn, rtx dest));\n \n+extern int    avr_hard_regno_mode_ok PARAMS ((int regno,\n+\t\t\t\t\t     enum machine_mode mode));\n #endif /* RTX_CODE */\n \n #ifdef HAVE_MACHINE_MODES"}, {"sha": "4e58c723303055e2ef749bd5cbe00132c465c667", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 152, "deletions": 77, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -49,6 +49,8 @@ static int    signal_function_p    PARAMS ((tree));\n static int    sequent_regs_live    PARAMS ((void));\n static char * ptrreg_to_str        PARAMS ((int));\n static char * cond_string          PARAMS ((enum rtx_code));\n+static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n+static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n \n \n /* Allocate registers from r25 to r8 for parameters for function calls */\n@@ -332,6 +334,124 @@ sequent_regs_live ()\n }\n \n \n+/* Output to FILE the asm instructions to adjust the frame pointer by\n+   ADJ (r29:r28 -= ADJ;) which can be positive (prologue) or negative\n+   (epilogue).  Returns the number of instructions generated.  */\n+\n+static int\n+out_adj_frame_ptr (file, adj)\n+     FILE *file;\n+     int adj;\n+{\n+  int size = 0;\n+\n+  if (adj)\n+    {\n+      /* For -mtiny-stack, the high byte (r29) does not change -\n+\t prefer \"subi\" (1 cycle) over \"sbiw\" (2 cycles).  */\n+\n+      if (adj < -63 || adj > 63 || TARGET_TINY_STACK)\n+\t{\n+\t  fprintf (file, (AS2 (subi, r28, lo8(%d)) CR_TAB), adj);\n+\t  size++;\n+\n+\t  if (TARGET_TINY_STACK)\n+\t    {\n+\t      /* In addition to any local data, each level of function calls\n+\t\t needs at least 4 more bytes of stack space for the saved\n+\t\t frame pointer and return address.  So, (255 - 16) leaves\n+\t\t room for 4 levels of function calls.  */\n+\n+\t      if (adj < -(255 - 16) || adj > (255 - 16))\n+\t\tfatal (\"Frame pointer change (%d) too big for -mtiny-stack\",\n+\t\t       adj);\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (file, (AS2 (sbci, r29, hi8(%d)) CR_TAB), adj);\n+\t      size++;\n+\t    }\n+\t}\n+      else if (adj < 0)\n+\t{\n+\t  fprintf (file, (AS2 (adiw, r28, %d) CR_TAB), -adj);\n+\t  size++;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, (AS2 (sbiw, r28, %d) CR_TAB), adj);\n+\t  size++;\n+\t}\n+    }\n+  return size;\n+}\n+\n+\n+/* Output to FILE the asm instructions to copy r29:r28 to SPH:SPL,\n+   handling various cases of interrupt enable flag state BEFORE and AFTER\n+   (0=disabled, 1=enabled, -1=unknown/unchanged) and target_flags.\n+   Returns the number of instructions generated.  */\n+\n+static int\n+out_set_stack_ptr (file, before, after)\n+     FILE *file;\n+     int before;\n+     int after;\n+{\n+  int do_sph, do_cli, do_save, size;\n+\n+  if (TARGET_NO_INTERRUPTS)\n+    {\n+      before = 0;\n+      after = 0;\n+    }\n+\n+  do_sph = !TARGET_TINY_STACK;\n+  do_cli = (before != 0 && (after == 0 || do_sph));\n+  do_save = (before == -1 && after == -1 && do_cli);\n+  size = 1;\n+\n+  if (do_save)\n+    {\n+      fprintf (file, AS2 (in, __tmp_reg__, __SREG__) CR_TAB);\n+      size++;\n+    }\n+\n+  if (do_cli)\n+    {\n+      fprintf (file, \"cli\" CR_TAB);\n+      size++;\n+    }\n+\n+  /* Do SPH first - maybe this will disable interrupts for one instruction\n+     someday, much like x86 does when changing SS (a suggestion has been\n+     sent to avr@atmel.com for consideration in future devices).  */\n+  if (do_sph)\n+    {\n+      fprintf (file, AS2 (out, __SP_H__, r29) CR_TAB);\n+      size++;\n+    }\n+\n+  /* Set/restore the I flag now - interrupts will be really enabled only\n+     after the next instruction starts.  This was not clearly documented.\n+     XXX - verify this on the new devices with enhanced AVR core.  */\n+  if (do_save)\n+    {\n+      fprintf (file, AS2 (out, __SREG__, __tmp_reg__) CR_TAB);\n+      size++;\n+    }\n+  else if (after == 1 && (before != 1 || do_cli))\n+    {\n+      fprintf (file, \"sei\" CR_TAB);\n+      size++;\n+    }\n+\n+  fprintf (file, AS2 (out, __SP_L__, r28) \"\\n\");\n+\n+  return size;\n+}\n+\n+\n /* Output function prologue */\n \n void\n@@ -392,8 +512,8 @@ function_prologue (FILE *file, int size)\n   else if (minimize && (frame_pointer_needed || live_seq > 6)) \n     {\n       fprintf (file, (\"\\t\"\n-\t\t      AS2 (ldi, r26, %d) CR_TAB\n-\t\t      AS2 (ldi, r27, %d) CR_TAB), size & 0xff, size / 0x100);\n+\t\t      AS2 (ldi, r26, lo8(%d)) CR_TAB\n+\t\t      AS2 (ldi, r27, hi8(%d)) CR_TAB), size, size);\n \n       fprintf (file, (AS2 (ldi, r30, pm_lo8(.L_%s_body)) CR_TAB\n \t\t      AS2 (ldi, r31, pm_hi8(.L_%s_body)) CR_TAB)\n@@ -444,44 +564,20 @@ function_prologue (FILE *file, int size)\n \t    prologue_size += 4;\n \t    if (size)\n \t      {\n-\t\tif (size > 63)\n-\t\t  {\n-\t\t    fprintf (file, (\"\\t\"\n-\t\t\t\t    AS2 (subi,r28,%d) CR_TAB\n-\t\t\t\t    AS2 (sbci,r29,%d) CR_TAB)\n-\t\t\t     , size & 0xff, size / 0x100);\n-\t\t    prologue_size += 2;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    fprintf (file, \"\\t\" AS2 (sbiw,r28,%d) CR_TAB, size);\n-\t\t    ++prologue_size;\n-\t\t  }\n+\t\tfputs (\"\\t\", file);\n+\t\tprologue_size += out_adj_frame_ptr (file, size);\n+\n \t\tif (interrupt_func_p)\n \t\t  {\n-\t\t    fprintf (file,\n-\t\t\t     \"cli\" CR_TAB\n-\t\t\t     AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t     \"sei\" CR_TAB\n-\t\t\t     AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t    prologue_size += 4;\n+\t\t    prologue_size += out_set_stack_ptr (file, -1, 1);\n \t\t  }\n-\t\telse if (signal_func_p || TARGET_NO_INTERRUPTS)\n+\t\telse if (signal_func_p)\n \t\t  {\n-\t\t    fprintf (file,\n-\t\t\t     AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t     AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t    prologue_size += 2;\n+\t\t    prologue_size += out_set_stack_ptr (file, 0, 0);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    fprintf (file,\n-\t\t\t     AS2 (in,__tmp_reg__,__SREG__) CR_TAB\n-\t\t\t     \"cli\" CR_TAB\n-\t\t\t     AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t     AS2 (out,__SREG__,__tmp_reg__) CR_TAB\n-\t\t\t     AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t    prologue_size += 5;\n+\t\t    prologue_size += out_set_stack_ptr (file, -1, -1);\n \t\t  }\n \t      }\n \t  }\n@@ -533,20 +629,7 @@ function_epilogue (FILE *file, int size)\n       ++epilogue_size;\n       if (frame_pointer_needed)\n \t{\n-\t  if (size)\n-\t    {\n-\t      if (size > 63)\n-\t\t{\n-\t\t  fprintf (file, AS2 (subi,r28,lo8(-%d)) CR_TAB, size);\n-\t\t  fprintf (file, AS2 (sbci,r29,hi8(-%d)) CR_TAB, size);\n-\t\t  epilogue_size += 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, AS2 (adiw,r28,%d) CR_TAB, size);\n-\t\t  ++epilogue_size;\n-\t\t}\n-\t    }\n+\t  epilogue_size += out_adj_frame_ptr (file, -size);\n \t}\n       else\n \t{\n@@ -574,41 +657,16 @@ function_epilogue (FILE *file, int size)\n \t{\n \t  if (size)\n \t    {\n-\t      if (size > 63)\n-\t\t{\n-\t\t  fprintf (file, \"\\t\" AS2 (subi,r28,lo8(-%d)) CR_TAB, size);\n-\t\t  fprintf (file, AS2 (sbci,r29,hi8(-%d)) CR_TAB, size);\n-\t\t  epilogue_size += 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, \"\\t\" AS2 (adiw,r28,%d) CR_TAB, size);\n-\t\t  ++epilogue_size;\n-\t\t}\n+\t      fputs (\"\\t\", file);\n+\t      epilogue_size += out_adj_frame_ptr (file, -size);\n+\n \t      if (interrupt_func_p | signal_func_p)\n \t\t{\n-\t\t  fprintf (file,\n-\t\t\t   \"cli\" CR_TAB\n-\t\t\t   AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t   AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t  epilogue_size += 3;\n-\t\t}\n-\t      else if (TARGET_NO_INTERRUPTS)\n-\t\t{\n-\t\t  fprintf (file,\n-\t\t\t   AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t   AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t  epilogue_size += 2;\n+\t\t  epilogue_size += out_set_stack_ptr (file, -1, 0);\n \t\t}\n \t      else\n \t\t{\n-\t\t  fprintf (file,\n-\t\t\t   AS2 (in,__tmp_reg__,__SREG__) CR_TAB\n-\t\t\t   \"cli\" CR_TAB\n-\t\t\t   AS2 (out,__SP_L__,r28) CR_TAB\n-\t\t\t   AS2 (out,__SREG__,__tmp_reg__) CR_TAB\n-\t\t\t   AS2 (out,__SP_H__,r29) \"\\n\");\n-\t\t  epilogue_size += 5;\n+\t\t  epilogue_size += out_set_stack_ptr (file, -1, -1);\n \t\t}\n \t    }\n \t  fprintf (file, \"\\t\"\n@@ -3886,3 +3944,20 @@ jump_over_one_insn_p (insn, dest)\n   int dest_addr = insn_addresses[uid];\n   return dest_addr - jump_addr == 2;\n }\n+\n+/* Returns 1 if a value of mode MODE can be stored starting with hard\n+   register number REGNO.  On the enhanced core, it should be a win to\n+   align modes larger than QI on even register numbers (even if < 24).\n+   so that the \"movw\" instruction can be used on them.  */\n+\n+int\n+avr_hard_regno_mode_ok (regno, mode)\n+     int regno;\n+     enum machine_mode mode;\n+{\n+  if (mode == QImode)\n+    return 1;\n+  if (regno < 24 /* && !TARGET_ENHANCED */ )\n+    return 1;\n+  return !(regno & 1);\n+}"}, {"sha": "0096629e5a71719bcbf84f14d58259f2d4095376", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -52,6 +52,7 @@ extern int target_flags;\n #define TARGET_NO_INTERRUPTS\t(target_flags & 0x20000)\n #define TARGET_INSN_SIZE_DUMP\t(target_flags &  0x2000)\n #define TARGET_CALL_PROLOGUES\t(target_flags & 0x40000)\n+#define TARGET_TINY_STACK\t(target_flags & 0x80000)\n \n /* Dump each assembler insn's rtl into the output file.\n    This is for debugging the compiler itself.  */\n@@ -87,7 +88,8 @@ extern int target_flags;\n   {\"int8\",0x10000,\"Assume int to be 8 bit integer\"},\t\t\t\\\n   {\"no-interrupts\",0x20000,\"Don't output interrupt compatible code\"},\t\\\n   {\"call-prologues\",0x40000,\t\t\t\t\t\t\\\n-   \"Use subroutines for functions prologeu/epilogue\"},\t\t\t\\\n+   \"Use subroutines for functions prologue/epilogue\"},\t\t\t\\\n+  {\"tiny-stack\", 0x80000, \"Change only low 8 bits of stack pointer\"},\t\\\n   {\"rtl\",0x10, NULL},\t\t\t\t\t\t\t\\\n   {\"size\",0x2000,\"Output instruction size's to the asm file\"},\t\t\\\n   {\"deb\",0xfe0, NULL},\t\t\t\t\t\t\t\\\n@@ -194,8 +196,13 @@ extern struct mcu_type_s *avr_mcu_type;\n    Note that this is not necessarily the width of data type `int';  */\n #define BITS_PER_WORD 8\n \n+#ifdef IN_LIBGCC2\n+/* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n+#define UNITS_PER_WORD 4\n+#else\n /* Width of a word, in units (bytes). */\n #define UNITS_PER_WORD 1\n+#endif\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n@@ -452,9 +459,7 @@ extern struct mcu_type_s *avr_mcu_type;\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n    / UNITS_PER_WORD))  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) (((REGNO) >= 24 && (MODE) != QImode) \\\n-\t\t\t\t\t ? ! ((REGNO) & 1)\t\t     \\\n-\t\t\t\t\t : 1)\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) avr_hard_regno_mode_ok(REGNO, MODE)\n /* A C expression that is nonzero if it is permissible to store a\n    value of mode MODE in hard register number REGNO (or in several\n    registers starting with that one).  For a machine where all"}, {"sha": "4d2451e763f8ca613bc50bdbfffe45a6dea18528", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -147,22 +147,29 @@\n (define_insn \"*mov_sp_r\"\n   [(set (reg:HI 32)\n         (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"!TARGET_NO_INTERRUPTS\"\n+  \"(!TARGET_TINY_STACK && !TARGET_NO_INTERRUPTS)\"\n   \"in __tmp_reg__,__SREG__\n \tcli\n-\tout __SP_L__,%A0\n+\tout __SP_H__,%B0\n \tout __SREG__,__tmp_reg__\n-\tout __SP_H__,%B0\"\n+\tout __SP_L__,%A0\"\n   [(set_attr \"length\" \"5\")])\n \n (define_insn \"*mov_sp_r_no_interrupts\"\n   [(set (reg:HI 32)\n         (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"TARGET_NO_INTERRUPTS\"\n-  \"out __SP_L__,%A0\n-\tout __SP_H__,%B0\"\n+  \"(!TARGET_TINY_STACK && TARGET_NO_INTERRUPTS)\"\n+  \"out __SP_H__,%B0\n+\tout __SP_L__,%A0\"\n   [(set_attr \"length\" \"2\")])\n \n+(define_insn \"*mov_sp_r_tiny\"\n+  [(set (reg:HI 32)\n+        (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"TARGET_TINY_STACK\"\n+  \"out __SP_L__,%A0\"\n+  [(set_attr \"length\" \"1\")])\n+\n ;;========================================================================\n ;; move byte\n (define_expand \"movqi\"\n@@ -209,13 +216,10 @@\n       case 4:\n         return out_movqi_r_mr (insn,operands,NULL);\n       case 5:\n-        return (AS2 (in,__tmp_reg__,__SREG__) CR_TAB\n-\t        \\\"cli\\\"                       CR_TAB\n-\t        AS2 (out,__SREG__,__tmp_reg__)CR_TAB\n-\t        AS2 (out,%0,%1));\n+        return (AS2 (out,%0,%1));\n       }\n }\"\n-  [(set_attr \"length\" \"1,1,1,5,5,4\")\n+  [(set_attr \"length\" \"1,1,1,5,5,1\")\n    (set_attr \"cc\" \"none,clobber,none,clobber,clobber,none\")])\n \n ;;============================================================================"}, {"sha": "00aa50b09ace6ae5a72dd1a27b9652626c6c1372", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cf8279acfb5c38229579af7d72ce3b9bfc511c/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=78cf8279acfb5c38229579af7d72ce3b9bfc511c", "patch": "@@ -583,9 +583,9 @@ __prologue_saves__:\n \tsbc\tr29,r27\n \tin\t__tmp_reg__,__SREG__\n \tcli\n-\tout\t__SP_L__,r28\n-\tout\t__SREG__,__tmp_reg__\n \tout\t__SP_H__,r29\n+\tout\t__SREG__,__tmp_reg__\n+\tout\t__SP_L__,r28\n _prologue_end:\n \tijmp\n .endfunc\n@@ -621,9 +621,9 @@ __epilogue_restores__:\n \tadc\tr29,__zero_reg__\n \tin\t__tmp_reg__,__SREG__\n \tcli\n-\tout\t__SP_L__,r28\n-\tout\t__SREG__,__tmp_reg__\n \tout\t__SP_H__,r29\n+\tout\t__SREG__,__tmp_reg__\n+\tout\t__SP_L__,r28\n \tmov\tr28,r26\n \tmov\tr29,r27\n \tret"}]}