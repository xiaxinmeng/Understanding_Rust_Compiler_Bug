{"sha": "f4d379b8df138d05368dded1c6368ef549d65088", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRkMzc5YjhkZjEzOGQwNTM2OGRkZWQxYzYzNjhlZjU0OWQ2NTA4OA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2005-11-15T13:54:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:54:36Z"}, "message": "rtsfind.ads, [...]: Complete support for Ada 2005 interfaces.\n\n2005-11-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* rtsfind.ads, exp_util.adb, exp_util.ads, exp_disp.adb, exp_disp.ads,\n\texp_ch7.adb, sem_ch9.adb, snames.adb, snames.ads,\n\texp_ch9.adb, exp_ch9.ads, exp_ch6.adb, exp_ch3.adb, exp_ch3.ads,\n\teinfo.ads, einfo.adb: Complete support for Ada 2005 interfaces.\n\n\t* a-tags.ads, a-tags.adb: Major rewrite and additions to implement\n\tproperly new Ada 2005 interfaces (AI-345) and add run-time checks (via\n\tassertions).\n\n\t* exp_dbug.ads, exp_dbug.adb (Get_Secondary_DT_External_Name): New\n\tsubprogram that generates the external name associated with a\n\tsecondary dispatch table.\n\t(Get_Secondary_DT_External_Name): New subprogram that generates the\n\texternal name associated with a secondary dispatch table.\n\nFrom-SVN: r106965", "tree": {"sha": "873996443f0c7e7119eead6a25a380b1d3b5441a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/873996443f0c7e7119eead6a25a380b1d3b5441a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4d379b8df138d05368dded1c6368ef549d65088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d379b8df138d05368dded1c6368ef549d65088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4d379b8df138d05368dded1c6368ef549d65088", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4d379b8df138d05368dded1c6368ef549d65088/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "748d8778ede2249ee70323886d36fcdd5c08248d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748d8778ede2249ee70323886d36fcdd5c08248d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748d8778ede2249ee70323886d36fcdd5c08248d"}], "stats": {"total": 8958, "additions": 5509, "deletions": 3449}, "files": [{"sha": "8c9312e205ca814d3a0f071340b002ef27045deb", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 460, "deletions": 96, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,43 +39,64 @@ pragma Elaborate_All (System.HTable);\n \n package body Ada.Tags is\n \n---  Structure of the GNAT Dispatch Table\n+--  Structure of the GNAT Primary Dispatch Table\n \n+--           +-----------------------+\n+--           |       Signature       |\n --           +-----------------------+\n --           |     Offset_To_Top     |\n --           +-----------------------+\n---           | Typeinfo_Ptr/TSD_Ptr  |----> Type Specific Data\n+--           | Typeinfo_Ptr/TSD_Ptr  | ---> Type Specific Data\n --  Tag ---> +-----------------------+      +-------------------+\n --           |        table of       |      | inheritance depth |\n --           :     primitive ops     :      +-------------------+\n---           |        pointers       |      |   expanded name   |\n+--           |        pointers       |      |   access level    |\n --           +-----------------------+      +-------------------+\n---                                          |   external tag    |\n---                                          +-------------------+\n---                                          |   Hash table link |\n+--                                          |   expanded name   |\n --                                          +-------------------+\n---                                          | Remotely Callable |\n---                                          +-------------------+\n---                                          | Rec Ctrler offset |\n+--                                          |   external tag    |\n --                                          +-------------------+\n---                                          |  Num_Interfaces   |\n+--                                          |   hash table link |\n --                                          +-------------------+\n---                                          | table of          |\n---                                          :   ancestor        :\n---                                          |      tags         |\n+--                                          | remotely callable |\n --                                          +-------------------+\n---                                          | table of          |\n---                                          :   interface       :\n---                                          |      tags         |\n+--                                          | rec ctrler offset |\n --                                          +-------------------+\n---                                          | table of          |\n---                                          :   primitive op    :\n---                                          |     kinds         |\n+--                                          |   num prim ops    |\n --                                          +-------------------+\n---                                          | table of          |\n---                                          :   entry           :\n---                                          |     indices       |\n+--                                          |  num interfaces   |\n --                                          +-------------------+\n+--           Select Specific Data      <--- |     SSD_Ptr       |\n+--           +-----------------------+      +-------------------+\n+--           | table of primitive    |      | table of          |\n+--           :    operation          :      :    ancestor       :\n+--           |       kinds           |      |       tags        |\n+--           +-----------------------+      +-------------------+\n+--           | table of              |      | table of          |\n+--           :    entry              :      :    interface      :\n+--           |       indices         |      |       tags        |\n+--           +-----------------------+      +-------------------+\n+\n+--  Structure of the GNAT Secondary Dispatch Table\n+\n+--           +-----------------------+\n+--           |       Signature       |\n+--           +-----------------------+\n+--           |     Offset_To_Top     |\n+--           +-----------------------+\n+--           |        OSD_Ptr        |---> Object Specific Data\n+--  Tag ---> +-----------------------+      +---------------+\n+--           |        table of       |      | num prim ops  |\n+--           :      primitive op     :      +---------------+\n+--           |     thunk pointers    |      | table of      |\n+--           +-----------------------+      +   primitive   |\n+--                                          |    op offsets |\n+--                                          +---------------+\n+\n+   Offset_To_Signature : constant SSE.Storage_Count :=\n+                           DT_Typeinfo_Ptr_Size\n+                             + DT_Offset_To_Top_Size\n+                             + DT_Signature_Size;\n \n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n@@ -87,13 +108,39 @@ package body Ada.Tags is\n    pragma Suppress_Initialization (Tag_Table);\n    pragma Suppress (Index_Check, On => Tag_Table);\n \n-   type Prim_Op_Kind_Table is array (Natural range <>) of Prim_Op_Kind;\n-   pragma Suppress_Initialization (Prim_Op_Kind_Table);\n-   pragma Suppress (Index_Check, On => Prim_Op_Kind_Table);\n+   --  Object specific data types\n+\n+   type Object_Specific_Data_Array is array (Positive range <>) of Positive;\n+\n+   type Object_Specific_Data (Nb_Prim : Positive) is record\n+      Num_Prim_Ops : Natural;\n+      --  Number of primitive operations of the dispatch table. This field is\n+      --  used by the run-time check routines that are activated when the\n+      --  run-time is compiled with assertions enabled.\n+\n+      OSD_Table : Object_Specific_Data_Array (1 .. Nb_Prim);\n+      --  Table used in secondary DT to reference their counterpart in the\n+      --  select specific data (in the TSD of the primary DT). This construct\n+      --  is used in the handling of dispatching triggers in select statements.\n+      --  Nb_Prim is the number of non-predefined primitive operations.\n+   end record;\n+\n+   --  Select specific data types\n+\n+   type Select_Specific_Data_Element is record\n+      Index : Positive;\n+      Kind  : Prim_Op_Kind;\n+   end record;\n+\n+   type Select_Specific_Data_Array is\n+     array (Positive range <>) of Select_Specific_Data_Element;\n+\n+   type Select_Specific_Data (Nb_Prim : Positive) is record\n+      SSD_Table : Select_Specific_Data_Array (1 .. Nb_Prim);\n+      --  NOTE: Nb_Prim is the number of non-predefined primitive operations\n+   end record;\n \n-   type Entry_Index_Table is array (Natural range <>) of Positive;\n-   pragma Suppress_Initialization (Entry_Index_Table);\n-   pragma Suppress (Index_Check, On => Entry_Index_Table);\n+   --  Type specific data types\n \n    type Type_Specific_Data is record\n       Idepth : Natural;\n@@ -124,11 +171,22 @@ package body Ada.Tags is\n       --  Controller Offset: Used to give support to tagged controlled objects\n       --  (see Get_Deep_Controller at s-finimp)\n \n+      Num_Prim_Ops : Natural;\n+      --  Number of primitive operations of the dispatch table. This field is\n+      --  used for additional run-time checks when the run-time is compiled\n+      --  with assertions enabled.\n+\n       Num_Interfaces : Natural;\n       --  Number of abstract interface types implemented by the tagged type.\n       --  The value Idepth+Num_Interfaces indicates the end of the second table\n       --  stored in the Tags_Table component. It is used to implement the\n-      --  membership test associated with interfaces (Ada 2005:AI-251)\n+      --  membership test associated with interfaces (Ada 2005:AI-251).\n+\n+      SSD_Ptr : System.Address;\n+      --  Pointer to a table of records used in dispatching selects. This\n+      --  field has a meaningful value for all tagged types that implement\n+      --  a limited, protected, synchronized or task interfaces and have\n+      --  non-predefined primitive operations.\n \n       Tags_Table : Tag_Table (0 .. 1);\n       --  The size of the Tags_Table array actually depends on the tagged type\n@@ -138,21 +196,9 @@ package body Ada.Tags is\n       --  purpose we are using the same mechanism as for the Prims_Ptr array in\n       --  the Dispatch_Table record. See comments below on Prims_Ptr for\n       --  further details.\n-\n-      POK_Table       : Prim_Op_Kind_Table (1 .. 1);\n-      Ent_Index_Table : Entry_Index_Table  (1 .. 1);\n-      --  Two auxiliary tables used for dispatching in asynchronous,\n-      --  conditional and timed selects. Their size depends on the number\n-      --  of primitive operations. Indexing in these two tables is performed\n-      --  by subtracting the number of predefined primitive operations from\n-      --  the given index value. POK_Table contains the callable entity kinds\n-      --  of all non-predefined primitive operations. Ent_Index_Table contains\n-      --  the entry index of primitive entry wrappers.\n    end record;\n \n    type Dispatch_Table is record\n-      --  Offset_To_Top : Natural;\n-      --  Typeinfo_Ptr  : System.Address;\n \n       --  According to the C++ ABI the components Offset_To_Top and\n       --  Typeinfo_Ptr are stored just \"before\" the dispatch table (that is,\n@@ -164,6 +210,9 @@ package body Ada.Tags is\n       --  enough space for these additional components, and generates code that\n       --  displaces the _Tag to point after these components.\n \n+      --  Offset_To_Top : Natural;\n+      --  Typeinfo_Ptr  : System.Address;\n+\n       Prims_Ptr : Address_Array (1 .. 1);\n       --  The size of the Prims_Ptr array actually depends on the tagged type\n       --  to which it applies. For each tagged type, the expander computes the\n@@ -185,6 +234,20 @@ package body Ada.Tags is\n       --  only to declare the corresponding access type.\n    end record;\n \n+   --  Run-time check types and subprograms: These subprograms are used only\n+   --  when the run-time is compiled with assertions enabled.\n+\n+   type Signature_Type is\n+      (Must_Be_Primary_DT,\n+       Must_Be_Secondary_DT,\n+       Must_Be_Primary_Or_Secondary_DT,\n+       Must_Be_Interface,\n+       Must_Be_Primary_Or_Interface);\n+   --  Type of signature accepted by primitives in this package that are called\n+   --  during the elaboration of tagged types. This type is used by the routine\n+   --  Check_Signature that is called only when the run-time is compiled with\n+   --  assertions enabled.\n+\n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------\n@@ -199,6 +262,12 @@ package body Ada.Tags is\n    -- Unchecked Conversions for other components --\n    ------------------------------------------------\n \n+   type Acc_Size\n+     is access function (A : System.Address) return Long_Long_Integer;\n+\n+   function To_Acc_Size is new Unchecked_Conversion (System.Address, Acc_Size);\n+   --  The profile of the implicitly defined _size primitive\n+\n    type Storage_Offset_Ptr is access System.Storage_Elements.Storage_Offset;\n \n    function To_Storage_Offset_Ptr is\n@@ -208,6 +277,30 @@ package body Ada.Tags is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Check_Index\n+     (T     : Tag;\n+      Index : Natural) return Boolean;\n+   --  Check that Index references a valid entry of the dispatch table of T\n+\n+   function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean;\n+   --  Check that the signature of T is valid and corresponds with the subset\n+   --  specified by the signature Kind.\n+\n+   function Check_Size\n+     (Old_T       : Tag;\n+      New_T       : Tag;\n+      Entry_Count : Natural) return Boolean;\n+   --  Verify that Old_T and New_T have at least Entry_Count entries\n+\n+   function Get_Num_Prim_Ops (T : Tag) return Natural;\n+   --  Retrieve the number of primitive operations in the dispatch table of T\n+\n+   function Is_Primary_DT (T : Tag) return Boolean;\n+   pragma Inline_Always (Is_Primary_DT);\n+   --  Given a tag returns True if it has the signature of a primary dispatch\n+   --  table.  This is Inline_Always since it is called from other Inline_\n+   --  Always subprograms where we want no out of line code to be generated.\n+\n    function Length (Str : Cstring_Ptr) return Natural;\n    --  Length of string represented by the given pointer (treating the string\n    --  as a C-style string, which is Nul terminated).\n@@ -261,9 +354,9 @@ package body Ada.Tags is\n \n    package body HTable_Subprograms is\n \n-   -----------\n-   -- Equal --\n-   -----------\n+      -----------\n+      -- Equal --\n+      -----------\n \n       function Equal (A, B : System.Address) return Boolean is\n          Str1 : constant Cstring_Ptr := To_Cstring_Ptr (A);\n@@ -313,6 +406,93 @@ package body Ada.Tags is\n \n    end HTable_Subprograms;\n \n+   -----------------\n+   -- Check_Index --\n+   -----------------\n+\n+   function Check_Index\n+     (T     : Tag;\n+      Index : Natural) return Boolean\n+   is\n+      Max_Entries : constant Natural := Get_Num_Prim_Ops (T);\n+\n+   begin\n+      return Index /= 0 and then Index <= Max_Entries;\n+   end Check_Index;\n+\n+   ---------------------\n+   -- Check_Signature --\n+   ---------------------\n+\n+   function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean is\n+      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n+                            To_Storage_Offset_Ptr (To_Address (T)\n+                              - Offset_To_Signature);\n+\n+      Signature : constant Signature_Values :=\n+                    To_Signature_Values (Offset_To_Top_Ptr.all);\n+\n+      Signature_Id : Signature_Kind;\n+\n+   begin\n+      if Signature (1) /= Valid_Signature then\n+         Signature_Id := Unknown;\n+\n+      elsif Signature (2) in Primary_DT .. Abstract_Interface then\n+         Signature_Id := Signature (2);\n+\n+      else\n+         Signature_Id := Unknown;\n+      end if;\n+\n+      case Signature_Id is\n+         when Primary_DT         =>\n+            if Kind = Must_Be_Secondary_DT\n+              or else Kind = Must_Be_Interface\n+            then\n+               return False;\n+            end if;\n+\n+         when Secondary_DT       =>\n+            if Kind = Must_Be_Primary_DT\n+              or else Kind = Must_Be_Interface\n+            then\n+               return False;\n+            end if;\n+\n+         when Abstract_Interface =>\n+            if Kind = Must_Be_Primary_DT\n+              or else Kind = Must_Be_Secondary_DT\n+              or else Kind = Must_Be_Primary_Or_Secondary_DT\n+            then\n+               return False;\n+            end if;\n+\n+         when others =>\n+            return False;\n+\n+      end case;\n+\n+      return True;\n+   end Check_Signature;\n+\n+   ----------------\n+   -- Check_Size --\n+   ----------------\n+\n+   function Check_Size\n+     (Old_T       : Tag;\n+      New_T       : Tag;\n+      Entry_Count : Natural) return Boolean\n+   is\n+      Max_Entries_Old : constant Natural := Get_Num_Prim_Ops (Old_T);\n+      Max_Entries_New : constant Natural := Get_Num_Prim_Ops (New_T);\n+\n+   begin\n+      return Entry_Count <= Max_Entries_Old\n+        and then Entry_Count <= Max_Entries_New;\n+   end Check_Size;\n+\n    -------------------\n    -- CW_Membership --\n    -------------------\n@@ -334,8 +514,11 @@ package body Ada.Tags is\n    --     = Typ'tag\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean is\n-      Pos : constant Integer := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n+      Pos : Integer;\n    begin\n+      pragma Assert (Check_Signature (Obj_Tag, Must_Be_Primary_DT));\n+      pragma Assert (Check_Signature (Typ_Tag, Must_Be_Primary_DT));\n+      Pos := TSD (Obj_Tag).Idepth - TSD (Typ_Tag).Idepth;\n       return Pos >= 0 and then TSD (Obj_Tag).Tags_Table (Pos) = Typ_Tag;\n    end CW_Membership;\n \n@@ -353,23 +536,34 @@ package body Ada.Tags is\n    --  Obj is in Iface'Class if Iface'Tag is found in the table of interfaces\n    --  that are contained in the dispatch table referenced by Obj'Tag.\n \n-   function IW_Membership\n-     (This : System.Address;\n-      T    : Tag) return Boolean\n-   is\n+   function IW_Membership (This : System.Address; T : Tag) return Boolean is\n       Curr_DT  : constant Tag := To_Tag_Ptr (This).all;\n-      Obj_Base : constant System.Address := This - Offset_To_Top (Curr_DT);\n-      Obj_DT   : constant Tag := To_Tag_Ptr (Obj_Base).all;\n-\n-      Obj_TSD : constant Type_Specific_Data_Ptr := TSD (Obj_DT);\n-      Last_Id : constant Natural := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n-      Id      : Natural;\n+      Id       : Natural;\n+      Last_Id  : Natural;\n+      Obj_Base : System.Address;\n+      Obj_DT   : Tag;\n+      Obj_TSD  : Type_Specific_Data_Ptr;\n \n    begin\n+      pragma Assert\n+        (Check_Signature (Curr_DT, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert\n+        (Check_Signature (T, Must_Be_Primary_Or_Interface));\n+\n+      Obj_Base := This - Offset_To_Top (Curr_DT);\n+      Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n+\n+      pragma Assert\n+        (Check_Signature (Curr_DT, Must_Be_Primary_DT));\n+\n+      Obj_TSD := TSD (Obj_DT);\n+      Last_Id := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n+\n       if Obj_TSD.Num_Interfaces > 0 then\n \n          --  Traverse the ancestor tags table plus the interface tags table.\n-         --  The former part is required to give support to:\n+         --  The former part is required for:\n+\n          --     Iface_CW in Typ'Class\n \n          Id := 0;\n@@ -391,9 +585,13 @@ package body Ada.Tags is\n    --------------------\n \n    function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n-      Int_Tag : constant Tag := Internal_Tag (External);\n+      Int_Tag : Tag;\n \n    begin\n+      pragma Assert (Check_Signature (Ancestor, Must_Be_Primary_DT));\n+      Int_Tag := Internal_Tag (External);\n+      pragma Assert (Check_Signature (Int_Tag, Must_Be_Primary_DT));\n+\n       if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n          raise Tag_Error;\n       end if;\n@@ -413,6 +611,7 @@ package body Ada.Tags is\n          raise Tag_Error;\n       end if;\n \n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       Result := TSD (T).Expanded_Name;\n       return Result (1 .. Length (Result));\n    end Expanded_Name;\n@@ -423,11 +622,13 @@ package body Ada.Tags is\n \n    function External_Tag (T : Tag) return String is\n       Result : Cstring_Ptr;\n+\n    begin\n       if T = No_Tag then\n          raise Tag_Error;\n       end if;\n \n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       Result := TSD (T).External_Tag;\n \n       return Result (1 .. Length (Result));\n@@ -439,18 +640,20 @@ package body Ada.Tags is\n \n    function Get_Access_Level (T : Tag) return Natural is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return TSD (T).Access_Level;\n    end Get_Access_Level;\n \n    ---------------------\n    -- Get_Entry_Index --\n    ---------------------\n \n-   function Get_Entry_Index\n-     (T        : Tag;\n-      Position : Positive) return Positive is\n+   function Get_Entry_Index (T : Tag; Position : Positive) return Positive is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n-      return TSD (T).Ent_Index_Table (Position - Default_Prim_Op_Count);\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Index > 0);\n+      return SSD (T).SSD_Table (Index).Index;\n    end Get_Entry_Index;\n \n    ----------------------\n@@ -459,17 +662,36 @@ package body Ada.Tags is\n \n    function Get_External_Tag (T : Tag) return System.Address is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return To_Address (TSD (T).External_Tag);\n    end Get_External_Tag;\n \n+   ----------------------\n+   -- Get_Num_Prim_Ops --\n+   ----------------------\n+\n+   function Get_Num_Prim_Ops (T : Tag) return Natural is\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+\n+      if Is_Primary_DT (T) then\n+         return TSD (T).Num_Prim_Ops;\n+      else\n+         return OSD (Interface_Tag (T)).Num_Prim_Ops;\n+      end if;\n+   end Get_Num_Prim_Ops;\n+\n    -------------------------\n    -- Get_Prim_Op_Address --\n    -------------------------\n \n    function Get_Prim_Op_Address\n      (T        : Tag;\n-      Position : Positive) return System.Address is\n+      Position : Positive) return System.Address\n+   is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       return T.Prims_Ptr (Position);\n    end Get_Prim_Op_Address;\n \n@@ -479,17 +701,37 @@ package body Ada.Tags is\n \n    function Get_Prim_Op_Kind\n      (T        : Tag;\n-      Position : Positive) return Prim_Op_Kind is\n+      Position : Positive) return Prim_Op_Kind\n+   is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n-      return TSD (T).POK_Table (Position - Default_Prim_Op_Count);\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Index > 0);\n+      return SSD (T).SSD_Table (Index).Kind;\n    end Get_Prim_Op_Kind;\n \n+   ----------------------\n+   -- Get_Offset_Index --\n+   ----------------------\n+\n+   function Get_Offset_Index\n+     (T        : Interface_Tag;\n+      Position : Positive) return Positive\n+   is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n+   begin\n+      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n+      pragma Assert (Index > 0);\n+      return OSD (T).OSD_Table (Index);\n+   end Get_Offset_Index;\n+\n    -------------------\n    -- Get_RC_Offset --\n    -------------------\n \n    function Get_RC_Offset (T : Tag) return SSE.Storage_Offset is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return TSD (T).RC_Offset;\n    end Get_RC_Offset;\n \n@@ -499,19 +741,20 @@ package body Ada.Tags is\n \n    function Get_Remotely_Callable (T : Tag) return Boolean is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return TSD (T).Remotely_Callable;\n    end Get_Remotely_Callable;\n \n    ----------------\n    -- Inherit_DT --\n    ----------------\n \n-   procedure Inherit_DT\n-    (Old_T       : Tag;\n-     New_T       : Tag;\n-     Entry_Count : Natural)\n-   is\n+   procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural) is\n    begin\n+      pragma Assert (Check_Signature (Old_T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Check_Signature (New_T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Check_Size (Old_T, New_T, Entry_Count));\n+\n       if Old_T /= null then\n          New_T.Prims_Ptr (1 .. Entry_Count) :=\n            Old_T.Prims_Ptr (1 .. Entry_Count);\n@@ -523,17 +766,22 @@ package body Ada.Tags is\n    -----------------\n \n    procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag) is\n-      New_TSD_Ptr : constant Type_Specific_Data_Ptr := TSD (New_Tag);\n+      New_TSD_Ptr : Type_Specific_Data_Ptr;\n       Old_TSD_Ptr : Type_Specific_Data_Ptr;\n \n    begin\n+      pragma Assert (Check_Signature (New_Tag, Must_Be_Primary_Or_Interface));\n+      New_TSD_Ptr := TSD (New_Tag);\n+\n       if Old_Tag /= null then\n+         pragma Assert\n+           (Check_Signature (Old_Tag, Must_Be_Primary_Or_Interface));\n          Old_TSD_Ptr := TSD (Old_Tag);\n          New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n          New_TSD_Ptr.Num_Interfaces := Old_TSD_Ptr.Num_Interfaces;\n \n          --  Copy the \"table of ancestor tags\" plus the \"table of interfaces\"\n-         --  of the parent\n+         --  of the parent.\n \n          New_TSD_Ptr.Tags_Table\n            (1 .. New_TSD_Ptr.Idepth + New_TSD_Ptr.Num_Interfaces) :=\n@@ -557,7 +805,7 @@ package body Ada.Tags is\n \n    begin\n       --  Make a copy of the string representing the external tag with\n-      --  a null at the end\n+      --  a null at the end.\n \n       Ext_Copy (External'Range) := External;\n       Ext_Copy (Ext_Copy'Last) := ASCII.NUL;\n@@ -567,6 +815,7 @@ package body Ada.Tags is\n          declare\n             Msg1 : constant String := \"unknown tagged type: \";\n             Msg2 : String (1 .. Msg1'Length + External'Length);\n+\n          begin\n             Msg2 (1 .. Msg1'Length) := Msg1;\n             Msg2 (Msg1'Length + 1 .. Msg1'Length + External'Length) :=\n@@ -591,6 +840,20 @@ package body Ada.Tags is\n         and then TSD (Descendant).Access_Level = TSD (Ancestor).Access_Level;\n    end Is_Descendant_At_Same_Level;\n \n+   -------------------\n+   -- Is_Primary_DT --\n+   -------------------\n+\n+   function Is_Primary_DT (T : Tag) return Boolean is\n+      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n+                            To_Storage_Offset_Ptr (To_Address (T)\n+                              - Offset_To_Signature);\n+      Signature         : constant Signature_Values :=\n+                            To_Signature_Values (Offset_To_Top_Ptr.all);\n+   begin\n+      return Signature (2) = Primary_DT;\n+   end Is_Primary_DT;\n+\n    ------------\n    -- Length --\n    ------------\n@@ -617,32 +880,45 @@ package body Ada.Tags is\n                             To_Storage_Offset_Ptr (To_Address (T)\n                               - DT_Typeinfo_Ptr_Size\n                               - DT_Offset_To_Top_Size);\n+\n    begin\n       return Offset_To_Top_Ptr.all;\n    end Offset_To_Top;\n \n+   ---------\n+   -- OSD --\n+   ---------\n+\n+   function OSD\n+     (T : Interface_Tag) return Object_Specific_Data_Ptr\n+   is\n+      OSD_Ptr : Addr_Ptr;\n+\n+   begin\n+      OSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n+   end OSD;\n+\n    -----------------\n    -- Parent_Size --\n    -----------------\n \n-   type Acc_Size\n-     is access function (A : System.Address) return Long_Long_Integer;\n-\n-   function To_Acc_Size is new Unchecked_Conversion (System.Address, Acc_Size);\n-   --  The profile of the implicitly defined _size primitive\n-\n    function Parent_Size\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count\n    is\n-      Parent_Tag : constant Tag := TSD (T).Tags_Table (1);\n+      Parent_Tag : Tag;\n       --  The tag of the parent type through the dispatch table\n \n-      F : constant Acc_Size := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n+      F : Acc_Size;\n       --  Access to the _size primitive of the parent. We assume that it is\n-      --  always in the first slot of the dispatch table\n+      --  always in the first slot of the dispatch table.\n \n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      Parent_Tag := TSD (T).Tags_Table (1);\n+      F := To_Acc_Size (Parent_Tag.Prims_Ptr (1));\n+\n       --  Here we compute the size of the _parent field of the object\n \n       return SSE.Storage_Count (F.all (Obj));\n@@ -658,6 +934,8 @@ package body Ada.Tags is\n          raise Tag_Error;\n       end if;\n \n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+\n       --  The Parent_Tag of a root-level tagged type is defined to be No_Tag.\n       --  The first entry in the Ancestors_Tags array will be null for such\n       --  a type, but it's better to be explicit about returning No_Tag in\n@@ -674,20 +952,24 @@ package body Ada.Tags is\n    -- Register_Interface_Tag --\n    ----------------------------\n \n-   procedure Register_Interface_Tag\n-    (T           : Tag;\n-     Interface_T : Tag)\n-   is\n-      New_T_TSD : constant Type_Specific_Data_Ptr := TSD (T);\n+   procedure Register_Interface_Tag (T : Tag; Interface_T : Tag) is\n+      New_T_TSD : Type_Specific_Data_Ptr;\n       Index     : Natural;\n+\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Signature (Interface_T, Must_Be_Interface));\n+\n+      New_T_TSD := TSD (T);\n+\n       --  Check if the interface is already registered\n \n       if New_T_TSD.Num_Interfaces > 0 then\n          declare\n-            Id       : Natural          := New_T_TSD.Idepth + 1;\n-            Last_Id  : constant Natural := New_T_TSD.Idepth\n+            Id      : Natural          := New_T_TSD.Idepth + 1;\n+            Last_Id : constant Natural := New_T_TSD.Idepth\n                                             + New_T_TSD.Num_Interfaces;\n+\n          begin\n             loop\n                if New_T_TSD.Tags_Table (Id) = Interface_T then\n@@ -720,6 +1002,7 @@ package body Ada.Tags is\n \n    procedure Set_Access_Level (T : Tag; Value : Natural) is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       TSD (T).Access_Level := Value;\n    end Set_Access_Level;\n \n@@ -730,9 +1013,14 @@ package body Ada.Tags is\n    procedure Set_Entry_Index\n      (T        : Tag;\n       Position : Positive;\n-      Value    : Positive) is\n+      Value    : Positive)\n+   is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n+\n    begin\n-      TSD (T).Ent_Index_Table (Position - Default_Prim_Op_Count) := Value;\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Index > 0);\n+      SSD (T).SSD_Table (Index).Index := Value;\n    end Set_Entry_Index;\n \n    -----------------------\n@@ -741,6 +1029,8 @@ package body Ada.Tags is\n \n    procedure Set_Expanded_Name (T : Tag; Value : System.Address) is\n    begin\n+      pragma Assert\n+        (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       TSD (T).Expanded_Name := To_Cstring_Ptr (Value);\n    end Set_Expanded_Name;\n \n@@ -750,9 +1040,41 @@ package body Ada.Tags is\n \n    procedure Set_External_Tag (T : Tag; Value : System.Address) is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       TSD (T).External_Tag := To_Cstring_Ptr (Value);\n    end Set_External_Tag;\n \n+   ----------------------\n+   -- Set_Num_Prim_Ops --\n+   ----------------------\n+\n+   procedure Set_Num_Prim_Ops (T : Tag; Value : Natural) is\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+\n+      if Is_Primary_DT (T) then\n+         TSD (T).Num_Prim_Ops := Value;\n+      else\n+         OSD (Interface_Tag (T)).Num_Prim_Ops := Value;\n+      end if;\n+   end Set_Num_Prim_Ops;\n+\n+   ----------------------\n+   -- Set_Offset_Index --\n+   ----------------------\n+\n+   procedure Set_Offset_Index\n+     (T        : Interface_Tag;\n+      Position : Positive;\n+      Value    : Positive)\n+   is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n+   begin\n+      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n+      pragma Assert (Index > 0);\n+      OSD (T).OSD_Table (Index) := Value;\n+   end Set_Offset_Index;\n+\n    -----------------------\n    -- Set_Offset_To_Top --\n    -----------------------\n@@ -766,18 +1088,34 @@ package body Ada.Tags is\n                               - DT_Typeinfo_Ptr_Size\n                               - DT_Offset_To_Top_Size);\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n       Offset_To_Top_Ptr.all := Value;\n    end Set_Offset_To_Top;\n \n+   -------------\n+   -- Set_OSD --\n+   -------------\n+\n+   procedure Set_OSD (T : Interface_Tag; Value : System.Address) is\n+      OSD_Ptr : Addr_Ptr;\n+   begin\n+      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n+      OSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      OSD_Ptr.all := Value;\n+   end Set_OSD;\n+\n    -------------------------\n    -- Set_Prim_Op_Address --\n    -------------------------\n \n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n-      Value    : System.Address) is\n+      Value    : System.Address)\n+   is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       T.Prims_Ptr (Position) := Value;\n    end Set_Prim_Op_Address;\n \n@@ -788,9 +1126,13 @@ package body Ada.Tags is\n    procedure Set_Prim_Op_Kind\n      (T        : Tag;\n       Position : Positive;\n-      Value    : Prim_Op_Kind) is\n+      Value    : Prim_Op_Kind)\n+   is\n+      Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n-      TSD (T).POK_Table (Position - Default_Prim_Op_Count) := Value;\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Index > 0);\n+      SSD (T).SSD_Table (Index).Kind := Value;\n    end Set_Prim_Op_Kind;\n \n    -------------------\n@@ -799,6 +1141,7 @@ package body Ada.Tags is\n \n    procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset) is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       TSD (T).RC_Offset := Value;\n    end Set_RC_Offset;\n \n@@ -808,20 +1151,41 @@ package body Ada.Tags is\n \n    procedure Set_Remotely_Callable (T : Tag; Value : Boolean) is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       TSD (T).Remotely_Callable := Value;\n    end Set_Remotely_Callable;\n \n+   -------------\n+   -- Set_SSD --\n+   -------------\n+\n+   procedure Set_SSD (T : Tag; Value : System.Address) is\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      TSD (T).SSD_Ptr := Value;\n+   end Set_SSD;\n+\n    -------------\n    -- Set_TSD --\n    -------------\n \n    procedure Set_TSD (T : Tag; Value : System.Address) is\n-      TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD_Ptr : Addr_Ptr;\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n+      TSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n       TSD_Ptr.all := Value;\n    end Set_TSD;\n \n+   ---------\n+   -- SSD --\n+   ---------\n+\n+   function SSD (T : Tag) return Select_Specific_Data_Ptr is\n+   begin\n+      return To_Select_Specific_Data_Ptr (TSD (T).SSD_Ptr);\n+   end SSD;\n+\n    ------------------\n    -- Typeinfo_Ptr --\n    ------------------"}, {"sha": "46e6c2041676898702619832c41ccc1df5126fdd", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 148, "deletions": 56, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -53,48 +53,68 @@ package Ada.Tags is\n \n    function Internal_Tag (External : String) return Tag;\n \n-   function Descendant_Tag (External : String; Ancestor : Tag) return Tag;\n+   function Descendant_Tag\n+     (External : String;\n+      Ancestor : Tag) return Tag;\n+   pragma Ada_05 (Descendant_Tag);\n \n    function Is_Descendant_At_Same_Level\n      (Descendant : Tag;\n       Ancestor   : Tag) return Boolean;\n+   pragma Ada_05 (Is_Descendant_At_Same_Level);\n \n    function Parent_Tag (T : Tag) return Tag;\n+   pragma Ada_05 (Parent_Tag);\n \n    Tag_Error : exception;\n \n private\n+   --  The following subprogram specifications are placed here instead of\n+   --  the package body to see them from the frontend through rtsfind.\n \n    ---------------------------------------------------------------\n    -- Abstract Procedural Interface For The GNAT Dispatch Table --\n    ---------------------------------------------------------------\n \n    --  GNAT's Dispatch Table format is customizable in order to match the\n-   --  format used in another language. GNAT supports programs that use\n-   --  two different dispatch table formats at the same time: the native\n-   --  format that supports Ada 95 tagged types and which is described in\n-   --  Ada.Tags, and a foreign format for types that are imported from some\n-   --  other language (typically C++) which is described in Interfaces.CPP.\n-   --  The runtime information kept for each tagged type is separated into\n-   --  two objects: the Dispatch Table and the Type Specific Data record.\n-   --  These two objects are allocated statically using the constants:\n+   --  format used in another language. GNAT supports programs that use two\n+   --  different dispatch table formats at the same time: the native format\n+   --  that supports Ada 95 tagged types and which is described in Ada.Tags,\n+   --  and a foreign format for types that are imported from some other\n+   --  language (typically C++) which is described in Interfaces.CPP. The\n+   --  runtime information kept for each tagged type is separated into two\n+   --  objects: the Dispatch Table and the Type Specific Data record. These\n+   --  two objects are allocated statically using the constants:\n \n    --      DT Size  = DT_Prologue_Size  + Nb_Prim * DT_Entry_Size\n    --      TSD Size = TSD_Prologue_Size + (1 + Idepth)  * TSD_Entry_Size\n \n    --  where Nb_prim is the number of primitive operations of the given\n    --  type and Idepth its inheritance depth.\n \n-   --  The compiler generates calls to the following SET routines to\n-   --  initialize those structures and uses the GET functions to\n-   --  retreive the information when needed\n+   --  In order to set or retrieve information from the Dispatch Table or\n+   --  the Type Specific Data record, GNAT generates calls to Set_XXX or\n+   --  Get_XXX routines, where XXX is the name of the field of interest.\n \n    type Dispatch_Table;\n    type Tag is access all Dispatch_Table;\n    type Interface_Tag is access all Dispatch_Table;\n \n    No_Tag : constant Tag := null;\n \n+   type Object_Specific_Data (Nb_Prim : Positive);\n+   type Object_Specific_Data_Ptr is access all Object_Specific_Data;\n+   --  Information associated with the secondary dispatch table of tagged-type\n+   --  objects implementing abstract interfaces.\n+\n+   type Select_Specific_Data (Nb_Prim : Positive);\n+   type Select_Specific_Data_Ptr is access all Select_Specific_Data;\n+   --  A table used to store the primitive operation kind and entry index of\n+   --  primitive subprograms of a type that implements a limited interface.\n+   --  The Select Specific Data table resides in the Type Specific Data of a\n+   --  type. This construct is used in the handling of dispatching triggers\n+   --  in select statements.\n+\n    type Type_Specific_Data;\n    type Type_Specific_Data_Ptr is access all Type_Specific_Data;\n \n@@ -109,27 +129,24 @@ private\n       POK_Protected_Function,\n       POK_Protected_Procedure,\n       POK_Task_Entry,\n+      POK_Task_Function,\n       POK_Task_Procedure);\n \n-   --  Number of predefined primitive operations added by the Expander\n-   --  for a tagged type. It is utilized for indexing in the two auxiliary\n-   --  tables used for dispatching asynchronous, conditional and timed\n-   --  selects. In order to be space efficien, indexing is performed by\n-   --  subtracting this constant value from the provided position in the\n-   --  auxiliary tables.\n-   --  This value is mirrored from Exp_Disp.ads.\n-\n-   Default_Prim_Op_Count : constant Positive := 14;\n+   Default_Prim_Op_Count : constant Positive := 15;\n+   --  Number of predefined primitive operations added by the Expander for a\n+   --  tagged type. It is utilized for indexing in the two auxiliary tables\n+   --  used for dispatching asynchronous, conditional and timed selects. In\n+   --  order to be space efficient, indexing is performed by subtracting this\n+   --  constant value from the provided position in the auxiliary tables (must\n+   --  match Exp_Disp.Default_Prim_Op_Count).\n \n    package SSE renames System.Storage_Elements;\n \n    function CW_Membership (Obj_Tag : Tag; Typ_Tag : Tag) return Boolean;\n    --  Given the tag of an object and the tag associated to a type, return\n    --  true if Obj is in Typ'Class.\n \n-   function IW_Membership\n-     (This : System.Address;\n-      T    : Tag) return Boolean;\n+   function IW_Membership (This : System.Address; T : Tag) return Boolean;\n    --  Ada 2005 (AI-251): General routine that checks if a given object\n    --  implements a tagged type. Its common usage is to check if Obj is in\n    --  Iface'Class, but it is also used to check if a class-wide interface\n@@ -147,22 +164,27 @@ private\n    --  Given the tag associated with a type, returns the accessibility level\n    --  of the type.\n \n-   function Get_Entry_Index\n-     (T        : Tag;\n-      Position : Positive) return Positive;\n+   function Get_Entry_Index (T : Tag; Position : Positive) return Positive;\n    --  Return a primitive operation's entry index (if entry) given a dispatch\n    --  table T and a position of a primitive operation in T.\n \n    function Get_External_Tag (T : Tag) return System.Address;\n    --  Retrieve the address of a null terminated string containing\n-   --  the external name\n+   --  the external name.\n+\n+   function Get_Offset_Index\n+     (T        : Interface_Tag;\n+      Position : Positive) return Positive;\n+   --  Given a pointer to a secondary dispatch table (T) and a position of an\n+   --  operation in the DT, retrieve the corresponding operation's position in\n+   --  the primary dispatch table from the Offset Specific Data table of T.\n \n    function Get_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive) return System.Address;\n    --  Given a pointer to a dispatch table (T) and a position in the DT\n    --  this function returns the address of the virtual function stored\n-   --  in it (used for dispatching calls)\n+   --  in it (used for dispatching calls).\n \n    function Get_Prim_Op_Kind\n      (T        : Tag;\n@@ -182,46 +204,53 @@ private\n    function Get_Remotely_Callable (T : Tag) return Boolean;\n    --  Return the value previously set by Set_Remotely_Callable\n \n-   procedure Inherit_DT\n-    (Old_T       : Tag;\n-     New_T       : Tag;\n-     Entry_Count : Natural);\n+   procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n    --  Entry point used to initialize the DT of a type knowing the tag\n    --  of the direct ancestor and the number of primitive ops that are\n    --  inherited (Entry_Count).\n \n    procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag);\n    --  Initialize the TSD of a type knowing the tag of the direct ancestor\n \n+   function OSD (T : Interface_Tag) return Object_Specific_Data_Ptr;\n+   --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n+   --  retrieve the address of the record containing the Objet Specific\n+   --  Data table.\n+\n    function Parent_Size\n      (Obj : System.Address;\n       T   : Tag) return SSE.Storage_Count;\n-   --  Computes the size the ancestor part of a tagged extension object\n-   --  whose address is 'obj' by calling the indirectly _size function of\n-   --  the ancestor. The ancestor is the parent of the type represented by\n-   --  tag T. This function assumes that _size is always in slot 1 of\n-   --  the dispatch table.\n+   --  Computes the size the ancestor part of a tagged extension object whose\n+   --  address is 'obj' by calling indirectly the ancestor _size function. The\n+   --  ancestor is the parent of the type represented by tag T. This function\n+   --  assumes that _size is always in slot one of the dispatch table.\n \n    pragma Export (Ada, Parent_Size, \"ada__tags__parent_size\");\n    --  This procedure is used in s-finimp and is thus exported manually\n \n-   procedure Register_Interface_Tag\n-    (T           : Tag;\n-     Interface_T : Tag);\n+   procedure Register_Interface_Tag (T : Tag; Interface_T : Tag);\n    --  Ada 2005 (AI-251): Used to initialize the table of interfaces\n    --  implemented by a type. Required to give support to IW_Membership.\n \n    procedure Register_Tag (T : Tag);\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n-   procedure Set_Entry_Index\n-     (T        : Tag;\n-      Position : Positive;\n-      Value    : Positive);\n+   procedure Set_Entry_Index (T : Tag; Position : Positive; Value : Positive);\n    --  Set the entry index of a primitive operation in T's TSD table indexed\n    --  by Position.\n \n+   procedure Set_Num_Prim_Ops (T : Tag; Value : Natural);\n+   --  Set the number of primitive operations in the dispatch table of T. This\n+   --  is used for debugging purposes.\n+\n+   procedure Set_Offset_Index\n+     (T        : Interface_Tag;\n+      Position : Positive;\n+      Value    : Positive);\n+   --  Set the offset value of a primitive operation in a secondary dispatch\n+   --  table denoted by T, indexed by Position.\n+\n    procedure Set_Offset_To_Top\n      (T     : Tag;\n       Value : System.Storage_Elements.Storage_Offset);\n@@ -230,6 +259,10 @@ private\n    --  is always 0; in secondary dispatch tables this is the offset to the base\n    --  of the enclosing type.\n \n+   procedure Set_OSD (T : Interface_Tag; Value : System.Address);\n+   --  Given a pointer T to a secondary dispatch table, store the pointer to\n+   --  the record containing the Object Specific Data generated by GNAT.\n+\n    procedure Set_Prim_Op_Address\n      (T        : Tag;\n       Position : Positive;\n@@ -245,6 +278,10 @@ private\n    --  Set the kind of a primitive operation in T's TSD table indexed by\n    --  Position.\n \n+   procedure Set_SSD (T : Tag; Value : System.Address);\n+   --  Given a pointer T to a dispatch Table, stores the pointer to the record\n+   --  containing the Select Specific Data generated by GNAT.\n+\n    procedure Set_TSD (T : Tag; Value : System.Address);\n    --  Given a pointer T to a dispatch Table, stores the address of the record\n    --  containing the Type Specific Data generated by GNAT.\n@@ -269,15 +306,24 @@ private\n    --  Set to true if the type has been declared in a context described\n    --  in E.4 (18).\n \n+   function SSD (T : Tag) return Select_Specific_Data_Ptr;\n+   --  Given a pointer T to a dispatch Table, retrieves the address of the\n+   --  record containing the Select Specific Data in T's TSD.\n+\n    function TSD (T : Tag) return Type_Specific_Data_Ptr;\n-   --  Given a pointer T to a dispatch Table, retreives the address of the\n-   --  record containing the Type Specific Data generated by GNAT\n+   --  Given a pointer T to a dispatch Table, retrieves the address of the\n+   --  record containing the Type Specific Data generated by GNAT.\n \n    DT_Prologue_Size : constant SSE.Storage_Count :=\n                         SSE.Storage_Count\n-                          (2 * (Standard'Address_Size / System.Storage_Unit));\n+                          (3 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the dispatch table\n \n+   DT_Signature_Size : constant SSE.Storage_Count :=\n+                         SSE.Storage_Count\n+                           (Standard'Address_Size / System.Storage_Unit);\n+   --  Size of the Signature field of the dispatch table\n+\n    DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n                             SSE.Storage_Count\n                               (Standard'Address_Size / System.Storage_Unit);\n@@ -295,7 +341,7 @@ private\n \n    TSD_Prologue_Size : constant SSE.Storage_Count :=\n                          SSE.Storage_Count\n-                           (8 * (Standard'Address_Size / System.Storage_Unit));\n+                          (10 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the type specific data\n \n    TSD_Entry_Size : constant SSE.Storage_Count :=\n@@ -308,22 +354,57 @@ private\n    --  of this type are declared with a dummy size of 1, the actual size\n    --  depending on the number of primitive operations.\n \n-   --  Unchecked Conversions for Tag and TSD\n+   type Signature_Kind is\n+      (Unknown,\n+       Valid_Signature,\n+       Primary_DT,\n+       Secondary_DT,\n+       Abstract_Interface);\n+   for Signature_Kind'Size use 8;\n+   --  Kind of signature found in the header of the dispatch table. These\n+   --  signatures are generated by the frontend and are used by the Check_XXX\n+   --  routines to ensure that the kind of dispatch table managed by each of\n+   --  the routines in this package is correct. This additional check is only\n+   --  performed with this run-time package is compiled with assertions enabled\n+\n+   --  The signature is a sequence of two bytes. The first byte must have the\n+   --  value Valid_Signature, and the second byte must have a value in the\n+   --  range Primary_DT .. Abstract_Interface. The Unknown value is used by\n+   --  the Check_XXX routines to indicate that the signature is wrong.\n+\n+   --  Unchecked Conversions\n+\n+   type Addr_Ptr is access System.Address;\n+   type Tag_Ptr  is access Tag;\n+\n+   type Signature_Values is\n+      array (1 .. DT_Signature_Size) of Signature_Kind;\n+   --  Type used to see the signature as a sequence of Signature_Kind values\n+\n+   function To_Addr_Ptr is\n+      new Unchecked_Conversion (System.Address, Addr_Ptr);\n \n    function To_Type_Specific_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Type_Specific_Data_Ptr);\n \n    function To_Address is\n-     new Unchecked_Conversion (Type_Specific_Data_Ptr, System.Address);\n+     new Unchecked_Conversion (Interface_Tag, System.Address);\n \n    function To_Address is\n      new Unchecked_Conversion (Tag, System.Address);\n \n-   type Addr_Ptr is access System.Address;\n-   type Tag_Ptr  is access Tag;\n+   function To_Address is\n+     new Unchecked_Conversion (Type_Specific_Data_Ptr, System.Address);\n \n-   function To_Addr_Ptr is\n-      new Unchecked_Conversion (System.Address, Addr_Ptr);\n+   function To_Object_Specific_Data_Ptr is\n+     new Unchecked_Conversion (System.Address, Object_Specific_Data_Ptr);\n+\n+   function To_Select_Specific_Data_Ptr is\n+     new Unchecked_Conversion (System.Address, Select_Specific_Data_Ptr);\n+\n+   function To_Signature_Values is\n+     new Unchecked_Conversion (System.Storage_Elements.Storage_Offset,\n+                               Signature_Values);\n \n    function To_Tag_Ptr is\n      new Unchecked_Conversion (System.Address, Tag_Ptr);\n@@ -334,21 +415,32 @@ private\n    pragma Inline_Always (CW_Membership);\n    pragma Inline_Always (IW_Membership);\n    pragma Inline_Always (Get_Access_Level);\n+   pragma Inline_Always (Get_Entry_Index);\n+   pragma Inline_Always (Get_Offset_Index);\n    pragma Inline_Always (Get_Prim_Op_Address);\n+   pragma Inline_Always (Get_Prim_Op_Kind);\n    pragma Inline_Always (Get_RC_Offset);\n    pragma Inline_Always (Get_Remotely_Callable);\n    pragma Inline_Always (Inherit_DT);\n    pragma Inline_Always (Inherit_TSD);\n+   pragma Inline_Always (OSD);\n    pragma Inline_Always (Register_Interface_Tag);\n    pragma Inline_Always (Register_Tag);\n    pragma Inline_Always (Set_Access_Level);\n+   pragma Inline_Always (Set_Entry_Index);\n    pragma Inline_Always (Set_Expanded_Name);\n    pragma Inline_Always (Set_External_Tag);\n+   pragma Inline_Always (Set_Num_Prim_Ops);\n+   pragma Inline_Always (Set_Offset_Index);\n    pragma Inline_Always (Set_Offset_To_Top);\n    pragma Inline_Always (Set_Prim_Op_Address);\n+   pragma Inline_Always (Set_Prim_Op_Kind);\n    pragma Inline_Always (Set_RC_Offset);\n    pragma Inline_Always (Set_Remotely_Callable);\n+   pragma Inline_Always (Set_OSD);\n+   pragma Inline_Always (Set_SSD);\n    pragma Inline_Always (Set_TSD);\n+   pragma Inline_Always (SSD);\n    pragma Inline_Always (TSD);\n \n end Ada.Tags;"}, {"sha": "c126bd88e33fae39058f7f16fe4e17db20db27ca", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 122, "deletions": 26, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -214,8 +214,10 @@ package body Einfo is\n    --    Abstract_Interfaces             Elist24\n \n    --    Abstract_Interface_Alias        Node25\n+   --    Current_Use_Clause              Node25\n \n    --    Overridden_Operation            Node26\n+   --    Package_Instantiation           Node26\n \n    --    Wrapped_Entity                  Node27\n \n@@ -388,7 +390,7 @@ package body Einfo is\n    --    Has_Recursive_Call             Flag143\n    --    Is_Unsigned_Type               Flag144\n    --    Strict_Alignment               Flag145\n-   --    Elaborate_All_Desirable        Flag146\n+   --    (unused)                       Flag146\n    --    Needs_Debug_Info               Flag147\n    --    Suppress_Elaboration_Warnings  Flag148\n    --    Is_Compilation_Unit            Flag149\n@@ -444,12 +446,13 @@ package body Einfo is\n    --    Is_Local_Anonymous_Access      Flag194\n    --    Is_Primitive_Wrapper           Flag195\n    --    Was_Hidden                     Flag196\n+   --    Is_Limited_Interface           Flag197\n+   --    Is_Protected_Interface         Flag198\n+   --    Is_Synchronized_Interface      Flag199\n+   --    Is_Task_Interface              Flag200\n+\n+   --    Has_Anon_Block_Suffix          Flag201\n \n-   --    (unused)                       Flag197\n-   --    (unused)                       Flag198\n-   --    (unused)                       Flag199\n-   --    (unused)                       Flag200\n-   --    (unused)                       Flag201\n    --    (unused)                       Flag202\n    --    (unused)                       Flag203\n    --    (unused)                       Flag204\n@@ -698,6 +701,12 @@ package body Einfo is\n       return Node22 (Id);\n    end Corresponding_Remote_Type;\n \n+   function Current_Use_Clause (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Package);\n+      return Node25 (Id);\n+   end Current_Use_Clause;\n+\n    function Current_Value (Id : E) return N is\n    begin\n       pragma Assert (Ekind (Id) in Object_Kind);\n@@ -839,11 +848,6 @@ package body Einfo is\n       return Node16 (Id);\n    end DTC_Entity;\n \n-   function Elaborate_All_Desirable (Id : E) return B is\n-   begin\n-      return Flag146 (Id);\n-   end Elaborate_All_Desirable;\n-\n    function Elaboration_Entity (Id : E) return E is\n    begin\n       pragma Assert\n@@ -1073,6 +1077,11 @@ package body Einfo is\n       return Flag79 (Id);\n    end Has_All_Calls_Remote;\n \n+   function Has_Anon_Block_Suffix (Id : E) return B is\n+   begin\n+      return Flag201 (Id);\n+   end Has_Anon_Block_Suffix;\n+\n    function Has_Atomic_Components (Id : E) return B is\n    begin\n       return Flag86 (Implementation_Base_Type (Id));\n@@ -1667,6 +1676,12 @@ package body Einfo is\n       return Flag106 (Id);\n    end Is_Limited_Composite;\n \n+   function Is_Limited_Interface (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      return Flag197 (Id);\n+   end Is_Limited_Interface;\n+\n    function Is_Limited_Record (Id : E) return B is\n    begin\n       return Flag25 (Id);\n@@ -1750,6 +1765,12 @@ package body Einfo is\n       return Flag53 (Id);\n    end Is_Private_Descendant;\n \n+   function Is_Protected_Interface (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      return Flag198 (Id);\n+   end Is_Protected_Interface;\n+\n    function Is_Public (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -1792,6 +1813,12 @@ package body Einfo is\n       return Flag28 (Id);\n    end Is_Statically_Allocated;\n \n+   function Is_Synchronized_Interface (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      return Flag199 (Id);\n+   end Is_Synchronized_Interface;\n+\n    function Is_Tag (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -1803,6 +1830,12 @@ package body Einfo is\n       return Flag55 (Id);\n    end Is_Tagged_Type;\n \n+   function Is_Task_Interface (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      return Flag200 (Id);\n+   end Is_Task_Interface;\n+\n    function Is_Thread_Body (Id : E) return B is\n    begin\n       return Flag77 (Id);\n@@ -2016,7 +2049,8 @@ package body Einfo is\n \n    function Obsolescent_Warning (Id : E) return N is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n+      pragma Assert\n+        (Is_Subprogram (Id) or else Is_Package_Or_Generic_Package (Id));\n       return Node24 (Id);\n    end Obsolescent_Warning;\n \n@@ -2048,6 +2082,15 @@ package body Einfo is\n       return Node26 (Id);\n    end Overridden_Operation;\n \n+   function Package_Instantiation (Id : E) return N is\n+   begin\n+      pragma Assert\n+        (False\n+           or else Ekind (Id) = E_Generic_Package\n+           or else Ekind (Id) = E_Package);\n+      return Node26 (Id);\n+   end Package_Instantiation;\n+\n    function Packed_Array_Type (Id : E) return E is\n    begin\n       pragma Assert (Is_Array_Type (Id));\n@@ -2744,7 +2787,13 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Corresponding_Remote_Type;\n \n-   procedure Set_Current_Value (Id : E; V : E) is\n+   procedure Set_Current_Use_Clause (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Package);\n+      Set_Node25 (Id, V);\n+   end Set_Current_Use_Clause;\n+\n+   procedure Set_Current_Value (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) in Object_Kind or else Ekind (Id) = E_Void);\n       Set_Node9 (Id, V);\n@@ -2888,11 +2937,6 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_DTC_Entity;\n \n-   procedure Set_Elaborate_All_Desirable (Id : E; V : B := True) is\n-   begin\n-      Set_Flag146 (Id, V);\n-   end Set_Elaborate_All_Desirable;\n-\n    procedure Set_Elaboration_Entity (Id : E; V : E) is\n    begin\n       pragma Assert\n@@ -3126,6 +3170,11 @@ package body Einfo is\n       Set_Flag79 (Id, V);\n    end Set_Has_All_Calls_Remote;\n \n+   procedure Set_Has_Anon_Block_Suffix (Id : E; V : B := True) is\n+   begin\n+      Set_Flag201 (Id, V);\n+   end Set_Has_Anon_Block_Suffix;\n+\n    procedure Set_Has_Atomic_Components (Id : E; V : B := True) is\n    begin\n       pragma Assert (not Is_Type (Id) or else Base_Type (Id) = Id);\n@@ -3754,6 +3803,12 @@ package body Einfo is\n       Set_Flag106 (Id, V);\n    end Set_Is_Limited_Composite;\n \n+   procedure Set_Is_Limited_Interface (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      Set_Flag197 (Id, V);\n+   end Set_Is_Limited_Interface;\n+\n    procedure Set_Is_Limited_Record (Id : E; V : B := True) is\n    begin\n       Set_Flag25 (Id, V);\n@@ -3838,6 +3893,12 @@ package body Einfo is\n       Set_Flag53 (Id, V);\n    end Set_Is_Private_Descendant;\n \n+   procedure Set_Is_Protected_Interface (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      Set_Flag198 (Id, V);\n+   end Set_Is_Protected_Interface;\n+\n    procedure Set_Is_Public (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3886,6 +3947,12 @@ package body Einfo is\n       Set_Flag28 (Id, V);\n    end Set_Is_Statically_Allocated;\n \n+   procedure Set_Is_Synchronized_Interface (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      Set_Flag199 (Id, V);\n+   end Set_Is_Synchronized_Interface;\n+\n    procedure Set_Is_Tag (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3902,6 +3969,12 @@ package body Einfo is\n       Set_Flag77 (Id, V);\n    end Set_Is_Thread_Body;\n \n+   procedure Set_Is_Task_Interface (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Interface (Id));\n+      Set_Flag200 (Id, V);\n+   end Set_Is_Task_Interface;\n+\n    procedure Set_Is_True_Constant (Id : E; V : B := True) is\n    begin\n       Set_Flag163 (Id, V);\n@@ -4108,7 +4181,8 @@ package body Einfo is\n \n    procedure Set_Obsolescent_Warning (Id : E; V : N) is\n    begin\n-      pragma Assert (Is_Subprogram (Id));\n+      pragma Assert\n+        (Is_Subprogram (Id) or else Is_Package_Or_Generic_Package (Id));\n       Set_Node24 (Id, V);\n    end Set_Obsolescent_Warning;\n \n@@ -4140,6 +4214,15 @@ package body Einfo is\n       Set_Node26 (Id, V);\n    end Set_Overridden_Operation;\n \n+   procedure Set_Package_Instantiation (Id : E; V : N) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Void\n+           or else Ekind (Id) = E_Generic_Package\n+           or else Ekind (Id) = E_Package);\n+      Set_Node26 (Id, V);\n+   end Set_Package_Instantiation;\n+\n    procedure Set_Packed_Array_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Array_Type (Id));\n@@ -5693,17 +5776,17 @@ package body Einfo is\n       end if;\n    end Is_Limited_Type;\n \n-   ----------------\n-   -- Is_Package --\n-   ----------------\n+   -----------------------------------\n+   -- Is_Package_Or_Generic_Package --\n+   -----------------------------------\n \n-   function Is_Package (Id : E) return B is\n+   function Is_Package_Or_Generic_Package (Id : E) return B is\n    begin\n       return\n         Ekind (Id) = E_Package\n           or else\n         Ekind (Id) = E_Generic_Package;\n-   end Is_Package;\n+   end Is_Package_Or_Generic_Package;\n \n    --------------------------\n    -- Is_Protected_Private --\n@@ -6466,7 +6549,6 @@ package body Einfo is\n       W (\"Delay_Subprogram_Descriptors\",  Flag50  (Id));\n       W (\"Depends_On_Private\",            Flag14  (Id));\n       W (\"Discard_Names\",                 Flag88  (Id));\n-      W (\"Elaborate_All_Desirable\",       Flag146 (Id));\n       W (\"Elaboration_Entity_Required\",   Flag174 (Id));\n       W (\"Entry_Accepted\",                Flag152 (Id));\n       W (\"Finalize_Storage_Only\",         Flag158 (Id));\n@@ -6475,6 +6557,7 @@ package body Einfo is\n       W (\"Has_Aliased_Components\",        Flag135 (Id));\n       W (\"Has_Alignment_Clause\",          Flag46  (Id));\n       W (\"Has_All_Calls_Remote\",          Flag79  (Id));\n+      W (\"Has_Anon_Block_Suffix\",         Flag201 (Id));\n       W (\"Has_Atomic_Components\",         Flag86  (Id));\n       W (\"Has_Biased_Representation\",     Flag139 (Id));\n       W (\"Has_Completion\",                Flag26  (Id));\n@@ -6580,6 +6663,7 @@ package body Einfo is\n       W (\"Is_Known_Valid\",                Flag37  (Id));\n       W (\"Is_Known_Valid\",                Flag170 (Id));\n       W (\"Is_Limited_Composite\",          Flag106 (Id));\n+      W (\"Is_Limited_Interface\",          Flag197 (Id));\n       W (\"Is_Limited_Record\",             Flag25  (Id));\n       W (\"Is_Machine_Code_Subprogram\",    Flag137 (Id));\n       W (\"Is_Non_Static_Subtype\",         Flag109 (Id));\n@@ -6595,16 +6679,19 @@ package body Einfo is\n       W (\"Is_Primitive_Wrapper\",          Flag195 (Id));\n       W (\"Is_Private_Composite\",          Flag107 (Id));\n       W (\"Is_Private_Descendant\",         Flag53  (Id));\n+      W (\"Is_Protected_Interface\",        Flag198 (Id));\n       W (\"Is_Public\",                     Flag10  (Id));\n       W (\"Is_Pure\",                       Flag44  (Id));\n       W (\"Is_Pure_Unit_Access_Type\",      Flag189 (Id));\n       W (\"Is_Remote_Call_Interface\",      Flag62  (Id));\n       W (\"Is_Remote_Types\",               Flag61  (Id));\n       W (\"Is_Renaming_Of_Object\",         Flag112 (Id));\n       W (\"Is_Shared_Passive\",             Flag60  (Id));\n+      W (\"Is_Synchronized_Interface\",     Flag199 (Id));\n       W (\"Is_Statically_Allocated\",       Flag28  (Id));\n       W (\"Is_Tag\",                        Flag78  (Id));\n       W (\"Is_Tagged_Type\",                Flag55  (Id));\n+      W (\"Is_Task_Interface\",             Flag200 (Id));\n       W (\"Is_Thread_Body\",                Flag77  (Id));\n       W (\"Is_True_Constant\",              Flag163 (Id));\n       W (\"Is_Unchecked_Union\",            Flag117 (Id));\n@@ -7526,7 +7613,9 @@ package body Einfo is\n               E_Record_Subtype_With_Private              =>\n             Write_Str (\"Abstract_Interfaces\");\n \n-         when Subprogram_Kind                            =>\n+         when Subprogram_Kind                            |\n+              E_Package                                  |\n+              E_Generic_Package                          =>\n             Write_Str (\"Obsolescent_Warning\");\n \n          when Task_Kind                                  =>\n@@ -7548,6 +7637,9 @@ package body Einfo is\n               E_Function                                 =>\n             Write_Str (\"Abstract_Interface_Alias\");\n \n+         when E_Package                                  =>\n+            Write_Str (\"Current_Use_Clause\");\n+\n          when others                                     =>\n             Write_Str (\"Field25??\");\n       end case;\n@@ -7560,6 +7652,10 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Generic_Package                          |\n+              E_Package                                  =>\n+            Write_Str (\"Package_Instantiation\");\n+\n          when E_Procedure                                |\n               E_Function                                 =>\n             Write_Str (\"Overridden_Operation\");"}, {"sha": "fa1e58416740a86f5d6b77dc345181826d97561f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 81, "deletions": 22, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -594,6 +594,11 @@ package Einfo is\n --      created at the same time as the discriminal, and used to replace\n --      occurrences of the discriminant within the type declaration.\n \n+--    Current_Use_Clause (Node25)\n+--      Present in packages. Indicates the use clause currently in scope\n+--      that makes the package use_visible. Used to detect redundant use\n+--      clauses for the same package.\n+\n --    Current_Value (Node9)\n --       Present in E_Variable, E_Out_Parameter and E_In_Out_Parameter\n --       entities. Set non-Empty if the (constant) current value of the\n@@ -801,13 +806,6 @@ package Einfo is\n --       Present in all entities. Contains a value of the enumeration type\n --       Entity_Kind declared in a subsequent section in this spec.\n \n---    Elaborate_All_Desirable (Flag146)\n---       Present in package and subprogram entities, and in generic package\n---       and subprogram entities. Set if internal analysis of a client that\n---       with's this unit determines that Elaborate_All is desirable, i.e.\n---       that there is a possibility that Program_Error may be raised if\n---       Elaborate_All conditions cannot be met.\n-\n --    Elaboration_Entity (Node13)\n --       Present in generic and non-generic package and subprogram\n --       entities. This is a boolean entity associated with the unit that\n@@ -1230,6 +1228,11 @@ package Einfo is\n --       be RCI entities, so the flag Is_Remote_Call_Interface will always\n --       be set if this flag is set.\n \n+--    Has_Anon_Block_Suffix (Flag201)\n+--       Present in all entities. Set if the entity is nested within one or\n+--       more anonymous blocks and the Chars field contains a name with an\n+--       anonymous block suffix (see Exp_Dbug for furthert details).\n+\n --    Has_Atomic_Components (Flag86) [implementation base type only]\n --       Present in all types and objects. Set only for an array type or\n --       an array object if a valid pragma Atomic_Components applies to the\n@@ -2106,6 +2109,10 @@ package Einfo is\n --       do not become visible until the immediate scope of the composite\n --       type itself (RM 7.3.1 (5)).\n \n+--    Is_Limited_Interface (Flag197)\n+--       Present in types that are interfaces. True if interface is declared\n+--       limited, or is derived from limited interfaces.\n+\n --    Is_Limited_Record (Flag25)\n --       Present in all entities. Set to true for record (sub)types if the\n --       record is declared to be limited. Note that this flag is not set\n@@ -2159,8 +2166,8 @@ package Einfo is\n --       including generic formal parameters.\n \n --    Is_Obsolescent (Flag153)\n---       Present in all entities. Set only for subprograms when a valid pragma\n---       Obsolescent applies to the subprogram.\n+--       Present in all entities. Set only for packages and subprograms to\n+--       which a valid pragma Obsolescent applies.\n \n --    Is_Optional_Parameter (Flag134)\n --       Present in parameter entities. Set if the parameter is specified as\n@@ -2175,7 +2182,7 @@ package Einfo is\n --       Present in subprograms. Set if the subprogram is a primitive\n --       operation of a derived type, that overrides an inherited operation.\n \n---    Is_Package (synthesized)\n+--    Is_Package_Or_Generic_Package (synthesized)\n --       Applies to all entities. True for packages and generic packages.\n --       False for all other entities.\n \n@@ -2264,6 +2271,10 @@ package Einfo is\n --       Applies to all entities, true for private types and subtypes,\n --       as well as for record with private types as subtypes\n \n+--    Is_Protected_Interface (Flag198)\n+--       Present in types that are interfaces. True if interface is declared\n+--       protected, or is derived from protected interfaces.\n+\n --    Is_Protected_Type (synthesized)\n --       Applies to all entities, true for protected types and subtypes\n \n@@ -2358,6 +2369,10 @@ package Einfo is\n --       or a string slice type, or an array type with one dimension and a\n --       component type that is a character type.\n \n+--    Is_Synchronized_Interface (Flag199)\n+--       Present_types that are interfaces. True is interface is declared\n+--       synchronized, or is derived from synchronized interfaces.\n+\n --    Is_Tag (Flag78)\n --       Present in E_Component. For regular tagged type this flag is set on\n --       the tag component (whose name is Name_uTag) and for CPP_Class tagged\n@@ -2367,6 +2382,10 @@ package Einfo is\n --    Is_Tagged_Type (Flag55)\n --       Present in all entities, true for an entity for a tagged type.\n \n+--    Is_Task_Interface (Flag200)\n+--       Present in types that are interfaces. True is interface is declared\n+--        as such, or if it is derived from task interfaces.\n+\n --    Is_Task_Record_Type (synthesized)\n --       Applies to all entities, true if Is_Concurrent_Record_Type\n --       Corresponding_Concurrent_Type is a task type.\n@@ -2732,8 +2751,8 @@ package Einfo is\n --       formals as a value of type Pos.\n \n --    Obsolescent_Warning (Node24)\n---       Present in subprogram entities. Set non-empty only if the pragma\n---       Obsolescent had a string argument, in which case it records the\n+--       Present in package and subprogram entities. Set non-empty only if the\n+--       pragma Obsolescent had a string argument, in which case it records the\n --       contents of the corresponding string literal node.\n \n --    Original_Access_Type (Node21)\n@@ -2778,6 +2797,18 @@ package Einfo is\n --       Present in subprograms. For overriding operations, points to the\n --       user-defined parent subprogram that is being overridden.\n \n+--    Package_Instantiation (Node26)\n+--       Present in packages and generic packages. When present, this field\n+--       references an N_Package_Instantiation node associated with an\n+--       instantiated package. In the case where the referenced node has\n+--       been rewritten to an N_Package_Specification, the instantiation\n+--       node is available from the Original_Node field of the package spec\n+--       node. This is currently not guaranteed to be set in all cases, but\n+--       when set, the field is used in Get_Package_Instantiation_Node as\n+--       one of the means of obtaining the instantiation node. Eventually\n+--       it should be set in all cases, including package entities associated\n+--       with formal packages. ???\n+\n --    Packed_Array_Type (Node23)\n --       Present in array types and subtypes, including the string literal\n --       subtype case, if the corresponding type is packed (either bit packed\n@@ -4009,6 +4040,7 @@ package Einfo is\n    --    Can_Never_Be_Null             (Flag38)\n    --    Checks_May_Be_Suppressed      (Flag31)\n    --    Debug_Info_Off                (Flag166)\n+   --    Has_Anon_Block_Suffix         (Flag201)\n    --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_Convention_Pragma         (Flag119)\n    --    Has_Delayed_Freeze            (Flag18)\n@@ -4123,6 +4155,10 @@ package Einfo is\n    --    Is_Frozen                     (Flag4)\n    --    Is_Generic_Actual_Type        (Flag94)\n    --    Is_Generic_Type               (Flag13)\n+   --    Is_Limited_Interface          (Flag197)\n+   --    Is_Protected_Interface        (Flag198)\n+   --    Is_Synchronized_Interface     (Flag199)\n+   --    Is_Task_Interface             (Flag200)\n    --    Is_Non_Static_Subtype         (Flag109)\n    --    Is_Packed                     (Flag51)   (base type only)\n    --    Is_Private_Composite          (Flag107)\n@@ -4428,7 +4464,6 @@ package Einfo is\n    --    Delay_Cleanups                (Flag114)\n    --    Delay_Subprogram_Descriptors  (Flag50)\n    --    Discard_Names                 (Flag88)\n-   --    Elaborate_All_Desirable       (Flag146)\n    --    Has_Completion                (Flag26)\n    --    Has_Controlling_Result        (Flag98)\n    --    Has_Master_Entity             (Flag21)\n@@ -4596,10 +4631,12 @@ package Einfo is\n    --    Generic_Renamings             (Elist23)  (for an instance)\n    --    Inner_Instances               (Elist23)  (generic case only)\n    --    Limited_View                  (Node23)   (non-generic, not instance)\n+   --    Obsolescent_Warning           (Node24)\n+   --    Current_Use_Clause            (Node25)\n+   --    Package_Instantiation         (Node26)\n    --    Delay_Subprogram_Descriptors  (Flag50)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Discard_Names                 (Flag88)\n-   --    Elaborate_All_Desirable       (Flag146)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    From_With_Type                (Flag159)\n    --    Has_All_Calls_Remote          (Flag79)\n@@ -4678,7 +4715,6 @@ package Einfo is\n    --    Delay_Cleanups                (Flag114)\n    --    Delay_Subprogram_Descriptors  (Flag50)\n    --    Discard_Names                 (Flag88)\n-   --    Elaborate_All_Desirable       (Flag146)\n    --    Has_Completion                (Flag26)\n    --    Has_Master_Entity             (Flag21)\n    --    Has_Nested_Block_With_Handler (Flag101)\n@@ -5145,6 +5181,7 @@ package Einfo is\n    function Corresponding_Equality             (Id : E) return E;\n    function Corresponding_Record_Type          (Id : E) return E;\n    function Corresponding_Remote_Type          (Id : E) return E;\n+   function Current_Use_Clause                 (Id : E) return E;\n    function Current_Value                      (Id : E) return N;\n    function Debug_Info_Off                     (Id : E) return B;\n    function Debug_Renaming_Link                (Id : E) return E;\n@@ -5168,7 +5205,6 @@ package Einfo is\n    function Discriminant_Constraint            (Id : E) return L;\n    function Discriminant_Default_Value         (Id : E) return N;\n    function Discriminant_Number                (Id : E) return U;\n-   function Elaborate_All_Desirable            (Id : E) return B;\n    function Elaboration_Entity                 (Id : E) return E;\n    function Elaboration_Entity_Required        (Id : E) return B;\n    function Enclosing_Scope                    (Id : E) return E;\n@@ -5208,6 +5244,7 @@ package Einfo is\n    function Has_Aliased_Components             (Id : E) return B;\n    function Has_Alignment_Clause               (Id : E) return B;\n    function Has_All_Calls_Remote               (Id : E) return B;\n+   function Has_Anon_Block_Suffix              (Id : E) return B;\n    function Has_Atomic_Components              (Id : E) return B;\n    function Has_Biased_Representation          (Id : E) return B;\n    function Has_Completion                     (Id : E) return B;\n@@ -5314,6 +5351,7 @@ package Einfo is\n    function Is_Known_Non_Null                  (Id : E) return B;\n    function Is_Known_Valid                     (Id : E) return B;\n    function Is_Limited_Composite               (Id : E) return B;\n+   function Is_Limited_Interface               (Id : E) return B;\n    function Is_Machine_Code_Subprogram         (Id : E) return B;\n    function Is_Non_Static_Subtype              (Id : E) return B;\n    function Is_Null_Init_Proc                  (Id : E) return B;\n@@ -5328,6 +5366,7 @@ package Einfo is\n \n    function Is_Private_Composite               (Id : E) return B;\n    function Is_Private_Descendant              (Id : E) return B;\n+   function Is_Protected_Interface             (Id : E) return B;\n    function Is_Public                          (Id : E) return B;\n    function Is_Pure                            (Id : E) return B;\n    function Is_Pure_Unit_Access_Type           (Id : E) return B;\n@@ -5336,8 +5375,10 @@ package Einfo is\n    function Is_Renaming_Of_Object              (Id : E) return B;\n    function Is_Shared_Passive                  (Id : E) return B;\n    function Is_Statically_Allocated            (Id : E) return B;\n+   function Is_Synchronized_Interface          (Id : E) return B;\n    function Is_Tag                             (Id : E) return B;\n    function Is_Tagged_Type                     (Id : E) return B;\n+   function Is_Task_Interface                  (Id : E) return B;\n    function Is_Thread_Body                     (Id : E) return B;\n    function Is_True_Constant                   (Id : E) return B;\n    function Is_Unchecked_Union                 (Id : E) return B;\n@@ -5379,6 +5420,7 @@ package Einfo is\n    function Original_Array_Type                (Id : E) return E;\n    function Original_Record_Component          (Id : E) return E;\n    function Overridden_Operation               (Id : E) return E;\n+   function Package_Instantiation              (Id : E) return N;\n    function Packed_Array_Type                  (Id : E) return E;\n    function Parent_Subtype                     (Id : E) return E;\n    function Primitive_Operations               (Id : E) return L;\n@@ -5519,7 +5561,7 @@ package Einfo is\n    function Is_Dynamic_Scope                   (Id : E) return B;\n    function Is_Indefinite_Subtype              (Id : E) return B;\n    function Is_Limited_Type                    (Id : E) return B;\n-   function Is_Package                         (Id : E) return B;\n+   function Is_Package_Or_Generic_Package      (Id : E) return B;\n    function Is_Protected_Private               (Id : E) return B;\n    function Is_Protected_Record_Type           (Id : E) return B;\n    function Is_Return_By_Reference_Type        (Id : E) return B;\n@@ -5638,6 +5680,7 @@ package Einfo is\n    procedure Set_Corresponding_Equality        (Id : E; V : E);\n    procedure Set_Corresponding_Record_Type     (Id : E; V : E);\n    procedure Set_Corresponding_Remote_Type     (Id : E; V : E);\n+   procedure Set_Current_Use_Clause            (Id : E; V : E);\n    procedure Set_Current_Value                 (Id : E; V : N);\n    procedure Set_Debug_Info_Off                (Id : E; V : B := True);\n    procedure Set_Debug_Renaming_Link           (Id : E; V : E);\n@@ -5661,7 +5704,6 @@ package Einfo is\n    procedure Set_Discriminant_Constraint       (Id : E; V : L);\n    procedure Set_Discriminant_Default_Value    (Id : E; V : N);\n    procedure Set_Discriminant_Number           (Id : E; V : U);\n-   procedure Set_Elaborate_All_Desirable       (Id : E; V : B := True);\n    procedure Set_Elaboration_Entity            (Id : E; V : E);\n    procedure Set_Elaboration_Entity_Required   (Id : E; V : B := True);\n    procedure Set_Enclosing_Scope               (Id : E; V : E);\n@@ -5700,6 +5742,7 @@ package Einfo is\n    procedure Set_Has_Aliased_Components        (Id : E; V : B := True);\n    procedure Set_Has_Alignment_Clause          (Id : E; V : B := True);\n    procedure Set_Has_All_Calls_Remote          (Id : E; V : B := True);\n+   procedure Set_Has_Anon_Block_Suffix         (Id : E; V : B := True);\n    procedure Set_Has_Atomic_Components         (Id : E; V : B := True);\n    procedure Set_Has_Biased_Representation     (Id : E; V : B := True);\n    procedure Set_Has_Completion                (Id : E; V : B := True);\n@@ -5810,6 +5853,7 @@ package Einfo is\n    procedure Set_Is_Known_Non_Null             (Id : E; V : B := True);\n    procedure Set_Is_Known_Valid                (Id : E; V : B := True);\n    procedure Set_Is_Limited_Composite          (Id : E; V : B := True);\n+   procedure Set_Is_Limited_Interface          (Id : E; V : B := True);\n    procedure Set_Is_Limited_Record             (Id : E; V : B := True);\n    procedure Set_Is_Machine_Code_Subprogram    (Id : E; V : B := True);\n    procedure Set_Is_Non_Static_Subtype         (Id : E; V : B := True);\n@@ -5823,9 +5867,9 @@ package Einfo is\n    procedure Set_Is_Potentially_Use_Visible    (Id : E; V : B := True);\n    procedure Set_Is_Preelaborated              (Id : E; V : B := True);\n    procedure Set_Is_Primitive_Wrapper          (Id : E; V : B := True);\n-\n    procedure Set_Is_Private_Composite          (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant         (Id : E; V : B := True);\n+   procedure Set_Is_Protected_Interface        (Id : E; V : B := True);\n    procedure Set_Is_Public                     (Id : E; V : B := True);\n    procedure Set_Is_Pure                       (Id : E; V : B := True);\n    procedure Set_Is_Pure_Unit_Access_Type      (Id : E; V : B := True);\n@@ -5834,8 +5878,10 @@ package Einfo is\n    procedure Set_Is_Renaming_Of_Object         (Id : E; V : B := True);\n    procedure Set_Is_Shared_Passive             (Id : E; V : B := True);\n    procedure Set_Is_Statically_Allocated       (Id : E; V : B := True);\n+   procedure Set_Is_Synchronized_Interface     (Id : E; V : B := True);\n    procedure Set_Is_Tag                        (Id : E; V : B := True);\n    procedure Set_Is_Tagged_Type                (Id : E; V : B := True);\n+   procedure Set_Is_Task_Interface             (Id : E; V : B := True);\n    procedure Set_Is_Thread_Body                (Id : E; V : B := True);\n    procedure Set_Is_True_Constant              (Id : E; V : B := True);\n    procedure Set_Is_Unchecked_Union            (Id : E; V : B := True);\n@@ -5876,6 +5922,7 @@ package Einfo is\n    procedure Set_Original_Array_Type           (Id : E; V : E);\n    procedure Set_Original_Record_Component     (Id : E; V : E);\n    procedure Set_Overridden_Operation          (Id : E; V : E);\n+   procedure Set_Package_Instantiation         (Id : E; V : N);\n    procedure Set_Packed_Array_Type             (Id : E; V : E);\n    procedure Set_Parent_Subtype                (Id : E; V : E);\n    procedure Set_Primitive_Operations          (Id : E; V : L);\n@@ -6185,6 +6232,7 @@ package Einfo is\n    pragma Inline (Corresponding_Equality);\n    pragma Inline (Corresponding_Record_Type);\n    pragma Inline (Corresponding_Remote_Type);\n+   pragma Inline (Current_Use_Clause);\n    pragma Inline (Current_Value);\n    pragma Inline (Debug_Info_Off);\n    pragma Inline (Debug_Renaming_Link);\n@@ -6208,7 +6256,6 @@ package Einfo is\n    pragma Inline (Discriminant_Constraint);\n    pragma Inline (Discriminant_Default_Value);\n    pragma Inline (Discriminant_Number);\n-   pragma Inline (Elaborate_All_Desirable);\n    pragma Inline (Elaboration_Entity);\n    pragma Inline (Elaboration_Entity_Required);\n    pragma Inline (Enclosing_Scope);\n@@ -6247,6 +6294,7 @@ package Einfo is\n    pragma Inline (Has_Aliased_Components);\n    pragma Inline (Has_Alignment_Clause);\n    pragma Inline (Has_All_Calls_Remote);\n+   pragma Inline (Has_Anon_Block_Suffix);\n    pragma Inline (Has_Atomic_Components);\n    pragma Inline (Has_Biased_Representation);\n    pragma Inline (Has_Completion);\n@@ -6377,6 +6425,7 @@ package Einfo is\n    pragma Inline (Is_Known_Non_Null);\n    pragma Inline (Is_Known_Valid);\n    pragma Inline (Is_Limited_Composite);\n+   pragma Inline (Is_Limited_Interface);\n    pragma Inline (Is_Limited_Record);\n    pragma Inline (Is_Machine_Code_Subprogram);\n    pragma Inline (Is_Modular_Integer_Type);\n@@ -6400,6 +6449,7 @@ package Einfo is\n    pragma Inline (Is_Private_Composite);\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Type);\n+   pragma Inline (Is_Protected_Interface);\n    pragma Inline (Is_Protected_Type);\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n@@ -6414,8 +6464,10 @@ package Einfo is\n    pragma Inline (Is_Signed_Integer_Type);\n    pragma Inline (Is_Statically_Allocated);\n    pragma Inline (Is_Subprogram);\n+   pragma Inline (Is_Synchronized_Interface);\n    pragma Inline (Is_Tag);\n    pragma Inline (Is_Tagged_Type);\n+   pragma Inline (Is_Task_Interface);\n    pragma Inline (Is_Thread_Body);\n    pragma Inline (Is_True_Constant);\n    pragma Inline (Is_Task_Type);\n@@ -6459,6 +6511,7 @@ package Einfo is\n    pragma Inline (Original_Array_Type);\n    pragma Inline (Original_Record_Component);\n    pragma Inline (Overridden_Operation);\n+   pragma Inline (Package_Instantiation);\n    pragma Inline (Packed_Array_Type);\n    pragma Inline (Parameter_Mode);\n    pragma Inline (Parent_Subtype);\n@@ -6552,6 +6605,7 @@ package Einfo is\n    pragma Inline (Set_Corresponding_Equality);\n    pragma Inline (Set_Corresponding_Record_Type);\n    pragma Inline (Set_Corresponding_Remote_Type);\n+   pragma Inline (Set_Current_Use_Clause);\n    pragma Inline (Set_Current_Value);\n    pragma Inline (Set_Debug_Info_Off);\n    pragma Inline (Set_Debug_Renaming_Link);\n@@ -6574,7 +6628,6 @@ package Einfo is\n    pragma Inline (Set_Discriminant_Constraint);\n    pragma Inline (Set_Discriminant_Default_Value);\n    pragma Inline (Set_Discriminant_Number);\n-   pragma Inline (Set_Elaborate_All_Desirable);\n    pragma Inline (Set_Elaboration_Entity);\n    pragma Inline (Set_Elaboration_Entity_Required);\n    pragma Inline (Set_Enclosing_Scope);\n@@ -6611,6 +6664,7 @@ package Einfo is\n    pragma Inline (Set_Has_Aliased_Components);\n    pragma Inline (Set_Has_Alignment_Clause);\n    pragma Inline (Set_Has_All_Calls_Remote);\n+   pragma Inline (Set_Has_Anon_Block_Suffix);\n    pragma Inline (Set_Has_Atomic_Components);\n    pragma Inline (Set_Has_Biased_Representation);\n    pragma Inline (Set_Has_Completion);\n@@ -6720,6 +6774,7 @@ package Einfo is\n    pragma Inline (Set_Is_Known_Non_Null);\n    pragma Inline (Set_Is_Known_Valid);\n    pragma Inline (Set_Is_Limited_Composite);\n+   pragma Inline (Set_Is_Limited_Interface);\n    pragma Inline (Set_Is_Limited_Record);\n    pragma Inline (Set_Is_Machine_Code_Subprogram);\n    pragma Inline (Set_Is_Non_Static_Subtype);\n@@ -6736,6 +6791,7 @@ package Einfo is\n \n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n+   pragma Inline (Set_Is_Protected_Interface);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n    pragma Inline (Set_Is_Pure_Unit_Access_Type);\n@@ -6744,8 +6800,10 @@ package Einfo is\n    pragma Inline (Set_Is_Renaming_Of_Object);\n    pragma Inline (Set_Is_Shared_Passive);\n    pragma Inline (Set_Is_Statically_Allocated);\n+   pragma Inline (Set_Is_Synchronized_Interface);\n    pragma Inline (Set_Is_Tag);\n    pragma Inline (Set_Is_Tagged_Type);\n+   pragma Inline (Set_Is_Task_Interface);\n    pragma Inline (Set_Is_Thread_Body);\n    pragma Inline (Set_Is_True_Constant);\n    pragma Inline (Set_Is_Unchecked_Union);\n@@ -6786,6 +6844,7 @@ package Einfo is\n    pragma Inline (Set_Original_Array_Type);\n    pragma Inline (Set_Original_Record_Component);\n    pragma Inline (Set_Overridden_Operation);\n+   pragma Inline (Set_Package_Instantiation);\n    pragma Inline (Set_Packed_Array_Type);\n    pragma Inline (Set_Parent_Subtype);\n    pragma Inline (Set_Primitive_Operations);\n@@ -6849,7 +6908,7 @@ package Einfo is\n    --  things here which are small, but not of the canonical attribute\n    --  access/set format that can be handled by xeinfo.\n \n-   pragma Inline (Is_Package);\n+   pragma Inline (Is_Package_Or_Generic_Package);\n    pragma Inline (Is_Wrapper_Package);\n    pragma Inline (Known_RM_Size);\n    pragma Inline (Known_Static_Component_Bit_Offset);"}, {"sha": "3feb7d33aaabf7e4e6d061f9b2d2960492e77e99", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 164, "deletions": 112, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -79,13 +79,6 @@ package body Exp_Ch3 is\n    --  used for attachment of any actions required in its construction.\n    --  It also supplies the source location used for the procedure.\n \n-   procedure Build_Class_Wide_Master (T : Entity_Id);\n-   --  for access to class-wide limited types we must build a task master\n-   --  because some subsequent extension may add a task component. To avoid\n-   --  bringing in the tasking run-time whenever an access-to-class-wide\n-   --  limited type is used, we use the soft-link mechanism and add a level\n-   --  of indirection to calls to routines that manipulate Master_Ids.\n-\n    function Build_Discriminant_Formals\n      (Rec_Id : Entity_Id;\n       Use_Dl : Boolean) return List_Id;\n@@ -651,6 +644,7 @@ package body Exp_Ch3 is\n       M_Id : Entity_Id;\n       Decl : Node_Id;\n       P    : Node_Id;\n+      Par  : Node_Id;\n \n    begin\n       --  Nothing to do if there is no task hierarchy\n@@ -659,6 +653,16 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n+      --  Find declaration that created the access type: either a\n+      --  type declaration, or an object declaration with an\n+      --  access definition, in which case the type is anonymous.\n+\n+      if Is_Itype (T) then\n+         P := Associated_Node_For_Itype (T);\n+      else\n+         P := Parent (T);\n+      end if;\n+\n       --  Nothing to do if we already built a master entity for this scope\n \n       if not Has_Master_Entity (Scope (T)) then\n@@ -677,24 +681,24 @@ package body Exp_Ch3 is\n                Make_Explicit_Dereference (Loc,\n                  New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n-         P := Parent (T);\n          Insert_Before (P, Decl);\n          Analyze (Decl);\n          Set_Has_Master_Entity (Scope (T));\n \n          --  Now mark the containing scope as a task master\n \n-         while Nkind (P) /= N_Compilation_Unit loop\n-            P := Parent (P);\n+         Par := P;\n+         while Nkind (Par) /= N_Compilation_Unit loop\n+            Par := Parent (Par);\n \n             --  If we fall off the top, we are at the outer level, and the\n             --  environment task is our effective master, so nothing to mark.\n \n-            if Nkind (P) = N_Task_Body\n-              or else Nkind (P) = N_Block_Statement\n-              or else Nkind (P) = N_Subprogram_Body\n+            if Nkind (Par) = N_Task_Body\n+              or else Nkind (Par) = N_Block_Statement\n+              or else Nkind (Par) = N_Subprogram_Body\n             then\n-               Set_Is_Task_Master (P, True);\n+               Set_Is_Task_Master (Par, True);\n                exit;\n             end if;\n          end loop;\n@@ -711,7 +715,7 @@ package body Exp_Ch3 is\n           Defining_Identifier => M_Id,\n           Subtype_Mark => New_Reference_To (Standard_Integer, Loc),\n           Name => Make_Identifier (Loc, Name_uMaster));\n-      Insert_Before (Parent (T), Decl);\n+      Insert_Before (P, Decl);\n       Analyze (Decl);\n \n       Set_Master_Id (T, M_Id);\n@@ -1758,10 +1762,18 @@ package body Exp_Ch3 is\n                Aux_N : Node_Id;\n \n             begin\n-               if not Is_Interface (Typ)\n-                 and then Etype (Typ) /= Typ\n-               then\n-                  Init_Secondary_Tags_Internal (Etype (Typ));\n+               if not Is_Interface (Typ) then\n+\n+                  --  Climb to the ancestor (if any) handling private types\n+\n+                  if Present (Full_View (Etype (Typ))) then\n+                     if Full_View (Etype (Typ)) /= Typ then\n+                        Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n+                     end if;\n+\n+                  elsif Etype (Typ) /= Typ then\n+                     Init_Secondary_Tags_Internal (Etype (Typ));\n+                  end if;\n                end if;\n \n                if Present (Abstract_Interfaces (Typ))\n@@ -1824,7 +1836,14 @@ package body Exp_Ch3 is\n             --  interfaces.\n \n             ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n-            Init_Secondary_Tags_Internal (Typ);\n+\n+            --  Handle private types\n+\n+            if Present (Full_View (Typ)) then\n+               Init_Secondary_Tags_Internal (Full_View (Typ));\n+            else\n+               Init_Secondary_Tags_Internal (Typ);\n+            end if;\n          end Init_Secondary_Tags;\n \n       --  Start of processing for Build_Init_Procedure\n@@ -2478,6 +2497,13 @@ package body Exp_Ch3 is\n             return False;\n          end if;\n \n+         --  If it is a type derived from a type with unknown discriminants,\n+         --  we cannot build an initialization procedure for it.\n+\n+         if Has_Unknown_Discriminants (Rec_Id) then\n+            return False;\n+         end if;\n+\n          --  Otherwise we need to generate an initialization procedure if\n          --  Is_CPP_Class is False and at least one of the following applies:\n \n@@ -4547,34 +4573,52 @@ package body Exp_Ch3 is\n                   ADT : Elist_Id := Access_Disp_Table (Def_Id);\n \n                   procedure Add_Secondary_Tables (Typ : Entity_Id);\n-                  --  Comment required ???\n+                  --  Internal subprogram, recursively climb to the ancestors\n \n                   --------------------------\n                   -- Add_Secondary_Tables --\n                   --------------------------\n \n                   procedure Add_Secondary_Tables (Typ : Entity_Id) is\n-                     E      : Entity_Id;\n-                     Result : List_Id;\n+                     E            : Entity_Id;\n+                     Iface        : Elmt_Id;\n+                     Result       : List_Id;\n+                     Suffix_Index : Int;\n \n                   begin\n-                     if Etype (Typ) /= Typ then\n+                     --  Climb to the ancestor (if any) handling private types\n+\n+                     if Present (Full_View (Etype (Typ))) then\n+                        if Full_View (Etype (Typ)) /= Typ then\n+                           Add_Secondary_Tables (Full_View (Etype (Typ)));\n+                        end if;\n+\n+                     elsif Etype (Typ) /= Typ then\n                         Add_Secondary_Tables (Etype (Typ));\n                      end if;\n \n                      if Present (Abstract_Interfaces (Typ))\n-                       and then not Is_Empty_Elmt_List\n-                                      (Abstract_Interfaces (Typ))\n+                       and then\n+                         not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n                      then\n+                        Iface := First_Elmt (Abstract_Interfaces (Typ));\n+                        Suffix_Index := 0;\n+\n                         E := First_Entity (Typ);\n                         while Present (E) loop\n                            if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                              Make_Abstract_Interface_DT\n-                                (AI_Tag          => E,\n+                              Make_Secondary_DT\n+                                (Typ             => Def_Id,\n+                                 Ancestor_Typ    => Typ,\n+                                 Suffix_Index    => Suffix_Index,\n+                                 Iface           => Node (Iface),\n+                                 AI_Tag          => E,\n                                  Acc_Disp_Tables => ADT,\n                                  Result          => Result);\n \n                               Append_Freeze_Actions (Def_Id, Result);\n+                              Suffix_Index := Suffix_Index + 1;\n+                              Next_Elmt (Iface);\n                            end if;\n \n                            Next_Entity (E);\n@@ -4585,7 +4629,14 @@ package body Exp_Ch3 is\n                --  Start of processing to build secondary dispatch tables\n \n                begin\n-                  Add_Secondary_Tables  (Def_Id);\n+                  --  Handle private types\n+\n+                  if Present (Full_View (Def_Id)) then\n+                     Add_Secondary_Tables  (Full_View (Def_Id));\n+                  else\n+                     Add_Secondary_Tables  (Def_Id);\n+                  end if;\n+\n                   Set_Access_Disp_Table (Def_Id, ADT);\n                   Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n                end;\n@@ -4699,9 +4750,14 @@ package body Exp_Ch3 is\n            and then not Is_Interface  (Def_Id)\n            and then not Is_Abstract   (Def_Id)\n            and then not Is_Controlled (Def_Id)\n-           and then Implements_Limited_Interface (Def_Id)\n+           and then\n+             Implements_Interface\n+               (Typ          => Def_Id,\n+                Kind         => Any_Limited_Interface,\n+                Check_Parent => True)\n          then\n-            Append_Freeze_Actions (Def_Id, Make_Disp_Select_Tables (Def_Id));\n+            Append_Freeze_Actions (Def_Id,\n+              Make_Select_Specific_Data_Table (Def_Id));\n          end if;\n       end if;\n    end Freeze_Record_Type;\n@@ -5897,6 +5953,7 @@ package body Exp_Ch3 is\n       --    disp_asynchronous_select\n       --    disp_conditional_select\n       --    disp_get_prim_op_kind\n+      --    disp_get_task_id\n       --    disp_timed_select\n       --  for limited interfaces and tagged types that implement a limited\n       --  interface.\n@@ -5908,50 +5965,36 @@ package body Exp_Ch3 is\n           or else\n              (not Is_Abstract (Tag_Typ)\n                 and then not Is_Controlled (Tag_Typ)\n-                and then Implements_Limited_Interface (Tag_Typ)))\n+              and then\n+                Implements_Interface\n+                  (Typ          => Tag_Typ,\n+                   Kind         => Any_Limited_Interface,\n+                   Check_Parent => True)))\n       then\n-         if Is_Interface (Tag_Typ) then\n-            Append_To (Res,\n-              Make_Abstract_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n-\n-            Append_To (Res,\n-              Make_Abstract_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n-\n-            Append_To (Res,\n-              Make_Abstract_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n-\n-            Append_To (Res,\n-              Make_Abstract_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n+         Append_To (Res,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n \n-         else\n-            Append_To (Res,\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Asynchronous_Select_Spec (Tag_Typ)));\n+         Append_To (Res,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n \n-            Append_To (Res,\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Conditional_Select_Spec (Tag_Typ)));\n+         Append_To (Res,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n \n-            Append_To (Res,\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Get_Prim_Op_Kind_Spec (Tag_Typ)));\n+         Append_To (Res,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Disp_Get_Task_Id_Spec (Tag_Typ)));\n \n-            Append_To (Res,\n-              Make_Subprogram_Declaration (Loc,\n-                Specification =>\n-                  Make_Disp_Timed_Select_Spec (Tag_Typ)));\n-         end if;\n+         Append_To (Res,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Disp_Timed_Select_Spec (Tag_Typ)));\n       end if;\n \n       --  Specs for finalization actions that may be required in case a\n@@ -6310,50 +6353,57 @@ package body Exp_Ch3 is\n       end if;\n \n       --  Generate the bodies for the following primitive operations:\n+\n       --    disp_asynchronous_select\n       --    disp_conditional_select\n       --    disp_get_prim_op_kind\n+      --    disp_get_task_id\n       --    disp_timed_select\n-      --  for tagged types that implement a limited interface.\n+\n+      --  for limited interfaces and tagged types that implement a limited\n+      --  interface. The interface versions will have null bodies.\n \n       if Ada_Version >= Ada_05\n-        and then not Is_Interface  (Tag_Typ)\n-        and then not Is_Abstract   (Tag_Typ)\n-        and then not Is_Controlled (Tag_Typ)\n-        and then Implements_Limited_Interface (Tag_Typ)\n+        and then\n+          ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n+              or else\n+                (not Is_Abstract (Tag_Typ)\n+                   and then not Is_Controlled (Tag_Typ)\n+                   and then\n+                     Implements_Interface\n+                       (Typ          => Tag_Typ,\n+                        Kind         => Any_Limited_Interface,\n+                        Check_Parent => True)))\n       then\n-         Append_To (Res,\n-           Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n-         Append_To (Res,\n-           Make_Disp_Conditional_Select_Body  (Tag_Typ));\n-         Append_To (Res,\n-           Make_Disp_Get_Prim_Op_Kind_Body    (Tag_Typ));\n-         Append_To (Res,\n-           Make_Disp_Timed_Select_Body        (Tag_Typ));\n+         Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n+         Append_To (Res, Make_Disp_Conditional_Select_Body  (Tag_Typ));\n+         Append_To (Res, Make_Disp_Get_Prim_Op_Kind_Body    (Tag_Typ));\n+         Append_To (Res, Make_Disp_Get_Task_Id_Body         (Tag_Typ));\n+         Append_To (Res, Make_Disp_Timed_Select_Body        (Tag_Typ));\n       end if;\n \n       if not Is_Limited_Type (Tag_Typ) then\n \n          --  Body for equality\n \n          if Eq_Needed then\n+            Decl :=\n+              Predef_Spec_Or_Body (Loc,\n+                Tag_Typ => Tag_Typ,\n+                Name    => Eq_Name,\n+                Profile => New_List (\n+                  Make_Parameter_Specification (Loc,\n+                    Defining_Identifier =>\n+                      Make_Defining_Identifier (Loc, Name_X),\n+                    Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n \n-            Decl := Predef_Spec_Or_Body (Loc,\n-              Tag_Typ => Tag_Typ,\n-              Name    => Eq_Name,\n-              Profile => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_X),\n-                  Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n-\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_Y),\n-                  Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n+                  Make_Parameter_Specification (Loc,\n+                    Defining_Identifier =>\n+                      Make_Defining_Identifier (Loc, Name_Y),\n+                    Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n \n-              Ret_Type => Standard_Boolean,\n-              For_Body => True);\n+                Ret_Type => Standard_Boolean,\n+                For_Body => True);\n \n             declare\n                Def          : constant Node_Id := Parent (Tag_Typ);\n@@ -6403,19 +6453,20 @@ package body Exp_Ch3 is\n \n          --  Body for dispatching assignment\n \n-         Decl := Predef_Spec_Or_Body (Loc,\n-           Tag_Typ => Tag_Typ,\n-           Name    => Name_uAssign,\n-           Profile => New_List (\n-             Make_Parameter_Specification (Loc,\n-               Defining_Identifier => Make_Defining_Identifier (Loc, Name_X),\n-               Out_Present         => True,\n-               Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n-\n-             Make_Parameter_Specification (Loc,\n-               Defining_Identifier => Make_Defining_Identifier (Loc, Name_Y),\n-               Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n-           For_Body => True);\n+         Decl :=\n+           Predef_Spec_Or_Body (Loc,\n+             Tag_Typ => Tag_Typ,\n+             Name    => Name_uAssign,\n+             Profile => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier => Make_Defining_Identifier (Loc, Name_X),\n+                 Out_Present         => True,\n+                 Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n+\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier => Make_Defining_Identifier (Loc, Name_Y),\n+                 Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n+             For_Body => True);\n \n          Set_Handled_Statement_Sequence (Decl,\n            Make_Handled_Sequence_Of_Statements (Loc, New_List (\n@@ -6541,6 +6592,7 @@ package body Exp_Ch3 is\n       return\n         not (Is_Limited_Type (Typ)\n                and then not Has_Inheritable_Stream_Attribute)\n+          and then not Has_Unknown_Discriminants (Typ)\n           and then RTE_Available (RE_Tag)\n           and then RTE_Available (RE_Root_Stream_Type)\n           and then not Restriction_Active (No_Dispatch)"}, {"sha": "ce2b7990a11b57ae38e9a4e8be9360a7ce7aced0", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,12 +40,21 @@ package Exp_Ch3 is\n    procedure Expand_Previous_Access_Type (Def_Id : Entity_Id);\n    --  For a full type declaration that contains tasks, or that is a task,\n    --  check whether there exists an access type whose designated type is an\n-   --  incomplete declarations for the current composite type. If so, build\n-   --  the master for that access type, now that it is known to denote an\n-   --  object with tasks.\n+   --  incomplete declarations for the current composite type. If so, build the\n+   --  master for that access type, now that it is known to denote an object\n+   --  with tasks.\n \n    procedure Expand_Record_Extension (T : Entity_Id; Def : Node_Id);\n-   --  Add a field _parent in the extension part of the record.\n+   --  Add a field _parent in the extension part of the record\n+\n+   procedure Build_Class_Wide_Master (T : Entity_Id);\n+   --  For access to class-wide limited types we must build a task master\n+   --  because some subsequent extension may add a task component. To avoid\n+   --  bringing in the tasking run-time whenever an access-to-class-wide\n+   --  limited type is used, we use the soft-link mechanism and add a level of\n+   --  indirection to calls to routines that manipulate Master_Ids. This must\n+   --  also be used for anonymous access types whose designated type is a task\n+   --  or synchronized interface.\n \n    procedure Build_Discr_Checking_Funcs (N : Node_Id);\n    --  Builds function which checks whether the component name is consistent\n@@ -66,10 +75,10 @@ package Exp_Ch3 is\n    --  constructed tree, and Typ is the type of the entity (the initialization\n    --  procedure of the base type is the procedure that actually gets called).\n    --  In_Init_Proc has to be set to True when the call is itself in an init\n-   --  proc in order to enable the use of discriminals. Enclos_type is the\n-   --  type of the init proc and it is used for various expansion cases\n-   --  including the case where Typ is a task type which is a array component,\n-   --  the indices of the enclosing type are used to build the string that\n+   --  proc in order to enable the use of discriminals. Enclos_type is the type\n+   --  of the init proc and it is used for various expansion cases including\n+   --  the case where Typ is a task type which is a array component, the\n+   --  indices of the enclosing type are used to build the string that\n    --  identifies each task at runtime.\n    --\n    --  Discr_Map is used to replace discriminants by their discriminals in\n@@ -84,33 +93,32 @@ package Exp_Ch3 is\n \n    function Freeze_Type (N : Node_Id) return Boolean;\n    --  This function executes the freezing actions associated with the given\n-   --  freeze type node N and returns True if the node is to be deleted.\n-   --  We delete the node if it is present just for front end purpose and\n-   --  we don't want Gigi to see the node.  This function can't delete the\n-   --  node itself since it would confuse any remaining processing of the\n-   --  freeze node.\n+   --  freeze type node N and returns True if the node is to be deleted. We\n+   --  delete the node if it is present just for front end purpose and we don't\n+   --  want Gigi to see the node. This function can't delete the node itself\n+   --  since it would confuse any remaining processing of the freeze node.\n \n    function Needs_Simple_Initialization (T : Entity_Id) return Boolean;\n    --  Certain types need initialization even though there is no specific\n-   --  initialization routine. In this category are access types (which\n-   --  need initializing to null), packed array types whose implementation\n-   --  is a modular type, and all scalar types if Normalize_Scalars is set,\n-   --  as well as private types whose underlying type is present and meets\n-   --  any of these criteria. Finally, descendants of String and Wide_String\n-   --  also need initialization in Initialize/Normalize_Scalars mode.\n+   --  initialization routine. In this category are access types (which need\n+   --  initializing to null), packed array types whose implementation is a\n+   --  modular type, and all scalar types if Normalize_Scalars is set, as well\n+   --  as private types whose underlying type is present and meets any of these\n+   --  criteria. Finally, descendants of String and Wide_String also need\n+   --  initialization in Initialize/Normalize_Scalars mode.\n \n    function Get_Simple_Init_Val\n      (T    : Entity_Id;\n       Loc  : Source_Ptr;\n       Size : Uint := No_Uint) return Node_Id;\n-   --  For a type which Needs_Simple_Initialization (see above), prepares\n-   --  the tree for an expression representing the required initial value.\n-   --  Loc is the source location used in constructing this tree which is\n-   --  returned as the result of the call. The Size parameter indicates the\n-   --  target size of the object if it is known (indicated by a value that\n-   --  is not No_Uint and is greater than zero). If Size is not given (Size\n-   --  set to No_Uint, or non-positive), then the Esize of T is used as an\n-   --  estimate of the Size. The object size is needed to prepare a known\n-   --  invalid value for use by Normalize_Scalars.\n+   --  For a type which Needs_Simple_Initialization (see above), prepares the\n+   --  tree for an expression representing the required initial value. Loc is\n+   --  the source location used in constructing this tree which is returned as\n+   --  the result of the call. The Size parameter indicates the target size of\n+   --  the object if it is known (indicated by a value that is not No_Uint and\n+   --  is greater than zero). If Size is not given (Size set to No_Uint, or\n+   --  non-positive), then the Esize of T is used as an estimate of the Size.\n+   --  The object size is needed to prepare a known invalid value for use by\n+   --  Normalize_Scalars.\n \n end Exp_Ch3;"}, {"sha": "76dde0e73cbd3029d1ab7055424e65ec1c2e42da", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 233, "deletions": 65, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -99,10 +99,11 @@ package body Exp_Ch6 is\n    --  we have an infinite recursion.\n \n    procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n-   --  For each actual of an in-out parameter which is a numeric conversion\n-   --  of the form T(A), where A denotes a variable, we insert the declaration:\n+   --  For each actual of an in-out or out parameter which is a numeric\n+   --  (view) conversion of the form T (A), where A denotes a variable,\n+   --  we insert the declaration:\n    --\n-   --    Temp : T := T (A);\n+   --    Temp : T[ := T (A)];\n    --\n    --  prior to the call. Then we replace the actual with a reference to Temp,\n    --  and append the assignment:\n@@ -1464,6 +1465,48 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n+      --  Ada 2005 (AI-345): We have a procedure call as a triggering\n+      --  alternative in an asynchronous select or as an entry call in\n+      --  a conditional or timed select. Check whether the procedure call\n+      --  is a renaming of an entry and rewrite it as an entry call.\n+\n+      if Ada_Version >= Ada_05\n+        and then Nkind (N) = N_Procedure_Call_Statement\n+        and then\n+           ((Nkind (Parent (N)) = N_Triggering_Alternative\n+               and then Triggering_Statement (Parent (N)) = N)\n+          or else\n+            (Nkind (Parent (N)) = N_Entry_Call_Alternative\n+               and then Entry_Call_Statement (Parent (N)) = N))\n+      then\n+         declare\n+            Ren_Decl : Node_Id;\n+            Ren_Root : Entity_Id := Subp;\n+\n+         begin\n+            --  This may be a chain of renamings, find the root\n+\n+            if Present (Alias (Ren_Root)) then\n+               Ren_Root := Alias (Ren_Root);\n+            end if;\n+\n+            if Present (Original_Node (Parent (Parent (Ren_Root)))) then\n+               Ren_Decl := Original_Node (Parent (Parent (Ren_Root)));\n+\n+               if Nkind (Ren_Decl) = N_Subprogram_Renaming_Declaration then\n+                  Rewrite (N,\n+                    Make_Entry_Call_Statement (Loc,\n+                      Name =>\n+                        New_Copy_Tree (Name (Ren_Decl)),\n+                      Parameter_Associations =>\n+                        New_Copy_List_Tree (Parameter_Associations (N))));\n+\n+                  return;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  First step, compute extra actuals, corresponding to any\n       --  Extra_Formals present. Note that we do not access Extra_Formals\n       --  directly, instead we simply note the presence of the extra\n@@ -1558,13 +1601,29 @@ package body Exp_Ch6 is\n                      Act_Prev := Expression (Act_Prev);\n                   end loop;\n \n-                  Add_Extra_Actual (\n-                    Make_Attribute_Reference (Sloc (Prev),\n-                      Prefix =>\n-                        Duplicate_Subexpr_No_Checks\n-                          (Act_Prev, Name_Req => True),\n-                      Attribute_Name => Name_Constrained),\n-                    Extra_Constrained (Formal));\n+                  --  If the expression is a conversion of a dereference,\n+                  --  this is internally generated code that manipulates\n+                  --  addresses, e.g. when building interface tables. No\n+                  --  check should occur in this case, and the discriminated\n+                  --  object is not directly a hand.\n+\n+                  if not Comes_From_Source (Actual)\n+                    and then Nkind (Actual) = N_Unchecked_Type_Conversion\n+                    and then Nkind (Act_Prev) = N_Explicit_Dereference\n+                  then\n+                     Add_Extra_Actual\n+                       (New_Occurrence_Of (Standard_False, Loc),\n+                        Extra_Constrained (Formal));\n+\n+                  else\n+                     Add_Extra_Actual\n+                       (Make_Attribute_Reference (Sloc (Prev),\n+                        Prefix =>\n+                          Duplicate_Subexpr_No_Checks\n+                            (Act_Prev, Name_Req => True),\n+                        Attribute_Name => Name_Constrained),\n+                        Extra_Constrained (Formal));\n+                  end if;\n                end;\n             end if;\n          end if;\n@@ -1591,32 +1650,32 @@ package body Exp_Ch6 is\n                      pragma Assert (Present (Parm_Ent));\n \n                      if Present (Extra_Accessibility (Parm_Ent)) then\n-                        Add_Extra_Actual (\n-                          New_Occurrence_Of\n-                            (Extra_Accessibility (Parm_Ent), Loc),\n-                          Extra_Accessibility (Formal));\n+                        Add_Extra_Actual\n+                          (New_Occurrence_Of\n+                             (Extra_Accessibility (Parm_Ent), Loc),\n+                           Extra_Accessibility (Formal));\n \n                      --  If the actual access parameter does not have an\n                      --  associated extra formal providing its scope level,\n                      --  then treat the actual as having library-level\n                      --  accessibility.\n \n                      else\n-                        Add_Extra_Actual (\n-                          Make_Integer_Literal (Loc,\n-                            Intval => Scope_Depth (Standard_Standard)),\n-                          Extra_Accessibility (Formal));\n+                        Add_Extra_Actual\n+                          (Make_Integer_Literal (Loc,\n+                           Intval => Scope_Depth (Standard_Standard)),\n+                           Extra_Accessibility (Formal));\n                      end if;\n                   end;\n \n                --  The actual is a normal access value, so just pass the\n                --  level of the actual's access type.\n \n                else\n-                  Add_Extra_Actual (\n-                    Make_Integer_Literal (Loc,\n-                      Intval => Type_Access_Level (Etype (Prev_Orig))),\n-                    Extra_Accessibility (Formal));\n+                  Add_Extra_Actual\n+                    (Make_Integer_Literal (Loc,\n+                     Intval => Type_Access_Level (Etype (Prev_Orig))),\n+                     Extra_Accessibility (Formal));\n                end if;\n \n             else\n@@ -3092,6 +3151,12 @@ package body Exp_Ch6 is\n       --  If the call is the right side of an assignment or the expression in\n       --  an object declaration, we don't need to create a temp as the left\n       --  side will already trigger stack checking if necessary.\n+      --\n+      --  If the call is a component in an extension aggregate, it will be\n+      --  expanded into assignments as well, so no temporary is needed. This\n+      --  also solves the problem of functions returning types with unknown\n+      --  discriminants, where it is not possible to declare an object of the\n+      --  type altogether.\n \n       ---------------------------\n       -- Returned_By_Reference --\n@@ -3143,6 +3208,9 @@ package body Exp_Ch6 is\n                 and then Expression (Parent (N)) = N\n                   and then Nkind (Parent (Parent (N))) = N_Aggregate\n                     and then Rhs_Of_Assign_Or_Decl (Parent (Parent (N))))\n+           or else\n+             (Nkind (Parent (N)) = N_Extension_Aggregate\n+               and then Is_Private_Type (Etype (Typ)))\n          then\n             return True;\n          else\n@@ -4052,8 +4120,8 @@ package body Exp_Ch6 is\n    -----------------------\n \n    procedure Freeze_Subprogram (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      E         : constant Entity_Id  := Entity (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      E   : constant Entity_Id  := Entity (N);\n \n       procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id);\n       --  (Ada 2005): Check if the primitive E covers some interface already\n@@ -4068,6 +4136,10 @@ package body Exp_Ch6 is\n       --  immediate ancestor associated with the interface; otherwise Prim and\n       --  Ancestor_Iface_Prim have the same info.\n \n+      procedure Register_Predefined_DT_Entry (Prim : Entity_Id);\n+      --  (Ada 2005): Register a predefined primitive in all the secondary\n+      --  dispatch tables of its primitive type.\n+\n       -------------------------------------------\n       -- Check_Overriding_Inherited_Interfaces --\n       -------------------------------------------\n@@ -4090,11 +4162,18 @@ package body Exp_Ch6 is\n          --  Get the entity associated with this primitive operation\n \n          Typ := Scope (DTC_Entity (E));\n-         while Etype (Typ) /= Typ loop\n+         loop\n+            exit when Etype (Typ) = Typ\n+              or else (Present (Full_View (Etype (Typ)))\n+                         and then Full_View (Etype (Typ)) = Typ);\n \n-            --  Climb to the immediate ancestor\n+            --  Climb to the immediate ancestor handling private types\n \n-            Typ := Etype (Typ);\n+            if Present (Full_View (Etype (Typ))) then\n+               Typ := Full_View (Etype (Typ));\n+            else\n+               Typ := Etype (Typ);\n+            end if;\n \n             if Present (Abstract_Interfaces (Typ)) then\n \n@@ -4192,35 +4271,40 @@ package body Exp_Ch6 is\n          if not Present (Ancestor_Iface_Prim) then\n             Prim_Typ  := Scope (DTC_Entity (Alias (Prim)));\n             Iface_Typ := Scope (DTC_Entity (Abstract_Interface_Alias (Prim)));\n-            Iface_Tag := Find_Interface_Tag\n-                           (T     => Prim_Typ,\n-                            Iface => Iface_Typ);\n \n             --  Generate the code of the thunk only when this primitive\n             --  operation is associated with a secondary dispatch table.\n \n-            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n-               Thunk_Id  := Make_Defining_Identifier (Loc,\n-                              New_Internal_Name ('T'));\n-               New_Thunk :=\n-                 Expand_Interface_Thunk\n-                   (N           => Prim,\n-                    Thunk_Alias => Alias (Prim),\n-                    Thunk_Id    => Thunk_Id,\n-                    Thunk_Tag   => Iface_Tag);\n-\n-               Insert_After (N, New_Thunk);\n-\n-               Iface_DT_Ptr :=\n-                 Find_Interface_ADT\n-                   (T     => Prim_Typ,\n-                    Iface => Iface_Typ);\n-\n-               Insert_After (New_Thunk,\n-                 Fill_Secondary_DT_Entry (Sloc (Prim),\n-                   Prim         => Prim,\n-                   Iface_DT_Ptr => Iface_DT_Ptr,\n-                   Thunk_Id     => Thunk_Id));\n+            if Is_Interface (Iface_Typ) then\n+               Iface_Tag := Find_Interface_Tag\n+                              (T     => Prim_Typ,\n+                               Iface => Iface_Typ);\n+\n+               if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n+                  Thunk_Id  :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => New_Internal_Name ('T'));\n+\n+                  New_Thunk :=\n+                    Expand_Interface_Thunk\n+                      (N           => Prim,\n+                       Thunk_Alias => Alias (Prim),\n+                       Thunk_Id    => Thunk_Id,\n+                       Thunk_Tag   => Iface_Tag);\n+\n+                  Insert_After (N, New_Thunk);\n+\n+                  Iface_DT_Ptr :=\n+                    Find_Interface_ADT\n+                      (T     => Prim_Typ,\n+                       Iface => Iface_Typ);\n+\n+                  Insert_After (New_Thunk,\n+                    Fill_Secondary_DT_Entry (Sloc (Prim),\n+                      Prim         => Prim,\n+                      Iface_DT_Ptr => Iface_DT_Ptr,\n+                      Thunk_Id     => Thunk_Id));\n+               end if;\n             end if;\n \n          else\n@@ -4243,8 +4327,9 @@ package body Exp_Ch6 is\n             --    type T is new I with ...\n \n             if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n-               Thunk_Id  := Make_Defining_Identifier (Loc,\n-                              New_Internal_Name ('T'));\n+               Thunk_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('T'));\n \n                if Present (Alias (Prim)) then\n                   Prim_Op := Alias (Prim);\n@@ -4275,6 +4360,70 @@ package body Exp_Ch6 is\n          end if;\n       end Register_Interface_DT_Entry;\n \n+      ----------------------------------\n+      -- Register_Predefined_DT_Entry --\n+      ----------------------------------\n+\n+      procedure Register_Predefined_DT_Entry (Prim : Entity_Id) is\n+         Iface_DT_Ptr : Elmt_Id;\n+         Iface_Tag    : Entity_Id;\n+         Iface_Typ    : Elmt_Id;\n+         New_Thunk    : Entity_Id;\n+         Prim_Typ     : Entity_Id;\n+         Thunk_Id     : Entity_Id;\n+\n+      begin\n+         Prim_Typ := Scope (DTC_Entity (Prim));\n+\n+         if not Present (Access_Disp_Table (Prim_Typ))\n+           or else not Present (Abstract_Interfaces (Prim_Typ))\n+         then\n+            return;\n+         end if;\n+\n+         --  Skip the first acces-to-dispatch-table pointer since it leads\n+         --  to the primary dispatch table. We are only concerned with the\n+         --  secondary dispatch table pointers. Note that the access-to-\n+         --  dispatch-table pointer corresponds to the first implemented\n+         --  interface retrieved below.\n+\n+         Iface_DT_Ptr := Next_Elmt (First_Elmt (Access_Disp_Table (Prim_Typ)));\n+         Iface_Typ := First_Elmt (Abstract_Interfaces (Prim_Typ));\n+         while Present (Iface_DT_Ptr) and then Present (Iface_Typ) loop\n+            Iface_Tag := Find_Interface_Tag (Prim_Typ, Node (Iface_Typ));\n+            pragma Assert (Present (Iface_Tag));\n+\n+            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n+               Thunk_Id := Make_Defining_Identifier (Loc,\n+                             New_Internal_Name ('T'));\n+\n+               New_Thunk :=\n+                 Expand_Interface_Thunk\n+                  (N           => Prim,\n+                   Thunk_Alias => Prim,\n+                   Thunk_Id    => Thunk_Id,\n+                   Thunk_Tag   => Iface_Tag);\n+\n+               Insert_After (N, New_Thunk);\n+               Insert_After (New_Thunk,\n+                 Make_DT_Access_Action (Node (Iface_Typ),\n+                   Action => Set_Prim_Op_Address,\n+                   Args   => New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (Node (Iface_DT_Ptr), Loc)),\n+\n+                     Make_Integer_Literal (Loc, DT_Position (Prim)),\n+\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Reference_To (Thunk_Id, Loc),\n+                       Attribute_Name => Name_Address))));\n+            end if;\n+\n+            Next_Elmt (Iface_DT_Ptr);\n+            Next_Elmt (Iface_Typ);\n+         end loop;\n+      end Register_Predefined_DT_Entry;\n+\n    --  Start of processing for Freeze_Subprogram\n \n    begin\n@@ -4297,19 +4446,38 @@ package body Exp_Ch6 is\n               Fill_DT_Entry (Sloc (N), Prim => E));\n \n          else\n-            --  Ada 2005 (AI-251): Check if this entry corresponds with\n-            --  a subprogram that covers an abstract interface type.\n+            declare\n+               Typ : constant Entity_Id := Scope (DTC_Entity (E));\n \n-            if Present (Abstract_Interface_Alias (E)) then\n-               Register_Interface_DT_Entry (E);\n+            begin\n+               --  There is no dispatch table associated with abstract\n+               --  interface types; each type implementing interfaces\n+               --  will fill the associated secondary DT entries.\n \n-            --  Common case: Primitive subprogram\n+               if not Is_Interface (Typ)\n+                 or else Present (Alias (E))\n+               then\n+                  --  Ada 2005 (AI-251): Check if this entry corresponds with\n+                  --  a subprogram that covers an abstract interface type.\n \n-            else\n-               Insert_After (N,\n-                 Fill_DT_Entry (Sloc (N), Prim => E));\n-               Check_Overriding_Inherited_Interfaces (E);\n-            end if;\n+                  if Present (Abstract_Interface_Alias (E)) then\n+                     Register_Interface_DT_Entry (E);\n+\n+                  --  Common case: Primitive subprogram\n+\n+                  else\n+                     --  Generate thunks for all the predefined operations\n+\n+                     if Is_Predefined_Dispatching_Operation (E) then\n+                        Register_Predefined_DT_Entry (E);\n+                     end if;\n+\n+                     Insert_After (N,\n+                       Fill_DT_Entry (Sloc (N), Prim => E));\n+                     Check_Overriding_Inherited_Interfaces (E);\n+                  end if;\n+               end if;\n+            end;\n          end if;\n       end if;\n "}, {"sha": "b0bad8c5718a4cd5acdc5afa35913fef1a9d9cc7", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -1793,6 +1793,13 @@ package body Exp_Ch7 is\n                   return The_Parent;\n                end if;\n \n+            --  A raise statement can be wrapped. This will arise when the\n+            --  expression in a raise_with_expression uses the secondary\n+            --  stack, for example.\n+\n+            when N_Raise_Statement  =>\n+               return The_Parent;\n+\n             --  If the expression is within the iteration scheme of a loop,\n             --  we must create a declaration for it, followed by an assignment\n             --  in order to have a usable statement to wrap.\n@@ -2728,13 +2735,27 @@ package body Exp_Ch7 is\n       Utyp := Underlying_Type (Base_Type (Utyp));\n       Set_Assignment_OK (Cref);\n \n-      --  Deal with non-tagged derivation of private views\n+      --  Deal with non-tagged derivation of private views. If the parent is\n+      --  now known to be protected, the finalization routine is the one\n+      --  defined on the corresponding record of the ancestor (corresponding\n+      --  records do not automatically inherit operations, but maybe they\n+      --  should???)\n \n       if Is_Untagged_Derivation (Typ) then\n-         Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n+         if Is_Protected_Type (Typ) then\n+            Utyp := Corresponding_Record_Type (Root_Type (Base_Type (Typ)));\n+         else\n+            Utyp := Underlying_Type (Root_Type (Base_Type (Typ)));\n+         end if;\n+\n          Cref := Unchecked_Convert_To (Utyp, Cref);\n+\n+         --  We need to set Assignment_OK to prevent problems with unchecked\n+         --  conversions, where we do not want them to be converted back in the\n+         --  case of untagged record derivation (see code in Make_*_Call\n+         --  procedures for similar situations).\n+\n          Set_Assignment_OK (Cref);\n-         --  To prevent problems with UC see 1.156 RH ???\n       end if;\n \n       --  If the underlying_type is a subtype, we are dealing with"}, {"sha": "3943dc4dbc05bcf7c311d469f9472a8355022817", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1057, "deletions": 856, "changes": 1913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088"}, {"sha": "baa5036d821aee76e0f54fbb5f569782fff22570", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -311,13 +311,21 @@ package Exp_Ch9 is\n    --  protected type.\n \n    procedure Set_Privals\n-      (Dec : Node_Id;\n-       Op  : Node_Id;\n-       Loc : Source_Ptr);\n+      (Dec           : Node_Id;\n+       Op            : Node_Id;\n+       Loc           : Source_Ptr;\n+       After_Barrier : Boolean := False);\n    --  Associates a new set of privals (placeholders for later access to\n    --  private components of protected objects) with the private object\n    --  declarations of a protected object. These will be used to expand\n    --  the references to private objects in the next protected\n    --  subprogram or entry body to be expanded.\n+   --\n+   --  The flag After_Barrier indicates whether this is called after building\n+   --  the barrier function for an entry body. This flag determines whether\n+   --  the privals should have source names (which simplifies debugging) or\n+   --  internally generated names. Entry barriers contain no debuggable code,\n+   --  and there may be visibility conflicts between an entry index and a\n+   --  a prival, so  privals for barrier function have internal names.\n \n end Exp_Ch9;"}, {"sha": "8281f154183908ae9bd94b4c66a6c290e70fd4ed", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -134,7 +134,7 @@ package body Exp_Dbug is\n    --  used to determine whether encoding is required for a discrete type.\n \n    procedure Output_Homonym_Numbers_Suffix;\n-   --  If homonym numbers are stored, then output them into Name_Buffer.\n+   --  If homonym numbers are stored, then output them into Name_Buffer\n \n    procedure Prepend_String_To_Buffer (S : String);\n    --  Prepend given string to the contents of the string buffer, updating\n@@ -250,9 +250,9 @@ package body Exp_Dbug is\n       then\n          return True;\n \n-      --  Here we check if the static bounds match the natural size, which\n-      --  is the size passed through with the debugging information. This\n-      --  is the Esize rounded up to 8, 16, 32 or 64 as appropriate.\n+      --  Here we check if the static bounds match the natural size, which is\n+      --  the size passed through with the debugging information. This is the\n+      --  Esize rounded up to 8, 16, 32 or 64 as appropriate.\n \n       else\n          declare\n@@ -305,12 +305,12 @@ package body Exp_Dbug is\n       Def : Entity_Id;\n \n       function Output_Subscript (N : Node_Id; S : String) return Boolean;\n-      --  Outputs a single subscript value as ?nnn (subscript is compile\n-      --  time known value with value nnn) or as ?e (subscript is local\n-      --  constant with name e), where S supplies the proper string to\n-      --  use for ?. Returns False if the subscript is not of an appropriate\n-      --  type to output in one of these two forms. The result is prepended\n-      --  to the name stored in Name_Buffer.\n+      --  Outputs a single subscript value as ?nnn (subscript is compile time\n+      --  known value with value nnn) or as ?e (subscript is local constant\n+      --  with name e), where S supplies the proper string to use for ?.\n+      --  Returns False if the subscript is not of an appropriate type to\n+      --  output in one of these two forms. The result is prepended to the\n+      --  name stored in Name_Buffer.\n \n       ----------------------\n       -- Output_Subscript --\n@@ -358,9 +358,9 @@ package body Exp_Dbug is\n          when N_Package_Renaming_Declaration =>\n             Add_Str_To_Name_Buffer (\"___XRP\");\n \n-            --  If it is a child unit create a fully qualified name,\n-            --  to disambiguate multiple child units with the same\n-            --  name and different parents.\n+            --  If it is a child unit create a fully qualified name, to\n+            --  disambiguate multiple child units with the same name and\n+            --  different parents.\n \n             if Is_Child_Unit (Ent) then\n                Prepend_String_To_Buffer (\"__\");\n@@ -386,8 +386,8 @@ package body Exp_Dbug is\n \n             when N_Expanded_Name =>\n \n-               --  The entity field for an N_Expanded_Name is on the\n-               --  expanded name node itself, so we are done here too.\n+               --  The entity field for an N_Expanded_Name is on the expanded\n+               --  name node itself, so we are done here too.\n \n                exit;\n \n@@ -713,6 +713,7 @@ package body Exp_Dbug is\n          --  If this is a library level subprogram (i.e. a subprogram that is a\n          --  compilation unit other than a subunit), then we prepend _ada_ to\n          --  ensure distinctions required as described in the spec.\n+\n          --  Check explicitly for child units, because those are not flagged\n          --  as Compilation_Units by lib. Should they be ???\n \n@@ -880,6 +881,39 @@ package body Exp_Dbug is\n       end if;\n    end Get_Variant_Encoding;\n \n+   ------------------------------------\n+   -- Get_Secondary_DT_External_Name --\n+   ------------------------------------\n+\n+   procedure Get_Secondary_DT_External_Name\n+     (Typ             : Entity_Id;\n+      Ancestor_Typ    : Entity_Id;\n+      Suffix_Index    : Int) is\n+   begin\n+      Get_External_Name (Typ, Has_Suffix => False);\n+\n+      if Ancestor_Typ /= Typ then\n+         declare\n+            Len      : constant Natural := Name_Len;\n+            Save_Str : constant String (1 .. Name_Len)\n+                         := Name_Buffer (1 .. Name_Len);\n+         begin\n+            Get_External_Name (Ancestor_Typ, Has_Suffix => False);\n+\n+            --  Append the extended name of the ancestor to the\n+            --  extended name of Typ\n+\n+            Name_Buffer (Len + 2 .. Len + Name_Len + 1) :=\n+              Name_Buffer (1 .. Name_Len);\n+            Name_Buffer (1 .. Len) := Save_Str;\n+            Name_Buffer (Len + 1) := '_';\n+            Name_Len := Len + Name_Len + 1;\n+         end;\n+      end if;\n+\n+      Add_Nat_To_Name_Buffer (Suffix_Index);\n+   end Get_Secondary_DT_External_Name;\n+\n    ---------------------------------\n    -- Make_Packed_Array_Type_Name --\n    ---------------------------------\n@@ -1166,7 +1200,6 @@ package body Exp_Dbug is\n          else\n             Add_Char_To_Name_Buffer ('X');\n          end if;\n-\n       end Set_BNPE_Suffix;\n \n       ---------------------\n@@ -1338,7 +1371,6 @@ package body Exp_Dbug is\n             exit;\n          end if;\n       end loop;\n-\n    end Strip_Suffixes;\n \n end Exp_Dbug;"}, {"sha": "ccd80f38f8a28be16bbe82da0f524907ef548258", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -360,7 +360,7 @@ package Exp_Dbug is\n       --  Operations generated for protected entries follow the same encoding.\n       --  Each entry results in two suprograms: a procedure that holds the\n       --  entry body, and a function that holds the evaluation of the barrier.\n-      --  The names of these subprograms include the prefix 'E' or 'B' res-\n+      --  The names of these subprograms include the prefix '_E' or '_B' res-\n       --  pectively. The names also include a numeric suffix to render them\n       --  unique in the presence of overloaded entries.\n \n@@ -382,8 +382,8 @@ package Exp_Dbug is\n       --    lock_setN\n       --    lock_setP\n \n-      --    lock_update1sE\n-      --    lock_udpate2sB\n+      --    lock_update_E1s\n+      --    lock_udpate_B2s\n \n       --  If the protected type implements at least one interface, the\n       --  following additional operations are created:\n@@ -538,6 +538,12 @@ package Exp_Dbug is\n       --  field, and neither the outer structure name, nor the field name\n       --  should appear when the value is printed.\n \n+      --  When the debugger sees a record named REP being a field inside\n+      --  another record, it should treat the fields inside REP as being\n+      --  part of the outer record (this REP field is only present for\n+      --  code generation purposes). The REP record should not appear in\n+      --  the values printed by the debugger.\n+\n       -----------------------\n       -- Fixed-Point Types --\n       -----------------------\n@@ -1432,6 +1438,66 @@ package Exp_Dbug is\n    --  the second enumeration literal would be named QU43 and the\n    --  value assigned to it would be 1.\n \n+   -----------------------------------------------\n+   -- Secondary Dispatch tables of tagged types --\n+   -----------------------------------------------\n+\n+   procedure Get_Secondary_DT_External_Name\n+     (Typ          : Entity_Id;\n+      Ancestor_Typ : Entity_Id;\n+      Suffix_Index : Int);\n+   --  Set Name_Buffer and Name_Len to the external name of one secondary\n+   --  dispatch table of Typ. If the interface has been inherited from some\n+   --  ancestor then Ancestor_Typ is such node (in this case the secondary\n+   --  DT is needed to handle overriden primitives); if there is no such\n+   --  ancestor then  Ancestor_Typ is equal to Typ.\n+   --\n+   --  Internal rule followed for the generation of the external name:\n+   --\n+   --  Case 1. If the secondary dispatch has not been inherited from some\n+   --          ancestor of Typ then the external name is composed as\n+   --          follows:\n+   --             External_Name (Typ) + Suffix_Number + 'P'\n+   --\n+   --  Case 2. if the secondary dispatch table has been inherited from some\n+   --          ancestor then the external name is composed as follows:\n+   --             External_Name (Typ) + '_' + External_Name (Ancestor_Typ)\n+   --               + Suffix_Number + 'P'\n+   --\n+   --  Note: We have to use the external names (instead of simply their\n+   --  names) to protect the frontend against programs that give the same\n+   --  name to all the interfaces and use the expanded name to reference\n+   --  them. The Suffix_Number is used to differentiate all the secondary\n+   --  dispatch tables of a given type.\n+   --\n+   --  Examples:\n+   --\n+   --        package Pkg1 is | package Pkg2 is | package Pkg3 is\n+   --          type Typ is   |   type Typ is   |   type Typ is\n+   --            interface;  |     interface;  |     interface;\n+   --        end Pkg1;       | end Pkg;        | end Pkg3;\n+   --\n+   --  with Pkg1, Pkg2, Pkg3;\n+   --  package Case_1 is\n+   --    type Typ is new Pkg1.Typ and Pkg2.Typ and Pkg3.Typ with ...\n+   --  end Case_1;\n+   --\n+   --  with Case_1;\n+   --  package Case_2 is\n+   --    type Typ is new Case_1.Typ with ...\n+   --  end Case_2;\n+   --\n+   --  These are the external names generated for Case_1.Typ (note that\n+   --  Pkg1.Typ is associated with the Primary Dispatch Table, because it\n+   --  is the the parent of this type, and hence no external name is\n+   --  generated for it).\n+   --      case_1__typ0P   (associated with Pkg2.Typ)\n+   --      case_1__typ1P   (associated with Pkg3.Typ)\n+   --\n+   --  These are the external names generated for Case_2.Typ:\n+   --      case_2__typ_case_1__typ0P\n+   --      case_2__typ_case_1__typ1P\n+\n    ----------------------------\n    -- Effect of Optimization --\n    ----------------------------"}, {"sha": "20e769e180435e91d95d6e875d7867448a764b16", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1731, "deletions": 1293, "changes": 3024, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088"}, {"sha": "bdc1417d4c4bd462990af477fa3efb8418d3d139", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 183, "deletions": 22, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,8 +28,144 @@\n --  dispatching expansion.\n \n with Types; use Types;\n+\n package Exp_Disp is\n \n+   -------------------------------------\n+   -- Predefined primitive operations --\n+   -------------------------------------\n+\n+   --  The predefined primitive operations (PPOs) are subprograms generated\n+   --  by GNAT for a particular tagged type. Their role is to provide support\n+   --  for different Ada language features such as the attribute 'Size or\n+   --  handling of dispatching triggers in select statements. PPOs are created\n+   --  when a tagged type is expanded or frozen. These subprograms are later\n+   --  collected and inserted into the dispatch table of a tagged type at\n+   --  fixed positions. Some of the PPOs that manipulate data in tagged objects\n+   --  require the generation of thunks.\n+\n+   --  List of predefined primitive operations\n+\n+   --    Leading underscores designate reserved names. Bracketed numerical\n+   --    values represent dispatch table slot numbers.\n+\n+   --      _Size (1) - implementation of the attribute 'Size for any tagged\n+   --      type. Constructs of the form Prefix'Size are converted into\n+   --      Prefix._Size.\n+\n+   --      _Alignment (2) - implementation of the attribute 'Alignment for\n+   --      any tagged type. Constructs of the form Prefix'Alignment are\n+   --      converted into Prefix._Alignment.\n+\n+   --      TSS_Stream_Read (3) - implementation of the stream attribute Read\n+   --      for any tagged type.\n+\n+   --      TSS_Stream_Write (4) - implementation of the stream attribute Write\n+   --      for any tagged type.\n+\n+   --      TSS_Stream_Input (5) - implementation of the stream attribute Input\n+   --      for any tagged type.\n+\n+   --      TSS_Stream_Output (6) - implementation of the stream attribute\n+   --      Output for any tagged type.\n+\n+   --      Op_Eq (7) - implementation of the equality operator for any non-\n+   --      limited tagged type.\n+\n+   --      _Assign (8) - implementation of the assignment operator for any\n+   --      non-limited tagged type.\n+\n+   --      TSS_Deep_Adjust (9) - implementation of the finalization operation\n+   --      Adjust for any non-limited tagged type.\n+\n+   --      TSS_Deep_Finalize (10) - implementation of the finalization\n+   --      operation Finalize for any non-limited tagged type.\n+\n+   --      _Disp_Asynchronous_Select (11) - used in the expansion of ATC with\n+   --      dispatching triggers. Null implementation for limited interfaces,\n+   --      full body generation for types that implement limited interfaces,\n+   --      not generated for the rest of the cases. See Expand_N_Asynchronous_\n+   --      Select in Exp_Ch9 for more information.\n+\n+   --      _Disp_Conditional_Select (12) - used in the expansion of conditional\n+   --      selects with dispatching triggers. Null implementation for limited\n+   --      interfaces, full body generation for types that implement limited\n+   --      interfaces, not generated for the rest of the cases. See Expand_N_\n+   --      Conditional_Entry_Call in Exp_Ch9 for more information.\n+\n+   --      _Disp_Get_Prim_Op_Kind (13) - helper routine used in the expansion\n+   --      of ATC with dispatching triggers. Null implementation for limited\n+   --      interfaces, full body generation for types that implement limited\n+   --      interfaces, not generated for the rest of the cases.\n+\n+   --      _Disp_Get_Task_Id (14) - helper routine used in the expansion of\n+   --      Abort, attributes 'Callable and 'Terminated for task interface\n+   --      class-wide types. Full body generation for task types, null\n+   --      implementation for limited interfaces, not generated for the rest\n+   --      of the cases. See Expand_N_Attribute_Reference in Exp_Attr and\n+   --      Expand_N_Abort_Statement in Exp_Ch9 for more information.\n+\n+   --      _Disp_Timed_Select (15) - used in the expansion of timed selects\n+   --      with dispatching triggers. Null implementation for limited\n+   --      interfaces, full body generation for types that implement limited\n+   --      interfaces, not generated for the rest of the cases. See Expand_N_\n+   --      Timed_Entry_Call for more information.\n+\n+   --  Lifecycle of predefined primitive operations\n+\n+   --      The specifications and bodies of the PPOs are created by\n+   --      Make_Predefined_Primitive_Specs and Predefined_Primitive_Bodies\n+   --      in Exp_Ch3. The generated specifications are immediately analyzed,\n+   --      while the bodies are left as freeze actions to the tagged type for\n+   --      which they are created.\n+\n+   --      PPOs are collected and added to the Primitive_Operations list of\n+   --      a type by the regular analysis mechanism.\n+\n+   --      PPOs are frozen in Predefined_Primitive_Freeze in Exp_Ch3.\n+\n+   --      Thunks for PPOs are created in Freeze_Subprogram in Exp_Ch6, by a\n+   --      call to Register_Predefined_DT_Entry, also in Exp_Ch6.\n+\n+   --      Dispatch table positions of PPOs are set in Set_All_DT_Position in\n+   --      Exp_Disp.\n+\n+   --      Calls to PPOs procede as regular dispatching calls. If the PPO\n+   --      has a thunk, a call procedes as a regular dispatching call with\n+   --      a thunk.\n+\n+   --  Guidelines for addition of new predefined primitive operations\n+\n+   --      Update the value of constant Default_Prim_Op_Count in Exp_Disp.ads\n+   --      to reflect the new number of PPOs.\n+\n+   --      Update the value of constant Default_Prim_Op_Count in A-Tags.ads\n+   --      to reflect the new number of PPOs. This value should be the same\n+   --      as the one in Exp_Disp.ads.\n+\n+   --      Introduce a new predefined name for the new PPO in Snames.ads and\n+   --      Snames.adb.\n+\n+   --      Categorize the new PPO name as predefined by adding an entry in\n+   --      Is_Predefined_Dispatching_Operation in Exp_Util.adb.\n+\n+   --      Reserve a dispatch table position for the new PPO by adding an entry\n+   --      in Default_Prim_Op_Position in Exp_Disp.adb.\n+\n+   --      Generate the specification of the new PPO in Make_Predefined_\n+   --      Primitive_Spec in Exp_Ch3.adb. The Is_Internal flag of the defining\n+   --      identifier of the specification must be set to True.\n+\n+   --      Generate the body of the new PPO in Predefined_Primitive_Bodies in\n+   --      Exp_Ch3.adb. The Is_Internal flag of the defining identifier of the\n+   --      specification must be set to True.\n+\n+   --      If the new PPO requires a thunk, add an entry in Freeze_Subprogram\n+   --      in Exp_Ch6.adb.\n+\n+   --      When generating calls to a PPO, use Find_Prim_Op from Exp_Util.ads\n+   --      to retrieve the entity of the operation directly.\n+\n    --  Number of predefined primitive operations added by the Expander\n    --  for a tagged type. If more predefined primitive operations are\n    --  added, the following items must be changed:\n@@ -38,7 +174,7 @@ package Exp_Disp is\n    --    Exp_Disp.Default_Prim_Op_Position - indirect use\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n-   Default_Prim_Op_Count : constant Int := 14;\n+   Default_Prim_Op_Count : constant Int := 15;\n \n    type DT_Access_Action is\n       (CW_Membership,\n@@ -48,6 +184,7 @@ package Exp_Disp is\n        Get_Access_Level,\n        Get_Entry_Index,\n        Get_External_Tag,\n+       Get_Offset_Index,\n        Get_Prim_Op_Address,\n        Get_Prim_Op_Kind,\n        Get_RC_Offset,\n@@ -60,10 +197,13 @@ package Exp_Disp is\n        Set_Entry_Index,\n        Set_Expanded_Name,\n        Set_External_Tag,\n+       Set_Offset_Index,\n+       Set_OSD,\n        Set_Prim_Op_Address,\n        Set_Prim_Op_Kind,\n        Set_RC_Offset,\n        Set_Remotely_Callable,\n+       Set_SSD,\n        Set_TSD,\n        TSD_Entry_Size,\n        TSD_Prologue_Size);\n@@ -117,16 +257,6 @@ package Exp_Disp is\n    --  Ada 2005 (AI-251): Initialize the entries associated with predefined\n    --  primitives in all the secondary dispatch tables of Typ.\n \n-   procedure Make_Abstract_Interface_DT\n-     (AI_Tag          : Entity_Id;\n-      Acc_Disp_Tables : in out Elist_Id;\n-      Result          : out List_Id);\n-   --  Ada 2005 (AI-251): Expand the declarations for the secondary Dispatch\n-   --  Tables corresponding with an abstract interface. The reference to the\n-   --  dispatch table is appended at the end of Acc_Disp_Tables; it will be\n-   --  are later used to generate the corresponding initialization statement\n-   --  (see Exp_Ch3.Build_Init_Procedure).\n-\n    function Make_DT_Access_Action\n      (Typ    : Entity_Id;\n       Action : DT_Access_Action;\n@@ -141,7 +271,8 @@ package Exp_Disp is\n    function Make_Disp_Asynchronous_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for dispatching in asynchronous selects.\n+   --  Typ used for dispatching in asynchronous selects. Generate a null body\n+   --  if Typ is an interface type.\n \n    function Make_Disp_Asynchronous_Select_Spec\n      (Typ : Entity_Id) return Node_Id;\n@@ -151,7 +282,8 @@ package Exp_Disp is\n    function Make_Disp_Conditional_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for dispatching in conditional selects.\n+   --  Typ used for dispatching in conditional selects. Generate a null body\n+   --  if Typ is an interface type.\n \n    function Make_Disp_Conditional_Select_Spec\n      (Typ : Entity_Id) return Node_Id;\n@@ -162,31 +294,60 @@ package Exp_Disp is\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n    --  Typ used for retrieving the callable entity kind during dispatching in\n-   --  asynchronous selects.\n+   --  asynchronous selects. Generate a null body if Typ is an interface type.\n \n    function Make_Disp_Get_Prim_Op_Kind_Spec\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n    --  of the type Typ use for retrieving the callable entity kind during\n    --  dispatching in asynchronous selects.\n \n-   function Make_Disp_Select_Tables\n-     (Typ : Entity_Id) return List_Id;\n-   --  Ada 2005 (AI-345): Populate the two auxiliary tables in the TSD of Typ\n-   --  used for dispatching in asynchronous, conditional and timed selects.\n-   --  Generate code to set the primitive operation kinds and entry indices\n-   --  of primitive operations and primitive wrappers.\n+   function Make_Disp_Get_Task_Id_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n+   --  Typ used for retrieving the _task_id field of a task interface class-\n+   --  wide type. Generate a null body if Typ is an interface or a non-task\n+   --  type.\n+\n+   function Make_Disp_Get_Task_Id_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n+   --  of type Typ used for retrieving the _task_id field of a task interface\n+   --  class-wide type.\n \n    function Make_Disp_Timed_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for dispatching in timed selects.\n+   --  Typ used for dispatching in timed selects. Generate a null body if Nul\n+   --  is an interface type.\n \n    function Make_Disp_Timed_Select_Spec\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the specification of the primitive operation\n    --  of type Typ used for dispatching in timed selects.\n \n+   function Make_Select_Specific_Data_Table\n+     (Typ : Entity_Id) return List_Id;\n+   --  Ada 2005 (AI-345): Create and populate the auxiliary table in the TSD\n+   --  of Typ used for dispatching in asynchronous, conditional and timed\n+   --  selects. Generate code to set the primitive operation kinds and entry\n+   --  indices of primitive operations and primitive wrappers.\n+\n+   procedure Make_Secondary_DT\n+     (Typ             : Entity_Id;\n+      Ancestor_Typ    : Entity_Id;\n+      Suffix_Index    : Int;\n+      Iface           : Entity_Id;\n+      AI_Tag          : Entity_Id;\n+      Acc_Disp_Tables : in out Elist_Id;\n+      Result          : out List_Id);\n+   --  Ada 2005 (AI-251): Expand the declarations for the Secondary Dispatch\n+   --  Table of Typ associated with Iface (each abstract interface implemented\n+   --  by Typ has a secondary dispatch table). The arguments Typ, Ancestor_Typ\n+   --  and Suffix_Index are used to generate an unique external name which\n+   --  is added at the end of Acc_Disp_Tables; this external name will be\n+   --  used later by the subprogram Exp_Ch3.Build_Init_Procedure.\n+\n    procedure Set_All_DT_Position (Typ : Entity_Id);\n    --  Set the DT_Position field for each primitive operation. In the CPP\n    --  Class case check that no pragma CPP_Virtual is missing and that the"}, {"sha": "c6924e97cb68085686d67e675734e26f9dace5a2", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 195, "deletions": 76, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1275,6 +1275,16 @@ package body Exp_Util is\n       then\n          null;\n \n+      --  Nothing to be done for derived types with unknown discriminants if\n+      --  the parent type also has unknown discriminants.\n+\n+      elsif Is_Record_Type (Unc_Type)\n+        and then not Is_Class_Wide_Type (Unc_Type)\n+        and then Has_Unknown_Discriminants (Unc_Type)\n+        and then Has_Unknown_Discriminants (Underlying_Type (Unc_Type))\n+      then\n+         null;\n+\n       --  Nothing to be done if the type of the expression is limited, because\n       --  in this case the expression cannot be copied, and its use can only\n       --  be by reference and there is no need for the actual subtype.\n@@ -1289,8 +1299,147 @@ package body Exp_Util is\n       end if;\n    end Expand_Subtype_From_Expr;\n \n+   --------------------------------\n+   -- Find_Implemented_Interface --\n+   --------------------------------\n+\n+   --  Given the following code (XXX denotes irrelevant value):\n+\n+   --     type Limd_Iface is limited interface;\n+   --     type Prot_Iface is protected interface;\n+   --     type Sync_Iface is synchronized interface;\n+\n+   --     type Parent_Subtype is new Limd_Iface and Sync_Iface with ...\n+   --     type Child_Subtype is new Parent_Subtype and Prot_Iface with ...\n+\n+   --  The following calls will return the following values:\n+\n+   --     Find_Implemented_Interface\n+   --       (Child_Subtype, Synchronized_Interface, False)    -> Empty\n+\n+   --     Find_Implemented_Interface\n+   --       (Child_Subtype, Synchronized_Interface, True)     -> Sync_Iface\n+\n+   --     Find_Implemented_Interface\n+   --       (Child_Subtype, Any_Synchronized_Interface, XXX)  -> Prot_Iface\n+\n+   --     Find_Implemented_Interface\n+   --       (Child_Subtype, Any_Limited_Interface, XXX)       -> Prot_Iface\n+\n+   function Find_Implemented_Interface\n+     (Typ          : Entity_Id;\n+      Kind         : Interface_Kind;\n+      Check_Parent : Boolean := False) return Entity_Id\n+   is\n+      Iface_Elmt : Elmt_Id;\n+\n+      function Interface_In_Kind\n+        (I    : Entity_Id;\n+         Kind : Interface_Kind) return Boolean;\n+      --  Determine whether an interface falls into a specified kind\n+\n+      -----------------------\n+      -- Interface_In_Kind --\n+      -----------------------\n+\n+      function Interface_In_Kind\n+        (I    : Entity_Id;\n+         Kind : Interface_Kind) return Boolean is\n+      begin\n+         if Is_Limited_Interface (I)\n+           and then (Kind = Any_Interface\n+             or else Kind = Any_Limited_Interface\n+             or else Kind = Limited_Interface)\n+         then\n+            return True;\n+\n+         elsif Is_Protected_Interface (I)\n+           and then (Kind = Any_Interface\n+             or else Kind = Any_Limited_Interface\n+             or else Kind = Any_Synchronized_Interface\n+             or else Kind = Protected_Interface)\n+         then\n+            return True;\n+\n+         elsif Is_Synchronized_Interface (I)\n+           and then (Kind = Any_Interface\n+             or else Kind = Any_Limited_Interface\n+             or else Kind = Synchronized_Interface)\n+         then\n+            return True;\n+\n+         elsif Is_Task_Interface (I)\n+           and then (Kind = Any_Interface\n+             or else Kind = Any_Limited_Interface\n+             or else Kind = Any_Synchronized_Interface\n+             or else Kind = Task_Interface)\n+         then\n+            return True;\n+\n+         --  Regular interface. This should be the last kind to check since\n+         --  all of the previous cases have their Is_Interface flags set.\n+\n+         elsif Is_Interface (I)\n+           and then (Kind = Any_Interface\n+             or else Kind = Iface)\n+         then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Interface_In_Kind;\n+\n+   --  Start of processing for Find_Implemented_Interface\n+\n+   begin\n+      if not Is_Tagged_Type (Typ) then\n+         return Empty;\n+      end if;\n+\n+      --  Implementations of the form:\n+      --    Typ is new Interface ...\n+\n+      if Is_Interface (Etype (Typ))\n+        and then Interface_In_Kind (Etype (Typ), Kind)\n+      then\n+         return Etype (Typ);\n+      end if;\n+\n+      --  Implementations of the form:\n+      --     Typ is new Typ_Parent and Interface ...\n+\n+      if Present (Abstract_Interfaces (Typ)) then\n+         Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+         while Present (Iface_Elmt) loop\n+            if Interface_In_Kind (Node (Iface_Elmt), Kind) then\n+               return Node (Iface_Elmt);\n+            end if;\n+\n+            Iface_Elmt := Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+\n+      --  Typ is a derived type and may implement a limited interface\n+      --  through its parent subtype. Check the parent subtype as well\n+      --  as any interfaces explicitly implemented at this level.\n+\n+      if Check_Parent\n+        and then Ekind (Typ) = E_Record_Type\n+        and then Present (Parent_Subtype (Typ))\n+      then\n+         return Find_Implemented_Interface (\n+           Parent_Subtype (Typ), Kind, Check_Parent);\n+      end if;\n+\n+      --  Typ does not implement a limited interface either at this level or\n+      --  in any of its parent subtypes.\n+\n+      return Empty;\n+   end Find_Implemented_Interface;\n+\n    ------------------------\n-   -- Find_Interface_Tag --\n+   -- Find_Interface_ADT --\n    ------------------------\n \n    function Find_Interface_ADT\n@@ -1302,7 +1451,7 @@ package body Exp_Util is\n       Typ   : Entity_Id := T;\n \n       procedure Find_Secondary_Table (Typ : Entity_Id);\n-      --  Comment required ???\n+      --  Internal subprogram used to recursively climb to the ancestors\n \n       --------------------------\n       -- Find_Secondary_Table --\n@@ -1313,10 +1462,23 @@ package body Exp_Util is\n          AI      : Node_Id;\n \n       begin\n-         if Etype (Typ) /= Typ then\n+         --  Climb to the ancestor (if any) handling private types\n+\n+         if Present (Full_View (Etype (Typ))) then\n+            if Full_View (Etype (Typ)) /= Typ then\n+               Find_Secondary_Table (Full_View (Etype (Typ)));\n+            end if;\n+\n+         elsif Etype (Typ) /= Typ then\n             Find_Secondary_Table (Etype (Typ));\n          end if;\n \n+         --  If we already found it there is nothing else to do\n+\n+         if Found then\n+            return;\n+         end if;\n+\n          if Present (Abstract_Interfaces (Typ))\n            and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n          then\n@@ -1401,9 +1563,14 @@ package body Exp_Util is\n             return;\n          end if;\n \n-         --  Climb to the root type\n+         --  Climb to the root type handling private types\n+\n+         if Present (Full_View (Etype (Typ))) then\n+            if Full_View (Etype (Typ)) /= Typ then\n+               Find_Tag (Full_View (Etype (Typ)));\n+            end if;\n \n-         if Etype (Typ) /= Typ then\n+         elsif Etype (Typ) /= Typ then\n             Find_Tag (Etype (Typ));\n          end if;\n \n@@ -1437,6 +1604,8 @@ package body Exp_Util is\n    --  Start of processing for Find_Interface_Tag\n \n    begin\n+      pragma Assert (Is_Interface (Iface));\n+\n       --  Handle private types\n \n       if Has_Private_Declaration (Typ)\n@@ -1742,67 +1911,17 @@ package body Exp_Util is\n       return Count;\n    end Homonym_Number;\n \n-   ----------------------------------\n-   -- Implements_Limited_Interface --\n-   ----------------------------------\n-\n-   function Implements_Limited_Interface (Typ : Entity_Id) return Boolean is\n-      function Contains_Limited_Interface\n-        (Ifaces : Elist_Id) return Boolean;\n-      --  Given a list of interfaces, determine whether one of them is limited\n-\n-      --------------------------------\n-      -- Contains_Limited_Interface --\n-      --------------------------------\n-\n-      function Contains_Limited_Interface\n-        (Ifaces : Elist_Id) return Boolean\n-      is\n-         Iface_Elmt : Elmt_Id;\n-\n-      begin\n-         if not Present (Ifaces) then\n-            return False;\n-         end if;\n-\n-         Iface_Elmt := First_Elmt (Ifaces);\n-\n-         while Present (Iface_Elmt) loop\n-            if Is_Limited_Record (Node (Iface_Elmt)) then\n-               return True;\n-            end if;\n-\n-            Iface_Elmt := Next_Elmt (Iface_Elmt);\n-         end loop;\n-\n-         return False;\n-      end Contains_Limited_Interface;\n-\n-   --  Start of processing for Implements_Limited_Interface\n+   --------------------------\n+   -- Implements_Interface --\n+   --------------------------\n \n+   function Implements_Interface\n+     (Typ          : Entity_Id;\n+      Kind         : Interface_Kind;\n+      Check_Parent : Boolean := False) return Boolean is\n    begin\n-      --  Typ is a derived type and may implement a limited interface\n-      --  through its parent subtype. Check the parent subtype as well\n-      --  as any interfaces explicitly implemented at this level.\n-\n-      if Ekind (Typ) = E_Record_Type\n-        and then Present (Parent_Subtype (Typ))\n-      then\n-         return Contains_Limited_Interface (Abstract_Interfaces (Typ))\n-           or else Implements_Limited_Interface (Parent_Subtype (Typ));\n-\n-      --  Typ is an abstract type derived from some interface\n-\n-      elsif Is_Abstract (Typ) then\n-         return Is_Interface (Etype (Typ))\n-           and then Is_Limited_Record (Etype (Typ));\n-\n-      --  Typ may directly implement some interface\n-\n-      else\n-         return Contains_Limited_Interface (Abstract_Interfaces (Typ));\n-      end if;\n-   end Implements_Limited_Interface;\n+      return Find_Implemented_Interface (Typ, Kind, Check_Parent) /= Empty;\n+   end Implements_Interface;\n \n    ------------------------------\n    -- In_Unconditional_Context --\n@@ -2436,7 +2555,6 @@ package body Exp_Util is\n       if Suppress = All_Checks then\n          declare\n             Svg : constant Suppress_Array := Scope_Suppress;\n-\n          begin\n             Scope_Suppress := (others => True);\n             Insert_Actions (Assoc_Node, Ins_Actions);\n@@ -2446,7 +2564,6 @@ package body Exp_Util is\n       else\n          declare\n             Svg : constant Boolean := Scope_Suppress (Suppress);\n-\n          begin\n             Scope_Suppress (Suppress) := True;\n             Insert_Actions (Assoc_Node, Ins_Actions);\n@@ -2557,12 +2674,12 @@ package body Exp_Util is\n       return True;\n    end Is_All_Null_Statements;\n \n-   ------------------------\n-   -- Is_Default_Prim_Op --\n-   ------------------------\n+   -----------------------------------------\n+   -- Is_Predefined_Dispatching_Operation --\n+   -----------------------------------------\n \n    function Is_Predefined_Dispatching_Operation\n-     (Subp     : Entity_Id) return Boolean\n+     (Subp : Entity_Id) return Boolean\n    is\n       TSS_Name : TSS_Name_Type;\n       E        : Entity_Id := Subp;\n@@ -2590,10 +2707,12 @@ package body Exp_Util is\n            or else Chars (E) = Name_uAssign\n            or else TSS_Name  = TSS_Deep_Adjust\n            or else TSS_Name  = TSS_Deep_Finalize\n-           or else Chars (E) = Name_uDisp_Asynchronous_Select\n-           or else Chars (E) = Name_uDisp_Conditional_Select\n-           or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n-           or else Chars (E) = Name_uDisp_Timed_Select\n+           or else (Ada_Version >= Ada_05\n+             and then (Chars (E) = Name_uDisp_Asynchronous_Select\n+               or else Chars (E) = Name_uDisp_Conditional_Select\n+               or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n+               or else Chars (E) = Name_uDisp_Get_Task_Id\n+               or else Chars (E) = Name_uDisp_Timed_Select))\n          then\n             return True;\n          end if;\n@@ -3466,7 +3585,7 @@ package body Exp_Util is\n             return New_Occurrence_Of (CW_Subtype, Loc);\n          end;\n \n-      --  Comment needed (what case is this ???)\n+      --  Indefinite record type with discriminants.\n \n       else\n          D := First_Discriminant (Unc_Typ);"}, {"sha": "2afb88f8ca617a3031869671f33cdfc544e2b7ca", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,21 @@ with Types;   use Types;\n \n package Exp_Util is\n \n+   --  An enumeration type used to capture all the possible interface\n+   --  kinds and their hierarchical relation. These values are used in\n+   --  Find_Implemented_Interface and Implements_Interface.\n+\n+   type Interface_Kind is (\n+     Any_Interface,               --  Any interface\n+     Any_Limited_Interface,       --  Only limited interfaces\n+     Any_Synchronized_Interface,  --  Only synchronized interfaces\n+\n+     Iface,                       --  Individual kinds\n+     Limited_Interface,\n+     Protected_Interface,\n+     Synchronized_Interface,\n+     Task_Interface);\n+\n    -----------------------------------------------\n    -- Handling of Actions Associated with Nodes --\n    -----------------------------------------------\n@@ -325,17 +340,27 @@ package Exp_Util is\n    --  class-wide).\n \n    function Find_Interface_ADT\n-     (T         : Entity_Id;\n-      Iface     : Entity_Id) return Entity_Id;\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id;\n    --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n    --  return the Access_Disp_Table value of the interface.\n \n    function Find_Interface_Tag\n-     (T         : Entity_Id;\n-      Iface     : Entity_Id) return Entity_Id;\n+     (T     : Entity_Id;\n+      Iface : Entity_Id) return Entity_Id;\n    --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n    --  return the record component containing the tag of Iface.\n \n+   function Find_Implemented_Interface\n+     (Typ          : Entity_Id;\n+      Kind         : Interface_Kind;\n+      Check_Parent : Boolean := False) return Entity_Id;\n+   --  Ada 2005 (AI-345): Find a designated kind of interface implemented by\n+   --  Typ or any parent subtype. Return the first encountered interface that\n+   --  correspond to the selected class. Return Empty if no such interface is\n+   --  found. Use Check_Parent to climb a potential derivation chain and\n+   --  examine the parent subtypes for any implementation.\n+\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id;\n    --  Find the first primitive operation of type T whose name is 'Name'.\n    --  This function allows the use of a primitive operation which is not\n@@ -410,11 +435,13 @@ package Exp_Util is\n    --  chain, counting only entries in the curren scope. If an entity is not\n    --  overloaded, the returned number will be one.\n \n-   function Implements_Limited_Interface (Typ : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-345): Determine whether Typ implements some limited\n-   --  interface. The interface may be of limited, protected, synchronized\n-   --  or taks kind. Typ may also be derived from a type that implements a\n-   --  limited interface.\n+   function Implements_Interface\n+     (Typ          : Entity_Id;\n+      Kind         : Interface_Kind;\n+      Check_Parent : Boolean := False) return Boolean;\n+   --  Ada 2005 (AI-345): Determine whether Typ implements a designated kind\n+   --  of interface. Use Check_Parent to climb a potential derivation chain\n+   --  and examine the parent subtypes for any implementation.\n \n    function Inside_Init_Proc return Boolean;\n    --  Returns True if current scope is within an init proc"}, {"sha": "8b19055fef903655471829389cd19d3883cce44f", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -209,9 +209,14 @@ package Rtsfind is\n       System_Exp_Mod,\n       System_Exp_Uns,\n       System_Fat_Flt,\n+      System_Fat_IEEE_Long_Float,\n+      System_Fat_IEEE_Short_Float,\n       System_Fat_LFlt,\n       System_Fat_LLF,\n       System_Fat_SFlt,\n+      System_Fat_VAX_D_Float,\n+      System_Fat_VAX_F_Float,\n+      System_Fat_VAX_G_Float,\n       System_Finalization_Implementation,\n       System_Finalization_Root,\n       System_Fore,\n@@ -493,6 +498,7 @@ package Rtsfind is\n      RE_Get_Access_Level,                -- Ada.Tags\n      RE_Get_Entry_Index,                 -- Ada.Tags\n      RE_Get_External_Tag,                -- Ada.Tags\n+     RE_Get_Offset_Index,                -- Ada.Tags\n      RE_Get_Prim_Op_Address,             -- Ada.Tags\n      RE_Get_Prim_Op_Kind,                -- Ada.Tags\n      RE_Get_RC_Offset,                   -- Ada.Tags\n@@ -501,32 +507,43 @@ package Rtsfind is\n      RE_Inherit_TSD,                     -- Ada.Tags\n      RE_Internal_Tag,                    -- Ada.Tags\n      RE_Is_Descendant_At_Same_Level,     -- Ada.Tags\n+     RE_Object_Specific_Data,            -- Ada.Tags\n      RE_POK_Function,                    -- Ada.Tags\n      RE_POK_Procedure,                   -- Ada.Tags\n      RE_POK_Protected_Entry,             -- Ada.Tags\n      RE_POK_Protected_Function,          -- Ada.Tags\n      RE_POK_Protected_Procedure,         -- Ada.Tags\n      RE_POK_Task_Entry,                  -- Ada.Tags\n+     RE_POK_Task_Function,               -- Ada.Tags\n      RE_POK_Task_Procedure,              -- Ada.Tags\n      RE_Prim_Op_Kind,                    -- Ada.Tags\n      RE_Register_Interface_Tag,          -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n+     RE_Select_Specific_Data,            -- Ada.Tags\n      RE_Set_Access_Level,                -- Ada.Tags\n      RE_Set_Entry_Index,                 -- Ada.Tags\n      RE_Set_Expanded_Name,               -- Ada.Tags\n      RE_Set_External_Tag,                -- Ada.Tags\n+     RE_Set_Num_Prim_Ops,                -- Ada.Tags\n+     RE_Set_Offset_Index,                -- Ada.Tags\n      RE_Set_Offset_To_Top,               -- Ada.Tags\n+     RE_Set_OSD,                         -- Ada.Tags\n      RE_Set_Prim_Op_Address,             -- Ada.Tags\n      RE_Set_Prim_Op_Kind,                -- Ada.Tags\n      RE_Set_RC_Offset,                   -- Ada.Tags\n      RE_Set_Remotely_Callable,           -- Ada.Tags\n+     RE_Set_SSD,                         -- Ada.Tags\n      RE_Set_TSD,                         -- Ada.Tags\n      RE_Tag_Error,                       -- Ada.Tags\n      RE_TSD_Entry_Size,                  -- Ada.Tags\n      RE_TSD_Prologue_Size,               -- Ada.Tags\n      RE_Interface_Tag,                   -- Ada.Tags\n      RE_Tag,                             -- Ada.Tags\n      RE_Address_Array,                   -- Ada.Tags\n+     RE_Valid_Signature,                 -- Ada.Tags\n+     RE_Primary_DT,                      -- Ada.Tags\n+     RE_Secondary_DT,                    -- Ada.Tags\n+     RE_Abstract_Interface,              -- Ada.Tags\n \n      RE_Abort_Task,                      -- Ada.Task_Identification\n      RE_Current_Task,                    -- Ada.Task_Identification\n@@ -666,13 +683,28 @@ package Rtsfind is\n \n      RE_Exp_Unsigned,                    -- System.Exp_Uns\n \n-     RE_Fat_Float,                       -- System.Fat_Flt\n+     RE_Attr_Float,                      -- System.Fat_Flt\n \n-     RE_Fat_Long_Float,                  -- System.Fat_LFlt\n+     RE_Attr_IEEE_Long,                  -- System.Fat_IEEE_Long_Float\n+     RE_Fat_IEEE_Long,                   -- System.Fat_IEEE_Long_Float\n \n-     RE_Fat_Long_Long_Float,             -- System.Fat_LLF\n+     RE_Attr_IEEE_Short,                 -- System.Fat_IEEE_Short_Float\n+     RE_Fat_IEEE_Short,                  -- System.Fat_IEEE_Short_Float\n \n-     RE_Fat_Short_Float,                 -- System.Fat_SFlt\n+     RE_Attr_Long_Float,                 -- System.Fat_LFlt\n+\n+     RE_Attr_Long_Long_Float,            -- System.Fat_LLF\n+\n+     RE_Attr_Short_Float,                -- System.Fat_SFlt\n+\n+     RE_Attr_VAX_D_Float,                -- System.Fat_VAX_D_Float\n+     RE_Fat_VAX_D,                       -- System.Fat_VAX_D_Float\n+\n+     RE_Attr_VAX_F_Float,                -- System.Fat_VAX_F_Float\n+     RE_Fat_VAX_F,                       -- System.Fat_VAX_F_Float\n+\n+     RE_Attr_VAX_G_Float,                -- System.Fat_VAX_G_Float\n+     RE_Fat_VAX_G,                       -- System.Fat_VAX_G_Float\n \n      RE_Attach_To_Final_List,            -- System.Finalization_Implementation\n      RE_Finalize_List,                   -- System.Finalization_Implementation\n@@ -1151,6 +1183,7 @@ package Rtsfind is\n \n      RE_TC_Alias,                        -- System.PolyORB_Interface\n      RE_TC_Build,                        -- System.PolyORB_Interface\n+     RE_Get_TC,                          -- System.PolyORB_Interface\n      RE_Set_TC,                          -- System.PolyORB_Interface\n      RE_TC_Any,                          -- System.PolyORB_Interface\n      RE_TC_AD,                           -- System.PolyORB_Interface\n@@ -1219,6 +1252,7 @@ package Rtsfind is\n      RE_Integer_Address,                 -- System.Storage_Elements\n      RE_Storage_Offset,                  -- System.Storage_Elements\n      RE_Storage_Array,                   -- System.Storage_Elements\n+     RE_Storage_Element,                 -- System.Storage_Elements\n      RE_To_Address,                      -- System.Storage_Elements\n \n      RE_Root_Storage_Pool,               -- System.Storage_Pools\n@@ -1291,6 +1325,7 @@ package Rtsfind is\n      RE_Task_Procedure_Access,           -- System.Tasking\n \n      RO_ST_Task_Id,                      -- System.Tasking\n+     RO_ST_Null_Task,                    -- System.Tasking\n \n      RE_Call_Modes,                      -- System.Tasking\n      RE_Simple_Call,                     -- System.Tasking\n@@ -1417,6 +1452,8 @@ package Rtsfind is\n      RE_Le_G,                            -- System.Vax_Float_Operations\n      RE_Lt_F,                            -- System.Vax_Float_Operations\n      RE_Lt_G,                            -- System.Vax_Float_Operations\n+     RE_Ne_F,                            -- System.Vax_Float_Operations\n+     RE_Ne_G,                            -- System.Vax_Float_Operations\n \n      RE_Valid_D,                         -- System.Vax_Float_Operations\n      RE_Valid_F,                         -- System.Vax_Float_Operations\n@@ -1602,6 +1639,7 @@ package Rtsfind is\n      RE_Get_Access_Level                 => Ada_Tags,\n      RE_Get_Entry_Index                  => Ada_Tags,\n      RE_Get_External_Tag                 => Ada_Tags,\n+     RE_Get_Offset_Index                 => Ada_Tags,\n      RE_Get_Prim_Op_Address              => Ada_Tags,\n      RE_Get_Prim_Op_Kind                 => Ada_Tags,\n      RE_Get_RC_Offset                    => Ada_Tags,\n@@ -1610,32 +1648,43 @@ package Rtsfind is\n      RE_Inherit_TSD                      => Ada_Tags,\n      RE_Internal_Tag                     => Ada_Tags,\n      RE_Is_Descendant_At_Same_Level      => Ada_Tags,\n+     RE_Object_Specific_Data             => Ada_Tags,\n      RE_POK_Function                     => Ada_Tags,\n      RE_POK_Procedure                    => Ada_Tags,\n      RE_POK_Protected_Entry              => Ada_Tags,\n      RE_POK_Protected_Function           => Ada_Tags,\n      RE_POK_Protected_Procedure          => Ada_Tags,\n      RE_POK_Task_Entry                   => Ada_Tags,\n+     RE_POK_Task_Function                => Ada_Tags,\n      RE_POK_Task_Procedure               => Ada_Tags,\n      RE_Prim_Op_Kind                     => Ada_Tags,\n      RE_Register_Interface_Tag           => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n+     RE_Select_Specific_Data             => Ada_Tags,\n      RE_Set_Access_Level                 => Ada_Tags,\n      RE_Set_Entry_Index                  => Ada_Tags,\n      RE_Set_Expanded_Name                => Ada_Tags,\n      RE_Set_External_Tag                 => Ada_Tags,\n+     RE_Set_Num_Prim_Ops                 => Ada_Tags,\n+     RE_Set_Offset_Index                 => Ada_Tags,\n      RE_Set_Offset_To_Top                => Ada_Tags,\n+     RE_Set_OSD                          => Ada_Tags,\n      RE_Set_Prim_Op_Address              => Ada_Tags,\n      RE_Set_Prim_Op_Kind                 => Ada_Tags,\n      RE_Set_RC_Offset                    => Ada_Tags,\n      RE_Set_Remotely_Callable            => Ada_Tags,\n+     RE_Set_SSD                          => Ada_Tags,\n      RE_Set_TSD                          => Ada_Tags,\n      RE_Tag_Error                        => Ada_Tags,\n      RE_TSD_Entry_Size                   => Ada_Tags,\n      RE_TSD_Prologue_Size                => Ada_Tags,\n      RE_Interface_Tag                    => Ada_Tags,\n      RE_Tag                              => Ada_Tags,\n      RE_Address_Array                    => Ada_Tags,\n+     RE_Valid_Signature                  => Ada_Tags,\n+     RE_Primary_DT                       => Ada_Tags,\n+     RE_Secondary_DT                     => Ada_Tags,\n+     RE_Abstract_Interface               => Ada_Tags,\n \n      RE_Abort_Task                       => Ada_Task_Identification,\n      RE_Current_Task                     => Ada_Task_Identification,\n@@ -1773,13 +1822,28 @@ package Rtsfind is\n \n      RE_Exp_Unsigned                     => System_Exp_Uns,\n \n-     RE_Fat_Float                        => System_Fat_Flt,\n+     RE_Attr_Float                       => System_Fat_Flt,\n+\n+     RE_Attr_IEEE_Long                   => System_Fat_IEEE_Long_Float,\n+     RE_Fat_IEEE_Long                    => System_Fat_IEEE_Long_Float,\n+\n+     RE_Attr_IEEE_Short                  => System_Fat_IEEE_Short_Float,\n+     RE_Fat_IEEE_Short                   => System_Fat_IEEE_Short_Float,\n+\n+     RE_Attr_Long_Float                  => System_Fat_LFlt,\n+\n+     RE_Attr_Long_Long_Float             => System_Fat_LLF,\n+\n+     RE_Attr_Short_Float                 => System_Fat_SFlt,\n \n-     RE_Fat_Long_Float                   => System_Fat_LFlt,\n+     RE_Attr_VAX_D_Float                 => System_Fat_VAX_D_Float,\n+     RE_Fat_VAX_D                        => System_Fat_VAX_D_Float,\n \n-     RE_Fat_Long_Long_Float              => System_Fat_LLF,\n+     RE_Attr_VAX_F_Float                 => System_Fat_VAX_F_Float,\n+     RE_Fat_VAX_F                        => System_Fat_VAX_F_Float,\n \n-     RE_Fat_Short_Float                  => System_Fat_SFlt,\n+     RE_Attr_VAX_G_Float                 => System_Fat_VAX_G_Float,\n+     RE_Fat_VAX_G                        => System_Fat_VAX_G_Float,\n \n      RE_Attach_To_Final_List             => System_Finalization_Implementation,\n      RE_Finalize_List                    => System_Finalization_Implementation,\n@@ -2249,6 +2313,7 @@ package Rtsfind is\n \n      RE_TC_Alias                         => System_PolyORB_Interface,\n      RE_TC_Build                         => System_PolyORB_Interface,\n+     RE_Get_TC                           => System_PolyORB_Interface,\n      RE_Set_TC                           => System_PolyORB_Interface,\n      RE_TC_Any                           => System_PolyORB_Interface,\n      RE_TC_AD                            => System_PolyORB_Interface,\n@@ -2326,6 +2391,7 @@ package Rtsfind is\n      RE_Integer_Address                  => System_Storage_Elements,\n      RE_Storage_Offset                   => System_Storage_Elements,\n      RE_Storage_Array                    => System_Storage_Elements,\n+     RE_Storage_Element                  => System_Storage_Elements,\n      RE_To_Address                       => System_Storage_Elements,\n \n      RE_Root_Storage_Pool                => System_Storage_Pools,\n@@ -2397,6 +2463,7 @@ package Rtsfind is\n      RE_Task_Procedure_Access            => System_Tasking,\n \n      RO_ST_Task_Id                       => System_Tasking,\n+     RO_ST_Null_Task                     => System_Tasking,\n \n      RE_Call_Modes                       => System_Tasking,\n      RE_Simple_Call                      => System_Tasking,\n@@ -2523,6 +2590,8 @@ package Rtsfind is\n      RE_Le_G                             => System_Vax_Float_Operations,\n      RE_Lt_F                             => System_Vax_Float_Operations,\n      RE_Lt_G                             => System_Vax_Float_Operations,\n+     RE_Ne_F                             => System_Vax_Float_Operations,\n+     RE_Ne_G                             => System_Vax_Float_Operations,\n \n      RE_Valid_D                          => System_Vax_Float_Operations,\n      RE_Valid_F                          => System_Vax_Float_Operations,"}, {"sha": "c49bed34cbf027f532891bc3079c19b5461456aa", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 109, "deletions": 46, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,7 +28,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Exp_Ch9;\n+with Exp_Ch9;  use Exp_Ch9;\n with Elists;   use Elists;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n@@ -94,11 +94,22 @@ package body Sem_Ch9 is\n       while Present (T_Name) loop\n          Analyze (T_Name);\n \n-         if not Is_Task_Type (Etype (T_Name)) then\n-            Error_Msg_N (\"expect task name for ABORT\", T_Name);\n-            return;\n-         else\n+         if Is_Task_Type (Etype (T_Name))\n+           or else (Ada_Version >= Ada_05\n+                      and then Ekind (Etype (T_Name)) = E_Class_Wide_Type\n+                      and then Is_Interface (Etype (T_Name))\n+                      and then Is_Task_Interface (Etype (T_Name)))\n+         then\n             Resolve (T_Name);\n+         else\n+            if Ada_Version >= Ada_05 then\n+               Error_Msg_N (\"expect task name or task interface class-wide \"\n+                          & \"object for ABORT\", T_Name);\n+            else\n+               Error_Msg_N (\"expect task name for ABORT\", T_Name);\n+            end if;\n+\n+            return;\n          end if;\n \n          Next (T_Name);\n@@ -298,9 +309,7 @@ package body Sem_Ch9 is\n \n          begin\n             E1 := First_Entity (Current_Scope);\n-\n             while Present (E1) loop\n-\n                if Ekind (E1) = E_Procedure\n                  and then Chars (E1) = Chars (Entry_Nam)\n                  and then Type_Conformant (E1, Entry_Nam)\n@@ -368,7 +377,6 @@ package body Sem_Ch9 is\n \n          begin\n             Decl := First (Declarations (N));\n-\n             while Present (Decl) loop\n                Analyze (Decl);\n \n@@ -390,6 +398,7 @@ package body Sem_Ch9 is\n       --  In the case of a select alternative of a selective accept,\n       --  the expander references the address declaration even if there\n       --  is no statement list.\n+\n       --  We also need to create the renaming declarations for the local\n       --  variables that will replace references to the formals within\n       --  the accept.\n@@ -440,14 +449,49 @@ package body Sem_Ch9 is\n    ---------------------------------\n \n    procedure Analyze_Asynchronous_Select (N : Node_Id) is\n+      Param   : Node_Id;\n+      Trigger : Node_Id;\n+\n    begin\n       Tasking_Used := True;\n       Check_Restriction (Max_Asynchronous_Select_Nesting, N);\n       Check_Restriction (No_Select_Statements, N);\n \n-      --  Analyze the statements. We analyze statements in the abortable part\n-      --  first, because this is the section that is executed first, and that\n-      --  way our remembering of saved values and checks is accurate.\n+      if Ada_Version >= Ada_05 then\n+         Trigger := Triggering_Statement (Triggering_Alternative (N));\n+\n+         Analyze (Trigger);\n+\n+         --  The trigger is a dispatching procedure. Postpone the analysis\n+         --  of the triggering and abortable statements until the expansion\n+         --  of this asynchronous select in Expand_N_Asynchronous_Select.\n+         --  This action is required since the code replication in Expand-\n+         --  _N_Asynchronous_Select of an already analyzed statement list\n+         --  causes Gigi aborts.\n+\n+         if Expander_Active\n+           and then Nkind (Trigger) = N_Procedure_Call_Statement\n+           and then Present (Parameter_Associations (Trigger))\n+         then\n+            Param := First (Parameter_Associations (Trigger));\n+\n+            if Is_Controlling_Actual (Param)\n+              and then Is_Interface (Etype (Param))\n+            then\n+               if Is_Limited_Record (Etype (Param)) then\n+                  return;\n+               else\n+                  Error_Msg_N\n+                   (\"dispatching operation of limited or synchronized \" &\n+                    \"interface required ('R'M 9.7.2(3))!\", N);\n+               end if;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Analyze the statements. We analyze statements in the abortable part,\n+      --  because this is the section that is executed first, and that way our\n+      --  remembering of saved values and checks is accurate.\n \n       Analyze_Statements (Statements (Abortable_Part (N)));\n       Analyze (Triggering_Alternative (N));\n@@ -462,6 +506,16 @@ package body Sem_Ch9 is\n       Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n       Analyze (Entry_Call_Alternative (N));\n+\n+      if List_Length (Else_Statements (N)) = 1\n+        and then Nkind (First (Else_Statements (N))) in N_Delay_Statement\n+      then\n+         Error_Msg_N\n+           (\"suspicious form of conditional entry call?\", N);\n+         Error_Msg_N\n+           (\"\\`SELECT OR` may be intended rather than `SELECT ELSE`\", N);\n+      end if;\n+\n       Analyze_Statements (Else_Statements (N));\n    end Analyze_Conditional_Entry_Call;\n \n@@ -491,19 +545,19 @@ package body Sem_Ch9 is\n \n          if Nkind (Delay_Statement (N)) = N_Delay_Relative_Statement then\n             Pre_Analyze_And_Resolve (Expr, Standard_Duration);\n-\n          else\n             Pre_Analyze_And_Resolve (Expr);\n          end if;\n \n-         if Nkind (Delay_Statement (N)) = N_Delay_Until_Statement and then\n-            not Is_RTE (Base_Type (Etype (Expr)), RO_CA_Time)     and then\n-            not Is_RTE (Base_Type (Etype (Expr)), RO_RT_Time)\n+         if Nkind (Delay_Statement (N)) = N_Delay_Until_Statement\n+           and then not Is_RTE (Base_Type (Etype (Expr)), RO_CA_Time)\n+           and then not Is_RTE (Base_Type (Etype (Expr)), RO_RT_Time)\n          then\n             Error_Msg_N (\"expect Time types for `DELAY UNTIL`\", Expr);\n          end if;\n \n          Check_Restriction (No_Fixed_Point, Expr);\n+\n       else\n          Analyze (Delay_Statement (N));\n       end if;\n@@ -632,7 +686,13 @@ package body Sem_Ch9 is\n                      then\n                         Set_Etype (Def, Empty);\n                         Set_Analyzed (Def, False);\n-                        Set_Discrete_Subtype_Definition (Index_Spec, Def);\n+\n+                        --  Keep the original subtree to ensure tree is\n+                        --  properly formed (e.g. for ASIS use)\n+\n+                        Rewrite\n+                          (Discrete_Subtype_Definition (Index_Spec), Def);\n+\n                         Set_Analyzed (Low_Bound (Def), False);\n                         Set_Analyzed (High_Bound (Def), False);\n \n@@ -683,12 +743,16 @@ package body Sem_Ch9 is\n       --  The entity for the protected subprogram corresponding to the entry\n       --  has been created. We retain the name of this entity in the entry\n       --  body, for use when the corresponding subprogram body is created.\n-      --  Note that entry bodies have to corresponding_spec, and there is no\n+      --  Note that entry bodies have no corresponding_spec, and there is no\n       --  easy link back in the tree between the entry body and the entity for\n-      --  the entry itself.\n+      --  the entry itself, which is why we must propagate some attributes\n+      --  explicitly from spec to body.\n \n-      Set_Protected_Body_Subprogram (Id,\n-        Protected_Body_Subprogram (Entry_Name));\n+      Set_Protected_Body_Subprogram\n+        (Id, Protected_Body_Subprogram (Entry_Name));\n+\n+      Set_Entry_Parameters_Type\n+        (Id, Entry_Parameters_Type (Entry_Name));\n \n       if Present (Decls) then\n          Analyze_Declarations (Decls);\n@@ -707,6 +771,9 @@ package body Sem_Ch9 is\n \n       --  At the same time, we set the flags on the spec entities to suppress\n       --  any warnings on the spec formals, since we also scan the spec.\n+      --  Finally, we propagate the Entry_Component attribute to the body\n+      --  formals, for use in the renaming declarations created later for the\n+      --  formals (see exp_ch9.Add_Formal_Renamings).\n \n       declare\n          E1  : Entity_Id;\n@@ -736,6 +803,7 @@ package body Sem_Ch9 is\n \n             Set_Referenced (E2, Referenced (E1));\n             Set_Referenced (E1);\n+            Set_Entry_Component (E2, Entry_Component (E1));\n \n          <<Continue>>\n             Next_Entity (E1);\n@@ -1011,9 +1079,7 @@ package body Sem_Ch9 is\n       end if;\n \n       E := First_Entity (Current_Scope);\n-\n       while Present (E) loop\n-\n          if Ekind (E) = E_Function\n            or else Ekind (E) = E_Procedure\n          then\n@@ -1072,8 +1138,9 @@ package body Sem_Ch9 is\n       --  Ada 2005 (AI-345)\n \n       if Present (Interface_List (N)) then\n-         Iface := First (Interface_List (N));\n+         Set_Is_Tagged_Type (T);\n \n+         Iface := First (Interface_List (N));\n          while Present (Iface) loop\n             Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n             Iface_Def := Type_Definition (Parent (Iface_Typ));\n@@ -1147,7 +1214,6 @@ package body Sem_Ch9 is\n       --  illegal uses. Now it can be set correctly.\n \n       E := First_Entity (Current_Scope);\n-\n       while Present (E) loop\n          if Ekind (E) = E_Void then\n             Set_Ekind (E, E_Component);\n@@ -1254,14 +1320,13 @@ package body Sem_Ch9 is\n       --  Overloaded case, find right interpretation\n \n       if Is_Overloaded (Entry_Name) then\n-         Get_First_Interp (Entry_Name, I, It);\n          Entry_Id := Empty;\n \n+         Get_First_Interp (Entry_Name, I, It);\n          while Present (It.Nam) loop\n             if No (First_Formal (It.Nam))\n               or else Subtype_Conformant (Enclosing, It.Nam)\n             then\n-\n                --  Ada 2005 (AI-345): Since protected and task types have\n                --  primitive entry wrappers, we only consider source entries.\n \n@@ -1348,9 +1413,10 @@ package body Sem_Ch9 is\n             --  Processing for parameters accessed by the requeue\n \n             declare\n-               Ent : Entity_Id := First_Formal (Enclosing);\n+               Ent : Entity_Id;\n \n             begin\n+               Ent := First_Formal (Enclosing);\n                while Present (Ent) loop\n \n                   --  For OUT or IN OUT parameter, the effect of the requeue\n@@ -1399,6 +1465,8 @@ package body Sem_Ch9 is\n       Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n \n+      --  Loop to analyze alternatives\n+\n       Alt := First (Alts);\n       while Present (Alt) loop\n          Alt_Count := Alt_Count + 1;\n@@ -1716,7 +1784,6 @@ package body Sem_Ch9 is\n \n       begin\n          Ent := First_Entity (Spec_Id);\n-\n          while Present (Ent) loop\n             if Is_Entry (Ent)\n               and then not Entry_Accepted (Ent)\n@@ -1799,6 +1866,8 @@ package body Sem_Ch9 is\n       --  Ada 2005 (AI-345)\n \n       if Present (Interface_List (N)) then\n+         Set_Is_Tagged_Type (T);\n+\n          Iface := First (Interface_List (N));\n          while Present (Iface) loop\n             Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n@@ -1919,21 +1988,20 @@ package body Sem_Ch9 is\n       end if;\n \n       Analyze (Trigger);\n+\n       if Comes_From_Source (Trigger)\n-        and then Nkind (Trigger) /= N_Delay_Until_Statement\n-        and then Nkind (Trigger) /= N_Delay_Relative_Statement\n+        and then Nkind (Trigger) not in N_Delay_Statement\n         and then Nkind (Trigger) /= N_Entry_Call_Statement\n       then\n          if Ada_Version < Ada_05 then\n             Error_Msg_N\n              (\"triggering statement must be delay or entry call\", Trigger);\n \n-         --  Ada 2005 (AI-345): If a procedure_call_statement is used\n-         --  for a procedure_or_entry_call, the procedure_name or pro-\n-         --  cedure_prefix of the procedure_call_statement shall denote\n-         --  an entry renamed by a procedure, or (a view of) a primitive\n-         --  subprogram of a limited interface whose first parameter is\n-         --  a controlling parameter.\n+         --  Ada 2005 (AI-345): If a procedure_call_statement is used for a\n+         --  procedure_or_entry_call, the procedure_name or pro- cedure_prefix\n+         --  of the procedure_call_statement shall denote an entry renamed by a\n+         --  procedure, or (a view of) a primitive subprogram of a limited\n+         --  interface whose first parameter is a controlling parameter.\n \n          elsif Nkind (Trigger) = N_Procedure_Call_Statement\n            and then not Is_Renamed_Entry (Entity (Name (Trigger)))\n@@ -2089,7 +2157,6 @@ package body Sem_Ch9 is\n \n          begin\n             Ent := First (Ifaces);\n-\n             while Present (Ent) loop\n                if Etype (Ent) = Iface then\n                   return True;\n@@ -2119,14 +2186,13 @@ package body Sem_Ch9 is\n \n          Entry_Param := First (Entry_Params);\n          Proc_Param  := Next (Proc_Param);\n-         while Present (Entry_Param)\n-           and then Present (Proc_Param)\n-         loop\n+         while Present (Entry_Param) and then Present (Proc_Param) loop\n+\n             --  The two parameters must be mode conformant and have the exact\n             --  same types.\n \n-            if In_Present (Entry_Param) /= In_Present (Proc_Param)\n-              or else Out_Present (Entry_Param) /= Out_Present (Proc_Param)\n+            if Ekind (Defining_Identifier (Entry_Param)) /=\n+               Ekind (Defining_Identifier (Proc_Param))\n               or else Etype (Parameter_Type (Entry_Param)) /=\n                       Etype (Parameter_Type (Proc_Param))\n             then\n@@ -2177,7 +2243,6 @@ package body Sem_Ch9 is\n                               Null_Present (Parent (Hom)))\n                   then\n                      Aliased_Hom := Hom;\n-\n                      while Present (Alias (Aliased_Hom)) loop\n                         Aliased_Hom := Alias (Aliased_Hom);\n                      end loop;\n@@ -2274,7 +2339,6 @@ package body Sem_Ch9 is\n \n       else\n          Decl := First (Vis_Decls);\n-\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Entry_Declaration\n               and then Must_Override (Decl)\n@@ -2322,7 +2386,6 @@ package body Sem_Ch9 is\n \n    begin\n       E := First_Entity (Spec);\n-\n       while Present (E) loop\n          Prev := Current_Entity (E);\n          Set_Current_Entity (E);"}, {"sha": "c1ca4dde7339fe762ae4af0884a6eecf34d51f9f", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=f4d379b8df138d05368dded1c6368ef549d65088", "patch": "@@ -93,6 +93,7 @@ package body Snames is\n      \"_disp_conditional_select#\" &\n      \"_disp_get_prim_op_kind#\" &\n      \"_disp_timed_select#\" &\n+     \"_disp_get_task_id#\" &\n      \"initialize#\" &\n      \"adjust#\" &\n      \"finalize#\" &\n@@ -458,6 +459,7 @@ package body Snames is\n      \"machine_mantissa#\" &\n      \"machine_overflows#\" &\n      \"machine_radix#\" &\n+     \"machine_rounding#\" &\n      \"machine_rounds#\" &\n      \"machine_size#\" &\n      \"mantissa#\" &\n@@ -639,6 +641,7 @@ package body Snames is\n      \"unchecked_conversion#\" &\n      \"unchecked_deallocation#\" &\n      \"to_pointer#\" &\n+     \"free#\" &\n      \"abstract#\" &\n      \"aliased#\" &\n      \"protected#\" &\n@@ -674,6 +677,7 @@ package body Snames is\n      \"include_option#\" &\n      \"language_processing#\" &\n      \"languages#\" &\n+     \"library_ali_dir#\" &\n      \"library_dir#\" &\n      \"library_auto_init#\" &\n      \"library_gcc#\" &"}, {"sha": "caa31e3575066ea76f7e3399e65438148442da56", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 715, "deletions": 703, "changes": 1418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4d379b8df138d05368dded1c6368ef549d65088/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=f4d379b8df138d05368dded1c6368ef549d65088"}]}